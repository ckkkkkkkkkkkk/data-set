package org . apache . camel . component . cxf ; import java . util . Map ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . HeaderFilterStrategyAware ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . spi . HeaderFilterStrategy ; public class CxfComponent extends DefaultComponent < CxfExchange > implements HeaderFilterStrategyAware { private HeaderFilterStrategy headerFilterStrategy = new CxfHeaderFilterStrategy ( ) ; public CxfComponent ( ) { } public CxfComponent ( CamelContext context ) { super ( context ) ; } @ Override protected Endpoint < CxfExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { CxfEndpoint result = new CxfEndpoint ( uri , remaining , this ) ; setProperties ( result , parameters ) ; return result ; } public HeaderFilterStrategy getHeaderFilterStrategy ( ) { return headerFilterStrategy ; } public void setHeaderFilterStrategy ( HeaderFilterStrategy strategy ) { headerFilterStrategy = strategy ; } } 	0	['5', '3', '0', '7', '10', '0', '1', '7', '4', '0.25', '43', '1', '1', '0.921052632', '0.36', '1', '2', '7.4', '1', '0.6', '0']
package org . apache . camel . impl ; import org . apache . camel . Exchange ; import org . apache . camel . processor . interceptor . ExchangeFormatter ; public class DefaultExchangeFormatter implements ExchangeFormatter { protected static final DefaultExchangeFormatter INSTANCE = new DefaultExchangeFormatter ( ) ; public static DefaultExchangeFormatter getInstance ( ) { return INSTANCE ; } public Object format ( Exchange exchange ) { return exchange ; } } 	0	['4', '1', '0', '3', '5', '4', '1', '2', '3', '0.666666667', '17', '1', '1', '0', '0.5', '0', '0', '3', '1', '0.5', '0']
package org . apache . camel . component . jetty ; import java . net . URI ; import java . util . HashMap ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . component . http . CamelServlet ; import org . apache . camel . component . http . HttpComponent ; import org . apache . camel . component . http . HttpConsumer ; import org . apache . camel . component . http . HttpEndpoint ; import org . apache . camel . component . http . HttpExchange ; import org . apache . camel . util . CamelContextHelper ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . camel . util . URISupport ; import org . apache . commons . httpclient . params . HttpClientParams ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . mortbay . jetty . Connector ; import org . mortbay . jetty . Server ; import org . mortbay . jetty . handler . ContextHandlerCollection ; import org . mortbay . jetty . nio . SelectChannelConnector ; import org . mortbay . jetty . security . SslSocketConnector ; import org . mortbay . jetty . servlet . Context ; import org . mortbay . jetty . servlet . HashSessionIdManager ; import org . mortbay . jetty . servlet . HashSessionManager ; import org . mortbay . jetty . servlet . ServletHolder ; import org . mortbay . jetty . servlet . SessionHandler ; public class JettyHttpComponent extends HttpComponent { class ConnectorRef { Connector connector ; CamelServlet servlet ; int refCount ; public ConnectorRef ( Connector connector , CamelServlet servlet ) { this . connector = connector ; this . servlet = servlet ; increment ( ) ; } public int increment ( ) { return ++ refCount ; } public int decrement ( ) { return -- refCount ; } } private static final transient Log LOG = LogFactory . getLog ( JettyHttpComponent . class ) ; protected Server server ; protected HashMap < String , ConnectorRef > connectors = new HashMap < String , ConnectorRef > ( ) ; protected String sslKeyPassword ; protected String sslPassword ; protected String sslKeystore ; protected SslSocketConnector sslSocketConnector ; @ Override protected Endpoint < HttpExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { uri = uri . startsWith ( "jetty:" ) ? remaining : uri ; HttpClientParams params = new HttpClientParams ( ) ; IntrospectionSupport . setProperties ( params , parameters , "httpClient." ) ; configureParameters ( parameters ) ; URI httpUri = URISupport . createRemainingURI ( new URI ( uri ) , parameters ) ; uri = httpUri . toString ( ) ; JettyHttpEndpoint result = new JettyHttpEndpoint ( this , uri , httpUri , params , getHttpConnectionManager ( ) , httpClientConfigurer ) ; if ( httpBinding != null ) { result . setBinding ( httpBinding ) ; } setProperties ( result , parameters ) ; return result ; } @ Override public void connect ( HttpConsumer consumer ) throws Exception { JettyHttpEndpoint endpoint = ( JettyHttpEndpoint ) consumer . getEndpoint ( ) ; String connectorKey = getConnectorKey ( endpoint ) ; synchronized ( connectors ) { ConnectorRef connectorRef = connectors . get ( connectorKey ) ; if ( connectorRef == null ) { Connector connector ; if ( "https" . equals ( endpoint . getProtocol ( ) ) ) { connector = getSslSocketConnector ( ) ; } else { connector = new SelectChannelConnector ( ) ; } connector . setPort ( endpoint . getPort ( ) ) ; connector . setHost ( endpoint . getHttpUri ( ) . getHost ( ) ) ; if ( "localhost" . equalsIgnoreCase ( endpoint . getHttpUri ( ) . getHost ( ) ) ) { LOG . warn ( "You use localhost interface! It means that no external connections will be available. Don't you want to use 0.0.0.0 instead (all network interfaces)?" ) ; } getServer ( ) . addConnector ( connector ) ; connectorRef = new ConnectorRef ( connector , createServletForConnector ( connector ) ) ; connector . start ( ) ; connectors . put ( connectorKey , connectorRef ) ; } else { connectorRef . increment ( ) ; } if ( endpoint . isSessionSupport ( ) ) { enableSessionSupport ( ) ; } connectorRef . servlet . connect ( consumer ) ; } } private void enableSessionSupport ( ) throws Exception { Context context = ( Context ) getServer ( ) . getChildHandlerByClass ( Context . class ) ; if ( context . getSessionHandler ( ) == null ) { SessionHandler sessionHandler = new SessionHandler ( ) ; context . setSessionHandler ( sessionHandler ) ; if ( context . isStarted ( ) ) { context . stop ( ) ; context . start ( ) ; } } } @ Override public void disconnect ( HttpConsumer consumer ) throws Exception { HttpEndpoint endpoint = consumer . getEndpoint ( ) ; String connectorKey = getConnectorKey ( endpoint ) ; synchronized ( connectors ) { ConnectorRef connectorRef = connectors . get ( connectorKey ) ; if ( connectorRef != null ) { connectorRef . servlet . disconnect ( consumer ) ; if ( connectorRef . decrement ( ) == 0 ) { getServer ( ) . removeConnector ( connectorRef . connector ) ; connectorRef . connector . stop ( ) ; connectors . remove ( connectorKey ) ; } } } } private String getConnectorKey ( HttpEndpoint endpoint ) { return endpoint . getProtocol ( ) + ":" + endpoint . getHttpUri ( ) . getHost ( ) + ":" + endpoint . getPort ( ) ; } public Server getServer ( ) throws Exception { if ( server == null ) { server = createServer ( ) ; } return server ; } public void setServer ( Server server ) { this . server = server ; } public String getSslKeyPassword ( ) { return sslKeyPassword ; } public void setSslKeyPassword ( String sslKeyPassword ) { this . sslKeyPassword = sslKeyPassword ; } public String getSslPassword ( ) { return sslPassword ; } public void setSslPassword ( String sslPassword ) { this . sslPassword = sslPassword ; } public void setKeystore ( String sslKeystore ) { this . sslKeystore = sslKeystore ; } public String getKeystore ( ) { return sslKeystore ; } public synchronized SslSocketConnector getSslSocketConnector ( ) { if ( sslSocketConnector == null ) { sslSocketConnector = new SslSocketConnector ( ) ; sslSocketConnector . setPassword ( sslPassword ) ; sslSocketConnector . setKeyPassword ( sslKeyPassword ) ; if ( sslKeystore != null ) { sslSocketConnector . setKeystore ( sslKeystore ) ; } } return sslSocketConnector ; } public void setSslSocketConnector ( SslSocketConnector connector ) { sslSocketConnector = connector ; } protected CamelServlet createServletForConnector ( Connector connector ) throws Exception { CamelServlet camelServlet = new CamelContinuationServlet ( ) ; Context context = new Context ( server , "/" , Context . NO_SECURITY | Context . NO_SESSIONS ) ; context . setConnectorNames ( new String [ ] { connector . getName ( ) } ) ; ServletHolder holder = new ServletHolder ( ) ; holder . setServlet ( camelServlet ) ; context . addServlet ( holder , "/*" ) ; connector . start ( ) ; context . start ( ) ; return camelServlet ; } protected Server createServer ( ) throws Exception { Server server = new Server ( ) ; ContextHandlerCollection collection = new ContextHandlerCollection ( ) ; collection . setServer ( server ) ; server . addHandler ( collection ) ; server . start ( ) ; return server ; } @ Override protected void doStop ( ) throws Exception { for ( ConnectorRef connectorRef : connectors . values ( ) ) { connectorRef . connector . stop ( ) ; } connectors . clear ( ) ; if ( server != null ) { server . stop ( ) ; } super . doStop ( ) ; } } 	0	['20', '4', '0', '26', '95', '144', '2', '26', '13', '0.842105263', '433', '1', '0', '0.727272727', '0.197368421', '4', '5', '20.3', '3', '1', '0']
package org . apache . camel . component . file ; import java . io . File ; public interface FileProcessStrategy { boolean begin ( FileEndpoint endpoint , FileExchange exchange , File file ) throws Exception ; void commit ( FileEndpoint endpoint , FileExchange exchange , File file ) throws Exception ; void rollback ( FileEndpoint endpoint , FileExchange exchange , File file ) ; } 	0	['3', '1', '0', '6', '3', '3', '5', '2', '3', '2', '3', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . restlet ; public final class RestletConstants { public static final String LOGIN = "org.apache.camel.restlet.auth.login" ; public static final String PASSWORD = "org.apache.camel.restlet.auth.password" ; public static final String MEDIA_TYPE = "org.apache.camel.restlet.mediaType" ; public static final String RESPONSE_CODE = "org.apache.camel.restlet.responseCode" ; public static final String QUERY_STRING = "org.apache.camel.restlet.queryString" ; private RestletConstants ( ) { } } 	0	['1', '1', '0', '0', '2', '0', '0', '0', '0', '2', '9', '0', '0', '0', '1', '0', '0', '3', '0', '0', '0']
package org . apache . camel ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . CONSTRUCTOR } ) public @ interface RecipientList { } 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . language . groovy ; import groovy . lang . Closure ; import org . apache . camel . Exchange ; import org . apache . camel . impl . ExpressionSupport ; import org . apache . camel . model . ChoiceType ; import org . apache . camel . model . FilterType ; import org . apache . camel . model . ProcessorType ; public final class CamelGroovyMethods { private CamelGroovyMethods ( ) { } public static FilterType filter ( ProcessorType self , Closure filter ) { return self . filter ( toExpression ( filter ) ) ; } public static ChoiceType when ( ChoiceType self , Closure filter ) { return self . when ( toExpression ( filter ) ) ; } public static ExpressionSupport toExpression ( final Closure filter ) { return new ExpressionSupport < Exchange > ( ) { protected String assertionFailureMessage ( Exchange exchange ) { return filter . toString ( ) ; } public Object evaluate ( Exchange exchange ) { return filter . call ( exchange ) ; } @ Override public String toString ( ) { return "Groovy[" + filter + "]" ; } } ; } } 	0	['4', '1', '0', '7', '8', '6', '0', '7', '3', '2', '22', '0', '0', '0', '0.375', '0', '0', '4.5', '1', '0.75', '0']
package org . apache . camel . component . file . remote ; import java . net . URI ; import java . util . Map ; import org . apache . camel . CamelContext ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . impl . DefaultComponent ; import org . apache . commons . net . ftp . FTPClientConfig ; public class RemoteFileComponent extends DefaultComponent < RemoteFileExchange > { private RemoteFileConfiguration configuration ; public RemoteFileComponent ( ) { this . configuration = new RemoteFileConfiguration ( ) ; } public RemoteFileComponent ( RemoteFileConfiguration configuration ) { this . configuration = configuration ; } public RemoteFileComponent ( CamelContext context ) { super ( context ) ; this . configuration = new RemoteFileConfiguration ( ) ; } public String toString ( ) { return "RemoteFileComponent" ; } public static RemoteFileComponent remoteFileComponent ( ) { return new RemoteFileComponent ( ) ; } protected RemoteFileEndpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { RemoteFileConfiguration config = getConfiguration ( ) . copy ( ) ; String baseUri = uri ; if ( uri . indexOf ( "?" ) != - 1 ) { baseUri = uri . substring ( 0 , uri . indexOf ( "?" ) ) ; } config . configure ( new URI ( baseUri ) ) ; final RemoteFileEndpoint endpoint ; if ( "ftp" . equals ( config . getProtocol ( ) ) ) { endpoint = new FtpEndpoint ( uri , this , config ) ; } else if ( "sftp" . equals ( config . getProtocol ( ) ) ) { endpoint = new SftpEndpoint ( uri , this , config ) ; } else { throw new RuntimeCamelException ( "Unsupported protocol: " + config . getProtocol ( ) ) ; } configureFTPClientConfig ( parameters , endpoint ) ; setProperties ( endpoint . getConfiguration ( ) , parameters ) ; return endpoint ; } private void configureFTPClientConfig ( Map parameters , RemoteFileEndpoint endpoint ) { String ref = getAndRemoveParameter ( parameters , "ftpClientConfig" , String . class ) ; if ( ref != null ) { FTPClientConfig ftpClientConfig = this . getCamelContext ( ) . getRegistry ( ) . lookup ( ref , FTPClientConfig . class ) ; if ( ftpClientConfig == null ) { throw new IllegalArgumentException ( "FTPClientConfig " + ref + " not found in registry." ) ; } endpoint . getConfiguration ( ) . setFtpClientConfig ( ftpClientConfig ) ; } } public RemoteFileConfiguration getConfiguration ( ) { return configuration ; } public void setConfiguration ( RemoteFileConfiguration configuration ) { this . configuration = configuration ; } } 	0	['10', '3', '0', '10', '33', '25', '3', '10', '7', '0.222222222', '165', '1', '1', '0.833333333', '0.3', '2', '3', '15.4', '3', '0.9', '0']
package org . apache . camel . component . jmx ; import javax . management . MBeanServer ; import javax . management . Notification ; import javax . management . ObjectName ; import javax . management . monitor . CounterMonitor ; import org . apache . camel . Consumer ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class JMXEndpoint extends DefaultEndpoint < JMXExchange > { private static final transient Log LOG = LogFactory . getLog ( JMXEndpoint . class ) ; private String name ; private ObjectName ourName ; private String observedObjectName ; private String attributeName ; private long granularityPeriod = 5000 ; private Number threshold ; private Number offset ; private MBeanServer mbeanServer ; private CounterMonitor counterMonitor = new CounterMonitor ( ) ; protected JMXEndpoint ( String endpointUri , JMXComponent component ) { super ( endpointUri , component ) ; observedObjectName = endpointUri ; } public JMXEndpoint ( String endpointUri ) { super ( endpointUri ) ; } public Producer < JMXExchange > createProducer ( ) throws Exception { throw new UnsupportedOperationException ( "Producer not supported" ) ; } public Consumer < JMXExchange > createConsumer ( Processor proc ) throws Exception { ObjectName observedName = new ObjectName ( observedObjectName ) ; if ( name == null ) { String type = observedName . getKeyProperty ( "type" ) ; type = type != null ? type : "UNKNOWN" ; name = mbeanServer . getDefaultDomain ( ) + ":type=CounterMonitor_" + type ; } JMXConsumer result = new JMXConsumer ( this , proc ) ; ourName = new ObjectName ( name ) ; counterMonitor . setNotify ( true ) ; counterMonitor . addObservedObject ( observedName ) ; counterMonitor . setObservedAttribute ( attributeName ) ; counterMonitor . setGranularityPeriod ( granularityPeriod ) ; counterMonitor . setDifferenceMode ( false ) ; counterMonitor . setInitThreshold ( threshold ) ; counterMonitor . setOffset ( offset ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Registering and adding notification listener for [" + counterMonitor + "] with name [" + ourName + "]" ) ; } mbeanServer . registerMBean ( counterMonitor , ourName ) ; mbeanServer . addNotificationListener ( ourName , result , null , new Object ( ) ) ; return result ; } public boolean isSingleton ( ) { return true ; } public JMXExchange createExchange ( Notification notification ) { return new JMXExchange ( getCamelContext ( ) , getExchangePattern ( ) , notification ) ; } public JMXExchange createExchange ( ) { return new JMXExchange ( getCamelContext ( ) , getExchangePattern ( ) , null ) ; } public JMXExchange createExchange ( ExchangePattern pattern ) { return new JMXExchange ( getCamelContext ( ) , pattern , null ) ; } public String getAttributeName ( ) { return attributeName ; } public void setAttributeName ( String attributeName ) { this . attributeName = attributeName ; } public long getGranularityPeriod ( ) { return granularityPeriod ; } public void setGranularityPeriod ( long granularityPeriod ) { this . granularityPeriod = granularityPeriod ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public Number getOffset ( ) { return offset ; } public void setOffset ( Number offset ) { this . offset = offset ; } public Number getThreshold ( ) { return threshold ; } public void setThreshold ( Number threshold ) { this . threshold = threshold ; } public MBeanServer getMbeanServer ( ) { return mbeanServer ; } public void setMbeanServer ( MBeanServer mbeanServer ) { this . mbeanServer = mbeanServer ; } } 	0	['23', '2', '0', '13', '49', '201', '2', '13', '21', '0.918181818', '266', '1', '0', '0.545454545', '0.176767677', '1', '1', '10.13043478', '1', '0.8696', '0']
package org . apache . camel . component . file . remote ; import com . jcraft . jsch . ChannelSftp ; import com . jcraft . jsch . JSch ; import com . jcraft . jsch . JSchException ; import com . jcraft . jsch . Session ; import com . jcraft . jsch . UserInfo ; import org . apache . camel . Processor ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import static org . apache . camel . util . ObjectHelper . isNotNullAndNonEmpty ; public class SftpEndpoint extends RemoteFileEndpoint < RemoteFileExchange > { protected final transient Log log = LogFactory . getLog ( getClass ( ) ) ; public SftpEndpoint ( String uri , RemoteFileComponent remoteFileComponent , RemoteFileConfiguration configuration ) { super ( uri , remoteFileComponent , configuration ) ; } public SftpEndpoint ( String endpointUri ) { super ( endpointUri ) ; } public SftpProducer createProducer ( ) throws Exception { return new SftpProducer ( this , createSession ( ) ) ; } public SftpConsumer createConsumer ( Processor processor ) throws Exception { final SftpConsumer consumer = new SftpConsumer ( this , processor , createSession ( ) ) ; configureConsumer ( consumer ) ; return consumer ; } protected Session createSession ( ) throws JSchException { final JSch jsch = new JSch ( ) ; String privateKeyFile = getConfiguration ( ) . getPrivateKeyFile ( ) ; if ( isNotNullAndNonEmpty ( privateKeyFile ) ) { log . debug ( "Using private keyfile: " + privateKeyFile ) ; String privateKeyFilePassphrase = getConfiguration ( ) . getPrivateKeyFilePassphrase ( ) ; if ( isNotNullAndNonEmpty ( privateKeyFilePassphrase ) ) { jsch . addIdentity ( privateKeyFile , privateKeyFilePassphrase ) ; } else { jsch . addIdentity ( privateKeyFile ) ; } } String knownHostsFile = getConfiguration ( ) . getKnownHosts ( ) ; if ( isNotNullAndNonEmpty ( knownHostsFile ) ) { log . debug ( "Using knownHosts: " + knownHostsFile ) ; jsch . setKnownHosts ( knownHostsFile ) ; } final Session session = jsch . getSession ( getConfiguration ( ) . getUsername ( ) , getConfiguration ( ) . getHost ( ) , getConfiguration ( ) . getPort ( ) ) ; session . setUserInfo ( new UserInfo ( ) { public String getPassphrase ( ) { return null ; } public String getPassword ( ) { return getConfiguration ( ) . getPassword ( ) ; } public boolean promptPassword ( String string ) { return true ; } public boolean promptPassphrase ( String string ) { return true ; } public boolean promptYesNo ( String string ) { log . error ( string ) ; return false ; } public void showMessage ( String string ) { } } ) ; return session ; } public ChannelSftp createChannelSftp ( Session session ) throws JSchException { final ChannelSftp channel = ( ChannelSftp ) session . openChannel ( "sftp" ) ; return channel ; } } 	0	['8', '4', '0', '18', '33', '22', '4', '18', '7', '0.142857143', '141', '1', '0', '0.872340426', '0.3125', '0', '0', '16.5', '1', '0.75', '0']
package org . apache . camel . component . bean ; import java . lang . annotation . Annotation ; import java . lang . reflect . Method ; import org . apache . camel . CamelContext ; import org . apache . camel . Expression ; import org . apache . camel . language . LanguageAnnotation ; import org . apache . camel . spi . Language ; import org . apache . camel . util . ObjectHelper ; public class DefaultAnnotationExpressionFactory implements AnnotationExpressionFactory { public Expression createExpression ( CamelContext camelContext , Annotation annotation , LanguageAnnotation languageAnnotation , Class expressionReturnType ) { String languageName = languageAnnotation . language ( ) ; if ( languageName == null ) { throw new IllegalArgumentException ( "Cannot determine the language from the annotation: " + annotation ) ; } Language language = camelContext . resolveLanguage ( languageName ) ; if ( language == null ) { throw new IllegalArgumentException ( "Cannot find the language: " + languageName + " on the classpath" ) ; } String expression = getExpressionFromAnnotation ( annotation ) ; return language . createExpression ( expression ) ; } protected String getExpressionFromAnnotation ( Annotation annotation ) { try { Method method = annotation . getClass ( ) . getMethod ( "value" ) ; Object value = ObjectHelper . invokeMethod ( method , annotation ) ; if ( value == null ) { throw new IllegalArgumentException ( "Cannot determine the expression from the annotation: " + annotation ) ; } return value . toString ( ) ; } catch ( NoSuchMethodException e ) { throw new IllegalArgumentException ( "Cannot determine the expression of the annotation: " + annotation + " as it does not have an value() method" ) ; } } } 	0	['3', '1', '2', '8', '16', '3', '2', '6', '2', '2', '96', '0', '0', '0', '0.533333333', '0', '0', '31', '3', '1.6667', '0']
package org . apache . camel . view ; import java . io . PrintWriter ; import java . util . List ; import java . util . Map ; import java . util . Set ; import org . apache . camel . model . FromType ; import org . apache . camel . model . MulticastType ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . model . RouteType ; import static org . apache . camel . util . ObjectHelper . isNullOrBlank ; public class XmlGraphGenerator extends GraphGeneratorSupport { private boolean addUrl = true ; public XmlGraphGenerator ( String dir ) { super ( dir , ".xml" ) ; } protected void generateFile ( PrintWriter writer , Map < String , List < RouteType > > map ) { writer . println ( "<?xml version='1.0' encoding='UTF-8'?>" ) ; writer . println ( "<Graph>" ) ; writer . println ( ) ; if ( map . size ( ) > 0 ) { writer . println ( "<Node id='root' name='Camel Routes' description='Collection of Camel Routes' nodeType='root'/>" ) ; } printRoutes ( writer , map ) ; writer . println ( ) ; writer . println ( "</Graph>" ) ; } protected void printRoutes ( PrintWriter writer , Map < String , List < RouteType > > map ) { Set < Map . Entry < String , List < RouteType > > > entries = map . entrySet ( ) ; for ( Map . Entry < String , List < RouteType > > entry : entries ) { String group = entry . getKey ( ) ; printRoutes ( writer , group , entry . getValue ( ) ) ; } } protected void printRoutes ( PrintWriter writer , String group , List < RouteType > routes ) { group = encode ( group ) ; if ( group != null ) { int idx = group . lastIndexOf ( '.' ) ; String name = group ; if ( idx > 0 && idx < group . length ( ) - 1 ) { name = group . substring ( idx + 1 ) ; } writer . println ( "<Node id='" + group + "' name='" + name + "' description='" + group + "' nodeType='group'/>" ) ; writer . println ( "<Edge fromID='root' toID='" + group + "'/>" ) ; } for ( RouteType route : routes ) { List < FromType > inputs = route . getInputs ( ) ; boolean first = true ; for ( FromType input : inputs ) { NodeData nodeData = getNodeData ( input ) ; if ( first ) { first = false ; if ( group != null ) { writer . println ( "<Edge fromID='" + group + "' toID='" + encode ( nodeData . id ) + "'/>" ) ; } } printRoute ( writer , route , nodeData ) ; } writer . println ( ) ; } } protected void printRoute ( PrintWriter writer , final RouteType route , NodeData nodeData ) { printNode ( writer , nodeData ) ; NodeData from = nodeData ; for ( ProcessorType output : route . getOutputs ( ) ) { NodeData newData = printNode ( writer , from , output ) ; from = newData ; } } protected NodeData printNode ( PrintWriter writer , NodeData fromData , ProcessorType node ) { if ( node instanceof MulticastType ) { List < ProcessorType > outputs = node . getOutputs ( ) ; for ( ProcessorType output : outputs ) { printNode ( writer , fromData , output ) ; } return fromData ; } NodeData toData = getNodeData ( node ) ; printNode ( writer , toData ) ; if ( fromData != null ) { writer . print ( "<Edge fromID=\"" ) ; writer . print ( encode ( fromData . id ) ) ; writer . print ( "\" toID=\"" ) ; writer . print ( encode ( toData . id ) ) ; String association = toData . edgeLabel ; if ( isNullOrBlank ( association ) ) { writer . print ( "\" association=\"" ) ; writer . print ( encode ( association ) ) ; } writer . println ( "\"/>" ) ; } List < ProcessorType > outputs = toData . outputs ; if ( outputs != null ) { for ( ProcessorType output : outputs ) { NodeData newData = printNode ( writer , toData , output ) ; if ( ! isMulticastNode ( node ) ) { toData = newData ; } } } return toData ; } protected void printNode ( PrintWriter writer , NodeData data ) { if ( ! data . nodeWritten ) { data . nodeWritten = true ; writer . println ( ) ; writer . print ( "<Node id=\"" ) ; writer . print ( encode ( data . id ) ) ; writer . print ( "\" name=\"" ) ; String name = data . label ; if ( isNullOrBlank ( name ) ) { name = data . tooltop ; } writer . print ( encode ( name ) ) ; writer . print ( "\" nodeType=\"" ) ; String nodeType = data . image ; if ( isNullOrBlank ( nodeType ) ) { nodeType = data . shape ; if ( isNullOrBlank ( nodeType ) ) { nodeType = "node" ; } } writer . print ( encode ( nodeType ) ) ; writer . print ( "\" description=\"" ) ; writer . print ( encode ( data . tooltop ) ) ; if ( addUrl ) { writer . print ( "\" url=\"" ) ; writer . print ( encode ( data . url ) ) ; } writer . println ( "\"/>" ) ; } } protected String encode ( String text ) { if ( text == null ) { return "" ; } return text . replaceAll ( "\"" , "&quot;" ) . replaceAll ( "<" , "&lt;" ) . replaceAll ( ">" , "&gt;" ) . replaceAll ( "&" , "&amp;" ) ; } } 	0	['8', '2', '0', '7', '33', '26', '0', '7', '1', '0.571428571', '415', '1', '0', '0.588235294', '0.390625', '1', '1', '50.75', '8', '3.625', '0']
package org . apache . camel . impl . converter ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . TypeConverter ; import org . apache . camel . processor . DelegateProcessor ; public class AsyncProcessorTypeConverter implements TypeConverter { private static final class ProcessorToAsyncProcessorBridge extends DelegateProcessor implements AsyncProcessor { private ProcessorToAsyncProcessorBridge ( Processor processor ) { super ( processor ) ; } public boolean process ( Exchange exchange , AsyncCallback callback ) { try { processor . process ( exchange ) ; } catch ( Throwable e ) { exchange . setException ( e ) ; } callback . done ( true ) ; return true ; } } public < T > T convertTo ( Class < T > toType , Object value ) { if ( value != null ) { if ( toType . equals ( AsyncProcessor . class ) ) { if ( value instanceof AsyncProcessor ) { return toType . cast ( value ) ; } else if ( value instanceof Processor ) { final Processor processor = ( Processor ) value ; return toType . cast ( new ProcessorToAsyncProcessorBridge ( processor ) ) ; } } } return null ; } public < T > T convertTo ( Class < T > toType , Exchange exchange , Object value ) { return convertTo ( toType , value ) ; } public static AsyncProcessor convert ( Processor value ) { if ( value instanceof AsyncProcessor ) { return ( AsyncProcessor ) value ; } return new ProcessorToAsyncProcessorBridge ( value ) ; } } 	0	['4', '1', '0', '17', '8', '6', '11', '6', '4', '2', '53', '0', '0', '0', '0.45', '0', '0', '12.25', '5', '2', '0']
package org . apache . camel . component . irc ; public class IrcBinding { public Object extractBodyFromIrc ( IrcExchange exchange , IrcMessage message ) { String type = message . getMessageType ( ) ; String text = message . getMessage ( ) ; if ( text != null ) { return text ; } else { return type ; } } } 	0	['2', '1', '0', '3', '5', '1', '3', '2', '2', '2', '17', '0', '0', '0', '0.666666667', '0', '0', '7.5', '2', '1', '0']
package org . apache . camel . bam . processor ; import org . apache . camel . Exchange ; import org . apache . camel . bam . model . ActivityState ; import org . apache . camel . bam . model . ProcessInstance ; import org . apache . camel . bam . rules . ActivityRules ; import org . apache . camel . bam . rules . ProcessRules ; public class ProcessContext { private Exchange exchange ; private ProcessRules processRules ; private ActivityRules activityRules ; private ProcessInstance processInstance ; private ActivityState activityState ; public ProcessContext ( Exchange exchange , ActivityRules activityRules , ActivityState activityState ) { this . exchange = exchange ; this . activityRules = activityRules ; this . activityState = activityState ; this . processRules = activityRules . getProcessRules ( ) ; this . processInstance = activityState . getProcessInstance ( ) ; } public ActivityRules getActivity ( ) { return activityRules ; } public void setActivity ( ActivityRules activityRules ) { this . activityRules = activityRules ; } public ActivityState getActivityState ( ) { return activityState ; } public void setActivityState ( ActivityState activityState ) { this . activityState = activityState ; } public Exchange getExchange ( ) { return exchange ; } public void setExchange ( Exchange exchange ) { this . exchange = exchange ; } public ProcessRules getProcessDefinition ( ) { return processRules ; } public void setProcessDefinition ( ProcessRules processRules ) { this . processRules = processRules ; } public ProcessInstance getProcessInstance ( ) { return processInstance ; } public void setProcessInstance ( ProcessInstance processInstance ) { this . processInstance = processInstance ; } public ActivityState getActivityState ( ActivityRules activityRules ) { return getProcessInstance ( ) . getActivityState ( activityRules ) ; } public void onStarted ( ActivityState activityState ) { } public void onCompleted ( ActivityState activityState ) { } } 	0	['14', '1', '0', '6', '18', '61', '2', '5', '14', '0.830769231', '81', '1', '5', '0', '0.297619048', '0', '0', '4.428571429', '1', '0.9286', '0']
package org . apache . camel . processor . resequencer ; import java . util . Timer ; public class ResequencerEngine < E > { private Element < E > lastDelivered ; private long timeout ; private Sequence < Element < E > > sequence ; private Timer timer ; private SequenceSender < E > sequenceSender ; public ResequencerEngine ( SequenceElementComparator < E > comparator ) { this . sequence = createSequence ( comparator ) ; this . timeout = 2000L ; this . lastDelivered = null ; } public void start ( ) { timer = new Timer ( "Stream Resequencer Timer" ) ; } public void stop ( ) { timer . cancel ( ) ; } public synchronized int size ( ) { return sequence . size ( ) ; } public long getTimeout ( ) { return timeout ; } public void setTimeout ( long timeout ) { this . timeout = timeout ; } public SequenceSender < E > getSequenceSender ( ) { return sequenceSender ; } public void setSequenceSender ( SequenceSender < E > sequenceSender ) { this . sequenceSender = sequenceSender ; } E getLastDelivered ( ) { if ( lastDelivered == null ) { return null ; } return lastDelivered . getObject ( ) ; } void setLastDelivered ( E o ) { lastDelivered = new Element < E > ( o ) ; } public synchronized void insert ( E o ) { Element < E > element = new Element < E > ( o ) ; sequence . add ( element ) ; Element < E > successor = sequence . successor ( element ) ; if ( successor != null ) { successor . cancel ( ) ; } if ( successorOfLastDelivered ( element ) ) { } else if ( sequence . predecessor ( element ) != null ) { } else { element . schedule ( defineTimeout ( ) ) ; } } public synchronized void deliver ( ) throws Exception { while ( deliverNext ( ) ) { } } public boolean deliverNext ( ) throws Exception { if ( sequence . size ( ) == 0 ) { return false ; } Element < E > element = sequence . first ( ) ; if ( element . scheduled ( ) ) { return false ; } sequence . remove ( element ) ; lastDelivered = element ; sequenceSender . sendElement ( element . getObject ( ) ) ; return true ; } private boolean successorOfLastDelivered ( Element < E > element ) { if ( lastDelivered == null ) { return false ; } if ( sequence . comparator ( ) . successor ( element , lastDelivered ) ) { return true ; } return false ; } private Timeout defineTimeout ( ) { return new Timeout ( timer , timeout ) ; } private static < E > Sequence < Element < E > > createSequence ( SequenceElementComparator < E > comparator ) { return new Sequence < Element < E > > ( new ElementComparator < E > ( comparator ) ) ; } } 	0	['16', '1', '0', '8', '36', '62', '2', '6', '11', '0.72', '184', '1', '3', '0', '0.229166667', '0', '0', '10.1875', '4', '1.3125', '0']
package org . apache . camel ; public class RuntimeCamelException extends RuntimeException { private static final long serialVersionUID = 8046489554418284257L ; public RuntimeCamelException ( ) { } public RuntimeCamelException ( String message ) { super ( message ) ; } public RuntimeCamelException ( String message , Throwable cause ) { super ( message , cause ) ; } public RuntimeCamelException ( Throwable cause ) { super ( cause ) ; } } 	0	['4', '4', '17', '66', '8', '6', '66', '0', '4', '1.333333333', '21', '1', '0', '1', '0.666666667', '0', '0', '4', '0', '0', '0']
package org . apache . camel . processor . resequencer ; class Element < E > implements TimeoutHandler { private E object ; private Timeout timeout ; public Element ( E object ) { this . object = object ; } public E getObject ( ) { return object ; } public synchronized boolean scheduled ( ) { return timeout != null ; } public synchronized void schedule ( Timeout t ) { this . timeout = t ; this . timeout . setTimeoutHandler ( this ) ; this . timeout . schedule ( ) ; } public synchronized void cancel ( ) { if ( timeout != null ) { timeout . cancel ( ) ; } timeout ( null ) ; } public synchronized void timeout ( Timeout t ) { this . timeout = null ; } } 	0	['6', '1', '0', '4', '10', '1', '2', '2', '6', '0.6', '50', '1', '1', '0', '0.5', '0', '0', '7', '2', '1.1667', '0']
package org . apache . camel . impl . converter ; import java . lang . reflect . Array ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . TypeConverter ; public class ArrayTypeConverter implements TypeConverter { public < T > T convertTo ( Class < T > type , Object value ) { if ( type . isArray ( ) ) { if ( value instanceof Collection ) { Collection collection = ( Collection ) value ; Object array = Array . newInstance ( type . getComponentType ( ) , collection . size ( ) ) ; if ( array instanceof Object [ ] ) { collection . toArray ( ( Object [ ] ) array ) ; } else { int index = 0 ; for ( Object element : collection ) { Array . set ( array , index ++ , element ) ; } } return ( T ) array ; } else if ( value != null && value . getClass ( ) . isArray ( ) ) { int size = Array . getLength ( value ) ; Object answer = Array . newInstance ( type . getComponentType ( ) , size ) ; for ( int i = 0 ; i < size ; i ++ ) { Array . set ( answer , i , Array . get ( value , i ) ) ; } return ( T ) answer ; } } else if ( Collection . class . isAssignableFrom ( type ) ) { if ( value != null ) { if ( value instanceof Object [ ] ) { return ( T ) Arrays . asList ( ( Object [ ] ) value ) ; } else if ( value . getClass ( ) . isArray ( ) ) { int size = Array . getLength ( value ) ; List answer = new ArrayList ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { answer . add ( Array . get ( value , i ) ) ; } return ( T ) answer ; } } } return null ; } public < T > T convertTo ( Class < T > type , Exchange exchange , Object value ) { return convertTo ( type , value ) ; } } 	0	['3', '1', '0', '3', '20', '3', '1', '2', '3', '2', '127', '0', '0', '0', '0.666666667', '0', '0', '41.33333333', '13', '4.6667', '0']
package org . apache . camel . component . xquery ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import org . apache . camel . language . LanguageAnnotation ; import org . apache . camel . language . NamespacePrefix ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . PARAMETER } ) @ LanguageAnnotation ( language = "xquery" , factory = XQueryAnnotationExpressionFactory . class ) public @ interface XQuery { String value ( ) ; NamespacePrefix [ ] namespaces ( ) default { @ NamespacePrefix ( prefix = "soap" , uri = "http://www.w3.org/2003/05/soap-envelope" ) , @ NamespacePrefix ( prefix = "xsd" , uri = "http://www.w3.org/2001/XMLSchema" ) } ; } 	0	['2', '1', '0', '2', '2', '1', '1', '1', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . mina ; import org . apache . camel . Exchange ; public final class MinaPayloadHelper { private MinaPayloadHelper ( ) { } public static Object getIn ( MinaEndpoint endpoint , Exchange exchange ) { if ( endpoint . isTransferExchange ( ) ) { return MinaPayloadHolder . marshal ( exchange ) ; } else { return exchange . getIn ( ) . getBody ( ) ; } } public static Object getOut ( MinaEndpoint endpoint , Exchange exchange ) { if ( endpoint . isTransferExchange ( ) ) { return MinaPayloadHolder . marshal ( exchange ) ; } else { return exchange . getOut ( ) . getBody ( ) ; } } public static void setIn ( Exchange exchange , Object payload ) { if ( payload instanceof MinaPayloadHolder ) { MinaPayloadHolder . unmarshal ( exchange , ( MinaPayloadHolder ) payload ) ; } else { exchange . getIn ( ) . setBody ( payload ) ; } } public static void setOut ( Exchange exchange , Object payload ) { if ( payload instanceof MinaPayloadHolder ) { MinaPayloadHolder . unmarshal ( exchange , ( MinaPayloadHolder ) payload ) ; } else { exchange . getOut ( ) . setHeaders ( exchange . getIn ( ) . getHeaders ( ) ) ; exchange . getOut ( ) . setBody ( payload ) ; } } } 	0	['5', '1', '0', '6', '15', '10', '3', '4', '4', '2', '60', '0', '0', '0', '0.45', '0', '0', '11', '2', '1.6', '0']
package org . apache . camel . component . cxf ; import java . io . OutputStream ; import javax . xml . transform . Source ; import org . apache . camel . Consumer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . component . cxf . util . CxfEndpointUtils ; import org . apache . camel . component . cxf . util . NullConduit ; import org . apache . camel . component . cxf . util . NullDestinationFactory ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . cxf . Bus ; import org . apache . cxf . common . classloader . ClassLoaderUtils ; import org . apache . cxf . endpoint . Server ; import org . apache . cxf . frontend . ServerFactoryBean ; import org . apache . cxf . interceptor . InterceptorChain ; import org . apache . cxf . interceptor . OutgoingChainInterceptor ; import org . apache . cxf . io . CachedOutputStream ; import org . apache . cxf . transport . MessageObserver ; public class CxfSoapConsumer implements Consumer { private static final Log LOG = LogFactory . getLog ( CxfSoapConsumer . class ) ; private final CxfSoapEndpoint endpoint ; private final Consumer consumer ; private MessageObserver inMessageObserver ; private Server server ; public CxfSoapConsumer ( CxfSoapEndpoint endpoint , Processor processor ) throws Exception { this . endpoint = endpoint ; Processor soapProcessor = new AsyncProcessorDecorator ( processor , new Processor ( ) { public void process ( Exchange exchange ) throws Exception { processSoapConsumerIn ( exchange ) ; } } , new Processor ( ) { public void process ( Exchange exchange ) throws Exception { processSoapConsumerOut ( exchange ) ; } } ) ; this . consumer = endpoint . getInnerEndpoint ( ) . createConsumer ( soapProcessor ) ; Class sei = null ; if ( ObjectHelper . isNotEmpty ( endpoint . getServiceClass ( ) ) ) { sei = ClassLoaderUtils . loadClass ( endpoint . getServiceClass ( ) , this . getClass ( ) ) ; } ServerFactoryBean sfb = CxfEndpointUtils . getServerFactoryBean ( sei ) ; sfb . setWsdlURL ( endpoint . getWsdl ( ) . getURL ( ) . toString ( ) ) ; if ( endpoint . getServiceName ( ) != null ) { sfb . setServiceName ( endpoint . getServiceName ( ) ) ; } if ( endpoint . getEndpointName ( ) != null ) { sfb . setEndpointName ( endpoint . getEndpointName ( ) ) ; } sfb . setDestinationFactory ( new NullDestinationFactory ( ) ) ; sfb . setStart ( false ) ; server = sfb . create ( ) ; } public void start ( ) throws Exception { server . start ( ) ; inMessageObserver = server . getDestination ( ) . getMessageObserver ( ) ; consumer . start ( ) ; } public void stop ( ) throws Exception { server . stop ( ) ; consumer . stop ( ) ; } protected Bus getBus ( ) { return endpoint . getBus ( ) ; } protected void processSoapConsumerIn ( Exchange exchange ) throws Exception { LOG . info ( "processSoapConsumerIn: " + exchange ) ; org . apache . cxf . message . Message inMessage = CxfSoapBinding . getCxfInMessage ( endpoint . getHeaderFilterStrategy ( ) , exchange , false ) ; org . apache . cxf . message . Exchange cxfExchange = inMessage . getExchange ( ) ; cxfExchange . put ( org . apache . cxf . endpoint . Endpoint . class , server . getEndpoint ( ) ) ; cxfExchange . put ( Bus . class , getBus ( ) ) ; cxfExchange . setConduit ( new NullConduit ( ) ) ; inMessageObserver . onMessage ( inMessage ) ; exchange . getIn ( ) . setBody ( inMessage . getContent ( Source . class ) ) ; exchange . getIn ( ) . setHeaders ( inMessage ) ; } protected void processSoapConsumerOut ( Exchange exchange ) throws Exception { LOG . info ( "processSoapConsumerOut: " + exchange ) ; org . apache . cxf . message . Message outMessage = CxfSoapBinding . getCxfOutMessage ( endpoint . getHeaderFilterStrategy ( ) , exchange , false ) ; org . apache . cxf . message . Exchange cxfExchange = outMessage . getExchange ( ) ; InterceptorChain chain = OutgoingChainInterceptor . getOutInterceptorChain ( cxfExchange ) ; outMessage . setInterceptorChain ( chain ) ; chain . doIntercept ( outMessage ) ; CachedOutputStream outputStream = ( CachedOutputStream ) outMessage . getContent ( OutputStream . class ) ; exchange . getOut ( ) . setBody ( outputStream . getInputStream ( ) ) ; } } 	0	['7', '1', '0', '32', '61', '0', '3', '32', '3', '0.633333333', '204', '1', '2', '0', '0.416666667', '0', '0', '27.42857143', '1', '0.7143', '0']
package org . apache . camel . converter . xmlbeans ; import java . io . InputStream ; import java . io . OutputStream ; import org . apache . camel . Exchange ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . util . ExchangeHelper ; import org . apache . xmlbeans . XmlObject ; public class XmlBeansDataFormat implements DataFormat { public void marshal ( Exchange exchange , Object body , OutputStream stream ) throws Exception { XmlObject object = ExchangeHelper . convertToMandatoryType ( exchange , XmlObject . class , body ) ; object . save ( stream ) ; } public Object unmarshal ( Exchange exchange , InputStream stream ) throws Exception { return XmlObject . Factory . parse ( stream ) ; } } 	0	['3', '1', '0', '5', '7', '3', '0', '5', '3', '2', '19', '0', '0', '0', '0.533333333', '0', '0', '5.333333333', '1', '0.6667', '0']
package org . apache . camel . component . file ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . RandomAccessFile ; import java . nio . ByteBuffer ; import java . nio . channels . FileChannel ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Message ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . language . simple . FileLanguage ; import org . apache . camel . util . ExchangeHelper ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class FileProducer extends DefaultProducer { private static final transient Log LOG = LogFactory . getLog ( FileProducer . class ) ; private FileEndpoint endpoint ; public FileProducer ( FileEndpoint endpoint ) { super ( endpoint ) ; this . endpoint = endpoint ; } public FileEndpoint getEndpoint ( ) { return endpoint ; } public void process ( Exchange exchange ) throws Exception { FileExchange fileExchange = endpoint . createExchange ( exchange ) ; process ( fileExchange ) ; ExchangeHelper . copyResults ( exchange , fileExchange ) ; } public void process ( FileExchange exchange ) throws Exception { boolean fileSource = exchange . getIn ( ) . getBody ( ) instanceof File ; File target = createFileName ( exchange . getIn ( ) ) ; buildDirectory ( target ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "About to write to: " + target + " from exchange: " + exchange ) ; } if ( fileSource ) { File source = ExchangeHelper . getMandatoryInBody ( exchange , File . class ) ; writeFileByFile ( source , target ) ; } else { InputStream in = ExchangeHelper . getMandatoryInBody ( exchange , InputStream . class ) ; writeFileByStream ( in , target ) ; } } private void writeFileByFile ( File source , File target ) throws IOException { FileChannel in = new FileInputStream ( source ) . getChannel ( ) ; FileChannel out = null ; try { out = prepareOutputFileChannel ( target , out ) ; if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Using FileChannel to transfer from: " + in + " to: " + out ) ; } in . transferTo ( 0 , in . size ( ) , out ) ; } finally { ObjectHelper . close ( in , source . getName ( ) , LOG ) ; ObjectHelper . close ( out , source . getName ( ) , LOG ) ; } } private void writeFileByStream ( InputStream in , File target ) throws IOException { FileChannel out = null ; try { out = prepareOutputFileChannel ( target , out ) ; if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Using InputStream to transfer from: " + in + " to: " + out ) ; } int size = endpoint . getBufferSize ( ) ; byte [ ] buffer = new byte [ size ] ; ByteBuffer byteBuffer = ByteBuffer . wrap ( buffer ) ; while ( true ) { int count = in . read ( buffer ) ; if ( count <= 0 ) { break ; } else if ( count < size ) { byteBuffer = ByteBuffer . wrap ( buffer , 0 , count ) ; out . write ( byteBuffer ) ; break ; } else { out . write ( byteBuffer ) ; byteBuffer . clear ( ) ; } } } finally { ObjectHelper . close ( in , target . getName ( ) , LOG ) ; ObjectHelper . close ( out , target . getName ( ) , LOG ) ; } } private FileChannel prepareOutputFileChannel ( File target , FileChannel out ) throws IOException { if ( endpoint . isAppend ( ) ) { out = new RandomAccessFile ( target , "rw" ) . getChannel ( ) ; out = out . position ( out . size ( ) ) ; } else { out = new FileOutputStream ( target ) . getChannel ( ) ; } return out ; } protected File createFileName ( Message message ) { File answer ; String name = null ; if ( ! endpoint . isIgnoreFileNameHeader ( ) ) { name = message . getHeader ( FileComponent . HEADER_FILE_NAME , String . class ) ; } Expression expression = endpoint . getExpression ( ) ; if ( name != null ) { if ( name . indexOf ( "${" ) > - 1 ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( FileComponent . HEADER_FILE_NAME + " contains a FileLanguage expression: " + name ) ; } expression = FileLanguage . file ( name ) ; } } if ( expression != null ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Filename evaluated as expression: " + expression ) ; } Object result = expression . evaluate ( message . getExchange ( ) ) ; name = message . getExchange ( ) . getContext ( ) . getTypeConverter ( ) . convertTo ( String . class , result ) ; } File endpointFile = endpoint . getFile ( ) ; if ( endpointFile . isDirectory ( ) ) { if ( name != null ) { answer = new File ( endpointFile , name ) ; if ( answer . isDirectory ( ) ) { answer = new File ( answer , endpoint . getGeneratedFileName ( message ) ) ; } } else { answer = new File ( endpointFile , endpoint . getGeneratedFileName ( message ) ) ; } } else { if ( name == null ) { answer = endpointFile ; } else { answer = new File ( endpointFile , name ) ; } } message . setHeader ( FileComponent . HEADER_FILE_NAME_PRODUCED , answer . getAbsolutePath ( ) ) ; return answer ; } private void buildDirectory ( File file ) { String dirName = file . getAbsolutePath ( ) ; int index = dirName . lastIndexOf ( File . separatorChar ) ; if ( index > 0 ) { dirName = dirName . substring ( 0 , index ) ; File dir = new File ( dirName ) ; dir . mkdirs ( ) ; } } } 	0	['11', '3', '0', '14', '63', '7', '1', '14', '5', '0.35', '416', '1', '1', '0.7', '0.25', '0', '0', '36.63636364', '11', '1.8182', '0']
package org . apache . camel . component . jhc ; import java . io . IOException ; import org . apache . http . HttpException ; import org . apache . http . HttpRequest ; import org . apache . http . HttpResponse ; import org . apache . http . protocol . HttpContext ; import org . apache . http . protocol . HttpRequestHandler ; public interface AsyncHttpRequestHandler extends HttpRequestHandler { void handle ( HttpRequest request , HttpContext context , AsyncResponseHandler handler ) throws HttpException , IOException ; } 	0	['1', '1', '0', '9', '1', '0', '4', '5', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlElementRef ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . FilterProcessor ; import org . apache . camel . spi . RouteContext ; @ XmlAccessorType ( XmlAccessType . FIELD ) public class ExpressionNode extends ProcessorType < ProcessorType > { @ XmlElementRef private ExpressionType expression ; @ XmlElementRef private List < ProcessorType < ? > > outputs = new ArrayList < ProcessorType < ? > > ( ) ; public ExpressionNode ( ) { } public ExpressionNode ( ExpressionType expression ) { this . expression = expression ; } public ExpressionNode ( Expression expression ) { if ( expression != null ) { setExpression ( new ExpressionType ( expression ) ) ; } } public ExpressionNode ( Predicate predicate ) { if ( predicate != null ) { setExpression ( new ExpressionType ( predicate ) ) ; } } @ Override public String getShortName ( ) { return "exp" ; } public ExpressionType getExpression ( ) { return expression ; } public void setExpression ( ExpressionType expression ) { this . expression = expression ; } public List < ProcessorType < ? > > getOutputs ( ) { return outputs ; } public void setOutputs ( List < ProcessorType < ? > > outputs ) { this . outputs = outputs ; } @ Override public String getLabel ( ) { if ( getExpression ( ) == null ) { return "" ; } return getExpression ( ) . getLabel ( ) ; } protected FilterProcessor createFilterProcessor ( RouteContext routeContext ) throws Exception { Processor childProcessor = routeContext . createProcessor ( this ) ; return new FilterProcessor ( getExpression ( ) . createPredicate ( routeContext ) , childProcessor ) ; } @ Override protected void configureChild ( ProcessorType output ) { super . configureChild ( output ) ; if ( isInheritErrorHandler ( ) ) { output . setErrorHandlerBuilder ( getErrorHandlerBuilder ( ) ) ; } } } 	0	['12', '3', '13', '22', '24', '30', '15', '8', '10', '0.5', '114', '1', '1', '0.956521739', '0.226190476', '1', '3', '8.333333333', '2', '0.8333', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . builder . ExpressionClause ; import org . apache . camel . processor . ChoiceProcessor ; import org . apache . camel . processor . FilterProcessor ; import org . apache . camel . spi . RouteContext ; import org . apache . camel . util . CollectionStringBuffer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; @ XmlRootElement ( name = "choice" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ChoiceType extends ProcessorType < ChoiceType > { private static final transient Log LOG = LogFactory . getLog ( ChoiceType . class ) ; @ XmlElementRef private List < WhenType > whenClauses = new ArrayList < WhenType > ( ) ; @ XmlElement ( required = false ) private OtherwiseType otherwise ; @ Override public String toString ( ) { if ( getOtherwise ( ) != null ) { return "Choice[" + getWhenClauses ( ) + " " + getOtherwise ( ) + "]" ; } else { return "Choice[" + getWhenClauses ( ) + "]" ; } } @ Override public String getShortName ( ) { return "choice" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { List < FilterProcessor > filters = new ArrayList < FilterProcessor > ( ) ; for ( WhenType whenClaus : whenClauses ) { filters . add ( whenClaus . createProcessor ( routeContext ) ) ; } Processor otherwiseProcessor = null ; if ( otherwise != null ) { otherwiseProcessor = otherwise . createProcessor ( routeContext ) ; } else { LOG . warn ( "No otherwise clause was specified for a choice block -- any unmatched exchanges will be dropped" ) ; } return new ChoiceProcessor ( filters , otherwiseProcessor ) ; } public ChoiceType when ( Predicate predicate ) { getWhenClauses ( ) . add ( new WhenType ( predicate ) ) ; return this ; } public ExpressionClause < ChoiceType > when ( ) { WhenType when = new WhenType ( ) ; getWhenClauses ( ) . add ( when ) ; ExpressionClause < ChoiceType > clause = new ExpressionClause < ChoiceType > ( this ) ; when . setExpression ( clause ) ; return clause ; } public ChoiceType otherwise ( ) { OtherwiseType answer = new OtherwiseType ( ) ; setOtherwise ( answer ) ; return this ; } @ Override public String getLabel ( ) { CollectionStringBuffer buffer = new CollectionStringBuffer ( ) ; List < WhenType > list = getWhenClauses ( ) ; for ( WhenType whenType : list ) { buffer . append ( whenType . getLabel ( ) ) ; } return buffer . toString ( ) ; } public List < WhenType > getWhenClauses ( ) { return whenClauses ; } public void setWhenClauses ( List < WhenType > whenClauses ) { this . whenClauses = whenClauses ; } public List < ProcessorType < ? > > getOutputs ( ) { if ( otherwise != null ) { return otherwise . getOutputs ( ) ; } else if ( whenClauses . isEmpty ( ) ) { return Collections . EMPTY_LIST ; } else { WhenType when = whenClauses . get ( whenClauses . size ( ) - 1 ) ; return when . getOutputs ( ) ; } } public OtherwiseType getOtherwise ( ) { return otherwise ; } public void setOtherwise ( OtherwiseType otherwise ) { this . otherwise = otherwise ; } } 	0	['14', '3', '0', '21', '43', '59', '9', '13', '13', '0.641025641', '208', '1', '1', '0.936170213', '0.261538462', '1', '3', '13.64285714', '3', '1.1429', '0']
package org . apache . camel . component . xquery ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . component . ResourceBasedComponent ; import org . apache . camel . impl . ProcessorEndpoint ; import org . springframework . core . io . Resource ; public class XQueryComponent extends ResourceBasedComponent { protected Endpoint < Exchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { Resource resource = resolveMandatoryResource ( remaining ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( this + " using schema resource: " + resource ) ; } XQueryBuilder xslt = XQueryBuilder . xquery ( resource . getURL ( ) ) ; configureXslt ( xslt , uri , remaining , parameters ) ; return new ProcessorEndpoint ( uri , this , xslt ) ; } protected void configureXslt ( XQueryBuilder xQueryBuilder , String uri , String remaining , Map parameters ) throws Exception { setProperties ( xQueryBuilder , parameters ) ; } } 	0	['3', '4', '0', '8', '15', '3', '0', '8', '1', '2', '49', '0', '0', '0.95', '0.666666667', '2', '2', '15.33333333', '1', '0.6667', '0']
package org . apache . camel . processor . idempotent ; public interface MessageIdRepository { boolean contains ( String messageId ) ; } 	0	['1', '1', '0', '7', '1', '0', '7', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . spring . handler ; import org . apache . camel . util . ObjectHelper ; public class LazyLoadingBeanDefinitionParser extends BeanDefinitionParser { private String className ; private String moduleName ; public LazyLoadingBeanDefinitionParser ( String className , String moduleName ) { this . className = className ; this . moduleName = moduleName ; } @ Override protected Class loadType ( ) { Class < ? > answer = ObjectHelper . loadClass ( className , getClass ( ) . getClassLoader ( ) ) ; if ( answer == null ) { throw new IllegalArgumentException ( "Class: " + className + " could not be found. You need to add Camel module: " + moduleName + " to your classpath" ) ; } return answer ; } } 	0	['2', '1', '1', '3', '10', '0', '1', '2', '1', '0', '44', '1', '0', '0.857142857', '0.75', '1', '1', '20', '2', '1', '0']
package org . apache . camel . component . cxf . invoker ; import java . util . Map ; import java . util . logging . Level ; import java . util . logging . Logger ; import org . apache . camel . util . ObjectHelper ; import org . apache . cxf . Bus ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . endpoint . ClientImpl ; import org . apache . cxf . endpoint . Endpoint ; import org . apache . cxf . message . Exchange ; import org . apache . cxf . message . ExchangeImpl ; import org . apache . cxf . message . Message ; import org . apache . cxf . phase . PhaseInterceptorChain ; import org . apache . cxf . service . Service ; import org . apache . cxf . service . model . BindingInfo ; import org . apache . cxf . service . model . BindingMessageInfo ; import org . apache . cxf . service . model . BindingOperationInfo ; import org . apache . cxf . service . model . OperationInfo ; import org . apache . cxf . transport . MessageObserver ; public class CxfClient extends ClientImpl { private static final Logger LOG = LogUtils . getL7dLogger ( CxfClient . class ) ; public CxfClient ( Bus b , Endpoint e ) { super ( b , e ) ; } public Object dispatch ( Map < Class , Object > params , Map < String , Object > context , Exchange exchange ) throws Exception { Object retval = null ; InvokingContext invokingContext = exchange . get ( InvokingContext . class ) ; ObjectHelper . notNull ( invokingContext , "invokingContext" ) ; BindingOperationInfo inBoundOp = exchange . get ( BindingOperationInfo . class ) ; BindingOperationInfo outBoundOp = null ; if ( inBoundOp != null ) { BindingInfo bi = getEndpoint ( ) . getEndpointInfo ( ) . getBinding ( ) ; outBoundOp = bi . getOperation ( inBoundOp . getOperationInfo ( ) . getName ( ) ) ; if ( outBoundOp != null && inBoundOp . isUnwrapped ( ) ) { outBoundOp = outBoundOp . getUnwrappedOperation ( ) ; } } retval = invokeWithMessageStream ( outBoundOp , params , context , invokingContext ) ; return retval ; } @ SuppressWarnings ( "unchecked" ) public Object invokeWithMessageStream ( BindingOperationInfo bi , Map < Class , Object > param , Map < String , Object > context , InvokingContext invokingContext ) throws Exception { Object retval = null ; Map < String , Object > requestContext = null ; Map < String , Object > responseContext = null ; if ( null != context ) { requestContext = ( Map < String , Object > ) context . get ( REQUEST_CONTEXT ) ; responseContext = ( Map < String , Object > ) context . get ( RESPONSE_CONTEXT ) ; } Exchange exchange = new ExchangeImpl ( ) ; exchange . put ( InvokingContext . class , invokingContext ) ; if ( bi != null ) { exchange . put ( BindingMessageInfo . class , bi . getInput ( ) ) ; exchange . setOneWay ( bi . getOperationInfo ( ) . isOneWay ( ) ) ; } Message message = prepareMessage ( exchange , requestContext , param , invokingContext ) ; message . put ( Message . INVOCATION_CONTEXT , context ) ; Endpoint ep = getEndpoint ( ) ; if ( ep != null ) { message . putAll ( ep ) ; } setExchangeProperties ( exchange , ep , bi ) ; PhaseInterceptorChain chain = setupInterceptorChain ( getEndpoint ( ) ) ; message . setInterceptorChain ( chain ) ; modifyChain ( chain , requestContext ) ; chain . setFaultObserver ( outFaultObserver ) ; prepareConduitSelector ( message ) ; modifyChain ( chain , null ) ; chain . doIntercept ( message ) ; Exception ex = message . getContent ( Exception . class ) ; if ( ex != null ) { if ( LOG . isLoggable ( Level . FINE ) ) { LOG . fine ( "Exception in outgoing chain: " + ex . toString ( ) ) ; } throw ex ; } if ( ! exchange . isOneWay ( ) ) { synchronized ( exchange ) { waitResponse ( exchange ) ; } ex = getException ( exchange ) ; if ( ex != null ) { if ( LOG . isLoggable ( Level . FINE ) ) { LOG . fine ( "Exception in incoming chain: " + ex . toString ( ) ) ; } throw ex ; } retval = invokingContext . getResponseObject ( exchange , responseContext ) ; } return retval ; } protected void waitResponse ( Exchange exchange ) { int remaining = synchronousTimeout ; while ( ! Boolean . TRUE . equals ( exchange . get ( FINISHED ) ) && remaining > 0 ) { long start = System . currentTimeMillis ( ) ; try { exchange . wait ( remaining ) ; } catch ( InterruptedException ex ) { } long end = System . currentTimeMillis ( ) ; remaining -= ( int ) ( end - start ) ; } if ( ! Boolean . TRUE . equals ( exchange . get ( FINISHED ) ) ) { LogUtils . log ( LOG , Level . WARNING , "RESPONSE_TIMEOUT" , exchange . get ( OperationInfo . class ) . getName ( ) . toString ( ) ) ; } } private Message prepareMessage ( Exchange exchange , Map < String , Object > requestContext , Map < Class , Object > param , InvokingContext invokingContext ) { Message message = getEndpoint ( ) . getBinding ( ) . createMessage ( ) ; message . put ( Message . REQUESTOR_ROLE , Boolean . TRUE ) ; message . put ( Message . INBOUND_MESSAGE , Boolean . FALSE ) ; if ( requestContext != null ) { message . putAll ( requestContext ) ; } if ( param != null ) { invokingContext . setRequestOutMessageContent ( message , param ) ; } if ( null != requestContext ) { exchange . putAll ( requestContext ) ; } exchange . setOutMessage ( message ) ; return message ; } } 	0	['6', '0', '0', '21', '54', '9', '2', '19', '3', '0.4', '309', '1', '0', '0', '0.457142857', '0', '0', '50.33333333', '4', '1.6667', '0']
package org . apache . camel . component . cxf . transport . spring ; import org . apache . camel . component . cxf . transport . CamelConduit ; public class CamelConduitDefinitionParser extends AbstractCamelContextBeanDefinitionParser { public CamelConduitDefinitionParser ( ) { super ( ) ; setBeanClass ( CamelConduit . class ) ; } } 	0	['1', '1', '0', '2', '3', '0', '1', '1', '1', '2', '7', '0', '0', '1', '1', '0', '0', '6', '0', '0', '0']
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . NoTypeConversionAvailableException ; import org . apache . camel . Processor ; import org . apache . camel . util . ExchangeHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class ConvertBodyProcessor implements Processor { private static final transient Log LOG = LogFactory . getLog ( ConvertBodyProcessor . class ) ; private final Class type ; public ConvertBodyProcessor ( Class type ) { this . type = type ; } public void process ( Exchange exchange ) throws Exception { Message in = exchange . getIn ( ) ; Object value = null ; try { value = in . getBody ( type ) ; } catch ( NoTypeConversionAvailableException e ) { LOG . warn ( "Could not convert body of IN message: " + in + " to type: " + type . getName ( ) ) ; } if ( exchange . getPattern ( ) . isOutCapable ( ) ) { Message out = exchange . getOut ( ) ; out . copyFrom ( in ) ; out . setBody ( value ) ; } else { in . setBody ( value ) ; } } } 	0	['3', '1', '0', '9', '18', '0', '2', '7', '2', '0.5', '61', '1', '0', '0', '0.666666667', '0', '0', '18.66666667', '1', '0.3333', '0']
package org . apache . camel . component . bean ; import org . apache . camel . CamelContext ; import org . apache . camel . NoTypeConversionAvailableException ; import org . apache . camel . Processor ; import org . apache . camel . spi . Registry ; import org . apache . camel . util . CamelContextHelper ; import org . apache . camel . util . ObjectHelper ; public class RegistryBean implements BeanHolder { private final CamelContext context ; private final String name ; private final Registry registry ; private Processor processor ; private BeanInfo beanInfo ; private Object bean ; private ParameterMappingStrategy parameterMappingStrategy ; public RegistryBean ( CamelContext context , String name ) { this . context = context ; this . name = name ; this . registry = context . getRegistry ( ) ; } public RegistryBean ( CamelContext context , String name , ParameterMappingStrategy parameterMappingStrategy ) { this ( context , name ) ; this . parameterMappingStrategy = parameterMappingStrategy ; } @ Override public String toString ( ) { return "bean: " + name ; } public ConstantBeanHolder createCacheHolder ( ) throws Exception { return new ConstantBeanHolder ( getBean ( ) , getBeanInfo ( ) ) ; } public Object getBean ( ) throws Exception { Object value = lookupBean ( ) ; if ( value == null ) { throw new NoBeanAvailableException ( name ) ; } if ( value != bean ) { bean = value ; processor = null ; if ( ! ObjectHelper . equal ( ObjectHelper . type ( bean ) , ObjectHelper . type ( value ) ) ) { beanInfo = null ; } } return value ; } public Processor getProcessor ( ) { if ( processor == null && bean != null ) { try { processor = CamelContextHelper . convertTo ( context , Processor . class , bean ) ; } catch ( NoTypeConversionAvailableException ex ) { } } return processor ; } public BeanInfo getBeanInfo ( ) { if ( beanInfo == null && bean != null ) { this . beanInfo = createBeanInfo ( ) ; } return beanInfo ; } public String getName ( ) { return name ; } public Registry getRegistry ( ) { return registry ; } public CamelContext getContext ( ) { return context ; } public ParameterMappingStrategy getParameterMappingStrategy ( ) { if ( parameterMappingStrategy == null ) { parameterMappingStrategy = createParameterMappingStrategy ( ) ; } return parameterMappingStrategy ; } public void setParameterMappingStrategy ( ParameterMappingStrategy parameterMappingStrategy ) { this . parameterMappingStrategy = parameterMappingStrategy ; } protected BeanInfo createBeanInfo ( ) { return new BeanInfo ( context , bean . getClass ( ) , getParameterMappingStrategy ( ) ) ; } protected ParameterMappingStrategy createParameterMappingStrategy ( ) { return BeanInfo . createParameterMappingStrategy ( context ) ; } protected Object lookupBean ( ) throws Exception { return registry . lookup ( name ) ; } } 	0	['15', '1', '1', '15', '29', '45', '4', '11', '12', '0.714285714', '171', '1', '5', '0', '0.35', '0', '0', '9.933333333', '3', '1.2', '0']
package org . apache . camel . language ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . PARAMETER } ) @ LanguageAnnotation ( language = "constant" ) public @ interface Constant { String value ( ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . mail ; import javax . mail . internet . MimeMessage ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . mail . javamail . JavaMailSender ; import org . springframework . mail . javamail . MimeMessagePreparator ; public class MailProducer extends DefaultProducer < MailExchange > { private static final transient Log LOG = LogFactory . getLog ( MailProducer . class ) ; private final MailEndpoint endpoint ; private final JavaMailSender sender ; public MailProducer ( MailEndpoint endpoint , JavaMailSender sender ) { super ( endpoint ) ; this . endpoint = endpoint ; this . sender = sender ; } public void process ( final Exchange exchange ) { sender . send ( new MimeMessagePreparator ( ) { public void prepare ( MimeMessage mimeMessage ) throws Exception { endpoint . getBinding ( ) . populateMailMessage ( endpoint , mimeMessage , exchange ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Sending MimeMessage: " + MailUtils . dumpMessage ( mimeMessage ) ) ; } } } ) ; } } 	0	['5', '3', '0', '9', '9', '4', '2', '9', '2', '0.75', '36', '1', '1', '0.875', '0.3', '0', '0', '5.6', '1', '0.6', '0']
package org . apache . camel . component . cxf . util ; import java . io . IOException ; import java . util . List ; import java . util . Set ; import org . apache . cxf . binding . AbstractBindingFactory ; import org . apache . cxf . service . model . EndpointInfo ; import org . apache . cxf . transport . Destination ; import org . apache . cxf . transport . DestinationFactory ; public class NullDestinationFactory implements DestinationFactory { public Destination getDestination ( EndpointInfo ei ) throws IOException { ei . setAddress ( "local://" + ei . getService ( ) . getName ( ) . toString ( ) + "/" + ei . getName ( ) . getLocalPart ( ) ) ; ei . getBinding ( ) . setProperty ( AbstractBindingFactory . DATABINDING_DISABLED , Boolean . TRUE ) ; return new NullDestination ( ) ; } public List < String > getTransportIds ( ) { return null ; } public Set < String > getUriPrefixes ( ) { return null ; } } 	0	['4', '1', '0', '7', '17', '6', '1', '6', '4', '2', '39', '0', '0', '0', '0.625', '0', '0', '8.75', '1', '0.75', '0']
package org . apache . camel . component . cxf ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . HeaderFilterStrategyAware ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . spi . HeaderFilterStrategy ; import org . apache . camel . util . CamelContextHelper ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . camel . util . URISupport ; public class CxfSoapComponent extends DefaultComponent implements HeaderFilterStrategyAware { private HeaderFilterStrategy headerFilterStrategy ; public CxfSoapComponent ( ) { setHeaderFilterStrategy ( new CxfHeaderFilterStrategy ( ) ) ; } @ Override protected Endpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { Map soapProps = IntrospectionSupport . extractProperties ( parameters , "soap." ) ; if ( parameters . size ( ) > 0 ) { remaining += "?" + URISupport . createQueryString ( parameters ) ; } Endpoint endpoint = CamelContextHelper . getMandatoryEndpoint ( getCamelContext ( ) , remaining ) ; CxfSoapEndpoint soapEndpoint = new CxfSoapEndpoint ( endpoint , getHeaderFilterStrategy ( ) ) ; setProperties ( soapEndpoint , soapProps ) ; soapEndpoint . init ( ) ; return soapEndpoint ; } @ Override protected boolean useIntrospectionOnEndpoint ( ) { return false ; } public HeaderFilterStrategy getHeaderFilterStrategy ( ) { return headerFilterStrategy ; } public void setHeaderFilterStrategy ( HeaderFilterStrategy strategy ) { headerFilterStrategy = strategy ; } } 	0	['5', '3', '0', '10', '18', '8', '0', '10', '3', '0.25', '62', '1', '1', '0.897435897', '0.4', '1', '3', '11.2', '1', '0.8', '0']
package org . apache . camel . dataformat . hl7 ; import ca . uhn . hl7v2 . HL7Exception ; import ca . uhn . hl7v2 . model . Message ; import ca . uhn . hl7v2 . parser . Parser ; import ca . uhn . hl7v2 . parser . PipeParser ; import org . apache . camel . Converter ; @ Converter public final class HL7Converter { private HL7Converter ( ) { } @ Converter public static String toString ( Message message ) throws HL7Exception { Parser parser = new PipeParser ( ) ; String encoded = parser . encode ( message ) ; return encoded ; } @ Converter public static Message toMessage ( String body ) throws HL7Exception { body = body . replace ( '\n' , '\r' ) ; Parser parser = new PipeParser ( ) ; Message message = parser . parse ( body ) ; return message ; } } 	0	['3', '1', '0', '6', '8', '3', '2', '4', '2', '2', '31', '0', '0', '0', '0.333333333', '0', '0', '9.333333333', '1', '0.6667', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Processor ; import org . apache . camel . processor . CatchProcessor ; import org . apache . camel . processor . TryProcessor ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "try" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class TryType extends OutputType < TryType > { @ XmlTransient private List < CatchType > catchClauses ; @ XmlTransient private FinallyType finallyClause ; @ XmlTransient private boolean initialized ; @ XmlTransient private List < ProcessorType < ? > > outputsWithoutCatches ; @ Override public String toString ( ) { return "Try[" + getOutputs ( ) + "]" ; } @ Override public String getShortName ( ) { return "try" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { Processor tryProcessor = createOutputsProcessor ( routeContext , getOutputsWithoutCatches ( ) ) ; Processor finallyProcessor = null ; if ( finallyClause != null ) { finallyProcessor = finallyClause . createProcessor ( routeContext ) ; } List < CatchProcessor > catchProcessors = new ArrayList < CatchProcessor > ( ) ; if ( catchClauses != null ) { for ( CatchType catchClause : catchClauses ) { catchProcessors . add ( catchClause . createProcessor ( routeContext ) ) ; } } return new TryProcessor ( tryProcessor , catchProcessors , finallyProcessor ) ; } public TryType handle ( Class < ? > exceptionType ) { popBlock ( ) ; CatchType answer = new CatchType ( exceptionType ) ; addOutput ( answer ) ; pushBlock ( answer ) ; return this ; } @ Deprecated public TryType handleAll ( ) { return finallyBlock ( ) ; } public TryType finallyBlock ( ) { popBlock ( ) ; FinallyType answer = new FinallyType ( ) ; addOutput ( answer ) ; pushBlock ( answer ) ; return this ; } @ Override public ProcessorType < ? extends ProcessorType > end ( ) { popBlock ( ) ; return super . end ( ) ; } public List < CatchType > getCatchClauses ( ) { if ( catchClauses == null ) { checkInitialized ( ) ; } return catchClauses ; } public FinallyType getFinallyClause ( ) { if ( finallyClause == null ) { checkInitialized ( ) ; } return finallyClause ; } public List < ProcessorType < ? > > getOutputsWithoutCatches ( ) { if ( outputsWithoutCatches == null ) { checkInitialized ( ) ; } return outputsWithoutCatches ; } public void setOutputs ( List < ProcessorType < ? > > outputs ) { initialized = false ; super . setOutputs ( outputs ) ; } @ Override public void addOutput ( ProcessorType output ) { initialized = false ; super . addOutput ( output ) ; } protected void checkInitialized ( ) { if ( ! initialized ) { initialized = true ; outputsWithoutCatches = new ArrayList < ProcessorType < ? > > ( ) ; catchClauses = new ArrayList < CatchType > ( ) ; finallyClause = null ; for ( ProcessorType output : outputs ) { if ( output instanceof CatchType ) { catchClauses . add ( ( CatchType ) output ) ; } else if ( output instanceof FinallyType ) { if ( finallyClause != null ) { throw new IllegalArgumentException ( "Multiple finally clauses added: " + finallyClause + " and " + output ) ; } else { finallyClause = ( FinallyType ) output ; } } else { outputsWithoutCatches . add ( output ) ; } } } } } 	0	['14', '4', '0', '11', '37', '73', '3', '9', '13', '0.634615385', '236', '1', '1', '0.932291667', '0.257142857', '1', '16', '15.57142857', '6', '1.5', '0']
package org . apache . camel . model . language ; import java . util . Map ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . spi . NamespaceAware ; import org . apache . camel . spi . RouteContext ; @ XmlAccessorType ( XmlAccessType . FIELD ) public abstract class NamespaceAwareExpression extends ExpressionType implements NamespaceAware { @ XmlTransient private Map < String , String > namespaces ; public NamespaceAwareExpression ( ) { } public NamespaceAwareExpression ( String expression ) { super ( expression ) ; } public Map < String , String > getNamespaces ( ) { return namespaces ; } public void setNamespaces ( Map < String , String > namespaces ) { this . namespaces = namespaces ; } @ Override protected void configureExpression ( RouteContext routeContext , Expression expression ) { configureNamespaceAware ( expression ) ; } @ Override protected void configurePredicate ( RouteContext routeContext , Predicate predicate ) { configureNamespaceAware ( predicate ) ; } protected void configureNamespaceAware ( Object builder ) { if ( namespaces != null && builder instanceof NamespaceAware ) { NamespaceAware namespaceAware = ( NamespaceAware ) builder ; namespaceAware . setNamespaces ( namespaces ) ; } } } 	0	['7', '2', '2', '7', '10', '15', '2', '5', '4', '0.333333333', '44', '1', '0', '0.814814815', '0.285714286', '0', '0', '5.142857143', '3', '1', '0']
package org . apache . camel . component . jpa ; import java . util . Iterator ; import javax . persistence . EntityManager ; import javax . persistence . PersistenceException ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . converter . ObjectConverter ; import org . apache . camel . impl . DefaultProducer ; import org . springframework . orm . jpa . JpaCallback ; public class JpaProducer extends DefaultProducer < Exchange > { private final TransactionStrategy template ; private final JpaEndpoint endpoint ; private final Expression < Exchange > expression ; public JpaProducer ( JpaEndpoint endpoint , Expression < Exchange > expression ) { super ( endpoint ) ; this . endpoint = endpoint ; this . expression = expression ; this . template = endpoint . createTransactionStrategy ( ) ; } public void process ( Exchange exchange ) { final Object values = expression . evaluate ( exchange ) ; if ( values != null ) { template . execute ( new JpaCallback ( ) { public Object doInJpa ( EntityManager entityManager ) throws PersistenceException { Iterator iter = ObjectConverter . iterator ( values ) ; while ( iter . hasNext ( ) ) { Object value = iter . next ( ) ; entityManager . persist ( value ) ; } if ( endpoint . isFlushOnSend ( ) ) { entityManager . flush ( ) ; } return null ; } } ) ; } exchange . setProperty ( "CamelJpaValue" , values ) ; } } 	0	['3', '3', '0', '8', '9', '0', '2', '8', '2', '0.5', '44', '1', '3', '0.913043478', '0.4', '0', '0', '12.66666667', '2', '1', '0']
package org . apache . camel . component . stream ; import org . apache . camel . impl . DefaultMessage ; public class StreamMessage extends DefaultMessage { private Object o ; public StreamMessage ( Object o ) { this . o = o ; } @ Override protected Object createBody ( ) { return o ; } @ Override public Object getBody ( ) { return o ; } @ Override public String toString ( ) { return o . toString ( ) ; } } 	0	['4', '3', '0', '1', '6', '0', '0', '1', '3', '0', '21', '1', '0', '0.921052632', '0.625', '2', '2', '4', '1', '0.75', '0']
package org . apache . camel . component . mail ; import java . net . URI ; import java . util . HashMap ; import java . util . Map ; import java . util . Properties ; import javax . mail . Authenticator ; import javax . mail . Message ; import javax . mail . PasswordAuthentication ; import javax . mail . Session ; import org . apache . camel . RuntimeCamelException ; import org . springframework . mail . javamail . JavaMailSenderImpl ; public class MailConfiguration implements Cloneable { public static final String DEFAULT_FOLDER_NAME = "INBOX" ; public static final String DEFAULT_FROM = "camel@localhost" ; public static final long DEFAULT_CONNECTION_TIMEOUT = 30000L ; private Properties javaMailProperties ; private String protocol ; private String host ; private int port = - 1 ; private String username ; private String password ; private Session session ; private String defaultEncoding ; private String from = DEFAULT_FROM ; private String folderName = DEFAULT_FOLDER_NAME ; private boolean deleteProcessedMessages ; private boolean ignoreUriScheme ; private boolean processOnlyUnseenMessages = true ; private Map < Message . RecipientType , String > recipients = new HashMap < Message . RecipientType , String > ( ) ; private String destination ; private int fetchSize = - 1 ; private boolean debugMode ; private long connectionTimeout = DEFAULT_CONNECTION_TIMEOUT ; private boolean dummyTrustManager ; private String contentType = "text/plain" ; public MailConfiguration ( ) { } public MailConfiguration copy ( ) { try { return ( MailConfiguration ) clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeCamelException ( e ) ; } } public void configure ( URI uri ) { String value = uri . getHost ( ) ; if ( value != null ) { setHost ( value ) ; } if ( ! isIgnoreUriScheme ( ) ) { String scheme = uri . getScheme ( ) ; if ( scheme != null ) { setProtocol ( scheme ) ; } } String userInfo = uri . getUserInfo ( ) ; if ( userInfo != null ) { setUsername ( userInfo ) ; } int port = uri . getPort ( ) ; if ( port > 0 ) { setPort ( port ) ; } else if ( port <= 0 && this . port <= 0 ) { setPort ( MailUtils . getDefaultPortForProtocol ( uri . getScheme ( ) ) ) ; } } protected JavaMailSenderImpl createJavaMailSender ( ) { JavaMailSenderImpl answer = new JavaMailSenderImpl ( ) ; answer . getSession ( ) . setDebug ( debugMode ) ; if ( javaMailProperties != null ) { answer . setJavaMailProperties ( javaMailProperties ) ; } else { answer . setJavaMailProperties ( createJavaMailProperties ( ) ) ; } if ( defaultEncoding != null ) { answer . setDefaultEncoding ( defaultEncoding ) ; } if ( host != null ) { answer . setHost ( host ) ; } if ( port >= 0 ) { answer . setPort ( port ) ; } if ( password != null ) { answer . setPassword ( password ) ; } if ( protocol != null ) { answer . setProtocol ( protocol ) ; } if ( session != null ) { answer . setSession ( session ) ; } else { Session session = Session . getDefaultInstance ( answer . getJavaMailProperties ( ) , getAuthenticator ( ) ) ; answer . setSession ( session ) ; } if ( username != null ) { answer . setUsername ( username ) ; } return answer ; } private Properties createJavaMailProperties ( ) { Properties properties = ( Properties ) System . getProperties ( ) . clone ( ) ; properties . put ( "mail." + protocol + ".connectiontimeout" , connectionTimeout ) ; properties . put ( "mail." + protocol + ".timeout" , connectionTimeout ) ; properties . put ( "mail." + protocol + ".host" , host ) ; properties . put ( "mail." + protocol + ".port" , "" + port ) ; if ( username != null ) { properties . put ( "mail." + protocol + ".user" , username ) ; properties . put ( "mail.user" , username ) ; properties . put ( "mail." + protocol + ".auth" , "true" ) ; } else { properties . put ( "mail." + protocol + ".auth" , "false" ) ; } properties . put ( "mail." + protocol + ".rsetbeforequit" , "true" ) ; properties . put ( "mail.transport.protocol" , protocol ) ; properties . put ( "mail.store.protocol" , protocol ) ; properties . put ( "mail.host" , host ) ; if ( debugMode ) { properties . put ( "javax.net.debug" , "all" ) ; } if ( dummyTrustManager && isSecureProtocol ( ) ) { properties . put ( "mail." + protocol + ".socketFactory.class" , "org.apache.camel.component.mail.security.DummySSLSocketFactory" ) ; properties . put ( "mail." + protocol + ".socketFactory.fallback" , "false" ) ; properties . put ( "mail." + protocol + ".socketFactory.port" , "" + port ) ; } return properties ; } public boolean isSecureProtocol ( ) { return this . protocol . equalsIgnoreCase ( "smtps" ) || this . protocol . equalsIgnoreCase ( "pop3s" ) || this . protocol . equalsIgnoreCase ( "imaps" ) ; } public Authenticator getAuthenticator ( ) { return new Authenticator ( ) { protected PasswordAuthentication getPasswordAuthentication ( ) { return new PasswordAuthentication ( getUsername ( ) , getPassword ( ) ) ; } } ; } public String getMailStoreLogInformation ( ) { String ssl = "" ; if ( isSecureProtocol ( ) ) { ssl = "(SSL enabled" + ( dummyTrustManager ? " using DummyTrustManager)" : ")" ) ; } return protocol + "//" + host + ":" + port + ssl + ", folder=" + folderName ; } public String getDefaultEncoding ( ) { return defaultEncoding ; } public void setDefaultEncoding ( String defaultEncoding ) { this . defaultEncoding = defaultEncoding ; } public String getHost ( ) { return host ; } public void setHost ( String host ) { this . host = host ; } public Properties getJavaMailProperties ( ) { return javaMailProperties ; } public void setJavaMailProperties ( Properties javaMailProperties ) { this . javaMailProperties = javaMailProperties ; } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public int getPort ( ) { return port ; } public void setPort ( int port ) { this . port = port ; } public String getProtocol ( ) { return protocol ; } public void setProtocol ( String protocol ) { this . protocol = protocol ; } public Session getSession ( ) { return session ; } public void setSession ( Session session ) { this . session = session ; } public String getUsername ( ) { return username ; } public void setUsername ( String username ) { this . username = username ; if ( destination == null ) { String address = username ; if ( address . indexOf ( "@" ) == - 1 ) { address += "@" + host ; } destination = address ; } } public String getDestination ( ) { return destination ; } public void setDestination ( String destination ) { this . destination = destination ; } public String getFrom ( ) { return from ; } public void setFrom ( String from ) { this . from = from ; } public boolean isDeleteProcessedMessages ( ) { return deleteProcessedMessages ; } public void setDeleteProcessedMessages ( boolean deleteProcessedMessages ) { this . deleteProcessedMessages = deleteProcessedMessages ; } public String getFolderName ( ) { return folderName ; } public void setFolderName ( String folderName ) { this . folderName = folderName ; } public boolean isIgnoreUriScheme ( ) { return ignoreUriScheme ; } public void setIgnoreUriScheme ( boolean ignoreUriScheme ) { this . ignoreUriScheme = ignoreUriScheme ; } public boolean isProcessOnlyUnseenMessages ( ) { return processOnlyUnseenMessages ; } public void setProcessOnlyUnseenMessages ( boolean processOnlyUnseenMessages ) { this . processOnlyUnseenMessages = processOnlyUnseenMessages ; } public void setTo ( String address ) { recipients . put ( Message . RecipientType . TO , address ) ; } public void setCC ( String address ) { recipients . put ( Message . RecipientType . CC , address ) ; } public void setBCC ( String address ) { recipients . put ( Message . RecipientType . BCC , address ) ; } public Map < Message . RecipientType , String > getRecipients ( ) { return recipients ; } public int getFetchSize ( ) { return fetchSize ; } public void setFetchSize ( int fetchSize ) { this . fetchSize = fetchSize ; } public boolean isDebugMode ( ) { return debugMode ; } public void setDebugMode ( boolean debugMode ) { this . debugMode = debugMode ; } public long getConnectionTimeout ( ) { return connectionTimeout ; } public void setConnectionTimeout ( long connectionTimeout ) { this . connectionTimeout = connectionTimeout ; } public boolean isDummyTrustManager ( ) { return dummyTrustManager ; } public void setDummyTrustManager ( boolean dummyTrustManager ) { this . dummyTrustManager = dummyTrustManager ; } public String getContentType ( ) { return contentType ; } public void setContentType ( String contentType ) { this . contentType = contentType ; } } 	0	['50', '1', '0', '8', '84', '1011', '5', '4', '48', '0.947648625', '726', '0.869565217', '0', '0', '0.1825', '0', '0', '13.06', '9', '1.5', '0']
package org . apache . camel . util ; import java . util . Comparator ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; public class ExpressionListComparator implements Comparator < Exchange > { private final List < Expression > expressions ; public ExpressionListComparator ( List < Expression > expressions ) { this . expressions = expressions ; } public int compare ( Exchange e1 , Exchange e2 ) { for ( Expression expression : expressions ) { Object o1 = expression . evaluate ( e1 ) ; Object o2 = expression . evaluate ( e2 ) ; int answer = ObjectHelper . compare ( o1 , o2 ) ; if ( answer != 0 ) { return answer ; } } return 0 ; } } 	0	['3', '1', '0', '4', '9', '1', '1', '3', '3', '0', '47', '1', '0', '0', '0.5', '0', '0', '14.33333333', '2', '1', '0']
package org . apache . camel . component . jms ; import javax . jms . Destination ; import javax . jms . JMSException ; import javax . jms . Session ; import javax . jms . TemporaryQueue ; import org . springframework . jms . core . JmsOperations ; import org . springframework . jms . core . SessionCallback ; public class JmsTemporaryQueueEndpoint extends JmsQueueEndpoint implements DestinationEndpoint { private Destination jmsDestination ; public JmsTemporaryQueueEndpoint ( String uri , JmsComponent component , String destination , JmsConfiguration configuration ) { super ( uri , component , destination , configuration ) ; } public JmsTemporaryQueueEndpoint ( String uri , JmsComponent component , String destination , JmsConfiguration configuration , QueueBrowseStrategy queueBrowseStrategy ) { super ( uri , component , destination , configuration , queueBrowseStrategy ) ; } public JmsTemporaryQueueEndpoint ( String endpointUri , String destination ) { super ( endpointUri , destination ) ; } public boolean isSingleton ( ) { return true ; } public synchronized Destination getJmsDestination ( Session session ) throws JMSException { if ( jmsDestination == null ) { jmsDestination = createJmsDestination ( session ) ; } return jmsDestination ; } protected Destination createJmsDestination ( Session session ) throws JMSException { return session . createTemporaryQueue ( ) ; } } 	0	['6', '4', '0', '5', '10', '15', '1', '5', '5', '1', '43', '1', '0', '0.950819672', '0.444444444', '0', '0', '6', '1', '0.5', '0']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "php" ) public class PhpExpression extends ExpressionType { public PhpExpression ( ) { } public PhpExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "php" ; } } 	0	['3', '2', '0', '1', '5', '3', '0', '1', '3', '2', '12', '0', '0', '0.956521739', '0.666666667', '1', '2', '3', '1', '0.3333', '0']
package org . apache . camel . spi ; import org . apache . camel . CamelContext ; public interface LanguageResolver { Language resolveLanguage ( String name , CamelContext context ) ; } 	0	['1', '1', '0', '7', '1', '0', '5', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . util ; import java . beans . PropertyEditor ; import java . beans . PropertyEditorManager ; import java . lang . reflect . Field ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . net . URI ; import java . net . URISyntaxException ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Iterator ; import java . util . LinkedHashMap ; import java . util . LinkedHashSet ; import java . util . Map ; import java . util . Set ; import org . apache . camel . NoTypeConversionAvailableException ; import org . apache . camel . TypeConverter ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public final class IntrospectionSupport { private static final transient Log LOG = LogFactory . getLog ( IntrospectionSupport . class ) ; private IntrospectionSupport ( ) { } public static boolean getProperties ( Object target , Map props , String optionPrefix ) { boolean rc = false ; if ( target == null ) { throw new IllegalArgumentException ( "target was null." ) ; } if ( props == null ) { throw new IllegalArgumentException ( "props was null." ) ; } if ( optionPrefix == null ) { optionPrefix = "" ; } Class clazz = target . getClass ( ) ; Method [ ] methods = clazz . getMethods ( ) ; for ( Method method : methods ) { String name = method . getName ( ) ; Class type = method . getReturnType ( ) ; Class params [ ] = method . getParameterTypes ( ) ; if ( name . startsWith ( "get" ) && params . length == 0 && type != null && isSettableType ( type ) ) { try { Object value = method . invoke ( target ) ; if ( value == null ) { continue ; } String strValue = convertToString ( value , type ) ; if ( strValue == null ) { continue ; } name = name . substring ( 3 , 4 ) . toLowerCase ( ) + name . substring ( 4 ) ; props . put ( optionPrefix + name , strValue ) ; rc = true ; } catch ( Throwable ignore ) { } } } return rc ; } public static Object getProperty ( Object target , String prop ) throws SecurityException , NoSuchMethodException , IllegalArgumentException , IllegalAccessException , InvocationTargetException { if ( target == null ) { throw new IllegalArgumentException ( "target was null." ) ; } if ( prop == null ) { throw new IllegalArgumentException ( "prop was null." ) ; } prop = prop . substring ( 0 , 1 ) . toUpperCase ( ) + prop . substring ( 1 ) ; Class clazz = target . getClass ( ) ; Method method = getPropertyGetter ( clazz , prop ) ; return method . invoke ( target ) ; } public static Method getPropertyGetter ( Class type , String propertyName ) throws NoSuchMethodException { Method method = type . getMethod ( "get" + ObjectHelper . capitalize ( propertyName ) ) ; return method ; } public static boolean setProperties ( Object target , Map props , String optionPrefix ) throws Exception { boolean rc = false ; if ( target == null ) { throw new IllegalArgumentException ( "target was null." ) ; } if ( props == null ) { throw new IllegalArgumentException ( "props was null." ) ; } for ( Iterator iter = props . keySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { String name = ( String ) iter . next ( ) ; if ( name . startsWith ( optionPrefix ) ) { Object value = props . get ( name ) ; name = name . substring ( optionPrefix . length ( ) ) ; if ( setProperty ( target , name , value ) ) { iter . remove ( ) ; rc = true ; } } } return rc ; } public static Map extractProperties ( Map props , String optionPrefix ) { if ( props == null ) { throw new IllegalArgumentException ( "props was null." ) ; } HashMap rc = new HashMap ( props . size ( ) ) ; for ( Iterator iter = props . keySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { String name = ( String ) iter . next ( ) ; if ( name . startsWith ( optionPrefix ) ) { Object value = props . get ( name ) ; name = name . substring ( optionPrefix . length ( ) ) ; rc . put ( name , value ) ; iter . remove ( ) ; } } return rc ; } public static boolean setProperties ( TypeConverter typeConverter , Object target , Map props ) throws Exception { boolean rc = false ; if ( target == null ) { throw new IllegalArgumentException ( "target was null." ) ; } if ( props == null ) { throw new IllegalArgumentException ( "props was null." ) ; } for ( Iterator iter = props . entrySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) iter . next ( ) ; if ( setProperty ( typeConverter , target , ( String ) entry . getKey ( ) , entry . getValue ( ) ) ) { iter . remove ( ) ; rc = true ; } } return rc ; } public static boolean setProperties ( Object target , Map props ) throws Exception { return setProperties ( null , target , props ) ; } public static boolean setProperty ( TypeConverter typeConverter , Object target , String name , Object value ) throws Exception { try { Class clazz = target . getClass ( ) ; Set < Method > setters = findSetterMethods ( typeConverter , clazz , name , value ) ; if ( setters . isEmpty ( ) ) { return false ; } Exception typeConvertionFailed = null ; for ( Method setter : setters ) { if ( value == null || setter . getParameterTypes ( ) [ 0 ] . isAssignableFrom ( value . getClass ( ) ) ) { setter . invoke ( target , value ) ; return true ; } else { try { Object convertedValue = convert ( typeConverter , setter . getParameterTypes ( ) [ 0 ] , value ) ; setter . invoke ( target , convertedValue ) ; return true ; } catch ( NoTypeConversionAvailableException e ) { typeConvertionFailed = e ; } catch ( IllegalArgumentException e ) { typeConvertionFailed = e ; } LOG . trace ( "Setter \"" + setter + "\" with parameter type \"" + setter . getParameterTypes ( ) [ 0 ] + "\" could not be used for type conertions of " + value ) ; } } if ( typeConvertionFailed != null ) { throw new IllegalArgumentException ( "Could not find a suitable setter for property: " + name + " as there isn't a setter method with same type: " + value . getClass ( ) . getCanonicalName ( ) + " nor type convertion possbile: " + typeConvertionFailed . getMessage ( ) ) ; } else { return false ; } } catch ( InvocationTargetException e ) { Throwable throwable = e . getCause ( ) ; if ( throwable instanceof Exception ) { Exception exception = ( Exception ) throwable ; throw exception ; } else { Error error = ( Error ) throwable ; throw error ; } } } public static boolean setProperty ( Object target , String name , Object value ) throws Exception { return setProperty ( null , target , name , value ) ; } private static Object convert ( TypeConverter typeConverter , Class type , Object value ) throws URISyntaxException { if ( typeConverter != null ) { return typeConverter . convertTo ( type , value ) ; } PropertyEditor editor = PropertyEditorManager . findEditor ( type ) ; if ( editor != null ) { editor . setAsText ( value . toString ( ) ) ; return editor . getValue ( ) ; } if ( type == URI . class ) { return new URI ( value . toString ( ) ) ; } return null ; } private static String convertToString ( Object value , Class type ) throws URISyntaxException { PropertyEditor editor = PropertyEditorManager . findEditor ( type ) ; if ( editor != null ) { editor . setValue ( value ) ; return editor . getAsText ( ) ; } if ( type == URI . class ) { return value . toString ( ) ; } return null ; } private static Set < Method > findSetterMethods ( TypeConverter typeConverter , Class clazz , String name , Object value ) { Set < Method > candidates = new LinkedHashSet < Method > ( ) ; name = "set" + ObjectHelper . capitalize ( name ) ; while ( clazz != Object . class ) { Method objectSetMethod = null ; Method [ ] methods = clazz . getMethods ( ) ; for ( Method method : methods ) { Class params [ ] = method . getParameterTypes ( ) ; if ( method . getName ( ) . equals ( name ) && params . length == 1 ) { Class paramType = params [ 0 ] ; if ( paramType . equals ( Object . class ) ) { objectSetMethod = method ; } else if ( typeConverter != null || isSettableType ( paramType ) || paramType . isInstance ( value ) ) { candidates . add ( method ) ; } } } if ( objectSetMethod != null ) { candidates . add ( objectSetMethod ) ; } clazz = clazz . getSuperclass ( ) ; } if ( candidates . isEmpty ( ) ) { return candidates ; } else if ( candidates . size ( ) == 1 ) { return candidates ; } else { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Found " + candidates . size ( ) + " suitable setter methods for setting " + name ) ; } for ( Method method : candidates ) { if ( method . getParameterTypes ( ) [ 0 ] . isInstance ( value ) ) { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Method " + method + " is the best candidate as it has parameter with same instance type" ) ; } candidates . clear ( ) ; candidates . add ( method ) ; return candidates ; } } return candidates ; } } private static boolean isSettableType ( Class clazz ) { if ( PropertyEditorManager . findEditor ( clazz ) != null ) { return true ; } if ( clazz == URI . class ) { return true ; } if ( clazz == Boolean . class ) { return true ; } return false ; } public static String toString ( Object target ) { return toString ( target , Object . class ) ; } public static String toString ( Object target , Class stopClass ) { LinkedHashMap map = new LinkedHashMap ( ) ; addFields ( target , target . getClass ( ) , stopClass , map ) ; StringBuffer buffer = new StringBuffer ( simpleName ( target . getClass ( ) ) ) ; buffer . append ( " {" ) ; Set entrySet = map . entrySet ( ) ; boolean first = true ; for ( Iterator iter = entrySet . iterator ( ) ; iter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) iter . next ( ) ; if ( first ) { first = false ; } else { buffer . append ( ", " ) ; } buffer . append ( entry . getKey ( ) ) ; buffer . append ( " = " ) ; appendToString ( buffer , entry . getValue ( ) ) ; } buffer . append ( "}" ) ; return buffer . toString ( ) ; } protected static void appendToString ( StringBuffer buffer , Object value ) { buffer . append ( value ) ; } public static String simpleName ( Class clazz ) { String name = clazz . getName ( ) ; int p = name . lastIndexOf ( "." ) ; if ( p >= 0 ) { name = name . substring ( p + 1 ) ; } return name ; } private static void addFields ( Object target , Class startClass , Class stopClass , LinkedHashMap map ) { if ( startClass != stopClass ) { addFields ( target , startClass . getSuperclass ( ) , stopClass , map ) ; } Field [ ] fields = startClass . getDeclaredFields ( ) ; for ( Field field : fields ) { if ( Modifier . isStatic ( field . getModifiers ( ) ) || Modifier . isTransient ( field . getModifiers ( ) ) || Modifier . isPrivate ( field . getModifiers ( ) ) ) { continue ; } try { field . setAccessible ( true ) ; Object o = field . get ( target ) ; if ( o != null && o . getClass ( ) . isArray ( ) ) { try { o = Arrays . asList ( ( Object [ ] ) o ) ; } catch ( Throwable e ) { } } map . put ( field . getName ( ) , o ) ; } catch ( Throwable e ) { LOG . debug ( "Error adding fields" , e ) ; } } } } 	0	['20', '1', '0', '20', '98', '178', '15', '5', '12', '0.631578947', '880', '1', '0', '0', '0.276315789', '0', '0', '42.95', '15', '2.85', '0']
package org . apache . camel . component . mina ; import org . apache . camel . CamelExchangeException ; import org . apache . camel . Exchange ; import org . apache . mina . common . IoSession ; import org . apache . mina . common . WriteFuture ; public final class MinaHelper { private MinaHelper ( ) { } public static void writeBody ( IoSession session , Object body , Exchange exchange ) throws CamelExchangeException { WriteFuture future = session . write ( body ) ; future . join ( ) ; if ( ! future . isWritten ( ) ) { throw new CamelExchangeException ( "Could not write body" , exchange ) ; } } } 	0	['2', '1', '0', '6', '7', '1', '2', '4', '1', '2', '21', '0', '0', '0', '0.5', '0', '0', '9.5', '1', '0.5', '0']
package org . apache . camel ; public interface TypeConverter { < T > T convertTo ( Class < T > type , Object value ) ; < T > T convertTo ( Class < T > type , Exchange exchange , Object value ) ; } 	0	['2', '1', '0', '38', '2', '1', '37', '1', '2', '2', '2', '0', '0', '0', '0.875', '0', '0', '0', '1', '1', '0']
package org . apache . camel . impl . converter ; import java . lang . reflect . Method ; import org . apache . camel . Exchange ; import org . apache . camel . TypeConverter ; import org . apache . camel . util . ObjectHelper ; public class StaticMethodTypeConverter implements TypeConverter { private final Method method ; private final boolean useExchange ; public StaticMethodTypeConverter ( Method method ) { this . method = method ; this . useExchange = method . getParameterTypes ( ) . length == 2 ; } @ Override public String toString ( ) { return "StaticMethodTypeConverter: " + method ; } public < T > T convertTo ( Class < T > type , Object value ) { return convertTo ( type , null , value ) ; } public < T > T convertTo ( Class < T > type , Exchange exchange , Object value ) { return useExchange ? ( T ) ObjectHelper . invokeMethod ( method , null , value , exchange ) : ( T ) ObjectHelper . invokeMethod ( method , null , value ) ; } } 	0	['4', '1', '0', '4', '11', '0', '1', '3', '4', '0.166666667', '67', '1', '0', '0', '0.5', '0', '0', '15.25', '2', '1', '0']
package org . apache . camel . component . dataset ; import org . apache . camel . Exchange ; public interface DataSet { String INDEX_HEADER = "camelDataSetIndex" ; void populateMessage ( Exchange exchange , long messageIndex ) throws Exception ; long getSize ( ) ; void assertMessageExpected ( DataSetEndpoint dataSetEndpoint , Exchange expected , Exchange actual , long index ) throws Exception ; long getReportCount ( ) ; } 	0	['4', '1', '0', '6', '4', '6', '5', '2', '4', '1.333333333', '5', '0', '0', '0', '0.5625', '0', '0', '0', '1', '1', '0']
package org . apache . camel . util ; import org . apache . camel . spi . Injector ; public class ReflectionInjector implements Injector { public < T > T newInstance ( Class < T > type ) { return ObjectHelper . newInstance ( type ) ; } } 	0	['2', '1', '0', '4', '4', '1', '2', '2', '2', '2', '8', '0', '0', '0', '0.75', '0', '0', '3', '1', '0.5', '0']
package org . apache . camel . component . atom ; import org . apache . abdera . model . Document ; import org . apache . abdera . model . Feed ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public class AtomPollingConsumer extends AtomConsumerSupport { public AtomPollingConsumer ( AtomEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; } protected void poll ( ) throws Exception { Document < Feed > document = AtomUtils . parseDocument ( endpoint . getAtomUri ( ) ) ; Feed feed = document . getRoot ( ) ; Exchange exchange = endpoint . createExchange ( feed ) ; getProcessor ( ) . process ( exchange ) ; } } 	0	['2', '5', '1', '9', '9', '1', '2', '8', '1', '2', '26', '0', '0', '0.972222222', '0.666666667', '1', '1', '12', '1', '0.5', '0']
package org . apache . camel . bam . processor ; import java . lang . reflect . Method ; import java . util . List ; import java . util . concurrent . locks . Lock ; import java . util . concurrent . locks . ReentrantLock ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . bam . model . ProcessDefinition ; import org . apache . camel . bam . rules . ActivityRules ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . orm . jpa . JpaTemplate ; import org . springframework . transaction . support . TransactionTemplate ; public class JpaBamProcessorSupport < T > extends BamProcessorSupport < T > { private static final transient Log LOG = LogFactory . getLog ( JpaBamProcessorSupport . class ) ; private static final Lock LOCK = new ReentrantLock ( ) ; private ActivityRules activityRules ; private JpaTemplate template ; private String findByKeyQuery ; private String keyPropertyName = "correlationKey" ; private boolean correlationKeyIsPrimary = true ; public JpaBamProcessorSupport ( TransactionTemplate transactionTemplate , JpaTemplate template , Expression < Exchange > correlationKeyExpression , ActivityRules activityRules , Class < T > entitytype ) { super ( transactionTemplate , correlationKeyExpression , entitytype ) ; this . activityRules = activityRules ; this . template = template ; } public JpaBamProcessorSupport ( TransactionTemplate transactionTemplate , JpaTemplate template , Expression < Exchange > correlationKeyExpression , ActivityRules activityRules ) { super ( transactionTemplate , correlationKeyExpression ) ; this . activityRules = activityRules ; this . template = template ; } public String getFindByKeyQuery ( ) { if ( findByKeyQuery == null ) { findByKeyQuery = createFindByKeyQuery ( ) ; } return findByKeyQuery ; } public void setFindByKeyQuery ( String findByKeyQuery ) { this . findByKeyQuery = findByKeyQuery ; } public ActivityRules getActivityRules ( ) { return activityRules ; } public void setActivityRules ( ActivityRules activityRules ) { this . activityRules = activityRules ; } public String getKeyPropertyName ( ) { return keyPropertyName ; } public void setKeyPropertyName ( String keyPropertyName ) { this . keyPropertyName = keyPropertyName ; } public JpaTemplate getTemplate ( ) { return template ; } public void setTemplate ( JpaTemplate template ) { this . template = template ; } public boolean isCorrelationKeyIsPrimary ( ) { return correlationKeyIsPrimary ; } public void setCorrelationKeyIsPrimary ( boolean correlationKeyIsPrimary ) { this . correlationKeyIsPrimary = correlationKeyIsPrimary ; } protected T loadEntity ( Exchange exchange , Object key ) throws Exception { LOCK . lock ( ) ; try { T entity = findEntityByCorrelationKey ( key ) ; if ( entity == null ) { entity = createEntity ( exchange , key ) ; setKeyProperty ( entity , key ) ; ProcessDefinition definition = ProcessDefinition . getRefreshedProcessDefinition ( template , getActivityRules ( ) . getProcessRules ( ) . getProcessDefinition ( ) ) ; setProcessDefinitionProperty ( entity , definition ) ; template . persist ( entity ) ; LOG . debug ( "About to flush on entity: " + entity + " with key: " + key ) ; template . flush ( ) ; } return entity ; } finally { LOCK . unlock ( ) ; } } protected T findEntityByCorrelationKey ( Object key ) { if ( isCorrelationKeyIsPrimary ( ) ) { return template . find ( getEntityType ( ) , key ) ; } else { List < T > list = template . find ( getFindByKeyQuery ( ) , key ) ; if ( list . isEmpty ( ) ) { return null ; } else { return list . get ( 0 ) ; } } } protected Class getKeyType ( ) { try { Method getter = IntrospectionSupport . getPropertyGetter ( getEntityType ( ) , getKeyPropertyName ( ) ) ; return getter . getReturnType ( ) ; } catch ( NoSuchMethodException e ) { LOG . warn ( "no such getter for: " + getKeyPropertyName ( ) + " on " + getEntityType ( ) + ". Reason: " + e , e ) ; return null ; } } protected void setKeyProperty ( T entity , Object key ) throws Exception { IntrospectionSupport . setProperty ( entity , getKeyPropertyName ( ) , key ) ; } protected void setProcessDefinitionProperty ( T entity , ProcessDefinition processDefinition ) throws Exception { IntrospectionSupport . setProperty ( entity , "processDefinition" , processDefinition ) ; } protected T createEntity ( Exchange exchange , Object key ) { return ( T ) exchange . getContext ( ) . getInjector ( ) . newInstance ( getEntityType ( ) ) ; } protected void processEntity ( Exchange exchange , T entity ) throws Exception { if ( entity instanceof Processor ) { Processor processor = ( Processor ) entity ; processor . process ( exchange ) ; } else { throw new IllegalArgumentException ( "No processor defined for this route" ) ; } } protected String createFindByKeyQuery ( ) { return "select x from " + getEntityType ( ) . getName ( ) + " x where x." + getKeyPropertyName ( ) + " = ?1" ; } } 	0	['21', '2', '1', '15', '52', '142', '1', '14', '12', '0.828571429', '292', '1', '1', '0.333333333', '0.2', '1', '2', '12.57142857', '3', '1', '0']
package org . apache . camel . component . dataset ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . util . CamelContextHelper ; public class DataSetComponent extends DefaultComponent < Exchange > { @ Override protected Endpoint < Exchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { DataSet dataSet = CamelContextHelper . mandatoryLookup ( getCamelContext ( ) , remaining , DataSet . class ) ; return new DataSetEndpoint ( uri , this , dataSet ) ; } } 	0	['2', '3', '0', '7', '6', '1', '0', '7', '1', '2', '19', '0', '0', '0.972222222', '0.666666667', '1', '1', '8.5', '1', '0.5', '0']
package org . apache . camel . builder . xml ; public class DomResultHandlerFactory implements ResultHandlerFactory { public ResultHandler createResult ( ) { return new DomResultHandler ( ) ; } } 	0	['2', '1', '0', '4', '4', '1', '1', '3', '2', '2', '9', '0', '0', '0', '1', '0', '0', '3.5', '1', '0.5', '0']
package org . apache . camel . component . bean ; import java . lang . reflect . Method ; import java . util . Map ; import org . apache . camel . CamelContext ; import org . apache . camel . util . LRUCache ; public class MethodInfoCache { private final CamelContext camelContext ; private Map < Method , MethodInfo > methodCache ; private Map < Class , BeanInfo > classCache ; public MethodInfoCache ( CamelContext camelContext ) { this ( camelContext , 1000 , 10000 ) ; } public MethodInfoCache ( CamelContext camelContext , int classCacheSize , int methodCacheSize ) { this ( camelContext , createLruCache ( classCacheSize ) , createLruCache ( methodCacheSize ) ) ; } public MethodInfoCache ( CamelContext camelContext , Map < Class , BeanInfo > classCache , Map < Method , MethodInfo > methodCache ) { this . camelContext = camelContext ; this . classCache = classCache ; this . methodCache = methodCache ; } public synchronized MethodInfo getMethodInfo ( Method method ) { MethodInfo answer = methodCache . get ( method ) ; if ( answer == null ) { answer = createMethodInfo ( method ) ; methodCache . put ( method , answer ) ; } return answer ; } protected MethodInfo createMethodInfo ( Method method ) { Class < ? > declaringClass = method . getDeclaringClass ( ) ; BeanInfo info = getBeanInfo ( declaringClass ) ; return info . getMethodInfo ( method ) ; } protected synchronized BeanInfo getBeanInfo ( Class < ? > declaringClass ) { BeanInfo beanInfo = classCache . get ( declaringClass ) ; if ( beanInfo == null ) { beanInfo = createBeanInfo ( declaringClass ) ; classCache . put ( declaringClass , beanInfo ) ; } return beanInfo ; } protected BeanInfo createBeanInfo ( Class < ? > declaringClass ) { return new BeanInfo ( camelContext , declaringClass ) ; } protected static Map createLruCache ( int size ) { return new LRUCache ( size ) ; } } 	0	['8', '1', '0', '7', '15', '22', '3', '4', '4', '0.619047619', '100', '1', '1', '0', '0.354166667', '0', '0', '11.125', '2', '0.875', '0']
package org . apache . camel . component . quartz ; import java . util . Map ; import org . apache . camel . impl . DefaultMessage ; import org . quartz . JobExecutionContext ; import org . quartz . Trigger ; public class QuartzMessage extends DefaultMessage { private final JobExecutionContext jobExecutionContext ; public QuartzMessage ( QuartzExchange exchange , JobExecutionContext jobExecutionContext ) { this . jobExecutionContext = jobExecutionContext ; setExchange ( exchange ) ; if ( jobExecutionContext != null ) { setBody ( jobExecutionContext . getJobDetail ( ) ) ; } } public JobExecutionContext getJobExecutionContext ( ) { return jobExecutionContext ; } @ Override protected void populateInitialHeaders ( Map < String , Object > map ) { super . populateInitialHeaders ( map ) ; if ( jobExecutionContext != null ) { map . put ( "calendar" , jobExecutionContext . getCalendar ( ) ) ; map . put ( "fireTime" , jobExecutionContext . getFireTime ( ) ) ; map . put ( "jobDetail" , jobExecutionContext . getJobDetail ( ) ) ; map . put ( "jobInstance" , jobExecutionContext . getJobInstance ( ) ) ; map . put ( "jobRunTime" , jobExecutionContext . getJobRunTime ( ) ) ; map . put ( "mergedJobDataMap" , jobExecutionContext . getMergedJobDataMap ( ) ) ; map . put ( "nextFireTime" , jobExecutionContext . getNextFireTime ( ) ) ; map . put ( "previousFireTime" , jobExecutionContext . getPreviousFireTime ( ) ) ; map . put ( "refireCount" , jobExecutionContext . getRefireCount ( ) ) ; map . put ( "result" , jobExecutionContext . getResult ( ) ) ; map . put ( "scheduledFireTime" , jobExecutionContext . getScheduledFireTime ( ) ) ; map . put ( "scheduler" , jobExecutionContext . getScheduler ( ) ) ; Trigger trigger = jobExecutionContext . getTrigger ( ) ; map . put ( "trigger" , trigger ) ; map . put ( "triggerName" , trigger . getName ( ) ) ; map . put ( "triggerGroup" , trigger . getGroup ( ) ) ; } } } 	0	['3', '3', '0', '10', '25', '0', '1', '10', '2', '0', '136', '1', '0', '0.945945946', '0.5', '1', '1', '44', '2', '1', '0']
package org . apache . camel . component . mina ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; import org . apache . mina . common . IoSession ; public class MinaExchange extends DefaultExchange { private IoSession session ; public MinaExchange ( CamelContext camelContext , ExchangePattern pattern , IoSession session ) { super ( camelContext , pattern ) ; this . session = session ; } public MinaExchange ( DefaultExchange parent , IoSession session ) { super ( parent ) ; this . session = session ; } public IoSession getSession ( ) { return session ; } @ Override public Exchange newInstance ( ) { return new MinaExchange ( this , getSession ( ) ) ; } } 	0	['4', '2', '0', '7', '6', '0', '2', '5', '4', '0', '30', '1', '0', '0.95', '0.45', '1', '1', '6.25', '1', '0.5', '0']
package org . apache . camel . component . jpa ; import javax . persistence . EntityManager ; import javax . persistence . EntityManagerFactory ; import javax . persistence . EntityTransaction ; import org . apache . camel . impl . ServiceSupport ; import org . springframework . orm . jpa . JpaCallback ; import static org . apache . camel . util . ObjectHelper . notNull ; public class DefaultTransactionStrategy extends ServiceSupport implements TransactionStrategy { private EntityManagerFactory entityManagerFactory ; private EntityManager entityManager ; public DefaultTransactionStrategy ( EntityManagerFactory entityManagerFactory ) { notNull ( entityManagerFactory , "entityManagerFactory" ) ; this . entityManagerFactory = entityManagerFactory ; } public DefaultTransactionStrategy ( EntityManager entityManager ) { notNull ( entityManager , "entityManager" ) ; this . entityManager = entityManager ; } public Object execute ( JpaCallback callback ) { EntityManager em = getEntityManager ( ) ; EntityTransaction transaction = em . getTransaction ( ) ; transaction . begin ( ) ; try { Object answer = callback . doInJpa ( em ) ; transaction . commit ( ) ; return answer ; } catch ( RuntimeException e ) { if ( transaction != null ) { transaction . rollback ( ) ; } throw e ; } } public EntityManager getEntityManager ( ) { if ( entityManager == null ) { entityManager = entityManagerFactory . createEntityManager ( ) ; } return entityManager ; } protected void doStart ( ) throws Exception { getEntityManager ( ) ; } protected void doStop ( ) throws Exception { if ( entityManager != null ) { entityManager . close ( ) ; } } } 	0	['6', '2', '0', '4', '15', '7', '0', '4', '4', '0.3', '71', '1', '0', '0.777777778', '0.375', '1', '1', '10.5', '2', '1', '0']
package org . apache . camel . language . simple ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . builder . ExpressionBuilder ; import org . apache . camel . builder . PredicateBuilder ; import org . apache . camel . spi . Language ; public abstract class AbstractSimpleLanguage implements Language { public Predicate < Exchange > createPredicate ( String expression ) { return PredicateBuilder . toPredicate ( createExpression ( expression ) ) ; } public Expression < Exchange > createExpression ( String expression ) { if ( expression . indexOf ( "${" ) >= 0 ) { return createComplexExpression ( expression ) ; } return createSimpleExpression ( expression ) ; } protected Expression < Exchange > createComplexExpression ( String expression ) { List < Expression > results = new ArrayList < Expression > ( ) ; int pivot = 0 ; int size = expression . length ( ) ; while ( pivot < size ) { int idx = expression . indexOf ( "${" , pivot ) ; if ( idx < 0 ) { results . add ( createConstantExpression ( expression , pivot , size ) ) ; break ; } else { if ( pivot < idx ) { results . add ( createConstantExpression ( expression , pivot , idx ) ) ; } pivot = idx + 2 ; int endIdx = expression . indexOf ( "}" , pivot ) ; if ( endIdx < 0 ) { throw new IllegalArgumentException ( "Expecting } but found end of string for simple expression: " + expression ) ; } String simpleText = expression . substring ( pivot , endIdx ) ; Expression simpleExpression = createSimpleExpression ( simpleText ) ; results . add ( simpleExpression ) ; pivot = endIdx + 1 ; } } return ExpressionBuilder . concatExpression ( results , expression ) ; } protected Expression createConstantExpression ( String expression , int start , int end ) { return ExpressionBuilder . constantExpression ( expression . substring ( start , end ) ) ; } protected abstract < E extends Exchange > Expression < Exchange > createSimpleExpression ( String expression ) ; protected String ifStartsWithReturnRemainder ( String prefix , String text ) { if ( text . startsWith ( prefix ) ) { String remainder = text . substring ( prefix . length ( ) ) ; if ( remainder . length ( ) > 0 ) { return remainder ; } } return null ; } } 	0	['7', '1', '2', '7', '23', '21', '2', '5', '3', '2', '133', '0', '0', '0', '0.666666667', '0', '0', '18', '5', '1.8571', '0']
package org . apache . camel . language ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . PARAMETER } ) @ LanguageAnnotation ( language = "simple" ) public @ interface Simple { String value ( ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . impl ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Exchange ; import org . apache . camel . spi . ComponentResolver ; import org . apache . camel . util . FactoryFinder ; import org . apache . camel . util . NoFactoryAvailableException ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DefaultComponentResolver < E extends Exchange > implements ComponentResolver < E > { protected static final FactoryFinder COMPONENT_FACTORY = new FactoryFinder ( "META-INF/services/org/apache/camel/component/" ) ; private static final transient Log LOG = LogFactory . getLog ( DefaultComponentResolver . class ) ; public Component < E > resolveComponent ( String name , CamelContext context ) { Object bean = null ; try { bean = context . getRegistry ( ) . lookup ( name ) ; if ( bean != null && LOG . isDebugEnabled ( ) ) { LOG . debug ( "Found component: " + name + " in registry: " + bean ) ; } } catch ( Exception e ) { LOG . debug ( "Ignored error looking up bean: " + name + ". Error: " + e ) ; } if ( bean != null ) { if ( bean instanceof Component ) { return ( Component ) bean ; } } Class type ; try { type = COMPONENT_FACTORY . findClass ( name ) ; } catch ( NoFactoryAvailableException e ) { return null ; } catch ( Throwable e ) { throw new IllegalArgumentException ( "Invalid URI, no Component registered for scheme : " + name , e ) ; } if ( type == null ) { return null ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Found component: " + name + " via type: " + type . getName ( ) + " via " + COMPONENT_FACTORY . getPath ( ) + name ) ; } if ( Component . class . isAssignableFrom ( type ) ) { return ( Component < E > ) context . getInjector ( ) . newInstance ( type ) ; } else { throw new IllegalArgumentException ( "Type is not a Component implementation. Found: " + type . getName ( ) ) ; } } } 	0	['3', '1', '0', '10', '22', '1', '1', '9', '2', '0.5', '141', '1', '1', '0', '0.666666667', '0', '0', '45.33333333', '6', '2', '0']
package org . apache . camel . management ; public final class JmxSystemPropertyKeys { public static final String DISABLED = "org.apache.camel.jmx.disabled" ; public static final String REGISTRY_PORT = "org.apache.camel.jmx.rmiConnector.registryPort" ; public static final String CONNECTOR_PORT = "org.apache.camel.jmx.rmiConnector.connectorPort" ; public static final String DOMAIN = "org.apache.camel.jmx.mbeanServerDefaultDomain" ; public static final String MBEAN_DOMAIN = "org.apache.camel.jmx.mbeanObjectDomainName" ; public static final String SERVICE_URL_PATH = "org.apache.camel.jmx.serviceUrlPath" ; public static final String CREATE_CONNECTOR = "org.apache.camel.jmx.createRmiConnector" ; public static final String USE_PLATFORM_MBS = "org.apache.camel.jmx.usePlatformMBeanServer" ; private JmxSystemPropertyKeys ( ) { } } 	0	['1', '1', '0', '0', '2', '0', '0', '0', '0', '2', '12', '0', '0', '0', '1', '0', '0', '3', '0', '0', '0']
package org . apache . camel . processor . aggregate ; import org . apache . camel . Exchange ; public interface AggregationStrategy { Exchange aggregate ( Exchange oldExchange , Exchange newExchange ) ; } 	0	['1', '1', '0', '16', '1', '0', '15', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . model . config . BatchResequencerConfig ; import org . apache . camel . model . config . StreamResequencerConfig ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . Resequencer ; import org . apache . camel . processor . StreamResequencer ; import org . apache . camel . processor . resequencer . ExpressionResultComparator ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "resequencer" ) public class ResequencerType extends ProcessorType < ProcessorType > { @ XmlElementRef private List < ExpressionType > expressions = new ArrayList < ExpressionType > ( ) ; @ XmlElementRef private List < ProcessorType < ? > > outputs = new ArrayList < ProcessorType < ? > > ( ) ; private BatchResequencerConfig batchConfig ; private StreamResequencerConfig streamConfig ; @ XmlTransient private List < Expression > expressionList ; public ResequencerType ( ) { this ( null ) ; } public ResequencerType ( List < Expression > expressions ) { this . expressionList = expressions ; this . batch ( ) ; } @ Override public String getShortName ( ) { return "resequencer" ; } public ResequencerType stream ( ) { return stream ( StreamResequencerConfig . getDefault ( ) ) ; } public ResequencerType batch ( ) { return batch ( BatchResequencerConfig . getDefault ( ) ) ; } public ResequencerType stream ( StreamResequencerConfig config ) { this . streamConfig = config ; this . batchConfig = null ; return this ; } public ResequencerType batch ( BatchResequencerConfig config ) { this . batchConfig = config ; this . streamConfig = null ; return this ; } public ResequencerType expression ( ExpressionType expression ) { expressions . add ( expression ) ; return this ; } @ Override public String toString ( ) { return "Resequencer[" + getExpressions ( ) + " -> " + getOutputs ( ) + "]" ; } @ Override public String getLabel ( ) { return ExpressionType . getLabel ( getExpressions ( ) ) ; } public List < ExpressionType > getExpressions ( ) { return expressions ; } public List < ProcessorType < ? > > getOutputs ( ) { return outputs ; } public void setOutputs ( List < ProcessorType < ? > > outputs ) { this . outputs = outputs ; } public BatchResequencerConfig getBatchConfig ( ) { return batchConfig ; } public BatchResequencerConfig getBatchConfig ( BatchResequencerConfig defaultConfig ) { return batchConfig ; } public StreamResequencerConfig getStreamConfig ( ) { return streamConfig ; } @ XmlElement ( name = "batch-config" , required = false ) public void setBatchConfig ( BatchResequencerConfig batchConfig ) { batch ( batchConfig ) ; } @ XmlElement ( name = "stream-config" , required = false ) public void setStreamConfig ( StreamResequencerConfig streamConfig ) { stream ( streamConfig ) ; } public ResequencerType timeout ( long timeout ) { if ( batchConfig != null ) { batchConfig . setBatchTimeout ( timeout ) ; } else { streamConfig . setTimeout ( timeout ) ; } return this ; } public ResequencerType size ( int batchSize ) { if ( batchConfig == null ) { throw new IllegalStateException ( "size() only supported for batch resequencer" ) ; } batchConfig . setBatchSize ( batchSize ) ; return this ; } public ResequencerType capacity ( int capacity ) { if ( streamConfig == null ) { throw new IllegalStateException ( "capacity() only supported for stream resequencer" ) ; } streamConfig . setCapacity ( capacity ) ; return this ; } public ResequencerType comparator ( ExpressionResultComparator < Exchange > comparator ) { if ( streamConfig == null ) { throw new IllegalStateException ( "comparator() only supported for stream resequencer" ) ; } streamConfig . setComparator ( comparator ) ; return this ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { if ( batchConfig != null ) { return createBatchResequencer ( routeContext , batchConfig ) ; } else { return createStreamResequencer ( routeContext , streamConfig ) ; } } protected Resequencer createBatchResequencer ( RouteContext routeContext , BatchResequencerConfig config ) throws Exception { Processor processor = routeContext . createProcessor ( this ) ; Resequencer resequencer = new Resequencer ( processor , resolveExpressionList ( routeContext ) ) ; resequencer . setBatchSize ( config . getBatchSize ( ) ) ; resequencer . setBatchTimeout ( config . getBatchTimeout ( ) ) ; return resequencer ; } protected StreamResequencer createStreamResequencer ( RouteContext routeContext , StreamResequencerConfig config ) throws Exception { config . getComparator ( ) . setExpressions ( resolveExpressionList ( routeContext ) ) ; Processor processor = routeContext . createProcessor ( this ) ; StreamResequencer resequencer = new StreamResequencer ( processor , config . getComparator ( ) ) ; resequencer . setTimeout ( config . getTimeout ( ) ) ; resequencer . setCapacity ( config . getCapacity ( ) ) ; return resequencer ; } private List < Expression > resolveExpressionList ( RouteContext routeContext ) { if ( expressionList == null ) { expressionList = new ArrayList < Expression > ( ) ; for ( ExpressionType expression : expressions ) { expressionList . add ( expression . createExpression ( routeContext ) ) ; } } if ( expressionList . isEmpty ( ) ) { throw new IllegalArgumentException ( "No expressions configured for: " + this ) ; } return expressionList ; } } 	0	['26', '3', '0', '14', '61', '235', '4', '11', '23', '0.712', '303', '1', '2', '0.88', '0.188034188', '1', '3', '10.46153846', '4', '1.1923', '0']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "javaScript" ) public class JavaScriptExpression extends ExpressionType { public JavaScriptExpression ( ) { } public JavaScriptExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "js" ; } } 	0	['3', '2', '0', '1', '5', '3', '0', '1', '3', '2', '12', '0', '0', '0.956521739', '0.666666667', '1', '2', '3', '1', '0.3333', '0']
package org . apache . camel . component . xmpp ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . jivesoftware . smack . Chat ; import org . jivesoftware . smack . ChatManager ; import org . jivesoftware . smack . MessageListener ; import org . jivesoftware . smack . XMPPException ; import org . jivesoftware . smack . packet . Message ; public class XmppPrivateChatProducer extends DefaultProducer { private static final transient Log LOG = LogFactory . getLog ( XmppPrivateChatProducer . class ) ; private final XmppEndpoint endpoint ; private final String participant ; public XmppPrivateChatProducer ( XmppEndpoint endpoint , String participant ) { super ( endpoint ) ; this . endpoint = endpoint ; this . participant = participant ; if ( participant == null ) { throw new IllegalArgumentException ( "No participant property specified" ) ; } } public void process ( Exchange exchange ) { String threadId = exchange . getExchangeId ( ) ; try { ChatManager chatManager = endpoint . getConnection ( ) . getChatManager ( ) ; Chat chat = chatManager . getThreadChat ( threadId ) ; if ( chat == null ) { chat = chatManager . createChat ( getParticipant ( ) , threadId , new MessageListener ( ) { public void processMessage ( Chat chat , Message message ) { } } ) ; } Message message = new Message ( ) ; message . setTo ( participant ) ; message . setThread ( threadId ) ; message . setType ( Message . Type . normal ) ; endpoint . getBinding ( ) . populateXmppMessage ( message , exchange ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( ">>>> message: " + message . getBody ( ) ) ; } chat . sendMessage ( message ) ; } catch ( XMPPException e ) { throw new RuntimeXmppException ( e ) ; } } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; } @ Override protected void doStop ( ) throws Exception { super . doStop ( ) ; } public String getParticipant ( ) { return participant ; } } 	0	['6', '3', '0', '16', '31', '7', '2', '16', '3', '0.733333333', '108', '1', '1', '0.84', '0.4', '1', '1', '16.5', '3', '1', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlElements ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Processor ; import org . apache . camel . model . dataformat . ArtixDSDataFormat ; import org . apache . camel . model . dataformat . CsvDataFormat ; import org . apache . camel . model . dataformat . DataFormatType ; import org . apache . camel . model . dataformat . FlatpackDataFormat ; import org . apache . camel . model . dataformat . HL7DataFormat ; import org . apache . camel . model . dataformat . JaxbDataFormat ; import org . apache . camel . model . dataformat . SerializationDataFormat ; import org . apache . camel . model . dataformat . StringDataFormat ; import org . apache . camel . model . dataformat . XMLBeansDataFormat ; import org . apache . camel . model . dataformat . XStreamDataFormat ; import org . apache . camel . model . dataformat . ZipDataFormat ; import org . apache . camel . processor . MarshalProcessor ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "marshal" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class MarshalType extends OutputType < ProcessorType > { @ XmlAttribute ( required = false ) private String ref ; @ XmlElements ( { @ XmlElement ( required = false , name = "artixDS" , type = ArtixDSDataFormat . class ) , @ XmlElement ( required = false , name = "csv" , type = CsvDataFormat . class ) , @ XmlElement ( required = false , name = "flatpack" , type = FlatpackDataFormat . class ) , @ XmlElement ( required = false , name = "hl7" , type = HL7DataFormat . class ) , @ XmlElement ( required = false , name = "jaxb" , type = JaxbDataFormat . class ) , @ XmlElement ( required = false , name = "serialization" , type = SerializationDataFormat . class ) , @ XmlElement ( required = false , name = "string" , type = StringDataFormat . class ) , @ XmlElement ( required = false , name = "xmlBeans" , type = XMLBeansDataFormat . class ) , @ XmlElement ( required = false , name = "xstream" , type = XStreamDataFormat . class ) , @ XmlElement ( required = false , name = "zip" , type = ZipDataFormat . class ) } ) private DataFormatType dataFormatType ; public MarshalType ( ) { } public MarshalType ( DataFormatType dataFormatType ) { this . dataFormatType = dataFormatType ; } public MarshalType ( String ref ) { this . ref = ref ; } @ Override public String toString ( ) { if ( dataFormatType != null ) { return "Marshal[" + dataFormatType + "]" ; } else { return "Marshal[ref: " + ref + "]" ; } } @ Override public String getShortName ( ) { return "marshal" ; } public String getRef ( ) { return ref ; } public void setRef ( String ref ) { this . ref = ref ; } public DataFormatType getDataFormatType ( ) { return dataFormatType ; } public void setDataFormatType ( DataFormatType dataFormatType ) { this . dataFormatType = dataFormatType ; } @ Override public Processor createProcessor ( RouteContext routeContext ) { DataFormat dataFormat = DataFormatType . getDataFormat ( routeContext , getDataFormatType ( ) , ref ) ; return new MarshalProcessor ( dataFormat ) ; } } 	0	['10', '4', '0', '7', '17', '13', '1', '6', '10', '0.555555556', '82', '1', '1', '0.962365591', '0.375', '1', '1', '7', '2', '0.8', '0']
@ javax . xml . bind . annotation . XmlSchema ( namespace = "http://activemq.apache.org/camel/schema/spring" , elementFormDefault = javax . xml . bind . annotation . XmlNsForm . QUALIFIED ) package org . apache . camel . spring ; 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . component ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import org . apache . camel . Component ; import org . apache . camel . Processor ; import org . apache . camel . converter . IOConverter ; import org . apache . camel . impl . ProcessorEndpoint ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . core . io . DefaultResourceLoader ; import org . springframework . core . io . Resource ; import org . springframework . core . io . ResourceLoader ; public abstract class ResourceBasedEndpoint extends ProcessorEndpoint { protected final transient Log log = LogFactory . getLog ( getClass ( ) ) ; private final String resourceUri ; private ResourceLoader resourceLoader = new DefaultResourceLoader ( ) ; private Resource resource ; private boolean contentCache ; private byte [ ] buffer ; public ResourceBasedEndpoint ( String endpointUri , Component component , String resourceUri , Processor processor ) { super ( endpointUri , component , processor ) ; this . resourceUri = resourceUri ; } protected ResourceBasedEndpoint ( String endpointUri , Processor processor , String resourceUri ) { super ( endpointUri , processor ) ; this . resourceUri = resourceUri ; } public Resource getResource ( ) { if ( resource == null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Loading resource: " + resourceUri + " using: " + getResourceLoader ( ) ) ; } resource = getResourceLoader ( ) . getResource ( resourceUri ) ; if ( resource == null ) { throw new IllegalArgumentException ( "Could not find resource for URI: " + resourceUri + " using: " + getResourceLoader ( ) ) ; } } return resource ; } public boolean isContentCache ( ) { return contentCache ; } public void setContentCache ( boolean contentCache ) { this . contentCache = contentCache ; } public InputStream getResourceAsInputStream ( ) throws IOException { if ( resource == null ) { resource = getResource ( ) ; } if ( contentCache ) { synchronized ( resource ) { if ( buffer == null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Reading resource: " + resourceUri + " into the content cache" ) ; } buffer = IOConverter . toBytes ( resource . getInputStream ( ) ) ; } } if ( log . isDebugEnabled ( ) ) { log . debug ( "Using resource: " + resourceUri + " from the content cache" ) ; } return new ByteArrayInputStream ( buffer ) ; } return resource . getInputStream ( ) ; } public ResourceLoader getResourceLoader ( ) { return resourceLoader ; } public void setResourceLoader ( ResourceLoader resourceLoader ) { this . resourceLoader = resourceLoader ; } public String getResourceUri ( ) { return resourceUri ; } } 	0	['9', '5', '3', '12', '25', '0', '3', '9', '8', '0.6875', '202', '1', '0', '0.833333333', '0.296296296', '0', '0', '20.77777778', '4', '1.1111', '0']
package org . apache . camel . converter . jaxb ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import javax . xml . bind . JAXBContext ; import javax . xml . bind . JAXBElement ; import javax . xml . bind . JAXBException ; import javax . xml . bind . Marshaller ; import javax . xml . bind . Unmarshaller ; import org . apache . camel . Exchange ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . util . IOHelper ; public class JaxbDataFormat implements DataFormat { private JAXBContext context ; private String contextPath ; private boolean prettyPrint = true ; private boolean ignoreJAXBElement = true ; private Marshaller marshaller ; private Unmarshaller unmarshaller ; public JaxbDataFormat ( ) { } public JaxbDataFormat ( JAXBContext context ) { this . context = context ; } public JaxbDataFormat ( String contextPath ) { this . contextPath = contextPath ; } public void marshal ( Exchange exchange , Object graph , OutputStream stream ) throws IOException { try { getMarshaller ( ) . marshal ( graph , stream ) ; } catch ( JAXBException e ) { throw IOHelper . createIOException ( e ) ; } } public Object unmarshal ( Exchange exchange , InputStream stream ) throws IOException , ClassNotFoundException { try { Object answer = getUnmarshaller ( ) . unmarshal ( stream ) ; if ( answer instanceof JAXBElement && isIgnoreJAXBElement ( ) ) { answer = ( ( JAXBElement ) answer ) . getValue ( ) ; } return answer ; } catch ( JAXBException e ) { throw IOHelper . createIOException ( e ) ; } } public boolean isIgnoreJAXBElement ( ) { return ignoreJAXBElement ; } public void setIgnoreJAXBElement ( boolean flag ) { ignoreJAXBElement = flag ; } public JAXBContext getContext ( ) throws JAXBException { if ( context == null ) { context = createContext ( ) ; } return context ; } public void setContext ( JAXBContext context ) { this . context = context ; } public String getContextPath ( ) { return contextPath ; } public void setContextPath ( String contextPath ) { this . contextPath = contextPath ; } public Marshaller getMarshaller ( ) throws JAXBException { if ( marshaller == null ) { marshaller = getContext ( ) . createMarshaller ( ) ; } return marshaller ; } public void setMarshaller ( Marshaller marshaller ) { this . marshaller = marshaller ; } public boolean isPrettyPrint ( ) { return prettyPrint ; } public void setPrettyPrint ( boolean prettyPrint ) { this . prettyPrint = prettyPrint ; } public Unmarshaller getUnmarshaller ( ) throws JAXBException { if ( unmarshaller == null ) { unmarshaller = getContext ( ) . createUnmarshaller ( ) ; } return unmarshaller ; } public void setUnmarshaller ( Unmarshaller unmarshaller ) { this . unmarshaller = unmarshaller ; } protected JAXBContext createContext ( ) throws JAXBException { if ( contextPath != null ) { return JAXBContext . newInstance ( contextPath ) ; } else { return JAXBContext . newInstance ( ) ; } } } 	0	['18', '1', '0', '3', '27', '97', '0', '3', '17', '0.774509804', '165', '1', '0', '0', '0.172222222', '0', '0', '7.833333333', '1', '0.8333', '0']
package org . apache . camel . component . jcr ; import javax . jcr . LoginException ; import javax . jcr . Node ; import javax . jcr . RepositoryException ; import javax . jcr . Session ; import javax . jcr . Value ; import org . apache . camel . Exchange ; import org . apache . camel . TypeConverter ; import org . apache . camel . impl . DefaultExchange ; import org . apache . camel . impl . DefaultProducer ; public class JcrProducer extends DefaultProducer < DefaultExchange > { public JcrProducer ( JcrEndpoint jcrEndpoint ) throws LoginException , RepositoryException { super ( jcrEndpoint ) ; } public void process ( Exchange exchange ) throws Exception { Session session = openSession ( ) ; try { Node base = getBaseNode ( session ) ; Node node = base . addNode ( getNodeName ( exchange ) ) ; TypeConverter converter = exchange . getContext ( ) . getTypeConverter ( ) ; for ( String key : exchange . getProperties ( ) . keySet ( ) ) { Value value = converter . convertTo ( Value . class , exchange , exchange . getProperty ( key ) ) ; node . setProperty ( key , value ) ; } node . addMixin ( "mix:referenceable" ) ; session . save ( ) ; exchange . getOut ( ) . setBody ( node . getUUID ( ) ) ; } finally { if ( session != null && session . isLive ( ) ) { session . logout ( ) ; } } } private String getNodeName ( Exchange exchange ) { if ( exchange . getProperty ( JcrComponent . NODE_NAME ) != null ) { return exchange . getProperty ( JcrComponent . NODE_NAME ) . toString ( ) ; } return exchange . getExchangeId ( ) ; } private Node getBaseNode ( Session session ) throws Exception { Node baseNode = session . getRootNode ( ) ; for ( String node : getJcrEndpoint ( ) . getBase ( ) . split ( "/" ) ) { baseNode = baseNode . addNode ( node ) ; } return baseNode ; } protected Session openSession ( ) throws LoginException , RepositoryException { return getJcrEndpoint ( ) . getRepository ( ) . login ( getJcrEndpoint ( ) . getCredentials ( ) ) ; } private JcrEndpoint getJcrEndpoint ( ) { JcrEndpoint endpoint = ( JcrEndpoint ) getEndpoint ( ) ; return endpoint ; } } 	0	['6', '3', '0', '7', '34', '15', '1', '7', '2', '2', '138', '0', '0', '0.807692308', '0.416666667', '0', '0', '22', '2', '1', '0']
package org . apache . camel . converter . jaxb ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "header" ) @ XmlAccessorType ( value = XmlAccessType . FIELD ) public class StringHeader extends HeaderType { @ XmlAttribute ( name = "value" , required = true ) private String text ; public StringHeader ( ) { } public StringHeader ( String name , String text ) { super ( name ) ; this . text = text ; } public String getText ( ) { return text ; } public void setText ( String text ) { this . text = text ; } public Object getValue ( ) { return getText ( ) ; } public void setValue ( Object value ) { if ( value instanceof String ) { setText ( ( String ) value ) ; } else { throw new IllegalArgumentException ( "Value must be a String" ) ; } } } 	0	['6', '2', '0', '2', '9', '9', '1', '1', '6', '0.2', '41', '1', '0', '0.5', '0.5', '0', '0', '5.666666667', '2', '0.8333', '0']
package org . apache . camel . component . cxf . interceptors ; import java . util . List ; import javax . xml . stream . XMLStreamException ; import javax . xml . stream . XMLStreamWriter ; import org . w3c . dom . Element ; import org . apache . cxf . interceptor . Fault ; import org . apache . cxf . message . Message ; import org . apache . cxf . phase . AbstractPhaseInterceptor ; import org . apache . cxf . phase . Phase ; import org . apache . cxf . staxutils . StaxUtils ; public class PayloadContentRedirectInterceptor extends AbstractPhaseInterceptor < Message > { public PayloadContentRedirectInterceptor ( ) { super ( Phase . POST_STREAM ) ; } @ SuppressWarnings ( "unchecked" ) public void handleMessage ( Message message ) throws Fault { Throwable ex = message . getContent ( Throwable . class ) ; if ( ex != null ) { if ( ex instanceof Fault ) { throw ( Fault ) ex ; } else { throw new Fault ( ex ) ; } } XMLStreamWriter out = message . getContent ( XMLStreamWriter . class ) ; List < Element > in = message . get ( List . class ) ; try { for ( Element el : in ) { StaxUtils . writeElement ( el , out , false , true ) ; } } catch ( XMLStreamException e ) { throw new Fault ( e ) ; } } } 	0	['2', '0', '0', '5', '10', '1', '1', '4', '2', '2', '58', '0', '0', '0', '0.75', '0', '0', '28', '1', '0.5', '0']
package org . apache . camel . bam ; import java . util . Date ; import org . apache . camel . bam . model . ActivityState ; import org . apache . camel . bam . model . ProcessInstance ; import org . apache . camel . bam . rules . ActivityRules ; import org . apache . camel . bam . rules . TemporalRule ; import org . apache . camel . util . ObjectHelper ; import static org . apache . camel . util . ObjectHelper . equal ; public abstract class TimeExpression { private ActivityRules activityRules ; private ActivityBuilder builder ; private ActivityLifecycle lifecycle ; public TimeExpression ( ActivityBuilder builder , ActivityLifecycle lifecycle ) { this . lifecycle = lifecycle ; this . builder = builder ; this . activityRules = builder . getActivityRules ( ) ; } public boolean isActivityLifecycle ( ActivityRules activityRules , ActivityLifecycle lifecycle ) { return equal ( activityRules , this . activityRules ) && equal ( lifecycle , this . lifecycle ) ; } public TemporalRule after ( TimeExpression expression ) { TemporalRule rule = new TemporalRule ( expression , this ) ; rule . getSecond ( ) . getActivityRules ( ) . addRule ( rule ) ; return rule ; } public Date evaluate ( ProcessInstance processInstance ) { ActivityState state = processInstance . getActivityState ( activityRules ) ; if ( state != null ) { return evaluate ( processInstance , state ) ; } return null ; } public abstract Date evaluate ( ProcessInstance instance , ActivityState state ) ; public ActivityBuilder getBuilder ( ) { return builder ; } public ActivityRules getActivityRules ( ) { return activityRules ; } public ActivityLifecycle getLifecycle ( ) { return lifecycle ; } public ActivityState getActivityState ( ProcessInstance instance ) { return instance . getActivityState ( activityRules ) ; } public ActivityState getOrCreateActivityState ( ProcessInstance instance ) { return instance . getOrCreateActivityState ( activityRules ) ; } } 	0	['10', '1', '2', '9', '18', '9', '4', '7', '10', '0.666666667', '86', '1', '3', '0', '0.285714286', '0', '0', '7.3', '3', '1.2', '0']
package org . apache . camel . component . log ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . converter . ObjectConverter ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . impl . ProcessorEndpoint ; import org . apache . camel . model . LoggingLevel ; import org . apache . camel . processor . Logger ; import org . apache . camel . processor . ThroughputLogger ; import org . apache . camel . util . IntrospectionSupport ; public class LogComponent extends DefaultComponent < Exchange > { protected Endpoint < Exchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { LoggingLevel level = getLoggingLevel ( parameters ) ; Integer groupSize = getAndRemoveParameter ( parameters , "groupSize" , Integer . class ) ; Logger logger ; if ( groupSize != null ) { logger = new ThroughputLogger ( remaining , level , ObjectConverter . toInteger ( groupSize ) ) ; } else { LogFormatter formatter = new LogFormatter ( ) ; IntrospectionSupport . setProperties ( formatter , parameters ) ; logger = new Logger ( remaining ) ; logger . setLevel ( level ) ; logger . setFormatter ( formatter ) ; } return new ProcessorEndpoint ( uri , this , logger ) ; } protected LoggingLevel getLoggingLevel ( Map parameters ) { String levelText = getAndRemoveParameter ( parameters , "level" , String . class , "INFO" ) ; return LoggingLevel . valueOf ( levelText . toUpperCase ( ) ) ; } } 	0	['3', '3', '0', '12', '17', '3', '0', '12', '1', '2', '67', '0', '0', '0.945945946', '0.666666667', '1', '3', '21.33333333', '1', '0.6667', '0']
package org . apache . camel . spring . spi ; import org . apache . camel . spi . Injector ; import org . springframework . beans . factory . config . AutowireCapableBeanFactory ; import org . springframework . context . ConfigurableApplicationContext ; public class SpringInjector implements Injector { private final ConfigurableApplicationContext applicationContext ; private int autowireMode = AutowireCapableBeanFactory . AUTOWIRE_CONSTRUCTOR ; private boolean dependencyCheck ; public SpringInjector ( ConfigurableApplicationContext applicationContext ) { this . applicationContext = applicationContext ; } public < T > T newInstance ( Class < T > type ) { Object value = applicationContext . getBeanFactory ( ) . createBean ( type , autowireMode , dependencyCheck ) ; return type . cast ( value ) ; } public int getAutowireMode ( ) { return autowireMode ; } public void setAutowireMode ( int autowireMode ) { this . autowireMode = autowireMode ; } public boolean isDependencyCheck ( ) { return dependencyCheck ; } public void setDependencyCheck ( boolean dependencyCheck ) { this . dependencyCheck = dependencyCheck ; } } 	0	['6', '1', '0', '4', '10', '0', '1', '3', '6', '0.6', '46', '1', '0', '0', '0.333333333', '0', '0', '6.166666667', '1', '0.8333', '0']
package org . apache . camel . model . dataformat ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . spi . DataFormat ; @ XmlRootElement ( name = "xmlBeans" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class XMLBeansDataFormat extends DataFormatType { @ XmlAttribute ( required = false ) private Boolean prettyPrint ; public XMLBeansDataFormat ( ) { super ( "org.apache.camel.converter.xmlbeans.XmlBeansDataFormat" ) ; } public Boolean getPrettyPrint ( ) { return prettyPrint ; } public void setPrettyPrint ( Boolean prettyPrint ) { this . prettyPrint = prettyPrint ; } } 	0	['3', '3', '0', '2', '4', '1', '1', '1', '3', '0.5', '15', '1', '0', '0.818181818', '0.666666667', '0', '0', '3.666666667', '1', '0.6667', '0']
package org . apache . camel . processor . aggregate ; import java . util . Collection ; import java . util . Iterator ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; public interface AggregationCollection extends Collection < Exchange > { Expression < Exchange > getCorrelationExpression ( ) ; void setCorrelationExpression ( Expression < Exchange > correlationExpression ) ; AggregationStrategy getAggregationStrategy ( ) ; void setAggregationStrategy ( AggregationStrategy aggregationStrategy ) ; boolean add ( Exchange exchange ) ; Iterator < Exchange > iterator ( ) ; int size ( ) ; void clear ( ) ; void onAggregation ( Object correlationKey , Exchange newExchange ) ; } 	0	['9', '1', '0', '7', '9', '36', '4', '3', '9', '2', '9', '0', '0', '0', '0.311111111', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . jms ; import javax . jms . ConnectionFactory ; import javax . jms . Destination ; import javax . jms . ExceptionListener ; import javax . jms . JMSException ; import javax . jms . Message ; import javax . jms . MessageProducer ; import javax . jms . QueueSender ; import javax . jms . Session ; import javax . jms . TopicPublisher ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . PackageHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . core . task . TaskExecutor ; import org . springframework . jms . JmsException ; import org . springframework . jms . connection . JmsResourceHolder ; import org . springframework . jms . core . JmsOperations ; import org . springframework . jms . core . JmsTemplate ; import org . springframework . jms . core . JmsTemplate102 ; import org . springframework . jms . core . MessageCreator ; import org . springframework . jms . core . SessionCallback ; import org . springframework . jms . listener . AbstractMessageListenerContainer ; import org . springframework . jms . listener . DefaultMessageListenerContainer ; import org . springframework . jms . listener . DefaultMessageListenerContainer102 ; import org . springframework . jms . listener . SimpleMessageListenerContainer ; import org . springframework . jms . listener . SimpleMessageListenerContainer102 ; import org . springframework . jms . listener . serversession . ServerSessionFactory ; import org . springframework . jms . listener . serversession . ServerSessionMessageListenerContainer ; import org . springframework . jms . listener . serversession . ServerSessionMessageListenerContainer102 ; import org . springframework . jms . support . JmsUtils ; import org . springframework . jms . support . converter . MessageConverter ; import org . springframework . jms . support . destination . DestinationResolver ; import org . springframework . transaction . PlatformTransactionManager ; import org . springframework . util . Assert ; import static org . apache . camel . util . ObjectHelper . removeStartingCharacters ; public class JmsConfiguration implements Cloneable { public static final String QUEUE_PREFIX = "queue:" ; public static final String TOPIC_PREFIX = "topic:" ; public static final String TEMP_QUEUE_PREFIX = "temp:queue:" ; public static final String TEMP_TOPIC_PREFIX = "temp:topic:" ; protected static final String TRANSACTED = "TRANSACTED" ; protected static final String CLIENT_ACKNOWLEDGE = "CLIENT_ACKNOWLEDGE" ; protected static final String AUTO_ACKNOWLEDGE = "AUTO_ACKNOWLEDGE" ; protected static final String DUPS_OK_ACKNOWLEDGE = "DUPS_OK_ACKNOWLEDGE" ; protected static final String REPLYTO_TEMP_DEST_AFFINITY_PER_COMPONENT = "component" ; protected static final String REPLYTO_TEMP_DEST_AFFINITY_PER_ENDPOINT = "endpoint" ; protected static final String REPLYTO_TEMP_DEST_AFFINITY_PER_PRODUCER = "producer" ; private static final transient Log LOG = LogFactory . getLog ( JmsConfiguration . class ) ; private JmsOperations jmsOperations ; private DestinationResolver destinationResolver ; private ConnectionFactory connectionFactory ; private ConnectionFactory templateConnectionFactory ; private ConnectionFactory listenerConnectionFactory ; private int acknowledgementMode = - 1 ; private String acknowledgementModeName ; private ExceptionListener exceptionListener ; private ConsumerType consumerType = ConsumerType . Default ; private boolean autoStartup = true ; private boolean acceptMessagesWhileStopping ; private String clientId ; private String durableSubscriptionName ; private boolean subscriptionDurable ; private boolean exposeListenerSession = true ; private TaskExecutor taskExecutor ; private boolean pubSubNoLocal ; private int concurrentConsumers = 1 ; private int maxMessagesPerTask = 1 ; private ServerSessionFactory serverSessionFactory ; private int cacheLevel = - 1 ; private String cacheLevelName ; private long recoveryInterval = - 1 ; private long receiveTimeout = - 1 ; private long requestTimeout = 20000L ; private int idleTaskExecutionLimit = 1 ; private int maxConcurrentConsumers = 1 ; private boolean useVersion102 ; private Boolean explicitQosEnabled ; private boolean deliveryPersistent = true ; private boolean replyToDeliveryPersistent = true ; private long timeToLive = - 1 ; private MessageConverter messageConverter ; private boolean messageIdEnabled = true ; private boolean messageTimestampEnabled = true ; private int priority = - 1 ; private boolean transacted ; private boolean transactedInOut ; private PlatformTransactionManager transactionManager ; private String transactionName ; private int transactionTimeout = - 1 ; private boolean preserveMessageQos ; private long requestMapPurgePollTimeMillis = 1000L ; private boolean disableReplyTo ; private boolean eagerLoadingOfProperties ; private boolean alwaysCopyMessage ; private boolean useMessageIDAsCorrelationID ; private JmsProviderMetadata providerMetadata = new JmsProviderMetadata ( ) ; private JmsOperations metadataJmsOperations ; private String replyToTempDestinationAffinity = REPLYTO_TEMP_DEST_AFFINITY_PER_ENDPOINT ; private String replyToDestination ; private String replyToDestinationSelectorName ; public JmsConfiguration ( ) { } public JmsConfiguration ( ConnectionFactory connectionFactory ) { this . connectionFactory = connectionFactory ; } public JmsConfiguration copy ( ) { try { return ( JmsConfiguration ) clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeCamelException ( e ) ; } } public static interface MessageSentCallback { void sent ( Message message ) ; } public static class CamelJmsTemplate extends JmsTemplate { private JmsConfiguration config ; public CamelJmsTemplate ( JmsConfiguration config , ConnectionFactory connectionFactory ) { super ( connectionFactory ) ; this . config = config ; } public void send ( final String destinationName , final MessageCreator messageCreator , final MessageSentCallback callback ) throws JmsException { execute ( new SessionCallback ( ) { public Object doInJms ( Session session ) throws JMSException { Destination destination = resolveDestinationName ( session , destinationName ) ; Assert . notNull ( messageCreator , "MessageCreator must not be null" ) ; MessageProducer producer = createProducer ( session , destination ) ; Message message = null ; try { message = messageCreator . createMessage ( session ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Sending created message: " + message ) ; } doSend ( producer , message ) ; if ( session . getTransacted ( ) && isSessionLocallyTransacted ( session ) ) { JmsUtils . commitIfNecessary ( session ) ; } } finally { JmsUtils . closeMessageProducer ( producer ) ; } if ( message != null && callback != null ) { callback . sent ( message ) ; } return null ; } } , false ) ; } @ Override protected void doSend ( MessageProducer producer , Message message ) throws JMSException { if ( config . isPreserveMessageQos ( ) ) { long ttl = message . getJMSExpiration ( ) ; if ( ttl != 0 ) { ttl = ttl - System . currentTimeMillis ( ) ; if ( ttl <= 0 ) { ttl = 1 ; } } producer . send ( message , message . getJMSDeliveryMode ( ) , message . getJMSPriority ( ) , ttl ) ; } else { super . doSend ( producer , message ) ; } } } public static class CamelJmsTeemplate102 extends JmsTemplate102 { private JmsConfiguration config ; public CamelJmsTeemplate102 ( JmsConfiguration config , ConnectionFactory connectionFactory , boolean pubSubDomain ) { super ( connectionFactory , pubSubDomain ) ; this . config = config ; } public void send ( final String destinationName , final MessageCreator messageCreator , final MessageSentCallback callback ) throws JmsException { execute ( new SessionCallback ( ) { public Object doInJms ( Session session ) throws JMSException { Destination destination = resolveDestinationName ( session , destinationName ) ; Assert . notNull ( messageCreator , "MessageCreator must not be null" ) ; MessageProducer producer = createProducer ( session , destination ) ; Message message = null ; try { message = messageCreator . createMessage ( session ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Sending created message: " + message ) ; } doSend ( producer , message ) ; if ( session . getTransacted ( ) && isSessionLocallyTransacted ( session ) ) { JmsUtils . commitIfNecessary ( session ) ; } } finally { JmsUtils . closeMessageProducer ( producer ) ; } if ( message != null && callback != null ) { callback . sent ( message ) ; } return null ; } } , false ) ; } @ Override protected void doSend ( MessageProducer producer , Message message ) throws JMSException { if ( config . isPreserveMessageQos ( ) ) { long ttl = message . getJMSExpiration ( ) ; if ( ttl != 0 ) { ttl = ttl - System . currentTimeMillis ( ) ; if ( ttl <= 0 ) { ttl = 1 ; } } if ( isPubSubDomain ( ) ) { ( ( TopicPublisher ) producer ) . publish ( message , message . getJMSDeliveryMode ( ) , message . getJMSPriority ( ) , ttl ) ; } else { ( ( QueueSender ) producer ) . send ( message , message . getJMSDeliveryMode ( ) , message . getJMSPriority ( ) , ttl ) ; } } else { super . doSend ( producer , message ) ; } } } public JmsOperations createInOutTemplate ( JmsEndpoint endpoint , boolean pubSubDomain , String destination , long requestTimeout ) { JmsOperations answer = createInOnlyTemplate ( endpoint , pubSubDomain , destination ) ; if ( answer instanceof JmsTemplate && requestTimeout > 0 ) { JmsTemplate jmsTemplate = ( JmsTemplate ) answer ; jmsTemplate . setExplicitQosEnabled ( true ) ; jmsTemplate . setTimeToLive ( requestTimeout ) ; jmsTemplate . setSessionTransacted ( isTransactedInOut ( ) ) ; if ( isTransactedInOut ( ) ) { jmsTemplate . setSessionAcknowledgeMode ( Session . SESSION_TRANSACTED ) ; } else { if ( acknowledgementMode >= 0 ) { jmsTemplate . setSessionAcknowledgeMode ( acknowledgementMode ) ; } else if ( acknowledgementModeName != null ) { jmsTemplate . setSessionAcknowledgeModeName ( acknowledgementModeName ) ; } else { jmsTemplate . setSessionAcknowledgeMode ( Session . AUTO_ACKNOWLEDGE ) ; } } } return answer ; } public JmsOperations createInOnlyTemplate ( JmsEndpoint endpoint , boolean pubSubDomain , String destination ) { if ( jmsOperations != null ) { return jmsOperations ; } ConnectionFactory factory = getTemplateConnectionFactory ( ) ; JmsTemplate template = useVersion102 ? new CamelJmsTeemplate102 ( this , factory , pubSubDomain ) : new CamelJmsTemplate ( this , factory ) ; template . setPubSubDomain ( pubSubDomain ) ; if ( destinationResolver != null ) { template . setDestinationResolver ( destinationResolver ) ; if ( endpoint instanceof DestinationEndpoint ) { LOG . debug ( "You are overloading the destinationResolver property on a DestinationEndpoint; are you sure you want to do that?" ) ; } } else if ( endpoint instanceof DestinationEndpoint ) { DestinationEndpoint destinationEndpoint = ( DestinationEndpoint ) endpoint ; template . setDestinationResolver ( createDestinationResolver ( destinationEndpoint ) ) ; } template . setDefaultDestinationName ( destination ) ; template . setExplicitQosEnabled ( isExplicitQosEnabled ( ) ) ; template . setDeliveryPersistent ( deliveryPersistent ) ; if ( messageConverter != null ) { template . setMessageConverter ( messageConverter ) ; } template . setMessageIdEnabled ( messageIdEnabled ) ; template . setMessageTimestampEnabled ( messageTimestampEnabled ) ; if ( priority >= 0 ) { template . setPriority ( priority ) ; } template . setPubSubNoLocal ( pubSubNoLocal ) ; if ( receiveTimeout >= 0 ) { template . setReceiveTimeout ( receiveTimeout ) ; } if ( timeToLive >= 0 ) { template . setTimeToLive ( timeToLive ) ; } template . setSessionTransacted ( transacted ) ; if ( transacted ) { template . setSessionAcknowledgeMode ( Session . SESSION_TRANSACTED ) ; } else { if ( acknowledgementMode >= 0 ) { template . setSessionAcknowledgeMode ( acknowledgementMode ) ; } else if ( acknowledgementModeName != null ) { template . setSessionAcknowledgeModeName ( acknowledgementModeName ) ; } } return template ; } public AbstractMessageListenerContainer createMessageListenerContainer ( JmsEndpoint endpoint ) { AbstractMessageListenerContainer container = chooseMessageListenerContainerImplementation ( ) ; configureMessageListenerContainer ( container , endpoint ) ; return container ; } public ConnectionFactory getConnectionFactory ( ) { if ( connectionFactory == null ) { connectionFactory = createConnectionFactory ( ) ; } return connectionFactory ; } public void setConnectionFactory ( ConnectionFactory connectionFactory ) { this . connectionFactory = connectionFactory ; } public ConnectionFactory getListenerConnectionFactory ( ) { if ( listenerConnectionFactory == null ) { listenerConnectionFactory = createListenerConnectionFactory ( ) ; } return listenerConnectionFactory ; } public void setListenerConnectionFactory ( ConnectionFactory listenerConnectionFactory ) { this . listenerConnectionFactory = listenerConnectionFactory ; } public ConnectionFactory getTemplateConnectionFactory ( ) { if ( templateConnectionFactory == null ) { templateConnectionFactory = createTemplateConnectionFactory ( ) ; } return templateConnectionFactory ; } public void setTemplateConnectionFactory ( ConnectionFactory templateConnectionFactory ) { this . templateConnectionFactory = templateConnectionFactory ; } public boolean isUseVersion102 ( ) { return useVersion102 ; } public void setUseVersion102 ( boolean useVersion102 ) { this . useVersion102 = useVersion102 ; } public boolean isAutoStartup ( ) { return autoStartup ; } public void setAutoStartup ( boolean autoStartup ) { this . autoStartup = autoStartup ; } public boolean isAcceptMessagesWhileStopping ( ) { return acceptMessagesWhileStopping ; } public void setAcceptMessagesWhileStopping ( boolean acceptMessagesWhileStopping ) { this . acceptMessagesWhileStopping = acceptMessagesWhileStopping ; } public String getClientId ( ) { return clientId ; } public void setClientId ( String consumerClientId ) { this . clientId = consumerClientId ; } public String getDurableSubscriptionName ( ) { return durableSubscriptionName ; } public void setDurableSubscriptionName ( String durableSubscriptionName ) { this . durableSubscriptionName = durableSubscriptionName ; } public ExceptionListener getExceptionListener ( ) { return exceptionListener ; } public void setExceptionListener ( ExceptionListener exceptionListener ) { this . exceptionListener = exceptionListener ; } public boolean isSubscriptionDurable ( ) { return subscriptionDurable ; } public void setSubscriptionDurable ( boolean subscriptionDurable ) { this . subscriptionDurable = subscriptionDurable ; } public String getAcknowledgementModeName ( ) { return acknowledgementModeName ; } public void setAcknowledgementModeName ( String consumerAcknowledgementMode ) { this . acknowledgementModeName = consumerAcknowledgementMode ; this . acknowledgementMode = - 1 ; } public boolean isExposeListenerSession ( ) { return exposeListenerSession ; } public void setExposeListenerSession ( boolean exposeListenerSession ) { this . exposeListenerSession = exposeListenerSession ; } public TaskExecutor getTaskExecutor ( ) { return taskExecutor ; } public void setTaskExecutor ( TaskExecutor taskExecutor ) { this . taskExecutor = taskExecutor ; } public boolean isPubSubNoLocal ( ) { return pubSubNoLocal ; } public void setPubSubNoLocal ( boolean pubSubNoLocal ) { this . pubSubNoLocal = pubSubNoLocal ; } public int getConcurrentConsumers ( ) { return concurrentConsumers ; } public void setConcurrentConsumers ( int concurrentConsumers ) { this . concurrentConsumers = concurrentConsumers ; } public int getMaxMessagesPerTask ( ) { return maxMessagesPerTask ; } public void setMaxMessagesPerTask ( int maxMessagesPerTask ) { this . maxMessagesPerTask = maxMessagesPerTask ; } public ServerSessionFactory getServerSessionFactory ( ) { return serverSessionFactory ; } public void setServerSessionFactory ( ServerSessionFactory serverSessionFactory ) { this . serverSessionFactory = serverSessionFactory ; } public int getCacheLevel ( ) { return cacheLevel ; } public void setCacheLevel ( int cacheLevel ) { this . cacheLevel = cacheLevel ; } public String getCacheLevelName ( ) { return cacheLevelName ; } public void setCacheLevelName ( String cacheName ) { this . cacheLevelName = cacheName ; } public long getRecoveryInterval ( ) { return recoveryInterval ; } public void setRecoveryInterval ( long recoveryInterval ) { this . recoveryInterval = recoveryInterval ; } public long getReceiveTimeout ( ) { return receiveTimeout ; } public void setReceiveTimeout ( long receiveTimeout ) { this . receiveTimeout = receiveTimeout ; } public PlatformTransactionManager getTransactionManager ( ) { return transactionManager ; } public void setTransactionManager ( PlatformTransactionManager transactionManager ) { this . transactionManager = transactionManager ; } public String getTransactionName ( ) { return transactionName ; } public void setTransactionName ( String transactionName ) { this . transactionName = transactionName ; } public int getTransactionTimeout ( ) { return transactionTimeout ; } public void setTransactionTimeout ( int transactionTimeout ) { this . transactionTimeout = transactionTimeout ; } public int getIdleTaskExecutionLimit ( ) { return idleTaskExecutionLimit ; } public void setIdleTaskExecutionLimit ( int idleTaskExecutionLimit ) { this . idleTaskExecutionLimit = idleTaskExecutionLimit ; } public int getMaxConcurrentConsumers ( ) { return maxConcurrentConsumers ; } public void setMaxConcurrentConsumers ( int maxConcurrentConsumers ) { this . maxConcurrentConsumers = maxConcurrentConsumers ; } public boolean isExplicitQosEnabled ( ) { return explicitQosEnabled != null ? explicitQosEnabled : false ; } public void setExplicitQosEnabled ( boolean explicitQosEnabled ) { this . explicitQosEnabled = explicitQosEnabled ; } public boolean isDeliveryPersistent ( ) { return deliveryPersistent ; } public void setDeliveryPersistent ( boolean deliveryPersistent ) { this . deliveryPersistent = deliveryPersistent ; configuredQoS ( ) ; } public boolean isReplyToDeliveryPersistent ( ) { return replyToDeliveryPersistent ; } public void setReplyToDeliveryPersistent ( boolean replyToDeliveryPersistent ) { this . replyToDeliveryPersistent = replyToDeliveryPersistent ; } public long getTimeToLive ( ) { return timeToLive ; } public void setTimeToLive ( long timeToLive ) { this . timeToLive = timeToLive ; configuredQoS ( ) ; } public MessageConverter getMessageConverter ( ) { return messageConverter ; } public void setMessageConverter ( MessageConverter messageConverter ) { this . messageConverter = messageConverter ; } public boolean isMessageIdEnabled ( ) { return messageIdEnabled ; } public void setMessageIdEnabled ( boolean messageIdEnabled ) { this . messageIdEnabled = messageIdEnabled ; } public boolean isMessageTimestampEnabled ( ) { return messageTimestampEnabled ; } public void setMessageTimestampEnabled ( boolean messageTimestampEnabled ) { this . messageTimestampEnabled = messageTimestampEnabled ; } public int getPriority ( ) { return priority ; } public void setPriority ( int priority ) { this . priority = priority ; configuredQoS ( ) ; } public ConsumerType getConsumerType ( ) { return consumerType ; } public void setConsumerType ( ConsumerType consumerType ) { this . consumerType = consumerType ; } public int getAcknowledgementMode ( ) { return acknowledgementMode ; } public void setAcknowledgementMode ( int consumerAcknowledgementMode ) { this . acknowledgementMode = consumerAcknowledgementMode ; this . acknowledgementModeName = null ; } public boolean isTransacted ( ) { return transacted ; } public void setTransacted ( boolean consumerTransacted ) { this . transacted = consumerTransacted ; } public boolean isTransactedInOut ( ) { return transactedInOut ; } public void setTransactedInOut ( boolean transactedInOut ) { this . transactedInOut = transactedInOut ; } public boolean isEagerLoadingOfProperties ( ) { return eagerLoadingOfProperties ; } public void setEagerLoadingOfProperties ( boolean eagerLoadingOfProperties ) { this . eagerLoadingOfProperties = eagerLoadingOfProperties ; } public boolean isDisableReplyTo ( ) { return disableReplyTo ; } public void setDisableReplyTo ( boolean disableReplyTo ) { this . disableReplyTo = disableReplyTo ; } public void setPreserveMessageQos ( boolean preserveMessageQos ) { this . preserveMessageQos = preserveMessageQos ; } public JmsOperations getJmsOperations ( ) { return jmsOperations ; } public void setJmsOperations ( JmsOperations jmsOperations ) { this . jmsOperations = jmsOperations ; } public DestinationResolver getDestinationResolver ( ) { return destinationResolver ; } public void setDestinationResolver ( DestinationResolver destinationResolver ) { this . destinationResolver = destinationResolver ; } public long getRequestMapPurgePollTimeMillis ( ) { return requestMapPurgePollTimeMillis ; } public void setRequestMapPurgePollTimeMillis ( long requestMapPurgePollTimeMillis ) { this . requestMapPurgePollTimeMillis = requestMapPurgePollTimeMillis ; } public JmsProviderMetadata getProviderMetadata ( ) { return providerMetadata ; } public void setProviderMetadata ( JmsProviderMetadata providerMetadata ) { this . providerMetadata = providerMetadata ; } public JmsOperations getMetadataJmsOperations ( JmsEndpoint endpoint ) { if ( metadataJmsOperations == null ) { metadataJmsOperations = getJmsOperations ( ) ; if ( metadataJmsOperations == null ) { metadataJmsOperations = createInOnlyTemplate ( endpoint , false , null ) ; } } return metadataJmsOperations ; } public void setMetadataJmsOperations ( JmsOperations metadataJmsOperations ) { this . metadataJmsOperations = metadataJmsOperations ; } public static DestinationResolver createDestinationResolver ( final DestinationEndpoint destinationEndpoint ) { return new DestinationResolver ( ) { public Destination resolveDestinationName ( Session session , String destinationName , boolean pubSubDomain ) throws JMSException { return destinationEndpoint . getJmsDestination ( session ) ; } } ; } protected void configureMessageListenerContainer ( AbstractMessageListenerContainer container , JmsEndpoint endpoint ) { container . setConnectionFactory ( getListenerConnectionFactory ( ) ) ; if ( endpoint instanceof DestinationEndpoint ) { container . setDestinationResolver ( createDestinationResolver ( ( DestinationEndpoint ) endpoint ) ) ; } else if ( destinationResolver != null ) { container . setDestinationResolver ( destinationResolver ) ; } if ( autoStartup ) { container . setAutoStartup ( true ) ; } if ( clientId != null ) { container . setClientId ( clientId ) ; } container . setSubscriptionDurable ( subscriptionDurable ) ; if ( durableSubscriptionName != null ) { container . setDurableSubscriptionName ( durableSubscriptionName ) ; } if ( durableSubscriptionName != null && clientId != null ) { container . setSubscriptionDurable ( true ) ; } if ( exceptionListener != null ) { container . setExceptionListener ( exceptionListener ) ; } container . setAcceptMessagesWhileStopping ( acceptMessagesWhileStopping ) ; container . setExposeListenerSession ( exposeListenerSession ) ; container . setSessionTransacted ( transacted ) ; if ( transacted ) { container . setSessionAcknowledgeMode ( Session . SESSION_TRANSACTED ) ; } else { if ( acknowledgementMode >= 0 ) { container . setSessionAcknowledgeMode ( acknowledgementMode ) ; } else if ( acknowledgementModeName != null ) { container . setSessionAcknowledgeModeName ( acknowledgementModeName ) ; } } if ( endpoint . getSelector ( ) != null && endpoint . getSelector ( ) . length ( ) != 0 ) { container . setMessageSelector ( endpoint . getSelector ( ) ) ; } if ( container instanceof DefaultMessageListenerContainer ) { DefaultMessageListenerContainer listenerContainer = ( DefaultMessageListenerContainer ) container ; if ( concurrentConsumers >= 0 ) { listenerContainer . setConcurrentConsumers ( concurrentConsumers ) ; } if ( cacheLevel >= 0 ) { listenerContainer . setCacheLevel ( cacheLevel ) ; } else if ( cacheLevelName != null ) { listenerContainer . setCacheLevelName ( cacheLevelName ) ; } else { listenerContainer . setCacheLevel ( defaultCacheLevel ( endpoint ) ) ; } if ( idleTaskExecutionLimit >= 0 ) { listenerContainer . setIdleTaskExecutionLimit ( idleTaskExecutionLimit ) ; } if ( maxConcurrentConsumers >= 0 ) { listenerContainer . setMaxConcurrentConsumers ( maxConcurrentConsumers ) ; } if ( maxMessagesPerTask >= 0 ) { listenerContainer . setMaxMessagesPerTask ( maxMessagesPerTask ) ; } listenerContainer . setPubSubNoLocal ( pubSubNoLocal ) ; if ( receiveTimeout >= 0 ) { listenerContainer . setReceiveTimeout ( receiveTimeout ) ; } if ( recoveryInterval >= 0 ) { listenerContainer . setRecoveryInterval ( recoveryInterval ) ; } if ( taskExecutor != null ) { listenerContainer . setTaskExecutor ( taskExecutor ) ; } PlatformTransactionManager tm = getTransactionManager ( ) ; if ( tm != null && transacted ) { listenerContainer . setTransactionManager ( tm ) ; } else if ( transacted ) { throw new IllegalArgumentException ( "Property transacted is enabled but a transactionManager was not injected!" ) ; } if ( transactionName != null ) { listenerContainer . setTransactionName ( transactionName ) ; } if ( transactionTimeout >= 0 ) { listenerContainer . setTransactionTimeout ( transactionTimeout ) ; } } else if ( container instanceof ServerSessionMessageListenerContainer ) { ServerSessionMessageListenerContainer listenerContainer = ( ServerSessionMessageListenerContainer ) container ; if ( maxMessagesPerTask >= 0 ) { listenerContainer . setMaxMessagesPerTask ( maxMessagesPerTask ) ; } if ( serverSessionFactory != null ) { listenerContainer . setServerSessionFactory ( serverSessionFactory ) ; } } else if ( container instanceof SimpleMessageListenerContainer ) { SimpleMessageListenerContainer listenerContainer = ( SimpleMessageListenerContainer ) container ; if ( concurrentConsumers >= 0 ) { listenerContainer . setConcurrentConsumers ( concurrentConsumers ) ; } listenerContainer . setPubSubNoLocal ( pubSubNoLocal ) ; if ( taskExecutor != null ) { listenerContainer . setTaskExecutor ( taskExecutor ) ; } } } public void configure ( EndpointMessageListener listener ) { if ( isDisableReplyTo ( ) ) { listener . setDisableReplyTo ( true ) ; } if ( isEagerLoadingOfProperties ( ) ) { listener . setEagerLoadingOfProperties ( true ) ; } JmsOperations operations = listener . getTemplate ( ) ; if ( operations instanceof JmsTemplate ) { JmsTemplate template = ( JmsTemplate ) operations ; template . setDeliveryPersistent ( isReplyToDeliveryPersistent ( ) ) ; } } public AbstractMessageListenerContainer chooseMessageListenerContainerImplementation ( ) { switch ( consumerType ) { case Simple : return isUseVersion102 ( ) ? new SimpleMessageListenerContainer102 ( ) : new SimpleMessageListenerContainer ( ) ; case ServerSessionPool : return isUseVersion102 ( ) ? new ServerSessionMessageListenerContainer102 ( ) : new ServerSessionMessageListenerContainer ( ) ; case Default : return isUseVersion102 ( ) ? new DefaultMessageListenerContainer102 ( ) : new DefaultMessageListenerContainer ( ) ; default : throw new IllegalArgumentException ( "Unknown consumer type: " + consumerType ) ; } } protected int defaultCacheLevel ( JmsEndpoint endpoint ) { if ( PackageHelper . isValidVersion ( "org.springframework.jms" , 2.51D ) ) { return DefaultMessageListenerContainer . CACHE_CONSUMER ; } else { if ( endpoint . isPubSubDomain ( ) && ! isSubscriptionDurable ( ) ) { return DefaultMessageListenerContainer . CACHE_CONSUMER ; } else { return DefaultMessageListenerContainer . CACHE_CONNECTION ; } } } protected ConnectionFactory createConnectionFactory ( ) { ObjectHelper . notNull ( connectionFactory , "connectionFactory" ) ; return null ; } protected ConnectionFactory createListenerConnectionFactory ( ) { return getConnectionFactory ( ) ; } protected ConnectionFactory createTemplateConnectionFactory ( ) { return getConnectionFactory ( ) ; } public boolean isPreserveMessageQos ( ) { return preserveMessageQos ; } protected void configuredQoS ( ) { if ( explicitQosEnabled == null ) { explicitQosEnabled = true ; } } public boolean isAlwaysCopyMessage ( ) { return alwaysCopyMessage ; } public void setAlwaysCopyMessage ( boolean alwaysCopyMessage ) { this . alwaysCopyMessage = alwaysCopyMessage ; } public boolean isUseMessageIDAsCorrelationID ( ) { return useMessageIDAsCorrelationID ; } public void setUseMessageIDAsCorrelationID ( boolean useMessageIDAsCorrelationID ) { this . useMessageIDAsCorrelationID = useMessageIDAsCorrelationID ; } public String getReplyToTempDestinationAffinity ( ) { return replyToTempDestinationAffinity ; } public void setReplyToTempDestinationAffinity ( String replyToTempDestinationAffinity ) { this . replyToTempDestinationAffinity = replyToTempDestinationAffinity ; } public long getRequestTimeout ( ) { return requestTimeout ; } public void setRequestTimeout ( long requestTimeout ) { this . requestTimeout = requestTimeout ; } public String getReplyTo ( ) { return replyToDestination ; } public void setReplyTo ( String replyToDestination ) { if ( ! replyToDestination . startsWith ( QUEUE_PREFIX ) ) { throw new IllegalArgumentException ( "ReplyTo destination value has to be of type queue; " + "e.g: \"queue:replyQueue\"" ) ; } this . replyToDestination = removeStartingCharacters ( replyToDestination . substring ( QUEUE_PREFIX . length ( ) ) , '/' ) ; } public String getReplyToDestinationSelectorName ( ) { return replyToDestinationSelectorName ; } public void setReplyToDestinationSelectorName ( String replyToDestinationSelectorName ) { this . replyToDestinationSelectorName = replyToDestinationSelectorName ; if ( replyToDestinationSelectorName != null ) { setAlwaysCopyMessage ( true ) ; } } } 	0	['120', '1', '0', '38', '200', '6646', '14', '28', '113', '0.973345588', '1370', '0.9375', '2', '0', '0.081822203', '0', '0', '9.883333333', '33', '1.5417', '0']
package org . apache . camel . component . file ; import java . io . File ; import org . apache . camel . impl . DefaultMessage ; public class FileMessage extends DefaultMessage { private File file ; public FileMessage ( ) { this ( new File ( "." ) ) ; } public FileMessage ( File file ) { this . file = file ; } @ Override public String toString ( ) { return "FileMessage: " + file ; } @ Override public FileExchange getExchange ( ) { return ( FileExchange ) super . getExchange ( ) ; } public File getFile ( ) { return file ; } public void setFile ( File file ) { this . file = file ; } @ Override public FileMessage newInstance ( ) { return new FileMessage ( ) ; } @ Override protected Object createBody ( ) { return file ; } } 	0	['11', '3', '0', '4', '15', '35', '1', '4', '10', '0.2', '62', '1', '0', '0.795454545', '0.590909091', '2', '5', '4.545454545', '1', '0.8182', '0']
package org . apache . camel . component . timer ; import java . util . Date ; import java . util . Timer ; import org . apache . camel . Consumer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . impl . DefaultEndpoint ; public class TimerEndpoint extends DefaultEndpoint < Exchange > { private String timerName ; private Date time ; private long period = 1000 ; private long delay ; private boolean fixedRate ; private boolean daemon = true ; private Timer timer ; public TimerEndpoint ( String fullURI , TimerComponent component , String timerName ) { super ( fullURI , component ) ; this . timer = component . getTimer ( this ) ; this . timerName = timerName ; } public TimerEndpoint ( String endpointUri , Timer timer ) { this ( endpointUri ) ; this . timer = timer ; } public TimerEndpoint ( String endpointUri ) { super ( endpointUri ) ; } public Producer < Exchange > createProducer ( ) throws Exception { throw new RuntimeCamelException ( "Cannot produce to a TimerEndpoint: " + getEndpointUri ( ) ) ; } public Consumer < Exchange > createConsumer ( Processor processor ) throws Exception { return new TimerConsumer ( this , processor ) ; } public String getTimerName ( ) { if ( timerName == null ) { timerName = getEndpointUri ( ) ; } return timerName ; } public void setTimerName ( String timerName ) { this . timerName = timerName ; } public boolean isDaemon ( ) { return daemon ; } public void setDaemon ( boolean daemon ) { this . daemon = daemon ; } public long getDelay ( ) { return delay ; } public void setDelay ( long delay ) { this . delay = delay ; } public boolean isFixedRate ( ) { return fixedRate ; } public void setFixedRate ( boolean fixedRate ) { this . fixedRate = fixedRate ; } public long getPeriod ( ) { return period ; } public void setPeriod ( long period ) { this . period = period ; } public Date getTime ( ) { return time ; } public void setTime ( Date time ) { this . time = time ; } public boolean isSingleton ( ) { return true ; } public Timer getTimer ( ) { if ( timer == null ) { timer = new Timer ( ) ; } return timer ; } public void setTimer ( Timer timer ) { this . timer = timer ; } } 	0	['20', '2', '0', '8', '30', '144', '2', '8', '20', '0.879699248', '148', '1', '0', '0.585365854', '0.20625', '0', '0', '6.05', '2', '0.95', '0']
package org . apache . camel . component . jpa ; import java . util . Map ; import javax . persistence . EntityManagerFactory ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . util . ObjectHelper ; public class JpaComponent extends DefaultComponent < Exchange > { private EntityManagerFactory entityManagerFactory ; public Component resolveComponent ( CamelContext container , String uri ) throws Exception { return null ; } public EntityManagerFactory getEntityManagerFactory ( ) { return entityManagerFactory ; } public void setEntityManagerFactory ( EntityManagerFactory entityManagerFactory ) { this . entityManagerFactory = entityManagerFactory ; } @ Override protected Endpoint < Exchange > createEndpoint ( String uri , String path , Map options ) throws Exception { JpaEndpoint endpoint = new JpaEndpoint ( uri , this ) ; if ( path != null ) { Class < ? > type = ObjectHelper . loadClass ( path ) ; if ( type != null ) { endpoint . setEntityType ( type ) ; } } return endpoint ; } } 	0	['5', '3', '0', '6', '9', '8', '1', '6', '4', '0.75', '36', '1', '0', '0.897435897', '0.4', '1', '1', '6', '1', '0.8', '0']
package org . apache . camel . model . dataformat ; import javax . xml . bind . annotation . XmlEnum ; @ XmlEnum ( String . class ) public enum ArtixDSContentType { Default , Auto , Binary , Text , Java , Xml , Sax , TagValuePair } 	0	['4', '2', '0', '3', '7', '4', '2', '1', '2', '0.962962963', '111', '0.111111111', '9', '0.857142857', '0.444444444', '1', '1', '24.5', '1', '0.5', '0']
package org . apache . camel ; import java . util . HashMap ; import java . util . Map ; import javax . xml . bind . annotation . XmlEnum ; import javax . xml . bind . annotation . XmlType ; @ XmlType @ XmlEnum ( String . class ) public enum ExchangePattern { InOnly , RobustInOnly , InOut , InOptionalOut , OutOnly , RobustOutOnly , OutIn , OutOptionalIn ; protected static final Map < String , ExchangePattern > MAP = new HashMap < String , ExchangePattern > ( ) ; public String getWsdlUri ( ) { switch ( this ) { case InOnly : return "http://www.w3.org/ns/wsdl/in-only" ; case InOptionalOut : return "http://www.w3.org/ns/wsdl/in-optional-out" ; case InOut : return "http://www.w3.org/ns/wsdl/in-out" ; case OutIn : return "http://www.w3.org/ns/wsdl/out-in" ; case OutOnly : return "http://www.w3.org/ns/wsdl/out-only" ; case OutOptionalIn : return "http://www.w3.org/ns/wsdl/out-optional_in" ; case RobustInOnly : return "http://www.w3.org/ns/wsdl/robust-in-only" ; case RobustOutOnly : return "http://www.w3.org/ns/wsdl/robust-out-only" ; default : throw new IllegalArgumentException ( "Unknown message exchange pattern: " + this ) ; } } public boolean isInCapable ( ) { switch ( this ) { case OutOnly : case RobustOutOnly : return false ; default : return true ; } } public boolean isOutCapable ( ) { switch ( this ) { case InOnly : case RobustInOnly : return false ; default : return true ; } } public boolean isFaultCapable ( ) { switch ( this ) { case InOnly : case OutOnly : return false ; default : return true ; } } public static ExchangePattern fromWsdlUri ( String wsdlUri ) { return MAP . get ( wsdlUri ) ; } public static ExchangePattern asEnum ( String value ) { try { return valueOf ( value ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Unknown message exchange pattern: " + value ) ; } } static { for ( ExchangePattern mep : values ( ) ) { String uri = mep . getWsdlUri ( ) ; MAP . put ( uri , mep ) ; String name = uri . substring ( uri . lastIndexOf ( '/' ) + 1 ) ; MAP . put ( "http://www.w3.org/2004/08/wsdl/" + name , mep ) ; MAP . put ( "http://www.w3.org/2006/01/wsdl/" + name , mep ) ; } } } 	0	['10', '2', '0', '73', '24', '41', '72', '2', '8', '0.977777778', '259', '0.2', '9', '0.6', '0.37037037', '1', '1', '23.9', '4', '1.8', '0']
package org . apache . camel . component . cxf ; import java . util . Map ; import javax . wsdl . Definition ; import javax . wsdl . factory . WSDLFactory ; import javax . wsdl . xml . WSDLReader ; import javax . xml . namespace . QName ; import org . apache . camel . CamelContext ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . PollingConsumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . spi . HeaderFilterStrategy ; import org . apache . cxf . Bus ; import org . apache . cxf . BusFactory ; import org . apache . cxf . helpers . DOMUtils ; import org . springframework . core . io . Resource ; import org . springframework . util . Assert ; public class CxfSoapEndpoint implements Endpoint { private final Endpoint endpoint ; private Resource wsdl ; private String serviceClass ; private org . w3c . dom . Document description ; private Definition definition ; private QName serviceName ; private QName endpointName ; private Bus bus ; private HeaderFilterStrategy headerFilterStrategy ; public CxfSoapEndpoint ( Endpoint endpoint ) { this ( endpoint , new CxfHeaderFilterStrategy ( ) ) ; } public CxfSoapEndpoint ( Endpoint endpoint , HeaderFilterStrategy headerFilterStrategy ) { this . endpoint = endpoint ; this . headerFilterStrategy = headerFilterStrategy ; } protected Endpoint getInnerEndpoint ( ) { return endpoint ; } public boolean isSingleton ( ) { return endpoint . isSingleton ( ) ; } public String getEndpointUri ( ) { return endpoint . getEndpointUri ( ) ; } public Exchange createExchange ( ) { return endpoint . createExchange ( ) ; } public Exchange createExchange ( ExchangePattern pattern ) { return endpoint . createExchange ( pattern ) ; } public Exchange createExchange ( Exchange exchange ) { return endpoint . createExchange ( exchange ) ; } public CamelContext getCamelContext ( ) { return endpoint . getCamelContext ( ) ; } public Producer createProducer ( ) throws Exception { return new CxfSoapProducer ( this ) ; } public Consumer createConsumer ( Processor processor ) throws Exception { return new CxfSoapConsumer ( this , processor ) ; } public PollingConsumer createPollingConsumer ( ) throws Exception { throw new UnsupportedOperationException ( ) ; } public void configureProperties ( Map options ) { } public Resource getWsdl ( ) { return wsdl ; } public void setWsdl ( Resource wsdl ) { this . wsdl = wsdl ; } public void setServiceClass ( String serviceClass ) { this . serviceClass = serviceClass ; } public String getServiceClass ( ) { return serviceClass ; } public void setServiceName ( String serviceName ) { this . serviceName = QName . valueOf ( serviceName ) ; } public void setEndpointName ( String endpointName ) { this . endpointName = QName . valueOf ( endpointName ) ; } public QName getEndpointName ( ) { return endpointName ; } public void init ( ) throws Exception { Assert . notNull ( wsdl , "soap.wsdl parameter must be set on the uri" ) ; if ( serviceName == null ) { description = DOMUtils . readXml ( wsdl . getInputStream ( ) ) ; WSDLFactory wsdlFactory = WSDLFactory . newInstance ( ) ; WSDLReader reader = wsdlFactory . newWSDLReader ( ) ; reader . setFeature ( "javax.wsdl.verbose" , false ) ; definition = reader . readWSDL ( wsdl . getURL ( ) . toString ( ) , description ) ; serviceName = ( QName ) definition . getServices ( ) . keySet ( ) . iterator ( ) . next ( ) ; } } protected Bus getBus ( ) { if ( bus == null ) { bus = BusFactory . newInstance ( ) . createBus ( ) ; } return bus ; } public Definition getDefinition ( ) { return definition ; } public QName getServiceName ( ) { return serviceName ; } public void setCamelContext ( CamelContext context ) { endpoint . setCamelContext ( context ) ; } @ Deprecated public CamelContext getContext ( ) { return getCamelContext ( ) ; } @ Deprecated public void setContext ( CamelContext context ) { setCamelContext ( context ) ; } public HeaderFilterStrategy getHeaderFilterStrategy ( ) { return headerFilterStrategy ; } public boolean isLenientProperties ( ) { return false ; } } 	0	['29', '1', '0', '18', '57', '314', '3', '17', '27', '0.920634921', '201', '1', '2', '0', '0.144827586', '0', '0', '5.620689655', '2', '0.9655', '0']
package org . apache . camel . component . cxf . spring ; import java . util . List ; import org . apache . cxf . frontend . AbstractWSDLBasedEndpointFactory ; import org . apache . cxf . service . factory . ReflectionServiceFactoryBean ; public class CxfEndpointBean extends AbstractWSDLBasedEndpointFactory { private List handlers ; public CxfEndpointBean ( ) { this ( new ReflectionServiceFactoryBean ( ) ) ; } public CxfEndpointBean ( ReflectionServiceFactoryBean factory ) { setServiceFactory ( factory ) ; } public List getHandlers ( ) { return handlers ; } public void setHandlers ( List handlers ) { this . handlers = handlers ; } } 	0	['4', '0', '1', '7', '7', '4', '5', '2', '4', '0.666666667', '24', '1', '0', '0', '0.5', '0', '0', '4.75', '1', '0.5', '0']
package org . apache . camel . processor . loadbalancer ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ServiceHelper ; public abstract class LoadBalancerSupport extends ServiceSupport implements LoadBalancer { private List < Processor > processors = new CopyOnWriteArrayList < Processor > ( ) ; public void addProcessor ( Processor processor ) { processors . add ( processor ) ; } public void removeProcessor ( Processor processor ) { processors . remove ( processor ) ; } public List < Processor > getProcessors ( ) { return processors ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( processors ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( processors ) ; } } 	0	['6', '2', '2', '6', '12', '0', '2', '4', '4', '0', '38', '1', '0', '0.736842105', '0.666666667', '1', '1', '5.166666667', '1', '0.8333', '0']
package org . apache . camel . component . jmx ; import java . util . Map ; import javax . management . MBeanServer ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; public class JMXComponent extends DefaultComponent < JMXExchange > { private MBeanServer mbeanServer ; public JMXComponent ( ) { } public JMXComponent ( CamelContext context ) { super ( context ) ; } protected Endpoint < JMXExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { JMXEndpoint result = new JMXEndpoint ( remaining , this ) ; setProperties ( result , parameters ) ; result . setMbeanServer ( getMbeanServer ( ) ) ; return result ; } public MBeanServer getMbeanServer ( ) { return mbeanServer ; } public void setMbeanServer ( MBeanServer mbeanServer ) { this . mbeanServer = mbeanServer ; } } 	0	['5', '3', '0', '4', '10', '8', '1', '4', '4', '0.5', '36', '1', '0', '0.921052632', '0.36', '1', '2', '6', '1', '0.6', '0']
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import static org . apache . camel . util . ObjectHelper . notNull ; public abstract class BinaryPredicateSupport < E extends Exchange > implements Predicate < E > { private final Expression < E > left ; private final Expression < E > right ; protected BinaryPredicateSupport ( Expression < E > left , Expression < E > right ) { notNull ( left , "left" ) ; notNull ( right , "right" ) ; this . left = left ; this . right = right ; } @ Override public String toString ( ) { return left + " " + getOperationText ( ) + " " + right ; } public boolean matches ( E exchange ) { Object leftValue = left . evaluate ( exchange ) ; Object rightValue = right . evaluate ( exchange ) ; return matches ( exchange , leftValue , rightValue ) ; } public void assertMatches ( String text , E exchange ) { Object leftValue = left . evaluate ( exchange ) ; Object rightValue = right . evaluate ( exchange ) ; if ( ! matches ( exchange , leftValue , rightValue ) ) { throw new AssertionError ( text + assertionFailureMessage ( exchange , leftValue , rightValue ) ) ; } } protected abstract boolean matches ( E exchange , Object leftValue , Object rightValue ) ; protected abstract String getOperationText ( ) ; protected String assertionFailureMessage ( E exchange , Object leftValue , Object rightValue ) { return this + " failed on " + exchange + " with left value <" + leftValue + "> right value <" + rightValue + ">" ; } } 	0	['9', '1', '7', '11', '17', '24', '7', '4', '5', '0.375', '125', '1', '2', '0', '0.444444444', '0', '0', '12.66666667', '2', '1', '0']
package org . apache . camel . processor . aggregate ; import org . apache . camel . Exchange ; public class UseLatestAggregationStrategy implements AggregationStrategy { public Exchange aggregate ( Exchange oldExchange , Exchange newExchange ) { newExchange . setException ( checkException ( oldExchange , newExchange ) ) ; return newExchange ; } protected Throwable checkException ( Exchange oldExchange , Exchange newExchange ) { return newExchange . getException ( ) != null ? newExchange . getException ( ) : oldExchange . getException ( ) ; } } 	0	['3', '1', '0', '6', '6', '3', '4', '2', '2', '2', '23', '0', '0', '0', '0.833333333', '0', '0', '6.666666667', '2', '1', '0']
package org . apache . camel . component . mock ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . builder . ExpressionClause ; import org . apache . camel . builder . ValueBuilder ; import static org . apache . camel . builder . ExpressionBuilder . bodyExpression ; import static org . apache . camel . builder . ExpressionBuilder . headerExpression ; import static org . apache . camel . builder . ExpressionBuilder . propertyExpression ; public abstract class AssertionClause implements Runnable { private List < Predicate < Exchange > > predicates = new ArrayList < Predicate < Exchange > > ( ) ; public AssertionClause predicate ( Predicate < Exchange > predicate ) { addPredicate ( predicate ) ; return this ; } public ExpressionClause < AssertionClause > predicate ( ) { ExpressionClause < AssertionClause > clause = new ExpressionClause < AssertionClause > ( this ) ; addPredicate ( clause ) ; return clause ; } public ValueBuilder < Exchange > header ( String name ) { Expression < Exchange > expression = headerExpression ( name ) ; return new PredicateValueBuilder ( expression ) ; } public ValueBuilder < Exchange > property ( String name ) { Expression < Exchange > expression = propertyExpression ( name ) ; return new PredicateValueBuilder ( expression ) ; } public PredicateValueBuilder body ( ) { Expression < Exchange > expression = bodyExpression ( ) ; return new PredicateValueBuilder ( expression ) ; } public < T > PredicateValueBuilder bodyAs ( Class < T > type ) { Expression < Exchange > expression = bodyExpression ( type ) ; return new PredicateValueBuilder ( expression ) ; } public PredicateValueBuilder outBody ( ) { Expression < Exchange > expression = bodyExpression ( ) ; return new PredicateValueBuilder ( expression ) ; } public < T > PredicateValueBuilder outBody ( Class < T > type ) { Expression < Exchange > expression = bodyExpression ( type ) ; return new PredicateValueBuilder ( expression ) ; } protected void applyAssertionOn ( MockEndpoint endpoint , int index , Exchange exchange ) { for ( Predicate < Exchange > predicate : predicates ) { predicate . assertMatches ( endpoint . getEndpointUri ( ) + " " , exchange ) ; } } protected void addPredicate ( Predicate < Exchange > predicate ) { predicates . add ( predicate ) ; } public class PredicateValueBuilder extends ValueBuilder < Exchange > { public PredicateValueBuilder ( Expression < Exchange > expression ) { super ( expression ) ; } protected Predicate < Exchange > onNewPredicate ( Predicate < Exchange > predicate ) { addPredicate ( predicate ) ; return predicate ; } } } 	0	['11', '1', '2', '10', '28', '49', '4', '8', '9', '0.6', '118', '1', '0', '0', '0.25974026', '0', '0', '9.636363636', '2', '1', '0']
package org . apache . camel . component . cxf . util ; import java . net . MalformedURLException ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URL ; import org . apache . camel . component . cxf . CxfConstants ; import org . apache . cxf . common . classloader . ClassLoaderUtils ; public final class UriUtils { private UriUtils ( ) { } static URL getWsdlUrl ( final URI uri ) throws MalformedURLException { URL wsdlUrl = null ; if ( uri . getScheme ( ) . equals ( CxfConstants . PROTOCOL_NAME_RES ) ) { if ( uri . getPath ( ) != null ) { String path = uri . isAbsolute ( ) ? getRelativePath ( uri ) : uri . getPath ( ) ; wsdlUrl = ClassLoaderUtils . getResource ( path , UriUtils . class ) ; } } else { wsdlUrl = new URL ( uri . getScheme ( ) , uri . getHost ( ) , uri . getPort ( ) , uri . getPath ( ) ) ; } return wsdlUrl ; } private static String getRelativePath ( URI uri ) { URI base = null ; try { base = new URI ( CxfConstants . PROTOCOL_NAME_RES , "" , "/" , "" ) ; } catch ( URISyntaxException e ) { e . printStackTrace ( ) ; } return base . relativize ( uri ) . getPath ( ) ; } } 	0	['3', '1', '0', '2', '15', '3', '1', '1', '0', '2', '63', '0', '0', '0', '0.5', '0', '0', '20', '1', '0.6667', '0']
package org . apache . camel . builder . xml ; import javax . xml . transform . Result ; import org . apache . camel . Message ; public interface ResultHandler { Result getResult ( ) ; void setBody ( Message in ) ; } 	0	['2', '1', '0', '9', '2', '1', '8', '1', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . jhc ; import java . io . IOException ; import org . apache . http . HttpException ; import org . apache . http . HttpResponse ; public interface AsyncResponseHandler { void sendResponse ( HttpResponse response ) throws IOException , HttpException ; } 	0	['1', '1', '0', '7', '1', '0', '5', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . cxf . transport . spring ; import org . apache . camel . component . cxf . transport . CamelDestination ; public class CamelDestinationDefinitionParser extends AbstractCamelContextBeanDefinitionParser { public CamelDestinationDefinitionParser ( ) { super ( ) ; setBeanClass ( CamelDestination . class ) ; } } 	0	['1', '1', '0', '2', '3', '0', '1', '1', '1', '2', '7', '0', '0', '1', '1', '0', '0', '6', '0', '0', '0']
package org . apache . camel . component . bean ; import org . apache . camel . CamelContext ; import org . apache . camel . NoTypeConversionAvailableException ; import org . apache . camel . Processor ; import org . apache . camel . util . CamelContextHelper ; public class ConstantBeanHolder implements BeanHolder { private final Object bean ; private Processor processor ; private BeanInfo beanInfo ; public ConstantBeanHolder ( Object bean , BeanInfo beanInfo ) { this . bean = bean ; this . beanInfo = beanInfo ; try { this . processor = CamelContextHelper . convertTo ( beanInfo . getCamelContext ( ) , Processor . class , bean ) ; } catch ( NoTypeConversionAvailableException ex ) { this . processor = null ; } } public ConstantBeanHolder ( Object bean , CamelContext context ) { this ( bean , new BeanInfo ( context , bean . getClass ( ) ) ) ; } public ConstantBeanHolder ( Object bean , CamelContext context , ParameterMappingStrategy parameterMappingStrategy ) { this ( bean , new BeanInfo ( context , bean . getClass ( ) , parameterMappingStrategy ) ) ; } @ Override public String toString ( ) { return bean . toString ( ) ; } public Object getBean ( ) { return bean ; } public Processor getProcessor ( ) { return processor ; } public BeanInfo getBeanInfo ( ) { return beanInfo ; } } 	0	['7', '1', '0', '11', '14', '11', '4', '7', '7', '0.444444444', '66', '1', '2', '0', '0.4', '0', '0', '8', '1', '0.5714', '0']
package org . apache . camel . impl ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Producer ; public abstract class DefaultProducer < E extends Exchange > extends ServiceSupport implements Producer < E > { private Endpoint < E > endpoint ; public DefaultProducer ( Endpoint < E > endpoint ) { this . endpoint = endpoint ; } @ Override public String toString ( ) { return "Producer[" + endpoint . getEndpointUri ( ) + "]" ; } public Endpoint < E > getEndpoint ( ) { return endpoint ; } public E createExchange ( ) { return endpoint . createExchange ( ) ; } public E createExchange ( ExchangePattern pattern ) { return endpoint . createExchange ( pattern ) ; } public E createExchange ( E exchange ) { return endpoint . createExchange ( exchange ) ; } protected void doStart ( ) throws Exception { } protected void doStop ( ) throws Exception { } } 	0	['8', '2', '27', '32', '16', '0', '27', '5', '6', '0.285714286', '47', '1', '1', '0.666666667', '0.34375', '1', '1', '4.75', '1', '0.875', '0']
package org . apache . camel . component . restlet ; import java . io . IOException ; import org . apache . camel . Exchange ; import org . restlet . data . Request ; import org . restlet . data . Response ; public interface RestletBinding { void populateRestletResponseFromExchange ( Exchange exchange , Response response ) ; void populateExchangeFromRestletRequest ( Request request , Exchange exchange ) throws Exception ; void populateRestletRequestFromExchange ( Request request , Exchange exchange ) ; void populateExchangeFromRestletResponse ( Exchange exchange , Response response ) throws IOException ; } 	0	['4', '1', '0', '8', '4', '6', '5', '3', '4', '2', '4', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . file . strategy ; import java . io . File ; import org . apache . camel . Expression ; import org . apache . camel . component . file . FileExchange ; public class FileExpressionRenamer implements FileRenamer { private static final boolean ON_WINDOWS = System . getProperty ( "os.name" ) . startsWith ( "Windows" ) ; private Expression expression ; public File renameFile ( FileExchange exchange , File file ) { if ( expression == null ) { throw new IllegalArgumentException ( "Expression is not set" ) ; } File parent = file . getParentFile ( ) ; Object result = expression . evaluate ( exchange ) ; String name = exchange . getContext ( ) . getTypeConverter ( ) . convertTo ( String . class , result ) ; if ( ON_WINDOWS && ( name . indexOf ( ":" ) >= 0 || name . startsWith ( "//" ) ) ) { return new File ( name ) ; } return new File ( parent , name ) ; } public Expression getExpression ( ) { return expression ; } public void setExpression ( Expression expression ) { this . expression = expression ; } } 	0	['5', '1', '0', '7', '17', '2', '1', '6', '4', '0.625', '68', '1', '1', '0', '0.4375', '0', '0', '12.2', '5', '1.4', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import javax . xml . bind . annotation . XmlType ; import org . apache . camel . CamelContext ; import org . apache . camel . CamelContextAware ; import org . apache . camel . Endpoint ; import org . apache . camel . NoSuchEndpointException ; import org . apache . camel . Route ; import org . apache . camel . builder . ErrorHandlerBuilder ; import org . apache . camel . impl . DefaultCamelContext ; import org . apache . camel . impl . DefaultRouteContext ; import org . apache . camel . processor . interceptor . StreamCachingInterceptor ; import org . apache . camel . spi . RouteContext ; import org . apache . camel . util . CamelContextHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; @ XmlRootElement ( name = "route" ) @ XmlType ( propOrder = { "inputs" , "outputs" } ) @ XmlAccessorType ( XmlAccessType . PROPERTY ) public class RouteType extends ProcessorType < ProcessorType > implements CamelContextAware { private static final transient Log LOG = LogFactory . getLog ( RouteType . class ) ; private List < InterceptorType > interceptors = new ArrayList < InterceptorType > ( ) ; private List < FromType > inputs = new ArrayList < FromType > ( ) ; private List < ProcessorType < ? > > outputs = new ArrayList < ProcessorType < ? > > ( ) ; private String group ; private CamelContext camelContext ; private Boolean streamCaching ; public RouteType ( ) { } public RouteType ( String uri ) { from ( uri ) ; } public RouteType ( Endpoint endpoint ) { from ( endpoint ) ; } @ Override public String toString ( ) { return "Route[" + inputs + " -> " + outputs + "]" ; } public void addRoutes ( CamelContext context , Collection < Route > routes ) throws Exception { setCamelContext ( context ) ; if ( context instanceof CamelContext ) { ErrorHandlerBuilder handler = context . getErrorHandlerBuilder ( ) ; if ( handler != null ) { setErrorHandlerBuilderIfNull ( handler ) ; } } for ( FromType fromType : inputs ) { addRoutes ( routes , fromType ) ; } } public Endpoint resolveEndpoint ( String uri ) throws NoSuchEndpointException { CamelContext context = getCamelContext ( ) ; if ( context == null ) { throw new IllegalArgumentException ( "No CamelContext has been injected!" ) ; } return CamelContextHelper . getMandatoryEndpoint ( context , uri ) ; } public RouteType from ( String uri ) { getInputs ( ) . add ( new FromType ( uri ) ) ; return this ; } public RouteType from ( Endpoint endpoint ) { getInputs ( ) . add ( new FromType ( endpoint ) ) ; return this ; } public RouteType group ( String name ) { setGroup ( name ) ; return this ; } public List < InterceptorType > getInterceptors ( ) { return interceptors ; } @ XmlTransient public void setInterceptors ( List < InterceptorType > interceptors ) { this . interceptors = interceptors ; } public List < FromType > getInputs ( ) { return inputs ; } @ XmlElementRef public void setInputs ( List < FromType > inputs ) { this . inputs = inputs ; } public List < ProcessorType < ? > > getOutputs ( ) { return outputs ; } @ XmlElementRef public void setOutputs ( List < ProcessorType < ? > > outputs ) { this . outputs = outputs ; if ( outputs != null ) { for ( ProcessorType output : outputs ) { configureChild ( output ) ; } } } public CamelContext getCamelContext ( ) { return camelContext ; } @ XmlTransient public void setCamelContext ( CamelContext camelContext ) { this . camelContext = camelContext ; } public String getGroup ( ) { return group ; } @ XmlAttribute public void setGroup ( String group ) { this . group = group ; } public Boolean getStreamCaching ( ) { return streamCaching ; } @ XmlAttribute ( required = false ) public void setStreamCaching ( Boolean streamCaching ) { this . streamCaching = streamCaching ; if ( streamCaching != null && streamCaching ) { streamCaching ( ) ; } else { noStreamCaching ( ) ; } } protected void addRoutes ( Collection < Route > routes , FromType fromType ) throws Exception { RouteContext routeContext = new DefaultRouteContext ( this , fromType , routes ) ; routeContext . getEndpoint ( ) ; if ( camelContext != null ) { camelContext . getLifecycleStrategy ( ) . onRouteContextCreate ( routeContext ) ; } List < ProcessorType < ? > > list = new ArrayList < ProcessorType < ? > > ( outputs ) ; for ( ProcessorType output : list ) { output . addRoutes ( routeContext , routes ) ; } routeContext . commit ( ) ; } @ Override protected void configureChild ( ProcessorType output ) { super . configureChild ( output ) ; if ( isInheritErrorHandler ( ) ) { output . setErrorHandlerBuilder ( getErrorHandlerBuilder ( ) ) ; } List < InterceptorType > interceptors = getInterceptors ( ) ; for ( InterceptorType interceptor : interceptors ) { output . addInterceptor ( interceptor ) ; } } public RouteType noStreamCaching ( ) { StreamCachingInterceptor . noStreamCaching ( interceptors ) ; return this ; } public RouteType streamCaching ( ) { addInterceptor ( new StreamCachingInterceptor ( ) ) ; return this ; } @ Override public void addInterceptor ( InterceptorType interceptor ) { getInterceptors ( ) . add ( interceptor ) ; } } 	0	['27', '3', '0', '32', '60', '245', '19', '16', '24', '0.835164835', '345', '1', '1', '0.884422111', '0.169230769', '1', '6', '11.51851852', '3', '1.0741', '0']
package org . apache . camel . component . jms ; import javax . jms . Message ; import javax . jms . MessageListener ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Processor ; import org . apache . camel . ProducerTemplate ; import org . apache . camel . impl . DefaultProducerTemplate ; import org . apache . camel . impl . ProducerTemplateProcessor ; import org . apache . camel . util . ObjectHelper ; import static org . apache . camel . util . ObjectHelper . wrapRuntimeCamelException ; public class CamelMessageListener implements MessageListener , Processor { private final CamelContext camelContext ; private final Processor processor ; private JmsBinding binding = new JmsBinding ( ) ; private ExchangePattern pattern = ExchangePattern . InOnly ; public CamelMessageListener ( CamelContext camelContext , Processor processor ) { this . camelContext = camelContext ; this . processor = processor ; ObjectHelper . notNull ( processor , "processor" ) ; } public static CamelMessageListener newInstance ( CamelContext camelContext , String endpointUri ) { DefaultProducerTemplate producerTemplate = DefaultProducerTemplate . newInstance ( camelContext , endpointUri ) ; return newInstance ( camelContext , producerTemplate ) ; } public static CamelMessageListener newInstance ( CamelContext camelContext , ProducerTemplate producerTemplate ) { return new CamelMessageListener ( camelContext , new ProducerTemplateProcessor ( producerTemplate ) ) ; } public void onMessage ( Message message ) { try { Exchange exchange = createExchange ( message ) ; process ( exchange ) ; } catch ( Exception e ) { throw wrapRuntimeCamelException ( e ) ; } } public void process ( Exchange exchange ) throws Exception { ObjectHelper . notNull ( exchange , "exchange" ) ; processor . process ( exchange ) ; } public JmsBinding getBinding ( ) { return binding ; } public void setBinding ( JmsBinding binding ) { this . binding = binding ; } public ExchangePattern getPattern ( ) { return pattern ; } public void setPattern ( ExchangePattern pattern ) { this . pattern = pattern ; } protected Exchange createExchange ( Message message ) { return new JmsExchange ( camelContext , pattern , binding , message ) ; } } 	0	['10', '1', '0', '11', '18', '21', '0', '11', '9', '0.555555556', '97', '1', '4', '0', '0.211111111', '0', '0', '8.3', '1', '0.9', '0']
package org . apache . camel . component . xmpp ; import java . util . Iterator ; import org . apache . camel . CamelException ; import org . apache . camel . Consumer ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . jivesoftware . smack . AccountManager ; import org . jivesoftware . smack . ConnectionConfiguration ; import org . jivesoftware . smack . XMPPConnection ; import org . jivesoftware . smack . XMPPException ; import org . jivesoftware . smack . packet . Message ; import org . jivesoftware . smackx . muc . MultiUserChat ; public class XmppEndpoint extends DefaultEndpoint < XmppExchange > { private static final transient Log LOG = LogFactory . getLog ( XmppEndpoint . class ) ; private XmppBinding binding ; private XMPPConnection connection ; private String host ; private int port ; private String user ; private String password ; private String resource = "Camel" ; private boolean login = true ; private boolean createAccount ; private String room ; private String participant ; private String nickname ; private String serviceName ; public XmppEndpoint ( String uri , XmppComponent component ) { super ( uri , component ) ; binding = new XmppBinding ( component . getHeaderFilterStrategy ( ) ) ; } public XmppEndpoint ( String endpointUri ) { super ( endpointUri ) ; } public Producer < XmppExchange > createProducer ( ) throws Exception { if ( room != null ) { return createGroupChatProducer ( ) ; } else { if ( participant == null ) { throw new IllegalArgumentException ( "No room or participant configured on this endpoint: " + this ) ; } return createPrivateChatProducer ( participant ) ; } } public Producer < XmppExchange > createGroupChatProducer ( ) throws Exception { return new XmppGroupChatProducer ( this ) ; } public Producer < XmppExchange > createPrivateChatProducer ( String participant ) throws Exception { return new XmppPrivateChatProducer ( this , participant ) ; } public Consumer < XmppExchange > createConsumer ( Processor processor ) throws Exception { return new XmppConsumer ( this , processor ) ; } @ Override public XmppExchange createExchange ( ExchangePattern pattern ) { return new XmppExchange ( getCamelContext ( ) , pattern , getBinding ( ) ) ; } public XmppExchange createExchange ( Message message ) { return new XmppExchange ( getCamelContext ( ) , getExchangePattern ( ) , getBinding ( ) , message ) ; } public XmppBinding getBinding ( ) { if ( binding == null ) { binding = new XmppBinding ( ) ; } return binding ; } public void setBinding ( XmppBinding binding ) { this . binding = binding ; } public String getHost ( ) { return host ; } public void setHost ( String host ) { this . host = host ; } public int getPort ( ) { return port ; } public void setPort ( int port ) { this . port = port ; } public String getUser ( ) { return user ; } public void setUser ( String user ) { this . user = user ; } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public String getResource ( ) { return resource ; } public void setResource ( String resource ) { this . resource = resource ; } public boolean isLogin ( ) { return login ; } public void setLogin ( boolean login ) { this . login = login ; } public boolean isCreateAccount ( ) { return createAccount ; } public void setCreateAccount ( boolean createAccount ) { this . createAccount = createAccount ; } public String getRoom ( ) { return room ; } public void setRoom ( String room ) { this . room = room ; } public String getParticipant ( ) { return participant ; } public void setParticipant ( String participant ) { this . participant = participant ; } public String getNickname ( ) { return nickname != null ? nickname : getUser ( ) ; } public void setNickname ( String nickname ) { this . nickname = nickname ; } public void setServiceName ( String serviceName ) { this . serviceName = serviceName ; } public String getServiceName ( ) { return serviceName ; } public XMPPConnection getConnection ( ) throws XMPPException { if ( connection == null ) { connection = createConnection ( ) ; } return connection ; } public void setConnection ( XMPPConnection connection ) { this . connection = connection ; } protected XMPPConnection createConnection ( ) throws XMPPException { XMPPConnection connection ; if ( port > 0 ) { if ( getServiceName ( ) == null ) { connection = new XMPPConnection ( new ConnectionConfiguration ( host , port ) ) ; } else { connection = new XMPPConnection ( new ConnectionConfiguration ( host , port , getServiceName ( ) ) ) ; } } else { connection = new XMPPConnection ( host ) ; } connection . connect ( ) ; if ( login && ! connection . isAuthenticated ( ) ) { if ( user != null ) { LOG . info ( "Logging in to XMPP as user: " + user + " on connection: " + connection ) ; if ( password == null ) { LOG . warn ( "No password configured for user: " + user ) ; } if ( createAccount ) { AccountManager accountManager = new AccountManager ( connection ) ; accountManager . createAccount ( user , password ) ; } if ( resource != null ) { connection . login ( user , password , resource ) ; } else { connection . login ( user , password ) ; } } else { LOG . info ( "Logging in anonymously to XMPP on connection: " + connection ) ; connection . loginAnonymously ( ) ; } } return connection ; } public String resolveRoom ( ) throws XMPPException , CamelException { if ( room == null ) { throw new IllegalArgumentException ( "room is not specified" ) ; } if ( room . indexOf ( '@' , 0 ) != - 1 ) { return room ; } XMPPConnection conn = getConnection ( ) ; Iterator < String > iterator = MultiUserChat . getServiceNames ( conn ) . iterator ( ) ; if ( ! iterator . hasNext ( ) ) { throw new CamelException ( "Can not find Multi User Chat service" ) ; } String chatServer = iterator . next ( ) ; if ( LOG . isInfoEnabled ( ) ) { LOG . info ( "Detected chat server: " + chatServer ) ; } return room + "@" + chatServer ; } public boolean isSingleton ( ) { return true ; } } 	0	['39', '2', '0', '24', '76', '641', '4', '24', '37', '0.904135338', '453', '1', '1', '0.4', '0.155263158', '1', '1', '10.25641026', '2', '0.9744', '0']
package org . apache . camel . component . spring . integration . adapter . config ; import org . w3c . dom . Attr ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . apache . camel . util . ObjectHelper ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . RuntimeBeanReference ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . xml . AbstractSingleBeanDefinitionParser ; import org . springframework . beans . factory . xml . ParserContext ; import org . springframework . util . StringUtils ; public class AbstractCamelContextBeanDefinitionParaser extends AbstractSingleBeanDefinitionParser { private static final String DEFAULT_CAMEL_CONTEXT_NAME = "camelContext" ; private String getContextId ( String contextId ) { if ( ObjectHelper . isNullOrBlank ( contextId ) ) { return DEFAULT_CAMEL_CONTEXT_NAME ; } else { return contextId ; } } protected void mapToProperty ( BeanDefinitionBuilder bean , String propertyName , String val ) { if ( ID_ATTRIBUTE . equals ( propertyName ) ) { return ; } if ( StringUtils . hasText ( val ) ) { if ( val . startsWith ( "#" ) ) { bean . addPropertyReference ( propertyName , val . substring ( 1 ) ) ; } else { bean . addPropertyValue ( propertyName , val ) ; } } } protected void wireCamelContext ( BeanDefinitionBuilder bean , String camelContextId ) { bean . addPropertyReference ( "camelContext" , camelContextId ) ; } protected void parseAttributes ( Element element , ParserContext ctx , BeanDefinitionBuilder bean ) { NamedNodeMap atts = element . getAttributes ( ) ; for ( int i = 0 ; i < atts . getLength ( ) ; i ++ ) { Attr node = ( Attr ) atts . item ( i ) ; String val = node . getValue ( ) ; String name = node . getLocalName ( ) ; if ( name . equals ( "requestChannel" ) || name . equals ( "replyChannel" ) ) { bean . addPropertyReference ( name , val ) ; } else { mapToProperty ( bean , name , val ) ; } } } protected void parseCamelContext ( Element element , ParserContext ctx , BeanDefinitionBuilder bean ) { NodeList children = element . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node n = children . item ( i ) ; if ( n . getNodeType ( ) == Node . ELEMENT_NODE ) { String name = n . getLocalName ( ) ; if ( "camelContext" . equals ( name ) ) { BeanDefinition bd = ctx . getDelegate ( ) . parseCustomElement ( ( Element ) n ) ; String contextId = ( String ) bd . getPropertyValues ( ) . getPropertyValue ( "id" ) . getValue ( ) ; wireCamelContext ( bean , getContextId ( contextId ) ) ; } else if ( "camelContextRef" . equals ( name ) ) { String contextId = n . getTextContent ( ) ; wireCamelContext ( bean , getContextId ( contextId ) ) ; } } } } protected void doParse ( Element element , ParserContext ctx , BeanDefinitionBuilder bean ) { parseAttributes ( element , ctx , bean ) ; parseCamelContext ( element , ctx , bean ) ; } } 	0	['7', '0', '2', '11', '31', '21', '2', '9', '1', '1.166666667', '163', '1', '0', '0', '0.6', '0', '0', '22.14285714', '5', '2.4286', '0']
package org . apache . camel . component . restlet ; import java . net . URI ; import java . util . Map ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . util . URISupport ; import org . apache . camel . util . UnsafeUriCharactersEncoder ; import org . restlet . data . Method ; public class RestletEndpoint extends DefaultEndpoint { private static final int DEFAULT_PORT = 80 ; private static final String DEFAULT_PROTOCOL = "http" ; private static final String DEFAULT_HOST = "localhost" ; private Method restletMethod = Method . GET ; private String protocol = DEFAULT_PROTOCOL ; private String host = DEFAULT_HOST ; private int port = DEFAULT_PORT ; private String uriPattern ; private RestletBinding restletBinding ; private Map < String , String > realm ; public RestletEndpoint ( RestletComponent component , String remaining , Map < String , String > parameters , RestletBinding restletBinding ) throws Exception { super ( remaining , component ) ; this . restletBinding = restletBinding ; URI u = new URI ( UnsafeUriCharactersEncoder . encode ( remaining ) ) ; protocol = u . getScheme ( ) ; uriPattern = u . getPath ( ) ; if ( parameters . size ( ) > 0 ) { uriPattern = uriPattern + "?" + URISupport . createQueryString ( parameters ) ; } host = u . getHost ( ) ; if ( u . getPort ( ) > 0 ) { port = u . getPort ( ) ; } } public boolean isSingleton ( ) { return true ; } @ Override public boolean isLenientProperties ( ) { return true ; } public Consumer createConsumer ( Processor processor ) throws Exception { return new RestletConsumer ( this , processor ) ; } public Producer createProducer ( ) throws Exception { return new RestletProducer ( this ) ; } public void connect ( RestletConsumer restletConsumer ) throws Exception { ( ( RestletComponent ) getComponent ( ) ) . connect ( restletConsumer ) ; } public void disconnect ( RestletConsumer restletConsumer ) throws Exception { ( ( RestletComponent ) getComponent ( ) ) . disconnect ( restletConsumer ) ; } public String getProtocol ( ) { return protocol ; } public String getHost ( ) { return host ; } public int getPort ( ) { return port ; } public String getUriPattern ( ) { return uriPattern ; } public RestletBinding getRestletBinding ( ) { return restletBinding ; } public void setRestletMethod ( Method restletMethod ) { this . restletMethod = restletMethod ; } public Method getRestletMethod ( ) { return restletMethod ; } public void setRealm ( Map < String , String > realm ) { this . realm = realm ; } public Map < String , String > getRealm ( ) { return realm ; } } 	0	['16', '2', '0', '14', '33', '102', '4', '13', '16', '0.966666667', '144', '1', '1', '0.615384615', '0.1953125', '0', '0', '7.375', '1', '0.9375', '0']
package org . apache . camel . component . jhc ; import org . apache . camel . impl . DefaultHeaderFilterStrategy ; public class JhcHeaderFilterStrategy extends DefaultHeaderFilterStrategy { public JhcHeaderFilterStrategy ( ) { initialize ( ) ; } protected void initialize ( ) { getOutFilter ( ) . add ( "content-length" ) ; getOutFilter ( ) . add ( "content-type" ) ; getOutFilter ( ) . add ( JhcProducer . HTTP_RESPONSE_CODE ) ; setIsLowercase ( true ) ; setOutFilterPattern ( "(org\\.apache\\.camel)[\\.|a-z|A-z|0-9]*" ) ; } } 	0	['2', '2', '0', '3', '7', '1', '2', '1', '1', '2', '29', '0', '0', '0.941176471', '1', '0', '0', '13.5', '1', '0.5', '0']
package org . apache . camel . bam ; public enum ActivityLifecycle { Started , Completed } 	0	['4', '2', '0', '5', '7', '4', '4', '1', '2', '0.888888889', '45', '0.333333333', '3', '0.857142857', '0.444444444', '1', '1', '9.5', '1', '0.5', '0']
package org . apache . camel . component . cxf . util ; public interface Dummy { } 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . component . cxf . transport . spring ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . apache . camel . util . ObjectHelper ; import org . apache . cxf . configuration . spring . AbstractBeanDefinitionParser ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . xml . ParserContext ; public class AbstractCamelContextBeanDefinitionParser extends AbstractBeanDefinitionParser { private static final String DEFAULT_CAMEL_CONTEXT_NAME = "camelContext" ; private String getContextId ( String contextId ) { if ( ObjectHelper . isEmpty ( contextId ) ) { return DEFAULT_CAMEL_CONTEXT_NAME ; } else { return contextId ; } } protected void wireCamelContext ( BeanDefinitionBuilder bean , String camelContextId ) { bean . addPropertyReference ( "camelContext" , camelContextId ) ; } protected void doParse ( Element element , ParserContext ctx , BeanDefinitionBuilder bean ) { bean . setAbstract ( true ) ; NodeList children = element . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node n = children . item ( i ) ; if ( n . getNodeType ( ) == Node . ELEMENT_NODE ) { String name = n . getLocalName ( ) ; if ( "camelContext" . equals ( name ) ) { BeanDefinition bd = ctx . getDelegate ( ) . parseCustomElement ( ( Element ) n ) ; String contextId = ( String ) bd . getPropertyValues ( ) . getPropertyValue ( "id" ) . getValue ( ) ; wireCamelContext ( bean , getContextId ( contextId ) ) ; } else if ( "camelContextRef" . equals ( name ) ) { String contextId = n . getTextContent ( ) ; wireCamelContext ( bean , getContextId ( contextId ) ) ; } } } } } 	0	['4', '0', '2', '10', '20', '6', '2', '8', '1', '1.333333333', '85', '1', '0', '0', '0.5', '0', '0', '20', '5', '2', '0']
package org . apache . camel . component . xmpp ; import org . apache . camel . CamelException ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . jivesoftware . smack . SmackConfiguration ; import org . jivesoftware . smack . XMPPException ; import org . jivesoftware . smack . packet . Message ; import org . jivesoftware . smackx . muc . DiscussionHistory ; import org . jivesoftware . smackx . muc . MultiUserChat ; public class XmppGroupChatProducer extends DefaultProducer { private static final transient Log LOG = LogFactory . getLog ( XmppGroupChatProducer . class ) ; private final XmppEndpoint endpoint ; private final String room ; private MultiUserChat chat ; public XmppGroupChatProducer ( XmppEndpoint endpoint ) throws XMPPException , CamelException { super ( endpoint ) ; this . endpoint = endpoint ; this . room = endpoint . resolveRoom ( ) ; if ( room == null ) { throw new IllegalArgumentException ( "No room property specified" ) ; } } public void process ( Exchange exchange ) { Message message = chat . createMessage ( ) ; message . setTo ( room ) ; message . setFrom ( endpoint . getUser ( ) ) ; endpoint . getBinding ( ) . populateXmppMessage ( message , exchange ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Sending XMPP message: " + message . getBody ( ) ) ; } try { chat . sendMessage ( message ) ; } catch ( XMPPException e ) { throw new RuntimeXmppException ( e ) ; } } @ Override protected void doStart ( ) throws Exception { if ( chat == null ) { chat = new MultiUserChat ( endpoint . getConnection ( ) , room ) ; DiscussionHistory history = new DiscussionHistory ( ) ; history . setMaxChars ( 0 ) ; chat . join ( this . endpoint . getNickname ( ) , null , history , SmackConfiguration . getPacketReplyTimeout ( ) ) ; } super . doStart ( ) ; } @ Override protected void doStop ( ) throws Exception { if ( chat != null ) { chat . leave ( ) ; chat = null ; } super . doStop ( ) ; } public MultiUserChat getChat ( ) { return chat ; } public void setChat ( MultiUserChat chat ) { this . chat = chat ; } public String getRoom ( ) { return room ; } } 	0	['8', '3', '0', '15', '36', '0', '1', '15', '5', '0.642857143', '135', '1', '1', '0.777777778', '0.357142857', '1', '1', '15.375', '2', '0.875', '0']
package org . apache . camel . spring . util ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . util . ObjectHelper ; public class SimpleRouteBuilder extends RouteBuilder { private List < String > fromUris = new ArrayList < String > ( ) ; private List < String > toUris = new ArrayList < String > ( ) ; private Class beanType ; private String beanClass ; private String beanRef ; private String beanMethod ; public void configure ( ) throws Exception { if ( fromUris . isEmpty ( ) ) { throw new IllegalArgumentException ( "the fromUris property must contain at least one valid URI" ) ; } for ( String fromUri : fromUris ) { ProcessorType route = from ( fromUri ) ; addBeanCall ( route ) ; for ( String toUri : toUris ) { route = route . to ( toUri ) ; } } } public void setFromUri ( String uri ) { setFromUris ( singletonList ( uri ) ) ; } public void setToUri ( String uri ) { setToUris ( singletonList ( uri ) ) ; } public List < String > getFromUris ( ) { return fromUris ; } public void setFromUris ( List < String > fromUris ) { this . fromUris = fromUris ; } public List < String > getToUris ( ) { return toUris ; } public void setToUris ( List < String > toUris ) { this . toUris = toUris ; } public String getBeanClass ( ) { return beanClass ; } public void setBeanClass ( String beanClass ) { this . beanClass = beanClass ; } public String getBeanRef ( ) { return beanRef ; } public void setBeanRef ( String beanRef ) { this . beanRef = beanRef ; } public Class getBeanType ( ) { if ( beanType == null ) { if ( beanClass != null ) { beanType = ObjectHelper . loadClass ( beanClass , getClass ( ) . getClassLoader ( ) ) ; } } return beanType ; } public void setBeanType ( Class beanType ) { this . beanType = beanType ; } public String getBeanMethod ( ) { return beanMethod ; } public void setBeanMethod ( String beanMethod ) { this . beanMethod = beanMethod ; } protected void addBeanCall ( ProcessorType route ) { Class type = getBeanType ( ) ; if ( type != null ) { if ( beanMethod != null ) { route = route . bean ( type , beanMethod ) ; } else { route = route . bean ( type ) ; } } else if ( beanRef != null ) { if ( beanMethod != null ) { route = route . beanRef ( beanRef , beanMethod ) ; } else { route = route . beanRef ( beanRef ) ; } } } protected List < String > singletonList ( String value ) { List < String > uris = new ArrayList < String > ( ) ; uris . add ( value ) ; return uris ; } } 	0	['18', '3', '0', '4', '35', '111', '0', '4', '16', '0.81372549', '200', '1', '0', '0.76056338', '0.311111111', '1', '2', '9.777777778', '5', '1.2778', '0']
package org . apache . camel . component . jpa ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . METHOD } ) public @ interface Consumed { } 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . component . jms ; import javax . jms . Message ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; public class JmsExchange extends DefaultExchange { private JmsBinding binding ; public JmsExchange ( CamelContext context , ExchangePattern pattern , JmsBinding binding ) { super ( context , pattern ) ; this . binding = binding ; } public JmsExchange ( CamelContext context , ExchangePattern pattern , JmsBinding binding , Message message ) { this ( context , pattern , binding ) ; setIn ( new JmsMessage ( message ) ) ; } public JmsExchange ( DefaultExchange parent , JmsBinding binding ) { super ( parent ) ; this . binding = binding ; } @ Override public JmsMessage getIn ( ) { return ( JmsMessage ) super . getIn ( ) ; } @ Override public JmsMessage getOut ( ) { return ( JmsMessage ) super . getOut ( ) ; } @ Override public JmsMessage getOut ( boolean lazyCreate ) { return ( JmsMessage ) super . getOut ( lazyCreate ) ; } @ Override public JmsMessage getFault ( ) { return ( JmsMessage ) super . getFault ( ) ; } public JmsBinding getBinding ( ) { return binding ; } @ Override public Exchange newInstance ( ) { return new JmsExchange ( this , binding ) ; } public Message getInMessage ( ) { return getIn ( ) . getJmsMessage ( ) ; } public Message getOutMessage ( ) { return getOut ( ) . getJmsMessage ( ) ; } public Message getFaultMessage ( ) { return getFault ( ) . getJmsMessage ( ) ; } @ Override protected JmsMessage createInMessage ( ) { return new JmsMessage ( ) ; } @ Override protected JmsMessage createOutMessage ( ) { return new JmsMessage ( ) ; } @ Override protected org . apache . camel . Message createFaultMessage ( ) { return new JmsMessage ( ) ; } } 	0	['21', '2', '0', '14', '25', '198', '8', '7', '16', '0.8', '119', '1', '1', '0.678571429', '0.217687075', '1', '3', '4.619047619', '1', '0.8571', '0']
package org . apache . camel . converter . jaxp ; import org . w3c . dom . Attr ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . Text ; import org . apache . camel . Converter ; @ Converter public final class DomConverter { private DomConverter ( ) { } @ Converter public static String toString ( NodeList nodeList ) { StringBuffer buffer = new StringBuffer ( ) ; append ( buffer , nodeList ) ; return buffer . toString ( ) ; } protected static void append ( StringBuffer buffer , NodeList nodeList ) { int size = nodeList . getLength ( ) ; for ( int i = 0 ; i < size ; i ++ ) { append ( buffer , nodeList . item ( i ) ) ; } } protected static void append ( StringBuffer buffer , Node node ) { if ( node instanceof Text ) { Text text = ( Text ) node ; buffer . append ( text . getTextContent ( ) ) ; } else if ( node instanceof Attr ) { Attr attribute = ( Attr ) node ; buffer . append ( attribute . getTextContent ( ) ) ; } else if ( node instanceof Element ) { Element element = ( Element ) node ; append ( buffer , element . getChildNodes ( ) ) ; } else if ( node instanceof Document ) { Document doc = ( Document ) node ; append ( buffer , doc . getChildNodes ( ) ) ; } } } 	0	['4', '1', '0', '0', '14', '6', '0', '0', '1', '2', '79', '0', '0', '0', '0.375', '0', '0', '18.75', '5', '2', '0']
package org . apache . camel . component . stream ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultComponent ; public class StreamComponent extends DefaultComponent < Exchange > { @ Override protected Endpoint < Exchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { return new StreamEndpoint ( uri , this ) ; } } 	0	['2', '3', '0', '4', '4', '1', '0', '4', '1', '2', '11', '0', '0', '0.972222222', '0.666666667', '1', '1', '4.5', '1', '0.5', '0']
package org . apache . camel . component . spring . integration ; import java . util . Map ; import org . apache . camel . impl . DefaultComponent ; public class SpringIntegrationComponent extends DefaultComponent < SpringIntegrationExchange > { protected SpringIntegrationEndpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { SpringIntegrationEndpoint endpoint = new SpringIntegrationEndpoint ( uri , remaining , this ) ; setProperties ( endpoint , parameters ) ; return endpoint ; } } 	0	['3', '3', '0', '3', '5', '3', '1', '3', '1', '2', '25', '0', '0', '0.945945946', '0.777777778', '1', '2', '7.333333333', '1', '0.6667', '0']
package org . apache . camel . component . cxf ; public interface CxfConstants { String METHOD = "method" ; String SERVICE_CLASS = "serviceClass" ; String DATA_FORMAT = "dataFormat" ; String SET_DEFAULT_BUS = "setDefaultBus" ; String WSDL_URL = "wsdlURL" ; String ADDRESS = "address" ; String SERVICE_NAME = "serviceName" ; String PORT_NAME = "portName" ; String SERVICE_LOCALNAME = "serviceLocalName" ; String SERVICE_NAMESPACE = "serviceNamespace" ; String PORT_LOCALNAME = "endpointLocalName" ; String PORT_NAMESPACE = "endpointNamespace" ; String PROTOCOL_NAME_RES = "res" ; String OPERATION_NAME = "operationName" ; String OPERATION_NAMESPACE = "operationNameSpace" ; String SPRING_CONTEXT_ENDPOINT = "bean:" ; String CAMEL_TRANSPORT_PREFIX = "camel:" ; String CXF_EXCHANGE = "org.apache.cxf.message.exchange" ; String CAMEL_EXCHANGE = "org.apache.camel.exchange" ; } 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '19', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . impl ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . PollingConsumer ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeExchangeException ; import org . apache . camel . util . ServiceHelper ; public class ProcessorPollingConsumer extends PollingConsumerSupport { private Processor processor ; public ProcessorPollingConsumer ( Endpoint endpoint , Processor processor ) { super ( endpoint ) ; this . processor = processor ; } protected void doStart ( ) throws Exception { ServiceHelper . startService ( processor ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopService ( processor ) ; } public Exchange receive ( ) { Exchange exchange = getEndpoint ( ) . createExchange ( ) ; try { processor . process ( exchange ) ; } catch ( Exception e ) { throw new RuntimeExchangeException ( e , exchange ) ; } return exchange ; } public Exchange receiveNoWait ( ) { return receive ( ) ; } public Exchange receive ( long timeout ) { return receive ( ) ; } } 	0	['6', '3', '0', '7', '13', '3', '1', '6', '4', '0', '46', '1', '1', '0.791666667', '0.375', '1', '1', '6.5', '1', '0.8333', '0']
package org . apache . camel . dataformat . xstream ; import java . io . InputStream ; import java . io . OutputStream ; import javax . xml . stream . XMLStreamException ; import javax . xml . stream . XMLStreamReader ; import javax . xml . stream . XMLStreamWriter ; import com . thoughtworks . xstream . XStream ; import com . thoughtworks . xstream . io . HierarchicalStreamReader ; import com . thoughtworks . xstream . io . HierarchicalStreamWriter ; import com . thoughtworks . xstream . io . xml . QNameMap ; import com . thoughtworks . xstream . io . xml . StaxReader ; import com . thoughtworks . xstream . io . xml . StaxWriter ; import org . apache . camel . Exchange ; import org . apache . camel . converter . jaxp . StaxConverter ; import org . apache . camel . spi . DataFormat ; public class XStreamDataFormat extends AbstractXStreamWrapper { public XStreamDataFormat ( ) { super ( ) ; } public XStreamDataFormat ( XStream xstream ) { super ( xstream ) ; } public static XStreamDataFormat processAnnotations ( Iterable < Class < ? > > types ) { XStreamDataFormat answer = new XStreamDataFormat ( ) ; XStream xstream = answer . getXStream ( ) ; for ( Class < ? > type : types ) { xstream . processAnnotations ( type ) ; } return answer ; } public static XStreamDataFormat processAnnotations ( Class < ? > ... types ) { XStreamDataFormat answer = new XStreamDataFormat ( ) ; XStream xstream = answer . getXStream ( ) ; for ( Class < ? > type : types ) { xstream . processAnnotations ( type ) ; } return answer ; } protected HierarchicalStreamWriter createHierarchicalStreamWriter ( Exchange exchange , Object body , OutputStream stream ) throws XMLStreamException { XMLStreamWriter xmlWriter = getStaxConverter ( ) . createXMLStreamWriter ( stream ) ; return new StaxWriter ( new QNameMap ( ) , xmlWriter ) ; } protected HierarchicalStreamReader createHierarchicalStreamReader ( Exchange exchange , InputStream stream ) throws XMLStreamException { XMLStreamReader xmlReader = getStaxConverter ( ) . createXMLStreamReader ( stream ) ; return new StaxReader ( new QNameMap ( ) , xmlReader ) ; } } 	0	['6', '2', '0', '9', '19', '15', '0', '9', '4', '2', '90', '0', '0', '0.692307692', '0.25', '1', '2', '14', '2', '1', '0']
package org . apache . camel . builder ; import org . apache . camel . Processor ; public class ConstantProcessorBuilder implements ProcessorFactory { private Processor processor ; public ConstantProcessorBuilder ( Processor processor ) { this . processor = processor ; } public Processor createProcessor ( ) { return processor ; } } 	0	['2', '1', '0', '3', '3', '0', '1', '2', '2', '0', '12', '1', '1', '0', '0.75', '0', '0', '4.5', '1', '0.5', '0']
package org . apache . camel . component . restlet ; import org . apache . camel . impl . DefaultHeaderFilterStrategy ; public class RestletHeaderFilterStrategy extends DefaultHeaderFilterStrategy { public RestletHeaderFilterStrategy ( ) { getOutFilter ( ) . add ( RestletConstants . LOGIN ) ; getOutFilter ( ) . add ( RestletConstants . PASSWORD ) ; } } 	0	['1', '2', '0', '2', '4', '0', '1', '1', '1', '2', '14', '0', '0', '1', '1', '0', '0', '13', '0', '0', '0']
package org . apache . camel . spring . spi ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangeProperty ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . processor . DelayPolicy ; import org . apache . camel . processor . DelegateProcessor ; import org . apache . camel . processor . RedeliveryPolicy ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . transaction . TransactionDefinition ; import org . springframework . transaction . TransactionStatus ; import org . springframework . transaction . support . DefaultTransactionStatus ; import org . springframework . transaction . support . TransactionCallbackWithoutResult ; import org . springframework . transaction . support . TransactionSynchronizationManager ; import org . springframework . transaction . support . TransactionTemplate ; import static org . apache . camel . util . ObjectHelper . wrapRuntimeCamelException ; public class TransactionInterceptor extends DelegateProcessor { public static final ExchangeProperty < Boolean > TRANSACTED = new ExchangeProperty < Boolean > ( "transacted" , "org.apache.camel.transacted" , Boolean . class ) ; private static final transient Log LOG = LogFactory . getLog ( TransactionInterceptor . class ) ; private final TransactionTemplate transactionTemplate ; private RedeliveryPolicy redeliveryPolicy ; private DelayPolicy delayPolicy ; public TransactionInterceptor ( TransactionTemplate transactionTemplate ) { this . transactionTemplate = transactionTemplate ; } public TransactionInterceptor ( Processor processor , TransactionTemplate transactionTemplate ) { super ( processor ) ; this . transactionTemplate = transactionTemplate ; } public TransactionInterceptor ( Processor processor , TransactionTemplate transactionTemplate , RedeliveryPolicy redeliveryPolicy ) { this ( processor , transactionTemplate ) ; this . redeliveryPolicy = redeliveryPolicy ; this . delayPolicy = redeliveryPolicy ; } public TransactionInterceptor ( Processor processor , TransactionTemplate transactionTemplate , DelayPolicy delayPolicy ) { this ( processor , transactionTemplate ) ; this . delayPolicy = delayPolicy ; } @ Override public String toString ( ) { return "TransactionInterceptor:" + propagationBehaviorToString ( transactionTemplate . getPropagationBehavior ( ) ) + "[" + getProcessor ( ) + "]" ; } public void process ( final Exchange exchange ) { transactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { protected void doInTransactionWithoutResult ( TransactionStatus status ) { RuntimeCamelException rce = null ; boolean activeTx = false ; try { activeTx = TransactionSynchronizationManager . isActualTransactionActive ( ) ; if ( ! activeTx ) { activeTx = status . isNewTransaction ( ) && ! status . isCompleted ( ) ; if ( ! activeTx ) { if ( DefaultTransactionStatus . class . isAssignableFrom ( status . getClass ( ) ) ) { DefaultTransactionStatus defStatus = DefaultTransactionStatus . class . cast ( status ) ; activeTx = defStatus . hasTransaction ( ) && ! status . isCompleted ( ) ; } } } if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Is actual transaction active: " + activeTx ) ; } if ( activeTx ) { TRANSACTED . set ( exchange , Boolean . TRUE ) ; } processNext ( exchange ) ; if ( exchange . getException ( ) != null ) { rce = wrapRuntimeCamelException ( exchange . getException ( ) ) ; } } catch ( Exception e ) { rce = wrapRuntimeCamelException ( e ) ; } if ( rce != null ) { delayBeforeRedelivery ( ) ; if ( activeTx ) { status . setRollbackOnly ( ) ; LOG . debug ( "Setting transaction to rollbackOnly due to exception being thrown: " + rce . getMessage ( ) ) ; } throw rce ; } } } ) ; } protected void delayBeforeRedelivery ( ) { long delay = 0 ; if ( redeliveryPolicy != null ) { delay = redeliveryPolicy . getDelay ( ) ; } else if ( delayPolicy != null ) { delay = delayPolicy . getDelay ( ) ; } if ( delay > 0 ) { try { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Sleeping for: " + delay + " millis until attempting redelivery" ) ; } Thread . sleep ( delay ) ; } catch ( InterruptedException e ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Thread interrupted: " + e , e ) ; } } } } public RedeliveryPolicy getRedeliveryPolicy ( ) { return redeliveryPolicy ; } public void setRedeliveryPolicy ( RedeliveryPolicy redeliveryPolicy ) { this . redeliveryPolicy = redeliveryPolicy ; } public DelayPolicy getDelayPolicy ( ) { return delayPolicy ; } public void setDelayPolicy ( DelayPolicy delayPolicy ) { this . delayPolicy = delayPolicy ; } protected String propagationBehaviorToString ( int propagationBehavior ) { String rc ; switch ( propagationBehavior ) { case TransactionDefinition . PROPAGATION_MANDATORY : rc = "PROPAGATION_MANDATORY" ; break ; case TransactionDefinition . PROPAGATION_NESTED : rc = "PROPAGATION_NESTED" ; break ; case TransactionDefinition . PROPAGATION_NEVER : rc = "PROPAGATION_NEVER" ; break ; case TransactionDefinition . PROPAGATION_NOT_SUPPORTED : rc = "PROPAGATION_NOT_SUPPORTED" ; break ; case TransactionDefinition . PROPAGATION_REQUIRED : rc = "PROPAGATION_REQUIRED" ; break ; case TransactionDefinition . PROPAGATION_REQUIRES_NEW : rc = "PROPAGATION_REQUIRES_NEW" ; break ; case TransactionDefinition . PROPAGATION_SUPPORTS : rc = "PROPAGATION_SUPPORTS" ; break ; default : rc = "UNKNOWN" ; } return rc ; } } 	0	['15', '3', '0', '14', '35', '57', '4', '11', '10', '0.8', '195', '0.8', '3', '0.6875', '0.241071429', '0', '0', '11.66666667', '6', '1.0667', '0']
package org . apache . camel . component . jetty ; import java . net . URI ; import java . net . URISyntaxException ; import org . apache . camel . Consumer ; import org . apache . camel . PollingConsumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . component . http . HttpClientConfigurer ; import org . apache . camel . component . http . HttpConsumer ; import org . apache . camel . component . http . HttpEndpoint ; import org . apache . camel . component . http . HttpExchange ; import org . apache . camel . component . http . HttpPollingConsumer ; import org . apache . commons . httpclient . HttpConnectionManager ; import org . apache . commons . httpclient . params . HttpClientParams ; public class JettyHttpEndpoint extends HttpEndpoint { private JettyHttpComponent component ; private boolean sessionSupport ; public JettyHttpEndpoint ( JettyHttpComponent component , String uri , URI httpURL , HttpClientParams clientParams , HttpConnectionManager httpConnectionManager , HttpClientConfigurer clientConfigurer ) throws URISyntaxException { super ( uri , component , httpURL , clientParams , httpConnectionManager , clientConfigurer ) ; this . component = component ; } @ Override public Producer < HttpExchange > createProducer ( ) throws Exception { return super . createProducer ( ) ; } @ Override public Consumer < HttpExchange > createConsumer ( Processor processor ) throws Exception { return new HttpConsumer ( this , processor ) ; } @ Override public PollingConsumer < HttpExchange > createPollingConsumer ( ) throws Exception { return new HttpPollingConsumer ( this ) ; } @ Override public JettyHttpComponent getComponent ( ) { return component ; } public void setSessionSupport ( boolean support ) { sessionSupport = support ; } public boolean isSessionSupport ( ) { return sessionSupport ; } } 	0	['8', '5', '0', '13', '11', '24', '1', '13', '8', '0.785714286', '49', '1', '1', '0.877192982', '0.222222222', '1', '1', '4.875', '1', '0.875', '0']
package org . apache . camel . component . restlet ; import java . util . HashMap ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . HeaderFilterStrategyAware ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . spi . HeaderFilterStrategy ; import org . apache . camel . util . CamelContextHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . restlet . Component ; import org . restlet . Guard ; import org . restlet . Restlet ; import org . restlet . Server ; import org . restlet . data . ChallengeScheme ; import org . restlet . data . Method ; import org . restlet . data . Protocol ; public class RestletComponent extends DefaultComponent < Exchange > implements HeaderFilterStrategyAware { private static final Log LOG = LogFactory . getLog ( RestletComponent . class ) ; private Map < String , Server > servers = new HashMap < String , Server > ( ) ; private Map < String , MethodBasedRouter > routers = new HashMap < String , MethodBasedRouter > ( ) ; private Component component = new Component ( ) ; private HeaderFilterStrategy headerFilterStrategy = new RestletHeaderFilterStrategy ( ) ; @ Override protected Endpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { RestletBinding restletBinding = null ; String ref = getAndRemoveParameter ( parameters , "restletBindingRef" , String . class ) ; if ( ref != null ) { restletBinding = CamelContextHelper . mandatoryLookup ( getCamelContext ( ) , ref , RestletBinding . class ) ; } if ( restletBinding == null ) { restletBinding = new DefaultRestletBinding ( ) ; } if ( restletBinding instanceof HeaderFilterStrategyAware ) { ( ( HeaderFilterStrategyAware ) restletBinding ) . setHeaderFilterStrategy ( headerFilterStrategy ) ; } Map < String , String > realm = null ; ref = getAndRemoveParameter ( parameters , "restletRealmRef" , String . class ) ; if ( ref != null ) { realm = CamelContextHelper . mandatoryLookup ( getCamelContext ( ) , ref , Map . class ) ; } Method method = getAndRemoveParameter ( parameters , "restletMethod" , Method . class ) ; RestletEndpoint result = new RestletEndpoint ( this , remaining , parameters , restletBinding ) ; if ( method != null ) { result . setRestletMethod ( method ) ; } if ( realm != null ) { result . setRealm ( realm ) ; } return result ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; component . start ( ) ; } @ Override protected void doStop ( ) throws Exception { component . stop ( ) ; super . doStop ( ) ; } public void connect ( RestletConsumer consumer ) throws Exception { RestletEndpoint endpoint = ( RestletEndpoint ) consumer . getEndpoint ( ) ; addServerIfNeccessary ( endpoint ) ; MethodBasedRouter router = getMethodRouter ( endpoint . getUriPattern ( ) ) ; Map < String , String > realm = endpoint . getRealm ( ) ; Restlet target = consumer . getRestlet ( ) ; if ( realm != null && realm . size ( ) > 0 ) { Guard guard = new Guard ( component . getContext ( ) . createChildContext ( ) , ChallengeScheme . HTTP_BASIC , "Camel-Restlet Endpoint Realm" ) ; for ( Map . Entry < String , String > entry : realm . entrySet ( ) ) { guard . getSecrets ( ) . put ( entry . getKey ( ) , entry . getValue ( ) . toCharArray ( ) ) ; } guard . setNext ( target ) ; target = guard ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Target has been set to guard: " + guard ) ; } } router . addRoute ( endpoint . getRestletMethod ( ) , target ) ; if ( ! router . hasBeenAttached ( ) ) { component . getDefaultHost ( ) . attach ( endpoint . getUriPattern ( ) , router ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Attached methodRouter uriPattern: " + endpoint . getUriPattern ( ) ) ; } } LOG . debug ( "Attached restlet uriPattern: " + endpoint . getUriPattern ( ) + " method: " + endpoint . getRestletMethod ( ) ) ; } public void disconnect ( RestletConsumer consumer ) throws Exception { RestletEndpoint endpoint = ( RestletEndpoint ) consumer . getEndpoint ( ) ; MethodBasedRouter router = getMethodRouter ( endpoint . getUriPattern ( ) ) ; router . removeRoute ( endpoint . getRestletMethod ( ) ) ; LOG . debug ( "Detached restlet uriPattern: " + endpoint . getUriPattern ( ) + " method: " + endpoint . getRestletMethod ( ) ) ; } public HeaderFilterStrategy getHeaderFilterStrategy ( ) { return headerFilterStrategy ; } public void setHeaderFilterStrategy ( HeaderFilterStrategy strategy ) { this . headerFilterStrategy = strategy ; } private MethodBasedRouter getMethodRouter ( String uriPattern ) { synchronized ( routers ) { MethodBasedRouter result = routers . get ( uriPattern ) ; if ( result == null ) { result = new MethodBasedRouter ( uriPattern ) ; routers . put ( uriPattern , result ) ; } return result ; } } private void addServerIfNeccessary ( RestletEndpoint endpoint ) throws Exception { String key = buildKey ( endpoint ) ; Server server = null ; synchronized ( servers ) { server = servers . get ( key ) ; if ( server == null ) { server = component . getServers ( ) . add ( Protocol . valueOf ( endpoint . getProtocol ( ) ) , endpoint . getPort ( ) ) ; servers . put ( key , server ) ; LOG . info ( "Add server: " + key ) ; server . start ( ) ; } } } private static String buildKey ( RestletEndpoint endpoint ) { return endpoint . getHost ( ) + ":" + endpoint . getPort ( ) ; } } 	0	['12', '3', '0', '25', '71', '22', '1', '25', '5', '0.727272727', '391', '1', '1', '0.777777778', '0.272727273', '2', '3', '31.16666667', '2', '0.9167', '0']
package org . apache . camel . impl . converter ; import java . lang . reflect . Method ; import org . apache . camel . Exchange ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . TypeConverter ; import org . apache . camel . util . ObjectHelper ; public class InstanceMethodTypeConverter implements TypeConverter { private final CachingInjector injector ; private final Method method ; private final boolean useExchange ; public InstanceMethodTypeConverter ( CachingInjector injector , Method method ) { this . injector = injector ; this . method = method ; this . useExchange = method . getParameterTypes ( ) . length == 2 ; } @ Override public String toString ( ) { return "InstanceMethodTypeConverter: " + method ; } public < T > T convertTo ( Class < T > type , Object value ) { return convertTo ( type , null , value ) ; } public < T > T convertTo ( Class < T > type , Exchange exchange , Object value ) { Object instance = injector . newInstance ( ) ; if ( instance == null ) { throw new RuntimeCamelException ( "Could not instantiate an instance of: " + type . getName ( ) ) ; } return useExchange ? ( T ) ObjectHelper . invokeMethod ( method , instance , value , exchange ) : ( T ) ObjectHelper . invokeMethod ( method , instance , value ) ; } } 	0	['4', '1', '0', '6', '14', '0', '1', '5', '4', '0.222222222', '90', '1', '1', '0', '0.458333333', '0', '0', '20.75', '3', '1.25', '0']
package org . apache . camel . component . atom ; import java . util . Date ; import org . apache . abdera . model . Entry ; import org . apache . abdera . model . Feed ; import org . apache . camel . Consumer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultPollingEndpoint ; import org . apache . camel . util . ObjectHelper ; public class AtomEndpoint extends DefaultPollingEndpoint < Exchange > { public static final String HEADER_ATOM_FEED = "org.apache.camel.component.atom.feed" ; private String atomUri ; private boolean splitEntries = true ; private Date lastUpdate ; private boolean filter = true ; public AtomEndpoint ( String endpointUri , AtomComponent component , String atomUri ) { super ( endpointUri , component ) ; this . atomUri = atomUri ; ObjectHelper . notNull ( atomUri , "atomUri property" ) ; } public AtomEndpoint ( String endpointUri , String atomUri ) { this ( endpointUri ) ; this . atomUri = atomUri ; ObjectHelper . notNull ( atomUri , "atomUri property" ) ; } public AtomEndpoint ( String endpointUri ) { super ( endpointUri ) ; } public boolean isSingleton ( ) { return true ; } public Producer < Exchange > createProducer ( ) throws Exception { throw new UnsupportedOperationException ( "AtomProducer is not implemented" ) ; } public Consumer < Exchange > createConsumer ( Processor processor ) throws Exception { AtomConsumerSupport answer ; if ( isSplitEntries ( ) ) { answer = new AtomEntryPollingConsumer ( this , processor , filter , lastUpdate ) ; } else { answer = new AtomPollingConsumer ( this , processor ) ; } answer . setDelay ( AtomConsumerSupport . DEFAULT_CONSUMER_DELAY ) ; configureConsumer ( answer ) ; return answer ; } public Exchange createExchange ( Feed feed ) { Exchange exchange = createExchange ( ) ; exchange . getIn ( ) . setBody ( feed . getEntries ( ) ) ; exchange . getIn ( ) . setHeader ( HEADER_ATOM_FEED , feed ) ; return exchange ; } public Exchange createExchange ( Feed feed , Entry entry ) { Exchange exchange = createExchange ( ) ; exchange . getIn ( ) . setBody ( entry ) ; exchange . getIn ( ) . setHeader ( HEADER_ATOM_FEED , feed ) ; return exchange ; } public String getAtomUri ( ) { return atomUri ; } public void setAtomUri ( String atomUri ) { this . atomUri = atomUri ; } public boolean isSplitEntries ( ) { return splitEntries ; } public void setSplitEntries ( boolean splitEntries ) { this . splitEntries = splitEntries ; } public Date getLastUpdate ( ) { return lastUpdate ; } public void setLastUpdate ( Date lastUpdate ) { this . lastUpdate = lastUpdate ; } public boolean isFilter ( ) { return filter ; } public void setFilter ( boolean filter ) { this . filter = filter ; } } 	0	['16', '4', '0', '17', '29', '72', '7', '14', '16', '0.813333333', '150', '0.8', '0', '0.69047619', '0.21875', '1', '1', '8.0625', '1', '0.8125', '0']
package org . apache . camel . component . cxf . interceptors ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import java . util . ResourceBundle ; import java . util . logging . Level ; import java . util . logging . Logger ; import javax . xml . namespace . QName ; import javax . xml . stream . XMLStreamException ; import javax . xml . stream . XMLStreamReader ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . NodeList ; import org . apache . cxf . binding . xml . XMLConstants ; import org . apache . cxf . binding . xml . XMLFault ; import org . apache . cxf . bindings . xformat . XMLBindingMessageFormat ; import org . apache . cxf . common . i18n . BundleUtils ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . endpoint . Endpoint ; import org . apache . cxf . interceptor . Fault ; import org . apache . cxf . message . Exchange ; import org . apache . cxf . message . XMLMessage ; import org . apache . cxf . phase . Phase ; import org . apache . cxf . service . model . BindingInfo ; import org . apache . cxf . service . model . BindingMessageInfo ; import org . apache . cxf . service . model . BindingOperationInfo ; import org . apache . cxf . service . model . MessagePartInfo ; import org . apache . cxf . staxutils . StaxUtils ; public class XMLMessageInInterceptor extends AbstractMessageInInterceptor < XMLMessage > { private static final Logger LOG = LogUtils . getL7dLogger ( XMLMessageInInterceptor . class ) ; public XMLMessageInInterceptor ( ) { super ( Phase . READ ) ; } protected Logger getLogger ( ) { return LOG ; } protected boolean isFaultMessage ( XMLMessage message ) { XMLStreamReader xsr = message . getContent ( XMLStreamReader . class ) ; boolean isFault = false ; try { if ( StaxUtils . skipToStartOfElement ( xsr ) ) { QName startQName = xsr . getName ( ) ; isFault = XMLConstants . NS_XML_FORMAT . equals ( startQName . getNamespaceURI ( ) ) && XMLFault . XML_FAULT_ROOT . equals ( startQName . getLocalPart ( ) ) ; } } catch ( XMLStreamException xse ) { throw new Fault ( new org . apache . cxf . common . i18n . Message ( "STAX_READ_EXC" , LOG ) ) ; } return isFault ; } protected BindingOperationInfo getBindingOperation ( XMLMessage message , Document doc ) { Exchange ex = message . getExchange ( ) ; BindingInfo binding = ex . get ( BindingInfo . class ) ; if ( binding == null ) { Endpoint ep = ex . get ( Endpoint . class ) ; binding = ep . getEndpointInfo ( ) . getBinding ( ) ; } Element payloadEl = ( Element ) doc . getChildNodes ( ) . item ( 0 ) ; QName startQName = new QName ( payloadEl . getNamespaceURI ( ) , payloadEl . getLocalName ( ) ) ; boolean client = isRequestor ( message ) ; List < BindingOperationInfo > boiList = new ArrayList < BindingOperationInfo > ( ) ; for ( BindingOperationInfo boi : binding . getOperations ( ) ) { BindingMessageInfo bmi = client ? boi . getOutput ( ) : boi . getInput ( ) ; QName rootName = null ; if ( bmi != null ) { XMLBindingMessageFormat msgFormat = bmi . getExtensor ( XMLBindingMessageFormat . class ) ; if ( msgFormat != null ) { rootName = msgFormat . getRootNode ( ) ; } else { Collection < MessagePartInfo > bodyParts = bmi . getMessageParts ( ) ; if ( bodyParts . size ( ) == 1 ) { MessagePartInfo p = bodyParts . iterator ( ) . next ( ) ; rootName = p . getConcreteName ( ) ; } } } if ( startQName . equals ( rootName ) ) { boiList . add ( boi ) ; } } BindingOperationInfo match = null ; if ( boiList . size ( ) > 1 ) { if ( LOG . isLoggable ( Level . INFO ) ) { LOG . info ( "Mulitple matching BindingOperationIno found in Binding." ) ; } } else if ( ! boiList . isEmpty ( ) ) { match = boiList . get ( 0 ) ; } return match ; } protected List < Element > getPartList ( XMLMessage inMessage , Element rootNode , BindingMessageInfo bmi ) { List < Element > partList = new ArrayList < Element > ( ) ; XMLBindingMessageFormat msgFormat = bmi . getExtensor ( XMLBindingMessageFormat . class ) ; if ( msgFormat != null ) { NodeList nodeList = rootNode . getChildNodes ( ) ; for ( int idx = 0 ; idx < nodeList . getLength ( ) ; idx ++ ) { partList . add ( ( Element ) nodeList . item ( idx ) ) ; } } else { partList . add ( rootNode ) ; } return partList ; } } 	0	['9', '1', '0', '16', '50', '24', '1', '15', '1', '0.375', '239', '1', '0', '0.5', '0.416666667', '1', '4', '25.44444444', '10', '2.1111', '0']
package org . apache . camel . component . atom ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . ScheduledPollConsumer ; public abstract class AtomConsumerSupport extends ScheduledPollConsumer < Exchange > { public static final long DEFAULT_CONSUMER_DELAY = 60 * 1000L ; protected final AtomEndpoint endpoint ; public AtomConsumerSupport ( AtomEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; } } 	0	['1', '4', '1', '5', '2', '0', '2', '4', '1', '2', '11', '0.5', '1', '1', '1', '0', '0', '8', '0', '0', '0']
package org . apache . camel . component . spring . integration ; import java . util . HashMap ; import java . util . Map ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . spring . SpringCamelContext ; import org . apache . camel . util . AsyncProcessorHelper ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . integration . channel . BeanFactoryChannelResolver ; import org . springframework . integration . channel . ChannelResolver ; import org . springframework . integration . channel . DirectChannel ; import org . springframework . integration . core . Message ; import org . springframework . integration . core . MessageChannel ; import org . springframework . integration . core . MessageHeaders ; import org . springframework . integration . message . MessageHandler ; public class SpringIntegrationProducer extends DefaultProducer < SpringIntegrationExchange > implements AsyncProcessor { private static final transient Log LOG = LogFactory . getLog ( SpringIntegrationProducer . class ) ; private SpringCamelContext context ; private DirectChannel inputChannel ; private MessageChannel outputChannel ; private String outputChannelName ; private ChannelResolver channelResolver ; private SpringIntegrationEndpoint endpoint ; public SpringIntegrationProducer ( SpringIntegrationEndpoint endpoint ) { super ( endpoint ) ; this . endpoint = endpoint ; context = ( SpringCamelContext ) endpoint . getCamelContext ( ) ; if ( context != null && endpoint . getMessageChannel ( ) == null ) { outputChannelName = endpoint . getDefaultChannel ( ) ; channelResolver = new BeanFactoryChannelResolver ( context . getApplicationContext ( ) ) ; if ( ObjectHelper . isNullOrBlank ( outputChannelName ) ) { outputChannelName = endpoint . getInputChannel ( ) ; } if ( ObjectHelper . isNullOrBlank ( outputChannelName ) ) { throw new RuntimeCamelException ( "Can't find the right outputChannelName, " + "please check the endpoint uri outputChannel part!" ) ; } else { outputChannel = channelResolver . resolveChannelName ( outputChannelName ) ; } } else { if ( endpoint . getMessageChannel ( ) != null ) { outputChannel = endpoint . getMessageChannel ( ) ; } else { throw new RuntimeCamelException ( "Can't find the right message channel, please check your configuration." ) ; } } if ( endpoint . isInOut ( ) ) { endpoint . setExchangePattern ( ExchangePattern . InOut ) ; if ( ObjectHelper . isNullOrBlank ( endpoint . getInputChannel ( ) ) ) { throw new RuntimeCamelException ( "Can't find the right inputChannel, " + "please check the endpoint uri inputChannel part!" ) ; } else { inputChannel = ( DirectChannel ) channelResolver . resolveChannelName ( endpoint . getInputChannel ( ) ) ; } } else { endpoint . setExchangePattern ( ExchangePattern . InOnly ) ; } } public void process ( Exchange exchange ) throws Exception { AsyncProcessorHelper . process ( this , exchange ) ; } public boolean process ( final Exchange exchange , final AsyncCallback callback ) { Map < String , Object > headers = new HashMap < String , Object > ( ) ; if ( exchange . getPattern ( ) . isOutCapable ( ) ) { headers . put ( MessageHeaders . REPLY_CHANNEL , inputChannel ) ; inputChannel . subscribe ( new MessageHandler ( ) { public void handleMessage ( Message < ? > message ) { SpringIntegrationBinding . storeToCamelMessage ( message , exchange . getOut ( ) ) ; callback . done ( true ) ; } } ) ; } org . springframework . integration . core . Message siOutmessage = SpringIntegrationBinding . createSpringIntegrationMessage ( exchange , headers ) ; outputChannel . send ( siOutmessage ) ; if ( ! exchange . getPattern ( ) . isOutCapable ( ) ) { callback . done ( true ) ; } return true ; } } 	0	['4', '3', '0', '24', '27', '4', '2', '24', '3', '0.904761905', '156', '1', '2', '0.913043478', '0.583333333', '0', '0', '36.25', '3', '1', '0']
package org . apache . camel . component . http ; import java . net . URI ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . HeaderFilterStrategyAware ; import org . apache . camel . ResolveEndpointFailedException ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . spi . HeaderFilterStrategy ; import org . apache . camel . util . CamelContextHelper ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . camel . util . URISupport ; import org . apache . commons . httpclient . HttpConnectionManager ; import org . apache . commons . httpclient . MultiThreadedHttpConnectionManager ; import org . apache . commons . httpclient . params . HttpClientParams ; public class HttpComponent extends DefaultComponent < HttpExchange > implements HeaderFilterStrategyAware { protected HttpClientConfigurer httpClientConfigurer ; protected HttpConnectionManager httpConnectionManager = new MultiThreadedHttpConnectionManager ( ) ; protected HeaderFilterStrategy headerFilterStrategy ; protected HttpBinding httpBinding ; public HttpComponent ( ) { this . setHeaderFilterStrategy ( new HttpHeaderFilterStrategy ( ) ) ; } public void connect ( HttpConsumer consumer ) throws Exception { } public void disconnect ( HttpConsumer consumer ) throws Exception { } protected void configureParameters ( Map parameters ) { String ref = getAndRemoveParameter ( parameters , "httpBindingRef" , String . class ) ; if ( ref != null ) { httpBinding = CamelContextHelper . mandatoryLookup ( getCamelContext ( ) , ref , HttpBinding . class ) ; } String username = getAndRemoveParameter ( parameters , "username" , String . class ) ; String password = getAndRemoveParameter ( parameters , "password" , String . class ) ; if ( username != null && password != null ) { httpClientConfigurer = new BasicAuthenticationHttpClientConfigurer ( username , password ) ; } ref = getAndRemoveParameter ( parameters , "httpClientConfigurerRef" , String . class ) ; if ( ref != null ) { httpClientConfigurer = CamelContextHelper . mandatoryLookup ( getCamelContext ( ) , ref , HttpClientConfigurer . class ) ; } } @ Override protected Endpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { HttpClientParams params = new HttpClientParams ( ) ; IntrospectionSupport . setProperties ( params , parameters , "httpClient." ) ; configureParameters ( parameters ) ; URI httpUri = URISupport . createRemainingURI ( new URI ( uri ) , parameters ) ; uri = httpUri . toString ( ) ; String part = httpUri . getSchemeSpecificPart ( ) ; if ( part != null ) { part = part . toLowerCase ( ) ; if ( part . startsWith ( "//http//" ) || part . startsWith ( "//https//" ) ) { throw new ResolveEndpointFailedException ( uri , "The uri part is not configured correctly. You have duplicated the http(s) protocol." ) ; } } HttpEndpoint endpoint = new HttpEndpoint ( uri , this , httpUri , params , httpConnectionManager , httpClientConfigurer ) ; if ( httpBinding != null ) { endpoint . setBinding ( httpBinding ) ; } return endpoint ; } @ Override protected boolean useIntrospectionOnEndpoint ( ) { return false ; } public HttpClientConfigurer getHttpClientConfigurer ( ) { return httpClientConfigurer ; } public void setHttpClientConfigurer ( HttpClientConfigurer httpClientConfigurer ) { this . httpClientConfigurer = httpClientConfigurer ; } public HttpConnectionManager getHttpConnectionManager ( ) { return httpConnectionManager ; } public void setHttpConnectionManager ( HttpConnectionManager httpConnectionManager ) { this . httpConnectionManager = httpConnectionManager ; } public HeaderFilterStrategy getHeaderFilterStrategy ( ) { return headerFilterStrategy ; } public void setHeaderFilterStrategy ( HeaderFilterStrategy strategy ) { headerFilterStrategy = strategy ; } public HttpBinding getHttpBinding ( ) { return httpBinding ; } public void setHttpBinding ( HttpBinding httpBinding ) { this . httpBinding = httpBinding ; } } 	0	['14', '3', '1', '20', '32', '55', '3', '18', '11', '0.788461538', '188', '1', '3', '0.729166667', '0.205357143', '1', '2', '12.14285714', '5', '1.2143', '0']
package org . apache . camel . bam . model ; import java . util . List ; import javax . persistence . Entity ; import javax . persistence . GeneratedValue ; import javax . persistence . Id ; import javax . persistence . Table ; import javax . persistence . UniqueConstraint ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . orm . jpa . JpaTemplate ; @ Entity @ Table ( name = "PROCESSDEFINITION" , uniqueConstraints = @ UniqueConstraint ( columnNames = { "name" } ) ) public class ProcessDefinition extends EntitySupport { private static final transient Log LOG = LogFactory . getLog ( ProcessDefinition . class ) ; private String name ; @ Override @ Id @ GeneratedValue public Long getId ( ) { return super . getId ( ) ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public static ProcessDefinition getRefreshedProcessDefinition ( JpaTemplate template , ProcessDefinition definition ) { ObjectHelper . notNull ( definition , "definition" ) ; Long id = definition . getId ( ) ; if ( id == null ) { LOG . warn ( "No primary key is available!" ) ; return findOrCreateProcessDefinition ( template , definition . getName ( ) ) ; } definition = template . find ( ProcessDefinition . class , id ) ; return definition ; } public static ProcessDefinition findOrCreateProcessDefinition ( JpaTemplate template , String processName ) { List < ProcessDefinition > list = template . find ( "select x from " + ProcessDefinition . class . getName ( ) + " x where x.name = ?1" , processName ) ; if ( ! list . isEmpty ( ) ) { return list . get ( 0 ) ; } else { ProcessDefinition answer = new ProcessDefinition ( ) ; answer . setName ( processName ) ; template . persist ( answer ) ; return answer ; } } } 	0	['7', '2', '0', '11', '21', '17', '6', '5', '6', '0.666666667', '90', '1', '0', '0.375', '0.375', '0', '0', '11.57142857', '2', '1', '0']
package org . apache . camel . spring . util ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . Arrays ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . factory . InitializingBean ; import static org . apache . camel . util . ObjectHelper . name ; public class MainRunner implements InitializingBean , Runnable { private static final Log LOG = LogFactory . getLog ( MainRunner . class ) ; private Class main ; private String [ ] args = { } ; private boolean asyncRun = true ; private long delay ; public String toString ( ) { return "MainRunner(" + name ( main ) + " " + Arrays . asList ( getArgs ( ) ) + ")" ; } public void run ( ) { try { runMethodWithoutCatchingExceptions ( ) ; } catch ( NoSuchMethodException e ) { LOG . error ( "Class: " + name ( main ) + " does not have a main method: " + e , e ) ; } catch ( IllegalAccessException e ) { LOG . error ( "Failed to run: " + this + ". Reason: " + e , e ) ; } catch ( InvocationTargetException e ) { Throwable throwable = e . getTargetException ( ) ; LOG . error ( "Failed to run: " + this + ". Reason: " + throwable , throwable ) ; } } public void runMethodWithoutCatchingExceptions ( ) throws NoSuchMethodException , IllegalAccessException , InvocationTargetException { if ( delay > 0 ) { try { Thread . sleep ( delay ) ; } catch ( InterruptedException e ) { LOG . info ( "Caught: " + e , e ) ; } } Method method = main . getMethod ( "main" , String [ ] . class ) ; if ( ! Modifier . isStatic ( method . getModifiers ( ) ) ) { throw new IllegalArgumentException ( "The main method is not static!: " + method ) ; } Object [ ] arguments = { getArgs ( ) } ; method . invoke ( null , arguments ) ; } public String [ ] getArgs ( ) { return args ; } public void setArgs ( String [ ] args ) { this . args = args ; } public boolean isAsyncRun ( ) { return asyncRun ; } public void setAsyncRun ( boolean asyncRun ) { this . asyncRun = asyncRun ; } public Class getMain ( ) { return main ; } public void setMain ( Class main ) { this . main = main ; } public long getDelay ( ) { return delay ; } public void setDelay ( long delay ) { this . delay = delay ; } public void afterPropertiesSet ( ) throws Exception { if ( main == null ) { throw new IllegalArgumentException ( "You must specify a main class!" ) ; } if ( isAsyncRun ( ) ) { Thread thread = new Thread ( this , "Thread for: " + this ) ; thread . start ( ) ; } else { runMethodWithoutCatchingExceptions ( ) ; } } } 	0	['14', '1', '0', '4', '33', '39', '0', '4', '13', '0.692307692', '231', '1', '0', '0', '0.261538462', '0', '0', '15.14285714', '1', '0.8571', '0']
package org . apache . camel . component . stringtemplate ; import java . io . StringWriter ; import java . util . Map ; import org . antlr . stringtemplate . AutoIndentWriter ; import org . antlr . stringtemplate . StringTemplate ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . component . ResourceBasedEndpoint ; import org . apache . camel . converter . IOConverter ; import org . apache . camel . util . ExchangeHelper ; public class StringTemplateEndpoint extends ResourceBasedEndpoint { public StringTemplateEndpoint ( String uri , StringTemplateComponent component , String resourceUri , Map parameters ) { super ( uri , component , resourceUri , null ) ; } public StringTemplateEndpoint ( String endpointUri , Processor processor , String resourceUri ) { super ( endpointUri , processor , resourceUri ) ; } @ Override public boolean isSingleton ( ) { return true ; } @ Override public ExchangePattern getExchangePattern ( ) { return ExchangePattern . InOut ; } @ Override protected void onExchange ( Exchange exchange ) throws Exception { StringWriter buffer = new StringWriter ( ) ; Map variableMap = ExchangeHelper . createVariableMap ( exchange ) ; String text = IOConverter . toString ( getResourceAsInputStream ( ) ) ; StringTemplate template = new StringTemplate ( text ) ; template . setAttributes ( variableMap ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "StringTemplate is writing using attributes: " + variableMap ) ; } template . write ( new AutoIndentWriter ( buffer ) ) ; Message out = exchange . getOut ( true ) ; out . setBody ( buffer . toString ( ) ) ; out . setHeader ( "org.apache.camel.stringtemplate.resource" , getResource ( ) ) ; } } 	0	['5', '6', '0', '14', '26', '10', '1', '14', '4', '2', '77', '0', '0', '0.933333333', '0.366666667', '0', '0', '14.4', '1', '0.6', '0']
package org . apache . camel . impl . converter ; import java . lang . reflect . Method ; import org . apache . camel . Exchange ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . TypeConverter ; import org . apache . camel . util . ObjectHelper ; public class EnumTypeConverter implements TypeConverter { public < T > T convertTo ( Class < T > type , Object value ) { if ( type . isEnum ( ) && value != null ) { String text = value . toString ( ) ; Method method = null ; try { method = type . getMethod ( "valueOf" , String . class ) ; } catch ( NoSuchMethodException e ) { throw new RuntimeCamelException ( "Could not find valueOf method on enum type: " + type . getName ( ) ) ; } return ( T ) ObjectHelper . invokeMethod ( method , null , text ) ; } return null ; } public < T > T convertTo ( Class < T > type , Exchange exchange , Object value ) { return convertTo ( type , value ) ; } } 	0	['3', '1', '0', '5', '13', '3', '1', '4', '3', '2', '58', '0', '0', '0', '0.666666667', '0', '0', '18.33333333', '3', '1.3333', '0']
package org . apache . camel . component . direct ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultComponent ; public class DirectComponent < E extends Exchange > extends DefaultComponent < E > { protected Endpoint < E > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { Endpoint < E > endpoint = new DirectEndpoint < E > ( uri , this ) ; setProperties ( endpoint , parameters ) ; return endpoint ; } } 	0	['2', '3', '0', '3', '5', '1', '1', '3', '1', '2', '17', '0', '0', '0.972222222', '0.666666667', '1', '2', '7.5', '1', '0.5', '0']
package org . apache . camel . impl ; import org . apache . camel . Processor ; import org . apache . camel . spi . Policy ; public class NoPolicy < E > implements Policy < E > { public Processor wrap ( Processor processor ) { return processor ; } } 	0	['2', '1', '0', '2', '3', '1', '0', '2', '2', '2', '7', '0', '0', '0', '0.75', '0', '0', '2.5', '1', '0.5', '0']
package org . apache . camel . component . mail ; import javax . mail . Flags ; import javax . mail . Folder ; import javax . mail . FolderNotFoundException ; import javax . mail . Message ; import javax . mail . MessagingException ; import javax . mail . Store ; import javax . mail . search . FlagTerm ; import org . apache . camel . Processor ; import org . apache . camel . impl . ScheduledPollConsumer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . mail . javamail . JavaMailSenderImpl ; public class MailConsumer extends ScheduledPollConsumer < MailExchange > { public static final long DEFAULT_CONSUMER_DELAY = 60 * 1000L ; private static final transient Log LOG = LogFactory . getLog ( MailConsumer . class ) ; private final MailEndpoint endpoint ; private final JavaMailSenderImpl sender ; private Folder folder ; private Store store ; public MailConsumer ( MailEndpoint endpoint , Processor processor , JavaMailSenderImpl sender ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; this . sender = sender ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; } @ Override protected void doStop ( ) throws Exception { if ( folder != null && folder . isOpen ( ) ) { folder . close ( true ) ; } if ( store != null && store . isConnected ( ) ) { store . close ( ) ; } super . doStop ( ) ; } protected void poll ( ) throws Exception { ensureIsConnected ( ) ; if ( store == null || folder == null ) { throw new IllegalStateException ( "MailConsumer did not connect properly to the MailStore: " + endpoint . getConfiguration ( ) . getMailStoreLogInformation ( ) ) ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Polling mailfolder: " + endpoint . getConfiguration ( ) . getMailStoreLogInformation ( ) ) ; } if ( endpoint . getConfiguration ( ) . getFetchSize ( ) == 0 ) { LOG . warn ( "Fetch size is 0 meaning the configuration is set to poll no new messages at all. Camel will skip this poll." ) ; return ; } if ( ! folder . isOpen ( ) ) { folder . open ( Folder . READ_WRITE ) ; } try { int count = folder . getMessageCount ( ) ; if ( count > 0 ) { Message [ ] messages ; if ( endpoint . getConfiguration ( ) . isProcessOnlyUnseenMessages ( ) ) { messages = folder . search ( new FlagTerm ( new Flags ( Flags . Flag . SEEN ) , false ) ) ; } else { messages = folder . getMessages ( ) ; } processMessages ( messages ) ; } else if ( count == - 1 ) { throw new MessagingException ( "Folder: " + folder . getFullName ( ) + " is closed" ) ; } } finally { try { if ( folder . isOpen ( ) ) { folder . close ( true ) ; } } catch ( MessagingException e ) { LOG . debug ( "Could not close mailbox folder: " + folder . getName ( ) , e ) ; } } } protected void ensureIsConnected ( ) throws MessagingException { MailConfiguration config = endpoint . getConfiguration ( ) ; if ( store == null || ! store . isConnected ( ) ) { store = sender . getSession ( ) . getStore ( config . getProtocol ( ) ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Connecting to MailStore " + endpoint . getConfiguration ( ) . getMailStoreLogInformation ( ) ) ; } store . connect ( config . getHost ( ) , config . getPort ( ) , config . getUsername ( ) , config . getPassword ( ) ) ; } if ( folder == null ) { folder = store . getFolder ( config . getFolderName ( ) ) ; if ( folder == null || ! folder . exists ( ) ) { throw new FolderNotFoundException ( folder , "Folder not found or invalid: " + config . getFolderName ( ) ) ; } } } protected void processMessages ( Message [ ] messages ) throws Exception { int fetchSize = endpoint . getConfiguration ( ) . getFetchSize ( ) ; int count = fetchSize == - 1 ? messages . length : Math . min ( fetchSize , messages . length ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Fetching " + count + " messages. Total " + messages . length + " messages." ) ; } for ( int i = 0 ; i < count ; i ++ ) { Message message = messages [ i ] ; if ( ! message . getFlags ( ) . contains ( Flags . Flag . DELETED ) ) { processMessage ( message ) ; flagMessageProcessed ( message ) ; } else { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Skipping message as it was flagged as deleted: " + MailUtils . dumpMessage ( message ) ) ; } } } } protected void processMessage ( Message message ) throws Exception { MailExchange exchange = endpoint . createExchange ( message ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Processing message: " + MailUtils . dumpMessage ( message ) ) ; } getProcessor ( ) . process ( exchange ) ; } protected void flagMessageProcessed ( Message message ) throws MessagingException { if ( endpoint . getConfiguration ( ) . isDeleteProcessedMessages ( ) ) { message . setFlag ( Flags . Flag . DELETED , true ) ; } else { message . setFlag ( Flags . Flag . SEEN , true ) ; } } } 	0	['9', '4', '0', '11', '60', '0', '1', '11', '1', '0.708333333', '407', '0.833333333', '1', '0.833333333', '0.291666667', '2', '4', '43.55555556', '1', '0.7778', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlType ; import org . apache . camel . processor . DelegateProcessor ; import org . apache . camel . spi . RouteContext ; @ XmlType ( name = "interceptorType" ) public abstract class InterceptorType extends OutputType implements Block { public abstract DelegateProcessor createInterceptor ( RouteContext routeContext ) throws Exception ; } 	0	['2', '4', '1', '9', '3', '1', '5', '4', '2', '2', '5', '0', '0', '0.994444444', '0.75', '0', '0', '1.5', '1', '0.5', '0']
package org . apache . camel . component . bean ; import java . io . Externalizable ; import java . io . IOException ; import java . io . ObjectInput ; import java . io . ObjectOutput ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . Arrays ; import org . apache . camel . Exchange ; import org . apache . camel . util . IOHelper ; import org . apache . camel . util . ObjectHelper ; public class BeanInvocation implements Externalizable { private Object [ ] args ; private MethodBean methodBean ; private transient Method method ; public BeanInvocation ( ) { } public BeanInvocation ( Method method , Object [ ] args ) { this . method = method ; this . args = args ; } @ Override public String toString ( ) { Object list = null ; if ( args != null ) { list = Arrays . asList ( args ) ; } return "BeanInvocation " + method + " with " + list + "]" ; } public Object [ ] getArgs ( ) { return args ; } public Method getMethod ( ) { return method ; } public void setMethod ( Method method ) { this . method = method ; } public void setArgs ( Object [ ] args ) { this . args = args ; } public void invoke ( Object pojo , Exchange exchange ) { try { Object response = getMethod ( ) . invoke ( pojo , getArgs ( ) ) ; exchange . getOut ( ) . setBody ( response ) ; } catch ( InvocationTargetException e ) { exchange . setException ( e . getCause ( ) ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Throwable e ) { throw new RuntimeException ( e ) ; } } public void readExternal ( ObjectInput objectInput ) throws IOException , ClassNotFoundException { methodBean = ObjectHelper . cast ( MethodBean . class , objectInput . readObject ( ) ) ; try { method = methodBean . getMethod ( ) ; } catch ( NoSuchMethodException e ) { throw IOHelper . createIOException ( e ) ; } args = ObjectHelper . cast ( Object [ ] . class , objectInput . readObject ( ) ) ; } public void writeExternal ( ObjectOutput objectOutput ) throws IOException { if ( methodBean == null ) { methodBean = new MethodBean ( method ) ; } objectOutput . writeObject ( methodBean ) ; objectOutput . writeObject ( args ) ; } } 	0	['10', '1', '0', '10', '28', '0', '5', '5', '10', '0.518518519', '136', '1', '1', '0', '0.257142857', '0', '0', '12.3', '2', '0.9', '0']
package org . apache . camel . component . jms ; import org . apache . camel . impl . DefaultHeaderFilterStrategy ; import org . apache . camel . util . ObjectHelper ; public class JmsHeaderFilterStrategy extends DefaultHeaderFilterStrategy { public JmsHeaderFilterStrategy ( ) { initialize ( ) ; } protected void initialize ( ) { getOutFilter ( ) . add ( "JMSXUserID" ) ; getOutFilter ( ) . add ( "JMSXAppID" ) ; getOutFilter ( ) . add ( "JMSXDeliveryCount" ) ; getOutFilter ( ) . add ( "JMSXProducerTXID" ) ; getOutFilter ( ) . add ( "JMSXConsumerTXID" ) ; getOutFilter ( ) . add ( "JMSXRcvTimestamp" ) ; getOutFilter ( ) . add ( "JMSXRecvTimestamp" ) ; getOutFilter ( ) . add ( "JMSXState" ) ; } @ Override protected boolean extendedFilter ( Direction direction , String key , Object value ) { return Direction . OUT == direction && ! ObjectHelper . isJavaIdentifier ( JmsBinding . encodeToSafeJmsHeaderName ( key ) ) ; } } 	0	['3', '2', '0', '6', '8', '3', '3', '4', '1', '2', '60', '0', '0', '0.888888889', '0.5', '1', '1', '19', '3', '1.3333', '0']
package org . apache . camel . component . mock ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . processor . ThroughputLogger ; public class MockComponent extends DefaultComponent < Exchange > { @ Override protected Endpoint < Exchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { MockEndpoint endpoint = new MockEndpoint ( uri , this ) ; Integer value = getAndRemoveParameter ( parameters , "reportGroup" , Integer . class ) ; if ( value != null ) { Processor reporter = new ThroughputLogger ( "org.apache.camel.mock:" + remaining , value ) ; endpoint . setReporter ( reporter ) ; } return endpoint ; } } 	0	['2', '3', '0', '6', '11', '1', '0', '6', '1', '2', '39', '0', '0', '0.972222222', '0.666666667', '1', '2', '18.5', '1', '0.5', '0']
package org . apache . camel . component . xmpp ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; import org . jivesoftware . smack . packet . Message ; public class XmppExchange extends DefaultExchange { private XmppBinding binding ; public XmppExchange ( CamelContext context , ExchangePattern pattern , XmppBinding binding ) { super ( context , pattern ) ; this . binding = binding ; } public XmppExchange ( CamelContext context , ExchangePattern pattern , XmppBinding binding , Message message ) { this ( context , pattern , binding ) ; setIn ( new XmppMessage ( message ) ) ; } public XmppExchange ( DefaultExchange parent , XmppBinding binding ) { super ( parent ) ; this . binding = binding ; } public XmppMessage getIn ( ) { return ( XmppMessage ) super . getIn ( ) ; } @ Override public XmppMessage getOut ( ) { return ( XmppMessage ) super . getOut ( ) ; } @ Override public XmppMessage getOut ( boolean lazyCreate ) { return ( XmppMessage ) super . getOut ( lazyCreate ) ; } @ Override public XmppMessage getFault ( ) { return ( XmppMessage ) super . getFault ( ) ; } public XmppBinding getBinding ( ) { return binding ; } @ Override public Exchange newInstance ( ) { return new XmppExchange ( this , binding ) ; } public Message getInMessage ( ) { return getIn ( ) . getXmppMessage ( ) ; } public Message getOutMessage ( ) { return getOut ( ) . getXmppMessage ( ) ; } public Message getFaultMessage ( ) { return getOut ( ) . getXmppMessage ( ) ; } @ Override protected XmppMessage createInMessage ( ) { return new XmppMessage ( ) ; } @ Override protected XmppMessage createOutMessage ( ) { return new XmppMessage ( ) ; } } 	0	['20', '2', '0', '10', '24', '178', '4', '8', '16', '0.789473684', '114', '1', '1', '0.690909091', '0.221428571', '1', '3', '4.65', '1', '0.85', '0']
package org . apache . camel . component . http ; import org . apache . camel . impl . DefaultHeaderFilterStrategy ; public class HttpHeaderFilterStrategy extends DefaultHeaderFilterStrategy { public HttpHeaderFilterStrategy ( ) { initialize ( ) ; } protected void initialize ( ) { getOutFilter ( ) . add ( "content-length" ) ; getOutFilter ( ) . add ( "content-type" ) ; getOutFilter ( ) . add ( HttpMethods . HTTP_METHOD ) ; getOutFilter ( ) . add ( HttpProducer . QUERY ) ; getOutFilter ( ) . add ( HttpProducer . HTTP_RESPONSE_CODE . toLowerCase ( ) ) ; setIsLowercase ( true ) ; setOutFilterPattern ( "(org\\.apache\\.camel)[\\.|a-z|A-z|0-9]*" ) ; } } 	0	['2', '2', '0', '3', '8', '1', '2', '1', '1', '2', '40', '0', '0', '0.941176471', '1', '0', '0', '19', '1', '0.5', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Processor ; import org . apache . camel . processor . CatchProcessor ; import org . apache . camel . spi . RouteContext ; import org . apache . camel . util . ObjectHelper ; @ XmlRootElement ( name = "catch" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class CatchType extends ProcessorType < CatchType > { @ XmlElement ( name = "exception" ) private List < String > exceptions = new ArrayList < String > ( ) ; @ XmlElementRef private List < ProcessorType < ? > > outputs = new ArrayList < ProcessorType < ? > > ( ) ; @ XmlTransient private List < Class > exceptionClasses ; public CatchType ( ) { } public CatchType ( List < Class > exceptionClasses ) { this . exceptionClasses = exceptionClasses ; } public CatchType ( Class exceptionType ) { exceptionClasses = new ArrayList < Class > ( ) ; exceptionClasses . add ( exceptionType ) ; } @ Override public String toString ( ) { return "Catch[ " + getExceptionClasses ( ) + " -> " + getOutputs ( ) + "]" ; } @ Override public String getShortName ( ) { return "catch" ; } @ Override public String getLabel ( ) { return getExceptionClasses ( ) . toString ( ) ; } @ Override public CatchProcessor createProcessor ( RouteContext routeContext ) throws Exception { Processor childProcessor = routeContext . createProcessor ( this ) ; return new CatchProcessor ( getExceptionClasses ( ) , childProcessor ) ; } public List < ProcessorType < ? > > getOutputs ( ) { return outputs ; } public void setOutputs ( List < ProcessorType < ? > > outputs ) { this . outputs = outputs ; } public List < Class > getExceptionClasses ( ) { if ( exceptionClasses == null ) { exceptionClasses = createExceptionClasses ( ) ; } return exceptionClasses ; } public void setExceptionClasses ( List < Class > exceptionClasses ) { this . exceptionClasses = exceptionClasses ; } public List < String > getExceptions ( ) { return exceptions ; } public void setExceptions ( List < String > exceptions ) { this . exceptions = exceptions ; } protected List < Class > createExceptionClasses ( ) { List < String > list = getExceptions ( ) ; List < Class > answer = new ArrayList < Class > ( list . size ( ) ) ; for ( String name : list ) { Class type = ObjectHelper . loadClass ( name , getClass ( ) . getClassLoader ( ) ) ; answer . add ( type ) ; } return answer ; } } 	0	['15', '3', '0', '6', '32', '61', '1', '5', '14', '0.595238095', '168', '1', '0', '0.936170213', '0.366666667', '1', '3', '10', '2', '0.9333', '0']
package org . apache . camel . component . http ; import java . io . IOException ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . apache . camel . Message ; import org . apache . camel . spi . HeaderFilterStrategy ; public interface HttpBinding { void readRequest ( HttpServletRequest request , HttpMessage message ) ; Object parseBody ( HttpMessage httpMessage ) throws IOException ; void writeResponse ( HttpExchange exchange , HttpServletResponse response ) throws IOException ; void doWriteExceptionResponse ( Throwable exception , HttpServletResponse response ) throws IOException ; void doWriteFaultResponse ( Message message , HttpServletResponse response ) throws IOException ; void doWriteResponse ( Message message , HttpServletResponse response ) throws IOException ; boolean isUseReaderForPayload ( ) ; void setUseReaderForPayload ( boolean useReaderForPayload ) ; HeaderFilterStrategy getHeaderFilterStrategy ( ) ; void setHeaderFilterStrategy ( HeaderFilterStrategy headerFilterStrategy ) ; } 	0	['10', '1', '0', '11', '10', '45', '8', '4', '10', '2', '10', '0', '0', '0', '0.255555556', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . amqp ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . component . jms . JmsComponent ; import org . apache . camel . component . jms . JmsConfiguration ; import org . apache . qpid . client . AMQConnectionFactory ; import org . apache . qpid . url . URLSyntaxException ; public class AMQPComponent extends JmsComponent { public AMQPComponent ( ) { init ( ) ; } public AMQPComponent ( JmsConfiguration configuration ) { super ( configuration ) ; } public AMQPComponent ( CamelContext context ) { super ( context ) ; init ( ) ; } public AMQPComponent ( AMQConnectionFactory connectionFactory ) { setConnectionFactory ( connectionFactory ) ; } public static Component amqpComponent ( String uri ) throws URLSyntaxException { AMQConnectionFactory connectionFactory = new AMQConnectionFactory ( uri ) ; return new AMQPComponent ( connectionFactory ) ; } private void init ( ) { AMQConnectionFactory connectionFactory = new AMQConnectionFactory ( ) ; setConnectionFactory ( connectionFactory ) ; } } 	0	['6', '4', '0', '6', '12', '15', '0', '6', '5', '2', '45', '0', '0', '0.979166667', '0.3', '0', '0', '6.5', '1', '0.3333', '0']
package org . apache . camel . component . cxf . invoker ; import java . util . Map ; import org . apache . cxf . message . Exchange ; import org . apache . cxf . message . Message ; public interface InvokingContext { void setRequestOutMessageContent ( Message message , Map < Class , Object > contents ) ; Object getResponseObject ( Exchange exchange , Map < String , Object > responseContext ) ; void setResponseContent ( Message outMessage , Object resultPayload ) ; Map < Class , Object > getRequestContent ( Message inMessage ) ; } 	0	['4', '1', '0', '6', '4', '6', '4', '2', '4', '2', '4', '0', '0', '0', '0.55', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . jdbc ; import java . sql . Connection ; import java . sql . ResultSet ; import java . sql . ResultSetMetaData ; import java . sql . SQLException ; import java . sql . Statement ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import javax . sql . DataSource ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultExchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class JdbcProducer extends DefaultProducer < DefaultExchange > { private static final transient Log LOG = LogFactory . getLog ( JdbcProducer . class ) ; private DataSource dataSource ; private int readSize ; public JdbcProducer ( JdbcEndpoint endpoint , DataSource dataSource , int readSize ) throws Exception { super ( endpoint ) ; this . dataSource = dataSource ; this . readSize = readSize ; } public void process ( Exchange exchange ) throws Exception { String sql = exchange . getIn ( ) . getBody ( String . class ) ; Connection conn = null ; Statement stmt = null ; ResultSet rs = null ; try { conn = dataSource . getConnection ( ) ; stmt = conn . createStatement ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Executing JDBC statement: " + sql ) ; } if ( stmt . execute ( sql ) ) { rs = stmt . getResultSet ( ) ; setResultSet ( exchange , rs ) ; } else { int updateCount = stmt . getUpdateCount ( ) ; exchange . getOut ( ) . setHeader ( "jdbc.updateCount" , updateCount ) ; } } finally { try { if ( rs != null ) { rs . close ( ) ; } if ( stmt != null ) { stmt . close ( ) ; } if ( conn != null ) { conn . close ( ) ; } } catch ( SQLException e ) { LOG . warn ( "Error closing JDBC resource: " + e , e ) ; } } } protected void setResultSet ( Exchange exchange , ResultSet rs ) throws SQLException { ResultSetMetaData meta = rs . getMetaData ( ) ; HashMap < String , Object > props = new HashMap < String , Object > ( ) ; IntrospectionSupport . getProperties ( meta , props , "jdbc." ) ; exchange . getOut ( ) . setHeaders ( props ) ; int count = meta . getColumnCount ( ) ; List < HashMap < String , Object > > data = new ArrayList < HashMap < String , Object > > ( ) ; int rowNumber = 0 ; while ( rs . next ( ) && ( readSize == 0 || rowNumber < readSize ) ) { HashMap < String , Object > row = new HashMap < String , Object > ( ) ; for ( int i = 0 ; i < count ; i ++ ) { int columnNumber = i + 1 ; String columnName = meta . getColumnName ( columnNumber ) ; row . put ( columnName , rs . getObject ( columnName ) ) ; } data . add ( row ) ; rowNumber ++ ; } exchange . getOut ( ) . setBody ( data ) ; } } 	0	['4', '3', '0', '8', '38', '0', '1', '8', '2', '0.555555556', '201', '1', '0', '0.913043478', '0.5', '0', '0', '48.5', '1', '0.5', '0']
package org . apache . camel . component . test ; import java . net . URI ; import java . util . HashMap ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . util . CamelContextHelper ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . UnsafeUriCharactersEncoder ; public class TestComponent extends DefaultComponent < Exchange > { public Endpoint < Exchange > createEndpoint ( String uri ) throws Exception { ObjectHelper . notNull ( getCamelContext ( ) , "camelContext" ) ; URI u = new URI ( UnsafeUriCharactersEncoder . encode ( uri ) ) ; String path = u . getSchemeSpecificPart ( ) ; return createEndpoint ( uri , path , new HashMap ( ) ) ; } @ Override protected Endpoint < Exchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { Endpoint endpoint = CamelContextHelper . getMandatoryEndpoint ( getCamelContext ( ) , remaining ) ; return new TestEndpoint ( uri , this , endpoint ) ; } } 	0	['3', '3', '0', '8', '12', '3', '0', '8', '2', '2', '39', '0', '0', '0.945945946', '0.666666667', '1', '1', '12', '1', '0.6667', '0']
package org . apache . camel . component . quartz ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; public class QuartzConsumer extends DefaultConsumer < QuartzExchange > { public QuartzConsumer ( QuartzEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; } @ Override public QuartzEndpoint getEndpoint ( ) { return ( QuartzEndpoint ) super . getEndpoint ( ) ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; getEndpoint ( ) . consumerStarted ( this ) ; } @ Override protected void doStop ( ) throws Exception { getEndpoint ( ) . consumerStopped ( this ) ; super . doStop ( ) ; } } 	0	['5', '3', '0', '4', '10', '10', '1', '4', '3', '2', '31', '0', '0', '0.851851852', '0.466666667', '1', '1', '5.2', '1', '0.8', '0']
package org . apache . camel . component . cxf . invoker ; import java . util . List ; import org . w3c . dom . Element ; import org . apache . cxf . binding . soap . SoapHeader ; public class PayloadMessage { private List < Element > payload ; private List < SoapHeader > headers ; public PayloadMessage ( List < Element > payload , List < SoapHeader > headers ) { this . payload = payload ; this . headers = headers ; } public List < Element > getPayload ( ) { return payload ; } public List < SoapHeader > getHeaders ( ) { return headers ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "payload: " + payload ) ; buf . append ( " headers: " + headers ) ; return buf . toString ( ) ; } } 	0	['4', '1', '0', '1', '12', '0', '1', '0', '4', '0.333333333', '52', '1', '0', '0', '0.625', '0', '0', '11.5', '1', '0.75', '0']
package org . apache . camel . model ; public class NodeFactory { public FilterType createFilter ( ) { return new FilterType ( ) ; } public LoopType createLoop ( ) { return new LoopType ( ) ; } public RouteType createRoute ( ) { return new RouteType ( ) ; } } 	0	['4', '1', '0', '4', '8', '6', '1', '3', '4', '2', '19', '0', '0', '0', '1', '0', '0', '3.75', '1', '0.75', '0']
package org . apache . camel . component . jhc ; import java . io . IOException ; import org . apache . http . ConnectionReuseStrategy ; import org . apache . http . HttpException ; import org . apache . http . HttpRequest ; import org . apache . http . HttpResponse ; import org . apache . http . HttpResponseFactory ; import org . apache . http . HttpStatus ; import org . apache . http . HttpVersion ; import org . apache . http . ProtocolVersion ; import org . apache . http . impl . DefaultConnectionReuseStrategy ; import org . apache . http . impl . DefaultHttpResponseFactory ; import org . apache . http . nio . NHttpServerConnection ; import org . apache . http . nio . util . ByteBufferAllocator ; import org . apache . http . params . HttpParams ; import org . apache . http . protocol . BasicHttpProcessor ; import org . apache . http . protocol . ExecutionContext ; import org . apache . http . protocol . HttpContext ; import org . apache . http . protocol . HttpProcessor ; import org . apache . http . protocol . HttpRequestHandler ; import org . apache . http . protocol . ResponseConnControl ; import org . apache . http . protocol . ResponseContent ; import org . apache . http . protocol . ResponseDate ; import org . apache . http . protocol . ResponseServer ; public class AsyncBufferingHttpServiceHandler extends BufferingHttpServiceHandler { public AsyncBufferingHttpServiceHandler ( final HttpParams params ) { super ( createDefaultProcessor ( ) , new DefaultHttpResponseFactory ( ) , new DefaultConnectionReuseStrategy ( ) , params ) ; } public AsyncBufferingHttpServiceHandler ( final HttpProcessor httpProcessor , final HttpResponseFactory responseFactory , final ConnectionReuseStrategy connStrategy , final HttpParams params ) { super ( httpProcessor , responseFactory , connStrategy , params ) ; } public AsyncBufferingHttpServiceHandler ( final HttpProcessor httpProcessor , final HttpResponseFactory responseFactory , final ConnectionReuseStrategy connStrategy , final ByteBufferAllocator allocator , final HttpParams params ) { super ( httpProcessor , responseFactory , connStrategy , allocator , params ) ; } protected static HttpProcessor createDefaultProcessor ( ) { BasicHttpProcessor httpproc = new BasicHttpProcessor ( ) ; httpproc . addInterceptor ( new ResponseDate ( ) ) ; httpproc . addInterceptor ( new ResponseServer ( ) ) ; httpproc . addInterceptor ( new ResponseContent ( ) ) ; httpproc . addInterceptor ( new ResponseConnControl ( ) ) ; return httpproc ; } protected void processRequest ( final NHttpServerConnection conn , final HttpRequest request ) throws IOException , HttpException { HttpContext context = conn . getContext ( ) ; ProtocolVersion ver = request . getRequestLine ( ) . getProtocolVersion ( ) ; if ( ! ver . lessEquals ( HttpVersion . HTTP_1_1 ) ) { ver = HttpVersion . HTTP_1_1 ; } context . setAttribute ( ExecutionContext . HTTP_REQUEST , request ) ; context . setAttribute ( ExecutionContext . HTTP_CONNECTION , conn ) ; try { this . httpProcessor . process ( request , context ) ; HttpRequestHandler handler = null ; if ( handlerResolver != null ) { String requestURI = request . getRequestLine ( ) . getUri ( ) ; handler = handlerResolver . lookup ( requestURI ) ; } if ( handler != null ) { if ( handler instanceof AsyncHttpRequestHandler ) { ( ( AsyncHttpRequestHandler ) handler ) . handle ( request , context , new AsyncResponseHandler ( ) { public void sendResponse ( HttpResponse response ) throws IOException , HttpException { try { AsyncBufferingHttpServiceHandler . this . sendResponse ( conn , response ) ; } catch ( HttpException ex ) { response = AsyncBufferingHttpServiceHandler . this . responseFactory . newHttpResponse ( HttpVersion . HTTP_1_0 , HttpStatus . SC_INTERNAL_SERVER_ERROR , conn . getContext ( ) ) ; response . setParams ( AsyncBufferingHttpServiceHandler . this . params ) ; AsyncBufferingHttpServiceHandler . this . handleException ( ex , response ) ; AsyncBufferingHttpServiceHandler . this . sendResponse ( conn , response ) ; } } } ) ; } else { HttpResponse response = this . responseFactory . newHttpResponse ( ver , HttpStatus . SC_OK , conn . getContext ( ) ) ; response . setParams ( this . params ) ; context . setAttribute ( ExecutionContext . HTTP_RESPONSE , response ) ; handler . handle ( request , response , context ) ; sendResponse ( conn , response ) ; } } else { HttpResponse response = this . responseFactory . newHttpResponse ( ver , HttpStatus . SC_OK , conn . getContext ( ) ) ; response . setStatusCode ( HttpStatus . SC_NOT_IMPLEMENTED ) ; } } catch ( HttpException ex ) { HttpResponse response = this . responseFactory . newHttpResponse ( HttpVersion . HTTP_1_0 , HttpStatus . SC_INTERNAL_SERVER_ERROR , context ) ; response . setParams ( this . params ) ; handleException ( ex , response ) ; sendResponse ( conn , response ) ; } } } 	0	['7', '1', '0', '28', '33', '17', '2', '27', '3', '2', '180', '0', '0', '0.714285714', '0.285714286', '1', '4', '24.71428571', '1', '0.5714', '0']
package org . apache . camel . processor ; import java . util . concurrent . ArrayBlockingQueue ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . RejectedExecutionException ; import java . util . concurrent . ThreadFactory ; import java . util . concurrent . ThreadPoolExecutor ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . Service ; import org . apache . camel . util . AsyncProcessorHelper ; public class ThreadProcessor implements AsyncProcessor , Service { private ThreadPoolExecutor executor ; private long stackSize ; private ThreadGroup threadGroup ; private int priority = Thread . NORM_PRIORITY ; private boolean daemon = true ; private String name = "Thread Processor" ; private BlockingQueue < Runnable > taskQueue ; private long keepAliveTime ; private int maxSize = 1 ; private int coreSize = 1 ; private final AtomicBoolean shutdown = new AtomicBoolean ( true ) ; private boolean callerRunsWhenRejected = true ; class ProcessCall implements Runnable { private final Exchange exchange ; private final AsyncCallback callback ; public ProcessCall ( Exchange exchange , AsyncCallback callback ) { this . exchange = exchange ; this . callback = callback ; } public void run ( ) { if ( shutdown . get ( ) ) { exchange . setException ( new RejectedExecutionException ( ) ) ; } callback . done ( false ) ; } } public void process ( Exchange exchange ) throws Exception { AsyncProcessorHelper . process ( this , exchange ) ; } public boolean process ( final Exchange exchange , final AsyncCallback callback ) { if ( shutdown . get ( ) ) { throw new IllegalStateException ( "ThreadProcessor is not running." ) ; } ProcessCall call = new ProcessCall ( exchange , callback ) ; try { executor . execute ( call ) ; return false ; } catch ( RejectedExecutionException e ) { if ( callerRunsWhenRejected ) { if ( shutdown . get ( ) ) { exchange . setException ( new RejectedExecutionException ( ) ) ; } else { callback . done ( true ) ; } } else { exchange . setException ( e ) ; } return true ; } } public void start ( ) throws Exception { shutdown . set ( false ) ; getExecutor ( ) ; } public void stop ( ) throws Exception { shutdown . set ( true ) ; executor . shutdown ( ) ; executor . awaitTermination ( 0 , TimeUnit . SECONDS ) ; } public long getStackSize ( ) { return stackSize ; } public void setStackSize ( long stackSize ) { this . stackSize = stackSize ; } public ThreadGroup getThreadGroup ( ) { return threadGroup ; } public void setThreadGroup ( ThreadGroup threadGroup ) { this . threadGroup = threadGroup ; } public int getPriority ( ) { return priority ; } public void setPriority ( int priority ) { this . priority = priority ; } public boolean isDaemon ( ) { return daemon ; } public void setDaemon ( boolean daemon ) { this . daemon = daemon ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public long getKeepAliveTime ( ) { return keepAliveTime ; } public void setKeepAliveTime ( long keepAliveTime ) { this . keepAliveTime = keepAliveTime ; } public int getMaxSize ( ) { return maxSize ; } public void setMaxSize ( int maxSize ) { this . maxSize = maxSize ; } public int getCoreSize ( ) { return coreSize ; } public void setCoreSize ( int coreSize ) { this . coreSize = coreSize ; } public BlockingQueue < Runnable > getTaskQueue ( ) { if ( taskQueue == null ) { taskQueue = new ArrayBlockingQueue < Runnable > ( 1000 ) ; } return taskQueue ; } public void setTaskQueue ( BlockingQueue < Runnable > taskQueue ) { this . taskQueue = taskQueue ; } public ThreadPoolExecutor getExecutor ( ) { if ( executor == null ) { executor = new ThreadPoolExecutor ( getCoreSize ( ) , getMaxSize ( ) , getKeepAliveTime ( ) , TimeUnit . MILLISECONDS , getTaskQueue ( ) , new ThreadFactory ( ) { public Thread newThread ( Runnable runnable ) { Thread thread ; if ( getStackSize ( ) > 0 ) { thread = new Thread ( getThreadGroup ( ) , runnable , getName ( ) , getStackSize ( ) ) ; } else { thread = new Thread ( getThreadGroup ( ) , runnable , getName ( ) ) ; } thread . setDaemon ( isDaemon ( ) ) ; thread . setPriority ( getPriority ( ) ) ; return thread ; } } ) ; } return executor ; } public void setExecutor ( ThreadPoolExecutor executor ) { this . executor = executor ; } public boolean isCallerRunsWhenRejected ( ) { return callerRunsWhenRejected ; } public void setCallerRunsWhenRejected ( boolean callerRunsWhenRejected ) { this . callerRunsWhenRejected = callerRunsWhenRejected ; } } 	0	['28', '1', '0', '8', '44', '300', '3', '7', '27', '0.910493827', '248', '1', '0', '0', '0.136363636', '0', '0', '7.428571429', '4', '1.1429', '0']
package org . apache . camel . component . dataset ; import org . apache . camel . Processor ; public class SimpleDataSet extends DataSetSupport { private Object defaultBody = "<hello>world!</hello>" ; private Processor inputTransformer ; public SimpleDataSet ( ) { } public SimpleDataSet ( int size ) { super ( size ) ; } public Object getDefaultBody ( ) { return defaultBody ; } public void setDefaultBody ( Object defaultBody ) { this . defaultBody = defaultBody ; } public Processor getInputTransformer ( ) { return inputTransformer ; } public void setInputTransformer ( Processor inputTransformer ) { this . inputTransformer = inputTransformer ; } protected Object createMessageBody ( long messageIndex ) { return getDefaultBody ( ) ; } } 	0	['7', '2', '0', '2', '9', '7', '0', '2', '6', '0.583333333', '39', '1', '1', '0.722222222', '0.314285714', '1', '1', '4.285714286', '1', '0.7143', '0']
package org . apache . camel . component . bean ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; public class BeanExchange extends DefaultExchange { public BeanExchange ( CamelContext context , ExchangePattern pattern ) { super ( context , pattern ) ; } public BeanExchange ( DefaultExchange parent ) { super ( parent ) ; } public BeanInvocation getInvocation ( ) { return getIn ( ) . getBody ( BeanInvocation . class ) ; } public void setInvocation ( BeanInvocation invocation ) { getIn ( ) . setBody ( invocation ) ; } @ Override public Exchange newInstance ( ) { return new BeanExchange ( this ) ; } } 	0	['5', '2', '0', '9', '10', '10', '3', '6', '5', '2', '30', '0', '0', '0.926829268', '0.36', '1', '1', '5', '1', '0.6', '0']
package org . apache . camel . spring ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlElements ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Routes ; import org . apache . camel . builder . ErrorHandlerBuilder ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . impl . DefaultLifecycleStrategy ; import org . apache . camel . management . DefaultInstrumentationAgent ; import org . apache . camel . management . InstrumentationLifecycleStrategy ; import org . apache . camel . model . ExceptionType ; import org . apache . camel . model . IdentifiedType ; import org . apache . camel . model . InterceptType ; import org . apache . camel . model . ProceedType ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . model . RouteBuilderRef ; import org . apache . camel . model . RouteContainer ; import org . apache . camel . model . RouteType ; import org . apache . camel . model . dataformat . DataFormatsType ; import org . apache . camel . processor . interceptor . Debugger ; import org . apache . camel . processor . interceptor . Delayer ; import org . apache . camel . processor . interceptor . TraceFormatter ; import org . apache . camel . processor . interceptor . Tracer ; import org . apache . camel . spi . LifecycleStrategy ; import org . apache . camel . spi . Registry ; import org . apache . camel . util . ResolverUtil ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . factory . DisposableBean ; import org . springframework . beans . factory . FactoryBean ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . beans . factory . config . BeanPostProcessor ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . context . ApplicationEvent ; import org . springframework . context . ApplicationListener ; import org . springframework . context . event . ContextRefreshedEvent ; import static org . apache . camel . util . ObjectHelper . wrapRuntimeCamelException ; @ XmlRootElement ( name = "camelContext" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class CamelContextFactoryBean extends IdentifiedType implements RouteContainer , FactoryBean , InitializingBean , DisposableBean , ApplicationContextAware , ApplicationListener { private static final Log LOG = LogFactory . getLog ( CamelContextFactoryBean . class ) ; @ XmlAttribute ( required = false ) @ Deprecated private Boolean useJmx = Boolean . TRUE ; @ XmlAttribute ( required = false ) private Boolean autowireRouteBuilders = Boolean . TRUE ; @ XmlAttribute ( required = false ) private Boolean trace ; @ XmlAttribute ( required = false ) private Long delay ; @ XmlAttribute ( required = false ) private String errorHandlerRef ; @ XmlAttribute ( required = false ) private Boolean shouldStartContext = Boolean . TRUE ; @ XmlElement ( name = "package" , required = false ) private String [ ] packages = { } ; @ XmlElement ( name = "jmxAgent" , type = CamelJMXAgentType . class , required = false ) private CamelJMXAgentType camelJMXAgent ; @ XmlElements ( { @ XmlElement ( name = "beanPostProcessor" , type = CamelBeanPostProcessor . class , required = false ) , @ XmlElement ( name = "template" , type = CamelTemplateFactoryBean . class , required = false ) , @ XmlElement ( name = "proxy" , type = CamelProxyFactoryType . class , required = false ) , @ XmlElement ( name = "export" , type = CamelServiceExporterType . class , required = false ) } ) private List beans ; @ XmlElement ( name = "routeBuilderRef" , required = false ) private List < RouteBuilderRef > builderRefs = new ArrayList < RouteBuilderRef > ( ) ; @ XmlElement ( name = "endpoint" , required = false ) private List < EndpointFactoryBean > endpoints ; @ XmlElement ( name = "dataFormats" , required = false ) private DataFormatsType dataFormats ; @ XmlElement ( name = "intercept" , required = false ) private List < InterceptType > intercepts = new ArrayList < InterceptType > ( ) ; @ XmlElement ( name = "route" , required = false ) private List < RouteType > routes = new ArrayList < RouteType > ( ) ; @ XmlTransient private SpringCamelContext context ; @ XmlTransient private RouteBuilder routeBuilder ; @ XmlTransient private List < Routes > additionalBuilders = new ArrayList < Routes > ( ) ; @ XmlTransient private ApplicationContext applicationContext ; @ XmlTransient private ClassLoader contextClassLoaderOnStart ; @ XmlTransient private BeanPostProcessor beanPostProcessor ; public CamelContextFactoryBean ( ) { contextClassLoaderOnStart = Thread . currentThread ( ) . getContextClassLoader ( ) ; } public Object getObject ( ) throws Exception { return getContext ( ) ; } public Class getObjectType ( ) { return SpringCamelContext . class ; } public boolean isSingleton ( ) { return true ; } public ClassLoader getContextClassLoaderOnStart ( ) { return contextClassLoaderOnStart ; } public List < Routes > getAdditionalBuilders ( ) { return additionalBuilders ; } public void afterPropertiesSet ( ) throws Exception { Debugger debugger = getBeanForType ( Debugger . class ) ; if ( debugger != null ) { getContext ( ) . addInterceptStrategy ( debugger ) ; } Tracer tracer = getBeanForType ( Tracer . class ) ; if ( tracer != null ) { TraceFormatter formatter = getBeanForType ( TraceFormatter . class ) ; if ( formatter != null ) { tracer . setFormatter ( formatter ) ; } getContext ( ) . addInterceptStrategy ( tracer ) ; } Delayer delayer = getBeanForType ( Delayer . class ) ; if ( delayer != null ) { getContext ( ) . addInterceptStrategy ( delayer ) ; } LifecycleStrategy lifecycleStrategy = getBeanForType ( LifecycleStrategy . class ) ; if ( lifecycleStrategy != null ) { getContext ( ) . setLifecycleStrategy ( lifecycleStrategy ) ; } Registry registry = getBeanForType ( Registry . class ) ; if ( registry != null ) { getContext ( ) . setRegistry ( registry ) ; } if ( beanPostProcessor != null ) { if ( beanPostProcessor instanceof ApplicationContextAware ) { ( ( ApplicationContextAware ) beanPostProcessor ) . setApplicationContext ( applicationContext ) ; } if ( beanPostProcessor instanceof CamelBeanPostProcessor ) { ( ( CamelBeanPostProcessor ) beanPostProcessor ) . setCamelContext ( getContext ( ) ) ; } } for ( RouteType route : routes ) { for ( InterceptType intercept : intercepts ) { List < ProcessorType < ? > > outputs = new ArrayList < ProcessorType < ? > > ( ) ; List < ProcessorType < ? > > exceptionHandlers = new ArrayList < ProcessorType < ? > > ( ) ; for ( ProcessorType output : route . getOutputs ( ) ) { if ( output instanceof ExceptionType ) { exceptionHandlers . add ( output ) ; } else { outputs . add ( output ) ; } } route . clearOutput ( ) ; route . getOutputs ( ) . addAll ( exceptionHandlers ) ; InterceptType proxy = intercept . createProxy ( ) ; route . addOutput ( proxy ) ; route . pushBlock ( proxy . getProceed ( ) ) ; int outputsSize = proxy . getOutputs ( ) . size ( ) ; if ( outputsSize > 0 ) { ProcessorType processorType = proxy . getOutputs ( ) . get ( outputsSize - 1 ) ; if ( processorType instanceof ProceedType ) { route . getOutputs ( ) . addAll ( outputs ) ; } } } } if ( dataFormats != null ) { getContext ( ) . setDataFormats ( dataFormats . asMap ( ) ) ; } getContext ( ) . addRouteDefinitions ( routes ) ; if ( ! isJmxEnabled ( ) || ( camelJMXAgent != null && camelJMXAgent . isDisabled ( ) ) ) { LOG . debug ( "JMXAgent disabled" ) ; getContext ( ) . setLifecycleStrategy ( new DefaultLifecycleStrategy ( ) ) ; } else if ( camelJMXAgent != null ) { LOG . debug ( "JMXAgent enabled" ) ; if ( lifecycleStrategy != null ) { LOG . warn ( "lifecycleStrategy will be overriden by InstrumentationLifecycleStrategy" ) ; } DefaultInstrumentationAgent agent = new DefaultInstrumentationAgent ( ) ; agent . setConnectorPort ( camelJMXAgent . getConnectorPort ( ) ) ; agent . setCreateConnector ( camelJMXAgent . isCreateConnector ( ) ) ; agent . setMBeanObjectDomainName ( camelJMXAgent . getMbeanObjectDomainName ( ) ) ; agent . setMBeanServerDefaultDomain ( camelJMXAgent . getMbeanServerDefaultDomain ( ) ) ; agent . setRegistryPort ( camelJMXAgent . getRegistryPort ( ) ) ; agent . setServiceUrlPath ( camelJMXAgent . getServiceUrlPath ( ) ) ; agent . setUsePlatformMBeanServer ( camelJMXAgent . isUsePlatformMBeanServer ( ) ) ; getContext ( ) . setLifecycleStrategy ( new InstrumentationLifecycleStrategy ( agent ) ) ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Found JAXB created routes: " + getRoutes ( ) ) ; } findRouteBuilders ( ) ; installRoutes ( ) ; } private < T > T getBeanForType ( Class < T > clazz ) { T bean = null ; String [ ] names = getApplicationContext ( ) . getBeanNamesForType ( clazz , true , true ) ; if ( names . length == 1 ) { bean = ( T ) getApplicationContext ( ) . getBean ( names [ 0 ] , clazz ) ; } if ( bean == null ) { ApplicationContext parentContext = getApplicationContext ( ) . getParent ( ) ; if ( parentContext != null ) { names = parentContext . getBeanNamesForType ( clazz , true , true ) ; if ( names . length == 1 ) { bean = ( T ) parentContext . getBean ( names [ 0 ] , clazz ) ; } } } return bean ; } public void destroy ( ) throws Exception { getContext ( ) . stop ( ) ; } public void onApplicationEvent ( ApplicationEvent event ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Publishing spring-event: " + event ) ; } if ( event instanceof ContextRefreshedEvent ) { try { LOG . debug ( "Starting the context now!" ) ; getContext ( ) . start ( ) ; } catch ( Exception e ) { throw wrapRuntimeCamelException ( e ) ; } } } public SpringCamelContext getContext ( ) throws Exception { if ( context == null ) { context = createContext ( ) ; } return context ; } public void setContext ( SpringCamelContext context ) { this . context = context ; } public List < RouteType > getRoutes ( ) { return routes ; } public void setRoutes ( List < RouteType > routes ) { this . routes = routes ; } public List < InterceptType > getIntercepts ( ) { return intercepts ; } public void setIntercepts ( List < InterceptType > intercepts ) { this . intercepts = intercepts ; } public RouteBuilder getRouteBuilder ( ) { return routeBuilder ; } public void setRouteBuilder ( RouteBuilder routeBuilder ) { this . routeBuilder = routeBuilder ; } public void setRouteBuilders ( RouteBuilder [ ] builders ) { for ( RouteBuilder builder : builders ) { additionalBuilders . add ( builder ) ; } } public ApplicationContext getApplicationContext ( ) { if ( applicationContext == null ) { throw new IllegalArgumentException ( "No applicationContext has been injected!" ) ; } return applicationContext ; } public void setApplicationContext ( ApplicationContext applicationContext ) { this . applicationContext = applicationContext ; } public String [ ] getPackages ( ) { return packages ; } public void setPackages ( String [ ] packages ) { this . packages = packages ; } public void setBeanPostProcessor ( BeanPostProcessor postProcessor ) { this . beanPostProcessor = postProcessor ; } public BeanPostProcessor getBeanPostProcessor ( ) { return beanPostProcessor ; } public boolean isJmxEnabled ( ) { return useJmx . booleanValue ( ) ; } public Boolean getUseJmx ( ) { return useJmx ; } public void setUseJmx ( Boolean useJmx ) { this . useJmx = useJmx ; } public void setCamelJMXAgent ( CamelJMXAgentType agent ) { camelJMXAgent = agent ; } public Boolean getTrace ( ) { return trace ; } public void setTrace ( Boolean trace ) { this . trace = trace ; } public Long getDelay ( ) { return delay ; } public void setDelay ( Long delay ) { this . delay = delay ; } public CamelJMXAgentType getCamelJMXAgent ( ) { return camelJMXAgent ; } public List < RouteBuilderRef > getBuilderRefs ( ) { return builderRefs ; } public void setBuilderRefs ( List < RouteBuilderRef > builderRefs ) { this . builderRefs = builderRefs ; } public void setAutowireRouteBuilders ( Boolean autowireRouteBuilders ) { this . autowireRouteBuilders = autowireRouteBuilders ; } public String getErrorHandlerRef ( ) { return errorHandlerRef ; } public void setErrorHandlerRef ( String errorHandlerRef ) { this . errorHandlerRef = errorHandlerRef ; } public Boolean getShouldStartContext ( ) { return shouldStartContext ; } public void setShouldStartContext ( Boolean shouldStartContext ) { this . shouldStartContext = shouldStartContext ; } protected SpringCamelContext createContext ( ) { SpringCamelContext ctx = new SpringCamelContext ( getApplicationContext ( ) ) ; ctx . setName ( getId ( ) ) ; if ( trace != null ) { ctx . setTrace ( trace ) ; } if ( delay != null ) { ctx . setDelay ( delay ) ; } if ( errorHandlerRef != null ) { ErrorHandlerBuilder errorHandlerBuilder = ( ErrorHandlerBuilder ) getApplicationContext ( ) . getBean ( errorHandlerRef , ErrorHandlerBuilder . class ) ; if ( errorHandlerBuilder == null ) { throw new IllegalArgumentException ( "Could not find bean: " + errorHandlerRef ) ; } ctx . setErrorHandlerBuilder ( errorHandlerBuilder ) ; } if ( shouldStartContext != null ) { ctx . setShouldStartContext ( shouldStartContext ) ; } return ctx ; } protected void installRoutes ( ) throws Exception { if ( autowireRouteBuilders != null && autowireRouteBuilders . booleanValue ( ) ) { Map builders = getApplicationContext ( ) . getBeansOfType ( RouteBuilder . class , true , true ) ; if ( builders != null ) { for ( Object builder : builders . values ( ) ) { getContext ( ) . addRoutes ( ( RouteBuilder ) builder ) ; } } } for ( Routes routeBuilder : additionalBuilders ) { getContext ( ) . addRoutes ( routeBuilder ) ; } if ( routeBuilder != null ) { getContext ( ) . addRoutes ( routeBuilder ) ; } if ( builderRefs != null ) { for ( RouteBuilderRef builderRef : builderRefs ) { RouteBuilder builder = builderRef . createRouteBuilder ( getContext ( ) ) ; getContext ( ) . addRoutes ( builder ) ; } } } protected void findRouteBuilders ( ) throws Exception , InstantiationException { if ( getPackages ( ) != null && getPackages ( ) . length > 0 ) { RouteBuilderFinder finder = new RouteBuilderFinder ( getContext ( ) , getPackages ( ) , getContextClassLoaderOnStart ( ) , getBeanPostProcessor ( ) , createResolverUtil ( ) ) ; finder . appendBuilders ( getAdditionalBuilders ( ) ) ; } } protected ResolverUtil createResolverUtil ( ) { return new ResolverUtil ( ) ; } public void setDataFormats ( DataFormatsType dataFormats ) { this . dataFormats = dataFormats ; } public DataFormatsType getDataFormats ( ) { return dataFormats ; } } 	0	['48', '2', '1', '45', '124', '992', '2', '43', '42', '0.929078014', '824', '1', '4', '0.041666667', '0.093617021', '0', '0', '15.72916667', '6', '1.2292', '0']
package org . apache . camel . dataformat . csv ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . Map ; import java . util . Set ; import org . apache . camel . Exchange ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . util . ExchangeHelper ; import org . apache . commons . csv . CSVParser ; import org . apache . commons . csv . CSVStrategy ; import org . apache . commons . csv . writer . CSVConfig ; import org . apache . commons . csv . writer . CSVField ; import org . apache . commons . csv . writer . CSVWriter ; public class CsvDataFormat implements DataFormat { private CSVStrategy strategy = CSVStrategy . DEFAULT_STRATEGY ; private CSVConfig config = new CSVConfig ( ) ; public void marshal ( Exchange exchange , Object object , OutputStream outputStream ) throws Exception { Map map = ExchangeHelper . convertToMandatoryType ( exchange , Map . class , object ) ; OutputStreamWriter out = new OutputStreamWriter ( outputStream ) ; try { CSVConfig conf = getConfig ( ) ; Set set = map . keySet ( ) ; for ( Object value : set ) { if ( value != null ) { String text = value . toString ( ) ; CSVField field = new CSVField ( text ) ; conf . addField ( field ) ; } } CSVWriter writer = new CSVWriter ( conf ) ; writer . setWriter ( out ) ; writer . writeRecord ( map ) ; } finally { out . close ( ) ; } } public Object unmarshal ( Exchange exchange , InputStream inputStream ) throws Exception { InputStreamReader in = new InputStreamReader ( inputStream ) ; try { CSVParser parser = new CSVParser ( in , getStrategy ( ) ) ; List < List < String > > list = new ArrayList < List < String > > ( ) ; while ( true ) { String [ ] strings = parser . getLine ( ) ; if ( strings == null ) { break ; } List < String > line = Arrays . asList ( strings ) ; list . add ( line ) ; } if ( list . size ( ) == 1 ) { return list . get ( 0 ) ; } else { return list ; } } finally { in . close ( ) ; } } public CSVConfig getConfig ( ) { if ( config == null ) { config = createConfig ( ) ; } return config ; } public void setConfig ( CSVConfig config ) { this . config = config ; } public CSVStrategy getStrategy ( ) { return strategy ; } public void setStrategy ( CSVStrategy strategy ) { this . strategy = strategy ; } protected CSVConfig createConfig ( ) { return new CSVConfig ( ) ; } } 	0	['8', '1', '0', '8', '32', '16', '0', '8', '7', '0.571428571', '159', '1', '0', '0', '0.267857143', '0', '0', '18.625', '2', '1', '0']
package org . apache . camel . component . jms . requestor ; import java . math . BigInteger ; import java . util . Random ; import java . util . concurrent . ScheduledExecutorService ; import javax . jms . Destination ; import javax . jms . ExceptionListener ; import javax . jms . JMSException ; import javax . jms . Message ; import javax . jms . Session ; import org . apache . camel . component . jms . JmsConfiguration ; import org . apache . camel . component . jms . requestor . DeferredRequestReplyMap . DeferredMessageSentCallback ; import org . springframework . core . task . TaskExecutor ; import org . springframework . jms . listener . AbstractMessageListenerContainer ; import org . springframework . jms . listener . DefaultMessageListenerContainer ; import org . springframework . jms . listener . DefaultMessageListenerContainer102 ; import org . springframework . jms . support . destination . DestinationResolver ; import org . springframework . transaction . PlatformTransactionManager ; public class PersistentReplyToRequestor extends Requestor { private String replyToSelectorValue ; public class DestinationResolverDelegate implements DestinationResolver { private DestinationResolver delegate ; private Destination destination ; public DestinationResolverDelegate ( DestinationResolver delegate ) { this . delegate = delegate ; } public Destination resolveDestinationName ( Session session , String destinationName , boolean pubSubDomain ) throws JMSException { synchronized ( getOutterInstance ( ) ) { try { if ( destination == null ) { destination = delegate . resolveDestinationName ( session , destinationName , pubSubDomain ) ; setReplyTo ( destination ) ; } } finally { getOutterInstance ( ) . notifyAll ( ) ; } } return destination ; } } ; public static interface MessageSelectorComposer { void addCorrelationID ( String id ) ; void removeCorrelationID ( String id ) ; } public static class CamelDefaultMessageListenerContainer102 extends DefaultMessageListenerContainer102 implements MessageSelectorComposer { MessageSelectorProvider provider = new MessageSelectorProvider ( ) ; public void addCorrelationID ( String id ) { provider . addCorrelationID ( id ) ; } public void removeCorrelationID ( String id ) { provider . removeCorrelationID ( id ) ; } @ Override public void setMessageSelector ( String messageSelector ) { throw new UnsupportedOperationException ( ) ; } @ Override public String getMessageSelector ( ) { return provider . get ( ) ; } } public static class CamelDefaultMessageListenerContainer extends DefaultMessageListenerContainer implements MessageSelectorComposer { MessageSelectorProvider provider = new MessageSelectorProvider ( ) ; public void addCorrelationID ( String id ) { provider . addCorrelationID ( id ) ; } public void removeCorrelationID ( String id ) { provider . removeCorrelationID ( id ) ; } @ Override public void setMessageSelector ( String messageSelector ) { throw new UnsupportedOperationException ( ) ; } @ Override public String getMessageSelector ( ) { return provider . get ( ) ; } } public PersistentReplyToRequestor ( JmsConfiguration configuration , ScheduledExecutorService executorService ) { super ( configuration , executorService ) ; } @ Override protected FutureHandler createFutureHandler ( String correlationID ) { boolean dynamicSelector = getConfiguration ( ) . getReplyToDestinationSelectorName ( ) == null ; if ( dynamicSelector ) { return new PersistentReplyToFutureHandler ( this , correlationID ) ; } return new FutureHandler ( ) ; } @ Override protected FutureHandler createFutureHandler ( DeferredMessageSentCallback callback ) { boolean dynamicSelector = getConfiguration ( ) . getReplyToDestinationSelectorName ( ) == null ; if ( dynamicSelector ) { return new PersistentReplyToFutureHandler ( this , callback ) ; } return new FutureHandler ( ) ; } @ Override public AbstractMessageListenerContainer createListenerContainer ( ) { JmsConfiguration config = getConfiguration ( ) ; String replyToSelectorName = getConfiguration ( ) . getReplyToDestinationSelectorName ( ) ; AbstractMessageListenerContainer container = config . isUseVersion102 ( ) ? ( replyToSelectorName != null ) ? new DefaultMessageListenerContainer102 ( ) : new CamelDefaultMessageListenerContainer102 ( ) : ( replyToSelectorName != null ) ? new DefaultMessageListenerContainer ( ) : new CamelDefaultMessageListenerContainer ( ) ; container . setConnectionFactory ( config . getListenerConnectionFactory ( ) ) ; DestinationResolver resolver = config . getDestinationResolver ( ) ; if ( resolver == null ) { resolver = container . getDestinationResolver ( ) ; } container . setDestinationResolver ( new DestinationResolverDelegate ( resolver ) ) ; container . setDestinationName ( getConfiguration ( ) . getReplyTo ( ) ) ; if ( replyToSelectorName != null ) { replyToSelectorValue = "ID:" + new BigInteger ( 24 * 8 , new Random ( ) ) . toString ( 16 ) ; container . setMessageSelector ( replyToSelectorName + "='" + replyToSelectorValue + "'" ) ; } else { ( ( MessageSelectorComposer ) container ) . addCorrelationID ( "ID:" + new BigInteger ( 24 * 8 , new Random ( ) ) . toString ( 16 ) ) ; } container . setAutoStartup ( true ) ; container . setMessageListener ( this ) ; container . setPubSubDomain ( false ) ; container . setSubscriptionDurable ( false ) ; ExceptionListener exceptionListener = config . getExceptionListener ( ) ; if ( exceptionListener != null ) { container . setExceptionListener ( exceptionListener ) ; } container . setSessionTransacted ( config . isTransacted ( ) ) ; if ( config . isTransacted ( ) ) { container . setSessionAcknowledgeMode ( Session . SESSION_TRANSACTED ) ; } else { if ( config . getAcknowledgementMode ( ) >= 0 ) { container . setSessionAcknowledgeMode ( config . getAcknowledgementMode ( ) ) ; } else if ( config . getAcknowledgementModeName ( ) != null ) { container . setSessionAcknowledgeModeName ( config . getAcknowledgementModeName ( ) ) ; } } if ( container instanceof DefaultMessageListenerContainer ) { DefaultMessageListenerContainer defContainer = ( DefaultMessageListenerContainer ) container ; defContainer . setConcurrentConsumers ( 1 ) ; defContainer . setCacheLevel ( DefaultMessageListenerContainer . CACHE_SESSION ) ; if ( config . getReceiveTimeout ( ) >= 0 ) { defContainer . setReceiveTimeout ( config . getReceiveTimeout ( ) ) ; } if ( config . getRecoveryInterval ( ) >= 0 ) { defContainer . setRecoveryInterval ( config . getRecoveryInterval ( ) ) ; } TaskExecutor taskExecutor = config . getTaskExecutor ( ) ; if ( taskExecutor != null ) { defContainer . setTaskExecutor ( taskExecutor ) ; } PlatformTransactionManager tm = config . getTransactionManager ( ) ; if ( tm != null ) { defContainer . setTransactionManager ( tm ) ; } else if ( config . isTransacted ( ) ) { throw new IllegalArgumentException ( "Property transacted is enabled but a transactionManager was not injected!" ) ; } if ( config . getTransactionName ( ) != null ) { defContainer . setTransactionName ( config . getTransactionName ( ) ) ; } if ( config . getTransactionTimeout ( ) >= 0 ) { defContainer . setTransactionTimeout ( config . getTransactionTimeout ( ) ) ; } } return container ; } @ Override public void setReplyToSelectorHeader ( org . apache . camel . Message in , Message jmsIn ) throws JMSException { String replyToSelectorName = getConfiguration ( ) . getReplyToDestinationSelectorName ( ) ; if ( replyToSelectorValue != null ) { in . setHeader ( replyToSelectorName , replyToSelectorValue ) ; jmsIn . setStringProperty ( replyToSelectorName , replyToSelectorValue ) ; } } } 	0	['5', '3', '0', '17', '61', '8', '3', '16', '3', '0.75', '295', '1', '0', '0.9', '0.314285714', '1', '1', '57.8', '18', '5', '0']
package org . apache . camel ; public class RuntimeTransformException extends RuntimeCamelException { private static final long serialVersionUID = - 8417806626073055262L ; public RuntimeTransformException ( String message ) { super ( message ) ; } public RuntimeTransformException ( String message , Throwable cause ) { super ( message , cause ) ; } public RuntimeTransformException ( Throwable cause ) { super ( cause ) ; } } 	0	['3', '5', '0', '3', '6', '3', '2', '1', '3', '1.5', '17', '1', '0', '1', '0.777777778', '0', '0', '4.333333333', '0', '0', '0']
package org . apache . camel . impl ; import org . apache . camel . Endpoint ; public class ProxyInstantiationException extends RuntimeException { private final Class < ? > type ; private final Endpoint endpoint ; public ProxyInstantiationException ( Class < ? > type , Endpoint endpoint , Throwable cause ) { super ( "Could not instantiate proxy of type " + type . getName ( ) + " on endpoint " + endpoint , cause ) ; this . type = type ; this . endpoint = endpoint ; } public Class < ? > getType ( ) { return type ; } public Endpoint getEndpoint ( ) { return endpoint ; } } 	0	['3', '4', '0', '2', '9', '0', '1', '1', '3', '0.5', '34', '1', '1', '0.894736842', '0.5', '0', '0', '9.666666667', '1', '0.6667', '0']
package org . apache . camel . component . freemarker ; import java . util . Map ; import freemarker . cache . ClassTemplateLoader ; import freemarker . template . Configuration ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import org . springframework . core . io . Resource ; public class FreemarkerComponent extends DefaultComponent { private Configuration configuraiton ; private Configuration noCacheConfiguration ; protected Endpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { FreemarkerEndpoint endpoint = new FreemarkerEndpoint ( uri , this , remaining , parameters ) ; Configuration config ; boolean cache = ( Boolean ) getAndRemoveParameter ( parameters , "contentCache" , Boolean . class , Boolean . TRUE ) ; if ( cache ) { config = getConfiguraiton ( ) ; } else { config = getNoCacheConfiguration ( ) ; } endpoint . setConfiguration ( config ) ; return endpoint ; } public synchronized Configuration getConfiguraiton ( ) { if ( configuraiton == null ) { configuraiton = new Configuration ( ) ; configuraiton . setTemplateLoader ( new ClassTemplateLoader ( Resource . class , "/" ) ) ; } return ( Configuration ) configuraiton . clone ( ) ; } public void setConfiguraiton ( Configuration configuraiton ) { this . configuraiton = configuraiton ; } private synchronized Configuration getNoCacheConfiguration ( ) { if ( noCacheConfiguration == null ) { noCacheConfiguration = ( Configuration ) getConfiguraiton ( ) . clone ( ) ; noCacheConfiguration . setCacheStorage ( new NoCacheStorage ( ) ) ; } return noCacheConfiguration ; } } 	0	['5', '3', '0', '9', '16', '8', '0', '9', '3', '0.5', '84', '1', '0', '0.897435897', '0.4', '1', '2', '15.4', '2', '1.2', '0']
package org . apache . camel . component . irc ; import org . apache . commons . logging . Log ; import org . schwering . irc . lib . IRCEventAdapter ; import org . schwering . irc . lib . IRCModeParser ; import org . schwering . irc . lib . IRCUser ; public class IrcErrorLogger extends IRCEventAdapter { private Log log ; public IrcErrorLogger ( Log log ) { this . log = log ; } @ Override public void onRegistered ( ) { super . onRegistered ( ) ; log . info ( "onRegistered" ) ; } @ Override public void onDisconnected ( ) { super . onDisconnected ( ) ; log . info ( "onDisconnected" ) ; } @ Override public void onMode ( String string , IRCUser ircUser , IRCModeParser ircModeParser ) { super . onMode ( string , ircUser , ircModeParser ) ; log . info ( "onMode.string = " + string ) ; log . info ( "onMode.ircUser = " + ircUser ) ; log . info ( "onMode.ircModeParser = " + ircModeParser ) ; } @ Override public void onMode ( IRCUser ircUser , String string , String string1 ) { super . onMode ( ircUser , string , string1 ) ; log . info ( "onMode.ircUser = " + ircUser ) ; log . info ( "onMode.string = " + string ) ; log . info ( "onMode.string1 = " + string1 ) ; } @ Override public void onPing ( String string ) { super . onPing ( string ) ; log . info ( "onPing.string = " + string ) ; } @ Override public void onError ( String string ) { log . info ( "onError.string = " + string ) ; } @ Override public void onError ( int i , String string ) { super . onError ( i , string ) ; log . error ( "onError.i = " + i ) ; log . error ( "onError.string = " + string ) ; } @ Override public void unknown ( String string , String string1 , String string2 , String string3 ) { super . unknown ( string , string1 , string2 , string3 ) ; log . error ( "unknown.string = " + string ) ; log . error ( "unknown.string1 = " + string1 ) ; log . error ( "unknown.string2 = " + string2 ) ; log . error ( "unknown.string3 = " + string3 ) ; } } 	0	['9', '0', '0', '5', '24', '0', '1', '4', '9', '0', '213', '1', '0', '0', '0.37037037', '0', '0', '22.55555556', '1', '0.8889', '0']
package org . apache . camel . component . cxf . transport ; import java . io . IOException ; import java . io . OutputStream ; import java . util . logging . Level ; import java . util . logging . Logger ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Processor ; import org . apache . camel . ProducerTemplate ; import org . apache . camel . component . cxf . CxfConstants ; import org . apache . camel . component . cxf . CxfSoapBinding ; import org . apache . camel . component . cxf . util . CxfHeaderHelper ; import org . apache . camel . impl . DefaultCamelContext ; import org . apache . camel . spi . HeaderFilterStrategy ; import org . apache . cxf . Bus ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . configuration . Configurable ; import org . apache . cxf . configuration . Configurer ; import org . apache . cxf . io . CachedOutputStream ; import org . apache . cxf . message . Message ; import org . apache . cxf . service . model . EndpointInfo ; import org . apache . cxf . transport . AbstractConduit ; import org . apache . cxf . transport . Conduit ; import org . apache . cxf . transport . Destination ; import org . apache . cxf . transport . MessageObserver ; import org . apache . cxf . ws . addressing . EndpointReferenceType ; public class CamelConduit extends AbstractConduit implements Configurable { protected static final String BASE_BEAN_NAME_SUFFIX = ".camel-conduit" ; private static final Logger LOG = LogUtils . getL7dLogger ( CamelConduit . class ) ; private CamelContext camelContext ; private EndpointInfo endpointInfo ; private String targetCamelEndpointUri ; private ProducerTemplate < Exchange > camelTemplate ; private Bus bus ; private HeaderFilterStrategy headerFilterStrategy ; public CamelConduit ( CamelContext context , Bus b , EndpointInfo endpointInfo ) { this ( context , b , endpointInfo , null ) ; } public CamelConduit ( CamelContext context , Bus b , EndpointInfo epInfo , EndpointReferenceType targetReference ) { this ( context , b , epInfo , targetReference , null ) ; } public CamelConduit ( CamelContext context , Bus b , EndpointInfo epInfo , EndpointReferenceType targetReference , HeaderFilterStrategy headerFilterStrategy ) { super ( getTargetReference ( epInfo , targetReference , b ) ) ; String address = epInfo . getAddress ( ) ; if ( address != null ) { targetCamelEndpointUri = address . substring ( CxfConstants . CAMEL_TRANSPORT_PREFIX . length ( ) ) ; if ( targetCamelEndpointUri . startsWith ( "//" ) ) { targetCamelEndpointUri = targetCamelEndpointUri . substring ( 2 ) ; } } camelContext = context ; endpointInfo = epInfo ; bus = b ; initConfig ( ) ; this . headerFilterStrategy = headerFilterStrategy ; } public void setCamelContext ( CamelContext context ) { camelContext = context ; } public CamelContext getCamelContext ( ) { if ( camelContext == null ) { getLogger ( ) . log ( Level . INFO , "No CamelContext injected, create a default one" ) ; camelContext = new DefaultCamelContext ( ) ; } return camelContext ; } public void prepare ( Message message ) throws IOException { getLogger ( ) . log ( Level . FINE , "CamelConduit send message" ) ; message . setContent ( OutputStream . class , new CamelOutputStream ( message ) ) ; } public void close ( ) { getLogger ( ) . log ( Level . FINE , "CamelConduit closed " ) ; } protected Logger getLogger ( ) { return LOG ; } public String getBeanName ( ) { if ( endpointInfo == null || endpointInfo . getName ( ) == null ) { return "default" + BASE_BEAN_NAME_SUFFIX ; } return endpointInfo . getName ( ) . toString ( ) + BASE_BEAN_NAME_SUFFIX ; } private void initConfig ( ) { if ( bus != null ) { Configurer configurer = bus . getExtension ( Configurer . class ) ; if ( null != configurer ) { configurer . configureBean ( this ) ; } } } public ProducerTemplate < Exchange > getCamelTemplate ( ) { if ( camelTemplate == null ) { camelTemplate = getCamelContext ( ) . createProducerTemplate ( ) ; } return camelTemplate ; } public void setCamelTemplate ( ProducerTemplate < Exchange > template ) { camelTemplate = template ; } private class CamelOutputStream extends CachedOutputStream { private Message outMessage ; private boolean isOneWay ; public CamelOutputStream ( Message m ) { outMessage = m ; } protected void doFlush ( ) throws IOException { } protected void doClose ( ) throws IOException { isOneWay = outMessage . getExchange ( ) . isOneWay ( ) ; commitOutputMessage ( ) ; } protected void onWrite ( ) throws IOException { } private void commitOutputMessage ( ) { ExchangePattern pattern ; if ( isOneWay ) { pattern = ExchangePattern . InOnly ; } else { pattern = ExchangePattern . InOut ; } getLogger ( ) . log ( Level . FINE , "send the message to endpoint" + targetCamelEndpointUri ) ; org . apache . camel . Exchange exchange = getCamelTemplate ( ) . send ( targetCamelEndpointUri , pattern , new Processor ( ) { public void process ( org . apache . camel . Exchange ex ) throws IOException { CachedOutputStream outputStream = ( CachedOutputStream ) outMessage . getContent ( OutputStream . class ) ; CxfHeaderHelper . propagateCxfToCamel ( headerFilterStrategy , outMessage , ex . getIn ( ) . getHeaders ( ) ) ; ex . getIn ( ) . setBody ( outputStream . getBytes ( ) ) ; getLogger ( ) . log ( Level . FINE , "template sending request: " , ex . getIn ( ) ) ; } } ) ; exchange . setProperty ( CxfConstants . CXF_EXCHANGE , outMessage . getExchange ( ) ) ; if ( ! isOneWay ) { handleResponse ( exchange ) ; } } private void handleResponse ( org . apache . camel . Exchange exchange ) { org . apache . cxf . message . Message inMessage = CxfSoapBinding . getCxfInMessage ( headerFilterStrategy , exchange , true ) ; incomingObserver . onMessage ( inMessage ) ; } } protected class DecoupledDestination implements Destination { protected MessageObserver decoupledMessageObserver ; private EndpointReferenceType address ; DecoupledDestination ( EndpointReferenceType ref , MessageObserver incomingObserver ) { address = ref ; decoupledMessageObserver = incomingObserver ; } public EndpointReferenceType getAddress ( ) { return address ; } public Conduit getBackChannel ( Message inMessage , Message partialResponse , EndpointReferenceType addr ) throws IOException { return null ; } public void shutdown ( ) { } public synchronized void setMessageObserver ( MessageObserver observer ) { decoupledMessageObserver = observer ; } public synchronized MessageObserver getMessageObserver ( ) { return decoupledMessageObserver ; } } } 	0	['16', '0', '0', '17', '35', '102', '4', '14', '10', '0.858333333', '189', '1', '3', '0', '0.222222222', '0', '0', '10.3125', '3', '1.125', '0']
package org . apache . camel . util ; public interface TimeoutMap extends Runnable { Object get ( Object key ) ; Object [ ] getKeys ( ) ; int size ( ) ; void put ( Object key , Object value , long timeoutMillis ) ; void remove ( Object key ) ; void purge ( ) ; } 	0	['6', '1', '0', '3', '6', '15', '3', '0', '6', '2', '6', '0', '0', '0', '0.555555556', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . xmpp ; import org . jivesoftware . smack . XMPPException ; public class RuntimeXmppException extends RuntimeException { private static final long serialVersionUID = - 2141493732308871761L ; public RuntimeXmppException ( XMPPException cause ) { super ( cause ) ; } public RuntimeXmppException ( String message , XMPPException cause ) { super ( message , cause ) ; } } 	0	['2', '4', '0', '3', '4', '1', '2', '1', '2', '2', '12', '1', '0', '1', '0.833333333', '0', '0', '4.5', '0', '0', '0']
package org . apache . camel . component . cxf ; import org . apache . camel . NoTypeConversionAvailableException ; import org . apache . camel . impl . DefaultMessage ; import org . apache . cxf . message . Message ; import org . apache . cxf . message . MessageContentsList ; import org . apache . cxf . message . MessageImpl ; public class CxfMessage extends DefaultMessage { private Message cxfMessage ; public CxfMessage ( ) { this ( new MessageImpl ( ) ) ; } public CxfMessage ( Message cxfMessage ) { if ( cxfMessage == null ) { this . cxfMessage = new MessageImpl ( ) ; } else { this . cxfMessage = cxfMessage ; } } @ Override public void copyFrom ( org . apache . camel . Message that ) { setMessageId ( that . getMessageId ( ) ) ; setBody ( that . getBody ( ) ) ; if ( that . getBody ( ) instanceof Message ) { setMessage ( ( Message ) that . getBody ( ) ) ; } getHeaders ( ) . putAll ( that . getHeaders ( ) ) ; if ( that instanceof CxfMessage ) { CxfMessage orig = ( CxfMessage ) that ; setMessage ( orig . getMessage ( ) ) ; } } @ Override public String toString ( ) { if ( cxfMessage != null ) { return "CxfMessage: " + cxfMessage ; } else { return "CxfMessage: " + getBody ( ) ; } } @ Override public CxfExchange getExchange ( ) { return ( CxfExchange ) super . getExchange ( ) ; } public Message getMessage ( ) { return cxfMessage ; } public void setMessage ( Message cxfMessage ) { this . cxfMessage = cxfMessage ; } @ Override public CxfMessage newInstance ( ) { return new CxfMessage ( ) ; } @ Override protected Object createBody ( ) { return CxfBinding . extractBodyFromCxf ( getExchange ( ) , cxfMessage ) ; } @ Override public void setBody ( Object body ) { super . setBody ( body ) ; if ( body instanceof Message ) { setMessage ( ( Message ) body ) ; } } public < T > T getBody ( Class < T > type ) { if ( ! ( MessageContentsList . class . isAssignableFrom ( type ) ) && getBody ( ) instanceof MessageContentsList ) { MessageContentsList list = ( MessageContentsList ) getBody ( ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { Object value = list . get ( i ) ; try { T answer = getBody ( type , value ) ; if ( answer != null ) { return answer ; } } catch ( NoTypeConversionAvailableException ex ) { } } } return super . getBody ( type ) ; } } 	0	['14', '3', '0', '11', '32', '71', '4', '9', '13', '0.230769231', '171', '1', '0', '0.744680851', '0.271428571', '2', '7', '11.14285714', '4', '1.3571', '0']
package org . apache . camel . component . timer ; import java . util . Collection ; import java . util . HashMap ; import java . util . Map ; import java . util . Timer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultComponent ; public class TimerComponent extends DefaultComponent < Exchange > { private Map < String , Timer > timers = new HashMap < String , Timer > ( ) ; public Timer getTimer ( TimerEndpoint endpoint ) { String key = endpoint . getTimerName ( ) ; if ( ! endpoint . isDaemon ( ) ) { key = "nonDaemon:" + key ; } Timer answer = timers . get ( key ) ; if ( answer == null ) { answer = new Timer ( endpoint . getTimerName ( ) , endpoint . isDaemon ( ) ) ; timers . put ( key , answer ) ; } return answer ; } @ Override protected Endpoint < Exchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { TimerEndpoint answer = new TimerEndpoint ( uri , this , remaining ) ; setProperties ( answer , parameters ) ; return answer ; } @ Override protected void doStop ( ) throws Exception { Collection < Timer > collection = timers . values ( ) ; for ( Timer timer : collection ) { timer . cancel ( ) ; } timers . clear ( ) ; } } 	0	['4', '3', '0', '3', '22', '0', '1', '3', '2', '0.333333333', '86', '1', '0', '0.921052632', '0.4375', '2', '3', '20.25', '3', '1.25', '0']
package org . apache . camel . component . cxf . interceptors ; import java . util . ResourceBundle ; import java . util . logging . Logger ; import org . apache . cxf . binding . soap . SoapMessage ; import org . apache . cxf . common . i18n . BundleUtils ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . interceptor . Fault ; import org . apache . cxf . interceptor . MessageSenderInterceptor ; import org . apache . cxf . message . Message ; import org . apache . cxf . message . XMLMessage ; import org . apache . cxf . phase . AbstractPhaseInterceptor ; import org . apache . cxf . phase . Phase ; public class DOMOutInterceptor extends AbstractPhaseInterceptor < Message > { private static final Logger LOG = LogUtils . getL7dLogger ( DOMOutInterceptor . class ) ; private final XMLMessageOutInterceptor xmlInterceptor = new XMLMessageOutInterceptor ( ) ; private final SoapMessageOutInterceptor soapInterceptor = new SoapMessageOutInterceptor ( ) ; public DOMOutInterceptor ( ) { super ( Phase . PREPARE_SEND ) ; this . addBefore ( MessageSenderInterceptor . class . getName ( ) ) ; } public boolean isRequestor ( Message message ) { return Boolean . TRUE . equals ( message . get ( Message . REQUESTOR_ROLE ) ) ; } @ SuppressWarnings ( "unchecked" ) public void handleMessage ( Message message ) throws Fault { if ( message instanceof XMLMessage ) { xmlInterceptor . handleMessage ( ( XMLMessage ) message ) ; } else if ( message instanceof SoapMessage ) { soapInterceptor . handleMessage ( ( SoapMessage ) message ) ; } else { throw new Fault ( new org . apache . cxf . common . i18n . Message ( "NOT_SUPPORTED_MESSAGE" , LOG , message . getClass ( ) . getName ( ) ) ) ; } } } 	0	['4', '0', '0', '10', '17', '2', '1', '9', '3', '0.666666667', '71', '1', '2', '0', '0.833333333', '0', '0', '16', '1', '0.5', '0']
package org . apache . camel . converter . jaxb ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlType ; import org . apache . camel . Message ; @ XmlType ( name = "headerType" ) @ XmlAccessorType ( value = XmlAccessType . FIELD ) public abstract class HeaderType { @ XmlAttribute private String name ; public HeaderType ( ) { } protected HeaderType ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public abstract Object getValue ( ) ; public abstract void setValue ( Object value ) ; } 	0	['6', '1', '4', '5', '7', '9', '5', '0', '5', '0.6', '23', '1', '0', '0', '0.5', '0', '0', '2.666666667', '1', '0.6667', '0']
package org . apache . camel . component . seda ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . concurrent . BlockingQueue ; import org . apache . camel . Component ; import org . apache . camel . Consumer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . spi . BrowsableEndpoint ; import org . apache . camel . util . ObjectHelper ; public class SedaEndpoint extends DefaultEndpoint < Exchange > implements BrowsableEndpoint < Exchange > { private BlockingQueue < Exchange > queue ; public SedaEndpoint ( String endpointUri , Component component , BlockingQueue < Exchange > queue ) { super ( endpointUri , component ) ; this . queue = queue ; } public SedaEndpoint ( String uri , SedaComponent component , Map parameters ) { this ( uri , component , component . createQueue ( uri , parameters ) ) ; } public SedaEndpoint ( String endpointUri , BlockingQueue < Exchange > queue ) { super ( endpointUri ) ; ObjectHelper . notNull ( queue , "queue" ) ; this . queue = queue ; } public Producer createProducer ( ) throws Exception { return new CollectionProducer ( this , getQueue ( ) ) ; } public Consumer createConsumer ( Processor processor ) throws Exception { return new SedaConsumer ( this , processor ) ; } public BlockingQueue < Exchange > getQueue ( ) { return queue ; } public boolean isSingleton ( ) { return true ; } public List < Exchange > getExchanges ( ) { return new ArrayList < Exchange > ( getQueue ( ) ) ; } } 	0	['8', '2', '0', '12', '15', '22', '3', '11', '8', '0.285714286', '60', '1', '0', '0.827586207', '0.303571429', '0', '0', '6.375', '1', '0.625', '0']
package org . apache . camel . component . cxf . interceptors ; import java . util . List ; import java . util . ResourceBundle ; import java . util . logging . Level ; import java . util . logging . Logger ; import javax . xml . namespace . QName ; import javax . xml . stream . XMLStreamException ; import javax . xml . stream . XMLStreamReader ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . apache . cxf . common . i18n . BundleUtils ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . endpoint . Endpoint ; import org . apache . cxf . interceptor . Fault ; import org . apache . cxf . message . Exchange ; import org . apache . cxf . message . Message ; import org . apache . cxf . phase . AbstractPhaseInterceptor ; import org . apache . cxf . service . model . BindingInfo ; import org . apache . cxf . service . model . BindingMessageInfo ; import org . apache . cxf . service . model . BindingOperationInfo ; import org . apache . cxf . service . model . OperationInfo ; import org . apache . cxf . staxutils . StaxUtils ; public abstract class AbstractMessageInInterceptor < T extends Message > extends AbstractPhaseInterceptor < T > { public AbstractMessageInInterceptor ( String phase ) { super ( phase ) ; } protected boolean isRequestor ( Message message ) { return Boolean . TRUE . equals ( message . get ( Message . REQUESTOR_ROLE ) ) ; } public void handleMessage ( T message ) throws Fault { Logger logger = getLogger ( ) ; if ( isFaultMessage ( message ) ) { message . getInterceptorChain ( ) . abort ( ) ; Endpoint ep = message . getExchange ( ) . get ( Endpoint . class ) ; if ( ep . getInFaultObserver ( ) != null ) { ep . getInFaultObserver ( ) . onMessage ( message ) ; return ; } } Document document = createDOMMessage ( message ) ; Element payloadEl = ( Element ) document . getChildNodes ( ) . item ( 0 ) ; Exchange ex = message . getExchange ( ) ; BindingOperationInfo boi = ex . get ( BindingOperationInfo . class ) ; if ( boi == null ) { BindingInfo bi = ex . get ( BindingInfo . class ) ; if ( bi == null ) { Endpoint ep = ex . get ( Endpoint . class ) ; bi = ep . getEndpointInfo ( ) . getBinding ( ) ; ex . put ( BindingInfo . class , bi ) ; } if ( logger . isLoggable ( Level . INFO ) ) { logger . info ( "AbstractRoutingMessageInInterceptor Infer BindingOperationInfo." ) ; } boi = getBindingOperation ( message , document ) ; if ( boi == null ) { QName startQName = new QName ( payloadEl . getNamespaceURI ( ) , payloadEl . getLocalName ( ) ) ; throw new Fault ( new org . apache . cxf . common . i18n . Message ( "REQ_NOT_UNDERSTOOD" , getLogger ( ) , startQName ) ) ; } if ( boi != null ) { ex . put ( BindingOperationInfo . class , boi ) ; ex . put ( OperationInfo . class , boi . getOperationInfo ( ) ) ; ex . setOneWay ( boi . getOperationInfo ( ) . isOneWay ( ) ) ; if ( logger . isLoggable ( Level . INFO ) ) { logger . info ( "DOMInInterceptor- BindingOperation is:" + boi . getName ( ) ) ; } } } BindingMessageInfo bmi = isRequestor ( message ) ? boi . getOutput ( ) : boi . getInput ( ) ; List < Element > partList = getPartList ( message , payloadEl , bmi ) ; message . put ( List . class , partList ) ; } protected Document createDOMMessage ( T message ) { Document doc = null ; try { if ( getLogger ( ) . isLoggable ( Level . INFO ) ) { getLogger ( ) . info ( "AbstractMessageInInterceptor Converting Stax Stream to DOM" ) ; } XMLStreamReader xsr = message . getContent ( XMLStreamReader . class ) ; doc = StaxUtils . read ( xsr ) ; } catch ( XMLStreamException xe ) { throw new Fault ( new org . apache . cxf . common . i18n . Message ( "STAX_READ_EXC" , getLogger ( ) ) , xe ) ; } return doc ; } protected abstract Logger getLogger ( ) ; protected abstract boolean isFaultMessage ( T message ) ; protected abstract BindingOperationInfo getBindingOperation ( T inMessage , Document document ) ; protected abstract List < Element > getPartList ( T inMessage , Element rootElement , BindingMessageInfo boi ) ; } 	0	['8', '0', '2', '16', '43', '28', '2', '14', '2', '2', '208', '0', '0', '0', '0.375', '0', '0', '25', '2', '1', '0']
package org . apache . camel . component . xmpp ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultHeaderFilterStrategy ; import org . apache . camel . spi . HeaderFilterStrategy ; import org . jivesoftware . smack . packet . Message ; public class XmppBinding { private HeaderFilterStrategy headerFilterStrategy ; public XmppBinding ( ) { this . headerFilterStrategy = new DefaultHeaderFilterStrategy ( ) ; } public XmppBinding ( HeaderFilterStrategy headerFilterStrategy ) { this . headerFilterStrategy = headerFilterStrategy ; } public void populateXmppMessage ( Message message , Exchange exchange ) { message . setBody ( exchange . getIn ( ) . getBody ( String . class ) ) ; Set < Map . Entry < String , Object > > entries = exchange . getIn ( ) . getHeaders ( ) . entrySet ( ) ; for ( Map . Entry < String , Object > entry : entries ) { String name = entry . getKey ( ) ; Object value = entry . getValue ( ) ; if ( headerFilterStrategy != null && ! headerFilterStrategy . applyFilterToCamelHeaders ( name , value ) ) { message . setProperty ( name , value ) ; } } String id = exchange . getExchangeId ( ) ; if ( id != null ) { message . setProperty ( "exchangeId" , id ) ; } } public Object extractBodyFromXmpp ( XmppExchange exchange , Message message ) { return message . getBody ( ) ; } public Map < String , Object > extractHeadersFromXmpp ( Message xmppMessage ) { Map < String , Object > answer = new HashMap < String , Object > ( ) ; for ( String name : xmppMessage . getPropertyNames ( ) ) { Object value = xmppMessage . getProperty ( name ) ; if ( headerFilterStrategy != null && ! headerFilterStrategy . applyFilterToExternalHeaders ( name , value ) ) { answer . put ( name , value ) ; } } return answer ; } } 	0	['5', '1', '0', '10', '27', '0', '5', '6', '5', '0.25', '112', '1', '1', '0', '0.44', '0', '0', '21.2', '3', '1.2', '0']
package org . apache . camel . component . spring . integration . converter ; import org . apache . camel . Converter ; import org . apache . camel . Endpoint ; import org . apache . camel . component . spring . integration . SpringIntegrationEndpoint ; import org . apache . camel . component . spring . integration . SpringIntegrationMessage ; import org . springframework . integration . core . MessageChannel ; import org . springframework . integration . core . MessageHeaders ; import org . springframework . integration . message . GenericMessage ; @ Converter public final class SpringIntegrationConverter { private SpringIntegrationConverter ( ) { } @ Converter public static Endpoint toEndpoint ( final MessageChannel channel ) throws Exception { if ( channel == null ) { throw new IllegalArgumentException ( "The MessageChannel is null" ) ; } Endpoint answer = new SpringIntegrationEndpoint ( "URL" , channel , null ) ; return answer ; } @ SuppressWarnings ( "unchecked" ) @ Converter public static org . springframework . integration . core . Message toSpringMessage ( final org . apache . camel . Message camelMessage ) throws Exception { if ( camelMessage instanceof SpringIntegrationMessage ) { SpringIntegrationMessage siMessage = ( SpringIntegrationMessage ) camelMessage ; org . springframework . integration . core . Message message = siMessage . getMessage ( ) ; if ( message != null ) { return message ; } } MessageHeaders messageHeaders = new MessageHeaders ( camelMessage . getHeaders ( ) ) ; return new GenericMessage ( camelMessage . getBody ( ) , messageHeaders ) ; } @ Converter public static org . apache . camel . Message toCamelMessage ( final org . springframework . integration . core . Message springMessage ) throws Exception { return new SpringIntegrationMessage ( springMessage ) ; } } 	0	['4', '1', '0', '9', '13', '6', '0', '9', '3', '2', '54', '0', '0', '0', '0.25', '0', '0', '12.5', '1', '0.75', '0']
package org . apache . camel . component . jms . requestor ; import java . util . concurrent . Callable ; import java . util . concurrent . FutureTask ; import javax . jms . JMSException ; import javax . jms . Message ; public class FutureHandler extends FutureTask < Message > implements ReplyHandler { private static final Callable < Message > EMPTY_CALLABLE = new Callable < Message > ( ) { public Message call ( ) throws Exception { return null ; } } ; public FutureHandler ( ) { super ( EMPTY_CALLABLE ) ; } public synchronized void set ( Message result ) { super . set ( result ) ; } public boolean handle ( Message message ) throws JMSException { set ( message ) ; return true ; } } 	0	['5', '2', '1', '5', '8', '8', '3', '2', '4', '0.75', '29', '1', '0', '0.769230769', '0.583333333', '0', '0', '4.6', '1', '0.6', '0']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "sql" ) public class SqlExpression extends ExpressionType { public SqlExpression ( ) { } public SqlExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "sql" ; } } 	0	['3', '2', '0', '1', '5', '3', '0', '1', '3', '2', '12', '0', '0', '0.956521739', '0.666666667', '1', '2', '3', '1', '0.3333', '0']
package org . apache . camel . osgi ; import org . apache . camel . impl . converter . AnnotationTypeConverterLoader ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . osgi . framework . BundleContext ; public class OsgiAnnotationTypeConverterLoader extends AnnotationTypeConverterLoader { private static final transient Log LOG = LogFactory . getLog ( OsgiAnnotationTypeConverterLoader . class ) ; public OsgiAnnotationTypeConverterLoader ( BundleContext context ) { super ( new OsgiResolverUtil ( context ) ) ; } protected String [ ] findPackageNames ( ) { return Activator . findTypeConverterPackageNames ( ) ; } } 	0	['3', '2', '0', '8', '7', '3', '1', '7', '1', '1', '17', '1', '0', '0.875', '0.75', '1', '1', '4.333333333', '1', '0.3333', '0']
package org . apache . camel ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . CONSTRUCTOR } ) public @ interface Consume { String uri ( ) default "" ; String ref ( ) default "" ; } 	0	['2', '1', '0', '1', '2', '1', '1', '0', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . impl ; import java . io . ByteArrayOutputStream ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . zip . Deflater ; import java . util . zip . DeflaterOutputStream ; import java . util . zip . InflaterInputStream ; import org . apache . camel . Exchange ; import org . apache . camel . converter . IOConverter ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . util . ExchangeHelper ; public class ZipDataFormat implements DataFormat { private int compressionLevel ; public ZipDataFormat ( ) { this . compressionLevel = Deflater . BEST_SPEED ; } public ZipDataFormat ( int compressionLevel ) { this . compressionLevel = compressionLevel ; } public void marshal ( Exchange exchange , Object graph , OutputStream stream ) throws Exception { InputStream is = exchange . getContext ( ) . getTypeConverter ( ) . convertTo ( InputStream . class , graph ) ; if ( is == null ) { throw new IllegalArgumentException ( "Cannot get the inputstream for ZipDataFormat mashalling" ) ; } DeflaterOutputStream zipOutput = new DeflaterOutputStream ( stream , new Deflater ( compressionLevel ) ) ; try { IOConverter . copy ( is , zipOutput ) ; } finally { zipOutput . close ( ) ; } } public Object unmarshal ( Exchange exchange , InputStream stream ) throws Exception { InputStream is = ExchangeHelper . getMandatoryInBody ( exchange , InputStream . class ) ; InflaterInputStream unzipInput = new InflaterInputStream ( is ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; IOConverter . copy ( unzipInput , bos ) ; return bos . toByteArray ( ) ; } } 	0	['4', '1', '0', '7', '17', '0', '1', '6', '4', '0.333333333', '74', '1', '0', '0', '0.416666667', '0', '0', '17.25', '1', '0.5', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . Predicate ; import org . apache . camel . builder . ErrorHandlerBuilder ; import org . apache . camel . processor . DelegateProcessor ; @ XmlRootElement ( name = "routes" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class RoutesType extends OptionalIdentifiedType < RoutesType > implements RouteContainer { @ XmlAttribute private Boolean inheritErrorHandlerFlag ; @ XmlElementRef private List < RouteType > routes = new ArrayList < RouteType > ( ) ; @ XmlElementRef private List < ServiceActivationType > activations = new ArrayList < ServiceActivationType > ( ) ; @ XmlTransient private List < InterceptorType > interceptors = new ArrayList < InterceptorType > ( ) ; @ XmlTransient private List < InterceptType > intercepts = new ArrayList < InterceptType > ( ) ; @ XmlTransient private List < ExceptionType > exceptions = new ArrayList < ExceptionType > ( ) ; @ XmlTransient private CamelContext camelContext ; @ XmlTransient private ErrorHandlerBuilder errorHandlerBuilder ; @ Override public String toString ( ) { return "Routes: " + routes ; } public List < RouteType > getRoutes ( ) { return routes ; } public void setRoutes ( List < RouteType > routes ) { this . routes = routes ; } public List < InterceptorType > getInterceptors ( ) { return interceptors ; } public void setInterceptors ( List < InterceptorType > interceptors ) { this . interceptors = interceptors ; } public List < InterceptType > getIntercepts ( ) { return intercepts ; } public void setIntercepts ( List < InterceptType > intercepts ) { this . intercepts = intercepts ; } public List < ExceptionType > getExceptions ( ) { return exceptions ; } public void setExceptions ( List < ExceptionType > exceptions ) { this . exceptions = exceptions ; } public CamelContext getCamelContext ( ) { return camelContext ; } public void setCamelContext ( CamelContext camelContext ) { this . camelContext = camelContext ; } public boolean isInheritErrorHandler ( ) { return ProcessorType . isInheritErrorHandler ( getInheritErrorHandlerFlag ( ) ) ; } public Boolean getInheritErrorHandlerFlag ( ) { return inheritErrorHandlerFlag ; } public void setInheritErrorHandlerFlag ( Boolean inheritErrorHandlerFlag ) { this . inheritErrorHandlerFlag = inheritErrorHandlerFlag ; } public ErrorHandlerBuilder getErrorHandlerBuilder ( ) { return errorHandlerBuilder ; } public void setErrorHandlerBuilder ( ErrorHandlerBuilder errorHandlerBuilder ) { this . errorHandlerBuilder = errorHandlerBuilder ; } public RouteType route ( ) { RouteType route = createRoute ( ) ; return route ( route ) ; } public RouteType from ( String uri ) { RouteType route = createRoute ( ) ; route . from ( uri ) ; return route ( route ) ; } public RouteType from ( Endpoint endpoint ) { RouteType route = createRoute ( ) ; route . from ( endpoint ) ; return route ( route ) ; } public RouteType route ( RouteType route ) { route . setCamelContext ( getCamelContext ( ) ) ; route . setInheritErrorHandlerFlag ( getInheritErrorHandlerFlag ( ) ) ; List < InterceptorType > list = getInterceptors ( ) ; for ( InterceptorType interceptorType : list ) { route . addInterceptor ( interceptorType ) ; } List < InterceptType > intercepts = getIntercepts ( ) ; for ( InterceptType intercept : intercepts ) { InterceptType proxy = intercept . createProxy ( ) ; route . addOutput ( proxy ) ; route . pushBlock ( proxy . getProceed ( ) ) ; } route . getOutputs ( ) . addAll ( getExceptions ( ) ) ; getRoutes ( ) . add ( route ) ; return route ; } public RoutesType intercept ( DelegateProcessor interceptor ) { getInterceptors ( ) . add ( new InterceptorRef ( interceptor ) ) ; return this ; } public InterceptType intercept ( ) { InterceptType answer = new InterceptType ( ) ; getIntercepts ( ) . add ( answer ) ; return answer ; } public ChoiceType intercept ( Predicate predicate ) { InterceptType answer = new InterceptType ( ) ; getIntercepts ( ) . add ( answer ) ; return answer . when ( predicate ) ; } public ExceptionType onException ( Class exceptionType ) { ExceptionType answer = new ExceptionType ( exceptionType ) ; getExceptions ( ) . add ( answer ) ; return answer ; } protected RouteType createRoute ( ) { RouteType route = new RouteType ( ) ; ErrorHandlerBuilder handler = getErrorHandlerBuilder ( ) ; if ( isInheritErrorHandler ( ) && handler != null ) { route . setErrorHandlerBuilderIfNull ( handler ) ; } return route ; } } 	0	['26', '2', '0', '17', '54', '289', '1', '16', '25', '0.875', '279', '1', '2', '0.324324324', '0.136363636', '0', '0', '9.423076923', '3', '1.1154', '0']
package org . apache . camel . component . cxf . invoker ; import javax . xml . ws . soap . SOAPBinding ; import org . apache . cxf . BusException ; import org . apache . cxf . endpoint . Client ; import org . apache . cxf . endpoint . ClientImpl ; import org . apache . cxf . endpoint . Endpoint ; import org . apache . cxf . endpoint . EndpointException ; import org . apache . cxf . frontend . ClientFactoryBean ; import org . apache . cxf . jaxws . binding . soap . JaxWsSoapBindingConfiguration ; import org . apache . cxf . jaxws . support . JaxWsServiceFactoryBean ; import org . apache . cxf . service . factory . ReflectionServiceFactoryBean ; import org . apache . cxf . service . factory . ServiceConstructionException ; public class CxfClientFactoryBean extends ClientFactoryBean { private boolean isJSR181Enabled ; public CxfClientFactoryBean ( ) { super ( ) ; } public void setJSR181Enabled ( boolean enabled ) { if ( enabled ) { setServiceFactory ( new JaxWsServiceFactoryBean ( ) ) ; } else { setServiceFactory ( new ReflectionServiceFactoryBean ( ) ) ; } isJSR181Enabled = enabled ; } @ Override public void setBindingId ( String bind ) { super . setBindingId ( bind ) ; if ( isJSR181Enabled ) { if ( SOAPBinding . SOAP11HTTP_BINDING . equals ( bind ) || SOAPBinding . SOAP12HTTP_BINDING . equals ( bind ) ) { setBindingConfig ( new JaxWsSoapBindingConfiguration ( ( JaxWsServiceFactoryBean ) getServiceFactory ( ) ) ) ; } else if ( SOAPBinding . SOAP11HTTP_MTOM_BINDING . equals ( bind ) || SOAPBinding . SOAP12HTTP_MTOM_BINDING . equals ( bind ) ) { setBindingConfig ( new JaxWsSoapBindingConfiguration ( ( JaxWsServiceFactoryBean ) getServiceFactory ( ) ) ) ; ( ( JaxWsSoapBindingConfiguration ) getBindingConfig ( ) ) . setMtomEnabled ( true ) ; } } } protected void createClient ( Endpoint ep ) { CxfClient client = new CxfClient ( getBus ( ) , ep ) ; setClient ( client ) ; } } 	0	['4', '0', '0', '10', '18', '4', '1', '9', '3', '0.666666667', '81', '1', '0', '0', '0.4375', '0', '0', '19', '6', '2.25', '0']
package org . apache . camel . impl . converter ; import java . beans . PropertyEditor ; import java . beans . PropertyEditorManager ; import org . apache . camel . Exchange ; import org . apache . camel . TypeConverter ; import org . apache . camel . util . ObjectHelper ; public class PropertyEditorTypeConverter implements TypeConverter { public < T > T convertTo ( Class < T > toType , Object value ) { if ( value == null ) { return null ; } if ( value . getClass ( ) == String . class ) { if ( toType == String . class ) { return ObjectHelper . cast ( toType , value ) ; } PropertyEditor editor = PropertyEditorManager . findEditor ( toType ) ; if ( editor != null ) { editor . setAsText ( value . toString ( ) ) ; return ObjectHelper . cast ( toType , editor . getValue ( ) ) ; } } else if ( toType == String . class ) { PropertyEditor editor = PropertyEditorManager . findEditor ( value . getClass ( ) ) ; if ( editor != null ) { editor . setValue ( value ) ; return ObjectHelper . cast ( toType , editor . getAsText ( ) ) ; } } return null ; } public < T > T convertTo ( Class < T > type , Exchange exchange , Object value ) { return convertTo ( type , value ) ; } } 	0	['3', '1', '0', '4', '12', '3', '1', '3', '3', '2', '60', '0', '0', '0', '0.666666667', '0', '0', '19', '6', '2.3333', '0']
package org . apache . camel . component . jms ; import javax . jms . JMSException ; public class RuntimeJmsException extends RuntimeException { private static final long serialVersionUID = - 2141493732308871761L ; public RuntimeJmsException ( String message , JMSException cause ) { super ( message , cause ) ; } } 	0	['1', '4', '3', '4', '2', '0', '4', '0', '1', '2', '7', '1', '0', '1', '1', '0', '0', '5', '0', '0', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . builder . ExpressionBuilder ; import org . apache . camel . builder . ProcessorBuilder ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . spi . RouteContext ; import org . apache . camel . util . ObjectHelper ; @ XmlRootElement ( name = "setHeader" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class SetHeaderType extends ExpressionNode { @ XmlAttribute ( required = true ) private String headerName ; public SetHeaderType ( ) { } public SetHeaderType ( String headerName , ExpressionType expression ) { super ( expression ) ; setHeaderName ( headerName ) ; } public SetHeaderType ( String headerName , Expression expression ) { super ( expression ) ; setHeaderName ( headerName ) ; } public SetHeaderType ( String headerName , String value ) { super ( ExpressionBuilder . constantExpression ( value ) ) ; setHeaderName ( headerName ) ; } @ Override public String toString ( ) { return "SetHeader[" + getHeaderName ( ) + ", " + getExpression ( ) + "]" ; } @ Override public String getShortName ( ) { return "setHeader" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { ObjectHelper . notEmpty ( headerName , "headerName" ) ; Expression expr = getExpression ( ) . createExpression ( routeContext ) ; return ProcessorBuilder . setHeader ( getHeaderName ( ) , expr ) ; } public void setHeaderName ( String headerName ) { this . headerName = headerName ; } public String getHeaderName ( ) { return headerName ; } } 	0	['9', '4', '0', '9', '21', '30', '1', '8', '9', '0.25', '75', '1', '0', '0.973544974', '0.355555556', '2', '3', '7.222222222', '1', '0.5556', '0']
package org . apache . camel . component . restlet ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . impl . DefaultConsumer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . restlet . Restlet ; import org . restlet . data . Request ; import org . restlet . data . Response ; public class RestletConsumer extends DefaultConsumer { private static final Log LOG = LogFactory . getLog ( RestletConsumer . class ) ; private Restlet restlet ; public RestletConsumer ( Endpoint endpoint , Processor processor ) throws Exception { super ( endpoint , processor ) ; restlet = new Restlet ( ) { @ Override public void handle ( Request request , Response response ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Consumer restlet handle request method: " + request . getMethod ( ) ) ; } try { Exchange exchange = getEndpoint ( ) . createExchange ( ) ; RestletBinding binding = ( ( RestletEndpoint ) getEndpoint ( ) ) . getRestletBinding ( ) ; binding . populateExchangeFromRestletRequest ( request , exchange ) ; getProcessor ( ) . process ( exchange ) ; binding . populateRestletResponseFromExchange ( exchange , response ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } } } ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; ( ( RestletEndpoint ) getEndpoint ( ) ) . connect ( this ) ; } @ Override public void doStop ( ) throws Exception { ( ( RestletEndpoint ) getEndpoint ( ) ) . disconnect ( this ) ; super . doStop ( ) ; } public Restlet getRestlet ( ) { return restlet ; } } 	0	['6', '3', '0', '9', '14', '11', '3', '8', '3', '0.8', '44', '1', '0', '0.851851852', '0.4', '1', '1', '6', '1', '0.6667', '0']
package org . apache . camel . component . jetty ; import java . io . IOException ; import javax . servlet . ServletException ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . apache . camel . AsyncCallback ; import org . apache . camel . component . http . CamelServlet ; import org . apache . camel . component . http . HttpConsumer ; import org . apache . camel . component . http . HttpExchange ; import org . mortbay . util . ajax . Continuation ; import org . mortbay . util . ajax . ContinuationSupport ; public class CamelContinuationServlet extends CamelServlet { private static final long serialVersionUID = 1L ; @ Override protected void service ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { try { HttpConsumer consumer = resolve ( request ) ; if ( consumer == null ) { response . sendError ( HttpServletResponse . SC_NOT_FOUND ) ; return ; } final Continuation continuation = ContinuationSupport . getContinuation ( request , null ) ; if ( continuation . isNew ( ) ) { final HttpExchange exchange = new HttpExchange ( consumer . getEndpoint ( ) , request , response ) ; boolean sync = consumer . getAsyncProcessor ( ) . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { if ( sync ) { return ; } continuation . setObject ( exchange ) ; continuation . resume ( ) ; } } ) ; if ( ! sync ) { continuation . suspend ( 0 ) ; } consumer . getBinding ( ) . writeResponse ( exchange , response ) ; return ; } if ( continuation . isResumed ( ) ) { HttpExchange exchange = ( HttpExchange ) continuation . getObject ( ) ; consumer . getBinding ( ) . writeResponse ( exchange , response ) ; return ; } } catch ( Exception e ) { throw new ServletException ( e ) ; } } } 	0	['2', '1', '0', '12', '18', '1', '2', '11', '1', '2', '75', '1', '0', '0.8', '0.666666667', '1', '1', '36', '1', '0.5', '0']
package org . apache . camel ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . PARAMETER } ) public @ interface Property { String name ( ) ; } 	0	['1', '1', '0', '1', '1', '0', '1', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "ruby" ) public class RubyExpression extends ExpressionType { public RubyExpression ( ) { } public RubyExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "ruby" ; } } 	0	['3', '2', '0', '1', '5', '3', '0', '1', '3', '2', '12', '0', '0', '0.956521739', '0.666666667', '1', '2', '3', '1', '0.3333', '0']
package org . apache . camel . language . ognl ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . spi . Language ; public class OgnlLanguage implements Language { public Predicate < Exchange > createPredicate ( String expression ) { return new OgnlExpression ( this , expression , Boolean . class ) ; } public Expression < Exchange > createExpression ( String expression ) { return new OgnlExpression ( this , expression , Object . class ) ; } } 	0	['3', '1', '0', '4', '5', '3', '1', '4', '3', '2', '20', '0', '0', '0', '0.833333333', '0', '0', '5.666666667', '1', '0.6667', '0']
package org . apache . camel . component . mina ; import java . net . SocketAddress ; import java . nio . charset . Charset ; import org . apache . camel . Consumer ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . mina . common . IoAcceptor ; import org . apache . mina . common . IoAcceptorConfig ; import org . apache . mina . common . IoConnector ; import org . apache . mina . common . IoConnectorConfig ; import org . apache . mina . common . IoSession ; public class MinaEndpoint extends DefaultEndpoint < MinaExchange > { private static final long DEFAULT_TIMEOUT = 30000 ; private long timeout = DEFAULT_TIMEOUT ; private final IoAcceptor acceptor ; private final SocketAddress address ; private final IoConnector connector ; private final IoAcceptorConfig acceptorConfig ; private final IoConnectorConfig connectorConfig ; private final boolean lazySessionCreation ; private final boolean transferExchange ; private final boolean sync ; private String charsetName ; public MinaEndpoint ( String endpointUri , MinaComponent component , SocketAddress address , IoAcceptor acceptor , IoAcceptorConfig acceptorConfig , IoConnector connector , IoConnectorConfig connectorConfig , boolean lazySessionCreation , long timeout , boolean transferExchange , boolean sync ) { super ( endpointUri , component ) ; this . address = address ; this . acceptor = acceptor ; this . acceptorConfig = acceptorConfig ; this . connectorConfig = connectorConfig ; this . connector = connector ; this . lazySessionCreation = lazySessionCreation ; if ( timeout > 0 ) { this . timeout = timeout ; } this . transferExchange = transferExchange ; this . sync = sync ; } @ SuppressWarnings ( { "unchecked" } ) public Producer < MinaExchange > createProducer ( ) throws Exception { return new MinaProducer ( this ) ; } public Consumer < MinaExchange > createConsumer ( Processor processor ) throws Exception { return new MinaConsumer ( this , processor ) ; } @ Override public MinaExchange createExchange ( ExchangePattern pattern ) { return new MinaExchange ( getCamelContext ( ) , pattern , null ) ; } public MinaExchange createExchange ( IoSession session , Object payload ) { MinaExchange exchange = new MinaExchange ( getCamelContext ( ) , getExchangePattern ( ) , session ) ; MinaPayloadHelper . setIn ( exchange , payload ) ; return exchange ; } public IoAcceptor getAcceptor ( ) { return acceptor ; } public SocketAddress getAddress ( ) { return address ; } public IoConnector getConnector ( ) { return connector ; } public boolean isLazySessionCreation ( ) { return lazySessionCreation ; } public IoAcceptorConfig getAcceptorConfig ( ) { return acceptorConfig ; } public IoConnectorConfig getConnectorConfig ( ) { return connectorConfig ; } public boolean isSingleton ( ) { return true ; } public long getTimeout ( ) { return timeout ; } public boolean isTransferExchange ( ) { return transferExchange ; } public boolean isSync ( ) { return sync ; } public void setCharsetName ( String charset ) { this . charsetName = charset ; } public String getCharsetName ( ) { return charsetName ; } } 	0	['18', '2', '0', '20', '24', '133', '6', '18', '18', '0.951871658', '141', '1', '0', '0.585365854', '0.130952381', '1', '1', '6.222222222', '1', '0.9444', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Processor ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "process" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ProcessorRef extends OutputType < ProcessorType > { @ XmlAttribute ( required = true ) private String ref ; @ XmlTransient private Processor processor ; public ProcessorRef ( ) { } public ProcessorRef ( Processor processor ) { this . processor = processor ; } @ Override public String getShortName ( ) { return "process" ; } @ Override public String toString ( ) { return "process[" + ( ( ref != null ) ? "ref: " + ref : processor ) + "]" ; } @ Override public String getLabel ( ) { if ( ref != null ) { return "ref: " + ref ; } else if ( processor != null ) { return processor . toString ( ) ; } else { return "" ; } } public String getRef ( ) { return ref ; } public void setRef ( String ref ) { this . ref = ref ; } @ Override public Processor createProcessor ( RouteContext routeContext ) { if ( processor == null ) { processor = routeContext . lookup ( getRef ( ) , Processor . class ) ; } return processor ; } } 	0	['8', '4', '0', '4', '15', '6', '1', '3', '8', '0.5', '89', '1', '1', '0.967567568', '0.34375', '1', '1', '9.875', '3', '1.25', '0']
package org . apache . camel . language . bean ; import org . apache . camel . Exchange ; import org . apache . camel . RuntimeExpressionException ; public class RuntimeBeanExpressionException extends RuntimeExpressionException { private final Exchange exchange ; private final String bean ; private final String method ; public RuntimeBeanExpressionException ( Exchange exchange , String bean , String method , Throwable e ) { super ( "Failed to invoke method: " + method + " on " + bean + " due to: " + e , e ) ; this . exchange = exchange ; this . bean = bean ; this . method = method ; } public String getBean ( ) { return bean ; } public Exchange getExchange ( ) { return exchange ; } public String getMethod ( ) { return method ; } } 	0	['4', '6', '0', '3', '9', '0', '1', '2', '4', '0.666666667', '45', '1', '1', '0.85', '0.4375', '0', '0', '9.5', '1', '0.75', '0']
package org . apache . camel . spi ; import org . apache . camel . Processor ; public interface Policy < E > { Processor wrap ( Processor processor ) ; } 	0	['1', '1', '0', '5', '1', '0', '4', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . spi ; import java . util . Map ; public interface NamespaceAware { void setNamespaces ( Map < String , String > namespaces ) ; } 	0	['1', '1', '0', '6', '1', '0', '6', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . cxf . feature ; import java . util . logging . Logger ; import org . apache . camel . component . cxf . interceptors . DOMInInterceptor ; import org . apache . camel . component . cxf . interceptors . DOMOutInterceptor ; import org . apache . camel . component . cxf . interceptors . FaultOutInterceptor ; import org . apache . camel . component . cxf . interceptors . PayloadContentRedirectInterceptor ; import org . apache . cxf . Bus ; import org . apache . cxf . binding . Binding ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . endpoint . Client ; import org . apache . cxf . endpoint . Server ; import org . apache . cxf . phase . Phase ; public class PayLoadDataFormatFeature extends AbstractDataFormatFeature { private static final Logger LOG = LogUtils . getL7dLogger ( PayLoadDataFormatFeature . class ) ; private static final String [ ] REMOVING_IN_PHASES = { Phase . UNMARSHAL , Phase . PRE_LOGICAL , Phase . PRE_LOGICAL_ENDING , Phase . POST_LOGICAL , Phase . POST_LOGICAL_ENDING } ; private static final String [ ] REMOVING_OUT_PHASES = { Phase . MARSHAL , Phase . MARSHAL_ENDING , Phase . PRE_LOGICAL , Phase . PRE_LOGICAL_ENDING , Phase . POST_LOGICAL , Phase . POST_LOGICAL_ENDING } ; @ Override public void initialize ( Client client , Bus bus ) { removeInterceptorWhichIsInThePhases ( client . getInInterceptors ( ) , REMOVING_IN_PHASES ) ; removeInterceptorWhichIsInThePhases ( client . getEndpoint ( ) . getService ( ) . getInInterceptors ( ) , REMOVING_IN_PHASES ) ; removeInterceptorWhichIsInThePhases ( client . getEndpoint ( ) . getInInterceptors ( ) , REMOVING_IN_PHASES ) ; removeInterceptorWhichIsInThePhases ( client . getEndpoint ( ) . getBinding ( ) . getInInterceptors ( ) , REMOVING_IN_PHASES ) ; removeInterceptorWhichIsInThePhases ( client . getOutInterceptors ( ) , REMOVING_OUT_PHASES ) ; removeInterceptorWhichIsInThePhases ( client . getEndpoint ( ) . getService ( ) . getOutInterceptors ( ) , REMOVING_OUT_PHASES ) ; removeInterceptorWhichIsInThePhases ( client . getEndpoint ( ) . getOutInterceptors ( ) , REMOVING_OUT_PHASES ) ; removeInterceptorWhichIsInThePhases ( client . getEndpoint ( ) . getBinding ( ) . getOutInterceptors ( ) , REMOVING_OUT_PHASES ) ; addDataHandlingInterceptors ( client . getEndpoint ( ) . getBinding ( ) ) ; client . getEndpoint ( ) . getBinding ( ) . getOutFaultInterceptors ( ) . add ( new FaultOutInterceptor ( ) ) ; } @ Override public void initialize ( Server server , Bus bus ) { removeInterceptorWhichIsInThePhases ( server . getEndpoint ( ) . getService ( ) . getInInterceptors ( ) , REMOVING_IN_PHASES ) ; removeInterceptorWhichIsInThePhases ( server . getEndpoint ( ) . getInInterceptors ( ) , REMOVING_IN_PHASES ) ; removeInterceptorWhichIsInThePhases ( server . getEndpoint ( ) . getBinding ( ) . getInInterceptors ( ) , REMOVING_IN_PHASES ) ; removeInterceptorWhichIsInThePhases ( server . getEndpoint ( ) . getService ( ) . getOutInterceptors ( ) , REMOVING_OUT_PHASES ) ; removeInterceptorWhichIsInThePhases ( server . getEndpoint ( ) . getOutInterceptors ( ) , REMOVING_OUT_PHASES ) ; removeInterceptorWhichIsInThePhases ( server . getEndpoint ( ) . getBinding ( ) . getOutInterceptors ( ) , REMOVING_OUT_PHASES ) ; resetServiceInvokerInterceptor ( server ) ; addDataHandlingInterceptors ( server . getEndpoint ( ) . getBinding ( ) ) ; server . getEndpoint ( ) . getBinding ( ) . getOutFaultInterceptors ( ) . add ( new FaultOutInterceptor ( ) ) ; } private void addDataHandlingInterceptors ( Binding binding ) { binding . getInInterceptors ( ) . add ( new DOMInInterceptor ( ) ) ; binding . getOutInterceptors ( ) . add ( new DOMOutInterceptor ( ) ) ; binding . getOutInterceptors ( ) . add ( new PayloadContentRedirectInterceptor ( ) ) ; } @ Override protected Logger getLogger ( ) { return LOG ; } } 	0	['6', '1', '0', '14', '28', '7', '2', '12', '3', '0.666666667', '213', '1', '0', '0.5', '0.4', '1', '1', '34', '1', '0.6667', '0']
package org . apache . camel ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . PARAMETER } ) public @ interface OutHeaders { } 	0	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . component . http ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . builder . ExpressionBuilder ; import org . apache . commons . httpclient . HttpMethod ; import org . apache . commons . httpclient . methods . DeleteMethod ; import org . apache . commons . httpclient . methods . EntityEnclosingMethod ; import org . apache . commons . httpclient . methods . GetMethod ; import org . apache . commons . httpclient . methods . HeadMethod ; import org . apache . commons . httpclient . methods . OptionsMethod ; import org . apache . commons . httpclient . methods . PostMethod ; import org . apache . commons . httpclient . methods . PutMethod ; import org . apache . commons . httpclient . methods . TraceMethod ; public enum HttpMethods implements Expression < Exchange > { GET ( GetMethod . class ) , POST ( PostMethod . class ) , PUT ( PutMethod . class ) , DELETE ( DeleteMethod . class ) , HEAD ( HeadMethod . class ) , OPTIONS ( OptionsMethod . class ) , TRACE ( TraceMethod . class ) ; public static final String HTTP_METHOD = "http.requestMethod" ; final Class < ? extends HttpMethod > clazz ; final boolean entity ; HttpMethods ( Class < ? extends HttpMethod > clazz ) { this . clazz = clazz ; entity = EntityEnclosingMethod . class . isAssignableFrom ( clazz ) ; } public HttpMethod createMethod ( final String url ) { try { return clazz . getDeclaredConstructor ( String . class ) . newInstance ( url ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } public HttpMethod createMethod ( ) { try { return clazz . newInstance ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } public final boolean isEntityEnclosing ( ) { return entity ; } public Object evaluate ( Exchange exchange ) { return ExpressionBuilder . constantExpression ( name ( ) ) . evaluate ( exchange ) ; } } 	0	['8', '2', '0', '6', '19', '18', '1', '5', '6', '0.935064935', '166', '0.090909091', '8', '0.666666667', '0.314285714', '1', '1', '18.375', '1', '0.75', '0']
package org . apache . camel . component . jms . requestor ; import java . util . HashMap ; import java . util . Map ; import java . util . concurrent . FutureTask ; import java . util . concurrent . ScheduledExecutorService ; import javax . jms . Destination ; import javax . jms . ExceptionListener ; import javax . jms . JMSException ; import javax . jms . Message ; import javax . jms . MessageListener ; import javax . jms . Session ; import javax . jms . TemporaryQueue ; import org . apache . camel . component . jms . JmsConfiguration ; import org . apache . camel . component . jms . JmsProducer ; import org . apache . camel . component . jms . requestor . DeferredRequestReplyMap . DeferredMessageSentCallback ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . DefaultTimeoutMap ; import org . apache . camel . util . TimeoutMap ; import org . apache . camel . util . UuidGenerator ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . core . task . TaskExecutor ; import org . springframework . jms . listener . AbstractMessageListenerContainer ; import org . springframework . jms . listener . SimpleMessageListenerContainer ; import org . springframework . jms . listener . SimpleMessageListenerContainer102 ; import org . springframework . jms . support . destination . DestinationResolver ; public class Requestor extends ServiceSupport implements MessageListener { private static final transient Log LOG = LogFactory . getLog ( Requestor . class ) ; private static UuidGenerator uuidGenerator ; private final JmsConfiguration configuration ; private ScheduledExecutorService executorService ; private AbstractMessageListenerContainer listenerContainer ; private TimeoutMap requestMap ; private Map < JmsProducer , DeferredRequestReplyMap > producerDeferredRequestReplyMap ; private TimeoutMap deferredRequestMap ; private TimeoutMap deferredReplyMap ; private Destination replyTo ; private long maxRequestTimeout = - 1 ; private long replyToResolverTimeout = 5000 ; public Requestor ( JmsConfiguration configuration , ScheduledExecutorService executorService ) { this . configuration = configuration ; this . executorService = executorService ; requestMap = new DefaultTimeoutMap ( executorService , configuration . getRequestMapPurgePollTimeMillis ( ) ) ; producerDeferredRequestReplyMap = new HashMap < JmsProducer , DeferredRequestReplyMap > ( ) ; deferredRequestMap = new DefaultTimeoutMap ( executorService , configuration . getRequestMapPurgePollTimeMillis ( ) ) ; deferredReplyMap = new DefaultTimeoutMap ( executorService , configuration . getRequestMapPurgePollTimeMillis ( ) ) ; } public synchronized DeferredRequestReplyMap getDeferredRequestReplyMap ( JmsProducer producer ) { DeferredRequestReplyMap map = producerDeferredRequestReplyMap . get ( producer ) ; if ( map == null ) { map = new DeferredRequestReplyMap ( this , producer , deferredRequestMap , deferredReplyMap ) ; producerDeferredRequestReplyMap . put ( producer , map ) ; if ( maxRequestTimeout == - 1 ) { maxRequestTimeout = producer . getRequestTimeout ( ) ; } else if ( maxRequestTimeout < producer . getRequestTimeout ( ) ) { maxRequestTimeout = producer . getRequestTimeout ( ) ; } } return map ; } public synchronized void removeDeferredRequestReplyMap ( JmsProducer producer ) { DeferredRequestReplyMap map = producerDeferredRequestReplyMap . remove ( producer ) ; if ( map == null ) { return ; } if ( maxRequestTimeout == producer . getRequestTimeout ( ) ) { long max = - 1 ; for ( Map . Entry < JmsProducer , DeferredRequestReplyMap > entry : producerDeferredRequestReplyMap . entrySet ( ) ) { if ( max < entry . getKey ( ) . getRequestTimeout ( ) ) { max = entry . getKey ( ) . getRequestTimeout ( ) ; } } maxRequestTimeout = max ; } } public synchronized long getMaxRequestTimeout ( ) { return maxRequestTimeout ; } public TimeoutMap getRequestMap ( ) { return requestMap ; } public TimeoutMap getDeferredRequestMap ( ) { return deferredRequestMap ; } public TimeoutMap getDeferredReplyMap ( ) { return deferredReplyMap ; } public FutureTask getReceiveFuture ( String correlationID , long requestTimeout ) { FutureHandler future = createFutureHandler ( correlationID ) ; requestMap . put ( correlationID , future , requestTimeout ) ; return future ; } public FutureTask getReceiveFuture ( DeferredMessageSentCallback callback ) { FutureHandler future = createFutureHandler ( callback ) ; DeferredRequestReplyMap map = callback . getDeferredRequestReplyMap ( ) ; map . put ( callback , future ) ; return future ; } protected FutureHandler createFutureHandler ( String correlationID ) { return new FutureHandler ( ) ; } protected FutureHandler createFutureHandler ( DeferredMessageSentCallback callback ) { return new FutureHandler ( ) ; } public void onMessage ( Message message ) { try { String correlationID = message . getJMSCorrelationID ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Message correlationID: " + correlationID ) ; } if ( correlationID == null ) { LOG . warn ( "Ignoring message with no correlationID! " + message ) ; return ; } Object handler = requestMap . get ( correlationID ) ; if ( handler != null && handler instanceof ReplyHandler ) { ReplyHandler replyHandler = ( ReplyHandler ) handler ; boolean complete = replyHandler . handle ( message ) ; if ( complete ) { requestMap . remove ( correlationID ) ; } } else { DeferredRequestReplyMap . processDeferredRequests ( this , deferredRequestMap , deferredReplyMap , correlationID , getMaxRequestTimeout ( ) , message ) ; } } catch ( JMSException e ) { throw new FailedToProcessResponse ( message , e ) ; } } public AbstractMessageListenerContainer getListenerContainer ( ) { if ( listenerContainer == null ) { listenerContainer = createListenerContainer ( ) ; } return listenerContainer ; } public void setListenerContainer ( AbstractMessageListenerContainer listenerContainer ) { this . listenerContainer = listenerContainer ; } public Destination getReplyTo ( ) { synchronized ( this ) { try { if ( replyTo == null ) { wait ( replyToResolverTimeout ) ; } } catch ( Throwable e ) { } } return replyTo ; } public void setReplyTo ( Destination replyTo ) { this . replyTo = replyTo ; } @ Override protected void doStart ( ) throws Exception { AbstractMessageListenerContainer container = getListenerContainer ( ) ; container . afterPropertiesSet ( ) ; } @ Override protected void doStop ( ) throws Exception { if ( listenerContainer != null ) { listenerContainer . stop ( ) ; listenerContainer . destroy ( ) ; } } protected Requestor getOutterInstance ( ) { return this ; } protected AbstractMessageListenerContainer createListenerContainer ( ) { SimpleMessageListenerContainer answer = configuration . isUseVersion102 ( ) ? new SimpleMessageListenerContainer102 ( ) : new SimpleMessageListenerContainer ( ) ; answer . setDestinationName ( "temporary" ) ; answer . setDestinationResolver ( new DestinationResolver ( ) { public Destination resolveDestinationName ( Session session , String destinationName , boolean pubSubDomain ) throws JMSException { TemporaryQueue queue = null ; synchronized ( getOutterInstance ( ) ) { try { queue = session . createTemporaryQueue ( ) ; setReplyTo ( queue ) ; } finally { getOutterInstance ( ) . notifyAll ( ) ; } } return queue ; } } ) ; answer . setAutoStartup ( true ) ; answer . setMessageListener ( this ) ; answer . setPubSubDomain ( false ) ; answer . setSubscriptionDurable ( false ) ; answer . setConcurrentConsumers ( 1 ) ; answer . setConnectionFactory ( configuration . getConnectionFactory ( ) ) ; String clientId = configuration . getClientId ( ) ; if ( clientId != null ) { clientId += ".Requestor" ; answer . setClientId ( clientId ) ; } TaskExecutor taskExecutor = configuration . getTaskExecutor ( ) ; if ( taskExecutor != null ) { answer . setTaskExecutor ( taskExecutor ) ; } ExceptionListener exceptionListener = configuration . getExceptionListener ( ) ; if ( exceptionListener != null ) { answer . setExceptionListener ( exceptionListener ) ; } return answer ; } public static synchronized UuidGenerator getUuidGenerator ( ) { if ( uuidGenerator == null ) { uuidGenerator = new UuidGenerator ( ) ; } return uuidGenerator ; } protected JmsConfiguration getConfiguration ( ) { return configuration ; } public void setReplyToSelectorHeader ( org . apache . camel . Message in , Message jmsIn ) throws JMSException { } } 	0	['24', '2', '1', '25', '80', '220', '8', '20', '16', '0.90942029', '444', '1', '5', '0.388888889', '0.14229249', '1', '1', '17', '5', '1.5833', '0']
package org . apache . camel . component . ref ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultComponent ; public class RefComponent extends DefaultComponent < Exchange > { protected Endpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { int index = uri . indexOf ( ":" ) ; String name = uri ; if ( index >= 0 ) { name = uri . substring ( index + 1 ) ; } return lookupEndpoint ( name , parameters ) ; } protected Endpoint lookupEndpoint ( String name , Map parameters ) { return getCamelContext ( ) . getRegistry ( ) . lookup ( name , Endpoint . class ) ; } } 	0	['3', '3', '0', '4', '9', '3', '0', '4', '1', '2', '33', '0', '0', '0.945945946', '0.777777778', '1', '1', '10', '1', '0.6667', '0']
package org . apache . camel . processor . interceptor ; import org . apache . camel . Exchange ; public class Breakpoint { public void waitForBreakpoint ( Exchange exchange ) { } } 	0	['2', '1', '0', '3', '3', '1', '2', '1', '2', '2', '6', '0', '0', '0', '0.75', '0', '0', '2', '1', '0.5', '0']
package org . apache . camel . management ; import java . util . Date ; import java . util . concurrent . atomic . AtomicLong ; import org . springframework . jmx . export . annotation . ManagedAttribute ; import org . springframework . jmx . export . annotation . ManagedOperation ; import org . springframework . jmx . export . annotation . ManagedResource ; @ ManagedResource ( description = "PerformanceCounter" , currencyTimeLimit = 15 ) public class PerformanceCounter extends Counter { private AtomicLong numCompleted = new AtomicLong ( 0L ) ; private double minProcessingTime ; private double maxProcessingTime ; private double totalProcessingTime ; private Date lastExchangeCompletionTime ; private Date lastExchangeFailureTime ; private Date firstExchangeCompletionTime ; private Date firstExchangeFailureTime ; @ Override @ ManagedOperation ( description = "Reset counters" ) public synchronized void reset ( ) { super . reset ( ) ; numCompleted . set ( 0L ) ; minProcessingTime = 0.0 ; maxProcessingTime = 0.0 ; totalProcessingTime = 0.0 ; lastExchangeCompletionTime = null ; lastExchangeFailureTime = null ; firstExchangeCompletionTime = null ; firstExchangeFailureTime = null ; } @ ManagedAttribute ( description = "Number of successful exchanges" ) public long getNumCompleted ( ) throws Exception { return numCompleted . get ( ) ; } @ ManagedAttribute ( description = "Number of failed exchanges" ) public long getNumFailed ( ) throws Exception { return numExchanges . get ( ) - numCompleted . get ( ) ; } @ ManagedAttribute ( description = "Min Processing Time [milliseconds]" ) public synchronized double getMinProcessingTimeMillis ( ) throws Exception { return minProcessingTime ; } @ ManagedAttribute ( description = "Mean Processing Time [milliseconds]" ) public synchronized double getMeanProcessingTimeMillis ( ) throws Exception { long count = numCompleted . get ( ) ; return count > 0 ? totalProcessingTime / count : 0.0 ; } @ ManagedAttribute ( description = "Max Processing Time [milliseconds]" ) public synchronized double getMaxProcessingTimeMillis ( ) throws Exception { return maxProcessingTime ; } @ ManagedAttribute ( description = "Total Processing Time [milliseconds]" ) public synchronized double getTotalProcessingTimeMillis ( ) throws Exception { return totalProcessingTime ; } @ ManagedAttribute ( description = "Last Exchange Completed Timestamp" ) public synchronized Date getLastExchangeCompletionTime ( ) { return lastExchangeCompletionTime ; } @ ManagedAttribute ( description = "First Exchange Completed Timestamp" ) public synchronized Date getFirstExchangeCompletionTime ( ) { return firstExchangeCompletionTime ; } @ ManagedAttribute ( description = "Last Exchange Failed Timestamp" ) public synchronized Date getLastExchangeFailureTime ( ) { return lastExchangeFailureTime ; } @ ManagedAttribute ( description = "First Exchange Failed Timestamp" ) public synchronized Date getFirstExchangeFailureTime ( ) { return firstExchangeFailureTime ; } public synchronized void completedExchange ( double time ) { increment ( ) ; numCompleted . incrementAndGet ( ) ; totalProcessingTime += time ; if ( minProcessingTime <= 0 || time < minProcessingTime ) { minProcessingTime = time ; } if ( time > maxProcessingTime ) { maxProcessingTime = time ; } Date timestamp = new Date ( ) ; if ( firstExchangeCompletionTime == null ) { firstExchangeCompletionTime = timestamp ; } lastExchangeCompletionTime = timestamp ; } public synchronized void failedExchange ( ) { increment ( ) ; Date timestamp = new Date ( ) ; if ( firstExchangeFailureTime == null ) { firstExchangeFailureTime = timestamp ; } lastExchangeFailureTime = timestamp ; } } 	0	['14', '2', '1', '6', '22', '29', '5', '1', '14', '0.807692308', '173', '1', '0', '0.1875', '0.535714286', '0', '0', '10.78571429', '5', '1.2857', '0']
package org . apache . camel . converter ; import org . apache . camel . Converter ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Message ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; @ Converter public class CamelConverter { @ Converter public Processor toProcessor ( final Predicate < Exchange > predicate ) { return new Processor ( ) { public void process ( Exchange exchange ) throws Exception { boolean answer = predicate . matches ( exchange ) ; Message out = exchange . getOut ( ) ; out . copyFrom ( exchange . getIn ( ) ) ; out . setBody ( answer ) ; } } ; } @ Converter public Processor toProcessor ( final Expression < Exchange > expresion ) { return new Processor ( ) { public void process ( Exchange exchange ) throws Exception { Object answer = expresion . evaluate ( exchange ) ; Message out = exchange . getOut ( ) ; out . copyFrom ( exchange . getIn ( ) ) ; out . setBody ( answer ) ; } } ; } } 	0	['3', '1', '0', '5', '6', '3', '2', '5', '3', '2', '18', '0', '0', '0', '0.555555556', '0', '0', '5', '1', '0.6667', '0']
package org . apache . camel . spring . spi ; import org . apache . camel . Processor ; import org . apache . camel . spi . Policy ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . transaction . PlatformTransactionManager ; import org . springframework . transaction . support . TransactionTemplate ; public class SpringTransactionPolicy < E > implements Policy < E > { private static final transient Log LOG = LogFactory . getLog ( SpringTransactionPolicy . class ) ; private TransactionTemplate template ; private String propagationBehaviorName ; private PlatformTransactionManager transactionManager ; public SpringTransactionPolicy ( ) { } public SpringTransactionPolicy ( TransactionTemplate template ) { this . template = template ; } public Processor wrap ( Processor processor ) { final TransactionTemplate transactionTemplate = getTemplate ( ) ; if ( transactionTemplate == null ) { LOG . warn ( "No TransactionTemplate available so transactions will not be enabled!" ) ; return processor ; } TransactionInterceptor answer = new TransactionInterceptor ( transactionTemplate ) ; answer . setProcessor ( processor ) ; return answer ; } public TransactionTemplate getTemplate ( ) { if ( template == null ) { template = new TransactionTemplate ( transactionManager ) ; if ( propagationBehaviorName != null ) { template . setPropagationBehaviorName ( propagationBehaviorName ) ; } } return template ; } public void setTemplate ( TransactionTemplate template ) { this . template = template ; } public void setTransactionManager ( PlatformTransactionManager transactionManager ) { this . transactionManager = transactionManager ; } public PlatformTransactionManager getTransactionManager ( ) { return transactionManager ; } public void setPropagationBehaviorName ( String propagationBehaviorName ) { this . propagationBehaviorName = propagationBehaviorName ; } public String getPropagationBehaviorName ( ) { return propagationBehaviorName ; } } 	0	['10', '1', '0', '8', '17', '25', '1', '7', '9', '0.722222222', '86', '1', '0', '0', '0.311111111', '0', '0', '7.2', '3', '1', '0']
package org . apache . camel . spring ; import org . apache . camel . Endpoint ; import org . apache . camel . NoTypeConversionAvailableException ; import org . apache . camel . component . bean . BeanProcessor ; import org . apache . camel . component . event . EventComponent ; import org . apache . camel . component . event . EventEndpoint ; import org . apache . camel . impl . DefaultCamelContext ; import org . apache . camel . impl . ProcessorEndpoint ; import org . apache . camel . spi . Injector ; import org . apache . camel . spi . Registry ; import org . apache . camel . spring . spi . ApplicationContextRegistry ; import org . apache . camel . spring . spi . SpringInjector ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . DisposableBean ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . context . ApplicationEvent ; import org . springframework . context . ApplicationListener ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . context . event . ContextRefreshedEvent ; import org . springframework . context . support . ClassPathXmlApplicationContext ; import static org . apache . camel . util . ObjectHelper . wrapRuntimeCamelException ; public class SpringCamelContext extends DefaultCamelContext implements InitializingBean , DisposableBean , ApplicationContextAware , ApplicationListener { private static final transient Log LOG = LogFactory . getLog ( SpringCamelContext . class ) ; private ApplicationContext applicationContext ; private EventEndpoint eventEndpoint ; private boolean shouldStartContext = ObjectHelper . getSystemProperty ( "shouldStartContext" , Boolean . TRUE ) ; public SpringCamelContext ( ) { } public SpringCamelContext ( ApplicationContext applicationContext ) { setApplicationContext ( applicationContext ) ; } public static SpringCamelContext springCamelContext ( ApplicationContext applicationContext ) throws Exception { String [ ] names = applicationContext . getBeanNamesForType ( SpringCamelContext . class ) ; if ( names . length == 1 ) { return ( SpringCamelContext ) applicationContext . getBean ( names [ 0 ] , SpringCamelContext . class ) ; } SpringCamelContext answer = new SpringCamelContext ( ) ; answer . setApplicationContext ( applicationContext ) ; answer . afterPropertiesSet ( ) ; return answer ; } public static SpringCamelContext springCamelContext ( String configLocations ) throws Exception { return springCamelContext ( new ClassPathXmlApplicationContext ( configLocations ) ) ; } public void afterPropertiesSet ( ) throws Exception { maybeStart ( ) ; } private void maybeStart ( ) throws Exception { if ( getShouldStartContext ( ) ) { LOG . debug ( "Starting the CamelContext now that the ApplicationContext has started" ) ; start ( ) ; } else { LOG . debug ( "Not starting the CamelContext since shouldStartContext property was false." ) ; } } public void destroy ( ) throws Exception { stop ( ) ; } public void onApplicationEvent ( ApplicationEvent event ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Publishing spring-event: " + event ) ; } if ( event instanceof ContextRefreshedEvent ) { try { maybeStart ( ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { throw wrapRuntimeCamelException ( e ) ; } if ( eventEndpoint != null ) { eventEndpoint . onApplicationEvent ( event ) ; } } else { if ( eventEndpoint != null ) { eventEndpoint . onApplicationEvent ( event ) ; } else { LOG . warn ( "No spring-event endpoint enabled for: " + event ) ; } } } public ApplicationContext getApplicationContext ( ) { return applicationContext ; } public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { this . applicationContext = applicationContext ; if ( applicationContext instanceof ConfigurableApplicationContext ) { addComponent ( "spring-event" , new EventComponent ( applicationContext ) ) ; } } public EventEndpoint getEventEndpoint ( ) { return eventEndpoint ; } public void setEventEndpoint ( EventEndpoint eventEndpoint ) { this . eventEndpoint = eventEndpoint ; } @ Override protected void doStart ( ) throws Exception { maybeDoStart ( ) ; } protected void maybeDoStart ( ) throws Exception { if ( getShouldStartContext ( ) ) { super . doStart ( ) ; if ( eventEndpoint == null ) { eventEndpoint = createEventEndpoint ( ) ; } } } @ Override protected Injector createInjector ( ) { if ( applicationContext instanceof ConfigurableApplicationContext ) { return new SpringInjector ( ( ConfigurableApplicationContext ) applicationContext ) ; } else { LOG . warn ( "Cannot use SpringInjector as applicationContext is not a ConfigurableApplicationContext as its: " + applicationContext ) ; return super . createInjector ( ) ; } } protected EventEndpoint createEventEndpoint ( ) { EventEndpoint endpoint = getEndpoint ( "spring-event:default" , EventEndpoint . class ) ; return endpoint ; } protected Endpoint convertBeanToEndpoint ( String uri , Object bean ) { try { Endpoint endpoint = getTypeConverter ( ) . convertTo ( Endpoint . class , bean ) ; if ( endpoint != null ) { endpoint . setCamelContext ( this ) ; return endpoint ; } } catch ( NoTypeConversionAvailableException ex ) { } return new ProcessorEndpoint ( uri , this , new BeanProcessor ( bean , this ) ) ; } @ Override protected Registry createRegistry ( ) { return new ApplicationContextRegistry ( getApplicationContext ( ) ) ; } public void setShouldStartContext ( boolean shouldStartContext ) { this . shouldStartContext = shouldStartContext ; } public boolean getShouldStartContext ( ) { return shouldStartContext ; } } 	0	['21', '3', '0', '37', '50', '168', '8', '29', '13', '0.725', '266', '1', '1', '0.825242718', '0.192857143', '2', '3', '11.47619048', '5', '1.0952', '0']
package org . apache . camel . component . cxf . util ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . apache . camel . component . cxf . transport . CamelTransportConstants ; import org . apache . camel . spi . HeaderFilterStrategy ; import org . apache . cxf . endpoint . Client ; import org . apache . cxf . helpers . CastUtils ; import org . apache . cxf . message . Message ; public final class CxfHeaderHelper { private CxfHeaderHelper ( ) { } public static void propagateCamelToCxf ( HeaderFilterStrategy strategy , Map < String , Object > headers , Message message ) { Map < String , List < String > > cxfHeaders = CastUtils . cast ( ( Map ) message . get ( Message . PROTOCOL_HEADERS ) ) ; if ( cxfHeaders == null ) { cxfHeaders = new HashMap < String , List < String > > ( ) ; message . put ( Message . PROTOCOL_HEADERS , cxfHeaders ) ; } for ( Map . Entry < String , Object > entry : headers . entrySet ( ) ) { if ( strategy != null && ! strategy . applyFilterToCamelHeaders ( entry . getKey ( ) , entry . getValue ( ) ) ) { if ( CamelTransportConstants . CONTENT_TYPE . equals ( entry . getKey ( ) ) ) { message . put ( Message . CONTENT_TYPE , entry . getValue ( ) ) ; } else if ( Client . REQUEST_CONTEXT . equals ( entry . getKey ( ) ) || Client . RESPONSE_CONTEXT . equals ( entry . getKey ( ) ) || Message . RESPONSE_CODE . equals ( entry . getKey ( ) ) ) { message . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } else { List < String > listValue = new ArrayList < String > ( ) ; listValue . add ( entry . getValue ( ) . toString ( ) ) ; cxfHeaders . put ( entry . getKey ( ) , listValue ) ; } } } } public static void propagateCxfToCamel ( HeaderFilterStrategy strategy , Message message , Map < String , Object > headers ) { if ( strategy == null ) { return ; } Map < String , List < String > > cxfHeaders = CastUtils . cast ( ( Map ) message . get ( Message . PROTOCOL_HEADERS ) ) ; if ( cxfHeaders != null ) { for ( Map . Entry < String , List < String > > entry : cxfHeaders . entrySet ( ) ) { if ( ! strategy . applyFilterToExternalHeaders ( entry . getKey ( ) , entry . getValue ( ) ) ) { headers . put ( entry . getKey ( ) , entry . getValue ( ) . get ( 0 ) ) ; } } } String key = Message . CONTENT_TYPE ; Object value = message . get ( key ) ; if ( value != null && ! strategy . applyFilterToExternalHeaders ( key , value ) ) { headers . put ( CamelTransportConstants . CONTENT_TYPE , value ) ; } key = Client . REQUEST_CONTEXT ; value = message . get ( key ) ; if ( value != null && ! strategy . applyFilterToExternalHeaders ( key , value ) ) { headers . put ( key , value ) ; } key = Client . RESPONSE_CONTEXT ; value = message . get ( key ) ; if ( value != null && ! strategy . applyFilterToExternalHeaders ( key , value ) ) { headers . put ( key , value ) ; } } } 	0	['3', '1', '0', '8', '22', '3', '5', '3', '2', '2', '193', '0', '0', '0', '0.583333333', '0', '0', '63.33333333', '10', '5.6667', '0']
package org . apache . camel . spi ; import org . apache . camel . Processor ; import org . apache . camel . model . ProcessorType ; public interface ErrorHandlerWrappingStrategy { Processor wrapProcessorInErrorHandler ( RouteContext routeContext , ProcessorType processorType , Processor target ) throws Exception ; } 	0	['1', '1', '0', '6', '1', '0', '5', '3', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel ; @ Deprecated public class InvalidHeaderTypeException extends RuntimeCamelException { private static final long serialVersionUID = - 8417806626073055262L ; private final Object headerValue ; public InvalidHeaderTypeException ( Throwable cause , Object headerValue ) { super ( cause . getMessage ( ) + " headerValue is: " + headerValue + " of type: " + typeName ( headerValue ) , cause ) ; this . headerValue = headerValue ; } public InvalidHeaderTypeException ( String message , Object headerValue ) { super ( message ) ; this . headerValue = headerValue ; } public Object getHeaderValue ( ) { return headerValue ; } protected static String typeName ( Object headerValue ) { return ( headerValue != null ) ? headerValue . getClass ( ) . getName ( ) : "null" ; } } 	0	['4', '5', '0', '1', '13', '0', '0', '1', '3', '0.833333333', '47', '1', '0', '0.894736842', '0.5', '0', '0', '10.25', '2', '0.75', '0']
package org . apache . camel . component . cxf . interceptors ; import java . util . Collection ; import java . util . Collections ; import org . apache . cxf . service . model . BindingFaultInfo ; import org . apache . cxf . service . model . BindingInfo ; import org . apache . cxf . service . model . BindingOperationInfo ; import org . apache . cxf . service . model . OperationInfo ; import org . apache . cxf . service . model . ServiceInfo ; public class FakeBindingOperationInfo extends BindingOperationInfo { public FakeBindingOperationInfo ( ) { super ( ) ; } public boolean isUnwrapped ( ) { return false ; } } 	0	['2', '0', '0', '2', '3', '1', '1', '1', '2', '2', '7', '0', '0', '0', '1', '0', '0', '2.5', '1', '0.5', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . CamelContext ; import org . apache . camel . processor . RedeliveryPolicy ; import org . apache . camel . util . CamelContextHelper ; @ XmlRootElement ( name = "redeliveryPolicy" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class RedeliveryPolicyType { @ XmlAttribute ( ) private String ref ; @ XmlAttribute private Integer maximumRedeliveries ; @ XmlAttribute private Long initialRedeliveryDelay ; @ XmlAttribute private Double backOffMultiplier ; @ XmlAttribute private Boolean useExponentialBackOff ; @ XmlAttribute private Double collisionAvoidanceFactor ; @ XmlAttribute private Boolean useCollisionAvoidance ; @ XmlAttribute private Long maximumRedeliveryDelay ; @ XmlAttribute private LoggingLevel retriesExhaustedLogLevel ; @ XmlAttribute private LoggingLevel retryAttemptedLogLevel ; public RedeliveryPolicy createRedeliveryPolicy ( CamelContext context , RedeliveryPolicy parentPolicy ) { if ( ref != null ) { return CamelContextHelper . mandatoryLookup ( context , ref , RedeliveryPolicy . class ) ; } RedeliveryPolicy answer = parentPolicy . copy ( ) ; if ( maximumRedeliveries != null ) { answer . setMaximumRedeliveries ( maximumRedeliveries ) ; } if ( initialRedeliveryDelay != null ) { answer . setDelay ( initialRedeliveryDelay ) ; } if ( retriesExhaustedLogLevel != null ) { answer . setRetriesExhaustedLogLevel ( retriesExhaustedLogLevel ) ; } if ( retryAttemptedLogLevel != null ) { answer . setRetryAttemptedLogLevel ( retryAttemptedLogLevel ) ; } if ( backOffMultiplier != null ) { answer . setBackOffMultiplier ( backOffMultiplier ) ; } if ( useExponentialBackOff != null ) { answer . setUseExponentialBackOff ( useExponentialBackOff ) ; } if ( collisionAvoidanceFactor != null ) { answer . setCollisionAvoidanceFactor ( collisionAvoidanceFactor ) ; } if ( useCollisionAvoidance != null ) { answer . setUseCollisionAvoidance ( useCollisionAvoidance ) ; } if ( maximumRedeliveryDelay != null ) { answer . setMaximumRedeliveryDelay ( maximumRedeliveryDelay ) ; } return answer ; } public String toString ( ) { return "RedeliveryPolicy[maximumRedeliveries: " + maximumRedeliveries + "]" ; } public RedeliveryPolicyType backOffMultiplier ( double backOffMultiplier ) { setBackOffMultiplier ( backOffMultiplier ) ; return this ; } public RedeliveryPolicyType collisionAvoidancePercent ( double collisionAvoidancePercent ) { setCollisionAvoidanceFactor ( collisionAvoidancePercent * 0.01d ) ; return this ; } public RedeliveryPolicyType collisionAvoidanceFactor ( double collisionAvoidanceFactor ) { setCollisionAvoidanceFactor ( collisionAvoidanceFactor ) ; return this ; } public RedeliveryPolicyType initialRedeliveryDelay ( long initialRedeliveryDelay ) { setInitialRedeliveryDelay ( initialRedeliveryDelay ) ; return this ; } public RedeliveryPolicyType retriesExhaustedLogLevel ( LoggingLevel retriesExhaustedLogLevel ) { setRetriesExhaustedLogLevel ( retriesExhaustedLogLevel ) ; return this ; } public RedeliveryPolicyType retryAttemptedLogLevel ( LoggingLevel retryAttemptedLogLevel ) { setRetryAttemptedLogLevel ( retryAttemptedLogLevel ) ; return this ; } public RedeliveryPolicyType maximumRedeliveries ( int maximumRedeliveries ) { setMaximumRedeliveries ( maximumRedeliveries ) ; return this ; } public RedeliveryPolicyType useCollisionAvoidance ( ) { setUseCollisionAvoidance ( Boolean . TRUE ) ; return this ; } public RedeliveryPolicyType useExponentialBackOff ( ) { setUseExponentialBackOff ( Boolean . TRUE ) ; return this ; } public RedeliveryPolicyType maximumRedeliveryDelay ( long maximumRedeliveryDelay ) { setMaximumRedeliveryDelay ( maximumRedeliveryDelay ) ; return this ; } public RedeliveryPolicyType ref ( String ref ) { setRef ( ref ) ; return this ; } public Double getBackOffMultiplier ( ) { return backOffMultiplier ; } public void setBackOffMultiplier ( Double backOffMultiplier ) { this . backOffMultiplier = backOffMultiplier ; } public Double getCollisionAvoidanceFactor ( ) { return collisionAvoidanceFactor ; } public void setCollisionAvoidanceFactor ( Double collisionAvoidanceFactor ) { this . collisionAvoidanceFactor = collisionAvoidanceFactor ; } public Long getInitialRedeliveryDelay ( ) { return initialRedeliveryDelay ; } public void setInitialRedeliveryDelay ( Long initialRedeliveryDelay ) { this . initialRedeliveryDelay = initialRedeliveryDelay ; } public Integer getMaximumRedeliveries ( ) { return maximumRedeliveries ; } public void setMaximumRedeliveries ( Integer maximumRedeliveries ) { this . maximumRedeliveries = maximumRedeliveries ; } public Boolean getUseCollisionAvoidance ( ) { return useCollisionAvoidance ; } public void setUseCollisionAvoidance ( Boolean useCollisionAvoidance ) { this . useCollisionAvoidance = useCollisionAvoidance ; } public Boolean getUseExponentialBackOff ( ) { return useExponentialBackOff ; } public void setUseExponentialBackOff ( Boolean useExponentialBackOff ) { this . useExponentialBackOff = useExponentialBackOff ; } public Long getMaximumRedeliveryDelay ( ) { return maximumRedeliveryDelay ; } public void setMaximumRedeliveryDelay ( Long maximumRedeliveryDelay ) { this . maximumRedeliveryDelay = maximumRedeliveryDelay ; } public void setRetriesExhaustedLogLevel ( LoggingLevel retriesExhaustedLogLevel ) { this . retriesExhaustedLogLevel = retriesExhaustedLogLevel ; } public LoggingLevel getRetriesExhaustedLogLevel ( ) { return retriesExhaustedLogLevel ; } public void setRetryAttemptedLogLevel ( LoggingLevel retryAttemptedLogLevel ) { this . retryAttemptedLogLevel = retryAttemptedLogLevel ; } public LoggingLevel getRetryAttemptedLogLevel ( ) { return retryAttemptedLogLevel ; } public String getRef ( ) { return ref ; } public void setRef ( String ref ) { this . ref = ref ; } } 	0	['34', '1', '0', '5', '57', '495', '1', '4', '34', '0.903030303', '277', '1', '2', '0', '0.134803922', '0', '0', '6.852941176', '11', '1.2647', '0']
package org . apache . camel . component . bean ; import org . apache . camel . Processor ; public interface BeanHolder { Object getBean ( ) throws Exception ; Processor getProcessor ( ) ; BeanInfo getBeanInfo ( ) ; } 	0	['3', '1', '0', '9', '3', '3', '7', '2', '3', '2', '3', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . spring . integration ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . impl . DefaultConsumer ; import org . apache . camel . impl . ScheduledPollConsumer ; import org . apache . camel . spring . SpringCamelContext ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . ServiceHelper ; import org . springframework . integration . channel . AbstractPollableChannel ; import org . springframework . integration . channel . BeanFactoryChannelResolver ; import org . springframework . integration . channel . ChannelResolver ; import org . springframework . integration . channel . DirectChannel ; import org . springframework . integration . core . Message ; import org . springframework . integration . core . MessageChannel ; import org . springframework . integration . message . MessageHandler ; public class SpringIntegrationConsumer extends DefaultConsumer < SpringIntegrationExchange > implements MessageHandler { private SpringCamelContext context ; private DirectChannel inputChannel ; private MessageChannel outputChannel ; private String inputChannelName ; private ChannelResolver channelResolver ; private SpringIntegrationEndpoint endpoint ; public SpringIntegrationConsumer ( SpringIntegrationEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; context = ( SpringCamelContext ) endpoint . getCamelContext ( ) ; if ( context != null && endpoint . getMessageChannel ( ) == null ) { channelResolver = new BeanFactoryChannelResolver ( context . getApplicationContext ( ) ) ; inputChannelName = endpoint . getDefaultChannel ( ) ; if ( ObjectHelper . isNullOrBlank ( inputChannelName ) ) { inputChannelName = endpoint . getInputChannel ( ) ; } if ( ! ObjectHelper . isNullOrBlank ( inputChannelName ) ) { inputChannel = ( DirectChannel ) channelResolver . resolveChannelName ( inputChannelName ) ; ObjectHelper . notNull ( inputChannel , "The inputChannel with the name [" + inputChannelName + "]" ) ; } else { throw new RuntimeCamelException ( "Can't find the right inputChannelName, please check your configuration." ) ; } } else { if ( endpoint . getMessageChannel ( ) != null ) { inputChannel = ( DirectChannel ) endpoint . getMessageChannel ( ) ; } else { throw new RuntimeCamelException ( "Can't find the right message channel, please check your configuration." ) ; } } if ( endpoint . isInOut ( ) ) { endpoint . setExchangePattern ( ExchangePattern . InOut ) ; } } protected void doStop ( ) throws Exception { inputChannel . unsubscribe ( this ) ; super . doStop ( ) ; } protected void doStart ( ) throws Exception { super . doStart ( ) ; inputChannel . subscribe ( this ) ; } public void handleMessage ( org . springframework . integration . core . Message < ? > siInMessage ) { SpringIntegrationExchange exchange = getEndpoint ( ) . createExchange ( ) ; exchange . setIn ( new SpringIntegrationMessage ( siInMessage ) ) ; try { getProcessor ( ) . process ( exchange ) ; } catch ( Exception e ) { throw ObjectHelper . wrapRuntimeCamelException ( e ) ; } if ( endpoint . isInOut ( ) ) { Object returnAddress = siInMessage . getHeaders ( ) . getReplyChannel ( ) ; MessageChannel reply = null ; if ( returnAddress != null ) { if ( returnAddress instanceof String ) { reply = ( MessageChannel ) context . getApplicationContext ( ) . getBean ( ( String ) returnAddress ) ; } else if ( returnAddress instanceof MessageChannel ) { reply = ( MessageChannel ) returnAddress ; } } else { if ( outputChannel != null ) { reply = outputChannel ; } else { if ( ObjectHelper . isNullOrBlank ( endpoint . getOutputChannel ( ) ) ) { outputChannel = ( MessageChannel ) channelResolver . resolveChannelName ( endpoint . getOutputChannel ( ) ) ; ObjectHelper . notNull ( inputChannel , "The outputChannel with the name [" + endpoint . getOutputChannel ( ) + "]" ) ; reply = outputChannel ; } else { throw new RuntimeCamelException ( "Can't find the right outputChannelName" ) ; } } } org . springframework . integration . core . Message siOutMessage = SpringIntegrationBinding . storeToSpringIntegrationMessage ( exchange . getOut ( ) ) ; reply . send ( siOutMessage ) ; } } } 	0	['4', '3', '0', '23', '38', '0', '1', '23', '2', '0.666666667', '221', '1', '2', '0.884615385', '0.4375', '1', '1', '52.75', '7', '2.25', '0']
package org . apache . camel . spring ; import java . lang . reflect . Modifier ; import java . util . List ; import java . util . Map ; import java . util . Set ; import org . apache . camel . Routes ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . util . ResolverUtil ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . factory . config . BeanPostProcessor ; import org . springframework . context . ApplicationContext ; public class RouteBuilderFinder { private static final transient Log LOG = LogFactory . getLog ( RouteBuilderFinder . class ) ; private final SpringCamelContext camelContext ; private final String [ ] packages ; private ResolverUtil resolver ; private ApplicationContext applicationContext ; private BeanPostProcessor beanPostProcessor ; public RouteBuilderFinder ( SpringCamelContext camelContext , String [ ] packages , ClassLoader classLoader , BeanPostProcessor postProcessor , ResolverUtil resolverUtil ) { this . camelContext = camelContext ; this . applicationContext = camelContext . getApplicationContext ( ) ; this . packages = packages ; this . beanPostProcessor = postProcessor ; this . resolver = resolverUtil ; Set set = resolver . getClassLoaders ( ) ; set . clear ( ) ; set . add ( classLoader ) ; } public String [ ] getPackages ( ) { return packages ; } public ApplicationContext getApplicationContext ( ) { return applicationContext ; } public void appendBuilders ( List < Routes > list ) throws IllegalAccessException , InstantiationException { resolver . findImplementations ( Routes . class , packages ) ; Set < Class > classes = resolver . getClasses ( ) ; for ( Class aClass : classes ) { if ( shouldIgnoreBean ( aClass ) ) { continue ; } if ( isValidClass ( aClass ) ) { Routes builder = instantiateBuilder ( aClass ) ; if ( beanPostProcessor != null ) { beanPostProcessor . postProcessBeforeInitialization ( builder , builder . toString ( ) ) ; } list . add ( builder ) ; } } } public void destroy ( ) throws Exception { } protected boolean shouldIgnoreBean ( Class type ) { Map beans = applicationContext . getBeansOfType ( type , true , true ) ; if ( beans == null || beans . isEmpty ( ) ) { return false ; } return true ; } protected boolean isValidClass ( Class type ) { if ( ! Modifier . isAbstract ( type . getModifiers ( ) ) && ! type . isInterface ( ) ) { return true ; } return false ; } protected Routes instantiateBuilder ( Class type ) throws IllegalAccessException , InstantiationException { return ( Routes ) camelContext . getInjector ( ) . newInstance ( type ) ; } } 	0	['9', '1', '0', '9', '30', '22', '1', '8', '5', '0.8125', '138', '1', '2', '0', '0.265625', '0', '0', '13.66666667', '3', '1.2222', '0']
package org . apache . camel . bam . model ; import javax . persistence . GeneratedValue ; import javax . persistence . Id ; public class EntitySupport { private Long id ; @ Id @ GeneratedValue public Long getId ( ) { return id ; } public void setId ( Long id ) { this . id = id ; } public String toString ( ) { return getClass ( ) . getName ( ) + "[" + id + "]" ; } } 	0	['4', '1', '3', '3', '11', '0', '3', '0', '4', '0.333333333', '31', '1', '0', '0', '0.625', '0', '0', '6.5', '1', '0.75', '0']
package org . apache . camel . component . http ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; public class HttpExchange extends DefaultExchange { private final HttpEndpoint endpoint ; private HttpServletRequest request ; private HttpServletResponse response ; public HttpExchange ( HttpEndpoint endpoint , ExchangePattern pattern ) { super ( endpoint . getCamelContext ( ) , pattern ) ; this . endpoint = endpoint ; } public HttpExchange ( HttpEndpoint endpoint , HttpServletRequest request , HttpServletResponse response ) { this ( endpoint , getPatternFromRequest ( request ) ) ; this . request = request ; this . response = response ; setIn ( new HttpMessage ( this , request ) ) ; } public HttpServletRequest getRequest ( ) { return request ; } public HttpServletResponse getResponse ( ) { return response ; } public HttpEndpoint getEndpoint ( ) { return endpoint ; } protected static ExchangePattern getPatternFromRequest ( HttpServletRequest request ) { return ExchangePattern . InOut ; } } 	0	['6', '2', '0', '12', '10', '9', '8', '6', '5', '0.733333333', '48', '1', '1', '0.904761905', '0.366666667', '0', '0', '6.5', '1', '0.6667', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Endpoint ; import org . apache . camel . ExchangePattern ; @ XmlRootElement ( name = "inOnly" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class InOnlyType extends SendType < InOnlyType > { public InOnlyType ( ) { } public InOnlyType ( String uri ) { setUri ( uri ) ; } public InOnlyType ( Endpoint endpoint ) { setEndpoint ( endpoint ) ; } @ Override public String toString ( ) { return "InOnly[" + getLabel ( ) + "]" ; } @ Override public String getShortName ( ) { return "inOnly" ; } @ Override public ExchangePattern getPattern ( ) { return ExchangePattern . InOnly ; } } 	0	['6', '4', '0', '3', '13', '15', '0', '3', '6', '2', '37', '0', '0', '0.984293194', '0.444444444', '2', '2', '5.166666667', '1', '0.5', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . processor . idempotent . IdempotentConsumer ; import org . apache . camel . processor . idempotent . MessageIdRepository ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "idempotentConsumer" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class IdempotentConsumerType extends ExpressionNode { @ XmlAttribute private String messageIdRepositoryRef ; @ XmlTransient private MessageIdRepository messageIdRepository ; public IdempotentConsumerType ( ) { } public IdempotentConsumerType ( Expression messageIdExpression , MessageIdRepository messageIdRepository ) { super ( messageIdExpression ) ; this . messageIdRepository = messageIdRepository ; } @ Override public String toString ( ) { return "IdempotentConsumer[" + getExpression ( ) + " -> " + getOutputs ( ) + "]" ; } @ Override public String getShortName ( ) { return "idempotentConsumer" ; } public String getMessageIdRepositoryRef ( ) { return messageIdRepositoryRef ; } public void setMessageIdRepositoryRef ( String messageIdRepositoryRef ) { this . messageIdRepositoryRef = messageIdRepositoryRef ; } public MessageIdRepository getMessageIdRepository ( ) { return messageIdRepository ; } public void setMessageIdRepository ( MessageIdRepository messageIdRepository ) { this . messageIdRepository = messageIdRepository ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { Processor childProcessor = routeContext . createProcessor ( this ) ; MessageIdRepository messageIdRepository = resolveMessageIdRepository ( routeContext ) ; return new IdempotentConsumer ( getExpression ( ) . createExpression ( routeContext ) , messageIdRepository , childProcessor ) ; } public MessageIdRepository resolveMessageIdRepository ( RouteContext routeContext ) { if ( messageIdRepository == null ) { messageIdRepository = routeContext . lookup ( messageIdRepositoryRef , MessageIdRepository . class ) ; } return messageIdRepository ; } } 	0	['10', '4', '0', '10', '22', '27', '3', '8', '10', '0.611111111', '87', '1', '1', '0.958333333', '0.32', '2', '3', '7.5', '2', '0.9', '0']
package org . apache . camel . component . cxf . invoker ; import java . io . InputStream ; import java . util . IdentityHashMap ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; import java . util . logging . Logger ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . message . Exchange ; import org . apache . cxf . message . Message ; public class RawMessageInvokingContext extends AbstractInvokingContext { private static final Logger LOG = LogUtils . getL7dLogger ( RawMessageInvokingContext . class ) ; public RawMessageInvokingContext ( ) { } public void setRequestOutMessageContent ( Message message , Map < Class , Object > contents ) { Set entries = contents . keySet ( ) ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { Object obj = iter . next ( ) ; if ( obj instanceof Class ) { message . setContent ( ( Class < ? > ) obj , contents . get ( ( Class < ? > ) obj ) ) ; } } } public Object getResponseObject ( Exchange exchange , Map < String , Object > responseContext ) { return getResponseObject ( exchange . getInMessage ( ) , responseContext , InputStream . class ) ; } public void setResponseContent ( Message outMessage , Object resultPayload ) { LOG . info ( "Set content: " + resultPayload ) ; outMessage . setContent ( InputStream . class , resultPayload ) ; } public Map < Class , Object > getRequestContent ( Message inMessage ) { IdentityHashMap < Class , Object > contents = new IdentityHashMap < Class , Object > ( ) ; Set set = inMessage . getContentFormats ( ) ; Iterator iter = set . iterator ( ) ; while ( iter . hasNext ( ) ) { Object obj = iter . next ( ) ; if ( obj instanceof Class ) { contents . put ( ( Class < ? > ) obj , inMessage . getContent ( ( Class < ? > ) obj ) ) ; } } return contents ; } @ Override protected Logger getLogger ( ) { return LOG ; } } 	0	['7', '2', '0', '5', '26', '15', '1', '4', '5', '0.666666667', '95', '1', '0', '0.375', '0.433333333', '1', '3', '12.42857143', '2', '1', '0']
package org . apache . camel . util ; import java . util . Map ; public class TimeoutMapEntry implements Comparable , Map . Entry { private Object key ; private Object value ; private long timeout ; private long expireTime ; public TimeoutMapEntry ( Object id , Object handler , long timeout ) { this . key = id ; this . value = handler ; this . timeout = timeout ; } public Object getKey ( ) { return key ; } public long getExpireTime ( ) { return expireTime ; } public void setExpireTime ( long expireTime ) { this . expireTime = expireTime ; } public Object getValue ( ) { return value ; } public Object setValue ( Object value ) { Object oldValue = value ; this . value = value ; return oldValue ; } public long getTimeout ( ) { return timeout ; } public void setTimeout ( long timeout ) { this . timeout = timeout ; } public int compareTo ( Object that ) { if ( this == that ) { return 0 ; } if ( that instanceof TimeoutMapEntry ) { return compareTo ( ( TimeoutMapEntry ) that ) ; } return 1 ; } public int compareTo ( TimeoutMapEntry that ) { long diff = this . expireTime - that . expireTime ; if ( diff > 0 ) { return 1 ; } else if ( diff < 0 ) { return - 1 ; } return this . key . hashCode ( ) - that . key . hashCode ( ) ; } public String toString ( ) { return "Entry for key: " + key ; } } 	0	['11', '1', '0', '1', '17', '25', '1', '0', '11', '0.725', '105', '1', '0', '0', '0.409090909', '0', '0', '8.181818182', '3', '1.2727', '0']
package org . apache . camel . component . cxf ; import javax . xml . ws . WebServiceProvider ; import org . apache . camel . Processor ; import org . apache . camel . component . cxf . feature . MessageDataFormatFeature ; import org . apache . camel . component . cxf . feature . PayLoadDataFormatFeature ; import org . apache . camel . component . cxf . spring . CxfEndpointBean ; import org . apache . camel . component . cxf . util . CxfEndpointUtils ; import org . apache . camel . impl . DefaultConsumer ; import org . apache . cxf . Bus ; import org . apache . cxf . BusFactory ; import org . apache . cxf . bus . spring . SpringBusFactory ; import org . apache . cxf . common . classloader . ClassLoaderUtils ; import org . apache . cxf . configuration . Configurer ; import org . apache . cxf . configuration . spring . ConfigurerImpl ; import org . apache . cxf . endpoint . Server ; import org . apache . cxf . frontend . ServerFactoryBean ; public class CxfConsumer extends DefaultConsumer < CxfExchange > { private CxfEndpoint endpoint ; private Server server ; public CxfConsumer ( CxfEndpoint endpoint , Processor processor ) throws Exception { super ( endpoint , processor ) ; Bus bus = null ; this . endpoint = endpoint ; boolean isWebServiceProvider = false ; if ( endpoint . getApplicationContext ( ) != null ) { if ( endpoint . getCxfEndpointBean ( ) != null ) { bus = endpoint . getCxfEndpointBean ( ) . getBus ( ) ; } else { SpringBusFactory busFactory = new SpringBusFactory ( endpoint . getApplicationContext ( ) ) ; bus = busFactory . createBus ( ) ; } if ( CxfEndpointUtils . getSetDefaultBus ( endpoint ) ) { BusFactory . setDefaultBus ( bus ) ; } } else { bus = BusFactory . getDefaultBus ( ) ; } Class serviceClass = CxfEndpointUtils . getServiceClass ( endpoint ) ; ServerFactoryBean svrBean = CxfEndpointUtils . getServerFactoryBean ( serviceClass ) ; isWebServiceProvider = CxfEndpointUtils . hasAnnotation ( serviceClass , WebServiceProvider . class ) ; if ( endpoint . isSpringContextEndpoint ( ) ) { endpoint . configure ( svrBean ) ; } else { svrBean . setAddress ( endpoint . getAddress ( ) ) ; if ( endpoint . getWsdlURL ( ) != null ) { svrBean . setWsdlURL ( endpoint . getWsdlURL ( ) ) ; } } svrBean . setServiceClass ( serviceClass ) ; if ( CxfEndpointUtils . getServiceName ( endpoint ) != null ) { svrBean . setServiceName ( CxfEndpointUtils . getServiceName ( endpoint ) ) ; } if ( CxfEndpointUtils . getServiceName ( endpoint ) != null ) { svrBean . setEndpointName ( CxfEndpointUtils . getPortName ( endpoint ) ) ; } DataFormat dataFormat = CxfEndpointUtils . getDataFormat ( endpoint ) ; svrBean . setInvoker ( new CamelInvoker ( this ) ) ; if ( ! dataFormat . equals ( DataFormat . POJO ) && ! isWebServiceProvider ) { if ( dataFormat . equals ( DataFormat . PAYLOAD ) ) { svrBean . getFeatures ( ) . add ( new PayLoadDataFormatFeature ( ) ) ; } else if ( dataFormat . equals ( DataFormat . MESSAGE ) ) { svrBean . getFeatures ( ) . add ( new MessageDataFormatFeature ( ) ) ; } } svrBean . setBus ( bus ) ; svrBean . setStart ( false ) ; server = svrBean . create ( ) ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; server . start ( ) ; } @ Override protected void doStop ( ) throws Exception { server . stop ( ) ; super . doStop ( ) ; } public CxfEndpoint getEndpoint ( ) { return endpoint ; } public Server getServer ( ) { return server ; } } 	0	['6', '3', '0', '17', '43', '1', '2', '17', '4', '0.5', '162', '1', '1', '0.821428571', '0.444444444', '1', '1', '25.66666667', '1', '0.8333', '0']
package org . apache . camel . component . atom ; import java . util . Date ; import org . apache . abdera . model . Document ; import org . apache . abdera . model . Entry ; import org . apache . abdera . model . Feed ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class UpdatedDateFilter implements EntryFilter { private static final transient Log LOG = LogFactory . getLog ( UpdatedDateFilter . class ) ; private Date lastUpdate ; public UpdatedDateFilter ( Date lastUpdate ) { this . lastUpdate = lastUpdate ; } public boolean isValidEntry ( AtomEndpoint endpoint , Document < Feed > feed , Entry entry ) { Date updated = entry . getUpdated ( ) ; if ( updated == null ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "No updated time for entry so assuming its valid: entry=[" + entry + "]" ) ; } return true ; } if ( lastUpdate != null ) { if ( lastUpdate . after ( updated ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Entry is older than lastupdate=[" + lastUpdate + "], no valid entry=[" + entry + "]" ) ; } return false ; } } lastUpdate = updated ; return true ; } } 	0	['3', '1', '0', '7', '13', '0', '1', '6', '2', '0.5', '72', '1', '0', '0', '0.6', '0', '0', '22.33333333', '6', '2', '0']
package org . apache . camel . builder . script ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import org . apache . camel . language . LanguageAnnotation ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . PARAMETER } ) @ LanguageAnnotation ( language = "python" ) public @ interface Python { String value ( ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . processor . validation ; import org . apache . camel . Exchange ; import org . apache . camel . ValidationException ; public class NoXmlBodyValidationException extends ValidationException { public NoXmlBodyValidationException ( Exchange exchange ) { super ( exchange , "No XML body could be found on the input message" + exchange ) ; } } 	0	['1', '6', '0', '3', '6', '0', '1', '2', '1', '2', '13', '0', '0', '1', '1', '0', '0', '12', '0', '0', '0']
package org . apache . camel . util ; import java . util . LinkedHashMap ; import java . util . Map ; public class LRUCache < K , V > extends LinkedHashMap < K , V > { private static final long serialVersionUID = - 342098639681884413L ; private int maxCacheSize = 10000 ; public LRUCache ( int maximumCacheSize ) { this ( maximumCacheSize , maximumCacheSize , 0.75f , true ) ; } public LRUCache ( int initialCapacity , int maximumCacheSize , float loadFactor , boolean accessOrder ) { super ( initialCapacity , loadFactor , accessOrder ) ; this . maxCacheSize = maximumCacheSize ; } public int getMaxCacheSize ( ) { return maxCacheSize ; } protected boolean removeEldestEntry ( Map . Entry entry ) { return size ( ) > maxCacheSize ; } } 	0	['4', '4', '0', '3', '6', '0', '3', '0', '3', '0.666666667', '37', '1', '0', '0.972222222', '0.45', '0', '0', '7.75', '2', '0.75', '0']
package org . apache . camel . component . stream ; import java . nio . charset . Charset ; import org . apache . camel . Component ; import org . apache . camel . Consumer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class StreamEndpoint extends DefaultEndpoint < Exchange > { private static final transient Log LOG = LogFactory . getLog ( StreamEndpoint . class ) ; private String uri ; private String file ; private String url ; private long delay ; private String encoding ; public StreamEndpoint ( String endpointUri , Component component ) throws Exception { super ( endpointUri , component ) ; this . uri = endpointUri ; } public StreamEndpoint ( String endpointUri ) { super ( endpointUri ) ; this . uri = endpointUri ; } public Consumer < Exchange > createConsumer ( Processor processor ) throws Exception { return new StreamConsumer ( this , processor , uri ) ; } public Producer < Exchange > createProducer ( ) throws Exception { return new StreamProducer ( this , uri ) ; } public boolean isSingleton ( ) { return true ; } public String getFile ( ) { return file ; } public void setFile ( String file ) { this . file = file ; } public String getUrl ( ) { return url ; } public void setUrl ( String url ) { this . url = url ; } public long getDelay ( ) { return delay ; } public void setDelay ( long delay ) { this . delay = delay ; } public String getEncoding ( ) { return encoding ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } Charset getCharset ( ) { if ( encoding == null ) { encoding = Charset . defaultCharset ( ) . name ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "No encoding parameter using default charset: " + encoding ) ; } } if ( ! Charset . isSupported ( encoding ) ) { throw new IllegalArgumentException ( "The encoding: " + encoding + " is not supported" ) ; } return Charset . forName ( encoding ) ; } } 	0	['15', '2', '0', '10', '30', '79', '3', '9', '13', '0.892857143', '129', '1', '0', '0.666666667', '0.314285714', '0', '0', '7.2', '4', '1', '0']
package org . apache . camel . processor . resequencer ; import java . util . Comparator ; public interface SequenceElementComparator < E > extends Comparator < E > { boolean predecessor ( E o1 , E o2 ) ; boolean successor ( E o1 , E o2 ) ; } 	0	['2', '1', '0', '6', '2', '1', '6', '0', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . impl ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Exchange ; import org . apache . camel . PollingConsumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; public class ProcessorEndpoint extends DefaultPollingEndpoint < Exchange > { private Processor processor ; protected ProcessorEndpoint ( ) { } protected ProcessorEndpoint ( String endpointUri ) { super ( endpointUri ) ; } public ProcessorEndpoint ( String endpointUri , CamelContext context , Processor processor ) { super ( endpointUri , context ) ; this . processor = processor ; } public ProcessorEndpoint ( String endpointUri , Component component , Processor processor ) { super ( endpointUri , component ) ; this . processor = processor ; } public ProcessorEndpoint ( String endpointUri , Processor processor ) { super ( endpointUri ) ; this . processor = processor ; } protected ProcessorEndpoint ( String endpointUri , Component component ) { super ( endpointUri , component ) ; } public Producer < Exchange > createProducer ( ) throws Exception { return new DefaultProducer < Exchange > ( this ) { public void process ( Exchange exchange ) throws Exception { onExchange ( exchange ) ; } } ; } @ Override public PollingConsumer < Exchange > createPollingConsumer ( ) throws Exception { return new ProcessorPollingConsumer ( this , getProcessor ( ) ) ; } public Processor getProcessor ( ) throws Exception { if ( processor == null ) { processor = createProcessor ( ) ; } return processor ; } protected Processor createProcessor ( ) throws Exception { return new Processor ( ) { public void process ( Exchange exchange ) throws Exception { onExchange ( exchange ) ; } } ; } protected void onExchange ( Exchange exchange ) throws Exception { getProcessor ( ) . process ( exchange ) ; } public boolean isSingleton ( ) { return true ; } } 	0	['12', '4', '2', '21', '20', '54', '12', '11', '7', '0.545454545', '83', '1', '1', '0.828571429', '0.333333333', '0', '0', '5.833333333', '1', '0.5', '0']
package org . apache . camel . processor . resequencer ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; public interface ExpressionResultComparator < E extends Exchange > extends SequenceElementComparator < E > { void setExpressions ( List < Expression > expressions ) ; } 	0	['1', '1', '0', '4', '1', '0', '3', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . spring . integration ; import org . apache . camel . CamelContext ; import org . apache . camel . Consumer ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . impl . ScheduledPollEndpoint ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . integration . core . MessageChannel ; public class SpringIntegrationEndpoint extends ScheduledPollEndpoint < SpringIntegrationExchange > { private static final Log LOG = LogFactory . getLog ( SpringIntegrationEndpoint . class ) ; private String inputChannel ; private String outputChannel ; private String defaultChannel ; private MessageChannel messageChannel ; private boolean inOut ; public SpringIntegrationEndpoint ( String uri , String channel , SpringIntegrationComponent component ) { super ( uri , component ) ; defaultChannel = channel ; } public SpringIntegrationEndpoint ( String uri , MessageChannel channel , CamelContext context ) { super ( uri , context ) ; messageChannel = channel ; } public SpringIntegrationEndpoint ( String endpointUri , MessageChannel messageChannel ) { super ( endpointUri ) ; this . messageChannel = messageChannel ; } public Producer < SpringIntegrationExchange > createProducer ( ) throws Exception { return new SpringIntegrationProducer ( this ) ; } public Consumer < SpringIntegrationExchange > createConsumer ( Processor processor ) throws Exception { return new SpringIntegrationConsumer ( this , processor ) ; } public SpringIntegrationExchange createExchange ( ) { return createExchange ( getExchangePattern ( ) ) ; } public SpringIntegrationExchange createExchange ( ExchangePattern pattern ) { return new SpringIntegrationExchange ( getCamelContext ( ) , pattern ) ; } public void setInputChannel ( String input ) { inputChannel = input ; } public String getInputChannel ( ) { return inputChannel ; } public void setOutputChannel ( String output ) { outputChannel = output ; } public String getOutputChannel ( ) { return outputChannel ; } public String getDefaultChannel ( ) { return defaultChannel ; } public MessageChannel getMessageChannel ( ) { return messageChannel ; } public boolean isSingleton ( ) { return false ; } public void setInOut ( boolean inOut ) { this . inOut = inOut ; } public boolean isInOut ( ) { return this . inOut ; } } 	0	['19', '3', '0', '16', '26', '157', '4', '15', '18', '0.944444444', '111', '1', '0', '0.651162791', '0.215277778', '1', '1', '4.526315789', '1', '0.7895', '0']
package org . apache . camel . builder . script ; import java . io . File ; import java . io . IOException ; import java . io . InputStreamReader ; import java . net . URL ; import javax . script . Compilable ; import javax . script . CompiledScript ; import javax . script . ScriptContext ; import javax . script . ScriptEngine ; import javax . script . ScriptEngineManager ; import javax . script . ScriptException ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . converter . ObjectConverter ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . core . io . FileSystemResource ; import org . springframework . core . io . Resource ; import org . springframework . core . io . UrlResource ; public class ScriptBuilder < E extends Exchange > implements Expression < E > , Predicate < E > , Processor { private static final transient Log LOG = LogFactory . getLog ( ScriptBuilder . class ) ; private String scriptEngineName ; private Resource scriptResource ; private String scriptText ; private ScriptEngine engine ; private CompiledScript compiledScript ; public ScriptBuilder ( String scriptEngineName ) { this . scriptEngineName = scriptEngineName ; } public ScriptBuilder ( String scriptEngineName , String scriptText ) { this ( scriptEngineName ) ; this . scriptText = scriptText ; } public ScriptBuilder ( String scriptEngineName , Resource scriptResource ) { this ( scriptEngineName ) ; this . scriptResource = scriptResource ; } @ Override public String toString ( ) { return getScriptDescription ( ) ; } public Object evaluate ( E exchange ) { return evaluateScript ( exchange ) ; } public boolean matches ( E exchange ) { Object scriptValue = evaluateScript ( exchange ) ; return matches ( exchange , scriptValue ) ; } public void assertMatches ( String text , E exchange ) throws AssertionError { Object scriptValue = evaluateScript ( exchange ) ; if ( ! matches ( exchange , scriptValue ) ) { throw new AssertionError ( this + " failed on " + exchange + " as script returned <" + scriptValue + ">" ) ; } } public void process ( Exchange exchange ) { evaluateScript ( exchange ) ; } public ScriptBuilder attribute ( String name , Object value ) { getScriptContext ( ) . setAttribute ( name , value , ScriptContext . ENGINE_SCOPE ) ; return this ; } public static ScriptBuilder script ( String language , String scriptText ) { return new ScriptBuilder ( language , scriptText ) ; } public static ScriptBuilder script ( String language , Resource scriptResource ) { return new ScriptBuilder ( language , scriptResource ) ; } public static ScriptBuilder script ( String language , File scriptFile ) { return new ScriptBuilder ( language , new FileSystemResource ( scriptFile ) ) ; } public static ScriptBuilder script ( String language , URL scriptURL ) { return new ScriptBuilder ( language , new UrlResource ( scriptURL ) ) ; } public static ScriptBuilder beanShell ( String scriptText ) { return new ScriptBuilder ( "beanshell" , scriptText ) ; } public static ScriptBuilder beanShell ( Resource scriptResource ) { return new ScriptBuilder ( "beanshell" , scriptResource ) ; } public static ScriptBuilder beanShell ( File scriptFile ) { return new ScriptBuilder ( "beanshell" , new FileSystemResource ( scriptFile ) ) ; } public static ScriptBuilder beanShell ( URL scriptURL ) { return new ScriptBuilder ( "beanshell" , new UrlResource ( scriptURL ) ) ; } public static ScriptBuilder groovy ( String scriptText ) { return new ScriptBuilder ( "groovy" , scriptText ) ; } public static ScriptBuilder groovy ( Resource scriptResource ) { return new ScriptBuilder ( "groovy" , scriptResource ) ; } public static ScriptBuilder groovy ( File scriptFile ) { return new ScriptBuilder ( "groovy" , new FileSystemResource ( scriptFile ) ) ; } public static ScriptBuilder groovy ( URL scriptURL ) { return new ScriptBuilder ( "groovy" , new UrlResource ( scriptURL ) ) ; } public static ScriptBuilder javaScript ( String scriptText ) { return new ScriptBuilder ( "js" , scriptText ) ; } public static ScriptBuilder javaScript ( Resource scriptResource ) { return new ScriptBuilder ( "js" , scriptResource ) ; } public static ScriptBuilder javaScript ( File scriptFile ) { return new ScriptBuilder ( "js" , new FileSystemResource ( scriptFile ) ) ; } public static ScriptBuilder javaScript ( URL scriptURL ) { return new ScriptBuilder ( "js" , new UrlResource ( scriptURL ) ) ; } public static ScriptBuilder php ( String scriptText ) { return new ScriptBuilder ( "php" , scriptText ) ; } public static ScriptBuilder php ( Resource scriptResource ) { return new ScriptBuilder ( "php" , scriptResource ) ; } public static ScriptBuilder php ( File scriptFile ) { return new ScriptBuilder ( "php" , new FileSystemResource ( scriptFile ) ) ; } public static ScriptBuilder php ( URL scriptURL ) { return new ScriptBuilder ( "php" , new UrlResource ( scriptURL ) ) ; } public static ScriptBuilder python ( String scriptText ) { return new ScriptBuilder ( "python" , scriptText ) ; } public static ScriptBuilder python ( Resource scriptResource ) { return new ScriptBuilder ( "python" , scriptResource ) ; } public static ScriptBuilder python ( File scriptFile ) { return new ScriptBuilder ( "python" , new FileSystemResource ( scriptFile ) ) ; } public static ScriptBuilder python ( URL scriptURL ) { return new ScriptBuilder ( "python" , new UrlResource ( scriptURL ) ) ; } public static ScriptBuilder ruby ( String scriptText ) { return new ScriptBuilder ( "jruby" , scriptText ) ; } public static ScriptBuilder ruby ( Resource scriptResource ) { return new ScriptBuilder ( "jruby" , scriptResource ) ; } public static ScriptBuilder ruby ( File scriptFile ) { return new ScriptBuilder ( "jruby" , new FileSystemResource ( scriptFile ) ) ; } public static ScriptBuilder ruby ( URL scriptURL ) { return new ScriptBuilder ( "jruby" , new UrlResource ( scriptURL ) ) ; } public ScriptEngine getEngine ( ) { checkInitialised ( ) ; if ( engine == null ) { throw new IllegalArgumentException ( "No script engine could be created for: " + getScriptEngineName ( ) ) ; } return engine ; } public CompiledScript getCompiledScript ( ) { return compiledScript ; } public String getScriptText ( ) { return scriptText ; } public void setScriptText ( String scriptText ) { this . scriptText = scriptText ; } public String getScriptEngineName ( ) { return scriptEngineName ; } public String getScriptDescription ( ) { if ( scriptText != null ) { return scriptEngineName + ": " + scriptText ; } else if ( scriptResource != null ) { return scriptEngineName + ": " + scriptResource . getDescription ( ) ; } else { return scriptEngineName + ": null script" ; } } public ScriptContext getScriptContext ( ) { return getEngine ( ) . getContext ( ) ; } public void setScriptContext ( ScriptContext scriptContext ) { getEngine ( ) . setContext ( scriptContext ) ; } public Resource getScriptResource ( ) { return scriptResource ; } public void setScriptResource ( Resource scriptResource ) { this . scriptResource = scriptResource ; } protected void checkInitialised ( ) { if ( scriptText == null && scriptResource == null ) { throw new IllegalArgumentException ( "Neither scriptText or scriptResource are specified" ) ; } if ( engine == null ) { engine = createScriptEngine ( ) ; } if ( compiledScript == null ) { if ( engine instanceof Compilable ) { compileScript ( ( Compilable ) engine ) ; } } } protected boolean matches ( E exchange , Object scriptValue ) { return ObjectConverter . toBool ( scriptValue ) ; } protected ScriptEngine createScriptEngine ( ) { ScriptEngineManager manager = new ScriptEngineManager ( ) ; try { engine = manager . getEngineByName ( scriptEngineName ) ; } catch ( NoClassDefFoundError ex ) { LOG . error ( "Can't load the scriptEngine for " + scriptEngineName + ", the exception is " + ex + ", please check the scriptEngine needs jars." ) ; } if ( engine == null ) { throw new IllegalArgumentException ( "No script engine could be created for: " + getScriptEngineName ( ) ) ; } if ( isPython ( ) ) { ScriptContext context = engine . getContext ( ) ; context . setAttribute ( "com.sun.script.jython.comp.mode" , "eval" , ScriptContext . ENGINE_SCOPE ) ; } return engine ; } protected void compileScript ( Compilable compilable ) { try { if ( scriptText != null ) { compiledScript = compilable . compile ( scriptText ) ; } else if ( scriptResource != null ) { compiledScript = compilable . compile ( createScriptReader ( ) ) ; } } catch ( ScriptException e ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Script compile failed: " + e , e ) ; } throw createScriptCompileException ( e ) ; } catch ( IOException e ) { throw createScriptCompileException ( e ) ; } } protected synchronized Object evaluateScript ( Exchange exchange ) { try { getScriptContext ( ) ; populateBindings ( getEngine ( ) , exchange ) ; Object result = runScript ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "The script evaluation result is: " + result ) ; } return result ; } catch ( ScriptException e ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Script evaluation failed: " + e , e ) ; } throw createScriptEvaluationException ( e . getCause ( ) ) ; } catch ( IOException e ) { throw createScriptEvaluationException ( e ) ; } } protected Object runScript ( ) throws ScriptException , IOException { checkInitialised ( ) ; Object result = null ; if ( compiledScript != null ) { result = compiledScript . eval ( ) ; } else { if ( scriptText != null ) { result = getEngine ( ) . eval ( scriptText ) ; } else { result = getEngine ( ) . eval ( createScriptReader ( ) ) ; } } return result ; } protected void populateBindings ( ScriptEngine engine , Exchange exchange ) { ScriptContext context = engine . getContext ( ) ; int scope = ScriptContext . ENGINE_SCOPE ; context . setAttribute ( "context" , exchange . getContext ( ) , scope ) ; context . setAttribute ( "exchange" , exchange , scope ) ; context . setAttribute ( "request" , exchange . getIn ( ) , scope ) ; context . setAttribute ( "response" , exchange . getOut ( false ) , scope ) ; } protected InputStreamReader createScriptReader ( ) throws IOException { return new InputStreamReader ( scriptResource . getInputStream ( ) ) ; } protected ScriptEvaluationException createScriptCompileException ( Exception e ) { return new ScriptEvaluationException ( "Failed to compile: " + getScriptDescription ( ) + ". Cause: " + e , e ) ; } protected ScriptEvaluationException createScriptEvaluationException ( Throwable e ) { if ( e . getClass ( ) . getName ( ) . equals ( "org.jruby.exceptions.RaiseException" ) ) { try { Object ex = e . getClass ( ) . getMethod ( "getException" ) . invoke ( e ) ; return new ScriptEvaluationException ( "Failed to evaluate: " + getScriptDescription ( ) + ".  Error: " + ex + ". Cause: " + e , e ) ; } catch ( Exception e1 ) { } } return new ScriptEvaluationException ( "Failed to evaluate: " + getScriptDescription ( ) + ". Cause: " + e , e ) ; } protected boolean isPython ( ) { return "python" . equals ( scriptEngineName ) || "jython" . equals ( scriptEngineName ) ; } } 	0	['61', '1', '0', '14', '99', '1708', '1', '13', '49', '0.661111111', '811', '1', '0', '0', '0.122222222', '0', '0', '12.19672131', '6', '1.2131', '0']
package org . apache . camel . impl . converter ; public interface TypeConverterLoader { void load ( TypeConverterRegistry registry ) throws Exception ; } 	0	['1', '1', '0', '4', '1', '0', '3', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Processor ; import org . apache . camel . component . bean . BeanProcessor ; import org . apache . camel . component . bean . RegistryBean ; import org . apache . camel . spi . RouteContext ; import org . apache . camel . util . CamelContextHelper ; import org . apache . camel . util . ObjectHelper ; @ XmlRootElement ( name = "bean" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class BeanRef extends OutputType < ProcessorType > { @ XmlAttribute ( required = false ) private String ref ; @ XmlAttribute ( required = false ) private String method ; @ XmlAttribute ( required = false ) private Class beanType ; @ XmlTransient private Object bean ; public BeanRef ( ) { } public BeanRef ( String ref ) { this . ref = ref ; } public BeanRef ( String ref , String method ) { this . ref = ref ; this . method = method ; } @ Override public String toString ( ) { return "Bean[" + getLabel ( ) + "]" ; } @ Override public String getShortName ( ) { return "bean" ; } public String getRef ( ) { return ref ; } public void setRef ( String ref ) { this . ref = ref ; } public String getMethod ( ) { return method ; } public void setMethod ( String method ) { this . method = method ; } public void setBean ( Object bean ) { this . bean = bean ; } public Class getBeanType ( ) { return beanType ; } public void setBeanType ( Class beanType ) { this . beanType = beanType ; } @ Override public Processor createProcessor ( RouteContext routeContext ) { BeanProcessor answer ; if ( ref != null ) { answer = new BeanProcessor ( new RegistryBean ( routeContext . getCamelContext ( ) , ref ) ) ; } else { if ( bean == null ) { ObjectHelper . notNull ( beanType , "bean, ref or beanType" ) ; bean = CamelContextHelper . newInstance ( routeContext . getCamelContext ( ) , beanType ) ; } answer = new BeanProcessor ( bean , routeContext . getCamelContext ( ) ) ; } if ( method != null ) { answer . setMethod ( method ) ; } return answer ; } @ Override public String getLabel ( ) { if ( ref != null ) { String methodText = "" ; if ( method != null ) { methodText = " method: " + method ; } return "ref: " + ref + methodText ; } else if ( bean != null ) { return bean . toString ( ) ; } else if ( beanType != null ) { return beanType . getName ( ) ; } else { return "" ; } } } 	0	['14', '4', '0', '11', '27', '33', '2', '9', '14', '0.653846154', '167', '1', '0', '0.942105263', '0.3', '1', '1', '10.64285714', '5', '1.2857', '0']
package org . apache . camel . component . cxf . interceptors ; import java . util . ResourceBundle ; import java . util . logging . Logger ; import org . apache . cxf . binding . soap . SoapMessage ; import org . apache . cxf . binding . soap . interceptor . CheckFaultInterceptor ; import org . apache . cxf . binding . soap . interceptor . SoapActionInInterceptor ; import org . apache . cxf . common . i18n . BundleUtils ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . interceptor . Fault ; import org . apache . cxf . message . Message ; import org . apache . cxf . message . XMLMessage ; import org . apache . cxf . phase . AbstractPhaseInterceptor ; import org . apache . cxf . phase . Phase ; public class DOMInInterceptor extends AbstractPhaseInterceptor < Message > { private static final Logger LOG = LogUtils . getL7dLogger ( DOMOutInterceptor . class ) ; private final XMLMessageInInterceptor xmlInterceptor = new XMLMessageInInterceptor ( ) ; private final SoapMessageInInterceptor soapInterceptor = new SoapMessageInInterceptor ( ) ; public DOMInInterceptor ( ) { super ( Phase . POST_PROTOCOL ) ; this . addAfter ( CheckFaultInterceptor . class . getName ( ) ) ; } public boolean isRequestor ( Message message ) { return Boolean . TRUE . equals ( message . get ( Message . REQUESTOR_ROLE ) ) ; } public void handleMessage ( Message message ) throws Fault { if ( message instanceof XMLMessage ) { xmlInterceptor . handleMessage ( ( XMLMessage ) message ) ; } else if ( message instanceof SoapMessage ) { soapInterceptor . handleMessage ( ( SoapMessage ) message ) ; } else { throw new Fault ( new org . apache . cxf . common . i18n . Message ( "NOT_SUPPORTED_MESSAGE" , LOG , message . getClass ( ) . getName ( ) ) ) ; } } } 	0	['4', '0', '0', '10', '17', '2', '1', '9', '3', '0.666666667', '71', '1', '2', '0', '0.833333333', '0', '0', '16', '1', '0.5', '0']
package org . apache . camel . builder . script ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import org . apache . camel . language . LanguageAnnotation ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . PARAMETER } ) @ LanguageAnnotation ( language = "js" ) public @ interface JavaScript { String value ( ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . converter . xmlbeans ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . Reader ; import java . nio . ByteBuffer ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . Source ; import javax . xml . transform . TransformerException ; import org . w3c . dom . Document ; import org . w3c . dom . Node ; import org . xml . sax . SAXException ; import org . apache . camel . Converter ; import org . apache . camel . Exchange ; import org . apache . camel . converter . IOConverter ; import org . apache . camel . converter . NIOConverter ; import org . apache . camel . converter . jaxp . XmlConverter ; import org . apache . xmlbeans . XmlException ; import org . apache . xmlbeans . XmlObject ; import org . apache . xmlbeans . impl . piccolo . xml . XMLStreamReader ; @ Converter public class XmlBeansConverter { private XmlConverter xmlConverter = new XmlConverter ( ) ; @ Converter public static XmlObject toXmlObject ( File value ) throws IOException , XmlException { return XmlObject . Factory . parse ( value ) ; } @ Converter public static XmlObject toXmlObject ( Reader value ) throws IOException , XmlException { return XmlObject . Factory . parse ( value ) ; } @ Converter public static XmlObject toXmlObject ( Node value ) throws IOException , XmlException { return XmlObject . Factory . parse ( value ) ; } @ Converter public static XmlObject toXmlObject ( InputStream value ) throws IOException , XmlException { return XmlObject . Factory . parse ( value ) ; } @ Converter public static XmlObject toXmlObject ( String value , Exchange exchange ) throws IOException , XmlException { return toXmlObject ( IOConverter . toInputStream ( value , exchange ) ) ; } @ Converter public static XmlObject toXmlObject ( byte [ ] value ) throws IOException , XmlException { return toXmlObject ( IOConverter . toInputStream ( value ) ) ; } @ Converter public static XmlObject toXmlObject ( ByteBuffer value ) throws IOException , XmlException { return toXmlObject ( NIOConverter . toInputStream ( value ) ) ; } @ Converter public static XmlObject toXmlObject ( XMLStreamReader value ) throws IOException , XmlException { return XmlObject . Factory . parse ( value ) ; } @ Converter public XmlObject toXmlObject ( Source value ) throws IOException , XmlException , TransformerException , ParserConfigurationException , SAXException { Document document = getXmlConverter ( ) . toDOMDocument ( value ) ; return toXmlObject ( document ) ; } public XmlConverter getXmlConverter ( ) { return xmlConverter ; } public void setXmlConverter ( XmlConverter xmlConverter ) { this . xmlConverter = xmlConverter ; } } 	0	['12', '1', '0', '8', '22', '60', '0', '8', '12', '0.727272727', '64', '1', '1', '0', '0.104166667', '0', '0', '4.25', '1', '0.9167', '0']
package org . apache . camel . component . quartz ; import org . quartz . Job ; import org . quartz . JobExecutionContext ; import org . quartz . JobExecutionException ; public class CamelJob implements Job { public void execute ( JobExecutionContext context ) throws JobExecutionException { QuartzEndpoint component = ( QuartzEndpoint ) context . getJobDetail ( ) . getJobDataMap ( ) . get ( QuartzEndpoint . ENDPOINT_KEY ) ; if ( component == null ) { throw new JobExecutionException ( "No quartz endpoint available for key: " + QuartzEndpoint . ENDPOINT_KEY + ". Bad job data map" ) ; } component . onJobExecute ( context ) ; } } 	0	['2', '1', '0', '6', '8', '1', '0', '6', '2', '2', '23', '0', '0', '0', '0.75', '0', '0', '10.5', '1', '0.5', '0']
package org . apache . camel . component . jms . requestor ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; import javax . jms . ExceptionListener ; import javax . jms . Message ; import javax . jms . Session ; import org . apache . camel . component . jms . JmsConfiguration ; import org . apache . camel . component . jms . JmsProducer ; import org . apache . camel . component . jms . requestor . DeferredRequestReplyMap . DeferredMessageSentCallback ; import org . apache . camel . component . jms . requestor . PersistentReplyToRequestor . MessageSelectorComposer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . core . task . TaskExecutor ; import org . springframework . jms . listener . AbstractMessageListenerContainer ; import org . springframework . jms . listener . DefaultMessageListenerContainer ; import org . springframework . transaction . PlatformTransactionManager ; public class PersistentReplyToFutureHandler extends FutureHandler { private static final transient Log LOG = LogFactory . getLog ( PersistentReplyToFutureHandler . class ) ; protected PersistentReplyToRequestor requestor ; protected DeferredMessageSentCallback callback ; protected String correlationID ; public PersistentReplyToFutureHandler ( PersistentReplyToRequestor requestor , String correlationID ) { super ( ) ; this . requestor = requestor ; this . correlationID = correlationID ; } public PersistentReplyToFutureHandler ( PersistentReplyToRequestor requestor , DeferredMessageSentCallback callback ) { super ( ) ; this . requestor = requestor ; this . callback = callback ; } @ Override public Message get ( ) throws InterruptedException , ExecutionException { Message result = null ; try { updateSelector ( ) ; result = super . get ( ) ; } finally { revertSelector ( ) ; } return result ; } @ Override public Message get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { Message result = null ; try { updateSelector ( ) ; result = super . get ( timeout , unit ) ; } finally { revertSelector ( ) ; } return result ; } protected void updateSelector ( ) throws ExecutionException { try { MessageSelectorComposer composer = ( MessageSelectorComposer ) requestor . getListenerContainer ( ) ; composer . addCorrelationID ( ( correlationID != null ) ? correlationID : callback . getMessage ( ) . getJMSMessageID ( ) ) ; } catch ( Exception e ) { throw new ExecutionException ( e ) ; } } protected void revertSelector ( ) throws ExecutionException { try { MessageSelectorComposer composer = ( MessageSelectorComposer ) requestor . getListenerContainer ( ) ; composer . removeCorrelationID ( ( correlationID != null ) ? correlationID : callback . getMessage ( ) . getJMSMessageID ( ) ) ; } catch ( Exception e ) { throw new ExecutionException ( e ) ; } } } 	0	['9', '3', '0', '7', '17', '24', '1', '7', '6', '0.40625', '131', '1', '2', '0.684210526', '0.333333333', '0', '0', '13.11111111', '1', '0.6667', '0']
package org . apache . camel . component . atom ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; public class AtomComponent extends DefaultComponent { protected Endpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { return new AtomEndpoint ( uri , this , remaining ) ; } } 	0	['2', '3', '0', '3', '4', '1', '1', '3', '1', '2', '12', '0', '0', '0.972222222', '0.666666667', '1', '1', '5', '1', '0.5', '0']
package org . apache . camel . converter . jaxb ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "longHeader" ) @ XmlAccessorType ( value = XmlAccessType . FIELD ) public class LongHeader extends HeaderType { @ XmlAttribute ( name = "value" ) private Long number ; public LongHeader ( ) { } public LongHeader ( String name , Long number ) { super ( name ) ; this . number = number ; } public Long getNumber ( ) { return number ; } public void setNumber ( Long number ) { this . number = number ; } public Object getValue ( ) { return getNumber ( ) ; } public void setValue ( Object value ) { if ( value instanceof Number ) { Number n = ( Number ) value ; setNumber ( n . longValue ( ) ) ; } else { throw new IllegalArgumentException ( "Value must be a Long" ) ; } } } 	0	['6', '2', '0', '2', '11', '9', '1', '1', '6', '0.2', '45', '1', '0', '0.5', '0.416666667', '0', '0', '6.333333333', '2', '0.8333', '0']
package org . apache . camel . component . http ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . impl . DefaultMessage ; public class HttpMessage extends DefaultMessage { private HttpServletRequest request ; public HttpMessage ( HttpExchange exchange , HttpServletRequest request ) { setExchange ( exchange ) ; this . request = request ; getExchange ( ) . getEndpoint ( ) . getBinding ( ) . readRequest ( request , this ) ; } @ Override public HttpExchange getExchange ( ) { return ( HttpExchange ) super . getExchange ( ) ; } public HttpServletRequest getRequest ( ) { return request ; } @ Override protected Object createBody ( ) { try { return getExchange ( ) . getEndpoint ( ) . getBinding ( ) . parseBody ( this ) ; } catch ( IOException e ) { throw new RuntimeCamelException ( e ) ; } } @ Override protected void populateInitialHeaders ( Map < String , Object > map ) { Enumeration names = request . getHeaderNames ( ) ; while ( names . hasMoreElements ( ) ) { String name = ( String ) names . nextElement ( ) ; Object value = request . getHeader ( name ) ; map . put ( name , value ) ; } if ( request . getMethod ( ) . equalsIgnoreCase ( "GET" ) ) { names = request . getParameterNames ( ) ; while ( names . hasMoreElements ( ) ) { String name = ( String ) names . nextElement ( ) ; Object value = request . getParameter ( name ) ; map . put ( name , value ) ; } } map . put ( HttpMethods . HTTP_METHOD , request . getMethod ( ) ) ; map . put ( HttpProducer . QUERY , request . getQueryString ( ) ) ; } } 	0	['6', '3', '0', '8', '23', '9', '4', '6', '4', '0.6', '111', '1', '0', '0.875', '0.375', '2', '4', '17.33333333', '4', '1.3333', '0']
package org . apache . camel . builder . script ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import org . apache . camel . language . LanguageAnnotation ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . PARAMETER } ) @ LanguageAnnotation ( language = "beanshell" ) @ Deprecated public @ interface BeanShell { String value ( ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . cxf ; import java . io . OutputStream ; import java . lang . reflect . Proxy ; import javax . xml . transform . Source ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . component . cxf . util . CxfEndpointUtils ; import org . apache . camel . component . cxf . util . Dummy ; import org . apache . camel . component . cxf . util . NullConduit ; import org . apache . camel . component . cxf . util . NullConduitSelector ; import org . apache . camel . util . AsyncProcessorHelper ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . cxf . Bus ; import org . apache . cxf . common . classloader . ClassLoaderUtils ; import org . apache . cxf . endpoint . ClientImpl ; import org . apache . cxf . frontend . ClientFactoryBean ; import org . apache . cxf . frontend . ClientProxy ; import org . apache . cxf . frontend . ClientProxyFactoryBean ; import org . apache . cxf . interceptor . InterceptorChain ; import org . apache . cxf . interceptor . OutgoingChainInterceptor ; import org . apache . cxf . io . CachedOutputStream ; import org . apache . cxf . message . ExchangeImpl ; import org . apache . cxf . message . Message ; public class CxfSoapProducer implements Producer , AsyncProcessor { private static final Log LOG = LogFactory . getLog ( CxfSoapProducer . class ) ; private final CxfSoapEndpoint endpoint ; private final Producer producer ; private final AsyncProcessor processor ; private ClientImpl client ; public CxfSoapProducer ( CxfSoapEndpoint endpoint ) throws Exception { this . endpoint = endpoint ; this . producer = endpoint . getInnerEndpoint ( ) . createProducer ( ) ; this . processor = new AsyncProcessorDecorator ( producer , new Processor ( ) { public void process ( Exchange exchange ) throws Exception { processSoapProviderIn ( exchange ) ; } } , new Processor ( ) { public void process ( Exchange exchange ) throws Exception { processSoapProviderOut ( exchange ) ; } } ) ; Class sei = null ; if ( ObjectHelper . isNotEmpty ( endpoint . getServiceClass ( ) ) ) { sei = ClassLoaderUtils . loadClass ( endpoint . getServiceClass ( ) , this . getClass ( ) ) ; } ClientProxyFactoryBean cfb = CxfEndpointUtils . getClientFactoryBean ( sei ) ; if ( sei == null ) { cfb . setServiceClass ( Dummy . class ) ; } else { cfb . setServiceClass ( sei ) ; } cfb . setWsdlURL ( endpoint . getWsdl ( ) . getURL ( ) . toString ( ) ) ; if ( endpoint . getServiceName ( ) != null ) { cfb . setServiceName ( endpoint . getServiceName ( ) ) ; } if ( endpoint . getEndpointName ( ) != null ) { cfb . setEndpointName ( endpoint . getEndpointName ( ) ) ; } cfb . setConduitSelector ( new NullConduitSelector ( ) ) ; client = ( ClientImpl ) ( ( ClientProxy ) Proxy . getInvocationHandler ( cfb . create ( ) ) ) . getClient ( ) ; } public org . apache . camel . Endpoint getEndpoint ( ) { return producer . getEndpoint ( ) ; } public Exchange createExchange ( ) { return producer . createExchange ( ) ; } public Exchange createExchange ( ExchangePattern pattern ) { return producer . createExchange ( pattern ) ; } public Exchange createExchange ( Exchange exchange ) { return producer . createExchange ( exchange ) ; } public void process ( Exchange exchange ) throws Exception { AsyncProcessorHelper . process ( this , exchange ) ; } public boolean process ( Exchange exchange , AsyncCallback callback ) { return processor . process ( exchange , callback ) ; } public void start ( ) throws Exception { producer . start ( ) ; } public void stop ( ) throws Exception { producer . stop ( ) ; } protected void processSoapProviderOut ( Exchange exchange ) throws Exception { LOG . info ( "processSoapProviderOut: " + exchange ) ; org . apache . cxf . message . Message inMessage = CxfSoapBinding . getCxfInMessage ( endpoint . getHeaderFilterStrategy ( ) , exchange , true ) ; client . setInInterceptors ( client . getEndpoint ( ) . getService ( ) . getInInterceptors ( ) ) ; client . onMessage ( inMessage ) ; exchange . getOut ( ) . setBody ( inMessage . getContent ( Source . class ) ) ; exchange . getOut ( ) . setHeaders ( inMessage ) ; } protected Bus getBus ( ) { return endpoint . getBus ( ) ; } protected void processSoapProviderIn ( Exchange exchange ) throws Exception { LOG . info ( "processSoapProviderIn: " + exchange ) ; org . apache . cxf . endpoint . Endpoint cxfEndpoint = client . getEndpoint ( ) ; org . apache . cxf . message . Exchange cxfExchange = new ExchangeImpl ( ) ; cxfExchange . put ( org . apache . cxf . endpoint . Endpoint . class , cxfEndpoint ) ; cxfExchange . put ( Bus . class , getBus ( ) ) ; cxfExchange . setConduit ( new NullConduit ( ) ) ; exchange . setProperty ( CxfConstants . CXF_EXCHANGE , cxfExchange ) ; org . apache . cxf . message . Message outMessage = CxfSoapBinding . getCxfOutMessage ( endpoint . getHeaderFilterStrategy ( ) , exchange , true ) ; outMessage . put ( Message . REQUESTOR_ROLE , Boolean . TRUE ) ; outMessage . put ( Message . INBOUND_MESSAGE , Boolean . FALSE ) ; InterceptorChain chain = OutgoingChainInterceptor . getOutInterceptorChain ( cxfExchange ) ; outMessage . setInterceptorChain ( chain ) ; chain . doIntercept ( outMessage ) ; CachedOutputStream outputStream = ( CachedOutputStream ) outMessage . getContent ( OutputStream . class ) ; exchange . getOut ( ) . setBody ( outputStream . getInputStream ( ) ) ; exchange . getIn ( ) . setBody ( outputStream . getInputStream ( ) ) ; } } 	0	['13', '1', '0', '38', '76', '18', '3', '38', '9', '0.766666667', '264', '1', '3', '0', '0.333333333', '0', '0', '18.92307692', '1', '0.8462', '0']
package org . apache . camel . processor . exceptionpolicy ; import java . util . Map ; import org . apache . camel . Exchange ; import org . apache . camel . model . ExceptionType ; public interface ExceptionPolicyStrategy { ExceptionType getExceptionPolicy ( Map < ExceptionPolicyKey , ExceptionType > exceptionPolicices , Exchange exchange , Throwable exception ) ; } 	0	['1', '1', '0', '6', '1', '0', '4', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . mina ; import java . io . IOException ; import java . io . InputStream ; import java . io . ObjectInput ; import org . apache . camel . Converter ; import org . apache . camel . Exchange ; import org . apache . camel . converter . IOConverter ; import org . apache . mina . common . ByteBuffer ; @ Converter public final class MinaConverter { private MinaConverter ( ) { } @ Converter public static byte [ ] toByteArray ( ByteBuffer buffer ) { byte [ ] answer = new byte [ buffer . remaining ( ) ] ; try { buffer . acquire ( ) ; } catch ( IllegalStateException ex ) { } buffer . get ( answer ) ; return answer ; } @ Converter public static String toString ( ByteBuffer buffer , Exchange exchange ) { return IOConverter . toString ( toByteArray ( buffer ) , exchange ) ; } @ Converter public static InputStream toInputStream ( ByteBuffer buffer ) { return buffer . asInputStream ( ) ; } @ Converter public static ObjectInput toObjectInput ( ByteBuffer buffer ) throws IOException { return IOConverter . toObjectInput ( toInputStream ( buffer ) ) ; } @ Converter public static ByteBuffer toByteBuffer ( byte [ ] bytes ) { ByteBuffer buf = ByteBuffer . allocate ( bytes . length ) ; buf . put ( bytes ) ; return buf ; } } 	0	['6', '1', '0', '3', '15', '15', '0', '3', '5', '2', '45', '0', '0', '0', '0.291666667', '0', '0', '6.5', '1', '0.8333', '0']
@ javax . xml . bind . annotation . XmlSchema ( namespace = "http://activemq.apache.org/camel/schema/spring" , elementFormDefault = javax . xml . bind . annotation . XmlNsForm . QUALIFIED ) package org . apache . camel . model . loadbalancer ; 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . impl ; import java . io . IOException ; import java . io . InputStream ; import java . io . ObjectInput ; import java . io . ObjectOutput ; import java . io . OutputStream ; import org . apache . camel . Exchange ; import org . apache . camel . converter . IOConverter ; import org . apache . camel . spi . DataFormat ; public class SerializationDataFormat implements DataFormat { public void marshal ( Exchange exchange , Object graph , OutputStream stream ) throws IOException { ObjectOutput out = IOConverter . toObjectOutput ( stream ) ; try { out . writeObject ( graph ) ; } finally { out . flush ( ) ; try { out . close ( ) ; } catch ( IOException e ) { } } } public Object unmarshal ( Exchange exchange , InputStream stream ) throws IOException , ClassNotFoundException { ObjectInput in = IOConverter . toObjectInput ( stream ) ; try { return in . readObject ( ) ; } finally { try { in . close ( ) ; } catch ( IOException e ) { } } } } 	0	['3', '1', '0', '4', '11', '3', '1', '3', '3', '2', '48', '0', '0', '0', '0.533333333', '0', '0', '15', '1', '0.6667', '0']
package org . apache . camel . component . jms ; import javax . jms . MessageListener ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; import org . springframework . jms . listener . AbstractMessageListenerContainer ; public class JmsConsumer extends DefaultConsumer < JmsExchange > { private final AbstractMessageListenerContainer listenerContainer ; private EndpointMessageListener messageListener ; public JmsConsumer ( JmsEndpoint endpoint , Processor processor , AbstractMessageListenerContainer listenerContainer ) { super ( endpoint , processor ) ; this . listenerContainer = listenerContainer ; createMessageListener ( endpoint , processor ) ; this . listenerContainer . setMessageListener ( messageListener ) ; } public AbstractMessageListenerContainer getListenerContainer ( ) { return listenerContainer ; } public EndpointMessageListener getEndpointMessageListener ( ) { return messageListener ; } protected void createMessageListener ( JmsEndpoint endpoint , Processor processor ) { messageListener = new EndpointMessageListener ( endpoint , processor ) ; messageListener . setBinding ( endpoint . getBinding ( ) ) ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; listenerContainer . afterPropertiesSet ( ) ; listenerContainer . start ( ) ; } @ Override protected void doStop ( ) throws Exception { listenerContainer . stop ( ) ; listenerContainer . destroy ( ) ; super . doStop ( ) ; } } 	0	['6', '3', '0', '7', '17', '0', '1', '7', '3', '0.5', '62', '1', '1', '0.821428571', '0.458333333', '1', '1', '9', '1', '0.8333', '0']
package org . apache . camel . spi ; public interface ExceptionHandler { void handleException ( Throwable exception ) ; } 	0	['1', '1', '0', '8', '1', '0', '8', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . irc ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . schwering . irc . lib . IRCConnection ; import org . schwering . irc . lib . IRCEventAdapter ; import org . schwering . irc . lib . IRCModeParser ; import org . schwering . irc . lib . IRCUser ; public class IrcConsumer extends DefaultConsumer < IrcExchange > { private static final transient Log LOG = LogFactory . getLog ( IrcConsumer . class ) ; private final IrcConfiguration configuration ; private final IrcEndpoint endpoint ; private final IRCConnection connection ; private FilteredIRCEventAdapter listener ; public IrcConsumer ( IrcEndpoint endpoint , Processor processor , IRCConnection connection ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; this . connection = connection ; configuration = endpoint . getConfiguration ( ) ; } @ Override protected void doStop ( ) throws Exception { String target = endpoint . getConfiguration ( ) . getTarget ( ) ; connection . doPart ( target ) ; connection . removeIRCEventListener ( listener ) ; super . doStop ( ) ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; String target = endpoint . getConfiguration ( ) . getTarget ( ) ; connection . addIRCEventListener ( new FilteredIRCEventAdapter ( target ) ) ; LOG . debug ( "joining: " + target ) ; connection . doJoin ( target ) ; } public IRCConnection getConnection ( ) { return connection ; } class FilteredIRCEventAdapter extends IRCEventAdapter { final String target ; public FilteredIRCEventAdapter ( String target ) { this . target = target ; } @ Override public void onNick ( IRCUser user , String newNick ) { if ( configuration . isOnNick ( ) ) { IrcExchange exchange = endpoint . createOnNickExchange ( user , newNick ) ; try { getProcessor ( ) . process ( exchange ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } @ Override public void onQuit ( IRCUser user , String msg ) { if ( configuration . isOnQuit ( ) ) { IrcExchange exchange = endpoint . createOnQuitExchange ( user , msg ) ; try { getProcessor ( ) . process ( exchange ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } @ Override public void onJoin ( String channel , IRCUser user ) { if ( configuration . isOnJoin ( ) ) { if ( channel . equals ( configuration . getTarget ( ) ) ) { IrcExchange exchange = endpoint . createOnJoinExchange ( channel , user ) ; try { getProcessor ( ) . process ( exchange ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } @ Override public void onKick ( String channel , IRCUser user , String passiveNick , String msg ) { if ( configuration . isOnKick ( ) ) { if ( channel . equals ( configuration . getTarget ( ) ) ) { IrcExchange exchange = endpoint . createOnKickExchange ( channel , user , passiveNick , msg ) ; try { getProcessor ( ) . process ( exchange ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } @ Override public void onMode ( String channel , IRCUser user , IRCModeParser modeParser ) { if ( configuration . isOnMode ( ) ) { if ( channel . equals ( configuration . getTarget ( ) ) ) { IrcExchange exchange = endpoint . createOnModeExchange ( channel , user , modeParser ) ; try { getProcessor ( ) . process ( exchange ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } @ Override public void onPart ( String channel , IRCUser user , String msg ) { if ( configuration . isOnPart ( ) ) { if ( channel . equals ( configuration . getTarget ( ) ) ) { IrcExchange exchange = endpoint . createOnPartExchange ( channel , user , msg ) ; try { getProcessor ( ) . process ( exchange ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } @ Override public void onTopic ( String channel , IRCUser user , String topic ) { if ( configuration . isOnTopic ( ) ) { if ( channel . equals ( configuration . getTarget ( ) ) ) { IrcExchange exchange = endpoint . createOnTopicExchange ( channel , user , topic ) ; try { getProcessor ( ) . process ( exchange ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } @ Override public void onPrivmsg ( String target , IRCUser user , String msg ) { if ( configuration . isOnPrivmsg ( ) ) { if ( target . equals ( configuration . getTarget ( ) ) ) { IrcExchange exchange = endpoint . createOnPrivmsgExchange ( target , user , msg ) ; try { getProcessor ( ) . process ( exchange ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } } } 	0	['7', '3', '0', '10', '22', '0', '2', '10', '2', '0.733333333', '88', '1', '3', '0.821428571', '0.3', '1', '1', '10.85714286', '1', '0.7143', '0']
package org . apache . camel . component . mina ; public enum TextLineDelimiter { DEFAULT , AUTO , UNIX , WINDOWS , MAC } 	0	['4', '2', '0', '3', '7', '4', '2', '1', '2', '0.944444444', '78', '0.166666667', '6', '0.857142857', '0.444444444', '1', '1', '17', '1', '0.5', '0']
package org . apache . camel . processor . idempotent . jpa ; import java . util . List ; import javax . persistence . EntityManagerFactory ; import javax . persistence . Persistence ; import org . apache . camel . processor . idempotent . MessageIdRepository ; import org . springframework . orm . jpa . JpaTemplate ; import org . springframework . orm . jpa . JpaTransactionManager ; import org . springframework . transaction . TransactionDefinition ; import org . springframework . transaction . TransactionStatus ; import org . springframework . transaction . support . TransactionCallback ; import org . springframework . transaction . support . TransactionTemplate ; public class JpaMessageIdRepository implements MessageIdRepository { protected static final String QUERY_STRING = "select x from " + MessageProcessed . class . getName ( ) + " x where x.processorName = ?1 and x.messageId = ?2" ; private JpaTemplate jpaTemplate ; private String processorName ; private TransactionTemplate transactionTemplate ; public JpaMessageIdRepository ( JpaTemplate template , String processorName ) { this ( template , createTransactionTemplate ( template ) , processorName ) ; } public JpaMessageIdRepository ( JpaTemplate template , TransactionTemplate transactionTemplate , String processorName ) { this . jpaTemplate = template ; this . processorName = processorName ; this . transactionTemplate = transactionTemplate ; } public static JpaMessageIdRepository jpaMessageIdRepository ( String persistenceUnit , String processorName ) { EntityManagerFactory entityManagerFactory = Persistence . createEntityManagerFactory ( persistenceUnit ) ; return jpaMessageIdRepository ( new JpaTemplate ( entityManagerFactory ) , processorName ) ; } public static JpaMessageIdRepository jpaMessageIdRepository ( JpaTemplate jpaTemplate , String processorName ) { return new JpaMessageIdRepository ( jpaTemplate , processorName ) ; } private static TransactionTemplate createTransactionTemplate ( JpaTemplate jpaTemplate ) { TransactionTemplate transactionTemplate = new TransactionTemplate ( ) ; transactionTemplate . setTransactionManager ( new JpaTransactionManager ( jpaTemplate . getEntityManagerFactory ( ) ) ) ; transactionTemplate . setPropagationBehavior ( TransactionDefinition . PROPAGATION_REQUIRED ) ; return transactionTemplate ; } public boolean contains ( final String messageId ) { Boolean rc = ( Boolean ) transactionTemplate . execute ( new TransactionCallback ( ) { public Object doInTransaction ( TransactionStatus arg0 ) { List list = jpaTemplate . find ( QUERY_STRING , processorName , messageId ) ; if ( list . isEmpty ( ) ) { MessageProcessed processed = new MessageProcessed ( ) ; processed . setProcessorName ( processorName ) ; processed . setMessageId ( messageId ) ; jpaTemplate . persist ( processed ) ; jpaTemplate . flush ( ) ; return Boolean . FALSE ; } else { return Boolean . TRUE ; } } } ) ; return rc . booleanValue ( ) ; } } 	0	['9', '1', '0', '7', '24', '30', '1', '7', '5', '0.71875', '96', '1', '0', '0', '0.375', '0', '0', '9.222222222', '1', '0.6667', '0']
package org . apache . camel . converter . jaxb ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Set ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAnyElement ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlMixed ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Message ; @ XmlRootElement ( name = "message" ) @ XmlAccessorType ( value = XmlAccessType . FIELD ) public class MessageType { @ XmlAnyElement ( lax = true ) @ XmlMixed List < HeaderType > headers = new ArrayList < HeaderType > ( ) ; @ XmlAnyElement ( lax = true ) @ XmlMixed private List content = new ArrayList ( ) ; @ XmlTransient private Object body ; public Object getBody ( ) { if ( body == null ) { if ( content != null ) { if ( content . size ( ) == 1 ) { return content . get ( 0 ) ; } else { return content ; } } } return body ; } public void setBody ( Object body ) { this . body = body ; if ( body instanceof List ) { content = ( List ) body ; } else { content = new ArrayList ( ) ; content . add ( body ) ; } } public List < HeaderType > getHeaders ( ) { return headers ; } public void setHeaders ( List < HeaderType > headers ) { this . headers = headers ; } public Map < String , Object > getHeaderMap ( ) { Map < String , Object > answer = new HashMap < String , Object > ( ) ; for ( HeaderType header : headers ) { answer . put ( header . getName ( ) , header . getValue ( ) ) ; } return answer ; } public void copyFrom ( Message message ) { headers . clear ( ) ; Set < Map . Entry < String , Object > > entries = message . getHeaders ( ) . entrySet ( ) ; for ( Map . Entry < String , Object > entry : entries ) { Object value = entry . getValue ( ) ; if ( value != null ) { headers . add ( createHeader ( entry . getKey ( ) , value ) ) ; } } setBody ( message . getBody ( ) ) ; } public void copyTo ( Message message ) { message . setHeaders ( getHeaderMap ( ) ) ; message . setBody ( getBody ( ) ) ; } protected HeaderType createHeader ( String key , Object value ) { if ( value instanceof String ) { return new StringHeader ( key , ( String ) value ) ; } else if ( value instanceof Integer ) { return new IntegerHeader ( key , ( Integer ) value ) ; } else if ( value instanceof Long ) { return new LongHeader ( key , ( Long ) value ) ; } else { return new StringHeader ( key , value . toString ( ) ) ; } } } 	0	['9', '1', '0', '6', '34', '10', '1', '5', '8', '0.5', '185', '0.666666667', '0', '0', '0.333333333', '0', '0', '19.22222222', '4', '1.8889', '0']
package org . apache . camel . language . juel ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . spi . Language ; public class JuelLanguage implements Language { public Predicate < Exchange > createPredicate ( String expression ) { return new JuelExpression ( expression , Boolean . class ) ; } public Expression < Exchange > createExpression ( String expression ) { return new JuelExpression ( expression , Object . class ) ; } } 	0	['3', '1', '0', '4', '5', '3', '0', '4', '3', '2', '18', '0', '0', '0', '0.833333333', '0', '0', '5', '1', '0.6667', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . Delayer ; import org . apache . camel . spi . RouteContext ; import org . apache . camel . util . ObjectHelper ; @ XmlRootElement ( name = "delayer" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class DelayerType extends ExpressionNode { @ XmlElement private Long delay = 0L ; public DelayerType ( ) { } public DelayerType ( Expression processAtExpression ) { super ( processAtExpression ) ; } public DelayerType ( ExpressionType processAtExpression ) { super ( processAtExpression ) ; } public DelayerType ( Expression processAtExpression , long delay ) { super ( processAtExpression ) ; this . delay = delay ; } @ Override public String toString ( ) { return "Delayer[" + getExpression ( ) + " -> " + getOutputs ( ) + "]" ; } @ Override public String getShortName ( ) { return "delayer" ; } public Long getDelay ( ) { return delay ; } public void setDelay ( Long delay ) { this . delay = delay ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { Processor childProcessor = routeContext . createProcessor ( this ) ; Expression processAtExpression = createAbsoluteTimeDelayExpression ( routeContext ) ; return new Delayer ( childProcessor , processAtExpression , delay ) ; } private Expression createAbsoluteTimeDelayExpression ( RouteContext routeContext ) { ExpressionType expr = getExpression ( ) ; if ( expr != null ) { if ( ObjectHelper . isNotNullAndNonEmpty ( expr . getExpression ( ) ) || expr . getExpressionValue ( ) != null ) { return expr . createExpression ( routeContext ) ; } } return null ; } } 	0	['10', '4', '0', '10', '27', '3', '3', '8', '9', '0.333333333', '107', '1', '0', '0.968421053', '0.283333333', '2', '3', '9.6', '4', '0.9', '0']
package org . apache . camel . component . jcr ; import java . io . InputStream ; import java . util . Calendar ; import javax . jcr . Value ; import org . apache . camel . Converter ; import org . apache . jackrabbit . value . BinaryValue ; import org . apache . jackrabbit . value . BooleanValue ; import org . apache . jackrabbit . value . DateValue ; import org . apache . jackrabbit . value . StringValue ; @ Converter public class JcrConverter { @ Converter public Value toValue ( Boolean bool ) { return new BooleanValue ( bool ) ; } @ Converter public Value toValue ( InputStream stream ) { return new BinaryValue ( stream ) ; } @ Converter public Value toValue ( Calendar calendar ) { return new DateValue ( calendar ) ; } @ Converter public Value toValue ( String value ) { return new StringValue ( value ) ; } } 	0	['5', '1', '0', '4', '10', '10', '0', '4', '5', '2', '28', '0', '0', '0', '0.36', '0', '0', '4.6', '1', '0.8', '0']
package org . apache . camel . language . juel ; import java . util . Properties ; import javax . el . ArrayELResolver ; import javax . el . CompositeELResolver ; import javax . el . ELContext ; import javax . el . ELResolver ; import javax . el . ExpressionFactory ; import javax . el . ListELResolver ; import javax . el . MapELResolver ; import javax . el . ResourceBundleELResolver ; import javax . el . ValueExpression ; import de . odysseus . el . util . SimpleContext ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . impl . ExpressionSupport ; public class JuelExpression extends ExpressionSupport < Exchange > { private final String expression ; private final Class < ? > type ; private ExpressionFactory expressionFactory ; private Properties expressionFactoryProperties ; public JuelExpression ( String expression , Class < ? > type ) { this . expression = expression ; this . type = type ; } public static JuelExpression el ( String expression ) { return new JuelExpression ( expression , Object . class ) ; } public Object evaluate ( Exchange exchange ) { ELContext context = populateContext ( createContext ( ) , exchange ) ; ValueExpression valueExpression = getExpressionFactory ( ) . createValueExpression ( context , expression , type ) ; return valueExpression . getValue ( context ) ; } public ExpressionFactory getExpressionFactory ( ) { if ( expressionFactory == null ) { Properties properties = getExpressionFactoryProperties ( ) ; expressionFactory = ExpressionFactory . newInstance ( properties ) ; } return expressionFactory ; } public void setExpressionFactory ( ExpressionFactory expressionFactory ) { this . expressionFactory = expressionFactory ; } public Properties getExpressionFactoryProperties ( ) { if ( expressionFactoryProperties == null ) { expressionFactoryProperties = new Properties ( ) ; populateDefaultExpressionProperties ( expressionFactoryProperties ) ; } return expressionFactoryProperties ; } public void setExpressionFactoryProperties ( Properties expressionFactoryProperties ) { this . expressionFactoryProperties = expressionFactoryProperties ; } protected ELContext populateContext ( ELContext context , Exchange exchange ) { setVariable ( context , "exchange" , exchange , Exchange . class ) ; setVariable ( context , "in" , exchange . getIn ( ) , Message . class ) ; Message out = exchange . getOut ( false ) ; setVariable ( context , "out" , out , Message . class ) ; return context ; } protected void populateDefaultExpressionProperties ( Properties properties ) { properties . setProperty ( "javax.el.methodInvocations" , "true" ) ; } protected void setVariable ( ELContext context , String name , Object value , Class < ? > type ) { ValueExpression valueExpression = getExpressionFactory ( ) . createValueExpression ( value , type ) ; SimpleContext simpleContext = ( SimpleContext ) context ; simpleContext . setVariable ( name , valueExpression ) ; } protected ELContext createContext ( ) { ELResolver resolver = new CompositeELResolver ( ) { { add ( new ArrayELResolver ( false ) ) ; add ( new ListELResolver ( false ) ) ; add ( new MapELResolver ( false ) ) ; add ( new ResourceBundleELResolver ( ) ) ; add ( new BeanAndMethodELResolver ( ) ) ; } } ; return new SimpleContext ( resolver ) ; } protected String assertionFailureMessage ( Exchange exchange ) { return expression ; } } 	0	['12', '2', '0', '6', '24', '56', '2', '5', '7', '0.75', '145', '1', '0', '0.3125', '0.260416667', '1', '2', '10.75', '2', '1.0833', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Endpoint ; import org . apache . camel . ExchangePattern ; @ XmlRootElement ( name = "to" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ToType extends SendType < ToType > { @ XmlAttribute ( required = false ) private ExchangePattern pattern ; public ToType ( ) { } public ToType ( String uri ) { setUri ( uri ) ; } public ToType ( Endpoint endpoint ) { setEndpoint ( endpoint ) ; } public ToType ( String uri , ExchangePattern pattern ) { this ( uri ) ; this . pattern = pattern ; } public ToType ( Endpoint endpoint , ExchangePattern pattern ) { this ( endpoint ) ; this . pattern = pattern ; } @ Override public String toString ( ) { return "To[" + getLabel ( ) + "]" ; } @ Override public String getShortName ( ) { return "to" ; } @ Override public ExchangePattern getPattern ( ) { return pattern ; } public void setPattern ( ExchangePattern pattern ) { this . pattern = pattern ; } } 	0	['9', '4', '0', '7', '16', '24', '4', '3', '9', '0.625', '60', '1', '1', '0.979166667', '0.444444444', '2', '2', '5.555555556', '1', '0.4444', '0']
package org . apache . camel . util ; import java . io . IOException ; public class NoFactoryAvailableException extends IOException { private final String uri ; public NoFactoryAvailableException ( String uri ) { super ( "Could not find factory class for resource: " + uri ) ; this . uri = uri ; } public String getUri ( ) { return uri ; } } 	0	['2', '4', '0', '6', '6', '0', '6', '0', '2', '0', '20', '1', '0', '0.944444444', '0.75', '0', '0', '8.5', '1', '0.5', '0']
package org . apache . camel . component . file . strategy ; import java . io . File ; import java . io . IOException ; import org . apache . camel . component . file . FileEndpoint ; import org . apache . camel . component . file . FileExchange ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class RenameFileProcessStrategy extends FileProcessStrategySupport { private static final transient Log LOG = LogFactory . getLog ( RenameFileProcessStrategy . class ) ; private FileRenamer beginRenamer ; private FileRenamer commitRenamer ; public RenameFileProcessStrategy ( ) { this ( true ) ; } public RenameFileProcessStrategy ( boolean lock ) { this ( lock , ".camel/" , "" ) ; } public RenameFileProcessStrategy ( boolean lock , String namePrefix , String namePostfix ) { this ( lock , new DefaultFileRenamer ( namePrefix , namePostfix ) , null ) ; } public RenameFileProcessStrategy ( boolean lock , String namePrefix , String namePostfix , String preNamePrefix , String preNamePostfix ) { this ( lock , new DefaultFileRenamer ( namePrefix , namePostfix ) , new DefaultFileRenamer ( preNamePrefix , preNamePostfix ) ) ; } public RenameFileProcessStrategy ( boolean lock , FileRenamer commitRenamer , FileRenamer beginRenamer ) { super ( lock ) ; this . commitRenamer = commitRenamer ; this . beginRenamer = beginRenamer ; } @ Override public boolean begin ( FileEndpoint endpoint , FileExchange exchange , File file ) throws Exception { boolean answer = super . begin ( endpoint , exchange , file ) ; if ( beginRenamer != null ) { File newName = beginRenamer . renameFile ( exchange , file ) ; File to = renameFile ( file , newName ) ; exchange . setFile ( to ) ; } return answer ; } @ Override public void commit ( FileEndpoint endpoint , FileExchange exchange , File file ) throws Exception { File newName = commitRenamer . renameFile ( exchange , file ) ; renameFile ( file , newName ) ; super . commit ( endpoint , exchange , file ) ; } private static File renameFile ( File from , File to ) throws IOException { if ( to . exists ( ) ) { to . delete ( ) ; } File parent = to . getParentFile ( ) ; if ( ! parent . exists ( ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Creating directory: " + parent ) ; } boolean mkdir = parent . mkdirs ( ) ; if ( ! mkdir ) { throw new IOException ( "Can not create directory: " + parent ) ; } } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Renaming file: " + from + " to: " + to ) ; } boolean renamed = from . renameTo ( to ) ; if ( ! renamed ) { throw new IOException ( "Can not rename file from: " + from + " to: " + to ) ; } return to ; } public FileRenamer getBeginRenamer ( ) { return beginRenamer ; } public void setBeginRenamer ( FileRenamer beginRenamer ) { this . beginRenamer = beginRenamer ; } public FileRenamer getCommitRenamer ( ) { return commitRenamer ; } public void setCommitRenamer ( FileRenamer commitRenamer ) { this . commitRenamer = commitRenamer ; } } 	0	['13', '2', '0', '8', '32', '52', '1', '7', '11', '0.638888889', '201', '1', '2', '0.533333333', '0.321428571', '0', '0', '14.23076923', '1', '0.5385', '0']
package org . apache . camel . component . jms ; import javax . jms . JMSException ; import javax . jms . Session ; import javax . jms . TemporaryQueue ; import javax . jms . TemporaryTopic ; import org . springframework . jms . core . JmsOperations ; import org . springframework . jms . core . SessionCallback ; public class JmsProviderMetadata { private Class < ? extends TemporaryQueue > temporaryQueueType ; private Class < ? extends TemporaryTopic > temporaryTopicType ; public Class < ? extends TemporaryQueue > getTemporaryQueueType ( JmsOperations template ) { Class < ? extends TemporaryQueue > answer = getTemporaryQueueType ( ) ; if ( answer == null ) { loadTemporaryDestinationTypes ( template ) ; answer = getTemporaryQueueType ( ) ; } return answer ; } public Class < ? extends TemporaryTopic > getTemporaryTopicType ( JmsOperations template ) { Class < ? extends TemporaryTopic > answer = getTemporaryTopicType ( ) ; if ( answer == null ) { loadTemporaryDestinationTypes ( template ) ; answer = getTemporaryTopicType ( ) ; } return answer ; } public Class < ? extends TemporaryQueue > getTemporaryQueueType ( ) { return temporaryQueueType ; } public void setTemporaryQueueType ( Class < ? extends TemporaryQueue > temporaryQueueType ) { this . temporaryQueueType = temporaryQueueType ; } public Class < ? extends TemporaryTopic > getTemporaryTopicType ( ) { return temporaryTopicType ; } public void setTemporaryTopicType ( Class < ? extends TemporaryTopic > temporaryTopicType ) { this . temporaryTopicType = temporaryTopicType ; } protected void loadTemporaryDestinationTypes ( JmsOperations template ) { if ( template == null ) { throw new IllegalArgumentException ( "No JmsTemplate supplied!" ) ; } template . execute ( new SessionCallback ( ) { public Object doInJms ( Session session ) throws JMSException { TemporaryQueue queue = session . createTemporaryQueue ( ) ; setTemporaryQueueType ( queue . getClass ( ) ) ; TemporaryTopic topic = session . createTemporaryTopic ( ) ; setTemporaryTopicType ( topic . getClass ( ) ) ; queue . delete ( ) ; topic . delete ( ) ; return null ; } } ) ; } } 	0	['8', '1', '0', '5', '12', '24', '3', '3', '7', '0.714285714', '68', '1', '0', '0', '0.541666667', '0', '0', '7.25', '2', '1.25', '0']
package org . apache . camel . component . jms . requestor ; import java . util . concurrent . FutureTask ; import javax . jms . JMSException ; import javax . jms . Message ; import org . apache . camel . component . jms . JmsConfiguration . MessageSentCallback ; import org . apache . camel . component . jms . JmsProducer ; import org . apache . camel . util . TimeoutMap ; import org . apache . camel . util . UuidGenerator ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DeferredRequestReplyMap { private static final transient Log LOG = LogFactory . getLog ( DeferredRequestReplyMap . class ) ; private Requestor requestor ; private JmsProducer producer ; private TimeoutMap deferredRequestMap ; private TimeoutMap deferredReplyMap ; public static class DeferredMessageSentCallback implements MessageSentCallback { private DeferredRequestReplyMap map ; private String transitionalID ; private Message message ; private Object monitor ; public DeferredMessageSentCallback ( DeferredRequestReplyMap map , UuidGenerator uuidGenerator , Object monitor ) { transitionalID = uuidGenerator . generateId ( ) ; this . map = map ; this . monitor = monitor ; } public DeferredRequestReplyMap getDeferredRequestReplyMap ( ) { return map ; } public String getID ( ) { return transitionalID ; } public Message getMessage ( ) { return message ; } public void sent ( Message message ) { this . message = message ; map . processDeferredReplies ( monitor , getID ( ) , message ) ; } } public DeferredRequestReplyMap ( Requestor requestor , JmsProducer producer , TimeoutMap deferredRequestMap , TimeoutMap deferredReplyMap ) { this . requestor = requestor ; this . producer = producer ; this . deferredRequestMap = deferredRequestMap ; this . deferredReplyMap = deferredReplyMap ; } public long getRequestTimeout ( ) { return producer . getRequestTimeout ( ) ; } public DeferredMessageSentCallback createDeferredMessageSentCallback ( ) { return new DeferredMessageSentCallback ( this , getUuidGenerator ( ) , requestor ) ; } public void put ( DeferredMessageSentCallback callback , FutureTask futureTask ) { deferredRequestMap . put ( callback . getID ( ) , futureTask , getRequestTimeout ( ) ) ; } public void processDeferredRequests ( String correlationID , Message inMessage ) { processDeferredRequests ( requestor , deferredRequestMap , deferredReplyMap , correlationID , requestor . getMaxRequestTimeout ( ) , inMessage ) ; } public static void processDeferredRequests ( Object monitor , TimeoutMap requestMap , TimeoutMap replyMap , String correlationID , long timeout , Message inMessage ) { synchronized ( monitor ) { try { Object handler = requestMap . get ( correlationID ) ; if ( handler == null ) { if ( requestMap . size ( ) > replyMap . size ( ) ) { replyMap . put ( correlationID , inMessage , timeout ) ; } else { LOG . warn ( "Response received for unknown correlationID: " + correlationID + "; response: " + inMessage ) ; } } if ( handler != null && handler instanceof ReplyHandler ) { ReplyHandler replyHandler = ( ReplyHandler ) handler ; boolean complete = replyHandler . handle ( inMessage ) ; if ( complete ) { requestMap . remove ( correlationID ) ; } } } catch ( JMSException e ) { throw new FailedToProcessResponse ( inMessage , e ) ; } } } public void processDeferredReplies ( Object monitor , String transitionalID , Message outMessage ) { synchronized ( monitor ) { try { Object handler = deferredRequestMap . get ( transitionalID ) ; if ( handler == null ) { return ; } deferredRequestMap . remove ( transitionalID ) ; String correlationID = outMessage . getJMSMessageID ( ) ; Object in = deferredReplyMap . get ( correlationID ) ; if ( in != null && in instanceof Message ) { Message inMessage = ( Message ) in ; if ( handler instanceof ReplyHandler ) { ReplyHandler replyHandler = ( ReplyHandler ) handler ; try { boolean complete = replyHandler . handle ( inMessage ) ; if ( complete ) { deferredReplyMap . remove ( correlationID ) ; } } catch ( JMSException e ) { throw new FailedToProcessResponse ( inMessage , e ) ; } } } else { deferredRequestMap . put ( correlationID , handler , getRequestTimeout ( ) ) ; } } catch ( JMSException e ) { throw new FailedToProcessResponse ( outMessage , e ) ; } } } protected UuidGenerator getUuidGenerator ( ) { return producer . getUuidGenerator ( ) ; } } 	0	['9', '1', '0', '9', '28', '12', '3', '9', '7', '0.65', '224', '1', '4', '0', '0.275', '0', '0', '23.33333333', '4', '1.3333', '0']
package org . apache . camel . util . concurrent ; import java . util . concurrent . atomic . AtomicReference ; import org . apache . camel . Exchange ; @ SuppressWarnings ( "serial" ) public class AtomicExchange extends AtomicReference < Exchange > { } 	0	['1', '2', '0', '2', '2', '0', '2', '0', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . camel . component . file . remote ; import java . io . ByteArrayOutputStream ; import org . apache . camel . CamelContext ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; public class RemoteFileExchange < T extends RemoteFileBinding > extends DefaultExchange { private T binding ; public RemoteFileExchange ( CamelContext context , ExchangePattern pattern , T binding ) { super ( context , pattern ) ; this . binding = binding ; } public RemoteFileExchange ( CamelContext context , ExchangePattern pattern , T binding , String host , String fullFileName , String fileName , long fileLength , ByteArrayOutputStream outputStream ) { this ( context , pattern , binding ) ; setIn ( new RemoteFileMessage ( host , fullFileName , fileName , fileLength , outputStream ) ) ; } public T getBinding ( ) { return binding ; } public void setBinding ( T binding ) { this . binding = binding ; } } 	0	['4', '2', '0', '11', '7', '0', '7', '6', '4', '0', '36', '1', '1', '0.95', '0.5', '0', '0', '7.75', '1', '0.5', '0']
package org . apache . camel . component . uface ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . component . list . ListEndpoint ; import org . apache . camel . util . ObjectHelper ; import org . eclipse . core . databinding . observable . Realm ; import org . eclipse . core . databinding . observable . list . WritableList ; public class UFaceEndpoint extends ListEndpoint { public UFaceEndpoint ( String uri , UFaceComponent component ) { super ( uri , component ) ; } public UFaceEndpoint ( String endpointUri ) { super ( endpointUri ) ; } @ Override protected List < Exchange > createExchangeList ( ) { Realm realm = Realm . getDefault ( ) ; ObjectHelper . notNull ( realm , "DataBinding Realm" ) ; return new WritableList ( realm ) ; } } 	0	['3', '3', '0', '6', '8', '3', '1', '6', '2', '2', '22', '0', '0', '0.971428571', '0.666666667', '1', '1', '6.333333333', '1', '0.3333', '0']
package org . apache . camel . component . mina ; import java . net . InetSocketAddress ; import java . net . SocketAddress ; import java . net . URI ; import java . nio . charset . CharacterCodingException ; import java . nio . charset . Charset ; import java . nio . charset . CharsetEncoder ; import java . util . Map ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . ExchangePattern ; import org . apache . camel . NoTypeConversionAvailableException ; import org . apache . camel . impl . DefaultComponent ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . mina . common . ByteBuffer ; import org . apache . mina . common . IoAcceptor ; import org . apache . mina . common . IoConnector ; import org . apache . mina . common . IoServiceConfig ; import org . apache . mina . common . IoSession ; import org . apache . mina . filter . LoggingFilter ; import org . apache . mina . filter . codec . ProtocolCodecFactory ; import org . apache . mina . filter . codec . ProtocolCodecFilter ; import org . apache . mina . filter . codec . ProtocolDecoder ; import org . apache . mina . filter . codec . ProtocolDecoderOutput ; import org . apache . mina . filter . codec . ProtocolEncoder ; import org . apache . mina . filter . codec . ProtocolEncoderOutput ; import org . apache . mina . filter . codec . serialization . ObjectSerializationCodecFactory ; import org . apache . mina . filter . codec . textline . LineDelimiter ; import org . apache . mina . transport . socket . nio . DatagramAcceptor ; import org . apache . mina . transport . socket . nio . DatagramAcceptorConfig ; import org . apache . mina . transport . socket . nio . DatagramConnector ; import org . apache . mina . transport . socket . nio . DatagramConnectorConfig ; import org . apache . mina . transport . socket . nio . SocketAcceptor ; import org . apache . mina . transport . socket . nio . SocketAcceptorConfig ; import org . apache . mina . transport . socket . nio . SocketConnector ; import org . apache . mina . transport . socket . nio . SocketConnectorConfig ; import org . apache . mina . transport . vmpipe . VmPipeAcceptor ; import org . apache . mina . transport . vmpipe . VmPipeAddress ; import org . apache . mina . transport . vmpipe . VmPipeConnector ; public class MinaComponent extends DefaultComponent < MinaExchange > { private static final transient Log LOG = LogFactory . getLog ( MinaComponent . class ) ; private static final long DEFAULT_CONNECT_TIMEOUT = 30000 ; private boolean sync = true ; private boolean textline ; private TextLineDelimiter textlineDelimiter ; private String codec ; private String encoding ; private long timeout ; private boolean lazySessionCreation ; private boolean transferExchange ; private boolean minaLogger ; private CharsetEncoder encoder ; public MinaComponent ( ) { } public MinaComponent ( CamelContext context ) { super ( context ) ; } @ Override protected Endpoint < MinaExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Creating MinaEndpoint from uri: " + uri ) ; } setProperties ( this , parameters ) ; URI u = new URI ( remaining ) ; String protocol = u . getScheme ( ) ; if ( protocol != null ) { if ( protocol . equals ( "tcp" ) ) { return createSocketEndpoint ( uri , u , parameters ) ; } else if ( protocol . equals ( "udp" ) || protocol . equals ( "mcast" ) || protocol . equals ( "multicast" ) ) { return createDatagramEndpoint ( uri , u , parameters ) ; } else if ( protocol . equals ( "vm" ) ) { return createVmEndpoint ( uri , u ) ; } } throw new IllegalArgumentException ( "Unrecognised MINA protocol: " + protocol + " for uri: " + uri ) ; } protected MinaEndpoint createVmEndpoint ( String uri , URI connectUri ) { IoAcceptor acceptor = new VmPipeAcceptor ( ) ; SocketAddress address = new VmPipeAddress ( connectUri . getPort ( ) ) ; IoConnector connector = new VmPipeConnector ( ) ; configureCodecFactory ( "MinaProducer" , connector . getDefaultConfig ( ) , textline , encoding , codec ) ; if ( minaLogger ) { connector . getFilterChain ( ) . addLast ( "logger" , new LoggingFilter ( ) ) ; } configureCodecFactory ( "MinaConsumer" , acceptor . getDefaultConfig ( ) , textline , encoding , codec ) ; if ( minaLogger ) { acceptor . getFilterChain ( ) . addLast ( "logger" , new LoggingFilter ( ) ) ; } MinaEndpoint endpoint = new MinaEndpoint ( uri , this , address , acceptor , null , connector , null , false , timeout , transferExchange , sync ) ; if ( encoding != null ) { endpoint . setCharsetName ( getEncodingParameter ( "MinaProducer" , encoding ) . name ( ) ) ; } if ( sync ) { endpoint . setExchangePattern ( ExchangePattern . InOut ) ; } else { endpoint . setExchangePattern ( ExchangePattern . InOnly ) ; } return endpoint ; } protected MinaEndpoint createSocketEndpoint ( String uri , URI connectUri , Map parameters ) { IoAcceptor acceptor = new SocketAcceptor ( ) ; SocketAddress address = new InetSocketAddress ( connectUri . getHost ( ) , connectUri . getPort ( ) ) ; IoConnector connector = new SocketConnector ( ) ; SocketConnectorConfig connectorConfig = new SocketConnectorConfig ( ) ; configureCodecFactory ( "MinaProducer" , connectorConfig , textline , encoding , codec ) ; if ( minaLogger ) { connectorConfig . getFilterChain ( ) . addLast ( "logger" , new LoggingFilter ( ) ) ; } long connectTimeout = timeout > 0 ? timeout : DEFAULT_CONNECT_TIMEOUT ; connectorConfig . setConnectTimeout ( ( int ) ( connectTimeout / 1000 ) ) ; SocketAcceptorConfig acceptorConfig = new SocketAcceptorConfig ( ) ; configureCodecFactory ( "MinaConsumer" , acceptorConfig , textline , encoding , codec ) ; acceptorConfig . setReuseAddress ( true ) ; acceptorConfig . setDisconnectOnUnbind ( true ) ; if ( minaLogger ) { acceptorConfig . getFilterChain ( ) . addLast ( "logger" , new LoggingFilter ( ) ) ; } MinaEndpoint endpoint = new MinaEndpoint ( uri , this , address , acceptor , acceptorConfig , connector , connectorConfig , lazySessionCreation , timeout , transferExchange , sync ) ; if ( encoding != null ) { endpoint . setCharsetName ( getEncodingParameter ( "MinaProducer" , encoding ) . name ( ) ) ; } if ( sync ) { endpoint . setExchangePattern ( ExchangePattern . InOut ) ; } else { endpoint . setExchangePattern ( ExchangePattern . InOnly ) ; } return endpoint ; } protected void configureCodecFactory ( String type , IoServiceConfig config , boolean textline , String encoding , String codec ) { ProtocolCodecFactory codecFactory = getCodecFactory ( type , codec ) ; if ( codecFactory == null ) { if ( textline ) { Charset charset = getEncodingParameter ( type , encoding ) ; LineDelimiter delimiter = getLineDelimiterParameter ( ) ; codecFactory = new TextLineCodecFactory ( charset , delimiter ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( type + ": Using TextLineCodecFactory: " + codecFactory + " using encoding: " + charset + " and line delimiter: " + textlineDelimiter + "(" + delimiter + ")" ) ; } } else { codecFactory = new ObjectSerializationCodecFactory ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( type + ": Using ObjectSerializationCodecFactory: " + codecFactory ) ; } } } addCodecFactory ( config , codecFactory ) ; } protected MinaEndpoint createDatagramEndpoint ( String uri , URI connectUri , Map parameters ) { IoAcceptor acceptor = new DatagramAcceptor ( ) ; SocketAddress address = new InetSocketAddress ( connectUri . getHost ( ) , connectUri . getPort ( ) ) ; IoConnector connector = new DatagramConnector ( ) ; if ( transferExchange ) { throw new IllegalArgumentException ( "transferExchange=true is not supported for datagram protocol" ) ; } DatagramConnectorConfig connectorConfig = new DatagramConnectorConfig ( ) ; configureDataGramCodecFactory ( "MinaProducer" , connectorConfig , encoding , codec ) ; if ( minaLogger ) { connectorConfig . getFilterChain ( ) . addLast ( "logger" , new LoggingFilter ( ) ) ; } long connectTimeout = timeout > 0 ? timeout : DEFAULT_CONNECT_TIMEOUT ; connectorConfig . setConnectTimeout ( ( int ) ( connectTimeout / 1000 ) ) ; DatagramAcceptorConfig acceptorConfig = new DatagramAcceptorConfig ( ) ; configureDataGramCodecFactory ( "MinaConsumer" , acceptorConfig , encoding , codec ) ; acceptorConfig . setDisconnectOnUnbind ( true ) ; if ( minaLogger ) { acceptorConfig . getFilterChain ( ) . addLast ( "logger" , new LoggingFilter ( ) ) ; } MinaEndpoint endpoint = new MinaEndpoint ( uri , this , address , acceptor , acceptorConfig , connector , connectorConfig , lazySessionCreation , timeout , transferExchange , sync ) ; if ( encoding != null ) { endpoint . setCharsetName ( getEncodingParameter ( "MinaProducer" , encoding ) . name ( ) ) ; } if ( sync ) { endpoint . setExchangePattern ( ExchangePattern . InOut ) ; } else { endpoint . setExchangePattern ( ExchangePattern . InOnly ) ; } return endpoint ; } private static Charset getEncodingParameter ( String type , String encoding ) { if ( encoding == null ) { encoding = Charset . defaultCharset ( ) . name ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( type + ": No encoding parameter using default charset: " + encoding ) ; } } if ( ! Charset . isSupported ( encoding ) ) { throw new IllegalArgumentException ( "The encoding: " + encoding + " is not supported" ) ; } return Charset . forName ( encoding ) ; } protected void configureDataGramCodecFactory ( String type , IoServiceConfig config , String encoding , String codec ) { ProtocolCodecFactory codecFactory = getCodecFactory ( type , codec ) ; if ( codecFactory == null ) { codecFactory = new ProtocolCodecFactory ( ) { public ProtocolEncoder getEncoder ( ) throws Exception { return new ProtocolEncoder ( ) { public void encode ( IoSession session , Object message , ProtocolEncoderOutput out ) throws Exception { ByteBuffer buf = toByteBuffer ( message ) ; buf . flip ( ) ; out . write ( buf ) ; } public void dispose ( IoSession session ) throws Exception { } } ; } public ProtocolDecoder getDecoder ( ) throws Exception { return new ProtocolDecoder ( ) { public void decode ( IoSession session , ByteBuffer in , ProtocolDecoderOutput out ) throws Exception { in . acquire ( ) ; out . write ( in ) ; } public void finishDecode ( IoSession session , ProtocolDecoderOutput out ) throws Exception { } public void dispose ( IoSession session ) throws Exception { } } ; } } ; Charset charset = getEncodingParameter ( type , encoding ) ; encoder = charset . newEncoder ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( type + ": Using CodecFactory: " + codecFactory + " using encoding: " + charset ) ; } } addCodecFactory ( config , codecFactory ) ; } protected ByteBuffer toByteBuffer ( Object message ) throws CharacterCodingException { ByteBuffer answer = null ; try { answer = convertTo ( ByteBuffer . class , message ) ; } catch ( NoTypeConversionAvailableException e ) { String value = convertTo ( String . class , message ) ; answer = ByteBuffer . allocate ( value . length ( ) ) . setAutoExpand ( true ) ; answer . putString ( value , encoder ) ; } return answer ; } protected ProtocolCodecFactory getCodecFactory ( String type , String codec ) { ProtocolCodecFactory codecFactory = null ; if ( codec != null ) { codecFactory = getCamelContext ( ) . getRegistry ( ) . lookup ( codec , ProtocolCodecFactory . class ) ; if ( codecFactory == null ) { throw new IllegalArgumentException ( "Codec " + codec + " not found in registry." ) ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( type + ": Using custom CodecFactory: " + codecFactory ) ; } } return codecFactory ; } protected void addCodecFactory ( IoServiceConfig config , ProtocolCodecFactory codecFactory ) { config . getFilterChain ( ) . addLast ( "codec" , new ProtocolCodecFilter ( codecFactory ) ) ; } private LineDelimiter getLineDelimiterParameter ( ) { if ( textlineDelimiter == null ) { return LineDelimiter . DEFAULT ; } switch ( textlineDelimiter ) { case DEFAULT : return LineDelimiter . DEFAULT ; case AUTO : return LineDelimiter . AUTO ; case UNIX : return LineDelimiter . UNIX ; case WINDOWS : return LineDelimiter . WINDOWS ; case MAC : return LineDelimiter . MAC ; default : throw new IllegalArgumentException ( "Unknown textline delimiter: " + textlineDelimiter ) ; } } public boolean isSync ( ) { return sync ; } public void setSync ( boolean sync ) { this . sync = sync ; } public boolean isTextline ( ) { return textline ; } public void setTextline ( boolean textline ) { this . textline = textline ; } public TextLineDelimiter getTextlineDelimiter ( ) { return textlineDelimiter ; } public void setTextlineDelimiter ( TextLineDelimiter textlineDelimiter ) { this . textlineDelimiter = textlineDelimiter ; } public String getCodec ( ) { return codec ; } public void setCodec ( String codec ) { this . codec = codec ; } public String getEncoding ( ) { return encoding ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public long getTimeout ( ) { return timeout ; } public void setTimeout ( long timeout ) { this . timeout = timeout ; } public boolean isLazySessionCreation ( ) { return lazySessionCreation ; } public void setLazySessionCreation ( boolean lazySessionCreation ) { this . lazySessionCreation = lazySessionCreation ; } public boolean isTransferExchange ( ) { return transferExchange ; } public void setTransferExchange ( boolean transferExchange ) { this . transferExchange = transferExchange ; } public boolean isMinaLogger ( ) { return minaLogger ; } public void setMinaLogger ( boolean minaLogger ) { this . minaLogger = minaLogger ; } } 	0	['32', '3', '0', '38', '97', '320', '3', '37', '20', '0.85483871', '834', '1', '1', '0.546875', '0.175953079', '2', '3', '24.6875', '7', '1.7813', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . LoopProcessor ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "loop" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class LoopType extends ExpressionNode implements Block { public LoopType ( ) { } public LoopType ( Expression expression ) { super ( expression ) ; } public LoopType ( ExpressionType expression ) { super ( expression ) ; } public void setExpression ( Expression < ? > expr ) { if ( expr != null ) { setExpression ( new ExpressionType ( expr ) ) ; } } @ Override public String toString ( ) { return "Loop[" + getExpression ( ) + " -> " + getOutputs ( ) + "]" ; } @ Override public String getShortName ( ) { return "loop" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { return new LoopProcessor ( getExpression ( ) . createExpression ( routeContext ) , routeContext . createProcessor ( this ) ) ; } } 	0	['7', '4', '0', '9', '21', '21', '2', '8', '7', '2', '57', '0', '0', '0.978723404', '0.392857143', '3', '4', '7.142857143', '2', '0.7143', '0']
package org . apache . camel . bam ; import java . util . Date ; import org . apache . camel . Endpoint ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . bam . model . ActivityState ; import org . apache . camel . bam . model . ProcessInstance ; import org . apache . camel . bam . rules . ActivityRules ; import org . apache . camel . builder . ProcessorFactory ; import org . apache . camel . impl . EventDrivenConsumerRoute ; public class ActivityBuilder implements ProcessorFactory { private ProcessBuilder processBuilder ; private Endpoint endpoint ; private ActivityRules activityRules ; private Expression correlationExpression ; public ActivityBuilder ( ProcessBuilder processBuilder , Endpoint endpoint ) { this . processBuilder = processBuilder ; this . endpoint = endpoint ; this . activityRules = new ActivityRules ( processBuilder ) ; this . activityRules . setActivityName ( endpoint . getEndpointUri ( ) ) ; } public Endpoint getEndpoint ( ) { return endpoint ; } public Processor createProcessor ( ) throws Exception { return processBuilder . createActivityProcessor ( this ) ; } public Route createRoute ( ) throws Exception { Processor processor = createProcessor ( ) ; if ( processor == null ) { throw new IllegalArgumentException ( "No processor created for ActivityBuilder: " + this ) ; } return new EventDrivenConsumerRoute ( getEndpoint ( ) , processor ) ; } public ActivityBuilder correlate ( Expression correlationExpression ) { this . correlationExpression = correlationExpression ; return this ; } public ActivityBuilder name ( String name ) { activityRules . setActivityName ( name ) ; return this ; } public TimeExpression starts ( ) { return new TimeExpression ( this , ActivityLifecycle . Started ) { public Date evaluate ( ProcessInstance instance , ActivityState state ) { return state . getTimeStarted ( ) ; } } ; } public TimeExpression completes ( ) { return new TimeExpression ( this , ActivityLifecycle . Completed ) { public Date evaluate ( ProcessInstance instance , ActivityState state ) { return state . getTimeCompleted ( ) ; } } ; } public Expression getCorrelationExpression ( ) { return correlationExpression ; } public ActivityRules getActivityRules ( ) { return activityRules ; } public ProcessBuilder getProcessBuilder ( ) { return processBuilder ; } } 	0	['11', '1', '0', '13', '24', '39', '5', '12', '11', '0.8', '101', '1', '4', '0', '0.272727273', '0', '0', '7.818181818', '1', '0.9091', '0']
@ javax . xml . bind . annotation . XmlSchema ( namespace = "http://activemq.apache.org/camel/schema/spring" , elementFormDefault = javax . xml . bind . annotation . XmlNsForm . QUALIFIED ) package org . apache . camel . model . language ; 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . component . seda ; import java . util . List ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . impl . PollingConsumerSupport ; @ Deprecated public class ListPollingConsumer extends PollingConsumerSupport { private final List < Exchange > exchanges ; public ListPollingConsumer ( Endpoint endpoint , List < Exchange > exchanges ) { super ( endpoint ) ; this . exchanges = exchanges ; } public Exchange receive ( ) { return receiveNoWait ( ) ; } public Exchange receiveNoWait ( ) { if ( exchanges . isEmpty ( ) ) { return null ; } else { return exchanges . remove ( 0 ) ; } } public Exchange receive ( long timeout ) { return receiveNoWait ( ) ; } protected void doStart ( ) throws Exception { } protected void doStop ( ) throws Exception { } } 	0	['6', '3', '0', '3', '9', '13', '0', '3', '4', '0.4', '34', '1', '0', '0.791666667', '0.375', '1', '1', '4.5', '2', '1', '0']
package org . apache . camel . component . irc ; import org . apache . camel . CamelContext ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; public class IrcExchange extends DefaultExchange { private IrcBinding binding ; public IrcExchange ( CamelContext context , ExchangePattern pattern , IrcBinding binding ) { super ( context , pattern ) ; this . binding = binding ; } public IrcExchange ( CamelContext context , ExchangePattern pattern , IrcBinding binding , IrcMessage inMessage ) { this ( context , pattern , binding ) ; setIn ( inMessage ) ; } public IrcExchange ( DefaultExchange parent , IrcBinding binding ) { super ( parent ) ; this . binding = binding ; } public IrcBinding getBinding ( ) { return binding ; } public void setBinding ( IrcBinding binding ) { this . binding = binding ; } @ Override public IrcMessage getIn ( ) { return ( IrcMessage ) super . getIn ( ) ; } @ Override public IrcMessage getOut ( ) { return ( IrcMessage ) super . getOut ( ) ; } @ Override public IrcMessage getOut ( boolean lazyCreate ) { return ( IrcMessage ) super . getOut ( lazyCreate ) ; } @ Override public IrcMessage getFault ( ) { return ( IrcMessage ) super . getFault ( ) ; } @ Override public IrcExchange newInstance ( ) { return new IrcExchange ( this , getBinding ( ) ) ; } @ Override protected IrcMessage createInMessage ( ) { return new IrcMessage ( ) ; } @ Override protected IrcMessage createOutMessage ( ) { return new IrcMessage ( ) ; } } 	0	['19', '2', '0', '9', '20', '159', '4', '7', '15', '0.666666667', '105', '1', '1', '0.703703704', '0.233082707', '1', '3', '4.473684211', '1', '0.8421', '0']
package org . apache . camel . language . jxpath ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import org . apache . camel . language . LanguageAnnotation ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . PARAMETER } ) @ LanguageAnnotation ( language = "jxpath" ) public @ interface JXPath { String value ( ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . model . language ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlID ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import javax . xml . bind . annotation . XmlType ; import javax . xml . bind . annotation . XmlValue ; import javax . xml . bind . annotation . adapters . CollapsedStringAdapter ; import javax . xml . bind . annotation . adapters . XmlJavaTypeAdapter ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . builder . ExpressionClause ; import org . apache . camel . impl . DefaultRouteContext ; import org . apache . camel . spi . Language ; import org . apache . camel . spi . RouteContext ; import org . apache . camel . util . CollectionStringBuffer ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . camel . util . ObjectHelper ; @ XmlRootElement @ XmlType ( name = "expressionType" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ExpressionType implements Expression < Exchange > , Predicate < Exchange > { @ XmlAttribute @ XmlJavaTypeAdapter ( CollapsedStringAdapter . class ) @ XmlID private String id ; @ XmlValue private String expression ; @ XmlTransient private Predicate predicate ; @ XmlTransient private Expression expressionValue ; @ XmlTransient private ExpressionType expressionType ; public ExpressionType ( ) { } public ExpressionType ( String expression ) { this . expression = expression ; } public ExpressionType ( Predicate predicate ) { this . predicate = predicate ; } public ExpressionType ( Expression expression ) { this . expressionValue = expression ; } public static String getLabel ( List < ExpressionType > expressions ) { CollectionStringBuffer buffer = new CollectionStringBuffer ( ) ; for ( ExpressionType expression : expressions ) { buffer . append ( expression . getLabel ( ) ) ; } return buffer . toString ( ) ; } @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; if ( getLanguage ( ) != null ) { sb . append ( getLanguage ( ) + "{" ) ; } if ( getExpression ( ) != null ) { sb . append ( getExpression ( ) ) ; } if ( getPredicate ( ) != null ) { sb . append ( getPredicate ( ) . toString ( ) ) ; } if ( getExpressionValue ( ) != null ) { sb . append ( getExpressionValue ( ) . toString ( ) ) ; } if ( getLanguage ( ) != null ) { sb . append ( "}" ) ; } return sb . toString ( ) ; } public Object evaluate ( Exchange exchange ) { if ( expressionValue == null ) { RouteContext routeContext = new DefaultRouteContext ( exchange . getContext ( ) ) ; expressionValue = createExpression ( routeContext ) ; } ObjectHelper . notNull ( expressionValue , "expressionValue" ) ; return expressionValue . evaluate ( exchange ) ; } public void assertMatches ( String text , Exchange exchange ) throws AssertionError { if ( ! matches ( exchange ) ) { throw new AssertionError ( text + getExpression ( ) + " for exchange: " + exchange ) ; } } public boolean matches ( Exchange exchange ) { if ( predicate == null ) { RouteContext routeContext = new DefaultRouteContext ( exchange . getContext ( ) ) ; predicate = createPredicate ( routeContext ) ; } ObjectHelper . notNull ( predicate , "predicate" ) ; return predicate . matches ( exchange ) ; } public String getLanguage ( ) { return "" ; } public Predicate < Exchange > createPredicate ( RouteContext routeContext ) { if ( predicate == null ) { if ( expressionType != null ) { predicate = expressionType . createPredicate ( routeContext ) ; } else { CamelContext camelContext = routeContext . getCamelContext ( ) ; Language language = camelContext . resolveLanguage ( getLanguage ( ) ) ; predicate = language . createPredicate ( getExpression ( ) ) ; configurePredicate ( routeContext , predicate ) ; } } return predicate ; } public Expression createExpression ( RouteContext routeContext ) { if ( expressionValue == null ) { if ( expressionType != null ) { expressionValue = expressionType . createExpression ( routeContext ) ; } else { CamelContext camelContext = routeContext . getCamelContext ( ) ; Language language = camelContext . resolveLanguage ( getLanguage ( ) ) ; expressionValue = language . createExpression ( getExpression ( ) ) ; configureExpression ( routeContext , expressionValue ) ; } } return expressionValue ; } public String getExpression ( ) { return expression ; } public void setExpression ( String expression ) { this . expression = expression ; } public String getId ( ) { return id ; } public void setId ( String value ) { this . id = value ; } public Predicate getPredicate ( ) { return predicate ; } public Expression getExpressionValue ( ) { return expressionValue ; } protected void setExpressionValue ( Expression expressionValue ) { this . expressionValue = expressionValue ; } public String getLabel ( ) { String language = getExpression ( ) ; if ( ObjectHelper . isNullOrBlank ( language ) ) { Predicate predicate = getPredicate ( ) ; if ( predicate != null ) { return predicate . toString ( ) ; } Expression expressionValue = getExpressionValue ( ) ; if ( expressionValue != null ) { return expressionValue . toString ( ) ; } } else { return language ; } return "" ; } protected void setExpressionType ( ExpressionType expressionType ) { this . expressionType = expressionType ; } protected void configurePredicate ( RouteContext routeContext , Predicate predicate ) { } protected void configureExpression ( RouteContext routeContext , Expression expression ) { } protected void setProperty ( Object bean , String name , Object value ) { try { IntrospectionSupport . setProperty ( bean , name , value ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Failed to set property " + name + " on " + bean + ". Reason: " + e , e ) ; } } } 	0	['26', '1', '17', '49', '51', '279', '39', '10', '21', '0.776', '366', '1', '3', '0', '0.205128205', '0', '0', '12.88461538', '6', '1.3846', '0']
package org . apache . camel . spring . util ; import java . lang . annotation . Annotation ; import java . lang . reflect . Field ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; public class ReflectionUtils extends org . springframework . util . ReflectionUtils { public static < T extends Annotation > void callLifecycleMethod ( final Object bean , final Class < T > annotation ) { ReflectionUtils . doWithMethods ( bean . getClass ( ) , new ReflectionUtils . MethodCallback ( ) { public void doWith ( Method method ) throws IllegalArgumentException , IllegalAccessException { if ( method . getAnnotation ( annotation ) != null ) { try { method . invoke ( bean , ( Object [ ] ) null ) ; } catch ( IllegalArgumentException ex ) { throw new IllegalStateException ( "Failure to invoke " + method + " on " + bean . getClass ( ) + ": args=[]" , ex ) ; } catch ( IllegalAccessException ex ) { throw new UnsupportedOperationException ( ex . toString ( ) ) ; } catch ( InvocationTargetException ex ) { throw new UnsupportedOperationException ( "PostConstruct method on bean threw exception" , ex . getTargetException ( ) ) ; } } } } ) ; } public static void setField ( Field f , Object instance , Object value ) { try { boolean oldAccessible = f . isAccessible ( ) ; boolean shouldSetAccessible = ! Modifier . isPublic ( f . getModifiers ( ) ) && ! oldAccessible ; if ( shouldSetAccessible ) { f . setAccessible ( true ) ; } f . set ( instance , value ) ; if ( shouldSetAccessible ) { f . setAccessible ( oldAccessible ) ; } } catch ( IllegalArgumentException ex ) { throw new UnsupportedOperationException ( "Cannot inject value of class '" + value . getClass ( ) + "' into " + f ) ; } catch ( IllegalAccessException ex ) { ReflectionUtils . handleReflectionException ( ex ) ; } } } 	0	['3', '0', '0', '4', '18', '3', '1', '3', '3', '2', '65', '0', '0', '0', '0.416666667', '0', '0', '20.66666667', '4', '1.6667', '0']
package org . apache . camel ; public interface Predicate < E > { boolean matches ( E exchange ) ; void assertMatches ( String text , E exchange ) throws AssertionError ; } 	0	['2', '1', '0', '60', '2', '1', '60', '0', '2', '2', '2', '0', '0', '0', '0.833333333', '0', '0', '0', '1', '1', '0']
package org . apache . camel . language . ognl ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import org . apache . camel . language . LanguageAnnotation ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . PARAMETER } ) @ LanguageAnnotation ( language = "ognl" ) public @ interface OGNL { String value ( ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . processor . idempotent . jpa ; import javax . persistence . Entity ; import javax . persistence . GeneratedValue ; import javax . persistence . Id ; import javax . persistence . Table ; import javax . persistence . UniqueConstraint ; @ Entity @ Table ( name = "MESSAGEPROCESSED" , uniqueConstraints = @ UniqueConstraint ( columnNames = { "processorName" , "messageId" } ) ) public class MessageProcessed { private Long id ; private String messageId ; private String processorName ; @ Override public String toString ( ) { return "MessageProcessed[processorName: " + getProcessorName ( ) + " messageId: " + getMessageId ( ) + "]" ; } @ Id @ GeneratedValue public Long getId ( ) { return id ; } public void setId ( Long id ) { this . id = id ; } public String getMessageId ( ) { return messageId ; } public void setMessageId ( String messageId ) { this . messageId = messageId ; } public String getProcessorName ( ) { return processorName ; } public void setProcessorName ( String processorName ) { this . processorName = processorName ; } } 	0	['8', '1', '0', '1', '12', '22', '1', '0', '8', '0.761904762', '52', '1', '0', '0', '0.458333333', '0', '0', '5.125', '1', '0.875', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlElements ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Processor ; import org . apache . camel . model . dataformat . ArtixDSDataFormat ; import org . apache . camel . model . dataformat . CsvDataFormat ; import org . apache . camel . model . dataformat . DataFormatType ; import org . apache . camel . model . dataformat . FlatpackDataFormat ; import org . apache . camel . model . dataformat . HL7DataFormat ; import org . apache . camel . model . dataformat . JaxbDataFormat ; import org . apache . camel . model . dataformat . SerializationDataFormat ; import org . apache . camel . model . dataformat . StringDataFormat ; import org . apache . camel . model . dataformat . TidyMarkupDataFormat ; import org . apache . camel . model . dataformat . XMLBeansDataFormat ; import org . apache . camel . model . dataformat . XStreamDataFormat ; import org . apache . camel . model . dataformat . ZipDataFormat ; import org . apache . camel . processor . UnmarshalProcessor ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "unmarshal" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class UnmarshalType extends OutputType < ProcessorType > { @ XmlAttribute ( required = false ) private String ref ; @ XmlElements ( { @ XmlElement ( required = false , name = "artixDS" , type = ArtixDSDataFormat . class ) , @ XmlElement ( required = false , name = "csv" , type = CsvDataFormat . class ) , @ XmlElement ( required = false , name = "flatpack" , type = FlatpackDataFormat . class ) , @ XmlElement ( required = false , name = "hl7" , type = HL7DataFormat . class ) , @ XmlElement ( required = false , name = "jaxb" , type = JaxbDataFormat . class ) , @ XmlElement ( required = false , name = "serialization" , type = SerializationDataFormat . class ) , @ XmlElement ( required = false , name = "string" , type = StringDataFormat . class ) , @ XmlElement ( required = false , name = "tidyMarkup" , type = TidyMarkupDataFormat . class ) , @ XmlElement ( required = false , name = "xmlBeans" , type = XMLBeansDataFormat . class ) , @ XmlElement ( required = false , name = "xstream" , type = XStreamDataFormat . class ) , @ XmlElement ( required = false , name = "zip" , type = ZipDataFormat . class ) } ) private DataFormatType dataFormatType ; public UnmarshalType ( ) { } public UnmarshalType ( DataFormatType dataFormatType ) { this . dataFormatType = dataFormatType ; } public UnmarshalType ( String ref ) { this . ref = ref ; } @ Override public String toString ( ) { if ( dataFormatType != null ) { return "Marshal[" + dataFormatType + "]" ; } else { return "Marshal[ref: " + ref + "]" ; } } @ Override public String getShortName ( ) { return "unmarshal" ; } public String getRef ( ) { return ref ; } public void setRef ( String ref ) { this . ref = ref ; } public DataFormatType getDataFormatType ( ) { return dataFormatType ; } public void setDataFormatType ( DataFormatType dataFormatType ) { this . dataFormatType = dataFormatType ; } @ Override public Processor createProcessor ( RouteContext routeContext ) { DataFormat dataFormat = DataFormatType . getDataFormat ( routeContext , getDataFormatType ( ) , ref ) ; return new UnmarshalProcessor ( dataFormat ) ; } } 	0	['10', '4', '0', '7', '17', '13', '1', '6', '10', '0.555555556', '82', '1', '1', '0.962365591', '0.375', '1', '1', '7', '2', '0.8', '0']
package org . apache . camel . spring . spi ; import org . apache . camel . Processor ; import org . apache . camel . builder . ErrorHandlerBuilder ; import org . apache . camel . builder . ErrorHandlerBuilderSupport ; import org . apache . camel . processor . DelayPolicy ; import org . apache . camel . processor . RedeliveryPolicy ; import org . apache . camel . spi . RouteContext ; import org . apache . camel . util . ObjectHelper ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . transaction . support . TransactionTemplate ; public class TransactionErrorHandlerBuilder extends ErrorHandlerBuilderSupport implements Cloneable , InitializingBean { private TransactionTemplate transactionTemplate ; private RedeliveryPolicy redeliveryPolicy = new RedeliveryPolicy ( ) ; private DelayPolicy delayPolicy = new DelayPolicy ( ) ; public TransactionErrorHandlerBuilder ( ) { } public TransactionTemplate getTransactionTemplate ( ) { return transactionTemplate ; } public void setTransactionTemplate ( TransactionTemplate transactionTemplate ) { this . transactionTemplate = transactionTemplate ; } public RedeliveryPolicy getRedeliveryPolicy ( ) { return redeliveryPolicy ; } public void setRedeliveryPolicy ( RedeliveryPolicy redeliveryPolicy ) { this . redeliveryPolicy = redeliveryPolicy ; } public DelayPolicy getDelayPolicy ( ) { return delayPolicy ; } public void setDelayPolicy ( DelayPolicy delayPolicy ) { this . delayPolicy = delayPolicy ; } public ErrorHandlerBuilder copy ( ) { try { return ( ErrorHandlerBuilder ) clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new Error ( "Clone should be supported: " + e , e ) ; } } public Processor createErrorHandler ( RouteContext routeContext , Processor processor ) throws Exception { return new TransactionInterceptor ( processor , transactionTemplate , delayPolicy ) ; } public void afterPropertiesSet ( ) throws Exception { ObjectHelper . notNull ( transactionTemplate , "transactionTemplate" ) ; } public TransactionErrorHandlerBuilder backOffMultiplier ( double backOffMultiplier ) { getRedeliveryPolicy ( ) . backOffMultiplier ( backOffMultiplier ) ; return this ; } public TransactionErrorHandlerBuilder collisionAvoidancePercent ( short collisionAvoidancePercent ) { getRedeliveryPolicy ( ) . collisionAvoidancePercent ( collisionAvoidancePercent ) ; return this ; } public TransactionErrorHandlerBuilder initialRedeliveryDelay ( long initialRedeliveryDelay ) { getDelayPolicy ( ) . delay ( initialRedeliveryDelay ) ; return this ; } public TransactionErrorHandlerBuilder maximumRedeliveries ( int maximumRedeliveries ) { getRedeliveryPolicy ( ) . maximumRedeliveries ( maximumRedeliveries ) ; return this ; } public TransactionErrorHandlerBuilder maximumRedeliveryDelay ( long maximumRedeliveryDelay ) { getRedeliveryPolicy ( ) . maximumRedeliveryDelay ( maximumRedeliveryDelay ) ; return this ; } public TransactionErrorHandlerBuilder useCollisionAvoidance ( ) { getRedeliveryPolicy ( ) . useCollisionAvoidance ( ) ; return this ; } public TransactionErrorHandlerBuilder useExponentialBackOff ( ) { getRedeliveryPolicy ( ) . useExponentialBackOff ( ) ; return this ; } public TransactionErrorHandlerBuilder delay ( long delay ) { getDelayPolicy ( ) . delay ( delay ) ; return this ; } } 	0	['18', '2', '0', '11', '36', '123', '1', '10', '18', '0.68627451', '142', '1', '2', '0.19047619', '0.161111111', '0', '0', '6.722222222', '1', '0.9444', '0']
package org . apache . camel . component . cxf ; import java . lang . reflect . Proxy ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import javax . xml . namespace . QName ; import org . apache . camel . CamelException ; import org . apache . camel . Exchange ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . component . cxf . feature . MessageDataFormatFeature ; import org . apache . camel . component . cxf . feature . PayLoadDataFormatFeature ; import org . apache . camel . component . cxf . invoker . CxfClient ; import org . apache . camel . component . cxf . invoker . CxfClientFactoryBean ; import org . apache . camel . component . cxf . invoker . InvokingContext ; import org . apache . camel . component . cxf . invoker . InvokingContextFactory ; import org . apache . camel . component . cxf . spring . CxfEndpointBean ; import org . apache . camel . component . cxf . util . CxfEndpointUtils ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . util . ObjectHelper ; import org . apache . cxf . Bus ; import org . apache . cxf . BusFactory ; import org . apache . cxf . bus . spring . SpringBusFactory ; import org . apache . cxf . common . classloader . ClassLoaderUtils ; import org . apache . cxf . configuration . Configurer ; import org . apache . cxf . configuration . spring . ConfigurerImpl ; import org . apache . cxf . endpoint . Client ; import org . apache . cxf . endpoint . Endpoint ; import org . apache . cxf . frontend . ClientProxy ; import org . apache . cxf . frontend . ClientProxyFactoryBean ; import org . apache . cxf . jaxws . JaxWsProxyFactoryBean ; import org . apache . cxf . message . ExchangeImpl ; import org . apache . cxf . message . Message ; import org . apache . cxf . message . MessageContentsList ; import org . apache . cxf . message . MessageImpl ; import org . apache . cxf . service . model . BindingOperationInfo ; public class CxfProducer extends DefaultProducer < CxfExchange > { private CxfEndpoint endpoint ; private Client client ; private DataFormat dataFormat ; public CxfProducer ( CxfEndpoint endpoint ) throws Exception { super ( endpoint ) ; this . endpoint = endpoint ; dataFormat = CxfEndpointUtils . getDataFormat ( endpoint ) ; if ( dataFormat . equals ( DataFormat . POJO ) ) { client = createClientFromClientFactoryBean ( null ) ; } else { client = createClientForStreamMessage ( ) ; } } private Client createClientForStreamMessage ( ) throws Exception { CxfClientFactoryBean cfb = new CxfClientFactoryBean ( ) ; Class serviceClass = null ; try { serviceClass = CxfEndpointUtils . getServiceClass ( endpoint ) ; } catch ( ClassNotFoundException e ) { throw new CamelException ( e ) ; } boolean jsr181Enabled = CxfEndpointUtils . hasWebServiceAnnotation ( serviceClass ) ; cfb . setJSR181Enabled ( jsr181Enabled ) ; return createClientFromClientFactoryBean ( jsr181Enabled ? new JaxWsProxyFactoryBean ( cfb ) : new ClientProxyFactoryBean ( cfb ) ) ; } private Client createClientFromClientFactoryBean ( ClientProxyFactoryBean cfb ) throws Exception { Bus bus = null ; if ( endpoint . getApplicationContext ( ) != null ) { if ( endpoint . getCxfEndpointBean ( ) != null ) { bus = endpoint . getCxfEndpointBean ( ) . getBus ( ) ; } else { SpringBusFactory busFactory = new SpringBusFactory ( endpoint . getApplicationContext ( ) ) ; bus = busFactory . createBus ( ) ; } if ( CxfEndpointUtils . getSetDefaultBus ( endpoint ) ) { BusFactory . setDefaultBus ( bus ) ; } } else { bus = BusFactory . getDefaultBus ( ) ; } Class serviceClass = CxfEndpointUtils . getServiceClass ( endpoint ) ; if ( cfb == null ) { cfb = CxfEndpointUtils . getClientFactoryBean ( serviceClass ) ; } if ( endpoint . isSpringContextEndpoint ( ) ) { endpoint . configure ( cfb ) ; } else { cfb . setAddress ( endpoint . getAddress ( ) ) ; if ( null != endpoint . getServiceClass ( ) ) { cfb . setServiceClass ( ObjectHelper . loadClass ( endpoint . getServiceClass ( ) ) ) ; } if ( null != endpoint . getWsdlURL ( ) ) { cfb . setWsdlURL ( endpoint . getWsdlURL ( ) ) ; } if ( endpoint . getWsdlURL ( ) != null ) { cfb . setWsdlURL ( endpoint . getWsdlURL ( ) ) ; } } cfb . setServiceClass ( serviceClass ) ; if ( CxfEndpointUtils . getServiceName ( endpoint ) != null ) { cfb . setServiceName ( CxfEndpointUtils . getServiceName ( endpoint ) ) ; } if ( CxfEndpointUtils . getPortName ( endpoint ) != null ) { cfb . setEndpointName ( CxfEndpointUtils . getPortName ( endpoint ) ) ; } if ( dataFormat . equals ( DataFormat . MESSAGE ) ) { cfb . getFeatures ( ) . add ( new MessageDataFormatFeature ( ) ) ; } else if ( dataFormat . equals ( DataFormat . PAYLOAD ) ) { cfb . getFeatures ( ) . add ( new PayLoadDataFormatFeature ( ) ) ; } cfb . setBus ( bus ) ; return ( ( ClientProxy ) Proxy . getInvocationHandler ( cfb . create ( ) ) ) . getClient ( ) ; } public void process ( Exchange exchange ) throws Exception { CxfExchange cxfExchange = endpoint . createExchange ( exchange ) ; process ( cxfExchange ) ; exchange . copyFrom ( cxfExchange ) ; } public void process ( CxfExchange exchange ) throws Exception { Message inMessage = CxfBinding . createCxfMessage ( endpoint . getHeaderFilterStrategy ( ) , exchange ) ; exchange . setProperty ( CxfExchange . DATA_FORMAT , dataFormat ) ; if ( dataFormat . equals ( DataFormat . POJO ) ) { List parameters = inMessage . getContent ( List . class ) ; if ( parameters == null ) { parameters = new ArrayList ( ) ; } String operationName = exchange . getIn ( ) . getHeader ( CxfConstants . OPERATION_NAME , String . class ) ; String operationNameSpace = exchange . getIn ( ) . getHeader ( CxfConstants . OPERATION_NAMESPACE , String . class ) ; Map < String , Object > context = new HashMap < String , Object > ( ) ; Map < String , Object > responseContext = CxfBinding . propogateContext ( inMessage , context ) ; Message response = new MessageImpl ( ) ; if ( operationName != null ) { Object [ ] result = null ; result = invokeClient ( operationNameSpace , operationName , parameters , context ) ; if ( result != null ) { response . setContent ( List . class , new MessageContentsList ( result ) ) ; } else { response . setContent ( List . class , new MessageContentsList ( ) ) ; } CxfBinding . storeCXfResponseContext ( response , responseContext ) ; CxfBinding . storeCxfResponse ( endpoint . getHeaderFilterStrategy ( ) , exchange , response ) ; } else { throw new RuntimeCamelException ( "Can't find the operation name in the message!" ) ; } } else { org . apache . cxf . message . Exchange ex = exchange . getExchange ( ) ; if ( ex == null ) { ex = ( org . apache . cxf . message . Exchange ) exchange . getProperty ( CxfConstants . CXF_EXCHANGE ) ; exchange . setExchange ( ex ) ; } if ( ex == null ) { ex = new ExchangeImpl ( ) ; exchange . setExchange ( ex ) ; } ObjectHelper . notNull ( ex , "exchange" ) ; InvokingContext invokingContext = ex . get ( InvokingContext . class ) ; if ( invokingContext == null ) { invokingContext = InvokingContextFactory . createContext ( dataFormat ) ; ex . put ( InvokingContext . class , invokingContext ) ; } Map < Class , Object > params = invokingContext . getRequestContent ( inMessage ) ; CxfClient cxfClient = ( CxfClient ) client ; BindingOperationInfo boi = ex . get ( BindingOperationInfo . class ) ; Message response = null ; if ( boi == null ) { response = new MessageImpl ( ) ; } else { Endpoint ep = ex . get ( Endpoint . class ) ; response = ep . getBinding ( ) . createMessage ( ) ; } response . setExchange ( ex ) ; Map < String , Object > context = new HashMap < String , Object > ( ) ; Map < String , Object > responseContext = CxfBinding . propogateContext ( inMessage , context ) ; Object result = cxfClient . dispatch ( params , context , ex ) ; ex . setOutMessage ( response ) ; invokingContext . setResponseContent ( response , result ) ; CxfBinding . storeCXfResponseContext ( response , responseContext ) ; CxfBinding . storeCxfResponse ( endpoint . getHeaderFilterStrategy ( ) , exchange , response ) ; } } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; } @ Override protected void doStop ( ) throws Exception { super . doStop ( ) ; } private Object [ ] invokeClient ( String operationNameSpace , String operationName , List parameters , Map < String , Object > context ) throws Exception { QName operationQName = null ; if ( operationNameSpace == null ) { operationQName = new QName ( client . getEndpoint ( ) . getService ( ) . getName ( ) . getNamespaceURI ( ) , operationName ) ; } else { operationQName = new QName ( operationNameSpace , operationName ) ; } BindingOperationInfo op = client . getEndpoint ( ) . getEndpointInfo ( ) . getBinding ( ) . getOperation ( operationQName ) ; if ( op == null ) { throw new RuntimeCamelException ( "No operation found in the CXF client, the operation is " + operationQName ) ; } if ( ! endpoint . isWrapped ( ) ) { if ( op . isUnwrappedCapable ( ) ) { op = op . getUnwrappedOperation ( ) ; } } Object [ ] result = client . invoke ( op , parameters . toArray ( ) , context ) ; return result ; } public Client getClient ( ) { return client ; } } 	0	['9', '3', '0', '40', '101', '0', '1', '40', '4', '0.458333333', '505', '1', '2', '0.724137931', '0.222222222', '1', '1', '54.77777778', '1', '0.8889', '0']
package org . apache . camel . component . mail ; import javax . mail . Message ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; public class MailExchange extends DefaultExchange { private MailBinding binding ; public MailExchange ( CamelContext context , ExchangePattern pattern , MailBinding binding ) { super ( context , pattern ) ; this . binding = binding ; } public MailExchange ( CamelContext context , ExchangePattern pattern , MailBinding binding , Message message ) { this ( context , pattern , binding ) ; setIn ( new MailMessage ( message ) ) ; } public MailExchange ( DefaultExchange parent , MailBinding binding ) { super ( parent ) ; this . binding = binding ; } @ Override public MailMessage getIn ( ) { return ( MailMessage ) super . getIn ( ) ; } @ Override public MailMessage getOut ( ) { return ( MailMessage ) super . getOut ( ) ; } @ Override public MailMessage getOut ( boolean lazyCreate ) { return ( MailMessage ) super . getOut ( lazyCreate ) ; } @ Override public MailMessage getFault ( ) { return ( MailMessage ) super . getFault ( ) ; } public MailBinding getBinding ( ) { return binding ; } @ Override public Exchange newInstance ( ) { return new MailExchange ( this , binding ) ; } @ Override protected MailMessage createInMessage ( ) { return new MailMessage ( ) ; } @ Override protected MailMessage createOutMessage ( ) { return new MailMessage ( ) ; } } 	0	['17', '2', '0', '9', '20', '124', '4', '7', '13', '0.75', '99', '1', '1', '0.730769231', '0.235294118', '1', '3', '4.764705882', '1', '0.8235', '0']
package org . apache . camel . component . spring . integration . adapter . config ; import org . w3c . dom . Attr ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . apache . camel . component . spring . integration . adapter . CamelSourceAdapter ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . xml . AbstractSimpleBeanDefinitionParser ; import org . springframework . beans . factory . xml . ParserContext ; public class CamelSourceAdpaterParser extends AbstractCamelContextBeanDefinitionParaser { @ Override protected Class < ? > getBeanClass ( Element element ) { return CamelSourceAdapter . class ; } } 	0	['2', '1', '0', '2', '3', '1', '1', '1', '1', '2', '7', '0', '0', '0.857142857', '0.75', '0', '0', '2.5', '1', '0.5', '0']
package org . apache . camel . language . bean ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . component . bean . BeanHolder ; import org . apache . camel . component . bean . BeanProcessor ; import org . apache . camel . component . bean . ConstantBeanHolder ; import org . apache . camel . component . bean . RegistryBean ; import org . apache . camel . impl . ExpressionSupport ; public class BeanExpression < E extends Exchange > extends ExpressionSupport < E > { private String beanName ; private String method ; private Object bean ; public BeanExpression ( Object bean , String method ) { this . bean = bean ; this . method = method ; } public BeanExpression ( String beanName , String method ) { this . beanName = beanName ; this . method = method ; } @ Override public String toString ( ) { return "BeanExpression[bean:" + ( bean == null ? beanName : bean ) + " method: " + method + "]" ; } protected String assertionFailureMessage ( E exchange ) { return "bean: " + beanName + " method: " + method ; } public Object evaluate ( E exchange ) { BeanHolder holder ; if ( bean == null ) { holder = new RegistryBean ( exchange . getContext ( ) , beanName ) ; } else { holder = new ConstantBeanHolder ( bean , exchange . getContext ( ) ) ; } BeanProcessor processor = new BeanProcessor ( holder ) ; if ( method != null ) { processor . setMethod ( method ) ; } try { Exchange newExchange = exchange . copy ( ) ; if ( ! newExchange . getPattern ( ) . isOutCapable ( ) ) { newExchange . setPattern ( ExchangePattern . InOut ) ; } processor . process ( newExchange ) ; return newExchange . getOut ( true ) . getBody ( ) ; } catch ( Exception e ) { throw new RuntimeBeanExpressionException ( exchange , beanName , method , e ) ; } } } 	0	['5', '2', '0', '12', '23', '0', '2', '10', '4', '0.25', '125', '1', '0', '0.625', '0.5', '1', '2', '23.4', '4', '1.4', '0']
package org . apache . camel . component . jpa ; public interface Callback < R , P > { R callback ( P parameter ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . file . remote ; import java . io . OutputStream ; import java . util . Map ; import org . apache . camel . impl . DefaultMessage ; public class RemoteFileMessage extends DefaultMessage { private OutputStream outputStream ; private String fullFileName ; private String fileName ; private String hostname ; private long fileLength ; public RemoteFileMessage ( ) { } public RemoteFileMessage ( String hostname , String fullFileName , String fileName , long fileLength , OutputStream outputStream ) { this . hostname = hostname ; this . fullFileName = fullFileName ; this . fileName = fileName ; this . fileLength = fileLength ; this . outputStream = outputStream ; } public String getHostname ( ) { return hostname ; } public void setHostname ( String hostname ) { this . hostname = hostname ; } public String getFullFileName ( ) { return fullFileName ; } public void setFullFileName ( String fullFileName ) { this . fullFileName = fullFileName ; } public OutputStream getOutputStream ( ) { return outputStream ; } public void setOutputStream ( OutputStream outputStream ) { this . outputStream = outputStream ; } @ Override public RemoteFileExchange getExchange ( ) { return ( RemoteFileExchange ) super . getExchange ( ) ; } @ Override protected Object createBody ( ) { if ( outputStream != null ) { return getExchange ( ) . getBinding ( ) . extractBodyFromOutputStream ( getExchange ( ) , outputStream ) ; } return null ; } @ Override public RemoteFileMessage newInstance ( ) { return new RemoteFileMessage ( ) ; } @ Override protected void populateInitialHeaders ( Map < String , Object > map ) { super . populateInitialHeaders ( map ) ; map . put ( "file.remote.host" , hostname ) ; map . put ( "file.remote.fullName" , fullFileName ) ; map . put ( "file.remote.name" , fileName ) ; map . put ( "CamelFileName" , fileName ) ; map . put ( "CamelFilePath" , fullFileName ) ; if ( fullFileName != null && fullFileName . indexOf ( "/" ) != - 1 ) { String parent = fullFileName . substring ( 0 , fullFileName . lastIndexOf ( "/" ) ) ; map . put ( "CamelFileParent" , parent ) ; } if ( fileLength > 0 ) { map . put ( "CamelFileLength" , new Long ( fileLength ) ) ; } } } 	0	['15', '3', '0', '5', '22', '71', '1', '5', '13', '0.842857143', '164', '1', '0', '0.729166667', '0.293333333', '2', '6', '9.6', '4', '1.1333', '0']
package org . apache . camel . impl ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . TypeConverter ; import org . apache . camel . impl . converter . TypeConverterRegistry ; import org . apache . camel . spi . Injector ; public class ReportingTypeConverterRegistry implements TypeConverterRegistry { private List < String > errors = new ArrayList < String > ( ) ; public String [ ] getErrors ( ) { return errors . toArray ( new String [ errors . size ( ) ] ) ; } public void addTypeConverter ( Class toType , Class fromType , TypeConverter typeConverter ) { if ( errors . size ( ) == 0 ) { errors . add ( "Method should not be invoked." ) ; } } public Injector getInjector ( ) { return null ; } } 	0	['4', '1', '0', '3', '9', '0', '0', '3', '4', '0.333333333', '34', '1', '0', '0', '0.5', '0', '0', '7.25', '2', '1', '0']
package org . apache . camel . component . spring . integration ; import java . util . Map ; import org . apache . camel . Exchange ; import org . springframework . integration . message . GenericMessage ; public final class SpringIntegrationBinding { private SpringIntegrationBinding ( ) { } public static org . springframework . integration . core . Message createSpringIntegrationMessage ( Exchange exchange ) { return createSpringIntegrationMessage ( exchange , null ) ; } @ SuppressWarnings ( "unchecked" ) public static org . springframework . integration . core . Message createSpringIntegrationMessage ( Exchange exchange , Map < String , Object > headers ) { org . apache . camel . Message message = exchange . getIn ( ) ; GenericMessage siMessage = new GenericMessage ( message . getBody ( ) , headers ) ; return siMessage ; } @ SuppressWarnings ( "unchecked" ) public static org . springframework . integration . core . Message storeToSpringIntegrationMessage ( org . apache . camel . Message message ) { GenericMessage siMessage = new GenericMessage ( message . getBody ( ) ) ; return siMessage ; } public static void storeToCamelMessage ( org . springframework . integration . core . Message siMessage , org . apache . camel . Message cMessage ) { cMessage . setBody ( siMessage . getPayload ( ) ) ; cMessage . setHeaders ( siMessage . getHeaders ( ) ) ; } } 	0	['5', '1', '0', '11', '14', '10', '6', '5', '4', '2', '41', '0', '0', '0', '0.28', '0', '0', '7.2', '1', '0.8', '0']
package org . apache . camel . component . cxf . interceptors ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import java . util . ResourceBundle ; import java . util . logging . Level ; import java . util . logging . Logger ; import javax . xml . namespace . QName ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . apache . cxf . bindings . xformat . XMLBindingMessageFormat ; import org . apache . cxf . common . i18n . BundleUtils ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . interceptor . Fault ; import org . apache . cxf . message . Exchange ; import org . apache . cxf . message . XMLMessage ; import org . apache . cxf . phase . Phase ; import org . apache . cxf . service . model . BindingMessageInfo ; import org . apache . cxf . service . model . MessagePartInfo ; public class XMLMessageOutInterceptor extends AbstractMessageOutInterceptor < XMLMessage > { private static final Logger LOG = LogUtils . getL7dLogger ( XMLMessageOutInterceptor . class ) ; public XMLMessageOutInterceptor ( ) { super ( Phase . PREPARE_SEND ) ; addAfter ( DOMOutInterceptor . class . getName ( ) ) ; } protected Logger getLogger ( ) { return LOG ; } @ SuppressWarnings ( "unchecked" ) public void handleMessage ( XMLMessage message ) throws Fault { Exchange exchange = message . getExchange ( ) ; BindingMessageInfo bmi = exchange . get ( BindingMessageInfo . class ) ; List < Element > payload = message . get ( List . class ) ; if ( bmi == null && payload . size ( ) > 1 ) { throw new Fault ( new org . apache . cxf . common . i18n . Message ( "NO_XML_ROOT_NODE" , LOG ) ) ; } if ( bmi != null ) { Element header = message . get ( Element . class ) ; if ( header != null ) { if ( LOG . isLoggable ( Level . INFO ) ) { LOG . info ( "DOMOutInterceptor Copy Message Part related Headers to Payload." ) ; } moveHeaderPartToPayload ( bmi , header , payload ) ; } XMLBindingMessageFormat msgFormat = bmi . getExtensor ( XMLBindingMessageFormat . class ) ; QName rootName = msgFormat != null ? msgFormat . getRootNode ( ) : null ; if ( rootName == null ) { if ( payload . size ( ) > 1 ) { throw new Fault ( new org . apache . cxf . common . i18n . Message ( "NO_XML_ROOT_NODE" , LOG ) ) ; } } else { if ( LOG . isLoggable ( Level . INFO ) ) { LOG . info ( "DOMOutInterceptor Create xmlformat RootNode element" ) ; } Element el = createElement ( rootName , payload ) ; payload = new ArrayList < Element > ( ) ; payload . add ( el ) ; } message . put ( List . class , payload ) ; message . remove ( Element . class ) ; } } private void moveHeaderPartToPayload ( BindingMessageInfo bmi , Element header , List < Element > payload ) { Collection < MessagePartInfo > bodyParts = bmi . getMessageParts ( ) ; NodeList nodes = header . getChildNodes ( ) ; for ( int idx = 0 ; idx < nodes . getLength ( ) ; idx ++ ) { Node node = nodes . item ( idx ) ; int index = 0 ; for ( MessagePartInfo mpi : bodyParts ) { QName name = mpi . getConcreteName ( ) ; if ( name . getLocalPart ( ) . equals ( node . getLocalName ( ) ) && name . getNamespaceURI ( ) . equals ( node . getNamespaceURI ( ) ) ) { payload . add ( index , ( Element ) node ) ; break ; } ++ index ; } } } } 	0	['6', '1', '0', '11', '39', '9', '1', '10', '3', '0.4', '189', '1', '0', '0.428571429', '0.333333333', '0', '0', '30.33333333', '5', '1.3333', '0']
package org . apache . camel . component . jms ; import javax . jms . Destination ; import javax . jms . JMSException ; import javax . jms . Session ; public interface DestinationEndpoint { Destination getJmsDestination ( Session session ) throws JMSException ; } 	0	['1', '1', '0', '5', '1', '0', '5', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . builder . xml ; import javax . xml . transform . Result ; import javax . xml . transform . dom . DOMResult ; import org . apache . camel . Message ; public class DomResultHandler implements ResultHandler { private DOMResult result = new DOMResult ( ) ; public Result getResult ( ) { return result ; } public void setBody ( Message in ) { in . setBody ( result . getNode ( ) ) ; } } 	0	['3', '1', '0', '3', '7', '0', '1', '2', '3', '0', '21', '1', '0', '0', '0.666666667', '0', '0', '5.666666667', '1', '0.6667', '0']
package org . apache . camel . component . http ; import java . io . IOException ; import java . io . InputStream ; import org . apache . camel . Message ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . component . http . helper . LoadingByteArrayOutputStream ; import org . apache . camel . impl . PollingConsumerSupport ; import org . apache . camel . spi . HeaderFilterStrategy ; import org . apache . commons . httpclient . Header ; import org . apache . commons . httpclient . HttpClient ; import org . apache . commons . httpclient . HttpMethod ; import org . apache . commons . httpclient . methods . GetMethod ; import org . apache . commons . io . IOUtils ; public class HttpPollingConsumer extends PollingConsumerSupport < HttpExchange > { private final HttpEndpoint endpoint ; private HttpClient httpClient ; public HttpPollingConsumer ( HttpEndpoint endpoint ) { super ( endpoint ) ; this . endpoint = endpoint ; httpClient = endpoint . createHttpClient ( ) ; } public HttpExchange receive ( ) { return receiveNoWait ( ) ; } public HttpExchange receive ( long timeout ) { return receiveNoWait ( ) ; } public HttpExchange receiveNoWait ( ) { HttpExchange exchange = endpoint . createExchange ( ) ; HttpMethod method = createMethod ( ) ; try { int responseCode = httpClient . executeMethod ( method ) ; LoadingByteArrayOutputStream bos = new LoadingByteArrayOutputStream ( ) ; InputStream is = method . getResponseBodyAsStream ( ) ; IOUtils . copy ( is , bos ) ; bos . flush ( ) ; is . close ( ) ; Message message = exchange . getIn ( ) ; message . setBody ( bos . createInputStream ( ) ) ; Header [ ] headers = method . getResponseHeaders ( ) ; HeaderFilterStrategy strategy = endpoint . getHeaderFilterStrategy ( ) ; for ( Header header : headers ) { String name = header . getName ( ) ; String value = header . getValue ( ) ; if ( strategy != null && ! strategy . applyFilterToExternalHeaders ( name , value ) ) { message . setHeader ( name , value ) ; } } message . setHeader ( "http.responseCode" , responseCode ) ; return exchange ; } catch ( IOException e ) { throw new RuntimeCamelException ( e ) ; } finally { method . releaseConnection ( ) ; } } public HttpClient getHttpClient ( ) { return httpClient ; } public void setHttpClient ( HttpClient httpClient ) { this . httpClient = httpClient ; } protected HttpMethod createMethod ( ) { String uri = endpoint . getEndpointUri ( ) ; return new GetMethod ( uri ) ; } protected void doStart ( ) throws Exception { } protected void doStop ( ) throws Exception { } } 	0	['12', '3', '0', '15', '32', '50', '2', '14', '9', '0.318181818', '156', '1', '1', '0.633333333', '0.333333333', '1', '1', '11.83333333', '4', '1.1667', '0']
package org . apache . camel . component . validator . msv ; import java . util . Map ; import javax . xml . XMLConstants ; import org . apache . camel . component . validator . SpringValidator ; import org . apache . camel . component . validator . ValidatorComponent ; import org . iso_relax . verifier . VerifierConfigurationException ; import org . iso_relax . verifier . jaxp . validation . RELAXNGSchemaFactoryImpl ; public class MsvComponent extends ValidatorComponent { private RELAXNGSchemaFactoryImpl schemaFactory ; public RELAXNGSchemaFactoryImpl getSchemaFactory ( ) throws VerifierConfigurationException { if ( schemaFactory == null ) { schemaFactory = new RELAXNGSchemaFactoryImpl ( ) ; } return schemaFactory ; } public void setSchemaFactory ( RELAXNGSchemaFactoryImpl schemaFactory ) { this . schemaFactory = schemaFactory ; } protected void configureValidator ( SpringValidator validator , String uri , String remaining , Map parameters ) throws Exception { validator . setSchemaLanguage ( XMLConstants . RELAXNG_NS_URI ) ; validator . setSchemaFactory ( getSchemaFactory ( ) ) ; super . configureValidator ( validator , uri , remaining , parameters ) ; } } 	0	['4', '5', '0', '4', '9', '4', '0', '4', '3', '0.333333333', '37', '1', '0', '0.930232558', '0.4', '1', '1', '8', '1', '0.75', '0']
package org . apache . camel . processor . validation ; import java . util . List ; import org . xml . sax . SAXParseException ; import org . apache . camel . Exchange ; import org . apache . camel . ValidationException ; public class SchemaValidationException extends ValidationException { private final Object schema ; private final List < SAXParseException > fatalErrors ; private final List < SAXParseException > errors ; private final List < SAXParseException > warnings ; public SchemaValidationException ( Exchange exchange , Object schema , List < SAXParseException > fatalErrors , List < SAXParseException > errors , List < SAXParseException > warnings ) { super ( exchange , message ( schema , fatalErrors , errors , warnings ) ) ; this . schema = schema ; this . fatalErrors = fatalErrors ; this . errors = errors ; this . warnings = warnings ; } public Object getSchema ( ) { return schema ; } public List < SAXParseException > getErrors ( ) { return errors ; } public List < SAXParseException > getFatalErrors ( ) { return fatalErrors ; } public List < SAXParseException > getWarnings ( ) { return warnings ; } protected static String message ( Object schema , List < SAXParseException > fatalErrors , List < SAXParseException > errors , List < SAXParseException > warnings ) { StringBuffer buffer = new StringBuffer ( "Validation failed for: " + schema ) ; if ( ! fatalErrors . isEmpty ( ) ) { buffer . append ( " fatal errors: " ) ; buffer . append ( fatalErrors ) ; } if ( ! errors . isEmpty ( ) ) { buffer . append ( " errors: " ) ; buffer . append ( errors ) ; } return buffer . toString ( ) ; } } 	0	['6', '6', '0', '3', '16', '7', '1', '2', '5', '0.8', '80', '1', '0', '0.791666667', '0.416666667', '0', '0', '11.66666667', '3', '1.1667', '0']
package org . apache . camel . component . mail ; import java . io . IOException ; import java . io . InputStream ; import javax . mail . BodyPart ; import javax . mail . Message ; import javax . mail . MessagingException ; import javax . mail . Multipart ; import javax . mail . internet . MimeMultipart ; import org . apache . camel . Converter ; import org . apache . camel . converter . IOConverter ; @ Converter public final class MailConverters { private MailConverters ( ) { } @ Converter public static String toString ( Message message ) throws MessagingException , IOException { Object content = message . getContent ( ) ; if ( content instanceof MimeMultipart ) { MimeMultipart multipart = ( MimeMultipart ) content ; if ( multipart . getCount ( ) > 0 ) { BodyPart part = multipart . getBodyPart ( 0 ) ; content = part . getContent ( ) ; } } if ( content != null ) { return content . toString ( ) ; } return null ; } @ Converter public static String toString ( Multipart multipart ) throws MessagingException , IOException { int size = multipart . getCount ( ) ; for ( int i = 0 ; i < size ; i ++ ) { BodyPart part = multipart . getBodyPart ( i ) ; if ( part . getContentType ( ) . startsWith ( "text" ) ) { return part . getContent ( ) . toString ( ) ; } } return null ; } @ Converter public static InputStream toInputStream ( Message message ) throws IOException , MessagingException { String s = toString ( message ) ; if ( s == null ) { return null ; } return IOConverter . toInputStream ( s , null ) ; } @ Converter public static InputStream toInputStream ( Multipart multipart ) throws IOException , MessagingException { String s = toString ( multipart ) ; if ( s == null ) { return null ; } return IOConverter . toInputStream ( s , null ) ; } } 	0	['5', '1', '0', '2', '16', '10', '0', '2', '4', '2', '81', '0', '0', '0', '0.333333333', '0', '0', '15.2', '1', '0.8', '0']
package org . apache . camel ; public class RuntimeExpressionException extends RuntimeCamelException { private static final long serialVersionUID = - 8417806626073055262L ; public RuntimeExpressionException ( String message ) { super ( message ) ; } public RuntimeExpressionException ( String message , Throwable cause ) { super ( message , cause ) ; } public RuntimeExpressionException ( Throwable cause ) { super ( cause ) ; } } 	0	['3', '5', '2', '6', '6', '3', '5', '1', '3', '1.5', '17', '1', '0', '1', '0.777777778', '0', '0', '4.333333333', '0', '0', '0']
package org . apache . camel . component . jhc ; import java . net . URI ; import org . apache . camel . Consumer ; import org . apache . camel . HeaderFilterStrategyAware ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . spi . HeaderFilterStrategy ; import org . apache . http . params . BasicHttpParams ; import org . apache . http . params . HttpParams ; public class JhcEndpoint extends DefaultEndpoint < JhcExchange > { private HttpParams params ; private URI httpUri ; public JhcEndpoint ( String endpointUri , JhcComponent component , URI httpUri ) { super ( endpointUri , component ) ; params = component . getParams ( ) . copy ( ) ; this . httpUri = httpUri ; } public JhcEndpoint ( String endpointUri , URI httpUri , HttpParams params ) { super ( endpointUri ) ; this . httpUri = httpUri ; this . params = params ; } public HttpParams getParams ( ) { return params ; } public void setParams ( HttpParams params ) { this . params = params ; } public URI getHttpUri ( ) { return httpUri ; } public void setHttpUri ( URI httpUri ) { this . httpUri = httpUri ; } public String getProtocol ( ) { return httpUri . getScheme ( ) ; } public String getHost ( ) { return httpUri . getHost ( ) ; } public int getPort ( ) { if ( httpUri . getPort ( ) == - 1 ) { if ( "https" . equals ( getProtocol ( ) ) ) { return 443 ; } else { return 80 ; } } return httpUri . getPort ( ) ; } public String getPath ( ) { return httpUri . getPath ( ) ; } public boolean isSingleton ( ) { return true ; } public Producer < JhcExchange > createProducer ( ) throws Exception { return new JhcProducer ( this ) ; } public Consumer < JhcExchange > createConsumer ( Processor processor ) throws Exception { return new JhcConsumer ( this , processor ) ; } public HeaderFilterStrategy getHeaderFilterStrategy ( ) { if ( getComponent ( ) instanceof HeaderFilterStrategyAware ) { return ( ( HeaderFilterStrategyAware ) getComponent ( ) ) . getHeaderFilterStrategy ( ) ; } else { return new JhcHeaderFilterStrategy ( ) ; } } } 	0	['14', '2', '0', '15', '28', '25', '6', '12', '14', '0.615384615', '109', '1', '0', '0.666666667', '0.273809524', '0', '0', '6.642857143', '3', '1.0714', '0']
package org . apache . camel . spi ; import org . apache . camel . Exchange ; public interface ExchangeConverter { < T > T convertTo ( Class < T > type , Exchange exchange ) ; } 	0	['1', '1', '0', '5', '1', '0', '4', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . util ; import java . util . concurrent . CountDownLatch ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; public final class AsyncProcessorHelper { private AsyncProcessorHelper ( ) { } public static void process ( AsyncProcessor processor , Exchange exchange ) throws Exception { final CountDownLatch latch = new CountDownLatch ( 1 ) ; boolean sync = processor . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { if ( ! sync ) { latch . countDown ( ) ; } } } ) ; if ( ! sync ) { latch . await ( ) ; } } } 	0	['2', '1', '0', '16', '7', '1', '12', '4', '1', '2', '23', '0', '0', '0', '0.5', '0', '0', '10.5', '1', '0.5', '0']
package org . apache . camel . impl . converter ; public class CachingInjector < T > { private final TypeConverterRegistry repository ; private final Class < T > type ; private T instance ; public CachingInjector ( TypeConverterRegistry repository , Class < T > type ) { this . repository = repository ; this . type = type ; } public synchronized T newInstance ( ) { if ( instance == null ) { instance = createInstance ( type ) ; } return instance ; } protected T createInstance ( Class < T > t ) { return repository . getInjector ( ) . newInstance ( t ) ; } } 	0	['3', '1', '0', '4', '6', '0', '2', '2', '2', '0.5', '33', '1', '1', '0', '0.666666667', '0', '0', '9', '2', '1', '0']
package org . apache . camel . component . http ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintWriter ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . apache . camel . Message ; import org . apache . camel . spi . HeaderFilterStrategy ; public class DefaultHttpBinding implements HttpBinding { private boolean useReaderForPayload ; private HeaderFilterStrategy headerFilterStrategy = new HttpHeaderFilterStrategy ( ) ; public DefaultHttpBinding ( ) { } public DefaultHttpBinding ( HeaderFilterStrategy headerFilterStrategy ) { this . headerFilterStrategy = headerFilterStrategy ; } public void readRequest ( HttpServletRequest request , HttpMessage message ) { message . getBody ( ) ; message . getHeaders ( ) ; } public void writeResponse ( HttpExchange exchange , HttpServletResponse response ) throws IOException { if ( exchange . isFailed ( ) ) { Message fault = exchange . getFault ( false ) ; if ( fault != null ) { doWriteFaultResponse ( fault , response ) ; } else { doWriteExceptionResponse ( exchange . getException ( ) , response ) ; } } else { Message out = exchange . getOut ( ) ; if ( out != null ) { doWriteResponse ( out , response ) ; } } } public void doWriteExceptionResponse ( Throwable exception , HttpServletResponse response ) throws IOException { response . setStatus ( 500 ) ; response . setContentType ( "text/plain" ) ; PrintWriter pw = response . getWriter ( ) ; exception . printStackTrace ( pw ) ; pw . flush ( ) ; } public void doWriteFaultResponse ( Message message , HttpServletResponse response ) throws IOException { doWriteResponse ( message , response ) ; } public void doWriteResponse ( Message message , HttpServletResponse response ) throws IOException { if ( message . getHeader ( HttpProducer . HTTP_RESPONSE_CODE ) != null ) { int code = message . getHeader ( HttpProducer . HTTP_RESPONSE_CODE , Integer . class ) ; response . setStatus ( code ) ; } if ( message . getHeader ( "Content-Type" ) != null ) { String contentType = message . getHeader ( "Content-Type" , String . class ) ; response . setContentType ( contentType ) ; } for ( String key : message . getHeaders ( ) . keySet ( ) ) { String value = message . getHeader ( key , String . class ) ; if ( headerFilterStrategy != null && ! headerFilterStrategy . applyFilterToCamelHeaders ( key , value ) ) { response . setHeader ( key , value ) ; } } if ( message . getBody ( ) != null ) { InputStream is = message . getBody ( InputStream . class ) ; int length = 0 ; if ( is != null ) { ServletOutputStream os = null ; try { os = response . getOutputStream ( ) ; int c ; while ( ( c = is . read ( ) ) >= 0 ) { os . write ( c ) ; length ++ ; } response . setContentLength ( length ) ; os . flush ( ) ; } finally { os . close ( ) ; is . close ( ) ; } } else { String data = message . getBody ( String . class ) ; if ( data != null ) { response . setContentLength ( data . length ( ) ) ; response . getWriter ( ) . print ( data ) ; response . getWriter ( ) . flush ( ) ; } } } } public Object parseBody ( HttpMessage httpMessage ) throws IOException { HttpServletRequest request = httpMessage . getRequest ( ) ; if ( isUseReaderForPayload ( ) ) { return request . getReader ( ) ; } else { return request . getInputStream ( ) ; } } public boolean isUseReaderForPayload ( ) { return useReaderForPayload ; } public void setUseReaderForPayload ( boolean useReaderForPayload ) { this . useReaderForPayload = useReaderForPayload ; } public HeaderFilterStrategy getHeaderFilterStrategy ( ) { return headerFilterStrategy ; } public void setHeaderFilterStrategy ( HeaderFilterStrategy headerFilterStrategy ) { this . headerFilterStrategy = headerFilterStrategy ; } } 	0	['12', '1', '0', '7', '49', '44', '1', '6', '12', '0.636363636', '239', '1', '1', '0', '0.240740741', '0', '0', '18.75', '1', '0.8333', '0']
package org . apache . camel . component . cxf . transport ; import java . io . IOException ; import java . util . Collection ; import java . util . HashSet ; import java . util . Set ; import javax . annotation . PostConstruct ; import javax . annotation . Resource ; import org . apache . camel . CamelContext ; import org . apache . camel . component . cxf . CxfHeaderFilterStrategy ; import org . apache . camel . spi . HeaderFilterStrategy ; import org . apache . cxf . Bus ; import org . apache . cxf . service . model . EndpointInfo ; import org . apache . cxf . transport . AbstractTransportFactory ; import org . apache . cxf . transport . Conduit ; import org . apache . cxf . transport . ConduitInitiator ; import org . apache . cxf . transport . ConduitInitiatorManager ; import org . apache . cxf . transport . Destination ; import org . apache . cxf . transport . DestinationFactory ; import org . apache . cxf . transport . DestinationFactoryManager ; import org . apache . cxf . ws . addressing . EndpointReferenceType ; public class CamelTransportFactory extends AbstractTransportFactory implements ConduitInitiator , DestinationFactory { public static final String TRANSPORT_ID = "http://cxf.apache.org/transports/camel" ; private static final Set < String > URI_PREFIXES = new HashSet < String > ( ) ; private Collection < String > activationNamespaces ; private HeaderFilterStrategy headerFilterStrategy = new CxfHeaderFilterStrategy ( ) ; static { URI_PREFIXES . add ( "camel://" ) ; } private Bus bus ; private CamelContext camelContext ; @ Resource ( name = "bus" ) public void setBus ( Bus b ) { bus = b ; } public Bus getBus ( ) { return bus ; } @ Resource public void setActivationNamespaces ( Collection < String > ans ) { activationNamespaces = ans ; } public CamelContext getCamelContext ( ) { return camelContext ; } @ Resource ( name = "camelContext" ) public void setCamelContext ( CamelContext camelContext ) { this . camelContext = camelContext ; } public Conduit getConduit ( EndpointInfo targetInfo ) throws IOException { return getConduit ( targetInfo , null ) ; } public Conduit getConduit ( EndpointInfo endpointInfo , EndpointReferenceType target ) throws IOException { return new CamelConduit ( camelContext , bus , endpointInfo , target , headerFilterStrategy ) ; } public Destination getDestination ( EndpointInfo endpointInfo ) throws IOException { return new CamelDestination ( camelContext , bus , this , endpointInfo , headerFilterStrategy ) ; } public Set < String > getUriPrefixes ( ) { return URI_PREFIXES ; } @ PostConstruct void registerWithBindingManager ( ) { if ( null == bus ) { return ; } ConduitInitiatorManager cim = bus . getExtension ( ConduitInitiatorManager . class ) ; if ( null != cim && null != activationNamespaces ) { for ( String ns : activationNamespaces ) { cim . registerConduitInitiator ( ns , this ) ; } } DestinationFactoryManager dfm = bus . getExtension ( DestinationFactoryManager . class ) ; if ( null != dfm && null != activationNamespaces ) { for ( String ns : activationNamespaces ) { dfm . registerDestinationFactory ( ns , this ) ; } } } public HeaderFilterStrategy getHeaderFilterStrategy ( ) { return headerFilterStrategy ; } public void setHeaderFilterStrategy ( HeaderFilterStrategy headerFilterStrategy ) { this . headerFilterStrategy = headerFilterStrategy ; } } 	0	['14', '0', '0', '15', '26', '39', '0', '15', '12', '0.807692308', '157', '0.833333333', '2', '0', '0.230769231', '0', '0', '9.785714286', '8', '1.3571', '0']
package org . apache . camel . component . cxf . util ; import java . util . logging . Logger ; import javax . xml . stream . XMLStreamException ; import javax . xml . transform . Source ; import javax . xml . transform . dom . DOMSource ; import org . w3c . dom . Document ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . interceptor . AbstractInDatabindingInterceptor ; import org . apache . cxf . interceptor . Fault ; import org . apache . cxf . message . Message ; import org . apache . cxf . phase . Phase ; import org . apache . cxf . staxutils . DepthXMLStreamReader ; import org . apache . cxf . staxutils . StaxUtils ; public class DataInInterceptor extends AbstractInDatabindingInterceptor { private static final Logger LOG = LogUtils . getL7dLogger ( DataInInterceptor . class ) ; public DataInInterceptor ( ) { super ( Phase . UNMARSHAL ) ; } public void handleMessage ( Message message ) throws Fault { DepthXMLStreamReader xmlReader = getXMLStreamReader ( message ) ; try { Document doc = StaxUtils . read ( xmlReader ) ; message . setContent ( Source . class , new DOMSource ( doc ) ) ; } catch ( XMLStreamException e ) { throw new Fault ( new org . apache . cxf . common . i18n . Message ( "XMLSTREAM_EXCEPTION" , LOG ) , e ) ; } } } 	0	['3', '0', '0', '8', '11', '1', '1', '7', '2', '0.5', '41', '1', '0', '0', '0.75', '0', '0', '12.33333333', '1', '0.3333', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Predicate ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . FilterProcessor ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "filter" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class FilterType extends ExpressionNode implements Block { public FilterType ( ) { } public FilterType ( ExpressionType expression ) { super ( expression ) ; } public FilterType ( Predicate predicate ) { super ( predicate ) ; } @ Override public String toString ( ) { return "Filter[" + getExpression ( ) + " -> " + getOutputs ( ) + "]" ; } @ Override public String getShortName ( ) { return "filter" ; } @ Override public FilterProcessor createProcessor ( RouteContext routeContext ) throws Exception { return createFilterProcessor ( routeContext ) ; } } 	0	['7', '4', '0', '11', '16', '21', '4', '7', '7', '2', '45', '0', '0', '0.978723404', '0.392857143', '3', '4', '5.428571429', '1', '0.5714', '0']
package org . apache . camel . impl ; import org . apache . camel . Exchange ; import org . apache . camel . Predicate ; public abstract class PredicateSupport < E extends Exchange > implements Predicate < E > { public void assertMatches ( String text , E exchange ) { if ( ! matches ( exchange ) ) { throw new AssertionError ( assertionFailureMessage ( exchange ) + " on " + exchange ) ; } } protected String assertionFailureMessage ( E exchange ) { return toString ( ) ; } } 	0	['4', '1', '0', '2', '12', '6', '0', '2', '3', '2', '37', '0', '0', '0', '0.5625', '0', '0', '8.25', '2', '1', '0']
package org . apache . camel . spring . spi ; import org . springframework . beans . factory . wiring . BeanConfigurerSupport ; import org . springframework . context . ApplicationContext ; public class BeanInjector extends BeanConfigurerSupport { public BeanInjector ( ApplicationContext applicationContext ) throws Exception { setBeanFactory ( applicationContext ) ; afterPropertiesSet ( ) ; } public void inject ( Object bean ) { configureBean ( bean ) ; } } 	0	['2', '0', '0', '3', '6', '1', '0', '3', '2', '2', '14', '0', '0', '0', '0.666666667', '0', '0', '6', '1', '0.5', '0']
package org . apache . camel . osgi ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . spi . Language ; import org . apache . camel . spi . LanguageResolver ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class OsgiLanguageResolver implements LanguageResolver { private static final transient Log LOG = LogFactory . getLog ( OsgiLanguageResolver . class ) ; public Language resolveLanguage ( String name , CamelContext context ) { Object bean = null ; try { bean = context . getRegistry ( ) . lookup ( name ) ; if ( bean != null && LOG . isDebugEnabled ( ) ) { LOG . debug ( "Found language: " + name + " in registry: " + bean ) ; } } catch ( Exception e ) { LOG . debug ( "Ignored error looking up bean: " + name + ". Error: " + e ) ; } if ( bean != null ) { if ( bean instanceof Language ) { return ( Language ) bean ; } } Class type = null ; try { type = getLanaguage ( name ) ; } catch ( Throwable e ) { throw new IllegalArgumentException ( "Invalid URI, no Language registered for scheme : " + name , e ) ; } if ( type == null ) { return null ; } if ( Language . class . isAssignableFrom ( type ) ) { return ( Language ) context . getInjector ( ) . newInstance ( type ) ; } else { throw new IllegalArgumentException ( "Type is not a Lanaguage implementation. Found: " + type . getName ( ) ) ; } } protected Class getLanaguage ( String name ) throws Exception { return Activator . getLanguage ( name ) ; } } 	0	['4', '1', '0', '9', '21', '4', '1', '8', '2', '0.666666667', '113', '1', '0', '0', '0.666666667', '0', '0', '27', '5', '1.5', '0']
package org . apache . camel . component . list ; import java . beans . PropertyChangeListener ; import java . beans . PropertyChangeSupport ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Consumer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . processor . loadbalancer . LoadBalancerConsumer ; import org . apache . camel . processor . loadbalancer . TopicLoadBalancer ; import org . apache . camel . spi . BrowsableEndpoint ; public class ListEndpoint extends DefaultEndpoint < Exchange > implements BrowsableEndpoint < Exchange > { private List < Exchange > exchanges ; private TopicLoadBalancer loadBalancer = new TopicLoadBalancer ( ) ; private PropertyChangeSupport propertyChangeSupport = new PropertyChangeSupport ( this ) ; public ListEndpoint ( String uri , CamelContext camelContext ) { super ( uri , camelContext ) ; reset ( ) ; } public ListEndpoint ( String uri , Component component ) { super ( uri , component ) ; reset ( ) ; } public ListEndpoint ( String endpointUri ) { super ( endpointUri ) ; reset ( ) ; } public boolean isSingleton ( ) { return true ; } public List < Exchange > getExchanges ( ) { return exchanges ; } public TopicLoadBalancer getLoadBalancer ( ) { return loadBalancer ; } public void addPropertyChangeListener ( PropertyChangeListener listener ) { propertyChangeSupport . addPropertyChangeListener ( listener ) ; } public void removePropertyChangeListener ( PropertyChangeListener listener ) { propertyChangeSupport . removePropertyChangeListener ( listener ) ; } public Producer < Exchange > createProducer ( ) throws Exception { return new DefaultProducer < Exchange > ( this ) { public void process ( Exchange exchange ) throws Exception { onExchange ( exchange ) ; } } ; } public Consumer < Exchange > createConsumer ( Processor processor ) throws Exception { return new LoadBalancerConsumer ( this , processor , loadBalancer ) ; } public void reset ( ) { exchanges = createExchangeList ( ) ; } protected List < Exchange > createExchangeList ( ) { return new CopyOnWriteArrayList < Exchange > ( ) ; } protected void onExchange ( Exchange exchange ) throws Exception { exchanges . add ( exchange ) ; loadBalancer . process ( exchange ) ; } } 	0	['13', '2', '1', '15', '25', '28', '3', '13', '11', '0.611111111', '120', '1', '1', '0.705882353', '0.241758242', '0', '0', '8', '1', '0.7692', '0']
package org . apache . camel . language ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . RuntimeCamelException ; public class ExpressionEvaluationException extends RuntimeCamelException { private final Expression < Exchange > expression ; private final Exchange exchange ; public ExpressionEvaluationException ( Expression < Exchange > expression , Exchange exchange , Throwable cause ) { super ( cause ) ; this . expression = expression ; this . exchange = exchange ; } public Expression < Exchange > getExpression ( ) { return expression ; } public Exchange getExchange ( ) { return exchange ; } } 	0	['3', '5', '0', '5', '4', '0', '2', '3', '3', '0.5', '21', '1', '2', '0.894736842', '0.5', '0', '0', '5.333333333', '1', '0.6667', '0']
package org . apache . camel . language . header ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . builder . ExpressionBuilder ; import org . apache . camel . builder . PredicateBuilder ; import org . apache . camel . spi . Language ; public class HeaderLanguage implements Language { public static Expression < Exchange > header ( String headerName ) { return ExpressionBuilder . headerExpression ( headerName ) ; } public Predicate < Exchange > createPredicate ( String expression ) { return PredicateBuilder . toPredicate ( createExpression ( expression ) ) ; } public Expression < Exchange > createExpression ( String expression ) { return HeaderLanguage . header ( expression ) ; } } 	0	['4', '1', '0', '5', '7', '6', '0', '5', '4', '2', '18', '0', '0', '0', '0.75', '0', '0', '3.5', '1', '0.75', '0']
package org . apache . camel . bam . rules ; import java . util . ArrayList ; import java . util . Date ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . bam . TimeExpression ; import org . apache . camel . bam . model . ActivityState ; import org . apache . camel . bam . model . ProcessInstance ; import org . apache . camel . impl . DefaultExchange ; import org . apache . camel . impl . DefaultRouteContext ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . model . OutputType ; import org . apache . camel . model . RouteType ; import org . apache . camel . spi . RouteContext ; import org . apache . camel . util . Time ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import static org . apache . camel . util . ServiceHelper . startServices ; import static org . apache . camel . util . ServiceHelper . stopServices ; public class TemporalRule extends ServiceSupport { private static final transient Log LOG = LogFactory . getLog ( TemporalRule . class ) ; private TimeExpression first ; private TimeExpression second ; private long expectedMillis ; private long overdueMillis ; private Processor overdueAction ; private OutputType overdueProcessors = new OutputType ( ) ; public TemporalRule ( TimeExpression first , TimeExpression second ) { this . first = first ; this . second = second ; } public TemporalRule expectWithin ( Time builder ) { return expectWithin ( builder . toMillis ( ) ) ; } public TemporalRule expectWithin ( long millis ) { expectedMillis = millis ; return this ; } public OutputType errorIfOver ( Time builder ) { return errorIfOver ( builder . toMillis ( ) ) ; } public OutputType errorIfOver ( long millis ) { overdueMillis = millis ; if ( overdueProcessors == null ) { overdueProcessors = new OutputType ( ) ; } return overdueProcessors ; } public TimeExpression getFirst ( ) { return first ; } public TimeExpression getSecond ( ) { return second ; } public Processor getOverdueAction ( ) throws Exception { if ( overdueAction == null && overdueProcessors != null ) { ArrayList < Route > list = new ArrayList < Route > ( ) ; RouteType route = new RouteType ( ) ; route . setCamelContext ( first . getBuilder ( ) . getProcessBuilder ( ) . getContext ( ) ) ; RouteContext routeContext = new DefaultRouteContext ( route , null , list ) ; overdueAction = overdueProcessors . createOutputsProcessor ( routeContext ) ; } return overdueAction ; } public void processExchange ( Exchange exchange , ProcessInstance instance ) { Date firstTime = first . evaluate ( instance ) ; if ( firstTime == null ) { return ; } ActivityState secondState = second . getOrCreateActivityState ( instance ) ; if ( expectedMillis > 0L ) { Date expected = secondState . getTimeExpected ( ) ; if ( expected == null ) { expected = add ( firstTime , expectedMillis ) ; secondState . setTimeExpected ( expected ) ; } } if ( overdueMillis > 0L ) { Date overdue = secondState . getTimeOverdue ( ) ; if ( overdue == null ) { overdue = add ( firstTime , overdueMillis ) ; secondState . setTimeOverdue ( overdue ) ; } } } public void processExpired ( ActivityState activityState ) throws Exception { Processor processor = getOverdueAction ( ) ; if ( processor != null ) { Date now = new Date ( ) ; ActivityState secondState = activityState ; Date overdue = secondState . getTimeOverdue ( ) ; if ( now . compareTo ( overdue ) >= 0 ) { Exchange exchange = createExchange ( ) ; exchange . getIn ( ) . setBody ( activityState ) ; processor . process ( exchange ) ; } else { LOG . warn ( "Process has not actually expired; the time is: " + now + " but the overdue time is: " + overdue ) ; } } } protected Exchange createExchange ( ) { return new DefaultExchange ( second . getBuilder ( ) . getProcessBuilder ( ) . getContext ( ) ) ; } protected Date add ( Date date , long millis ) { return new Date ( date . getTime ( ) + millis ) ; } protected void doStart ( ) throws Exception { startServices ( getOverdueAction ( ) ) ; } protected void doStop ( ) throws Exception { stopServices ( getOverdueAction ( ) ) ; } } 	0	['15', '2', '0', '21', '48', '73', '2', '20', '10', '0.755102041', '243', '1', '4', '0.518518519', '0.214285714', '1', '1', '14.73333333', '6', '1.2667', '0']
package org . apache . camel . component . jms ; import java . util . concurrent . FutureTask ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; import java . util . concurrent . atomic . AtomicBoolean ; import javax . jms . Destination ; import javax . jms . JMSException ; import javax . jms . Message ; import javax . jms . Session ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangeTimedOutException ; import org . apache . camel . FailedToCreateProducerException ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . RuntimeExchangeException ; import org . apache . camel . component . jms . JmsConfiguration . CamelJmsTemplate ; import org . apache . camel . component . jms . requestor . DeferredRequestReplyMap ; import org . apache . camel . component . jms . requestor . DeferredRequestReplyMap . DeferredMessageSentCallback ; import org . apache . camel . component . jms . requestor . PersistentReplyToRequestor ; import org . apache . camel . component . jms . requestor . Requestor ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . util . UuidGenerator ; import org . apache . camel . util . ValueHolder ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . jms . core . JmsOperations ; import org . springframework . jms . core . MessageCreator ; public class JmsProducer extends DefaultProducer { private static final transient Log LOG = LogFactory . getLog ( JmsProducer . class ) ; RequestorAffinity affinity ; private final JmsEndpoint endpoint ; private JmsOperations inOnlyTemplate ; private JmsOperations inOutTemplate ; private UuidGenerator uuidGenerator ; private DeferredRequestReplyMap deferredRequestReplyMap ; private Requestor requestor ; private AtomicBoolean started = new AtomicBoolean ( false ) ; private enum RequestorAffinity { PER_COMPONENT ( 0 ) , PER_ENDPOINT ( 1 ) , PER_PRODUCER ( 2 ) ; private int value ; private RequestorAffinity ( int value ) { this . value = value ; } } ; public JmsProducer ( JmsEndpoint endpoint ) { super ( endpoint ) ; this . endpoint = endpoint ; JmsConfiguration c = endpoint . getConfiguration ( ) ; affinity = RequestorAffinity . PER_PRODUCER ; if ( c . getReplyTo ( ) != null ) { if ( c . getReplyToTempDestinationAffinity ( ) . equals ( c . REPLYTO_TEMP_DEST_AFFINITY_PER_ENDPOINT ) ) { affinity = RequestorAffinity . PER_ENDPOINT ; } else if ( c . getReplyToTempDestinationAffinity ( ) . equals ( c . REPLYTO_TEMP_DEST_AFFINITY_PER_COMPONENT ) ) { affinity = RequestorAffinity . PER_COMPONENT ; } } } public long getRequestTimeout ( ) { return endpoint . getRequestTimeout ( ) ; } protected void doStart ( ) throws Exception { super . doStart ( ) ; } protected void testAndSetRequestor ( ) throws RuntimeCamelException { if ( ! started . get ( ) ) { synchronized ( this ) { if ( started . get ( ) ) { return ; } try { JmsConfiguration c = endpoint . getConfiguration ( ) ; if ( c . getReplyTo ( ) != null ) { requestor = new PersistentReplyToRequestor ( endpoint . getConfiguration ( ) , endpoint . getExecutorService ( ) ) ; requestor . start ( ) ; } else { if ( affinity == RequestorAffinity . PER_PRODUCER ) { requestor = new Requestor ( endpoint . getConfiguration ( ) , endpoint . getExecutorService ( ) ) ; requestor . start ( ) ; } else if ( affinity == RequestorAffinity . PER_ENDPOINT ) { requestor = endpoint . getRequestor ( ) ; } else if ( affinity == RequestorAffinity . PER_COMPONENT ) { requestor = ( ( JmsComponent ) endpoint . getComponent ( ) ) . getRequestor ( ) ; } } } catch ( Exception e ) { throw new FailedToCreateProducerException ( endpoint , e ) ; } deferredRequestReplyMap = requestor . getDeferredRequestReplyMap ( this ) ; started . set ( true ) ; } } } protected void testAndUnsetRequestor ( ) throws Exception { if ( started . get ( ) ) { synchronized ( this ) { if ( ! started . get ( ) ) { return ; } requestor . removeDeferredRequestReplyMap ( this ) ; if ( affinity == RequestorAffinity . PER_PRODUCER ) { requestor . stop ( ) ; } started . set ( false ) ; } } } protected void doStop ( ) throws Exception { testAndUnsetRequestor ( ) ; super . doStop ( ) ; } public void process ( final Exchange exchange ) { final org . apache . camel . Message in = exchange . getIn ( ) ; if ( exchange . getPattern ( ) . isOutCapable ( ) ) { testAndSetRequestor ( ) ; final Destination replyTo = requestor . getReplyTo ( ) ; if ( replyTo == null ) { throw new RuntimeExchangeException ( "Failed to resolve replyTo destination" , exchange ) ; } final boolean msgIdAsCorrId = endpoint . getConfiguration ( ) . isUseMessageIDAsCorrelationID ( ) ; String correlationId = in . getHeader ( "JMSCorrelationID" , String . class ) ; if ( correlationId == null && ! msgIdAsCorrId ) { in . setHeader ( "JMSCorrelationID" , getUuidGenerator ( ) . generateId ( ) ) ; } final ValueHolder < FutureTask > futureHolder = new ValueHolder < FutureTask > ( ) ; final DeferredMessageSentCallback callback = msgIdAsCorrId ? deferredRequestReplyMap . createDeferredMessageSentCallback ( ) : null ; final CamelJmsTemplate template = ( CamelJmsTemplate ) getInOutTemplate ( ) ; template . send ( endpoint . getDestination ( ) , new MessageCreator ( ) { public Message createMessage ( Session session ) throws JMSException { Message message = endpoint . getBinding ( ) . makeJmsMessage ( exchange , in , session ) ; message . setJMSReplyTo ( replyTo ) ; requestor . setReplyToSelectorHeader ( in , message ) ; FutureTask future = null ; future = ( ! msgIdAsCorrId ) ? requestor . getReceiveFuture ( message . getJMSCorrelationID ( ) , endpoint . getRequestTimeout ( ) ) : requestor . getReceiveFuture ( callback ) ; futureHolder . set ( future ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( endpoint + " sending JMS message: " + message ) ; } return message ; } } , callback ) ; setMessageId ( exchange ) ; long requestTimeout = endpoint . getConfiguration ( ) . getRequestTimeout ( ) ; try { Message message = null ; try { if ( requestTimeout < 0 ) { message = ( Message ) futureHolder . get ( ) . get ( ) ; } else { message = ( Message ) futureHolder . get ( ) . get ( requestTimeout , TimeUnit . MILLISECONDS ) ; } } catch ( InterruptedException e ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Future interupted: " + e , e ) ; } } catch ( TimeoutException e ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Future timed out: " + e , e ) ; } } if ( message != null ) { exchange . setOut ( new JmsMessage ( message , endpoint . getBinding ( ) ) ) ; if ( correlationId != null ) { message . setJMSCorrelationID ( correlationId ) ; exchange . getOut ( false ) . setHeader ( "JMSCorrelationID" , correlationId ) ; } } else { exchange . setException ( new ExchangeTimedOutException ( exchange , requestTimeout ) ) ; } } catch ( Exception e ) { exchange . setException ( e ) ; } } else { getInOnlyTemplate ( ) . send ( endpoint . getDestination ( ) , new MessageCreator ( ) { public Message createMessage ( Session session ) throws JMSException { Message message = endpoint . getBinding ( ) . makeJmsMessage ( exchange , in , session ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( endpoint + " sending JMS message: " + message ) ; } return message ; } } ) ; setMessageId ( exchange ) ; } } protected void setMessageId ( Exchange exchange ) { if ( ! ( exchange instanceof JmsExchange ) ) { return ; } try { JmsExchange jmsExchange = JmsExchange . class . cast ( exchange ) ; JmsMessage out = jmsExchange . getOut ( false ) ; if ( out != null ) { out . setMessageId ( out . getJmsMessage ( ) . getJMSMessageID ( ) ) ; } } catch ( JMSException e ) { LOG . warn ( "Unable to retrieve JMSMessageID from outgoing JMS Message and " + "set it into Camel's MessageId" , e ) ; } } public JmsOperations getTemplate ( ) { return getInOnlyTemplate ( ) ; } public JmsOperations getInOnlyTemplate ( ) { if ( inOnlyTemplate == null ) { inOnlyTemplate = endpoint . createInOnlyTemplate ( ) ; } return inOnlyTemplate ; } public void setInOnlyTemplate ( JmsOperations inOnlyTemplate ) { this . inOnlyTemplate = inOnlyTemplate ; } public JmsOperations getInOutTemplate ( ) { if ( inOutTemplate == null ) { inOutTemplate = endpoint . createInOutTemplate ( ) ; } return inOutTemplate ; } public void setInOutTemplate ( JmsOperations inOutTemplate ) { this . inOutTemplate = inOutTemplate ; } public UuidGenerator getUuidGenerator ( ) { if ( uuidGenerator == null ) { uuidGenerator = new UuidGenerator ( ) ; } return uuidGenerator ; } public void setUuidGenerator ( UuidGenerator uuidGenerator ) { this . uuidGenerator = uuidGenerator ; } } 	0	['19', '3', '0', '31', '84', '99', '5', '31', '10', '0.814814815', '501', '0.888888889', '5', '0.552631579', '0.212962963', '1', '1', '24.89473684', '9', '1.5263', '0']
package org . apache . camel . bam . model ; import java . util . Date ; import javax . persistence . CascadeType ; import javax . persistence . Entity ; import javax . persistence . FetchType ; import javax . persistence . GeneratedValue ; import javax . persistence . Id ; import javax . persistence . ManyToOne ; import javax . persistence . Temporal ; import javax . persistence . TemporalType ; import javax . persistence . Transient ; import org . apache . camel . bam . processor . ProcessContext ; import org . apache . camel . bam . rules . ActivityRules ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; @ Entity public class ActivityState extends TemporalEntity { private static final transient Log LOG = LogFactory . getLog ( ActivityState . class ) ; private ProcessInstance processInstance ; private Integer receivedMessageCount = 0 ; private ActivityDefinition activityDefinition ; private Date timeExpected ; @ Temporal ( TemporalType . TIME ) private Date timeOverdue ; private Integer escalationLevel = 0 ; @ Override @ Id @ GeneratedValue public Long getId ( ) { return super . getId ( ) ; } @ Override public String toString ( ) { return "ActivityState[" + getId ( ) + " on " + getProcessInstance ( ) + " " + getActivityDefinition ( ) + "]" ; } public synchronized void processExchange ( ActivityRules activityRules , ProcessContext context ) throws Exception { int messageCount = 0 ; Integer count = getReceivedMessageCount ( ) ; if ( count != null ) { messageCount = count . intValue ( ) ; } setReceivedMessageCount ( ++ messageCount ) ; if ( messageCount == 1 ) { onFirstMessage ( context ) ; } int expectedMessages = activityRules . getExpectedMessages ( ) ; if ( messageCount == expectedMessages ) { onExpectedMessage ( context ) ; } else if ( messageCount > expectedMessages ) { onExcessMessage ( context ) ; } } public boolean isActivity ( ActivityRules activityRules ) { return ObjectHelper . equal ( getActivityDefinition ( ) , activityRules . getActivityDefinition ( ) ) ; } @ ManyToOne ( fetch = FetchType . LAZY , cascade = { CascadeType . PERSIST , CascadeType . MERGE } ) public ProcessInstance getProcessInstance ( ) { return processInstance ; } public void setProcessInstance ( ProcessInstance processInstance ) { this . processInstance = processInstance ; processInstance . getActivityStates ( ) . add ( this ) ; } @ ManyToOne ( fetch = FetchType . LAZY , cascade = { CascadeType . PERSIST , CascadeType . MERGE } ) public ActivityDefinition getActivityDefinition ( ) { return activityDefinition ; } public void setActivityDefinition ( ActivityDefinition activityDefinition ) { this . activityDefinition = activityDefinition ; } public Integer getEscalationLevel ( ) { return escalationLevel ; } public void setEscalationLevel ( Integer escalationLevel ) { this . escalationLevel = escalationLevel ; } public Integer getReceivedMessageCount ( ) { return receivedMessageCount ; } public void setReceivedMessageCount ( Integer receivedMessageCount ) { this . receivedMessageCount = receivedMessageCount ; } @ Temporal ( TemporalType . TIME ) public Date getTimeExpected ( ) { return timeExpected ; } public void setTimeExpected ( Date timeExpected ) { this . timeExpected = timeExpected ; } @ Temporal ( TemporalType . TIME ) public Date getTimeOverdue ( ) { return timeOverdue ; } public void setTimeOverdue ( Date timeOverdue ) { this . timeOverdue = timeOverdue ; } public void setTimeCompleted ( Date timeCompleted ) { super . setTimeCompleted ( timeCompleted ) ; if ( timeCompleted != null ) { setEscalationLevel ( - 1 ) ; } } @ Transient public String getCorrelationKey ( ) { ProcessInstance pi = getProcessInstance ( ) ; if ( pi == null ) { return null ; } return pi . getCorrelationKey ( ) ; } protected void onFirstMessage ( ProcessContext context ) { if ( ! isStarted ( ) ) { setTimeStarted ( currentTime ( ) ) ; context . onStarted ( this ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Activity first message: " + this ) ; } } } protected void onExpectedMessage ( ProcessContext context ) { if ( ! isCompleted ( ) ) { setTimeCompleted ( currentTime ( ) ) ; setTimeOverdue ( null ) ; context . onCompleted ( this ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Activity complete: " + this ) ; } } } protected void onExcessMessage ( ProcessContext context ) { } protected Date currentTime ( ) { return new Date ( ) ; } } 	0	['24', '3', '0', '17', '48', '250', '12', '8', '19', '0.881987578', '238', '1', '2', '0.290322581', '0.223602484', '0', '0', '8.625', '3', '1.1667', '0']
package org . apache . camel . component . uface . swing ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . component . uface . UFaceComponent ; import org . ufacekit . ui . swing . databinding . swing . SwingRealm ; public class SwingComponent extends UFaceComponent { public SwingComponent ( ) { SwingRealm . createDefault ( ) ; } protected Endpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { return super . createEndpoint ( uri , remaining , parameters ) ; } } 	0	['2', '4', '0', '3', '5', '1', '0', '3', '1', '2', '12', '0', '0', '0.972972973', '0.666666667', '1', '1', '5', '1', '0.5', '0']
package org . apache . camel . component . seda ; import java . util . concurrent . BlockingQueue ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class QueueComponent extends SedaComponent { private static final transient Log LOG = LogFactory . getLog ( QueueComponent . class ) ; public QueueComponent ( ) { LOG . warn ( "This component has been deprecated; please use the seda: URI format instead of queue:" ) ; } } 	0	['2', '4', '0', '3', '5', '0', '0', '3', '1', '0', '13', '1', '0', '1', '1', '0', '0', '5', '0', '0', '0']
package org . apache . camel . spi ; import java . io . InputStream ; import java . io . OutputStream ; import org . apache . camel . Exchange ; public interface DataFormat { void marshal ( Exchange exchange , Object graph , OutputStream stream ) throws Exception ; Object unmarshal ( Exchange exchange , InputStream stream ) throws Exception ; } 	0	['2', '1', '0', '22', '2', '1', '21', '1', '2', '2', '2', '0', '0', '0', '0.7', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . jms ; import javax . jms . JMSException ; public class MessagePropertyAccessException extends RuntimeJmsException { private static final long serialVersionUID = - 3996286386119163309L ; private final String propertyName ; public MessagePropertyAccessException ( String propertyName , JMSException e ) { super ( "Error accessing header: " + propertyName , e ) ; this . propertyName = propertyName ; } public String getPropertyName ( ) { return propertyName ; } } 	0	['2', '5', '0', '3', '6', '0', '2', '1', '2', '1', '22', '1', '0', '0.944444444', '0.666666667', '0', '0', '9', '1', '0.5', '0']
package org . apache . camel . converter . jaxb ; import java . io . Closeable ; import java . io . InputStream ; import java . io . Reader ; import java . io . StringReader ; import java . io . StringWriter ; import javax . xml . bind . JAXBContext ; import javax . xml . bind . JAXBException ; import javax . xml . bind . Marshaller ; import javax . xml . bind . Unmarshaller ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . util . JAXBSource ; import javax . xml . transform . Source ; import org . apache . camel . Exchange ; import org . apache . camel . NoTypeConversionAvailableException ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . TypeConverter ; import org . apache . camel . converter . stream . StreamCache ; import org . apache . camel . spi . TypeConverterAware ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class FallbackTypeConverter implements TypeConverter , TypeConverterAware { private static final transient Log LOG = LogFactory . getLog ( FallbackTypeConverter . class ) ; private TypeConverter parentTypeConverter ; private boolean prettyPrint = true ; public boolean isPrettyPrint ( ) { return prettyPrint ; } public void setPrettyPrint ( boolean prettyPrint ) { this . prettyPrint = prettyPrint ; } public void setTypeConverter ( TypeConverter parentTypeConverter ) { this . parentTypeConverter = parentTypeConverter ; } public < T > T convertTo ( Class < T > type , Object value ) { try { if ( isJaxbType ( type ) ) { return unmarshall ( type , value ) ; } if ( value != null ) { if ( isJaxbType ( value . getClass ( ) ) && isNotStreamCacheType ( type ) ) { return marshall ( type , value ) ; } } return null ; } catch ( JAXBException e ) { throw new RuntimeCamelException ( e ) ; } } private < T > boolean isNotStreamCacheType ( Class < T > type ) { return ! StreamCache . class . isAssignableFrom ( type ) ; } public < T > T convertTo ( Class < T > type , Exchange exchange , Object value ) { return convertTo ( type , value ) ; } protected < T > boolean isJaxbType ( Class < T > type ) { XmlRootElement element = type . getAnnotation ( XmlRootElement . class ) ; boolean jaxbType = element != null ; return jaxbType ; } protected < T > T unmarshall ( Class < T > type , Object value ) throws JAXBException { JAXBContext context = createContext ( type ) ; Unmarshaller unmarshaller = context . createUnmarshaller ( ) ; if ( parentTypeConverter != null ) { InputStream inputStream = parentTypeConverter . convertTo ( InputStream . class , value ) ; if ( inputStream != null ) { Object unmarshalled = unmarshal ( unmarshaller , inputStream ) ; return type . cast ( unmarshalled ) ; } Reader reader = parentTypeConverter . convertTo ( Reader . class , value ) ; if ( reader != null ) { Object unmarshalled = unmarshal ( unmarshaller , reader ) ; return type . cast ( unmarshalled ) ; } Source source = parentTypeConverter . convertTo ( Source . class , value ) ; if ( source != null ) { Object unmarshalled = unmarshal ( unmarshaller , source ) ; return type . cast ( unmarshalled ) ; } } if ( value instanceof String ) { value = new StringReader ( ( String ) value ) ; } if ( value instanceof InputStream || value instanceof Reader ) { Object unmarshalled = unmarshal ( unmarshaller , value ) ; return type . cast ( unmarshalled ) ; } return null ; } protected < T > T marshall ( Class < T > type , Object value ) throws JAXBException { if ( parentTypeConverter != null ) { JAXBContext context = createContext ( value . getClass ( ) ) ; JAXBSource source = new JAXBSource ( context , value ) ; try { return parentTypeConverter . convertTo ( type , source ) ; } catch ( NoTypeConversionAvailableException e ) { StringWriter buffer = new StringWriter ( ) ; Marshaller marshaller = context . createMarshaller ( ) ; marshaller . setProperty ( Marshaller . JAXB_FORMATTED_OUTPUT , isPrettyPrint ( ) ? Boolean . TRUE : Boolean . FALSE ) ; marshaller . marshal ( value , buffer ) ; return parentTypeConverter . convertTo ( type , buffer . toString ( ) ) ; } } return null ; } protected Object unmarshal ( Unmarshaller unmarshaller , Object value ) throws JAXBException { try { if ( value instanceof InputStream ) { return unmarshaller . unmarshal ( ( InputStream ) value ) ; } else if ( value instanceof Reader ) { return unmarshaller . unmarshal ( ( Reader ) value ) ; } else if ( value instanceof Source ) { return unmarshaller . unmarshal ( ( Source ) value ) ; } } finally { if ( value instanceof Closeable ) { ObjectHelper . close ( ( Closeable ) value , "Unmarshalling" , LOG ) ; } } return null ; } protected < T > JAXBContext createContext ( Class < T > type ) throws JAXBException { JAXBContext context = JAXBContext . newInstance ( type ) ; return context ; } } 	0	['13', '1', '0', '8', '34', '64', '0', '8', '6', '0.75', '322', '1', '1', '0', '0.333333333', '0', '0', '23.53846154', '5', '1.3077', '0']
package org . apache . camel . component . mina ; import java . net . SocketAddress ; import org . apache . camel . CamelException ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; import org . apache . camel . util . ExchangeHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . mina . common . IoAcceptor ; import org . apache . mina . common . IoHandler ; import org . apache . mina . common . IoHandlerAdapter ; import org . apache . mina . common . IoSession ; public class MinaConsumer extends DefaultConsumer < MinaExchange > { private static final transient Log LOG = LogFactory . getLog ( MinaConsumer . class ) ; private final MinaEndpoint endpoint ; private final SocketAddress address ; private final IoAcceptor acceptor ; private boolean sync ; public MinaConsumer ( final MinaEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; this . address = endpoint . getAddress ( ) ; this . acceptor = endpoint . getAcceptor ( ) ; this . sync = endpoint . isSync ( ) ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; if ( LOG . isInfoEnabled ( ) ) { LOG . info ( "Binding to server address: " + address + " using acceptor: " + acceptor ) ; } IoHandler handler = new ReceiveHandler ( ) ; acceptor . bind ( address , handler , endpoint . getAcceptorConfig ( ) ) ; } @ Override protected void doStop ( ) throws Exception { if ( LOG . isInfoEnabled ( ) ) { LOG . info ( "Unbinding from server address: " + address + " using acceptor: " + acceptor ) ; } acceptor . unbind ( address ) ; super . doStop ( ) ; } private final class ReceiveHandler extends IoHandlerAdapter { @ Override public void exceptionCaught ( IoSession session , Throwable cause ) throws Exception { if ( session != null ) { LOG . debug ( "Closing session as an exception was thrown from MINA" ) ; session . close ( ) ; } throw new CamelException ( cause ) ; } @ Override public void messageReceived ( IoSession session , Object object ) throws Exception { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Received body: " + object ) ; } MinaExchange exchange = endpoint . createExchange ( session , object ) ; if ( endpoint . getCharsetName ( ) != null ) { exchange . setProperty ( Exchange . CHARSET_NAME , endpoint . getCharsetName ( ) ) ; } getProcessor ( ) . process ( exchange ) ; if ( sync ) { Object body ; if ( ExchangeHelper . isOutCapable ( exchange ) ) { body = MinaPayloadHelper . getOut ( endpoint , exchange ) ; } else { body = MinaPayloadHelper . getIn ( endpoint , exchange ) ; } boolean failed = exchange . isFailed ( ) ; if ( failed && ! endpoint . isTransferExchange ( ) ) { if ( exchange . getException ( ) != null ) { body = exchange . getException ( ) ; } else { body = exchange . getFault ( ) . getBody ( ) ; } } if ( body == null ) { LOG . warn ( "Can not write body since its null, closing session: " + exchange ) ; session . close ( ) ; } else { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Writing body: " + body ) ; } MinaHelper . writeBody ( session , body , exchange ) ; } } } } } 	0	['7', '3', '0', '12', '24', '0', '2', '12', '1', '0.666666667', '108', '1', '1', '0.821428571', '0.291666667', '1', '1', '13.71428571', '1', '0.7143', '0']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "constant" ) public class ConstantExpression extends ExpressionType { public ConstantExpression ( ) { } public ConstantExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "constant" ; } } 	0	['3', '2', '0', '3', '5', '3', '2', '1', '3', '2', '12', '0', '0', '0.956521739', '0.666666667', '1', '2', '3', '1', '0.3333', '0']
package org . apache . camel . component . spring . integration . adapter . config ; import org . w3c . dom . Attr ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . apache . camel . component . spring . integration . adapter . CamelTargetAdapter ; import org . springframework . beans . factory . parsing . BeanComponentDefinition ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . RootBeanDefinition ; import org . springframework . beans . factory . xml . AbstractSimpleBeanDefinitionParser ; import org . springframework . beans . factory . xml . ParserContext ; import org . springframework . util . StringUtils ; public class CamelTargetAdapterParser extends AbstractCamelContextBeanDefinitionParaser { @ Override protected Class < ? > getBeanClass ( Element element ) { return CamelTargetAdapter . class ; } } 	0	['2', '1', '0', '2', '3', '1', '1', '1', '1', '2', '7', '0', '0', '0.857142857', '0.75', '0', '0', '2.5', '1', '0.5', '0']
package org . apache . camel . component . mail ; import java . net . URI ; import java . util . Map ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . HeaderFilterStrategyAware ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . impl . DefaultHeaderFilterStrategy ; import org . apache . camel . spi . HeaderFilterStrategy ; import org . apache . camel . util . ObjectHelper ; public class MailComponent extends DefaultComponent < MailExchange > implements HeaderFilterStrategyAware { private MailConfiguration configuration ; private HeaderFilterStrategy headerFilterStrategy = new DefaultHeaderFilterStrategy ( ) ; public MailComponent ( ) { this . configuration = new MailConfiguration ( ) ; } public MailComponent ( MailConfiguration configuration ) { this . configuration = configuration ; } public MailComponent ( CamelContext context ) { super ( context ) ; this . configuration = new MailConfiguration ( ) ; } public static MailComponent mailComponent ( ) { return new MailComponent ( ) ; } public static MailComponent mailComponent ( MailConfiguration configuration ) { return new MailComponent ( configuration ) ; } @ Override protected Endpoint < MailExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { URI url = new URI ( uri ) ; if ( "nntp" . equalsIgnoreCase ( url . getScheme ( ) ) ) { throw new UnsupportedOperationException ( "nntp protocol is not supported" ) ; } ObjectHelper . notNull ( configuration , "configuration" ) ; MailConfiguration config = configuration . copy ( ) ; config . configure ( url ) ; MailEndpoint endpoint = new MailEndpoint ( uri , this , config ) ; setProperties ( endpoint . getConfiguration ( ) , parameters ) ; ObjectHelper . notEmpty ( config . getHost ( ) , "host" ) ; ObjectHelper . notEmpty ( config . getProtocol ( ) , "protocol" ) ; if ( config . getPort ( ) <= 0 ) { throw new IllegalArgumentException ( "port mut be specified" ) ; } return endpoint ; } public MailConfiguration getConfiguration ( ) { return configuration ; } public void setConfiguration ( MailConfiguration configuration ) { this . configuration = configuration ; } protected String convertPathToActualDestination ( String path ) { return path ; } public HeaderFilterStrategy getHeaderFilterStrategy ( ) { return headerFilterStrategy ; } public void setHeaderFilterStrategy ( HeaderFilterStrategy strategy ) { headerFilterStrategy = strategy ; } } 	0	['11', '3', '0', '9', '30', '11', '1', '9', '9', '0.35', '132', '1', '2', '0.813953488', '0.257575758', '1', '2', '10.81818182', '1', '0.7273', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . processor . TransformProcessor ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "transform" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class TransformType extends ExpressionNode { public TransformType ( ) { } public TransformType ( Expression expression ) { super ( expression ) ; } @ Override public String toString ( ) { return "Transform[" + getExpression ( ) + "]" ; } @ Override public String getShortName ( ) { return "transform" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { Expression expr = getExpression ( ) . createExpression ( routeContext ) ; Processor childProcessor = routeContext . createProcessor ( this ) ; return new TransformProcessor ( expr , childProcessor ) ; } } 	0	['5', '4', '0', '7', '15', '10', '1', '7', '5', '2', '41', '0', '0', '0.983957219', '0.466666667', '2', '3', '7.2', '1', '0.6', '0']
package org . apache . camel . language . groovy ; import groovy . lang . GroovyShell ; import org . apache . camel . CamelContext ; import org . apache . camel . builder . RouteBuilder ; public abstract class GroovyRouteBuilder extends RouteBuilder { public GroovyRouteBuilder ( ) { init ( ) ; } public GroovyRouteBuilder ( CamelContext context ) { super ( context ) ; init ( ) ; } private void init ( ) { ClassLoader loader = getClass ( ) . getClassLoader ( ) ; GroovyShell shell = new GroovyShell ( loader ) ; shell . evaluate ( loader . getResourceAsStream ( "org/apache/camel/language/groovy/ConfigureCamel.groovy" ) ) ; } } 	0	['3', '3', '0', '3', '10', '3', '0', '3', '2', '2', '30', '0', '0', '0.981818182', '0.666666667', '0', '0', '9', '1', '0.3333', '0']
package org . apache . camel . component . file . remote ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . util . Vector ; import java . util . concurrent . ScheduledExecutorService ; import com . jcraft . jsch . ChannelSftp ; import com . jcraft . jsch . JSchException ; import com . jcraft . jsch . Session ; import com . jcraft . jsch . SftpException ; import org . apache . camel . Processor ; import org . apache . camel . component . file . FileComponent ; public class SftpConsumer extends RemoteFileConsumer < RemoteFileExchange > { private final SftpEndpoint endpoint ; private ChannelSftp channel ; private Session session ; public SftpConsumer ( SftpEndpoint endpoint , Processor processor , Session session ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; this . session = session ; } public SftpConsumer ( SftpEndpoint endpoint , Processor processor , Session session , ScheduledExecutorService executor ) { super ( endpoint , processor , executor ) ; this . endpoint = endpoint ; this . session = session ; } protected void doStart ( ) throws Exception { log . info ( "Starting" ) ; super . doStart ( ) ; } protected void doStop ( ) throws Exception { log . info ( "Stopping" ) ; try { disconnect ( ) ; } catch ( Exception e ) { log . warn ( "Exception occured during disconecting from " + remoteServer ( ) + ". " + e . getClass ( ) . getCanonicalName ( ) + " message: " + e . getMessage ( ) ) ; } super . doStop ( ) ; } protected void connectIfNecessary ( ) throws JSchException { if ( channel == null || ! channel . isConnected ( ) ) { if ( session == null || ! session . isConnected ( ) ) { log . trace ( "Session isn't connected, trying to recreate and connect." ) ; session = endpoint . createSession ( ) ; session . connect ( ) ; } log . trace ( "Channel isn't connected, trying to recreate and connect." ) ; channel = endpoint . createChannelSftp ( session ) ; channel . connect ( ) ; log . info ( "Connected to " + remoteServer ( ) ) ; } } protected void disconnect ( ) throws JSchException { log . debug ( "Disconnecting from " + remoteServer ( ) ) ; if ( session != null ) { session . disconnect ( ) ; } if ( channel != null ) { channel . disconnect ( ) ; } } protected void poll ( ) throws Exception { if ( log . isTraceEnabled ( ) ) { log . trace ( "Polling " + endpoint . getConfiguration ( ) ) ; } connectIfNecessary ( ) ; try { final String fileName = endpoint . getConfiguration ( ) . getFile ( ) ; if ( endpoint . getConfiguration ( ) . isDirectory ( ) ) { pollDirectory ( fileName ) ; } else { int index = fileName . lastIndexOf ( '/' ) ; if ( index > - 1 ) { channel . cd ( fileName . substring ( 0 , index ) ) ; } final Vector files = channel . ls ( fileName . substring ( index + 1 ) ) ; final ChannelSftp . LsEntry file = ( ChannelSftp . LsEntry ) files . get ( 0 ) ; pollFile ( file ) ; } lastPollTime = System . currentTimeMillis ( ) ; } catch ( Exception e ) { if ( isStopping ( ) || isStopped ( ) ) { log . warn ( "Consumer is stopping. Ignoring caught exception: " + e . getClass ( ) . getCanonicalName ( ) + " message: " + e . getMessage ( ) ) ; } else { log . warn ( "Exception occured during polling: " + e . getClass ( ) . getCanonicalName ( ) + " message: " + e . getMessage ( ) ) ; disconnect ( ) ; throw e ; } } } protected void pollDirectory ( String dir ) throws Exception { if ( log . isTraceEnabled ( ) ) { log . trace ( "Polling directory: " + dir ) ; } String currentDir = channel . pwd ( ) ; channel . cd ( dir ) ; Vector files = channel . ls ( "." ) ; for ( int i = 0 ; i < files . size ( ) ; i ++ ) { ChannelSftp . LsEntry sftpFile = ( ChannelSftp . LsEntry ) files . get ( i ) ; if ( sftpFile . getFilename ( ) . startsWith ( "." ) ) { } else if ( sftpFile . getAttrs ( ) . isDir ( ) ) { if ( isRecursive ( ) ) { pollDirectory ( getFullFileName ( sftpFile ) ) ; } } else { pollFile ( sftpFile ) ; } } channel . cd ( currentDir ) ; } protected String getFullFileName ( ChannelSftp . LsEntry sftpFile ) throws IOException , SftpException { return channel . pwd ( ) + "/" + sftpFile . getFilename ( ) ; } private void pollFile ( ChannelSftp . LsEntry sftpFile ) throws Exception { if ( log . isTraceEnabled ( ) ) { log . trace ( "Polling file: " + sftpFile ) ; } boolean timestampMatched = true ; if ( isTimestamp ( ) ) { long ts = sftpFile . getAttrs ( ) . getMTime ( ) * 1000L ; timestampMatched = ts > lastPollTime ; if ( log . isTraceEnabled ( ) ) { log . trace ( "The file is to old + " + sftpFile + ". lastPollTime=" + lastPollTime + " > fileTimestamp=" + ts ) ; } } if ( timestampMatched && isMatched ( sftpFile ) ) { String fullFileName = getFullFileName ( sftpFile ) ; if ( exclusiveReadLock ) { acquireExclusiveReadLock ( sftpFile ) ; } final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream ( ) ; channel . get ( sftpFile . getFilename ( ) , byteArrayOutputStream ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Retrieved file: " + sftpFile . getFilename ( ) + " from: " + remoteServer ( ) ) ; } RemoteFileExchange exchange = endpoint . createExchange ( getFullFileName ( sftpFile ) , sftpFile . getFilename ( ) , sftpFile . getAttrs ( ) . getSize ( ) , byteArrayOutputStream ) ; if ( isSetNames ( ) ) { String ftpBasePath = endpoint . getConfiguration ( ) . getFile ( ) ; String relativePath = fullFileName . substring ( ftpBasePath . length ( ) + 1 ) ; relativePath = relativePath . replaceFirst ( "/" , "" ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Setting exchange filename to " + relativePath ) ; } exchange . getIn ( ) . setHeader ( FileComponent . HEADER_FILE_NAME , relativePath ) ; } if ( deleteFile ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Deleteing file: " + sftpFile . getFilename ( ) + " from: " + remoteServer ( ) ) ; } deleteFile ( sftpFile . getFilename ( ) ) ; } else if ( isMoveFile ( ) ) { String fromName = sftpFile . getFilename ( ) ; String toName = getMoveFileName ( fromName , exchange ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Moving file: " + fromName + " to: " + toName ) ; } boolean deleted = deleteFile ( toName ) ; if ( ! deleted ) { int lastPathIndex = toName . lastIndexOf ( '/' ) ; if ( lastPathIndex != - 1 ) { String directory = toName . substring ( 0 , lastPathIndex ) ; if ( ! SftpUtils . buildDirectory ( channel , directory ) ) { log . warn ( "Can not build directory: " + directory + " (maybe because of denied permissions)" ) ; } } } try { channel . rename ( fromName , toName ) ; } catch ( SftpException e ) { log . warn ( "Can not move file: " + fromName + " to: " + toName ) ; } } getProcessor ( ) . process ( exchange ) ; } } private boolean deleteFile ( String filename ) { try { channel . rm ( filename ) ; return true ; } catch ( SftpException e ) { log . warn ( "Could not delete file: " + filename + " from: " + remoteServer ( ) ) ; return false ; } } protected void acquireExclusiveReadLock ( ChannelSftp . LsEntry sftpFile ) throws SftpException { if ( log . isTraceEnabled ( ) ) { log . trace ( "Waiting for exclusive read lock to file: " + sftpFile ) ; } String originalName = sftpFile . getFilename ( ) ; String newName = originalName + ".camelExclusiveReadLock" ; boolean exclusive = false ; while ( ! exclusive ) { try { channel . rename ( originalName , newName ) ; exclusive = true ; } catch ( SftpException e ) { } if ( exclusive ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Acquired exclusive read lock to file: " + originalName ) ; } channel . rename ( newName , originalName ) ; } else { log . trace ( "Exclusive read lock not granted. Sleeping for 1000 millis" ) ; try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException e ) { } } } } protected String getFileName ( Object file ) { ChannelSftp . LsEntry sftpFile = ( ChannelSftp . LsEntry ) file ; return sftpFile . getFilename ( ) ; } } 	0	['13', '5', '0', '16', '79', '0', '1', '16', '2', '0.5', '744', '1', '1', '0.849315068', '0.25', '3', '6', '56', '1', '0.8462', '0']
package org . apache . camel . spring ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . CamelContext ; import org . apache . camel . CamelContextAware ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultProducerTemplate ; import org . apache . camel . model . IdentifiedType ; import org . springframework . beans . factory . FactoryBean ; import org . springframework . beans . factory . InitializingBean ; @ XmlRootElement ( name = "template" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class CamelTemplateFactoryBean extends IdentifiedType implements FactoryBean , InitializingBean , CamelContextAware { @ XmlAttribute ( required = false ) private String defaultEndpoint ; @ XmlTransient private CamelContext camelContext ; public void afterPropertiesSet ( ) throws Exception { if ( camelContext == null ) { throw new IllegalArgumentException ( "A CamelContext must be injected!" ) ; } } public Object getObject ( ) throws Exception { CamelContext context = getCamelContext ( ) ; if ( defaultEndpoint != null ) { Endpoint endpoint = context . getEndpoint ( defaultEndpoint ) ; if ( endpoint == null ) { throw new IllegalArgumentException ( "No endpoint found for URI: " + defaultEndpoint ) ; } else { return new DefaultProducerTemplate ( context , endpoint ) ; } } return new DefaultProducerTemplate ( context ) ; } public Class getObjectType ( ) { return DefaultProducerTemplate . class ; } public boolean isSingleton ( ) { return true ; } public CamelContext getCamelContext ( ) { return camelContext ; } public void setCamelContext ( CamelContext camelContext ) { this . camelContext = camelContext ; } public String getDefaultEndpoint ( ) { return defaultEndpoint ; } public void setDefaultEndpoint ( String defaultEndpoint ) { this . defaultEndpoint = defaultEndpoint ; } } 	0	['9', '2', '0', '7', '17', '24', '0', '7', '9', '0.6875', '78', '1', '1', '0.2', '0.407407407', '0', '0', '7.444444444', '1', '0.8889', '0']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "expression" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class LanguageExpression extends ExpressionType { @ XmlAttribute private String language ; public LanguageExpression ( ) { } public LanguageExpression ( String language , String expression ) { setLanguage ( language ) ; setExpression ( expression ) ; } public String getLanguage ( ) { return language ; } public void setLanguage ( String language ) { this . language = language ; } } 	0	['4', '2', '0', '2', '6', '4', '1', '1', '4', '0.333333333', '24', '1', '0', '0.916666667', '0.75', '1', '2', '4.75', '1', '0.5', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . ThreadPoolExecutor ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Processor ; import org . apache . camel . builder . ErrorHandlerBuilder ; import org . apache . camel . processor . Pipeline ; import org . apache . camel . processor . ThreadProcessor ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "thread" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ThreadType extends ProcessorType < ProcessorType > { @ XmlAttribute ( required = false ) private Integer coreSize = 1 ; @ XmlAttribute ( required = false ) private Boolean daemon = Boolean . TRUE ; @ XmlAttribute ( required = false ) private Long keepAliveTime ; @ XmlAttribute ( required = false ) private Integer maxSize = 1 ; @ XmlAttribute ( required = false ) private String name = "Thread Processor" ; @ XmlAttribute ( required = false ) private Integer priority = Thread . NORM_PRIORITY ; @ XmlAttribute ( required = false ) private Long stackSize ; @ XmlElementRef private List < ProcessorType < ? > > outputs = new ArrayList < ProcessorType < ? > > ( ) ; @ XmlTransient private BlockingQueue < Runnable > taskQueue ; @ XmlTransient private ThreadGroup threadGroup ; @ XmlTransient private ThreadPoolExecutor executor ; public ThreadType ( ) { } public ThreadType ( int coreSize ) { this . coreSize = coreSize ; this . maxSize = coreSize ; } public ThreadType ( ThreadPoolExecutor executor ) { this . executor = executor ; } @ Override public List < ProcessorType < ? > > getOutputs ( ) { return outputs ; } @ Override public String toString ( ) { return "Thread[" + name + "]" ; } @ Override public String getShortName ( ) { return "thread" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { ThreadProcessor thread = new ThreadProcessor ( ) ; thread . setExecutor ( executor ) ; if ( coreSize != null ) { thread . setCoreSize ( coreSize ) ; } if ( daemon != null ) { thread . setDaemon ( daemon ) ; } if ( keepAliveTime != null ) { thread . setKeepAliveTime ( keepAliveTime ) ; } if ( maxSize != null ) { thread . setMaxSize ( maxSize ) ; } thread . setName ( name ) ; thread . setPriority ( priority ) ; if ( stackSize != null ) { thread . setStackSize ( stackSize ) ; } thread . setTaskQueue ( taskQueue ) ; thread . setThreadGroup ( threadGroup ) ; ArrayList < Processor > pipe = new ArrayList < Processor > ( 2 ) ; pipe . add ( thread ) ; pipe . add ( createOutputsProcessor ( routeContext , outputs ) ) ; return new Pipeline ( pipe ) ; } @ Override protected void configureChild ( ProcessorType output ) { super . configureChild ( output ) ; if ( isInheritErrorHandler ( ) ) { output . setErrorHandlerBuilder ( getErrorHandlerBuilder ( ) ) ; } } @ Override public ProcessorType errorHandler ( ErrorHandlerBuilder errorHandlerBuilder ) { throw new IllegalArgumentException ( "Setting errorHandler on ThreadType is not supported." + " Instead set the errorHandler on the parent." ) ; } public ThreadType coreSize ( int coreSize ) { setCoreSize ( coreSize ) ; return this ; } public ThreadType daemon ( boolean daemon ) { setDaemon ( daemon ) ; return this ; } public ThreadType keepAliveTime ( long keepAliveTime ) { setKeepAliveTime ( keepAliveTime ) ; return this ; } public ThreadType maxSize ( int maxSize ) { setMaxSize ( maxSize ) ; return this ; } public ThreadType name ( String name ) { setName ( name ) ; return this ; } public ThreadType priority ( int priority ) { setPriority ( priority ) ; return this ; } public ThreadType stackSize ( long stackSize ) { setStackSize ( stackSize ) ; return this ; } public ThreadType taskQueue ( BlockingQueue < Runnable > taskQueue ) { setTaskQueue ( taskQueue ) ; return this ; } public ThreadType threadGroup ( ThreadGroup threadGroup ) { setThreadGroup ( threadGroup ) ; return this ; } public ThreadType executor ( ThreadPoolExecutor executor ) { setExecutor ( executor ) ; return this ; } public void setCoreSize ( int coreSize ) { this . coreSize = coreSize ; } public void setDaemon ( boolean daemon ) { this . daemon = daemon ; } public void setKeepAliveTime ( long keepAliveTime ) { this . keepAliveTime = keepAliveTime ; } public void setMaxSize ( int maxSize ) { this . maxSize = maxSize ; } public void setName ( String name ) { this . name = name ; } public void setPriority ( int priority ) { this . priority = priority ; } public void setStackSize ( long stackSize ) { this . stackSize = stackSize ; } public void setTaskQueue ( BlockingQueue < Runnable > taskQueue ) { this . taskQueue = taskQueue ; } public void setThreadGroup ( ThreadGroup threadGroup ) { this . threadGroup = threadGroup ; } public ThreadPoolExecutor getExecutor ( ) { return executor ; } public void setExecutor ( ThreadPoolExecutor executor ) { this . executor = executor ; } } 	0	['30', '3', '0', '6', '61', '347', '1', '6', '29', '0.868338558', '349', '1', '0', '0.866995074', '0.166666667', '1', '5', '10.26666667', '2', '0.9333', '0']
package org . apache . camel ; public interface Intercept { Processor getInterceptorLogic ( ) ; void setInterceptorLogic ( Processor interceptorLogic ) ; } 	0	['2', '1', '0', '5', '2', '1', '4', '1', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . camel . model . dataformat ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "string" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class StringDataFormat extends DataFormatType { @ XmlAttribute ( required = false ) private String charset ; @ Override protected DataFormat createDataFormat ( RouteContext routeContext ) { return new org . apache . camel . impl . StringDataFormat ( charset ) ; } public String getCharset ( ) { return charset ; } public void setCharset ( String charset ) { this . charset = charset ; } } 	0	['4', '3', '0', '5', '6', '0', '1', '4', '3', '0.333333333', '21', '1', '0', '0.75', '0.5', '1', '1', '4', '1', '0.75', '0']
package org . apache . camel . component . jms . requestor ; import java . util . HashMap ; import java . util . Map ; public class MessageSelectorProvider { protected Map < String , String > correlationIds ; protected boolean dirty = true ; protected StringBuilder expression ; public MessageSelectorProvider ( ) { correlationIds = new HashMap < String , String > ( ) ; } public synchronized void addCorrelationID ( String id ) { correlationIds . put ( id , id ) ; dirty = true ; } public synchronized void removeCorrelationID ( String id ) { correlationIds . remove ( id ) ; dirty = true ; } public synchronized String get ( ) { if ( ! dirty ) { return expression . toString ( ) ; } expression = new StringBuilder ( "JMSCorrelationID='" ) ; boolean first = true ; for ( Map . Entry < String , String > entry : correlationIds . entrySet ( ) ) { if ( ! first ) { expression . append ( " OR JMSCorrelationID='" ) ; } expression . append ( entry . getValue ( ) ) . append ( "'" ) ; if ( first ) { first = false ; } } dirty = false ; return expression . toString ( ) ; } } 	0	['4', '1', '0', '2', '16', '0', '2', '0', '4', '0.333333333', '92', '1', '0', '0', '0.75', '0', '0', '21.25', '4', '1.5', '0']
package org . apache . camel . component . jhc ; import org . apache . camel . impl . DefaultMessage ; public class JhcMessage extends DefaultMessage { } 	0	['1', '3', '0', '1', '2', '0', '0', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . camel . component . freemarker ; import freemarker . cache . CacheStorage ; public class NoCacheStorage implements CacheStorage { public Object get ( Object key ) { return null ; } public void put ( Object key , Object value ) { } public void remove ( Object key ) { } public void clear ( ) { } } 	0	['5', '1', '0', '2', '6', '10', '1', '1', '5', '2', '13', '0', '0', '0', '0.8', '0', '0', '1.6', '1', '0.8', '0']
package org . apache . camel . spring . remoting ; import org . aopalliance . intercept . MethodInterceptor ; import org . aopalliance . intercept . MethodInvocation ; import org . apache . camel . CamelContext ; import org . apache . camel . CamelContextAware ; import org . apache . camel . Endpoint ; import org . apache . camel . Producer ; import org . apache . camel . component . bean . CamelInvocationHandler ; import org . apache . camel . component . bean . MethodInfoCache ; import org . apache . camel . util . CamelContextHelper ; import org . springframework . beans . factory . DisposableBean ; import org . springframework . beans . factory . InitializingBean ; import static org . apache . camel . util . ObjectHelper . notNull ; public class SendBeforeInterceptor implements MethodInterceptor , CamelContextAware , InitializingBean , DisposableBean { private String uri ; private CamelContext camelContext ; private CamelInvocationHandler invocationHandler ; private Producer producer ; public Object invoke ( MethodInvocation invocation ) throws Throwable { invocationHandler . invoke ( invocation . getThis ( ) , invocation . getMethod ( ) , invocation . getArguments ( ) ) ; return invocation . proceed ( ) ; } public void afterPropertiesSet ( ) throws Exception { notNull ( uri , "uri" ) ; notNull ( camelContext , "camelContext" ) ; Endpoint endpoint = CamelContextHelper . getMandatoryEndpoint ( camelContext , uri ) ; producer = endpoint . createProducer ( ) ; producer . start ( ) ; invocationHandler = new CamelInvocationHandler ( endpoint , producer , new MethodInfoCache ( endpoint . getCamelContext ( ) ) ) ; } public void destroy ( ) throws Exception { if ( producer != null ) { producer . stop ( ) ; } } public void setCamelContext ( CamelContext camelContext ) { this . camelContext = camelContext ; } public String getUri ( ) { return uri ; } public void setUri ( String uri ) { this . uri = uri ; } } 	0	['7', '1', '0', '12', '21', '9', '0', '12', '7', '0.791666667', '80', '1', '3', '0', '0.357142857', '0', '0', '9.857142857', '1', '0.8571', '0']
@ javax . xml . bind . annotation . XmlSchema ( namespace = "http://activemq.apache.org/camel/schema/osgi" , elementFormDefault = javax . xml . bind . annotation . XmlNsForm . QUALIFIED ) package org . apache . camel . osgi ; 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . processor . idempotent ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . RuntimeCamelException ; public class NoMessageIdException extends RuntimeCamelException { private final Exchange exchange ; private final Expression expression ; public NoMessageIdException ( Exchange exchange , Expression expression ) { super ( "No message ID could be found using expression: " + expression + " on message exchange: " + exchange ) ; this . exchange = exchange ; this . expression = expression ; } public Exchange getExchange ( ) { return exchange ; } public Expression getExpression ( ) { return expression ; } } 	0	['3', '5', '0', '4', '8', '0', '1', '3', '3', '0.5', '32', '1', '2', '0.894736842', '0.555555556', '0', '0', '9', '1', '0.6667', '0']
package org . apache . camel . component . cxf . interceptors ; import java . util . List ; import java . util . logging . Logger ; import javax . xml . namespace . QName ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . apache . cxf . helpers . DOMUtils ; import org . apache . cxf . message . Message ; import org . apache . cxf . phase . AbstractPhaseInterceptor ; public abstract class AbstractMessageOutInterceptor < T extends Message > extends AbstractPhaseInterceptor < T > { public AbstractMessageOutInterceptor ( String phase ) { super ( phase ) ; } protected boolean isRequestor ( Message message ) { return Boolean . TRUE . equals ( message . get ( Message . REQUESTOR_ROLE ) ) ; } protected abstract Logger getLogger ( ) ; protected Element createElement ( QName elName , List < Element > childEl ) { Document doc = DOMUtils . createDocument ( ) ; String prefix = elName . getPrefix ( ) ; StringBuilder tagName = new StringBuilder ( ) ; if ( ! "" . equals ( prefix ) ) { tagName . append ( prefix ) ; tagName . append ( ":" ) ; } tagName . append ( elName . getLocalPart ( ) ) ; Element el = doc . createElementNS ( elName . getNamespaceURI ( ) , tagName . toString ( ) ) ; if ( ! "" . equals ( elName . getPrefix ( ) ) ) { StringBuilder attrName = new StringBuilder ( "xmlns" ) ; attrName . append ( ':' ) ; attrName . append ( elName . getPrefix ( ) ) ; el . setAttribute ( attrName . toString ( ) , elName . getNamespaceURI ( ) ) ; } for ( Element part : childEl ) { Node adoptedNode = doc . adoptNode ( part ) ; el . appendChild ( adoptedNode ) ; } return el ; } } 	0	['4', '0', '2', '5', '24', '6', '2', '3', '1', '2', '93', '0', '0', '0', '0.4', '0', '0', '22.25', '4', '1.5', '0']
package org . apache . camel . component . file . remote ; import java . util . concurrent . ScheduledExecutorService ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . ScheduledPollConsumer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public abstract class RemoteFileConsumer < T extends RemoteFileExchange > extends ScheduledPollConsumer < T > { protected final transient Log log = LogFactory . getLog ( getClass ( ) ) ; protected RemoteFileEndpoint < T > endpoint ; protected long lastPollTime ; protected boolean recursive ; protected String regexPattern ; protected boolean setNames = true ; protected boolean exclusiveReadLock ; protected boolean deleteFile ; protected String moveNamePrefix ; protected String moveNamePostfix ; protected String excludedNamePrefix ; protected String excludedNamePostfix ; private boolean timestamp ; public RemoteFileConsumer ( RemoteFileEndpoint < T > endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; } public RemoteFileConsumer ( RemoteFileEndpoint < T > endpoint , Processor processor , ScheduledExecutorService executor ) { super ( endpoint , processor , executor ) ; } protected abstract String getFileName ( Object file ) ; protected boolean isMatched ( Object file ) { String name = getFileName ( file ) ; if ( name . startsWith ( "." ) ) { return false ; } if ( regexPattern != null && regexPattern . length ( ) > 0 ) { if ( ! name . matches ( regexPattern ) ) { return false ; } } if ( excludedNamePrefix != null ) { if ( name . startsWith ( excludedNamePrefix ) ) { return false ; } } if ( excludedNamePostfix != null ) { if ( name . endsWith ( excludedNamePostfix ) ) { return false ; } } return true ; } protected boolean isMoveFile ( ) { return moveNamePostfix != null || moveNamePrefix != null || endpoint . getConfiguration ( ) . getExpression ( ) != null ; } protected String getMoveFileName ( String name , Exchange exchange ) { if ( endpoint . getConfiguration ( ) . getExpression ( ) != null ) { Object result = endpoint . getConfiguration ( ) . getExpression ( ) . evaluate ( exchange ) ; return exchange . getContext ( ) . getTypeConverter ( ) . convertTo ( String . class , result ) ; } StringBuffer buffer = new StringBuffer ( ) ; if ( moveNamePrefix != null ) { buffer . append ( moveNamePrefix ) ; } buffer . append ( name ) ; if ( moveNamePostfix != null ) { buffer . append ( moveNamePostfix ) ; } return buffer . toString ( ) ; } protected String remoteServer ( ) { return endpoint . getConfiguration ( ) . remoteServerInformation ( ) ; } public boolean isRecursive ( ) { return recursive ; } public void setRecursive ( boolean recursive ) { this . recursive = recursive ; } public long getLastPollTime ( ) { return lastPollTime ; } public void setLastPollTime ( long lastPollTime ) { this . lastPollTime = lastPollTime ; } public String getRegexPattern ( ) { return regexPattern ; } public void setRegexPattern ( String regexPattern ) { this . regexPattern = regexPattern ; } public boolean isSetNames ( ) { return setNames ; } public void setSetNames ( boolean setNames ) { this . setNames = setNames ; } public boolean isExclusiveReadLock ( ) { return exclusiveReadLock ; } public void setExclusiveReadLock ( boolean exclusiveReadLock ) { this . exclusiveReadLock = exclusiveReadLock ; } public boolean isDeleteFile ( ) { return deleteFile ; } public void setDeleteFile ( boolean deleteFile ) { this . deleteFile = deleteFile ; } public String getMoveNamePrefix ( ) { return moveNamePrefix ; } public void setMoveNamePrefix ( String moveNamePrefix ) { this . moveNamePrefix = moveNamePrefix ; } public String getMoveNamePostfix ( ) { return moveNamePostfix ; } public void setMoveNamePostfix ( String moveNamePostfix ) { this . moveNamePostfix = moveNamePostfix ; } public String getExcludedNamePrefix ( ) { return excludedNamePrefix ; } public void setExcludedNamePrefix ( String excludedNamePrefix ) { this . excludedNamePrefix = excludedNamePrefix ; } public String getExcludedNamePostfix ( ) { return excludedNamePostfix ; } public void setExcludedNamePostfix ( String excludedNamePostfix ) { this . excludedNamePostfix = excludedNamePostfix ; } public boolean isTimestamp ( ) { return timestamp ; } public void setTimestamp ( boolean timestamp ) { this . timestamp = timestamp ; } } 	0	['29', '4', '2', '14', '47', '334', '2', '12', '24', '0.934065934', '262', '1', '1', '0.564516129', '0.187739464', '0', '0', '7.586206897', '9', '1.4138', '0']
package org . apache . camel ; public class AlreadyStoppedException extends CamelException { public AlreadyStoppedException ( ) { super ( "Already stopped" ) ; } } 	0	['1', '4', '0', '2', '2', '0', '1', '1', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . apache . camel . builder . script ; import org . apache . camel . RuntimeCamelException ; public class ScriptEvaluationException extends RuntimeCamelException { public ScriptEvaluationException ( String message ) { super ( message ) ; } public ScriptEvaluationException ( String message , Throwable cause ) { super ( message , cause ) ; } public ScriptEvaluationException ( Throwable cause ) { super ( cause ) ; } } 	0	['3', '5', '0', '2', '6', '3', '1', '1', '3', '2', '16', '0', '0', '1', '0.777777778', '0', '0', '4.333333333', '0', '0', '0']
package org . apache . camel ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . PARAMETER } ) public @ interface Header { String name ( ) ; } 	0	['1', '1', '0', '1', '1', '0', '1', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . osgi ; import java . lang . reflect . Method ; import java . net . URL ; import java . util . Enumeration ; import java . util . HashSet ; import java . util . Set ; import org . apache . camel . util . ResolverUtil ; import org . apache . camel . util . ResolverUtil . Test ; import org . osgi . framework . Bundle ; import org . osgi . framework . BundleContext ; import org . springframework . osgi . util . BundleDelegatingClassLoader ; public class OsgiResolverUtil extends ResolverUtil { private Bundle bundle ; public OsgiResolverUtil ( BundleContext context ) { bundle = context . getBundle ( ) ; } public Set < ClassLoader > getClassLoaders ( ) { Set < ClassLoader > classLoaders = super . getClassLoaders ( ) ; ClassLoader osgiLoader = BundleDelegatingClassLoader . createBundleClassLoaderFor ( bundle ) ; classLoaders . add ( osgiLoader ) ; return classLoaders ; } public void find ( Test test , String packageName ) { packageName = packageName . replace ( '.' , '/' ) ; Set < ClassLoader > set = getClassLoaders ( ) ; ClassLoader osgiClassLoader = getOsgiClassLoader ( set ) ; if ( osgiClassLoader != null ) { LOG . debug ( "Using only osgi bundle classloader" ) ; findInOsgiClassLoader ( test , packageName , osgiClassLoader ) ; } else { LOG . debug ( "Using only regular classloaders" ) ; for ( ClassLoader classLoader : set ) { if ( ! isOsgiClassloader ( classLoader ) ) { find ( test , packageName , classLoader ) ; } } } } private void findInOsgiClassLoader ( Test test , String packageName , ClassLoader osgiClassLoader ) { try { Method mth = osgiClassLoader . getClass ( ) . getMethod ( "getBundle" , new Class [ ] { } ) ; if ( mth != null ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Loading from osgi buindle using classloader: " + osgiClassLoader ) ; } loadImplementationsInBundle ( test , packageName , osgiClassLoader , mth ) ; return ; } } catch ( NoSuchMethodException e ) { LOG . warn ( "It's not an osgi bundle classloader: " + osgiClassLoader ) ; return ; } } private static ClassLoader getOsgiClassLoader ( Set < ClassLoader > set ) { for ( ClassLoader loader : set ) { if ( isOsgiClassloader ( loader ) ) { return loader ; } } return null ; } private static boolean isOsgiClassloader ( ClassLoader loader ) { try { Method mth = loader . getClass ( ) . getMethod ( "getBundle" , new Class [ ] { } ) ; if ( mth != null ) { return true ; } } catch ( NoSuchMethodException e ) { } return false ; } private void loadImplementationsInBundle ( Test test , String packageName , ClassLoader loader , Method mth ) { Set < String > urls = OsgiUtil . getImplementationsInBundle ( test , packageName , loader , mth ) ; if ( urls != null ) { for ( String url : urls ) { addIfMatching ( test , url ) ; } } } private static final class OsgiUtil { private OsgiUtil ( ) { } static Set < String > getImplementationsInBundle ( Test test , String packageName , ClassLoader loader , Method mth ) { try { org . osgi . framework . Bundle bundle = ( org . osgi . framework . Bundle ) mth . invoke ( loader ) ; org . osgi . framework . Bundle [ ] bundles = bundle . getBundleContext ( ) . getBundles ( ) ; Set < String > urls = new HashSet < String > ( ) ; for ( org . osgi . framework . Bundle bd : bundles ) { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Searching in bundle:" + bd ) ; } Enumeration < URL > paths = bd . findEntries ( "/" + packageName , "*.class" , true ) ; while ( paths != null && paths . hasMoreElements ( ) ) { URL path = paths . nextElement ( ) ; String pathString = path . getPath ( ) ; pathString . indexOf ( packageName ) ; urls . add ( pathString . substring ( pathString . indexOf ( packageName ) ) ) ; } } return urls ; } catch ( Throwable t ) { LOG . error ( "Could not search osgi bundles for classes matching criteria: " + test + "due to an Exception: " + t . getMessage ( ) ) ; return null ; } } } } 	0	['10', '2', '0', '9', '31', '23', '3', '7', '3', '0.777777778', '182', '1', '0', '0.55', '0.242857143', '1', '5', '17.1', '3', '1.5', '0']
package org . apache . camel . component . jdbc ; import javax . sql . DataSource ; import org . apache . camel . Component ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . impl . DefaultExchange ; public class JdbcEndpoint extends DefaultEndpoint < DefaultExchange > { private int readSize ; private DataSource dataSource ; public JdbcEndpoint ( String endpointUri , Component component , DataSource dataSource ) { super ( endpointUri , component ) ; this . dataSource = dataSource ; } public boolean isSingleton ( ) { return true ; } public Consumer < DefaultExchange > createConsumer ( Processor processor ) throws Exception { throw new UnsupportedOperationException ( "Not supported" ) ; } public Producer < DefaultExchange > createProducer ( ) throws Exception { return new JdbcProducer ( this , dataSource , readSize ) ; } public void setReadSize ( int readSize ) { this . readSize = readSize ; } } 	0	['5', '2', '0', '7', '8', '6', '2', '6', '5', '0.75', '35', '1', '0', '0.857142857', '0.333333333', '0', '0', '5.6', '1', '0.8', '0']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "header" ) public class HeaderExpression extends ExpressionType { public HeaderExpression ( ) { } public HeaderExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "header" ; } } 	0	['3', '2', '0', '1', '5', '3', '0', '1', '3', '2', '12', '0', '0', '0.956521739', '0.666666667', '1', '2', '3', '1', '0.3333', '0']
package org . apache . camel ; public class CamelException extends Exception { public CamelException ( ) { } public CamelException ( String message ) { super ( message ) ; } public CamelException ( String message , Throwable cause ) { super ( message , cause ) ; } public CamelException ( Throwable cause ) { super ( cause ) ; } } 	0	['4', '3', '4', '14', '8', '6', '14', '0', '4', '2', '20', '0', '0', '1', '0.666666667', '0', '0', '4', '0', '0', '0']
package org . apache . camel . component . cxf . transport . spring ; import org . springframework . beans . factory . xml . NamespaceHandlerSupport ; public class NamespaceHandler extends NamespaceHandlerSupport { public void init ( ) { registerBeanDefinitionParser ( "conduit" , new CamelConduitDefinitionParser ( ) ) ; registerBeanDefinitionParser ( "destination" , new CamelDestinationDefinitionParser ( ) ) ; } } 	0	['2', '0', '0', '4', '6', '1', '0', '4', '2', '2', '18', '0', '0', '0', '1', '0', '0', '8', '1', '0.5', '0']
package org . apache . camel . component . uface . swing ; import org . apache . camel . CamelContext ; import org . apache . camel . impl . DefaultCamelContext ; public class Main extends org . apache . camel . spring . Main { public static void main ( String ... args ) { new Main ( ) . run ( args ) ; } protected void postProcesCamelContext ( CamelContext camelContext ) throws Exception { super . postProcesCamelContext ( camelContext ) ; SwingBrowser browser = new SwingBrowser ( ( DefaultCamelContext ) camelContext ) ; browser . run ( ) ; } } 	0	['3', '4', '0', '4', '8', '3', '0', '4', '2', '2', '24', '0', '0', '0.973684211', '0.444444444', '1', '1', '7', '1', '0.6667', '0']
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Predicate ; public interface PredicateFactory < E extends Exchange > { Predicate < E > createPredicate ( ) ; } 	0	['1', '1', '0', '1', '1', '0', '0', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . converter . jaxb ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAnyElement ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "objectHeader" ) @ XmlAccessorType ( value = XmlAccessType . FIELD ) public class ObjectHeader extends HeaderType { @ XmlAnyElement ( lax = true ) private Object value ; public ObjectHeader ( ) { } public ObjectHeader ( String name , Object value ) { super ( name ) ; this . value = value ; } public Object getValue ( ) { return value ; } public void setValue ( Object value ) { this . value = value ; } } 	0	['4', '2', '0', '1', '6', '0', '0', '1', '4', '0.333333333', '22', '1', '0', '0.666666667', '0.583333333', '0', '0', '4.25', '1', '0.5', '0']
package org . apache . camel . component . cxf . feature ; import java . util . List ; import java . util . logging . Logger ; import org . apache . cxf . endpoint . Server ; import org . apache . cxf . feature . AbstractFeature ; import org . apache . cxf . interceptor . Interceptor ; import org . apache . cxf . phase . Phase ; import org . apache . cxf . phase . PhaseInterceptor ; public abstract class AbstractDataFormatFeature extends AbstractFeature { protected abstract Logger getLogger ( ) ; protected void resetServiceInvokerInterceptor ( Server server ) { List < Interceptor > serviceInterceptor = server . getEndpoint ( ) . getService ( ) . getInInterceptors ( ) ; removeInterceptorWhichIsInThePhases ( serviceInterceptor , new String [ ] { Phase . INVOKE } ) ; serviceInterceptor . add ( new MessageInvokerInterceptor ( ) ) ; } protected void removeInterceptorWhichIsInThePhases ( List < Interceptor > interceptors , String [ ] phaseNames ) { for ( Interceptor i : interceptors ) { if ( i instanceof PhaseInterceptor ) { PhaseInterceptor p = ( PhaseInterceptor ) i ; for ( String phaseName : phaseNames ) { if ( p . getPhase ( ) . equals ( phaseName ) ) { getLogger ( ) . info ( "removing the interceptor " + p ) ; interceptors . remove ( p ) ; break ; } } } } } protected void removeInterceptorWhichIsOutThePhases ( List < Interceptor > interceptors , String [ ] phaseNames ) { for ( Interceptor i : interceptors ) { boolean outside = false ; if ( i instanceof PhaseInterceptor ) { PhaseInterceptor p = ( PhaseInterceptor ) i ; for ( String phaseName : phaseNames ) { if ( p . getPhase ( ) . equals ( phaseName ) ) { outside = true ; break ; } } if ( ! outside ) { getLogger ( ) . info ( "removing the interceptor " + p ) ; interceptors . remove ( p ) ; } } } } } 	0	['5', '0', '2', '9', '22', '10', '2', '7', '1', '2', '145', '0', '0', '0', '0.5', '0', '0', '28', '4', '1.8', '0']
package org . apache . camel . component . jms ; import java . io . File ; import java . io . InputStream ; import java . io . Reader ; import java . io . Serializable ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . nio . ByteBuffer ; import java . util . Date ; import java . util . Enumeration ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import javax . jms . BytesMessage ; import javax . jms . Destination ; import javax . jms . JMSException ; import javax . jms . MapMessage ; import javax . jms . Message ; import javax . jms . ObjectMessage ; import javax . jms . Session ; import javax . jms . StreamMessage ; import javax . jms . TextMessage ; import javax . xml . transform . TransformerException ; import org . w3c . dom . Node ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . converter . jaxp . XmlConverter ; import org . apache . camel . impl . DefaultHeaderFilterStrategy ; import org . apache . camel . spi . HeaderFilterStrategy ; import org . apache . camel . util . CamelContextHelper ; import org . apache . camel . util . ExchangeHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class JmsBinding { private static final transient Log LOG = LogFactory . getLog ( JmsBinding . class ) ; private JmsEndpoint endpoint ; private XmlConverter xmlConverter = new XmlConverter ( ) ; private HeaderFilterStrategy headerFilterStrategy ; public JmsBinding ( ) { headerFilterStrategy = new JmsHeaderFilterStrategy ( ) ; } public JmsBinding ( JmsEndpoint endpoint ) { this . endpoint = endpoint ; headerFilterStrategy = endpoint . getHeaderFilterStrategy ( ) ; if ( headerFilterStrategy == null ) { headerFilterStrategy = new JmsHeaderFilterStrategy ( ) ; } } public Object extractBodyFromJms ( Exchange exchange , Message message ) { try { if ( message instanceof ObjectMessage ) { ObjectMessage objectMessage = ( ObjectMessage ) message ; return objectMessage . getObject ( ) ; } else if ( message instanceof TextMessage ) { TextMessage textMessage = ( TextMessage ) message ; return textMessage . getText ( ) ; } else if ( message instanceof MapMessage ) { return createMapFromMapMessage ( ( MapMessage ) message ) ; } else if ( message instanceof BytesMessage ) { return createByteArrayFromBytesMessage ( ( BytesMessage ) message ) ; } else if ( message instanceof StreamMessage ) { return message ; } else { return null ; } } catch ( JMSException e ) { throw new RuntimeJmsException ( "Failed to extract body due to: " + e + ". Message: " + message , e ) ; } } public Map < String , Object > extractHeadersFromJms ( Message jmsMessage ) { Map < String , Object > map = new HashMap < String , Object > ( ) ; if ( jmsMessage != null ) { try { map . put ( "JMSCorrelationID" , jmsMessage . getJMSCorrelationID ( ) ) ; map . put ( "JMSDeliveryMode" , jmsMessage . getJMSDeliveryMode ( ) ) ; map . put ( "JMSDestination" , jmsMessage . getJMSDestination ( ) ) ; map . put ( "JMSExpiration" , jmsMessage . getJMSExpiration ( ) ) ; map . put ( "JMSMessageID" , jmsMessage . getJMSMessageID ( ) ) ; map . put ( "JMSPriority" , jmsMessage . getJMSPriority ( ) ) ; map . put ( "JMSRedelivered" , jmsMessage . getJMSRedelivered ( ) ) ; map . put ( "JMSReplyTo" , jmsMessage . getJMSReplyTo ( ) ) ; map . put ( "JMSTimestamp" , jmsMessage . getJMSTimestamp ( ) ) ; map . put ( "JMSType" , jmsMessage . getJMSType ( ) ) ; map . put ( "JMSXGroupID" , jmsMessage . getStringProperty ( "JMSXGroupID" ) ) ; } catch ( JMSException e ) { throw new MessageJMSPropertyAccessException ( e ) ; } Enumeration names ; try { names = jmsMessage . getPropertyNames ( ) ; } catch ( JMSException e ) { throw new MessagePropertyNamesAccessException ( e ) ; } while ( names . hasMoreElements ( ) ) { String name = names . nextElement ( ) . toString ( ) ; try { Object value = jmsMessage . getObjectProperty ( name ) ; if ( headerFilterStrategy != null && headerFilterStrategy . applyFilterToExternalHeaders ( name , value ) ) { continue ; } String key = JmsBinding . decodeFromSafeJmsHeaderName ( name ) ; map . put ( key , value ) ; } catch ( JMSException e ) { throw new MessagePropertyAccessException ( name , e ) ; } } } return map ; } protected byte [ ] createByteArrayFromBytesMessage ( BytesMessage message ) throws JMSException { if ( message . getBodyLength ( ) > Integer . MAX_VALUE ) { return null ; } byte [ ] result = new byte [ ( int ) message . getBodyLength ( ) ] ; message . readBytes ( result ) ; return result ; } public Message makeJmsMessage ( Exchange exchange , Session session ) throws JMSException { return makeJmsMessage ( exchange , exchange . getIn ( ) , session ) ; } public Message makeJmsMessage ( Exchange exchange , org . apache . camel . Message camelMessage , Session session ) throws JMSException { Message answer = null ; boolean alwaysCopy = ( endpoint != null ) ? endpoint . getConfiguration ( ) . isAlwaysCopyMessage ( ) : false ; if ( ! alwaysCopy && camelMessage instanceof JmsMessage ) { JmsMessage jmsMessage = ( JmsMessage ) camelMessage ; if ( ! jmsMessage . shouldCreateNewMessage ( ) ) { answer = jmsMessage . getJmsMessage ( ) ; } } if ( answer == null ) { answer = createJmsMessage ( camelMessage . getBody ( ) , session , exchange . getContext ( ) ) ; appendJmsProperties ( answer , exchange , camelMessage ) ; } return answer ; } public void appendJmsProperties ( Message jmsMessage , Exchange exchange ) throws JMSException { appendJmsProperties ( jmsMessage , exchange , exchange . getIn ( ) ) ; } public void appendJmsProperties ( Message jmsMessage , Exchange exchange , org . apache . camel . Message in ) throws JMSException { Set < Map . Entry < String , Object > > entries = in . getHeaders ( ) . entrySet ( ) ; for ( Map . Entry < String , Object > entry : entries ) { String headerName = entry . getKey ( ) ; Object headerValue = entry . getValue ( ) ; appendJmsProperty ( jmsMessage , exchange , in , headerName , headerValue ) ; } } public void appendJmsProperty ( Message jmsMessage , Exchange exchange , org . apache . camel . Message in , String headerName , Object headerValue ) throws JMSException { if ( headerName . startsWith ( "JMS" ) && ! headerName . startsWith ( "JMSX" ) ) { if ( headerName . equals ( "JMSCorrelationID" ) ) { jmsMessage . setJMSCorrelationID ( ExchangeHelper . convertToType ( exchange , String . class , headerValue ) ) ; } else if ( headerName . equals ( "JMSReplyTo" ) && headerValue != null ) { jmsMessage . setJMSReplyTo ( ExchangeHelper . convertToType ( exchange , Destination . class , headerValue ) ) ; } else if ( headerName . equals ( "JMSType" ) ) { jmsMessage . setJMSType ( ExchangeHelper . convertToType ( exchange , String . class , headerValue ) ) ; } else if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Ignoring JMS header: " + headerName + " with value: " + headerValue ) ; } } else if ( shouldOutputHeader ( in , headerName , headerValue ) ) { String key = encodeToSafeJmsHeaderName ( headerName ) ; Object value = getValidJMSHeaderValue ( headerName , headerValue ) ; if ( value != null ) { jmsMessage . setObjectProperty ( key , value ) ; } else if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Ignoring non primitive header: " + headerName + " of class: " + headerValue . getClass ( ) . getName ( ) + " with value: " + headerValue ) ; } } } protected Object getValidJMSHeaderValue ( String headerName , Object headerValue ) { if ( headerValue . getClass ( ) . isPrimitive ( ) ) { return headerValue ; } else if ( headerValue instanceof String ) { return headerValue ; } else if ( headerValue instanceof Number ) { return headerValue ; } else if ( headerValue instanceof Character ) { return headerValue . toString ( ) ; } else if ( headerValue instanceof BigDecimal || headerValue instanceof BigInteger ) { return headerValue . toString ( ) ; } else if ( headerValue instanceof CharSequence ) { return headerValue . toString ( ) ; } else if ( headerValue instanceof Boolean ) { return headerValue . toString ( ) ; } else if ( headerValue instanceof Date ) { return headerValue . toString ( ) ; } return null ; } protected Message createJmsMessage ( Object body , Session session , CamelContext context ) throws JMSException { if ( body instanceof Node ) { try { body = xmlConverter . toString ( ( Node ) body ) ; } catch ( TransformerException e ) { JMSException jmsException = new JMSException ( e . getMessage ( ) ) ; jmsException . setLinkedException ( e ) ; throw jmsException ; } } if ( body instanceof byte [ ] ) { BytesMessage result = session . createBytesMessage ( ) ; result . writeBytes ( ( byte [ ] ) body ) ; return result ; } if ( body instanceof Map ) { MapMessage result = session . createMapMessage ( ) ; Map < ? , ? > map = ( Map < ? , ? > ) body ; try { populateMapMessage ( result , map , context ) ; return result ; } catch ( JMSException e ) { LOG . warn ( "Can not populate MapMessage will fall back to ObjectMessage, cause by: " + e . getMessage ( ) ) ; } } if ( body instanceof String ) { return session . createTextMessage ( ( String ) body ) ; } if ( body instanceof File || body instanceof Reader || body instanceof InputStream || body instanceof ByteBuffer ) { BytesMessage result = session . createBytesMessage ( ) ; byte [ ] bytes = context . getTypeConverter ( ) . convertTo ( byte [ ] . class , body ) ; result . writeBytes ( bytes ) ; return result ; } if ( body instanceof Serializable ) { return session . createObjectMessage ( ( Serializable ) body ) ; } return session . createMessage ( ) ; } protected void populateMapMessage ( MapMessage message , Map < ? , ? > map , CamelContext context ) throws JMSException { for ( Object key : map . keySet ( ) ) { String keyString = CamelContextHelper . convertTo ( context , String . class , key ) ; if ( keyString != null ) { message . setObject ( keyString , map . get ( key ) ) ; } } } public Map < String , Object > createMapFromMapMessage ( MapMessage message ) throws JMSException { Map < String , Object > answer = new HashMap < String , Object > ( ) ; Enumeration names = message . getMapNames ( ) ; while ( names . hasMoreElements ( ) ) { String name = names . nextElement ( ) . toString ( ) ; Object value = message . getObject ( name ) ; answer . put ( name , value ) ; } return answer ; } public Set < String > getIgnoreJmsHeaders ( ) { if ( headerFilterStrategy instanceof DefaultHeaderFilterStrategy ) { return ( ( DefaultHeaderFilterStrategy ) headerFilterStrategy ) . getOutFilter ( ) ; } else { return null ; } } public void setIgnoreJmsHeaders ( Set < String > ignoreJmsHeaders ) { if ( headerFilterStrategy instanceof DefaultHeaderFilterStrategy ) { ( ( DefaultHeaderFilterStrategy ) headerFilterStrategy ) . setOutFilter ( ignoreJmsHeaders ) ; } else { } } protected boolean shouldOutputHeader ( org . apache . camel . Message camelMessage , String headerName , Object headerValue ) { return headerFilterStrategy == null || ! headerFilterStrategy . applyFilterToCamelHeaders ( headerName , headerValue ) ; } public static String encodeToSafeJmsHeaderName ( String headerName ) { return headerName . replace ( "." , "_" ) ; } public static String decodeFromSafeJmsHeaderName ( String headerName ) { return headerName . replace ( "_" , "." ) ; } } 	0	['20', '1', '0', '27', '109', '148', '11', '19', '14', '0.802631579', '728', '1', '3', '0', '0.210526316', '0', '0', '35.2', '10', '1.95', '0']
package org . apache . camel ; public class ValidationException extends CamelExchangeException { public ValidationException ( Exchange exchange , String message ) { super ( message , exchange ) ; } public ValidationException ( String message , Exchange exchange , Throwable cause ) { super ( message , exchange , cause ) ; } } 	0	['2', '5', '2', '6', '4', '1', '4', '2', '2', '2', '13', '0', '0', '1', '0.875', '0', '0', '5.5', '0', '0', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . builder . ExpressionBuilder ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . RecipientList ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "recipientList" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class RecipientListType extends ExpressionNode { @ XmlAttribute ( required = false ) private String delimiter ; public RecipientListType ( ) { } public RecipientListType ( ExpressionType expression ) { super ( expression ) ; } public RecipientListType ( Expression expression ) { super ( expression ) ; } @ Override public String toString ( ) { return "RecipientList[" + getExpression ( ) + "]" ; } @ Override public String getShortName ( ) { return "recipientList" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { Expression expression = getExpression ( ) . createExpression ( routeContext ) ; if ( delimiter != null ) { expression = ExpressionBuilder . tokenizeExpression ( expression , delimiter ) ; } return new RecipientList ( expression ) ; } public String getDelimiter ( ) { return delimiter ; } public void setDelimiter ( String delimiter ) { this . delimiter = delimiter ; } } 	0	['8', '4', '0', '9', '19', '22', '2', '7', '8', '0.714285714', '59', '1', '0', '0.973544974', '0.3', '2', '3', '6.25', '1', '0.625', '0']
package org . apache . camel . converter . jaxp ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . Reader ; import java . io . Writer ; import javax . xml . stream . XMLEventReader ; import javax . xml . stream . XMLEventWriter ; import javax . xml . stream . XMLInputFactory ; import javax . xml . stream . XMLOutputFactory ; import javax . xml . stream . XMLStreamException ; import javax . xml . stream . XMLStreamReader ; import javax . xml . stream . XMLStreamWriter ; import javax . xml . transform . Result ; import javax . xml . transform . Source ; import javax . xml . transform . stream . StreamSource ; import org . apache . camel . Converter ; @ Converter public class StreamSourceConverter { @ Converter public InputStream toInputStream ( StreamSource source ) { return source . getInputStream ( ) ; } @ Converter public Reader toReader ( StreamSource source ) { return source . getReader ( ) ; } } 	0	['3', '1', '0', '0', '6', '3', '0', '0', '3', '2', '12', '0', '0', '0', '0.833333333', '0', '0', '3', '1', '0.6667', '0']
package org . apache . camel . component . jms ; import java . util . ArrayList ; import java . util . Enumeration ; import java . util . List ; import javax . jms . JMSException ; import javax . jms . Message ; import javax . jms . QueueBrowser ; import javax . jms . Session ; import org . apache . camel . Exchange ; import org . springframework . jms . core . BrowserCallback ; import org . springframework . jms . core . JmsOperations ; public class DefaultQueueBrowseStrategy implements QueueBrowseStrategy { public List < Exchange > browse ( JmsOperations template , String queue , final JmsQueueEndpoint endpoint ) { return ( List < Exchange > ) template . browse ( queue , new BrowserCallback ( ) { public Object doInJms ( Session session , QueueBrowser browser ) throws JMSException { List < Exchange > answer = new ArrayList < Exchange > ( ) ; Enumeration iter = browser . getEnumeration ( ) ; while ( iter . hasMoreElements ( ) ) { Message message = ( Message ) iter . nextElement ( ) ; JmsExchange exchange = endpoint . createExchange ( message ) ; answer . add ( exchange ) ; } return answer ; } } ) ; } } 	0	['2', '1', '0', '5', '5', '1', '1', '5', '2', '2', '15', '0', '0', '0', '0.625', '0', '0', '6.5', '1', '0.5', '0']
package org . apache . camel . model ; import java . util . Collections ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . processor . ConvertBodyProcessor ; import org . apache . camel . spi . RouteContext ; import org . apache . camel . util . ObjectHelper ; @ XmlRootElement ( name = "convertBodyTo" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ConvertBodyType extends ProcessorType < ProcessorType > { @ XmlAttribute private String type ; @ XmlTransient private Class typeClass ; public ConvertBodyType ( ) { } public ConvertBodyType ( String type ) { setType ( type ) ; } public ConvertBodyType ( Class typeClass ) { setTypeClass ( typeClass ) ; setType ( typeClass . getName ( ) ) ; } @ Override public String toString ( ) { return "convertBodyTo[" + getType ( ) + "]" ; } @ Override public String getShortName ( ) { return "convertBodyTo" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { return new ConvertBodyProcessor ( getTypeClass ( ) ) ; } @ Override public List < ProcessorType < ? > > getOutputs ( ) { return Collections . EMPTY_LIST ; } protected Class createTypeClass ( ) { return ObjectHelper . loadClass ( getType ( ) , getClass ( ) . getClassLoader ( ) ) ; } public void setType ( String type ) { this . type = type ; } public String getType ( ) { return type ; } public void setTypeClass ( Class typeClass ) { this . typeClass = typeClass ; } public Class getTypeClass ( ) { if ( typeClass == null ) { Class clazz = createTypeClass ( ) ; if ( clazz == null ) { throw new RuntimeCamelException ( "Can't load the class with the class name: " + getType ( ) ) ; } setTypeClass ( clazz ) ; } return typeClass ; } } 	0	['12', '3', '0', '6', '22', '62', '1', '6', '11', '0.590909091', '100', '1', '0', '0.951351351', '0.354166667', '1', '3', '7.166666667', '3', '0.9167', '0']
package org . apache . camel . model . dataformat ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . w3c . dom . Node ; import org . apache . camel . spi . DataFormat ; @ XmlRootElement ( name = "tidyMarkup" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class TidyMarkupDataFormat extends DataFormatType { @ XmlAttribute ( required = false ) private Class < ? > dataObjectType ; public TidyMarkupDataFormat ( ) { super ( "org.apache.camel.dataformat.tagsoup.TidyMarkupDataFormat" ) ; this . setDataObjectType ( Node . class ) ; } public TidyMarkupDataFormat ( Class < ? > dataObjectType ) { this ( ) ; if ( ! dataObjectType . isAssignableFrom ( String . class ) && ! dataObjectType . isAssignableFrom ( Node . class ) ) { throw new IllegalArgumentException ( "TidyMarkupDataFormat only supports returning a String or a org.w3c.dom.Node object" ) ; } this . setDataObjectType ( dataObjectType ) ; } public void setDataObjectType ( Class < ? > dataObjectType ) { this . dataObjectType = dataObjectType ; } public Class < ? > getDataObjectType ( ) { return dataObjectType ; } @ Override protected void configureDataFormat ( DataFormat dataFormat ) { Class < ? > type = getDataObjectType ( ) ; if ( type != null ) { setProperty ( dataFormat , "dataObjectType" , type ) ; } } } 	0	['5', '3', '0', '3', '9', '8', '1', '2', '4', '0', '50', '1', '0', '0.75', '0.533333333', '1', '2', '8.8', '2', '0.8', '0']
package org . apache . camel . component . http ; import java . io . IOException ; import java . io . InputStream ; import java . io . UnsupportedEncodingException ; import java . util . Arrays ; import java . util . HashSet ; import java . util . Set ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . NoTypeConversionAvailableException ; import org . apache . camel . Producer ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . component . http . helper . LoadingByteArrayOutputStream ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . spi . HeaderFilterStrategy ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . httpclient . Header ; import org . apache . commons . httpclient . HttpClient ; import org . apache . commons . httpclient . HttpMethod ; import org . apache . commons . httpclient . methods . EntityEnclosingMethod ; import org . apache . commons . httpclient . methods . RequestEntity ; import org . apache . commons . httpclient . methods . StringRequestEntity ; import org . apache . commons . io . IOUtils ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import static org . apache . camel . component . http . HttpMethods . HTTP_METHOD ; public class HttpProducer extends DefaultProducer < HttpExchange > implements Producer < HttpExchange > { public static final String HTTP_URI = "http.uri" ; public static final String HTTP_RESPONSE_CODE = "http.responseCode" ; public static final String QUERY = "org.apache.camel.component.http.query" ; @ Deprecated public static final Set < String > HEADERS_TO_SKIP = new HashSet < String > ( Arrays . asList ( "content-length" , "content-type" , HTTP_RESPONSE_CODE . toLowerCase ( ) ) ) ; private static final transient Log LOG = LogFactory . getLog ( HttpProducer . class ) ; private HttpClient httpClient ; public HttpProducer ( HttpEndpoint endpoint ) { super ( endpoint ) ; httpClient = endpoint . createHttpClient ( ) ; } public void process ( Exchange exchange ) throws Exception { HttpMethod method = createMethod ( exchange ) ; Message in = exchange . getIn ( ) ; HeaderFilterStrategy strategy = ( ( HttpEndpoint ) getEndpoint ( ) ) . getHeaderFilterStrategy ( ) ; for ( String headerName : in . getHeaders ( ) . keySet ( ) ) { String headerValue = in . getHeader ( headerName , String . class ) ; if ( strategy != null && ! strategy . applyFilterToCamelHeaders ( headerName , headerValue ) ) { method . addRequestHeader ( headerName , headerValue ) ; } } try { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Executing http " + method . getName ( ) + " method: " + method . getURI ( ) . toString ( ) ) ; } int responseCode = executeMethod ( method ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Http responseCode: " + responseCode ) ; } if ( responseCode >= 100 && responseCode < 300 ) { Message answer = exchange . getOut ( true ) ; answer . setHeaders ( in . getHeaders ( ) ) ; answer . setHeader ( HTTP_RESPONSE_CODE , responseCode ) ; answer . setBody ( extractResponseBody ( method ) ) ; Header [ ] headers = method . getResponseHeaders ( ) ; for ( Header header : headers ) { String name = header . getName ( ) ; String value = header . getValue ( ) ; if ( strategy != null && ! strategy . applyFilterToExternalHeaders ( name , value ) ) { answer . setHeader ( name , value ) ; } } } else { HttpOperationFailedException exception = null ; Header [ ] headers = method . getResponseHeaders ( ) ; InputStream is = extractResponseBody ( method ) ; if ( responseCode >= 300 && responseCode < 400 ) { String redirectLocation ; Header locationHeader = method . getResponseHeader ( "location" ) ; if ( locationHeader != null ) { redirectLocation = locationHeader . getValue ( ) ; exception = new HttpOperationFailedException ( responseCode , method . getStatusLine ( ) , redirectLocation , headers , is ) ; } else { exception = new HttpOperationFailedException ( responseCode , method . getStatusLine ( ) , headers , is ) ; } } else { exception = new HttpOperationFailedException ( responseCode , method . getStatusLine ( ) , headers , is ) ; } if ( exception != null ) { throw exception ; } } } finally { method . releaseConnection ( ) ; } } protected int executeMethod ( HttpMethod method ) throws IOException { return httpClient . executeMethod ( method ) ; } protected static InputStream extractResponseBody ( HttpMethod method ) throws IOException { LoadingByteArrayOutputStream bos = null ; InputStream is = null ; try { bos = new LoadingByteArrayOutputStream ( ) ; is = method . getResponseBodyAsStream ( ) ; if ( is == null ) { return null ; } IOUtils . copy ( is , bos ) ; bos . flush ( ) ; return bos . createInputStream ( ) ; } finally { ObjectHelper . close ( is , "Extracting response body" , LOG ) ; ObjectHelper . close ( bos , "Extracting response body" , LOG ) ; } } protected HttpMethod createMethod ( Exchange exchange ) { String queryString = exchange . getIn ( ) . getHeader ( QUERY , String . class ) ; if ( queryString == null ) { queryString = ( ( HttpEndpoint ) getEndpoint ( ) ) . getHttpUri ( ) . getQuery ( ) ; } RequestEntity requestEntity = createRequestEntity ( exchange ) ; HttpMethods methodToUse ; HttpMethods m = exchange . getIn ( ) . getHeader ( HTTP_METHOD , HttpMethods . class ) ; if ( m != null ) { methodToUse = m ; } else if ( queryString != null ) { methodToUse = HttpMethods . GET ; } else { methodToUse = requestEntity != null ? HttpMethods . POST : HttpMethods . GET ; } String uri = exchange . getIn ( ) . getHeader ( HTTP_URI , String . class ) ; if ( uri == null ) { uri = ( ( HttpEndpoint ) getEndpoint ( ) ) . getHttpUri ( ) . toString ( ) ; } HttpMethod method = methodToUse . createMethod ( uri ) ; if ( queryString != null ) { method . setQueryString ( queryString ) ; } if ( methodToUse . isEntityEnclosing ( ) ) { ( ( EntityEnclosingMethod ) method ) . setRequestEntity ( requestEntity ) ; } return method ; } protected RequestEntity createRequestEntity ( Exchange exchange ) { Message in = exchange . getIn ( ) ; if ( in . getBody ( ) == null ) { return null ; } try { return in . getBody ( RequestEntity . class ) ; } catch ( NoTypeConversionAvailableException ex ) { try { String data = in . getBody ( String . class ) ; if ( data != null ) { String contentType = in . getHeader ( "Content-Type" , String . class ) ; String charset = exchange . getProperty ( Exchange . CHARSET_NAME , String . class ) ; return new StringRequestEntity ( data , contentType , charset ) ; } else { return null ; } } catch ( UnsupportedEncodingException e ) { throw new RuntimeCamelException ( e ) ; } } } public HttpClient getHttpClient ( ) { return httpClient ; } public void setHttpClient ( HttpClient httpClient ) { this . httpClient = httpClient ; } } 	0	['9', '3', '0', '24', '68', '18', '1', '24', '4', '0.9375', '442', '0.333333333', '0', '0.75', '0.35', '0', '0', '47.44444444', '8', '1.7778', '0']
package org . apache . camel . component . ibatis ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . impl . PollingConsumerSupport ; public class IBatisPollingConsumer extends PollingConsumerSupport { private final IBatisEndpoint endpoint ; public IBatisPollingConsumer ( IBatisEndpoint endpoint ) { super ( endpoint ) ; this . endpoint = endpoint ; } public Exchange receive ( long timeout ) { return receiveNoWait ( ) ; } public Exchange receive ( ) { return receiveNoWait ( ) ; } public Exchange receiveNoWait ( ) { try { Exchange exchange = endpoint . createExchange ( ) ; Message in = exchange . getIn ( ) ; endpoint . query ( in ) ; return exchange ; } catch ( Exception e ) { throw new RuntimeCamelException ( "Failed to poll: " + endpoint + ". Reason: " + e , e ) ; } } protected void doStart ( ) throws Exception { } protected void doStop ( ) throws Exception { } } 	0	['6', '3', '0', '6', '15', '13', '1', '6', '4', '0.4', '54', '1', '1', '0.791666667', '0.444444444', '1', '1', '7.833333333', '1', '0.8333', '0']
package org . apache . camel . component . file . remote ; import org . apache . camel . RuntimeCamelException ; public class FtpOperationFailedException extends RuntimeCamelException { private final int code ; private final String reason ; public FtpOperationFailedException ( int code , String reason ) { super ( "Ftp operation failed: " + reason + ". Code: " + code ) ; this . code = code ; this . reason = reason ; } public FtpOperationFailedException ( int code , String reason , String message ) { this ( code , reason + " " + message ) ; } public int getCode ( ) { return code ; } public String getReason ( ) { return reason ; } } 	0	['4', '5', '0', '3', '9', '2', '2', '1', '4', '0.333333333', '47', '1', '0', '0.894736842', '0.666666667', '0', '0', '10.25', '1', '0.5', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Processor ; import org . apache . camel . spi . Policy ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "policy" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class PolicyRef extends OutputType < ProcessorType > { @ XmlAttribute ( required = true ) private String ref ; @ XmlTransient private Policy policy ; public PolicyRef ( ) { } public PolicyRef ( Policy policy ) { this . policy = policy ; } @ Override public String toString ( ) { return "Policy[" + description ( ) + "]" ; } @ Override public String getShortName ( ) { return "policy" ; } @ Override public String getLabel ( ) { if ( ref != null ) { return "ref:  " + ref ; } else if ( policy != null ) { return policy . toString ( ) ; } else { return "" ; } } public String getRef ( ) { return ref ; } public void setRef ( String ref ) { this . ref = ref ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { Processor childProcessor = createOutputsProcessor ( routeContext ) ; Policy policy = resolvePolicy ( routeContext ) ; if ( policy == null ) { throw new IllegalArgumentException ( "No policy configured: " + this ) ; } return policy . wrap ( childProcessor ) ; } protected Policy resolvePolicy ( RouteContext routeContext ) { if ( policy == null ) { policy = routeContext . lookup ( getRef ( ) , Policy . class ) ; } return policy ; } protected String description ( ) { if ( policy != null ) { return policy . toString ( ) ; } else { return "ref: " + ref ; } } } 	0	['10', '4', '0', '5', '20', '23', '1', '4', '8', '0.444444444', '121', '1', '1', '0.957219251', '0.35', '1', '2', '10.9', '3', '1.2', '0']
package org . apache . camel . builder . xml ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . Result ; import javax . xml . transform . Source ; import javax . xml . transform . Templates ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . stream . StreamSource ; import org . apache . camel . Exchange ; import org . apache . camel . ExpectedBodyTypeException ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeTransformException ; import org . apache . camel . converter . jaxp . XmlConverter ; import static org . apache . camel . util . ObjectHelper . notNull ; public class XsltBuilder implements Processor { private Map < String , Object > parameters = new HashMap < String , Object > ( ) ; private XmlConverter converter = new XmlConverter ( ) ; private Templates template ; private ResultHandlerFactory resultHandlerFactory = new StringResultHandlerFactory ( ) ; private boolean failOnNullBody = true ; public XsltBuilder ( ) { } public XsltBuilder ( Templates templates ) { this . template = templates ; } @ Override public String toString ( ) { return "XSLT[" + template + "]" ; } public void process ( Exchange exchange ) throws Exception { if ( getTemplate ( ) == null ) { throw new IllegalArgumentException ( "No template configured!" ) ; } Transformer transformer = getTemplate ( ) . newTransformer ( ) ; configureTransformer ( transformer , exchange ) ; Source source = getSource ( exchange ) ; ResultHandler resultHandler = resultHandlerFactory . createResult ( ) ; Result result = resultHandler . getResult ( ) ; Message out = exchange . getOut ( true ) ; out . copyFrom ( exchange . getIn ( ) ) ; transformer . transform ( source , result ) ; resultHandler . setBody ( out ) ; } public static XsltBuilder xslt ( Templates templates ) { return new XsltBuilder ( templates ) ; } public static XsltBuilder xslt ( Source xslt ) throws TransformerConfigurationException { notNull ( xslt , "xslt" ) ; XsltBuilder answer = new XsltBuilder ( ) ; answer . setTransformerSource ( xslt ) ; return answer ; } public static XsltBuilder xslt ( File xslt ) throws TransformerConfigurationException { notNull ( xslt , "xslt" ) ; return xslt ( new StreamSource ( xslt ) ) ; } public static XsltBuilder xslt ( URL xslt ) throws TransformerConfigurationException , IOException { notNull ( xslt , "xslt" ) ; return xslt ( xslt . openStream ( ) ) ; } public static XsltBuilder xslt ( InputStream xslt ) throws TransformerConfigurationException , IOException { notNull ( xslt , "xslt" ) ; return xslt ( new StreamSource ( xslt ) ) ; } public XsltBuilder outputBytes ( ) { setResultHandlerFactory ( new StreamResultHandlerFactory ( ) ) ; return this ; } public XsltBuilder outputString ( ) { setResultHandlerFactory ( new StringResultHandlerFactory ( ) ) ; return this ; } public XsltBuilder outputDOM ( ) { setResultHandlerFactory ( new DomResultHandlerFactory ( ) ) ; return this ; } public XsltBuilder parameter ( String name , Object value ) { parameters . put ( name , value ) ; return this ; } public Map < String , Object > getParameters ( ) { return parameters ; } public void setParameters ( Map < String , Object > parameters ) { this . parameters = parameters ; } public void setTemplate ( Templates template ) { this . template = template ; } public Templates getTemplate ( ) { return template ; } public boolean isFailOnNullBody ( ) { return failOnNullBody ; } public void setFailOnNullBody ( boolean failOnNullBody ) { this . failOnNullBody = failOnNullBody ; } public ResultHandlerFactory getResultHandlerFactory ( ) { return resultHandlerFactory ; } public void setResultHandlerFactory ( ResultHandlerFactory resultHandlerFactory ) { this . resultHandlerFactory = resultHandlerFactory ; } public void setTransformerSource ( Source source ) throws TransformerConfigurationException { Templates templates = converter . getTransformerFactory ( ) . newTemplates ( source ) ; if ( templates != null ) { setTemplate ( templates ) ; } else { throw new TransformerConfigurationException ( "Error creating XSLT template. " + "This is most likely be caused by an XML parse error. " + "Please verify your XSLT file configured." ) ; } } public void setTransformerFile ( File xslt ) throws TransformerConfigurationException { setTransformerSource ( new StreamSource ( xslt ) ) ; } public void setTransformerURL ( URL url ) throws TransformerConfigurationException , IOException { notNull ( url , "url" ) ; setTransformerInputStream ( url . openStream ( ) ) ; } public void setTransformerInputStream ( InputStream in ) throws TransformerConfigurationException , IOException { notNull ( in , "in" ) ; setTransformerSource ( new StreamSource ( in ) ) ; } public XmlConverter getConverter ( ) { return converter ; } public void setConverter ( XmlConverter converter ) { this . converter = converter ; } protected Source getSource ( Exchange exchange ) { Message in = exchange . getIn ( ) ; Source source = in . getBody ( Source . class ) ; if ( source == null ) { if ( isFailOnNullBody ( ) ) { throw new ExpectedBodyTypeException ( exchange , Source . class ) ; } else { try { source = converter . toSource ( converter . createDocument ( ) ) ; } catch ( ParserConfigurationException e ) { throw new RuntimeTransformException ( e ) ; } } } return source ; } protected void configureTransformer ( Transformer transformer , Exchange exchange ) { transformer . clearParameters ( ) ; addParameters ( transformer , exchange . getProperties ( ) ) ; addParameters ( transformer , exchange . getIn ( ) . getHeaders ( ) ) ; addParameters ( transformer , getParameters ( ) ) ; transformer . setParameter ( "exchange" , exchange ) ; transformer . setParameter ( "in" , exchange . getIn ( ) ) ; transformer . setParameter ( "out" , exchange . getOut ( ) ) ; } protected void addParameters ( Transformer transformer , Map < String , Object > map ) { Set < Map . Entry < String , Object > > propertyEntries = map . entrySet ( ) ; for ( Map . Entry < String , Object > entry : propertyEntries ) { String key = entry . getKey ( ) ; Object value = entry . getValue ( ) ; if ( value != null ) { transformer . setParameter ( key , value ) ; } } } } 	0	['30', '1', '0', '13', '73', '347', '1', '12', '27', '0.668965517', '380', '1', '2', '0', '0.114285714', '0', '0', '11.5', '3', '1.0333', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Processor ; import org . apache . camel . processor . Throttler ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "throttler" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ThrottlerType extends ProcessorType < ProcessorType > { @ XmlAttribute private Long maximumRequestsPerPeriod ; @ XmlAttribute private long timePeriodMillis = 1000 ; @ XmlElementRef private List < ProcessorType < ? > > outputs = new ArrayList < ProcessorType < ? > > ( ) ; public ThrottlerType ( ) { } public ThrottlerType ( long maximumRequestsPerPeriod ) { this . maximumRequestsPerPeriod = maximumRequestsPerPeriod ; } @ Override public String toString ( ) { return "Throttler[" + getMaximumRequestsPerPeriod ( ) + " request per " + getTimePeriodMillis ( ) + " millis -> " + getOutputs ( ) + "]" ; } @ Override public String getShortName ( ) { return "throttler" ; } @ Override public String getLabel ( ) { return "" + getMaximumRequestsPerPeriod ( ) + " per " + getTimePeriodMillis ( ) + " (ms)" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { Processor childProcessor = routeContext . createProcessor ( this ) ; return new Throttler ( childProcessor , maximumRequestsPerPeriod , timePeriodMillis ) ; } public ThrottlerType timePeriodMillis ( long timePeriodMillis ) { setTimePeriodMillis ( timePeriodMillis ) ; return this ; } public ThrottlerType maximumRequestsPerPeriod ( Long maximumRequestsPerPeriod ) { setMaximumRequestsPerPeriod ( maximumRequestsPerPeriod ) ; return this ; } public Long getMaximumRequestsPerPeriod ( ) { return maximumRequestsPerPeriod ; } public void setMaximumRequestsPerPeriod ( Long maximumRequestsPerPeriod ) { this . maximumRequestsPerPeriod = maximumRequestsPerPeriod ; } public long getTimePeriodMillis ( ) { return timePeriodMillis ; } public void setTimePeriodMillis ( long timePeriodMillis ) { this . timePeriodMillis = timePeriodMillis ; } public List < ProcessorType < ? > > getOutputs ( ) { return outputs ; } public void setOutputs ( List < ProcessorType < ? > > outputs ) { this . outputs = outputs ; } } 	0	['14', '3', '0', '6', '25', '51', '3', '4', '14', '0.564102564', '129', '1', '0', '0.936170213', '0.3', '1', '3', '8', '1', '0.8571', '0']
package org . apache . camel . component . file . strategy ; import java . io . File ; import org . apache . camel . component . file . FileExchange ; public interface FileRenamer { File renameFile ( FileExchange exchange , File file ) ; } 	0	['1', '1', '0', '6', '1', '0', '5', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . cxf . invoker ; import java . io . IOException ; import java . io . InputStream ; import java . util . Map ; import java . util . logging . Logger ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . helpers . IOUtils ; import org . apache . cxf . io . CachedOutputStream ; import org . apache . cxf . message . Message ; public abstract class AbstractInvokingContext implements InvokingContext { protected abstract Logger getLogger ( ) ; protected < T > T getResponseObject ( Message inMessage , Map < String , Object > responseContext , Class < T > clazz ) { T retval = null ; if ( inMessage != null ) { if ( null != responseContext ) { responseContext . putAll ( inMessage ) ; getLogger ( ) . info ( "set responseContext to be" + responseContext ) ; } retval = inMessage . getContent ( clazz ) ; } return retval ; } protected void loggerTheMessage ( Message message , String messageTile ) { StringBuffer buffer = new StringBuffer ( messageTile + "\n" + "--------------------------------------" ) ; InputStream is = message . getContent ( InputStream . class ) ; if ( is != null ) { CachedOutputStream bos = new CachedOutputStream ( ) ; try { IOUtils . copy ( is , bos ) ; is . close ( ) ; bos . close ( ) ; buffer . append ( "\nMessage:\n" ) ; buffer . append ( bos . getOut ( ) . toString ( ) ) ; message . setContent ( InputStream . class , bos . getInputStream ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } buffer . append ( "\n--------------------------------------" ) ; getLogger ( ) . info ( buffer . toString ( ) ) ; } } 	0	['4', '1', '2', '6', '24', '6', '2', '4', '1', '2', '96', '0', '0', '0', '0.45', '0', '0', '23', '3', '1.5', '0']
package org . apache . camel . bam . rules ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . bam . model . ActivityState ; import org . apache . camel . bam . model . ProcessDefinition ; import org . apache . camel . bam . model . ProcessInstance ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ServiceHelper ; public class ProcessRules extends ServiceSupport { private ProcessDefinition processDefinition ; private List < ActivityRules > activities = new ArrayList < ActivityRules > ( ) ; public void processExpired ( ActivityState activityState ) throws Exception { for ( ActivityRules activityRules : activities ) { activityRules . processExpired ( activityState ) ; } } public void processExchange ( Exchange exchange , ProcessInstance process ) { for ( ActivityRules activityRules : activities ) { activityRules . processExchange ( exchange , process ) ; } } public List < ActivityRules > getActivities ( ) { return activities ; } public ProcessDefinition getProcessDefinition ( ) { return processDefinition ; } public void setProcessDefinition ( ProcessDefinition processDefinition ) { this . processDefinition = processDefinition ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( activities ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( activities ) ; } } 	0	['8', '2', '0', '14', '17', '0', '8', '7', '6', '0.571428571', '69', '1', '1', '0.666666667', '0.3', '1', '1', '7.375', '2', '1', '0']
package org . apache . camel . component . rmi ; import java . net . URI ; import java . net . URISyntaxException ; import java . rmi . RemoteException ; import java . rmi . registry . LocateRegistry ; import java . rmi . registry . Registry ; import java . util . Arrays ; import java . util . List ; import org . apache . camel . Consumer ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . component . bean . BeanExchange ; import org . apache . camel . impl . DefaultEndpoint ; public class RmiEndpoint extends DefaultEndpoint < BeanExchange > { private List < Class > remoteInterfaces ; private ClassLoader classLoader ; private URI uri ; private int port ; private String method ; protected RmiEndpoint ( String endpointUri , RmiComponent component ) throws URISyntaxException { super ( endpointUri , component ) ; this . uri = new URI ( endpointUri ) ; } public RmiEndpoint ( String endpointUri ) throws URISyntaxException { super ( endpointUri ) ; this . uri = new URI ( endpointUri ) ; } public boolean isSingleton ( ) { return false ; } @ Override public BeanExchange createExchange ( ExchangePattern pattern ) { return new BeanExchange ( getCamelContext ( ) , pattern ) ; } public Consumer < BeanExchange > createConsumer ( Processor processor ) throws Exception { if ( remoteInterfaces == null || remoteInterfaces . size ( ) == 0 ) { throw new RuntimeCamelException ( "To create a RMI consumer, the RMI endpoint's remoteInterfaces property must be be configured." ) ; } return new RmiConsumer ( this , processor ) ; } public Producer < BeanExchange > createProducer ( ) throws Exception { return new RmiProducer ( this ) ; } public String getName ( ) { String path = uri . getPath ( ) ; if ( path == null ) { path = uri . getSchemeSpecificPart ( ) ; } if ( path . startsWith ( "/" ) ) { return path . substring ( 1 ) ; } return path ; } public Registry getRegistry ( ) throws RemoteException { if ( uri . getHost ( ) != null ) { if ( uri . getPort ( ) == - 1 ) { return LocateRegistry . getRegistry ( uri . getHost ( ) ) ; } else { return LocateRegistry . getRegistry ( uri . getHost ( ) , uri . getPort ( ) ) ; } } else { return LocateRegistry . getRegistry ( ) ; } } public List < Class > getRemoteInterfaces ( ) { return remoteInterfaces ; } public void setRemoteInterfaces ( List < Class > remoteInterfaces ) { this . remoteInterfaces = remoteInterfaces ; if ( classLoader == null && ! remoteInterfaces . isEmpty ( ) ) { classLoader = remoteInterfaces . get ( 0 ) . getClassLoader ( ) ; } } public void setRemoteInterfaces ( Class ... remoteInterfaces ) { setRemoteInterfaces ( Arrays . asList ( remoteInterfaces ) ) ; } public ClassLoader getClassLoader ( ) { return classLoader ; } public void setClassLoader ( ClassLoader classLoader ) { this . classLoader = classLoader ; } public int getPort ( ) { return port ; } public void setPort ( int port ) { this . port = port ; } public String getMethod ( ) { return method ; } public void setMethod ( String method ) { this . method = method ; } } 	0	['18', '2', '0', '13', '39', '125', '3', '13', '17', '0.870588235', '170', '1', '0', '0.6', '0.179012346', '1', '1', '8.166666667', '3', '1.1111', '0']
package org . apache . camel . bam . model ; import java . util . Date ; import javax . persistence . Temporal ; import javax . persistence . TemporalType ; import javax . persistence . Transient ; public abstract class TemporalEntity extends EntitySupport { private Date timeStarted ; private Date timeCompleted ; @ Transient public boolean isStarted ( ) { return timeStarted != null ; } @ Transient public boolean isCompleted ( ) { return timeCompleted != null ; } @ Temporal ( TemporalType . TIME ) public Date getTimeStarted ( ) { return timeStarted ; } public void setTimeStarted ( Date timeStarted ) { this . timeStarted = timeStarted ; } @ Temporal ( TemporalType . TIME ) public Date getTimeCompleted ( ) { return timeCompleted ; } public void setTimeCompleted ( Date timeCompleted ) { this . timeCompleted = timeCompleted ; } } 	0	['7', '2', '1', '2', '8', '9', '1', '1', '7', '0.666666667', '40', '1', '0', '0.333333333', '0.642857143', '0', '0', '4.428571429', '2', '1.1429', '0']
package org . apache . camel . bam . processor ; import java . lang . reflect . ParameterizedType ; import java . lang . reflect . Type ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . util . ExchangeHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . transaction . TransactionStatus ; import org . springframework . transaction . support . TransactionCallback ; import org . springframework . transaction . support . TransactionTemplate ; import static org . apache . camel . util . ObjectHelper . wrapRuntimeCamelException ; public abstract class BamProcessorSupport < T > implements Processor { private static final transient Log LOG = LogFactory . getLog ( BamProcessorSupport . class ) ; private Class < T > entityType ; private Expression < Exchange > correlationKeyExpression ; private TransactionTemplate transactionTemplate ; private int retryCount = 20 ; private long retrySleep = 1000L ; protected BamProcessorSupport ( TransactionTemplate transactionTemplate , Expression < Exchange > correlationKeyExpression ) { this . transactionTemplate = transactionTemplate ; this . correlationKeyExpression = correlationKeyExpression ; Type type = getClass ( ) . getGenericSuperclass ( ) ; if ( type instanceof ParameterizedType ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ; Type [ ] arguments = parameterizedType . getActualTypeArguments ( ) ; if ( arguments . length > 0 ) { Type argumentType = arguments [ 0 ] ; if ( argumentType instanceof Class ) { this . entityType = ( Class < T > ) argumentType ; } } } if ( entityType == null ) { throw new IllegalArgumentException ( "Could not infer the entity type!" ) ; } } protected BamProcessorSupport ( TransactionTemplate transactionTemplate , Expression < Exchange > correlationKeyExpression , Class < T > entitytype ) { this . transactionTemplate = transactionTemplate ; this . entityType = entitytype ; this . correlationKeyExpression = correlationKeyExpression ; } public void process ( final Exchange exchange ) { for ( int i = 1 ; i <= retryCount ; i ++ ) { if ( i > 1 ) { LOG . info ( "Retrying attempt: " + i ) ; try { Thread . sleep ( retryCount ) ; } catch ( InterruptedException e ) { LOG . debug ( "Caught: " + e , e ) ; } } try { transactionTemplate . execute ( new TransactionCallback ( ) { public Object doInTransaction ( TransactionStatus status ) { try { Object key = getCorrelationKey ( exchange ) ; T entity = loadEntity ( exchange , key ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Correlation key: " + key + " with entity: " + entity ) ; } processEntity ( exchange , entity ) ; return entity ; } catch ( Exception e ) { return onError ( status , e ) ; } } } ) ; if ( i > 1 ) { LOG . info ( "Attempt " + i + " worked!" ) ; } return ; } catch ( Exception e ) { LOG . warn ( "Failed to complete transaction: " + e , e ) ; } } } public Expression < Exchange > getCorrelationKeyExpression ( ) { return correlationKeyExpression ; } public Class < T > getEntityType ( ) { return entityType ; } protected abstract void processEntity ( Exchange exchange , T entity ) throws Exception ; protected abstract T loadEntity ( Exchange exchange , Object key ) throws Exception ; protected abstract Class getKeyType ( ) ; protected Object getCorrelationKey ( Exchange exchange ) throws NoCorrelationKeyException { Object value = correlationKeyExpression . evaluate ( exchange ) ; Class keyType = getKeyType ( ) ; if ( keyType != null ) { value = ExchangeHelper . convertToType ( exchange , keyType , value ) ; } if ( value == null ) { throw new NoCorrelationKeyException ( this , exchange ) ; } return value ; } protected Object onError ( TransactionStatus status , Exception e ) { status . setRollbackOnly ( ) ; LOG . error ( "Caught: " + e , e ) ; throw wrapRuntimeCamelException ( e ) ; } } 	0	['12', '1', '1', '14', '35', '34', '3', '13', '3', '0.803030303', '215', '1', '1', '0', '0.261363636', '0', '0', '16.41666667', '4', '1', '0']
package org . apache . camel . component . xquery ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . io . Reader ; import java . io . StringWriter ; import java . net . URL ; import java . util . Collection ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Properties ; import java . util . Set ; import java . util . concurrent . atomic . AtomicBoolean ; import javax . xml . transform . Result ; import javax . xml . transform . Source ; import javax . xml . transform . dom . DOMResult ; import javax . xml . transform . stream . StreamResult ; import org . w3c . dom . Node ; import net . sf . saxon . Configuration ; import net . sf . saxon . om . DocumentInfo ; import net . sf . saxon . om . Item ; import net . sf . saxon . om . SequenceIterator ; import net . sf . saxon . query . DynamicQueryContext ; import net . sf . saxon . query . StaticQueryContext ; import net . sf . saxon . query . XQueryExpression ; import net . sf . saxon . trans . XPathException ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Message ; import org . apache . camel . NoTypeConversionAvailableException ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeExpressionException ; import org . apache . camel . converter . IOConverter ; import org . apache . camel . converter . jaxp . BytesSource ; import org . apache . camel . converter . jaxp . StringSource ; import org . apache . camel . converter . jaxp . XmlConverter ; import org . apache . camel . spi . NamespaceAware ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public abstract class XQueryBuilder implements Expression < Exchange > , Predicate < Exchange > , NamespaceAware , Processor { private static final transient Log LOG = LogFactory . getLog ( XQueryBuilder . class ) ; private Configuration configuration ; private XQueryExpression expression ; private StaticQueryContext staticQueryContext ; private Map < String , Object > parameters = new HashMap < String , Object > ( ) ; private Map < String , String > namespacePrefixes = new HashMap < String , String > ( ) ; private XmlConverter converter = new XmlConverter ( ) ; private ResultFormat resultsFormat = ResultFormat . DOM ; private Properties properties = new Properties ( ) ; private Class resultType ; private final AtomicBoolean initialized = new AtomicBoolean ( false ) ; @ Override public String toString ( ) { return "XQuery[" + expression + "]" ; } public void process ( Exchange exchange ) throws Exception { Object body = evaluate ( exchange ) ; exchange . getOut ( true ) . setBody ( body ) ; exchange . getOut ( ) . getHeaders ( ) . putAll ( exchange . getIn ( ) . getHeaders ( ) ) ; } public Object evaluate ( Exchange exchange ) { try { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Evaluation " + expression + " for exchange: " + exchange ) ; } if ( resultType != null ) { if ( resultType . equals ( String . class ) ) { return evaluateAsString ( exchange ) ; } else if ( resultType . isAssignableFrom ( Collection . class ) ) { return evaluateAsList ( exchange ) ; } else if ( resultType . isAssignableFrom ( Node . class ) ) { return evaluateAsDOM ( exchange ) ; } else { throw new IllegalArgumentException ( "ResultType: " + resultType . getCanonicalName ( ) + " not supported" ) ; } } switch ( resultsFormat ) { case Bytes : return evaluateAsBytes ( exchange ) ; case BytesSource : return evaluateAsBytesSource ( exchange ) ; case DOM : return evaluateAsDOM ( exchange ) ; case List : return evaluateAsList ( exchange ) ; case StringSource : return evaluateAsStringSource ( exchange ) ; case String : default : return evaluateAsString ( exchange ) ; } } catch ( Exception e ) { throw new RuntimeExpressionException ( e ) ; } } public List evaluateAsList ( Exchange exchange ) throws Exception { initialize ( exchange ) ; return getExpression ( ) . evaluate ( createDynamicContext ( exchange ) ) ; } public Object evaluateAsStringSource ( Exchange exchange ) throws Exception { initialize ( exchange ) ; String text = evaluateAsString ( exchange ) ; return new StringSource ( text ) ; } public Object evaluateAsBytesSource ( Exchange exchange ) throws Exception { initialize ( exchange ) ; byte [ ] bytes = evaluateAsBytes ( exchange ) ; return new BytesSource ( bytes ) ; } public Node evaluateAsDOM ( Exchange exchange ) throws Exception { initialize ( exchange ) ; DOMResult result = new DOMResult ( ) ; DynamicQueryContext context = createDynamicContext ( exchange ) ; XQueryExpression expression = getExpression ( ) ; expression . pull ( context , result , properties ) ; return result . getNode ( ) ; } public byte [ ] evaluateAsBytes ( Exchange exchange ) throws Exception { initialize ( exchange ) ; ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; Result result = new StreamResult ( buffer ) ; getExpression ( ) . pull ( createDynamicContext ( exchange ) , result , properties ) ; byte [ ] bytes = buffer . toByteArray ( ) ; return bytes ; } public String evaluateAsString ( Exchange exchange ) throws Exception { initialize ( exchange ) ; StringWriter buffer = new StringWriter ( ) ; SequenceIterator iter = getExpression ( ) . iterator ( createDynamicContext ( exchange ) ) ; for ( Item item = iter . next ( ) ; item != null ; item = iter . next ( ) ) { buffer . append ( item . getStringValueCS ( ) ) ; } return buffer . toString ( ) ; } public boolean matches ( Exchange exchange ) { try { List list = evaluateAsList ( exchange ) ; return matches ( exchange , list ) ; } catch ( Exception e ) { throw new RuntimeExpressionException ( e ) ; } } public void assertMatches ( String text , Exchange exchange ) throws AssertionError { try { List list = evaluateAsList ( exchange ) ; if ( ! matches ( exchange , list ) ) { throw new AssertionError ( this + " failed on " + exchange + " as evaluated: " + list ) ; } } catch ( Exception e ) { throw new AssertionError ( e ) ; } } public static XQueryBuilder xquery ( final String queryText ) { return new XQueryBuilder ( ) { protected XQueryExpression createQueryExpression ( StaticQueryContext staticQueryContext ) throws XPathException { return staticQueryContext . compileQuery ( queryText ) ; } } ; } public static XQueryBuilder xquery ( final Reader reader ) { return new XQueryBuilder ( ) { protected XQueryExpression createQueryExpression ( StaticQueryContext staticQueryContext ) throws XPathException , IOException { return staticQueryContext . compileQuery ( reader ) ; } } ; } public static XQueryBuilder xquery ( final InputStream in , final String characterSet ) { return new XQueryBuilder ( ) { protected XQueryExpression createQueryExpression ( StaticQueryContext staticQueryContext ) throws XPathException , IOException { return staticQueryContext . compileQuery ( in , characterSet ) ; } } ; } public static XQueryBuilder xquery ( File file , String characterSet ) throws FileNotFoundException { return xquery ( IOConverter . toInputStream ( file ) , characterSet ) ; } public static XQueryBuilder xquery ( URL url , String characterSet ) throws IOException { return xquery ( IOConverter . toInputStream ( url ) , characterSet ) ; } public static XQueryBuilder xquery ( File file ) throws FileNotFoundException { return xquery ( IOConverter . toInputStream ( file ) , ObjectHelper . getDefaultCharacterSet ( ) ) ; } public static XQueryBuilder xquery ( URL url ) throws IOException { return xquery ( IOConverter . toInputStream ( url ) , ObjectHelper . getDefaultCharacterSet ( ) ) ; } public XQueryBuilder parameter ( String name , Object value ) { parameters . put ( name , value ) ; return this ; } public XQueryBuilder namespace ( String prefix , String uri ) { namespacePrefixes . put ( prefix , uri ) ; initialized . set ( false ) ; return this ; } public XQueryBuilder resultType ( Class resultType ) { setResultType ( resultType ) ; return this ; } public XQueryBuilder asBytes ( ) { setResultsFormat ( ResultFormat . Bytes ) ; return this ; } public XQueryBuilder asBytesSource ( ) { setResultsFormat ( ResultFormat . BytesSource ) ; return this ; } public XQueryBuilder asDOM ( ) { setResultsFormat ( ResultFormat . DOM ) ; return this ; } public XQueryBuilder asDOMSource ( ) { setResultsFormat ( ResultFormat . DOMSource ) ; return this ; } public XQueryBuilder asList ( ) { setResultsFormat ( ResultFormat . List ) ; return this ; } public XQueryBuilder asString ( ) { setResultsFormat ( ResultFormat . String ) ; return this ; } public XQueryBuilder asStringSource ( ) { setResultsFormat ( ResultFormat . StringSource ) ; return this ; } public void setNamespaces ( Map < String , String > namespaces ) { namespacePrefixes . putAll ( namespaces ) ; initialized . set ( false ) ; } public XQueryExpression getExpression ( ) throws IOException , XPathException { return expression ; } public Configuration getConfiguration ( ) { return configuration ; } public void setConfiguration ( Configuration configuration ) { this . configuration = configuration ; initialized . set ( false ) ; } public StaticQueryContext getStaticQueryContext ( ) { return staticQueryContext ; } public void setStaticQueryContext ( StaticQueryContext staticQueryContext ) { this . staticQueryContext = staticQueryContext ; initialized . set ( false ) ; } public Map < String , Object > getParameters ( ) { return parameters ; } public void setParameters ( Map < String , Object > parameters ) { this . parameters = parameters ; } public Properties getProperties ( ) { return properties ; } public void setProperties ( Properties properties ) { this . properties = properties ; } public ResultFormat getResultsFormat ( ) { return resultsFormat ; } public void setResultsFormat ( ResultFormat resultsFormat ) { this . resultsFormat = resultsFormat ; } public Class getResultType ( ) { return resultType ; } public void setResultType ( Class resultType ) { this . resultType = resultType ; } protected abstract XQueryExpression createQueryExpression ( StaticQueryContext staticQueryContext ) throws XPathException , IOException ; protected DynamicQueryContext createDynamicContext ( Exchange exchange ) throws Exception { Configuration config = getConfiguration ( ) ; DynamicQueryContext dynamicQueryContext = new DynamicQueryContext ( config ) ; Message in = exchange . getIn ( ) ; Source source = null ; try { Item item = in . getBody ( Item . class ) ; dynamicQueryContext . setContextItem ( item ) ; } catch ( NoTypeConversionAvailableException e ) { try { source = in . getBody ( Source . class ) ; } catch ( NoTypeConversionAvailableException e2 ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "No body available on exchange so using an empty document: " + exchange ) ; } source = converter . toSource ( converter . createDocument ( ) ) ; } DocumentInfo doc = getStaticQueryContext ( ) . buildDocument ( source ) ; dynamicQueryContext . setContextItem ( doc ) ; } configureQuery ( dynamicQueryContext , exchange ) ; return dynamicQueryContext ; } protected void configureQuery ( DynamicQueryContext dynamicQueryContext , Exchange exchange ) throws Exception { addParameters ( dynamicQueryContext , exchange . getProperties ( ) ) ; addParameters ( dynamicQueryContext , exchange . getIn ( ) . getHeaders ( ) ) ; addParameters ( dynamicQueryContext , getParameters ( ) ) ; dynamicQueryContext . setParameter ( "exchange" , exchange ) ; Message out = exchange . getOut ( false ) ; if ( out != null && exchange . getPattern ( ) . isOutCapable ( ) ) { dynamicQueryContext . setParameter ( "out" , out ) ; } } protected void addParameters ( DynamicQueryContext dynamicQueryContext , Map < String , Object > map ) { Set < Map . Entry < String , Object > > propertyEntries = map . entrySet ( ) ; for ( Map . Entry < String , Object > entry : propertyEntries ) { dynamicQueryContext . setParameter ( entry . getKey ( ) , entry . getValue ( ) ) ; } } protected boolean matches ( Exchange exchange , List results ) { return ObjectHelper . matches ( results ) ; } protected synchronized void initialize ( Exchange exchange ) throws XPathException , IOException { if ( ! initialized . get ( ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Initializing XQueryBuilder " + this ) ; } configuration = new Configuration ( ) ; configuration . setHostLanguage ( Configuration . XQUERY ) ; staticQueryContext = new StaticQueryContext ( getConfiguration ( ) ) ; Set < Map . Entry < String , String > > entries = namespacePrefixes . entrySet ( ) ; for ( Map . Entry < String , String > entry : entries ) { String prefix = entry . getKey ( ) ; String uri = entry . getValue ( ) ; staticQueryContext . declareNamespace ( prefix , uri ) ; staticQueryContext . setInheritNamespaces ( true ) ; } expression = createQueryExpression ( staticQueryContext ) ; initialized . set ( true ) ; } exchange . setProperty ( "CamelSaxonConfiguration" , configuration ) ; } } 	0	['52', '1', '3', '32', '124', '1214', '6', '29', '45', '0.793226381', '766', '1', '2', '0', '0.107843137', '0', '0', '13.51923077', '7', '1.0962', '0']
package org . apache . camel . spring ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . model . IdentifiedType ; @ XmlRootElement ( name = "proxy" ) public class CamelProxyFactoryType extends IdentifiedType { @ XmlAttribute private String serviceUrl ; @ XmlAttribute private Class serviceInterface ; } 	0	['1', '2', '0', '1', '2', '0', '0', '1', '1', '2', '6', '1', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . camel . language . xpath ; import javax . xml . namespace . QName ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . builder . xml . XPathBuilder ; import org . apache . camel . spi . Language ; public class XPathLanguage implements Language { private QName resultType ; public Predicate < Exchange > createPredicate ( String expression ) { XPathBuilder builder = XPathBuilder . xpath ( expression ) ; configureBuilder ( builder ) ; return builder ; } public Expression < Exchange > createExpression ( String expression ) { XPathBuilder builder = XPathBuilder . xpath ( expression ) ; configureBuilder ( builder ) ; return builder ; } public QName getResultType ( ) { return resultType ; } public void setResultType ( QName resultType ) { this . resultType = resultType ; } protected void configureBuilder ( XPathBuilder builder ) { if ( resultType != null ) { builder . setResultQName ( resultType ) ; } } } 	0	['6', '1', '0', '4', '9', '9', '0', '4', '5', '0.2', '41', '1', '0', '0', '0.416666667', '0', '0', '5.666666667', '2', '1', '0']
package org . apache . camel . component . jdbc ; import java . util . Map ; import javax . sql . DataSource ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . impl . DefaultExchange ; public class JdbcComponent extends DefaultComponent < DefaultExchange > { private DataSource ds ; public JdbcComponent ( ) { } public JdbcComponent ( CamelContext context ) { super ( context ) ; } @ Override protected Endpoint < DefaultExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { DataSource dataSource ; if ( ds != null ) { dataSource = ds ; } else { dataSource = getCamelContext ( ) . getRegistry ( ) . lookup ( remaining , DataSource . class ) ; if ( dataSource == null ) { throw new IllegalArgumentException ( "DataSource " + remaining + " not found in registry" ) ; } } JdbcEndpoint jdbc = new JdbcEndpoint ( uri , this , dataSource ) ; setProperties ( jdbc , parameters ) ; return jdbc ; } public void setDataSource ( DataSource dataSource ) { this . ds = dataSource ; } } 	0	['4', '3', '0', '6', '15', '4', '0', '6', '3', '0.666666667', '60', '1', '0', '0.945945946', '0.4', '1', '3', '13.75', '1', '0.5', '0']
package org . apache . camel . component . cxf . converter ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . util . Map ; import javax . xml . soap . SOAPException ; import javax . xml . soap . SOAPMessage ; import org . apache . camel . Converter ; import org . apache . camel . Endpoint ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . cxf . message . MessageContentsList ; @ Converter public final class CxfConverter { private static final Log LOG = LogFactory . getLog ( CxfConverter . class ) ; private CxfConverter ( ) { } @ Converter public static Object [ ] toArray ( final MessageContentsList list ) throws Exception { if ( list == null ) { throw new IllegalArgumentException ( "The MessageChannel is null" ) ; } return list . toArray ( ) ; } @ Converter public static MessageContentsList toMessageContentsList ( final Object [ ] array ) { if ( array != null ) { return new MessageContentsList ( array ) ; } else { return new MessageContentsList ( ) ; } } @ Converter public static String soapMessageToString ( final SOAPMessage soapMessage ) { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; try { soapMessage . writeTo ( baos ) ; } catch ( Exception e ) { LOG . error ( "Get the exception when converting the SOAPMessage into String, the exception is " + e ) ; } return baos . toString ( ) ; } } 	0	['5', '1', '0', '3', '19', '8', '0', '3', '3', '0.75', '56', '1', '0', '0', '0.25', '0', '0', '10', '2', '0.8', '0']
package org . apache . camel ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . CONSTRUCTOR } ) public @ interface Produce { String uri ( ) default "" ; String ref ( ) default "" ; } 	0	['2', '1', '0', '2', '2', '1', '2', '0', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . language . ognl ; import java . util . Map ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; public class RootObject { private final Exchange exchange ; public RootObject ( Exchange exchange ) { this . exchange = exchange ; } public Exchange getExchange ( ) { return exchange ; } public CamelContext getContext ( ) { return exchange . getContext ( ) ; } public Throwable getException ( ) { return exchange . getException ( ) ; } public String getExchangeId ( ) { return exchange . getExchangeId ( ) ; } public Message getFault ( ) { return exchange . getFault ( ) ; } public Message getRequest ( ) { return exchange . getIn ( ) ; } public Message getIn ( ) { return exchange . getIn ( ) ; } public Message getOut ( ) { return exchange . getOut ( ) ; } public Message getResponse ( ) { return exchange . getOut ( ) ; } public Map < String , Object > getProperties ( ) { return exchange . getProperties ( ) ; } public Object getProperty ( String name ) { return exchange . getProperty ( name ) ; } public < T > T getProperty ( String name , Class < T > type ) { return exchange . getProperty ( name , type ) ; } } 	0	['13', '1', '0', '4', '23', '0', '1', '3', '13', '0', '70', '1', '1', '0', '0.326923077', '0', '0', '4.307692308', '1', '0.9231', '0']
package org . apache . camel . component . quartz ; import java . net . URI ; import java . util . Map ; import org . apache . camel . CamelContext ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . quartz . CronTrigger ; import org . quartz . JobDetail ; import org . quartz . Scheduler ; import org . quartz . SchedulerException ; import org . quartz . SchedulerFactory ; import org . quartz . Trigger ; import org . quartz . impl . StdSchedulerFactory ; public class QuartzComponent extends DefaultComponent < QuartzExchange > { private static final transient Log LOG = LogFactory . getLog ( QuartzComponent . class ) ; private SchedulerFactory factory ; private Scheduler scheduler ; private Map < Trigger , JobDetail > triggers ; public QuartzComponent ( ) { } public QuartzComponent ( final CamelContext context ) { super ( context ) ; } @ Override protected QuartzEndpoint createEndpoint ( final String uri , final String remaining , final Map parameters ) throws Exception { QuartzEndpoint answer = new QuartzEndpoint ( uri , this , getScheduler ( ) ) ; URI u = new URI ( uri ) ; String name ; String group = "Camel" ; String path = u . getPath ( ) ; CronTrigger cronTrigger = null ; if ( path != null && path . length ( ) > 1 ) { if ( path . startsWith ( "/" ) ) { path = path . substring ( 1 ) ; } int idx = path . indexOf ( '/' ) ; if ( idx > 0 ) { cronTrigger = new CronTrigger ( ) ; name = path . substring ( 0 , idx ) ; String cronExpression = path . substring ( idx + 1 ) ; cronExpression = cronExpression . replace ( '/' , ' ' ) ; cronExpression = cronExpression . replace ( '$' , '?' ) ; LOG . debug ( "Creating cron trigger: " + cronExpression ) ; cronTrigger . setCronExpression ( cronExpression ) ; answer . setTrigger ( cronTrigger ) ; } else { name = path ; } group = u . getHost ( ) ; } else { name = u . getHost ( ) ; } Trigger trigger = cronTrigger ; if ( trigger == null ) { trigger = answer . getTrigger ( ) ; } trigger . setName ( name ) ; trigger . setGroup ( group ) ; Map triggerParameters = IntrospectionSupport . extractProperties ( parameters , "trigger." ) ; Map jobParameters = IntrospectionSupport . extractProperties ( parameters , "job." ) ; setProperties ( trigger , triggerParameters ) ; setProperties ( answer . getJobDetail ( ) , jobParameters ) ; return answer ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; getScheduler ( ) . start ( ) ; } @ Override protected void doStop ( ) throws Exception { if ( scheduler != null ) { scheduler . shutdown ( ) ; } super . doStop ( ) ; } public SchedulerFactory getFactory ( ) { if ( factory == null ) { factory = createSchedulerFactory ( ) ; } return factory ; } public void setFactory ( final SchedulerFactory factory ) { this . factory = factory ; } public Scheduler getScheduler ( ) throws SchedulerException { if ( scheduler == null ) { scheduler = createScheduler ( ) ; } return scheduler ; } public void setScheduler ( final Scheduler scheduler ) { this . scheduler = scheduler ; } public Map getTriggers ( ) { return triggers ; } public void setTriggers ( final Map triggers ) { this . triggers = triggers ; } protected SchedulerFactory createSchedulerFactory ( ) { return new StdSchedulerFactory ( ) ; } protected Scheduler createScheduler ( ) throws SchedulerException { Scheduler scheduler = getFactory ( ) . getScheduler ( ) ; scheduler . getContext ( ) . put ( QuartzEndpoint . CONTEXT_KEY , getCamelContext ( ) ) ; return scheduler ; } } 	0	['15', '3', '0', '15', '49', '93', '1', '15', '8', '0.821428571', '226', '1', '0', '0.744680851', '0.261904762', '2', '3', '13.8', '2', '0.8667', '0']
package org . apache . camel . component . jms ; import javax . jms . Destination ; import javax . jms . JMSException ; import javax . jms . Session ; import javax . jms . TemporaryTopic ; import org . springframework . jms . core . JmsOperations ; import org . springframework . jms . core . SessionCallback ; public class JmsTemporaryTopicEndpoint extends JmsEndpoint implements DestinationEndpoint { private Destination jmsDestination ; public JmsTemporaryTopicEndpoint ( String uri , JmsComponent component , String destination , JmsConfiguration configuration ) { super ( uri , component , destination , true , configuration ) ; } public JmsTemporaryTopicEndpoint ( String endpointUri , String destination ) { super ( endpointUri , destination ) ; } public boolean isSingleton ( ) { return true ; } public synchronized Destination getJmsDestination ( Session session ) throws JMSException { if ( jmsDestination == null ) { jmsDestination = createJmsDestination ( session ) ; } return jmsDestination ; } protected Destination createJmsDestination ( Session session ) throws JMSException { return session . createTemporaryTopic ( ) ; } } 	0	['5', '3', '0', '4', '8', '10', '1', '4', '4', '1', '35', '1', '0', '0.947368421', '0.44', '0', '0', '5.8', '1', '0.6', '0']
package org . apache . camel . language . groovy ; import java . util . AbstractMap ; import java . util . Collections ; import java . util . Set ; import groovy . lang . Binding ; import groovy . lang . Script ; import org . apache . camel . Exchange ; import org . apache . camel . impl . ExpressionSupport ; import org . apache . camel . util . ExchangeHelper ; public class GroovyExpression extends ExpressionSupport < Exchange > { private Class < Script > scriptType ; private String text ; public GroovyExpression ( Class < Script > scriptType , String text ) { this . scriptType = scriptType ; this . text = text ; } @ Override public String toString ( ) { return "groovy: " + text ; } protected String assertionFailureMessage ( Exchange exchange ) { return "groovy: " + text ; } public Object evaluate ( Exchange exchange ) { Script script = ExchangeHelper . newInstance ( exchange , scriptType ) ; configure ( exchange , script ) ; return script . run ( ) ; } private void configure ( Exchange exchange , Script script ) { final Binding binding = script . getBinding ( ) ; ExchangeHelper . populateVariableMap ( exchange , new AbstractMap < String , Object > ( ) { @ Override public Object put ( String key , Object value ) { binding . setProperty ( key , value ) ; return null ; } public Set entrySet ( ) { return Collections . EMPTY_SET ; } } ) ; } } 	0	['5', '2', '0', '7', '14', '2', '2', '6', '3', '0.625', '60', '1', '0', '0.555555556', '0.44', '1', '2', '10.6', '1', '0.8', '0']
package org . apache . camel . processor ; import java . text . NumberFormat ; import java . util . concurrent . atomic . AtomicInteger ; import org . apache . camel . Exchange ; import org . apache . camel . model . LoggingLevel ; import org . apache . commons . logging . Log ; public class ThroughputLogger extends Logger { private int groupSize = 100 ; private long startTime ; private long groupStartTime ; private AtomicInteger receivedCounter = new AtomicInteger ( ) ; private NumberFormat numberFormat = NumberFormat . getNumberInstance ( ) ; private String action = "Received" ; private String logMessage ; public ThroughputLogger ( ) { } public ThroughputLogger ( Log log ) { super ( log ) ; } public ThroughputLogger ( Log log , LoggingLevel level ) { super ( log , level ) ; } public ThroughputLogger ( String logName ) { super ( logName ) ; } public ThroughputLogger ( String logName , LoggingLevel level ) { super ( logName , level ) ; } public ThroughputLogger ( String logName , LoggingLevel level , int groupSize ) { super ( logName , level ) ; setGroupSize ( groupSize ) ; } public ThroughputLogger ( String logName , int groupSize ) { super ( logName ) ; setGroupSize ( groupSize ) ; } public ThroughputLogger ( int groupSize ) { setGroupSize ( groupSize ) ; } @ Override public void process ( Exchange exchange ) { if ( startTime == 0 ) { startTime = System . currentTimeMillis ( ) ; } int receivedCount = receivedCounter . incrementAndGet ( ) ; if ( receivedCount % groupSize == 0 ) { logMessage = createLogMessage ( exchange , receivedCount ) ; super . process ( exchange ) ; } } public int getGroupSize ( ) { return groupSize ; } public void setGroupSize ( int groupSize ) { if ( groupSize == 0 ) { throw new IllegalArgumentException ( "groupSize cannot be zero!" ) ; } this . groupSize = groupSize ; } public NumberFormat getNumberFormat ( ) { return numberFormat ; } public void setNumberFormat ( NumberFormat numberFormat ) { this . numberFormat = numberFormat ; } public String getAction ( ) { return action ; } public void setAction ( String action ) { this . action = action ; } @ Override protected Object logMessage ( Exchange exchange ) { return logMessage ; } protected String createLogMessage ( Exchange exchange , int receivedCount ) { long time = System . currentTimeMillis ( ) ; if ( groupStartTime == 0 ) { groupStartTime = startTime ; } double rate = messagesPerSecond ( groupSize , groupStartTime , time ) ; double average = messagesPerSecond ( receivedCount , startTime , time ) ; long duration = time - groupStartTime ; groupStartTime = time ; return getAction ( ) + ": " + receivedCount + " messages so far. Last group took: " + duration + " millis which is: " + numberFormat . format ( rate ) + " messages per second. average: " + numberFormat . format ( average ) ; } protected double messagesPerSecond ( long messageCount , long startTime , long endTime ) { double rate = messageCount * 1000.0 ; rate /= endTime - startTime ; return rate ; } } 	0	['18', '2', '0', '7', '35', '0', '3', '4', '15', '0.638655462', '317', '1', '0', '0.565217391', '0.263888889', '1', '1', '16.22222222', '3', '0.7778', '0']
package org . apache . camel . processor . exceptionpolicy ; import org . apache . camel . model . WhenType ; public final class ExceptionPolicyKey { private final Class exceptionClass ; private final WhenType when ; public ExceptionPolicyKey ( Class exceptionClass , WhenType when ) { this . exceptionClass = exceptionClass ; this . when = when ; } public Class getExceptionClass ( ) { return exceptionClass ; } public WhenType getWhen ( ) { return when ; } public static ExceptionPolicyKey newInstance ( Class exceptionClass ) { return new ExceptionPolicyKey ( exceptionClass , null ) ; } public static ExceptionPolicyKey newInstance ( Class exceptionClass , WhenType when ) { return new ExceptionPolicyKey ( exceptionClass , when ) ; } @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } ExceptionPolicyKey that = ( ExceptionPolicyKey ) o ; if ( ! exceptionClass . equals ( that . exceptionClass ) ) { return false ; } if ( when != null ? ! when . equals ( that . when ) : that . when != null ) { return false ; } return true ; } @ Override public int hashCode ( ) { int result = exceptionClass . hashCode ( ) ; result = 31 * result + ( when != null ? when . hashCode ( ) : 0 ) ; return result ; } @ Override public String toString ( ) { return "ExceptionPolicyKey[" + exceptionClass + ( when != null ? " " + when : "" ) + "]" ; } } 	0	['8', '1', '0', '3', '16', '0', '2', '1', '8', '0.142857143', '125', '1', '1', '0', '0.375', '1', '1', '14.375', '8', '2', '0']
package org . apache . camel . processor . interceptor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . processor . DelayProcessorSupport ; public class DelayInterceptor extends DelayProcessorSupport { private final ProcessorType node ; private Delayer delayer ; public DelayInterceptor ( ProcessorType node , Processor target , Delayer delayer ) { super ( target ) ; this . node = node ; this . delayer = delayer ; } @ Override public String toString ( ) { return "DelayInterceptor[delay: " + delayer . getDelay ( ) + " on: " + node + "]" ; } public void delay ( Exchange exchange ) throws Exception { if ( delayer . isEnabled ( ) ) { long time = currentSystemTime ( ) + delayer . getDelay ( ) ; waitUntil ( time , exchange ) ; } } } 	0	['3', '4', '0', '6', '13', '0', '2', '5', '3', '0.25', '49', '1', '2', '0.939393939', '0.466666667', '1', '2', '14.66666667', '1', '0.6667', '0']
package org . apache . camel . component . bean ; import org . apache . camel . Component ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Processor ; import org . apache . camel . impl . ProcessorEndpoint ; public class BeanEndpoint extends ProcessorEndpoint { private boolean cache ; private boolean multiParameterArray ; private String beanName ; private String method ; private BeanHolder beanHolder ; public BeanEndpoint ( ) { init ( ) ; } public BeanEndpoint ( String endpointUri ) { super ( endpointUri ) ; init ( ) ; } public BeanEndpoint ( String endpointUri , BeanProcessor processor ) { super ( endpointUri , processor ) ; init ( ) ; } public BeanEndpoint ( String endpointUri , Component component , BeanProcessor processor ) { super ( endpointUri , component , processor ) ; init ( ) ; } public BeanEndpoint ( String endpointUri , Component component ) { super ( endpointUri , component ) ; init ( ) ; } public String getBeanName ( ) { return beanName ; } public void setBeanName ( String beanName ) { this . beanName = beanName ; } public boolean isMultiParameterArray ( ) { return multiParameterArray ; } public void setMultiParameterArray ( boolean mpArray ) { multiParameterArray = mpArray ; } public boolean isCache ( ) { return cache ; } public void setCache ( boolean cache ) { this . cache = cache ; } public String getMethod ( ) { return method ; } public void setMethod ( String method ) { this . method = method ; } public BeanHolder getBeanHolder ( ) { return beanHolder ; } public void setBeanHolder ( BeanHolder beanHolder ) { this . beanHolder = beanHolder ; } @ Override protected String createEndpointUri ( ) { return "bean:" + getBeanName ( ) + ( method != null ? "?method=" + method : "" ) ; } private void init ( ) { setExchangePattern ( ExchangePattern . InOut ) ; } @ Override protected Processor createProcessor ( ) throws Exception { BeanHolder holder = getBeanHolder ( ) ; if ( holder == null ) { RegistryBean registryBean = new RegistryBean ( getCamelContext ( ) , beanName ) ; if ( cache ) { holder = registryBean . createCacheHolder ( ) ; } else { holder = registryBean ; } } BeanProcessor processor = new BeanProcessor ( holder ) ; if ( method != null ) { processor . setMethod ( method ) ; } processor . setMultiParameterArray ( isMultiParameterArray ( ) ) ; return processor ; } } 	0	['18', '5', '0', '11', '33', '125', '2', '9', '15', '0.858823529', '160', '1', '1', '0.729166667', '0.287037037', '1', '1', '7.611111111', '2', '0.7778', '0']
package org . apache . camel . spring . remoting ; import org . apache . camel . CamelContext ; import org . apache . camel . CamelContextAware ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . component . bean . BeanProcessor ; import org . apache . camel . util . CamelContextHelper ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . DisposableBean ; import org . springframework . beans . factory . FactoryBean ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . remoting . support . RemoteExporter ; import static org . apache . camel . util . ObjectHelper . notNull ; public class CamelServiceExporter extends RemoteExporter implements InitializingBean , DisposableBean , ApplicationContextAware , CamelContextAware { private String uri ; private CamelContext camelContext ; private Consumer consumer ; private String serviceRef ; private ApplicationContext applicationContext ; public String getUri ( ) { return uri ; } public void setUri ( String uri ) { this . uri = uri ; } public CamelContext getCamelContext ( ) { return camelContext ; } public void setCamelContext ( CamelContext camelContext ) { this . camelContext = camelContext ; } public String getServiceRef ( ) { return serviceRef ; } public void setServiceRef ( String serviceRef ) { this . serviceRef = serviceRef ; } public ApplicationContext getApplicationContext ( ) { return applicationContext ; } public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { this . applicationContext = applicationContext ; } public void afterPropertiesSet ( ) throws Exception { notNull ( uri , "uri" ) ; notNull ( camelContext , "camelContext" ) ; if ( serviceRef != null && getService ( ) == null && applicationContext != null ) { setService ( applicationContext . getBean ( serviceRef ) ) ; } Endpoint endpoint = CamelContextHelper . getMandatoryEndpoint ( camelContext , uri ) ; notNull ( camelContext , "service" ) ; Object proxy = getProxyForService ( ) ; consumer = endpoint . createConsumer ( new BeanProcessor ( proxy , camelContext ) ) ; consumer . start ( ) ; } public void destroy ( ) throws Exception { if ( consumer != null ) { consumer . stop ( ) ; } } } 	0	['11', '0', '0', '14', '22', '29', '0', '14', '11', '0.82', '105', '1', '2', '0', '0.340909091', '0', '0', '8.090909091', '1', '0.9091', '0']
package org . apache . camel . spi ; import org . apache . camel . TypeConverter ; public interface TypeConverterAware { void setTypeConverter ( TypeConverter parentTypeConverter ) ; } 	0	['1', '1', '0', '3', '1', '0', '2', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . builder . xml ; import java . util . HashMap ; import java . util . Map ; import org . w3c . dom . Attr ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . apache . camel . model . language . XPathExpression ; import org . apache . camel . model . language . XQueryExpression ; import org . apache . camel . spi . NamespaceAware ; import org . apache . camel . util . ObjectHelper ; public class Namespaces { public static final String DEFAULT_NAMESPACE = "http://activemq.apache.org/camel/schema/spring" ; public static final String IN_NAMESPACE = "http://camel.apache.org/xml/in/" ; public static final String OUT_NAMESPACE = "http://camel.apache.org/xml/out/" ; public static final String SYSTEM_PROPERTIES_NAMESPACE = "http://camel.apache.org/xml/variables/system-properties" ; public static final String ENVIRONMENT_VARIABLES = "http://camel.apache.org/xml/variables/environment-variables" ; public static final String EXCHANGE_PROPERTY = "http://camel.apache.org/xml/variables/exchange-property" ; private Map < String , String > namespaces = new HashMap < String , String > ( ) ; public Namespaces ( Element element ) { add ( element ) ; } public Namespaces ( String prefix , String uri ) { add ( prefix , uri ) ; } public static boolean isMatchingNamespaceOrEmptyNamespace ( String namespaceURI , String expectedNamespace ) { return ObjectHelper . isNullOrBlank ( namespaceURI ) || namespaceURI . equals ( expectedNamespace ) ; } public Namespaces add ( String prefix , String uri ) { namespaces . put ( prefix , uri ) ; return this ; } public Namespaces add ( Element element ) { Node parentNode = element . getParentNode ( ) ; if ( parentNode instanceof org . w3c . dom . Element ) { add ( ( Element ) parentNode ) ; } NamedNodeMap attributes = element . getAttributes ( ) ; int size = attributes . getLength ( ) ; for ( int i = 0 ; i < size ; i ++ ) { Attr node = ( Attr ) attributes . item ( i ) ; String name = node . getName ( ) ; if ( name . startsWith ( "xmlns:" ) ) { String prefix = name . substring ( "xmlns:" . length ( ) ) ; String uri = node . getValue ( ) ; add ( prefix , uri ) ; } } return this ; } public XPathExpression xpath ( String expression ) { XPathExpression answer = new XPathExpression ( expression ) ; configure ( answer ) ; return answer ; } public XPathExpression xpath ( String expression , Class < ? > resultType ) { XPathExpression answer = xpath ( expression ) ; answer . setResultType ( resultType ) ; return answer ; } public XQueryExpression xquery ( String expression ) { XQueryExpression answer = new XQueryExpression ( expression ) ; configure ( answer ) ; return answer ; } public XQueryExpression xquery ( String expression , Class < ? > resultType ) { XQueryExpression answer = new XQueryExpression ( expression ) ; answer . setResultType ( resultType ) ; configure ( answer ) ; return answer ; } public Map < String , String > getNamespaces ( ) { return namespaces ; } public void configure ( NamespaceAware namespaceAware ) { namespaceAware . setNamespaces ( getNamespaces ( ) ) ; } } 	0	['11', '1', '0', '8', '30', '43', '4', '4', '11', '1.014285714', '163', '0.142857143', '0', '0', '0.4', '0', '0', '13.18181818', '4', '1.2727', '0']
package org . apache . camel . component . jms ; import java . io . ByteArrayOutputStream ; import java . io . DataOutputStream ; import java . io . ObjectOutputStream ; import java . nio . ByteBuffer ; import java . util . Enumeration ; import javax . jms . BytesMessage ; import javax . jms . MapMessage ; import javax . jms . Message ; import javax . jms . MessageEOFException ; import javax . jms . ObjectMessage ; import javax . jms . StreamMessage ; import javax . jms . TextMessage ; import org . apache . camel . Converter ; import org . apache . camel . Exchange ; import org . apache . camel . converter . NIOConverter ; @ Converter public final class JmsIOConverter { private JmsIOConverter ( ) { } @ Converter public static ByteBuffer toByteBuffer ( final Message message , Exchange exchange ) throws Exception { if ( message instanceof TextMessage ) { final String text = ( ( TextMessage ) message ) . getText ( ) ; return NIOConverter . toByteBuffer ( text , exchange ) ; } if ( message instanceof BytesMessage ) { final BytesMessage bmsg = ( BytesMessage ) message ; final int len = ( int ) bmsg . getBodyLength ( ) ; final byte [ ] data = new byte [ len ] ; bmsg . readBytes ( data , len ) ; return NIOConverter . toByteBuffer ( data ) ; } if ( message instanceof StreamMessage ) { final StreamMessage msg = ( StreamMessage ) message ; final ByteArrayOutputStream bytesOut = new ByteArrayOutputStream ( ) ; final DataOutputStream dataOut = new DataOutputStream ( bytesOut ) ; try { while ( true ) { final Object obj = msg . readObject ( ) ; writeData ( dataOut , obj ) ; } } catch ( MessageEOFException e ) { } finally { dataOut . close ( ) ; } return NIOConverter . toByteBuffer ( bytesOut . toByteArray ( ) ) ; } if ( message instanceof MapMessage ) { final MapMessage msg = ( MapMessage ) message ; final ByteArrayOutputStream bytesOut = new ByteArrayOutputStream ( ) ; final DataOutputStream dataOut = new DataOutputStream ( bytesOut ) ; for ( final Enumeration en = msg . getMapNames ( ) ; en . hasMoreElements ( ) ; ) { final Object obj = msg . getObject ( en . nextElement ( ) . toString ( ) ) ; writeData ( dataOut , obj ) ; } dataOut . close ( ) ; return NIOConverter . toByteBuffer ( bytesOut . toByteArray ( ) ) ; } if ( message instanceof ObjectMessage ) { ObjectMessage objMessage = ( ObjectMessage ) message ; Object object = objMessage . getObject ( ) ; ByteArrayOutputStream bytesOut = new ByteArrayOutputStream ( ) ; ObjectOutputStream objectOut = new ObjectOutputStream ( bytesOut ) ; objectOut . writeObject ( object ) ; objectOut . close ( ) ; return NIOConverter . toByteBuffer ( bytesOut . toByteArray ( ) ) ; } return null ; } private static void writeData ( DataOutputStream dataOut , Object data ) throws Exception { if ( data instanceof byte [ ] ) { dataOut . write ( ( byte [ ] ) data ) ; } else if ( data instanceof String ) { dataOut . writeUTF ( data . toString ( ) ) ; } else if ( data instanceof Double ) { dataOut . writeDouble ( ( ( Double ) data ) . doubleValue ( ) ) ; } else if ( data instanceof Float ) { dataOut . writeFloat ( ( ( Float ) data ) . floatValue ( ) ) ; } else if ( data instanceof Long ) { dataOut . writeLong ( ( ( Long ) data ) . longValue ( ) ) ; } else if ( data instanceof Integer ) { dataOut . writeInt ( ( ( Integer ) data ) . intValue ( ) ) ; } else if ( data instanceof Short ) { dataOut . writeShort ( ( ( Short ) data ) . shortValue ( ) ) ; } else if ( data instanceof Character ) { dataOut . writeChar ( ( ( Character ) data ) . charValue ( ) ) ; } else if ( data instanceof Byte ) { dataOut . writeByte ( ( ( Byte ) data ) . byteValue ( ) ) ; } else if ( data instanceof Boolean ) { dataOut . writeBoolean ( ( ( Boolean ) data ) . booleanValue ( ) ) ; } } } 	0	['3', '1', '0', '2', '41', '3', '0', '2', '1', '2', '228', '0', '0', '0', '0.333333333', '0', '0', '75', '1', '0.6667', '0']
package org . apache . camel . component . file . strategy ; import java . io . File ; import org . apache . camel . component . file . FileExchange ; public class DefaultFileRenamer implements FileRenamer { private static final boolean ON_WINDOWS = System . getProperty ( "os.name" ) . startsWith ( "Windows" ) ; private String namePrefix ; private String namePostfix ; public DefaultFileRenamer ( ) { } public DefaultFileRenamer ( String namePrefix , String namePostfix ) { this . namePrefix = namePrefix ; this . namePostfix = namePostfix ; } public File renameFile ( FileExchange exchange , File file ) { File parent = file . getParentFile ( ) ; String name = renameFileName ( file ) ; if ( ON_WINDOWS && ( name . indexOf ( ":" ) >= 0 || name . startsWith ( "//" ) ) ) { return new File ( name ) ; } return new File ( parent , name ) ; } public String getNamePostfix ( ) { return namePostfix ; } public void setNamePostfix ( String namePostfix ) { this . namePostfix = namePostfix ; } public String getNamePrefix ( ) { return namePrefix ; } public void setNamePrefix ( String namePrefix ) { this . namePrefix = namePrefix ; } protected String renameFileName ( File file ) { StringBuffer buffer = new StringBuffer ( ) ; if ( namePrefix != null ) { buffer . append ( namePrefix ) ; } buffer . append ( file . getName ( ) ) ; if ( namePostfix != null ) { buffer . append ( namePostfix ) ; } return buffer . toString ( ) ; } } 	0	['9', '1', '0', '5', '20', '12', '3', '2', '7', '0.625', '100', '1', '0', '0', '0.4375', '0', '0', '9.777777778', '4', '1.2222', '0']
package org . apache . camel . language . bean ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . builder . PredicateBuilder ; import org . apache . camel . spi . Language ; import org . apache . camel . util . ObjectHelper ; public class BeanLanguage implements Language { public static Expression bean ( String expression ) { BeanLanguage language = new BeanLanguage ( ) ; return language . createExpression ( expression ) ; } public static Expression bean ( Class beanType , String method ) { Object bean = ObjectHelper . newInstance ( beanType ) ; return bean ( bean , method ) ; } public static Expression bean ( Object bean , String method ) { BeanLanguage language = new BeanLanguage ( ) ; return language . createExpression ( bean , method ) ; } public Predicate < Exchange > createPredicate ( String expression ) { return PredicateBuilder . toPredicate ( createExpression ( expression ) ) ; } public Expression < Exchange > createExpression ( String expression ) { ObjectHelper . notNull ( expression , "expression" ) ; int idx = expression . lastIndexOf ( '.' ) ; String beanName = expression ; String method = null ; if ( idx > 0 ) { beanName = expression . substring ( 0 , idx ) ; method = expression . substring ( idx + 1 ) ; } return new BeanExpression ( beanName , method ) ; } public Expression < Exchange > createExpression ( Object bean , String method ) { ObjectHelper . notNull ( bean , "bean" ) ; return new BeanExpression ( bean , method ) ; } } 	0	['7', '1', '0', '7', '16', '21', '1', '6', '7', '2', '78', '0', '0', '0', '0.464285714', '0', '0', '10.14285714', '2', '1', '0']
package org . apache . camel . processor . resequencer ; import java . util . Timer ; import java . util . TimerTask ; public class Timeout extends TimerTask { private TimeoutHandler timeoutHandler ; private Timer timer ; private long timeout ; public Timeout ( Timer timer , long timeout ) { this . timeout = timeout ; this . timer = timer ; } public TimeoutHandler getTimeoutHandlers ( ) { return timeoutHandler ; } public void setTimeoutHandler ( TimeoutHandler timeoutHandler ) { this . timeoutHandler = timeoutHandler ; } public void schedule ( ) { timer . schedule ( this , timeout ) ; } @ Override public void run ( ) { timeoutHandler . timeout ( this ) ; } } 	0	['5', '2', '0', '3', '8', '2', '3', '1', '5', '0.666666667', '36', '1', '1', '0.428571429', '0.4', '0', '0', '5.6', '1', '0.8', '0']
package org . apache . camel . converter ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . PARAMETER } ) public @ interface HasAnnotation { Class value ( ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . file . remote ; import java . io . IOException ; import java . io . InputStream ; import org . apache . camel . Exchange ; import org . apache . commons . net . ftp . FTPClient ; public class FtpProducer extends RemoteFileProducer < RemoteFileExchange > { private FtpEndpoint endpoint ; private FTPClient client ; private boolean loggedIn ; public FtpProducer ( FtpEndpoint endpoint , FTPClient client ) { super ( endpoint ) ; this . endpoint = endpoint ; this . client = client ; } public void process ( Exchange exchange ) throws Exception { if ( log . isTraceEnabled ( ) ) { log . trace ( "Processing " + endpoint . getConfiguration ( ) ) ; } try { connectIfNecessary ( ) ; if ( ! loggedIn ) { String message = "Could not connect/login to " + endpoint . getConfiguration ( ) ; log . warn ( message ) ; throw new FtpOperationFailedException ( client . getReplyCode ( ) , client . getReplyString ( ) , message ) ; } process ( endpoint . createExchange ( exchange ) ) ; } catch ( Exception e ) { loggedIn = false ; if ( isStopping ( ) || isStopped ( ) ) { log . warn ( "Producer is stopping. Ignoring caught exception: " + e . getClass ( ) . getCanonicalName ( ) + " message: " + e . getMessage ( ) ) ; } else { log . warn ( "Exception occured during processing: " + e . getClass ( ) . getCanonicalName ( ) + " message: " + e . getMessage ( ) ) ; disconnect ( ) ; throw e ; } } } protected void connectIfNecessary ( ) throws IOException { if ( ! client . isConnected ( ) || ! loggedIn ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Not connected/logged in, connecting to " + remoteServer ( ) ) ; } loggedIn = FtpUtils . connect ( client , endpoint . getConfiguration ( ) ) ; if ( ! loggedIn ) { return ; } } log . info ( "Connected and logged in to " + remoteServer ( ) ) ; } public void disconnect ( ) throws IOException { loggedIn = false ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Disconnecting from " + remoteServer ( ) ) ; } FtpUtils . disconnect ( client ) ; } public void process ( RemoteFileExchange exchange ) throws Exception { InputStream payload = exchange . getIn ( ) . getBody ( InputStream . class ) ; try { String fileName = createFileName ( exchange . getIn ( ) , endpoint . getConfiguration ( ) ) ; int lastPathIndex = fileName . lastIndexOf ( '/' ) ; if ( lastPathIndex != - 1 ) { String directory = fileName . substring ( 0 , lastPathIndex ) ; if ( ! FtpUtils . buildDirectory ( client , directory ) ) { log . warn ( "Couldn't build directory: " + directory + " (could be because of denied permissions)" ) ; } } boolean success = client . storeFile ( fileName , payload ) ; if ( ! success ) { String message = "Error sending file: " + fileName + " to: " + remoteServer ( ) ; throw new FtpOperationFailedException ( client . getReplyCode ( ) , client . getReplyString ( ) , message ) ; } log . info ( "Sent: " + fileName + " to: " + remoteServer ( ) ) ; } finally { if ( payload != null ) { payload . close ( ) ; } } } } 	0	['5', '4', '0', '11', '38', '0', '1', '11', '4', '0.25', '303', '1', '1', '0.870967742', '0.36', '1', '1', '59', '1', '0.8', '0']
package org . apache . camel . spi ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; public interface Language { Predicate < Exchange > createPredicate ( String expression ) ; Expression < Exchange > createExpression ( String expression ) ; } 	0	['2', '1', '0', '30', '2', '1', '28', '2', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . impl ; import java . util . Map ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . ResolveEndpointFailedException ; import org . apache . camel . util . IntrospectionSupport ; public abstract class ScheduledPollEndpoint < E extends Exchange > extends DefaultEndpoint < E > { private Map consumerProperties ; protected ScheduledPollEndpoint ( String endpointUri , Component component ) { super ( endpointUri , component ) ; } protected ScheduledPollEndpoint ( String endpointUri , CamelContext context ) { super ( endpointUri , context ) ; } protected ScheduledPollEndpoint ( String endpointUri ) { super ( endpointUri ) ; } protected ScheduledPollEndpoint ( ) { } public Map getConsumerProperties ( ) { return consumerProperties ; } public void setConsumerProperties ( Map consumerProperties ) { this . consumerProperties = consumerProperties ; } protected void configureConsumer ( Consumer < E > consumer ) throws Exception { if ( consumerProperties != null ) { IntrospectionSupport . setProperties ( getCamelContext ( ) . getTypeConverter ( ) , consumer , consumerProperties ) ; if ( ! this . isLenientProperties ( ) && consumerProperties . size ( ) > 0 ) { throw new ResolveEndpointFailedException ( this . getEndpointUri ( ) , "There are " + consumerProperties . size ( ) + " parameters that couldn't be set on the endpoint consumer." + " Check the uri if the parameters are spelt correctly and that they are properties of the endpoint." + " Unknown consumer parameters=[" + consumerProperties + "]" ) ; } } } public void configureProperties ( Map options ) { Map consumerProperties = IntrospectionSupport . extractProperties ( options , "consumer." ) ; if ( consumerProperties != null ) { setConsumerProperties ( consumerProperties ) ; } } } 	0	['8', '2', '6', '13', '25', '22', '6', '7', '3', '0.571428571', '89', '1', '0', '0.857142857', '0.333333333', '0', '0', '10', '2', '0.625', '0']
package org . apache . camel . component . cxf ; import org . apache . cxf . message . Exchange ; public interface MessageInvoker { void invoke ( Exchange exchange ) ; } 	0	['1', '1', '0', '4', '1', '0', '3', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . language ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . ANNOTATION_TYPE } ) public @ interface NamespacePrefix { String prefix ( ) ; String uri ( ) ; } 	0	['2', '1', '0', '4', '2', '1', '4', '0', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . file . strategy ; public class NoOpFileProcessStrategy extends FileProcessStrategySupport { public NoOpFileProcessStrategy ( ) { super ( true ) ; } public NoOpFileProcessStrategy ( boolean isLock ) { super ( isLock ) ; } } 	0	['2', '2', '0', '2', '3', '1', '1', '1', '2', '2', '10', '0', '0', '1', '0.75', '0', '0', '4', '0', '0', '0']
package org . apache . camel . spi ; import java . util . Collection ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Route ; import org . apache . camel . Service ; public interface LifecycleStrategy { void onContextStart ( CamelContext context ) ; void onEndpointAdd ( Endpoint < ? extends Exchange > endpoint ) ; void onServiceAdd ( CamelContext context , Service service ) ; void onRoutesAdd ( Collection < Route > routes ) ; void onRouteContextCreate ( RouteContext routeContext ) ; } 	0	['5', '1', '0', '12', '5', '10', '9', '4', '5', '2', '5', '0', '0', '0', '0.366666667', '0', '0', '0', '1', '1', '0']
package org . apache . camel . language ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . spi . Language ; public class IllegalSyntaxException extends RuntimeCamelException { private final Language language ; private final String expression ; public IllegalSyntaxException ( Language language , String expression ) { this ( language , expression , null ) ; } public IllegalSyntaxException ( Language language , String expression , Throwable cause ) { super ( "Illegal syntax for language: " + language + ". Expression: " + expression , cause ) ; this . language = language ; this . expression = expression ; } public String getExpression ( ) { return expression ; } public Language getLanguage ( ) { return language ; } } 	0	['4', '5', '0', '6', '9', '2', '4', '2', '4', '0.333333333', '40', '1', '1', '0.894736842', '0.5625', '0', '0', '8.5', '1', '0.5', '0']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "groovy" ) public class GroovyExpression extends ExpressionType { public GroovyExpression ( ) { } public GroovyExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "groovy" ; } } 	0	['3', '2', '0', '1', '5', '3', '0', '1', '3', '2', '12', '0', '0', '0.956521739', '0.666666667', '1', '2', '3', '1', '0.3333', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlEnum ; @ XmlEnum public enum LoggingLevel { DEBUG , ERROR , FATAL , INFO , TRACE , WARN , OFF } 	0	['4', '2', '0', '17', '7', '4', '16', '1', '2', '0.958333333', '100', '0.125', '8', '0.857142857', '0.444444444', '1', '1', '22', '1', '0.5', '0']
package org . apache . camel . component . jcr ; import java . net . URI ; import java . net . URISyntaxException ; import javax . jcr . Credentials ; import javax . jcr . Repository ; import javax . jcr . SimpleCredentials ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . impl . DefaultExchange ; public class JcrEndpoint extends DefaultEndpoint < DefaultExchange > { private Credentials credentials ; private Repository repository ; private String base ; @ SuppressWarnings ( "unchecked" ) protected JcrEndpoint ( String endpointUri , JcrComponent component ) { super ( endpointUri , component ) ; try { URI uri = new URI ( endpointUri ) ; if ( uri . getUserInfo ( ) != null && uri . getAuthority ( ) != null ) { this . credentials = new SimpleCredentials ( uri . getUserInfo ( ) , uri . getAuthority ( ) . toCharArray ( ) ) ; } this . repository = ( Repository ) component . getCamelContext ( ) . getRegistry ( ) . lookup ( uri . getHost ( ) ) ; if ( repository == null ) { throw new RuntimeCamelException ( "No JCR repository defined under '" + uri . getHost ( ) + "'" ) ; } this . base = uri . getPath ( ) . replaceAll ( "^/" , "" ) ; } catch ( URISyntaxException e ) { throw new IllegalArgumentException ( "Invalid URI: " + endpointUri , e ) ; } } public JcrEndpoint ( String endpointUri , String base , Credentials credentials , Repository repository ) { super ( endpointUri ) ; this . base = base ; this . credentials = credentials ; this . repository = repository ; } public Consumer < DefaultExchange > createConsumer ( Processor processor ) throws Exception { throw new RuntimeCamelException ( "No consumer endpoint support for JCR available" ) ; } public Producer < DefaultExchange > createProducer ( ) throws Exception { return new JcrProducer ( this ) ; } public boolean isSingleton ( ) { return false ; } protected Repository getRepository ( ) { return repository ; } protected Credentials getCredentials ( ) { return credentials ; } protected String getBase ( ) { return base ; } } 	0	['8', '2', '0', '10', '27', '14', '2', '10', '4', '0.714285714', '120', '1', '0', '0.8', '0.291666667', '0', '0', '13.625', '1', '0.75', '0']
package org . apache . camel . component . cxf ; import org . apache . camel . Consumer ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . component . cxf . spring . CxfEndpointBean ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . spi . HeaderFilterStrategy ; import org . apache . camel . spring . SpringCamelContext ; import org . apache . camel . util . ObjectHelper ; import org . apache . cxf . configuration . spring . ConfigurerImpl ; import org . apache . cxf . message . Message ; import org . springframework . context . ApplicationContext ; public class CxfEndpoint extends DefaultEndpoint < CxfExchange > { private final CxfComponent component ; private final String address ; private String wsdlURL ; private String serviceClass ; private String portName ; private String serviceName ; private String dataFormat ; private String beanId ; private String serviceClassInstance ; private boolean isWrapped ; private boolean isSpringContextEndpoint ; private boolean inOut = true ; private Boolean isSetDefaultBus ; private ConfigurerImpl configurer ; private CxfEndpointBean cxfEndpointBean ; public CxfEndpoint ( String uri , String address , CxfComponent component ) { super ( uri , component ) ; this . component = component ; this . address = address ; if ( address . startsWith ( CxfConstants . SPRING_CONTEXT_ENDPOINT ) ) { isSpringContextEndpoint = true ; beanId = address . substring ( CxfConstants . SPRING_CONTEXT_ENDPOINT . length ( ) ) ; if ( beanId . startsWith ( "//" ) ) { beanId = beanId . substring ( 2 ) ; } SpringCamelContext context = ( SpringCamelContext ) this . getCamelContext ( ) ; configurer = new ConfigurerImpl ( context . getApplicationContext ( ) ) ; cxfEndpointBean = ( CxfEndpointBean ) context . getApplicationContext ( ) . getBean ( beanId ) ; ObjectHelper . notNull ( cxfEndpointBean , "cxfEndpointBean" ) ; } } public Producer < CxfExchange > createProducer ( ) throws Exception { return new CxfProducer ( this ) ; } public Consumer < CxfExchange > createConsumer ( Processor processor ) throws Exception { return new CxfConsumer ( this , processor ) ; } public CxfExchange createExchange ( ) { return new CxfExchange ( getCamelContext ( ) , getExchangePattern ( ) ) ; } public CxfExchange createExchange ( ExchangePattern pattern ) { return new CxfExchange ( getCamelContext ( ) , pattern ) ; } public CxfExchange createExchange ( Message inMessage ) { return new CxfExchange ( getCamelContext ( ) , getExchangePattern ( ) , inMessage ) ; } public String getDataFormat ( ) { return dataFormat ; } public void setDataFormat ( String format ) { dataFormat = format ; } public boolean isSpringContextEndpoint ( ) { return isSpringContextEndpoint ; } public String getAddress ( ) { return address ; } public String getWsdlURL ( ) { return wsdlURL ; } public void setWsdlURL ( String url ) { wsdlURL = url ; } public void setSetDefaultBus ( Boolean set ) { isSetDefaultBus = set ; } public Boolean isSetDefaultBus ( ) { return isSetDefaultBus ; } public String getServiceClass ( ) { return serviceClass ; } public void setServiceClass ( String className ) { serviceClass = className ; } public String getServiceClassInstance ( ) { return serviceClassInstance ; } public void setServiceClassInstance ( String classInstance ) { serviceClassInstance = classInstance ; } public void setPortName ( String port ) { portName = port ; } public void setServiceName ( String service ) { serviceName = service ; } public String getPortName ( ) { return portName ; } public String getServiceName ( ) { return serviceName ; } public boolean isInOut ( ) { return inOut ; } public void setInOut ( boolean inOut ) { this . inOut = inOut ; } public boolean isWrapped ( ) { return isWrapped ; } public void setWrapped ( boolean wrapped ) { isWrapped = wrapped ; } public CxfComponent getComponent ( ) { return component ; } public boolean isSingleton ( ) { return true ; } public String getBeanId ( ) { return beanId ; } public CxfEndpointBean getCxfEndpointBean ( ) { return cxfEndpointBean ; } public void configure ( Object beanInstance ) { configurer . configureBean ( beanId , beanInstance ) ; } public ApplicationContext getApplicationContext ( ) { if ( getCamelContext ( ) instanceof SpringCamelContext ) { SpringCamelContext context = ( SpringCamelContext ) getCamelContext ( ) ; return context . getApplicationContext ( ) ; } else { return null ; } } public HeaderFilterStrategy getHeaderFilterStrategy ( ) { return component . getHeaderFilterStrategy ( ) ; } } 	0	['36', '2', '0', '21', '49', '590', '5', '19', '36', '0.963809524', '261', '1', '2', '0.406779661', '0.160493827', '1', '2', '5.833333333', '2', '1', '0']
package org . apache . camel . impl . converter ; import org . apache . camel . TypeConverter ; import org . apache . camel . spi . Injector ; public interface TypeConverterRegistry { void addTypeConverter ( Class toType , Class fromType , TypeConverter typeConverter ) ; Injector getInjector ( ) ; } 	0	['2', '1', '0', '8', '2', '1', '6', '2', '2', '2', '2', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . mail ; import java . io . IOException ; import java . util . Enumeration ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; import javax . activation . DataHandler ; import javax . activation . DataSource ; import javax . mail . Address ; import javax . mail . BodyPart ; import javax . mail . Header ; import javax . mail . Message ; import javax . mail . MessagingException ; import javax . mail . Part ; import javax . mail . internet . InternetAddress ; import javax . mail . internet . MimeBodyPart ; import javax . mail . internet . MimeMessage ; import javax . mail . internet . MimeMultipart ; import javax . mail . util . ByteArrayDataSource ; import org . apache . camel . Exchange ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . converter . ObjectConverter ; import org . apache . camel . impl . DefaultHeaderFilterStrategy ; import org . apache . camel . spi . HeaderFilterStrategy ; import org . apache . camel . util . CollectionHelper ; public class MailBinding { private HeaderFilterStrategy headerFilterStrategy ; public MailBinding ( ) { headerFilterStrategy = new DefaultHeaderFilterStrategy ( ) ; } public MailBinding ( HeaderFilterStrategy headerFilterStrategy ) { this . headerFilterStrategy = headerFilterStrategy ; } public void populateMailMessage ( MailEndpoint endpoint , MimeMessage mimeMessage , Exchange exchange ) throws MessagingException , IOException { if ( hasRecipientHeaders ( exchange . getIn ( ) ) ) { setRecipientFromCamelMessage ( mimeMessage , exchange , exchange . getIn ( ) ) ; } else { setRecipientFromEndpointConfiguration ( mimeMessage , endpoint ) ; } if ( mimeMessage . getAllRecipients ( ) == null ) { throw new IllegalArgumentException ( "The mail message does not have any recipients set." ) ; } appendHeadersFromCamelMessage ( mimeMessage , exchange , exchange . getIn ( ) ) ; if ( empty ( mimeMessage . getFrom ( ) ) ) { String from = endpoint . getConfiguration ( ) . getFrom ( ) ; mimeMessage . setFrom ( new InternetAddress ( from ) ) ; } if ( exchange . getIn ( ) . hasAttachments ( ) ) { appendAttachmentsFromCamel ( mimeMessage , exchange . getIn ( ) , endpoint . getConfiguration ( ) ) ; } else { if ( "text/html" . equals ( endpoint . getConfiguration ( ) . getContentType ( ) ) ) { DataSource ds = new ByteArrayDataSource ( exchange . getIn ( ) . getBody ( String . class ) , "text/html" ) ; mimeMessage . setDataHandler ( new DataHandler ( ds ) ) ; } else { mimeMessage . setText ( exchange . getIn ( ) . getBody ( String . class ) ) ; } } } public Object extractBodyFromMail ( MailExchange exchange , Message message ) { try { return message . getContent ( ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( "Failed to extract body due to: " + e . getMessage ( ) + ". Exchange: " + exchange + ". Message: " + message , e ) ; } } protected void appendHeadersFromCamelMessage ( MimeMessage mimeMessage , Exchange exchange , org . apache . camel . Message camelMessage ) throws MessagingException { for ( Map . Entry < String , Object > entry : camelMessage . getHeaders ( ) . entrySet ( ) ) { String headerName = entry . getKey ( ) ; Object headerValue = entry . getValue ( ) ; if ( headerValue != null ) { if ( headerFilterStrategy != null && ! headerFilterStrategy . applyFilterToCamelHeaders ( headerName , headerValue ) ) { if ( isRecipientHeader ( headerName ) ) { continue ; } if ( ObjectConverter . isCollection ( headerValue ) ) { Iterator iter = ObjectConverter . iterator ( headerValue ) ; while ( iter . hasNext ( ) ) { Object value = iter . next ( ) ; mimeMessage . addHeader ( headerName , asString ( exchange , value ) ) ; } } else { mimeMessage . setHeader ( headerName , asString ( exchange , headerValue ) ) ; } } } } } private void setRecipientFromCamelMessage ( MimeMessage mimeMessage , Exchange exchange , org . apache . camel . Message camelMessage ) throws MessagingException { for ( Map . Entry < String , Object > entry : camelMessage . getHeaders ( ) . entrySet ( ) ) { String headerName = entry . getKey ( ) ; Object headerValue = entry . getValue ( ) ; if ( headerValue != null && isRecipientHeader ( headerName ) ) { if ( ObjectConverter . isCollection ( headerValue ) ) { Iterator iter = ObjectConverter . iterator ( headerValue ) ; while ( iter . hasNext ( ) ) { Object recipient = iter . next ( ) ; appendRecipientToMimeMessage ( mimeMessage , headerName , asString ( exchange , recipient ) ) ; } } else { appendRecipientToMimeMessage ( mimeMessage , headerName , asString ( exchange , headerValue ) ) ; } } } } protected void setRecipientFromEndpointConfiguration ( MimeMessage mimeMessage , MailEndpoint endpoint ) throws MessagingException { Map < Message . RecipientType , String > recipients = endpoint . getConfiguration ( ) . getRecipients ( ) ; if ( recipients . containsKey ( Message . RecipientType . TO ) ) { appendRecipientToMimeMessage ( mimeMessage , Message . RecipientType . TO . toString ( ) , recipients . get ( Message . RecipientType . TO ) ) ; } if ( recipients . containsKey ( Message . RecipientType . CC ) ) { appendRecipientToMimeMessage ( mimeMessage , Message . RecipientType . CC . toString ( ) , recipients . get ( Message . RecipientType . CC ) ) ; } if ( recipients . containsKey ( Message . RecipientType . BCC ) ) { appendRecipientToMimeMessage ( mimeMessage , Message . RecipientType . BCC . toString ( ) , recipients . get ( Message . RecipientType . BCC ) ) ; } String destination = endpoint . getConfiguration ( ) . getDestination ( ) ; if ( destination != null && mimeMessage . getRecipients ( Message . RecipientType . TO ) == null ) { appendRecipientToMimeMessage ( mimeMessage , Message . RecipientType . TO . toString ( ) , destination ) ; } } protected void appendAttachmentsFromCamel ( MimeMessage mimeMessage , org . apache . camel . Message camelMessage , MailConfiguration configuration ) throws MessagingException { MimeMultipart multipart = new MimeMultipart ( ) ; multipart . setSubType ( "mixed" ) ; MimeBodyPart textBodyPart = new MimeBodyPart ( ) ; textBodyPart . setContent ( camelMessage . getBody ( String . class ) , configuration . getContentType ( ) ) ; multipart . addBodyPart ( textBodyPart ) ; for ( Map . Entry < String , DataHandler > entry : camelMessage . getAttachments ( ) . entrySet ( ) ) { String attachmentFilename = entry . getKey ( ) ; DataHandler handler = entry . getValue ( ) ; if ( handler != null ) { if ( shouldOutputAttachment ( camelMessage , attachmentFilename , handler ) ) { BodyPart messageBodyPart = new MimeBodyPart ( ) ; messageBodyPart . setDataHandler ( handler ) ; messageBodyPart . setFileName ( attachmentFilename ) ; messageBodyPart . setDisposition ( Part . ATTACHMENT ) ; multipart . addBodyPart ( messageBodyPart ) ; } } } mimeMessage . setContent ( multipart ) ; } protected boolean shouldOutputAttachment ( org . apache . camel . Message camelMessage , String attachmentFilename , DataHandler handler ) { return true ; } protected Map < String , Object > extractHeadersFromMail ( Message mailMessage ) throws MessagingException { Map < String , Object > answer = new HashMap < String , Object > ( ) ; Enumeration names = mailMessage . getAllHeaders ( ) ; while ( names . hasMoreElements ( ) ) { Header header = ( Header ) names . nextElement ( ) ; String [ ] value = mailMessage . getHeader ( header . getName ( ) ) ; if ( headerFilterStrategy != null && ! headerFilterStrategy . applyFilterToExternalHeaders ( header . getName ( ) , value ) ) { if ( value . length == 1 ) { CollectionHelper . appendValue ( answer , header . getName ( ) . toLowerCase ( ) , value [ 0 ] ) ; } else { CollectionHelper . appendValue ( answer , header . getName ( ) . toLowerCase ( ) , value ) ; } } } return answer ; } private static void appendRecipientToMimeMessage ( MimeMessage mimeMessage , String type , String recipient ) throws MessagingException { String [ ] lines = recipient . split ( "[,|;]" ) ; for ( String line : lines ) { line = line . trim ( ) ; mimeMessage . addRecipients ( asRecipientType ( type ) , line ) ; } } private static boolean hasRecipientHeaders ( org . apache . camel . Message camelMessage ) { for ( String key : camelMessage . getHeaders ( ) . keySet ( ) ) { if ( isRecipientHeader ( key ) ) { return true ; } } return false ; } private static boolean isRecipientHeader ( String key ) { if ( Message . RecipientType . TO . toString ( ) . equalsIgnoreCase ( key ) ) { return true ; } else if ( Message . RecipientType . CC . toString ( ) . equalsIgnoreCase ( key ) ) { return true ; } else if ( Message . RecipientType . BCC . toString ( ) . equalsIgnoreCase ( key ) ) { return true ; } return false ; } private static Message . RecipientType asRecipientType ( String type ) { if ( Message . RecipientType . TO . toString ( ) . equalsIgnoreCase ( type ) ) { return Message . RecipientType . TO ; } else if ( Message . RecipientType . CC . toString ( ) . equalsIgnoreCase ( type ) ) { return Message . RecipientType . CC ; } else if ( Message . RecipientType . BCC . toString ( ) . equalsIgnoreCase ( type ) ) { return Message . RecipientType . BCC ; } throw new IllegalArgumentException ( "Unknown recipient type: " + type ) ; } private static boolean empty ( Address [ ] addresses ) { return addresses == null || addresses . length == 0 ; } private static String asString ( Exchange exchange , Object value ) { return exchange . getContext ( ) . getTypeConverter ( ) . convertTo ( String . class , exchange , value ) ; } } 	0	['16', '1', '0', '14', '86', '108', '4', '12', '4', '0.733333333', '559', '1', '1', '0', '0.1875', '0', '0', '33.875', '4', '1.4375', '0']
package org . apache . camel . component . http ; import org . apache . commons . httpclient . HttpClient ; public interface HttpClientConfigurer { void configureHttpClient ( HttpClient client ) ; } 	0	['1', '1', '0', '6', '1', '0', '5', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
@ javax . xml . bind . annotation . XmlSchema ( namespace = "http://activemq.apache.org/camel/schema/spring" , elementFormDefault = javax . xml . bind . annotation . XmlNsForm . QUALIFIED ) package org . apache . camel . model ; 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . component . list ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; public class ListComponent extends DefaultComponent { protected Endpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { return new ListEndpoint ( uri , this ) ; } } 	0	['2', '3', '0', '4', '4', '1', '0', '4', '1', '2', '11', '0', '0', '0.972222222', '0.666666667', '1', '1', '4.5', '1', '0.5', '0']
package org . apache . camel . component . cxf ; import java . lang . reflect . Method ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . logging . Level ; import java . util . logging . Logger ; import org . apache . camel . ExchangePattern ; import org . apache . camel . component . cxf . util . CxfHeaderHelper ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . endpoint . Endpoint ; import org . apache . cxf . frontend . MethodDispatcher ; import org . apache . cxf . helpers . CastUtils ; import org . apache . cxf . interceptor . Fault ; import org . apache . cxf . message . Exchange ; import org . apache . cxf . message . Message ; import org . apache . cxf . message . MessageContentsList ; import org . apache . cxf . service . Service ; import org . apache . cxf . service . invoker . Invoker ; import org . apache . cxf . service . model . BindingMessageInfo ; import org . apache . cxf . service . model . BindingOperationInfo ; public class CamelInvoker implements Invoker , MessageInvoker { private static final Logger LOG = LogUtils . getL7dLogger ( CamelInvoker . class ) ; private CxfConsumer cxfConsumer ; public CamelInvoker ( CxfConsumer consumer ) { cxfConsumer = consumer ; } public void invoke ( Exchange exchange ) { Message inMessage = exchange . getInMessage ( ) ; CxfEndpoint endpoint = cxfConsumer . getEndpoint ( ) ; CxfExchange cxfExchange = endpoint . createExchange ( inMessage ) ; BindingOperationInfo bop = exchange . get ( BindingOperationInfo . class ) ; cxfExchange . setProperty ( BindingOperationInfo . class . toString ( ) , bop ) ; if ( bop != null && bop . getOperationInfo ( ) . isOneWay ( ) ) { cxfExchange . setPattern ( ExchangePattern . InOnly ) ; } else { cxfExchange . setPattern ( ExchangePattern . InOut ) ; } try { cxfConsumer . getProcessor ( ) . process ( cxfExchange ) ; } catch ( Exception ex ) { throw new Fault ( ex ) ; } copybackExchange ( cxfExchange , exchange ) ; Message outMessage = exchange . getOutMessage ( ) ; outMessage . put ( Message . INBOUND_MESSAGE , Boolean . FALSE ) ; BindingOperationInfo boi = exchange . get ( BindingOperationInfo . class ) ; if ( boi != null ) { exchange . put ( BindingMessageInfo . class , boi . getOutput ( ) ) ; } } public void copybackExchange ( CxfExchange result , Exchange exchange ) { final Endpoint endpoint = exchange . get ( Endpoint . class ) ; Message outMessage = null ; if ( result . isFailed ( ) ) { CxfMessage fault = result . getFault ( ) ; outMessage = exchange . getInFaultMessage ( ) ; if ( outMessage == null ) { outMessage = endpoint . getBinding ( ) . createMessage ( ) ; outMessage . setExchange ( exchange ) ; exchange . setInFaultMessage ( outMessage ) ; } Throwable ex = ( Throwable ) fault . getBody ( ) ; if ( ex != null ) { outMessage . setContent ( Throwable . class , ex ) ; } else { outMessage . setContent ( Throwable . class , result . getException ( ) ) ; } } else { outMessage = result . getOutMessage ( ) ; if ( LOG . isLoggable ( Level . FINEST ) ) { LOG . finest ( "Get the response outMessage " + outMessage ) ; } org . apache . camel . Message camelMessage = result . getOut ( ) ; CxfBinding . copyMessage ( camelMessage , outMessage ) ; } exchange . setOutMessage ( outMessage ) ; } @ SuppressWarnings ( "unchecked" ) public void updateContext ( Map < String , Object > from , Map < String , Object > to ) { if ( to != null && from != null ) { for ( Iterator iter = from . entrySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) iter . next ( ) ; String key = ( String ) entry . getKey ( ) ; if ( ! ( Message . INBOUND_MESSAGE . equals ( key ) || Message . REQUESTOR_ROLE . equals ( key ) || Message . PROTOCOL_HEADERS . equals ( key ) ) ) { to . put ( key , entry . getValue ( ) ) ; } } } } public Object invoke ( Exchange exchange , Object o ) { CxfEndpoint endpoint = cxfConsumer . getEndpoint ( ) ; Object params = null ; if ( o instanceof List ) { params = CastUtils . cast ( ( List < ? > ) o ) ; } else if ( o != null ) { params = new MessageContentsList ( o ) ; } CxfExchange cxfExchange = endpoint . createExchange ( exchange . getInMessage ( ) ) ; BindingOperationInfo bop = exchange . get ( BindingOperationInfo . class ) ; MethodDispatcher md = ( MethodDispatcher ) exchange . get ( Service . class ) . get ( MethodDispatcher . class . getName ( ) ) ; Method m = md . getMethod ( bop ) ; cxfExchange . setProperty ( BindingOperationInfo . class . toString ( ) , bop ) ; if ( bop != null && bop . getOperationInfo ( ) . isOneWay ( ) ) { cxfExchange . setPattern ( ExchangePattern . InOnly ) ; } else { cxfExchange . setPattern ( ExchangePattern . InOut ) ; } if ( bop != null && bop . getName ( ) != null ) { cxfExchange . getIn ( ) . setHeader ( CxfConstants . OPERATION_NAMESPACE , bop . getName ( ) . getNamespaceURI ( ) ) ; cxfExchange . getIn ( ) . setHeader ( CxfConstants . OPERATION_NAME , bop . getName ( ) . getLocalPart ( ) ) ; } else { cxfExchange . getIn ( ) . setHeader ( CxfConstants . OPERATION_NAME , m . getName ( ) ) ; } CxfHeaderHelper . propagateCxfToCamel ( endpoint . getHeaderFilterStrategy ( ) , exchange . getInMessage ( ) , cxfExchange . getIn ( ) . getHeaders ( ) ) ; cxfExchange . getIn ( ) . setBody ( params ) ; try { cxfConsumer . getProcessor ( ) . process ( cxfExchange ) ; } catch ( Exception ex ) { throw new Fault ( ex ) ; } Object result = null ; if ( cxfExchange . isFailed ( ) ) { Throwable ex = ( Throwable ) cxfExchange . getFault ( ) . getBody ( ) ; if ( ex instanceof Fault ) { throw ( Fault ) ex ; } else { if ( ex == null ) { ex = cxfExchange . getException ( ) ; } throw new Fault ( ex ) ; } } else { result = cxfExchange . getOut ( ) . getBody ( ) ; if ( result != null ) { if ( result instanceof MessageContentsList || result instanceof List || result . getClass ( ) . isArray ( ) ) { return result ; } else { MessageContentsList resList = new MessageContentsList ( ) ; resList . add ( result ) ; return resList ; } } } return result ; } } 	0	['6', '1', '0', '26', '71', '7', '1', '26', '5', '0.6', '373', '1', '1', '0', '0.4', '0', '0', '60.83333333', '14', '4.5', '0']
package org . apache . camel . component . cxf . interceptors ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import java . util . logging . Level ; import java . util . logging . Logger ; import javax . xml . namespace . QName ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . apache . cxf . binding . soap . SoapMessage ; import org . apache . cxf . binding . soap . model . SoapBindingInfo ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . helpers . DOMUtils ; import org . apache . cxf . message . Exchange ; import org . apache . cxf . phase . Phase ; import org . apache . cxf . service . model . BindingInfo ; import org . apache . cxf . service . model . BindingMessageInfo ; import org . apache . cxf . service . model . BindingOperationInfo ; import org . apache . cxf . service . model . MessagePartInfo ; public class SoapMessageInInterceptor extends AbstractMessageInInterceptor < SoapMessage > { private static final Logger LOG = LogUtils . getL7dLogger ( SoapMessageInInterceptor . class ) ; public SoapMessageInInterceptor ( ) { super ( Phase . READ ) ; } protected Logger getLogger ( ) { return LOG ; } protected boolean isFaultMessage ( SoapMessage message ) { return false ; } protected BindingOperationInfo getBindingOperation ( SoapMessage message , Document doc ) { Exchange ex = message . getExchange ( ) ; SoapBindingInfo soapBinding = ( SoapBindingInfo ) ex . get ( BindingInfo . class ) ; Element payloadEl = ( Element ) doc . getChildNodes ( ) . item ( 0 ) ; QName startQName = new QName ( payloadEl . getNamespaceURI ( ) , payloadEl . getLocalName ( ) ) ; boolean client = isRequestor ( message ) ; List < BindingOperationInfo > boiList = new ArrayList < BindingOperationInfo > ( ) ; for ( BindingOperationInfo boi : soapBinding . getOperations ( ) ) { String style = soapBinding . getStyle ( boi . getOperationInfo ( ) ) ; QName rootName = null ; if ( "rpc" . equals ( style ) ) { rootName = boi . getOperationInfo ( ) . getName ( ) ; } else { BindingMessageInfo bmi = client ? boi . getOutput ( ) : boi . getInput ( ) ; if ( bmi != null ) { Collection < MessagePartInfo > bodyParts = bmi . getMessageParts ( ) ; if ( bodyParts . size ( ) == 1 ) { MessagePartInfo p = bodyParts . iterator ( ) . next ( ) ; rootName = p . getConcreteName ( ) ; } } } if ( startQName . equals ( rootName ) ) { boiList . add ( boi ) ; } } if ( boiList . size ( ) > 1 && LOG . isLoggable ( Level . INFO ) ) { LOG . info ( "Mulitple matching BindingOperationIno found in Binding." ) ; } return boiList . size ( ) != 1 ? null : boiList . get ( 0 ) ; } protected List < Element > getPartList ( SoapMessage inMessage , Element rootNode , BindingMessageInfo bmi ) { List < Element > partList = new ArrayList < Element > ( ) ; Exchange ex = inMessage . getExchange ( ) ; SoapBindingInfo soapBinding = ( SoapBindingInfo ) ex . get ( BindingInfo . class ) ; String style = soapBinding . getStyle ( bmi . getBindingOperation ( ) . getOperationInfo ( ) ) ; if ( "rpc" . equals ( style ) ) { rootNode = ( Element ) DOMUtils . getChild ( rootNode , Node . ELEMENT_NODE ) ; } partList . add ( rootNode ) ; return partList ; } } 	0	['9', '1', '0', '12', '41', '30', '1', '11', '1', '0.625', '186', '1', '0', '0.5', '0.416666667', '1', '4', '19.55555556', '9', '1.7778', '0']
package org . apache . camel . component . jpa ; import org . apache . camel . Service ; import org . springframework . orm . jpa . JpaCallback ; public interface TransactionStrategy extends Service { Object execute ( JpaCallback callback ) ; } 	0	['1', '1', '0', '7', '1', '0', '5', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . processor . interceptor ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . processor . DelegateProcessor ; public class DebugInterceptor extends DelegateProcessor { private final ProcessorType node ; private final List < Exchange > exchanges ; private final List < ExceptionEvent > exceptions ; private Predicate traceFilter ; private Breakpoint breakpoint = new Breakpoint ( ) ; private boolean traceExceptions = true ; private boolean enabled = true ; public DebugInterceptor ( ProcessorType node , Processor target , List < Exchange > exchanges , List < ExceptionEvent > exceptions ) { super ( target ) ; this . node = node ; this . exchanges = exchanges ; this . exceptions = exceptions ; } @ Override public String toString ( ) { return "DebugInterceptor[" + node + "]" ; } public void process ( Exchange exchange ) throws Exception { if ( isEnabled ( ) ) { checkForBreakpoint ( exchange ) ; addTraceExchange ( exchange ) ; } try { super . proceed ( exchange ) ; } catch ( Exception e ) { onException ( exchange , e ) ; throw e ; } catch ( Error e ) { onException ( exchange , e ) ; throw e ; } } public ProcessorType getNode ( ) { return node ; } public boolean isEnabled ( ) { return enabled ; } public void setEnabled ( boolean flag ) { enabled = flag ; } public List < Exchange > getExchanges ( ) { return exchanges ; } public List < ExceptionEvent > getExceptions ( ) { return exceptions ; } public Breakpoint getBreakpoint ( ) { return breakpoint ; } public Predicate getTraceFilter ( ) { return traceFilter ; } public void setTraceFilter ( Predicate traceFilter ) { this . traceFilter = traceFilter ; } public boolean isTraceExceptions ( ) { return traceExceptions ; } public void setTraceExceptions ( boolean traceExceptions ) { this . traceExceptions = traceExceptions ; } protected void checkForBreakpoint ( Exchange exchange ) { breakpoint . waitForBreakpoint ( exchange ) ; } protected void onException ( Exchange exchange , Throwable e ) { if ( shouldTraceExceptionEvents ( exchange , e ) ) { exceptions . add ( new ExceptionEvent ( this , exchange , e ) ) ; } } private boolean shouldTraceExceptionEvents ( Exchange exchange , Throwable e ) { return isTraceExceptions ( ) && isEnabled ( ) ; } protected void addTraceExchange ( Exchange exchange ) { if ( shouldTraceExchange ( exchange ) ) { exchanges . add ( copyExchange ( exchange ) ) ; } } protected Exchange copyExchange ( Exchange previousExchange ) { Exchange answer = previousExchange . newInstance ( ) ; answer . getProperties ( ) . putAll ( previousExchange . getProperties ( ) ) ; answer . getIn ( ) . copyFrom ( previousExchange . getIn ( ) ) ; Message previousOut = previousExchange . getOut ( false ) ; if ( previousOut != null ) { answer . getOut ( ) . copyFrom ( previousOut ) ; } return answer ; } protected boolean shouldTraceExchange ( Exchange exchange ) { return traceFilter == null || traceFilter . matches ( exchange ) ; } } 	0	['19', '3', '0', '9', '37', '129', '2', '8', '13', '0.833333333', '203', '1', '3', '0.55', '0.223684211', '1', '1', '9.315789474', '3', '1.3158', '0']
package org . apache . camel ; public interface Producer < E extends Exchange > extends Processor , Service { Endpoint < E > getEndpoint ( ) ; E createExchange ( ) ; E createExchange ( ExchangePattern pattern ) ; E createExchange ( E exchange ) ; } 	0	['4', '1', '0', '51', '4', '6', '47', '5', '4', '2', '4', '0', '0', '0', '0.5', '0', '0', '0', '1', '1', '0']
package org . apache . camel . model ; import java . util . Collections ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Processor ; import org . apache . camel . processor . RoutingSlip ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "routingSlip" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class RoutingSlipType extends ProcessorType < ProcessorType > { public static final String ROUTING_SLIP_HEADER = "routingSlipHeader" ; public static final String DEFAULT_DELIMITER = "," ; @ XmlAttribute private String headerName ; @ XmlAttribute private String uriDelimiter ; public RoutingSlipType ( ) { this ( ROUTING_SLIP_HEADER , DEFAULT_DELIMITER ) ; } public RoutingSlipType ( String headerName ) { this ( headerName , DEFAULT_DELIMITER ) ; } public RoutingSlipType ( String headerName , String uriDelimiter ) { setHeaderName ( headerName ) ; setUriDelimiter ( uriDelimiter ) ; } @ Override public String toString ( ) { return "RoutingSlip[headerName=" + getHeaderName ( ) + ", uriDelimiter=" + getUriDelimiter ( ) + "]" ; } @ Override public String getShortName ( ) { return "routingSlip" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { return new RoutingSlip ( getHeaderName ( ) , getUriDelimiter ( ) ) ; } @ Override public List < ProcessorType < ? > > getOutputs ( ) { return Collections . EMPTY_LIST ; } public void setHeaderName ( String headerName ) { this . headerName = headerName ; } public String getHeaderName ( ) { return this . headerName ; } public void setUriDelimiter ( String uriDelimiter ) { this . uriDelimiter = uriDelimiter ; } public String getUriDelimiter ( ) { return uriDelimiter ; } } 	0	['11', '3', '0', '5', '16', '51', '2', '4', '11', '0.85', '77', '0.5', '0', '0.956521739', '0.484848485', '1', '3', '5.636363636', '1', '0.7273', '0']
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Predicate ; public abstract class PredicateSupport < E extends Exchange > implements Predicate < E > { public void assertMatches ( String text , E exchange ) { if ( ! matches ( exchange ) ) { throw new AssertionError ( assertionFailureMessage ( exchange ) + " on " + exchange ) ; } } protected String assertionFailureMessage ( E exchange ) { return toString ( ) ; } } 	0	['4', '1', '6', '8', '12', '6', '6', '2', '3', '2', '37', '0', '0', '0', '0.5625', '0', '0', '8.25', '2', '1', '0']
package org . apache . camel . component . cxf . util ; import java . io . IOException ; import org . apache . cxf . message . Message ; import org . apache . cxf . transport . Conduit ; import org . apache . cxf . transport . Destination ; import org . apache . cxf . transport . MessageObserver ; import org . apache . cxf . ws . addressing . EndpointReferenceType ; public class NullDestination implements Destination { MessageObserver messageObserver ; public NullDestination ( ) { } public EndpointReferenceType getAddress ( ) { return null ; } public Conduit getBackChannel ( Message inMessage , Message partialResponse , EndpointReferenceType address ) throws IOException { return null ; } public MessageObserver getMessageObserver ( ) { return messageObserver ; } public void shutdown ( ) { messageObserver = null ; } public void setMessageObserver ( MessageObserver observer ) { messageObserver = observer ; } } 	0	['6', '1', '0', '6', '7', '9', '1', '5', '6', '0.6', '25', '0', '0', '0', '0.375', '0', '0', '3', '1', '0.8333', '0']
package org . apache . camel . component . cxf ; public enum DataFormat { PAYLOAD , MESSAGE , POJO , UNKNOWN ; public static DataFormat asEnum ( String value ) { try { return valueOf ( value . toUpperCase ( ) ) ; } catch ( Exception e ) { return UNKNOWN ; } } } 	0	['5', '2', '0', '6', '9', '6', '5', '1', '3', '0.9', '75', '0.2', '5', '0.8', '0.416666667', '1', '1', '13', '1', '0.6', '0']
package org . apache . camel . view ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . model . AggregatorType ; import org . apache . camel . model . BeanRef ; import org . apache . camel . model . ChoiceType ; import org . apache . camel . model . FilterType ; import org . apache . camel . model . FromType ; import org . apache . camel . model . OtherwiseType ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . model . RecipientListType ; import org . apache . camel . model . ResequencerType ; import org . apache . camel . model . RoutingSlipType ; import org . apache . camel . model . SplitterType ; import org . apache . camel . model . ToType ; import org . apache . camel . model . WhenType ; import static org . apache . camel . util . ObjectHelper . isNotNullAndNonEmpty ; import static org . apache . camel . util . ObjectHelper . isNullOrBlank ; public class NodeData { public String id ; public String image ; public String label ; public String shape ; public String edgeLabel ; public String tooltop ; public String nodeType ; public boolean nodeWritten ; public String url ; public List < ProcessorType > outputs ; public String association = "property" ; private final String imagePrefix ; public NodeData ( String id , Object node , String imagePrefix ) { this . id = id ; this . imagePrefix = imagePrefix ; if ( node instanceof ProcessorType ) { ProcessorType processorType = ( ProcessorType ) node ; this . edgeLabel = processorType . getLabel ( ) ; } if ( node instanceof FromType ) { FromType fromType = ( FromType ) node ; this . tooltop = fromType . getLabel ( ) ; this . label = removeQueryString ( this . tooltop ) ; this . url = "http://activemq.apache.org/camel/message-endpoint.html" ; } else if ( node instanceof ToType ) { ToType toType = ( ToType ) node ; this . tooltop = toType . getLabel ( ) ; this . label = removeQueryString ( this . tooltop ) ; this . edgeLabel = "" ; this . url = "http://activemq.apache.org/camel/message-endpoint.html" ; } else if ( node instanceof FilterType ) { this . image = imagePrefix + "MessageFilterIcon.png" ; this . label = "Filter" ; this . nodeType = "Message Filter" ; } else if ( node instanceof WhenType ) { this . image = imagePrefix + "MessageFilterIcon.png" ; this . nodeType = "When Filter" ; this . label = "When" ; this . url = "http://activemq.apache.org/camel/content-based-router.html" ; } else if ( node instanceof OtherwiseType ) { this . nodeType = "Otherwise" ; this . edgeLabel = "" ; this . url = "http://activemq.apache.org/camel/content-based-router.html" ; this . tooltop = "Otherwise" ; } else if ( node instanceof ChoiceType ) { this . image = imagePrefix + "ContentBasedRouterIcon.png" ; this . nodeType = "Content Based Router" ; this . label = "Choice" ; this . edgeLabel = "" ; ChoiceType choice = ( ChoiceType ) node ; List < ProcessorType > outputs = new ArrayList < ProcessorType > ( choice . getWhenClauses ( ) ) ; if ( choice . getOtherwise ( ) != null ) { outputs . add ( choice . getOtherwise ( ) ) ; } this . outputs = outputs ; } else if ( node instanceof RecipientListType ) { this . image = imagePrefix + "RecipientListIcon.png" ; this . nodeType = "Recipient List" ; } else if ( node instanceof RoutingSlipType ) { this . image = imagePrefix + "RoutingTableIcon.png" ; this . nodeType = "Routing Slip" ; this . url = "http://activemq.apache.org/camel/routing-slip.html" ; this . tooltop = ( ( RoutingSlipType ) node ) . getHeaderName ( ) ; } else if ( node instanceof SplitterType ) { this . image = imagePrefix + "SplitterIcon.png" ; this . nodeType = "Splitter" ; } else if ( node instanceof AggregatorType ) { this . image = imagePrefix + "AggregatorIcon.png" ; this . nodeType = "Aggregator" ; } else if ( node instanceof ResequencerType ) { this . image = imagePrefix + "ResequencerIcon.png" ; this . nodeType = "Resequencer" ; } else if ( node instanceof BeanRef ) { BeanRef beanRef = ( BeanRef ) node ; this . nodeType = "Bean Ref" ; this . label = beanRef . getLabel ( ) + " Bean" ; this . shape = "box" ; } if ( isNullOrBlank ( this . nodeType ) && node != null ) { String name = node . getClass ( ) . getName ( ) ; int idx = name . lastIndexOf ( '.' ) ; if ( idx > 0 ) { name = name . substring ( idx + 1 ) ; } if ( name . endsWith ( "Type" ) ) { name = name . substring ( 0 , name . length ( ) - 4 ) ; } this . nodeType = insertSpacesBetweenCamelCase ( name ) ; } if ( this . label == null ) { if ( isNullOrBlank ( this . image ) ) { this . label = this . nodeType ; this . shape = "box" ; } else if ( isNotNullAndNonEmpty ( this . edgeLabel ) ) { this . label = "" ; } else { this . label = node . toString ( ) ; } } if ( isNullOrBlank ( this . tooltop ) ) { if ( isNotNullAndNonEmpty ( this . nodeType ) ) { String description = isNotNullAndNonEmpty ( this . edgeLabel ) ? this . edgeLabel : this . label ; this . tooltop = this . nodeType + ": " + description ; } else { this . tooltop = this . label ; } } if ( isNullOrBlank ( this . url ) && isNotNullAndNonEmpty ( this . nodeType ) ) { this . url = "http://activemq.apache.org/camel/" + this . nodeType . toLowerCase ( ) . replace ( ' ' , '-' ) + ".html" ; } if ( node instanceof ProcessorType && this . outputs == null ) { ProcessorType processorType = ( ProcessorType ) node ; this . outputs = processorType . getOutputs ( ) ; } } protected String removeQueryString ( String text ) { int idx = text . indexOf ( "?" ) ; if ( idx <= 0 ) { return text ; } else { return text . substring ( 0 , idx ) ; } } public static String insertSpacesBetweenCamelCase ( String name ) { boolean lastCharacterLowerCase = false ; StringBuffer buffer = new StringBuffer ( ) ; int i = 0 ; for ( int size = name . length ( ) ; i < size ; i ++ ) { char ch = name . charAt ( i ) ; if ( Character . isUpperCase ( ch ) ) { if ( lastCharacterLowerCase ) { buffer . append ( ' ' ) ; } lastCharacterLowerCase = false ; } else { lastCharacterLowerCase = true ; } buffer . append ( ch ) ; } return buffer . toString ( ) ; } } 	0	['3', '1', '0', '17', '35', '3', '3', '14', '2', '1.041666667', '491', '0.083333333', '0', '0', '0.666666667', '0', '0', '158.6666667', '4', '2', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . processor . HandleFaultProcessor ; @ XmlRootElement ( name = "handleFault" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class HandleFaultType extends InterceptorRef { public HandleFaultType ( ) { super ( new HandleFaultProcessor ( ) ) ; } @ Override public String getShortName ( ) { return "handleFault" ; } @ Override public String toString ( ) { return "HandleFault[" + getLabel ( ) + "]" ; } } 	0	['3', '6', '0', '4', '9', '3', '1', '3', '3', '2', '23', '0', '0', '0.989473684', '1', '1', '1', '6.666666667', '1', '0.6667', '0']
package org . apache . camel . component . jmx ; import javax . management . Notification ; import org . apache . camel . impl . DefaultMessage ; public class JMXMessage extends DefaultMessage { private Notification notification ; public JMXMessage ( ) { this ( null ) ; } public JMXMessage ( Notification notification ) { this . notification = notification ; } @ Override public String toString ( ) { return "JMXMessage: " + notification ; } @ Override public JMXExchange getExchange ( ) { return ( JMXExchange ) super . getExchange ( ) ; } @ Override public JMXMessage newInstance ( ) { return new JMXMessage ( ) ; } public Notification getNotification ( ) { return notification ; } } 	0	['9', '3', '0', '4', '12', '30', '1', '4', '9', '0.25', '50', '1', '0', '0.833333333', '0.555555556', '2', '5', '4.444444444', '1', '0.7778', '0']
package org . apache . camel . component . bean ; import org . apache . camel . Expression ; public interface ParameterMappingStrategy { Expression getDefaultParameterTypeExpression ( Class parameterType ) ; } 	0	['1', '1', '0', '8', '1', '0', '7', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . language ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . CONSTRUCTOR } ) public @ interface LanguageExpression { String language ( ) ; String expression ( ) ; } 	0	['2', '1', '0', '0', '2', '1', '0', '0', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . builder . script ; import org . apache . camel . CamelContext ; import org . apache . camel . spi . Language ; import org . apache . camel . spi . LanguageResolver ; public class ScriptLanguageResolver implements LanguageResolver { public Language resolveLanguage ( String name , CamelContext context ) { return new ScriptLanguage ( name ) ; } } 	0	['2', '1', '0', '4', '4', '1', '0', '4', '2', '2', '10', '0', '0', '0', '0.666666667', '0', '0', '4', '1', '0.5', '0']
package org . apache . camel . management ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . springframework . jmx . export . annotation . ManagedAttribute ; import org . springframework . jmx . export . annotation . ManagedResource ; @ ManagedResource ( description = "Managed Endpoint" , currencyTimeLimit = 15 ) public class ManagedEndpoint { private Endpoint < ? extends Exchange > endpoint ; public ManagedEndpoint ( Endpoint < ? extends Exchange > endpoint ) { this . endpoint = endpoint ; } public Endpoint < ? extends Exchange > getEndpoint ( ) { return endpoint ; } @ ManagedAttribute ( description = "Endpoint Uri" ) public String getUri ( ) throws Exception { return endpoint . getEndpointUri ( ) ; } @ ManagedAttribute ( description = "Singleton" ) public boolean getSingleton ( ) throws Exception { return endpoint . isSingleton ( ) ; } } 	0	['4', '1', '0', '3', '7', '0', '2', '1', '4', '0', '22', '1', '1', '0', '0.625', '0', '0', '4.25', '1', '0.75', '0']
package org . apache . camel . model ; import java . util . List ; import java . util . concurrent . ThreadPoolExecutor ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Processor ; import org . apache . camel . processor . MulticastProcessor ; import org . apache . camel . processor . aggregate . AggregationStrategy ; import org . apache . camel . processor . aggregate . UseLatestAggregationStrategy ; import org . apache . camel . processor . interceptor . StreamCachingInterceptor ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "multicast" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class MulticastType extends OutputType < ProcessorType > { @ XmlAttribute ( required = false ) private Boolean parallelProcessing ; @ XmlAttribute ( required = false ) private String strategyRef ; @ XmlAttribute ( required = false ) private String threadPoolRef ; @ XmlTransient private AggregationStrategy aggregationStrategy ; @ XmlTransient private ThreadPoolExecutor threadPoolExecutor ; @ Override public String toString ( ) { return "Multicast[" + getOutputs ( ) + "]" ; } @ Override public String getShortName ( ) { return "multicast" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { return createOutputsProcessor ( routeContext ) ; } public MulticastType aggregationStrategy ( AggregationStrategy aggregationStrategy ) { setAggregationStrategy ( aggregationStrategy ) ; return this ; } public MulticastType parallelProcessing ( ) { setParallelProcessing ( true ) ; return this ; } public MulticastType parallelProcessing ( boolean parallelProcessing ) { setParallelProcessing ( parallelProcessing ) ; return this ; } public MulticastType executor ( ThreadPoolExecutor executor ) { setThreadPoolExecutor ( executor ) ; return this ; } protected Processor createCompositeProcessor ( RouteContext routeContext , List < Processor > list ) { if ( aggregationStrategy == null && strategyRef != null ) { aggregationStrategy = routeContext . lookup ( strategyRef , AggregationStrategy . class ) ; } if ( aggregationStrategy == null ) { aggregationStrategy = new UseLatestAggregationStrategy ( ) ; } if ( threadPoolRef != null ) { threadPoolExecutor = routeContext . lookup ( threadPoolRef , ThreadPoolExecutor . class ) ; } return new MulticastProcessor ( list , aggregationStrategy , isParallelProcessing ( ) , threadPoolExecutor ) ; } public AggregationStrategy getAggregationStrategy ( ) { return aggregationStrategy ; } public void setAggregationStrategy ( AggregationStrategy aggregationStrategy ) { this . aggregationStrategy = aggregationStrategy ; } public boolean isParallelProcessing ( ) { return parallelProcessing != null ? parallelProcessing : false ; } public void setParallelProcessing ( boolean parallelProcessing ) { this . parallelProcessing = parallelProcessing ; } public ThreadPoolExecutor getThreadPoolExecutor ( ) { return threadPoolExecutor ; } public void setThreadPoolExecutor ( ThreadPoolExecutor executor ) { this . threadPoolExecutor = executor ; } @ Override protected Processor wrapProcessorInInterceptors ( RouteContext routeContext , Processor target ) throws Exception { return super . wrapProcessorInInterceptors ( routeContext , new StreamCachingInterceptor ( target ) ) ; } } 	0	['16', '4', '0', '14', '30', '106', '7', '7', '14', '0.866666667', '142', '1', '1', '0.922680412', '0.241071429', '1', '4', '7.5625', '5', '1.25', '0']
package org . apache . camel . component . irc ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultEndpoint ; import org . schwering . irc . lib . IRCModeParser ; import org . schwering . irc . lib . IRCUser ; public class IrcEndpoint extends DefaultEndpoint < IrcExchange > { private IrcBinding binding ; private IrcConfiguration configuration ; private IrcComponent component ; public IrcEndpoint ( String endpointUri , IrcComponent component , IrcConfiguration configuration ) { super ( endpointUri , component ) ; this . component = component ; this . configuration = configuration ; } public boolean isSingleton ( ) { return true ; } public IrcExchange createExchange ( ExchangePattern pattern ) { return new IrcExchange ( getCamelContext ( ) , pattern , getBinding ( ) ) ; } public IrcExchange createOnPrivmsgExchange ( String target , IRCUser user , String msg ) { return new IrcExchange ( getCamelContext ( ) , getExchangePattern ( ) , getBinding ( ) , new IrcMessage ( "PRIVMSG" , target , user , msg ) ) ; } public IrcExchange createOnNickExchange ( IRCUser user , String newNick ) { return new IrcExchange ( getCamelContext ( ) , getExchangePattern ( ) , getBinding ( ) , new IrcMessage ( "NICK" , user , newNick ) ) ; } public IrcExchange createOnQuitExchange ( IRCUser user , String msg ) { return new IrcExchange ( getCamelContext ( ) , getExchangePattern ( ) , getBinding ( ) , new IrcMessage ( "QUIT" , user , msg ) ) ; } public IrcExchange createOnJoinExchange ( String channel , IRCUser user ) { return new IrcExchange ( getCamelContext ( ) , getExchangePattern ( ) , getBinding ( ) , new IrcMessage ( "JOIN" , channel , user ) ) ; } public IrcExchange createOnKickExchange ( String channel , IRCUser user , String whoWasKickedNick , String msg ) { return new IrcExchange ( getCamelContext ( ) , getExchangePattern ( ) , getBinding ( ) , new IrcMessage ( "KICK" , channel , user , whoWasKickedNick , msg ) ) ; } public IrcExchange createOnModeExchange ( String channel , IRCUser user , IRCModeParser modeParser ) { return new IrcExchange ( getCamelContext ( ) , getExchangePattern ( ) , getBinding ( ) , new IrcMessage ( "MODE" , channel , user , modeParser . getLine ( ) ) ) ; } public IrcExchange createOnPartExchange ( String channel , IRCUser user , String msg ) { return new IrcExchange ( getCamelContext ( ) , getExchangePattern ( ) , getBinding ( ) , new IrcMessage ( "PART" , channel , user , msg ) ) ; } public IrcExchange createOnTopicExchange ( String channel , IRCUser user , String topic ) { return new IrcExchange ( getCamelContext ( ) , getExchangePattern ( ) , getBinding ( ) , new IrcMessage ( "TOPIC" , channel , user , topic ) ) ; } public IrcProducer createProducer ( ) throws Exception { return new IrcProducer ( this , component . getIRCConnection ( configuration ) ) ; } public IrcConsumer createConsumer ( Processor processor ) throws Exception { return new IrcConsumer ( this , processor , component . getIRCConnection ( configuration ) ) ; } public IrcComponent getComponent ( ) { return component ; } public void setComponent ( IrcComponent component ) { this . component = component ; } public IrcBinding getBinding ( ) { if ( binding == null ) { binding = new IrcBinding ( ) ; } return binding ; } public void setBinding ( IrcBinding binding ) { this . binding = binding ; } public IrcConfiguration getConfiguration ( ) { return configuration ; } public void setConfiguration ( IrcConfiguration configuration ) { this . configuration = configuration ; } } 	0	['23', '2', '0', '19', '33', '217', '4', '18', '23', '0.636363636', '247', '1', '3', '0.52173913', '0.241545894', '1', '2', '9.608695652', '2', '1', '0']
package org . apache . camel . component . restlet . converter ; import org . apache . camel . Converter ; import org . restlet . data . MediaType ; import org . restlet . data . Method ; @ Converter public class RestletConverter { @ Converter public Method toMethod ( String name ) { return Method . valueOf ( name . toUpperCase ( ) ) ; } @ Converter public MediaType toMediaType ( String name ) { return MediaType . valueOf ( name ) ; } } 	0	['3', '1', '0', '2', '7', '3', '0', '2', '3', '2', '13', '0', '0', '0', '0.833333333', '0', '0', '3.333333333', '1', '0.6667', '0']
package org . apache . camel . component . event ; import org . apache . camel . Exchange ; import org . apache . camel . NoTypeConversionAvailableException ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . processor . loadbalancer . LoadBalancer ; import org . apache . camel . processor . loadbalancer . TopicLoadBalancer ; import org . apache . camel . util . ObjectHelper ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . context . ApplicationEvent ; import static org . apache . camel . util . ObjectHelper . wrapRuntimeCamelException ; public class EventEndpoint extends DefaultEndpoint < Exchange > implements ApplicationContextAware { private LoadBalancer loadBalancer ; private ApplicationContext applicationContext ; public EventEndpoint ( String endpointUri , EventComponent component ) { super ( endpointUri , component ) ; this . applicationContext = component . getApplicationContext ( ) ; } public EventEndpoint ( String endpointUri ) { super ( endpointUri ) ; } public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { this . applicationContext = applicationContext ; } public ApplicationContext getApplicationContext ( ) { return applicationContext ; } public boolean isSingleton ( ) { return true ; } public Producer < Exchange > createProducer ( ) throws Exception { ObjectHelper . notNull ( getApplicationContext ( ) , "applicationContext" ) ; return new DefaultProducer < Exchange > ( this ) { public void process ( Exchange exchange ) throws Exception { ApplicationEvent event = toApplicationEvent ( exchange ) ; getApplicationContext ( ) . publishEvent ( event ) ; } } ; } public EventConsumer createConsumer ( Processor processor ) throws Exception { return new EventConsumer ( this , processor ) ; } public void onApplicationEvent ( ApplicationEvent event ) { Exchange exchange = createExchange ( ) ; exchange . getIn ( ) . setBody ( event ) ; try { getLoadBalancer ( ) . process ( exchange ) ; } catch ( Exception e ) { throw wrapRuntimeCamelException ( e ) ; } } public LoadBalancer getLoadBalancer ( ) { if ( loadBalancer == null ) { loadBalancer = createLoadBalancer ( ) ; } return loadBalancer ; } public void setLoadBalancer ( LoadBalancer loadBalancer ) { this . loadBalancer = loadBalancer ; } public synchronized void consumerStarted ( EventConsumer consumer ) { getLoadBalancer ( ) . addProcessor ( consumer . getProcessor ( ) ) ; } public synchronized void consumerStopped ( EventConsumer consumer ) { getLoadBalancer ( ) . removeProcessor ( consumer . getProcessor ( ) ) ; } protected LoadBalancer createLoadBalancer ( ) { return new TopicLoadBalancer ( ) ; } protected ApplicationEvent toApplicationEvent ( Exchange exchange ) { try { ApplicationEvent event = exchange . getIn ( ) . getBody ( ApplicationEvent . class ) ; if ( event != null ) { return event ; } } catch ( NoTypeConversionAvailableException ex ) { } return new CamelEvent ( this , exchange ) ; } } 	0	['15', '2', '0', '22', '31', '97', '5', '21', '13', '0.75', '124', '1', '1', '0.648648649', '0.192592593', '0', '0', '7.133333333', '2', '0.9333', '0']
package org . apache . camel . model ; public interface Block { void addOutput ( ProcessorType processorType ) ; } 	0	['1', '1', '0', '9', '1', '0', '9', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . spring ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . Map ; import java . util . Set ; import javax . xml . bind . JAXBException ; import org . apache . camel . CamelContext ; import org . apache . camel . ProducerTemplate ; import org . apache . camel . spring . handler . CamelNamespaceHandler ; import org . apache . camel . util . MainSupport ; import org . apache . camel . view . ModelFileGenerator ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . context . ApplicationContext ; import org . springframework . context . support . AbstractApplicationContext ; import org . springframework . context . support . ClassPathXmlApplicationContext ; import org . springframework . context . support . FileSystemXmlApplicationContext ; public class Main extends MainSupport { private static Main instance ; private String applicationContextUri = "META-INF/spring/*.xml" ; private String fileApplicationContextUri ; private AbstractApplicationContext applicationContext ; private AbstractApplicationContext parentApplicationContext ; private String parentApplicationContextUri ; public Main ( ) { addOption ( new ParameterOption ( "ac" , "applicationContext" , "Sets the classpath based spring ApplicationContext" , "applicationContext" ) { protected void doProcess ( String arg , String parameter , LinkedList < String > remainingArgs ) { setApplicationContextUri ( parameter ) ; } } ) ; addOption ( new ParameterOption ( "fa" , "fileApplicationContext" , "Sets the filesystem based spring ApplicationContext" , "fileApplicationContext" ) { protected void doProcess ( String arg , String parameter , LinkedList < String > remainingArgs ) { setFileApplicationContextUri ( parameter ) ; } } ) ; } private class HangupInterceptor extends Thread { Log log = LogFactory . getLog ( this . getClass ( ) ) ; Main mainInstance ; public HangupInterceptor ( Main main ) { mainInstance = main ; } @ Override public void run ( ) { log . info ( "Recieved hang up - stopping the main instance." ) ; try { mainInstance . stop ( ) ; } catch ( Exception ex ) { log . warn ( ex ) ; } } } public static void main ( String ... args ) { Main main = new Main ( ) ; instance = main ; main . enableHangupSupport ( ) ; main . run ( args ) ; } public static Main getInstance ( ) { return instance ; } public void enableHangupSupport ( ) { HangupInterceptor interceptor = new HangupInterceptor ( this ) ; Runtime . getRuntime ( ) . addShutdownHook ( interceptor ) ; } @ Override public void enableDebug ( ) { super . enableDebug ( ) ; setParentApplicationContextUri ( "/META-INF/services/org/apache/camel/spring/debug.xml" ) ; } @ Override public void enableTrace ( ) { super . enableTrace ( ) ; setParentApplicationContextUri ( "/META-INF/services/org/apache/camel/spring/trace.xml" ) ; } public AbstractApplicationContext getApplicationContext ( ) { return applicationContext ; } public void setApplicationContext ( AbstractApplicationContext applicationContext ) { this . applicationContext = applicationContext ; } public String getApplicationContextUri ( ) { return applicationContextUri ; } public void setApplicationContextUri ( String applicationContextUri ) { this . applicationContextUri = applicationContextUri ; } public String getFileApplicationContextUri ( ) { return fileApplicationContextUri ; } public void setFileApplicationContextUri ( String fileApplicationContextUri ) { this . fileApplicationContextUri = fileApplicationContextUri ; } public AbstractApplicationContext getParentApplicationContext ( ) { if ( parentApplicationContext == null ) { if ( parentApplicationContextUri != null ) { parentApplicationContext = new ClassPathXmlApplicationContext ( parentApplicationContextUri ) ; parentApplicationContext . start ( ) ; } } return parentApplicationContext ; } public void setParentApplicationContext ( AbstractApplicationContext parentApplicationContext ) { this . parentApplicationContext = parentApplicationContext ; } public String getParentApplicationContextUri ( ) { return parentApplicationContextUri ; } public void setParentApplicationContextUri ( String parentApplicationContextUri ) { this . parentApplicationContextUri = parentApplicationContextUri ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; if ( applicationContext == null ) { applicationContext = createDefaultApplicationContext ( ) ; } LOG . debug ( "Starting Spring ApplicationContext: " + applicationContext . getId ( ) ) ; applicationContext . start ( ) ; postProcessContext ( ) ; } protected void doStop ( ) throws Exception { super . doStop ( ) ; if ( applicationContext != null ) { LOG . debug ( "Stopping Spring ApplicationContext: " + applicationContext . getId ( ) ) ; applicationContext . close ( ) ; } } protected ProducerTemplate findOrCreateCamelTemplate ( ) { String [ ] names = getApplicationContext ( ) . getBeanNamesForType ( ProducerTemplate . class ) ; if ( names != null && names . length > 0 ) { return ( ProducerTemplate ) getApplicationContext ( ) . getBean ( names [ 0 ] , ProducerTemplate . class ) ; } for ( CamelContext camelContext : getCamelContexts ( ) ) { return camelContext . createProducerTemplate ( ) ; } throw new IllegalArgumentException ( "No CamelContexts are available so cannot create a ProducerTemplate!" ) ; } protected AbstractApplicationContext createDefaultApplicationContext ( ) { if ( getFileApplicationContextUri ( ) != null ) { String [ ] args = getFileApplicationContextUri ( ) . split ( ";" ) ; ApplicationContext parentContext = getParentApplicationContext ( ) ; if ( parentContext != null ) { return new FileSystemXmlApplicationContext ( args , parentContext ) ; } else { return new FileSystemXmlApplicationContext ( args ) ; } } String [ ] args = getApplicationContextUri ( ) . split ( ";" ) ; ApplicationContext parentContext = getParentApplicationContext ( ) ; if ( parentContext != null ) { return new ClassPathXmlApplicationContext ( args , parentContext ) ; } else { return new ClassPathXmlApplicationContext ( args ) ; } } protected Map < String , CamelContext > getCamelContextMap ( ) { Map < String , SpringCamelContext > map = applicationContext . getBeansOfType ( SpringCamelContext . class ) ; Set < Map . Entry < String , SpringCamelContext > > entries = map . entrySet ( ) ; Map < String , CamelContext > answer = new HashMap < String , CamelContext > ( ) ; for ( Map . Entry < String , SpringCamelContext > entry : entries ) { String name = entry . getKey ( ) ; CamelContext camelContext = entry . getValue ( ) ; answer . put ( name , camelContext ) ; } return answer ; } protected ModelFileGenerator createModelFileGenerator ( ) throws JAXBException { return new ModelFileGenerator ( new CamelNamespaceHandler ( ) . getJaxbContext ( ) ) ; } } 	0	['22', '3', '1', '15', '66', '193', '4', '14', '16', '0.849206349', '318', '1', '1', '0.716216216', '0.295454545', '1', '3', '13.18181818', '4', '1.3636', '0']
package org . apache . camel . language . jxpath ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . spi . Language ; public class JXPathLanguage implements Language { public Expression < Exchange > createExpression ( String expression ) { return new JXPathExpression ( expression , Object . class ) ; } public Predicate < Exchange > createPredicate ( String predicate ) { return new JXPathExpression ( predicate , Boolean . class ) ; } } 	0	['3', '1', '0', '4', '5', '3', '0', '4', '3', '2', '18', '0', '0', '0', '0.833333333', '0', '0', '5', '1', '0.6667', '0']
package org . apache . camel . component . ibatis ; import java . util . Iterator ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . util . ObjectHelper ; public class IBatisProducer extends DefaultProducer { private final IBatisEndpoint endpoint ; public IBatisProducer ( IBatisEndpoint endpoint ) { super ( endpoint ) ; this . endpoint = endpoint ; } @ Override public IBatisEndpoint getEndpoint ( ) { return ( IBatisEndpoint ) super . getEndpoint ( ) ; } public void process ( Exchange exchange ) throws Exception { Object body = exchange . getIn ( ) . getBody ( ) ; if ( body == null ) { endpoint . query ( exchange . getOut ( true ) ) ; } else { String operation = getOperationName ( exchange ) ; Iterator iter = ObjectHelper . createIterator ( body ) ; while ( iter . hasNext ( ) ) { endpoint . getSqlClient ( ) . insert ( operation , iter . next ( ) ) ; } } } protected String getOperationName ( Exchange exchange ) { return endpoint . getEntityName ( ) ; } } 	0	['5', '3', '0', '7', '16', '4', '1', '7', '4', '0.5', '57', '1', '1', '0.84', '0.533333333', '0', '0', '10.2', '1', '0.8', '0']
package org . apache . camel . component . spring . integration ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Message ; import org . apache . camel . impl . DefaultExchange ; public class SpringIntegrationExchange extends DefaultExchange { public SpringIntegrationExchange ( CamelContext context ) { super ( context ) ; } public SpringIntegrationExchange ( CamelContext context , ExchangePattern pattern ) { super ( context , pattern ) ; } @ Override public Exchange newInstance ( ) { return new SpringIntegrationExchange ( this . getContext ( ) ) ; } @ Override public SpringIntegrationMessage getIn ( ) { return ( SpringIntegrationMessage ) super . getIn ( ) ; } @ Override public SpringIntegrationMessage getOut ( ) { return ( SpringIntegrationMessage ) super . getOut ( ) ; } @ Override public SpringIntegrationMessage getOut ( boolean lazyCreate ) { return ( SpringIntegrationMessage ) super . getOut ( lazyCreate ) ; } @ Override public SpringIntegrationMessage getFault ( ) { return ( SpringIntegrationMessage ) super . getFault ( ) ; } @ Override protected Message createFaultMessage ( ) { return new SpringIntegrationMessage ( ) ; } @ Override protected Message createInMessage ( ) { return new SpringIntegrationMessage ( ) ; } @ Override protected Message createOutMessage ( ) { return new SpringIntegrationMessage ( ) ; } } 	0	['14', '2', '0', '9', '18', '91', '4', '6', '11', '2', '71', '0', '0', '0.76', '0.339285714', '1', '3', '4.071428571', '1', '0.8571', '0']
package org . apache . camel . model . dataformat ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; @ XmlRootElement ( name = "artixDS" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ArtixDSDataFormat extends DataFormatType { private static final transient Log LOG = LogFactory . getLog ( ArtixDSDataFormat . class ) ; @ XmlAttribute ( required = false ) private String elementTypeName ; @ XmlAttribute ( required = false ) private String format ; @ XmlAttribute ( required = false ) private Class < ? > elementType ; @ XmlAttribute ( required = false ) private ArtixDSContentType contentType ; public ArtixDSDataFormat ( ) { super ( "org.apache.camel.artix.ds.ArtixDSFormat" ) ; } public ArtixDSDataFormat ( Class < ? > elementType ) { this ( ) ; this . elementType = elementType ; } public ArtixDSDataFormat ( Class < ? > elementType , ArtixDSContentType contentType ) { this ( ) ; this . elementType = elementType ; this . contentType = contentType ; } public ArtixDSDataFormat ( ArtixDSContentType contentType ) { this ( ) ; this . contentType = contentType ; } public String getElementTypeName ( ) { return elementTypeName ; } public void setElementTypeName ( String elementTypeName ) { this . elementTypeName = elementTypeName ; } public ArtixDSContentType getContentType ( ) { return contentType ; } public void setContentType ( ArtixDSContentType contentType ) { this . contentType = contentType ; } public Class < ? > getElementType ( ) { if ( elementType == null ) { if ( elementTypeName != null ) { elementType = ObjectHelper . loadClass ( elementTypeName , getClass ( ) . getClassLoader ( ) ) ; if ( elementType == null ) { throw new IllegalArgumentException ( "The ArtixDS Element class " + elementTypeName + " is not on the classpath! Cannot use the dataFormat " + this ) ; } } } return elementType ; } public void setElementType ( Class < ? > elementType ) { this . elementType = elementType ; } public String getFormat ( ) { return format ; } public void setFormat ( String format ) { this . format = format ; } @ Override protected void configureDataFormat ( DataFormat dataFormat ) { Class < ? > type = getElementType ( ) ; if ( type != null ) { setProperty ( dataFormat , "elementType" , type ) ; } ArtixDSContentType content = getContentType ( ) ; if ( content != null ) { setProperty ( dataFormat , "contentType" , content ) ; } } } 	0	['14', '3', '0', '7', '25', '59', '1', '6', '12', '0.815384615', '131', '1', '1', '0.5', '0.338461538', '1', '2', '8', '4', '1', '0']
package org . apache . camel . component . http ; import java . io . BufferedReader ; import java . io . IOException ; import javax . servlet . ServletInputStream ; import javax . servlet . http . HttpServletRequest ; import org . apache . camel . Converter ; @ Converter public class HttpConverter { @ Converter public HttpServletRequest toServletRequest ( HttpMessage message ) { if ( message == null ) { return null ; } return message . getRequest ( ) ; } @ Converter public ServletInputStream toServletInputStream ( HttpMessage message ) throws IOException { HttpServletRequest request = toServletRequest ( message ) ; if ( request != null ) { return request . getInputStream ( ) ; } return null ; } @ Converter public BufferedReader toReader ( HttpMessage message ) throws IOException { HttpServletRequest request = toServletRequest ( message ) ; if ( request != null ) { return request . getReader ( ) ; } return null ; } } 	0	['4', '1', '0', '1', '8', '6', '0', '1', '4', '2', '36', '0', '0', '0', '0.875', '0', '0', '8', '2', '1', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlID ; import javax . xml . bind . annotation . XmlType ; import javax . xml . bind . annotation . adapters . CollapsedStringAdapter ; import javax . xml . bind . annotation . adapters . XmlJavaTypeAdapter ; @ XmlType ( name = "identifiedType" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public abstract class IdentifiedType { @ XmlAttribute @ XmlJavaTypeAdapter ( CollapsedStringAdapter . class ) @ XmlID private String id ; public String getId ( ) { return id ; } public void setId ( String value ) { this . id = value ; } } 	0	['3', '1', '9', '9', '4', '1', '9', '0', '3', '0.5', '14', '1', '0', '0', '0.666666667', '0', '0', '3.333333333', '1', '0.6667', '0']
package org . apache . camel . component . event ; import java . util . Map ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultComponent ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . context . ConfigurableApplicationContext ; public class EventComponent extends DefaultComponent < Exchange > implements ApplicationContextAware { private ApplicationContext applicationContext ; public EventComponent ( ) { } public EventComponent ( ApplicationContext applicationContext ) { setApplicationContext ( applicationContext ) ; } public ApplicationContext getApplicationContext ( ) { return applicationContext ; } public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { this . applicationContext = applicationContext ; } public ConfigurableApplicationContext getConfigurableApplicationContext ( ) { ApplicationContext applicationContext = getApplicationContext ( ) ; if ( applicationContext instanceof ConfigurableApplicationContext ) { return ( ConfigurableApplicationContext ) applicationContext ; } else { throw new IllegalArgumentException ( "Not created with a ConfigurableApplicationContext! Was: " + applicationContext ) ; } } protected EventEndpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { EventEndpoint answer = new EventEndpoint ( uri , this ) ; return answer ; } } 	0	['7', '3', '0', '8', '13', '19', '2', '7', '5', '0.5', '59', '1', '0', '0.875', '0.464285714', '1', '1', '7.285714286', '2', '0.8571', '0']
package org . apache . camel . component . jpa ; import javax . persistence . EntityManager ; import javax . persistence . Query ; public interface QueryFactory { Query createQuery ( EntityManager entityManager ) ; } 	0	['1', '1', '0', '3', '1', '0', '3', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . processor . resequencer ; class ElementComparator < E > implements SequenceElementComparator < Element < E > > { private SequenceElementComparator < E > comparator ; public ElementComparator ( SequenceElementComparator < E > comparator ) { this . comparator = comparator ; } public boolean predecessor ( Element < E > o1 , Element < E > o2 ) { return comparator . predecessor ( o1 . getObject ( ) , o2 . getObject ( ) ) ; } public boolean successor ( Element < E > o1 , Element < E > o2 ) { return comparator . successor ( o1 . getObject ( ) , o2 . getObject ( ) ) ; } public int compare ( Element < E > o1 , Element < E > o2 ) { return comparator . compare ( o1 . getObject ( ) , o2 . getObject ( ) ) ; } } 	0	['7', '1', '0', '3', '12', '9', '1', '2', '7', '0', '59', '1', '1', '0', '0.5', '0', '0', '7.285714286', '1', '0.8571', '0']
package org . apache . camel . component . cxf . interceptors ; import java . util . ArrayList ; import java . util . List ; import java . util . ResourceBundle ; import java . util . logging . Level ; import java . util . logging . Logger ; import javax . wsdl . Definition ; import javax . xml . namespace . QName ; import org . w3c . dom . Element ; import org . apache . cxf . binding . soap . SoapMessage ; import org . apache . cxf . binding . soap . SoapVersion ; import org . apache . cxf . binding . soap . model . SoapBindingInfo ; import org . apache . cxf . binding . soap . model . SoapHeaderInfo ; import org . apache . cxf . common . i18n . BundleUtils ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . endpoint . Endpoint ; import org . apache . cxf . interceptor . Fault ; import org . apache . cxf . message . Exchange ; import org . apache . cxf . phase . Phase ; import org . apache . cxf . service . model . BindingInfo ; import org . apache . cxf . service . model . BindingMessageInfo ; import org . apache . cxf . service . model . MessagePartInfo ; import org . apache . cxf . service . model . OperationInfo ; import org . apache . cxf . wsdl11 . WSDLServiceBuilder ; public class SoapMessageOutInterceptor extends AbstractMessageOutInterceptor < SoapMessage > { private static final Logger LOG = LogUtils . getL7dLogger ( SoapMessageInInterceptor . class ) ; public SoapMessageOutInterceptor ( ) { super ( Phase . PREPARE_SEND ) ; addAfter ( DOMOutInterceptor . class . getName ( ) ) ; } protected Logger getLogger ( ) { return LOG ; } @ SuppressWarnings ( "unchecked" ) public void handleMessage ( SoapMessage message ) throws Fault { List < Element > payload = message . get ( List . class ) ; Exchange exchange = message . getExchange ( ) ; BindingMessageInfo bmi = exchange . get ( BindingMessageInfo . class ) ; if ( LOG . isLoggable ( Level . INFO ) ) { LOG . info ( "SoapMessageOutInterceptor binding operation style processing." ) ; } SoapBindingInfo soapBinding = ( SoapBindingInfo ) exchange . get ( BindingInfo . class ) ; String style = soapBinding . getStyle ( bmi . getBindingOperation ( ) . getOperationInfo ( ) ) ; if ( "rpc" . equals ( style ) ) { OperationInfo oi = bmi . getBindingOperation ( ) . getOperationInfo ( ) ; Endpoint ep = exchange . get ( Endpoint . class ) ; Definition def = ep . getService ( ) . getServiceInfos ( ) . get ( 0 ) . getProperty ( WSDLServiceBuilder . WSDL_DEFINITION , Definition . class ) ; String prefix = def . getPrefix ( oi . getName ( ) . getNamespaceURI ( ) ) ; if ( "" . equals ( prefix ) ) { prefix = "tns" ; } QName opName = null ; boolean isClient = isRequestor ( message ) ; if ( isClient ) { opName = new QName ( oi . getName ( ) . getNamespaceURI ( ) , oi . getName ( ) . getLocalPart ( ) , prefix ) ; } else { opName = new QName ( oi . getName ( ) . getNamespaceURI ( ) , oi . getName ( ) . getLocalPart ( ) + "Response" , prefix ) ; } Element opEl = createElement ( opName , payload ) ; payload = new ArrayList < Element > ( ) ; payload . add ( opEl ) ; } message . put ( List . class , payload ) ; } } 	0	['5', '1', '0', '15', '35', '4', '1', '14', '3', '0.25', '148', '1', '0', '0.5', '0.5', '0', '0', '28.4', '1', '0.6', '0']
package org . apache . camel . language . juel ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import org . apache . camel . language . LanguageAnnotation ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . PARAMETER } ) @ LanguageAnnotation ( language = "el" ) public @ interface EL { String value ( ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . processor . loadbalancer ; import java . util . List ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Processor ; public interface LoadBalancer extends AsyncProcessor { void addProcessor ( Processor processor ) ; void removeProcessor ( Processor processor ) ; List < Processor > getProcessors ( ) ; } 	0	['3', '1', '0', '13', '3', '3', '11', '2', '3', '2', '3', '0', '0', '0', '0.833333333', '0', '0', '0', '1', '1', '0']
package org . apache . camel ; import org . apache . camel . spi . HeaderFilterStrategy ; public interface HeaderFilterStrategyAware { HeaderFilterStrategy getHeaderFilterStrategy ( ) ; void setHeaderFilterStrategy ( HeaderFilterStrategy strategy ) ; } 	0	['2', '1', '0', '12', '2', '1', '11', '1', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . camel . spring . remoting ; import org . apache . camel . CamelContext ; import org . apache . camel . CamelContextAware ; import org . apache . camel . Endpoint ; import org . apache . camel . Producer ; import org . apache . camel . component . bean . ProxyHelper ; import org . springframework . beans . factory . DisposableBean ; import org . springframework . beans . factory . FactoryBean ; import org . springframework . remoting . support . UrlBasedRemoteAccessor ; public class CamelProxyFactoryBean extends UrlBasedRemoteAccessor implements FactoryBean , CamelContextAware , DisposableBean { private CamelContext camelContext ; private Endpoint endpoint ; private Object serviceProxy ; private Producer producer ; @ Override public void afterPropertiesSet ( ) { super . afterPropertiesSet ( ) ; try { if ( endpoint == null ) { if ( getServiceUrl ( ) == null || camelContext == null ) { throw new IllegalArgumentException ( "If endpoint is not specified, the serviceUrl and camelContext must be specified." ) ; } endpoint = camelContext . getEndpoint ( getServiceUrl ( ) ) ; if ( endpoint == null ) { throw new IllegalArgumentException ( "Could not resolve endpoint: " + getServiceUrl ( ) ) ; } } this . producer = endpoint . createProducer ( ) ; this . producer . start ( ) ; this . serviceProxy = ProxyHelper . createProxy ( endpoint , producer , getServiceInterface ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( e ) ; } } public void destroy ( ) throws Exception { this . producer . stop ( ) ; this . producer = null ; this . serviceProxy = null ; } public Class getServiceInterface ( ) { return super . getServiceInterface ( ) ; } public String getServiceUrl ( ) { return super . getServiceUrl ( ) ; } public Object getObject ( ) throws Exception { return serviceProxy ; } public Class getObjectType ( ) { return getServiceInterface ( ) ; } public boolean isSingleton ( ) { return true ; } public Endpoint getEndpoint ( ) { return endpoint ; } public void setEndpoint ( Endpoint endpoint ) { this . endpoint = endpoint ; } public CamelContext getCamelContext ( ) { return camelContext ; } public void setCamelContext ( CamelContext camelContext ) { this . camelContext = camelContext ; } } 	0	['12', '0', '0', '8', '26', '48', '0', '8', '12', '0.840909091', '126', '1', '3', '0', '0.388888889', '0', '0', '9.166666667', '5', '1.25', '0']
package org . apache . camel . language . groovy ; import groovy . lang . GroovyClassLoader ; import groovy . lang . Script ; import org . apache . camel . spi . Language ; public class GroovyLanguage implements Language { public static GroovyExpression groovy ( String expression ) { return new GroovyLanguage ( ) . createExpression ( expression ) ; } public GroovyExpression createPredicate ( String expression ) { return createExpression ( expression ) ; } public GroovyExpression createExpression ( String expression ) { Class < Script > scriptType = parseExpression ( expression ) ; return new GroovyExpression ( scriptType , expression ) ; } protected Class < Script > parseExpression ( String expression ) { return new GroovyClassLoader ( ) . parseClass ( expression ) ; } } 	0	['7', '1', '0', '5', '9', '21', '0', '5', '6', '2', '44', '0', '0', '0', '0.857142857', '0', '0', '5.285714286', '1', '0.8571', '0']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "el" ) public class ELExpression extends ExpressionType { public ELExpression ( ) { } public ELExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "el" ; } } 	0	['3', '2', '0', '1', '5', '3', '0', '1', '3', '2', '12', '0', '0', '0.956521739', '0.666666667', '1', '2', '3', '1', '0.3333', '0']
package org . apache . camel ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . METHOD } ) @ Pattern ( ExchangePattern . InOut ) public @ interface InOut { } 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . component . bean ; import org . apache . camel . CamelException ; public class NoBeanAvailableException extends CamelException { private final String name ; public NoBeanAvailableException ( String name ) { super ( "No bean available for endpoint: " + name ) ; this . name = name ; } public String getName ( ) { return name ; } } 	0	['2', '4', '0', '2', '6', '0', '1', '1', '2', '0', '20', '1', '0', '0.944444444', '0.75', '0', '0', '8.5', '1', '0.5', '0']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . spi . RouteContext ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; @ XmlRootElement ( name = "xquery" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class XQueryExpression extends NamespaceAwareExpression { private static final transient Log LOG = LogFactory . getLog ( XQueryExpression . class ) ; @ XmlAttribute ( required = false ) private String type ; @ XmlTransient private Class resultType ; public XQueryExpression ( ) { } public XQueryExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "xquery" ; } public String getType ( ) { return type ; } public void setType ( String type ) { this . type = type ; } public Class getResultType ( ) { return resultType ; } public void setResultType ( Class resultType ) { this . resultType = resultType ; } @ Override protected void configureExpression ( RouteContext routeContext , Expression expression ) { super . configureExpression ( routeContext , expression ) ; updateResultType ( ) ; if ( resultType != null ) { setProperty ( expression , "resultType" , resultType ) ; } } @ Override protected void configurePredicate ( RouteContext routeContext , Predicate predicate ) { super . configurePredicate ( routeContext , predicate ) ; updateResultType ( ) ; if ( resultType != null ) { setProperty ( predicate , "resultType" , resultType ) ; } } private void updateResultType ( ) { if ( resultType == null && type != null ) { try { resultType = Class . forName ( type ) ; } catch ( ClassNotFoundException e ) { LOG . error ( "ClassNotFoundException creating class: " + type ) ; } } } } 	0	['11', '3', '0', '8', '22', '27', '2', '6', '7', '0.633333333', '98', '1', '0', '0.771428571', '0.283333333', '1', '4', '7.636363636', '3', '1.0909', '0']
package org . apache . camel . component . test ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . Component ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Service ; import org . apache . camel . component . mock . MockEndpoint ; import org . apache . camel . util . EndpointHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class TestEndpoint extends MockEndpoint implements Service { private static final transient Log LOG = LogFactory . getLog ( TestEndpoint . class ) ; private final Endpoint expectedMessageEndpoint ; private long timeout = 2000L ; public TestEndpoint ( String endpointUri , Component component , Endpoint expectedMessageEndpoint ) { super ( endpointUri , component ) ; this . expectedMessageEndpoint = expectedMessageEndpoint ; } public TestEndpoint ( String endpointUri , Endpoint expectedMessageEndpoint ) { super ( endpointUri ) ; this . expectedMessageEndpoint = expectedMessageEndpoint ; } public void start ( ) throws Exception { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Consuming expected messages from: " + expectedMessageEndpoint ) ; } final List expectedBodies = new ArrayList ( ) ; EndpointHelper . pollEndpoint ( expectedMessageEndpoint , new Processor ( ) { public void process ( Exchange exchange ) throws Exception { Object body = getInBody ( exchange ) ; expectedBodies . add ( body ) ; } } , timeout ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Received: " + expectedBodies . size ( ) + " expected message(s) from: " + expectedMessageEndpoint ) ; } expectedBodiesReceived ( expectedBodies ) ; } public void stop ( ) throws Exception { } protected Object getInBody ( Exchange exchange ) { return exchange . getIn ( ) . getBody ( ) ; } } 	0	['6', '3', '0', '12', '23', '7', '2', '11', '4', '0.666666667', '90', '1', '1', '0.967032967', '0.44', '0', '0', '13.5', '1', '0.5', '0']
package org . apache . camel . language . juel ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . List ; import javax . el . BeanELResolver ; import javax . el . ELContext ; import javax . el . PropertyNotFoundException ; public class BeanAndMethodELResolver extends BeanELResolver { public BeanAndMethodELResolver ( ) { super ( false ) ; } @ Override public Object getValue ( ELContext elContext , Object base , Object property ) { try { return super . getValue ( elContext , base , property ) ; } catch ( PropertyNotFoundException e ) { Method method = findMethod ( elContext , base , property ) ; if ( method != null ) { elContext . setPropertyResolved ( true ) ; return method ; } else { throw e ; } } } protected Method findMethod ( ELContext elContext , Object base , Object property ) { if ( base != null && property instanceof String ) { Method [ ] methods = base . getClass ( ) . getMethods ( ) ; List < Method > matching = new ArrayList < Method > ( ) ; for ( Method method : methods ) { if ( method . getName ( ) . equals ( property ) && Modifier . isPublic ( method . getModifiers ( ) ) ) { matching . add ( method ) ; } } int size = matching . size ( ) ; if ( size > 0 ) { if ( size > 1 ) { for ( Method method : matching ) { Class < ? > [ ] paramTypes = method . getParameterTypes ( ) ; if ( paramTypes . length == 1 ) { return method ; } } } return matching . get ( 0 ) ; } } return null ; } } 	0	['3', '0', '0', '1', '20', '3', '1', '0', '2', '2', '106', '0', '0', '0', '0.777777778', '0', '0', '34.33333333', '9', '3.6667', '0']
package org . apache . camel . component . jhc ; import java . util . HashMap ; import java . util . Map ; import org . apache . http . params . HttpParams ; public final class JhcServerEngineFactory { private static Map < Integer , JhcServerEngine > portMap = new HashMap < Integer , JhcServerEngine > ( ) ; private JhcServerEngineFactory ( ) { } public static synchronized JhcServerEngine getJhcServerEngine ( final HttpParams params , final int port , final String protocol ) { JhcServerEngine engine = portMap . get ( port ) ; if ( engine == null ) { engine = new JhcServerEngine ( params , port , protocol . trim ( ) ) ; portMap . put ( port , engine ) ; } else { if ( ! engine . getProtocol ( ) . equals ( protocol . trim ( ) ) ) { throw new IllegalArgumentException ( "Jhc protocol error, the engine's protocol is " + engine . getProtocol ( ) + " you want is " + protocol ) ; } } return engine ; } } 	0	['3', '1', '0', '3', '16', '1', '1', '2', '1', '0.5', '60', '1', '0', '0', '0.5', '0', '0', '18.66666667', '3', '1', '0']
package org . apache . camel . converter . jaxp ; import java . io . ByteArrayInputStream ; import java . io . Externalizable ; import java . io . IOException ; import java . io . InputStream ; import java . io . ObjectInput ; import java . io . ObjectOutput ; import java . io . Reader ; import java . io . StringReader ; import java . io . UnsupportedEncodingException ; import javax . xml . transform . stream . StreamSource ; import org . apache . camel . util . ObjectHelper ; public class StringSource extends StreamSource implements Externalizable { private String text ; private String encoding = "UTF-8" ; public StringSource ( ) { } public StringSource ( String text ) { ObjectHelper . notNull ( text , "text" ) ; this . text = text ; } public StringSource ( String text , String systemId ) { this ( text ) ; ObjectHelper . notNull ( systemId , "systemId" ) ; setSystemId ( systemId ) ; } public StringSource ( String text , String systemId , String encoding ) { this ( text , systemId ) ; ObjectHelper . notNull ( encoding , "encoding" ) ; this . encoding = encoding ; } public InputStream getInputStream ( ) { try { return new ByteArrayInputStream ( text . getBytes ( encoding ) ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } public Reader getReader ( ) { return new StringReader ( text ) ; } public String toString ( ) { return "StringSource[" + text + "]" ; } public String getText ( ) { return text ; } public String getEncoding ( ) { return encoding ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public void setText ( String text ) { this . text = text ; } public void writeExternal ( ObjectOutput out ) throws IOException { int b = ( text != null ? 0x01 : 0x00 ) + ( encoding != null ? 0x02 : 0x00 ) + ( getPublicId ( ) != null ? 0x04 : 0x00 ) + ( getSystemId ( ) != null ? 0x08 : 0x00 ) ; out . writeByte ( b ) ; if ( ( b & 0x01 ) != 0 ) { out . writeUTF ( text ) ; } if ( ( b & 0x02 ) != 0 ) { out . writeUTF ( encoding ) ; } if ( ( b & 0x04 ) != 0 ) { out . writeUTF ( getPublicId ( ) ) ; } if ( ( b & 0x08 ) != 0 ) { out . writeUTF ( getSystemId ( ) ) ; } } public void readExternal ( ObjectInput in ) throws IOException , ClassNotFoundException { int b = in . readByte ( ) ; if ( ( b & 0x01 ) != 0 ) { text = in . readUTF ( ) ; } if ( ( b & 0x02 ) != 0 ) { encoding = in . readUTF ( ) ; } if ( ( b & 0x04 ) != 0 ) { setPublicId ( in . readUTF ( ) ) ; } if ( ( b & 0x08 ) != 0 ) { setSystemId ( in . readUTF ( ) ) ; } } } 	0	['13', '2', '1', '6', '30', '0', '5', '1', '13', '0.291666667', '201', '1', '0', '0.5', '0.384615385', '0', '0', '14.30769231', '1', '0.6923', '0']
package org . apache . camel . model ; import java . util . Collections ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Endpoint ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Processor ; import org . apache . camel . processor . SendProcessor ; import org . apache . camel . spi . RouteContext ; import org . apache . camel . util . ObjectHelper ; @ XmlAccessorType ( XmlAccessType . FIELD ) public class SendType < Type extends ProcessorType > extends ProcessorType < Type > { @ XmlAttribute ( required = false ) private String uri ; @ XmlAttribute ( required = false ) private String ref ; @ XmlTransient private Endpoint endpoint ; @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { Endpoint endpoint = resolveEndpoint ( routeContext ) ; return new SendProcessor ( endpoint , getPattern ( ) ) ; } public Endpoint resolveEndpoint ( RouteContext context ) { if ( endpoint == null ) { endpoint = context . resolveEndpoint ( getUri ( ) , getRef ( ) ) ; } return endpoint ; } public String getRef ( ) { return ref ; } public void setRef ( String ref ) { this . ref = ref ; } public String getUri ( ) { return uri ; } public void setUri ( String uri ) { this . uri = uri ; } public Endpoint getEndpoint ( ) { return endpoint ; } public void setEndpoint ( Endpoint endpoint ) { this . endpoint = endpoint ; } public ExchangePattern getPattern ( ) { return null ; } public List < ProcessorType < ? > > getOutputs ( ) { return Collections . EMPTY_LIST ; } public Object getUriOrRef ( ) { String uri = getUri ( ) ; if ( ObjectHelper . isEmpty ( uri ) ) { return uri ; } else if ( endpoint != null ) { return endpoint . getEndpointUri ( ) ; } return getRef ( ) ; } @ Override public String getLabel ( ) { return FromType . description ( getUri ( ) , getRef ( ) , getEndpoint ( ) ) ; } } 	0	['13', '3', '3', '11', '19', '62', '3', '8', '13', '0.638888889', '95', '1', '1', '0.936170213', '0.346153846', '1', '3', '6.076923077', '3', '1.1538', '0']
package org . apache . camel . builder . script ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . spi . Language ; public class ScriptLanguage implements Language { private final String language ; public ScriptLanguage ( String language ) { this . language = language ; } public Predicate < Exchange > createPredicate ( String expression ) { return new ScriptBuilder ( language , expression ) ; } public Expression < Exchange > createExpression ( String expression ) { return new ScriptBuilder ( language , expression ) ; } } 	0	['3', '1', '0', '5', '5', '0', '1', '4', '3', '0', '24', '1', '0', '0', '1', '0', '0', '6.666666667', '1', '0.6667', '0']
package org . apache . camel . component . http ; import java . net . URI ; import java . net . URISyntaxException ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . apache . camel . ExchangePattern ; import org . apache . camel . PollingConsumer ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultPollingEndpoint ; import org . apache . camel . spi . HeaderFilterStrategy ; import org . apache . commons . httpclient . HttpClient ; import org . apache . commons . httpclient . HttpConnectionManager ; import org . apache . commons . httpclient . params . HttpClientParams ; public class HttpEndpoint extends DefaultPollingEndpoint < HttpExchange > { private HttpBinding binding ; private HttpComponent component ; private URI httpUri ; private HttpClientParams clientParams ; private HttpClientConfigurer httpClientConfigurer ; private HttpConnectionManager httpConnectionManager ; public HttpEndpoint ( String endPointURI , HttpComponent component , URI httpURI , HttpConnectionManager httpConnectionManager ) throws URISyntaxException { this ( endPointURI , component , httpURI , new HttpClientParams ( ) , httpConnectionManager , null ) ; } public HttpEndpoint ( String endPointURI , HttpComponent component , URI httpURI , HttpClientParams clientParams , HttpConnectionManager httpConnectionManager , HttpClientConfigurer clientConfigurer ) throws URISyntaxException { super ( endPointURI , component ) ; this . component = component ; this . httpUri = httpURI ; this . clientParams = clientParams ; this . httpClientConfigurer = clientConfigurer ; this . httpConnectionManager = httpConnectionManager ; } public Producer < HttpExchange > createProducer ( ) throws Exception { return new HttpProducer ( this ) ; } @ Override public PollingConsumer < HttpExchange > createPollingConsumer ( ) throws Exception { return new HttpPollingConsumer ( this ) ; } public HttpExchange createExchange ( ExchangePattern pattern ) { return new HttpExchange ( this , pattern ) ; } public HttpExchange createExchange ( HttpServletRequest request , HttpServletResponse response ) { return new HttpExchange ( this , request , response ) ; } public HttpClient createHttpClient ( ) { HttpClient answer = new HttpClient ( getClientParams ( ) ) ; answer . setHttpConnectionManager ( httpConnectionManager ) ; HttpClientConfigurer configurer = getHttpClientConfigurer ( ) ; if ( configurer != null ) { configurer . configureHttpClient ( answer ) ; } return answer ; } public void connect ( HttpConsumer consumer ) throws Exception { component . connect ( consumer ) ; } public void disconnect ( HttpConsumer consumer ) throws Exception { component . disconnect ( consumer ) ; } @ Override public boolean isLenientProperties ( ) { return true ; } public HttpClientParams getClientParams ( ) { return clientParams ; } public void setClientParams ( HttpClientParams clientParams ) { this . clientParams = clientParams ; } public HttpClientConfigurer getHttpClientConfigurer ( ) { return httpClientConfigurer ; } public void setHttpClientConfigurer ( HttpClientConfigurer httpClientConfigurer ) { this . httpClientConfigurer = httpClientConfigurer ; } public HttpBinding getBinding ( ) { if ( binding == null ) { binding = new DefaultHttpBinding ( getHeaderFilterStrategy ( ) ) ; } return binding ; } public HeaderFilterStrategy getHeaderFilterStrategy ( ) { return component . getHeaderFilterStrategy ( ) ; } public void setBinding ( HttpBinding binding ) { this . binding = binding ; } public boolean isSingleton ( ) { return true ; } public String getPath ( ) { return httpUri . getPath ( ) ; } public int getPort ( ) { if ( httpUri . getPort ( ) == - 1 ) { if ( "https" . equals ( getProtocol ( ) ) ) { return 443 ; } else { return 80 ; } } return httpUri . getPort ( ) ; } public String getProtocol ( ) { return httpUri . getScheme ( ) ; } public URI getHttpUri ( ) { return httpUri ; } } 	0	['23', '4', '1', '23', '39', '205', '10', '18', '23', '0.840909091', '185', '1', '3', '0.58', '0.152173913', '1', '1', '6.782608696', '3', '1.087', '0']
package org . apache . camel . component . http ; import java . io . IOException ; import java . util . concurrent . ConcurrentHashMap ; import javax . servlet . ServletException ; import javax . servlet . http . HttpServlet ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; public class CamelServlet extends HttpServlet { private ConcurrentHashMap < String , HttpConsumer > consumers = new ConcurrentHashMap < String , HttpConsumer > ( ) ; public CamelServlet ( ) { } @ Override protected void service ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { try { HttpConsumer consumer = resolve ( request ) ; if ( consumer == null ) { response . sendError ( HttpServletResponse . SC_NOT_FOUND ) ; return ; } HttpExchange exchange = new HttpExchange ( consumer . getEndpoint ( ) , request , response ) ; consumer . getProcessor ( ) . process ( exchange ) ; consumer . getBinding ( ) . writeResponse ( exchange , response ) ; } catch ( Exception e ) { throw new ServletException ( e ) ; } } protected HttpConsumer resolve ( HttpServletRequest request ) { String path = request . getPathInfo ( ) ; return consumers . get ( path ) ; } public void connect ( HttpConsumer consumer ) { consumers . put ( consumer . getPath ( ) , consumer ) ; } public void disconnect ( HttpConsumer consumer ) { consumers . remove ( consumer . getPath ( ) ) ; } } 	0	['5', '0', '1', '9', '20', '0', '3', '6', '3', '0', '73', '1', '0', '0', '0.5', '0', '0', '13.4', '1', '0.8', '0']
package org . apache . camel . model . config ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . processor . Resequencer ; @ XmlRootElement @ XmlAccessorType ( XmlAccessType . FIELD ) public class BatchResequencerConfig { @ XmlAttribute private Integer batchSize ; @ XmlAttribute private Long batchTimeout ; public BatchResequencerConfig ( ) { this ( 100 , 1000L ) ; } public BatchResequencerConfig ( int batchSize , long batchTimeout ) { this . batchSize = batchSize ; this . batchTimeout = batchTimeout ; } public static BatchResequencerConfig getDefault ( ) { return new BatchResequencerConfig ( ) ; } public int getBatchSize ( ) { return batchSize ; } public void setBatchSize ( int batchSize ) { this . batchSize = batchSize ; } public long getBatchTimeout ( ) { return batchTimeout ; } public void setBatchTimeout ( long batchTimeout ) { this . batchTimeout = batchTimeout ; } } 	0	['7', '1', '0', '2', '12', '9', '2', '0', '7', '0.333333333', '47', '1', '0', '0', '0.476190476', '0', '0', '5.428571429', '1', '0.7143', '0']
package org . apache . camel . processor . resequencer ; public interface SequenceSender < E > { void sendElement ( E o ) throws Exception ; } 	0	['1', '1', '0', '2', '1', '0', '2', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . language ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . PARAMETER } ) @ LanguageAnnotation ( language = "bean" ) public @ interface Bean { String value ( ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel ; public class InvalidTypeException extends CamelExchangeException { private final Object value ; private final Class < ? > type ; public InvalidTypeException ( Exchange exchange , Object value , Class < ? > type ) { super ( "Could not convert value: " + value + " to type: " + type . getName ( ) + NoSuchPropertyException . valueDescription ( value ) , exchange ) ; this . value = value ; this . type = type ; } public Object getValue ( ) { return value ; } public Class < ? > getType ( ) { return type ; } } 	0	['3', '5', '0', '4', '10', '0', '1', '3', '3', '0.5', '37', '1', '0', '0.904761905', '0.5', '0', '0', '10.66666667', '1', '0.6667', '0']
package org . apache . camel . model ; import java . util . Collections ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . CamelException ; import org . apache . camel . Processor ; import org . apache . camel . processor . ThrowFaultProcessor ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "throwFault" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ThrowFaultType extends ProcessorType < ThrowFaultType > { @ XmlTransient private Throwable fault ; @ XmlTransient private Processor processor ; @ XmlAttribute ( required = true ) private String faultRef ; public ThrowFaultType ( ) { } @ Override public String getShortName ( ) { return "throwFault" ; } @ Override public String toString ( ) { if ( faultRef != null ) { return "ThrowFault[ref: " + faultRef + "]" ; } else { return "ThrowFault[" + fault . getClass ( ) . getCanonicalName ( ) ; } } public void setFault ( Throwable fault ) { this . fault = fault ; } public Throwable getFault ( ) { return fault ; } public void setFaultRef ( String ref ) { this . faultRef = ref ; } public String getFaultRef ( ) { return faultRef ; } @ Override public Processor createProcessor ( RouteContext routeContext ) { if ( processor == null ) { if ( fault == null ) { fault = routeContext . lookup ( faultRef , Throwable . class ) ; if ( fault == null ) { fault = new CamelException ( faultRef ) ; } } processor = new ThrowFaultProcessor ( fault ) ; } return processor ; } @ Override public List < ProcessorType < ? > > getOutputs ( ) { return Collections . EMPTY_LIST ; } } 	0	['9', '3', '0', '5', '18', '14', '1', '5', '9', '0.75', '94', '1', '1', '0.956521739', '0.333333333', '1', '3', '9.111111111', '4', '1.3333', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . CamelContext ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . builder . ErrorHandlerBuilder ; import org . apache . camel . builder . ExpressionClause ; import org . apache . camel . language . constant . ConstantLanguage ; import org . apache . camel . processor . CatchProcessor ; import org . apache . camel . processor . RedeliveryPolicy ; import org . apache . camel . spi . RouteContext ; import org . apache . camel . util . ObjectHelper ; import static org . apache . camel . builder . PredicateBuilder . toPredicate ; @ XmlRootElement ( name = "onException" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ExceptionType extends ProcessorType < ProcessorType > { @ XmlElement ( name = "exception" ) private List < String > exceptions = new ArrayList < String > ( ) ; @ XmlElement ( name = "onWhen" , required = false ) private WhenType onWhen ; @ XmlElement ( name = "redeliveryPolicy" , required = false ) private RedeliveryPolicyType redeliveryPolicy ; @ XmlElement ( name = "handled" , required = false ) private ExpressionSubElementType handled ; @ XmlElementRef private List < ProcessorType < ? > > outputs = new ArrayList < ProcessorType < ? > > ( ) ; @ XmlTransient private List < Class > exceptionClasses ; @ XmlTransient private Processor errorHandler ; @ XmlTransient private Predicate handledPolicy ; public ExceptionType ( ) { } public ExceptionType ( List < Class > exceptionClasses ) { this . exceptionClasses = exceptionClasses ; } public ExceptionType ( Class exceptionType ) { exceptionClasses = new ArrayList < Class > ( ) ; exceptionClasses . add ( exceptionType ) ; } @ Override public String toString ( ) { return "Exception[" + getExceptionClasses ( ) + ( onWhen != null ? " " + onWhen : "" ) + " -> " + getOutputs ( ) + "]" ; } @ Override public ExceptionType onException ( Class exceptionType ) { getExceptionClasses ( ) . add ( exceptionType ) ; return this ; } public RedeliveryPolicy createRedeliveryPolicy ( CamelContext context , RedeliveryPolicy parentPolicy ) { if ( redeliveryPolicy != null ) { return redeliveryPolicy . createRedeliveryPolicy ( context , parentPolicy ) ; } else if ( errorHandler != null ) { RedeliveryPolicy answer = parentPolicy . copy ( ) ; answer . setMaximumRedeliveries ( 0 ) ; return answer ; } return parentPolicy ; } public void addRoutes ( RouteContext routeContext , Collection < Route > routes ) throws Exception { setHandledFromExpressionType ( routeContext ) ; errorHandler = routeContext . createProcessor ( this ) ; ErrorHandlerBuilder builder = routeContext . getRoute ( ) . getErrorHandlerBuilder ( ) ; builder . addErrorHandlers ( this ) ; } @ Override public CatchProcessor createProcessor ( RouteContext routeContext ) throws Exception { Processor childProcessor = routeContext . createProcessor ( this ) ; return new CatchProcessor ( getExceptionClasses ( ) , childProcessor ) ; } public ExceptionType handled ( boolean handled ) { ConstantLanguage constant = new ConstantLanguage ( ) ; return handled ( constant . createPredicate ( Boolean . toString ( handled ) ) ) ; } public ExceptionType handled ( Predicate handled ) { setHandledPolicy ( handled ) ; return this ; } public ExceptionType handled ( Expression handled ) { setHandledPolicy ( toPredicate ( handled ) ) ; return this ; } public ExceptionType onWhen ( Predicate predicate ) { setOnWhen ( new WhenType ( predicate ) ) ; return this ; } public ExpressionClause < ExceptionType > onWhen ( ) { onWhen = new WhenType ( ) ; ExpressionClause < ExceptionType > clause = new ExpressionClause < ExceptionType > ( this ) ; onWhen . setExpression ( clause ) ; return clause ; } public ExceptionType backOffMultiplier ( double backOffMultiplier ) { getOrCreateRedeliveryPolicy ( ) . backOffMultiplier ( backOffMultiplier ) ; return this ; } public ExceptionType collisionAvoidanceFactor ( double collisionAvoidanceFactor ) { getOrCreateRedeliveryPolicy ( ) . collisionAvoidanceFactor ( collisionAvoidanceFactor ) ; return this ; } public ExceptionType collisionAvoidancePercent ( short collisionAvoidancePercent ) { getOrCreateRedeliveryPolicy ( ) . collisionAvoidancePercent ( collisionAvoidancePercent ) ; return this ; } public ExceptionType initialRedeliveryDelay ( long initialRedeliveryDelay ) { getOrCreateRedeliveryPolicy ( ) . initialRedeliveryDelay ( initialRedeliveryDelay ) ; return this ; } public ExceptionType retriesExhaustedLogLevel ( LoggingLevel retriesExhaustedLogLevel ) { getOrCreateRedeliveryPolicy ( ) . retriesExhaustedLogLevel ( retriesExhaustedLogLevel ) ; return this ; } public ExceptionType retryAttemptedLogLevel ( LoggingLevel retryAttemptedLogLevel ) { getOrCreateRedeliveryPolicy ( ) . retryAttemptedLogLevel ( retryAttemptedLogLevel ) ; return this ; } public ExceptionType maximumRedeliveries ( int maximumRedeliveries ) { getOrCreateRedeliveryPolicy ( ) . maximumRedeliveries ( maximumRedeliveries ) ; return this ; } public ExceptionType useCollisionAvoidance ( ) { getOrCreateRedeliveryPolicy ( ) . useCollisionAvoidance ( ) ; return this ; } public ExceptionType useExponentialBackOff ( ) { getOrCreateRedeliveryPolicy ( ) . useExponentialBackOff ( ) ; return this ; } public ExceptionType maximumRedeliveryDelay ( long maximumRedeliveryDelay ) { getOrCreateRedeliveryPolicy ( ) . maximumRedeliveryDelay ( maximumRedeliveryDelay ) ; return this ; } public List < ProcessorType < ? > > getOutputs ( ) { return outputs ; } public void setOutputs ( List < ProcessorType < ? > > outputs ) { this . outputs = outputs ; } public List < Class > getExceptionClasses ( ) { if ( exceptionClasses == null ) { exceptionClasses = createExceptionClasses ( ) ; } return exceptionClasses ; } public void setExceptionClasses ( List < Class > exceptionClasses ) { this . exceptionClasses = exceptionClasses ; } public List < String > getExceptions ( ) { return exceptions ; } public void setExceptions ( List < String > exceptions ) { this . exceptions = exceptions ; } public Processor getErrorHandler ( ) { return errorHandler ; } public RedeliveryPolicyType getRedeliveryPolicy ( ) { return redeliveryPolicy ; } public void setRedeliveryPolicy ( RedeliveryPolicyType redeliveryPolicy ) { this . redeliveryPolicy = redeliveryPolicy ; } public Predicate getHandledPolicy ( ) { return handledPolicy ; } public void setHandled ( ExpressionSubElementType handled ) { this . handled = handled ; } public ExpressionSubElementType getHandled ( ) { return handled ; } private void setHandledFromExpressionType ( RouteContext routeContext ) { if ( getHandled ( ) != null && handledPolicy == null && routeContext != null ) { handled ( getHandled ( ) . createPredicate ( routeContext ) ) ; } } public void setHandledPolicy ( Predicate handledPolicy ) { this . handledPolicy = handledPolicy ; } public WhenType getOnWhen ( ) { return onWhen ; } public void setOnWhen ( WhenType onWhen ) { this . onWhen = onWhen ; } protected RedeliveryPolicyType getOrCreateRedeliveryPolicy ( ) { if ( redeliveryPolicy == null ) { redeliveryPolicy = new RedeliveryPolicyType ( ) ; } return redeliveryPolicy ; } protected List < Class > createExceptionClasses ( ) { List < String > list = getExceptions ( ) ; List < Class > answer = new ArrayList < Class > ( list . size ( ) ) ; for ( String name : list ) { Class type = ObjectHelper . loadClass ( name , getClass ( ) . getClassLoader ( ) ) ; answer . add ( type ) ; } return answer ; } } 	0	['42', '3', '0', '31', '84', '779', '14', '19', '39', '0.868902439', '427', '1', '5', '0.818604651', '0.093915344', '1', '3', '8.976190476', '4', '1.1429', '0']
package org . apache . camel . bam . model ; import java . util . Collection ; import java . util . Date ; import java . util . HashSet ; import javax . persistence . CascadeType ; import javax . persistence . Entity ; import javax . persistence . FetchType ; import javax . persistence . Id ; import javax . persistence . ManyToOne ; import javax . persistence . OneToMany ; import javax . persistence . Temporal ; import javax . persistence . TemporalType ; import javax . persistence . Transient ; import org . apache . camel . bam . rules . ActivityRules ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; @ Entity public class ProcessInstance { private static final transient Log LOG = LogFactory . getLog ( ProcessInstance . class ) ; private ProcessDefinition processDefinition ; private Collection < ActivityState > activityStates = new HashSet < ActivityState > ( ) ; private String correlationKey ; private Date timeStarted ; private Date timeCompleted ; public ProcessInstance ( ) { setTimeStarted ( new Date ( ) ) ; } public String toString ( ) { return "ProcessInstance[" + getCorrelationKey ( ) + "]" ; } @ Id public String getCorrelationKey ( ) { return correlationKey ; } public void setCorrelationKey ( String correlationKey ) { this . correlationKey = correlationKey ; } @ ManyToOne ( fetch = FetchType . LAZY , cascade = { CascadeType . PERSIST , CascadeType . MERGE } ) public ProcessDefinition getProcessDefinition ( ) { return processDefinition ; } public void setProcessDefinition ( ProcessDefinition processDefinition ) { this . processDefinition = processDefinition ; } @ OneToMany ( mappedBy = "processInstance" , fetch = FetchType . LAZY , cascade = { CascadeType . ALL } ) public Collection < ActivityState > getActivityStates ( ) { return activityStates ; } public void setActivityStates ( Collection < ActivityState > activityStates ) { this . activityStates = activityStates ; } @ Transient public boolean isStarted ( ) { return timeStarted != null ; } @ Transient public boolean isCompleted ( ) { return timeCompleted != null ; } @ Temporal ( TemporalType . TIME ) public Date getTimeStarted ( ) { return timeStarted ; } public void setTimeStarted ( Date timeStarted ) { this . timeStarted = timeStarted ; } @ Temporal ( TemporalType . TIME ) public Date getTimeCompleted ( ) { return timeCompleted ; } public void setTimeCompleted ( Date timeCompleted ) { this . timeCompleted = timeCompleted ; } public ActivityState getActivityState ( ActivityRules activityRules ) { for ( ActivityState activityState : getActivityStates ( ) ) { if ( activityState . isActivity ( activityRules ) ) { return activityState ; } } return null ; } public ActivityState getOrCreateActivityState ( ActivityRules activityRules ) { ActivityState state = getActivityState ( activityRules ) ; if ( state == null ) { state = createActivityState ( ) ; state . setProcessInstance ( this ) ; state . setActivityDefinition ( activityRules . getActivityDefinition ( ) ) ; } return state ; } protected ActivityState createActivityState ( ) { return new ActivityState ( ) ; } } 	0	['18', '1', '0', '13', '33', '131', '9', '6', '16', '0.882352941', '144', '1', '1', '0', '0.235294118', '0', '0', '6.666666667', '2', '1.1111', '0']
package org . apache . camel . spring ; import org . apache . camel . CamelContext ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . spring . spi . SpringTransactionPolicy ; import org . apache . camel . spring . spi . TransactionErrorHandlerBuilder ; import org . apache . camel . spring . spi . TransactionInterceptor ; import org . springframework . context . ApplicationContext ; import org . springframework . transaction . support . TransactionTemplate ; public abstract class SpringRouteBuilder extends RouteBuilder { private ApplicationContext applicationContext ; public TransactionInterceptor transactionInterceptor ( ) { return new TransactionInterceptor ( bean ( TransactionTemplate . class ) ) ; } public < T > T bean ( Class < T > type , String beanName ) { ApplicationContext context = getApplicationContext ( ) ; return ( T ) context . getBean ( beanName , type ) ; } public < T > T bean ( Class < T > type ) { ApplicationContext context = getApplicationContext ( ) ; String [ ] names = context . getBeanNamesForType ( type , true , true ) ; if ( names != null ) { int count = names . length ; if ( count == 1 ) { return ( T ) context . getBean ( names [ 0 ] ) ; } else if ( count > 1 ) { throw new IllegalArgumentException ( "Too many beans in the application context of type: " + type + ". Found: " + count ) ; } } throw new IllegalArgumentException ( "No bean available in the application context of type: " + type ) ; } public ApplicationContext getApplicationContext ( ) { if ( applicationContext == null ) { CamelContext camelContext = getContext ( ) ; if ( camelContext instanceof SpringCamelContext ) { SpringCamelContext springCamelContext = ( SpringCamelContext ) camelContext ; return springCamelContext . getApplicationContext ( ) ; } else { throw new IllegalArgumentException ( "This SpringBuilder is not being used with a SpringCamelContext and there is no applicationContext property configured" ) ; } } return applicationContext ; } public void setApplicationContext ( ApplicationContext applicationContext ) { this . applicationContext = applicationContext ; } public TransactionErrorHandlerBuilder transactionErrorHandler ( SpringTransactionPolicy policy ) { TransactionErrorHandlerBuilder answer = new TransactionErrorHandlerBuilder ( ) ; answer . setTransactionTemplate ( policy . getTemplate ( ) ) ; return answer ; } } 	0	['7', '3', '0', '8', '23', '19', '0', '8', '7', '0.5', '118', '1', '0', '0.9', '0.342857143', '0', '0', '15.71428571', '4', '1.5714', '0']
package org . apache . camel . spring . handler ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; import javax . xml . bind . Binder ; import javax . xml . bind . JAXBContext ; import javax . xml . bind . JAXBException ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . apache . camel . ExchangePattern ; import org . apache . camel . builder . xml . Namespaces ; import org . apache . camel . model . dataformat . ArtixDSDataFormat ; import org . apache . camel . model . dataformat . JaxbDataFormat ; import org . apache . camel . model . dataformat . SerializationDataFormat ; import org . apache . camel . model . dataformat . XMLBeansDataFormat ; import org . apache . camel . model . loadbalancer . RandomLoadBalanceStrategy ; import org . apache . camel . model . loadbalancer . RoundRobinLoadBalanceStrategy ; import org . apache . camel . model . loadbalancer . StickyLoadBalanceStrategy ; import org . apache . camel . model . loadbalancer . TopicLoadBalanceStrategy ; import org . apache . camel . spi . NamespaceAware ; import org . apache . camel . spring . CamelBeanPostProcessor ; import org . apache . camel . spring . CamelContextFactoryBean ; import org . apache . camel . spring . CamelJMXAgentType ; import org . apache . camel . spring . CamelTemplateFactoryBean ; import org . apache . camel . spring . EndpointFactoryBean ; import org . apache . camel . spring . remoting . CamelProxyFactoryBean ; import org . apache . camel . spring . remoting . CamelServiceExporter ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . view . ModelFileGenerator ; import org . springframework . beans . factory . BeanDefinitionStoreException ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . RuntimeBeanReference ; import org . springframework . beans . factory . parsing . BeanComponentDefinition ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . xml . NamespaceHandlerSupport ; import org . springframework . beans . factory . xml . ParserContext ; public class CamelNamespaceHandler extends NamespaceHandlerSupport { protected BeanDefinitionParser endpointParser = new BeanDefinitionParser ( EndpointFactoryBean . class ) ; protected BeanDefinitionParser beanPostProcessorParser = new BeanDefinitionParser ( CamelBeanPostProcessor . class ) ; protected Set < String > parserElementNames = new HashSet < String > ( ) ; protected Binder < Node > binder ; private JAXBContext jaxbContext ; private Map < String , BeanDefinitionParser > parserMap = new HashMap < String , BeanDefinitionParser > ( ) ; public ModelFileGenerator createModelFileGenerator ( ) throws JAXBException { return new ModelFileGenerator ( getJaxbContext ( ) ) ; } public void init ( ) { addBeanDefinitionParser ( "proxy" , CamelProxyFactoryBean . class ) ; addBeanDefinitionParser ( "template" , CamelTemplateFactoryBean . class ) ; addBeanDefinitionParser ( "export" , CamelServiceExporter . class ) ; addBeanDefinitionParser ( "artixDS" , ArtixDSDataFormat . class ) ; addBeanDefinitionParser ( "jaxb" , JaxbDataFormat . class ) ; addBeanDefinitionParser ( "serialization" , SerializationDataFormat . class ) ; addBeanDefinitionParser ( "xmlBeans" , XMLBeansDataFormat . class ) ; addBeanDefinitionParser ( "roundRobin" , RoundRobinLoadBalanceStrategy . class ) ; addBeanDefinitionParser ( "random" , RandomLoadBalanceStrategy . class ) ; addBeanDefinitionParser ( "sticky" , StickyLoadBalanceStrategy . class ) ; addBeanDefinitionParser ( "topic" , TopicLoadBalanceStrategy . class ) ; addBeanDefinitionParser ( "jmxAgent" , CamelJMXAgentType . class ) ; registerParser ( "endpoint" , endpointParser ) ; Class cl = CamelContextFactoryBean . class ; try { cl = Class . forName ( "org.apache.camel.osgi.CamelContextFactoryBean" ) ; } catch ( Throwable t ) { } registerParser ( "camelContext" , new CamelContextBeanDefinitionParser ( cl ) ) ; } private void addBeanDefinitionParser ( String elementName , Class < ? > type ) { BeanDefinitionParser parser = new BeanDefinitionParser ( type ) ; registerParser ( elementName , parser ) ; parserMap . put ( elementName , parser ) ; } protected void createBeanPostProcessor ( ParserContext parserContext , String contextId , Element childElement , BeanDefinitionBuilder parentBuilder ) { String beanPostProcessorId = contextId + ":beanPostProcessor" ; childElement . setAttribute ( "id" , beanPostProcessorId ) ; BeanDefinition definition = beanPostProcessorParser . parse ( childElement , parserContext ) ; definition . getPropertyValues ( ) . addPropertyValue ( "camelContext" , new RuntimeBeanReference ( contextId ) ) ; parentBuilder . addPropertyReference ( "beanPostProcessor" , beanPostProcessorId ) ; } protected void registerScriptParser ( String elementName , String engineName ) { registerParser ( elementName , new ScriptDefinitionParser ( engineName ) ) ; } protected void registerParser ( String name , org . springframework . beans . factory . xml . BeanDefinitionParser parser ) { parserElementNames . add ( name ) ; registerBeanDefinitionParser ( name , parser ) ; } public Set < String > getParserElementNames ( ) { return parserElementNames ; } protected Object parseUsingJaxb ( Element element , ParserContext parserContext ) { try { binder = getJaxbContext ( ) . createBinder ( ) ; return binder . unmarshal ( element ) ; } catch ( JAXBException e ) { throw new BeanDefinitionStoreException ( "Failed to parse JAXB element: " + e , e ) ; } } public JAXBContext getJaxbContext ( ) throws JAXBException { if ( jaxbContext == null ) { jaxbContext = createJaxbContext ( ) ; } return jaxbContext ; } protected JAXBContext createJaxbContext ( ) throws JAXBException { StringBuilder packages = new StringBuilder ( ) ; for ( Class cl : getJaxbPackages ( ) ) { if ( packages . length ( ) > 0 ) { packages . append ( ":" ) ; } packages . append ( cl . getName ( ) . substring ( 0 , cl . getName ( ) . lastIndexOf ( '.' ) ) ) ; } return JAXBContext . newInstance ( packages . toString ( ) , getClass ( ) . getClassLoader ( ) ) ; } protected Set < Class > getJaxbPackages ( ) { Set < Class > classes = new HashSet < Class > ( ) ; classes . add ( org . apache . camel . spring . CamelContextFactoryBean . class ) ; classes . add ( ExchangePattern . class ) ; classes . add ( org . apache . camel . model . RouteType . class ) ; classes . add ( org . apache . camel . model . config . StreamResequencerConfig . class ) ; classes . add ( org . apache . camel . model . dataformat . DataFormatType . class ) ; classes . add ( org . apache . camel . model . language . ExpressionType . class ) ; classes . add ( org . apache . camel . model . loadbalancer . LoadBalancerType . class ) ; return classes ; } protected class CamelContextBeanDefinitionParser extends BeanDefinitionParser { public CamelContextBeanDefinitionParser ( Class type ) { super ( type ) ; } @ Override protected void doParse ( Element element , ParserContext parserContext , BeanDefinitionBuilder builder ) { super . doParse ( element , parserContext , builder ) ; String contextId = element . getAttribute ( "id" ) ; if ( ObjectHelper . isNullOrBlank ( contextId ) ) { contextId = "camelContext" ; element . setAttribute ( "id" , contextId ) ; } Object value = parseUsingJaxb ( element , parserContext ) ; if ( value instanceof CamelContextFactoryBean ) { CamelContextFactoryBean factoryBean = ( CamelContextFactoryBean ) value ; builder . addPropertyValue ( "id" , contextId ) ; builder . addPropertyValue ( "routes" , factoryBean . getRoutes ( ) ) ; builder . addPropertyValue ( "intercepts" , factoryBean . getIntercepts ( ) ) ; builder . addPropertyValue ( "dataFormats" , factoryBean . getDataFormats ( ) ) ; builder . addPropertyValue ( "builderRefs" , factoryBean . getBuilderRefs ( ) ) ; if ( factoryBean . getPackages ( ) . length > 0 ) { builder . addPropertyValue ( "packages" , factoryBean . getPackages ( ) ) ; } } boolean createdBeanPostProcessor = false ; NodeList list = element . getChildNodes ( ) ; int size = list . getLength ( ) ; for ( int i = 0 ; i < size ; i ++ ) { Node child = list . item ( i ) ; if ( child instanceof Element ) { Element childElement = ( Element ) child ; String localName = child . getLocalName ( ) ; if ( localName . equals ( "beanPostProcessor" ) ) { createBeanPostProcessor ( parserContext , contextId , childElement , builder ) ; createdBeanPostProcessor = true ; } else if ( localName . equals ( "endpoint" ) ) { BeanDefinition definition = endpointParser . parse ( childElement , parserContext ) ; String id = childElement . getAttribute ( "id" ) ; if ( ObjectHelper . isNotNullAndNonEmpty ( id ) ) { definition . getPropertyValues ( ) . addPropertyValue ( "camelContext" , new RuntimeBeanReference ( contextId ) ) ; parserContext . registerComponent ( new BeanComponentDefinition ( definition , id ) ) ; } } else { BeanDefinitionParser parser = parserMap . get ( localName ) ; if ( parser != null ) { BeanDefinition definition = parser . parse ( childElement , parserContext ) ; String id = childElement . getAttribute ( "id" ) ; if ( ObjectHelper . isNotNullAndNonEmpty ( id ) ) { parserContext . registerComponent ( new BeanComponentDefinition ( definition , id ) ) ; if ( localName . equals ( "jmxAgent" ) ) { builder . addPropertyReference ( "camelJMXAgent" , id ) ; } } } } } } injectNamespaces ( element ) ; if ( ! createdBeanPostProcessor ) { Element childElement = element . getOwnerDocument ( ) . createElement ( "beanPostProcessor" ) ; element . appendChild ( childElement ) ; createBeanPostProcessor ( parserContext , contextId , childElement , builder ) ; } } } protected void injectNamespaces ( Element element ) { NodeList list = element . getChildNodes ( ) ; Namespaces namespaces = null ; int size = list . getLength ( ) ; for ( int i = 0 ; i < size ; i ++ ) { Node child = list . item ( i ) ; if ( child instanceof Element ) { Element childElement = ( Element ) child ; Object object = binder . getJAXBNode ( child ) ; if ( object instanceof NamespaceAware ) { NamespaceAware namespaceAware = ( NamespaceAware ) object ; if ( namespaces == null ) { namespaces = new Namespaces ( element ) ; } namespaces . configure ( namespaceAware ) ; } injectNamespaces ( childElement ) ; } } } } 	0	['14', '0', '1', '16', '54', '73', '3', '14', '5', '0.833333333', '352', '1', '2', '0', '0.232142857', '0', '0', '23.71428571', '5', '1.2143', '0']
package org . apache . camel . component . file . remote ; import java . io . IOException ; import com . jcraft . jsch . ChannelSftp ; import com . jcraft . jsch . SftpException ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public final class SftpUtils { private static final transient Log LOG = LogFactory . getLog ( SftpUtils . class ) ; private SftpUtils ( ) { } public static boolean buildDirectory ( ChannelSftp sftpClient , String dirName ) throws IOException , SftpException { String originalDirectory = sftpClient . pwd ( ) ; boolean success = false ; try { try { sftpClient . cd ( dirName ) ; success = true ; } catch ( SftpException e ) { } if ( ! success ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Trying to build remote directory: " + dirName ) ; } try { sftpClient . mkdir ( dirName ) ; success = true ; } catch ( SftpException e ) { success = buildDirectoryChunks ( sftpClient , dirName ) ; } } } finally { sftpClient . cd ( originalDirectory ) ; } return success ; } public static boolean buildDirectoryChunks ( ChannelSftp sftpClient , String dirName ) throws IOException , SftpException { final StringBuilder sb = new StringBuilder ( dirName . length ( ) ) ; final String [ ] dirs = dirName . split ( "\\/" ) ; boolean success = false ; for ( String dir : dirs ) { sb . append ( dir ) . append ( '/' ) ; String directory = sb . toString ( ) ; if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Trying to build remote directory: " + directory ) ; } try { sftpClient . mkdir ( directory ) ; success = true ; } catch ( SftpException e ) { } } return success ; } } 	0	['4', '1', '0', '6', '20', '0', '2', '4', '2', '0.333333333', '121', '1', '0', '0', '0.555555556', '0', '0', '29', '1', '0.5', '0']
package org . apache . camel . processor . loadbalancer ; import java . util . List ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public abstract class QueueLoadBalancer extends LoadBalancerSupport { public void process ( Exchange exchange ) throws Exception { List < Processor > list = getProcessors ( ) ; if ( list . isEmpty ( ) ) { throw new IllegalStateException ( "No processors available to process " + exchange ) ; } Processor processor = chooseProcessor ( list , exchange ) ; if ( processor == null ) { throw new IllegalStateException ( "No processors could be chosen to process " + exchange ) ; } else { processor . process ( exchange ) ; } } public boolean process ( final Exchange exchange , final AsyncCallback callback ) { boolean sync = false ; List < Processor > list = getProcessors ( ) ; if ( list . isEmpty ( ) ) { throw new IllegalStateException ( "No processors available to process " + exchange ) ; } Processor processor = chooseProcessor ( list , exchange ) ; if ( processor == null ) { throw new IllegalStateException ( "No processors could be chosen to process " + exchange ) ; } else { if ( processor instanceof AsyncProcessor ) { AsyncProcessor asyncProcessor = ( AsyncProcessor ) processor ; sync = asyncProcessor . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { if ( sync ) { return ; } else { callback . done ( sync ) ; } } } ) ; } else { try { processor . process ( exchange ) ; } catch ( Exception ex ) { exchange . setException ( ex ) ; } callback . done ( false ) ; } } return sync ; } protected abstract Processor chooseProcessor ( List < Processor > processors , Exchange exchange ) ; } 	0	['4', '3', '3', '9', '17', '6', '4', '6', '3', '2', '116', '0', '0', '0.863636364', '0.5625', '0', '0', '28', '4', '1.5', '0']
package org . apache . camel . management ; import java . util . concurrent . atomic . AtomicLong ; import org . springframework . jmx . export . annotation . ManagedAttribute ; import org . springframework . jmx . export . annotation . ManagedOperation ; import org . springframework . jmx . export . annotation . ManagedResource ; @ ManagedResource ( description = "Counter" , currencyTimeLimit = 15 ) public class Counter { protected AtomicLong numExchanges = new AtomicLong ( 0L ) ; @ ManagedOperation ( description = "Reset counters" ) public void reset ( ) { numExchanges . set ( 0L ) ; } @ ManagedAttribute ( description = "Total number of exchanges" ) public long getNumExchanges ( ) throws Exception { return numExchanges . get ( ) ; } public long increment ( ) { return numExchanges . incrementAndGet ( ) ; } } 	0	['4', '1', '1', '1', '9', '0', '1', '0', '4', '0', '27', '1', '0', '0', '1', '0', '0', '5.5', '1', '0.75', '0']
package org . apache . camel . component . cxf . spring ; import java . util . Map ; import javax . xml . namespace . QName ; import org . w3c . dom . Element ; import org . apache . cxf . Bus ; import org . apache . cxf . BusFactory ; import org . apache . cxf . bus . spring . BusWiringBeanFactoryPostProcessor ; import org . apache . cxf . common . util . StringUtils ; import org . apache . cxf . configuration . spring . AbstractBeanDefinitionParser ; import org . apache . cxf . service . factory . ReflectionServiceFactoryBean ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanDefinitionStoreException ; import org . springframework . beans . factory . support . AbstractBeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . xml . ParserContext ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; public class CxfEndpointBeanDefinitionParser extends AbstractBeanDefinitionParser { @ Override protected Class getBeanClass ( Element arg0 ) { return CxfSpringEndpointBean . class ; } @ Override protected void mapAttribute ( BeanDefinitionBuilder bean , Element e , String name , String val ) { if ( "endpointName" . equals ( name ) || "serviceName" . equals ( name ) ) { QName q = parseQName ( e , val ) ; bean . addPropertyValue ( name , q ) ; } else { mapToProperty ( bean , name , val ) ; } } @ Override protected void mapElement ( ParserContext ctx , BeanDefinitionBuilder bean , Element el , String name ) { if ( "properties" . equals ( name ) ) { Map map = ctx . getDelegate ( ) . parseMapElement ( el , bean . getBeanDefinition ( ) ) ; bean . addPropertyValue ( "properties" , map ) ; } else if ( "binding" . equals ( name ) ) { setFirstChildAsProperty ( el , ctx , bean , "bindingConfig" ) ; } else if ( "inInterceptors" . equals ( name ) || "inFaultInterceptors" . equals ( name ) || "outInterceptors" . equals ( name ) || "outFaultInterceptors" . equals ( name ) || "features" . equals ( name ) || "schemaLocations" . equals ( name ) || "handlers" . equals ( name ) ) { java . util . List list = ( java . util . List ) ctx . getDelegate ( ) . parseListElement ( el , bean . getBeanDefinition ( ) ) ; bean . addPropertyValue ( name , list ) ; } else { setFirstChildAsProperty ( el , ctx , bean , name ) ; } } @ Override protected void doParse ( Element element , ParserContext ctx , BeanDefinitionBuilder bean ) { super . doParse ( element , ctx , bean ) ; bean . setLazyInit ( false ) ; } @ Override protected String resolveId ( Element elem , AbstractBeanDefinition definition , ParserContext ctx ) throws BeanDefinitionStoreException { String id = super . resolveId ( elem , definition , ctx ) ; if ( StringUtils . isEmpty ( id ) ) { throw new BeanDefinitionStoreException ( "The bean id is needed." ) ; } return id ; } @ Override protected boolean hasBusProperty ( ) { return true ; } public static class CxfSpringEndpointBean extends CxfEndpointBean implements ApplicationContextAware { public CxfSpringEndpointBean ( ) { super ( ) ; } public CxfSpringEndpointBean ( ReflectionServiceFactoryBean factory ) { super ( factory ) ; } public void setApplicationContext ( ApplicationContext ctx ) throws BeansException { if ( getBus ( ) == null ) { Bus bus = BusFactory . getDefaultBus ( ) ; setBus ( bus ) ; } BusWiringBeanFactoryPostProcessor . updateBusReferencesInContext ( getBus ( ) , ctx ) ; } } } 	0	['7', '0', '0', '9', '22', '21', '1', '8', '1', '2', '141', '0', '0', '0', '0.5', '0', '0', '19.14285714', '10', '2.4286', '0']
package org . apache . camel . component . jms ; import java . util . Collections ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . spi . BrowsableEndpoint ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . jms . core . JmsOperations ; public class JmsQueueEndpoint extends JmsEndpoint implements BrowsableEndpoint < JmsExchange > { private static final transient Log LOG = LogFactory . getLog ( JmsQueueEndpoint . class ) ; private int maximumBrowseSize = - 1 ; private final QueueBrowseStrategy queueBrowseStrategy ; public JmsQueueEndpoint ( String uri , JmsComponent component , String destination , JmsConfiguration configuration ) { this ( uri , component , destination , configuration , null ) ; } public JmsQueueEndpoint ( String uri , JmsComponent component , String destination , JmsConfiguration configuration , QueueBrowseStrategy queueBrowseStrategy ) { super ( uri , component , destination , false , configuration ) ; if ( queueBrowseStrategy == null ) { this . queueBrowseStrategy = createQueueBrowseStrategy ( ) ; } else { this . queueBrowseStrategy = queueBrowseStrategy ; } } public JmsQueueEndpoint ( String endpointUri , String destination , QueueBrowseStrategy queueBrowseStrategy ) { super ( endpointUri , destination , false ) ; if ( queueBrowseStrategy == null ) { this . queueBrowseStrategy = createQueueBrowseStrategy ( ) ; } else { this . queueBrowseStrategy = queueBrowseStrategy ; } } public JmsQueueEndpoint ( String endpointUri , String destination ) { super ( endpointUri , destination , false ) ; queueBrowseStrategy = createQueueBrowseStrategy ( ) ; } public int getMaximumBrowseSize ( ) { return maximumBrowseSize ; } public void setMaximumBrowseSize ( int maximumBrowseSize ) { this . maximumBrowseSize = maximumBrowseSize ; } public List < Exchange > getExchanges ( ) { if ( queueBrowseStrategy == null ) { return Collections . EMPTY_LIST ; } String queue = getDestination ( ) ; JmsOperations template = getConfiguration ( ) . createInOnlyTemplate ( this , false , queue ) ; return queueBrowseStrategy . browse ( template , queue , this ) ; } protected static QueueBrowseStrategy createQueueBrowseStrategy ( ) { QueueBrowseStrategy answer = null ; try { answer = JmsComponent . tryCreateDefaultQueueBrowseStrategy ( ) ; } catch ( Throwable e ) { LOG . debug ( "Caught exception trying to create default QueueBrowseStrategy. " + "This could be due to spring 2.0.x on classpath? Cause: " + e , e ) ; } if ( answer == null ) { LOG . warn ( "Cannot browse queues as no QueueBrowseStrategy specified. Are you using Spring 2.0.x by any chance? If you upgrade to 2.5.x or later then queue browsing is supported" ) ; } return answer ; } } 	0	['9', '3', '1', '11', '23', '8', '5', '8', '7', '0.458333333', '127', '1', '1', '0.931034483', '0.375', '0', '0', '12.77777778', '2', '0.6667', '0']
package org . apache . camel . component . irc ; import org . apache . camel . Exchange ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . impl . DefaultProducer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . schwering . irc . lib . IRCConnection ; import org . schwering . irc . lib . IRCEventListener ; public class IrcProducer extends DefaultProducer < IrcExchange > { public static final String [ ] COMMANDS = new String [ ] { "AWAY" , "INVITE" , "ISON" , "JOIN" , "KICK" , "LIST" , "NAMES" , "PRIVMSG" , "MODE" , "NICK" , "NOTICE" , "PART" , "PONG" , "QUIT" , "TOPIC" , "WHO" , "WHOIS" , "WHOWAS" , "USERHOST" } ; private static final transient Log LOG = LogFactory . getLog ( IrcProducer . class ) ; private IRCConnection connection ; private IrcEndpoint endpoint ; private IRCEventListener ircErrorLogger ; public IrcProducer ( IrcEndpoint endpoint , IRCConnection connection ) { super ( endpoint ) ; this . endpoint = endpoint ; this . connection = connection ; } public void process ( Exchange exchange ) throws Exception { try { final String msg = exchange . getIn ( ) . getBody ( String . class ) ; if ( isMessageACommand ( msg ) ) { connection . send ( msg ) ; } else { final String target = endpoint . getConfiguration ( ) . getTarget ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "sending to: " + target + " message: " + msg ) ; } connection . doPrivmsg ( target , msg ) ; } } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; ircErrorLogger = createIrcErrorLogger ( ) ; connection . addIRCEventListener ( ircErrorLogger ) ; final String target = endpoint . getConfiguration ( ) . getTarget ( ) ; LOG . debug ( "joining: " + target ) ; connection . doJoin ( target ) ; } @ Override protected void doStop ( ) throws Exception { super . doStop ( ) ; if ( connection != null ) { connection . removeIRCEventListener ( ircErrorLogger ) ; } } protected boolean isMessageACommand ( String msg ) { for ( String command : COMMANDS ) { if ( msg . startsWith ( command ) ) { return true ; } } return false ; } protected IRCEventListener createIrcErrorLogger ( ) { return new IrcErrorLogger ( LOG ) ; } } 	0	['7', '3', '0', '12', '28', '0', '1', '12', '2', '0.633333333', '227', '0.8', '1', '0.807692308', '0.333333333', '1', '1', '30.71428571', '3', '1', '0']
package org . apache . camel . component . jms ; import java . util . Map ; import javax . jms . ConnectionFactory ; import javax . jms . ExceptionListener ; import javax . jms . Session ; import org . apache . camel . CamelContext ; import org . apache . camel . CamelException ; import org . apache . camel . Endpoint ; import org . apache . camel . HeaderFilterStrategyAware ; import org . apache . camel . component . jms . requestor . Requestor ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . spi . HeaderFilterStrategy ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . core . task . TaskExecutor ; import org . springframework . jms . connection . JmsTransactionManager ; import org . springframework . jms . connection . UserCredentialsConnectionFactoryAdapter ; import org . springframework . jms . core . JmsOperations ; import org . springframework . jms . listener . serversession . ServerSessionFactory ; import org . springframework . jms . support . converter . MessageConverter ; import org . springframework . jms . support . destination . DestinationResolver ; import org . springframework . transaction . PlatformTransactionManager ; import static org . apache . camel . util . ObjectHelper . removeStartingCharacters ; public class JmsComponent extends DefaultComponent < JmsExchange > implements ApplicationContextAware , HeaderFilterStrategyAware { private static final transient Log LOG = LogFactory . getLog ( JmsComponent . class ) ; private static final String DEFAULT_QUEUE_BROWSE_STRATEGY = "org.apache.camel.component.jms.DefaultQueueBrowseStrategy" ; private JmsConfiguration configuration ; private ApplicationContext applicationContext ; private Requestor requestor ; private QueueBrowseStrategy queueBrowseStrategy ; private boolean attemptedToCreateQueueBrowserStrategy ; private HeaderFilterStrategy headerFilterStrategy ; public JmsComponent ( ) { setHeaderFilterStrategy ( new JmsHeaderFilterStrategy ( ) ) ; } public JmsComponent ( JmsConfiguration configuration ) { this . configuration = configuration ; setHeaderFilterStrategy ( new JmsHeaderFilterStrategy ( ) ) ; } public JmsComponent ( CamelContext context ) { super ( context ) ; setHeaderFilterStrategy ( new JmsHeaderFilterStrategy ( ) ) ; } public static JmsComponent jmsComponent ( ) { return new JmsComponent ( ) ; } public static JmsComponent jmsComponent ( JmsConfiguration configuration ) { return new JmsComponent ( configuration ) ; } public static JmsComponent jmsComponent ( ConnectionFactory connectionFactory ) { return jmsComponent ( new JmsConfiguration ( connectionFactory ) ) ; } public static JmsComponent jmsComponentClientAcknowledge ( ConnectionFactory connectionFactory ) { JmsConfiguration template = new JmsConfiguration ( connectionFactory ) ; template . setAcknowledgementMode ( Session . CLIENT_ACKNOWLEDGE ) ; return jmsComponent ( template ) ; } public static JmsComponent jmsComponentAutoAcknowledge ( ConnectionFactory connectionFactory ) { JmsConfiguration template = new JmsConfiguration ( connectionFactory ) ; template . setAcknowledgementMode ( Session . AUTO_ACKNOWLEDGE ) ; return jmsComponent ( template ) ; } public static JmsComponent jmsComponentTransacted ( ConnectionFactory connectionFactory ) { JmsTransactionManager transactionManager = new JmsTransactionManager ( ) ; transactionManager . setConnectionFactory ( connectionFactory ) ; return jmsComponentTransacted ( connectionFactory , transactionManager ) ; } public static JmsComponent jmsComponentTransacted ( ConnectionFactory connectionFactory , PlatformTransactionManager transactionManager ) { JmsConfiguration template = new JmsConfiguration ( connectionFactory ) ; template . setTransactionManager ( transactionManager ) ; template . setTransacted ( true ) ; template . setTransactedInOut ( true ) ; return jmsComponent ( template ) ; } public JmsConfiguration getConfiguration ( ) { if ( configuration == null ) { configuration = createConfiguration ( ) ; if ( applicationContext != null ) { Map beansOfType = applicationContext . getBeansOfType ( ConnectionFactory . class ) ; if ( ! beansOfType . isEmpty ( ) ) { ConnectionFactory cf = ( ConnectionFactory ) beansOfType . values ( ) . iterator ( ) . next ( ) ; configuration . setConnectionFactory ( cf ) ; } beansOfType = applicationContext . getBeansOfType ( DestinationResolver . class ) ; if ( ! beansOfType . isEmpty ( ) ) { DestinationResolver destinationResolver = ( DestinationResolver ) beansOfType . values ( ) . iterator ( ) . next ( ) ; configuration . setDestinationResolver ( destinationResolver ) ; } } } return configuration ; } public void setConfiguration ( JmsConfiguration configuration ) { this . configuration = configuration ; } public void setAcceptMessagesWhileStopping ( boolean acceptMessagesWhileStopping ) { getConfiguration ( ) . setAcceptMessagesWhileStopping ( acceptMessagesWhileStopping ) ; } public void setAcknowledgementMode ( int consumerAcknowledgementMode ) { getConfiguration ( ) . setAcknowledgementMode ( consumerAcknowledgementMode ) ; } public void setAcknowledgementModeName ( String consumerAcknowledgementMode ) { getConfiguration ( ) . setAcknowledgementModeName ( consumerAcknowledgementMode ) ; } public void setAutoStartup ( boolean autoStartup ) { getConfiguration ( ) . setAutoStartup ( autoStartup ) ; } public void setCacheLevel ( int cacheLevel ) { getConfiguration ( ) . setCacheLevel ( cacheLevel ) ; } public void setCacheLevelName ( String cacheName ) { getConfiguration ( ) . setCacheLevelName ( cacheName ) ; } public void setClientId ( String consumerClientId ) { getConfiguration ( ) . setClientId ( consumerClientId ) ; } public void setConcurrentConsumers ( int concurrentConsumers ) { getConfiguration ( ) . setConcurrentConsumers ( concurrentConsumers ) ; } public void setConnectionFactory ( ConnectionFactory connectionFactory ) { getConfiguration ( ) . setConnectionFactory ( connectionFactory ) ; } public void setConsumerType ( ConsumerType consumerType ) { getConfiguration ( ) . setConsumerType ( consumerType ) ; } public void setDeliveryPersistent ( boolean deliveryPersistent ) { getConfiguration ( ) . setDeliveryPersistent ( deliveryPersistent ) ; } public void setDurableSubscriptionName ( String durableSubscriptionName ) { getConfiguration ( ) . setDurableSubscriptionName ( durableSubscriptionName ) ; } public void setExceptionListener ( ExceptionListener exceptionListener ) { getConfiguration ( ) . setExceptionListener ( exceptionListener ) ; } public void setExplicitQosEnabled ( boolean explicitQosEnabled ) { getConfiguration ( ) . setExplicitQosEnabled ( explicitQosEnabled ) ; } public void setExposeListenerSession ( boolean exposeListenerSession ) { getConfiguration ( ) . setExposeListenerSession ( exposeListenerSession ) ; } public void setIdleTaskExecutionLimit ( int idleTaskExecutionLimit ) { getConfiguration ( ) . setIdleTaskExecutionLimit ( idleTaskExecutionLimit ) ; } public void setMaxConcurrentConsumers ( int maxConcurrentConsumers ) { getConfiguration ( ) . setMaxConcurrentConsumers ( maxConcurrentConsumers ) ; } public void setMaxMessagesPerTask ( int maxMessagesPerTask ) { getConfiguration ( ) . setMaxMessagesPerTask ( maxMessagesPerTask ) ; } public void setMessageConverter ( MessageConverter messageConverter ) { getConfiguration ( ) . setMessageConverter ( messageConverter ) ; } public void setMessageIdEnabled ( boolean messageIdEnabled ) { getConfiguration ( ) . setMessageIdEnabled ( messageIdEnabled ) ; } public void setMessageTimestampEnabled ( boolean messageTimestampEnabled ) { getConfiguration ( ) . setMessageTimestampEnabled ( messageTimestampEnabled ) ; } public void setAlwaysCopyMessage ( boolean alwaysCopyMessage ) { getConfiguration ( ) . setAlwaysCopyMessage ( alwaysCopyMessage ) ; } public void setUseMessageIDAsCorrelationID ( boolean useMessageIDAsCorrelationID ) { getConfiguration ( ) . setUseMessageIDAsCorrelationID ( useMessageIDAsCorrelationID ) ; } public void setPriority ( int priority ) { getConfiguration ( ) . setPriority ( priority ) ; } public void setPubSubNoLocal ( boolean pubSubNoLocal ) { getConfiguration ( ) . setPubSubNoLocal ( pubSubNoLocal ) ; } public void setReceiveTimeout ( long receiveTimeout ) { getConfiguration ( ) . setReceiveTimeout ( receiveTimeout ) ; } public void setRecoveryInterval ( long recoveryInterval ) { getConfiguration ( ) . setRecoveryInterval ( recoveryInterval ) ; } public void setServerSessionFactory ( ServerSessionFactory serverSessionFactory ) { getConfiguration ( ) . setServerSessionFactory ( serverSessionFactory ) ; } public void setSubscriptionDurable ( boolean subscriptionDurable ) { getConfiguration ( ) . setSubscriptionDurable ( subscriptionDurable ) ; } public void setTaskExecutor ( TaskExecutor taskExecutor ) { getConfiguration ( ) . setTaskExecutor ( taskExecutor ) ; } public void setTimeToLive ( long timeToLive ) { getConfiguration ( ) . setTimeToLive ( timeToLive ) ; } public void setTransacted ( boolean consumerTransacted ) { getConfiguration ( ) . setTransacted ( consumerTransacted ) ; } public void setTransactionManager ( PlatformTransactionManager transactionManager ) { getConfiguration ( ) . setTransactionManager ( transactionManager ) ; } public void setTransactionName ( String transactionName ) { getConfiguration ( ) . setTransactionName ( transactionName ) ; } public void setTransactionTimeout ( int transactionTimeout ) { getConfiguration ( ) . setTransactionTimeout ( transactionTimeout ) ; } public void setUseVersion102 ( boolean useVersion102 ) { getConfiguration ( ) . setUseVersion102 ( useVersion102 ) ; } public void setJmsOperations ( JmsOperations jmsOperations ) { getConfiguration ( ) . setJmsOperations ( jmsOperations ) ; } public void setDestinationResolver ( DestinationResolver destinationResolver ) { getConfiguration ( ) . setDestinationResolver ( destinationResolver ) ; } public synchronized Requestor getRequestor ( ) throws Exception { if ( requestor == null ) { requestor = new Requestor ( getConfiguration ( ) , getExecutorService ( ) ) ; requestor . start ( ) ; } return requestor ; } public void setRequestor ( Requestor requestor ) { this . requestor = requestor ; } public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { this . applicationContext = applicationContext ; } public QueueBrowseStrategy getQueueBrowseStrategy ( ) { if ( queueBrowseStrategy == null ) { if ( ! attemptedToCreateQueueBrowserStrategy ) { attemptedToCreateQueueBrowserStrategy = true ; try { queueBrowseStrategy = tryCreateDefaultQueueBrowseStrategy ( ) ; } catch ( Throwable e ) { LOG . warn ( "Could not instantiate the QueueBrowseStrategy are you using Spring 2.0.x" + " by any chance? Error: " + e , e ) ; } } } return queueBrowseStrategy ; } public void setQueueBrowseStrategy ( QueueBrowseStrategy queueBrowseStrategy ) { this . queueBrowseStrategy = queueBrowseStrategy ; } @ Override protected void doStop ( ) throws Exception { if ( requestor != null ) { requestor . stop ( ) ; } super . doStop ( ) ; } @ Override protected Endpoint < JmsExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { boolean pubSubDomain = false ; boolean tempDestination = false ; if ( remaining . startsWith ( JmsConfiguration . QUEUE_PREFIX ) ) { pubSubDomain = false ; remaining = removeStartingCharacters ( remaining . substring ( JmsConfiguration . QUEUE_PREFIX . length ( ) ) , '/' ) ; } else if ( remaining . startsWith ( JmsConfiguration . TOPIC_PREFIX ) ) { pubSubDomain = true ; remaining = removeStartingCharacters ( remaining . substring ( JmsConfiguration . TOPIC_PREFIX . length ( ) ) , '/' ) ; } else if ( remaining . startsWith ( JmsConfiguration . TEMP_QUEUE_PREFIX ) ) { pubSubDomain = false ; tempDestination = true ; remaining = removeStartingCharacters ( remaining . substring ( JmsConfiguration . TEMP_QUEUE_PREFIX . length ( ) ) , '/' ) ; } else if ( remaining . startsWith ( JmsConfiguration . TEMP_TOPIC_PREFIX ) ) { pubSubDomain = true ; tempDestination = true ; remaining = removeStartingCharacters ( remaining . substring ( JmsConfiguration . TEMP_TOPIC_PREFIX . length ( ) ) , '/' ) ; } final String subject = convertPathToActualDestination ( remaining , parameters ) ; JmsConfiguration newConfiguration = getConfiguration ( ) . copy ( ) ; JmsEndpoint endpoint ; if ( pubSubDomain ) { if ( tempDestination ) { endpoint = new JmsTemporaryTopicEndpoint ( uri , this , subject , newConfiguration ) ; } else { endpoint = new JmsEndpoint ( uri , this , subject , pubSubDomain , newConfiguration ) ; } } else { QueueBrowseStrategy strategy = getQueueBrowseStrategy ( ) ; if ( tempDestination ) { endpoint = new JmsTemporaryQueueEndpoint ( uri , this , subject , newConfiguration , strategy ) ; } else { endpoint = new JmsQueueEndpoint ( uri , this , subject , newConfiguration , strategy ) ; } } String selector = getAndRemoveParameter ( parameters , "selector" , String . class ) ; if ( selector != null ) { endpoint . setSelector ( selector ) ; } String username = getAndRemoveParameter ( parameters , "username" , String . class ) ; String password = getAndRemoveParameter ( parameters , "password" , String . class ) ; if ( username != null && password != null ) { ConnectionFactory cf = endpoint . getConfiguration ( ) . getConnectionFactory ( ) ; UserCredentialsConnectionFactoryAdapter ucfa = new UserCredentialsConnectionFactoryAdapter ( ) ; ucfa . setTargetConnectionFactory ( cf ) ; ucfa . setPassword ( password ) ; ucfa . setUsername ( username ) ; endpoint . getConfiguration ( ) . setConnectionFactory ( ucfa ) ; } else { if ( username != null || password != null ) { throw new IllegalArgumentException ( "The JmsComponent's username or password is null" ) ; } } setProperties ( endpoint . getConfiguration ( ) , parameters ) ; return endpoint ; } protected String convertPathToActualDestination ( String path , Map parameters ) { return path ; } protected JmsConfiguration createConfiguration ( ) { return new JmsConfiguration ( ) ; } protected static QueueBrowseStrategy tryCreateDefaultQueueBrowseStrategy ( ) { Class < ? > type = ObjectHelper . loadClass ( DEFAULT_QUEUE_BROWSE_STRATEGY ) ; if ( type == null ) { LOG . warn ( "Could not load class: " + DEFAULT_QUEUE_BROWSE_STRATEGY + " maybe you are on Spring 2.0.x?" ) ; return null ; } else { return ( QueueBrowseStrategy ) ObjectHelper . newInstance ( type ) ; } } public HeaderFilterStrategy getHeaderFilterStrategy ( ) { return headerFilterStrategy ; } public void setHeaderFilterStrategy ( HeaderFilterStrategy strategy ) { this . headerFilterStrategy = strategy ; } } 	0	['63', '3', '1', '30', '147', '1929', '6', '28', '57', '0.788306452', '692', '1', '4', '0.372340426', '0.084485407', '2', '4', '9.857142857', '5', '1.0476', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . CamelContext ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . util . CamelContextHelper ; import org . apache . camel . util . ObjectHelper ; @ XmlRootElement ( name = "routeBuilderRef" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class RouteBuilderRef extends IdentifiedType { @ XmlAttribute ( required = true ) private String ref ; public RouteBuilderRef ( ) { } public RouteBuilderRef ( String ref ) { this . ref = ref ; } @ Override public String toString ( ) { return "RouteBuilderRef[" + getRef ( ) + "]" ; } public String getRef ( ) { return ref ; } public void setRef ( String ref ) { this . ref = ref ; } public RouteBuilder createRouteBuilder ( CamelContext camelContext ) { ObjectHelper . notNull ( camelContext , "camelContext" ) ; ObjectHelper . notNull ( ref , "ref" ) ; RouteBuilder builder = CamelContextHelper . lookup ( camelContext , ref , RouteBuilder . class ) ; return builder != null ? builder : CamelContextHelper . newInstance ( camelContext , RouteBuilder . class ) ; } } 	0	['6', '2', '0', '6', '13', '3', '1', '5', '6', '0.2', '58', '1', '0', '0.333333333', '0.5', '0', '0', '8.5', '2', '0.8333', '0']
package org . apache . camel . component . restlet ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . atomic . AtomicBoolean ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . restlet . Restlet ; import org . restlet . data . Method ; import org . restlet . data . Request ; import org . restlet . data . Response ; import org . restlet . data . Status ; class MethodBasedRouter extends Restlet { private static final Log LOG = LogFactory . getLog ( MethodBasedRouter . class ) ; private String uriPattern ; private Map < Method , Restlet > routes = new ConcurrentHashMap < Method , Restlet > ( ) ; private AtomicBoolean hasBeenAttachedFlag = new AtomicBoolean ( false ) ; MethodBasedRouter ( String uriPattern ) { this . uriPattern = uriPattern ; } @ Override public void handle ( Request request , Response response ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "MethodRouter (" + uriPattern + ") received request method: " + request . getMethod ( ) ) ; } Restlet target = routes . get ( request . getMethod ( ) ) ; if ( target != null ) { target . handle ( request , response ) ; } else { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "No route for request method: " + request . getMethod ( ) ) ; } response . setStatus ( Status . CLIENT_ERROR_NOT_FOUND ) ; } } void addRoute ( Method method , Restlet target ) { routes . put ( method , target ) ; } void removeRoute ( Method method ) { routes . remove ( method ) ; } boolean hasBeenAttached ( ) { return hasBeenAttachedFlag . getAndSet ( true ) ; } } 	0	['6', '0', '0', '8', '23', '0', '1', '7', '1', '0.7', '100', '1', '0', '0', '0.366666667', '0', '0', '15', '4', '1.1667', '0']
package org . apache . camel . component . ibatis ; import java . io . IOException ; import java . io . InputStream ; import java . util . Map ; import com . ibatis . sqlmap . client . SqlMapClient ; import com . ibatis . sqlmap . client . SqlMapClientBuilder ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . core . io . ClassPathResource ; import org . springframework . core . io . Resource ; public class IBatisComponent extends DefaultComponent { public static final String DEFAULT_CONFIG_URI = "SqlMapConfig.xml" ; private static final transient Log LOG = LogFactory . getLog ( IBatisComponent . class ) ; private SqlMapClient sqlMapClient ; private Resource sqlMapResource ; public IBatisComponent ( ) { } public IBatisComponent ( SqlMapClient sqlMapClient ) { this . sqlMapClient = sqlMapClient ; } public SqlMapClient getSqlMapClient ( ) throws IOException { if ( sqlMapClient == null ) { sqlMapClient = createSqlMapClient ( ) ; } return sqlMapClient ; } public void setSqlMapClient ( SqlMapClient sqlMapClient ) { this . sqlMapClient = sqlMapClient ; } public Resource getSqlMapResource ( ) { if ( sqlMapResource == null ) { sqlMapResource = new ClassPathResource ( DEFAULT_CONFIG_URI ) ; LOG . debug ( "Defaulting to use the iBatis configuration from: " + sqlMapResource ) ; } return sqlMapResource ; } public void setSqlMapResource ( Resource sqlMapResource ) { this . sqlMapResource = sqlMapResource ; } protected Endpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { return new IBatisEndpoint ( uri , this , remaining ) ; } protected SqlMapClient createSqlMapClient ( ) throws IOException { InputStream in = getSqlMapResource ( ) . getInputStream ( ) ; return SqlMapClientBuilder . buildSqlMapClient ( in ) ; } } 	0	['9', '3', '0', '9', '20', '26', '1', '9', '6', '0.84375', '81', '0.75', '0', '0.853658537', '0.325', '1', '1', '7.555555556', '2', '0.7778', '0']
package org . apache . camel . spring . spi ; import org . apache . camel . spi . Registry ; import org . springframework . beans . factory . NoSuchBeanDefinitionException ; import org . springframework . context . ApplicationContext ; public class ApplicationContextRegistry implements Registry { private ApplicationContext applicationContext ; public ApplicationContextRegistry ( ApplicationContext applicationContext ) { this . applicationContext = applicationContext ; } public < T > T lookup ( String name , Class < T > type ) { try { Object value = applicationContext . getBean ( name , type ) ; return type . cast ( value ) ; } catch ( NoSuchBeanDefinitionException e ) { return null ; } } public Object lookup ( String name ) { try { return applicationContext . getBean ( name ) ; } catch ( NoSuchBeanDefinitionException e ) { return null ; } } } 	0	['3', '1', '0', '4', '7', '0', '1', '3', '3', '0', '31', '1', '0', '0', '0.583333333', '0', '0', '9', '1', '0.6667', '0']
package org . apache . camel . component . file . remote ; import org . apache . camel . Expression ; import org . apache . camel . Message ; import org . apache . camel . component . file . FileComponent ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . language . simple . FileLanguage ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public abstract class RemoteFileProducer < T extends RemoteFileExchange > extends DefaultProducer < T > { protected final transient Log log = LogFactory . getLog ( getClass ( ) ) ; protected RemoteFileEndpoint < T > endpoint ; protected RemoteFileProducer ( RemoteFileEndpoint < T > endpoint ) { super ( endpoint ) ; this . endpoint = endpoint ; } protected String createFileName ( Message message , RemoteFileConfiguration fileConfig ) { String answer ; String name = message . getHeader ( FileComponent . HEADER_FILE_NAME , String . class ) ; Expression expression = endpoint . getConfiguration ( ) . getExpression ( ) ; if ( name != null ) { if ( name . indexOf ( "${" ) > - 1 ) { if ( log . isDebugEnabled ( ) ) { log . debug ( FileComponent . HEADER_FILE_NAME + " contains a FileLanguage expression: " + name ) ; } expression = FileLanguage . file ( name ) ; } } if ( expression != null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Filename evaluated as expression: " + expression ) ; } Object result = expression . evaluate ( message . getExchange ( ) ) ; name = message . getExchange ( ) . getContext ( ) . getTypeConverter ( ) . convertTo ( String . class , result ) ; } String endpointFile = fileConfig . getFile ( ) ; if ( fileConfig . isDirectory ( ) ) { String baseDir = "" ; if ( endpointFile . length ( ) > 0 ) { baseDir = endpointFile + ( endpointFile . endsWith ( "/" ) ? "" : "/" ) ; } String fileName = ( name != null ) ? name : endpoint . getGeneratedFileName ( message ) ; answer = baseDir + fileName ; } else { answer = endpointFile ; } message . setHeader ( FileComponent . HEADER_FILE_NAME_PRODUCED , answer ) ; return answer ; } protected String remoteServer ( ) { return endpoint . getConfiguration ( ) . remoteServerInformation ( ) ; } @ Override protected void doStart ( ) throws Exception { log . info ( "Starting" ) ; super . doStart ( ) ; } @ Override protected void doStop ( ) throws Exception { log . info ( "Stopping" ) ; try { disconnect ( ) ; } catch ( Exception e ) { log . warn ( "Exception occured during disconecting from " + remoteServer ( ) + ". " + e . getClass ( ) . getCanonicalName ( ) + " message: " + e . getMessage ( ) ) ; } super . doStop ( ) ; } protected abstract void connectIfNecessary ( ) throws Exception ; protected abstract void disconnect ( ) throws Exception ; } 	0	['7', '3', '2', '14', '39', '5', '2', '12', '0', '0.5', '187', '1', '1', '0.777777778', '0.357142857', '1', '1', '25.42857143', '10', '2.1429', '0']
package org . apache . camel . component . bean ; import java . util . Collection ; import org . apache . camel . CamelExchangeException ; import org . apache . camel . Exchange ; public class AmbiguousMethodCallException extends CamelExchangeException { private final Collection < MethodInfo > methods ; public AmbiguousMethodCallException ( Exchange exchange , Collection < MethodInfo > methods ) { super ( "Ambiguous method invocations possible: " + methods , exchange ) ; this . methods = methods ; } public Collection < MethodInfo > getMethods ( ) { return methods ; } } 	0	['2', '5', '0', '3', '7', '0', '1', '2', '2', '0', '21', '1', '0', '0.95', '0.666666667', '0', '0', '9', '1', '0.5', '0']
package org . apache . camel . component . xmpp ; import java . net . URI ; import java . util . Map ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . HeaderFilterStrategyAware ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . impl . DefaultHeaderFilterStrategy ; import org . apache . camel . spi . HeaderFilterStrategy ; public class XmppComponent extends DefaultComponent < XmppExchange > implements HeaderFilterStrategyAware { private HeaderFilterStrategy headerFilterStrategy = new DefaultHeaderFilterStrategy ( ) ; public XmppComponent ( ) { } public XmppComponent ( CamelContext context ) { super ( context ) ; } public static XmppComponent xmppComponent ( ) { return new XmppComponent ( ) ; } @ Override protected Endpoint < XmppExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { XmppEndpoint endpoint = new XmppEndpoint ( uri , this ) ; URI u = new URI ( uri ) ; endpoint . setHost ( u . getHost ( ) ) ; endpoint . setPort ( u . getPort ( ) ) ; if ( u . getUserInfo ( ) != null ) { endpoint . setUser ( u . getUserInfo ( ) ) ; } String remainingPath = u . getPath ( ) ; if ( remainingPath != null ) { if ( remainingPath . startsWith ( "/" ) ) { remainingPath = remainingPath . substring ( 1 ) ; } if ( remainingPath . length ( ) > 0 ) { endpoint . setParticipant ( remainingPath ) ; } } return endpoint ; } public HeaderFilterStrategy getHeaderFilterStrategy ( ) { return headerFilterStrategy ; } public void setHeaderFilterStrategy ( HeaderFilterStrategy strategy ) { headerFilterStrategy = strategy ; } } 	0	['6', '3', '0', '7', '22', '3', '1', '7', '5', '0.2', '82', '1', '1', '0.897435897', '0.3', '1', '1', '12.5', '1', '0.6667', '0']
package org . apache . camel . spi ; public interface Provider < T > { T get ( ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . bean ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . Processor ; import org . apache . camel . converter . ObjectConverter ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . impl . ProcessorEndpoint ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class BeanComponent extends DefaultComponent { private static final transient Log LOG = LogFactory . getLog ( BeanComponent . class ) ; private ParameterMappingStrategy parameterMappingStrategy ; public BeanComponent ( ) { } public ProcessorEndpoint createEndpoint ( Object bean ) { String uri = "bean:generated:" + bean ; return createEndpoint ( bean , uri ) ; } public ProcessorEndpoint createEndpoint ( Object bean , String uri ) { BeanProcessor processor = new BeanProcessor ( bean , getCamelContext ( ) , getParameterMappingStrategy ( ) ) ; return createEndpoint ( uri , processor ) ; } public ParameterMappingStrategy getParameterMappingStrategy ( ) { if ( parameterMappingStrategy == null ) { parameterMappingStrategy = createParameterMappingStrategy ( ) ; } return parameterMappingStrategy ; } public void setParameterMappingStrategy ( ParameterMappingStrategy parameterMappingStrategy ) { this . parameterMappingStrategy = parameterMappingStrategy ; } protected Endpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { BeanEndpoint endpoint = new BeanEndpoint ( uri , this ) ; endpoint . setBeanName ( remaining ) ; endpoint . setCache ( ObjectConverter . toBool ( parameters . remove ( "cache" ) ) ) ; Processor processor = endpoint . getProcessor ( ) ; setProperties ( processor , parameters ) ; return endpoint ; } protected BeanEndpoint createEndpoint ( String uri , BeanProcessor processor ) { return new BeanEndpoint ( uri , this , processor ) ; } protected ParameterMappingStrategy createParameterMappingStrategy ( ) { return BeanInfo . createParameterMappingStrategy ( getCamelContext ( ) ) ; } } 	0	['9', '3', '0', '13', '26', '34', '0', '13', '5', '0.875', '95', '1', '1', '0.833333333', '0.333333333', '1', '2', '9.333333333', '2', '0.8889', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "expression" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ExpressionSubElementType { @ XmlElementRef private ExpressionType expressionType ; @ XmlTransient private Expression expression ; @ XmlTransient private Predicate predicate ; public ExpressionSubElementType ( ) { } public ExpressionSubElementType ( Expression expression ) { this . expression = expression ; } public ExpressionSubElementType ( Predicate predicate ) { this . predicate = predicate ; } public ExpressionType getExpressionType ( ) { return expressionType ; } public void setExpressionType ( ExpressionType expressionType ) { this . expressionType = expressionType ; } public Expression getExpression ( ) { return expression ; } public void setExpression ( Expression expression ) { this . expression = expression ; } public void setPredicate ( Predicate predicate ) { this . predicate = predicate ; } public Predicate getPredicate ( ) { return predicate ; } public Expression createExpression ( RouteContext routeContext ) { ExpressionType expressionType = getExpressionType ( ) ; if ( expressionType != null && expression == null ) { expression = expressionType . createExpression ( routeContext ) ; } return expression ; } public Predicate createPredicate ( RouteContext routeContext ) { ExpressionType expressionType = getExpressionType ( ) ; if ( expressionType != null && getPredicate ( ) == null ) { setPredicate ( expressionType . createPredicate ( routeContext ) ) ; } return getPredicate ( ) ; } } 	0	['11', '1', '0', '6', '14', '35', '2', '4', '11', '0.7', '82', '1', '3', '0', '0.327272727', '0', '0', '6.181818182', '3', '1.0909', '0']
package org . apache . camel . component . spring . integration ; import java . util . HashMap ; import java . util . Map ; import org . apache . camel . impl . DefaultMessage ; import org . springframework . integration . core . MessageHeaders ; public class SpringIntegrationMessage extends DefaultMessage { private org . springframework . integration . core . Message siMessage ; public SpringIntegrationMessage ( org . springframework . integration . core . Message message ) { siMessage = message ; } public SpringIntegrationMessage ( ) { } public void setMessage ( org . springframework . integration . core . Message message ) { siMessage = message ; } public org . springframework . integration . core . Message getMessage ( ) { return siMessage ; } @ Override public void copyFrom ( org . apache . camel . Message that ) { setMessageId ( that . getMessageId ( ) ) ; setBody ( that . getBody ( ) ) ; getHeaders ( ) . putAll ( that . getHeaders ( ) ) ; if ( that instanceof SpringIntegrationMessage ) { SpringIntegrationMessage orig = ( SpringIntegrationMessage ) that ; setMessage ( orig . getMessage ( ) ) ; } } @ Override public String toString ( ) { if ( siMessage != null ) { return "SpringIntegrationMessage: " + siMessage ; } else { return "SpringIntegrationMessage: " + getBody ( ) ; } } @ Override public SpringIntegrationExchange getExchange ( ) { return ( SpringIntegrationExchange ) super . getExchange ( ) ; } public Object getHeader ( String name ) { if ( siMessage != null ) { return siMessage . getHeaders ( ) . get ( name ) ; } else { return super . getHeader ( name ) ; } } @ Override public Map < String , Object > getHeaders ( ) { if ( siMessage != null ) { return siMessage . getHeaders ( ) ; } else { return super . getHeaders ( ) ; } } @ Override public SpringIntegrationMessage newInstance ( ) { return new SpringIntegrationMessage ( ) ; } @ Override protected Object createBody ( ) { return siMessage . getPayload ( ) ; } } 	0	['14', '3', '0', '8', '29', '49', '3', '6', '13', '0.461538462', '122', '1', '0', '0.744680851', '0.321428571', '2', '8', '7.642857143', '2', '1.1429', '0']
package org . apache . camel . processor . resequencer ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; public class DefaultExchangeComparator implements ExpressionResultComparator < Exchange > { private Expression < Exchange > expression ; public Expression < Exchange > getExpression ( ) { return expression ; } public void setExpression ( Expression < Exchange > expression ) { this . expression = expression ; } @ SuppressWarnings ( "unchecked" ) public void setExpressions ( List < Expression > expressions ) { if ( expressions . isEmpty ( ) ) { throw new IllegalArgumentException ( "Expression required to resolve sequence number" ) ; } else if ( expressions . size ( ) > 1 ) { throw new IllegalArgumentException ( "More than one expression currently not supported" ) ; } expression = expressions . get ( 0 ) ; } public boolean predecessor ( Exchange o1 , Exchange o2 ) { long n1 = getSequenceNumber ( o1 ) ; long n2 = getSequenceNumber ( o2 ) ; return n1 == ( n2 - 1L ) ; } public boolean successor ( Exchange o1 , Exchange o2 ) { long n1 = getSequenceNumber ( o1 ) ; long n2 = getSequenceNumber ( o2 ) ; return n2 == ( n1 - 1L ) ; } public int compare ( Exchange o1 , Exchange o2 ) { Long n1 = getSequenceNumber ( o1 ) ; Long n2 = getSequenceNumber ( o2 ) ; return n1 . compareTo ( n2 ) ; } private long getSequenceNumber ( Exchange exchange ) { return ( Long ) expression . evaluate ( exchange ) ; } } 	0	['11', '1', '0', '4', '20', '43', '1', '3', '10', '0.1', '124', '1', '1', '0', '0.363636364', '0', '0', '10.18181818', '3', '1.2727', '0']
package org . apache . camel . converter . jaxb ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "intHeader" ) @ XmlAccessorType ( value = XmlAccessType . FIELD ) public class IntegerHeader extends HeaderType { @ XmlAttribute ( name = "value" ) private Integer number ; public IntegerHeader ( ) { } public IntegerHeader ( String name , Integer number ) { super ( name ) ; this . number = number ; } public Integer getNumber ( ) { return number ; } public void setNumber ( Integer number ) { this . number = number ; } public Object getValue ( ) { return getNumber ( ) ; } public void setValue ( Object value ) { if ( value instanceof Number ) { Number n = ( Number ) value ; setNumber ( n . intValue ( ) ) ; } else { throw new IllegalArgumentException ( "Value must be an Integer" ) ; } } } 	0	['6', '2', '0', '2', '11', '9', '1', '1', '6', '0.2', '45', '1', '0', '0.5', '0.416666667', '0', '0', '6.333333333', '2', '0.8333', '0']
package org . apache . camel . processor . interceptor ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . NoTypeConversionAvailableException ; import org . apache . camel . converter . stream . StreamCache ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . spi . UnitOfWork ; import org . apache . camel . util . ObjectHelper ; public class TraceFormatter { private int breadCrumbLength ; private int nodeLength ; private boolean showBreadCrumb = true ; private boolean showNode = true ; private boolean showExchangeId ; private boolean showShortExchangeId ; private boolean showExchangePattern = true ; private boolean showProperties = true ; private boolean showHeaders = true ; private boolean showBody = true ; private boolean showBodyType = true ; private boolean showOutBody ; private boolean showOutBodyType ; private boolean showException = true ; public Object format ( TraceInterceptor interceptor , Exchange exchange ) { Message in = exchange . getIn ( ) ; Message out = exchange . getOut ( false ) ; Throwable exception = exchange . getException ( ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( getExchangeAndNode ( interceptor , exchange ) ) ; if ( showExchangePattern ) { sb . append ( ", Pattern:" ) . append ( exchange . getPattern ( ) ) . append ( " " ) ; } if ( showProperties && ! exchange . getProperties ( ) . isEmpty ( ) ) { sb . append ( ", Properties:" ) . append ( exchange . getProperties ( ) ) . append ( " " ) ; } if ( showHeaders && ! in . getHeaders ( ) . isEmpty ( ) ) { sb . append ( ", Headers:" ) . append ( in . getHeaders ( ) ) . append ( " " ) ; } if ( showBodyType ) { sb . append ( ", BodyType:" ) . append ( getBodyTypeAsString ( in ) ) . append ( " " ) ; } if ( showBody ) { sb . append ( ", Body:" ) . append ( getBodyAsString ( in ) ) . append ( " " ) ; } if ( showOutBodyType && out != null ) { sb . append ( ", OutBodyType:" ) . append ( getBodyTypeAsString ( out ) ) . append ( " " ) ; } if ( showOutBody && out != null ) { sb . append ( ", OutBody:" ) . append ( getBodyAsString ( out ) ) . append ( " " ) ; } if ( showException && exception != null ) { sb . append ( ", Exception:" ) . append ( exception ) ; } return sb . toString ( ) ; } public boolean isShowBody ( ) { return showBody ; } public void setShowBody ( boolean showBody ) { this . showBody = showBody ; } public boolean isShowBodyType ( ) { return showBodyType ; } public void setShowBodyType ( boolean showBodyType ) { this . showBodyType = showBodyType ; } public void setShowOutBody ( boolean showOutBody ) { this . showOutBody = showOutBody ; } public boolean isShowOutBody ( ) { return showOutBody ; } public void setShowOutBodyType ( boolean showOutBodyType ) { this . showOutBodyType = showOutBodyType ; } public boolean isShowOutBodyType ( ) { return showOutBodyType ; } public boolean isShowBreadCrumb ( ) { return showBreadCrumb ; } public void setShowBreadCrumb ( boolean showBreadCrumb ) { this . showBreadCrumb = showBreadCrumb ; } public boolean isShowExchangeId ( ) { return showExchangeId ; } public void setShowExchangeId ( boolean showExchangeId ) { this . showExchangeId = showExchangeId ; } public boolean isShowHeaders ( ) { return showHeaders ; } public void setShowHeaders ( boolean showHeaders ) { this . showHeaders = showHeaders ; } public boolean isShowProperties ( ) { return showProperties ; } public void setShowProperties ( boolean showProperties ) { this . showProperties = showProperties ; } public boolean isShowNode ( ) { return showNode ; } public void setShowNode ( boolean showNode ) { this . showNode = showNode ; } public boolean isShowExchangePattern ( ) { return showExchangePattern ; } public void setShowExchangePattern ( boolean showExchangePattern ) { this . showExchangePattern = showExchangePattern ; } public boolean isShowException ( ) { return showException ; } public void setShowException ( boolean showException ) { this . showException = showException ; } public int getBreadCrumbLength ( ) { return breadCrumbLength ; } public void setBreadCrumbLength ( int breadCrumbLength ) { this . breadCrumbLength = breadCrumbLength ; } public boolean isShowShortExchangeId ( ) { return showShortExchangeId ; } public void setShowShortExchangeId ( boolean showShortExchangeId ) { this . showShortExchangeId = showShortExchangeId ; } public int getNodeLength ( ) { return nodeLength ; } public void setNodeLength ( int nodeLength ) { this . nodeLength = nodeLength ; } protected Object getBreadCrumbID ( Exchange exchange ) { UnitOfWork unitOfWork = exchange . getUnitOfWork ( ) ; return unitOfWork . getId ( ) ; } protected Object getBodyAsString ( Message in ) { if ( in == null ) { return null ; } StreamCache newBody = null ; try { newBody = in . getBody ( StreamCache . class ) ; if ( newBody != null ) { in . setBody ( newBody ) ; } } catch ( NoTypeConversionAvailableException ex ) { } Object answer = null ; try { answer = in . getBody ( String . class ) ; } catch ( NoTypeConversionAvailableException ex ) { answer = in . getBody ( ) ; } if ( newBody != null ) { newBody . reset ( ) ; } return answer ; } protected Object getBodyTypeAsString ( Message message ) { if ( message == null ) { return null ; } String answer = ObjectHelper . classCanonicalName ( message . getBody ( ) ) ; if ( answer != null && answer . startsWith ( "java.lang." ) ) { return answer . substring ( 10 ) ; } return answer ; } protected String getNodeMessage ( TraceInterceptor interceptor ) { String message = interceptor . getNode ( ) . getShortName ( ) + "(" + interceptor . getNode ( ) . getLabel ( ) + ")" ; if ( nodeLength > 0 ) { return String . format ( "%1$-" + nodeLength + "." + nodeLength + "s" , message ) ; } else { return message ; } } protected String getExchangeAndNode ( TraceInterceptor interceptor , Exchange exchange ) { String id = "" ; String node = "" ; String result ; if ( ! showBreadCrumb && ! showExchangeId && ! showShortExchangeId && ! showNode ) { return "" ; } if ( showBreadCrumb ) { id = getBreadCrumbID ( exchange ) . toString ( ) ; } else if ( showExchangeId || showShortExchangeId ) { id = getBreadCrumbID ( exchange ) . toString ( ) ; if ( showShortExchangeId ) { id = id . substring ( id . indexOf ( "/" ) + 1 ) ; } } if ( showNode ) { node = getNodeMessage ( interceptor ) ; } if ( interceptor . shouldTraceOutExchanges ( ) && exchange . getOut ( false ) != null ) { result = node . trim ( ) + " -> " + id . trim ( ) ; } else { result = id . trim ( ) + " -> " + node . trim ( ) ; } if ( breadCrumbLength > 0 ) { return String . format ( "%1$-" + breadCrumbLength + "." + breadCrumbLength + "s" , result ) . trim ( ) ; } else { return result . trim ( ) ; } } } 	0	['35', '1', '0', '13', '65', '475', '5', '9', '30', '0.911764706', '537', '1', '0', '0', '0.271428571', '0', '0', '13.94285714', '14', '1.8571', '0']
package org . apache . camel . component . cxf . transport ; public final class CamelTransportConstants { public static final String TEXT_MESSAGE_TYPE = "text" ; public static final String BINARY_MESSAGE_TYPE = "binary" ; public static final String CAMEL_TARGET_ENDPOINT_URI = "org.apache.cxf.camel.target.endpoint.uri" ; public static final String CAMEL_SERVER_REQUEST_HEADERS = "org.apache.cxf.camel.server.request.headers" ; public static final String CAMEL_SERVER_RESPONSE_HEADERS = "org.apache.cxf.camel.server.response.headers" ; public static final String CAMEL_REQUEST_MESSAGE = "org.apache.cxf.camel.request.message" ; public static final String CAMEL_RESPONSE_MESSAGE = "org.apache.cxf.camel.reponse.message" ; public static final String CAMEL_CLIENT_REQUEST_HEADERS = "org.apache.cxf.camel.template.request.headers" ; public static final String CAMEL_CLIENT_RESPONSE_HEADERS = "org.apache.cxf.camel.template.response.headers" ; public static final String CAMEL_CLIENT_RECEIVE_TIMEOUT = "org.apache.cxf.camel.template.timeout" ; public static final String CAMEL_SERVER_CONFIGURATION_URI = "http://cxf.apache.org/configuration/transport/camel-server" ; public static final String CAMEL_CLIENT_CONFIGURATION_URI = "http://cxf.apache.org/configuration/transport/camel-template" ; public static final String ENDPOINT_CONFIGURATION_URI = "http://cxf.apache.org/jaxws/endpoint-config" ; public static final String SERVICE_CONFIGURATION_URI = "http://cxf.apache.org/jaxws/service-config" ; public static final String PORT_CONFIGURATION_URI = "http://cxf.apache.org/jaxws/port-config" ; public static final String CAMEL_CLIENT_CONFIG_ID = "camel-template" ; public static final String CAMEL_SERVER_CONFIG_ID = "camel-server" ; public static final String CAMEL_REBASED_REPLY_TO = "org.apache.cxf.camel.server.replyto" ; public static final String CAMEL_CORRELATION_ID = "org.apache.cxf.camel.correlationId" ; public static final String CONTENT_TYPE = "content.type" ; private CamelTransportConstants ( ) { } } 	0	['1', '1', '0', '0', '2', '0', '0', '0', '0', '2', '24', '0', '0', '0', '1', '0', '0', '3', '0', '0', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Processor ; import org . apache . camel . processor . DelegateProcessor ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "interceptor" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class InterceptorRef extends InterceptorType { @ XmlAttribute ( required = true ) private String ref ; @ XmlTransient private DelegateProcessor interceptor ; public InterceptorRef ( ) { } public InterceptorRef ( String ref ) { setRef ( ref ) ; } public InterceptorRef ( DelegateProcessor interceptor ) { this . interceptor = interceptor ; } @ Override public String toString ( ) { return "Interceptor[" + getLabel ( ) + "]" ; } @ Override public String getShortName ( ) { return "interceptor" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { DelegateProcessor processor = createInterceptor ( routeContext ) ; Processor child = createOutputsProcessor ( routeContext ) ; processor . setProcessor ( child ) ; return processor ; } public DelegateProcessor createInterceptor ( RouteContext routeContext ) { if ( interceptor == null ) { interceptor = routeContext . lookup ( getRef ( ) , DelegateProcessor . class ) ; } if ( interceptor == null ) { throw new IllegalArgumentException ( "No DelegateProcessor bean available for reference: " + getRef ( ) ) ; } return interceptor ; } public String getRef ( ) { return ref ; } public void setRef ( String ref ) { this . ref = ref ; } public String getLabel ( ) { if ( ref != null ) { return "ref:  " + ref ; } else if ( interceptor != null ) { return interceptor . toString ( ) ; } else { return "" ; } } @ XmlTransient public DelegateProcessor getInterceptor ( ) { return interceptor ; } } 	0	['11', '5', '1', '10', '20', '37', '6', '4', '11', '0.5', '117', '1', '1', '0.957446809', '0.363636364', '1', '3', '9.454545455', '3', '1.0909', '0']
package org . apache . camel . language . constant ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . builder . ExpressionBuilder ; import org . apache . camel . builder . PredicateBuilder ; import org . apache . camel . spi . Language ; public class ConstantLanguage implements Language { public static Expression < Exchange > constant ( Object value ) { return ExpressionBuilder . constantExpression ( value ) ; } public Predicate < Exchange > createPredicate ( String expression ) { return PredicateBuilder . toPredicate ( createExpression ( expression ) ) ; } public Expression < Exchange > createExpression ( String expression ) { return ConstantLanguage . constant ( expression ) ; } } 	0	['4', '1', '0', '7', '7', '6', '2', '5', '4', '2', '18', '0', '0', '0', '0.5', '0', '0', '3.5', '1', '0.75', '0']
package org . apache . camel . component . xmpp ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . jivesoftware . smack . Chat ; import org . jivesoftware . smack . MessageListener ; import org . jivesoftware . smack . PacketListener ; import org . jivesoftware . smack . SmackConfiguration ; import org . jivesoftware . smack . packet . Message ; import org . jivesoftware . smack . packet . Packet ; import org . jivesoftware . smackx . muc . DiscussionHistory ; import org . jivesoftware . smackx . muc . MultiUserChat ; public class XmppConsumer extends DefaultConsumer < XmppExchange > implements PacketListener , MessageListener { private static final transient Log LOG = LogFactory . getLog ( XmppConsumer . class ) ; private final XmppEndpoint endpoint ; private Chat privateChat ; private MultiUserChat muc ; public XmppConsumer ( XmppEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; } @ Override protected void doStart ( ) throws Exception { if ( endpoint . getRoom ( ) == null ) { privateChat = endpoint . getConnection ( ) . getChatManager ( ) . createChat ( endpoint . getParticipant ( ) , this ) ; LOG . info ( "Open chat to " + privateChat . getParticipant ( ) ) ; } else { muc = new MultiUserChat ( endpoint . getConnection ( ) , endpoint . resolveRoom ( ) ) ; muc . addMessageListener ( this ) ; DiscussionHistory history = new DiscussionHistory ( ) ; history . setMaxChars ( 0 ) ; muc . join ( endpoint . getNickname ( ) , null , history , SmackConfiguration . getPacketReplyTimeout ( ) ) ; LOG . info ( "Joined room: " + muc . getRoom ( ) ) ; } super . doStart ( ) ; } @ Override protected void doStop ( ) throws Exception { super . doStop ( ) ; if ( muc != null ) { muc . leave ( ) ; muc = null ; } } public void processPacket ( Packet packet ) { Message message = ( Message ) packet ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Recieved XMPP message: " + message . getBody ( ) ) ; } XmppExchange exchange = endpoint . createExchange ( message ) ; try { getProcessor ( ) . process ( exchange ) ; } catch ( Exception e ) { LOG . error ( "Error while processing message" , e ) ; } } public void processMessage ( Chat chat , Message message ) { processPacket ( message ) ; } } 	0	['6', '3', '0', '18', '37', '3', '1', '18', '3', '0.65', '146', '1', '1', '0.851851852', '0.333333333', '1', '1', '22.66666667', '2', '0.8333', '0']
package org . apache . camel ; import org . apache . camel . impl . DefaultProducerTemplate ; @ Deprecated public class CamelTemplate < E extends Exchange > extends DefaultProducerTemplate < E > { public CamelTemplate ( CamelContext context ) { super ( context ) ; } public CamelTemplate ( CamelContext context , Endpoint defaultEndpoint ) { super ( context , defaultEndpoint ) ; } } 	0	['2', '3', '0', '3', '4', '1', '0', '3', '2', '2', '11', '0', '0', '1', '0.833333333', '0', '0', '4.5', '0', '0', '0']
package org . apache . camel . component . validator . jing ; import java . util . Map ; public class RelaxNGCompactSyntaxComponent extends JingComponent { protected void configureValidator ( JingValidator validator , String uri , String remaining , Map parameters ) throws Exception { validator . setCompactSyntax ( true ) ; super . configureValidator ( validator , uri , remaining , parameters ) ; } } 	0	['2', '5', '0', '2', '5', '1', '0', '2', '1', '2', '15', '0', '0', '0.975609756', '0.625', '1', '1', '6.5', '1', '0.5', '0']
package org . apache . camel . builder . xml ; import java . io . StringWriter ; import javax . xml . transform . Result ; import javax . xml . transform . stream . StreamResult ; import org . apache . camel . Message ; public class StringResultHandler implements ResultHandler { StringWriter buffer = new StringWriter ( ) ; StreamResult result = new StreamResult ( buffer ) ; public Result getResult ( ) { return result ; } public void setBody ( Message in ) { in . setBody ( buffer . toString ( ) ) ; } } 	0	['3', '1', '0', '3', '8', '0', '1', '2', '3', '0.5', '29', '0', '0', '0', '0.666666667', '0', '0', '8', '1', '0.6667', '0']
package org . apache . camel . component . jhc ; import java . io . IOException ; import java . io . InputStream ; import java . io . UnsupportedEncodingException ; import org . apache . camel . Converter ; import org . apache . http . HttpEntity ; import org . apache . http . entity . InputStreamEntity ; import org . apache . http . entity . StringEntity ; import org . apache . http . util . EntityUtils ; @ Converter public final class JhcConverter { private JhcConverter ( ) { } @ Converter public static InputStream toInputStream ( HttpEntity entity ) throws IOException { return entity . getContent ( ) ; } @ Converter public static byte [ ] toByteArray ( HttpEntity entity ) throws IOException { return EntityUtils . toByteArray ( entity ) ; } @ Converter public static String toString ( HttpEntity entity ) throws IOException { return EntityUtils . toString ( entity ) ; } @ Converter public static HttpEntity toEntity ( InputStream is ) { return new InputStreamEntity ( is , - 1 ) ; } @ Converter public static HttpEntity toEntity ( String str ) throws UnsupportedEncodingException { return new StringEntity ( str ) ; } } 	0	['6', '1', '0', '4', '12', '15', '0', '4', '5', '2', '29', '0', '0', '0', '0.25', '0', '0', '3.833333333', '1', '0.8333', '0']
package org . apache . camel . component . cxf . interceptors ; import java . io . InputStream ; import java . io . OutputStream ; import org . apache . commons . io . IOUtils ; import org . apache . cxf . interceptor . Fault ; import org . apache . cxf . message . Message ; import org . apache . cxf . phase . AbstractPhaseInterceptor ; import org . apache . cxf . phase . Phase ; public class RawMessageContentRedirectInterceptor extends AbstractPhaseInterceptor < Message > { public RawMessageContentRedirectInterceptor ( ) { super ( Phase . WRITE ) ; } public void handleMessage ( Message message ) throws Fault { Throwable ex = message . getContent ( Throwable . class ) ; if ( ex != null ) { if ( ex instanceof Fault ) { throw ( Fault ) ex ; } else { throw new Fault ( ex ) ; } } InputStream is = message . getContent ( InputStream . class ) ; OutputStream os = message . getContent ( OutputStream . class ) ; try { IOUtils . copy ( is , os ) ; is . close ( ) ; os . flush ( ) ; } catch ( Exception e ) { throw new Fault ( e ) ; } } } 	0	['2', '0', '0', '5', '8', '1', '1', '4', '2', '2', '50', '0', '0', '0', '0.75', '0', '0', '24', '1', '0.5', '0']
@ javax . xml . bind . annotation . XmlSchema ( namespace = "http://activemq.apache.org/camel/schema/spring" , elementFormDefault = javax . xml . bind . annotation . XmlNsForm . QUALIFIED ) package org . apache . camel ; 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . component . jpa ; import java . lang . reflect . Method ; import java . util . List ; import javax . persistence . EntityManager ; import javax . persistence . LockModeType ; import javax . persistence . PersistenceException ; import javax . persistence . Query ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . ScheduledPollConsumer ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . orm . jpa . JpaCallback ; public class JpaConsumer extends ScheduledPollConsumer < Exchange > { private static final transient Log LOG = LogFactory . getLog ( JpaConsumer . class ) ; private final JpaEndpoint endpoint ; private final TransactionStrategy template ; private QueryFactory queryFactory ; private DeleteHandler < Object > deleteHandler ; private String query ; private String namedQuery ; private String nativeQuery ; public JpaConsumer ( JpaEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; this . template = endpoint . createTransactionStrategy ( ) ; } protected void poll ( ) throws Exception { template . execute ( new JpaCallback ( ) { public Object doInJpa ( EntityManager entityManager ) throws PersistenceException { Query query = getQueryFactory ( ) . createQuery ( entityManager ) ; configureParameters ( query ) ; List results = query . getResultList ( ) ; for ( Object result : results ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Processing new entity: " + result ) ; } if ( lockEntity ( result , entityManager ) ) { Exchange exchange = createExchange ( result ) ; try { getProcessor ( ) . process ( exchange ) ; } catch ( Exception e ) { throw new PersistenceException ( e ) ; } getDeleteHandler ( ) . deleteObject ( entityManager , result ) ; } } entityManager . flush ( ) ; return null ; } } ) ; } public JpaEndpoint getEndpoint ( ) { return endpoint ; } public QueryFactory getQueryFactory ( ) { if ( queryFactory == null ) { queryFactory = createQueryFactory ( ) ; if ( queryFactory == null ) { throw new IllegalArgumentException ( "No queryType property configured on this consumer, nor an entityType configured on the endpoint so cannot consume" ) ; } } return queryFactory ; } public void setQueryFactory ( QueryFactory queryFactory ) { this . queryFactory = queryFactory ; } public DeleteHandler getDeleteHandler ( ) { if ( deleteHandler == null ) { deleteHandler = createDeleteHandler ( ) ; } return deleteHandler ; } public void setDeleteHandler ( DeleteHandler deleteHandler ) { this . deleteHandler = deleteHandler ; } public String getNamedQuery ( ) { return namedQuery ; } public void setNamedQuery ( String namedQuery ) { this . namedQuery = namedQuery ; } public String getNativeQuery ( ) { return nativeQuery ; } public void setNativeQuery ( String nativeQuery ) { this . nativeQuery = nativeQuery ; } public String getQuery ( ) { return query ; } public void setQuery ( String query ) { this . query = query ; } protected boolean lockEntity ( Object entity , EntityManager entityManager ) { if ( ! getEndpoint ( ) . isConsumeDelete ( ) || ! getEndpoint ( ) . isConsumeLockEntity ( ) ) { return true ; } try { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Acquiring exclusive lock on entity: " + entity ) ; } entityManager . lock ( entity , LockModeType . WRITE ) ; return true ; } catch ( Exception e ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Failed to achieve lock on entity: " + entity + ". Reason: " + e , e ) ; } return false ; } } protected QueryFactory createQueryFactory ( ) { if ( query != null ) { return QueryBuilder . query ( query ) ; } else if ( namedQuery != null ) { return QueryBuilder . namedQuery ( namedQuery ) ; } else if ( nativeQuery != null ) { return QueryBuilder . nativeQuery ( nativeQuery ) ; } else { Class < ? > entityType = endpoint . getEntityType ( ) ; if ( entityType == null ) { return null ; } else { return QueryBuilder . query ( "select x from " + entityType . getName ( ) + " x" ) ; } } } protected DeleteHandler < Object > createDeleteHandler ( ) { Class < ? > entityType = getEndpoint ( ) . getEntityType ( ) ; if ( entityType != null ) { List < Method > methods = ObjectHelper . findMethodsWithAnnotation ( entityType , Consumed . class ) ; if ( methods . size ( ) > 1 ) { throw new IllegalArgumentException ( "Only one method can be annotated with the @Consumed annotation but found: " + methods ) ; } else if ( methods . size ( ) == 1 ) { final Method method = methods . get ( 0 ) ; return new DeleteHandler < Object > ( ) { public void deleteObject ( EntityManager entityManager , Object entityBean ) { ObjectHelper . invokeMethod ( method , entityBean ) ; } } ; } } if ( getEndpoint ( ) . isConsumeDelete ( ) ) { return new DeleteHandler < Object > ( ) { public void deleteObject ( EntityManager entityManager , Object entityBean ) { entityManager . remove ( entityBean ) ; } } ; } else { return new DeleteHandler < Object > ( ) { public void deleteObject ( EntityManager entityManager , Object entityBean ) { } } ; } } protected void configureParameters ( Query query ) { int maxResults = endpoint . getMaximumResults ( ) ; if ( maxResults > 0 ) { query . setMaxResults ( maxResults ) ; } } protected Exchange createExchange ( Object result ) { Exchange exchange = endpoint . createExchange ( ) ; exchange . getIn ( ) . setBody ( result ) ; return exchange ; } } 	0	['21', '4', '0', '19', '52', '160', '5', '19', '13', '0.8625', '287', '1', '4', '0.648148148', '0.166666667', '1', '2', '12.28571429', '5', '1.6667', '0']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "python" ) public class PythonExpression extends ExpressionType { public PythonExpression ( ) { } public PythonExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "python" ; } } 	0	['3', '2', '0', '1', '5', '3', '0', '1', '3', '2', '12', '0', '0', '0.956521739', '0.666666667', '1', '2', '3', '1', '0.3333', '0']
package org . apache . camel . management ; import java . io . IOException ; import org . apache . camel . Service ; import org . apache . camel . impl . ServiceSupport ; import org . springframework . jmx . export . annotation . ManagedAttribute ; import org . springframework . jmx . export . annotation . ManagedOperation ; import org . springframework . jmx . export . annotation . ManagedResource ; @ ManagedResource ( description = "Managed Service" , currencyTimeLimit = 15 ) public class ManagedService { private ServiceSupport service ; public ManagedService ( ServiceSupport service ) { this . service = service ; } public Service getService ( ) { return service ; } @ ManagedAttribute ( description = "Service running state" ) public boolean isStarted ( ) throws IOException { return service . isStarted ( ) ; } @ ManagedOperation ( description = "Start Service" ) public void start ( ) throws IOException { try { service . start ( ) ; } catch ( Exception e ) { throw new IOException ( e . getMessage ( ) ) ; } } @ ManagedOperation ( description = "Stop Service" ) public void stop ( ) throws IOException { try { service . stop ( ) ; } catch ( Exception e ) { throw new IOException ( e . getMessage ( ) ) ; } } } 	0	['5', '1', '0', '4', '11', '0', '2', '2', '5', '0', '43', '1', '1', '0', '0.6', '0', '0', '7.4', '1', '0.8', '0']
package org . apache . camel . component . file . strategy ; import java . io . File ; import java . io . IOException ; import org . apache . camel . component . file . FileEndpoint ; import org . apache . camel . component . file . FileExchange ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DeleteFileProcessStrategy extends FileProcessStrategySupport { private static final transient Log LOG = LogFactory . getLog ( DeleteFileProcessStrategy . class ) ; public DeleteFileProcessStrategy ( ) { } public DeleteFileProcessStrategy ( boolean lockFile ) { super ( lockFile ) ; } @ Override public void commit ( FileEndpoint endpoint , FileExchange exchange , File file ) throws Exception { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Deleting file: " + file ) ; } boolean deleted = file . delete ( ) ; if ( ! deleted ) { throw new IOException ( "Can not delete file: " + file ) ; } super . commit ( endpoint , exchange , file ) ; } } 	0	['4', '2', '0', '6', '16', '4', '1', '5', '3', '0.666666667', '52', '1', '0', '0.888888889', '0.466666667', '0', '0', '11.75', '1', '0.25', '0']
package org . apache . camel . component . atom ; import java . text . DateFormat ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Date ; import org . apache . camel . Converter ; @ Converter public final class AtomConverter { public static final String DATE_PATTERN_NO_TIMEZONE = "yyyy-MM-dd'T'HH:mm:ss" ; private AtomConverter ( ) { } @ Converter public static Date toDate ( String text ) throws ParseException { DateFormat sdf = new SimpleDateFormat ( DATE_PATTERN_NO_TIMEZONE ) ; return sdf . parse ( text ) ; } } 	0	['2', '1', '0', '0', '5', '1', '0', '0', '1', '2', '15', '0', '0', '0', '0.5', '0', '0', '6', '1', '0.5', '0']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "simple" ) public class SimpleExpression extends ExpressionType { public SimpleExpression ( ) { } public SimpleExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "simple" ; } } 	0	['3', '2', '0', '1', '5', '3', '0', '1', '3', '2', '12', '0', '0', '0.956521739', '0.666666667', '1', '2', '3', '1', '0.3333', '0']
package org . apache . camel ; public interface Consumer < E extends Exchange > extends Service { } 	0	['0', '1', '0', '46', '0', '0', '45', '1', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . component . jms ; import javax . jms . Message ; import org . apache . camel . impl . PollingConsumerSupport ; import org . springframework . jms . core . JmsOperations ; import org . springframework . jms . core . JmsTemplate ; import org . springframework . jms . core . JmsTemplate102 ; public class JmsPollingConsumer extends PollingConsumerSupport < JmsExchange > { private JmsOperations template ; public JmsPollingConsumer ( JmsEndpoint endpoint , JmsOperations template ) { super ( endpoint ) ; this . template = template ; } @ Override public JmsEndpoint getEndpoint ( ) { return ( JmsEndpoint ) super . getEndpoint ( ) ; } public JmsExchange receiveNoWait ( ) { return receive ( 0 ) ; } public JmsExchange receive ( ) { return receive ( - 1 ) ; } public JmsExchange receive ( long timeout ) { setReceiveTimeout ( timeout ) ; Message message = template . receive ( ) ; if ( message != null ) { return getEndpoint ( ) . createExchange ( message ) ; } return null ; } protected void doStart ( ) throws Exception { } protected void doStop ( ) throws Exception { } protected void setReceiveTimeout ( long timeout ) { if ( template instanceof JmsTemplate ) { JmsTemplate jmsTemplate = ( JmsTemplate ) template ; jmsTemplate . setReceiveTimeout ( timeout ) ; } else if ( template instanceof JmsTemplate102 ) { JmsTemplate102 jmsTemplate102 = ( JmsTemplate102 ) template ; jmsTemplate102 . setReceiveTimeout ( timeout ) ; } else { throw new IllegalArgumentException ( "Cannot set the receiveTimeout property on unknown JmsOperations type: " + template ) ; } } } 	0	['12', '3', '0', '8', '19', '60', '1', '8', '9', '0.363636364', '101', '1', '0', '0.633333333', '0.354166667', '1', '1', '7.333333333', '3', '1.1667', '0']
package org . apache . camel . view ; import java . io . PrintWriter ; import java . util . List ; import java . util . Map ; import java . util . Set ; import org . apache . camel . model . FromType ; import org . apache . camel . model . InterceptorRef ; import org . apache . camel . model . MulticastType ; import org . apache . camel . model . PipelineType ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . model . RouteType ; import org . apache . camel . model . ToType ; import static org . apache . camel . util . ObjectHelper . isNotNullAndNonEmpty ; public class RouteDotGenerator extends GraphGeneratorSupport { public RouteDotGenerator ( String dir ) { super ( dir , ".dot" ) ; } protected void printRoutes ( PrintWriter writer , Map < String , List < RouteType > > map ) { Set < Map . Entry < String , List < RouteType > > > entries = map . entrySet ( ) ; for ( Map . Entry < String , List < RouteType > > entry : entries ) { String group = entry . getKey ( ) ; printRoutes ( writer , group , entry . getValue ( ) ) ; } } protected void printRoutes ( PrintWriter writer , String group , List < RouteType > routes ) { if ( group != null ) { writer . println ( "subgraph cluster_" + ( clusterCounter ++ ) + " {" ) ; writer . println ( "label = \"" + group + "\";" ) ; writer . println ( "color = grey;" ) ; writer . println ( "style = \"dashed\";" ) ; writer . println ( "URL = \"" + group + ".html\";" ) ; writer . println ( ) ; } for ( RouteType route : routes ) { List < FromType > inputs = route . getInputs ( ) ; for ( FromType input : inputs ) { printRoute ( writer , route , input ) ; } writer . println ( ) ; } if ( group != null ) { writer . println ( "}" ) ; writer . println ( ) ; } } protected String escapeNodeId ( String text ) { return text . replace ( '.' , '_' ) . replace ( "$" , "_" ) ; } protected void printRoute ( PrintWriter writer , final RouteType route , FromType input ) { NodeData nodeData = getNodeData ( input ) ; printNode ( writer , nodeData ) ; NodeData from = nodeData ; for ( ProcessorType output : route . getOutputs ( ) ) { NodeData newData = printNode ( writer , from , output ) ; from = newData ; } } protected NodeData printNode ( PrintWriter writer , NodeData fromData , ProcessorType node ) { if ( node instanceof MulticastType || node instanceof InterceptorRef ) { List < ProcessorType > outputs = node . getOutputs ( ) ; boolean isPipeline = isPipeline ( node ) ; for ( ProcessorType output : outputs ) { NodeData out = printNode ( writer , fromData , output ) ; if ( isPipeline ) { fromData = out ; } } return fromData ; } NodeData toData = getNodeData ( node ) ; printNode ( writer , toData ) ; if ( fromData != null ) { writer . print ( fromData . id ) ; writer . print ( " -> " ) ; writer . print ( toData . id ) ; writer . println ( " [" ) ; String label = fromData . edgeLabel ; if ( isNotNullAndNonEmpty ( label ) ) { writer . println ( "label = \"" + label + "\"" ) ; } writer . println ( "];" ) ; } List < ProcessorType > outputs = toData . outputs ; if ( outputs != null ) { for ( ProcessorType output : outputs ) { NodeData newData = printNode ( writer , toData , output ) ; if ( ! isMulticastNode ( node ) ) { toData = newData ; } } } return toData ; } protected void printNode ( PrintWriter writer , NodeData data ) { if ( ! data . nodeWritten ) { data . nodeWritten = true ; writer . println ( ) ; writer . print ( data . id ) ; writer . println ( " [" ) ; writer . println ( "label = \"" + data . label + "\"" ) ; writer . println ( "tooltip = \"" + data . tooltop + "\"" ) ; if ( data . url != null ) { writer . println ( "URL = \"" + data . url + "\"" ) ; } String image = data . image ; if ( image != null ) { writer . println ( "shapefile = \"" + image + "\"" ) ; writer . println ( "peripheries=0" ) ; } String shape = data . shape ; if ( shape == null && image != null ) { shape = "custom" ; } if ( shape != null ) { writer . println ( "shape = \"" + shape + "\"" ) ; } writer . println ( "];" ) ; writer . println ( ) ; } } protected void generateFile ( PrintWriter writer , Map < String , List < RouteType > > map ) { writer . println ( "digraph CamelRoutes {" ) ; writer . println ( ) ; writer . println ( "node [style = \"rounded,filled\", fillcolor = yellow, " + "fontname=\"Helvetica-Oblique\"];" ) ; writer . println ( ) ; printRoutes ( writer , map ) ; writer . println ( "}" ) ; } private static boolean isPipeline ( ProcessorType node ) { if ( node instanceof MulticastType ) { return false ; } if ( node instanceof PipelineType ) { return true ; } if ( node . getOutputs ( ) . size ( ) > 1 ) { for ( Object type : node . getOutputs ( ) ) { if ( ! ( type instanceof ToType ) ) { return false ; } } return true ; } return false ; } } 	0	['9', '2', '0', '11', '33', '36', '1', '10', '1', '2', '440', '0', '0', '0.555555556', '0.320987654', '1', '1', '47.88888889', '8', '3.4444', '0']
package org . apache . camel . builder . xml ; import javax . xml . xpath . XPathException ; import org . apache . camel . RuntimeExpressionException ; public class InvalidXPathExpression extends RuntimeExpressionException { private final String xpath ; public InvalidXPathExpression ( String xpath , XPathException e ) { super ( "Invalid xpath: " + xpath + ". Reason: " + e , e ) ; this . xpath = xpath ; } public String getXpath ( ) { return xpath ; } } 	0	['2', '6', '0', '2', '7', '0', '1', '1', '2', '0', '25', '1', '0', '0.944444444', '0.666666667', '0', '0', '11', '1', '0.5', '0']
package org . apache . camel . component . cxf . feature ; import java . util . concurrent . Executor ; import org . apache . camel . component . cxf . MessageInvoker ; import org . apache . cxf . endpoint . Endpoint ; import org . apache . cxf . message . Exchange ; import org . apache . cxf . message . Message ; import org . apache . cxf . phase . AbstractPhaseInterceptor ; import org . apache . cxf . phase . Phase ; import org . apache . cxf . service . Service ; public class MessageInvokerInterceptor extends AbstractPhaseInterceptor < Message > { public MessageInvokerInterceptor ( ) { super ( Phase . INVOKE ) ; } public void handleMessage ( final Message message ) { final Exchange exchange = message . getExchange ( ) ; final Endpoint endpoint = exchange . get ( Endpoint . class ) ; final Service service = endpoint . getService ( ) ; final MessageInvoker invoker = ( MessageInvoker ) service . getInvoker ( ) ; Runnable invocation = new Runnable ( ) { public void run ( ) { Exchange runableEx = message . getExchange ( ) ; invoker . invoke ( runableEx ) ; if ( ! exchange . isOneWay ( ) ) { Endpoint ep = exchange . get ( Endpoint . class ) ; Message outMessage = runableEx . getOutMessage ( ) ; copyJaxwsProperties ( message , outMessage ) ; if ( outMessage == null ) { outMessage = ep . getBinding ( ) . createMessage ( ) ; exchange . setOutMessage ( outMessage ) ; } } } } ; Executor executor = getExecutor ( endpoint ) ; if ( exchange . get ( Executor . class ) == executor ) { invocation . run ( ) ; } else { exchange . put ( Executor . class , executor ) ; executor . execute ( invocation ) ; } } private Executor getExecutor ( final Endpoint endpoint ) { return endpoint . getService ( ) . getExecutor ( ) ; } private void copyJaxwsProperties ( Message inMsg , Message outMsg ) { outMsg . put ( Message . WSDL_OPERATION , inMsg . get ( Message . WSDL_OPERATION ) ) ; outMsg . put ( Message . WSDL_SERVICE , inMsg . get ( Message . WSDL_SERVICE ) ) ; outMsg . put ( Message . WSDL_INTERFACE , inMsg . get ( Message . WSDL_INTERFACE ) ) ; outMsg . put ( Message . WSDL_PORT , inMsg . get ( Message . WSDL_PORT ) ) ; outMsg . put ( Message . WSDL_DESCRIPTION , inMsg . get ( Message . WSDL_DESCRIPTION ) ) ; } } 	0	['5', '0', '0', '9', '17', '10', '2', '8', '2', '2', '97', '0', '0', '0', '0.45', '0', '0', '18.4', '2', '1', '0']
package org . apache . camel . util . jndi ; import java . io . Serializable ; import java . util . HashMap ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . Map ; import javax . naming . Binding ; import javax . naming . CompositeName ; import javax . naming . Context ; import javax . naming . LinkRef ; import javax . naming . Name ; import javax . naming . NameClassPair ; import javax . naming . NameNotFoundException ; import javax . naming . NameParser ; import javax . naming . NamingEnumeration ; import javax . naming . NamingException ; import javax . naming . NotContextException ; import javax . naming . OperationNotSupportedException ; import javax . naming . Reference ; import javax . naming . spi . NamingManager ; import org . apache . camel . spi . Injector ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . ReflectionInjector ; public class JndiContext implements Context , Serializable { public static final String SEPARATOR = "/" ; protected static final NameParser NAME_PARSER = new NameParser ( ) { public Name parse ( String name ) throws NamingException { return new CompositeName ( name ) ; } } ; protected static final Injector INJETOR = new ReflectionInjector ( ) ; private static final long serialVersionUID = - 5754338187296859149L ; private final Hashtable environment ; private final Map bindings ; private final Map treeBindings ; private boolean frozen ; private String nameInNamespace = "" ; public JndiContext ( ) throws Exception { this ( new Hashtable ( ) ) ; } public JndiContext ( Hashtable env ) throws Exception { this ( env , createBindingsMapFromEnvironment ( env ) ) ; } public JndiContext ( Hashtable environment , Map bindings ) { if ( environment == null ) { this . environment = new Hashtable ( ) ; } else { this . environment = new Hashtable ( environment ) ; } this . bindings = bindings ; treeBindings = new HashMap ( ) ; } public JndiContext ( Hashtable environment , Map bindings , String nameInNamespace ) { this ( environment , bindings ) ; this . nameInNamespace = nameInNamespace ; } protected JndiContext ( JndiContext clone , Hashtable env ) { this . bindings = clone . bindings ; this . treeBindings = clone . treeBindings ; this . environment = new Hashtable ( env ) ; } protected JndiContext ( JndiContext clone , Hashtable env , String nameInNamespace ) { this ( clone , env ) ; this . nameInNamespace = nameInNamespace ; } public static Map createBindingsMapFromEnvironment ( Hashtable env ) throws Exception { Map answer = new HashMap ( env ) ; for ( Object object : env . entrySet ( ) ) { Map . Entry entry = ( Map . Entry ) object ; Object key = entry . getKey ( ) ; Object value = entry . getValue ( ) ; if ( key instanceof String && value instanceof String ) { String keyText = ( String ) key ; String valueText = ( String ) value ; if ( keyText . endsWith ( ".class" ) ) { Class < ? > type = ObjectHelper . loadClass ( valueText ) ; if ( type != null ) { String newEntry = keyText . substring ( 0 , keyText . length ( ) - ".class" . length ( ) ) ; Object bean = createBean ( type , answer , newEntry + "." ) ; if ( bean != null ) { answer . put ( newEntry , bean ) ; } } } } } return answer ; } public void freeze ( ) { frozen = true ; } boolean isFrozen ( ) { return frozen ; } protected Map internalBind ( String name , Object value ) throws NamingException { assert name != null && name . length ( ) > 0 ; assert ! frozen ; Map newBindings = new HashMap ( ) ; int pos = name . indexOf ( '/' ) ; if ( pos == - 1 ) { if ( treeBindings . put ( name , value ) != null ) { throw new NamingException ( "Something already bound at " + name ) ; } bindings . put ( name , value ) ; newBindings . put ( name , value ) ; } else { String segment = name . substring ( 0 , pos ) ; assert segment != null ; assert ! segment . equals ( "" ) ; Object o = treeBindings . get ( segment ) ; if ( o == null ) { o = newContext ( ) ; treeBindings . put ( segment , o ) ; bindings . put ( segment , o ) ; newBindings . put ( segment , o ) ; } else if ( ! ( o instanceof JndiContext ) ) { throw new NamingException ( "Something already bound where a subcontext should go" ) ; } JndiContext defaultContext = ( JndiContext ) o ; String remainder = name . substring ( pos + 1 ) ; Map subBindings = defaultContext . internalBind ( remainder , value ) ; for ( Iterator iterator = subBindings . entrySet ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) iterator . next ( ) ; String subName = segment + "/" + ( String ) entry . getKey ( ) ; Object bound = entry . getValue ( ) ; treeBindings . put ( subName , bound ) ; newBindings . put ( subName , bound ) ; } } return newBindings ; } protected JndiContext newContext ( ) { try { return new JndiContext ( ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( e ) ; } } public Object addToEnvironment ( String propName , Object propVal ) throws NamingException { return environment . put ( propName , propVal ) ; } public Hashtable getEnvironment ( ) throws NamingException { return ( Hashtable ) environment . clone ( ) ; } public Object removeFromEnvironment ( String propName ) throws NamingException { return environment . remove ( propName ) ; } public Object lookup ( String name ) throws NamingException { if ( name . length ( ) == 0 ) { return this ; } Object result = treeBindings . get ( name ) ; if ( result == null ) { result = bindings . get ( name ) ; } if ( result == null ) { int pos = name . indexOf ( ':' ) ; if ( pos > 0 ) { String scheme = name . substring ( 0 , pos ) ; Context ctx = NamingManager . getURLContext ( scheme , environment ) ; if ( ctx == null ) { throw new NamingException ( "scheme " + scheme + " not recognized" ) ; } return ctx . lookup ( name ) ; } else { CompositeName path = new CompositeName ( name ) ; if ( path . size ( ) == 0 ) { return this ; } else { String first = path . get ( 0 ) ; Object value = bindings . get ( first ) ; if ( value == null ) { throw new NameNotFoundException ( name ) ; } else if ( value instanceof Context && path . size ( ) > 1 ) { Context subContext = ( Context ) value ; value = subContext . lookup ( path . getSuffix ( 1 ) ) ; } return value ; } } } if ( result instanceof LinkRef ) { LinkRef ref = ( LinkRef ) result ; result = lookup ( ref . getLinkName ( ) ) ; } if ( result instanceof Reference ) { try { result = NamingManager . getObjectInstance ( result , null , null , this . environment ) ; } catch ( NamingException e ) { throw e ; } catch ( Exception e ) { throw ( NamingException ) new NamingException ( "could not look up : " + name ) . initCause ( e ) ; } } if ( result instanceof JndiContext ) { String prefix = getNameInNamespace ( ) ; if ( prefix . length ( ) > 0 ) { prefix = prefix + SEPARATOR ; } result = new JndiContext ( ( JndiContext ) result , environment , prefix + name ) ; } return result ; } public Object lookup ( Name name ) throws NamingException { return lookup ( name . toString ( ) ) ; } public Object lookupLink ( String name ) throws NamingException { return lookup ( name ) ; } public Name composeName ( Name name , Name prefix ) throws NamingException { Name result = ( Name ) prefix . clone ( ) ; result . addAll ( name ) ; return result ; } public String composeName ( String name , String prefix ) throws NamingException { CompositeName result = new CompositeName ( prefix ) ; result . addAll ( new CompositeName ( name ) ) ; return result . toString ( ) ; } public NamingEnumeration list ( String name ) throws NamingException { Object o = lookup ( name ) ; if ( o == this ) { return new ListEnumeration ( ) ; } else if ( o instanceof Context ) { return ( ( Context ) o ) . list ( "" ) ; } else { throw new NotContextException ( ) ; } } public NamingEnumeration listBindings ( String name ) throws NamingException { Object o = lookup ( name ) ; if ( o == this ) { return new ListBindingEnumeration ( ) ; } else if ( o instanceof Context ) { return ( ( Context ) o ) . listBindings ( "" ) ; } else { throw new NotContextException ( ) ; } } public Object lookupLink ( Name name ) throws NamingException { return lookupLink ( name . toString ( ) ) ; } public NamingEnumeration list ( Name name ) throws NamingException { return list ( name . toString ( ) ) ; } public NamingEnumeration listBindings ( Name name ) throws NamingException { return listBindings ( name . toString ( ) ) ; } public void bind ( Name name , Object value ) throws NamingException { bind ( name . toString ( ) , value ) ; } public void bind ( String name , Object value ) throws NamingException { if ( isFrozen ( ) ) { throw new OperationNotSupportedException ( ) ; } else { internalBind ( name , value ) ; } } public void close ( ) throws NamingException { } public Context createSubcontext ( Name name ) throws NamingException { throw new OperationNotSupportedException ( ) ; } public Context createSubcontext ( String name ) throws NamingException { throw new OperationNotSupportedException ( ) ; } public void destroySubcontext ( Name name ) throws NamingException { throw new OperationNotSupportedException ( ) ; } public void destroySubcontext ( String name ) throws NamingException { throw new OperationNotSupportedException ( ) ; } public String getNameInNamespace ( ) throws NamingException { return nameInNamespace ; } public NameParser getNameParser ( Name name ) throws NamingException { return NAME_PARSER ; } public NameParser getNameParser ( String name ) throws NamingException { return NAME_PARSER ; } public void rebind ( Name name , Object value ) throws NamingException { bind ( name , value ) ; } public void rebind ( String name , Object value ) throws NamingException { bind ( name , value ) ; } public void rename ( Name oldName , Name newName ) throws NamingException { throw new OperationNotSupportedException ( ) ; } public void rename ( String oldName , String newName ) throws NamingException { throw new OperationNotSupportedException ( ) ; } public void unbind ( Name name ) throws NamingException { throw new OperationNotSupportedException ( ) ; } public void unbind ( String name ) throws NamingException { bindings . remove ( name ) ; treeBindings . remove ( name ) ; } private abstract class LocalNamingEnumeration implements NamingEnumeration { private Iterator i = bindings . entrySet ( ) . iterator ( ) ; public boolean hasMore ( ) throws NamingException { return i . hasNext ( ) ; } public boolean hasMoreElements ( ) { return i . hasNext ( ) ; } protected Map . Entry getNext ( ) { return ( Map . Entry ) i . next ( ) ; } public void close ( ) throws NamingException { } } private class ListEnumeration extends LocalNamingEnumeration { ListEnumeration ( ) { } public Object next ( ) throws NamingException { return nextElement ( ) ; } public Object nextElement ( ) { Map . Entry entry = getNext ( ) ; return new NameClassPair ( ( String ) entry . getKey ( ) , entry . getValue ( ) . getClass ( ) . getName ( ) ) ; } } private class ListBindingEnumeration extends LocalNamingEnumeration { ListBindingEnumeration ( ) { } public Object next ( ) throws NamingException { return nextElement ( ) ; } public Object nextElement ( ) { Map . Entry entry = getNext ( ) ; return new Binding ( ( String ) entry . getKey ( ) , entry . getValue ( ) ) ; } } protected static Object createBean ( Class < ? > type , Map properties , String prefix ) throws Exception { Object value = INJETOR . newInstance ( type ) ; IntrospectionSupport . setProperties ( value , properties , prefix ) ; return value ; } } 	0	['43', '1', '0', '9', '101', '815', '4', '7', '35', '0.833333333', '792', '0.8', '1', '0', '0.261904762', '0', '0', '17.18604651', '1', '0.8372', '0']
package org . apache . camel . builder . script ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import org . apache . camel . language . LanguageAnnotation ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . PARAMETER } ) @ LanguageAnnotation ( language = "groovy" ) public @ interface Groovy { String value ( ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . converter . jaxp ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . Reader ; import java . io . Writer ; import javax . xml . stream . XMLEventReader ; import javax . xml . stream . XMLEventWriter ; import javax . xml . stream . XMLInputFactory ; import javax . xml . stream . XMLOutputFactory ; import javax . xml . stream . XMLStreamException ; import javax . xml . stream . XMLStreamReader ; import javax . xml . stream . XMLStreamWriter ; import javax . xml . transform . Result ; import javax . xml . transform . Source ; import org . apache . camel . Converter ; @ Converter public class StaxConverter { private XMLInputFactory inputFactory ; private XMLOutputFactory outputFactory ; @ Converter public XMLEventWriter createXMLEventWriter ( OutputStream out ) throws XMLStreamException { return getOutputFactory ( ) . createXMLEventWriter ( out ) ; } @ Converter public XMLEventWriter createXMLEventWriter ( Writer writer ) throws XMLStreamException { return getOutputFactory ( ) . createXMLEventWriter ( writer ) ; } @ Converter public XMLEventWriter createXMLEventWriter ( Result result ) throws XMLStreamException { return getOutputFactory ( ) . createXMLEventWriter ( result ) ; } @ Converter public XMLStreamWriter createXMLStreamWriter ( OutputStream outputStream ) throws XMLStreamException { return getOutputFactory ( ) . createXMLStreamWriter ( outputStream ) ; } @ Converter public XMLStreamWriter createXMLStreamWriter ( Writer writer ) throws XMLStreamException { return getOutputFactory ( ) . createXMLStreamWriter ( writer ) ; } @ Converter public XMLStreamWriter createXMLStreamWriter ( Result result ) throws XMLStreamException { return getOutputFactory ( ) . createXMLStreamWriter ( result ) ; } @ Converter public XMLStreamReader createXMLStreamReader ( InputStream in ) throws XMLStreamException { return getInputFactory ( ) . createXMLStreamReader ( in ) ; } @ Converter public XMLStreamReader createXMLStreamReader ( Reader in ) throws XMLStreamException { return getInputFactory ( ) . createXMLStreamReader ( in ) ; } @ Converter public XMLStreamReader createXMLStreamReader ( Source in ) throws XMLStreamException { return getInputFactory ( ) . createXMLStreamReader ( in ) ; } @ Converter public XMLEventReader createXMLEventReader ( InputStream in ) throws XMLStreamException { return getInputFactory ( ) . createXMLEventReader ( in ) ; } @ Converter public XMLEventReader createXMLEventReader ( Reader in ) throws XMLStreamException { return getInputFactory ( ) . createXMLEventReader ( in ) ; } @ Converter public XMLEventReader createXMLEventReader ( XMLStreamReader in ) throws XMLStreamException { return getInputFactory ( ) . createXMLEventReader ( in ) ; } @ Converter public XMLEventReader createXMLEventReader ( Source in ) throws XMLStreamException { return getInputFactory ( ) . createXMLEventReader ( in ) ; } public XMLInputFactory getInputFactory ( ) { if ( inputFactory == null ) { inputFactory = XMLInputFactory . newInstance ( ) ; } return inputFactory ; } public void setInputFactory ( XMLInputFactory inputFactory ) { this . inputFactory = inputFactory ; } public XMLOutputFactory getOutputFactory ( ) { if ( outputFactory == null ) { outputFactory = XMLOutputFactory . newInstance ( ) ; } return outputFactory ; } public void setOutputFactory ( XMLOutputFactory outputFactory ) { this . outputFactory = outputFactory ; } } 	0	['18', '1', '0', '2', '34', '149', '2', '0', '18', '0.558823529', '114', '1', '0', '0', '0.183333333', '0', '0', '5.222222222', '2', '1.0556', '0']
package org . apache . camel . component . jhc ; import java . io . IOException ; import java . io . InterruptedIOException ; import java . net . InetSocketAddress ; import java . net . SocketAddress ; import java . util . Arrays ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Set ; import java . util . concurrent . ThreadFactory ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . spi . HeaderFilterStrategy ; import org . apache . camel . util . AsyncProcessorHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . http . Header ; import org . apache . http . HttpEntity ; import org . apache . http . HttpException ; import org . apache . http . HttpRequest ; import org . apache . http . HttpResponse ; import org . apache . http . entity . ByteArrayEntity ; import org . apache . http . impl . DefaultConnectionReuseStrategy ; import org . apache . http . impl . nio . DefaultClientIOEventDispatch ; import org . apache . http . impl . nio . reactor . DefaultConnectingIOReactor ; import org . apache . http . message . BasicHttpEntityEnclosingRequest ; import org . apache . http . message . BasicHttpRequest ; import org . apache . http . nio . NHttpConnection ; import org . apache . http . nio . protocol . BufferingHttpClientHandler ; import org . apache . http . nio . protocol . EventListener ; import org . apache . http . nio . protocol . HttpRequestExecutionHandler ; import org . apache . http . nio . reactor . ConnectingIOReactor ; import org . apache . http . nio . reactor . IOEventDispatch ; import org . apache . http . nio . reactor . SessionRequest ; import org . apache . http . nio . reactor . SessionRequestCallback ; import org . apache . http . params . HttpParams ; import org . apache . http . protocol . BasicHttpProcessor ; import org . apache . http . protocol . HttpContext ; import org . apache . http . protocol . RequestConnControl ; import org . apache . http . protocol . RequestContent ; import org . apache . http . protocol . RequestExpectContinue ; import org . apache . http . protocol . RequestTargetHost ; import org . apache . http . protocol . RequestUserAgent ; public class JhcProducer extends DefaultProducer < JhcExchange > implements AsyncProcessor { public static final String HTTP_RESPONSE_CODE = "http.responseCode" ; @ Deprecated public static final Set < String > HEADERS_TO_SKIP = new HashSet < String > ( Arrays . asList ( "content-length" , "content-type" , HTTP_RESPONSE_CODE . toLowerCase ( ) ) ) ; private static final transient Log LOG = LogFactory . getLog ( JhcProducer . class ) ; private int nbThreads = 2 ; private ConnectingIOReactor ioReactor ; private ThreadFactory threadFactory ; private Thread runner ; public JhcProducer ( JhcEndpoint endpoint ) { super ( endpoint ) ; } @ Override public JhcEndpoint getEndpoint ( ) { return ( JhcEndpoint ) super . getEndpoint ( ) ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; HttpParams params = getEndpoint ( ) . getParams ( ) ; ioReactor = new DefaultConnectingIOReactor ( nbThreads , threadFactory , params ) ; BasicHttpProcessor httpproc = new BasicHttpProcessor ( ) ; httpproc . addInterceptor ( new RequestContent ( ) ) ; httpproc . addInterceptor ( new RequestTargetHost ( ) ) ; httpproc . addInterceptor ( new RequestConnControl ( ) ) ; httpproc . addInterceptor ( new RequestUserAgent ( ) ) ; httpproc . addInterceptor ( new RequestExpectContinue ( ) ) ; BufferingHttpClientHandler handler = new BufferingHttpClientHandler ( httpproc , new MyHttpRequestExecutionHandler ( ) , new DefaultConnectionReuseStrategy ( ) , params ) ; handler . setEventListener ( new EventLogger ( ) ) ; final IOEventDispatch ioEventDispatch = new DefaultClientIOEventDispatch ( handler , params ) ; runner = new Thread ( new Runnable ( ) { public void run ( ) { try { ioReactor . execute ( ioEventDispatch ) ; } catch ( InterruptedIOException ex ) { LOG . info ( "Interrupted" ) ; } catch ( IOException e ) { LOG . warn ( "I/O error: " + e . getMessage ( ) ) ; } LOG . debug ( "Shutdown" ) ; } } ) ; runner . start ( ) ; } @ Override protected void doStop ( ) throws Exception { ioReactor . shutdown ( ) ; runner . join ( ) ; super . doStop ( ) ; } public void process ( Exchange exchange ) throws Exception { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "process: " + exchange ) ; } AsyncProcessorHelper . process ( this , exchange ) ; } public boolean process ( Exchange exchange , AsyncCallback callback ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "processAsync: " + exchange ) ; } SocketAddress addr = new InetSocketAddress ( getEndpoint ( ) . getHost ( ) , getEndpoint ( ) . getPort ( ) ) ; exchange . setProperty ( AsyncCallback . class . getName ( ) , callback ) ; SessionRequest req = ioReactor . connect ( addr , null , exchange , new MySessionRequestCallback ( ) ) ; return false ; } protected HttpRequest createRequest ( Exchange exchange ) { String uri = getEndpoint ( ) . getEndpointUri ( ) ; HttpEntity entity = createEntity ( exchange ) ; HttpRequest req ; if ( entity == null ) { req = new BasicHttpRequest ( "GET" , getEndpoint ( ) . getPath ( ) ) ; } else { req = new BasicHttpEntityEnclosingRequest ( "POST" , getEndpoint ( ) . getPath ( ) ) ; ( ( BasicHttpEntityEnclosingRequest ) req ) . setEntity ( entity ) ; } HeaderFilterStrategy strategy = ( ( JhcEndpoint ) getEndpoint ( ) ) . getHeaderFilterStrategy ( ) ; for ( String headerName : exchange . getIn ( ) . getHeaders ( ) . keySet ( ) ) { String headerValue = exchange . getIn ( ) . getHeader ( headerName , String . class ) ; if ( strategy != null && ! strategy . applyFilterToCamelHeaders ( headerName , headerValue ) ) { req . addHeader ( headerName , headerValue ) ; } } return req ; } protected HttpEntity createEntity ( Exchange exchange ) { Message in = exchange . getIn ( ) ; HttpEntity entity = in . getBody ( HttpEntity . class ) ; if ( entity == null ) { byte [ ] data = in . getBody ( byte [ ] . class ) ; if ( data == null ) { return null ; } entity = new ByteArrayEntity ( data ) ; String contentType = in . getHeader ( "Content-Type" , String . class ) ; if ( contentType != null ) { ( ( ByteArrayEntity ) entity ) . setContentType ( contentType ) ; } String contentEncoding = in . getHeader ( "Content-Encoding" , String . class ) ; if ( contentEncoding != null ) { ( ( ByteArrayEntity ) entity ) . setContentEncoding ( contentEncoding ) ; } } return entity ; } static class MySessionRequestCallback implements SessionRequestCallback { public void completed ( SessionRequest sessionRequest ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Completed" ) ; } } public void failed ( SessionRequest sessionRequest ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Failed" ) ; } } public void timeout ( SessionRequest sessionRequest ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Timeout" ) ; } } public void cancelled ( SessionRequest sessionRequest ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Cancelled" ) ; } } } class MyHttpRequestExecutionHandler implements HttpRequestExecutionHandler { private static final String REQUEST_SENT = "request-sent" ; private static final String RESPONSE_RECEIVED = "response-received" ; public void initalizeContext ( HttpContext httpContext , Object o ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Initialize context" ) ; } httpContext . setAttribute ( Exchange . class . getName ( ) , ( Exchange ) o ) ; } public HttpRequest submitRequest ( HttpContext httpContext ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Submit request: " + httpContext ) ; } Object flag = httpContext . getAttribute ( REQUEST_SENT ) ; if ( flag == null ) { httpContext . setAttribute ( REQUEST_SENT , Boolean . TRUE ) ; Exchange e = ( Exchange ) httpContext . getAttribute ( Exchange . class . getName ( ) ) ; return createRequest ( e ) ; } else { return null ; } } public void handleResponse ( HttpResponse httpResponse , HttpContext httpContext ) throws IOException { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Handle response" ) ; } httpContext . setAttribute ( RESPONSE_RECEIVED , Boolean . TRUE ) ; Exchange e = ( Exchange ) httpContext . getAttribute ( Exchange . class . getName ( ) ) ; e . getOut ( ) . setBody ( httpResponse . getEntity ( ) ) ; HeaderFilterStrategy strategy = getEndpoint ( ) . getHeaderFilterStrategy ( ) ; for ( Iterator it = httpResponse . headerIterator ( ) ; it . hasNext ( ) ; ) { Header h = ( Header ) it . next ( ) ; if ( strategy != null && ! strategy . applyFilterToExternalHeaders ( h . getName ( ) , h . getValue ( ) ) ) { e . getOut ( ) . setHeader ( h . getName ( ) , h . getValue ( ) ) ; } } e . getOut ( ) . setHeader ( HTTP_RESPONSE_CODE , httpResponse . getStatusLine ( ) . getStatusCode ( ) ) ; AsyncCallback callback = ( AsyncCallback ) e . removeProperty ( AsyncCallback . class . getName ( ) ) ; callback . done ( false ) ; } public void finalizeContext ( HttpContext httpContext ) { } } static class EventLogger implements EventListener { public void connectionOpen ( final NHttpConnection conn ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Connection open: " + conn ) ; } } public void connectionTimeout ( final NHttpConnection conn ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Connection timed out: " + conn ) ; } } public void connectionClosed ( final NHttpConnection conn ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Connection closed: " + conn ) ; } } public void fatalIOException ( final IOException ex , final NHttpConnection conn ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "I/O error: " + ex . getMessage ( ) ) ; } } public void fatalProtocolException ( final HttpException ex , final NHttpConnection conn ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "HTTP error: " + ex . getMessage ( ) ) ; } } } } 	0	['12', '3', '0', '41', '72', '40', '5', '41', '5', '0.909090909', '330', '0.714285714', '0', '0.677419355', '0.290909091', '1', '1', '25.91666667', '5', '1.4167', '0']
package org . apache . camel . bam . model ; import javax . persistence . CascadeType ; import javax . persistence . Entity ; import javax . persistence . FetchType ; import javax . persistence . GeneratedValue ; import javax . persistence . Id ; import javax . persistence . ManyToOne ; import javax . persistence . Table ; import javax . persistence . UniqueConstraint ; @ Entity @ Table ( name = "ACTIVITYDEFINITION" , uniqueConstraints = @ UniqueConstraint ( columnNames = { "name" } ) ) public class ActivityDefinition extends EntitySupport { private String name ; private ProcessDefinition processDefinition ; @ Override @ Id @ GeneratedValue public Long getId ( ) { return super . getId ( ) ; } @ Override public String toString ( ) { return "Activity[" + getId ( ) + " name: " + getName ( ) + "]" ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } @ ManyToOne ( fetch = FetchType . LAZY , cascade = { CascadeType . PERSIST , CascadeType . MERGE } ) public ProcessDefinition getProcessDefinition ( ) { return processDefinition ; } public void setProcessDefinition ( ProcessDefinition processDefinition ) { this . processDefinition = processDefinition ; } } 	0	['7', '2', '0', '6', '13', '17', '4', '2', '7', '0.75', '46', '1', '1', '0.333333333', '0.428571429', '0', '0', '5.285714286', '1', '0.8571', '0']
package org . apache . camel . component . xmpp ; import java . util . Map ; import org . apache . camel . impl . DefaultMessage ; import org . jivesoftware . smack . packet . Message ; public class XmppMessage extends DefaultMessage { private Message xmppMessage ; public XmppMessage ( ) { this ( new Message ( ) ) ; } public XmppMessage ( Message jmsMessage ) { this . xmppMessage = jmsMessage ; } @ Override public String toString ( ) { if ( xmppMessage != null ) { return "XmppMessage: " + xmppMessage ; } else { return "XmppMessage: " + getBody ( ) ; } } @ Override public XmppExchange getExchange ( ) { return ( XmppExchange ) super . getExchange ( ) ; } public Message getXmppMessage ( ) { return xmppMessage ; } public void setXmppMessage ( Message xmppMessage ) { this . xmppMessage = xmppMessage ; } @ Override public XmppMessage newInstance ( ) { return new XmppMessage ( ) ; } @ Override protected Object createBody ( ) { if ( xmppMessage != null ) { return getExchange ( ) . getBinding ( ) . extractBodyFromXmpp ( getExchange ( ) , xmppMessage ) ; } return null ; } @ Override protected void populateInitialHeaders ( Map < String , Object > map ) { if ( xmppMessage != null ) { map . putAll ( getExchange ( ) . getBinding ( ) . extractHeadersFromXmpp ( xmppMessage ) ) ; } } } 	0	['12', '3', '0', '6', '21', '36', '1', '6', '10', '0.181818182', '98', '1', '0', '0.777777778', '0.416666667', '2', '6', '7.083333333', '2', '1.0833', '0']
package org . apache . camel . impl ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . util . ObjectHelper ; public abstract class ExpressionSupport < E extends Exchange > implements Expression < E > , Predicate < E > { public boolean matches ( E exchange ) { Object value = evaluate ( exchange ) ; return ObjectHelper . evaluateValuePredicate ( value ) ; } public void assertMatches ( String text , E exchange ) { if ( ! matches ( exchange ) ) { throw new AssertionError ( text + " " + assertionFailureMessage ( exchange ) + " for exchange: " + exchange ) ; } } protected abstract String assertionFailureMessage ( E exchange ) ; } 	0	['6', '1', '6', '11', '14', '15', '7', '4', '5', '2', '52', '0', '0', '0', '0.541666667', '0', '0', '7.666666667', '2', '1', '0']
package org . apache . camel . model ; import java . util . concurrent . LinkedBlockingQueue ; import java . util . concurrent . ThreadPoolExecutor ; import java . util . concurrent . TimeUnit ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . Splitter ; import org . apache . camel . processor . aggregate . AggregationStrategy ; import org . apache . camel . processor . aggregate . UseLatestAggregationStrategy ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "splitter" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class SplitterType extends ExpressionNode { @ XmlTransient private AggregationStrategy aggregationStrategy ; @ XmlAttribute ( required = false ) private Boolean parallelProcessing ; @ XmlTransient private ThreadPoolExecutor threadPoolExecutor ; @ XmlAttribute ( required = false ) private String threadPoolExecutorRef ; @ XmlAttribute ( required = false ) private Boolean streaming = false ; public SplitterType ( ) { } public SplitterType ( Expression expression ) { super ( expression ) ; } public SplitterType ( ExpressionType expression ) { super ( expression ) ; } @ Override public String toString ( ) { return "Splitter[" + getExpression ( ) + " -> " + getOutputs ( ) + "]" ; } @ Override public String getShortName ( ) { return "splitter" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { Processor childProcessor = routeContext . createProcessor ( this ) ; if ( aggregationStrategy == null ) { aggregationStrategy = new UseLatestAggregationStrategy ( ) ; } threadPoolExecutor = createThreadPoolExecutor ( routeContext ) ; return new Splitter ( getExpression ( ) . createExpression ( routeContext ) , childProcessor , aggregationStrategy , isParallelProcessing ( ) , threadPoolExecutor , streaming ) ; } public SplitterType aggregationStrategy ( AggregationStrategy aggregationStrategy ) { setAggregationStrategy ( aggregationStrategy ) ; return this ; } public SplitterType parallelProcessing ( ) { setParallelProcessing ( true ) ; return this ; } public SplitterType parallelProcessing ( boolean parallelProcessing ) { setParallelProcessing ( parallelProcessing ) ; return this ; } public SplitterType streaming ( ) { setStreaming ( true ) ; return this ; } public SplitterType executor ( ThreadPoolExecutor executor ) { setThreadPoolExecutor ( executor ) ; return this ; } public AggregationStrategy getAggregationStrategy ( ) { return aggregationStrategy ; } public void setAggregationStrategy ( AggregationStrategy aggregationStrategy ) { this . aggregationStrategy = aggregationStrategy ; } public boolean isParallelProcessing ( ) { return parallelProcessing != null ? parallelProcessing : false ; } public void setParallelProcessing ( boolean parallelProcessing ) { this . parallelProcessing = parallelProcessing ; } public boolean isStreaming ( ) { return streaming != null ? streaming : false ; } public void setStreaming ( boolean streaming ) { this . streaming = streaming ; } private ThreadPoolExecutor createThreadPoolExecutor ( RouteContext routeContext ) { ThreadPoolExecutor threadPoolExecutor = getThreadPoolExecutor ( ) ; if ( threadPoolExecutor == null && threadPoolExecutorRef != null ) { threadPoolExecutor = routeContext . lookup ( threadPoolExecutorRef , ThreadPoolExecutor . class ) ; } if ( threadPoolExecutor == null ) { threadPoolExecutor = new ThreadPoolExecutor ( 4 , 16 , 0L , TimeUnit . MILLISECONDS , new LinkedBlockingQueue ( ) ) ; } return threadPoolExecutor ; } public ThreadPoolExecutor getThreadPoolExecutor ( ) { return threadPoolExecutor ; } public void setThreadPoolExecutor ( ThreadPoolExecutor threadPoolExecutor ) { this . threadPoolExecutor = threadPoolExecutor ; } } 	0	['20', '4', '0', '12', '38', '146', '4', '9', '19', '0.810526316', '199', '1', '1', '0.915422886', '0.221428571', '2', '3', '8.7', '4', '1.1', '0']
package org . apache . camel . component . file . remote ; import org . apache . camel . Processor ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class FtpEndpoint extends RemoteFileEndpoint < RemoteFileExchange > { private static final transient Log LOG = LogFactory . getLog ( FtpEndpoint . class ) ; public FtpEndpoint ( String uri , RemoteFileComponent remoteFileComponent , RemoteFileConfiguration configuration ) { super ( uri , remoteFileComponent , configuration ) ; } public FtpEndpoint ( String endpointUri ) { super ( endpointUri ) ; } public FtpProducer createProducer ( ) throws Exception { return new FtpProducer ( this , FtpUtils . createNewFtpClient ( ) ) ; } public FtpConsumer createConsumer ( Processor processor ) throws Exception { final FtpConsumer consumer = new FtpConsumer ( this , processor , FtpUtils . createNewFtpClient ( ) ) ; configureConsumer ( consumer ) ; return consumer ; } } 	0	['7', '4', '0', '12', '12', '21', '3', '12', '6', '1', '47', '1', '0', '0.911111111', '0.4', '0', '0', '5.571428571', '1', '0.5714', '0']
package org . apache . camel . spring ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . CamelContextAware ; import org . apache . camel . Endpoint ; import org . apache . camel . EndpointInject ; import org . apache . camel . Produce ; import org . apache . camel . impl . CamelPostProcessorHelper ; import org . apache . camel . spring . util . ReflectionUtils ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . BeanInstantiationException ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . config . BeanPostProcessor ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; @ XmlRootElement ( name = "beanPostProcessor" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class CamelBeanPostProcessor implements BeanPostProcessor , ApplicationContextAware { private static final transient Log LOG = LogFactory . getLog ( CamelBeanPostProcessor . class ) ; @ XmlTransient private SpringCamelContext camelContext ; @ XmlTransient private ApplicationContext applicationContext ; @ XmlTransient private CamelPostProcessorHelper postProcessor ; public CamelBeanPostProcessor ( ) { } public Object postProcessBeforeInitialization ( Object bean , String beanName ) throws BeansException { injectFields ( bean ) ; injectMethods ( bean ) ; if ( bean instanceof CamelContextAware ) { CamelContextAware contextAware = ( CamelContextAware ) bean ; if ( camelContext == null ) { LOG . warn ( "No CamelContext defined yet so cannot inject into: " + bean ) ; } else { contextAware . setCamelContext ( camelContext ) ; } } return bean ; } public Object postProcessAfterInitialization ( Object bean , String beanName ) throws BeansException { return bean ; } public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { this . applicationContext = applicationContext ; } public SpringCamelContext getCamelContext ( ) { return camelContext ; } public void setCamelContext ( SpringCamelContext camelContext ) { this . camelContext = camelContext ; postProcessor = new CamelPostProcessorHelper ( camelContext ) { @ Override protected RuntimeException createProxyInstantiationRuntimeException ( Class < ? > type , Endpoint endpoint , Exception e ) { return new BeanInstantiationException ( type , "Could not instantiate proxy of type " + type . getName ( ) + " on endpoint " + endpoint , e ) ; } } ; } protected void injectFields ( final Object bean ) { ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { public void doWith ( Field field ) throws IllegalArgumentException , IllegalAccessException { EndpointInject annotation = field . getAnnotation ( EndpointInject . class ) ; if ( annotation != null ) { injectField ( field , annotation . uri ( ) , annotation . name ( ) , bean ) ; } Produce produce = field . getAnnotation ( Produce . class ) ; if ( produce != null ) { injectField ( field , produce . uri ( ) , produce . ref ( ) , bean ) ; } } } ) ; } protected void injectField ( Field field , String endpointUri , String endpointRef , Object bean ) { ReflectionUtils . setField ( field , bean , getPostProcessor ( ) . getInjectionValue ( field . getType ( ) , endpointUri , endpointRef , field . getName ( ) ) ) ; } protected void injectMethods ( final Object bean ) { ReflectionUtils . doWithMethods ( bean . getClass ( ) , new ReflectionUtils . MethodCallback ( ) { @ SuppressWarnings ( "unchecked" ) public void doWith ( Method method ) throws IllegalArgumentException , IllegalAccessException { setterInjection ( method , bean ) ; getPostProcessor ( ) . consumerInjection ( method , bean ) ; } } ) ; } protected void setterInjection ( Method method , Object bean ) { EndpointInject annoation = method . getAnnotation ( EndpointInject . class ) ; if ( annoation != null ) { setterInjection ( method , bean , annoation . uri ( ) , annoation . name ( ) ) ; } Produce produce = method . getAnnotation ( Produce . class ) ; if ( produce != null ) { setterInjection ( method , bean , produce . uri ( ) , produce . ref ( ) ) ; } } protected void setterInjection ( Method method , Object bean , String endpointUri , String endpointRef ) { Class < ? > [ ] parameterTypes = method . getParameterTypes ( ) ; if ( parameterTypes != null ) { if ( parameterTypes . length != 1 ) { LOG . warn ( "Ignoring badly annotated method for injection due to incorrect number of parameters: " + method ) ; } else { String propertyName = ObjectHelper . getPropertyName ( method ) ; Object value = getPostProcessor ( ) . getInjectionValue ( parameterTypes [ 0 ] , endpointUri , endpointRef , propertyName ) ; ObjectHelper . invokeMethod ( method , bean , value ) ; } } } protected void consumerInjection ( final Object bean ) { org . springframework . util . ReflectionUtils . doWithMethods ( bean . getClass ( ) , new org . springframework . util . ReflectionUtils . MethodCallback ( ) { @ SuppressWarnings ( "unchecked" ) public void doWith ( Method method ) throws IllegalArgumentException , IllegalAccessException { } } ) ; } public CamelPostProcessorHelper getPostProcessor ( ) { ObjectHelper . notNull ( postProcessor , "postProcessor" ) ; return postProcessor ; } } 	0	['14', '1', '0', '22', '43', '77', '5', '21', '7', '0.846153846', '198', '1', '2', '0', '0.32967033', '0', '0', '12.85714286', '3', '1.1429', '0']
package org . apache . camel . component . cxf . feature ; import java . util . logging . Logger ; import org . apache . camel . component . cxf . interceptors . FaultOutInterceptor ; import org . apache . camel . component . cxf . interceptors . RawMessageContentRedirectInterceptor ; import org . apache . cxf . Bus ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . endpoint . Client ; import org . apache . cxf . endpoint . Server ; import org . apache . cxf . phase . Phase ; public class MessageDataFormatFeature extends AbstractDataFormatFeature { private static final Logger LOG = LogUtils . getL7dLogger ( MessageDataFormatFeature . class ) ; private static final String [ ] REMAINING_IN_PHASES = { Phase . RECEIVE , Phase . POST_INVOKE } ; private static final String [ ] REMAINING_OUT_PHASES = { Phase . PREPARE_SEND , Phase . WRITE , Phase . SEND , Phase . PREPARE_SEND_ENDING } ; @ Override public void initialize ( Client client , Bus bus ) { removeInterceptorWhichIsOutThePhases ( client . getInInterceptors ( ) , REMAINING_IN_PHASES ) ; removeInterceptorWhichIsOutThePhases ( client . getEndpoint ( ) . getInInterceptors ( ) , REMAINING_IN_PHASES ) ; client . getEndpoint ( ) . getBinding ( ) . getInInterceptors ( ) . clear ( ) ; removeInterceptorWhichIsOutThePhases ( client . getOutInterceptors ( ) , REMAINING_OUT_PHASES ) ; removeInterceptorWhichIsOutThePhases ( client . getEndpoint ( ) . getOutInterceptors ( ) , REMAINING_OUT_PHASES ) ; client . getEndpoint ( ) . getBinding ( ) . getOutInterceptors ( ) . clear ( ) ; client . getEndpoint ( ) . getOutInterceptors ( ) . add ( new RawMessageContentRedirectInterceptor ( ) ) ; client . getEndpoint ( ) . getBinding ( ) . getOutFaultInterceptors ( ) . add ( new FaultOutInterceptor ( ) ) ; } @ Override public void initialize ( Server server , Bus bus ) { removeInterceptorWhichIsOutThePhases ( server . getEndpoint ( ) . getService ( ) . getInInterceptors ( ) , REMAINING_IN_PHASES ) ; removeInterceptorWhichIsOutThePhases ( server . getEndpoint ( ) . getInInterceptors ( ) , REMAINING_IN_PHASES ) ; server . getEndpoint ( ) . getBinding ( ) . getInInterceptors ( ) . clear ( ) ; removeInterceptorWhichIsOutThePhases ( server . getEndpoint ( ) . getService ( ) . getOutInterceptors ( ) , REMAINING_OUT_PHASES ) ; removeInterceptorWhichIsOutThePhases ( server . getEndpoint ( ) . getOutInterceptors ( ) , REMAINING_OUT_PHASES ) ; server . getEndpoint ( ) . getBinding ( ) . getOutInterceptors ( ) . clear ( ) ; server . getEndpoint ( ) . getBinding ( ) . getOutFaultInterceptors ( ) . add ( new FaultOutInterceptor ( ) ) ; resetServiceInvokerInterceptor ( server ) ; server . getEndpoint ( ) . getOutInterceptors ( ) . add ( new RawMessageContentRedirectInterceptor ( ) ) ; } @ Override protected Logger getLogger ( ) { return LOG ; } } 	0	['5', '1', '0', '12', '26', '2', '2', '10', '3', '0.583333333', '154', '1', '0', '0.571428571', '0.5', '1', '1', '29.2', '1', '0.6', '0']
package org . apache . camel . osgi ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . impl . converter . AnnotationTypeConverterLoader ; import org . apache . camel . impl . converter . DefaultTypeConverter ; import org . apache . camel . impl . converter . TypeConverterLoader ; import org . apache . camel . spring . RouteBuilderFinder ; import org . apache . camel . spring . SpringCamelContext ; import org . apache . camel . util . FactoryFinder ; import org . apache . camel . util . ResolverUtil ; import org . osgi . framework . BundleContext ; import org . springframework . osgi . context . BundleContextAware ; @ XmlRootElement ( name = "camelContext" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class CamelContextFactoryBean extends org . apache . camel . spring . CamelContextFactoryBean implements BundleContextAware { @ XmlTransient private BundleContext bundleContext ; public BundleContext getBundleContext ( ) { return bundleContext ; } public void setBundleContext ( BundleContext bundleContext ) { this . bundleContext = bundleContext ; } protected SpringCamelContext createContext ( ) { SpringCamelContext context = super . createContext ( ) ; if ( bundleContext != null ) { context . setComponentResolver ( new OsgiComponentResolver ( ) ) ; context . setLanguageResolver ( new OsgiLanguageResolver ( ) ) ; addOsgiAnnotationTypeConverterLoader ( context , bundleContext ) ; context . setFactoryFinderClass ( OsgiFactoryFinder . class ) ; } return context ; } protected ResolverUtil createResolverUtil ( ) { if ( bundleContext != null ) { return new OsgiResolverUtil ( bundleContext ) ; } else { return new ResolverUtil ( ) ; } } protected void addOsgiAnnotationTypeConverterLoader ( SpringCamelContext context , BundleContext bundleContext ) { DefaultTypeConverter typeConverter = ( DefaultTypeConverter ) context . getTypeConverter ( ) ; List < TypeConverterLoader > typeConverterLoaders = typeConverter . getTypeConverterLoaders ( ) ; TypeConverterLoader atLoader = null ; for ( TypeConverterLoader loader : typeConverterLoaders ) { if ( loader instanceof AnnotationTypeConverterLoader ) { atLoader = loader ; break ; } } if ( atLoader != null ) { typeConverterLoaders . remove ( atLoader ) ; } typeConverterLoaders . add ( new OsgiAnnotationTypeConverterLoader ( bundleContext ) ) ; } } 	0	['6', '3', '0', '15', '23', '3', '0', '15', '3', '0.4', '96', '1', '0', '0.905660377', '0.5', '1', '2', '14.83333333', '3', '1.5', '0']
package org . apache . camel . processor ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . ProducerCache ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . processor . aggregate . UseLatestAggregationStrategy ; import org . apache . camel . util . ExchangeHelper ; import org . apache . camel . util . ObjectHelper ; import static org . apache . camel . util . ObjectHelper . notNull ; public class RecipientList extends ServiceSupport implements Processor { private final Expression < Exchange > expression ; private ProducerCache < Exchange > producerCache = new ProducerCache < Exchange > ( ) ; public RecipientList ( Expression < Exchange > expression ) { notNull ( expression , "expression" ) ; this . expression = expression ; } @ Override public String toString ( ) { return "RecipientList[" + expression + "]" ; } public void process ( Exchange exchange ) throws Exception { Object receipientList = expression . evaluate ( exchange ) ; sendToRecipientList ( exchange , receipientList ) ; } public void sendToRecipientList ( Exchange exchange , Object receipientList ) throws Exception { Iterator iter = ObjectHelper . createIterator ( receipientList ) ; List < Processor > processors = new ArrayList < Processor > ( ) ; while ( iter . hasNext ( ) ) { Object recipient = iter . next ( ) ; Endpoint < Exchange > endpoint = resolveEndpoint ( exchange , recipient ) ; Producer < Exchange > producer = producerCache . getProducer ( endpoint ) ; processors . add ( producer ) ; } MulticastProcessor mp = new MulticastProcessor ( processors , new UseLatestAggregationStrategy ( ) ) ; mp . process ( exchange ) ; } protected Endpoint < Exchange > resolveEndpoint ( Exchange exchange , Object recipient ) { if ( recipient instanceof String ) { recipient = ( ( String ) recipient ) . trim ( ) ; } return ExchangeHelper . resolveEndpoint ( exchange , recipient ) ; } protected void doStop ( ) throws Exception { producerCache . stop ( ) ; } protected void doStart ( ) throws Exception { } } 	0	['7', '2', '0', '16', '27', '9', '4', '12', '4', '0.583333333', '101', '1', '2', '0.7', '0.464285714', '1', '1', '13.14285714', '2', '1', '0']
package org . apache . camel . component . stream ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . net . URL ; import java . net . URLConnection ; import java . nio . charset . Charset ; import java . util . Arrays ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; import org . apache . camel . impl . DefaultMessage ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class StreamConsumer extends DefaultConsumer < Exchange > { private static final transient Log LOG = LogFactory . getLog ( StreamConsumer . class ) ; private static final String TYPES = "in,file,url" ; private static final String INVALID_URI = "Invalid uri, valid form: 'stream:{" + TYPES + "}'" ; private static final List < String > TYPES_LIST = Arrays . asList ( TYPES . split ( "," ) ) ; private InputStream inputStream = System . in ; private StreamEndpoint endpoint ; private String uri ; public StreamConsumer ( StreamEndpoint endpoint , Processor processor , String uri ) throws Exception { super ( endpoint , processor ) ; this . endpoint = endpoint ; this . uri = uri ; validateUri ( uri ) ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; if ( "in" . equals ( uri ) ) { inputStream = System . in ; } else if ( "file" . equals ( uri ) ) { inputStream = resolveStreamFromFile ( ) ; } else if ( "url" . equals ( uri ) ) { inputStream = resolveStreamFromUrl ( ) ; } readFromStream ( ) ; } @ Override public void doStop ( ) throws Exception { super . doStop ( ) ; } private void readFromStream ( ) throws Exception { Charset charset = endpoint . getCharset ( ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( inputStream , charset ) ) ; String line ; while ( ( line = br . readLine ( ) ) != null ) { consumeLine ( line ) ; } } private void consumeLine ( Object line ) throws Exception { Exchange exchange = endpoint . createExchange ( ) ; Message msg = new DefaultMessage ( ) ; msg . setBody ( line ) ; exchange . setIn ( msg ) ; getProcessor ( ) . process ( exchange ) ; } private InputStream resolveStreamFromUrl ( ) throws IOException { String u = endpoint . getUrl ( ) ; URL url = new URL ( u ) ; URLConnection c = url . openConnection ( ) ; return c . getInputStream ( ) ; } private InputStream resolveStreamFromFile ( ) throws IOException { String fileName = endpoint . getFile ( ) != null ? endpoint . getFile ( ) . trim ( ) : "_file" ; File f = new File ( fileName ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "About to read from file: " + f ) ; } f . createNewFile ( ) ; return new FileInputStream ( f ) ; } private void validateUri ( String uri ) throws IllegalArgumentException { String [ ] s = uri . split ( ":" ) ; if ( s . length < 2 ) { throw new IllegalArgumentException ( INVALID_URI ) ; } String [ ] t = s [ 1 ] . split ( "\\?" ) ; if ( t . length < 1 ) { throw new IllegalArgumentException ( INVALID_URI ) ; } this . uri = t [ 0 ] . trim ( ) ; if ( ! TYPES_LIST . contains ( this . uri ) ) { throw new IllegalArgumentException ( INVALID_URI ) ; } } } 	0	['9', '3', '0', '9', '43', '4', '1', '9', '2', '0.803571429', '218', '1', '1', '0.766666667', '0.325', '2', '2', '22.44444444', '1', '0.7778', '0']
package org . apache . camel . spring ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . model . IdentifiedType ; @ XmlRootElement ( name = "export" ) public class CamelServiceExporterType extends IdentifiedType { @ XmlAttribute private String uri ; @ XmlAttribute private String serviceRef ; @ XmlAttribute private Class serviceInterface ; } 	0	['1', '2', '0', '1', '2', '0', '0', '1', '1', '2', '7', '1', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . camel . component . rmi ; import java . rmi . NotBoundException ; import java . rmi . RemoteException ; import org . apache . camel . Exchange ; import org . apache . camel . component . bean . BeanExchange ; import org . apache . camel . component . bean . BeanHolder ; import org . apache . camel . component . bean . BeanProcessor ; import org . apache . camel . impl . DefaultProducer ; public class RmiProducer extends DefaultProducer < BeanExchange > { private BeanProcessor beanProcessor ; public RmiProducer ( RmiEndpoint endpoint ) throws RemoteException , NotBoundException { super ( endpoint ) ; BeanHolder holder = new RmiRegistryBean ( endpoint . getCamelContext ( ) , endpoint . getName ( ) , endpoint . getRegistry ( ) ) ; beanProcessor = new BeanProcessor ( holder ) ; String method = endpoint . getMethod ( ) ; if ( method != null ) { beanProcessor . setMethod ( method ) ; } } public void process ( Exchange exchange ) throws Exception { beanProcessor . process ( exchange ) ; } } 	0	['2', '3', '0', '8', '11', '0', '1', '8', '2', '0', '37', '1', '1', '0.954545455', '0.666666667', '0', '0', '17', '1', '0.5', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Processor ; import org . apache . camel . builder . ProcessorBuilder ; import org . apache . camel . spi . RouteContext ; import org . apache . camel . util . ObjectHelper ; @ XmlRootElement ( name = "removeProperty" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class RemovePropertyType extends OutputType < ProcessorType > { @ XmlAttribute ( required = true ) private String propertyName ; public RemovePropertyType ( ) { } public RemovePropertyType ( String propertyName ) { setPropertyName ( propertyName ) ; } @ Override public String toString ( ) { return "RemoveProperty[" + getPropertyName ( ) + "]" ; } @ Override public String getShortName ( ) { return "removeProperty" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { ObjectHelper . notNull ( getPropertyName ( ) , "propertyName" ) ; return ProcessorBuilder . removeProperty ( getPropertyName ( ) ) ; } public void setPropertyName ( String propertyName ) { this . propertyName = propertyName ; } public String getPropertyName ( ) { return propertyName ; } } 	0	['7', '4', '0', '6', '13', '19', '1', '5', '7', '0.333333333', '46', '1', '0', '0.972826087', '0.476190476', '1', '2', '5.428571429', '1', '0.7143', '0']
package org . apache . camel . component . file . remote ; import java . io . ByteArrayOutputStream ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Message ; import org . apache . camel . impl . ScheduledPollEndpoint ; import org . apache . camel . util . UuidGenerator ; public abstract class RemoteFileEndpoint < T extends RemoteFileExchange > extends ScheduledPollEndpoint < T > { private RemoteFileBinding binding ; private RemoteFileConfiguration configuration ; public RemoteFileEndpoint ( String uri , RemoteFileComponent component , RemoteFileConfiguration configuration ) { super ( uri , component ) ; this . configuration = configuration ; } protected RemoteFileEndpoint ( String endpointUri , RemoteFileConfiguration configuration ) { super ( endpointUri ) ; this . configuration = configuration ; } protected RemoteFileEndpoint ( String endpointUri ) { this ( endpointUri , new RemoteFileConfiguration ( ) ) ; } protected RemoteFileBinding createRemoteFileBinding ( ) { return new RemoteFileBinding ( ) ; } public T createExchange ( ) { return ( T ) new RemoteFileExchange ( getCamelContext ( ) , getExchangePattern ( ) , getBinding ( ) ) ; } public T createExchange ( ExchangePattern pattern ) { return ( T ) new RemoteFileExchange ( getCamelContext ( ) , pattern , getBinding ( ) ) ; } public T createExchange ( String fullFileName , String fileName , long fileLength , ByteArrayOutputStream outputStream ) { return ( T ) new RemoteFileExchange ( getCamelContext ( ) , getExchangePattern ( ) , getBinding ( ) , getConfiguration ( ) . getHost ( ) , fullFileName , fileName , fileLength , outputStream ) ; } public RemoteFileBinding getBinding ( ) { if ( binding == null ) { binding = createRemoteFileBinding ( ) ; } return binding ; } public void setBinding ( RemoteFileBinding binding ) { this . binding = binding ; } public boolean isSingleton ( ) { return true ; } public RemoteFileConfiguration getConfiguration ( ) { return configuration ; } public void setConfiguration ( RemoteFileConfiguration configuration ) { this . configuration = configuration ; } public String getGeneratedFileName ( Message message ) { return getFileFriendlyMessageId ( message . getMessageId ( ) ) ; } protected String getFileFriendlyMessageId ( String id ) { return UuidGenerator . generateSanitizedId ( id ) ; } } 	0	['16', '3', '2', '19', '25', '106', '9', '11', '12', '0.633333333', '118', '1', '2', '0.682926829', '0.215277778', '1', '1', '6.25', '2', '0.875', '0']
package org . apache . camel . impl ; import org . apache . camel . Exchange ; import org . apache . camel . spi . ExchangeConverter ; public class DefaultExchangeConverter implements ExchangeConverter { public < T > T convertTo ( Class < T > type , Exchange exchange ) { throw new UnsupportedOperationException ( "Not implemented yet" ) ; } } 	0	['2', '1', '0', '3', '4', '1', '1', '2', '2', '2', '10', '0', '0', '0', '0.666666667', '0', '0', '4', '1', '0.5', '0']
package org . apache . camel . spring . spi ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import org . aopalliance . intercept . MethodInvocation ; import org . apache . camel . Converter ; import org . apache . camel . component . bean . BeanInvocation ; import org . springframework . core . io . ByteArrayResource ; import org . springframework . core . io . FileSystemResource ; import org . springframework . core . io . Resource ; import org . springframework . core . io . UrlResource ; @ Converter public final class SpringConverters { private SpringConverters ( ) { } @ Converter public static InputStream toInputStream ( Resource resource ) throws IOException { return resource . getInputStream ( ) ; } @ Converter public static File toFile ( Resource resource ) throws IOException { return resource . getFile ( ) ; } @ Converter public static URL toUrl ( Resource resource ) throws IOException { return resource . getURL ( ) ; } @ Converter public static UrlResource toResource ( String uri ) throws IOException { return new UrlResource ( uri ) ; } @ Converter public static UrlResource toResource ( URL uri ) throws IOException { return new UrlResource ( uri ) ; } @ Converter public static FileSystemResource toResource ( File file ) throws IOException { return new FileSystemResource ( file ) ; } @ Converter public static ByteArrayResource toResource ( byte [ ] data ) throws IOException { return new ByteArrayResource ( data ) ; } @ Converter public static BeanInvocation toBeanInvocation ( MethodInvocation invocation ) { return new BeanInvocation ( invocation . getMethod ( ) , invocation . getArguments ( ) ) ; } } 	0	['9', '1', '0', '6', '20', '36', '0', '6', '8', '2', '49', '0', '0', '0', '0.142857143', '0', '0', '4.444444444', '1', '0.8889', '0']
package org . apache . camel . component . jms ; public enum ConsumerType { Simple , Default , ServerSessionPool } 	0	['4', '2', '0', '4', '7', '4', '3', '1', '2', '0.916666667', '56', '0.25', '4', '0.857142857', '0.444444444', '1', '1', '12', '1', '0.5', '0']
package org . apache . camel . component . file . remote ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . util . concurrent . ScheduledExecutorService ; import org . apache . camel . Processor ; import org . apache . camel . component . file . FileComponent ; import org . apache . commons . net . ftp . FTPClient ; import org . apache . commons . net . ftp . FTPFile ; public class FtpConsumer extends RemoteFileConsumer < RemoteFileExchange > { private FtpEndpoint endpoint ; private FTPClient client ; private boolean loggedIn ; public FtpConsumer ( FtpEndpoint endpoint , Processor processor , FTPClient client ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; this . client = client ; } public FtpConsumer ( FtpEndpoint endpoint , Processor processor , FTPClient client , ScheduledExecutorService executor ) { super ( endpoint , processor , executor ) ; this . endpoint = endpoint ; this . client = client ; } protected void doStart ( ) throws Exception { log . info ( "Starting" ) ; super . doStart ( ) ; } protected void doStop ( ) throws Exception { log . info ( "Stopping" ) ; try { disconnect ( ) ; } catch ( Exception e ) { String message = "Could not disconnect from " + remoteServer ( ) + ". Reason: " + client . getReplyString ( ) + ". Code: " + client . getReplyCode ( ) ; log . warn ( message ) ; } super . doStop ( ) ; } protected void connectIfNecessary ( ) throws IOException { if ( ! client . isConnected ( ) || ! loggedIn ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Not connected/logged in, connecting to " + remoteServer ( ) ) ; } loggedIn = FtpUtils . connect ( client , endpoint . getConfiguration ( ) ) ; if ( ! loggedIn ) { return ; } } log . info ( "Connected and logged in to " + remoteServer ( ) ) ; } protected void disconnect ( ) throws IOException { loggedIn = false ; log . debug ( "Disconnecting from " + remoteServer ( ) ) ; FtpUtils . disconnect ( client ) ; } protected void poll ( ) throws Exception { if ( log . isTraceEnabled ( ) ) { log . trace ( "Polling " + endpoint . getConfiguration ( ) ) ; } try { connectIfNecessary ( ) ; if ( ! loggedIn ) { String message = "Could not connect/login to " + endpoint . getConfiguration ( ) ; log . warn ( message ) ; throw new FtpOperationFailedException ( client . getReplyCode ( ) , client . getReplyString ( ) , message ) ; } final String fileName = endpoint . getConfiguration ( ) . getFile ( ) ; if ( endpoint . getConfiguration ( ) . isDirectory ( ) ) { pollDirectory ( fileName ) ; } else { int index = fileName . lastIndexOf ( '/' ) ; if ( index > - 1 ) { client . changeWorkingDirectory ( fileName . substring ( 0 , index ) ) ; } final FTPFile [ ] files = client . listFiles ( fileName . substring ( index + 1 ) ) ; pollFile ( files [ 0 ] ) ; } lastPollTime = System . currentTimeMillis ( ) ; } catch ( Exception e ) { loggedIn = false ; if ( isStopping ( ) || isStopped ( ) ) { log . warn ( "Consumer is stopping. Ignoring caught exception: " + e . getClass ( ) . getCanonicalName ( ) + " message: " + e . getMessage ( ) ) ; } else { log . warn ( "Exception occured during polling: " + e . getClass ( ) . getCanonicalName ( ) + " message: " + e . getMessage ( ) ) ; disconnect ( ) ; throw e ; } } } protected void pollDirectory ( String dir ) throws Exception { if ( log . isTraceEnabled ( ) ) { log . trace ( "Polling directory: " + dir ) ; } String currentDir = client . printWorkingDirectory ( ) ; client . changeWorkingDirectory ( dir ) ; for ( FTPFile ftpFile : client . listFiles ( ) ) { if ( ftpFile . isFile ( ) ) { pollFile ( ftpFile ) ; } else if ( ftpFile . isDirectory ( ) ) { if ( isRecursive ( ) ) { pollDirectory ( getFullFileName ( ftpFile ) ) ; } } else { log . debug ( "Unsupported type of FTPFile: " + ftpFile + " (not a file or directory). It is skipped." ) ; } } client . changeWorkingDirectory ( currentDir ) ; } protected String getFullFileName ( FTPFile ftpFile ) throws IOException { return client . printWorkingDirectory ( ) + "/" + ftpFile . getName ( ) ; } private void pollFile ( FTPFile ftpFile ) throws Exception { if ( ftpFile == null ) { return ; } if ( log . isTraceEnabled ( ) ) { log . trace ( "Polling file: " + ftpFile ) ; } boolean timestampMatched = true ; if ( isTimestamp ( ) ) { long ts = ftpFile . getTimestamp ( ) . getTimeInMillis ( ) ; timestampMatched = ts > lastPollTime ; if ( log . isTraceEnabled ( ) ) { log . trace ( "The file is to old + " + ftpFile + ". lastPollTime=" + lastPollTime + " > fileTimestamp=" + ts ) ; } } if ( timestampMatched && isMatched ( ftpFile ) ) { String fullFileName = getFullFileName ( ftpFile ) ; if ( exclusiveReadLock ) { acquireExclusiveReadLock ( client , ftpFile ) ; } final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream ( ) ; client . retrieveFile ( ftpFile . getName ( ) , byteArrayOutputStream ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Retrieved file: " + ftpFile . getName ( ) + " from: " + remoteServer ( ) ) ; } RemoteFileExchange exchange = endpoint . createExchange ( fullFileName , ftpFile . getName ( ) , ftpFile . getSize ( ) , byteArrayOutputStream ) ; if ( isSetNames ( ) ) { String ftpBasePath = endpoint . getConfiguration ( ) . getFile ( ) ; String relativePath = fullFileName . substring ( ftpBasePath . length ( ) + 1 ) ; relativePath = relativePath . replaceFirst ( "/" , "" ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Setting exchange filename to " + relativePath ) ; } exchange . getIn ( ) . setHeader ( FileComponent . HEADER_FILE_NAME , relativePath ) ; } if ( deleteFile ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Deleteing file: " + ftpFile . getName ( ) + " from: " + remoteServer ( ) ) ; } boolean deleted = client . deleteFile ( ftpFile . getName ( ) ) ; if ( ! deleted ) { String message = "Can not delete file: " + ftpFile . getName ( ) + " from: " + remoteServer ( ) ; throw new FtpOperationFailedException ( client . getReplyCode ( ) , client . getReplyString ( ) , message ) ; } } else if ( isMoveFile ( ) ) { String fromName = ftpFile . getName ( ) ; String toName = getMoveFileName ( fromName , exchange ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Moving file: " + fromName + " to: " + toName ) ; } boolean deleted = client . deleteFile ( toName ) ; if ( ! deleted ) { int lastPathIndex = toName . lastIndexOf ( '/' ) ; if ( lastPathIndex != - 1 ) { String directory = toName . substring ( 0 , lastPathIndex ) ; if ( ! FtpUtils . buildDirectory ( client , directory ) ) { log . warn ( "Can not build directory: " + directory + " (maybe because of denied permissions)" ) ; } } } boolean success = client . rename ( fromName , toName ) ; if ( ! success ) { String message = "Can not move file: " + fromName + " to: " + toName ; throw new FtpOperationFailedException ( client . getReplyCode ( ) , client . getReplyString ( ) , message ) ; } } getProcessor ( ) . process ( exchange ) ; } } protected void acquireExclusiveReadLock ( FTPClient client , FTPFile ftpFile ) throws IOException { if ( log . isTraceEnabled ( ) ) { log . trace ( "Waiting for exclusive read lock to file: " + ftpFile ) ; } String originalName = ftpFile . getName ( ) ; String newName = originalName + ".camelExclusiveReadLock" ; boolean exclusive = false ; while ( ! exclusive ) { exclusive = client . rename ( originalName , newName ) ; if ( exclusive ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Acquired exclusive read lock to file: " + originalName ) ; } client . rename ( newName , originalName ) ; } else { log . trace ( "Exclusive read lock not granted. Sleeping for 1000 millis." ) ; try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException e ) { } } } } protected String getFileName ( Object file ) { FTPFile ftpFile = ( FTPFile ) file ; return ftpFile . getName ( ) ; } } 	0	['12', '5', '0', '13', '76', '0', '1', '13', '2', '0.515151515', '788', '1', '1', '0.861111111', '0.260416667', '3', '6', '64.41666667', '1', '0.8333', '0']
package org . apache . camel . component . quartz ; import org . apache . camel . CamelContext ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; import org . quartz . JobExecutionContext ; public class QuartzExchange extends DefaultExchange { public QuartzExchange ( CamelContext context , ExchangePattern pattern , JobExecutionContext jobExecutionContext ) { super ( context , pattern ) ; setIn ( new QuartzMessage ( this , jobExecutionContext ) ) ; } @ Override public QuartzMessage getIn ( ) { return ( QuartzMessage ) super . getIn ( ) ; } public JobExecutionContext getJobExecutionContext ( ) { return getIn ( ) . getJobExecutionContext ( ) ; } } 	0	['4', '2', '0', '7', '8', '6', '2', '6', '4', '2', '27', '0', '0', '0.926829268', '0.4375', '1', '1', '5.75', '1', '0.75', '0']
package org . apache . camel . converter ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Properties ; import java . util . Set ; import org . apache . camel . Converter ; @ Converter public final class CollectionConverter { private CollectionConverter ( ) { } @ Converter public static Object [ ] toArray ( Collection value ) { if ( value == null ) { return null ; } return value . toArray ( ) ; } @ Converter public static List toList ( Object [ ] array ) { return Arrays . asList ( array ) ; } @ Converter public static List toList ( Collection collection ) { return new ArrayList ( collection ) ; } @ Converter public static ArrayList toArrayList ( Iterator it ) { ArrayList list = new ArrayList ( ) ; while ( it . hasNext ( ) ) { list . add ( it . next ( ) ) ; } return list ; } @ Converter public static Set toSet ( Object [ ] array ) { Set answer = new HashSet ( ) ; answer . addAll ( Arrays . asList ( array ) ) ; return answer ; } @ Converter public static Set toSet ( Collection collection ) { return new HashSet ( collection ) ; } @ Converter public static Set toSet ( Map map ) { return map . entrySet ( ) ; } @ Converter public static Properties toProperties ( Map map ) { Properties answer = new Properties ( ) ; answer . putAll ( map ) ; return answer ; } @ Converter public static Hashtable toHashtable ( Map map ) { return new Hashtable ( map ) ; } @ Converter public static HashMap toHashMap ( Map map ) { return new HashMap ( map ) ; } @ Converter public static List toList ( Iterable iterable ) { if ( iterable instanceof List ) { return ( List ) iterable ; } List result = new LinkedList ( ) ; for ( Object value : iterable ) { result . add ( value ) ; } return result ; } } 	0	['12', '1', '0', '0', '31', '66', '0', '0', '11', '2', '109', '0', '0', '0', '0.166666667', '0', '0', '8.083333333', '3', '1.25', '0']
package org . apache . camel . component . validator ; import java . io . IOException ; import javax . xml . transform . Source ; import javax . xml . transform . stream . StreamSource ; import org . apache . camel . processor . validation . ValidatingProcessor ; import org . springframework . core . io . Resource ; public class SpringValidator extends ValidatingProcessor { private Resource schemaResource ; public Resource getSchemaResource ( ) { return schemaResource ; } public void setSchemaResource ( Resource schemaResource ) { this . schemaResource = schemaResource ; } @ Override protected Source createSchemaSource ( ) throws IOException { if ( schemaResource != null ) { if ( schemaResource . getURL ( ) == null ) { return new StreamSource ( schemaResource . getInputStream ( ) ) ; } else { return new StreamSource ( schemaResource . getInputStream ( ) , schemaResource . getURL ( ) . toExternalForm ( ) ) ; } } else { throw new IllegalArgumentException ( "You must specify a schema, schemaFile, schemaResource, schemaSource or schemaUrl property" ) ; } } } 	0	['4', '2', '0', '4', '11', '0', '2', '2', '3', '0.333333333', '45', '1', '0', '0.857142857', '0.625', '1', '1', '10', '1', '0.75', '0']
package org . apache . camel . processor . resequencer ; import java . util . TreeSet ; public class Sequence < E > extends TreeSet < E > { private static final long serialVersionUID = 5647393631147741711L ; private SequenceElementComparator < E > comparator ; public Sequence ( SequenceElementComparator < E > comparator ) { super ( comparator ) ; this . comparator = comparator ; } public E predecessor ( E e ) { E elem = lower ( e ) ; if ( elem == null ) { return null ; } if ( comparator . predecessor ( elem , e ) ) { return elem ; } return null ; } public E successor ( E e ) { E elem = higher ( e ) ; if ( elem == null ) { return null ; } if ( comparator . successor ( elem , e ) ) { return elem ; } return null ; } public SequenceElementComparator < E > comparator ( ) { return comparator ; } public E higher ( E e ) { boolean found = false ; for ( E current : this ) { if ( found ) { return current ; } if ( comparator . compare ( e , current ) == 0 ) { found = true ; } } return null ; } public E lower ( E e ) { E last = null ; for ( E current : this ) { if ( comparator . compare ( e , current ) == 0 ) { return last ; } last = current ; } return last ; } } 	0	['7', '4', '0', '2', '13', '0', '1', '1', '7', '0.583333333', '108', '1', '1', '0.85', '0.571428571', '0', '0', '14.14285714', '3', '2', '0']
package org . apache . camel . component . spring . integration . adapter . config ; import org . springframework . beans . factory . xml . NamespaceHandlerSupport ; public class NamespaceHandler extends NamespaceHandlerSupport { public void init ( ) { registerBeanDefinitionParser ( "camelSource" , new CamelSourceAdpaterParser ( ) ) ; registerBeanDefinitionParser ( "camelTarget" , new CamelTargetAdapterParser ( ) ) ; } } 	0	['2', '0', '0', '4', '6', '1', '0', '4', '2', '2', '18', '0', '0', '0', '1', '0', '0', '8', '1', '0.5', '0']
package org . apache . camel . impl ; import java . util . List ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . Service ; public class EventDrivenConsumerRoute < E extends Exchange > extends Route < E > { private Processor processor ; public EventDrivenConsumerRoute ( Endpoint endpoint , Processor processor ) { super ( endpoint ) ; this . processor = processor ; } @ Override public String toString ( ) { return "EventDrivenConsumerRoute[" + getEndpoint ( ) + " -> " + processor + "]" ; } public Processor getProcessor ( ) { return processor ; } public void setProcessor ( Processor processor ) { this . processor = processor ; } @ Override protected void addServices ( List < Service > services ) throws Exception { Endpoint < E > endpoint = getEndpoint ( ) ; Consumer < E > consumer = endpoint . createConsumer ( processor ) ; if ( consumer != null ) { services . add ( consumer ) ; } Processor processor = getProcessor ( ) ; if ( processor instanceof Service ) { services . add ( ( Service ) processor ) ; } } } 	0	['5', '2', '0', '7', '13', '0', '2', '5', '4', '0', '63', '1', '1', '0.692307692', '0.45', '1', '1', '11.4', '1', '0.8', '0']
package org . apache . camel . component . restlet ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . restlet . Client ; import org . restlet . data . Request ; import org . restlet . data . Response ; public class RestletProducer extends DefaultProducer { private static final Log LOG = LogFactory . getLog ( RestletProducer . class ) ; private Client client ; public RestletProducer ( RestletEndpoint endpoint ) throws Exception { super ( endpoint ) ; client = new Client ( endpoint . getProtocol ( ) ) ; } @ Override public void doStart ( ) throws Exception { super . doStart ( ) ; client . start ( ) ; } @ Override public void doStop ( ) throws Exception { client . stop ( ) ; super . doStop ( ) ; } public void process ( Exchange exchange ) throws Exception { RestletEndpoint endpoint = ( RestletEndpoint ) getEndpoint ( ) ; String resourceUri = buildUri ( endpoint ) ; Request request = new Request ( endpoint . getRestletMethod ( ) , resourceUri ) ; RestletBinding binding = endpoint . getRestletBinding ( ) ; binding . populateRestletRequestFromExchange ( request , exchange ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Client sends a request (method: " + request . getMethod ( ) + ", uri: " + resourceUri + ")" ) ; } Response response = client . handle ( request ) ; binding . populateExchangeFromRestletResponse ( exchange , response ) ; } private static String buildUri ( RestletEndpoint endpoint ) { return endpoint . getProtocol ( ) + "://" + endpoint . getHost ( ) + ":" + endpoint . getPort ( ) + endpoint . getUriPattern ( ) ; } } 	0	['6', '3', '0', '11', '32', '1', '1', '11', '4', '0.6', '107', '1', '0', '0.84', '0.466666667', '1', '1', '16.5', '1', '0.6667', '0']
package org . apache . camel . component . cxf ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . converter . AsyncProcessorTypeConverter ; import org . apache . camel . util . AsyncProcessorHelper ; public class AsyncProcessorDecorator implements AsyncProcessor { private final AsyncProcessor processor ; private final Processor before ; private final Processor after ; public AsyncProcessorDecorator ( Processor processor , Processor before , Processor after ) { this . processor = AsyncProcessorTypeConverter . convert ( processor ) ; this . before = before ; this . after = after ; } public void process ( Exchange exchange ) throws Exception { AsyncProcessorHelper . process ( this , exchange ) ; } public boolean process ( final Exchange exchange , final AsyncCallback callback ) { try { before . process ( exchange ) ; } catch ( Throwable t ) { exchange . setException ( t ) ; callback . done ( true ) ; return true ; } return processor . process ( exchange , new AsyncCallback ( ) { public void done ( boolean doneSynchronously ) { try { after . process ( exchange ) ; callback . done ( doneSynchronously ) ; } catch ( Throwable t ) { exchange . setException ( t ) ; } } } ) ; } } 	0	['4', '1', '0', '9', '12', '2', '3', '7', '3', '0.666666667', '52', '1', '3', '0', '0.4', '0', '0', '11.25', '1', '0.75', '0']
package org . apache . camel . component . jpa ; import javax . persistence . EntityManager ; public interface DeleteHandler < T > { void deleteObject ( EntityManager entityManager , Object entityBean ) ; } 	0	['1', '1', '0', '5', '1', '0', '5', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . util ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; import java . util . SortedSet ; import java . util . TreeSet ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . TimeUnit ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DefaultTimeoutMap implements TimeoutMap , Runnable { private static final transient Log LOG = LogFactory . getLog ( DefaultTimeoutMap . class ) ; private final Map map = new HashMap ( ) ; private SortedSet index = new TreeSet ( ) ; private ScheduledExecutorService executor ; private long purgePollTime ; public DefaultTimeoutMap ( ) { this ( null , 1000L ) ; } public DefaultTimeoutMap ( ScheduledExecutorService executor , long requestMapPollTimeMillis ) { this . executor = executor ; this . purgePollTime = requestMapPollTimeMillis ; schedulePoll ( ) ; } public Object get ( Object key ) { TimeoutMapEntry entry = null ; synchronized ( map ) { entry = ( TimeoutMapEntry ) map . get ( key ) ; if ( entry == null ) { return null ; } index . remove ( entry ) ; updateExpireTime ( entry ) ; index . add ( entry ) ; } return entry . getValue ( ) ; } public void put ( Object key , Object value , long timeoutMillis ) { TimeoutMapEntry entry = new TimeoutMapEntry ( key , value , timeoutMillis ) ; synchronized ( map ) { Object oldValue = map . put ( key , entry ) ; if ( oldValue != null ) { index . remove ( oldValue ) ; } updateExpireTime ( entry ) ; index . add ( entry ) ; } } public void remove ( Object id ) { synchronized ( map ) { TimeoutMapEntry entry = ( TimeoutMapEntry ) map . remove ( id ) ; if ( entry != null ) { index . remove ( entry ) ; } } } public Object [ ] getKeys ( ) { Object [ ] keys = null ; synchronized ( map ) { Set keySet = map . keySet ( ) ; keys = new Object [ keySet . size ( ) ] ; keySet . toArray ( keys ) ; } return keys ; } public int size ( ) { synchronized ( map ) { return map . size ( ) ; } } public void run ( ) { purge ( ) ; schedulePoll ( ) ; } public void purge ( ) { long now = currentTime ( ) ; synchronized ( map ) { for ( Iterator iter = index . iterator ( ) ; iter . hasNext ( ) ; ) { TimeoutMapEntry entry = ( TimeoutMapEntry ) iter . next ( ) ; if ( entry == null ) { break ; } if ( entry . getExpireTime ( ) < now ) { if ( isValidForEviction ( entry ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Evicting inactive request for correlationID: " + entry ) ; } map . remove ( entry . getKey ( ) ) ; iter . remove ( ) ; } } else { break ; } } } } public long getPurgePollTime ( ) { return purgePollTime ; } public void setPurgePollTime ( long purgePollTime ) { this . purgePollTime = purgePollTime ; } public ScheduledExecutorService getExecutor ( ) { return executor ; } public void setExecutor ( ScheduledExecutorService executor ) { this . executor = executor ; } protected void schedulePoll ( ) { if ( executor != null ) { executor . schedule ( this , purgePollTime , TimeUnit . MILLISECONDS ) ; } } protected boolean isValidForEviction ( TimeoutMapEntry entry ) { return true ; } protected void updateExpireTime ( TimeoutMapEntry entry ) { long now = currentTime ( ) ; entry . setExpireTime ( entry . getTimeout ( ) + now ) ; } protected long currentTime ( ) { return System . currentTimeMillis ( ) ; } } 	0	['18', '1', '0', '5', '49', '87', '1', '4', '13', '0.694117647', '317', '1', '0', '0', '0.317647059', '0', '0', '16.33333333', '5', '1.2778', '0']
package org . apache . camel . impl ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . ProducerTemplate ; import org . apache . camel . util . ObjectHelper ; public class ProducerTemplateProcessor implements Processor { private final ProducerTemplate producerTemplate ; public ProducerTemplateProcessor ( ProducerTemplate producerTemplate ) { this . producerTemplate = producerTemplate ; ObjectHelper . notNull ( producerTemplate , "producerTemplate" ) ; } public void process ( Exchange exchange ) throws Exception { producerTemplate . send ( exchange ) ; } @ Override public String toString ( ) { return "ProducerTemplateProcessor[" + producerTemplate + "]" ; } } 	0	['3', '1', '0', '5', '10', '0', '1', '4', '3', '0', '31', '1', '1', '0', '0.555555556', '0', '0', '9', '1', '0.6667', '0']
package org . apache . camel . component . jms ; import javax . jms . JMSException ; public class MessagePropertyNamesAccessException extends RuntimeJmsException { private static final long serialVersionUID = - 6744171518099741324L ; public MessagePropertyNamesAccessException ( JMSException e ) { super ( "Failed to access the JMS message property names: " + e , e ) ; } } 	0	['1', '5', '0', '2', '6', '0', '1', '1', '1', '2', '14', '1', '0', '1', '1', '0', '0', '12', '0', '0', '0']
package org . apache . camel . component . direct ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultConsumer ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . impl . converter . AsyncProcessorTypeConverter ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DirectProducer < E extends Exchange > extends DefaultProducer implements AsyncProcessor { private static final transient Log LOG = LogFactory . getLog ( DirectProducer . class ) ; private DirectEndpoint < E > endpoint ; public DirectProducer ( DirectEndpoint < E > endpoint ) { super ( endpoint ) ; this . endpoint = endpoint ; } public void process ( Exchange exchange ) throws Exception { if ( endpoint . getConsumers ( ) . isEmpty ( ) ) { LOG . warn ( "No getConsumers() available on " + this + " for " + exchange ) ; } else { for ( DefaultConsumer < E > consumer : endpoint . getConsumers ( ) ) { consumer . getProcessor ( ) . process ( exchange ) ; } } } public boolean process ( Exchange exchange , AsyncCallback callback ) { int size = endpoint . getConsumers ( ) . size ( ) ; if ( size == 0 ) { LOG . warn ( "No getConsumers() available on " + this + " for " + exchange ) ; } else if ( size == 1 ) { DefaultConsumer < E > consumer = endpoint . getConsumers ( ) . get ( 0 ) ; AsyncProcessor processor = AsyncProcessorTypeConverter . convert ( consumer . getProcessor ( ) ) ; return processor . process ( exchange , callback ) ; } else if ( size > 1 ) { try { for ( DefaultConsumer < E > consumer : endpoint . getConsumers ( ) ) { consumer . getProcessor ( ) . process ( exchange ) ; } } catch ( Throwable error ) { exchange . setException ( error ) ; } } callback . done ( true ) ; return true ; } } 	0	['4', '3', '0', '11', '24', '0', '1', '11', '3', '0.333333333', '126', '1', '1', '0.913043478', '0.583333333', '0', '0', '30', '4', '1.25', '0']
package org . apache . camel . util ; import java . io . UnsupportedEncodingException ; import java . util . BitSet ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public final class UnsafeUriCharactersEncoder { private static BitSet unsafeCharacters ; private static final transient Log LOG = LogFactory . getLog ( UnsafeUriCharactersEncoder . class ) ; private static final char [ ] HEX_DIGITS = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } ; static { unsafeCharacters = new BitSet ( 256 ) ; unsafeCharacters . set ( ' ' ) ; unsafeCharacters . set ( '"' ) ; unsafeCharacters . set ( '<' ) ; unsafeCharacters . set ( '>' ) ; unsafeCharacters . set ( '#' ) ; unsafeCharacters . set ( '%' ) ; unsafeCharacters . set ( '{' ) ; unsafeCharacters . set ( '}' ) ; unsafeCharacters . set ( '|' ) ; unsafeCharacters . set ( '\\' ) ; unsafeCharacters . set ( '^' ) ; unsafeCharacters . set ( '~' ) ; unsafeCharacters . set ( '[' ) ; unsafeCharacters . set ( ']' ) ; unsafeCharacters . set ( '`' ) ; } private UnsafeUriCharactersEncoder ( ) { } public static String encode ( String s ) { int n = s . length ( ) ; if ( n == 0 ) { return s ; } try { byte [ ] bytes = s . getBytes ( "UTF8" ) ; for ( int i = 0 ; ; ) { if ( unsafeCharacters . get ( bytes [ i ] ) ) { break ; } if ( ++ i >= bytes . length ) { return s ; } } StringBuffer sb = new StringBuffer ( ) ; for ( byte b : bytes ) { if ( unsafeCharacters . get ( b ) ) { appendEscape ( sb , b ) ; } else { sb . append ( ( char ) b ) ; } } return sb . toString ( ) ; } catch ( UnsupportedEncodingException e ) { LOG . error ( "Can't encoding the uri: " , e ) ; return null ; } } private static void appendEscape ( StringBuffer sb , byte b ) { sb . append ( '%' ) ; sb . append ( HEX_DIGITS [ ( b > > 4 ) & 0x0f ] ) ; sb . append ( HEX_DIGITS [ ( b > > 0 ) & 0x0f ] ) ; } } 	0	['4', '1', '0', '5', '15', '2', '3', '2', '1', '0.555555556', '226', '1', '0', '0', '0.333333333', '0', '0', '54.75', '6', '1.75', '0']
package org . apache . camel ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . TYPE , ElementType . METHOD } ) public @ interface Pattern { ExchangePattern value ( ) ; } 	0	['1', '1', '0', '2', '1', '0', '1', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . sql ; import java . util . Map ; import javax . sql . DataSource ; import org . apache . camel . Component ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . util . IntrospectionSupport ; import org . springframework . jdbc . core . JdbcTemplate ; public class SqlEndpoint extends DefaultEndpoint { private JdbcTemplate jdbcTemplate ; private String query ; public SqlEndpoint ( String uri , String query , Component component , DataSource dataSource , Map parameters ) throws Exception { super ( uri , component ) ; this . jdbcTemplate = new JdbcTemplate ( dataSource ) ; IntrospectionSupport . setProperties ( jdbcTemplate , parameters , "template." ) ; this . query = query ; } public SqlEndpoint ( String endpointUri , JdbcTemplate jdbcTemplate , String query ) { super ( endpointUri ) ; this . jdbcTemplate = jdbcTemplate ; this . query = query ; } public Consumer createConsumer ( Processor processor ) throws Exception { throw new UnsupportedOperationException ( "Not implemented" ) ; } public Producer createProducer ( ) throws Exception { return new SqlProducer ( this , query , jdbcTemplate ) ; } public boolean isSingleton ( ) { return false ; } } 	0	['5', '2', '0', '9', '11', '4', '2', '8', '5', '0.5', '53', '1', '0', '0.888888889', '0.342857143', '0', '0', '9.2', '1', '0.6', '0']
@ javax . xml . bind . annotation . XmlSchema ( namespace = "http://activemq.apache.org/camel/schema/spring" , elementFormDefault = javax . xml . bind . annotation . XmlNsForm . QUALIFIED ) package org . apache . camel . model . config ; 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . component . vm ; import java . util . HashMap ; import java . util . Map ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . atomic . AtomicInteger ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . component . seda . SedaComponent ; import org . apache . camel . component . seda . SedaEndpoint ; public class VmComponent extends SedaComponent { protected static final Map < String , BlockingQueue > QUEUES = new HashMap < String , BlockingQueue > ( ) ; private static final AtomicInteger START_COUNTER = new AtomicInteger ( ) ; @ Override protected Endpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { BlockingQueue < Exchange > blockingQueue = getBlockingQueue ( uri , parameters ) ; return new SedaEndpoint ( uri , this , blockingQueue ) ; } protected BlockingQueue < Exchange > getBlockingQueue ( String uri , Map parameters ) { synchronized ( QUEUES ) { BlockingQueue < Exchange > answer = QUEUES . get ( uri ) ; if ( answer == null ) { answer = createQueue ( uri , parameters ) ; QUEUES . put ( uri , answer ) ; } return answer ; } } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; START_COUNTER . incrementAndGet ( ) ; } @ Override protected void doStop ( ) throws Exception { super . doStop ( ) ; if ( START_COUNTER . decrementAndGet ( ) == 0 ) { synchronized ( QUEUES ) { for ( BlockingQueue q : QUEUES . values ( ) ) { q . clear ( ) ; } QUEUES . clear ( ) ; } } } } 	0	['6', '4', '0', '4', '23', '5', '0', '4', '1', '0.5', '102', '1', '0', '0.902439024', '0.6', '2', '2', '15.66666667', '2', '0.8333', '0']
package org . apache . camel . component . jms ; import java . util . List ; import org . apache . camel . Exchange ; import org . springframework . jms . core . JmsOperations ; public interface QueueBrowseStrategy { List < Exchange > browse ( JmsOperations template , String queue , JmsQueueEndpoint endpoint ) ; } 	0	['1', '1', '0', '5', '1', '0', '4', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . seda ; import java . util . Map ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . LinkedBlockingQueue ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultComponent ; public class SedaComponent extends DefaultComponent < Exchange > { public BlockingQueue < Exchange > createQueue ( String uri , Map parameters ) { int size = getAndRemoveParameter ( parameters , "size" , Integer . class , 1000 ) ; return new LinkedBlockingQueue < Exchange > ( size ) ; } @ Override protected Endpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { return new SedaEndpoint ( uri , this , parameters ) ; } } 	0	['3', '3', '2', '5', '9', '3', '3', '3', '2', '2', '28', '0', '0', '0.945945946', '0.777777778', '1', '1', '8.333333333', '1', '0.6667', '0']
package org . apache . camel . component . cxf . invoker ; import org . apache . camel . component . cxf . DataFormat ; public final class InvokingContextFactory { private InvokingContextFactory ( ) { } public static InvokingContext createContext ( DataFormat dataFormat ) { if ( dataFormat == DataFormat . MESSAGE ) { return new RawMessageInvokingContext ( ) ; } if ( dataFormat == DataFormat . PAYLOAD ) { return new PayloadInvokingContext ( ) ; } return new RawMessageInvokingContext ( ) ; } } 	0	['2', '1', '0', '5', '5', '1', '1', '4', '1', '2', '23', '0', '0', '0', '0.5', '0', '0', '10.5', '3', '1.5', '0']
package org . apache . camel . component . jms ; import javax . jms . Message ; import javax . jms . TemporaryQueue ; import javax . jms . TemporaryTopic ; import org . apache . camel . ExchangePattern ; import org . apache . camel . HeaderFilterStrategyAware ; import org . apache . camel . PollingConsumer ; import org . apache . camel . Processor ; import org . apache . camel . component . jms . requestor . Requestor ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . spi . HeaderFilterStrategy ; import org . springframework . jms . core . JmsOperations ; import org . springframework . jms . core . JmsTemplate ; import org . springframework . jms . listener . AbstractMessageListenerContainer ; public class JmsEndpoint extends DefaultEndpoint < JmsExchange > { private final boolean pubSubDomain ; private JmsBinding binding ; private String destination ; private String selector ; private JmsConfiguration configuration ; private Requestor requestor ; public JmsEndpoint ( String uri , JmsComponent component , String destination , boolean pubSubDomain , JmsConfiguration configuration ) { super ( uri , component ) ; this . configuration = configuration ; this . destination = destination ; this . pubSubDomain = pubSubDomain ; } public JmsEndpoint ( String endpointUri , JmsBinding binding , JmsConfiguration configuration , String destination , boolean pubSubDomain ) { super ( endpointUri ) ; this . binding = binding ; this . configuration = configuration ; this . destination = destination ; this . pubSubDomain = pubSubDomain ; } public JmsEndpoint ( String endpointUri , String destination , boolean pubSubDomain ) { this ( endpointUri , new JmsBinding ( ) , new JmsConfiguration ( ) , destination , pubSubDomain ) ; } public JmsEndpoint ( String endpointUri , String destination ) { this ( endpointUri , destination , true ) ; } public JmsProducer createProducer ( ) throws Exception { return new JmsProducer ( this ) ; } public JmsProducer createProducer ( JmsOperations template ) throws Exception { JmsProducer answer = createProducer ( ) ; if ( template instanceof JmsTemplate ) { JmsTemplate jmsTemplate = ( JmsTemplate ) template ; jmsTemplate . setPubSubDomain ( pubSubDomain ) ; jmsTemplate . setDefaultDestinationName ( destination ) ; } answer . setInOnlyTemplate ( template ) ; return answer ; } public JmsConsumer createConsumer ( Processor processor ) throws Exception { AbstractMessageListenerContainer listenerContainer = configuration . createMessageListenerContainer ( this ) ; return createConsumer ( processor , listenerContainer ) ; } public JmsConsumer createConsumer ( Processor processor , AbstractMessageListenerContainer listenerContainer ) throws Exception { listenerContainer . setDestinationName ( destination ) ; listenerContainer . setPubSubDomain ( pubSubDomain ) ; return new JmsConsumer ( this , processor , listenerContainer ) ; } @ Override public PollingConsumer < JmsExchange > createPollingConsumer ( ) throws Exception { JmsOperations template = createInOnlyTemplate ( ) ; return new JmsPollingConsumer ( this , template ) ; } @ Override public JmsExchange createExchange ( ExchangePattern pattern ) { return new JmsExchange ( getCamelContext ( ) , pattern , getBinding ( ) ) ; } public JmsExchange createExchange ( Message message ) { return new JmsExchange ( getCamelContext ( ) , getExchangePattern ( ) , getBinding ( ) , message ) ; } public JmsOperations createInOnlyTemplate ( ) { return configuration . createInOnlyTemplate ( this , pubSubDomain , destination ) ; } public JmsOperations createInOutTemplate ( ) { return configuration . createInOutTemplate ( this , pubSubDomain , destination , getRequestTimeout ( ) ) ; } public JmsBinding getBinding ( ) { if ( binding == null ) { binding = new JmsBinding ( this ) ; } return binding ; } public void setBinding ( JmsBinding binding ) { this . binding = binding ; } public String getDestination ( ) { return destination ; } public JmsConfiguration getConfiguration ( ) { return configuration ; } public String getSelector ( ) { return selector ; } public void setSelector ( String selector ) { this . selector = selector ; } public boolean isSingleton ( ) { return false ; } public synchronized Requestor getRequestor ( ) throws Exception { if ( requestor == null ) { requestor = new Requestor ( getConfiguration ( ) , getExecutorService ( ) ) ; requestor . start ( ) ; } return requestor ; } public void setRequestor ( Requestor requestor ) { this . requestor = requestor ; } public long getRequestTimeout ( ) { return configuration . getRequestTimeout ( ) ; } public void setRequestTimeout ( long requestTimeout ) { configuration . setRequestTimeout ( requestTimeout ) ; } public boolean isPubSubDomain ( ) { return pubSubDomain ; } public Class < ? extends TemporaryQueue > getTemporaryQueueType ( ) { JmsProviderMetadata metadata = getProviderMetadata ( ) ; JmsOperations template = getMetadataJmsOperations ( ) ; return metadata . getTemporaryQueueType ( template ) ; } public Class < ? extends TemporaryTopic > getTemporaryTopicType ( ) { JmsOperations template = getMetadataJmsOperations ( ) ; JmsProviderMetadata metadata = getProviderMetadata ( ) ; return metadata . getTemporaryTopicType ( template ) ; } protected JmsProviderMetadata getProviderMetadata ( ) { JmsConfiguration conf = getConfiguration ( ) ; JmsProviderMetadata metadata = conf . getProviderMetadata ( ) ; return metadata ; } protected JmsOperations getMetadataJmsOperations ( ) { JmsOperations template = getConfiguration ( ) . getMetadataJmsOperations ( this ) ; if ( template == null ) { throw new IllegalArgumentException ( "No Metadata JmsTemplate supplied!" ) ; } return template ; } public void checkValidTemplate ( JmsTemplate template ) { if ( template . getDestinationResolver ( ) == null ) { if ( this instanceof DestinationEndpoint ) { final DestinationEndpoint destinationEndpoint = ( DestinationEndpoint ) this ; template . setDestinationResolver ( JmsConfiguration . createDestinationResolver ( destinationEndpoint ) ) ; } } } public HeaderFilterStrategy getHeaderFilterStrategy ( ) { if ( getComponent ( ) instanceof HeaderFilterStrategyAware ) { return ( ( HeaderFilterStrategyAware ) getComponent ( ) ) . getHeaderFilterStrategy ( ) ; } else { return new JmsHeaderFilterStrategy ( ) ; } } } 	0	['34', '2', '2', '32', '67', '453', '12', '26', '32', '0.772727273', '334', '1', '3', '0.444444444', '0.121848739', '1', '1', '8.647058824', '3', '1.0294', '0']
package org . apache . camel . component . atom ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class AtomProducer extends DefaultProducer { private static final transient Log LOG = LogFactory . getLog ( AtomProducer . class ) ; private final AtomEndpoint endpoint ; public AtomProducer ( AtomEndpoint endpoint ) { super ( endpoint ) ; this . endpoint = endpoint ; } public void process ( Exchange exchange ) throws Exception { throw new UnsupportedOperationException ( "AtomProducer is not implemented" ) ; } } 	0	['3', '3', '0', '6', '6', '3', '0', '6', '2', '1', '21', '1', '1', '0.954545455', '0.666666667', '0', '0', '5.333333333', '1', '0.3333', '0']
package org . apache . camel . util ; public class ValueHolder < V > { private V value ; public ValueHolder ( ) { } public ValueHolder ( V val ) { value = val ; } public V get ( ) { return value ; } public void set ( V val ) { value = val ; } } 	0	['4', '1', '0', '2', '5', '0', '2', '0', '4', '0.333333333', '21', '1', '0', '0', '0.75', '0', '0', '4', '1', '0.5', '0']
package org . apache . camel . component . cxf ; import java . io . InputStream ; import java . util . List ; import java . util . Map ; import javax . xml . transform . Source ; import org . apache . camel . NoTypeConversionAvailableException ; import org . apache . camel . component . cxf . util . CxfHeaderHelper ; import org . apache . camel . impl . DefaultHeaderFilterStrategy ; import org . apache . camel . spi . HeaderFilterStrategy ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . cxf . message . ExchangeImpl ; import org . apache . cxf . message . MessageImpl ; public final class CxfSoapBinding { private static final Log LOG = LogFactory . getLog ( CxfSoapBinding . class ) ; private CxfSoapBinding ( ) { } public static org . apache . cxf . message . Message getCxfInMessage ( org . apache . camel . Exchange exchange , boolean isClient ) { return CxfSoapBinding . getCxfInMessage ( new DefaultHeaderFilterStrategy ( ) , exchange , isClient ) ; } public static org . apache . cxf . message . Message getCxfInMessage ( HeaderFilterStrategy headerFilterStrategy , org . apache . camel . Exchange exchange , boolean isClient ) { MessageImpl answer = new MessageImpl ( ) ; org . apache . cxf . message . Exchange cxfExchange = exchange . getProperty ( CxfConstants . CXF_EXCHANGE , org . apache . cxf . message . Exchange . class ) ; org . apache . camel . Message message = null ; if ( isClient ) { message = exchange . getOut ( ) ; } else { message = exchange . getIn ( ) ; } ObjectHelper . notNull ( message , "message" ) ; if ( cxfExchange == null ) { cxfExchange = new ExchangeImpl ( ) ; exchange . setProperty ( CxfConstants . CXF_EXCHANGE , cxfExchange ) ; } CxfHeaderHelper . propagateCamelToCxf ( headerFilterStrategy , message . getHeaders ( ) , answer ) ; try { InputStream body = message . getBody ( InputStream . class ) ; answer . setContent ( InputStream . class , body ) ; } catch ( NoTypeConversionAvailableException ex ) { LOG . warn ( "Can't get right InputStream object here, the message body is " + message . getBody ( ) ) ; } answer . putAll ( message . getHeaders ( ) ) ; answer . setExchange ( cxfExchange ) ; cxfExchange . setInMessage ( answer ) ; return answer ; } public static org . apache . cxf . message . Message getCxfOutMessage ( org . apache . camel . Exchange exchange , boolean isClient ) { return CxfSoapBinding . getCxfOutMessage ( new DefaultHeaderFilterStrategy ( ) , exchange , isClient ) ; } public static org . apache . cxf . message . Message getCxfOutMessage ( HeaderFilterStrategy headerFilterStrategy , org . apache . camel . Exchange exchange , boolean isClient ) { org . apache . cxf . message . Exchange cxfExchange = exchange . getProperty ( CxfConstants . CXF_EXCHANGE , org . apache . cxf . message . Exchange . class ) ; ObjectHelper . notNull ( cxfExchange , "cxfExchange" ) ; org . apache . cxf . endpoint . Endpoint cxfEndpoint = cxfExchange . get ( org . apache . cxf . endpoint . Endpoint . class ) ; org . apache . cxf . message . Message outMessage = cxfEndpoint . getBinding ( ) . createMessage ( ) ; outMessage . setExchange ( cxfExchange ) ; cxfExchange . setOutMessage ( outMessage ) ; org . apache . camel . Message message = null ; if ( isClient ) { message = exchange . getIn ( ) ; } else { message = exchange . getOut ( ) ; } CxfHeaderHelper . propagateCamelToCxf ( headerFilterStrategy , message . getHeaders ( ) , outMessage ) ; try { Source body = message . getBody ( Source . class ) ; outMessage . setContent ( Source . class , body ) ; } catch ( NoTypeConversionAvailableException ex ) { LOG . warn ( "Can't get right Source object here, the message body is " + message . getBody ( ) ) ; } outMessage . putAll ( message . getHeaders ( ) ) ; return outMessage ; } public static void setProtocolHeader ( Map < String , Object > headers , Map < String , List < String > > protocolHeader ) { if ( protocolHeader != null ) { StringBuilder value = new StringBuilder ( 256 ) ; for ( Map . Entry < String , List < String > > entry : protocolHeader . entrySet ( ) ) { value . setLength ( 0 ) ; boolean first = true ; for ( String s : entry . getValue ( ) ) { if ( ! first ) { value . append ( "; " ) ; } value . append ( s ) ; first = false ; } headers . put ( entry . getKey ( ) , value . toString ( ) ) ; } } } } 	0	['7', '1', '0', '19', '47', '15', '4', '15', '5', '0.333333333', '227', '1', '0', '0', '0.4', '0', '0', '31.28571429', '5', '1.7143', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . builder . ExpressionBuilder ; import org . apache . camel . builder . ProcessorBuilder ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . spi . RouteContext ; import org . apache . camel . util . ObjectHelper ; @ XmlRootElement ( name = "setProperty" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class SetPropertyType extends ExpressionNode { @ XmlAttribute ( required = true ) private String propertyName ; public SetPropertyType ( ) { } public SetPropertyType ( String propertyName , ExpressionType expression ) { super ( expression ) ; setPropertyName ( propertyName ) ; } public SetPropertyType ( String propertyName , Expression expression ) { super ( expression ) ; setPropertyName ( propertyName ) ; } public SetPropertyType ( String propertyName , String value ) { super ( ExpressionBuilder . constantExpression ( value ) ) ; setPropertyName ( propertyName ) ; } @ Override public String toString ( ) { return "SetProperty[" + getPropertyName ( ) + ", " + getExpression ( ) + "]" ; } @ Override public String getShortName ( ) { return "setProperty" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { ObjectHelper . notNull ( getPropertyName ( ) , "propertyName" ) ; Expression expr = getExpression ( ) . createExpression ( routeContext ) ; return ProcessorBuilder . setProperty ( getPropertyName ( ) , expr ) ; } public void setPropertyName ( String propertyName ) { this . propertyName = propertyName ; } public String getPropertyName ( ) { return propertyName ; } } 	0	['9', '4', '0', '9', '21', '34', '1', '8', '9', '0.25', '75', '1', '0', '0.973544974', '0.355555556', '2', '3', '7.222222222', '1', '0.5556', '0']
package org . apache . camel ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . TYPE , ElementType . METHOD } ) public @ interface Converter { } 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . component . http ; import org . apache . commons . httpclient . Credentials ; import org . apache . commons . httpclient . HttpClient ; import org . apache . commons . httpclient . UsernamePasswordCredentials ; import org . apache . commons . httpclient . auth . AuthScope ; public class BasicAuthenticationHttpClientConfigurer implements HttpClientConfigurer { private final String username ; private final String password ; public BasicAuthenticationHttpClientConfigurer ( String user , String pwd ) { username = user ; password = pwd ; } public void configureHttpClient ( HttpClient client ) { Credentials defaultcreds = new UsernamePasswordCredentials ( username , password ) ; client . getState ( ) . setCredentials ( AuthScope . ANY , defaultcreds ) ; } } 	0	['2', '1', '0', '7', '6', '0', '1', '6', '2', '0', '27', '1', '0', '0', '0.666666667', '0', '0', '11.5', '1', '0.5', '0']
package org . apache . camel . util ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import javax . xml . bind . JAXBException ; import org . apache . camel . CamelContext ; import org . apache . camel . ProducerTemplate ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . impl . DefaultCamelContext ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . model . RouteType ; import org . apache . camel . processor . interceptor . Debugger ; import org . apache . camel . view . ModelFileGenerator ; import org . apache . camel . view . RouteDotGenerator ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public abstract class MainSupport extends ServiceSupport { protected static final Log LOG = LogFactory . getLog ( MainSupport . class ) ; protected String dotOutputDir ; private List < Option > options = new ArrayList < Option > ( ) ; private CountDownLatch latch = new CountDownLatch ( 1 ) ; private AtomicBoolean completed = new AtomicBoolean ( false ) ; private long duration = - 1 ; private TimeUnit timeUnit = TimeUnit . MILLISECONDS ; private String routesOutputFile ; private boolean aggregateDot ; private boolean debug ; private boolean trace ; private List < RouteBuilder > routeBuilders = new ArrayList < RouteBuilder > ( ) ; private List < CamelContext > camelContexts = new ArrayList < CamelContext > ( ) ; private ProducerTemplate camelTemplate ; protected MainSupport ( ) { addOption ( new Option ( "h" , "help" , "Displays the help screen" ) { protected void doProcess ( String arg , LinkedList < String > remainingArgs ) { showOptions ( ) ; completed ( ) ; } } ) ; addOption ( new ParameterOption ( "o" , "outdir" , "Sets the DOT output directory where the visual representations of the routes are generated" , "dot" ) { protected void doProcess ( String arg , String parameter , LinkedList < String > remainingArgs ) { setDotOutputDir ( parameter ) ; } } ) ; addOption ( new ParameterOption ( "ad" , "aggregate-dot" , "Aggregates all routes (in addition to individual route generation) into one context to create one monolithic DOT file for visual representations the entire system." , "aggregate-dot" ) { protected void doProcess ( String arg , String parameter , LinkedList < String > remainingArgs ) { setAggregateDot ( "true" . equals ( parameter ) ) ; } } ) ; addOption ( new ParameterOption ( "d" , "duration" , "Sets the time duration that the applicaiton will run for, by default in milliseconds. You can use '10s' for 10 seconds etc" , "duration" ) { protected void doProcess ( String arg , String parameter , LinkedList < String > remainingArgs ) { String value = parameter . toUpperCase ( ) ; if ( value . endsWith ( "S" ) ) { value = value . substring ( 0 , value . length ( ) - 1 ) ; setTimeUnit ( TimeUnit . SECONDS ) ; } setDuration ( Integer . parseInt ( value ) ) ; } } ) ; addOption ( new Option ( "x" , "debug" , "Enables the debugger" ) { protected void doProcess ( String arg , LinkedList < String > remainingArgs ) { enableDebug ( ) ; } } ) ; addOption ( new Option ( "t" , "trace" , "Enables tracing" ) { protected void doProcess ( String arg , LinkedList < String > remainingArgs ) { enableTrace ( ) ; } } ) ; addOption ( new ParameterOption ( "out" , "output" , "Output all routes to the specified XML file" , "filename" ) { protected void doProcess ( String arg , String parameter , LinkedList < String > remainingArgs ) { setRoutesOutputFile ( parameter ) ; } } ) ; } public void run ( ) { if ( ! completed . get ( ) ) { try { start ( ) ; waitUntilCompleted ( ) ; stop ( ) ; } catch ( Exception e ) { LOG . error ( "Failed: " + e , e ) ; } } } public void completed ( ) { completed . set ( true ) ; latch . countDown ( ) ; } public void showOptions ( ) { showOptionsHeader ( ) ; for ( Option option : options ) { System . out . println ( option . getInformation ( ) ) ; } } public void parseArguments ( String [ ] arguments ) { LinkedList < String > args = new LinkedList < String > ( Arrays . asList ( arguments ) ) ; boolean valid = true ; while ( ! args . isEmpty ( ) ) { String arg = args . removeFirst ( ) ; boolean handled = false ; for ( Option option : options ) { if ( option . processOption ( arg , args ) ) { handled = true ; break ; } } if ( ! handled ) { System . out . println ( "Unknown option: " + arg ) ; System . out . println ( ) ; valid = false ; break ; } } if ( ! valid ) { showOptions ( ) ; completed ( ) ; } } public void addOption ( Option option ) { options . add ( option ) ; } public long getDuration ( ) { return duration ; } public void setDuration ( long duration ) { this . duration = duration ; } public TimeUnit getTimeUnit ( ) { return timeUnit ; } public void setTimeUnit ( TimeUnit timeUnit ) { this . timeUnit = timeUnit ; } public String getDotOutputDir ( ) { return dotOutputDir ; } public void setDotOutputDir ( String dotOutputDir ) { this . dotOutputDir = dotOutputDir ; } public void setAggregateDot ( boolean aggregateDot ) { this . aggregateDot = aggregateDot ; } public boolean isAggregateDot ( ) { return aggregateDot ; } public boolean isDebug ( ) { return debug ; } public void enableDebug ( ) { this . debug = true ; } public boolean isTrace ( ) { return trace ; } public void enableTrace ( ) { this . trace = true ; } public void setRoutesOutputFile ( String routesOutputFile ) { this . routesOutputFile = routesOutputFile ; } public String getRoutesOutputFile ( ) { return routesOutputFile ; } public Debugger getDebugger ( ) { for ( CamelContext camelContext : camelContexts ) { Debugger debugger = Debugger . getDebugger ( camelContext ) ; if ( debugger != null ) { return debugger ; } } return null ; } protected void doStop ( ) throws Exception { LOG . info ( "Apache Camel " + getVersion ( ) + " stopping" ) ; completed ( ) ; } protected void doStart ( ) throws Exception { LOG . info ( "Apache Camel " + getVersion ( ) + " starting" ) ; } protected void waitUntilCompleted ( ) { while ( ! completed . get ( ) ) { try { if ( duration > 0 ) { TimeUnit unit = getTimeUnit ( ) ; LOG . info ( "Waiting for: " + duration + " " + unit ) ; latch . await ( duration , unit ) ; completed . set ( true ) ; } else { latch . await ( ) ; } } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } } } public void run ( String [ ] args ) { parseArguments ( args ) ; run ( ) ; } public void showOptionsHeader ( ) { System . out . println ( "Apache Camel Runner takes the following options" ) ; System . out . println ( ) ; } public List < CamelContext > getCamelContexts ( ) { return camelContexts ; } public List < RouteBuilder > getRouteBuilders ( ) { return routeBuilders ; } public void setRouteBuilders ( List < RouteBuilder > routeBuilders ) { this . routeBuilders = routeBuilders ; } public List < RouteType > getRouteDefinitions ( ) { List < RouteType > answer = new ArrayList < RouteType > ( ) ; for ( CamelContext camelContext : camelContexts ) { answer . addAll ( camelContext . getRouteDefinitions ( ) ) ; } return answer ; } public ProducerTemplate getCamelTemplate ( ) { if ( camelTemplate == null ) { camelTemplate = findOrCreateCamelTemplate ( ) ; } return camelTemplate ; } protected abstract ProducerTemplate findOrCreateCamelTemplate ( ) ; protected abstract Map < String , CamelContext > getCamelContextMap ( ) ; protected void postProcessContext ( ) throws Exception { Map < String , CamelContext > map = getCamelContextMap ( ) ; Set < Map . Entry < String , CamelContext > > entries = map . entrySet ( ) ; int size = entries . size ( ) ; for ( Map . Entry < String , CamelContext > entry : entries ) { String name = entry . getKey ( ) ; CamelContext camelContext = entry . getValue ( ) ; camelContexts . add ( camelContext ) ; generateDot ( name , camelContext , size ) ; postProcesCamelContext ( camelContext ) ; } if ( isAggregateDot ( ) ) { generateDot ( "aggregate" , aggregateCamelContext ( ) , 1 ) ; } if ( ! "" . equals ( getRoutesOutputFile ( ) ) ) { outputRoutesToFile ( ) ; } } protected void outputRoutesToFile ( ) throws IOException , JAXBException { if ( ObjectHelper . isNotNullAndNonEmpty ( getRoutesOutputFile ( ) ) ) { LOG . info ( "Generating routes as XML in the file named: " + getRoutesOutputFile ( ) ) ; ModelFileGenerator generator = createModelFileGenerator ( ) ; generator . marshalRoutesUsingJaxb ( getRoutesOutputFile ( ) , getRouteDefinitions ( ) ) ; } } protected abstract ModelFileGenerator createModelFileGenerator ( ) throws JAXBException ; protected void generateDot ( String name , CamelContext camelContext , int size ) throws IOException { String outputDir = dotOutputDir ; if ( ObjectHelper . isNotNullAndNonEmpty ( outputDir ) ) { if ( size > 1 ) { outputDir += "/" + name ; } RouteDotGenerator generator = new RouteDotGenerator ( outputDir ) ; LOG . info ( "Generating DOT file for routes: " + outputDir + " for: " + camelContext + " with name: " + name ) ; generator . drawRoutes ( camelContext ) ; } } private CamelContext aggregateCamelContext ( ) throws Exception { if ( camelContexts . size ( ) == 1 ) { return camelContexts . get ( 0 ) ; } else { DefaultCamelContext answer = new DefaultCamelContext ( ) ; for ( CamelContext camelContext : camelContexts ) { answer . addRouteDefinitions ( camelContext . getRouteDefinitions ( ) ) ; } return answer ; } } protected void postProcesCamelContext ( CamelContext camelContext ) throws Exception { for ( RouteBuilder routeBuilder : routeBuilders ) { camelContext . addRoutes ( routeBuilder ) ; } } public void addRouteBuilder ( RouteBuilder routeBuilder ) { getRouteBuilders ( ) . add ( routeBuilder ) ; } public abstract class Option { private String abbreviation ; private String fullName ; private String description ; protected Option ( String abbreviation , String fullName , String description ) { this . abbreviation = "-" + abbreviation ; this . fullName = "-" + fullName ; this . description = description ; } public boolean processOption ( String arg , LinkedList < String > remainingArgs ) { if ( arg . equalsIgnoreCase ( abbreviation ) || fullName . startsWith ( arg ) ) { doProcess ( arg , remainingArgs ) ; return true ; } return false ; } public String getAbbreviation ( ) { return abbreviation ; } public String getDescription ( ) { return description ; } public String getFullName ( ) { return fullName ; } public String getInformation ( ) { return "  " + getAbbreviation ( ) + " or " + getFullName ( ) + " = " + getDescription ( ) ; } protected abstract void doProcess ( String arg , LinkedList < String > remainingArgs ) ; } public abstract class ParameterOption extends Option { private String parameterName ; protected ParameterOption ( String abbreviation , String fullName , String description , String parameterName ) { super ( abbreviation , fullName , description ) ; this . parameterName = parameterName ; } protected void doProcess ( String arg , LinkedList < String > remainingArgs ) { if ( remainingArgs . isEmpty ( ) ) { System . err . println ( "Expected fileName for " ) ; showOptions ( ) ; completed ( ) ; } else { String parameter = remainingArgs . removeFirst ( ) ; doProcess ( arg , parameter , remainingArgs ) ; } } public String getInformation ( ) { return "  " + getAbbreviation ( ) + " or " + getFullName ( ) + " <" + parameterName + "> = " + getDescription ( ) ; } protected abstract void doProcess ( String arg , String parameter , LinkedList < String > remainingArgs ) ; } } 	0	['41', '2', '1', '24', '100', '684', '12', '20', '28', '0.905357143', '669', '1', '1', '0.264150943', '0.122727273', '1', '1', '14.97560976', '4', '1.1951', '0']
package org . apache . camel . component . cxf . util ; import javax . xml . namespace . QName ; import org . apache . cxf . binding . AbstractBindingFactory ; import org . apache . cxf . binding . soap . interceptor . CheckFaultInterceptor ; import org . apache . cxf . binding . soap . interceptor . MustUnderstandInterceptor ; import org . apache . cxf . binding . soap . interceptor . ReadHeadersInterceptor ; import org . apache . cxf . binding . soap . interceptor . SoapActionInInterceptor ; import org . apache . cxf . binding . soap . interceptor . SoapActionOutInterceptor ; import org . apache . cxf . binding . soap . interceptor . SoapHeaderInterceptor ; import org . apache . cxf . binding . soap . interceptor . SoapHeaderOutFilterInterceptor ; import org . apache . cxf . binding . soap . interceptor . SoapOutInterceptor ; import org . apache . cxf . binding . soap . interceptor . SoapPreProtocolOutInterceptor ; import org . apache . cxf . interceptor . AttachmentInInterceptor ; import org . apache . cxf . interceptor . AttachmentOutInterceptor ; import org . apache . cxf . interceptor . StaxInInterceptor ; import org . apache . cxf . interceptor . StaxOutInterceptor ; import org . apache . cxf . interceptor . URIMappingInterceptor ; import org . apache . cxf . service . Service ; import org . apache . cxf . service . factory . ReflectionServiceFactoryBean ; import org . apache . cxf . service . model . EndpointInfo ; import org . apache . cxf . service . model . ServiceInfo ; import org . apache . cxf . wsdl11 . WSDLServiceFactory ; public class WSDLSoapServiceFactoryBean extends ReflectionServiceFactoryBean { private QName serviceName ; private QName endpointName ; @ Override public Service create ( ) { WSDLServiceFactory factory = new WSDLServiceFactory ( getBus ( ) , getWsdlURL ( ) , getServiceQName ( ) ) ; setService ( factory . create ( ) ) ; initializeSoapInterceptors ( ) ; updateEndpointInfors ( ) ; createEndpoints ( ) ; return getService ( ) ; } private void updateEndpointInfors ( ) { Service service = getService ( ) ; for ( ServiceInfo inf : service . getServiceInfos ( ) ) { for ( EndpointInfo ei : inf . getEndpoints ( ) ) { ei . setAddress ( "local://" + ei . getService ( ) . getName ( ) . toString ( ) + "/" + ei . getName ( ) . getLocalPart ( ) ) ; ei . getBinding ( ) . setProperty ( AbstractBindingFactory . DATABINDING_DISABLED , Boolean . TRUE ) ; } } } protected void checkServiceClassAnnotations ( Class < ? > sc ) { } private void initializeSoapInterceptors ( ) { getService ( ) . getInInterceptors ( ) . add ( new DataInInterceptor ( ) ) ; getService ( ) . getInInterceptors ( ) . add ( new ReadHeadersInterceptor ( getBus ( ) ) ) ; getService ( ) . getInInterceptors ( ) . add ( new MustUnderstandInterceptor ( ) ) ; getService ( ) . getInInterceptors ( ) . add ( new AttachmentInInterceptor ( ) ) ; getService ( ) . getInInterceptors ( ) . add ( new SoapHeaderInterceptor ( ) ) ; getService ( ) . getInInterceptors ( ) . add ( new CheckFaultInterceptor ( ) ) ; getService ( ) . getInInterceptors ( ) . add ( new URIMappingInterceptor ( ) ) ; getService ( ) . getInInterceptors ( ) . add ( new StaxInInterceptor ( ) ) ; getService ( ) . getInInterceptors ( ) . add ( new SoapActionInInterceptor ( ) ) ; getService ( ) . getOutInterceptors ( ) . add ( new DataOutInterceptor ( ) ) ; getService ( ) . getOutInterceptors ( ) . add ( new SoapActionOutInterceptor ( ) ) ; getService ( ) . getOutInterceptors ( ) . add ( new AttachmentOutInterceptor ( ) ) ; getService ( ) . getOutInterceptors ( ) . add ( new StaxOutInterceptor ( ) ) ; getService ( ) . getOutInterceptors ( ) . add ( new SoapHeaderOutFilterInterceptor ( ) ) ; getService ( ) . getOutInterceptors ( ) . add ( new SoapPreProtocolOutInterceptor ( ) ) ; getService ( ) . getOutInterceptors ( ) . add ( new SoapOutInterceptor ( getBus ( ) ) ) ; getService ( ) . getOutFaultInterceptors ( ) . add ( new SoapOutInterceptor ( getBus ( ) ) ) ; } public void setServiceName ( QName name ) { serviceName = name ; } public String getServiceName ( ) { return serviceName . toString ( ) ; } public QName getServiceQName ( ) { return serviceName ; } public QName getEndpointName ( ) { if ( endpointName == null ) { endpointName = getService ( ) . getEndpoints ( ) . keySet ( ) . iterator ( ) . next ( ) ; } return endpointName ; } public void setEndpointName ( QName name ) { endpointName = name ; } } 	0	['10', '0', '0', '24', '58', '37', '1', '23', '7', '0.777777778', '264', '1', '0', '0', '0.433333333', '0', '0', '25.2', '2', '1.1', '0']
package org . apache . camel ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . PARAMETER } ) public @ interface Properties { } 	0	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . util ; import java . util . Comparator ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; public class ExpressionComparator < E extends Exchange > implements Comparator < E > { private final Expression < E > expression ; public ExpressionComparator ( Expression < E > expression ) { this . expression = expression ; } public int compare ( E e1 , E e2 ) { Object o1 = expression . evaluate ( e1 ) ; Object o2 = expression . evaluate ( e2 ) ; return ObjectHelper . compare ( o1 , o2 ) ; } } 	0	['3', '1', '0', '5', '6', '1', '2', '3', '3', '0', '31', '1', '1', '0', '0.5', '0', '0', '9', '1', '0.6667', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlValue ; @ XmlRootElement ( name = "description" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class Description { @ XmlAttribute ( required = false ) private String lang ; @ XmlValue private String text ; public String getLang ( ) { return lang ; } public void setLang ( String lang ) { this . lang = lang ; } public String getText ( ) { return text ; } public void setText ( String text ) { this . text = text ; } } 	0	['5', '1', '0', '1', '6', '6', '1', '0', '5', '0.75', '24', '1', '0', '0', '0.7', '0', '0', '3.4', '1', '0.8', '0']
package org . apache . camel . component . validator . jing ; import java . io . IOException ; import java . io . InputStream ; import javax . xml . XMLConstants ; import javax . xml . transform . Source ; import javax . xml . transform . sax . SAXSource ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; import com . thaiopensource . relaxng . SchemaFactory ; import com . thaiopensource . util . PropertyMap ; import com . thaiopensource . util . PropertyMapBuilder ; import com . thaiopensource . validate . IncorrectSchemaException ; import com . thaiopensource . validate . Schema ; import com . thaiopensource . validate . ValidateProperty ; import com . thaiopensource . validate . Validator ; import com . thaiopensource . xml . sax . Jaxp11XMLReaderCreator ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . processor . validation . DefaultValidationErrorHandler ; import org . apache . camel . util . ExchangeHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . core . io . Resource ; public class JingValidator implements Processor { private static final transient Log LOG = LogFactory . getLog ( JingValidator . class ) ; private Schema schema ; private SchemaFactory schemaFactory ; private String schemaNamespace = XMLConstants . RELAXNG_NS_URI ; private Resource schemaResource ; private InputSource inputSource ; private boolean compactSyntax ; public void process ( Exchange exchange ) throws Exception { Jaxp11XMLReaderCreator xmlCreator = new Jaxp11XMLReaderCreator ( ) ; DefaultValidationErrorHandler errorHandler = new DefaultValidationErrorHandler ( ) ; PropertyMapBuilder mapBuilder = new PropertyMapBuilder ( ) ; mapBuilder . put ( ValidateProperty . XML_READER_CREATOR , xmlCreator ) ; mapBuilder . put ( ValidateProperty . ERROR_HANDLER , errorHandler ) ; PropertyMap propertyMap = mapBuilder . toPropertyMap ( ) ; Validator validator = getSchema ( ) . createValidator ( propertyMap ) ; Message in = exchange . getIn ( ) ; SAXSource saxSource = in . getBody ( SAXSource . class ) ; if ( saxSource == null ) { Source source = ExchangeHelper . getMandatoryInBody ( exchange , Source . class ) ; saxSource = ExchangeHelper . convertToMandatoryType ( exchange , SAXSource . class , source ) ; } InputSource bodyInput = saxSource . getInputSource ( ) ; XMLReader reader = xmlCreator . createXMLReader ( ) ; reader . setContentHandler ( validator . getContentHandler ( ) ) ; reader . setDTDHandler ( validator . getDTDHandler ( ) ) ; reader . setErrorHandler ( errorHandler ) ; reader . parse ( bodyInput ) ; errorHandler . handleErrors ( exchange , schema ) ; } public Schema getSchema ( ) throws IOException , IncorrectSchemaException , SAXException { if ( schema == null ) { SchemaFactory factory = getSchemaFactory ( ) ; schema = factory . createSchema ( getInputSource ( ) ) ; } return schema ; } public void setSchema ( Schema schema ) { this . schema = schema ; } public InputSource getInputSource ( ) throws IOException { if ( inputSource == null ) { Resource resource = getSchemaResource ( ) ; if ( resource == null ) { throw new IllegalArgumentException ( "No schemaResource or inputSource specified" ) ; } else { InputStream inputStream = resource . getInputStream ( ) ; if ( inputStream == null ) { throw new IllegalArgumentException ( "No inputStream available for: " + resource ) ; } inputSource = new InputSource ( inputStream ) ; } } return inputSource ; } public void setInputSource ( InputSource inputSource ) { this . inputSource = inputSource ; } public SchemaFactory getSchemaFactory ( ) { if ( schemaFactory == null ) { schemaFactory = new SchemaFactory ( ) ; schemaFactory . setCompactSyntax ( compactSyntax ) ; schemaFactory . setXMLReaderCreator ( new Jaxp11XMLReaderCreator ( ) ) ; } return schemaFactory ; } public void setSchemaFactory ( SchemaFactory schemaFactory ) { this . schemaFactory = schemaFactory ; } public Resource getSchemaResource ( ) { return schemaResource ; } public void setSchemaResource ( Resource schemaResource ) { this . schemaResource = schemaResource ; } public String getSchemaNamespace ( ) { return schemaNamespace ; } public void setSchemaNamespace ( String schemaNamespace ) { this . schemaNamespace = schemaNamespace ; } public boolean isCompactSyntax ( ) { return compactSyntax ; } public void setCompactSyntax ( boolean compactSyntax ) { this . compactSyntax = compactSyntax ; } } 	0	['15', '1', '0', '22', '47', '81', '2', '20', '14', '0.867346939', '218', '1', '0', '0', '0.1875', '0', '0', '13.06666667', '2', '0.9333', '0']
package org . apache . camel . component . spring . integration . adapter ; import org . apache . camel . CamelContext ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; public abstract class AbstractCamelAdapter { private CamelContext camelContext ; private String camelEndpointUri ; private volatile boolean expectReply = true ; public void setCamelContext ( CamelContext context ) { camelContext = context ; } public CamelContext getCamelContext ( ) { return camelContext ; } public String getCamelEndpointUri ( ) { return camelEndpointUri ; } public void setCamelEndpointUri ( String uri ) { camelEndpointUri = uri ; } public void setExpectReply ( boolean expectReply ) { this . expectReply = expectReply ; } public boolean isExpectReply ( ) { return expectReply ; } } 	0	['7', '1', '2', '3', '8', '11', '2', '1', '7', '0.777777778', '37', '1', '1', '0', '0.357142857', '0', '0', '3.857142857', '1', '0.8571', '0']
package org . apache . camel ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . PARAMETER } ) public @ interface Headers { } 	0	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . spring . handler ; import org . w3c . dom . Element ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . xml . ParserContext ; import org . springframework . util . xml . DomUtils ; public class ScriptDefinitionParser extends LazyLoadingBeanDefinitionParser { private final String scriptEngineName ; public ScriptDefinitionParser ( String scriptEngineName ) { super ( "org.apache.camel.builder.script.ScriptBuilder" , "camel-script" ) ; this . scriptEngineName = scriptEngineName ; } @ Override protected void doParse ( Element element , ParserContext parserContext , BeanDefinitionBuilder builder ) { String engine = scriptEngineName ; if ( engine == null ) { engine = element . getAttribute ( "language" ) ; } builder . addConstructorArgValue ( engine ) ; super . doParse ( element , parserContext , builder ) ; String scriptText = DomUtils . getTextValue ( element ) . trim ( ) ; if ( scriptText . length ( ) > 0 ) { builder . addPropertyValue ( "scriptText" , scriptText ) ; } } } 	0	['2', '2', '0', '5', '10', '0', '1', '4', '1', '0', '42', '1', '0', '0.875', '0.6', '0', '0', '19.5', '3', '1.5', '0']
package org . apache . camel . model . dataformat ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlElements ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlType ; @ XmlRootElement ( name = "dataFormats" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class DataFormatsType { @ XmlElements ( { @ XmlElement ( required = false , name = "artixDS" , type = ArtixDSDataFormat . class ) , @ XmlElement ( required = false , name = "csv" , type = CsvDataFormat . class ) , @ XmlElement ( required = false , name = "flatpack" , type = FlatpackDataFormat . class ) , @ XmlElement ( required = false , name = "hl7" , type = HL7DataFormat . class ) , @ XmlElement ( required = false , name = "jaxb" , type = JaxbDataFormat . class ) , @ XmlElement ( required = false , name = "json" , type = JsonDataFormat . class ) , @ XmlElement ( required = false , name = "serialization" , type = SerializationDataFormat . class ) , @ XmlElement ( required = false , name = "string" , type = StringDataFormat . class ) , @ XmlElement ( required = false , name = "tidyMarkup" , type = TidyMarkupDataFormat . class ) , @ XmlElement ( required = false , name = "xmlBeans" , type = XMLBeansDataFormat . class ) , @ XmlElement ( required = false , name = "xstream" , type = XStreamDataFormat . class ) , @ XmlElement ( required = false , name = "zip" , type = ZipDataFormat . class ) } ) private List < DataFormatType > dataFormats ; public void setDataFormats ( List < DataFormatType > dataFormats ) { this . dataFormats = dataFormats ; } public List < DataFormatType > getDataFormats ( ) { return dataFormats ; } public Map < String , DataFormatType > asMap ( ) { Map < String , DataFormatType > dataFormatsAsMap = new HashMap < String , DataFormatType > ( ) ; for ( DataFormatType dataFormatType : getDataFormats ( ) ) { dataFormatsAsMap . put ( dataFormatType . getId ( ) , dataFormatType ) ; } return dataFormatsAsMap ; } } 	0	['4', '1', '0', '3', '11', '4', '2', '1', '4', '0.333333333', '39', '1', '0', '0', '0.625', '0', '0', '8.5', '2', '1', '0']
package org . apache . camel . component . bean ; import java . lang . annotation . Annotation ; import org . apache . camel . Expression ; public class ParameterInfo { private final int index ; private final Class type ; private final Annotation [ ] annotations ; private Expression expression ; public ParameterInfo ( int index , Class type , Annotation [ ] annotations , Expression expression ) { this . index = index ; this . type = type ; this . annotations = annotations ; this . expression = expression ; } public Annotation [ ] getAnnotations ( ) { return annotations ; } public Expression getExpression ( ) { return expression ; } public int getIndex ( ) { return index ; } public Class getType ( ) { return type ; } public void setExpression ( Expression expression ) { this . expression = expression ; } } 	0	['6', '1', '0', '4', '7', '3', '3', '1', '6', '0.75', '41', '1', '1', '0', '0.366666667', '0', '0', '5.166666667', '1', '0.8333', '0']
package org . apache . camel . component . rmi ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . rmi . Remote ; import java . rmi . registry . Registry ; import java . rmi . server . UnicastRemoteObject ; import org . apache . camel . Processor ; import org . apache . camel . component . bean . BeanExchange ; import org . apache . camel . component . bean . BeanInvocation ; import org . apache . camel . impl . DefaultConsumer ; public class RmiConsumer extends DefaultConsumer < BeanExchange > implements InvocationHandler { private final RmiEndpoint endpoint ; private Remote stub ; private Remote proxy ; public RmiConsumer ( RmiEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; } @ Override protected void doStart ( ) throws Exception { Class [ ] interfaces = new Class [ endpoint . getRemoteInterfaces ( ) . size ( ) ] ; endpoint . getRemoteInterfaces ( ) . toArray ( interfaces ) ; proxy = ( Remote ) Proxy . newProxyInstance ( endpoint . getClassLoader ( ) , interfaces , this ) ; stub = UnicastRemoteObject . exportObject ( proxy , endpoint . getPort ( ) ) ; try { Registry registry = endpoint . getRegistry ( ) ; String name = endpoint . getName ( ) ; registry . bind ( name , stub ) ; } catch ( Exception e ) { try { UnicastRemoteObject . unexportObject ( stub , true ) ; } catch ( Throwable ignore ) { } stub = null ; throw e ; } super . doStart ( ) ; } @ Override protected void doStop ( ) throws Exception { super . doStop ( ) ; try { Registry registry = endpoint . getRegistry ( ) ; registry . unbind ( endpoint . getName ( ) ) ; } catch ( Throwable e ) { } UnicastRemoteObject . unexportObject ( proxy , true ) ; } public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { if ( ! isStarted ( ) ) { throw new IllegalStateException ( "The endpoint is not active: " + getEndpoint ( ) . getEndpointUri ( ) ) ; } BeanInvocation invocation = new BeanInvocation ( method , args ) ; BeanExchange exchange = getEndpoint ( ) . createExchange ( ) ; exchange . setInvocation ( invocation ) ; getProcessor ( ) . process ( exchange ) ; Throwable fault = exchange . getException ( ) ; if ( fault != null ) { throw new InvocationTargetException ( fault ) ; } return exchange . getOut ( ) . getBody ( ) ; } public Remote getProxy ( ) { return proxy ; } public Remote getStub ( ) { return stub ; } } 	0	['6', '3', '0', '8', '37', '3', '1', '8', '4', '0.666666667', '150', '1', '1', '0.821428571', '0.305555556', '1', '1', '23.5', '1', '0.8333', '0']
package org . apache . camel . component . mina ; import java . io . Serializable ; import java . util . LinkedHashMap ; import java . util . Map ; import java . util . Set ; import org . apache . camel . Exchange ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class MinaPayloadHolder implements Serializable { private static final long serialVersionUID = 1L ; private static final transient Log LOG = LogFactory . getLog ( MinaPayloadHolder . class ) ; private Object inBody ; private Object outBody ; private Object faultBody ; private Map < String , Object > inHeaders = new LinkedHashMap < String , Object > ( ) ; private Map < String , Object > outHeaders = new LinkedHashMap < String , Object > ( ) ; private Map < String , Object > properties = new LinkedHashMap < String , Object > ( ) ; private Map < String , Object > faultHeaders = new LinkedHashMap < String , Object > ( ) ; private Throwable exception ; public static MinaPayloadHolder marshal ( Exchange exchange ) { MinaPayloadHolder payload = new MinaPayloadHolder ( ) ; payload . inBody = checkSerializableObject ( exchange . getIn ( ) . getBody ( ) ) ; if ( exchange . getOut ( false ) != null ) { payload . outBody = checkSerializableObject ( exchange . getOut ( ) . getBody ( ) ) ; } payload . inHeaders . putAll ( checkMapSerializableObjects ( exchange . getIn ( ) . getHeaders ( ) ) ) ; payload . outHeaders . putAll ( checkMapSerializableObjects ( exchange . getOut ( ) . getHeaders ( ) ) ) ; payload . properties . putAll ( checkMapSerializableObjects ( exchange . getProperties ( ) ) ) ; payload . exception = exchange . getException ( ) ; if ( exchange . getFault ( false ) != null ) { payload . faultBody = exchange . getFault ( ) . getBody ( ) ; payload . faultHeaders . putAll ( checkMapSerializableObjects ( exchange . getFault ( ) . getHeaders ( ) ) ) ; } return payload ; } public static void unmarshal ( Exchange exchange , MinaPayloadHolder payload ) { exchange . getIn ( ) . setBody ( payload . inBody ) ; exchange . getOut ( ) . setBody ( payload . outBody ) ; exchange . getIn ( ) . setHeaders ( payload . inHeaders ) ; exchange . getOut ( ) . setHeaders ( payload . outHeaders ) ; if ( payload . faultBody != null ) { exchange . getFault ( ) . setBody ( payload . faultBody ) ; exchange . getFault ( ) . setHeaders ( payload . faultHeaders ) ; } for ( String key : payload . properties . keySet ( ) ) { exchange . setProperty ( key , payload . properties . get ( key ) ) ; } exchange . setException ( payload . exception ) ; } public String toString ( ) { return "MinaPayloadHolder{" + "inBody=" + inBody + ", outBody=" + outBody + ", inHeaders=" + inHeaders + ", outHeaders=" + outHeaders + ", faultBody=" + faultBody + " , faultHeaders=" + faultHeaders + ", properties=" + properties + ", exception=" + exception + '}' ; } private static Object checkSerializableObject ( Object object ) { if ( object instanceof Serializable ) { return object ; } else { LOG . warn ( "Object " + object + " can't be serialized, it will be excluded by the MinaPayloadHolder" ) ; return null ; } } private static Map < String , Object > checkMapSerializableObjects ( Map < String , Object > map ) { if ( map == null ) { return null ; } Map < String , Object > result = new LinkedHashMap < String , Object > ( ) ; for ( Map . Entry < String , Object > entry : map . entrySet ( ) ) { if ( entry . getValue ( ) instanceof Serializable ) { result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } else { LOG . warn ( "Object " + entry . getValue ( ) + " of key " + entry . getKey ( ) + " can't be serialized, it will be excluded by the MinaPayloadHolder" ) ; } } return result ; } } 	0	['7', '1', '0', '5', '39', '3', '1', '4', '4', '0.633333333', '283', '1', '0', '0', '0.233333333', '0', '0', '38', '4', '1.8571', '0']
package org . apache . camel . builder . sql ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import org . apache . camel . language . LanguageAnnotation ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . PARAMETER } ) @ LanguageAnnotation ( language = "sql" ) public @ interface SQL { String value ( ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . jms . requestor ; import javax . jms . JMSException ; import javax . jms . Message ; public interface ReplyHandler { boolean handle ( Message message ) throws JMSException ; } 	0	['1', '1', '0', '3', '1', '0', '3', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . jms ; public class DestinationTransformProcessor { } 	0	['1', '1', '0', '0', '2', '0', '0', '0', '1', '2', '4', '0', '0', '0', '1', '0', '0', '3', '0', '0', '0']
package org . apache . camel . component . spring . integration . adapter ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . ProducerTemplate ; import org . apache . camel . component . spring . integration . SpringIntegrationBinding ; import org . apache . camel . component . spring . integration . SpringIntegrationExchange ; import org . apache . camel . impl . DefaultCamelContext ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . integration . core . Message ; import org . springframework . integration . core . MessageChannel ; import org . springframework . integration . core . MessageHeaders ; import org . springframework . integration . message . MessageDeliveryException ; import org . springframework . integration . message . MessageHandler ; import org . springframework . integration . message . MessageRejectedException ; public class CamelTargetAdapter extends AbstractCamelAdapter implements MessageHandler { private final Log logger = LogFactory . getLog ( this . getClass ( ) ) ; private ProducerTemplate < Exchange > camelTemplate ; private MessageChannel replyChannel ; public void setReplyChannel ( MessageChannel channel ) { replyChannel = channel ; } public MessageChannel getReplyChannel ( ) { return replyChannel ; } public ProducerTemplate < Exchange > getCamelTemplate ( ) { if ( camelTemplate == null ) { CamelContext ctx = getCamelContext ( ) ; if ( ctx == null ) { ctx = new DefaultCamelContext ( ) ; } camelTemplate = ctx . createProducerTemplate ( ) ; } return camelTemplate ; } public boolean send ( Message < ? > message ) throws MessageRejectedException , MessageDeliveryException { ExchangePattern pattern ; boolean result = false ; if ( isExpectReply ( ) ) { pattern = ExchangePattern . InOut ; } else { pattern = ExchangePattern . InOnly ; } Exchange inExchange = new SpringIntegrationExchange ( getCamelContext ( ) , pattern ) ; SpringIntegrationBinding . storeToCamelMessage ( message , inExchange . getIn ( ) ) ; Exchange outExchange = getCamelTemplate ( ) . send ( getCamelEndpointUri ( ) , inExchange ) ; if ( outExchange . getFault ( ) != null ) { result = true ; } Message response = null ; if ( isExpectReply ( ) ) { response = SpringIntegrationBinding . storeToSpringIntegrationMessage ( outExchange . getOut ( ) ) ; if ( replyChannel == null ) { MessageChannel messageReplyChannel = ( MessageChannel ) message . getHeaders ( ) . get ( MessageHeaders . REPLY_CHANNEL ) ; if ( messageReplyChannel != null ) { result = messageReplyChannel . send ( response ) ; } else { throw new MessageDeliveryException ( response , "Can't find reply channel from the CamelTargetAdapter or MessageHeaders" ) ; } } else { result = replyChannel . send ( response ) ; } } return result ; } public void handleMessage ( Message < ? > message ) { send ( message ) ; } } 	0	['6', '2', '0', '17', '25', '9', '0', '17', '6', '0.666666667', '120', '1', '1', '0.545454545', '0.5', '0', '0', '18.5', '3', '1.1667', '0']
package org . apache . camel . component . spring . integration . adapter ; import java . util . HashMap ; import java . util . Map ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . component . spring . integration . SpringIntegrationBinding ; import org . apache . camel . util . AsyncProcessorHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . integration . channel . DirectChannel ; import org . springframework . integration . channel . PollableChannel ; import org . springframework . integration . core . Message ; import org . springframework . integration . core . MessageChannel ; import org . springframework . integration . core . MessageHeaders ; import org . springframework . integration . gateway . SimpleMessagingGateway ; import org . springframework . integration . message . MessageHandler ; import org . springframework . integration . transformer . Transformer ; public class CamelSourceAdapter extends AbstractCamelAdapter implements InitializingBean { protected final Object lifecycleMonitor = new Object ( ) ; private final Log logger = LogFactory . getLog ( this . getClass ( ) ) ; private Consumer consumer ; private Endpoint camelEndpoint ; private MessageChannel requestChannel ; private DirectChannel replyChannel ; private volatile boolean initialized ; public void setRequestChannel ( MessageChannel channel ) { requestChannel = channel ; } public MessageChannel getChannel ( ) { return requestChannel ; } public void setReplyChannel ( DirectChannel channel ) { replyChannel = channel ; } protected class ConsumerProcessor implements AsyncProcessor { public void process ( Exchange exchange ) throws Exception { AsyncProcessorHelper . process ( this , exchange ) ; } public boolean process ( final Exchange exchange , final AsyncCallback callback ) { org . springframework . integration . core . Message request = SpringIntegrationBinding . createSpringIntegrationMessage ( exchange ) ; Map < String , Object > headers = new HashMap < String , Object > ( ) ; if ( exchange . getPattern ( ) . isOutCapable ( ) ) { headers . put ( MessageHeaders . REPLY_CHANNEL , replyChannel ) ; replyChannel . subscribe ( new MessageHandler ( ) { public void handleMessage ( Message < ? > message ) { SpringIntegrationBinding . storeToCamelMessage ( message , exchange . getOut ( ) ) ; callback . done ( true ) ; } } ) ; } requestChannel . send ( request ) ; if ( ! exchange . getPattern ( ) . isOutCapable ( ) ) { callback . done ( true ) ; } return true ; } } public final void afterPropertiesSet ( ) throws Exception { synchronized ( this . lifecycleMonitor ) { if ( this . initialized ) { return ; } } this . initialize ( ) ; this . initialized = true ; } protected void initialize ( ) throws Exception { camelEndpoint = getCamelContext ( ) . getEndpoint ( getCamelEndpointUri ( ) ) ; consumer = camelEndpoint . createConsumer ( new ConsumerProcessor ( ) ) ; consumer . start ( ) ; } } 	0	['8', '2', '0', '11', '18', '18', '1', '11', '5', '0.87755102', '90', '1', '2', '0.461538462', '0.3125', '0', '0', '9.375', '1', '0.875', '0']
package org . apache . camel . spring ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . CamelContext ; import org . apache . camel . CamelContextAware ; import org . apache . camel . Endpoint ; import org . apache . camel . NoSuchEndpointException ; import org . apache . camel . model . IdentifiedType ; import org . springframework . beans . factory . FactoryBean ; import static org . apache . camel . util . ObjectHelper . notNull ; @ XmlRootElement ( name = "endpoint" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class EndpointFactoryBean extends IdentifiedType implements FactoryBean , CamelContextAware { @ XmlAttribute private String uri ; @ XmlTransient private CamelContext context ; @ XmlTransient private Endpoint endpoint ; @ XmlTransient private boolean singleton ; public Object getObject ( ) throws Exception { if ( endpoint == null ) { endpoint = createEndpoint ( ) ; } return endpoint ; } public Class getObjectType ( ) { return Endpoint . class ; } public boolean isSingleton ( ) { return singleton ; } public CamelContext getCamelContext ( ) { return context ; } public void setCamelContext ( CamelContext context ) { this . context = context ; } public Endpoint getEndpoint ( ) { return endpoint ; } public void setEndpoint ( Endpoint endpoint ) { this . endpoint = endpoint ; } public void setSingleton ( boolean singleton ) { this . singleton = singleton ; } public String getUri ( ) { return uri ; } public void setUri ( String uri ) { this . uri = uri ; } protected Endpoint createEndpoint ( ) { notNull ( context , "context" ) ; notNull ( uri , "uri" ) ; Endpoint endpoint = context . getEndpoint ( uri ) ; if ( endpoint == null ) { throw new NoSuchEndpointException ( uri ) ; } return endpoint ; } } 	0	['12', '2', '0', '7', '16', '46', '0', '7', '11', '0.795454545', '83', '1', '2', '0.153846154', '0.266666667', '0', '0', '5.583333333', '2', '1', '0']
package org . apache . camel . util ; import org . apache . camel . converter . ObjectConverter ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public final class SystemHelper { private static final transient Log LOG = LogFactory . getLog ( SystemHelper . class ) ; private SystemHelper ( ) { } public static String getSystemProperty ( String name ) { try { return System . getProperty ( name ) ; } catch ( Exception e ) { LOG . debug ( "Caught exception looking for system property: " + name + " exception: " + e , e ) ; return null ; } } public static boolean isSystemProperty ( String name ) { String text = getSystemProperty ( name ) ; return ObjectConverter . toBool ( text ) ; } } 	0	['4', '1', '0', '4', '13', '4', '1', '3', '2', '0.333333333', '39', '1', '0', '0', '0.5', '0', '0', '8.5', '1', '0.5', '0']
package org . apache . camel . language ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import org . apache . camel . component . bean . DefaultAnnotationExpressionFactory ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . ANNOTATION_TYPE } ) public @ interface LanguageAnnotation { String language ( ) ; Class < ? > factory ( ) default DefaultAnnotationExpressionFactory . class ; } 	0	['2', '1', '0', '5', '2', '1', '5', '0', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . osgi ; import java . io . BufferedInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import java . util . Properties ; import org . apache . camel . util . FactoryFinder ; import org . apache . camel . util . NoFactoryAvailableException ; import org . apache . camel . util . ObjectHelper ; import org . osgi . framework . Bundle ; import org . osgi . framework . BundleContext ; public class OsgiFactoryFinder extends FactoryFinder { private class BundleEntry { URL url ; Bundle bundle ; } public OsgiFactoryFinder ( ) { super ( ) ; } public OsgiFactoryFinder ( String path ) { super ( path ) ; } public Class findClass ( String key , String propertyPrefix ) throws ClassNotFoundException , IOException { if ( propertyPrefix == null ) { propertyPrefix = "" ; } Class clazz = ( Class ) classMap . get ( propertyPrefix + key ) ; Properties properties = null ; if ( clazz == null ) { BundleEntry entry = getResource ( key ) ; if ( entry != null ) { URL url = entry . url ; InputStream in = url . openStream ( ) ; BufferedInputStream reader = null ; try { reader = new BufferedInputStream ( in ) ; properties = new Properties ( ) ; properties . load ( reader ) ; String className = properties . getProperty ( propertyPrefix + "class" ) ; if ( className == null ) { throw new IOException ( "Expected property is missing: " + propertyPrefix + "class" ) ; } clazz = entry . bundle . loadClass ( className ) ; classMap . put ( propertyPrefix + key , clazz ) ; } finally { ObjectHelper . close ( reader , key , null ) ; ObjectHelper . close ( in , key , null ) ; } } else { throw new NoFactoryAvailableException ( propertyPrefix + key ) ; } } return clazz ; } public BundleEntry getResource ( String name ) { URL url = null ; BundleEntry entry = null ; BundleContext bundleContext = Activator . getBundle ( ) . getBundleContext ( ) ; for ( Bundle bundle : bundleContext . getBundles ( ) ) { url = bundle . getEntry ( getPath ( ) + name ) ; if ( url != null ) { entry = new BundleEntry ( ) ; entry . url = url ; entry . bundle = bundle ; break ; } } return entry ; } } 	0	['4', '2', '0', '9', '26', '6', '1', '9', '4', '2', '191', '0', '0', '0.875', '0.875', '1', '3', '46.75', '3', '1', '0']
package org . apache . camel . language . jxpath ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Message ; import org . apache . camel . impl . ExpressionSupport ; import org . apache . camel . language . ExpressionEvaluationException ; import org . apache . commons . jxpath . CompiledExpression ; import org . apache . commons . jxpath . JXPathContext ; import org . apache . commons . jxpath . JXPathException ; public class JXPathExpression extends ExpressionSupport < Exchange > { private String expression ; private CompiledExpression compiledExpression ; private final Class < ? > type ; public JXPathExpression ( String expression , Class < ? > type ) { super ( ) ; this . expression = expression ; this . type = type ; } public Object evaluate ( Exchange exchange ) { try { JXPathContext context = JXPathContext . newContext ( exchange ) ; Object result = getJXPathExpression ( ) . getValue ( context , type ) ; assertResultType ( exchange , result ) ; return result ; } catch ( JXPathException e ) { throw new ExpressionEvaluationException ( this , exchange , e ) ; } } private void assertResultType ( Exchange exchange , Object result ) { if ( result != null && ! type . isAssignableFrom ( result . getClass ( ) ) ) { throw new JXPathException ( "JXPath result type is " + result . getClass ( ) + " instead of required type " + type ) ; } } @ Override protected String assertionFailureMessage ( Exchange exchange ) { return expression . toString ( ) ; } private synchronized CompiledExpression getJXPathExpression ( ) { if ( compiledExpression == null ) { compiledExpression = JXPathContext . compile ( expression ) ; } return compiledExpression ; } } 	0	['5', '2', '0', '8', '18', '0', '1', '7', '2', '0.5', '83', '1', '0', '0.555555556', '0.44', '1', '2', '15', '3', '1.4', '0']
package org . apache . camel . component . file ; import java . io . File ; import java . io . IOException ; import java . util . Date ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; public class FileExchange extends DefaultExchange { private File file ; public FileExchange ( CamelContext camelContext , ExchangePattern pattern , File file ) { super ( camelContext , pattern ) ; setFile ( file ) ; } public FileExchange ( DefaultExchange parent , File file ) { super ( parent ) ; setFile ( file ) ; } public File getFile ( ) { return this . file ; } public void setFile ( File file ) { setIn ( new FileMessage ( file ) ) ; this . file = file ; populateHeaders ( file ) ; } public Exchange newInstance ( ) { return new FileExchange ( this , getFile ( ) ) ; } private void populateHeaders ( File file ) { if ( file != null ) { getIn ( ) . setHeader ( "CamelFileName" , file . getName ( ) ) ; getIn ( ) . setHeader ( "CamelFileAbsolutePath" , file . getAbsolutePath ( ) ) ; getIn ( ) . setHeader ( "CamelFileParent" , file . getParent ( ) ) ; getIn ( ) . setHeader ( "CamelFilePath" , file . getPath ( ) ) ; try { getIn ( ) . setHeader ( "CamelFileCanonicalPath" , file . getCanonicalPath ( ) ) ; } catch ( IOException e ) { } if ( file . length ( ) > 0 ) { getIn ( ) . setHeader ( "CamelFileLength" , new Long ( file . length ( ) ) ) ; } if ( file . lastModified ( ) > 0 ) { getIn ( ) . setHeader ( "CamelFileLastModified" , new Date ( file . lastModified ( ) ) ) ; } } } } 	0	['6', '2', '0', '17', '21', '13', '12', '6', '5', '0.2', '108', '1', '0', '0.904761905', '0.433333333', '1', '1', '16.83333333', '4', '1.1667', '0']
package org . apache . camel . builder . xml ; import java . util . HashMap ; import java . util . Map ; import javax . xml . namespace . QName ; import javax . xml . xpath . XPathVariableResolver ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import static org . apache . camel . builder . xml . Namespaces . ENVIRONMENT_VARIABLES ; import static org . apache . camel . builder . xml . Namespaces . EXCHANGE_PROPERTY ; import static org . apache . camel . builder . xml . Namespaces . IN_NAMESPACE ; import static org . apache . camel . builder . xml . Namespaces . OUT_NAMESPACE ; import static org . apache . camel . builder . xml . Namespaces . SYSTEM_PROPERTIES_NAMESPACE ; public class MessageVariableResolver implements XPathVariableResolver { private static final transient Log LOG = LogFactory . getLog ( MessageVariableResolver . class ) ; private Exchange exchange ; private Map < String , Object > variables = new HashMap < String , Object > ( ) ; public Exchange getExchange ( ) { return exchange ; } public void setExchange ( Exchange exchange ) { this . exchange = exchange ; } public Object resolveVariable ( QName name ) { String uri = name . getNamespaceURI ( ) ; String localPart = name . getLocalPart ( ) ; Object answer = null ; Message in = exchange . getIn ( ) ; if ( uri == null || uri . length ( ) == 0 ) { answer = variables . get ( localPart ) ; if ( answer == null ) { Message message = in ; if ( message != null ) { answer = message . getHeader ( localPart ) ; } if ( answer == null ) { answer = exchange . getProperty ( localPart ) ; } } } else if ( uri . equals ( SYSTEM_PROPERTIES_NAMESPACE ) ) { try { answer = System . getProperty ( localPart ) ; } catch ( Exception e ) { LOG . debug ( "Security exception evaluating system property: " + localPart + ". Reason: " + e , e ) ; } } else if ( uri . equals ( ENVIRONMENT_VARIABLES ) ) { answer = System . getenv ( ) . get ( localPart ) ; } else if ( uri . equals ( EXCHANGE_PROPERTY ) ) { answer = exchange . getProperty ( localPart ) ; } else if ( uri . equals ( IN_NAMESPACE ) ) { answer = in . getHeader ( localPart ) ; if ( answer == null && localPart . equals ( "body" ) ) { answer = in . getBody ( ) ; } } else if ( uri . equals ( OUT_NAMESPACE ) ) { Message out = exchange . getOut ( false ) ; if ( out != null ) { answer = out . getHeader ( localPart ) ; if ( answer == null && localPart . equals ( "body" ) ) { answer = out . getBody ( ) ; } } } if ( answer == null ) { return Void . class ; } else { return answer ; } } public void addVariable ( String localPart , Object value ) { variables . put ( localPart , value ) ; } } 	0	['6', '1', '0', '5', '27', '1', '1', '4', '5', '0.666666667', '167', '1', '1', '0', '0.36', '0', '0', '26.33333333', '16', '3.1667', '0']
package org . apache . camel . spi ; import javax . management . JMException ; import javax . management . MBeanServer ; import javax . management . ObjectName ; import org . apache . camel . Service ; public interface InstrumentationAgent extends Service { void register ( Object obj , ObjectName name ) throws JMException ; void register ( Object obj , ObjectName name , boolean forceRegistration ) throws JMException ; void unregister ( ObjectName name ) throws JMException ; MBeanServer getMBeanServer ( ) ; String getMBeanObjectDomainName ( ) ; } 	0	['5', '1', '0', '4', '5', '10', '3', '1', '5', '2', '5', '0', '0', '0', '0.55', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultComponent ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . core . io . DefaultResourceLoader ; import org . springframework . core . io . Resource ; import org . springframework . core . io . ResourceLoader ; public abstract class ResourceBasedComponent extends DefaultComponent < Exchange > { protected final transient Log log = LogFactory . getLog ( getClass ( ) ) ; private ResourceLoader resourceLoader = new DefaultResourceLoader ( ) ; public ResourceLoader getResourceLoader ( ) { return resourceLoader ; } public void setResourceLoader ( ResourceLoader resourceLoader ) { this . resourceLoader = resourceLoader ; } protected Resource resolveMandatoryResource ( String uri ) { Resource resource = getResourceLoader ( ) . getResource ( uri ) ; if ( resource == null ) { throw new IllegalArgumentException ( "Could not find resource for URI: " + uri + " using: " + getResourceLoader ( ) ) ; } else { return resource ; } } } 	0	['4', '3', '4', '10', '14', '0', '4', '6', '3', '0.5', '52', '1', '0', '0.921052632', '0.5', '0', '0', '11.5', '2', '1', '0']
package org . apache . camel . component . irc ; import java . net . URI ; import java . util . HashMap ; import java . util . Map ; import org . apache . camel . CamelContext ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . impl . DefaultComponent ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . schwering . irc . lib . IRCConnection ; public class IrcComponent extends DefaultComponent < IrcExchange > { private static final transient Log LOG = LogFactory . getLog ( IrcComponent . class ) ; private IrcConfiguration configuration ; private final Map < String , IRCConnection > connectionCache = new HashMap < String , IRCConnection > ( ) ; public IrcComponent ( ) { configuration = new IrcConfiguration ( ) ; } public IrcComponent ( IrcConfiguration configuration ) { this . configuration = configuration ; } public IrcComponent ( CamelContext context ) { super ( context ) ; configuration = new IrcConfiguration ( ) ; } public static IrcComponent ircComponent ( ) { return new IrcComponent ( ) ; } protected IrcEndpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { IrcConfiguration config = getConfiguration ( ) . copy ( ) ; config . configure ( new URI ( uri ) ) ; final IrcEndpoint endpoint = new IrcEndpoint ( uri , this , config ) ; setProperties ( endpoint . getConfiguration ( ) , parameters ) ; return endpoint ; } public IrcConfiguration getConfiguration ( ) { return configuration ; } public void setConfiguration ( IrcConfiguration configuration ) { this . configuration = configuration ; } public synchronized IRCConnection getIRCConnection ( IrcConfiguration configuration ) { final IRCConnection connection ; if ( connectionCache . containsKey ( configuration . getCacheKey ( ) ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Returning Cached Connection to " + configuration . getHostname ( ) + " " + configuration . getTarget ( ) ) ; } connection = connectionCache . get ( configuration . getCacheKey ( ) ) ; } else { connection = createConnection ( configuration ) ; connectionCache . put ( configuration . getCacheKey ( ) , connection ) ; } return connection ; } protected IRCConnection createConnection ( IrcConfiguration configuration ) { LOG . debug ( "Creating Connection to " + configuration . getHostname ( ) + " destination: " + configuration . getTarget ( ) + " nick: " + configuration . getNickname ( ) + " user: " + configuration . getUsername ( ) ) ; final IRCConnection conn = new IRCConnection ( configuration . getHostname ( ) , configuration . getPorts ( ) , configuration . getPassword ( ) , configuration . getNickname ( ) , configuration . getUsername ( ) , configuration . getRealname ( ) ) ; conn . setEncoding ( "UTF-8" ) ; conn . setColors ( configuration . isColors ( ) ) ; conn . setPong ( true ) ; try { conn . connect ( ) ; } catch ( Exception e ) { LOG . error ( "Failed to connect: " + e , e ) ; throw new RuntimeCamelException ( e ) ; } return conn ; } public void closeConnection ( String key , IRCConnection connection ) { try { connection . doQuit ( ) ; connection . close ( ) ; } catch ( Exception e ) { LOG . warn ( "Error closing connection." , e ) ; } } @ Override protected synchronized void doStop ( ) throws Exception { Map < String , IRCConnection > map = new HashMap < String , IRCConnection > ( connectionCache ) ; connectionCache . clear ( ) ; for ( Map . Entry < String , IRCConnection > entry : map . entrySet ( ) ) { closeConnection ( entry . getKey ( ) , entry . getValue ( ) ) ; } super . doStop ( ) ; } } 	0	['13', '3', '0', '9', '60', '32', '1', '9', '8', '0.555555556', '262', '1', '1', '0.795454545', '0.305555556', '2', '3', '18.92307692', '3', '0.8462', '0']
package org . apache . camel . spring . factory ; import org . apache . camel . component . bean . BeanEndpoint ; import org . springframework . beans . factory . FactoryBean ; public class BeanEndpointFactory implements FactoryBean { private boolean singleton = true ; public Object getObject ( ) throws Exception { return new BeanEndpoint ( ) ; } public Class getObjectType ( ) { return BeanEndpoint . class ; } public boolean isSingleton ( ) { return singleton ; } protected void setSingleton ( boolean singleton ) { this . singleton = singleton ; } } 	0	['5', '1', '0', '2', '7', '4', '0', '2', '4', '0.5', '25', '1', '0', '0', '0.6', '0', '0', '3.8', '1', '0.8', '0']
package org . apache . camel . processor ; import org . apache . camel . Processor ; public interface ErrorHandler extends Processor { } 	0	['0', '1', '0', '2', '0', '0', '1', '1', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . component . rmi ; import java . rmi . registry . Registry ; import org . apache . camel . CamelContext ; import org . apache . camel . component . bean . ParameterMappingStrategy ; import org . apache . camel . component . bean . RegistryBean ; public class RmiRegistryBean extends RegistryBean { private final Registry registry ; public RmiRegistryBean ( CamelContext context , String name , Registry registry ) { super ( context , name ) ; this . registry = registry ; } public RmiRegistryBean ( CamelContext context , String name , ParameterMappingStrategy parameterMappingStrategy , Registry registry ) { super ( context , name , parameterMappingStrategy ) ; this . registry = registry ; } @ Override protected Object lookupBean ( ) throws Exception { return registry . lookup ( getName ( ) ) ; } } 	0	['3', '2', '0', '4', '7', '0', '1', '3', '2', '0', '27', '1', '0', '0.928571429', '0.666666667', '1', '1', '7.666666667', '1', '0.3333', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Predicate ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . FilterProcessor ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "when" ) public class WhenType < Type extends ProcessorType > extends ExpressionNode { public WhenType ( ) { } public WhenType ( Predicate predicate ) { super ( predicate ) ; } public WhenType ( ExpressionType expression ) { super ( expression ) ; } @ Override public String toString ( ) { return "When[" + getExpression ( ) + " -> " + getOutputs ( ) + "]" ; } @ Override public String getShortName ( ) { return "when" ; } @ Override public FilterProcessor createProcessor ( RouteContext routeContext ) throws Exception { return createFilterProcessor ( routeContext ) ; } } 	0	['7', '4', '0', '13', '16', '21', '7', '6', '7', '2', '45', '0', '0', '0.978723404', '0.392857143', '3', '4', '5.428571429', '1', '0.5714', '0']
package org . apache . camel . component . validator ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . component . ResourceBasedComponent ; import org . apache . camel . impl . ProcessorEndpoint ; import org . springframework . core . io . Resource ; public class ValidatorComponent extends ResourceBasedComponent { protected Endpoint < Exchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { SpringValidator validator = new SpringValidator ( ) ; Resource resource = resolveMandatoryResource ( remaining ) ; validator . setSchemaResource ( resource ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( this + " using schema resource: " + resource ) ; } configureValidator ( validator , uri , remaining , parameters ) ; return new ProcessorEndpoint ( uri , this , validator ) ; } protected void configureValidator ( SpringValidator validator , String uri , String remaining , Map parameters ) throws Exception { setProperties ( validator , parameters ) ; } } 	0	['3', '4', '1', '9', '15', '3', '1', '8', '1', '2', '52', '0', '0', '0.95', '0.666666667', '2', '2', '16.33333333', '1', '0.6667', '0']
package org . apache . camel . builder . xml ; import java . io . ByteArrayOutputStream ; import javax . xml . transform . Result ; import javax . xml . transform . stream . StreamResult ; import org . apache . camel . Message ; public class StreamResultHandler implements ResultHandler { ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; StreamResult result = new StreamResult ( buffer ) ; public Result getResult ( ) { return result ; } public void setBody ( Message in ) { in . setBody ( buffer . toByteArray ( ) ) ; } } 	0	['3', '1', '0', '3', '8', '0', '1', '2', '3', '0.5', '29', '0', '0', '0', '0.666666667', '0', '0', '8', '1', '0.6667', '0']
package org . apache . camel . component . velocity ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import org . apache . velocity . app . VelocityEngine ; public class VelocityComponent extends DefaultComponent { private VelocityEngine velocityEngine = new VelocityEngine ( ) ; public VelocityEngine getVelocityEngine ( ) { return velocityEngine ; } public void setVelocityEngine ( VelocityEngine velocityEngine ) { this . velocityEngine = velocityEngine ; } protected Endpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { return new VelocityEndpoint ( uri , this , remaining , parameters ) ; } } 	0	['4', '3', '0', '4', '7', '0', '1', '4', '3', '0.333333333', '28', '1', '0', '0.921052632', '0.4375', '1', '1', '5.75', '1', '0.75', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . spi . RouteContext ; import org . apache . camel . util . ObjectHelper ; @ XmlRootElement ( name = "from" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class FromType extends OptionalIdentifiedType < FromType > { @ XmlAttribute private String uri ; @ XmlAttribute private String ref ; @ XmlTransient private Endpoint < ? extends Exchange > endpoint ; public FromType ( ) { } public FromType ( String uri ) { setUri ( uri ) ; } public FromType ( Endpoint < ? extends Exchange > endpoint ) { this . endpoint = endpoint ; } @ Override public String toString ( ) { return "From[" + getLabel ( ) + "]" ; } @ Override public String getShortName ( ) { return "from" ; } public String getLabel ( ) { return description ( getUri ( ) , getRef ( ) , getEndpoint ( ) ) ; } public Endpoint < ? extends Exchange > resolveEndpoint ( RouteContext context ) { if ( endpoint == null ) { endpoint = context . resolveEndpoint ( getUri ( ) , getRef ( ) ) ; } return endpoint ; } public String getUri ( ) { return uri ; } public void setUri ( String uri ) { this . uri = uri ; } public String getRef ( ) { return ref ; } public void setRef ( String ref ) { this . ref = ref ; } public Endpoint getEndpoint ( ) { return endpoint ; } public void setEndpoint ( Endpoint endpoint ) { this . endpoint = endpoint ; } public Object getUriOrRef ( ) { if ( ObjectHelper . isNullOrBlank ( uri ) ) { return uri ; } else if ( endpoint != null ) { return endpoint . getEndpointUri ( ) ; } return ref ; } protected static String description ( String uri , String ref , Endpoint endpoint ) { if ( ref != null ) { return "ref:" + ref ; } else if ( endpoint != null ) { return endpoint . getEndpointUri ( ) ; } else if ( uri != null ) { return uri ; } else { return "no uri or ref supplied!" ; } } } 	0	['15', '2', '0', '13', '22', '73', '10', '4', '14', '0.666666667', '129', '1', '1', '0.5', '0.366666667', '1', '1', '7.4', '4', '1.2', '0']
package org . apache . camel . component . quartz ; import java . util . Date ; import java . util . Map ; import java . util . Set ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . processor . loadbalancer . LoadBalancer ; import org . apache . camel . processor . loadbalancer . RoundRobinLoadBalancer ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . quartz . JobDetail ; import org . quartz . JobExecutionContext ; import org . quartz . JobExecutionException ; import org . quartz . Scheduler ; import org . quartz . SchedulerException ; import org . quartz . SimpleTrigger ; import org . quartz . Trigger ; public class QuartzEndpoint extends DefaultEndpoint < QuartzExchange > { public static final String ENDPOINT_KEY = "org.apache.camel.quartz" ; public static final String CONTEXT_KEY = "org.apache.camel.CamelContext" ; private static final transient Log LOG = LogFactory . getLog ( QuartzEndpoint . class ) ; private Scheduler scheduler ; private LoadBalancer loadBalancer ; private Trigger trigger ; private JobDetail jobDetail ; private boolean started ; private boolean stateful ; public QuartzEndpoint ( final String endpointUri , final QuartzComponent component , final Scheduler scheduler ) { super ( endpointUri , component ) ; this . scheduler = scheduler ; } public QuartzEndpoint ( final String endpointUri , final Scheduler scheduler ) { super ( endpointUri ) ; this . scheduler = scheduler ; } public void addTriggers ( final Map < Trigger , JobDetail > triggerMap ) throws SchedulerException { if ( triggerMap != null ) { Set < Map . Entry < Trigger , JobDetail > > entries = triggerMap . entrySet ( ) ; for ( Map . Entry < Trigger , JobDetail > entry : entries ) { Trigger key = entry . getKey ( ) ; JobDetail value = entry . getValue ( ) ; ObjectHelper . notNull ( key , "key" ) ; ObjectHelper . notNull ( value , "value" ) ; addTrigger ( key , value ) ; } } } public void addTrigger ( final Trigger trigger , final JobDetail detail ) throws SchedulerException { if ( trigger . getName ( ) == null ) { trigger . setName ( detail . getName ( ) ) ; } if ( trigger . getGroup ( ) == null ) { trigger . setGroup ( detail . getGroup ( ) ) ; } if ( trigger . getStartTime ( ) == null ) { trigger . setStartTime ( new Date ( ) ) ; } if ( isStateful ( ) ) { detail . getJobDataMap ( ) . put ( ENDPOINT_KEY , getEndpointUri ( ) ) ; } else { detail . getJobDataMap ( ) . put ( ENDPOINT_KEY , this ) ; } if ( null == detail . getJobClass ( ) ) { if ( isStateful ( ) ) { detail . setJobClass ( StatefulCamelJob . class ) ; } else { detail . setJobClass ( CamelJob . class ) ; } } if ( detail . getName ( ) == null ) { detail . setName ( getEndpointUri ( ) ) ; } getScheduler ( ) . scheduleJob ( detail , trigger ) ; } public void removeTrigger ( final Trigger trigger , final JobDetail jobDetail ) throws SchedulerException { getScheduler ( ) . unscheduleJob ( trigger . getName ( ) , trigger . getGroup ( ) ) ; } public void onJobExecute ( final JobExecutionContext jobExecutionContext ) throws JobExecutionException { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Firing Quartz Job with context: " + jobExecutionContext ) ; } QuartzExchange exchange = createExchange ( jobExecutionContext ) ; try { getLoadBalancer ( ) . process ( exchange ) ; } catch ( JobExecutionException e ) { throw e ; } catch ( Exception e ) { throw new JobExecutionException ( e ) ; } } @ Override public QuartzExchange createExchange ( final ExchangePattern pattern ) { return new QuartzExchange ( getCamelContext ( ) , pattern , null ) ; } public QuartzExchange createExchange ( final JobExecutionContext jobExecutionContext ) { return new QuartzExchange ( getCamelContext ( ) , getExchangePattern ( ) , jobExecutionContext ) ; } public Producer < QuartzExchange > createProducer ( ) throws Exception { throw new UnsupportedOperationException ( "You cannot send messages to this endpoint" ) ; } public QuartzConsumer createConsumer ( final Processor processor ) throws Exception { return new QuartzConsumer ( this , processor ) ; } @ Override public QuartzComponent getComponent ( ) { return ( QuartzComponent ) super . getComponent ( ) ; } public boolean isSingleton ( ) { return true ; } public Scheduler getScheduler ( ) { return scheduler ; } public LoadBalancer getLoadBalancer ( ) { if ( loadBalancer == null ) { loadBalancer = createLoadBalancer ( ) ; } return loadBalancer ; } public void setLoadBalancer ( final LoadBalancer loadBalancer ) { this . loadBalancer = loadBalancer ; } public JobDetail getJobDetail ( ) { if ( jobDetail == null ) { jobDetail = createJobDetail ( ) ; } return jobDetail ; } public void setJobDetail ( final JobDetail jobDetail ) { this . jobDetail = jobDetail ; } public Trigger getTrigger ( ) { if ( trigger == null ) { trigger = createTrigger ( ) ; } return trigger ; } public void setTrigger ( final Trigger trigger ) { this . trigger = trigger ; } public boolean isStateful ( ) { return this . stateful ; } public void setStateful ( final boolean stateful ) { this . stateful = stateful ; } public synchronized void consumerStarted ( final QuartzConsumer consumer ) throws SchedulerException { getLoadBalancer ( ) . addProcessor ( consumer . getProcessor ( ) ) ; if ( ! started ) { addTrigger ( getTrigger ( ) , getJobDetail ( ) ) ; started = true ; } } public synchronized void consumerStopped ( final QuartzConsumer consumer ) throws SchedulerException { getLoadBalancer ( ) . removeProcessor ( consumer . getProcessor ( ) ) ; if ( getLoadBalancer ( ) . getProcessors ( ) . isEmpty ( ) && started ) { removeTrigger ( getTrigger ( ) , getJobDetail ( ) ) ; started = false ; } } protected LoadBalancer createLoadBalancer ( ) { return new RoundRobinLoadBalancer ( ) ; } protected JobDetail createJobDetail ( ) { return new JobDetail ( ) ; } protected Trigger createTrigger ( ) { return new SimpleTrigger ( ) ; } } 	0	['30', '2', '0', '26', '77', '417', '4', '24', '26', '0.927203065', '350', '0.777777778', '1', '0.470588235', '0.135278515', '1', '2', '10.36666667', '2', '1', '0']
package org . apache . camel . osgi ; import java . io . BufferedInputStream ; import java . net . URL ; import java . util . Enumeration ; import java . util . HashMap ; import java . util . Map ; import java . util . Properties ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . spi . ComponentResolver ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . osgi . framework . Bundle ; import org . osgi . framework . BundleContext ; import org . osgi . framework . BundleEvent ; import org . osgi . framework . SynchronousBundleListener ; import org . springframework . osgi . util . BundleDelegatingClassLoader ; public class OsgiComponentResolver implements ComponentResolver { private static final transient Log LOG = LogFactory . getLog ( OsgiComponentResolver . class ) ; protected Class getComponent ( String name ) throws Exception { return Activator . getComponent ( name ) ; } public Component resolveComponent ( String name , CamelContext context ) throws Exception { Object bean = null ; try { bean = context . getRegistry ( ) . lookup ( name ) ; if ( bean != null && LOG . isDebugEnabled ( ) ) { LOG . debug ( "Found component: " + name + " in registry: " + bean ) ; } } catch ( Exception e ) { LOG . debug ( "Ignored error looking up bean: " + name + ". Error: " + e ) ; } if ( bean != null ) { if ( bean instanceof Component ) { return ( Component ) bean ; } } Class type = null ; try { type = getComponent ( name ) ; } catch ( Throwable e ) { throw new IllegalArgumentException ( "Invalid URI, no Component registered for scheme : " + name , e ) ; } if ( type == null ) { return null ; } if ( Component . class . isAssignableFrom ( type ) ) { return ( Component ) context . getInjector ( ) . newInstance ( type ) ; } else { throw new IllegalArgumentException ( "Type is not a Component implementation. Found: " + type . getName ( ) ) ; } } } 	0	['4', '1', '0', '9', '21', '4', '1', '8', '2', '0.666666667', '113', '1', '0', '0', '0.666666667', '0', '0', '27', '1', '0.5', '0']
package org . apache . camel . component . jms . requestor ; import javax . jms . JMSException ; import javax . jms . Message ; import org . apache . camel . RuntimeCamelException ; public class FailedToProcessResponse extends RuntimeCamelException { private final Message response ; public FailedToProcessResponse ( Message response , JMSException e ) { super ( "Failed to process response: " + e + ". Message: " + response , e ) ; this . response = response ; } public Message getResponse ( ) { return response ; } } 	0	['2', '5', '0', '3', '7', '0', '2', '1', '2', '0', '25', '1', '0', '0.944444444', '0.666666667', '0', '0', '11', '1', '0.5', '0']
package org . apache . camel . component . uface ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; public class UFaceComponent extends DefaultComponent { protected Endpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { return new UFaceEndpoint ( uri , this ) ; } } 	0	['2', '3', '1', '4', '4', '1', '2', '3', '1', '2', '11', '0', '0', '0.972222222', '0.666666667', '1', '1', '4.5', '1', '0.5', '0']
package org . apache . camel . builder ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . util . ObjectHelper ; import static org . apache . camel . util . ObjectHelper . compare ; import static org . apache . camel . util . ObjectHelper . notNull ; public final class PredicateBuilder { private PredicateBuilder ( ) { } public static < E extends Exchange > Predicate < E > toPredicate ( final Expression < E > expression ) { return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { Object value = expression . evaluate ( exchange ) ; return ObjectHelper . evaluateValuePredicate ( value ) ; } @ Override public String toString ( ) { return expression . toString ( ) ; } } ; } public static < E extends Exchange > Predicate < E > not ( final Predicate < E > predicate ) { notNull ( predicate , "predicate" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { return ! predicate . matches ( exchange ) ; } @ Override public String toString ( ) { return "not " + predicate ; } } ; } public static < E extends Exchange > Predicate < E > and ( final Predicate < E > left , final Predicate < E > right ) { notNull ( left , "left" ) ; notNull ( right , "right" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { return left . matches ( exchange ) && right . matches ( exchange ) ; } @ Override public String toString ( ) { return "(" + left + ") and (" + right + ")" ; } } ; } public static < E extends Exchange > Predicate < E > or ( final Predicate < E > left , final Predicate < E > right ) { notNull ( left , "left" ) ; notNull ( right , "right" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { return left . matches ( exchange ) || right . matches ( exchange ) ; } @ Override public String toString ( ) { return "(" + left + ") or (" + right + ")" ; } } ; } public static < E extends Exchange > Predicate < E > isEqualTo ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return ObjectHelper . equal ( leftValue , rightValue ) ; } protected String getOperationText ( ) { return "==" ; } } ; } public static < E extends Exchange > Predicate < E > isNotEqualTo ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return ! ObjectHelper . equal ( leftValue , rightValue ) ; } protected String getOperationText ( ) { return "!=" ; } } ; } public static < E extends Exchange > Predicate < E > isLessThan ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return compare ( leftValue , rightValue ) < 0 ; } protected String getOperationText ( ) { return "<" ; } } ; } public static < E extends Exchange > Predicate < E > isLessThanOrEqualTo ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return compare ( leftValue , rightValue ) <= 0 ; } protected String getOperationText ( ) { return "<=" ; } } ; } public static < E extends Exchange > Predicate < E > isGreaterThan ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return compare ( leftValue , rightValue ) > 0 ; } protected String getOperationText ( ) { return ">" ; } } ; } public static < E extends Exchange > Predicate < E > isGreaterThanOrEqualTo ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return compare ( leftValue , rightValue ) >= 0 ; } protected String getOperationText ( ) { return ">=" ; } } ; } public static < E extends Exchange > Predicate < E > contains ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return ObjectHelper . contains ( leftValue , rightValue ) ; } protected String getOperationText ( ) { return "contains" ; } } ; } public static < E extends Exchange > Predicate < E > isNull ( final Expression < E > expression ) { return isEqualTo ( expression , ExpressionBuilder . < E > constantExpression ( null ) ) ; } public static < E extends Exchange > Predicate < E > isNotNull ( final Expression < E > expression ) { return isNotEqualTo ( expression , ExpressionBuilder . < E > constantExpression ( null ) ) ; } public static < E extends Exchange > Predicate < E > isInstanceOf ( final Expression < E > expression , final Class type ) { notNull ( expression , "expression" ) ; notNull ( type , "type" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { Object value = expression . evaluate ( exchange ) ; return type . isInstance ( value ) ; } @ Override public String toString ( ) { return expression + " instanceof " + type . getName ( ) ; } @ Override protected String assertionFailureMessage ( E exchange ) { return super . assertionFailureMessage ( exchange ) + " for <" + expression . evaluate ( exchange ) + ">" ; } } ; } public static < E extends Exchange > Predicate < E > regex ( final Expression < E > expression , final String regex ) { return regex ( expression , Pattern . compile ( regex ) ) ; } public static < E extends Exchange > Predicate < E > regex ( final Expression < E > expression , final Pattern pattern ) { notNull ( expression , "expression" ) ; notNull ( pattern , "pattern" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { Object value = expression . evaluate ( exchange ) ; if ( value != null ) { Matcher matcher = pattern . matcher ( value . toString ( ) ) ; return matcher . matches ( ) ; } return false ; } @ Override public String toString ( ) { return expression + ".matches(" + pattern + ")" ; } @ Override protected String assertionFailureMessage ( E exchange ) { return super . assertionFailureMessage ( exchange ) + " for <" + expression . evaluate ( exchange ) + ">" ; } } ; } } 	0	['17', '1', '0', '24', '34', '136', '7', '17', '16', '2', '138', '0', '0', '0', '0.196078431', '0', '0', '7.117647059', '1', '0.9412', '0']
package org . apache . camel . management ; import java . io . IOException ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Route ; import org . springframework . jmx . export . annotation . ManagedAttribute ; import org . springframework . jmx . export . annotation . ManagedOperation ; import org . springframework . jmx . export . annotation . ManagedResource ; @ ManagedResource ( description = "Managed Route" , currencyTimeLimit = 15 ) public class ManagedRoute extends PerformanceCounter { public static final String VALUE_UNKNOWN = "Unknown" ; private Route < ? extends Exchange > route ; private String description ; ManagedRoute ( Route < ? extends Exchange > route ) { this . route = route ; this . description = route . toString ( ) ; } public Route < ? extends Exchange > getRoute ( ) { return route ; } @ ManagedAttribute ( description = "Route Endpoint Uri" ) public String getEndpointUri ( ) { Endpoint < ? extends Exchange > ep = route . getEndpoint ( ) ; return ep != null ? ep . getEndpointUri ( ) : VALUE_UNKNOWN ; } @ ManagedAttribute ( description = "Route description" ) public String getDescription ( ) { return description ; } @ ManagedOperation ( description = "Start Route" ) public void start ( ) throws IOException { throw new IOException ( "Not supported" ) ; } @ ManagedOperation ( description = "Stop Route" ) public void stop ( ) throws IOException { throw new IOException ( "Not supported" ) ; } } 	0	['6', '3', '0', '5', '11', '7', '2', '3', '5', '0.866666667', '46', '0.666666667', '1', '0.761904762', '0.583333333', '0', '0', '6.166666667', '2', '1', '0']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "beanshell" ) public class BeanShellExpression extends ExpressionType { public BeanShellExpression ( ) { } public BeanShellExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "beanshell" ; } } 	0	['3', '2', '0', '1', '5', '3', '0', '1', '3', '2', '12', '0', '0', '0.956521739', '0.666666667', '1', '2', '3', '1', '0.3333', '0']
package org . apache . camel . component . http ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; public class HttpConsumer extends DefaultConsumer < HttpExchange > { private final HttpEndpoint endpoint ; public HttpConsumer ( HttpEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; } @ Override public HttpEndpoint getEndpoint ( ) { return ( HttpEndpoint ) super . getEndpoint ( ) ; } public HttpBinding getBinding ( ) { return endpoint . getBinding ( ) ; } public String getPath ( ) { return endpoint . getPath ( ) ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; endpoint . connect ( this ) ; } @ Override protected void doStop ( ) throws Exception { endpoint . disconnect ( this ) ; super . doStop ( ) ; } } 	0	['7', '3', '0', '10', '14', '1', '6', '5', '5', '0.333333333', '45', '1', '1', '0.793103448', '0.428571429', '1', '1', '5.285714286', '1', '0.8571', '0']
package org . apache . camel . language . ognl ; import ognl . Ognl ; import ognl . OgnlContext ; import ognl . OgnlException ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . impl . ExpressionSupport ; import org . apache . camel . language . ExpressionEvaluationException ; import org . apache . camel . language . IllegalSyntaxException ; public class OgnlExpression extends ExpressionSupport < Exchange > { private final String expressionString ; private final Class < ? > type ; private Object expression ; public OgnlExpression ( OgnlLanguage language , String expressionString , Class < ? > type ) { this . expressionString = expressionString ; this . type = type ; try { this . expression = Ognl . parseExpression ( expressionString ) ; } catch ( OgnlException e ) { throw new IllegalSyntaxException ( language , expressionString , e ) ; } } public static OgnlExpression ognl ( String expression ) { return new OgnlExpression ( new OgnlLanguage ( ) , expression , Object . class ) ; } public Object evaluate ( Exchange exchange ) { OgnlContext oglContext = new OgnlContext ( ) ; try { return Ognl . getValue ( expression , oglContext , new RootObject ( exchange ) ) ; } catch ( OgnlException e ) { throw new ExpressionEvaluationException ( this , exchange , e ) ; } } protected String assertionFailureMessage ( Exchange exchange ) { return expressionString ; } } 	0	['4', '2', '0', '11', '12', '2', '1', '11', '3', '0.444444444', '62', '1', '0', '0.625', '0.45', '1', '2', '13.75', '1', '0.75', '0']
package org . apache . camel . impl ; import java . lang . reflect . Method ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . CamelContext ; import org . apache . camel . CamelContextAware ; import org . apache . camel . Consume ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . MessageDriven ; import org . apache . camel . PollingConsumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . ProducerTemplate ; import org . apache . camel . Service ; import org . apache . camel . component . bean . BeanProcessor ; import org . apache . camel . component . bean . ProxyHelper ; import org . apache . camel . util . CamelContextHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class CamelPostProcessorHelper implements CamelContextAware { private static final transient Log LOG = LogFactory . getLog ( CamelPostProcessorHelper . class ) ; @ XmlTransient private CamelContext camelContext ; public CamelPostProcessorHelper ( ) { } public CamelPostProcessorHelper ( CamelContext camelContext ) { this . setCamelContext ( camelContext ) ; } public CamelContext getCamelContext ( ) { return camelContext ; } public void setCamelContext ( CamelContext camelContext ) { this . camelContext = camelContext ; } public void consumerInjection ( Method method , Object bean ) { MessageDriven annotation = method . getAnnotation ( MessageDriven . class ) ; if ( annotation != null ) { LOG . info ( "Creating a consumer for: " + annotation ) ; subscribeMethod ( method , bean , annotation . uri ( ) , annotation . name ( ) ) ; } Consume consume = method . getAnnotation ( Consume . class ) ; if ( consume != null ) { LOG . info ( "Creating a consumer for: " + consume ) ; subscribeMethod ( method , bean , consume . uri ( ) , consume . ref ( ) ) ; } } protected void subscribeMethod ( Method method , Object bean , String endpointUri , String endpointName ) { String injectionPointName = method . getName ( ) ; Endpoint endpoint = getEndpointInjection ( endpointUri , endpointName , injectionPointName , true ) ; if ( endpoint != null ) { try { Processor processor = createConsumerProcessor ( bean , method , endpoint ) ; LOG . info ( "Created processor: " + processor ) ; Consumer consumer = endpoint . createConsumer ( processor ) ; startService ( consumer ) ; } catch ( Exception e ) { LOG . warn ( e ) ; throw org . apache . camel . util . ObjectHelper . wrapRuntimeCamelException ( e ) ; } } } public void startService ( Service service ) throws Exception { CamelContext camelContext = getCamelContext ( ) ; if ( camelContext instanceof DefaultCamelContext ) { DefaultCamelContext defaultCamelContext = ( DefaultCamelContext ) camelContext ; defaultCamelContext . addService ( service ) ; } else { service . start ( ) ; } } protected Processor createConsumerProcessor ( final Object pojo , final Method method , final Endpoint endpoint ) { BeanProcessor answer = new BeanProcessor ( pojo , getCamelContext ( ) ) ; answer . setMethodObject ( method ) ; return answer ; } protected Endpoint getEndpointInjection ( String uri , String name , String injectionPointName , boolean mandatory ) { return CamelContextHelper . getEndpointInjection ( getCamelContext ( ) , uri , name , injectionPointName , mandatory ) ; } public Object getInjectionValue ( Class < ? > type , String endpointUri , String endpointRef , String injectionPointName ) { if ( type . isAssignableFrom ( ProducerTemplate . class ) ) { Endpoint endpoint = getEndpointInjection ( endpointUri , endpointRef , injectionPointName , false ) ; return new DefaultProducerTemplate ( getCamelContext ( ) , endpoint ) ; } else { Endpoint endpoint = getEndpointInjection ( endpointUri , endpointRef , injectionPointName , true ) ; if ( endpoint != null ) { if ( type . isInstance ( endpoint ) ) { return endpoint ; } else if ( type . isAssignableFrom ( Producer . class ) ) { return createInjectionProducer ( endpoint ) ; } else if ( type . isAssignableFrom ( PollingConsumer . class ) ) { return createInjectionPollingConsumer ( endpoint ) ; } else if ( type . isInterface ( ) ) { try { return ProxyHelper . createProxy ( endpoint , type ) ; } catch ( Exception e ) { throw createProxyInstantiationRuntimeException ( type , endpoint , e ) ; } } else { throw new IllegalArgumentException ( "Invalid type: " + type . getName ( ) + " which cannot be injected via @EndpointInject for " + endpoint ) ; } } return null ; } } protected RuntimeException createProxyInstantiationRuntimeException ( Class < ? > type , Endpoint endpoint , Exception e ) { return new ProxyInstantiationException ( type , endpoint , e ) ; } protected PollingConsumer createInjectionPollingConsumer ( Endpoint endpoint ) { try { PollingConsumer pollingConsumer = endpoint . createPollingConsumer ( ) ; startService ( pollingConsumer ) ; return pollingConsumer ; } catch ( Exception e ) { throw org . apache . camel . util . ObjectHelper . wrapRuntimeCamelException ( e ) ; } } protected Producer createInjectionProducer ( Endpoint endpoint ) { try { Producer producer = endpoint . createProducer ( ) ; startService ( producer ) ; return producer ; } catch ( Exception e ) { throw org . apache . camel . util . ObjectHelper . wrapRuntimeCamelException ( e ) ; } } } 	0	['14', '1', '1', '23', '45', '83', '3', '20', '7', '0.615384615', '285', '1', '1', '0', '0.253846154', '0', '0', '19.21428571', '7', '1.4286', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Processor ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "otherwise" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class OtherwiseType extends OutputType < ProcessorType > implements Block { @ Override public String toString ( ) { return "Otherwise[" + getOutputs ( ) + "]" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { return routeContext . createProcessor ( this ) ; } @ Override public String getShortName ( ) { return "otherwise" ; } @ Override public String getLabel ( ) { return "otherwise" ; } } 	0	['5', '4', '0', '8', '12', '10', '3', '5', '5', '2', '28', '0', '0', '0.978142077', '0.6', '1', '1', '4.6', '1', '0.8', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Endpoint ; import org . apache . camel . ExchangePattern ; @ XmlRootElement ( name = "inOut" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class InOutType extends SendType < InOutType > { public InOutType ( ) { } public InOutType ( String uri ) { setUri ( uri ) ; } public InOutType ( Endpoint endpoint ) { setEndpoint ( endpoint ) ; } @ Override public String toString ( ) { return "InOut[" + getLabel ( ) + "]" ; } @ Override public String getShortName ( ) { return "inOut" ; } @ Override public ExchangePattern getPattern ( ) { return ExchangePattern . InOut ; } } 	0	['6', '4', '0', '3', '13', '15', '0', '3', '6', '2', '37', '0', '0', '0.984293194', '0.444444444', '2', '2', '5.166666667', '1', '0.5', '0']
package org . apache . camel . component . jhc ; import java . net . URI ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . HeaderFilterStrategyAware ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . impl . DefaultHeaderFilterStrategy ; import org . apache . camel . spi . HeaderFilterStrategy ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . http . params . BasicHttpParams ; import org . apache . http . params . HttpConnectionParams ; import org . apache . http . params . HttpParams ; import org . apache . http . params . HttpProtocolParams ; public class JhcComponent extends DefaultComponent < JhcExchange > implements HeaderFilterStrategyAware { private static final Log LOG = LogFactory . getLog ( JhcComponent . class ) ; private HttpParams params ; private HeaderFilterStrategy headerFilterStrategy ; public JhcComponent ( ) { setHeaderFilterStrategy ( new JhcHeaderFilterStrategy ( ) ) ; params = new BasicHttpParams ( ) . setIntParameter ( HttpConnectionParams . SO_TIMEOUT , 5000 ) . setIntParameter ( HttpConnectionParams . CONNECTION_TIMEOUT , 10000 ) . setIntParameter ( HttpConnectionParams . SOCKET_BUFFER_SIZE , 8 * 1024 ) . setBooleanParameter ( HttpConnectionParams . STALE_CONNECTION_CHECK , false ) . setBooleanParameter ( HttpConnectionParams . TCP_NODELAY , true ) . setParameter ( HttpProtocolParams . USER_AGENT , "Camel-JhcComponent/1.1" ) ; } public HttpParams getParams ( ) { return params ; } public void setParams ( HttpParams params ) { this . params = params ; } protected Endpoint < JhcExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { return new JhcEndpoint ( uri , this , new URI ( uri . substring ( uri . indexOf ( ':' ) + 1 ) ) ) ; } public HeaderFilterStrategy getHeaderFilterStrategy ( ) { return headerFilterStrategy ; } public void setHeaderFilterStrategy ( HeaderFilterStrategy strategy ) { headerFilterStrategy = strategy ; } } 	0	['7', '3', '0', '10', '19', '13', '1', '10', '5', '0.777777778', '75', '1', '1', '0.875', '0.333333333', '1', '1', '9.285714286', '1', '0.7143', '0']
package org . apache . camel . builder ; import org . apache . camel . Processor ; public interface ProcessorFactory { Processor createProcessor ( ) throws Exception ; } 	0	['1', '1', '0', '5', '1', '0', '4', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . jcr ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . impl . DefaultExchange ; public class JcrComponent extends DefaultComponent < DefaultExchange > { public static final String NODE_NAME = "org.apache.camel.component.jcr.node_name" ; @ Override @ SuppressWarnings ( "unchecked" ) protected Endpoint < DefaultExchange > createEndpoint ( String uri , String remaining , Map properties ) throws Exception { return new JcrEndpoint ( uri , this ) ; } } 	0	['2', '3', '0', '3', '4', '1', '1', '3', '1', '2', '12', '0', '0', '0.972222222', '0.666666667', '1', '1', '4.5', '1', '0.5', '0']
package org . apache . camel . component . atom ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import org . apache . abdera . Abdera ; import org . apache . abdera . model . Document ; import org . apache . abdera . model . Feed ; import org . apache . abdera . parser . ParseException ; import org . apache . abdera . parser . Parser ; public final class AtomUtils { private AtomUtils ( ) { } public static Parser getAtomParser ( ) { return Abdera . getInstance ( ) . getParser ( ) ; } public static Document < Feed > parseDocument ( String uri ) throws IOException , ParseException { InputStream in = new URL ( uri ) . openStream ( ) ; return getAtomParser ( ) . parse ( in ) ; } } 	0	['3', '1', '0', '6', '9', '3', '2', '4', '2', '2', '19', '0', '0', '0', '0.333333333', '0', '0', '5.333333333', '1', '0.6667', '0']
package org . apache . camel . component . stream ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . Writer ; import java . net . URL ; import java . net . URLConnection ; import java . nio . charset . Charset ; import java . util . Arrays ; import java . util . List ; import org . apache . camel . CamelExchangeException ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class StreamProducer extends DefaultProducer < Exchange > { private static final transient Log LOG = LogFactory . getLog ( StreamProducer . class ) ; private static final String TYPES = "out,err,file,header,url" ; private static final String INVALID_URI = "Invalid uri, valid form: 'stream:{" + TYPES + "}'" ; private static final List < String > TYPES_LIST = Arrays . asList ( TYPES . split ( "," ) ) ; private OutputStream outputStream = System . out ; private StreamEndpoint endpoint ; private String uri ; public StreamProducer ( StreamEndpoint endpoint , String uri ) throws Exception { super ( endpoint ) ; this . endpoint = endpoint ; validateUri ( uri ) ; } @ Override public void doStop ( ) throws Exception { super . doStop ( ) ; } public void process ( Exchange exchange ) throws Exception { delay ( endpoint . getDelay ( ) ) ; if ( "out" . equals ( uri ) ) { outputStream = System . out ; } else if ( "err" . equals ( uri ) ) { outputStream = System . err ; } else if ( "file" . equals ( uri ) ) { outputStream = resolveStreamFromFile ( ) ; } else if ( "header" . equals ( uri ) ) { outputStream = resolveStreamFromHeader ( exchange . getIn ( ) . getHeader ( "stream" ) , exchange ) ; } else if ( "url" . equals ( uri ) ) { outputStream = resolveStreamFromUrl ( ) ; } writeToStream ( exchange ) ; } private OutputStream resolveStreamFromUrl ( ) throws IOException { String u = endpoint . getUrl ( ) ; URL url = new URL ( u ) ; URLConnection c = url . openConnection ( ) ; return c . getOutputStream ( ) ; } private OutputStream resolveStreamFromFile ( ) throws IOException { String fileName = endpoint . getFile ( ) != null ? endpoint . getFile ( ) . trim ( ) : "_file" ; File f = new File ( fileName ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "About to write to file: " + f ) ; } f . createNewFile ( ) ; return new FileOutputStream ( f ) ; } private OutputStream resolveStreamFromHeader ( Object o , Exchange exchange ) throws CamelExchangeException { if ( o != null && o instanceof OutputStream ) { return ( OutputStream ) o ; } else { throw new CamelExchangeException ( "Expected OutputStream in header('stream'), found: " + o , exchange ) ; } } private void delay ( long ms ) throws InterruptedException { if ( ms == 0 ) { return ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Delaying " + ms + " millis" ) ; } Thread . sleep ( ms ) ; } private void writeToStream ( Exchange exchange ) throws IOException , CamelExchangeException { Object body = exchange . getIn ( ) . getBody ( ) ; if ( body instanceof String ) { Charset charset = endpoint . getCharset ( ) ; Writer writer = new OutputStreamWriter ( outputStream , charset ) ; BufferedWriter bw = new BufferedWriter ( writer ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Writing as text: " + body + " to " + outputStream + " using encoding:" + charset ) ; } bw . write ( ( String ) body ) ; bw . write ( "\n" ) ; bw . flush ( ) ; } else if ( body instanceof byte [ ] ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Writing as text: " + body + " to " + outputStream ) ; } outputStream . write ( ( byte [ ] ) body ) ; } else { throw new CamelExchangeException ( "The body is neither a String or byte array. " + "Can not write body to output stream" , exchange ) ; } } private void validateUri ( String uri ) throws Exception { String [ ] s = uri . split ( ":" ) ; if ( s . length < 2 ) { throw new IllegalArgumentException ( INVALID_URI ) ; } String [ ] t = s [ 1 ] . split ( "\\?" ) ; if ( t . length < 1 ) { throw new IllegalArgumentException ( INVALID_URI ) ; } this . uri = t [ 0 ] . trim ( ) ; if ( ! TYPES_LIST . contains ( this . uri ) ) { throw new IllegalArgumentException ( INVALID_URI ) ; } } } 	0	['10', '3', '0', '8', '46', '11', '1', '8', '3', '0.80952381', '334', '1', '1', '0.724137931', '0.314814815', '1', '1', '31.7', '1', '0.8', '0']
package org . apache . camel . spring ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . model . IdentifiedType ; @ XmlRootElement ( name = "jmxAgent" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class CamelJMXAgentType extends IdentifiedType { @ XmlAttribute ( required = false ) private Boolean disabled = Boolean . FALSE ; @ XmlAttribute ( required = false ) private Integer registryPort ; @ XmlAttribute ( required = false ) private Integer connectorPort ; @ XmlAttribute ( required = false ) private String mbeanServerDefaultDomain ; @ XmlAttribute ( required = false ) private String mbeanObjectDomainName ; @ XmlAttribute ( required = false ) private String serviceUrlPath ; @ XmlAttribute ( required = false ) private Boolean createConnector = Boolean . TRUE ; @ XmlAttribute ( required = false ) private Boolean usePlatformMBeanServer = Boolean . TRUE ; public Integer getConnectorPort ( ) { return connectorPort ; } public void setConnectorPort ( Integer value ) { connectorPort = value ; } public Integer getRegistryPort ( ) { return registryPort ; } public void setRegistryPort ( Integer value ) { registryPort = value ; } public String getMbeanServerDefaultDomain ( ) { return mbeanServerDefaultDomain ; } public void setMbeanServerDefaultDomain ( String value ) { mbeanServerDefaultDomain = value ; } public String getMbeanObjectDomainName ( ) { return mbeanObjectDomainName ; } public void setMbeanObjectDomainName ( String value ) { mbeanObjectDomainName = value ; } public String getServiceUrlPath ( ) { return serviceUrlPath ; } public void setServiceUrlPath ( String value ) { serviceUrlPath = value ; } public Boolean isCreateConnector ( ) { return createConnector ; } public void setCreateConnector ( Boolean value ) { createConnector = value != null ? value : Boolean . FALSE ; } public Boolean isUsePlatformMBeanServer ( ) { return usePlatformMBeanServer ; } public void setUsePlatformMBeanServer ( Boolean value ) { usePlatformMBeanServer = value != null ? value : Boolean . FALSE ; } public Boolean isDisabled ( ) { return disabled ; } public void setDisabled ( Boolean value ) { disabled = value != null ? value : Boolean . FALSE ; } } 	0	['17', '2', '0', '2', '18', '108', '1', '1', '17', '0.9140625', '105', '1', '0', '0.111111111', '0.367647059', '0', '0', '4.705882353', '2', '1.1176', '0']
package org . apache . camel . component . jhc ; import org . apache . camel . CamelContext ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; import org . apache . http . HttpRequest ; import org . apache . http . HttpResponse ; public class JhcExchange extends DefaultExchange { public JhcExchange ( CamelContext context ) { super ( context ) ; } public JhcExchange ( CamelContext context , ExchangePattern pattern ) { super ( context , pattern ) ; } } 	0	['2', '2', '0', '3', '4', '1', '0', '3', '2', '2', '11', '0', '0', '1', '0.833333333', '0', '0', '4.5', '0', '0', '0']
package org . apache . camel . component . uface ; import java . beans . PropertyChangeListener ; import java . beans . PropertyChangeSupport ; import java . util . Collection ; import java . util . List ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultCamelContext ; import org . apache . camel . impl . DelegateLifecycleStrategy ; import org . apache . camel . spi . BrowsableEndpoint ; import org . apache . camel . util . CamelContextHelper ; import org . apache . camel . util . ObjectHelper ; import org . eclipse . core . databinding . observable . Realm ; import org . eclipse . core . databinding . observable . list . IObservableList ; import org . eclipse . core . databinding . observable . list . WritableList ; import org . eclipse . core . databinding . observable . value . WritableValue ; import org . ufacekit . model . ModelHelper ; import org . ufacekit . ui . AttributeDescriptor ; import org . ufacekit . ui . UIComposite ; import org . ufacekit . ui . UIFactory ; import org . ufacekit . ui . beanform . BeanForm ; import org . ufacekit . ui . controls . CellLabelProvider ; import org . ufacekit . ui . controls . UITable ; import org . ufacekit . ui . controls . UITableColumn ; import org . ufacekit . ui . layouts . GridLayoutData ; public class UFaceBrowser { private final DefaultCamelContext camelContext ; private IObservableList endpoints ; private PropertyChangeSupport propertyChangeSupport = new PropertyChangeSupport ( this ) ; public UFaceBrowser ( DefaultCamelContext camelContext ) { ObjectHelper . notNull ( camelContext , "camelContext" ) ; this . camelContext = camelContext ; this . endpoints = new WritableList ( Realm . getDefault ( ) ) ; List < BrowsableEndpoint > list = CamelContextHelper . getSingletonEndpoints ( camelContext , BrowsableEndpoint . class ) ; for ( BrowsableEndpoint endpoint : list ) { if ( ! endpoints . contains ( endpoint ) ) { endpoints . add ( endpoint ) ; } } camelContext . setLifecycleStrategy ( new DelegateLifecycleStrategy ( camelContext . getLifecycleStrategy ( ) ) { @ Override public void onEndpointAdd ( Endpoint < ? extends Exchange > endpoint ) { super . onEndpointAdd ( endpoint ) ; if ( endpoint instanceof BrowsableEndpoint ) { onBrowsableEndpoint ( ( BrowsableEndpoint ) endpoint ) ; } } } ) ; } public void addPropertyChangeListener ( PropertyChangeListener listener ) { propertyChangeSupport . addPropertyChangeListener ( listener ) ; } public void removePropertyChangeListener ( PropertyChangeListener listener ) { propertyChangeSupport . removePropertyChangeListener ( listener ) ; } public IObservableList getEndpoints ( ) { return endpoints ; } public DefaultCamelContext getCamelContext ( ) { return camelContext ; } public void createBrowserUI ( UIComposite root ) { UIFactory ui = root . getFactory ( ) ; UIComposite splitter = ui . newHorizontalSplitPanel ( root , new GridLayoutData ( GridLayoutData . ALIGN_CENTER , GridLayoutData . ALIGN_CENTER ) ) ; UITable tree = createEndpointTableUI ( splitter ) ; BeanForm selectionForm = new BeanForm ( ) ; UITable table = ui . newTable ( splitter , new UITable . TableUIInfo ( new GridLayoutData ( GridLayoutData . ALIGN_FILL , GridLayoutData . ALIGN_FILL , true , true ) ) ) ; selectionForm . add ( table , new UITable . TableBindingInfo ( selectionForm . detailList ( "exchanges" , Collection . class ) ) ) ; ui . newTableColumn ( table , new UITableColumn . TableColumnUIInfo ( null , new CellLabelProvider ( ) { public String getLabel ( Object object ) { Exchange exchange = ( Exchange ) object ; return exchange . getIn ( ) . getBody ( String . class ) ; } } ) ) ; ui . newTableColumn ( table , new UITableColumn . TableColumnUIInfo ( null , new CellLabelProvider ( ) { public String getLabel ( Object object ) { Exchange exchange = ( Exchange ) object ; return exchange . getIn ( ) . getHeaders ( ) . toString ( ) ; } } ) ) ; selectionForm . bind ( tree . getSelectionObservable ( ) ) ; } protected UITable createEndpointTableUI ( UIComposite root ) { BeanForm form = new BeanForm ( ) ; UIFactory ui = root . getFactory ( ) ; AttributeDescriptor bindingData = form . detailList ( "endpoints" , Collection . class ) ; UITable table = ui . newTable ( root , new UITable . TableUIInfo ( null ) ) ; form . add ( table , new UITable . TableBindingInfo ( bindingData ) ) ; ui . newTableColumn ( table , new UITableColumn . TableColumnUIInfo ( null , new CellLabelProvider ( ) { public String getLabel ( Object object ) { BrowsableEndpoint endpoint = ( BrowsableEndpoint ) object ; return endpoint . getEndpointUri ( ) ; } } ) ) ; WritableValue value = ModelHelper . createWritableValue ( this ) ; form . bind ( value ) ; return table ; } protected void onBrowsableEndpoint ( BrowsableEndpoint endpoint ) { endpoints . add ( endpoint ) ; } } 	0	['8', '1', '1', '31', '42', '14', '5', '30', '6', '0.761904762', '207', '1', '1', '0', '0.35', '0', '0', '24.5', '1', '0.875', '0']
package org . apache . camel . spi ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Exchange ; public interface ComponentResolver < E extends Exchange > { Component < E > resolveComponent ( String name , CamelContext context ) throws Exception ; } 	0	['1', '1', '0', '6', '1', '0', '4', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . processor . interceptor ; import org . apache . camel . Exchange ; public interface ExchangeFormatter { Object format ( Exchange exchange ) ; } 	0	['1', '1', '0', '6', '1', '0', '5', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . jhc ; import java . io . IOException ; import org . apache . camel . AsyncCallback ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . http . HttpEntity ; import org . apache . http . HttpEntityEnclosingRequest ; import org . apache . http . HttpException ; import org . apache . http . HttpRequest ; import org . apache . http . HttpResponse ; import org . apache . http . HttpResponseFactory ; import org . apache . http . HttpStatus ; import org . apache . http . HttpVersion ; import org . apache . http . ProtocolVersion ; import org . apache . http . impl . DefaultHttpResponseFactory ; import org . apache . http . nio . NHttpConnection ; import org . apache . http . nio . protocol . EventListener ; import org . apache . http . params . HttpParams ; import org . apache . http . protocol . HttpContext ; import org . apache . http . protocol . HttpRequestHandler ; public class JhcConsumer extends DefaultConsumer < JhcExchange > { private static final Log LOG = LogFactory . getLog ( JhcConsumer . class ) ; private JhcServerEngine engine ; private MyHandler handler ; public JhcConsumer ( JhcEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; engine = JhcServerEngineFactory . getJhcServerEngine ( endpoint . getParams ( ) , endpoint . getPort ( ) , endpoint . getProtocol ( ) ) ; handler = new MyHandler ( endpoint . getParams ( ) , endpoint . getPath ( ) ) ; } public JhcEndpoint getEndpoint ( ) { return ( JhcEndpoint ) super . getEndpoint ( ) ; } protected void doStart ( ) throws Exception { super . doStart ( ) ; engine . register ( handler . getPath ( ) + "*" , handler ) ; if ( ! engine . isStarted ( ) ) { engine . start ( ) ; } } protected void doStop ( ) throws Exception { engine . unregister ( handler . getPath ( ) + "*" ) ; if ( engine . getReferenceCounter ( ) == 0 ) { engine . stop ( ) ; } super . doStop ( ) ; } class MyHttpRequestHandler implements HttpRequestHandler { public void handle ( HttpRequest httpRequest , HttpResponse httpResponse , HttpContext httpContext ) throws HttpException , IOException { LOG . debug ( "handle" ) ; } } static class EventLogger implements EventListener { public void connectionOpen ( final NHttpConnection conn ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Connection open: " + conn ) ; } } public void connectionTimeout ( final NHttpConnection conn ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Connection timed out: " + conn ) ; } } public void connectionClosed ( final NHttpConnection conn ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Connection closed: " + conn ) ; } } public void fatalIOException ( final IOException ex , final NHttpConnection conn ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "I/O error: " + ex . getMessage ( ) ) ; } } public void fatalProtocolException ( final HttpException ex , final NHttpConnection conn ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "HTTP error: " + ex . getMessage ( ) ) ; } } } class MyHandler implements AsyncHttpRequestHandler { private final HttpParams params ; private final HttpResponseFactory responseFactory ; private final String path ; public MyHandler ( HttpParams params , String path ) { this ( params , path , new DefaultHttpResponseFactory ( ) ) ; } public MyHandler ( HttpParams params , String path , HttpResponseFactory responseFactory ) { this . params = params ; this . path = path ; this . responseFactory = responseFactory ; } public String getPath ( ) { return path ; } public void handle ( final HttpRequest request , final HttpContext context , final AsyncResponseHandler handler ) throws HttpException , IOException { final Exchange exchange = getEndpoint ( ) . createExchange ( ) ; exchange . getIn ( ) . setHeader ( "http.uri" , request . getRequestLine ( ) . getUri ( ) ) ; if ( request instanceof HttpEntityEnclosingRequest ) { exchange . getIn ( ) . setBody ( ( ( HttpEntityEnclosingRequest ) request ) . getEntity ( ) ) ; } getAsyncProcessor ( ) . process ( exchange , new AsyncCallback ( ) { public void done ( boolean doneSynchronously ) { LOG . debug ( "handleExchange" ) ; ProtocolVersion httpVersion = ( HttpVersion ) request . getRequestLine ( ) . getProtocolVersion ( ) ; HttpResponse response = responseFactory . newHttpResponse ( httpVersion , HttpStatus . SC_OK , context ) ; response . setParams ( params ) ; HttpEntity entity = exchange . getOut ( ) . getBody ( HttpEntity . class ) ; response . setEntity ( entity ) ; response . setParams ( getEndpoint ( ) . getParams ( ) ) ; try { handler . sendResponse ( response ) ; } catch ( Exception e ) { LOG . info ( e ) ; } } } ) ; } public void handle ( HttpRequest request , HttpResponse response , HttpContext context ) throws HttpException , IOException { } } } 	0	['7', '3', '0', '14', '27', '13', '5', '11', '3', '0.722222222', '95', '1', '2', '0.821428571', '0.388888889', '1', '1', '12.14285714', '1', '0.7143', '0']
package org . apache . camel . builder ; public class NoRouteBuilder extends RouteBuilder { private static final NoRouteBuilder INSTANCE = new NoRouteBuilder ( ) ; public static NoRouteBuilder getInstance ( ) { return INSTANCE ; } public void configure ( ) throws Exception { } } 	0	['4', '3', '0', '1', '5', '4', '0', '1', '3', '0.666666667', '16', '1', '1', '0.964285714', '0.666666667', '1', '1', '2.75', '1', '0.5', '0']
package org . apache . camel . impl . converter ; import org . apache . camel . Exchange ; import org . apache . camel . TypeConverter ; public class ToStringTypeConverter implements TypeConverter { public < T > T convertTo ( Class < T > toType , Object value ) { if ( value != null ) { if ( toType . equals ( String . class ) ) { return ( T ) value . toString ( ) ; } } return null ; } public < T > T convertTo ( Class < T > type , Exchange exchange , Object value ) { return convertTo ( type , value ) ; } } 	0	['3', '1', '0', '3', '6', '3', '1', '2', '3', '2', '22', '0', '0', '0', '0.666666667', '0', '0', '6.333333333', '3', '1.3333', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Processor ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "pipeline" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class PipelineType extends OutputType < ProcessorType > { @ Override public String getShortName ( ) { return "pipeline" ; } public Processor createProcessor ( RouteContext routeContext ) throws Exception { return createOutputsProcessor ( routeContext ) ; } } 	0	['3', '4', '0', '4', '5', '3', '1', '3', '3', '2', '12', '0', '0', '0.988950276', '0.666666667', '1', '2', '3', '1', '0.6667', '0']
package org . apache . camel . model ; import java . util . List ; import javax . xml . bind . annotation . XmlElementRef ; public interface RouteContainer { @ XmlElementRef List < RouteType > getRoutes ( ) ; void setRoutes ( List < RouteType > routes ) ; } 	0	['2', '1', '0', '2', '2', '1', '2', '0', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . camel . model ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Processor ; import org . apache . camel . processor . ExchangePatternProcessor ; import org . apache . camel . spi . RouteContext ; import org . apache . camel . util . ObjectHelper ; @ XmlRootElement ( name = "setExchangePattern" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class SetExchangePatternType extends OutputType { @ XmlAttribute ( required = true ) private ExchangePattern pattern ; @ XmlTransient private ExchangePatternProcessor processor ; public SetExchangePatternType ( ) { } public SetExchangePatternType ( ExchangePattern pattern ) { this . pattern = pattern ; } public SetExchangePatternType pattern ( ExchangePattern pattern ) { setPattern ( pattern ) ; return this ; } public ExchangePattern getPattern ( ) { return pattern ; } public void setPattern ( ExchangePattern pattern ) { this . pattern = pattern ; } @ Override public String getShortName ( ) { return "setExchangePattern" ; } @ Override public String toString ( ) { return "setExchangePattern[" + "pattern: " + pattern + "]" ; } @ Override public String getLabel ( ) { return "setExchangePattern: " + pattern ; } @ Override public Processor createProcessor ( RouteContext routeContext ) { if ( processor == null ) { processor = new ExchangePatternProcessor ( getPattern ( ) ) ; } return processor ; } } 	0	['9', '4', '0', '6', '15', '16', '1', '5', '9', '0.625', '69', '1', '2', '0.962365591', '0.481481481', '1', '1', '6.444444444', '2', '0.8889', '0']
package org . apache . camel . component . rmi ; import java . util . Map ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . component . bean . BeanExchange ; import org . apache . camel . impl . DefaultComponent ; public class RmiComponent extends DefaultComponent < BeanExchange > { public RmiComponent ( ) { } public RmiComponent ( CamelContext context ) { super ( context ) ; } @ Override protected Endpoint < BeanExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { return new RmiEndpoint ( uri , this ) ; } } 	0	['3', '3', '0', '4', '6', '3', '1', '4', '2', '2', '16', '0', '0', '0.972222222', '0.5', '1', '1', '4.333333333', '1', '0.3333', '0']
package org . apache . camel . spi ; import java . util . List ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; public interface BrowsableEndpoint < T extends Exchange > extends Endpoint < T > { List < Exchange > getExchanges ( ) ; } 	0	['1', '1', '0', '8', '1', '0', '7', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . cxf . transport ; import java . io . IOException ; import java . io . OutputStream ; import java . util . logging . Level ; import java . util . logging . Logger ; import org . apache . camel . CamelContext ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . ProducerTemplate ; import org . apache . camel . component . cxf . CxfConstants ; import org . apache . camel . component . cxf . CxfSoapBinding ; import org . apache . camel . component . cxf . util . CxfHeaderHelper ; import org . apache . camel . impl . DefaultCamelContext ; import org . apache . camel . spi . HeaderFilterStrategy ; import org . apache . cxf . Bus ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . configuration . Configurable ; import org . apache . cxf . configuration . Configurer ; import org . apache . cxf . io . CachedOutputStream ; import org . apache . cxf . message . Message ; import org . apache . cxf . message . MessageImpl ; import org . apache . cxf . service . model . EndpointInfo ; import org . apache . cxf . transport . AbstractConduit ; import org . apache . cxf . transport . AbstractDestination ; import org . apache . cxf . transport . Conduit ; import org . apache . cxf . transport . ConduitInitiator ; import org . apache . cxf . transport . MessageObserver ; import org . apache . cxf . ws . addressing . EndpointReferenceType ; import org . apache . cxf . wsdl . EndpointReferenceUtils ; public class CamelDestination extends AbstractDestination implements Configurable { protected static final String BASE_BEAN_NAME_SUFFIX = ".camel-destination" ; private static final Logger LOG = LogUtils . getL7dLogger ( CamelDestination . class ) ; final ConduitInitiator conduitInitiator ; CamelContext camelContext ; Consumer consumer ; String camelDestinationUri ; private ProducerTemplate < Exchange > camelTemplate ; private Endpoint distinationEndpoint ; private HeaderFilterStrategy headerFilterStrategy ; public CamelDestination ( CamelContext camelContext , Bus bus , ConduitInitiator ci , EndpointInfo info ) throws IOException { this ( camelContext , bus , ci , info , null ) ; } public CamelDestination ( CamelContext camelContext , Bus bus , ConduitInitiator ci , EndpointInfo info , HeaderFilterStrategy headerFilterStrategy ) throws IOException { super ( bus , getTargetReference ( info , bus ) , info ) ; this . camelContext = camelContext ; conduitInitiator = ci ; camelDestinationUri = endpointInfo . getAddress ( ) . substring ( CxfConstants . CAMEL_TRANSPORT_PREFIX . length ( ) ) ; if ( camelDestinationUri . startsWith ( "//" ) ) { camelDestinationUri = camelDestinationUri . substring ( 2 ) ; } initConfig ( ) ; this . headerFilterStrategy = headerFilterStrategy ; } protected Logger getLogger ( ) { return LOG ; } protected Conduit getInbuiltBackChannel ( Message inMessage ) { return new BackChannelConduit ( inMessage ) ; } public void activate ( ) { getLogger ( ) . log ( Level . FINE , "CamelDestination activate().... " ) ; try { getLogger ( ) . log ( Level . FINE , "establishing Camel connection" ) ; distinationEndpoint = getCamelContext ( ) . getEndpoint ( camelDestinationUri ) ; consumer = distinationEndpoint . createConsumer ( new ConsumerProcessor ( ) ) ; consumer . start ( ) ; } catch ( Exception ex ) { getLogger ( ) . log ( Level . SEVERE , "Camel connect failed with Exception : " , ex ) ; } } public void deactivate ( ) { try { consumer . stop ( ) ; } catch ( Exception e ) { getLogger ( ) . log ( Level . SEVERE , "Camel stop failed with Exception : " , e ) ; } } public void shutdown ( ) { getLogger ( ) . log ( Level . FINE , "CamelDestination shutdown()" ) ; this . deactivate ( ) ; } public ProducerTemplate < Exchange > getCamelTemplate ( ) { if ( camelTemplate == null ) { camelTemplate = getCamelContext ( ) . createProducerTemplate ( ) ; } return camelTemplate ; } public void setCamelTemplate ( ProducerTemplate < Exchange > template ) { camelTemplate = template ; } public void setCamelContext ( CamelContext context ) { camelContext = context ; } public CamelContext getCamelContext ( ) { if ( camelContext == null ) { getLogger ( ) . log ( Level . INFO , "No CamelContext injected, create a default one" ) ; camelContext = new DefaultCamelContext ( ) ; } return camelContext ; } protected void incoming ( org . apache . camel . Exchange camelExchange ) { getLogger ( ) . log ( Level . FINE , "server received request: " , camelExchange ) ; org . apache . cxf . message . Message inMessage = CxfSoapBinding . getCxfInMessage ( headerFilterStrategy , camelExchange , false ) ; inMessage . put ( CxfConstants . CAMEL_EXCHANGE , camelExchange ) ; ( ( MessageImpl ) inMessage ) . setDestination ( this ) ; incomingObserver . onMessage ( inMessage ) ; } public String getBeanName ( ) { if ( endpointInfo == null || endpointInfo . getName ( ) == null ) { return "default" + BASE_BEAN_NAME_SUFFIX ; } return endpointInfo . getName ( ) . toString ( ) + BASE_BEAN_NAME_SUFFIX ; } private void initConfig ( ) { if ( bus != null ) { Configurer configurer = bus . getExtension ( Configurer . class ) ; if ( null != configurer ) { configurer . configureBean ( this ) ; } } } protected class ConsumerProcessor implements Processor { public void process ( Exchange exchange ) { try { incoming ( exchange ) ; } catch ( Throwable ex ) { getLogger ( ) . log ( Level . WARNING , "Failed to process incoming message : " , ex ) ; } } } protected class BackChannelConduit extends AbstractConduit { protected Message inMessage ; Exchange camelExchange ; org . apache . cxf . message . Exchange cxfExchange ; BackChannelConduit ( Message message ) { super ( EndpointReferenceUtils . getAnonymousEndpointReference ( ) ) ; inMessage = message ; cxfExchange = inMessage . getExchange ( ) ; camelExchange = cxfExchange . get ( Exchange . class ) ; } public void setMessageObserver ( MessageObserver observer ) { } public void prepare ( Message message ) throws IOException { message . put ( CxfConstants . CAMEL_EXCHANGE , inMessage . get ( CxfConstants . CAMEL_EXCHANGE ) ) ; message . setContent ( OutputStream . class , new CamelOutputStream ( message ) ) ; } protected Logger getLogger ( ) { return LOG ; } } protected boolean markPartialResponse ( Message partialResponse , EndpointReferenceType decoupledTarget ) { return true ; } protected ConduitInitiator getConduitInitiator ( ) { return conduitInitiator ; } private class CamelOutputStream extends CachedOutputStream { private Message outMessage ; public CamelOutputStream ( Message m ) { super ( ) ; outMessage = m ; } private void commitOutputMessage ( ) throws IOException { Exchange camelExchange = ( Exchange ) outMessage . get ( CxfConstants . CAMEL_EXCHANGE ) ; CxfHeaderHelper . propagateCxfToCamel ( headerFilterStrategy , outMessage , camelExchange . getOut ( ) . getHeaders ( ) ) ; CachedOutputStream outputStream = ( CachedOutputStream ) outMessage . getContent ( OutputStream . class ) ; camelExchange . getOut ( ) . setBody ( outputStream . getBytes ( ) ) ; getLogger ( ) . log ( Level . FINE , "send the response message: " + outputStream ) ; } @ Override protected void doFlush ( ) throws IOException { } @ Override protected void doClose ( ) throws IOException { commitOutputMessage ( ) ; } @ Override protected void onWrite ( ) throws IOException { } } } 	0	['19', '0', '0', '26', '48', '143', '4', '24', '10', '0.87037037', '252', '0.555555556', '5', '0', '0.161616162', '0', '0', '11.78947368', '3', '1.1579', '0']
package org . apache . camel . component . bean ; import java . io . Serializable ; import java . lang . reflect . Method ; public class MethodBean implements Serializable { private String name ; private Class < ? > type ; private Class < ? > [ ] parameterTypes ; public MethodBean ( ) { } public MethodBean ( Method method ) { this . name = method . getName ( ) ; this . type = method . getDeclaringClass ( ) ; this . parameterTypes = method . getParameterTypes ( ) ; } public Method getMethod ( ) throws NoSuchMethodException { return type . getMethod ( name , parameterTypes ) ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public Class < ? > [ ] getParameterTypes ( ) { return parameterTypes ; } public void setParameterTypes ( Class < ? > [ ] parameterTypes ) { this . parameterTypes = parameterTypes ; } public Class < ? > getType ( ) { return type ; } public void setType ( Class < ? > type ) { this . type = type ; } } 	0	['9', '1', '0', '1', '14', '4', '1', '0', '9', '0.625', '59', '1', '0', '0', '0.288888889', '0', '0', '5.222222222', '1', '0.7778', '0']
package org . apache . camel . component . file . strategy ; import java . io . File ; import java . io . RandomAccessFile ; import java . nio . channels . Channel ; import java . nio . channels . FileChannel ; import java . nio . channels . FileLock ; import org . apache . camel . component . file . FileEndpoint ; import org . apache . camel . component . file . FileExchange ; import org . apache . camel . component . file . FileProcessStrategy ; import org . apache . camel . util . ExchangeHelper ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public abstract class FileProcessStrategySupport implements FileProcessStrategy { private static final transient Log LOG = LogFactory . getLog ( FileProcessStrategySupport . class ) ; private boolean lockFile ; private FileRenamer lockFileRenamer ; protected FileProcessStrategySupport ( ) { this ( true ) ; } protected FileProcessStrategySupport ( boolean lockFile ) { this ( lockFile , new DefaultFileRenamer ( null , FileEndpoint . DEFAULT_LOCK_FILE_POSTFIX ) ) ; } protected FileProcessStrategySupport ( boolean lockFile , FileRenamer lockFileRenamer ) { this . lockFile = lockFile ; this . lockFileRenamer = lockFileRenamer ; } public boolean begin ( FileEndpoint endpoint , FileExchange exchange , File file ) throws Exception { if ( isLockFile ( ) ) { File newFile = lockFileRenamer . renameFile ( exchange , file ) ; String lockFileName = newFile . getAbsolutePath ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Locking the file: " + file + " using the lock file name: " + lockFileName ) ; } FileChannel channel = new RandomAccessFile ( lockFileName , "rw" ) . getChannel ( ) ; FileLock lock = channel . lock ( ) ; if ( lock != null ) { exchange . setProperty ( "org.apache.camel.file.lock" , lock ) ; exchange . setProperty ( "org.apache.camel.file.lock.name" , lockFileName ) ; return true ; } else { return false ; } } return true ; } public void commit ( FileEndpoint endpoint , FileExchange exchange , File file ) throws Exception { unlockFile ( endpoint , exchange , file ) ; } public void rollback ( FileEndpoint endpoint , FileExchange exchange , File file ) { try { unlockFile ( endpoint , exchange , file ) ; } catch ( Exception e ) { LOG . warn ( "Unable to unlock file: " + file , e ) ; } } public boolean isLockFile ( ) { return lockFile ; } public void setLockFile ( boolean lockFile ) { this . lockFile = lockFile ; } public FileRenamer getLockFileRenamer ( ) { return lockFileRenamer ; } public void setLockFileRenamer ( FileRenamer lockFileRenamer ) { this . lockFileRenamer = lockFileRenamer ; } protected void unlockFile ( FileEndpoint endpoint , FileExchange exchange , File file ) throws Exception { if ( isLockFile ( ) ) { FileLock lock = ExchangeHelper . getMandatoryProperty ( exchange , "org.apache.camel.file.lock" , FileLock . class ) ; String lockFileName = ExchangeHelper . getMandatoryProperty ( exchange , "org.apache.camel.file.lock.name" , String . class ) ; Channel channel = lock . channel ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Unlocking file: " + file ) ; } try { lock . release ( ) ; } finally { ObjectHelper . close ( channel , "Closing channel" , LOG ) ; if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Deleting lock file: " + lockFileName ) ; } File lockfile = new File ( lockFileName ) ; lockfile . delete ( ) ; } } } } 	0	['12', '1', '3', '13', '36', '36', '3', '10', '7', '0.606060606', '223', '1', '1', '0', '0.424242424', '0', '0', '17.33333333', '1', '0.6667', '0']
package org . apache . camel . builder . script ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import org . apache . camel . language . LanguageAnnotation ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . PARAMETER } ) @ LanguageAnnotation ( language = "php" ) public @ interface PHP { String value ( ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . jpa ; import java . util . Map ; import javax . persistence . EntityManager ; import javax . persistence . EntityManagerFactory ; import javax . persistence . Persistence ; import org . apache . camel . Consumer ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . NoTypeConversionAvailableException ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . builder . ExpressionBuilder ; import org . apache . camel . impl . DefaultExchange ; import org . apache . camel . impl . ScheduledPollEndpoint ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . camel . util . ObjectHelper ; import org . springframework . orm . jpa . JpaTemplate ; public class JpaEndpoint extends ScheduledPollEndpoint < Exchange > { private EntityManagerFactory entityManagerFactory ; private String persistenceUnit = "camel" ; private JpaTemplate template ; private Expression < Exchange > producerExpression ; private int maximumResults = - 1 ; private Class < ? > entityType ; private Map entityManagerProperties ; private boolean consumeDelete = true ; private boolean consumeLockEntity = true ; private boolean flushOnSend = true ; public JpaEndpoint ( String uri , JpaComponent component ) { super ( uri , component ) ; entityManagerFactory = component . getEntityManagerFactory ( ) ; } public JpaEndpoint ( String endpointUri , EntityManagerFactory entityManagerFactory ) { super ( endpointUri ) ; this . entityManagerFactory = entityManagerFactory ; } public JpaEndpoint ( String endpointUri ) { super ( endpointUri ) ; } public Producer < Exchange > createProducer ( ) throws Exception { validate ( ) ; return new JpaProducer ( this , getProducerExpression ( ) ) ; } public Consumer < Exchange > createConsumer ( Processor processor ) throws Exception { validate ( ) ; JpaConsumer consumer = new JpaConsumer ( this , processor ) ; configureConsumer ( consumer ) ; return consumer ; } @ Override public void configureProperties ( Map options ) { super . configureProperties ( options ) ; Map emProperties = IntrospectionSupport . extractProperties ( options , "emf." ) ; if ( emProperties != null ) { setEntityManagerProperties ( emProperties ) ; } } public boolean isSingleton ( ) { return false ; } public JpaTemplate getTemplate ( ) { if ( template == null ) { template = createTemplate ( ) ; } return template ; } public void setTemplate ( JpaTemplate template ) { this . template = template ; } public Expression < Exchange > getProducerExpression ( ) { if ( producerExpression == null ) { producerExpression = createProducerExpression ( ) ; } return producerExpression ; } public void setProducerExpression ( Expression < Exchange > producerExpression ) { this . producerExpression = producerExpression ; } public int getMaximumResults ( ) { return maximumResults ; } public void setMaximumResults ( int maximumResults ) { this . maximumResults = maximumResults ; } public Class < ? > getEntityType ( ) { return entityType ; } public void setEntityType ( Class < ? > entityType ) { this . entityType = entityType ; } public EntityManagerFactory getEntityManagerFactory ( ) { if ( entityManagerFactory == null ) { entityManagerFactory = createEntityManagerFactory ( ) ; } return entityManagerFactory ; } public void setEntityManagerFactory ( EntityManagerFactory entityManagerFactory ) { this . entityManagerFactory = entityManagerFactory ; } public Map getEntityManagerProperties ( ) { if ( entityManagerProperties == null ) { entityManagerProperties = System . getProperties ( ) ; } return entityManagerProperties ; } public void setEntityManagerProperties ( Map entityManagerProperties ) { this . entityManagerProperties = entityManagerProperties ; } public String getPersistenceUnit ( ) { return persistenceUnit ; } public void setPersistenceUnit ( String persistenceUnit ) { this . persistenceUnit = persistenceUnit ; } public boolean isConsumeDelete ( ) { return consumeDelete ; } public void setConsumeDelete ( boolean consumeDelete ) { this . consumeDelete = consumeDelete ; } public boolean isConsumeLockEntity ( ) { return consumeLockEntity ; } public void setConsumeLockEntity ( boolean consumeLockEntity ) { this . consumeLockEntity = consumeLockEntity ; } public boolean isFlushOnSend ( ) { return flushOnSend ; } public void setFlushOnSend ( boolean flushOnSend ) { this . flushOnSend = flushOnSend ; } protected void validate ( ) { ObjectHelper . notNull ( getEntityManagerFactory ( ) , "entityManagerFactory property" ) ; } protected JpaTemplate createTemplate ( ) { return new JpaTemplate ( getEntityManagerFactory ( ) ) ; } protected EntityManagerFactory createEntityManagerFactory ( ) { return Persistence . createEntityManagerFactory ( persistenceUnit , getEntityManagerProperties ( ) ) ; } protected EntityManager createEntityManager ( ) { return getEntityManagerFactory ( ) . createEntityManager ( ) ; } protected TransactionStrategy createTransactionStrategy ( ) { EntityManagerFactory emf = getEntityManagerFactory ( ) ; return JpaTemplateTransactionStrategy . newInstance ( emf , getTemplate ( ) ) ; } protected Expression < Exchange > createProducerExpression ( ) { final Class < ? > type = getEntityType ( ) ; if ( type == null ) { return ExpressionBuilder . bodyExpression ( ) ; } else { return new Expression < Exchange > ( ) { public Object evaluate ( Exchange exchange ) { Object answer = exchange . getIn ( ) . getBody ( type ) ; if ( answer == null ) { Object defaultValue = exchange . getIn ( ) . getBody ( ) ; if ( defaultValue != null ) { throw new NoTypeConversionAvailableException ( defaultValue , type ) ; } answer = exchange . getContext ( ) . getInjector ( ) . newInstance ( type ) ; } return answer ; } } ; } } } 	0	['33', '3', '0', '17', '49', '424', '5', '16', '27', '0.86875', '284', '1', '1', '0.482758621', '0.137741047', '0', '0', '7.303030303', '2', '1.0909', '0']
package org . apache . camel . view ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Set ; import org . apache . camel . CamelContext ; import org . apache . camel . model . ChoiceType ; import org . apache . camel . model . FromType ; import org . apache . camel . model . MulticastType ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . model . RouteType ; import org . apache . camel . model . ToType ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . util . CollectionStringBuffer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public abstract class GraphGeneratorSupport { private static final transient Log LOG = LogFactory . getLog ( RouteDotGenerator . class ) ; protected String dir ; protected int clusterCounter ; protected String extension ; private String imagePrefix = "http://activemq.apache.org/camel/images/eip/" ; private Map < Object , NodeData > nodeMap = new HashMap < Object , NodeData > ( ) ; private boolean makeParentDirs = true ; private Map < String , List < RouteType > > routeGroupMap ; protected GraphGeneratorSupport ( String dir , String extension ) { this . dir = dir ; this . extension = extension ; } public String getDir ( ) { return dir ; } public void setDir ( String dir ) { this . dir = dir ; } public void drawRoutes ( CamelContext context ) throws IOException { File parent = new File ( dir ) ; if ( makeParentDirs ) { parent . mkdirs ( ) ; } List < RouteType > routes = context . getRouteDefinitions ( ) ; routeGroupMap = createRouteGroupMap ( routes ) ; generateFile ( parent , "routes" + extension , routeGroupMap ) ; if ( routeGroupMap . size ( ) >= 1 ) { Set < Map . Entry < String , List < RouteType > > > entries = routeGroupMap . entrySet ( ) ; for ( Map . Entry < String , List < RouteType > > entry : entries ) { Map < String , List < RouteType > > map = new HashMap < String , List < RouteType > > ( ) ; String group = entry . getKey ( ) ; map . put ( group , entry . getValue ( ) ) ; generateFile ( parent , group + extension , map ) ; } } } private void generateFile ( File parent , String fileName , Map < String , List < RouteType > > map ) throws IOException { nodeMap . clear ( ) ; clusterCounter = 0 ; PrintWriter writer = new PrintWriter ( new FileWriter ( new File ( parent , fileName ) ) ) ; try { generateFile ( writer , map ) ; } finally { writer . close ( ) ; } } protected abstract void generateFile ( PrintWriter writer , Map < String , List < RouteType > > map ) ; protected boolean isMulticastNode ( ProcessorType node ) { return node instanceof MulticastType || node instanceof ChoiceType ; } protected String getLabel ( List < ExpressionType > expressions ) { CollectionStringBuffer buffer = new CollectionStringBuffer ( ) ; for ( ExpressionType expression : expressions ) { buffer . append ( getLabel ( expression ) ) ; } return buffer . toString ( ) ; } protected String getLabel ( ExpressionType expression ) { if ( expression != null ) { return expression . getLabel ( ) ; } return "" ; } protected NodeData getNodeData ( Object node ) { Object key = node ; if ( node instanceof FromType ) { FromType fromType = ( FromType ) node ; key = fromType . getUriOrRef ( ) ; } else if ( node instanceof ToType ) { ToType toType = ( ToType ) node ; key = toType . getUriOrRef ( ) ; } NodeData answer = nodeMap . get ( key ) ; if ( answer == null ) { String id = "node" + ( nodeMap . size ( ) + 1 ) ; answer = new NodeData ( id , node , imagePrefix ) ; nodeMap . put ( key , answer ) ; } return answer ; } protected Map < String , List < RouteType > > createRouteGroupMap ( List < RouteType > routes ) { Map < String , List < RouteType > > map = new HashMap < String , List < RouteType > > ( ) ; for ( RouteType route : routes ) { String group = route . getGroup ( ) ; if ( group == null ) { group = "Camel Routes" ; } List < RouteType > list = map . get ( group ) ; if ( list == null ) { list = new ArrayList < RouteType > ( ) ; map . put ( group , list ) ; } list . add ( route ) ; } return map ; } } 	0	['12', '1', '2', '14', '47', '48', '2', '12', '3', '0.886363636', '306', '1', '0', '0', '0.218181818', '0', '0', '23.83333333', '4', '1.6667', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . builder . ProcessorBuilder ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . spi . RouteContext ; import org . apache . camel . util . ObjectHelper ; @ XmlRootElement ( name = "setOutHeader" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class SetOutHeaderType extends ExpressionNode { @ XmlAttribute ( required = true ) private String headerName ; public SetOutHeaderType ( ) { } public SetOutHeaderType ( String headerName , ExpressionType expression ) { super ( expression ) ; setHeaderName ( headerName ) ; } public SetOutHeaderType ( String headerName , Expression expression ) { super ( expression ) ; setHeaderName ( headerName ) ; } @ Override public String toString ( ) { return "SetOutHeader[" + getHeaderName ( ) + ", " + getExpression ( ) + "]" ; } @ Override public String getShortName ( ) { return "setOutHeader" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { ObjectHelper . notNull ( getHeaderName ( ) , "headerName" ) ; Expression expr = getExpression ( ) . createExpression ( routeContext ) ; return ProcessorBuilder . setOutHeader ( getHeaderName ( ) , expr ) ; } public void setHeaderName ( String headerName ) { this . headerName = headerName ; } public String getHeaderName ( ) { return headerName ; } } 	0	['8', '4', '0', '8', '19', '26', '1', '7', '8', '0.285714286', '66', '1', '0', '0.973544974', '0.35', '2', '3', '7.125', '1', '0.625', '0']
package org . apache . camel . impl ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import org . apache . camel . Exchange ; import org . apache . camel . converter . IOConverter ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . util . ExchangeHelper ; public class StringDataFormat implements DataFormat { private String charset ; public StringDataFormat ( String charset ) { this . charset = charset ; } public void marshal ( Exchange exchange , Object graph , OutputStream stream ) throws IOException { String text = ExchangeHelper . convertToType ( exchange , String . class , graph ) ; byte [ ] bytes ; if ( charset != null ) { bytes = text . getBytes ( charset ) ; } else { bytes = text . getBytes ( ) ; } stream . write ( bytes ) ; } public Object unmarshal ( Exchange exchange , InputStream stream ) throws IOException , ClassNotFoundException { byte [ ] bytes = IOConverter . toBytes ( stream ) ; String answer ; if ( charset != null ) { answer = new String ( bytes , charset ) ; } else { answer = new String ( bytes ) ; } return answer ; } } 	0	['3', '1', '0', '5', '11', '0', '1', '4', '3', '0', '53', '1', '0', '0', '0.5', '0', '0', '16.33333333', '1', '0.6667', '0']
package org . apache . camel . processor . resequencer ; public interface TimeoutHandler { void timeout ( Timeout timeout ) ; } 	0	['1', '1', '0', '2', '1', '0', '2', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . TYPE , ElementType . METHOD } ) @ Pattern ( ExchangePattern . InOnly ) public @ interface InOnly { } 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . builder . xml ; public class StreamResultHandlerFactory implements ResultHandlerFactory { public ResultHandler createResult ( ) { return new StreamResultHandler ( ) ; } } 	0	['2', '1', '0', '4', '4', '1', '1', '3', '2', '2', '9', '0', '0', '0', '1', '0', '0', '3.5', '1', '0.5', '0']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "jxpath" ) public class JXPathExpression extends ExpressionType { public JXPathExpression ( ) { } public JXPathExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "jxpath" ; } } 	0	['3', '2', '0', '1', '5', '3', '0', '1', '3', '2', '12', '0', '0', '0.956521739', '0.666666667', '1', '2', '3', '1', '0.3333', '0']
package org . apache . camel . builder . xml ; public interface ResultHandlerFactory { ResultHandler createResult ( ) ; } 	0	['1', '1', '0', '5', '1', '0', '4', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . jms ; import javax . jms . Destination ; import javax . jms . JMSException ; import javax . jms . Message ; import javax . jms . MessageListener ; import javax . jms . Session ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeCamelException ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . jms . core . JmsOperations ; import org . springframework . jms . core . MessageCreator ; import static org . apache . camel . util . ObjectHelper . wrapRuntimeCamelException ; public class EndpointMessageListener implements MessageListener { private static final transient Log LOG = LogFactory . getLog ( EndpointMessageListener . class ) ; private JmsEndpoint endpoint ; private Processor processor ; private JmsBinding binding ; private boolean eagerLoadingOfProperties ; private Destination replyToDestination ; private JmsOperations template ; private boolean disableReplyTo ; public EndpointMessageListener ( JmsEndpoint endpoint , Processor processor ) { this . endpoint = endpoint ; this . processor = processor ; endpoint . getConfiguration ( ) . configure ( this ) ; } public void onMessage ( final Message message ) { RuntimeCamelException rce = null ; try { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( endpoint + " consumer receiving JMS message: " + message ) ; } Destination replyDestination = getReplyToDestination ( message ) ; final JmsExchange exchange = createExchange ( message , replyDestination ) ; if ( eagerLoadingOfProperties ) { exchange . getIn ( ) . getHeaders ( ) ; } processor . process ( exchange ) ; JmsMessage body = null ; if ( exchange . isFailed ( ) ) { if ( exchange . getException ( ) != null ) { rce = wrapRuntimeCamelException ( exchange . getException ( ) ) ; } else if ( exchange . getFault ( ) . getBody ( ) != null ) { body = exchange . getFault ( ) ; } } else { body = exchange . getOut ( false ) ; } if ( rce == null && body != null && ! disableReplyTo ) { sendReply ( replyDestination , message , exchange , body ) ; } } catch ( Exception e ) { rce = wrapRuntimeCamelException ( e ) ; } if ( rce != null ) { LOG . warn ( endpoint + " consumer caught an exception while processing " + "JMS message: " + message , rce ) ; throw rce ; } } public JmsExchange createExchange ( Message message , Destination replyDestination ) { JmsExchange exchange = new JmsExchange ( endpoint . getCamelContext ( ) , endpoint . getExchangePattern ( ) , getBinding ( ) , message ) ; if ( replyDestination != null && ! disableReplyTo ) { exchange . setProperty ( "org.apache.camel.jms.replyDestination" , replyDestination ) ; exchange . setPattern ( ExchangePattern . InOut ) ; } return exchange ; } public JmsBinding getBinding ( ) { if ( binding == null ) { binding = new JmsBinding ( endpoint ) ; } return binding ; } public void setBinding ( JmsBinding binding ) { this . binding = binding ; } public boolean isEagerLoadingOfProperties ( ) { return eagerLoadingOfProperties ; } public void setEagerLoadingOfProperties ( boolean eagerLoadingOfProperties ) { this . eagerLoadingOfProperties = eagerLoadingOfProperties ; } public synchronized JmsOperations getTemplate ( ) { if ( template == null ) { template = endpoint . createInOnlyTemplate ( ) ; } return template ; } public void setTemplate ( JmsOperations template ) { this . template = template ; } public boolean isDisableReplyTo ( ) { return disableReplyTo ; } public void setDisableReplyTo ( boolean disableReplyTo ) { this . disableReplyTo = disableReplyTo ; } public Destination getReplyToDestination ( ) { return replyToDestination ; } public void setReplyToDestination ( Destination replyToDestination ) { this . replyToDestination = replyToDestination ; } protected void sendReply ( Destination replyDestination , final Message message , final JmsExchange exchange , final JmsMessage out ) { if ( replyDestination == null ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Cannot send reply message as there is no replyDestination for: " + out ) ; } return ; } getTemplate ( ) . send ( replyDestination , new MessageCreator ( ) { public Message createMessage ( Session session ) throws JMSException { Message reply = endpoint . getBinding ( ) . makeJmsMessage ( exchange , out , session ) ; if ( endpoint . getConfiguration ( ) . isUseMessageIDAsCorrelationID ( ) ) { String messageID = exchange . getIn ( ) . getHeader ( "JMSMessageID" , String . class ) ; reply . setJMSCorrelationID ( messageID ) ; } else { String correlationID = message . getJMSCorrelationID ( ) ; if ( correlationID != null ) { reply . setJMSCorrelationID ( correlationID ) ; } } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( endpoint + " sending reply JMS message: " + reply ) ; } return reply ; } } ) ; } protected Destination getReplyToDestination ( Message message ) throws JMSException { Destination destination = replyToDestination ; if ( destination == null ) { destination = message . getJMSReplyTo ( ) ; } return destination ; } } 	0	['18', '1', '0', '17', '48', '85', '3', '16', '13', '0.838235294', '268', '1', '3', '0', '0.165775401', '0', '0', '13.44444444', '7', '1.5556', '0']
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . Processor ; public class ThrowFaultProcessor implements Processor { private Throwable fault ; public ThrowFaultProcessor ( Throwable fault ) { this . fault = fault ; } public void process ( Exchange exchange ) throws Exception { Message message = exchange . getFault ( ) ; message . setBody ( fault ) ; } } 	0	['2', '1', '0', '4', '5', '0', '1', '3', '2', '0', '17', '1', '0', '0', '0.666666667', '0', '0', '7', '1', '0.5', '0']
package org . apache . camel . component . freemarker ; import java . io . StringWriter ; import java . util . Map ; import freemarker . template . Configuration ; import freemarker . template . Template ; import org . apache . camel . Component ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Message ; import org . apache . camel . component . ResourceBasedEndpoint ; import org . apache . camel . util . ExchangeHelper ; import org . apache . camel . util . ObjectHelper ; public class FreemarkerEndpoint extends ResourceBasedEndpoint { private String encoding ; private Configuration configuration ; public FreemarkerEndpoint ( String uri , Component component , String resourceUri , Map parameters ) { super ( uri , component , resourceUri , null ) ; } @ Override public boolean isSingleton ( ) { return true ; } @ Override public ExchangePattern getExchangePattern ( ) { return ExchangePattern . InOut ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String getEncoding ( ) { return encoding ; } public Configuration getConfiguration ( ) { return configuration ; } public void setConfiguration ( Configuration configuration ) { this . configuration = configuration ; } @ Override @ SuppressWarnings ( "unchecked" ) protected void onExchange ( Exchange exchange ) throws Exception { String path = getResourceUri ( ) ; ObjectHelper . notNull ( configuration , "configuration" ) ; ObjectHelper . notNull ( path , "resourceUri" ) ; Map variableMap = ExchangeHelper . createVariableMap ( exchange ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Freemarker is evaluating " + path + " using context: " + variableMap ) ; } Template template ; if ( encoding != null ) { template = configuration . getTemplate ( path , encoding ) ; } else { template = configuration . getTemplate ( path ) ; } StringWriter buffer = new StringWriter ( ) ; template . process ( variableMap , buffer ) ; buffer . flush ( ) ; Message out = exchange . getOut ( true ) ; out . setBody ( buffer . toString ( ) ) ; out . setHeader ( "org.apache.camel.freemarker.resource" , getResource ( ) ) ; out . setHeader ( "org.apache.camel.freemarker.resourceUri" , path ) ; Map < String , Object > headers = ( Map < String , Object > ) variableMap . get ( "headers" ) ; for ( String key : headers . keySet ( ) ) { out . setHeader ( key , headers . get ( key ) ) ; } } } 	0	['8', '6', '0', '13', '33', '16', '1', '12', '7', '0.714285714', '134', '1', '0', '0.857142857', '0.291666667', '0', '0', '15.5', '1', '0.875', '0']
package org . apache . camel . component . event ; import org . apache . camel . Exchange ; import org . springframework . context . ApplicationEvent ; public class CamelEvent extends ApplicationEvent { private final Exchange exchange ; public CamelEvent ( EventEndpoint source , Exchange exchange ) { super ( source ) ; this . exchange = exchange ; } @ Override public EventEndpoint getSource ( ) { return ( EventEndpoint ) super . getSource ( ) ; } public Exchange getExchange ( ) { return exchange ; } } 	0	['4', '0', '0', '3', '5', '4', '1', '3', '4', '0.666666667', '22', '1', '1', '0', '0.5', '0', '0', '4.25', '1', '0.75', '0']
package org . apache . camel . component . timer ; import java . util . Date ; import java . util . Timer ; import java . util . TimerTask ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class TimerConsumer extends DefaultConsumer < Exchange > { private static final transient Log LOG = LogFactory . getLog ( TimerConsumer . class ) ; private final TimerEndpoint endpoint ; private TimerTask task ; public TimerConsumer ( TimerEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; } @ Override protected void doStart ( ) throws Exception { task = new TimerTask ( ) { @ Override public void run ( ) { sendTimerExchange ( ) ; } } ; Timer timer = endpoint . getTimer ( ) ; configureTask ( task , timer ) ; } @ Override protected void doStop ( ) throws Exception { task . cancel ( ) ; } protected void configureTask ( TimerTask task , Timer timer ) { if ( endpoint . isFixedRate ( ) ) { if ( endpoint . getTime ( ) != null ) { timer . scheduleAtFixedRate ( task , endpoint . getTime ( ) , endpoint . getPeriod ( ) ) ; } else { timer . scheduleAtFixedRate ( task , endpoint . getDelay ( ) , endpoint . getPeriod ( ) ) ; } } else { if ( endpoint . getTime ( ) != null ) { if ( endpoint . getPeriod ( ) >= 0 ) { timer . schedule ( task , endpoint . getTime ( ) , endpoint . getPeriod ( ) ) ; } else { timer . schedule ( task , endpoint . getTime ( ) ) ; } } else { if ( endpoint . getPeriod ( ) >= 0 ) { timer . schedule ( task , endpoint . getDelay ( ) , endpoint . getPeriod ( ) ) ; } else { timer . schedule ( task , endpoint . getDelay ( ) ) ; } } } } protected void sendTimerExchange ( ) { Exchange exchange = endpoint . createExchange ( ) ; exchange . setProperty ( "org.apache.camel.timer.name" , endpoint . getTimerName ( ) ) ; exchange . setProperty ( "org.apache.camel.timer.time" , endpoint . getTime ( ) ) ; exchange . setProperty ( "org.apache.camel.timer.period" , endpoint . getPeriod ( ) ) ; Date now = new Date ( ) ; exchange . setProperty ( "org.apache.camel.timer.firedTime" , now ) ; exchange . getIn ( ) . setHeader ( "firedTime" , now ) ; try { getProcessor ( ) . process ( exchange ) ; } catch ( Exception e ) { LOG . error ( "Caught: " + e , e ) ; } } } 	0	['6', '3', '0', '9', '35', '0', '2', '9', '1', '0.666666667', '174', '1', '1', '0.851851852', '0.36', '1', '1', '27.5', '6', '1.5', '0']
package org . apache . camel . component . http ; import java . io . InputStream ; import org . apache . camel . CamelException ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . httpclient . Header ; import org . apache . commons . httpclient . StatusLine ; public class HttpOperationFailedException extends CamelException { private final String redirectLocation ; private final int statusCode ; private final StatusLine statusLine ; private final Header [ ] responseHeaders ; private final InputStream responseBody ; public HttpOperationFailedException ( int statusCode , StatusLine statusLine , String location , Header [ ] responseHeaders , InputStream responseBody ) { super ( "HTTP operation failed with statusCode: " + statusCode + ", status: " + statusLine + ( location != null ? ", redirectLocation: " + location : "" ) ) ; this . statusCode = statusCode ; this . statusLine = statusLine ; this . redirectLocation = location ; this . responseHeaders = responseHeaders ; this . responseBody = responseBody ; } public HttpOperationFailedException ( int statusCode , StatusLine statusLine , Header [ ] responseHeaders , InputStream responseBody ) { this ( statusCode , statusLine , null , responseHeaders , responseBody ) ; } public boolean isRedirectError ( ) { return statusCode >= 300 && statusCode < 400 ; } public boolean hasRedirectLocation ( ) { return ObjectHelper . isNotNullAndNonEmpty ( redirectLocation ) ; } public String getRedirectLocation ( ) { return redirectLocation ; } public StatusLine getStatusLine ( ) { return statusLine ; } public int getStatusCode ( ) { return statusCode ; } public Header [ ] getResponseHeaders ( ) { return responseHeaders ; } public InputStream getResponseBody ( ) { return responseBody ; } } 	0	['9', '4', '0', '5', '16', '18', '1', '4', '9', '0.7', '96', '1', '0', '0.708333333', '0.333333333', '0', '0', '9.111111111', '3', '1', '0']
package org . apache . camel . component . cxf . spring ; import org . springframework . beans . factory . xml . NamespaceHandlerSupport ; public class NamespaceHandler extends NamespaceHandlerSupport { public void init ( ) { registerBeanDefinitionParser ( "cxfEndpoint" , new CxfEndpointBeanDefinitionParser ( ) ) ; } } 	0	['2', '0', '0', '3', '5', '1', '0', '3', '2', '2', '12', '0', '0', '0', '1', '0', '0', '5', '1', '0.5', '0']
package org . apache . camel . model ; import java . util . HashMap ; import java . util . Map ; import java . util . concurrent . atomic . AtomicInteger ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlID ; import javax . xml . bind . annotation . XmlTransient ; import javax . xml . bind . annotation . XmlType ; import javax . xml . bind . annotation . adapters . CollapsedStringAdapter ; import javax . xml . bind . annotation . adapters . XmlJavaTypeAdapter ; @ XmlType ( name = "optionalIdentifiedType" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public abstract class OptionalIdentifiedType < T extends OptionalIdentifiedType > { @ XmlTransient protected static Map < String , AtomicInteger > nodeCounters = new HashMap < String , AtomicInteger > ( ) ; @ XmlAttribute ( required = false ) @ XmlJavaTypeAdapter ( CollapsedStringAdapter . class ) @ XmlID private String id ; @ XmlElement ( required = false ) private Description description ; public String getId ( ) { return id ; } public void setId ( String value ) { this . id = value ; } public Description getDescription ( ) { return description ; } public void setDescription ( Description description ) { this . description = description ; } public String getShortName ( ) { return "node" ; } public T describe ( String id , String text , String lang ) { if ( id != null ) { setId ( id ) ; } if ( text != null ) { if ( description == null ) { description = new Description ( ) ; } description . setText ( text ) ; } if ( lang != null ) { if ( description == null ) { description = new Description ( ) ; } description . setLang ( lang ) ; } return ( T ) this ; } public T description ( String text ) { if ( description == null ) { description = new Description ( ) ; } description . setText ( text ) ; return ( T ) this ; } public T description ( String text , String lang ) { description ( text ) ; description . setLang ( lang ) ; return ( T ) this ; } public T id ( String id ) { setId ( id ) ; return ( T ) this ; } public String idOrCreate ( ) { if ( id == null ) { setId ( createId ( ) ) ; } return getId ( ) ; } protected String createId ( ) { String key = getShortName ( ) ; return key + getNodeCounter ( key ) . incrementAndGet ( ) ; } protected static synchronized AtomicInteger getNodeCounter ( String key ) { AtomicInteger answer = nodeCounters . get ( key ) ; if ( answer == null ) { answer = new AtomicInteger ( 0 ) ; nodeCounters . put ( key , answer ) ; } return answer ; } } 	0	['14', '1', '3', '4', '27', '63', '3', '1', '11', '0.743589744', '148', '1', '1', '0', '0.487179487', '0', '0', '9.357142857', '6', '1.4286', '0']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "xpath" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class XPathExpression extends NamespaceAwareExpression { @ XmlAttribute ( required = false ) private Class resultType ; public XPathExpression ( ) { } public XPathExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "xpath" ; } public Class getResultType ( ) { return resultType ; } public void setResultType ( Class resultType ) { this . resultType = resultType ; } @ Override protected void configureExpression ( RouteContext routeContext , Expression expression ) { super . configureExpression ( routeContext , expression ) ; if ( resultType != null ) { setProperty ( expression , "resultType" , resultType ) ; } } @ Override protected void configurePredicate ( RouteContext routeContext , Predicate predicate ) { super . configurePredicate ( routeContext , predicate ) ; if ( resultType != null ) { setProperty ( predicate , "resultType" , resultType ) ; } } } 	0	['7', '3', '0', '6', '12', '9', '2', '4', '5', '0.5', '52', '1', '0', '0.84375', '0.30952381', '1', '4', '6.285714286', '2', '1', '0']
package org . apache . camel . language ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import org . apache . camel . component . bean . XPathAnnotationExpressionFactory ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . PARAMETER } ) @ LanguageAnnotation ( language = "xpath" , factory = XPathAnnotationExpressionFactory . class ) public @ interface XPath { String value ( ) ; NamespacePrefix [ ] namespaces ( ) default { @ NamespacePrefix ( prefix = "soap" , uri = "http://www.w3.org/2003/05/soap-envelope" ) , @ NamespacePrefix ( prefix = "xsd" , uri = "http://www.w3.org/2001/XMLSchema" ) } ; } 	0	['2', '1', '0', '2', '2', '1', '1', '1', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . bean ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . Method ; public interface MethodInvocation { Method getMethod ( ) ; Object [ ] getArguments ( ) ; Object proceed ( ) throws Exception ; Object getThis ( ) ; AccessibleObject getStaticPart ( ) ; } 	0	['5', '1', '0', '4', '5', '10', '4', '0', '5', '2', '5', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . impl ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import static org . apache . camel . util . ObjectHelper . notNull ; public abstract class BinaryPredicateSupport < E extends Exchange > implements Predicate < E > { private final Expression < E > left ; private final Expression < E > right ; protected BinaryPredicateSupport ( Expression < E > left , Expression < E > right ) { notNull ( left , "left" ) ; notNull ( right , "right" ) ; this . left = left ; this . right = right ; } @ Override public String toString ( ) { return left + " " + getOperationText ( ) + " " + right ; } public boolean matches ( E exchange ) { Object leftValue = left . evaluate ( exchange ) ; Object rightValue = right . evaluate ( exchange ) ; return matches ( exchange , leftValue , rightValue ) ; } public void assertMatches ( String text , E exchange ) { Object leftValue = left . evaluate ( exchange ) ; Object rightValue = right . evaluate ( exchange ) ; if ( ! matches ( exchange , leftValue , rightValue ) ) { throw new AssertionError ( text + assertionFailureMessage ( exchange , leftValue , rightValue ) ) ; } } protected abstract boolean matches ( E exchange , Object leftValue , Object rightValue ) ; protected abstract String getOperationText ( ) ; protected String assertionFailureMessage ( E exchange , Object leftValue , Object rightValue ) { return this + " failed on " + exchange + " with left value <" + leftValue + "> right value <" + rightValue + ">" ; } } 	0	['9', '1', '0', '4', '17', '24', '0', '4', '5', '0.375', '125', '1', '2', '0', '0.444444444', '0', '0', '12.66666667', '2', '1', '0']
package org . apache . camel . model . config ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Exchange ; import org . apache . camel . processor . StreamResequencer ; import org . apache . camel . processor . resequencer . DefaultExchangeComparator ; import org . apache . camel . processor . resequencer . ExpressionResultComparator ; @ XmlRootElement @ XmlAccessorType ( XmlAccessType . FIELD ) public class StreamResequencerConfig { @ XmlAttribute private Integer capacity ; @ XmlAttribute private Long timeout ; @ XmlTransient private ExpressionResultComparator < Exchange > comparator ; public StreamResequencerConfig ( ) { this ( 1000 , 1000L ) ; } public StreamResequencerConfig ( int capacity , long timeout ) { this ( capacity , timeout , new DefaultExchangeComparator ( ) ) ; } public StreamResequencerConfig ( int capacity , long timeout , ExpressionResultComparator < Exchange > comparator ) { this . capacity = capacity ; this . timeout = timeout ; this . comparator = comparator ; } public static StreamResequencerConfig getDefault ( ) { return new StreamResequencerConfig ( ) ; } public int getCapacity ( ) { return capacity ; } public void setCapacity ( int capacity ) { this . capacity = capacity ; } public long getTimeout ( ) { return timeout ; } public void setTimeout ( long timeout ) { this . timeout = timeout ; } public ExpressionResultComparator < Exchange > getComparator ( ) { return comparator ; } public void setComparator ( ExpressionResultComparator < Exchange > comparator ) { this . comparator = comparator ; } } 	0	['10', '1', '0', '3', '16', '27', '1', '2', '10', '0.666666667', '69', '1', '1', '0', '0.425', '0', '0', '5.6', '1', '0.7', '0']
package org . apache . camel . component . ibatis ; import java . io . IOException ; import java . sql . SQLException ; import java . util . List ; import com . ibatis . sqlmap . client . SqlMapClient ; import org . apache . camel . Message ; import org . apache . camel . PollingConsumer ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultPollingEndpoint ; public class IBatisEndpoint extends DefaultPollingEndpoint { private final String entityName ; public IBatisEndpoint ( String endpointUri , IBatisComponent component , String entityName ) { super ( endpointUri , component ) ; this . entityName = entityName ; } public IBatisEndpoint ( String endpointUri , String entityName ) { super ( endpointUri ) ; this . entityName = entityName ; } @ Override public IBatisComponent getComponent ( ) { return ( IBatisComponent ) super . getComponent ( ) ; } public boolean isSingleton ( ) { return true ; } public Producer createProducer ( ) throws Exception { return new IBatisProducer ( this ) ; } @ Override public PollingConsumer createPollingConsumer ( ) throws Exception { return new IBatisPollingConsumer ( this ) ; } public SqlMapClient getSqlClient ( ) throws IOException { return getComponent ( ) . getSqlMapClient ( ) ; } public String getEntityName ( ) { return entityName ; } public void query ( Message message ) throws IOException , SQLException { String name = getEntityName ( ) ; List list = getSqlClient ( ) . queryForList ( name ) ; message . setBody ( list ) ; message . setHeader ( "org.apache.camel.ibatis.queryName" , name ) ; } } 	0	['10', '4', '0', '9', '18', '39', '3', '9', '10', '0.666666667', '68', '1', '0', '0.783783784', '0.35', '1', '1', '5.7', '1', '0.8', '0']
package org . apache . camel . component . irc ; import java . net . URI ; import org . apache . camel . RuntimeCamelException ; public class IrcConfiguration implements Cloneable { private String target ; private String hostname ; private String password ; private String nickname ; private String realname ; private String username ; private boolean persistent = true ; private boolean colors = true ; private boolean onNick = true ; private boolean onQuit = true ; private boolean onJoin = true ; private boolean onKick = true ; private boolean onMode = true ; private boolean onPart = true ; private boolean onTopic = true ; private boolean onPrivmsg = true ; private int [ ] ports = { 6667 , 6668 , 6669 } ; public IrcConfiguration ( ) { } public IrcConfiguration ( String hostname , String nickname , String displayname , String target ) { this . target = target ; this . hostname = hostname ; this . nickname = nickname ; this . username = nickname ; this . realname = displayname ; } public IrcConfiguration ( String hostname , String username , String password , String nickname , String displayname , String target ) { this . target = target ; this . hostname = hostname ; this . username = username ; this . password = password ; this . nickname = nickname ; this . realname = displayname ; } public IrcConfiguration copy ( ) { try { return ( IrcConfiguration ) clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeCamelException ( e ) ; } } public String getCacheKey ( ) { return hostname + ":" + nickname ; } public void configure ( URI uri ) { setNickname ( uri . getUserInfo ( ) ) ; setUsername ( uri . getUserInfo ( ) ) ; setRealname ( uri . getUserInfo ( ) ) ; setHostname ( uri . getHost ( ) ) ; setTarget ( uri . getPath ( ) . substring ( 1 ) ) ; } public String getHostname ( ) { return hostname ; } public void setHostname ( String hostname ) { this . hostname = hostname ; } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public String getNickname ( ) { return nickname ; } public void setNickname ( String nickname ) { this . nickname = nickname ; } public String getRealname ( ) { return realname ; } public void setRealname ( String realname ) { this . realname = realname ; } public String getUsername ( ) { return username ; } public void setUsername ( String username ) { this . username = username ; } public int [ ] getPorts ( ) { return ports ; } public void setPorts ( int [ ] ports ) { this . ports = ports ; } public String getTarget ( ) { return target ; } public void setTarget ( String target ) { this . target = target ; } public boolean isPersistent ( ) { return persistent ; } public void setPersistent ( boolean persistent ) { this . persistent = persistent ; } public boolean isColors ( ) { return colors ; } public void setColors ( boolean colors ) { this . colors = colors ; } public boolean isOnNick ( ) { return onNick ; } public void setOnNick ( boolean onNick ) { this . onNick = onNick ; } public boolean isOnQuit ( ) { return onQuit ; } public void setOnQuit ( boolean onQuit ) { this . onQuit = onQuit ; } public boolean isOnJoin ( ) { return onJoin ; } public void setOnJoin ( boolean onJoin ) { this . onJoin = onJoin ; } public boolean isOnKick ( ) { return onKick ; } public void setOnKick ( boolean onKick ) { this . onKick = onKick ; } public boolean isOnMode ( ) { return onMode ; } public void setOnMode ( boolean onMode ) { this . onMode = onMode ; } public boolean isOnPart ( ) { return onPart ; } public void setOnPart ( boolean onPart ) { this . onPart = onPart ; } public boolean isOnTopic ( ) { return onTopic ; } public void setOnTopic ( boolean onTopic ) { this . onTopic = onTopic ; } public boolean isOnPrivmsg ( ) { return onPrivmsg ; } public void setOnPrivmsg ( boolean onPrivmsg ) { this . onPrivmsg = onPrivmsg ; } public String toString ( ) { return "IrcConfiguration{" + "target='" + target + '\'' + ", hostname='" + hostname + '\'' + ", password='" + password + '\'' + ", nickname='" + nickname + '\'' + ", realname='" + realname + '\'' + ", username='" + username + '\'' + ", persistent=" + persistent + ", colors=" + colors + ", onNick=" + onNick + ", onQuit=" + onQuit + ", onJoin=" + onJoin + ", onKick=" + onKick + ", onMode=" + onMode + ", onPart=" + onPart + ", onTopic=" + onTopic + ", onPrivmsg=" + onPrivmsg + ", ports=" + ports + '}' ; } } 	0	['41', '1', '0', '6', '54', '516', '5', '1', '41', '0.875', '507', '1', '0', '0', '0.297560976', '0', '0', '10.95121951', '1', '0.9268', '0']
package org . apache . camel . component . irc ; import java . util . Map ; import org . apache . camel . impl . DefaultMessage ; import org . schwering . irc . lib . IRCUser ; public class IrcMessage extends DefaultMessage { private String messageType ; private String target ; private IRCUser user ; private String whoWasKickedNick ; private String message ; public IrcMessage ( ) { } public IrcMessage ( String messageType , IRCUser user , String message ) { this . messageType = messageType ; this . user = user ; this . message = message ; } public IrcMessage ( String messageType , String target , IRCUser user , String message ) { this . messageType = messageType ; this . target = target ; this . user = user ; this . message = message ; } public IrcMessage ( String messageType , String target , IRCUser user , String whoWasKickedNick , String message ) { this . messageType = messageType ; this . target = target ; this . user = user ; this . whoWasKickedNick = whoWasKickedNick ; this . message = message ; } public IrcMessage ( String messageType , String target , IRCUser user ) { this . messageType = messageType ; this . target = target ; this . user = user ; } public String getMessageType ( ) { return messageType ; } public void setMessageType ( String messageType ) { this . messageType = messageType ; } public String getTarget ( ) { return target ; } public void setTarget ( String target ) { this . target = target ; } public IRCUser getUser ( ) { return user ; } public void setUser ( IRCUser user ) { this . user = user ; } public String getWhoWasKickedNick ( ) { return whoWasKickedNick ; } public void setWhoWasKickedNick ( String whoWasKickedNick ) { this . whoWasKickedNick = whoWasKickedNick ; } public String getMessage ( ) { return message ; } public void setMessage ( String message ) { this . message = message ; } @ Override public IrcExchange getExchange ( ) { return ( IrcExchange ) super . getExchange ( ) ; } @ Override protected Object createBody ( ) { IrcExchange ircExchange = getExchange ( ) ; IrcBinding binding = ircExchange . getBinding ( ) ; return binding . extractBodyFromIrc ( ircExchange , this ) ; } @ Override public IrcMessage newInstance ( ) { return new IrcMessage ( ) ; } @ Override protected void populateInitialHeaders ( Map < String , Object > map ) { map . put ( "irc.messageType" , messageType ) ; if ( target != null ) { map . put ( "irc.target" , target ) ; } if ( whoWasKickedNick != null ) { map . put ( "irc.user.kicked" , whoWasKickedNick ) ; } if ( user != null ) { map . put ( "irc.user.host" , user . getHost ( ) ) ; map . put ( "irc.user.nick" , user . getNick ( ) ) ; map . put ( "irc.user.servername" , user . getServername ( ) ) ; map . put ( "irc.user.username" , user . getUsername ( ) ) ; } } @ Override public String toString ( ) { if ( message != null ) { return "IrcMessage: " + message ; } else { return "IrcMessage: " + getBody ( ) ; } } } 	0	['23', '3', '0', '7', '34', '137', '3', '6', '21', '0.772727273', '230', '1', '0', '0.660377358', '0.402173913', '2', '6', '8.782608696', '4', '0.9565', '0']
package org . apache . camel . component . atom ; import java . io . IOException ; import java . util . Date ; import java . util . List ; import org . apache . abdera . model . Document ; import org . apache . abdera . model . Entry ; import org . apache . abdera . model . Feed ; import org . apache . abdera . parser . ParseException ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public class AtomEntryPollingConsumer extends AtomPollingConsumer { private Document < Feed > document ; private int entryIndex ; private EntryFilter entryFilter ; private List < Entry > list ; public AtomEntryPollingConsumer ( AtomEndpoint endpoint , Processor processor , boolean filter , Date lastUpdate ) { super ( endpoint , processor ) ; if ( filter ) { entryFilter = new UpdatedDateFilter ( lastUpdate ) ; } } public void poll ( ) throws Exception { getDocument ( ) ; Feed feed = document . getRoot ( ) ; while ( hasNextEntry ( ) ) { Entry entry = list . get ( entryIndex -- ) ; boolean valid = true ; if ( entryFilter != null ) { valid = entryFilter . isValidEntry ( endpoint , document , entry ) ; } if ( valid ) { Exchange exchange = endpoint . createExchange ( feed , entry ) ; getProcessor ( ) . process ( exchange ) ; return ; } } document = null ; } private Document < Feed > getDocument ( ) throws IOException , ParseException { if ( document == null ) { document = AtomUtils . parseDocument ( endpoint . getAtomUri ( ) ) ; list = document . getRoot ( ) . getEntries ( ) ; entryIndex = list . size ( ) - 1 ; } return document ; } private boolean hasNextEntry ( ) { return entryIndex >= 0 ; } } 	0	['4', '6', '0', '12', '16', '0', '1', '12', '2', '0.583333333', '109', '1', '1', '0.923076923', '0.4', '1', '1', '25.25', '2', '1', '0']
package org . apache . camel . component . file . remote ; import java . io . InputStream ; import com . jcraft . jsch . ChannelSftp ; import com . jcraft . jsch . JSchException ; import com . jcraft . jsch . Session ; import org . apache . camel . Exchange ; public class SftpProducer extends RemoteFileProducer < RemoteFileExchange > { private SftpEndpoint endpoint ; private ChannelSftp channel ; private Session session ; public SftpProducer ( SftpEndpoint endpoint , Session session ) { super ( endpoint ) ; this . endpoint = endpoint ; this . session = session ; } public void process ( Exchange exchange ) throws Exception { if ( log . isTraceEnabled ( ) ) { log . trace ( "Processing " + endpoint . getConfiguration ( ) ) ; } connectIfNecessary ( ) ; try { process ( endpoint . createExchange ( exchange ) ) ; } catch ( Exception e ) { if ( isStopping ( ) || isStopped ( ) ) { log . warn ( "Producer is stopping. Ignoring caught exception: " + e . getClass ( ) . getCanonicalName ( ) + " message: " + e . getMessage ( ) ) ; } else { log . warn ( "Exception occured during processing: " + e . getClass ( ) . getCanonicalName ( ) + " message: " + e . getMessage ( ) ) ; disconnect ( ) ; throw e ; } } } protected void connectIfNecessary ( ) throws JSchException { if ( channel == null || ! channel . isConnected ( ) ) { if ( session == null || ! session . isConnected ( ) ) { log . trace ( "Session isn't connected, trying to recreate and connect." ) ; session = endpoint . createSession ( ) ; session . connect ( ) ; } log . trace ( "Channel isn't connected, trying to recreate and connect." ) ; channel = endpoint . createChannelSftp ( session ) ; channel . connect ( ) ; log . info ( "Connected to " + endpoint . getConfiguration ( ) . remoteServerInformation ( ) ) ; } } protected void disconnect ( ) throws JSchException { if ( log . isDebugEnabled ( ) ) { log . debug ( "Disconnecting from " + remoteServer ( ) ) ; } if ( session != null ) { session . disconnect ( ) ; } if ( channel != null ) { channel . disconnect ( ) ; } } public void process ( RemoteFileExchange exchange ) throws Exception { InputStream payload = exchange . getIn ( ) . getBody ( InputStream . class ) ; try { String remoteServer = endpoint . getConfiguration ( ) . remoteServerInformation ( ) ; String fileName = createFileName ( exchange . getIn ( ) , endpoint . getConfiguration ( ) ) ; int lastPathIndex = fileName . lastIndexOf ( '/' ) ; if ( lastPathIndex != - 1 ) { String directory = fileName . substring ( 0 , lastPathIndex ) ; boolean success = SftpUtils . buildDirectory ( channel , directory ) ; if ( ! success ) { log . warn ( "Couldn't build directory: " + directory + " (could be because of denied permissions)" ) ; } } channel . put ( payload , fileName ) ; log . info ( "Sent: " + fileName + " to: " + remoteServer ) ; } finally { if ( payload != null ) { payload . close ( ) ; } } } } 	0	['5', '4', '0', '12', '41', '0', '1', '12', '3', '0.25', '262', '1', '1', '0.870967742', '0.36', '1', '1', '50.8', '1', '0.8', '0']
package org . apache . camel ; public interface Component < E extends Exchange > { CamelContext getCamelContext ( ) ; void setCamelContext ( CamelContext context ) ; Endpoint < E > createEndpoint ( String uri ) throws Exception ; } 	0	['3', '1', '0', '67', '3', '3', '66', '2', '3', '2', '3', '0', '0', '0', '0.555555556', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . mail ; import java . io . IOException ; import java . util . Map ; import javax . activation . DataHandler ; import javax . mail . Message ; import javax . mail . MessagingException ; import javax . mail . Multipart ; import javax . mail . Part ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . impl . DefaultMessage ; import org . apache . camel . util . CollectionHelper ; public class MailMessage extends DefaultMessage { private Message mailMessage ; public MailMessage ( ) { } public MailMessage ( Message message ) { this . mailMessage = message ; } @ Override public String toString ( ) { if ( mailMessage != null ) { return "MailMessage: " + MailUtils . dumpMessage ( mailMessage ) ; } else { return "MailMessage: " + getBody ( ) ; } } @ Override public MailExchange getExchange ( ) { return ( MailExchange ) super . getExchange ( ) ; } public MailMessage copy ( ) { MailMessage answer = ( MailMessage ) super . copy ( ) ; answer . mailMessage = mailMessage ; return answer ; } public Message getMessage ( ) { return mailMessage ; } public void setMessage ( Message mailMessage ) { this . mailMessage = mailMessage ; } @ Override public Object getHeader ( String name ) { Object answer = super . getHeader ( name ) ; if ( answer == null ) { answer = super . getHeader ( name . toLowerCase ( ) ) ; } return answer ; } @ Override public MailMessage newInstance ( ) { return new MailMessage ( ) ; } @ Override protected Object createBody ( ) { if ( mailMessage != null ) { return getExchange ( ) . getBinding ( ) . extractBodyFromMail ( getExchange ( ) , mailMessage ) ; } return null ; } @ Override protected void populateInitialHeaders ( Map < String , Object > map ) { if ( mailMessage != null ) { try { map . putAll ( getExchange ( ) . getBinding ( ) . extractHeadersFromMail ( mailMessage ) ) ; } catch ( MessagingException e ) { throw new RuntimeCamelException ( "Error accessing headers due to: " + e . getMessage ( ) , e ) ; } } } @ Override protected void populateInitialAttachments ( Map < String , DataHandler > map ) { if ( mailMessage != null ) { try { extractAttachments ( mailMessage , map ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( "Error populating the initial mail message attachments" , e ) ; } } } public void copyFrom ( org . apache . camel . Message that ) { super . copyFrom ( that ) ; if ( that instanceof MailMessage ) { MailMessage mailMessage = ( MailMessage ) that ; this . mailMessage = mailMessage . mailMessage ; } } protected static void extractAttachments ( Message message , Map < String , DataHandler > map ) throws javax . mail . MessagingException , IOException { Object content = message . getContent ( ) ; if ( content instanceof Multipart ) { Multipart mp = ( Multipart ) content ; for ( int i = 0 ; i < mp . getCount ( ) ; i ++ ) { Part part = mp . getBodyPart ( i ) ; String disposition = part . getDisposition ( ) ; if ( disposition != null ) { if ( disposition . equalsIgnoreCase ( Part . ATTACHMENT ) || disposition . equalsIgnoreCase ( Part . INLINE ) ) { if ( part . getFileName ( ) != null ) { CollectionHelper . appendValue ( map , part . getFileName ( ) , part . getDataHandler ( ) ) ; } } } } } } } 	0	['18', '3', '0', '8', '40', '81', '1', '8', '14', '0.470588235', '218', '1', '0', '0.68627451', '0.277777778', '2', '7', '11.05555556', '2', '1.2222', '0']
package org . apache . camel ; public class ExchangeTimedOutException extends CamelExchangeException { private final long timeout ; public ExchangeTimedOutException ( Exchange exchange , long timeout ) { super ( "The OUT message was not received within: " + timeout + " millis" , exchange ) ; this . timeout = timeout ; } public long getTimeout ( ) { return timeout ; } } 	0	['2', '5', '0', '4', '7', '0', '2', '2', '2', '0', '23', '1', '0', '0.95', '0.666666667', '0', '0', '10', '1', '0.5', '0']
package org . apache . camel . component . cxf . invoker ; import java . util . IdentityHashMap ; import java . util . List ; import java . util . Map ; import java . util . logging . Level ; import java . util . logging . Logger ; import org . w3c . dom . Element ; import org . apache . camel . Headers ; import org . apache . cxf . binding . soap . SoapHeader ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . headers . Header ; import org . apache . cxf . helpers . CastUtils ; import org . apache . cxf . message . Exchange ; import org . apache . cxf . message . Message ; public class PayloadInvokingContext extends AbstractInvokingContext { private static final Logger LOG = LogUtils . getL7dLogger ( PayloadInvokingContext . class ) ; public PayloadInvokingContext ( ) { } public void setRequestOutMessageContent ( Message message , Map < Class , Object > contents ) { PayloadMessage request = ( PayloadMessage ) contents . get ( PayloadMessage . class ) ; List < SoapHeader > headers = request . getHeaders ( ) ; List < Element > payload = request . getPayload ( ) ; if ( LOG . isLoggable ( Level . FINEST ) ) { LOG . finest ( "header = " + headers + ", paylaod = " + payload ) ; } message . put ( Header . HEADER_LIST , headers ) ; message . put ( List . class , payload ) ; } @ SuppressWarnings ( "unchecked" ) public Object getResponseObject ( Exchange exchange , Map < String , Object > responseContext ) { PayloadMessage payloadMsg = null ; Message msg = exchange . getInMessage ( ) ; List < Element > payload = getResponseObject ( msg , responseContext , List . class ) ; List < SoapHeader > header = CastUtils . cast ( ( List < ? > ) exchange . getInMessage ( ) . get ( Header . HEADER_LIST ) ) ; payloadMsg = new PayloadMessage ( payload , header ) ; if ( LOG . isLoggable ( Level . FINEST ) ) { LOG . finest ( payloadMsg . toString ( ) ) ; } return payloadMsg ; } @ Override protected < T > T getResponseObject ( Message inMessage , Map < String , Object > responseContext , Class < T > clazz ) { T retval = null ; if ( inMessage != null ) { if ( null != responseContext ) { responseContext . putAll ( inMessage ) ; LOG . info ( "set responseContext to be" + responseContext ) ; } retval = inMessage . get ( clazz ) ; } return retval ; } public void setResponseContent ( Message outMessage , Object resultPayload ) { if ( resultPayload != null ) { PayloadMessage payloadMessage = ( PayloadMessage ) resultPayload ; if ( LOG . isLoggable ( Level . FINEST ) ) { LOG . finest ( payloadMessage . toString ( ) ) ; } outMessage . put ( List . class , payloadMessage . getPayload ( ) ) ; outMessage . put ( Header . HEADER_LIST , payloadMessage . getHeaders ( ) ) ; } } @ SuppressWarnings ( "unchecked" ) public Map < Class , Object > getRequestContent ( Message inMessage ) { List < Element > payload = inMessage . get ( List . class ) ; List < SoapHeader > headers = CastUtils . cast ( ( List < ? > ) inMessage . get ( Header . HEADER_LIST ) ) ; if ( LOG . isLoggable ( Level . FINEST ) ) { LOG . finest ( "Header = " + headers + ", Payload = " + payload ) ; } Map < Class , Object > contents = new IdentityHashMap < Class , Object > ( ) ; contents . put ( PayloadMessage . class , new PayloadMessage ( payload , headers ) ) ; return contents ; } @ Override protected Logger getLogger ( ) { return LOG ; } } 	0	['8', '2', '0', '8', '31', '0', '1', '7', '5', '0.142857143', '187', '1', '0', '0.333333333', '0.404761905', '1', '2', '22.25', '3', '1.625', '0']
package org . apache . camel ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class Route < E extends Exchange > { public static final String ID_PROPERTY = "id" ; public static final String PARENT_PROPERTY = "parent" ; public static final String GROUP_PROPERTY = "group" ; private final Map < String , Object > properties = new HashMap < String , Object > ( 16 ) ; private Endpoint < E > endpoint ; private List < Service > services = new ArrayList < Service > ( ) ; public Route ( Endpoint < E > endpoint ) { this . endpoint = endpoint ; } public Route ( Endpoint < E > endpoint , Service ... services ) { this ( endpoint ) ; for ( Service service : services ) { addService ( service ) ; } } @ Override public String toString ( ) { return "Route" ; } public Endpoint < E > getEndpoint ( ) { return endpoint ; } public void setEndpoint ( Endpoint < E > endpoint ) { this . endpoint = endpoint ; } public Map < String , Object > getProperties ( ) { return properties ; } public List < Service > getServicesForRoute ( ) throws Exception { List < Service > servicesForRoute = new ArrayList < Service > ( getServices ( ) ) ; addServices ( servicesForRoute ) ; return servicesForRoute ; } public List < Service > getServices ( ) { return services ; } public void setServices ( List < Service > services ) { this . services = services ; } public void addService ( Service service ) { getServices ( ) . add ( service ) ; } protected void addServices ( List < Service > services ) throws Exception { } } 	0	['11', '1', '1', '10', '16', '41', '8', '2', '10', '0.883333333', '94', '0.5', '1', '0', '0.327272727', '0', '0', '7', '1', '0.8182', '0']
package org . apache . camel . bam . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . bam . model . ActivityState ; import org . apache . camel . bam . model . ProcessInstance ; import org . apache . camel . bam . rules . ActivityRules ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . orm . jpa . JpaTemplate ; import org . springframework . transaction . support . TransactionTemplate ; public class JpaBamProcessor extends JpaBamProcessorSupport < ProcessInstance > { private static final transient Log LOG = LogFactory . getLog ( JpaBamProcessor . class ) ; public JpaBamProcessor ( TransactionTemplate transactionTemplate , JpaTemplate template , Expression < Exchange > correlationKeyExpression , ActivityRules activityRules ) { super ( transactionTemplate , template , correlationKeyExpression , activityRules ) ; } public JpaBamProcessor ( TransactionTemplate transactionTemplate , JpaTemplate template , Expression < Exchange > correlationKeyExpression , ActivityRules activityRules , Class < ProcessInstance > entitytype ) { super ( transactionTemplate , template , correlationKeyExpression , activityRules , entitytype ) ; } protected void processEntity ( Exchange exchange , ProcessInstance process ) throws Exception { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Processing process instance: " + process ) ; } ActivityRules rules = getActivityRules ( ) ; ActivityState state = process . getOrCreateActivityState ( rules ) ; state . processExchange ( rules , new ProcessContext ( exchange , rules , state ) ) ; rules . getProcessRules ( ) . processExchange ( exchange , process ) ; } } 	0	['5', '3', '0', '13', '20', '8', '1', '12', '2', '0.5', '66', '1', '0', '0.931034483', '0.472222222', '0', '0', '12', '1', '0.4', '0']
package org . apache . camel . component . sql ; import java . util . Map ; import javax . sql . DataSource ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultComponent ; public class SqlComponent extends DefaultComponent < Exchange > { private DataSource dataSource ; public SqlComponent ( ) { } public SqlComponent ( CamelContext context ) { super ( context ) ; } @ Override protected Endpoint < Exchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { String dataSourceRef = getAndRemoveParameter ( parameters , "dataSourceRef" , String . class ) ; if ( dataSourceRef != null ) { dataSource = getCamelContext ( ) . getRegistry ( ) . lookup ( dataSourceRef , DataSource . class ) ; if ( dataSource == null ) { throw new IllegalArgumentException ( "DataSource " + dataSourceRef + " not found in registry" ) ; } } return new SqlEndpoint ( uri , remaining . replaceAll ( "#" , "?" ) , this , dataSource , parameters ) ; } public void setDataSource ( DataSource dataSource ) { this . dataSource = dataSource ; } } 	0	['4', '3', '0', '6', '16', '4', '0', '6', '3', '0.666666667', '64', '1', '0', '0.945945946', '0.4', '1', '3', '14.75', '1', '0.5', '0']
package org . apache . camel . util ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; public final class ExpressionHelper { private ExpressionHelper ( ) { } public static < E extends Exchange > String evaluateAsString ( Expression < E > expression , E exchange ) { return evaluateAsType ( expression , exchange , String . class ) ; } public static < T , E extends Exchange > T evaluateAsType ( Expression < E > expression , E exchange , Class < T > resultType ) { Object value = expression . evaluate ( exchange ) ; return exchange . getContext ( ) . getTypeConverter ( ) . convertTo ( resultType , exchange , value ) ; } } 	0	['3', '1', '0', '6', '8', '3', '2', '4', '2', '2', '24', '0', '0', '0', '0.5', '0', '0', '7', '1', '0.6667', '0']
package org . apache . camel ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . CONSTRUCTOR } ) public @ interface MessageDriven { String uri ( ) default "" ; String name ( ) default "" ; } 	0	['2', '1', '0', '1', '2', '1', '1', '0', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . bam . processor ; import org . apache . camel . CamelExchangeException ; import org . apache . camel . Exchange ; public class NoCorrelationKeyException extends CamelExchangeException { private final BamProcessorSupport processor ; public NoCorrelationKeyException ( BamProcessorSupport processor , Exchange exchange ) { super ( "No correlation key could be found for " + processor . getCorrelationKeyExpression ( ) , exchange ) ; this . processor = processor ; } public BamProcessorSupport getProcessor ( ) { return processor ; } } 	0	['2', '5', '0', '4', '8', '0', '1', '4', '2', '0', '22', '1', '1', '0.95', '0.666666667', '0', '0', '9.5', '1', '0.5', '0']
package org . apache . camel . component . file . remote ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . InputStream ; import org . apache . camel . Converter ; @ Converter public final class RemoteFileConverter { private RemoteFileConverter ( ) { } @ Converter public static byte [ ] toByteArray ( ByteArrayOutputStream os ) { return os . toByteArray ( ) ; } @ Converter public static String toString ( ByteArrayOutputStream os ) { return os . toString ( ) ; } @ Converter public static InputStream toInputStream ( ByteArrayOutputStream os ) { return new ByteArrayInputStream ( os . toByteArray ( ) ) ; } } 	0	['4', '1', '0', '0', '8', '6', '0', '0', '3', '2', '19', '0', '0', '0', '0.5', '0', '0', '3.75', '1', '0.75', '0']
package org . apache . camel . component . hl7 ; import java . nio . charset . Charset ; import java . nio . charset . CharsetDecoder ; import java . nio . charset . CharsetEncoder ; import ca . uhn . hl7v2 . model . Message ; import org . apache . camel . dataformat . hl7 . HL7Converter ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . mina . common . ByteBuffer ; import org . apache . mina . common . IoSession ; import org . apache . mina . filter . codec . ProtocolCodecFactory ; import org . apache . mina . filter . codec . ProtocolDecoder ; import org . apache . mina . filter . codec . ProtocolDecoderOutput ; import org . apache . mina . filter . codec . ProtocolEncoder ; import org . apache . mina . filter . codec . ProtocolEncoderOutput ; public class HL7MLLPCodec implements ProtocolCodecFactory { private static final transient Log LOG = LogFactory . getLog ( HL7MLLPCodec . class ) ; private static final String CHARSET_ENCODER = HL7MLLPCodec . class . getName ( ) + ".charsetencoder" ; private static final String CHARSET_DECODER = HL7MLLPCodec . class . getName ( ) + ".charsetdecoder" ; private char startByte = 0x0b ; private char endByte1 = 0x1c ; private char endByte2 = 0x0d ; private Charset charset = Charset . defaultCharset ( ) ; private boolean convertLFtoCR = true ; public ProtocolEncoder getEncoder ( ) throws Exception { return new ProtocolEncoder ( ) { public void encode ( IoSession session , Object message , ProtocolEncoderOutput out ) throws Exception { if ( message == null ) { throw new IllegalArgumentException ( "Message to encode is null" ) ; } else if ( message instanceof Exception ) { throw ( Exception ) message ; } CharsetEncoder encoder = ( CharsetEncoder ) session . getAttribute ( CHARSET_ENCODER ) ; if ( encoder == null ) { encoder = charset . newEncoder ( ) ; session . setAttribute ( CHARSET_ENCODER , encoder ) ; } String body ; if ( message instanceof Message ) { body = HL7Converter . toString ( ( Message ) message ) ; } else if ( message instanceof String ) { body = ( String ) message ; } else if ( message instanceof byte [ ] ) { body = new String ( ( byte [ ] ) message ) ; } else { throw new IllegalArgumentException ( "The message to encode is not a supported type: " + message . getClass ( ) . getCanonicalName ( ) ) ; } if ( convertLFtoCR ) { body = body . replace ( '\n' , '\r' ) ; } ByteBuffer bb = ByteBuffer . allocate ( body . length ( ) + 3 ) . setAutoExpand ( true ) ; bb . put ( ( byte ) startByte ) ; bb . putString ( body , encoder ) ; bb . put ( ( byte ) endByte1 ) ; bb . put ( ( byte ) endByte2 ) ; bb . flip ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Encoding HL7 from " + message . getClass ( ) . getCanonicalName ( ) + " to byte stream" ) ; } out . write ( bb ) ; } public void dispose ( IoSession session ) throws Exception { session . removeAttribute ( CHARSET_ENCODER ) ; } } ; } public ProtocolDecoder getDecoder ( ) throws Exception { return new ProtocolDecoder ( ) { public void decode ( IoSession session , ByteBuffer in , ProtocolDecoderOutput out ) throws Exception { int posEnd = 0 ; int posStart = 0 ; while ( in . hasRemaining ( ) ) { byte b = in . get ( ) ; if ( b == startByte ) { posStart = in . position ( ) ; } if ( b == endByte1 ) { byte next = in . get ( ) ; if ( next == endByte2 ) { posEnd = in . position ( ) - 2 ; break ; } else { LOG . warn ( "The 2nd end byte " + endByte2 + " was not found, but was " + b ) ; } } } in . rewind ( ) ; in . skip ( posStart ) ; if ( posEnd > 0 ) { in . limit ( posEnd ) ; } try { CharsetDecoder decoder = ( CharsetDecoder ) session . getAttribute ( CHARSET_DECODER ) ; if ( decoder == null ) { decoder = charset . newDecoder ( ) ; session . setAttribute ( CHARSET_DECODER , decoder ) ; } String body = in . getString ( decoder ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Decoding HL7 from byte stream to String" ) ; } out . write ( body ) ; } finally { in . clear ( ) ; } } public void finishDecode ( IoSession session , ProtocolDecoderOutput out ) throws Exception { } public void dispose ( IoSession session ) throws Exception { session . removeAttribute ( CHARSET_DECODER ) ; } } ; } public Charset getCharset ( ) { return charset ; } public void setCharset ( Charset charset ) { this . charset = charset ; } public void setCharset ( String charsetName ) { this . charset = Charset . forName ( charsetName ) ; } public boolean isConvertLFtoCR ( ) { return convertLFtoCR ; } public void setConvertLFtoCR ( boolean convertLFtoCR ) { this . convertLFtoCR = convertLFtoCR ; } public char getStartByte ( ) { return startByte ; } public void setStartByte ( char startByte ) { this . startByte = startByte ; } public char getEndByte1 ( ) { return endByte1 ; } public void setEndByte1 ( char endByte1 ) { this . endByte1 = endByte1 ; } public char getEndByte2 ( ) { return endByte2 ; } public void setEndByte2 ( char endByte2 ) { this . endByte2 = endByte2 ; } } 	0	['23', '1', '0', '7', '33', '179', '2', '7', '14', '0.892045455', '144', '1', '0', '0', '0.189393939', '0', '0', '4.913043478', '1', '0.913', '0']
package org . apache . camel . converter . stream ; import java . io . IOException ; import org . apache . camel . processor . interceptor . StreamCachingInterceptor ; public interface StreamCache { void reset ( ) ; } 	0	['1', '1', '0', '8', '1', '0', '8', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Processor ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "finally" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class FinallyType extends OutputType < ProcessorType > implements Block { @ Override public String toString ( ) { return "Finally[" + getOutputs ( ) + "]" ; } @ Override public String getShortName ( ) { return "finally" ; } @ Override public String getLabel ( ) { return "" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { return routeContext . createProcessor ( this ) ; } } 	0	['5', '4', '0', '6', '12', '10', '1', '5', '5', '2', '28', '0', '0', '0.978142077', '0.6', '1', '1', '4.6', '1', '0.8', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . model . language . ExpressionType ; @ XmlRootElement ( name = "serviceActivation" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ServiceActivationType { @ XmlAttribute private String group = "default" ; @ XmlElementRef private List < ExpressionType > uris = new ArrayList < ExpressionType > ( ) ; public String getGroup ( ) { return group ; } public void setGroup ( String group ) { this . group = group ; } public List < ExpressionType > getUris ( ) { return uris ; } public void setUris ( List < ExpressionType > uris ) { this . uris = uris ; } } 	0	['5', '1', '0', '0', '7', '0', '0', '0', '5', '0.5', '32', '1', '0', '0', '0.466666667', '0', '0', '5', '1', '0.8', '0']
package org . apache . camel . converter . jaxb ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAnyElement ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "exchange" ) @ XmlAccessorType ( value = XmlAccessType . FIELD ) public class ExchangeType { @ XmlElement ( name = "property" , required = false ) List < PropertyType > properties = new ArrayList < PropertyType > ( ) ; @ XmlAnyElement ( lax = true ) private Object body ; public Object getBody ( ) { return body ; } public void setBody ( Object body ) { this . body = body ; } public List < PropertyType > getProperties ( ) { return properties ; } public void setProperties ( List < PropertyType > properties ) { this . properties = properties ; } } 	0	['5', '1', '0', '0', '7', '2', '0', '0', '5', '0.625', '29', '0.5', '0', '0', '0.466666667', '0', '0', '4.4', '1', '0.8', '0']
package org . apache . camel . component . mail ; import javax . mail . Message ; import org . apache . camel . Consumer ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . ScheduledPollEndpoint ; import org . springframework . mail . javamail . JavaMailSender ; import org . springframework . mail . javamail . JavaMailSenderImpl ; public class MailEndpoint extends ScheduledPollEndpoint < MailExchange > { private MailBinding binding ; private MailConfiguration configuration ; public MailEndpoint ( String uri , MailComponent component , MailConfiguration configuration ) { super ( uri , component ) ; this . configuration = configuration ; this . binding = new MailBinding ( component . getHeaderFilterStrategy ( ) ) ; } public MailEndpoint ( String endpointUri , MailConfiguration configuration ) { super ( endpointUri ) ; this . configuration = configuration ; } public MailEndpoint ( String endpointUri ) { this ( endpointUri , new MailConfiguration ( ) ) ; } public Producer < MailExchange > createProducer ( ) throws Exception { JavaMailSender sender = configuration . createJavaMailSender ( ) ; return createProducer ( sender ) ; } public Producer < MailExchange > createProducer ( JavaMailSender sender ) throws Exception { return new MailProducer ( this , sender ) ; } public Consumer < MailExchange > createConsumer ( Processor processor ) throws Exception { if ( configuration . getProtocol ( ) . startsWith ( "smtp" ) ) { throw new IllegalArgumentException ( "Protocol " + configuration . getProtocol ( ) + " can not be used for a MailConsumer. Please use another protocol such as pop3 or imap." ) ; } JavaMailSenderImpl sender = configuration . createJavaMailSender ( ) ; return createConsumer ( processor , sender ) ; } public Consumer < MailExchange > createConsumer ( Processor processor , JavaMailSenderImpl sender ) throws Exception { MailConsumer answer = new MailConsumer ( this , processor , sender ) ; answer . setDelay ( MailConsumer . DEFAULT_CONSUMER_DELAY ) ; configureConsumer ( answer ) ; return answer ; } @ Override public MailExchange createExchange ( ExchangePattern pattern ) { return new MailExchange ( getCamelContext ( ) , pattern , getBinding ( ) ) ; } public MailExchange createExchange ( Message message ) { return new MailExchange ( getCamelContext ( ) , getExchangePattern ( ) , getBinding ( ) , message ) ; } public MailBinding getBinding ( ) { if ( binding == null ) { binding = new MailBinding ( ) ; } return binding ; } public void setBinding ( MailBinding binding ) { this . binding = binding ; } public boolean isSingleton ( ) { return false ; } public MailConfiguration getConfiguration ( ) { return configuration ; } } 	0	['14', '3', '0', '18', '34', '65', '5', '17', '14', '0.615384615', '149', '1', '2', '0.717948718', '0.2', '0', '0', '9.5', '2', '0.8571', '0']
package org . apache . camel . spring . handler ; import org . w3c . dom . Attr ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . xml . AbstractSingleBeanDefinitionParser ; import org . springframework . core . Conventions ; import org . springframework . util . Assert ; import org . springframework . util . StringUtils ; public class BeanDefinitionParser extends AbstractSingleBeanDefinitionParser { private Class type ; protected BeanDefinitionParser ( ) { } public BeanDefinitionParser ( Class type ) { this . type = type ; } protected Class getBeanClass ( Element element ) { if ( type == null ) { type = loadType ( ) ; } return type ; } protected Class loadType ( ) { throw new IllegalArgumentException ( "No type specified!" ) ; } protected boolean isEligibleAttribute ( String attributeName ) { return attributeName != null && ! ID_ATTRIBUTE . equals ( attributeName ) && ! attributeName . equals ( "xmlns" ) && ! attributeName . startsWith ( "xmlns:" ) ; } protected final void doParse ( Element element , BeanDefinitionBuilder builder ) { NamedNodeMap attributes = element . getAttributes ( ) ; for ( int x = 0 ; x < attributes . getLength ( ) ; x ++ ) { Attr attribute = ( Attr ) attributes . item ( x ) ; String name = attribute . getLocalName ( ) ; String fullName = attribute . getName ( ) ; if ( ! fullName . startsWith ( "xmlns:" ) && ! fullName . equals ( "xmlns" ) && isEligibleAttribute ( name ) ) { String propertyName = extractPropertyName ( name ) ; Assert . state ( StringUtils . hasText ( propertyName ) , "Illegal property name returned from 'extractPropertyName(String)': cannot be null or empty." ) ; builder . addPropertyValue ( propertyName , attribute . getValue ( ) ) ; } } postProcess ( builder , element ) ; } protected String extractPropertyName ( String attributeName ) { return Conventions . attributeNameToPropertyName ( attributeName ) ; } protected void postProcess ( BeanDefinitionBuilder beanDefinition , Element element ) { } } 	0	['8', '0', '2', '8', '22', '26', '3', '5', '1', '0.857142857', '108', '1', '0', '0', '0.4', '0', '0', '12.375', '5', '1.875', '0']
package org . apache . camel . component . file . remote ; import java . io . IOException ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . commons . net . ftp . FTPClient ; public final class FtpUtils { private static final transient Log LOG = LogFactory . getLog ( FtpUtils . class ) ; private FtpUtils ( ) { } public static boolean connect ( FTPClient client , RemoteFileConfiguration config ) throws IOException { String host = config . getHost ( ) ; int port = config . getPort ( ) ; String username = config . getUsername ( ) ; if ( config . getFtpClientConfig ( ) != null ) { LOG . trace ( "Configuring FTPClient with config: " + config . getFtpClientConfig ( ) ) ; client . configure ( config . getFtpClientConfig ( ) ) ; } LOG . trace ( "Connecting to " + config ) ; client . connect ( host , port ) ; if ( config . isPassiveMode ( ) ) { LOG . trace ( "Using passive mode connections" ) ; client . enterLocalPassiveMode ( ) ; } boolean login ; if ( username != null ) { LOG . trace ( "Attempting to login user: " + username ) ; login = client . login ( username , config . getPassword ( ) ) ; } else { LOG . trace ( "Attempting to login anonymous" ) ; login = client . login ( "anonymous" , null ) ; } if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "User " + ( username != null ? username : "anonymous" ) + " logged in: " + login ) ; } if ( ! login ) { return false ; } client . setFileType ( config . isBinary ( ) ? FTPClient . BINARY_FILE_TYPE : FTPClient . ASCII_FILE_TYPE ) ; return true ; } public static void disconnect ( FTPClient client ) throws IOException { if ( client . isConnected ( ) ) { client . disconnect ( ) ; } } public static FTPClient createNewFtpClient ( ) { return new FTPClient ( ) ; } public static boolean buildDirectory ( FTPClient ftpClient , String dirName ) throws IOException { String originalDirectory = ftpClient . printWorkingDirectory ( ) ; boolean success = false ; try { success = ftpClient . changeWorkingDirectory ( dirName ) ; if ( ! success ) { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Trying to build remote directory: " + dirName ) ; } success = ftpClient . makeDirectory ( dirName ) ; if ( ! success ) { buildDirectoryChunks ( ftpClient , dirName ) ; } } } finally { ftpClient . changeWorkingDirectory ( originalDirectory ) ; } return success ; } public static boolean buildDirectoryChunks ( FTPClient ftpClient , String dirName ) throws IOException { final StringBuilder sb = new StringBuilder ( dirName . length ( ) ) ; final String [ ] dirs = dirName . split ( "\\/" ) ; boolean success = false ; for ( String dir : dirs ) { sb . append ( dir ) . append ( '/' ) ; String directory = sb . toString ( ) ; if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Trying to build remote directory: " + directory ) ; } success = ftpClient . makeDirectory ( directory ) ; } return success ; } } 	0	['7', '1', '0', '8', '38', '9', '3', '5', '5', '0.5', '241', '1', '0', '0', '0.333333333', '0', '0', '33.28571429', '1', '0.7143', '0']
package org . apache . camel . component . cxf ; import org . apache . camel . impl . DefaultHeaderFilterStrategy ; public class CxfHeaderFilterStrategy extends DefaultHeaderFilterStrategy { public CxfHeaderFilterStrategy ( ) { initialize ( ) ; } protected void initialize ( ) { getOutFilter ( ) . add ( CxfConstants . OPERATION_NAME ) ; getOutFilter ( ) . add ( CxfConstants . OPERATION_NAMESPACE ) ; } } 	0	['2', '2', '0', '6', '5', '1', '5', '1', '1', '2', '18', '0', '0', '0.941176471', '1', '0', '0', '8', '1', '0.5', '0']
package org . apache . camel . dataformat . xstream ; import java . io . InputStream ; import java . io . OutputStream ; import javax . xml . stream . XMLStreamException ; import com . thoughtworks . xstream . XStream ; import com . thoughtworks . xstream . io . HierarchicalStreamReader ; import com . thoughtworks . xstream . io . HierarchicalStreamWriter ; import org . apache . camel . Exchange ; import org . apache . camel . converter . jaxp . StaxConverter ; import org . apache . camel . spi . DataFormat ; public abstract class AbstractXStreamWrapper implements DataFormat { private XStream xstream ; private StaxConverter staxConverter ; public AbstractXStreamWrapper ( ) { } public AbstractXStreamWrapper ( XStream xstream ) { this . xstream = xstream ; } public XStream getXStream ( ) { if ( xstream == null ) { xstream = createXStream ( ) ; } return xstream ; } public void setXStream ( XStream xstream ) { this . xstream = xstream ; } protected XStream createXStream ( ) { return new XStream ( ) ; } public StaxConverter getStaxConverter ( ) { if ( staxConverter == null ) { staxConverter = new StaxConverter ( ) ; } return staxConverter ; } public void setStaxConverter ( StaxConverter staxConverter ) { this . staxConverter = staxConverter ; } public void marshal ( Exchange exchange , Object body , OutputStream stream ) throws Exception { HierarchicalStreamWriter writer = createHierarchicalStreamWriter ( exchange , body , stream ) ; try { getXStream ( ) . marshal ( body , writer ) ; } finally { writer . close ( ) ; } } public Object unmarshal ( Exchange exchange , InputStream stream ) throws Exception { HierarchicalStreamReader reader = createHierarchicalStreamReader ( exchange , stream ) ; try { return getXStream ( ) . unmarshal ( reader ) ; } finally { reader . close ( ) ; } } protected abstract HierarchicalStreamWriter createHierarchicalStreamWriter ( Exchange exchange , Object body , OutputStream stream ) throws XMLStreamException ; protected abstract HierarchicalStreamReader createHierarchicalStreamReader ( Exchange exchange , InputStream stream ) throws XMLStreamException ; } 	0	['11', '1', '2', '8', '18', '47', '2', '6', '8', '0.75', '94', '1', '1', '0', '0.311688312', '0', '0', '7.363636364', '2', '1', '0']
package org . apache . camel . component . stringtemplate ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; public class StringTemplateComponent extends DefaultComponent { protected Endpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { return new StringTemplateEndpoint ( uri , this , remaining , parameters ) ; } } 	0	['2', '3', '0', '3', '4', '1', '1', '3', '1', '2', '13', '0', '0', '0.972222222', '0.666666667', '1', '1', '5.5', '1', '0.5', '0']
package org . apache . camel . builder . xml ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; import javax . xml . namespace . NamespaceContext ; import javax . xml . xpath . XPathFactory ; import org . apache . camel . spi . NamespaceAware ; public class DefaultNamespaceContext implements NamespaceContext , NamespaceAware { private final Map < String , String > map ; private final NamespaceContext parent ; public DefaultNamespaceContext ( ) { this ( XPathFactory . newInstance ( ) ) ; } public DefaultNamespaceContext ( XPathFactory factory ) { this . parent = factory . newXPath ( ) . getNamespaceContext ( ) ; this . map = new HashMap < String , String > ( ) ; } public DefaultNamespaceContext ( NamespaceContext parent , Map < String , String > map ) { this . parent = parent ; this . map = map ; } public DefaultNamespaceContext add ( String prefix , String uri ) { map . put ( prefix , uri ) ; return this ; } public String getNamespaceURI ( String prefix ) { String answer = map . get ( prefix ) ; if ( answer == null && parent != null ) { return parent . getNamespaceURI ( prefix ) ; } return answer ; } public String getPrefix ( String namespaceURI ) { for ( Iterator iter = map . entrySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) iter . next ( ) ; if ( namespaceURI . equals ( entry . getValue ( ) ) ) { return ( String ) entry . getKey ( ) ; } } if ( parent != null ) { return parent . getPrefix ( namespaceURI ) ; } return null ; } public Iterator getPrefixes ( String namespaceURI ) { Set set = new HashSet ( ) ; for ( Iterator iter = map . entrySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) iter . next ( ) ; if ( namespaceURI . equals ( entry . getValue ( ) ) ) { set . add ( entry . getKey ( ) ) ; } } if ( parent != null ) { Iterator iter = parent . getPrefixes ( namespaceURI ) ; while ( iter . hasNext ( ) ) { set . add ( iter . next ( ) ) ; } } return set . iterator ( ) ; } public void setNamespaces ( Map < String , String > namespaces ) { map . putAll ( namespaces ) ; } } 	0	['8', '1', '0', '2', '28', '0', '1', '1', '8', '0.142857143', '146', '1', '0', '0', '0.4', '0', '0', '17', '4', '1.5', '0']
package org . apache . camel . processor . aggregate ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; public class PredicateAggregationCollection extends DefaultAggregationCollection { private Predicate aggregationCompletedPredicate ; private List < Exchange > collection = new ArrayList < Exchange > ( ) ; public PredicateAggregationCollection ( Expression < Exchange > correlationExpression , AggregationStrategy aggregationStrategy , Predicate aggregationCompletedPredicate ) { super ( correlationExpression , aggregationStrategy ) ; this . aggregationCompletedPredicate = aggregationCompletedPredicate ; } @ Override public void onAggregation ( Object correlationKey , Exchange newExchange ) { if ( aggregationCompletedPredicate . matches ( newExchange ) ) { super . getMap ( ) . remove ( correlationKey ) ; collection . add ( newExchange ) ; } } @ Override public Iterator < Exchange > iterator ( ) { return collection . iterator ( ) ; } @ Override public int size ( ) { return collection . size ( ) ; } @ Override public void clear ( ) { collection . clear ( ) ; super . clear ( ) ; } } 	0	['5', '3', '0', '6', '15', '0', '1', '5', '5', '0.375', '50', '1', '1', '0.862068966', '0.333333333', '2', '6', '8.6', '2', '1', '0']
package org . apache . camel . component . mina ; import java . nio . charset . Charset ; import org . apache . mina . filter . codec . ProtocolCodecFactory ; import org . apache . mina . filter . codec . ProtocolDecoder ; import org . apache . mina . filter . codec . ProtocolEncoder ; import org . apache . mina . filter . codec . textline . LineDelimiter ; import org . apache . mina . filter . codec . textline . TextLineDecoder ; import org . apache . mina . filter . codec . textline . TextLineEncoder ; public class TextLineCodecFactory implements ProtocolCodecFactory { private ProtocolEncoder encoder ; private ProtocolDecoder decoder ; public TextLineCodecFactory ( Charset charset , LineDelimiter delimiter ) { if ( delimiter . equals ( LineDelimiter . AUTO ) ) { encoder = new TextLineEncoder ( charset ) ; } else { encoder = new TextLineEncoder ( charset , delimiter ) ; } decoder = new TextLineDecoder ( charset , delimiter ) ; } public ProtocolEncoder getEncoder ( ) throws Exception { return encoder ; } public ProtocolDecoder getDecoder ( ) throws Exception { return decoder ; } } 	0	['3', '1', '0', '7', '8', '0', '1', '6', '3', '0.5', '39', '1', '0', '0', '0.555555556', '0', '0', '11.33333333', '1', '0.6667', '0']
package org . apache . camel . bam . rules ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . bam . ProcessBuilder ; import org . apache . camel . bam . model . ActivityDefinition ; import org . apache . camel . bam . model . ActivityState ; import org . apache . camel . bam . model . ProcessInstance ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ServiceHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class ActivityRules extends ServiceSupport { private static final transient Log LOG = LogFactory . getLog ( ActivityRules . class ) ; private int expectedMessages = 1 ; private ProcessRules processRules ; private List < TemporalRule > rules = new ArrayList < TemporalRule > ( ) ; private ActivityDefinition activityDefinition ; private String activityName ; private final org . apache . camel . bam . ProcessBuilder builder ; public ActivityRules ( ProcessBuilder builder ) { this . builder = builder ; this . processRules = builder . getProcessRules ( ) ; processRules . getActivities ( ) . add ( this ) ; } public void addRule ( TemporalRule rule ) { rules . add ( rule ) ; } public void processExpired ( ActivityState activityState ) throws Exception { for ( TemporalRule rule : rules ) { rule . processExpired ( activityState ) ; } } public void processExchange ( Exchange exchange , ProcessInstance process ) { for ( TemporalRule rule : rules ) { rule . processExchange ( exchange , process ) ; } } public ActivityDefinition getActivityDefinition ( ) { return builder . findOrCreateActivityDefinition ( activityName ) ; } public void setActivityDefinition ( ActivityDefinition activityDefinition ) { this . activityDefinition = activityDefinition ; } public int getExpectedMessages ( ) { return expectedMessages ; } public void setExpectedMessages ( int expectedMessages ) { this . expectedMessages = expectedMessages ; } public ProcessRules getProcessRules ( ) { return processRules ; } public void setActivityName ( String activityName ) { this . activityName = activityName ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( rules ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( rules ) ; } } 	0	['13', '2', '0', '16', '27', '36', '9', '11', '10', '0.880952381', '119', '1', '3', '0.56', '0.185185185', '1', '1', '7.615384615', '2', '0.9231', '0']
package org . apache . camel . component . cxf . util ; import java . lang . annotation . Annotation ; import java . net . URI ; import java . net . URL ; import java . util . logging . Logger ; import javax . jws . WebService ; import javax . xml . namespace . QName ; import javax . xml . ws . WebServiceProvider ; import org . apache . camel . CamelContext ; import org . apache . camel . CamelException ; import org . apache . camel . component . cxf . CxfConstants ; import org . apache . camel . component . cxf . CxfEndpoint ; import org . apache . camel . component . cxf . DataFormat ; import org . apache . camel . component . cxf . spring . CxfEndpointBean ; import org . apache . camel . util . ObjectHelper ; import org . apache . cxf . Bus ; import org . apache . cxf . common . classloader . ClassLoaderUtils ; import org . apache . cxf . common . i18n . Message ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . common . util . ClassHelper ; import org . apache . cxf . frontend . ClientProxyFactoryBean ; import org . apache . cxf . frontend . ServerFactoryBean ; import org . apache . cxf . jaxws . JaxWsProxyFactoryBean ; import org . apache . cxf . jaxws . JaxWsServerFactoryBean ; import org . apache . cxf . jaxws . support . JaxWsServiceFactoryBean ; import org . apache . cxf . service . Service ; import org . apache . cxf . service . factory . AbstractServiceFactoryBean ; import org . apache . cxf . service . factory . ReflectionServiceFactoryBean ; import org . apache . cxf . service . model . EndpointInfo ; import org . apache . cxf . wsdl11 . WSDLServiceFactory ; public final class CxfEndpointUtils { public static final String PROP_NAME_PORT = "port" ; public static final String PROP_NAME_SERVICE = "service" ; public static final String PROP_NAME_SERVICECLASS = "serviceClass" ; public static final String PROP_NAME_DATAFORMAT = "dataFormat" ; public static final String DATAFORMAT_POJO = "pojo" ; public static final String DATAFORMAT_MESSAGE = "message" ; public static final String DATAFORMAT_PAYLOAD = "payload" ; private static final Logger LOG = LogUtils . getL7dLogger ( CxfEndpointUtils . class ) ; private CxfEndpointUtils ( ) { } static QName getQName ( final String name ) { QName qName = null ; if ( name != null ) { try { qName = QName . valueOf ( name ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } return qName ; } public static Class getServiceClass ( CxfEndpoint cxfEndpoint ) throws ClassNotFoundException { Class < ? > answer = null ; if ( cxfEndpoint . isSpringContextEndpoint ( ) ) { answer = cxfEndpoint . getCxfEndpointBean ( ) . getServiceClass ( ) ; if ( answer != null ) { return answer ; } } if ( cxfEndpoint . getServiceClassInstance ( ) != null ) { Object bean = cxfEndpoint . getCamelContext ( ) . getRegistry ( ) . lookup ( cxfEndpoint . getServiceClassInstance ( ) ) ; if ( bean != null ) { answer = ClassHelper . getRealClass ( bean ) ; } else { throw new ClassNotFoundException ( "Can't find serviceClass instace with name" + cxfEndpoint . getServiceClassInstance ( ) + " from CamelContext registry." ) ; } } else { if ( ObjectHelper . isNotEmpty ( cxfEndpoint . getServiceClass ( ) ) ) { answer = ClassLoaderUtils . loadClass ( cxfEndpoint . getServiceClass ( ) , CxfEndpointUtils . class ) ; } else { throw new ClassNotFoundException ( "Can't find serviceClass from uri, please check the cxf endpoint configuration" ) ; } } return answer ; } public static QName getPortName ( final CxfEndpoint endpoint ) { if ( endpoint . getPortName ( ) != null ) { return getQName ( endpoint . getPortName ( ) ) ; } else { String portLocalName = getCxfEndpointPropertyValue ( endpoint , CxfConstants . PORT_LOCALNAME ) ; String portNamespace = getCxfEndpointPropertyValue ( endpoint , CxfConstants . PORT_NAMESPACE ) ; if ( portLocalName != null ) { return new QName ( portNamespace , portLocalName ) ; } else { return null ; } } } public static QName getServiceName ( final CxfEndpoint endpoint ) { if ( endpoint . getServiceName ( ) != null ) { return getQName ( endpoint . getServiceName ( ) ) ; } else { String serviceLocalName = getCxfEndpointPropertyValue ( endpoint , CxfConstants . SERVICE_LOCALNAME ) ; String serviceNamespace = getCxfEndpointPropertyValue ( endpoint , CxfConstants . SERVICE_NAMESPACE ) ; if ( serviceLocalName != null ) { return new QName ( serviceNamespace , serviceLocalName ) ; } else { return null ; } } } public static EndpointInfo getEndpointInfo ( final Service service , final CxfEndpoint endpoint ) { EndpointInfo endpointInfo = null ; final java . util . Collection < EndpointInfo > endpoints = service . getServiceInfos ( ) . get ( 0 ) . getEndpoints ( ) ; if ( endpoints . size ( ) == 1 ) { endpointInfo = endpoints . iterator ( ) . next ( ) ; } else { final String port = endpoint . getPortName ( ) ; if ( port != null ) { final QName endpointName = QName . valueOf ( port ) ; endpointInfo = service . getServiceInfos ( ) . get ( 0 ) . getEndpoint ( endpointName ) ; } } return endpointInfo ; } public static boolean hasWebServiceAnnotation ( Class < ? > cls ) { return hasAnnotation ( cls , WebService . class ) || hasAnnotation ( cls , WebServiceProvider . class ) ; } public static boolean hasAnnotation ( Class < ? > cls , Class < ? extends Annotation > annotation ) { if ( cls == null || cls == Object . class ) { return false ; } if ( null != cls . getAnnotation ( annotation ) ) { return true ; } for ( Class < ? > interfaceClass : cls . getInterfaces ( ) ) { if ( null != interfaceClass . getAnnotation ( annotation ) ) { return true ; } } return hasAnnotation ( cls . getSuperclass ( ) , annotation ) ; } public static ServerFactoryBean getServerFactoryBean ( Class < ? > cls ) throws CamelException { ServerFactoryBean serverFactory = null ; try { if ( cls == null ) { serverFactory = new ServerFactoryBean ( ) ; serverFactory . setServiceFactory ( new WSDLSoapServiceFactoryBean ( ) ) ; } else { boolean isJSR181SEnabled = CxfEndpointUtils . hasWebServiceAnnotation ( cls ) ; serverFactory = isJSR181SEnabled ? new JaxWsServerFactoryBean ( ) : new ServerFactoryBean ( ) ; } return serverFactory ; } catch ( Exception e ) { throw new CamelException ( e ) ; } } public static ClientProxyFactoryBean getClientFactoryBean ( Class < ? > cls ) throws CamelException { ClientProxyFactoryBean clientFactory = null ; try { if ( cls == null ) { clientFactory = new ClientProxyFactoryBean ( ) ; clientFactory . setServiceFactory ( new WSDLSoapServiceFactoryBean ( ) ) ; } else { boolean isJSR181SEnabled = CxfEndpointUtils . hasWebServiceAnnotation ( cls ) ; clientFactory = isJSR181SEnabled ? new JaxWsProxyFactoryBean ( ) : new ClientProxyFactoryBean ( ) ; } return clientFactory ; } catch ( Exception e ) { throw new CamelException ( e ) ; } } public static void checkEndpiontIntegration ( CxfEndpoint endpoint , Bus bus ) throws CamelException { String wsdlLocation = endpoint . getWsdlURL ( ) ; QName serviceQName = CxfEndpointUtils . getQName ( endpoint . getServiceName ( ) ) ; String serviceClassName = endpoint . getServiceClass ( ) ; DataFormat dataFormat = CxfEndpointUtils . getDataFormat ( endpoint ) ; URL wsdlUrl = null ; if ( wsdlLocation != null ) { try { wsdlUrl = UriUtils . getWsdlUrl ( new URI ( wsdlLocation ) ) ; } catch ( Exception e ) { throw new CamelException ( e ) ; } } if ( serviceQName == null ) { throw new CamelException ( new Message ( "SVC_QNAME_NOT_FOUND_X" , LOG , endpoint . getServiceName ( ) ) . toString ( ) ) ; } if ( serviceClassName == null && dataFormat == DataFormat . POJO ) { throw new CamelException ( new Message ( "SVC_CLASS_PROP_IS_REQUIRED_X" , LOG ) . toString ( ) ) ; } AbstractServiceFactoryBean serviceFactory = null ; try { if ( serviceClassName != null ) { Class < ? > cls = ClassLoaderUtils . loadClass ( serviceClassName , CxfEndpointUtils . class ) ; boolean isJSR181SEnabled = CxfEndpointUtils . hasWebServiceAnnotation ( cls ) ; serviceFactory = isJSR181SEnabled ? new JaxWsServiceFactoryBean ( ) : new ReflectionServiceFactoryBean ( ) ; serviceFactory . setBus ( bus ) ; if ( wsdlUrl != null ) { ( ( ReflectionServiceFactoryBean ) serviceFactory ) . setWsdlURL ( wsdlUrl ) ; } if ( serviceQName != null ) { ( ( ReflectionServiceFactoryBean ) serviceFactory ) . setServiceName ( serviceQName ) ; } ( ( ReflectionServiceFactoryBean ) serviceFactory ) . setServiceClass ( cls ) ; } else { if ( wsdlUrl == null ) { throw new CamelException ( new Message ( "SVC_WSDL_URL_IS_NULL_X" , LOG , wsdlLocation ) . toString ( ) ) ; } serviceFactory = new WSDLServiceFactory ( bus , wsdlUrl , serviceQName ) ; } } catch ( ClassNotFoundException cnfe ) { throw new CamelException ( new Message ( "CLASS_X_NOT_FOUND " , LOG , serviceClassName ) . toString ( ) , cnfe ) ; } catch ( Exception e ) { throw new CamelException ( e ) ; } } public static boolean getSetDefaultBus ( CxfEndpoint endpoint ) { Boolean isSetDefaultBus = null ; CxfEndpointBean cxfEndpointBean = endpoint . getCxfEndpointBean ( ) ; if ( cxfEndpointBean != null && cxfEndpointBean . getProperties ( ) != null ) { String value = ( String ) cxfEndpointBean . getProperties ( ) . get ( CxfConstants . SET_DEFAULT_BUS ) ; isSetDefaultBus = Boolean . valueOf ( value ) ; } if ( isSetDefaultBus != null && endpoint . isSetDefaultBus ( ) == null ) { return isSetDefaultBus . booleanValue ( ) ; } else if ( endpoint . isSetDefaultBus ( ) != null ) { return endpoint . isSetDefaultBus ( ) . booleanValue ( ) ; } else { return false ; } } public static String getCxfEndpointPropertyValue ( CxfEndpoint endpoint , String property ) { String result = null ; CxfEndpointBean cxfEndpointBean = endpoint . getCxfEndpointBean ( ) ; if ( cxfEndpointBean != null && cxfEndpointBean . getProperties ( ) != null ) { result = ( String ) cxfEndpointBean . getProperties ( ) . get ( property ) ; } return result ; } public static DataFormat getDataFormat ( CxfEndpoint endpoint ) throws CamelException { String dataFormatString = endpoint . getDataFormat ( ) ; if ( dataFormatString == null ) { dataFormatString = getCxfEndpointPropertyValue ( endpoint , CxfConstants . DATA_FORMAT ) ; } if ( dataFormatString == null ) { return DataFormat . POJO ; } DataFormat retval = DataFormat . asEnum ( dataFormatString ) ; if ( retval == DataFormat . UNKNOWN ) { throw new CamelException ( new Message ( "INVALID_MESSAGE_FORMAT_XXXX" , LOG , dataFormatString ) . toString ( ) ) ; } return retval ; } } 	0	['15', '1', '0', '29', '76', '99', '4', '25', '12', '1.044642857', '566', '0.125', '0', '0', '0.202380952', '0', '0', '36.2', '6', '2.2667', '0']
package org . apache . camel . component . event ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; public class EventConsumer extends DefaultConsumer < Exchange > { private EventEndpoint endpoint ; public EventConsumer ( EventEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; endpoint . consumerStarted ( this ) ; } @ Override protected void doStop ( ) throws Exception { endpoint . consumerStopped ( this ) ; super . doStop ( ) ; } } 	0	['3', '3', '0', '4', '8', '0', '1', '4', '1', '0', '26', '1', '1', '0.92', '0.555555556', '1', '1', '7.333333333', '1', '0.6667', '0']
package org . apache . camel . component . validator . jing ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . component . ResourceBasedComponent ; import org . apache . camel . impl . ProcessorEndpoint ; import org . springframework . core . io . Resource ; public class JingComponent extends ResourceBasedComponent { protected Endpoint < Exchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { JingValidator validator = new JingValidator ( ) ; Resource resource = resolveMandatoryResource ( remaining ) ; validator . setSchemaResource ( resource ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( this + " using schema resource: " + resource ) ; } configureValidator ( validator , uri , remaining , parameters ) ; return new ProcessorEndpoint ( uri , this , validator ) ; } protected void configureValidator ( JingValidator validator , String uri , String remaining , Map parameters ) throws Exception { setProperties ( validator , parameters ) ; } } 	0	['3', '4', '1', '9', '15', '3', '1', '8', '1', '2', '52', '0', '0', '0.95', '0.666666667', '2', '2', '16.33333333', '1', '0.6667', '0']
package org . apache . camel . processor . idempotent ; import java . util . HashMap ; import java . util . Map ; import org . apache . camel . util . LRUCache ; public class MemoryMessageIdRepository implements MessageIdRepository { private final Map cache ; public MemoryMessageIdRepository ( Map set ) { this . cache = set ; } public static MessageIdRepository memoryMessageIdRepository ( ) { return memoryMessageIdRepository ( new HashMap ( ) ) ; } public static MessageIdRepository memoryMessageIdRepository ( int cacheSize ) { return memoryMessageIdRepository ( new LRUCache ( cacheSize ) ) ; } public static MessageIdRepository memoryMessageIdRepository ( Map cache ) { return new MemoryMessageIdRepository ( cache ) ; } public boolean contains ( String messageId ) { synchronized ( cache ) { if ( cache . containsKey ( messageId ) ) { return true ; } else { cache . put ( messageId , messageId ) ; return false ; } } } } 	0	['5', '1', '0', '3', '10', '8', '1', '2', '5', '0.5', '57', '1', '0', '0', '0.3', '0', '0', '10.2', '2', '1', '0']
package org . apache . camel . component . velocity ; import java . io . InputStreamReader ; import java . io . Reader ; import java . io . StringWriter ; import java . util . Map ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Message ; import org . apache . camel . component . ResourceBasedEndpoint ; import org . apache . camel . util . ExchangeHelper ; import org . apache . velocity . VelocityContext ; import org . apache . velocity . app . Velocity ; import org . apache . velocity . app . VelocityEngine ; import org . apache . velocity . context . Context ; import org . apache . velocity . runtime . log . SimpleLog4JLogSystem ; import org . springframework . core . io . Resource ; public class VelocityEndpoint extends ResourceBasedEndpoint { private final VelocityComponent component ; private VelocityEngine velocityEngine ; private boolean loaderCache = true ; private String encoding ; public VelocityEndpoint ( String uri , VelocityComponent component , String resourceUri , Map parameters ) { super ( uri , component , resourceUri , null ) ; this . component = component ; } @ Override public boolean isSingleton ( ) { return true ; } @ Override public ExchangePattern getExchangePattern ( ) { return ExchangePattern . InOut ; } private VelocityEngine getVelocityEngine ( ) throws Exception { if ( velocityEngine == null ) { velocityEngine = component . getVelocityEngine ( ) ; velocityEngine . setProperty ( Velocity . FILE_RESOURCE_LOADER_CACHE , isLoaderCache ( ) ? Boolean . TRUE : Boolean . FALSE ) ; velocityEngine . setProperty ( Velocity . RUNTIME_LOG_LOGSYSTEM_CLASS , SimpleLog4JLogSystem . class . getName ( ) ) ; velocityEngine . setProperty ( "runtime.log.logsystem.log4j.category" , VelocityEndpoint . class . getName ( ) ) ; velocityEngine . init ( ) ; } return velocityEngine ; } public void setVelocityEngine ( VelocityEngine velocityEngine ) { this . velocityEngine = velocityEngine ; } public boolean isLoaderCache ( ) { return loaderCache ; } public void setLoaderCache ( boolean loaderCache ) { this . loaderCache = loaderCache ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String getEncoding ( ) { return encoding ; } @ SuppressWarnings ( "unchecked" ) @ Override protected void onExchange ( Exchange exchange ) throws Exception { Resource resource = getResource ( ) ; Reader reader = encoding != null ? new InputStreamReader ( getResourceAsInputStream ( ) , encoding ) : new InputStreamReader ( getResourceAsInputStream ( ) ) ; StringWriter buffer = new StringWriter ( ) ; String logTag = getClass ( ) . getName ( ) ; Map variableMap = ExchangeHelper . createVariableMap ( exchange ) ; Context velocityContext = new VelocityContext ( variableMap ) ; VelocityEngine engine = getVelocityEngine ( ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Velocity is evaluating using velocity context: " + variableMap ) ; } engine . evaluate ( velocityContext , buffer , logTag , reader ) ; Message out = exchange . getOut ( true ) ; out . setBody ( buffer . toString ( ) ) ; out . setHeader ( "org.apache.camel.velocity.resource" , resource ) ; Map < String , Object > headers = ( Map < String , Object > ) velocityContext . get ( "headers" ) ; for ( String key : headers . keySet ( ) ) { out . setHeader ( key , headers . get ( key ) ) ; } } } 	0	['10', '6', '0', '13', '40', '29', '1', '13', '8', '0.722222222', '182', '1', '1', '0.823529412', '0.242857143', '0', '0', '16.8', '1', '0.9', '0']
package org . apache . camel . dataformat . hl7 ; import java . io . InputStream ; import java . io . OutputStream ; import ca . uhn . hl7v2 . model . Message ; import ca . uhn . hl7v2 . util . Terser ; import org . apache . camel . Exchange ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . util . ExchangeHelper ; public class HL7DataFormat implements DataFormat { public void marshal ( Exchange exchange , Object body , OutputStream outputStream ) throws Exception { Message message = ExchangeHelper . convertToMandatoryType ( exchange , Message . class , body ) ; String encoded = HL7Converter . toString ( message ) ; outputStream . write ( encoded . getBytes ( ) ) ; } public Object unmarshal ( Exchange exchange , InputStream inputStream ) throws Exception { String body = ExchangeHelper . convertToMandatoryType ( exchange , String . class , inputStream ) ; Message message = HL7Converter . toMessage ( body ) ; Terser terser = new Terser ( message ) ; exchange . getOut ( ) . setHeader ( "hl7.msh.sendingApplication" , terser . get ( "MSH-3" ) ) ; exchange . getOut ( ) . setHeader ( "hl7.msh.sendingFacility" , terser . get ( "MSH-4" ) ) ; exchange . getOut ( ) . setHeader ( "hl7.msh.receivingApplication" , terser . get ( "MSH-5" ) ) ; exchange . getOut ( ) . setHeader ( "hl7.msh.receivingFacility" , terser . get ( "MSH-6" ) ) ; exchange . getOut ( ) . setHeader ( "hl7.msh.timestamp" , terser . get ( "MSH-7" ) ) ; exchange . getOut ( ) . setHeader ( "hl7.msh.security" , terser . get ( "MSH-8" ) ) ; exchange . getOut ( ) . setHeader ( "hl7.msh.messageType" , terser . get ( "MSH-9-1" ) ) ; exchange . getOut ( ) . setHeader ( "hl7.msh.triggerEvent" , terser . get ( "MSH-9-2" ) ) ; exchange . getOut ( ) . setHeader ( "hl7.msh.messageControl" , terser . get ( "MSH-10" ) ) ; exchange . getOut ( ) . setHeader ( "hl7.msh.processingId" , terser . get ( "MSH-11" ) ) ; exchange . getOut ( ) . setHeader ( "hl7.msh.versionId" , terser . get ( "MSH-12" ) ) ; return message ; } } 	0	['3', '1', '0', '7', '13', '3', '0', '7', '3', '2', '113', '0', '0', '0', '0.533333333', '0', '0', '36.66666667', '1', '0.6667', '0']
package org . apache . camel . component . xquery ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . spi . Language ; public class XQueryLanguage implements Language { public Predicate < Exchange > createPredicate ( String expression ) { return XQueryBuilder . xquery ( expression ) ; } public Expression < Exchange > createExpression ( String expression ) { return XQueryBuilder . xquery ( expression ) ; } } 	0	['3', '1', '0', '4', '5', '3', '0', '4', '3', '2', '12', '0', '0', '0', '0.833333333', '0', '0', '3', '1', '0.6667', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Processor ; import org . apache . camel . builder . ProcessorBuilder ; import org . apache . camel . spi . RouteContext ; import org . apache . camel . util . ObjectHelper ; @ XmlRootElement ( name = "removeHeader" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class RemoveHeaderType extends OutputType < ProcessorType > { @ XmlAttribute ( required = true ) private String headerName ; public RemoveHeaderType ( ) { } public RemoveHeaderType ( String headerName ) { setHeaderName ( headerName ) ; } @ Override public String toString ( ) { return "RemoveHeader[" + getHeaderName ( ) + "]" ; } @ Override public String getShortName ( ) { return "removeHeader" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { ObjectHelper . notNull ( getHeaderName ( ) , "headerName" ) ; return ProcessorBuilder . removeHeader ( getHeaderName ( ) ) ; } public void setHeaderName ( String headerName ) { this . headerName = headerName ; } public String getHeaderName ( ) { return headerName ; } } 	0	['7', '4', '0', '6', '13', '19', '1', '5', '7', '0.333333333', '46', '1', '0', '0.972826087', '0.476190476', '1', '2', '5.428571429', '1', '0.7143', '0']
package org . apache . camel . component . cxf ; import java . io . InputStream ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Set ; import javax . xml . ws . BindingProvider ; import javax . xml . ws . handler . MessageContext ; import javax . xml . ws . handler . MessageContext . Scope ; import org . apache . camel . NoTypeConversionAvailableException ; import org . apache . camel . component . cxf . util . CxfHeaderHelper ; import org . apache . camel . spi . HeaderFilterStrategy ; import org . apache . cxf . endpoint . Client ; import org . apache . cxf . helpers . CastUtils ; import org . apache . cxf . jaxws . context . WrappedMessageContext ; import org . apache . cxf . message . Message ; public final class CxfBinding { private CxfBinding ( ) { } public static Object extractBodyFromCxf ( CxfExchange exchange , Message message ) { return getBody ( message ) ; } protected static Object getBody ( Message message ) { Set < Class < ? > > contentFormats = message . getContentFormats ( ) ; if ( contentFormats != null ) { for ( Class < ? > contentFormat : contentFormats ) { Object answer = message . getContent ( contentFormat ) ; if ( answer != null ) { return answer ; } } } return null ; } public static Message createCxfMessage ( CxfExchange exchange ) { return CxfBinding . createCxfMessage ( new CxfHeaderFilterStrategy ( ) , exchange ) ; } public static Message createCxfMessage ( HeaderFilterStrategy strategy , CxfExchange exchange ) { Message answer = exchange . getInMessage ( ) ; CxfMessage in = exchange . getIn ( ) ; try { List body = in . getBody ( List . class ) ; answer . setContent ( List . class , body ) ; CxfHeaderHelper . propagateCamelToCxf ( strategy , in . getHeaders ( ) , answer ) ; } catch ( NoTypeConversionAvailableException ex ) { try { InputStream body = in . getBody ( InputStream . class ) ; answer . setContent ( InputStream . class , body ) ; } catch ( NoTypeConversionAvailableException ex2 ) { } } Map < String , Object > requestContext = CastUtils . cast ( ( Map ) answer . get ( Client . REQUEST_CONTEXT ) ) ; if ( requestContext == null ) { requestContext = new HashMap < String , Object > ( ) ; } if ( exchange . getExchange ( ) != null ) { requestContext . putAll ( exchange . getExchange ( ) ) ; } if ( exchange . getProperties ( ) != null ) { requestContext . putAll ( exchange . getProperties ( ) ) ; } answer . put ( Client . REQUEST_CONTEXT , requestContext ) ; return answer ; } public static void storeCxfResponse ( CxfExchange exchange , Message response ) { CxfBinding . storeCxfResponse ( new CxfHeaderFilterStrategy ( ) , exchange , response ) ; } public static void storeCxfResponse ( HeaderFilterStrategy strategy , CxfExchange exchange , Message response ) { CxfMessage out = exchange . getOut ( ) ; if ( response != null ) { CxfHeaderHelper . propagateCxfToCamel ( strategy , response , out . getHeaders ( ) ) ; out . setMessage ( response ) ; DataFormat dataFormat = ( DataFormat ) exchange . getProperty ( CxfExchange . DATA_FORMAT ) ; if ( dataFormat . equals ( DataFormat . MESSAGE ) ) { out . setBody ( response . getContent ( InputStream . class ) ) ; } if ( dataFormat . equals ( DataFormat . PAYLOAD ) ) { out . setBody ( response ) ; } } } public static void copyMessage ( org . apache . camel . Message camelMessage , org . apache . cxf . message . Message cxfMessage ) { CxfBinding . copyMessage ( new CxfHeaderFilterStrategy ( ) , camelMessage , cxfMessage ) ; } public static void copyMessage ( HeaderFilterStrategy strategy , org . apache . camel . Message camelMessage , org . apache . cxf . message . Message cxfMessage ) { CxfHeaderHelper . propagateCamelToCxf ( strategy , camelMessage . getHeaders ( ) , cxfMessage ) ; try { InputStream is = camelMessage . getBody ( InputStream . class ) ; if ( is != null ) { cxfMessage . setContent ( InputStream . class , is ) ; } } catch ( NoTypeConversionAvailableException ex ) { Object result = camelMessage . getBody ( ) ; if ( result instanceof InputStream ) { cxfMessage . setContent ( InputStream . class , result ) ; } else { cxfMessage . setContent ( result . getClass ( ) , result ) ; } } } public static void storeCXfResponseContext ( Message response , Map < String , Object > context ) { if ( context != null ) { MessageContext messageContext = new WrappedMessageContext ( context , null , Scope . HANDLER ) ; response . put ( Client . RESPONSE_CONTEXT , messageContext ) ; Object value = context . get ( Message . RESPONSE_CODE ) ; if ( value != null ) { response . put ( Message . RESPONSE_CODE , value ) ; } } } public static void storeCxfResponse ( CxfExchange exchange , Object response ) { CxfMessage out = exchange . getOut ( ) ; if ( response != null ) { out . setBody ( response ) ; } } public static void storeCxfFault ( CxfExchange exchange , Message message ) { CxfMessage fault = exchange . getFault ( ) ; if ( fault != null ) { fault . setBody ( getBody ( message ) ) ; } } public static Map < String , Object > propogateContext ( Message message , Map < String , Object > context ) { Map < String , Object > requestContext = CastUtils . cast ( ( Map ) message . get ( Client . REQUEST_CONTEXT ) ) ; Map < String , Object > responseContext = CastUtils . cast ( ( Map ) message . get ( Client . RESPONSE_CONTEXT ) ) ; if ( requestContext != null ) { Map < String , Object > realMap = new HashMap < String , Object > ( ) ; WrappedMessageContext ctx = new WrappedMessageContext ( realMap , null , Scope . APPLICATION ) ; ctx . putAll ( requestContext ) ; requestContext = realMap ; } if ( responseContext == null ) { responseContext = new HashMap < String , Object > ( ) ; } else { responseContext . clear ( ) ; } context . put ( Client . REQUEST_CONTEXT , requestContext ) ; context . put ( Client . RESPONSE_CONTEXT , responseContext ) ; return responseContext ; } } 	0	['13', '1', '0', '14', '49', '78', '3', '12', '11', '2', '297', '0', '0', '0', '0.274725275', '0', '0', '21.84615385', '4', '2.0769', '0']
package org . apache . camel ; public class NoSuchLanguageException extends RuntimeCamelException { private static final long serialVersionUID = - 8721487431101572630L ; private final String language ; public NoSuchLanguageException ( String language ) { super ( "No language could be found for: " + language ) ; this . language = language ; } public String getLanguage ( ) { return language ; } } 	0	['2', '5', '0', '2', '6', '0', '1', '1', '2', '1', '21', '1', '0', '0.944444444', '0.75', '0', '0', '8.5', '1', '0.5', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . builder . ExpressionClause ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . Aggregator ; import org . apache . camel . processor . aggregate . AggregationCollection ; import org . apache . camel . processor . aggregate . AggregationStrategy ; import org . apache . camel . processor . aggregate . UseLatestAggregationStrategy ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "aggregator" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class AggregatorType extends ExpressionNode { @ XmlTransient private AggregationStrategy aggregationStrategy ; @ XmlTransient private AggregationCollection aggregationCollection ; @ XmlAttribute ( required = false ) private Integer batchSize ; @ XmlAttribute ( required = false ) private Integer outBatchSize ; @ XmlAttribute ( required = false ) private Long batchTimeout ; @ XmlAttribute ( required = false ) private String strategyRef ; @ XmlAttribute ( required = false ) private String collectionRef ; @ XmlElement ( name = "completedPredicate" , required = false ) private ExpressionSubElementType completedPredicate ; public AggregatorType ( ) { } public AggregatorType ( Expression correlationExpression ) { super ( correlationExpression ) ; } public AggregatorType ( ExpressionType correlationExpression ) { super ( correlationExpression ) ; } public AggregatorType ( Expression correlationExpression , AggregationStrategy aggregationStrategy ) { super ( correlationExpression ) ; this . aggregationStrategy = aggregationStrategy ; } @ Override public String toString ( ) { return "Aggregator[" + getExpression ( ) + " -> " + getOutputs ( ) + "]" ; } @ Override public String getShortName ( ) { return "aggregator" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { return createAggregator ( routeContext ) ; } protected Aggregator createAggregator ( RouteContext routeContext ) throws Exception { final Processor processor = routeContext . createProcessor ( this ) ; final Aggregator aggregator ; if ( getAggregationCollection ( ) == null ) { setAggregationCollection ( createAggregationCollection ( routeContext ) ) ; } if ( aggregationCollection != null ) { if ( aggregationCollection . getCorrelationExpression ( ) == null ) { aggregationCollection . setCorrelationExpression ( getExpression ( ) ) ; } if ( aggregationCollection . getAggregationStrategy ( ) == null ) { AggregationStrategy strategy = createAggregationStrategy ( routeContext ) ; aggregationCollection . setAggregationStrategy ( strategy ) ; } aggregator = new Aggregator ( processor , aggregationCollection ) ; } else { AggregationStrategy strategy = createAggregationStrategy ( routeContext ) ; Expression aggregateExpression = getExpression ( ) . createExpression ( routeContext ) ; Predicate predicate = null ; if ( getCompletedPredicate ( ) != null ) { predicate = getCompletedPredicate ( ) . createPredicate ( routeContext ) ; } if ( predicate != null ) { aggregator = new Aggregator ( processor , aggregateExpression , strategy , predicate ) ; } else { aggregator = new Aggregator ( processor , aggregateExpression , strategy ) ; } } if ( batchSize != null ) { aggregator . setBatchSize ( batchSize ) ; } if ( batchTimeout != null ) { aggregator . setBatchTimeout ( batchTimeout ) ; } if ( outBatchSize != null ) { aggregator . setOutBatchSize ( outBatchSize ) ; } return aggregator ; } private AggregationStrategy createAggregationStrategy ( RouteContext routeContext ) { AggregationStrategy strategy = getAggregationStrategy ( ) ; if ( strategy == null && strategyRef != null ) { strategy = routeContext . lookup ( strategyRef , AggregationStrategy . class ) ; } if ( strategy == null ) { strategy = new UseLatestAggregationStrategy ( ) ; } return strategy ; } private AggregationCollection createAggregationCollection ( RouteContext routeContext ) { AggregationCollection collection = getAggregationCollection ( ) ; if ( collection == null && collectionRef != null ) { collection = routeContext . lookup ( collectionRef , AggregationCollection . class ) ; } return collection ; } public AggregationCollection getAggregationCollection ( ) { return aggregationCollection ; } public void setAggregationCollection ( AggregationCollection aggregationCollection ) { this . aggregationCollection = aggregationCollection ; } public AggregationStrategy getAggregationStrategy ( ) { return aggregationStrategy ; } public void setAggregationStrategy ( AggregationStrategy aggregationStrategy ) { this . aggregationStrategy = aggregationStrategy ; } public Integer getBatchSize ( ) { return batchSize ; } public void setBatchSize ( Integer batchSize ) { this . batchSize = batchSize ; } public Integer getOutBatchSize ( ) { return outBatchSize ; } public void setOutBatchSize ( Integer outBatchSize ) { this . outBatchSize = outBatchSize ; } public Long getBatchTimeout ( ) { return batchTimeout ; } public void setBatchTimeout ( Long batchTimeout ) { this . batchTimeout = batchTimeout ; } public String getStrategyRef ( ) { return strategyRef ; } public void setStrategyRef ( String strategyRef ) { this . strategyRef = strategyRef ; } public void setCompletedPredicate ( ExpressionSubElementType completedPredicate ) { this . completedPredicate = completedPredicate ; } public ExpressionSubElementType getCompletedPredicate ( ) { return completedPredicate ; } public AggregatorType batchSize ( int batchSize ) { setBatchSize ( batchSize ) ; return this ; } public AggregatorType outBatchSize ( int batchSize ) { setOutBatchSize ( batchSize ) ; return this ; } public AggregatorType batchTimeout ( long batchTimeout ) { setBatchTimeout ( batchTimeout ) ; return this ; } public AggregatorType aggregationCollection ( AggregationCollection aggregationCollection ) { setAggregationCollection ( aggregationCollection ) ; return this ; } public AggregatorType aggregationStrategy ( AggregationStrategy aggregationStrategy ) { setAggregationStrategy ( aggregationStrategy ) ; return this ; } public AggregatorType strategyRef ( String strategyRef ) { setStrategyRef ( strategyRef ) ; return this ; } public ExpressionClause < AggregatorType > completedPredicate ( ) { checkNoCompletedPredicate ( ) ; ExpressionClause < AggregatorType > clause = new ExpressionClause < AggregatorType > ( this ) ; setCompletedPredicate ( new ExpressionSubElementType ( ( Expression ) clause ) ) ; return clause ; } public AggregatorType completedPredicate ( Predicate predicate ) { checkNoCompletedPredicate ( ) ; setCompletedPredicate ( new ExpressionSubElementType ( predicate ) ) ; return this ; } protected void checkNoCompletedPredicate ( ) { if ( getCompletedPredicate ( ) != null ) { throw new IllegalArgumentException ( "There is already a completedPredicate defined for this aggregator: " + this ) ; } } } 	0	['33', '4', '0', '16', '65', '490', '4', '13', '29', '0.87890625', '352', '1', '3', '0.863849765', '0.128205128', '2', '3', '9.424242424', '4', '1.0606', '0']
package org . apache . camel . component . cxf ; import org . apache . camel . CamelContext ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; import org . apache . cxf . message . Exchange ; import org . apache . cxf . message . Message ; import org . apache . cxf . transport . Conduit ; import org . apache . cxf . transport . Destination ; public class CxfExchange extends DefaultExchange { public static final String DATA_FORMAT = "DATA_FORMAT" ; private Exchange exchange ; public CxfExchange ( CamelContext context , ExchangePattern pattern , Exchange exchange ) { super ( context , pattern ) ; this . exchange = exchange ; if ( exchange != null ) { if ( exchange . getOutMessage ( ) != null ) { setOut ( new CxfMessage ( exchange . getOutMessage ( ) ) ) ; } if ( exchange . getInMessage ( ) != null ) { setIn ( new CxfMessage ( exchange . getInMessage ( ) ) ) ; } if ( exchange . getInFaultMessage ( ) != null ) { setFault ( new CxfMessage ( exchange . getInFaultMessage ( ) ) ) ; } } } public CxfExchange ( CamelContext context , ExchangePattern pattern ) { super ( context , pattern ) ; } public CxfExchange ( CxfExchange exchange ) { super ( exchange ) ; this . exchange = exchange . getExchange ( ) ; } public CxfExchange ( CamelContext context , ExchangePattern pattern , Message inMessage ) { this ( context , pattern ) ; this . exchange = inMessage . getExchange ( ) ; setIn ( new CxfMessage ( inMessage ) ) ; if ( exchange != null ) { if ( exchange . getOutMessage ( ) != null ) { setOut ( new CxfMessage ( exchange . getOutMessage ( ) ) ) ; } if ( exchange . getInFaultMessage ( ) != null ) { setFault ( new CxfMessage ( exchange . getInFaultMessage ( ) ) ) ; } } } @ Override public org . apache . camel . Exchange newInstance ( ) { return new CxfExchange ( this ) ; } @ Override public CxfMessage getIn ( ) { return ( CxfMessage ) super . getIn ( ) ; } @ Override public CxfMessage getOut ( ) { return ( CxfMessage ) super . getOut ( ) ; } @ Override public CxfMessage getOut ( boolean lazyCreate ) { return ( CxfMessage ) super . getOut ( lazyCreate ) ; } @ Override public CxfMessage getFault ( ) { return ( CxfMessage ) super . getFault ( ) ; } @ Override protected org . apache . camel . Message createFaultMessage ( ) { return new CxfMessage ( ) ; } public void setExchange ( Exchange exchange ) { this . exchange = exchange ; } public Exchange getExchange ( ) { return exchange ; } public Message getInMessage ( ) { return getIn ( ) . getMessage ( ) ; } public Message getOutMessage ( ) { return getOut ( ) . getMessage ( ) ; } public Message getOutFaultMessage ( ) { return getExchange ( ) . getOutFaultMessage ( ) ; } public Message getInFaultMessage ( ) { return getExchange ( ) . getInFaultMessage ( ) ; } public Destination getDestination ( ) { return getExchange ( ) . getDestination ( ) ; } public Conduit getConduit ( Message message ) { return getExchange ( ) . getConduit ( message ) ; } @ Override protected CxfMessage createInMessage ( ) { return new CxfMessage ( ) ; } @ Override protected CxfMessage createOutMessage ( ) { return new CxfMessage ( ) ; } } 	0	['26', '2', '0', '14', '39', '305', '5', '10', '21', '0.84', '208', '0.5', '0', '0.633333333', '0.214285714', '1', '3', '6.923076923', '1', '0.8462', '0']
package org . apache . camel . util ; import java . util . Date ; import java . util . concurrent . TimeUnit ; public class Time { private long number ; private TimeUnit timeUnit = TimeUnit . MILLISECONDS ; public Time ( long number , TimeUnit timeUnit ) { this . number = number ; this . timeUnit = timeUnit ; } public static Time millis ( long value ) { return new Time ( value , TimeUnit . MILLISECONDS ) ; } public static Time micros ( long value ) { return new Time ( value , TimeUnit . MICROSECONDS ) ; } public static Time nanos ( long value ) { return new Time ( value , TimeUnit . NANOSECONDS ) ; } public static Time seconds ( long value ) { return new Time ( value , TimeUnit . SECONDS ) ; } public static Time minutes ( long value ) { return new Time ( minutesAsSeconds ( value ) , TimeUnit . MILLISECONDS ) ; } public static Time hours ( long value ) { return new Time ( hoursAsSeconds ( value ) , TimeUnit . MILLISECONDS ) ; } public static Time days ( long value ) { return new Time ( daysAsSeconds ( value ) , TimeUnit . MILLISECONDS ) ; } public long toMillis ( ) { return timeUnit . toMillis ( number ) ; } public Date toDate ( ) { return new Date ( toMillis ( ) ) ; } public long getNumber ( ) { return number ; } public TimeUnit getTimeUnit ( ) { return timeUnit ; } protected static long minutesAsSeconds ( long value ) { return value * 60 ; } protected static long hoursAsSeconds ( long value ) { return minutesAsSeconds ( value ) * 60 ; } protected static long daysAsSeconds ( long value ) { return hoursAsSeconds ( value ) * 24 ; } } 	0	['15', '1', '0', '1', '18', '95', '1', '0', '12', '0.285714286', '106', '1', '0', '0', '0.377777778', '0', '0', '5.933333333', '1', '0.9333', '0']
package org . apache . camel . component . jpa ; import javax . persistence . EntityManager ; import javax . persistence . EntityManagerFactory ; import javax . persistence . PersistenceException ; import org . apache . camel . impl . ServiceSupport ; import org . springframework . orm . jpa . JpaCallback ; import org . springframework . orm . jpa . JpaTemplate ; import org . springframework . orm . jpa . JpaTransactionManager ; import org . springframework . transaction . TransactionStatus ; import org . springframework . transaction . support . TransactionCallback ; import org . springframework . transaction . support . TransactionTemplate ; public class JpaTemplateTransactionStrategy extends ServiceSupport implements TransactionStrategy { private final JpaTemplate jpaTemplate ; private final TransactionTemplate transactionTemplate ; public JpaTemplateTransactionStrategy ( JpaTemplate jpaTemplate , TransactionTemplate transactionTemplate ) { this . jpaTemplate = jpaTemplate ; this . transactionTemplate = transactionTemplate ; } public static JpaTemplateTransactionStrategy newInstance ( EntityManagerFactory emf ) { JpaTemplate template = new JpaTemplate ( emf ) ; return newInstance ( emf , template ) ; } public static JpaTemplateTransactionStrategy newInstance ( EntityManagerFactory emf , JpaTemplate template ) { JpaTransactionManager transactionManager = new JpaTransactionManager ( emf ) ; transactionManager . afterPropertiesSet ( ) ; TransactionTemplate tranasctionTemplate = new TransactionTemplate ( transactionManager ) ; tranasctionTemplate . afterPropertiesSet ( ) ; return new JpaTemplateTransactionStrategy ( template , tranasctionTemplate ) ; } public Object execute ( final JpaCallback callback ) { return transactionTemplate . execute ( new TransactionCallback ( ) { public Object doInTransaction ( TransactionStatus status ) { return jpaTemplate . execute ( new JpaCallback ( ) { public Object doInJpa ( EntityManager entityManager ) throws PersistenceException { return callback . doInJpa ( entityManager ) ; } } ) ; } } ) ; } protected void doStart ( ) throws Exception { } protected void doStop ( ) throws Exception { } } 	0	['7', '2', '0', '10', '15', '17', '2', '9', '4', '0.666666667', '61', '1', '0', '0.7', '0.261904762', '1', '1', '7.428571429', '1', '0.8571', '0']
package org . apache . camel . component . bean ; import java . lang . annotation . Annotation ; import org . apache . camel . CamelContext ; import org . apache . camel . Expression ; import org . apache . camel . language . LanguageAnnotation ; public interface AnnotationExpressionFactory { Expression createExpression ( CamelContext camelContext , Annotation annotation , LanguageAnnotation languageAnnotation , Class expressionReturnType ) ; } 	0	['1', '1', '0', '5', '1', '0', '2', '3', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . model . dataformat ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "serialization" ) public class SerializationDataFormat extends DataFormatType { @ Override protected DataFormat createDataFormat ( RouteContext routeContext ) { return new org . apache . camel . impl . SerializationDataFormat ( ) ; } } 	0	['2', '3', '0', '5', '4', '1', '1', '4', '1', '2', '9', '0', '0', '0.9', '0.75', '1', '1', '3.5', '1', '0.5', '0']
package org . apache . camel . component . cxf . util ; import java . util . logging . Logger ; import javax . xml . stream . XMLStreamException ; import javax . xml . stream . XMLStreamReader ; import javax . xml . stream . XMLStreamWriter ; import javax . xml . transform . Source ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . interceptor . AbstractOutDatabindingInterceptor ; import org . apache . cxf . interceptor . Fault ; import org . apache . cxf . message . Message ; import org . apache . cxf . phase . Phase ; import org . apache . cxf . staxutils . StaxUtils ; public class DataOutInterceptor extends AbstractOutDatabindingInterceptor { private static final Logger LOG = LogUtils . getL7dLogger ( DataOutInterceptor . class ) ; public DataOutInterceptor ( ) { super ( Phase . MARSHAL ) ; } public void handleMessage ( Message message ) throws Fault { XMLStreamWriter xmlWriter = getXMLStreamWriter ( message ) ; try { Source source = message . getContent ( Source . class ) ; if ( source != null ) { XMLStreamReader xmlReader = StaxUtils . createXMLStreamReader ( source ) ; StaxUtils . copy ( xmlReader , xmlWriter ) ; } } catch ( XMLStreamException e ) { throw new Fault ( new org . apache . cxf . common . i18n . Message ( "XMLSTREAM_EXCEPTION" , LOG , e ) , e ) ; } } } 	0	['3', '0', '0', '7', '11', '1', '1', '6', '2', '0.5', '48', '1', '0', '0', '0.75', '0', '0', '14.66666667', '1', '0.3333', '0']
package org . apache . camel . converter . jaxb ; import java . util . HashMap ; import java . util . Map ; import javax . xml . bind . JAXBContext ; import javax . xml . bind . JAXBException ; import javax . xml . bind . Marshaller ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . util . JAXBSource ; import javax . xml . parsers . ParserConfigurationException ; import org . w3c . dom . Document ; import org . apache . camel . Converter ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . converter . HasAnnotation ; import org . apache . camel . converter . jaxp . XmlConverter ; public final class JaxbConverter { private XmlConverter jaxbConverter ; private Map < Class , JAXBContext > contexts = new HashMap < Class , JAXBContext > ( ) ; public XmlConverter getJaxbConverter ( ) { if ( jaxbConverter == null ) { jaxbConverter = new XmlConverter ( ) ; } return jaxbConverter ; } public void setJaxbConverter ( XmlConverter jaxbConverter ) { this . jaxbConverter = jaxbConverter ; } @ Converter public JAXBSource toSource ( @ HasAnnotation ( XmlRootElement . class ) Object value ) throws JAXBException { JAXBContext context = getJaxbContext ( value ) ; return new JAXBSource ( context , value ) ; } @ Converter public Document toDocument ( @ HasAnnotation ( XmlRootElement . class ) Object value ) throws JAXBException , ParserConfigurationException { JAXBContext context = getJaxbContext ( value ) ; Marshaller marshaller = context . createMarshaller ( ) ; Document doc = getJaxbConverter ( ) . createDocument ( ) ; marshaller . marshal ( value , doc ) ; return doc ; } @ Converter public static MessageType toMessageType ( Exchange exchange ) { return toMessageType ( exchange . getIn ( ) ) ; } @ Converter public static MessageType toMessageType ( Message in ) { MessageType answer = new MessageType ( ) ; answer . copyFrom ( in ) ; return answer ; } private synchronized JAXBContext getJaxbContext ( Object value ) throws JAXBException { JAXBContext context = contexts . get ( value . getClass ( ) ) ; if ( context == null ) { context = createJaxbContext ( value ) ; contexts . put ( value . getClass ( ) , context ) ; } return context ; } private JAXBContext createJaxbContext ( Object value ) throws JAXBException { if ( value == null ) { throw new IllegalArgumentException ( "Cannot convert from null value to JAXBSource" ) ; } return JAXBContext . newInstance ( value . getClass ( ) ) ; } } 	0	['9', '1', '0', '4', '24', '32', '0', '4', '7', '0.6875', '112', '1', '1', '0', '0.311111111', '0', '0', '11.22222222', '2', '1', '0']
package org . apache . camel . component . mina ; import java . net . SocketAddress ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import org . apache . camel . CamelExchangeException ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangeTimedOutException ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . util . ExchangeHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . mina . common . ConnectFuture ; import org . apache . mina . common . IoConnector ; import org . apache . mina . common . IoHandler ; import org . apache . mina . common . IoHandlerAdapter ; import org . apache . mina . common . IoSession ; import org . apache . mina . transport . socket . nio . SocketConnector ; public class MinaProducer extends DefaultProducer { private static final transient Log LOG = LogFactory . getLog ( MinaProducer . class ) ; private IoSession session ; private MinaEndpoint endpoint ; private CountDownLatch latch ; private boolean lazySessionCreation ; private long timeout ; private IoConnector connector ; private boolean sync ; public MinaProducer ( MinaEndpoint endpoint ) { super ( endpoint ) ; this . endpoint = endpoint ; this . lazySessionCreation = endpoint . isLazySessionCreation ( ) ; this . timeout = endpoint . getTimeout ( ) ; this . sync = endpoint . isSync ( ) ; } public void process ( Exchange exchange ) throws Exception { if ( session == null && ! lazySessionCreation ) { throw new IllegalStateException ( "Not started yet!" ) ; } if ( session == null || ! session . isConnected ( ) ) { openConnection ( ) ; } if ( endpoint . getCharsetName ( ) != null ) { exchange . setProperty ( Exchange . CHARSET_NAME , endpoint . getCharsetName ( ) ) ; } Object body = MinaPayloadHelper . getIn ( endpoint , exchange ) ; if ( body == null ) { LOG . warn ( "No payload to send for exchange: " + exchange ) ; return ; } if ( sync ) { latch = new CountDownLatch ( 1 ) ; ResponseHandler handler = ( ResponseHandler ) session . getHandler ( ) ; handler . reset ( ) ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Writing body: " + body ) ; } MinaHelper . writeBody ( session , body , exchange ) ; if ( sync ) { LOG . debug ( "Waiting for response" ) ; latch . await ( timeout , TimeUnit . MILLISECONDS ) ; if ( latch . getCount ( ) == 1 ) { throw new ExchangeTimedOutException ( exchange , timeout ) ; } ResponseHandler handler = ( ResponseHandler ) session . getHandler ( ) ; if ( handler . getCause ( ) != null ) { throw new CamelExchangeException ( "Response Handler had an exception" , exchange , handler . getCause ( ) ) ; } else if ( ! handler . isMessageRecieved ( ) ) { throw new CamelExchangeException ( "No response received from remote server: " + endpoint . getEndpointUri ( ) , exchange ) ; } else { if ( ExchangeHelper . isOutCapable ( exchange ) ) { MinaPayloadHelper . setOut ( exchange , handler . getMessage ( ) ) ; } else { MinaPayloadHelper . setIn ( exchange , handler . getMessage ( ) ) ; } } } } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; if ( ! lazySessionCreation ) { openConnection ( ) ; } } @ Override protected void doStop ( ) throws Exception { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Stopping connector: " + connector + " at address: " + endpoint . getAddress ( ) ) ; } if ( connector instanceof SocketConnector ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Setting SocketConnector WorkerTimeout=0 to force MINA stopping its resources faster" ) ; } ( ( SocketConnector ) connector ) . setWorkerTimeout ( 0 ) ; } if ( session != null ) { session . close ( ) ; } super . doStop ( ) ; } private void openConnection ( ) { SocketAddress address = endpoint . getAddress ( ) ; connector = endpoint . getConnector ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Creating connector to address: " + address + " using connector: " + connector + " timeout: " + timeout + " millis." ) ; } IoHandler ioHandler = new ResponseHandler ( endpoint ) ; ConnectFuture future = connector . connect ( address , ioHandler , endpoint . getConnectorConfig ( ) ) ; future . join ( ) ; session = future . getSession ( ) ; } private final class ResponseHandler extends IoHandlerAdapter { private MinaEndpoint endpoint ; private Object message ; private Throwable cause ; private boolean messageRecieved ; private ResponseHandler ( MinaEndpoint endpoint ) { this . endpoint = endpoint ; } public void reset ( ) { this . message = null ; this . cause = null ; this . messageRecieved = false ; } @ Override public void messageReceived ( IoSession ioSession , Object message ) throws Exception { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Message received: " + message ) ; } this . message = message ; messageRecieved = true ; cause = null ; countDown ( ) ; } protected void countDown ( ) { CountDownLatch downLatch = latch ; if ( downLatch != null ) { downLatch . countDown ( ) ; } } @ Override public void sessionClosed ( IoSession session ) throws Exception { if ( sync && message == null ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Session closed but no message received from address: " + this . endpoint . getAddress ( ) ) ; } countDown ( ) ; } } @ Override public void exceptionCaught ( IoSession ioSession , Throwable cause ) { LOG . error ( "Exception on receiving message from address: " + this . endpoint . getAddress ( ) + " using connector: " + this . endpoint . getConnector ( ) , cause ) ; this . message = null ; this . messageRecieved = false ; this . cause = cause ; if ( ioSession != null ) { ioSession . close ( ) ; } } public Throwable getCause ( ) { return this . cause ; } public Object getMessage ( ) { return this . message ; } public boolean isMessageRecieved ( ) { return messageRecieved ; } } } 	0	['9', '3', '0', '21', '54', '0', '2', '21', '2', '0.640625', '314', '1', '1', '0.75', '0.28125', '1', '1', '33', '2', '0.8889', '0']
package org . apache . camel . builder . xml ; public class StringResultHandlerFactory implements ResultHandlerFactory { public ResultHandler createResult ( ) { return new StringResultHandler ( ) ; } } 	0	['2', '1', '0', '4', '4', '1', '1', '3', '2', '2', '9', '0', '0', '0', '1', '0', '0', '3.5', '1', '0.5', '0']
package org . apache . camel . component . jms ; import java . io . File ; import java . util . Map ; import javax . jms . Destination ; import javax . jms . JMSException ; import javax . jms . Message ; import javax . jms . Queue ; import javax . jms . Topic ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultMessage ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class JmsMessage extends DefaultMessage { private static final transient Log LOG = LogFactory . getLog ( JmsMessage . class ) ; private Message jmsMessage ; private JmsBinding binding ; public JmsMessage ( ) { } public JmsMessage ( Message jmsMessage ) { setJmsMessage ( jmsMessage ) ; } public JmsMessage ( Message jmsMessage , JmsBinding binding ) { this ( jmsMessage ) ; setBinding ( binding ) ; } @ Override public String toString ( ) { if ( jmsMessage != null ) { return "JmsMessage: " + jmsMessage ; } else { return "JmsMessage: " + getBody ( ) ; } } @ Override public void copyFrom ( org . apache . camel . Message that ) { boolean copyMessageId = true ; if ( that instanceof JmsMessage ) { JmsMessage thatMessage = ( JmsMessage ) that ; this . jmsMessage = thatMessage . jmsMessage ; if ( this . jmsMessage != null ) { copyMessageId = false ; } } if ( copyMessageId ) { setMessageId ( that . getMessageId ( ) ) ; } setBody ( that . getBody ( ) ) ; getHeaders ( ) . putAll ( that . getHeaders ( ) ) ; } public Message getJmsMessage ( ) { return jmsMessage ; } public JmsBinding getBinding ( ) { if ( binding == null ) { Exchange exchange = getExchange ( ) ; if ( exchange instanceof JmsExchange ) { JmsExchange jmsExchange = ( JmsExchange ) exchange ; return jmsExchange . getBinding ( ) ; } else { return new JmsBinding ( ) ; } } return binding ; } public void setBinding ( JmsBinding binding ) { this . binding = binding ; } public void setJmsMessage ( Message jmsMessage ) { try { setMessageId ( jmsMessage . getJMSMessageID ( ) ) ; } catch ( JMSException e ) { LOG . warn ( "Unable to retrieve JMSMessageID from JMS Message" , e ) ; } this . jmsMessage = jmsMessage ; } public Object getHeader ( String name ) { Object answer = null ; if ( jmsMessage != null && ! name . startsWith ( "JMS" ) ) { try { answer = jmsMessage . getObjectProperty ( name ) ; } catch ( JMSException e ) { throw new MessagePropertyAccessException ( name , e ) ; } } if ( answer == null ) { answer = super . getHeader ( name ) ; } return answer ; } @ Override public JmsMessage newInstance ( ) { return new JmsMessage ( ) ; } public boolean shouldCreateNewMessage ( ) { return super . hasPopulatedHeaders ( ) ; } @ Override protected Object createBody ( ) { if ( jmsMessage != null ) { return getBinding ( ) . extractBodyFromJms ( getExchange ( ) , jmsMessage ) ; } return null ; } @ Override protected void populateInitialHeaders ( Map < String , Object > map ) { if ( jmsMessage != null && map != null ) { map . putAll ( getBinding ( ) . extractHeadersFromJms ( jmsMessage ) ) ; } } @ Override protected String createMessageId ( ) { if ( jmsMessage == null ) { LOG . info ( "The jmsMessage is not set yet, call the super's createMessageId" ) ; return super . createMessageId ( ) ; } try { String id = getDestinationAsString ( jmsMessage . getJMSDestination ( ) ) + jmsMessage . getJMSMessageID ( ) ; return getSanitizedString ( id ) ; } catch ( JMSException e ) { LOG . error ( "Failed to get message id from message " + jmsMessage , e ) ; return super . createMessageId ( ) ; } } private String getDestinationAsString ( Destination destination ) throws JMSException { String result ; if ( destination == null ) { result = "null destination!" + File . separator ; } else if ( destination instanceof Topic ) { result = "topic" + File . separator + ( ( Topic ) destination ) . getTopicName ( ) + File . separator ; } else { result = "queue" + File . separator + ( ( Queue ) destination ) . getQueueName ( ) + File . separator ; } return result ; } private String getSanitizedString ( Object value ) { return value != null ? value . toString ( ) . replaceAll ( "[^a-zA-Z0-9\\.\\_\\-]" , "_" ) : "" ; } } 	0	['20', '3', '0', '11', '52', '128', '5', '8', '14', '0.701754386', '313', '1', '1', '0.68627451', '0.190789474', '2', '5', '14.5', '4', '1.5', '0']
package org . apache . camel . component . spring . integration ; public final class SpringIntegrationHelper { private SpringIntegrationHelper ( ) { } public static void checkSpringBeanInstance ( Object bean , String name ) { if ( bean == null ) { throw new IllegalArgumentException ( "Can't find the bean: " + name + " from the Spring context" ) ; } } } 	0	['2', '1', '0', '0', '7', '1', '0', '0', '1', '2', '22', '0', '0', '0', '0.5', '0', '0', '10', '2', '1', '0']
package org . apache . camel . component . http . helper ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; public class LoadingByteArrayOutputStream extends ByteArrayOutputStream { public LoadingByteArrayOutputStream ( ) { super ( 1024 ) ; } public LoadingByteArrayOutputStream ( int i ) { super ( i ) ; } public ByteArrayInputStream createInputStream ( ) { return new ByteArrayInputStream ( buf , 0 , count ) ; } public byte [ ] toByteArray ( ) { if ( count != buf . length ) { buf = super . toByteArray ( ) ; } return buf ; } } 	0	['4', '3', '0', '2', '7', '4', '2', '0', '4', '2', '34', '0', '0', '0.882352941', '0.625', '1', '3', '7.5', '2', '0.75', '0']
package org . apache . camel . dataformat . xstream ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . HashMap ; import javax . xml . stream . XMLStreamException ; import com . thoughtworks . xstream . io . HierarchicalStreamReader ; import com . thoughtworks . xstream . io . HierarchicalStreamWriter ; import com . thoughtworks . xstream . io . xml . QNameMap ; import com . thoughtworks . xstream . io . xml . StaxReader ; import com . thoughtworks . xstream . io . xml . StaxWriter ; import org . apache . camel . Exchange ; import org . apache . camel . spi . DataFormat ; import org . codehaus . jettison . mapped . MappedXMLInputFactory ; import org . codehaus . jettison . mapped . MappedXMLOutputFactory ; public class JsonDataFormat extends AbstractXStreamWrapper { private final MappedXMLOutputFactory mof ; private final MappedXMLInputFactory mif ; public JsonDataFormat ( ) { final HashMap nstjsons = new HashMap ( ) ; mof = new MappedXMLOutputFactory ( nstjsons ) ; mif = new MappedXMLInputFactory ( nstjsons ) ; } protected HierarchicalStreamWriter createHierarchicalStreamWriter ( Exchange exchange , Object body , OutputStream stream ) throws XMLStreamException { return new StaxWriter ( new QNameMap ( ) , mof . createXMLStreamWriter ( stream ) ) ; } protected HierarchicalStreamReader createHierarchicalStreamReader ( Exchange exchange , InputStream stream ) throws XMLStreamException { return new StaxReader ( new QNameMap ( ) , mif . createXMLStreamReader ( stream ) ) ; } } 	0	['3', '2', '0', '9', '12', '0', '0', '9', '1', '0.5', '46', '1', '0', '0.818181818', '0.533333333', '1', '2', '13.66666667', '1', '0.6667', '0']
package org . apache . camel . processor ; import java . util . Collection ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ServiceHelper ; public class CompositeProcessor extends ServiceSupport implements Processor { private final Collection < Processor > processors ; public CompositeProcessor ( Collection < Processor > processors ) { this . processors = processors ; } public void process ( Exchange exchange ) throws Exception { for ( Processor processor : processors ) { processor . process ( exchange ) ; } } @ Override public String toString ( ) { StringBuilder builder = new StringBuilder ( "[ " ) ; boolean first = true ; for ( Processor processor : processors ) { if ( first ) { first = false ; } else { builder . append ( ", " ) ; } builder . append ( processor . toString ( ) ) ; } builder . append ( " ]" ) ; return builder . toString ( ) ; } public Collection < Processor > getProcessors ( ) { return processors ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( processors ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( processors ) ; } } 	0	['6', '2', '0', '4', '17', '0', '0', '4', '4', '0', '80', '1', '0', '0.736842105', '0.444444444', '1', '1', '12.16666667', '3', '1.1667', '0']
package org . apache . camel . component . xquery ; import java . lang . annotation . Annotation ; import net . sf . saxon . functions . Collection ; import org . apache . camel . CamelContext ; import org . apache . camel . Expression ; import org . apache . camel . component . bean . DefaultAnnotationExpressionFactory ; import org . apache . camel . language . LanguageAnnotation ; import org . apache . camel . language . NamespacePrefix ; public class XQueryAnnotationExpressionFactory extends DefaultAnnotationExpressionFactory { @ Override public Expression createExpression ( CamelContext camelContext , Annotation annotation , LanguageAnnotation languageAnnotation , Class expressionReturnType ) { String xQuery = getExpressionFromAnnotation ( annotation ) ; XQueryBuilder builder = XQueryBuilder . xquery ( xQuery ) ; if ( annotation instanceof XQuery ) { XQuery xQueryAnnotation = ( XQuery ) annotation ; NamespacePrefix [ ] namespaces = xQueryAnnotation . namespaces ( ) ; if ( namespaces != null ) { for ( NamespacePrefix namespacePrefix : namespaces ) { } } } if ( expressionReturnType . isAssignableFrom ( String . class ) ) { builder . setResultsFormat ( ResultFormat . String ) ; } else if ( expressionReturnType . isAssignableFrom ( Collection . class ) ) { builder . setResultsFormat ( ResultFormat . List ) ; } return builder ; } } 	0	['2', '2', '0', '8', '8', '1', '0', '8', '2', '2', '56', '0', '0', '0.666666667', '0.6', '1', '1', '27', '6', '3', '0']
@ javax . xml . bind . annotation . XmlSchema ( namespace = "http://activemq.apache.org/camel/schema/spring" , elementFormDefault = javax . xml . bind . annotation . XmlNsForm . QUALIFIED ) package org . apache . camel . model . dataformat ; 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . component . cxf . interceptors ; import java . util . logging . Level ; import java . util . logging . Logger ; import org . apache . cxf . binding . soap . SoapFault ; import org . apache . cxf . binding . soap . SoapMessage ; import org . apache . cxf . binding . xml . XMLFault ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . interceptor . Fault ; import org . apache . cxf . message . Message ; import org . apache . cxf . message . XMLMessage ; import org . apache . cxf . phase . AbstractPhaseInterceptor ; import org . apache . cxf . phase . Phase ; import org . apache . cxf . service . model . BindingOperationInfo ; public class FaultOutInterceptor extends AbstractPhaseInterceptor < Message > { private static final Logger LOG = LogUtils . getL7dLogger ( FaultOutInterceptor . class ) ; public FaultOutInterceptor ( ) { super ( Phase . PREPARE_SEND ) ; } @ SuppressWarnings ( "unchecked" ) public void handleMessage ( Message message ) throws Fault { checkBindingOperationInfor ( message ) ; Throwable ex = message . getContent ( Throwable . class ) ; if ( ex != null ) { if ( ! ( ex instanceof Fault ) ) { ex = new Fault ( ex ) ; } if ( message instanceof XMLMessage ) { if ( LOG . isLoggable ( Level . INFO ) ) { LOG . info ( "FaultOutInterceptor Creating XMLFault" ) ; } ex = XMLFault . createFault ( ( Fault ) ex ) ; } else if ( message instanceof SoapMessage ) { if ( LOG . isLoggable ( Level . INFO ) ) { LOG . info ( "FaultOutInterceptor Creating SoapFault" ) ; } SoapMessage sm = ( SoapMessage ) message ; ex = SoapFault . createFault ( ( Fault ) ex , sm . getVersion ( ) ) ; } message . setContent ( Throwable . class , ex ) ; } } private void checkBindingOperationInfor ( Message message ) { BindingOperationInfo bop = message . getExchange ( ) . get ( BindingOperationInfo . class ) ; if ( bop == null ) { bop = new FakeBindingOperationInfo ( ) ; message . getExchange ( ) . put ( BindingOperationInfo . class , bop ) ; } } } 	0	['4', '0', '0', '14', '18', '4', '2', '12', '2', '0.666666667', '88', '1', '0', '0', '0.833333333', '0', '0', '20.75', '2', '0.75', '0']
package org . apache . camel . component . bean ; import java . lang . reflect . Proxy ; import org . apache . camel . Endpoint ; import org . apache . camel . Producer ; public final class ProxyHelper { private ProxyHelper ( ) { } @ SuppressWarnings ( "unchecked" ) public static Object createProxyObject ( Endpoint endpoint , Producer producer , ClassLoader classLoader , Class [ ] interfaces , MethodInfoCache methodCache ) { return Proxy . newProxyInstance ( classLoader , interfaces . clone ( ) , new CamelInvocationHandler ( endpoint , producer , methodCache ) ) ; } @ SuppressWarnings ( "unchecked" ) public static < T > T createProxy ( Endpoint endpoint , ClassLoader cl , Class [ ] interfaces , MethodInfoCache methodCache ) throws Exception { return ( T ) createProxyObject ( endpoint , endpoint . createProducer ( ) , cl , interfaces , methodCache ) ; } @ SuppressWarnings ( "unchecked" ) public static < T > T createProxy ( Endpoint endpoint , ClassLoader cl , Class < T > ... interfaceClasses ) throws Exception { return ( T ) createProxy ( endpoint , cl , interfaceClasses , createMethodInfoCache ( endpoint ) ) ; } @ SuppressWarnings ( "unchecked" ) public static < T > T createProxy ( Endpoint endpoint , Class < T > ... interfaceClasses ) throws Exception { return ( T ) createProxy ( endpoint , getClassLoader ( interfaceClasses ) , interfaceClasses ) ; } @ SuppressWarnings ( "unchecked" ) public static < T > T createProxy ( Endpoint endpoint , Producer producer , Class < T > ... interfaceClasses ) throws Exception { return ( T ) createProxyObject ( endpoint , producer , getClassLoader ( interfaceClasses ) , interfaceClasses , createMethodInfoCache ( endpoint ) ) ; } protected static ClassLoader getClassLoader ( Class ... interfaces ) { if ( interfaces == null || interfaces . length < 1 ) { throw new IllegalArgumentException ( "You must provide at least 1 interface class." ) ; } return interfaces [ 0 ] . getClassLoader ( ) ; } protected static MethodInfoCache createMethodInfoCache ( Endpoint endpoint ) { return new MethodInfoCache ( endpoint . getCamelContext ( ) ) ; } } 	0	['8', '1', '0', '8', '17', '28', '2', '6', '5', '2', '75', '0', '0', '0', '0.416666667', '0', '0', '8.375', '3', '1.125', '0']
package org . apache . camel . component . jmx ; import javax . management . Notification ; import javax . management . NotificationListener ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; public class JMXConsumer extends DefaultConsumer implements NotificationListener { private JMXEndpoint jmxEndpoint ; public JMXConsumer ( JMXEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . jmxEndpoint = endpoint ; } public void handleNotification ( Notification notification , Object handback ) { try { getProcessor ( ) . process ( jmxEndpoint . createExchange ( notification ) ) ; } catch ( Throwable e ) { handleException ( e ) ; } } } 	0	['2', '3', '0', '6', '7', '0', '1', '6', '2', '0', '24', '1', '1', '0.958333333', '0.6', '0', '0', '10.5', '1', '0.5', '0']
package org . apache . camel . component . atom ; import org . apache . abdera . model . Document ; import org . apache . abdera . model . Entry ; import org . apache . abdera . model . Feed ; public interface EntryFilter { boolean isValidEntry ( AtomEndpoint endpoint , Document < Feed > feed , Entry entry ) ; } 	0	['1', '1', '0', '5', '1', '0', '2', '3', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlElements ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . model . loadbalancer . LoadBalancerType ; import org . apache . camel . model . loadbalancer . RandomLoadBalanceStrategy ; import org . apache . camel . model . loadbalancer . RoundRobinLoadBalanceStrategy ; import org . apache . camel . model . loadbalancer . StickyLoadBalanceStrategy ; import org . apache . camel . model . loadbalancer . TopicLoadBalanceStrategy ; import org . apache . camel . processor . SendProcessor ; import org . apache . camel . processor . loadbalancer . LoadBalancer ; import org . apache . camel . processor . loadbalancer . RandomLoadBalancer ; import org . apache . camel . processor . loadbalancer . RoundRobinLoadBalancer ; import org . apache . camel . processor . loadbalancer . StickyLoadBalancer ; import org . apache . camel . processor . loadbalancer . TopicLoadBalancer ; import org . apache . camel . spi . RouteContext ; import org . apache . camel . util . CollectionStringBuffer ; @ XmlRootElement ( name = "loadBalance" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class LoadBalanceType extends ProcessorType < LoadBalanceType > { @ XmlAttribute ( required = false ) private String ref ; @ XmlElements ( { @ XmlElement ( required = false , name = "roundRobin" , type = RoundRobinLoadBalanceStrategy . class ) , @ XmlElement ( required = false , name = "random" , type = RandomLoadBalanceStrategy . class ) , @ XmlElement ( required = false , name = "sticky" , type = StickyLoadBalanceStrategy . class ) , @ XmlElement ( required = false , name = "topic" , type = TopicLoadBalanceStrategy . class ) } ) private LoadBalancerType loadBalancerType ; @ XmlElementRef private List < ProcessorType < ? > > outputs = new ArrayList < ProcessorType < ? > > ( ) ; public LoadBalanceType ( ) { } @ Override public String getShortName ( ) { return "loadbalance" ; } public List < ProcessorType < ? > > getOutputs ( ) { return outputs ; } public void setOutputs ( List < ProcessorType < ? > > outputs ) { this . outputs = outputs ; if ( outputs != null ) { for ( ProcessorType output : outputs ) { configureChild ( output ) ; } } } @ Override protected void configureChild ( ProcessorType output ) { super . configureChild ( output ) ; if ( isInheritErrorHandler ( ) ) { output . setErrorHandlerBuilder ( getErrorHandlerBuilder ( ) ) ; } } public String getRef ( ) { return ref ; } public void setRef ( String ref ) { this . ref = ref ; } public LoadBalancerType getLoadBalancerType ( ) { return loadBalancerType ; } public void setLoadBalancerType ( LoadBalancerType loadbalancer ) { loadBalancerType = loadbalancer ; } protected Processor createOutputsProcessor ( RouteContext routeContext , Collection < ProcessorType < ? > > outputs ) throws Exception { LoadBalancer loadBalancer = LoadBalancerType . getLoadBalancer ( routeContext , loadBalancerType , ref ) ; for ( ProcessorType processorType : outputs ) { SendProcessor processor = ( SendProcessor ) processorType . createProcessor ( routeContext ) ; loadBalancer . addProcessor ( processor ) ; } return loadBalancer ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { LoadBalancer loadBalancer = LoadBalancerType . getLoadBalancer ( routeContext , loadBalancerType , ref ) ; for ( ProcessorType processorType : getOutputs ( ) ) { Processor processor = processorType . createProcessor ( routeContext ) ; processor = processorType . wrapProcessorInInterceptors ( routeContext , processor ) ; loadBalancer . addProcessor ( processor ) ; } return loadBalancer ; } public LoadBalanceType setLoadBalancer ( LoadBalancer loadBalancer ) { loadBalancerType = new LoadBalancerType ( loadBalancer ) ; return this ; } public LoadBalanceType roundRobin ( ) { loadBalancerType = new LoadBalancerType ( new RoundRobinLoadBalancer ( ) ) ; return this ; } public LoadBalanceType random ( ) { loadBalancerType = new LoadBalancerType ( new RandomLoadBalancer ( ) ) ; return this ; } public LoadBalanceType sticky ( Expression < Exchange > correlationExpression ) { loadBalancerType = new LoadBalancerType ( new StickyLoadBalancer ( correlationExpression ) ) ; return this ; } public LoadBalanceType topic ( ) { loadBalancerType = new LoadBalancerType ( new TopicLoadBalancer ( ) ) ; return this ; } @ Override public String getLabel ( ) { CollectionStringBuffer buffer = new CollectionStringBuffer ( ) ; List < ProcessorType < ? > > list = getOutputs ( ) ; for ( ProcessorType < ? > processorType : list ) { buffer . append ( processorType . getLabel ( ) ) ; } return buffer . toString ( ) ; } @ Override public String toString ( ) { if ( loadBalancerType != null ) { return "LoadBalanceType[" + loadBalancerType + ", " + getOutputs ( ) + "]" ; } else { return "LoadBalanceType[ref: " + ref + ", " + getOutputs ( ) + "]" ; } } } 	0	['18', '3', '0', '15', '45', '43', '3', '13', '16', '0.647058824', '251', '1', '1', '0.911917098', '0.166666667', '1', '6', '12.77777778', '3', '1.2222', '0']
package org . apache . camel . bam ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . Endpoint ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . bam . model . ActivityDefinition ; import org . apache . camel . bam . model . ProcessDefinition ; import org . apache . camel . bam . model . ProcessInstance ; import org . apache . camel . bam . processor . ActivityMonitorEngine ; import org . apache . camel . bam . processor . JpaBamProcessor ; import org . apache . camel . bam . rules . ProcessRules ; import org . apache . camel . builder . RouteBuilder ; import org . springframework . orm . jpa . JpaTemplate ; import org . springframework . transaction . TransactionStatus ; import org . springframework . transaction . support . TransactionCallbackWithoutResult ; import org . springframework . transaction . support . TransactionTemplate ; import static org . apache . camel . util . ObjectHelper . notNull ; public abstract class ProcessBuilder extends RouteBuilder { private static int processCounter ; private JpaTemplate jpaTemplate ; private final TransactionTemplate transactionTemplate ; private final String processName ; private List < ActivityBuilder > activityBuilders = new ArrayList < ActivityBuilder > ( ) ; private Class entityType = ProcessInstance . class ; private ProcessRules processRules = new ProcessRules ( ) ; private ProcessDefinition processDefinition ; protected ProcessBuilder ( JpaTemplate jpaTemplate , TransactionTemplate transactionTemplate ) { this ( jpaTemplate , transactionTemplate , createProcessName ( ) ) ; } protected ProcessBuilder ( JpaTemplate jpaTemplate , TransactionTemplate transactionTemplate , String processName ) { this . jpaTemplate = jpaTemplate ; this . transactionTemplate = transactionTemplate ; this . processName = processName ; } protected static synchronized String createProcessName ( ) { return "Process-" + ( ++ processCounter ) ; } public ActivityBuilder activity ( String endpointUri ) { return activity ( endpoint ( endpointUri ) ) ; } public ActivityBuilder activity ( Endpoint endpoint ) { ActivityBuilder answer = new ActivityBuilder ( this , endpoint ) ; activityBuilders . add ( answer ) ; return answer ; } public ProcessBuilder entityType ( Class entityType ) { this . entityType = entityType ; return this ; } public Processor createActivityProcessor ( ActivityBuilder activityBuilder ) { notNull ( jpaTemplate , "jpaTemplate" ) ; transactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { protected void doInTransactionWithoutResult ( TransactionStatus status ) { processRules . setProcessDefinition ( getProcessDefinition ( ) ) ; } } ) ; return new JpaBamProcessor ( getTransactionTemplate ( ) , getJpaTemplate ( ) , activityBuilder . getCorrelationExpression ( ) , activityBuilder . getActivityRules ( ) , getEntityType ( ) ) ; } public List < ActivityBuilder > getActivityBuilders ( ) { return activityBuilders ; } public Class getEntityType ( ) { return entityType ; } public JpaTemplate getJpaTemplate ( ) { return jpaTemplate ; } public void setJpaTemplate ( JpaTemplate jpaTemplate ) { this . jpaTemplate = jpaTemplate ; } public TransactionTemplate getTransactionTemplate ( ) { return transactionTemplate ; } public ProcessRules getProcessRules ( ) { return processRules ; } public String getProcessName ( ) { return processName ; } public ProcessDefinition getProcessDefinition ( ) { if ( processDefinition == null ) { processDefinition = findOrCreateProcessDefinition ( ) ; } return processDefinition ; } public void setProcessDefinition ( ProcessDefinition processDefinition ) { this . processDefinition = processDefinition ; } protected void populateRoutes ( List < Route > routes ) throws Exception { boolean first = true ; for ( ActivityBuilder builder : activityBuilders ) { Route route = builder . createRoute ( ) ; if ( first ) { route . getServices ( ) . add ( new ActivityMonitorEngine ( getJpaTemplate ( ) , getTransactionTemplate ( ) , getProcessRules ( ) ) ) ; first = false ; } routes . add ( route ) ; } } public ActivityDefinition findOrCreateActivityDefinition ( String activityName ) { ProcessDefinition definition = getProcessDefinition ( ) ; List < ActivityDefinition > list = jpaTemplate . find ( "select x from " + ActivityDefinition . class . getName ( ) + " x where x.processDefinition = ?1 and x.name = ?2" , definition , activityName ) ; if ( ! list . isEmpty ( ) ) { return list . get ( 0 ) ; } else { ActivityDefinition answer = new ActivityDefinition ( ) ; answer . setName ( activityName ) ; answer . setProcessDefinition ( ProcessDefinition . getRefreshedProcessDefinition ( jpaTemplate , definition ) ) ; jpaTemplate . persist ( answer ) ; return answer ; } } protected ProcessDefinition findOrCreateProcessDefinition ( ) { List < ProcessDefinition > list = jpaTemplate . find ( "select x from " + ProcessDefinition . class . getName ( ) + " x where x.name = ?1" , processName ) ; if ( ! list . isEmpty ( ) ) { return list . get ( 0 ) ; } else { ProcessDefinition answer = new ProcessDefinition ( ) ; answer . setName ( processName ) ; jpaTemplate . persist ( answer ) ; return answer ; } } } 	0	['20', '3', '0', '18', '53', '126', '4', '17', '14', '0.782894737', '299', '1', '2', '0.75', '0.16', '1', '1', '13.55', '2', '1.05', '0']
package org . apache . camel . component . sql ; import java . sql . PreparedStatement ; import java . sql . SQLException ; import java . util . Iterator ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . NoTypeConversionAvailableException ; import org . apache . camel . impl . DefaultProducer ; import org . springframework . dao . DataAccessException ; import org . springframework . jdbc . core . ColumnMapRowMapper ; import org . springframework . jdbc . core . JdbcTemplate ; import org . springframework . jdbc . core . PreparedStatementCallback ; import org . springframework . jdbc . core . RowMapperResultSetExtractor ; public class SqlProducer extends DefaultProducer { public static final String UPDATE_COUNT = "org.apache.camel.sql.update-count" ; private String query ; private JdbcTemplate jdbcTemplate ; public SqlProducer ( SqlEndpoint endpoint , String query , JdbcTemplate jdbcTemplate ) { super ( endpoint ) ; this . jdbcTemplate = jdbcTemplate ; this . query = query ; } public void process ( final Exchange exchange ) throws Exception { jdbcTemplate . execute ( query , new PreparedStatementCallback ( ) { public Object doInPreparedStatement ( PreparedStatement ps ) throws SQLException , DataAccessException { int argNumber = 1 ; try { Iterator < ? > iterator = exchange . getIn ( ) . getBody ( Iterator . class ) ; while ( iterator != null && iterator . hasNext ( ) ) { ps . setObject ( argNumber ++ , iterator . next ( ) ) ; } } catch ( NoTypeConversionAvailableException e ) { } int expected = ps . getParameterMetaData ( ) . getParameterCount ( ) ; if ( argNumber - 1 != expected ) { throw new SQLException ( "Number of parameters mismatch. Expected: " + expected + ", was:" + ( argNumber - 1 ) ) ; } boolean isResultSet = ps . execute ( ) ; if ( isResultSet ) { RowMapperResultSetExtractor mapper = new RowMapperResultSetExtractor ( new ColumnMapRowMapper ( ) ) ; List < ? > result = ( List < ? > ) mapper . extractData ( ps . getResultSet ( ) ) ; exchange . getOut ( ) . setBody ( result ) ; exchange . getOut ( ) . setHeaders ( exchange . getIn ( ) . getHeaders ( ) ) ; } else { exchange . getIn ( ) . setHeader ( UPDATE_COUNT , ps . getUpdateCount ( ) ) ; } return null ; } } ) ; } } 	0	['2', '3', '0', '7', '5', '0', '2', '7', '2', '0.666666667', '27', '0.666666667', '0', '0.954545455', '0.6', '0', '0', '11', '1', '0.5', '0']
package org . apache . camel ; public interface PollingConsumer < E extends Exchange > extends Consumer < E > { E receive ( ) ; E receiveNoWait ( ) ; E receive ( long timeout ) ; } 	0	['3', '1', '0', '15', '3', '3', '13', '2', '3', '2', '3', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . xquery ; public enum ResultFormat { Bytes , BytesSource , DOM , DOMSource , List , String , StringSource } 	0	['4', '2', '0', '4', '7', '4', '3', '1', '2', '0.958333333', '100', '0.125', '8', '0.857142857', '0.444444444', '1', '1', '22', '1', '0.5', '0']
package org . apache . camel ; public interface Processor { void process ( Exchange exchange ) throws Exception ; } 	0	['1', '1', '0', '274', '1', '0', '273', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . builder . ProcessorBuilder ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "setBody" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class SetBodyType extends ExpressionNode { public SetBodyType ( ) { } public SetBodyType ( Expression expression ) { super ( expression ) ; } @ Override public String toString ( ) { return "SetBody[" + getExpression ( ) + "]" ; } @ Override public String getShortName ( ) { return "setBody" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { Expression expr = getExpression ( ) . createExpression ( routeContext ) ; return ProcessorBuilder . setBody ( expr ) ; } } 	0	['5', '4', '0', '7', '14', '10', '1', '6', '5', '2', '34', '0', '0', '0.983957219', '0.466666667', '2', '4', '5.8', '1', '0.6', '0']
package org . apache . camel . dataformat . tagsoup ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . StringWriter ; import java . io . Writer ; import java . util . Map ; import java . util . Map . Entry ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . dom . DOMResult ; import javax . xml . transform . sax . SAXSource ; import org . w3c . dom . Node ; import org . xml . sax . ContentHandler ; import org . xml . sax . InputSource ; import org . xml . sax . XMLReader ; import org . apache . camel . CamelException ; import org . apache . camel . Exchange ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . ccil . cowan . tagsoup . HTMLSchema ; import org . ccil . cowan . tagsoup . Parser ; import org . ccil . cowan . tagsoup . Schema ; import org . ccil . cowan . tagsoup . XMLWriter ; public class TidyMarkupDataFormat implements DataFormat { private static final transient Log LOG = LogFactory . getLog ( TidyMarkupDataFormat . class ) ; private static final String NO = "no" ; private static final String YES = "yes" ; private static final String XML = "xml" ; private boolean isOmitXmlDeclaration ; private Class dataObjectType ; private String method ; private Schema parsingSchema ; private Map < String , Boolean > parserFeatures ; private Map < String , Object > parserPropeties ; public void marshal ( Exchange exchange , Object object , OutputStream outputStream ) throws Exception { throw new CamelException ( "Marshalling from Well Formed HTML to ugly HTML is not supported." + " Only unmarshal is supported" ) ; } public Object unmarshal ( Exchange exchange , InputStream inputStream ) throws Exception { ObjectHelper . notNull ( dataObjectType , "dataObjectType" , this ) ; if ( dataObjectType . isAssignableFrom ( Node . class ) ) { return asNodeTidyMarkup ( inputStream ) ; } else if ( dataObjectType . isAssignableFrom ( String . class ) ) { return asStringTidyMarkup ( inputStream ) ; } else { throw new IllegalArgumentException ( "The return type [" + dataObjectType . getCanonicalName ( ) + "] is unsupported" ) ; } } public String asStringTidyMarkup ( InputStream inputStream ) throws CamelException { XMLReader parser = createTagSoupParser ( ) ; StringWriter w = new StringWriter ( ) ; parser . setContentHandler ( createContentHandler ( w ) ) ; try { parser . parse ( new InputSource ( inputStream ) ) ; return w . toString ( ) ; } catch ( Exception e ) { throw new CamelException ( "Failed to convert the HTML to tidy Markup" , e ) ; } finally { try { inputStream . close ( ) ; } catch ( Exception e ) { LOG . warn ( "Failed to close the inputStream" ) ; } } } public Node asNodeTidyMarkup ( InputStream inputStream ) throws CamelException { XMLReader parser = createTagSoupParser ( ) ; StringWriter w = new StringWriter ( ) ; parser . setContentHandler ( createContentHandler ( w ) ) ; try { Transformer transformer = TransformerFactory . newInstance ( ) . newTransformer ( ) ; DOMResult result = new DOMResult ( ) ; transformer . transform ( new SAXSource ( parser , new InputSource ( inputStream ) ) , result ) ; return result . getNode ( ) ; } catch ( Exception e ) { throw new CamelException ( "Failed to convert the HTML to tidy Markup" , e ) ; } } protected XMLReader createTagSoupParser ( ) throws CamelException { XMLReader reader = new Parser ( ) ; try { reader . setFeature ( Parser . namespacesFeature , false ) ; reader . setFeature ( Parser . namespacePrefixesFeature , false ) ; if ( getParserFeatures ( ) != null ) { for ( Entry < String , Boolean > e : getParserFeatures ( ) . entrySet ( ) ) { reader . setFeature ( e . getKey ( ) , e . getValue ( ) ) ; } } if ( getParserPropeties ( ) != null ) { for ( Entry < String , Object > e : getParserPropeties ( ) . entrySet ( ) ) { reader . setProperty ( e . getKey ( ) , e . getValue ( ) ) ; } } if ( this . getParsingSchema ( ) != null ) { reader . setProperty ( Parser . schemaProperty , getParsingSchema ( ) ) ; } } catch ( Exception e ) { throw new IllegalArgumentException ( "Problem configuring the parser" , e ) ; } return reader ; } public void setParsingSchema ( Schema schema ) { this . parsingSchema = schema ; } public Schema getParsingSchema ( ) { if ( parsingSchema == null ) { this . parsingSchema = new HTMLSchema ( ) ; } return parsingSchema ; } protected ContentHandler createContentHandler ( Writer w ) { XMLWriter xmlWriter = new XMLWriter ( w ) ; if ( getMethod ( ) != null ) { xmlWriter . setOutputProperty ( XMLWriter . METHOD , getMethod ( ) ) ; } else { xmlWriter . setOutputProperty ( XMLWriter . METHOD , XML ) ; } if ( isOmitXmlDeclaration ) { xmlWriter . setOutputProperty ( XMLWriter . OMIT_XML_DECLARATION , YES ) ; } else { xmlWriter . setOutputProperty ( XMLWriter . OMIT_XML_DECLARATION , NO ) ; } return xmlWriter ; } public void setParserFeatures ( Map < String , Boolean > parserFeatures ) { this . parserFeatures = parserFeatures ; } public Map < String , Boolean > getParserFeatures ( ) { return parserFeatures ; } public void setParserPropeties ( Map < String , Object > parserPropeties ) { this . parserPropeties = parserPropeties ; } public Map < String , Object > getParserPropeties ( ) { return parserPropeties ; } public void setMethod ( String method ) { this . method = method ; } public String getMethod ( ) { return method ; } public Class getDataObjectType ( ) { return dataObjectType ; } public void setDataObjectType ( Class dataObjectType ) { this . dataObjectType = dataObjectType ; } } 	0	['18', '1', '0', '10', '56', '137', '0', '10', '15', '0.935294118', '319', '1', '0', '0', '0.176470588', '0', '0', '16.16666667', '3', '1.0556', '0']
package org . apache . camel . component . file . remote ; import java . net . URI ; import org . apache . camel . Expression ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . language . simple . FileLanguage ; import org . apache . commons . net . ftp . FTPClientConfig ; public class RemoteFileConfiguration implements Cloneable { private String protocol ; private String username ; private String host ; private int port ; private String password ; private String file ; private boolean binary ; private boolean directory = true ; private FTPClientConfig ftpClientConfig ; private Expression expression ; private boolean passiveMode ; private String knownHosts ; private String privateKeyFile ; private String privateKeyFilePassphrase ; public RemoteFileConfiguration ( ) { } public RemoteFileConfiguration ( URI uri ) { configure ( uri ) ; } public RemoteFileConfiguration copy ( ) { try { return ( RemoteFileConfiguration ) clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeCamelException ( e ) ; } } public String toString ( ) { return remoteServerInformation ( ) + "/" + file ; } public String remoteServerInformation ( ) { return protocol + "://" + ( username != null ? username : "anonymous" ) + "@" + host + ":" + port ; } public void configure ( URI uri ) { setProtocol ( uri . getScheme ( ) ) ; setDefaultPort ( ) ; setUsername ( uri . getUserInfo ( ) ) ; setHost ( uri . getHost ( ) ) ; setPort ( uri . getPort ( ) ) ; setFile ( uri . getPath ( ) ) ; } protected void setDefaultPort ( ) { if ( "ftp" . equalsIgnoreCase ( protocol ) ) { setPort ( 21 ) ; } else if ( "sftp" . equalsIgnoreCase ( protocol ) ) { setPort ( 22 ) ; } } public String getFile ( ) { return file ; } public void setFile ( String file ) { if ( file . startsWith ( "/" ) ) { file = file . substring ( 1 ) ; } this . file = file ; } public String getKnownHosts ( ) { return knownHosts ; } public void setKnownHosts ( String knownHosts ) { this . knownHosts = knownHosts ; } public String getHost ( ) { return host ; } public void setHost ( String host ) { this . host = host ; } public int getPort ( ) { return port ; } public void setPort ( int port ) { if ( port != - 1 ) { this . port = port ; } } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public String getProtocol ( ) { return protocol ; } public void setProtocol ( String protocol ) { this . protocol = protocol ; } public String getUsername ( ) { return username ; } public void setUsername ( String username ) { this . username = username ; } public boolean isBinary ( ) { return binary ; } public void setBinary ( boolean binary ) { this . binary = binary ; } public boolean isDirectory ( ) { return directory ; } public void setDirectory ( boolean directory ) { this . directory = directory ; } public FTPClientConfig getFtpClientConfig ( ) { return ftpClientConfig ; } public void setFtpClientConfig ( FTPClientConfig ftpClientConfig ) { this . ftpClientConfig = ftpClientConfig ; } public Expression getExpression ( ) { return expression ; } public void setExpression ( Expression expression ) { this . expression = expression ; } public void setExpression ( String fileLanguageExpression ) { this . expression = FileLanguage . file ( fileLanguageExpression ) ; } public boolean isPassiveMode ( ) { return passiveMode ; } public void setPassiveMode ( boolean passiveMode ) { this . passiveMode = passiveMode ; } public String getPrivateKeyFile ( ) { return privateKeyFile ; } public void setPrivateKeyFile ( String privateKeyFile ) { this . privateKeyFile = privateKeyFile ; } public String getPrivateKeyFilePassphrase ( ) { return privateKeyFilePassphrase ; } public void setPrivateKeyFilePassphrase ( String privateKeyFilePassphrase ) { this . privateKeyFilePassphrase = privateKeyFilePassphrase ; } } 	0	['36', '1', '0', '16', '52', '562', '12', '4', '35', '0.932653061', '271', '1', '1', '0', '0.21031746', '0', '0', '6.138888889', '3', '1.0833', '0']
package org . apache . camel . component . jhc ; import java . io . IOException ; import java . io . InterruptedIOException ; import java . net . InetSocketAddress ; import java . net . SocketAddress ; import java . util . concurrent . ThreadFactory ; import javax . net . ssl . SSLContext ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . http . impl . nio . DefaultServerIOEventDispatch ; import org . apache . http . impl . nio . reactor . DefaultListeningIOReactor ; import org . apache . http . impl . nio . reactor . SSLServerIOEventDispatch ; import org . apache . http . nio . reactor . IOEventDispatch ; import org . apache . http . nio . reactor . IOReactorException ; import org . apache . http . nio . reactor . ListeningIOReactor ; import org . apache . http . params . HttpParams ; import org . apache . http . protocol . HttpRequestHandlerRegistry ; public class JhcServerEngine { private static final Log LOG = LogFactory . getLog ( JhcServerEngine . class ) ; private final HttpParams params ; private int port ; private String protocol ; private int nbThreads = 2 ; private ListeningIOReactor ioReactor ; private ThreadFactory threadFactory ; private Thread runner ; private SSLContext sslContext ; private AsyncBufferingHttpServiceHandler serviceHandler ; private HttpRequestHandlerRegistry handlerRegistry ; private boolean isStarted ; private int referenceCounter ; JhcServerEngine ( HttpParams params , int port , String protocol ) { this . params = params ; serviceHandler = new AsyncBufferingHttpServiceHandler ( params ) ; handlerRegistry = new HttpRequestHandlerRegistry ( ) ; serviceHandler . setHandlerResolver ( handlerRegistry ) ; this . port = port ; this . protocol = protocol ; } public int getPort ( ) { return port ; } public String getProtocol ( ) { return this . protocol ; } public void setSslContext ( SSLContext sslContext ) { this . sslContext = sslContext ; } public SSLContext getSslContext ( ) { return this . sslContext ; } public synchronized void register ( String pattern , AsyncHttpRequestHandler handler ) { handlerRegistry . register ( pattern , handler ) ; referenceCounter ++ ; } public synchronized void unregister ( String pattern ) { handlerRegistry . unregister ( pattern ) ; referenceCounter -- ; } public int getReferenceCounter ( ) { return referenceCounter ; } public boolean isStarted ( ) { return isStarted ; } public void start ( ) throws IOReactorException { final SocketAddress addr = new InetSocketAddress ( port ) ; ioReactor = new DefaultListeningIOReactor ( nbThreads , threadFactory , params ) ; final IOEventDispatch ioEventDispatch ; if ( "https" . equals ( protocol ) ) { ioEventDispatch = new SSLServerIOEventDispatch ( serviceHandler , sslContext , params ) ; } else { ioEventDispatch = new DefaultServerIOEventDispatch ( serviceHandler , params ) ; } runner = new Thread ( ) { public void run ( ) { try { ioReactor . listen ( addr ) ; isStarted = true ; ioReactor . execute ( ioEventDispatch ) ; } catch ( InterruptedIOException ex ) { LOG . info ( "Interrupted" ) ; } catch ( IOException e ) { LOG . warn ( "I/O error: " + e . getMessage ( ) ) ; } LOG . debug ( "Shutdown" ) ; } } ; runner . start ( ) ; } public void stop ( ) throws IOException { LOG . debug ( "Stopping the jhc ioReactor " ) ; ioReactor . shutdown ( ) ; LOG . debug ( "Waiting the runner" ) ; try { runner . join ( ) ; } catch ( InterruptedException e ) { } isStarted = false ; LOG . debug ( "Runner stopped" ) ; } } 	0	['15', '1', '0', '18', '32', '61', '3', '16', '10', '0.89010989', '189', '1', '1', '0', '0.1875', '0', '0', '10.73333333', '1', '0.8667', '0']
package org . apache . camel . osgi ; import java . util . HashSet ; import java . util . Set ; import javax . xml . bind . JAXBContext ; import javax . xml . bind . JAXBException ; public class CamelNamespaceHandler extends org . apache . camel . spring . handler . CamelNamespaceHandler { public void init ( ) { super . init ( ) ; registerParser ( "camelContext" , new CamelContextBeanDefinitionParser ( CamelContextFactoryBean . class ) ) ; } protected JAXBContext createJaxbContext ( ) throws JAXBException { StringBuilder packages = new StringBuilder ( ) ; for ( Class cl : getJaxbPackages ( ) ) { if ( packages . length ( ) > 0 ) { packages . append ( ":" ) ; } packages . append ( cl . getName ( ) . substring ( 0 , cl . getName ( ) . lastIndexOf ( '.' ) ) ) ; } return JAXBContext . newInstance ( packages . toString ( ) , getClass ( ) . getClassLoader ( ) ) ; } protected Set < Class > getJaxbPackages ( ) { Set < Class > classes = new HashSet < Class > ( ) ; classes . add ( org . apache . camel . osgi . CamelContextFactoryBean . class ) ; classes . add ( org . apache . camel . spring . CamelContextFactoryBean . class ) ; classes . add ( org . apache . camel . model . RouteType . class ) ; classes . add ( org . apache . camel . model . config . StreamResequencerConfig . class ) ; classes . add ( org . apache . camel . model . dataformat . DataFormatType . class ) ; classes . add ( org . apache . camel . model . language . ExpressionType . class ) ; classes . add ( org . apache . camel . model . loadbalancer . LoadBalancerType . class ) ; return classes ; } } 	0	['4', '1', '0', '3', '23', '6', '0', '3', '2', '2', '93', '0', '0', '0.8125', '1', '1', '2', '22.25', '1', '0.75', '0']
package org . apache . camel . component . cxf . util ; import org . apache . cxf . endpoint . ConduitSelector ; import org . apache . cxf . endpoint . Endpoint ; import org . apache . cxf . message . Exchange ; import org . apache . cxf . message . Message ; import org . apache . cxf . transport . Conduit ; public class NullConduitSelector implements ConduitSelector { private Endpoint endpoint ; private NullConduit nullConduit ; public NullConduitSelector ( ) { nullConduit = new NullConduit ( ) ; } public void complete ( Exchange exchange ) { } public Endpoint getEndpoint ( ) { return endpoint ; } public void prepare ( Message message ) { } public Conduit selectConduit ( Message message ) { return nullConduit ; } public void setEndpoint ( Endpoint endpoint ) { this . endpoint = endpoint ; } } 	0	['6', '1', '0', '7', '8', '11', '1', '6', '6', '0.8', '28', '1', '1', '0', '0.416666667', '0', '0', '3.333333333', '1', '0.8333', '0']
package org . apache . camel . component . cxf . util ; import java . io . IOException ; import java . io . OutputStream ; import org . apache . cxf . io . CachedOutputStream ; import org . apache . cxf . message . Message ; import org . apache . cxf . transport . Conduit ; import org . apache . cxf . transport . Destination ; import org . apache . cxf . transport . MessageObserver ; import org . apache . cxf . ws . addressing . EndpointReferenceType ; public class NullConduit implements Conduit { public void close ( ) { } public void close ( Message message ) throws IOException { OutputStream outputStream = message . getContent ( OutputStream . class ) ; if ( outputStream != null ) { outputStream . close ( ) ; } } public Destination getBackChannel ( ) { return null ; } public EndpointReferenceType getTarget ( ) { return null ; } public void prepare ( Message message ) throws IOException { CachedOutputStream outputStream = new CachedOutputStream ( ) ; message . setContent ( OutputStream . class , outputStream ) ; } public void setMessageObserver ( MessageObserver observer ) { } } 	0	['7', '1', '0', '9', '12', '21', '3', '6', '7', '2', '35', '0', '0', '0', '0.476190476', '0', '0', '4', '1', '0.8571', '0']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "ognl" ) public class OgnlExpression extends ExpressionType { public OgnlExpression ( ) { } public OgnlExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "ognl" ; } } 	0	['3', '2', '0', '1', '5', '3', '0', '1', '3', '2', '12', '0', '0', '0.956521739', '0.666666667', '1', '2', '3', '1', '0.3333', '0']
package org . apache . camel . builder . script ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import org . apache . camel . language . LanguageAnnotation ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . PARAMETER } ) @ LanguageAnnotation ( language = "jruby" ) public @ interface Ruby { String value ( ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel ; public interface Service { void start ( ) throws Exception ; void stop ( ) throws Exception ; } 	0	['2', '1', '0', '23', '2', '1', '23', '0', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . restlet ; import java . io . IOException ; import java . util . Map ; import javax . xml . transform . dom . DOMSource ; import org . apache . camel . Exchange ; import org . apache . camel . HeaderFilterStrategyAware ; import org . apache . camel . Message ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . converter . jaxp . StringSource ; import org . apache . camel . spi . HeaderFilterStrategy ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . restlet . data . ChallengeResponse ; import org . restlet . data . ChallengeScheme ; import org . restlet . data . Form ; import org . restlet . data . MediaType ; import org . restlet . data . Parameter ; import org . restlet . data . Request ; import org . restlet . data . Response ; import org . restlet . data . Status ; public class DefaultRestletBinding implements RestletBinding , HeaderFilterStrategyAware { private static final Log LOG = LogFactory . getLog ( DefaultRestletBinding . class ) ; private HeaderFilterStrategy headerFilterStrategy ; public void populateExchangeFromRestletRequest ( Request request , Exchange exchange ) throws Exception { Message inMessage = exchange . getIn ( ) ; for ( Map . Entry < String , Object > entry : request . getAttributes ( ) . entrySet ( ) ) { if ( ! headerFilterStrategy . applyFilterToExternalHeaders ( entry . getKey ( ) , entry . getValue ( ) ) ) { inMessage . setHeader ( entry . getKey ( ) , entry . getValue ( ) ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Populate exchange from Restlet request header: " + entry . getKey ( ) + " value: " + entry . getValue ( ) ) ; } } } String query = request . getResourceRef ( ) . getQuery ( ) ; if ( null != query ) { inMessage . setHeader ( RestletConstants . QUERY_STRING , query ) ; } if ( ! request . isEntityAvailable ( ) ) { return ; } Form form = new Form ( request . getEntity ( ) ) ; if ( form != null ) { for ( Map . Entry < String , String > entry : form . getValuesMap ( ) . entrySet ( ) ) { if ( entry . getValue ( ) == null ) { inMessage . setBody ( entry . getKey ( ) ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Populate exchange from Restlet request body: " + entry . getValue ( ) ) ; } } else { if ( ! headerFilterStrategy . applyFilterToExternalHeaders ( entry . getKey ( ) , entry . getValue ( ) ) ) { inMessage . setHeader ( entry . getKey ( ) , entry . getValue ( ) ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Populate exchange from Restlet request user header: " + entry . getKey ( ) + " value: " + entry . getValue ( ) ) ; } } } } } } public void populateRestletRequestFromExchange ( Request request , Exchange exchange ) { request . setReferrerRef ( "camel-restlet" ) ; String body = exchange . getIn ( ) . getBody ( String . class ) ; Form form = new Form ( ) ; form . add ( body , null ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Populate Restlet request from exchange body: " + body ) ; } String login = ( String ) exchange . getIn ( ) . getHeader ( RestletConstants . LOGIN ) ; String password = ( String ) exchange . getIn ( ) . getHeader ( RestletConstants . PASSWORD ) ; if ( login != null && password != null ) { ChallengeResponse authentication = new ChallengeResponse ( ChallengeScheme . HTTP_BASIC , login , password ) ; request . setChallengeResponse ( authentication ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Basic HTTP Authentication has been applied" ) ; } } for ( Map . Entry < String , Object > entry : exchange . getIn ( ) . getHeaders ( ) . entrySet ( ) ) { if ( ! headerFilterStrategy . applyFilterToCamelHeaders ( entry . getKey ( ) , entry . getValue ( ) ) ) { if ( entry . getKey ( ) . startsWith ( "org.restlet." ) ) { request . getAttributes ( ) . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } else { form . add ( entry . getKey ( ) , entry . getValue ( ) . toString ( ) ) ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Populate Restlet request from exchange header: " + entry . getKey ( ) + " value: " + entry . getValue ( ) ) ; } } } request . setEntity ( form . getWebRepresentation ( ) ) ; } public void populateRestletResponseFromExchange ( Exchange exchange , Response response ) { Message out = exchange . getOut ( ) ; MediaType mediaType = out . getHeader ( RestletConstants . MEDIA_TYPE , MediaType . class ) ; if ( mediaType == null ) { Object body = out . getBody ( ) ; mediaType = MediaType . TEXT_PLAIN ; if ( body instanceof String ) { mediaType = MediaType . TEXT_PLAIN ; } else if ( body instanceof StringSource || body instanceof DOMSource ) { mediaType = MediaType . TEXT_XML ; } } Integer responseCode = out . getHeader ( RestletConstants . RESPONSE_CODE , Integer . class ) ; if ( responseCode != null ) { response . setStatus ( Status . valueOf ( responseCode ) ) ; } for ( Map . Entry < String , Object > entry : out . getHeaders ( ) . entrySet ( ) ) { if ( ! headerFilterStrategy . applyFilterToCamelHeaders ( entry . getKey ( ) , entry . getValue ( ) ) ) { response . getAttributes ( ) . put ( entry . getKey ( ) , entry . getValue ( ) ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Populate Restlet response from exchange header: " + entry . getKey ( ) + " value: " + entry . getValue ( ) ) ; } } } String text = out . getBody ( String . class ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Populate Restlet response from exchange body: " + text ) ; } response . setEntity ( text , mediaType ) ; } public void populateExchangeFromRestletResponse ( Exchange exchange , Response response ) throws IOException { for ( Map . Entry < String , Object > entry : response . getAttributes ( ) . entrySet ( ) ) { if ( ! headerFilterStrategy . applyFilterToExternalHeaders ( entry . getKey ( ) , entry . getValue ( ) ) ) { exchange . getOut ( ) . setHeader ( entry . getKey ( ) , entry . getValue ( ) ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Populate exchange from Restlet response header: " + entry . getKey ( ) + " value: " + entry . getValue ( ) ) ; } } } String text = response . getEntity ( ) . getText ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Populate exchange from Restlet response: " + text ) ; } if ( exchange . getPattern ( ) . isOutCapable ( ) ) { exchange . getOut ( ) . setBody ( text ) ; } else { throw new RuntimeCamelException ( "Exchange is incapable of receiving response: " + exchange ) ; } } public HeaderFilterStrategy getHeaderFilterStrategy ( ) { return headerFilterStrategy ; } public void setHeaderFilterStrategy ( HeaderFilterStrategy strategy ) { headerFilterStrategy = strategy ; } } 	0	['8', '1', '0', '20', '60', '0', '1', '19', '7', '0.357142857', '513', '1', '1', '0', '0.457142857', '0', '0', '62.875', '8', '2.375', '0']
package org . apache . camel . builder . sql ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Set ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Message ; import org . apache . camel . Predicate ; import org . apache . camel . RuntimeExpressionException ; import org . apache . camel . util . ObjectHelper ; import org . josql . Query ; import org . josql . QueryExecutionException ; import org . josql . QueryParseException ; public class SqlBuilder < E extends Exchange > implements Expression < E > , Predicate < E > { private Query query ; private Map < String , Object > variables = new HashMap < String , Object > ( ) ; public SqlBuilder ( Query query ) { this . query = query ; } public Object evaluate ( E exchange ) { return evaluateQuery ( exchange ) ; } public boolean matches ( E exchange ) { List list = evaluateQuery ( exchange ) ; return matches ( exchange , list ) ; } public void assertMatches ( String text , E exchange ) throws AssertionError { List list = evaluateQuery ( exchange ) ; if ( ! matches ( exchange , list ) ) { throw new AssertionError ( this + " failed on " + exchange + " as found " + list ) ; } } public static < E extends Exchange > SqlBuilder < E > sql ( String sql ) throws QueryParseException { Query q = new Query ( ) ; q . parse ( sql ) ; return new SqlBuilder ( q ) ; } public SqlBuilder < E > variable ( String name , Object value ) { getVariables ( ) . put ( name , value ) ; return this ; } public Map < String , Object > getVariables ( ) { return variables ; } public void setVariables ( Map < String , Object > properties ) { this . variables = properties ; } protected boolean matches ( E exchange , List list ) { return ObjectHelper . matches ( list ) ; } protected List evaluateQuery ( E exchange ) { configureQuery ( exchange ) ; Message in = exchange . getIn ( ) ; List list = in . getBody ( List . class ) ; if ( list == null ) { list = Collections . singletonList ( in . getBody ( ) ) ; } try { return query . execute ( list ) . getResults ( ) ; } catch ( QueryExecutionException e ) { throw new RuntimeExpressionException ( e ) ; } } protected void configureQuery ( E exchange ) { addVariables ( exchange . getProperties ( ) ) ; addVariables ( exchange . getIn ( ) . getHeaders ( ) ) ; addVariables ( getVariables ( ) ) ; query . setVariable ( "exchange" , exchange ) ; query . setVariable ( "in" , exchange . getIn ( ) ) ; query . setVariable ( "out" , exchange . getOut ( ) ) ; } protected void addVariables ( Map < String , Object > map ) { Set < Map . Entry < String , Object > > propertyEntries = map . entrySet ( ) ; for ( Map . Entry < String , Object > entry : propertyEntries ) { query . setVariable ( entry . getKey ( ) , entry . getValue ( ) ) ; } } } 	0	['14', '1', '0', '10', '42', '73', '0', '10', '10', '0.461538462', '192', '1', '0', '0', '0.306122449', '0', '0', '12.57142857', '2', '1.0714', '0']
package org . apache . camel . component . quartz ; import org . apache . camel . CamelContext ; import org . quartz . JobExecutionContext ; import org . quartz . JobExecutionException ; import org . quartz . SchedulerContext ; import org . quartz . SchedulerException ; import org . quartz . StatefulJob ; public class StatefulCamelJob implements StatefulJob { public void execute ( final JobExecutionContext context ) throws JobExecutionException { SchedulerContext schedulerContext ; try { schedulerContext = context . getScheduler ( ) . getContext ( ) ; } catch ( SchedulerException e ) { throw new JobExecutionException ( "Failed to obtain scheduler context for job " + context . getJobDetail ( ) . getName ( ) ) ; } CamelContext camelContext = ( CamelContext ) schedulerContext . get ( QuartzEndpoint . CONTEXT_KEY ) ; String endpointUri = ( String ) context . getJobDetail ( ) . getJobDataMap ( ) . get ( QuartzEndpoint . ENDPOINT_KEY ) ; QuartzEndpoint quartzEndpoint = ( QuartzEndpoint ) camelContext . getEndpoint ( endpointUri ) ; quartzEndpoint . onJobExecute ( context ) ; } } 	0	['2', '1', '0', '11', '16', '1', '0', '11', '2', '2', '46', '0', '0', '0', '0.75', '0', '0', '22', '1', '0.5', '0']
package org . apache . camel . converter . jaxb ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAnyElement ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "property" ) @ XmlAccessorType ( value = XmlAccessType . FIELD ) public class PropertyType { @ XmlAttribute private String key ; @ XmlAnyElement ( lax = true ) private Object value ; public String getKey ( ) { return key ; } public void setKey ( String key ) { this . key = key ; } public Object getValue ( ) { return value ; } public void setValue ( Object value ) { this . value = value ; } } 	0	['5', '1', '0', '0', '6', '6', '0', '0', '5', '0.75', '24', '1', '0', '0', '0.466666667', '0', '0', '3.4', '1', '0.8', '0']
package org . apache . camel . component . xslt ; import java . util . Map ; import javax . xml . transform . TransformerFactory ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . builder . xml . XsltBuilder ; import org . apache . camel . component . ResourceBasedComponent ; import org . apache . camel . converter . jaxp . XmlConverter ; import org . apache . camel . impl . ProcessorEndpoint ; import org . apache . camel . util . ObjectHelper ; import org . springframework . core . io . Resource ; public class XsltComponent extends ResourceBasedComponent { private XmlConverter xmlConverter ; public XmlConverter getXmlConverter ( ) { return xmlConverter ; } public void setXmlConverter ( XmlConverter xmlConverter ) { this . xmlConverter = xmlConverter ; } protected Endpoint < Exchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { Resource resource = resolveMandatoryResource ( remaining ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( this + " using schema resource: " + resource ) ; } XsltBuilder xslt = newInstance ( XsltBuilder . class ) ; XmlConverter converter = null ; String converterName = getAndRemoveParameter ( parameters , "converter" , String . class ) ; if ( converterName != null ) { converter = mandatoryLookup ( converterName , XmlConverter . class ) ; } if ( converter == null ) { converter = getXmlConverter ( ) ; } if ( converter != null ) { xslt . setConverter ( converter ) ; } String transformerFactoryClassName = getAndRemoveParameter ( parameters , "transformerFactoryClass" , String . class ) ; TransformerFactory factory = null ; if ( transformerFactoryClassName != null ) { Class factoryClass = ObjectHelper . loadClass ( transformerFactoryClassName ) ; if ( factoryClass != null ) { factory = ( TransformerFactory ) newInstance ( factoryClass ) ; } else { log . warn ( "Can't find the TransformerFactoryClass with the class name " + transformerFactoryClassName ) ; } } String transformerFactoryName = getAndRemoveParameter ( parameters , "transformerFactory" , String . class ) ; if ( transformerFactoryName != null ) { factory = mandatoryLookup ( transformerFactoryName , TransformerFactory . class ) ; } if ( factory != null ) { xslt . getConverter ( ) . setTransformerFactory ( factory ) ; } xslt . setTransformerInputStream ( resource . getInputStream ( ) ) ; configureXslt ( xslt , uri , remaining , parameters ) ; return new ProcessorEndpoint ( uri , this , xslt ) ; } protected void configureXslt ( XsltBuilder xslt , String uri , String remaining , Map parameters ) throws Exception { setProperties ( xslt , parameters ) ; } } 	0	['5', '4', '0', '10', '25', '8', '0', '10', '3', '0.5', '145', '1', '1', '0.904761905', '0.44', '2', '5', '27.8', '1', '0.8', '0']
package org . apache . camel . osgi ; import java . io . BufferedInputStream ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . net . URL ; import java . util . Enumeration ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Map ; import java . util . Properties ; import java . util . Set ; import java . util . StringTokenizer ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . osgi . framework . Bundle ; import org . osgi . framework . BundleActivator ; import org . osgi . framework . BundleContext ; import org . osgi . framework . BundleEvent ; import org . osgi . framework . SynchronousBundleListener ; import org . springframework . osgi . util . BundleDelegatingClassLoader ; public class Activator implements BundleActivator , SynchronousBundleListener { public static final String META_INF_TYPE_CONVERTER = "META-INF/services/org/apache/camel/TypeConverter" ; public static final String META_INF_COMPONENT = "META-INF/services/org/apache/camel/component/" ; public static final String META_INF_LANGUAGE = "META-INF/services/org/apache/camel/language/" ; private static final transient Log LOG = LogFactory . getLog ( Activator . class ) ; private static final Map < String , ComponentEntry > COMPONENTS = new HashMap < String , ComponentEntry > ( ) ; private static final Map < URL , TypeConverterEntry > TYPE_CONVERTERS = new HashMap < URL , TypeConverterEntry > ( ) ; private static final Map < String , ComponentEntry > LANGUAGES = new HashMap < String , ComponentEntry > ( ) ; private static Bundle bundle ; private class ComponentEntry { Bundle bundle ; String path ; String name ; Class type ; } private class TypeConverterEntry { Bundle bundle ; URL resource ; Set < String > converterPackages ; } public void bundleChanged ( BundleEvent event ) { try { Bundle bundle = event . getBundle ( ) ; if ( event . getType ( ) == BundleEvent . RESOLVED ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Bundle resolved: " + bundle . getSymbolicName ( ) ) ; } mayBeAddComponentAndLanguageFor ( bundle ) ; mayBeAddTypeConverterFor ( bundle ) ; } else if ( event . getType ( ) == BundleEvent . UNRESOLVED ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Bundle unresolved: " + bundle . getSymbolicName ( ) ) ; } mayBeRemoveComponentAndLanguageFor ( bundle ) ; mayBeRemoveTypeConverterFor ( bundle ) ; } } catch ( Throwable e ) { LOG . fatal ( "Exception handing bundle changed event" , e ) ; } } protected synchronized void addComponentEntry ( String entryPath , Bundle bundle , Map < String , ComponentEntry > entries ) { Enumeration e = bundle . getEntryPaths ( entryPath ) ; if ( e != null ) { while ( e . hasMoreElements ( ) ) { String path = ( String ) e . nextElement ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Found entry: " + path + " in bundle " + bundle . getSymbolicName ( ) ) ; } ComponentEntry entry = new ComponentEntry ( ) ; entry . bundle = bundle ; entry . path = path ; entry . name = path . substring ( path . lastIndexOf ( "/" ) + 1 ) ; entries . put ( entry . name , entry ) ; } } } protected void mayBeAddComponentAndLanguageFor ( Bundle bundle ) { addComponentEntry ( META_INF_COMPONENT , bundle , COMPONENTS ) ; addComponentEntry ( META_INF_LANGUAGE , bundle , LANGUAGES ) ; } protected synchronized void mayBeAddTypeConverterFor ( Bundle bundle ) { try { Enumeration e = bundle . getResources ( META_INF_TYPE_CONVERTER ) ; if ( e != null ) { while ( e . hasMoreElements ( ) ) { URL resource = ( URL ) e . nextElement ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Found entry: " + resource + " in bundle " + bundle . getSymbolicName ( ) ) ; } TypeConverterEntry entry = new TypeConverterEntry ( ) ; entry . bundle = bundle ; entry . resource = resource ; entry . converterPackages = getConverterPackages ( resource ) ; TYPE_CONVERTERS . put ( resource , entry ) ; } } } catch ( IOException ignore ) { } } protected void mayBeRemoveComponentAndLanguageFor ( Bundle bundle ) { removeComponentEntry ( bundle , COMPONENTS ) ; removeComponentEntry ( bundle , LANGUAGES ) ; } protected void removeComponentEntry ( Bundle bundle , Map < String , ComponentEntry > entries ) { ComponentEntry [ ] entriesArray = entries . values ( ) . toArray ( new ComponentEntry [ 0 ] ) ; for ( ComponentEntry entry : entriesArray ) { if ( entry . bundle == bundle ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Removing entry: " + entry . path + " in bundle " + bundle . getSymbolicName ( ) ) ; } entries . remove ( entry . name ) ; } } } protected synchronized void mayBeRemoveTypeConverterFor ( Bundle bundle ) { TypeConverterEntry [ ] entriesArray = TYPE_CONVERTERS . values ( ) . toArray ( new TypeConverterEntry [ 0 ] ) ; for ( TypeConverterEntry entry : entriesArray ) { if ( entry . bundle == bundle ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Removing entry: " + entry . resource + " in bundle " + bundle . getSymbolicName ( ) ) ; } COMPONENTS . remove ( entry . resource ) ; } } } public void start ( BundleContext context ) throws Exception { bundle = context . getBundle ( ) ; context . addBundleListener ( this ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "checking existing bundles" ) ; } for ( Bundle bundle : context . getBundles ( ) ) { if ( bundle . getState ( ) == Bundle . RESOLVED || bundle . getState ( ) == Bundle . STARTING || bundle . getState ( ) == Bundle . ACTIVE || bundle . getState ( ) == Bundle . STOPPING ) { mayBeAddComponentAndLanguageFor ( bundle ) ; mayBeAddTypeConverterFor ( bundle ) ; } } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "actived" ) ; } } public void stop ( BundleContext context ) throws Exception { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "removing the components of existing bundles" ) ; } for ( Bundle bundle : context . getBundles ( ) ) { if ( bundle . getState ( ) == Bundle . RESOLVED || bundle . getState ( ) == Bundle . STARTING || bundle . getState ( ) == Bundle . ACTIVE || bundle . getState ( ) == Bundle . STOPPING ) { mayBeRemoveComponentAndLanguageFor ( bundle ) ; mayBeRemoveTypeConverterFor ( bundle ) ; } } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "stopped" ) ; } } protected Set < String > getConverterPackages ( URL resource ) { Set < String > packages = new HashSet < String > ( ) ; if ( resource != null ) { BufferedReader reader = null ; try { reader = new BufferedReader ( new InputStreamReader ( resource . openStream ( ) ) ) ; while ( true ) { String line = reader . readLine ( ) ; if ( line == null ) { break ; } line = line . trim ( ) ; if ( line . startsWith ( "#" ) || line . length ( ) == 0 ) { continue ; } tokenize ( packages , line ) ; } } catch ( Exception ignore ) { } finally { if ( reader != null ) { ObjectHelper . close ( reader , null , LOG ) ; } } } return packages ; } protected void tokenize ( Set < String > packages , String line ) { StringTokenizer iter = new StringTokenizer ( line , "," ) ; while ( iter . hasMoreTokens ( ) ) { String name = iter . nextToken ( ) . trim ( ) ; if ( name . length ( ) > 0 ) { packages . add ( name ) ; } } } protected static Bundle getBundle ( ) { return bundle ; } protected static synchronized String [ ] findTypeConverterPackageNames ( ) { Set < String > packages = new HashSet < String > ( ) ; for ( TypeConverterEntry entry : TYPE_CONVERTERS . values ( ) ) { for ( String packageName : entry . converterPackages ) { packages . add ( packageName ) ; } } return packages . toArray ( new String [ packages . size ( ) ] ) ; } public static synchronized Class getComponent ( String name ) throws Exception { return getClassFromEntries ( name , COMPONENTS ) ; } public static synchronized Class getLanguage ( String name ) throws Exception { return getClassFromEntries ( name , LANGUAGES ) ; } protected static synchronized Class getClassFromEntries ( String name , Map < String , ComponentEntry > entries ) throws Exception { ComponentEntry entry = entries . get ( name ) ; if ( entry == null ) { return null ; } if ( entry . type == null ) { URL url = entry . bundle . getEntry ( entry . path ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "The entry " + name + "'s url is" + url ) ; } Properties properties = new Properties ( ) ; BufferedInputStream reader = null ; try { reader = new BufferedInputStream ( url . openStream ( ) ) ; properties . load ( reader ) ; } finally { try { if ( reader != null ) { reader . close ( ) ; } } catch ( Exception ignore ) { } } String classname = ( String ) properties . get ( "class" ) ; ClassLoader loader = BundleDelegatingClassLoader . createBundleClassLoaderFor ( entry . bundle ) ; entry . type = loader . loadClass ( classname ) ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Found entry: " + name + " via type: " + entry . type . getName ( ) ) ; } return entry . type ; } } 	0	['18', '1', '0', '17', '76', '31', '6', '13', '6', '0.779411765', '693', '0.625', '0', '0', '0.227941176', '0', '0', '37.05555556', '8', '2.1111', '0']
package org . apache . camel ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . PARAMETER } ) public @ interface Body { } 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . bam . processor ; import java . util . Date ; import java . util . List ; import javax . persistence . EntityManager ; import javax . persistence . LockModeType ; import javax . persistence . PersistenceException ; import org . apache . camel . bam . model . ActivityState ; import org . apache . camel . bam . rules . ProcessRules ; import org . apache . camel . impl . ServiceSupport ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . orm . jpa . JpaCallback ; import org . springframework . orm . jpa . JpaTemplate ; import org . springframework . transaction . TransactionStatus ; import org . springframework . transaction . support . TransactionCallbackWithoutResult ; import org . springframework . transaction . support . TransactionTemplate ; public class ActivityMonitorEngine extends ServiceSupport implements Runnable { private static final Log LOG = LogFactory . getLog ( ActivityMonitorEngine . class ) ; private JpaTemplate template ; private TransactionTemplate transactionTemplate ; private ProcessRules rules ; private int escalateLevel ; private long windowMillis = 1000L ; private Thread thread ; private boolean useLocking ; public ActivityMonitorEngine ( JpaTemplate template , TransactionTemplate transactionTemplate , ProcessRules rules ) { this . template = template ; this . transactionTemplate = transactionTemplate ; this . rules = rules ; } public boolean isUseLocking ( ) { return useLocking ; } public void setUseLocking ( boolean useLocking ) { this . useLocking = useLocking ; } public void run ( ) { LOG . debug ( "Starting to poll for timeout events" ) ; while ( ! isStopped ( ) ) { try { long now = System . currentTimeMillis ( ) ; long nextPoll = now + windowMillis ; final Date timeNow = new Date ( now ) ; transactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { protected void doInTransactionWithoutResult ( TransactionStatus status ) { List < ActivityState > list = template . find ( "select x from " + ActivityState . class . getName ( ) + " x where x.timeOverdue < ?1" , timeNow ) ; for ( ActivityState activityState : list ) { fireExpiredEvent ( activityState ) ; } } } ) ; long timeToSleep = nextPoll - System . currentTimeMillis ( ) ; if ( timeToSleep > 0 ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Sleeping for " + timeToSleep + " millis" ) ; } try { Thread . sleep ( timeToSleep ) ; } catch ( InterruptedException e ) { LOG . debug ( "Caught: " + e , e ) ; } } } catch ( Exception e ) { LOG . error ( "Caught: " + e , e ) ; } } } protected void fireExpiredEvent ( final ActivityState activityState ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Trying to fire expiration of: " + activityState ) ; } template . execute ( new JpaCallback ( ) { public Object doInJpa ( EntityManager entityManager ) throws PersistenceException { if ( isUseLocking ( ) ) { LOG . info ( "Attempting to lock: " + activityState ) ; entityManager . lock ( activityState , LockModeType . WRITE ) ; LOG . info ( "Grabbed lock: " + activityState ) ; } try { rules . processExpired ( activityState ) ; } catch ( Exception e ) { LOG . error ( "Failed to process expiration of: " + activityState + ". Reason: " + e , e ) ; } activityState . setTimeOverdue ( null ) ; return null ; } } ) ; } protected void doStart ( ) throws Exception { rules . start ( ) ; thread = new Thread ( this , "ActivityMonitorEngine" ) ; thread . start ( ) ; } protected void doStop ( ) throws Exception { if ( thread != null ) { thread = null ; } rules . stop ( ) ; } } 	0	['11', '2', '0', '12', '34', '21', '3', '11', '4', '0.8625', '180', '1', '1', '0.608695652', '0.2', '1', '1', '14.63636364', '3', '1.0909', '0']
package org . apache . camel ; public interface Expression < E extends Exchange > { Object evaluate ( E exchange ) ; } 	0	['1', '1', '0', '167', '1', '0', '166', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . converter ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . UnsupportedEncodingException ; import java . nio . ByteBuffer ; import org . apache . camel . Converter ; import org . apache . camel . Exchange ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; @ Converter public final class NIOConverter { private static final transient Log LOG = LogFactory . getLog ( NIOConverter . class ) ; private NIOConverter ( ) { } @ Converter public static byte [ ] toByteArray ( ByteBuffer buffer ) { return buffer . array ( ) ; } @ Converter public static String toString ( ByteBuffer buffer , Exchange exchange ) { return IOConverter . toString ( buffer . array ( ) , exchange ) ; } @ Converter public static ByteBuffer toByteBuffer ( byte [ ] data ) { return ByteBuffer . wrap ( data ) ; } @ Converter public static ByteBuffer toByteBuffer ( File file ) throws IOException { InputStream in = null ; try { byte [ ] buf = new byte [ ( int ) file . length ( ) ] ; in = new BufferedInputStream ( new FileInputStream ( file ) ) ; int sizeLeft = ( int ) file . length ( ) ; int offset = 0 ; while ( sizeLeft > 0 ) { int readSize = in . read ( buf , offset , sizeLeft ) ; sizeLeft -= readSize ; offset += readSize ; } return ByteBuffer . wrap ( buf ) ; } finally { try { if ( in != null ) { in . close ( ) ; } } catch ( IOException e ) { LOG . warn ( "Failed to close file stream: " + file . getPath ( ) , e ) ; } } } @ Converter public static ByteBuffer toByteBuffer ( String value , Exchange exchange ) { ByteBuffer buf = ByteBuffer . allocate ( value . length ( ) ) ; byte [ ] bytes = null ; if ( exchange != null ) { String charsetName = exchange . getProperty ( Exchange . CHARSET_NAME , String . class ) ; if ( charsetName != null ) { try { bytes = value . getBytes ( charsetName ) ; } catch ( UnsupportedEncodingException e ) { LOG . warn ( "Can't convert the byte to String with the charset " + charsetName , e ) ; } } } if ( bytes == null ) { bytes = value . getBytes ( ) ; } buf . put ( bytes ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Short value ) { ByteBuffer buf = ByteBuffer . allocate ( 2 ) ; buf . putShort ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Integer value ) { ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Long value ) { ByteBuffer buf = ByteBuffer . allocate ( 8 ) ; buf . putLong ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Float value ) { ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putFloat ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Double value ) { ByteBuffer buf = ByteBuffer . allocate ( 8 ) ; buf . putDouble ( value ) ; return buf ; } @ Converter public static InputStream toInputStream ( ByteBuffer bufferbuffer ) { return IOConverter . toInputStream ( toByteArray ( bufferbuffer ) ) ; } } 	0	['13', '1', '0', '7', '45', '72', '3', '4', '11', '0.833333333', '212', '1', '0', '0', '0.106060606', '0', '0', '15.23076923', '4', '1.0769', '0']
package org . apache . camel . component . jms ; import javax . jms . JMSException ; public class MessageJMSPropertyAccessException extends RuntimeJmsException { private static final long serialVersionUID = - 6744171518099741324L ; public MessageJMSPropertyAccessException ( JMSException e ) { super ( "Failed to access a JMS property: " + e , e ) ; } } 	0	['1', '5', '0', '2', '6', '0', '1', '1', '1', '2', '14', '1', '0', '1', '1', '0', '0', '12', '0', '0', '0']
package org . apache . camel . component . file . remote ; import java . io . OutputStream ; public class RemoteFileBinding { public Object extractBodyFromOutputStream ( RemoteFileExchange exchange , OutputStream outputStream ) { return outputStream ; } } 	0	['2', '1', '0', '3', '3', '1', '3', '1', '2', '2', '7', '0', '0', '0', '0.666666667', '0', '0', '2.5', '1', '0.5', '0']
package org . apache . camel . component . jhc ; import java . io . IOException ; import java . io . OutputStream ; import org . apache . http . ConnectionReuseStrategy ; import org . apache . http . HttpEntity ; import org . apache . http . HttpEntityEnclosingRequest ; import org . apache . http . HttpException ; import org . apache . http . HttpRequest ; import org . apache . http . HttpResponse ; import org . apache . http . HttpResponseFactory ; import org . apache . http . HttpStatus ; import org . apache . http . HttpVersion ; import org . apache . http . MethodNotSupportedException ; import org . apache . http . ProtocolException ; import org . apache . http . ProtocolVersion ; import org . apache . http . UnsupportedHttpVersionException ; import org . apache . http . entity . ByteArrayEntity ; import org . apache . http . nio . ContentDecoder ; import org . apache . http . nio . ContentEncoder ; import org . apache . http . nio . NHttpServerConnection ; import org . apache . http . nio . NHttpServiceHandler ; import org . apache . http . nio . entity . ContentBufferEntity ; import org . apache . http . nio . entity . ContentOutputStream ; import org . apache . http . nio . protocol . NHttpServiceHandlerBase ; import org . apache . http . nio . util . ByteBufferAllocator ; import org . apache . http . nio . util . ContentInputBuffer ; import org . apache . http . nio . util . ContentOutputBuffer ; import org . apache . http . nio . util . HeapByteBufferAllocator ; import org . apache . http . nio . util . SimpleInputBuffer ; import org . apache . http . nio . util . SimpleOutputBuffer ; import org . apache . http . params . HttpParams ; import org . apache . http . protocol . ExecutionContext ; import org . apache . http . protocol . HttpContext ; import org . apache . http . protocol . HttpProcessor ; import org . apache . http . protocol . HttpRequestHandler ; import org . apache . http . util . EncodingUtils ; public class BufferingHttpServiceHandler extends NHttpServiceHandlerBase implements NHttpServiceHandler { public BufferingHttpServiceHandler ( final HttpProcessor httpProcessor , final HttpResponseFactory responseFactory , final ConnectionReuseStrategy connStrategy , final ByteBufferAllocator allocator , final HttpParams params ) { super ( httpProcessor , responseFactory , connStrategy , allocator , params ) ; } public BufferingHttpServiceHandler ( final HttpProcessor httpProcessor , final HttpResponseFactory responseFactory , final ConnectionReuseStrategy connStrategy , final HttpParams params ) { this ( httpProcessor , responseFactory , connStrategy , new HeapByteBufferAllocator ( ) , params ) ; } public void connected ( final NHttpServerConnection conn ) { HttpContext context = conn . getContext ( ) ; ServerConnState connState = new ServerConnState ( allocator ) ; context . setAttribute ( CONN_STATE , connState ) ; if ( this . eventListener != null ) { this . eventListener . connectionOpen ( conn ) ; } } public void requestReceived ( final NHttpServerConnection conn ) { HttpContext context = conn . getContext ( ) ; HttpRequest request = conn . getHttpRequest ( ) ; request . setParams ( this . params ) ; ServerConnState connState = ( ServerConnState ) context . getAttribute ( CONN_STATE ) ; connState . resetInput ( ) ; connState . setRequest ( request ) ; connState . setInputState ( ServerConnState . REQUEST_RECEIVED ) ; ProtocolVersion ver = request . getRequestLine ( ) . getProtocolVersion ( ) ; if ( ! ver . lessEquals ( HttpVersion . HTTP_1_1 ) ) { ver = HttpVersion . HTTP_1_1 ; } HttpResponse response ; try { if ( request instanceof HttpEntityEnclosingRequest ) { if ( ( ( HttpEntityEnclosingRequest ) request ) . expectContinue ( ) ) { response = this . responseFactory . newHttpResponse ( ver , HttpStatus . SC_CONTINUE , context ) ; request . setParams ( this . params ) ; if ( this . expectationVerifier != null ) { try { this . expectationVerifier . verify ( request , response , context ) ; } catch ( HttpException ex ) { response = this . responseFactory . newHttpResponse ( HttpVersion . HTTP_1_0 , HttpStatus . SC_INTERNAL_SERVER_ERROR , context ) ; request . setParams ( this . params ) ; handleException ( ex , response ) ; } } if ( response . getStatusLine ( ) . getStatusCode ( ) < 200 ) { conn . submitResponse ( response ) ; } else { conn . resetInput ( ) ; connState . resetInput ( ) ; sendResponse ( conn , response ) ; } } } else { conn . suspendInput ( ) ; processRequest ( conn , request ) ; } } catch ( IOException ex ) { shutdownConnection ( conn , ex ) ; if ( this . eventListener != null ) { this . eventListener . fatalIOException ( ex , conn ) ; } } catch ( HttpException ex ) { closeConnection ( conn , ex ) ; if ( this . eventListener != null ) { this . eventListener . fatalProtocolException ( ex , conn ) ; } } } public void closed ( final NHttpServerConnection conn ) { if ( this . eventListener != null ) { this . eventListener . connectionClosed ( conn ) ; } } public void exception ( final NHttpServerConnection conn , final HttpException httpex ) { HttpContext context = conn . getContext ( ) ; try { HttpResponse response = this . responseFactory . newHttpResponse ( HttpVersion . HTTP_1_0 , HttpStatus . SC_INTERNAL_SERVER_ERROR , context ) ; response . setParams ( this . params ) ; handleException ( httpex , response ) ; response . setEntity ( null ) ; sendResponse ( conn , response ) ; } catch ( IOException ex ) { shutdownConnection ( conn , ex ) ; if ( this . eventListener != null ) { this . eventListener . fatalIOException ( ex , conn ) ; } } catch ( HttpException ex ) { closeConnection ( conn , ex ) ; if ( this . eventListener != null ) { this . eventListener . fatalProtocolException ( ex , conn ) ; } } } public void inputReady ( final NHttpServerConnection conn , final ContentDecoder decoder ) { HttpContext context = conn . getContext ( ) ; HttpRequest request = conn . getHttpRequest ( ) ; ServerConnState connState = ( ServerConnState ) context . getAttribute ( CONN_STATE ) ; ContentInputBuffer buffer = connState . getInbuffer ( ) ; connState . setInputState ( ServerConnState . REQUEST_BODY_STREAM ) ; try { buffer . consumeContent ( decoder ) ; if ( decoder . isCompleted ( ) ) { connState . setInputState ( ServerConnState . REQUEST_BODY_DONE ) ; HttpEntityEnclosingRequest entityReq = ( HttpEntityEnclosingRequest ) request ; if ( entityReq . getEntity ( ) != null ) { entityReq . setEntity ( new ContentBufferEntity ( entityReq . getEntity ( ) , connState . getInbuffer ( ) ) ) ; } conn . suspendInput ( ) ; processRequest ( conn , request ) ; } } catch ( IOException ex ) { shutdownConnection ( conn , ex ) ; if ( this . eventListener != null ) { this . eventListener . fatalIOException ( ex , conn ) ; } } catch ( HttpException ex ) { closeConnection ( conn , ex ) ; if ( this . eventListener != null ) { this . eventListener . fatalProtocolException ( ex , conn ) ; } } } public void responseReady ( final NHttpServerConnection conn ) { } public void outputReady ( final NHttpServerConnection conn , final ContentEncoder encoder ) { HttpContext context = conn . getContext ( ) ; HttpResponse response = conn . getHttpResponse ( ) ; ServerConnState connState = ( ServerConnState ) context . getAttribute ( CONN_STATE ) ; ContentOutputBuffer buffer = connState . getOutbuffer ( ) ; connState . setOutputState ( ServerConnState . RESPONSE_BODY_STREAM ) ; try { buffer . produceContent ( encoder ) ; if ( encoder . isCompleted ( ) ) { connState . setOutputState ( ServerConnState . RESPONSE_BODY_DONE ) ; connState . resetOutput ( ) ; if ( ! this . connStrategy . keepAlive ( response , context ) ) { conn . close ( ) ; } else { conn . requestInput ( ) ; } } } catch ( IOException ex ) { shutdownConnection ( conn , ex ) ; if ( this . eventListener != null ) { this . eventListener . fatalIOException ( ex , conn ) ; } } } protected void handleException ( final HttpException ex , final HttpResponse response ) { int code = HttpStatus . SC_INTERNAL_SERVER_ERROR ; if ( ex instanceof MethodNotSupportedException ) { code = HttpStatus . SC_NOT_IMPLEMENTED ; } else if ( ex instanceof UnsupportedHttpVersionException ) { code = HttpStatus . SC_HTTP_VERSION_NOT_SUPPORTED ; } else if ( ex instanceof ProtocolException ) { code = HttpStatus . SC_BAD_REQUEST ; } response . setStatusCode ( code ) ; byte [ ] msg = EncodingUtils . getAsciiBytes ( ex . getMessage ( ) ) ; ByteArrayEntity entity = new ByteArrayEntity ( msg ) ; entity . setContentType ( "text/plain; charset=US-ASCII" ) ; response . setEntity ( entity ) ; } protected void processRequest ( final NHttpServerConnection conn , final HttpRequest request ) throws IOException , HttpException { HttpContext context = conn . getContext ( ) ; ProtocolVersion ver = request . getRequestLine ( ) . getProtocolVersion ( ) ; if ( ! ver . lessEquals ( HttpVersion . HTTP_1_1 ) ) { ver = HttpVersion . HTTP_1_1 ; } HttpResponse response = this . responseFactory . newHttpResponse ( ver , HttpStatus . SC_OK , conn . getContext ( ) ) ; request . setParams ( this . params ) ; context . setAttribute ( ExecutionContext . HTTP_REQUEST , request ) ; context . setAttribute ( ExecutionContext . HTTP_CONNECTION , conn ) ; context . setAttribute ( ExecutionContext . HTTP_RESPONSE , response ) ; try { this . httpProcessor . process ( request , context ) ; HttpRequestHandler handler = null ; if ( this . handlerResolver != null ) { String requestURI = request . getRequestLine ( ) . getUri ( ) ; handler = this . handlerResolver . lookup ( requestURI ) ; } if ( handler != null ) { handler . handle ( request , response , context ) ; } else { response . setStatusCode ( HttpStatus . SC_NOT_IMPLEMENTED ) ; } } catch ( HttpException ex ) { response = this . responseFactory . newHttpResponse ( HttpVersion . HTTP_1_0 , HttpStatus . SC_INTERNAL_SERVER_ERROR , context ) ; request . setParams ( this . params ) ; handleException ( ex , response ) ; } sendResponse ( conn , response ) ; } protected void sendResponse ( final NHttpServerConnection conn , final HttpResponse response ) throws IOException , HttpException { HttpContext context = conn . getContext ( ) ; ServerConnState connState = ( ServerConnState ) context . getAttribute ( CONN_STATE ) ; ContentOutputBuffer buffer = connState . getOutbuffer ( ) ; this . httpProcessor . process ( response , context ) ; if ( ! canResponseHaveBody ( connState . getRequest ( ) , response ) ) { response . setEntity ( null ) ; } conn . submitResponse ( response ) ; connState . setOutputState ( ServerConnState . RESPONSE_SENT ) ; HttpEntity entity = response . getEntity ( ) ; if ( entity != null ) { OutputStream outstream = new ContentOutputStream ( buffer ) ; entity . writeTo ( outstream ) ; outstream . flush ( ) ; outstream . close ( ) ; } else { connState . resetOutput ( ) ; if ( ! this . connStrategy . keepAlive ( response , context ) ) { conn . close ( ) ; } else { conn . requestInput ( ) ; } } } static class ServerConnState { public static final int READY = 0 ; public static final int REQUEST_RECEIVED = 1 ; public static final int REQUEST_BODY_STREAM = 2 ; public static final int REQUEST_BODY_DONE = 4 ; public static final int RESPONSE_SENT = 8 ; public static final int RESPONSE_BODY_STREAM = 16 ; public static final int RESPONSE_BODY_DONE = 32 ; private SimpleInputBuffer inbuffer ; private ContentOutputBuffer outbuffer ; private int inputState ; private int outputState ; private HttpRequest request ; private final ByteBufferAllocator allocator ; public ServerConnState ( final ByteBufferAllocator allocator ) { super ( ) ; this . inputState = READY ; this . outputState = READY ; this . allocator = allocator ; } public ContentInputBuffer getInbuffer ( ) { if ( this . inbuffer == null ) { this . inbuffer = new SimpleInputBuffer ( 2048 , allocator ) ; } return this . inbuffer ; } public ContentOutputBuffer getOutbuffer ( ) { if ( this . outbuffer == null ) { this . outbuffer = new SimpleOutputBuffer ( 2048 , allocator ) ; } return this . outbuffer ; } public int getInputState ( ) { return this . inputState ; } public void setInputState ( int inputState ) { this . inputState = inputState ; } public int getOutputState ( ) { return this . outputState ; } public void setOutputState ( int outputState ) { this . outputState = outputState ; } public HttpRequest getRequest ( ) { return this . request ; } public void setRequest ( final HttpRequest request ) { this . request = request ; } public void resetInput ( ) { this . inbuffer = null ; this . request = null ; this . inputState = READY ; } public void resetOutput ( ) { this . outbuffer = null ; this . outputState = READY ; } } } 	0	['12', '0', '1', '37', '74', '28', '1', '36', '9', '2', '566', '0', '0', '0', '0.256944444', '0', '0', '46.16666667', '6', '2.0833', '0']
package org . apache . camel . component . jmx ; import javax . management . Notification ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; public class JMXExchange extends DefaultExchange { public JMXExchange ( CamelContext camelContext , ExchangePattern pattern , Notification notification ) { super ( camelContext , pattern ) ; setIn ( new JMXMessage ( notification ) ) ; } } 	0	['1', '2', '0', '7', '4', '0', '3', '5', '1', '2', '12', '0', '0', '1', '1', '0', '0', '11', '0', '0', '0']
package org . apache . camel . spi ; public interface Injector { < T > T newInstance ( Class < T > type ) ; } 	0	['1', '1', '0', '22', '1', '0', '22', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . mail ; import java . text . DateFormat ; import java . util . Date ; import javax . mail . Address ; import javax . mail . Message ; import javax . mail . MessagingException ; public final class MailUtils { public static final int DEFAULT_PORT_SMTP = 25 ; public static final int DEFAULT_PORT_SMTPS = 465 ; public static final int DEFAULT_PORT_POP3 = 110 ; public static final int DEFAULT_PORT_POP3S = 995 ; public static final int DEFAULT_PORT_NNTP = 119 ; public static final int DEFAULT_PORT_IMAP = 143 ; public static final int DEFAULT_PORT_IMAPS = 993 ; public static final String PROTOCOL_SMTP = "smtp" ; public static final String PROTOCOL_SMTPS = "smtps" ; public static final String PROTOCOL_POP3 = "pop3" ; public static final String PROTOCOL_POP3S = "pop3s" ; public static final String PROTOCOL_NNTP = "nntp" ; public static final String PROTOCOL_IMAP = "imap" ; public static final String PROTOCOL_IMAPS = "imaps" ; private MailUtils ( ) { } public static int getDefaultPortForProtocol ( final String protocol ) { int port = DEFAULT_PORT_SMTP ; if ( protocol != null ) { if ( protocol . equalsIgnoreCase ( PROTOCOL_IMAP ) ) { port = DEFAULT_PORT_IMAP ; } else if ( protocol . equalsIgnoreCase ( PROTOCOL_IMAPS ) ) { port = DEFAULT_PORT_IMAPS ; } else if ( protocol . equalsIgnoreCase ( PROTOCOL_NNTP ) ) { port = DEFAULT_PORT_NNTP ; } else if ( protocol . equalsIgnoreCase ( PROTOCOL_POP3 ) ) { port = DEFAULT_PORT_POP3 ; } else if ( protocol . equalsIgnoreCase ( PROTOCOL_POP3S ) ) { port = DEFAULT_PORT_POP3S ; } else if ( protocol . equalsIgnoreCase ( PROTOCOL_SMTP ) ) { port = DEFAULT_PORT_SMTP ; } else if ( protocol . equalsIgnoreCase ( PROTOCOL_SMTPS ) ) { port = DEFAULT_PORT_SMTPS ; } else { port = DEFAULT_PORT_SMTP ; } } return port ; } public static String dumpMessage ( Message message ) { try { StringBuilder sb = new StringBuilder ( ) ; int number = message . getMessageNumber ( ) ; sb . append ( "messageNumber=[" ) . append ( number ) . append ( "]" ) ; Address [ ] from = message . getFrom ( ) ; if ( from != null ) { for ( Address adr : from ) { sb . append ( ", from=[" ) . append ( adr ) . append ( "]" ) ; } } Address [ ] to = message . getRecipients ( Message . RecipientType . TO ) ; if ( to != null ) { for ( Address adr : to ) { sb . append ( ", to=[" ) . append ( adr ) . append ( "]" ) ; } } String subject = message . getSubject ( ) ; if ( subject != null ) { sb . append ( ", subject=[" ) . append ( subject ) . append ( "]" ) ; } Date sentDate = message . getSentDate ( ) ; if ( sentDate != null ) { sb . append ( ", sentDate=[" ) . append ( DateFormat . getDateTimeInstance ( ) . format ( sentDate ) ) . append ( "]" ) ; } Date receivedDate = message . getReceivedDate ( ) ; if ( receivedDate != null ) { sb . append ( ", receivedDate=[" ) . append ( DateFormat . getDateTimeInstance ( ) . format ( receivedDate ) ) . append ( "]" ) ; } return sb . toString ( ) ; } catch ( MessagingException e ) { return message . toString ( ) ; } } } 	0	['3', '1', '0', '4', '19', '3', '4', '0', '2', '1.5', '201', '0', '0', '0', '0.333333333', '0', '0', '61.33333333', '9', '5.6667', '0']
package org . apache . camel . component . uface . swing ; import java . awt . * ; import javax . swing . * ; import org . apache . camel . component . uface . UFaceBrowser ; import org . apache . camel . impl . DefaultCamelContext ; import org . apache . camel . spring . Main ; import org . ufacekit . ui . UIComposite ; import org . ufacekit . ui . swing . SwingComposite ; import org . ufacekit . ui . swing . SwingFactory ; import org . ufacekit . ui . swing . databinding . swing . SwingRealm ; public class SwingBrowser extends UFaceBrowser { static { SwingRealm . createDefault ( ) ; } public SwingBrowser ( DefaultCamelContext camelContext ) { super ( camelContext ) ; } public void run ( ) { JFrame frame = new JFrame ( ) ; frame . setTitle ( "Camel Browser" ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; Container container = frame . getContentPane ( ) ; UIComposite composite = new SwingComposite ( container , new SwingFactory ( ) . newFillLayout ( ) ) ; createBrowserUI ( composite ) ; frame . pack ( ) ; frame . setSize ( 650 , 500 ) ; frame . setVisible ( true ) ; } } 	0	['3', '2', '0', '8', '16', '3', '1', '7', '2', '2', '44', '0', '0', '0.875', '0.75', '0', '0', '13.66666667', '1', '0.3333', '0']
package org . apache . camel . component . jpa ; import java . util . Arrays ; import java . util . Collection ; import java . util . Map ; import java . util . Set ; import javax . persistence . EntityManager ; import javax . persistence . Query ; public abstract class QueryBuilder implements QueryFactory { ParameterBuilder parameterBuilder ; public static QueryBuilder query ( final String query ) { return new QueryBuilder ( ) { protected Query makeQueryObject ( EntityManager entityManager ) { return entityManager . createQuery ( query ) ; } @ Override public String toString ( ) { return "Query: " + query + " params: " + getParameterDescription ( ) ; } } ; } public static QueryBuilder namedQuery ( final String namedQuery ) { return new QueryBuilder ( ) { protected Query makeQueryObject ( EntityManager entityManager ) { return entityManager . createNamedQuery ( namedQuery ) ; } @ Override public String toString ( ) { return "Named: " + namedQuery + getParameterDescription ( ) ; } } ; } public static QueryBuilder nativeQuery ( final String nativeQuery ) { return new QueryBuilder ( ) { protected Query makeQueryObject ( EntityManager entityManager ) { return entityManager . createNativeQuery ( nativeQuery ) ; } @ Override public String toString ( ) { return "NativeQuery: " + nativeQuery + getParameterDescription ( ) ; } } ; } public QueryBuilder parameters ( Object ... parameters ) { return parameters ( Arrays . asList ( parameters ) ) ; } public QueryBuilder parameters ( final Collection parameters ) { checkNoParametersConfigured ( ) ; parameterBuilder = new ParameterBuilder ( ) { public void populateQuery ( EntityManager entityManager , Query query ) { int counter = 0 ; for ( Object parameter : parameters ) { query . setParameter ( counter ++ , parameter ) ; } } @ Override public String toString ( ) { return "Parameters: " + parameters ; } } ; return this ; } public QueryBuilder parameters ( final Map < String , Object > parameterMap ) { checkNoParametersConfigured ( ) ; parameterBuilder = new ParameterBuilder ( ) { public void populateQuery ( EntityManager entityManager , Query query ) { Set < Map . Entry < String , Object > > entries = parameterMap . entrySet ( ) ; for ( Map . Entry < String , Object > entry : entries ) { query . setParameter ( entry . getKey ( ) , entry . getValue ( ) ) ; } } @ Override public String toString ( ) { return "Parameters: " + parameterMap ; } } ; return this ; } protected void checkNoParametersConfigured ( ) { if ( parameterBuilder != null ) { throw new IllegalArgumentException ( "Cannot add parameters to a QueryBuilder which already has parameters configured" ) ; } } public Query createQuery ( EntityManager entityManager ) { Query query = makeQueryObject ( entityManager ) ; populateQuery ( entityManager , query ) ; return query ; } protected String getParameterDescription ( ) { if ( parameterBuilder == null ) { return "" ; } else { return " " + parameterBuilder . toString ( ) ; } } protected void populateQuery ( EntityManager entityManager , Query query ) { if ( parameterBuilder != null ) { parameterBuilder . populateQuery ( entityManager , query ) ; } } protected abstract Query makeQueryObject ( EntityManager entityManager ) ; protected abstract static class ParameterBuilder { public abstract void populateQuery ( EntityManager entityManager , Query query ) ; } } 	0	['12', '1', '3', '8', '25', '46', '6', '7', '8', '0.454545455', '102', '0', '1', '0', '0.226190476', '0', '0', '7.416666667', '2', '1.1667', '0']
package org . apache . camel . processor . interceptor ; import org . apache . camel . Exchange ; public class ExceptionEvent { private final DebugInterceptor interceptor ; private final Exchange exchange ; private final Throwable exception ; public ExceptionEvent ( DebugInterceptor interceptor , Exchange exchange , Throwable exception ) { this . interceptor = interceptor ; this . exchange = exchange ; this . exception = exception ; } public Throwable getException ( ) { return exception ; } public Exchange getExchange ( ) { return exchange ; } public DebugInterceptor getInterceptor ( ) { return interceptor ; } } 	0	['4', '1', '0', '2', '5', '0', '1', '2', '4', '0.666666667', '28', '1', '2', '0', '0.4375', '0', '0', '5.25', '1', '0.75', '0']
