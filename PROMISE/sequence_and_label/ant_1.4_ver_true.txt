package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . * ; import java . util . * ; import java . io . File ; public class PathConvert extends Task { public class MapEntry { public void setFrom ( String from ) { this . from = from ; } public void setTo ( String to ) { this . to = to ; } public String apply ( String elem ) { if ( from == null || to == null ) { throw new BuildException ( "Both 'from' and 'to' must be set in a map entry" ) ; } String cmpElem = onWindows ? elem . toLowerCase ( ) : elem ; String cmpFrom = onWindows ? from . toLowerCase ( ) : from ; if ( cmpElem . startsWith ( cmpFrom ) ) { int len = from . length ( ) ; if ( len >= elem . length ( ) ) { elem = to ; } else { elem = to + elem . substring ( len ) ; } } return elem ; } private String from = null ; private String to = null ; } public Path createPath ( ) { if ( isReference ( ) ) throw noChildrenAllowed ( ) ; if ( path == null ) { path = new Path ( getProject ( ) ) ; } return path . createPath ( ) ; } public MapEntry createMap ( ) { MapEntry entry = new MapEntry ( ) ; prefixMap . addElement ( entry ) ; return entry ; } public void setTargetos ( String target ) { targetOS = target . toLowerCase ( ) ; if ( ! targetOS . equals ( "windows" ) && ! target . equals ( "unix" ) ) { throw new BuildException ( "targetos must be one of 'unix' or 'windows'" ) ; } targetWindows = targetOS . equals ( "windows" ) ; } public void setProperty ( String p ) { property = p ; } public void setRefid ( Reference r ) { if ( path != null ) throw noChildrenAllowed ( ) ; refid = r ; } public void setPathSep ( String sep ) { pathSep = sep ; } public void setDirSep ( String sep ) { dirSep = sep ; } public boolean isReference ( ) { return refid != null ; } public void execute ( ) throws BuildException { if ( isReference ( ) ) { path = new Path ( getProject ( ) ) . createPath ( ) ; Object obj = refid . getReferencedObject ( getProject ( ) ) ; if ( obj instanceof Path ) { path . setRefid ( refid ) ; } else if ( obj instanceof FileSet ) { FileSet fs = ( FileSet ) obj ; path . addFileset ( fs ) ; } else { throw new BuildException ( "'refid' does not refer to a path or fileset" ) ; } } validateSetup ( ) ; String osname = System . getProperty ( "os.name" ) . toLowerCase ( ) ; onWindows = ( osname . indexOf ( "windows" ) >= 0 ) ; char fromDirSep = onWindows ? '\\' : '/' ; char toDirSep = dirSep . charAt ( 0 ) ; StringBuffer rslt = new StringBuffer ( 100 ) ; String [ ] elems = path . list ( ) ; for ( int i = 0 ; i < elems . length ; i ++ ) { String elem = elems [ i ] ; elem = mapElement ( elem ) ; elem = elem . replace ( fromDirSep , toDirSep ) ; if ( i != 0 ) rslt . append ( pathSep ) ; rslt . append ( elem ) ; } String value = rslt . toString ( ) ; log ( "Set property " + property + " = " + value , Project . MSG_VERBOSE ) ; getProject ( ) . setProperty ( property , value ) ; } private String mapElement ( String elem ) { int size = prefixMap . size ( ) ; if ( size != 0 ) { for ( int i = 0 ; i < size ; i ++ ) { MapEntry entry = ( MapEntry ) prefixMap . elementAt ( i ) ; String newElem = entry . apply ( elem ) ; if ( newElem != elem ) { elem = newElem ; break ; } } } return elem ; } private void validateSetup ( ) throws BuildException { if ( path == null ) throw new BuildException ( "You must specify a path to convert" ) ; if ( property == null ) throw new BuildException ( "You must specify a property" ) ; if ( targetOS == null && pathSep == null && dirSep == null ) throw new BuildException ( "You must specify at least one of targetOS, dirSep, or pathSep" ) ; String dsep = File . separator ; String psep = File . pathSeparator ; if ( targetOS != null ) { psep = targetWindows ? ";" : ":" ; dsep = targetWindows ? "\\" : "/" ; } if ( pathSep != null ) { psep = pathSep ; } if ( dirSep != null ) { dsep = dirSep ; } pathSep = psep ; dirSep = dsep ; } private BuildException noChildrenAllowed ( ) { return new BuildException ( "You must not specify nested PATH elements when using refid" ) ; } private Path path = null ; private Reference refid = null ; private String targetOS = null ; private boolean targetWindows = false ; private boolean onWindows = false ; private String property = null ; private Vector prefixMap = new Vector ( ) ; private String pathSep = null ; private String dirSep = null ; } 	0	['14', '3', '0', '8', '41', '33', '1', '8', '10', '0.760683761', '385', '1', '2', '0.74', '0.357142857', '1', '1', '25.85714286', '4', '1.5714', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . tar . * ; import java . io . * ; public class Untar extends Task { private File dest ; private File source ; private boolean overwrite = true ; public void execute ( ) throws BuildException { Touch touch = ( Touch ) project . createTask ( "touch" ) ; touch . setOwningTarget ( target ) ; touch . setTaskName ( getTaskName ( ) ) ; touch . setLocation ( getLocation ( ) ) ; File srcF = source ; TarInputStream tis = null ; try { if ( source == null ) { throw new BuildException ( "No source specified" , location ) ; } if ( ! srcF . exists ( ) ) { throw new BuildException ( "source " + srcF + " doesn't exist" , location ) ; } if ( dest == null ) { throw new BuildException ( "No destination specified" , location ) ; } File dir = dest ; log ( "Expanding: " + srcF + " into " + dir , Project . MSG_INFO ) ; tis = new TarInputStream ( new FileInputStream ( srcF ) ) ; TarEntry te = null ; while ( ( te = tis . getNextEntry ( ) ) != null ) { try { File f = new File ( dir , project . translatePath ( te . getName ( ) ) ) ; if ( ! overwrite && f . exists ( ) && f . lastModified ( ) >= te . getModTime ( ) . getTime ( ) ) { log ( "Skipping " + f + " as it is up-to-date" , Project . MSG_DEBUG ) ; continue ; } log ( "expanding " + te . getName ( ) + " to " + f , Project . MSG_VERBOSE ) ; File dirF = new File ( f . getParent ( ) ) ; dirF . mkdirs ( ) ; if ( te . isDirectory ( ) ) { f . mkdirs ( ) ; } else { byte [ ] buffer = new byte [ 1024 ] ; int length = 0 ; FileOutputStream fos = new FileOutputStream ( f ) ; while ( ( length = tis . read ( buffer ) ) >= 0 ) { fos . write ( buffer , 0 , length ) ; } fos . close ( ) ; } if ( project . getJavaVersion ( ) != Project . JAVA_1_1 ) { touch . setFile ( f ) ; touch . setMillis ( te . getModTime ( ) . getTime ( ) ) ; touch . touch ( ) ; } } catch ( FileNotFoundException ex ) { log ( "FileNotFoundException: " + te . getName ( ) , Project . MSG_WARN ) ; } } } catch ( IOException ioe ) { throw new BuildException ( "Error while expanding " + srcF . getPath ( ) , ioe , location ) ; } finally { if ( tis != null ) { try { tis . close ( ) ; } catch ( IOException e ) { } } } } public void setDest ( File d ) { this . dest = d ; } public void setSrc ( File s ) { this . source = s ; } public void setOverwrite ( boolean b ) { overwrite = b ; } } 	0	['5', '3', '0', '9', '43', '0', '0', '9', '5', '0.666666667', '276', '1', '0', '0.902439024', '0.533333333', '2', '3', '53.6', '1', '0.8', '0']
package org . apache . tools . ant . taskdefs ; import java . io . InputStream ; import java . io . IOException ; import java . io . OutputStream ; public class PumpStreamHandler implements ExecuteStreamHandler { private Thread inputThread ; private Thread errorThread ; private OutputStream out , err ; public PumpStreamHandler ( OutputStream out , OutputStream err ) { this . out = out ; this . err = err ; } public PumpStreamHandler ( OutputStream outAndErr ) { this ( outAndErr , outAndErr ) ; } public PumpStreamHandler ( ) { this ( System . out , System . err ) ; } public void setProcessOutputStream ( InputStream is ) { createProcessOutputPump ( is , out ) ; } public void setProcessErrorStream ( InputStream is ) { createProcessErrorPump ( is , err ) ; } public void setProcessInputStream ( OutputStream os ) { } public void start ( ) { inputThread . start ( ) ; errorThread . start ( ) ; } public void stop ( ) { try { inputThread . join ( ) ; } catch ( InterruptedException e ) { } try { errorThread . join ( ) ; } catch ( InterruptedException e ) { } try { err . flush ( ) ; } catch ( IOException e ) { } try { out . flush ( ) ; } catch ( IOException e ) { } } protected OutputStream getErr ( ) { return err ; } protected OutputStream getOut ( ) { return out ; } protected void createProcessOutputPump ( InputStream is , OutputStream os ) { inputThread = createPump ( is , os ) ; } protected void createProcessErrorPump ( InputStream is , OutputStream os ) { errorThread = createPump ( is , os ) ; } protected Thread createPump ( InputStream is , OutputStream os ) { final Thread result = new Thread ( new StreamPumper ( is , os ) ) ; result . setDaemon ( true ) ; return result ; } } 	0	['13', '1', '1', '8', '20', '46', '6', '2', '8', '0.666666667', '111', '1', '0', '0', '0.615384615', '0', '0', '7.230769231', '1', '0.7692', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import java . util . * ; import org . apache . tools . ant . * ; public class Copydir extends MatchingTask { private File srcDir ; private File destDir ; private boolean filtering = false ; private boolean flatten = false ; private boolean forceOverwrite = false ; private Hashtable filecopyList = new Hashtable ( ) ; public void setSrc ( File src ) { srcDir = src ; } public void setDest ( File dest ) { destDir = dest ; } public void setFiltering ( boolean filter ) { filtering = filter ; } public void setFlatten ( boolean flatten ) { this . flatten = flatten ; } public void setForceoverwrite ( boolean force ) { forceOverwrite = force ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The copydir task is deprecated.  Use copy instead." ) ; if ( srcDir == null ) { throw new BuildException ( "src attribute must be set!" , location ) ; } if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir " + srcDir . toString ( ) + " does not exist!" , location ) ; } if ( destDir == null ) { throw new BuildException ( "The dest attribute must be set." , location ) ; } if ( srcDir . equals ( destDir ) ) { log ( "Warning: src == dest" ) ; } DirectoryScanner ds = super . getDirectoryScanner ( srcDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( srcDir , destDir , files ) ; if ( filecopyList . size ( ) > 0 ) { log ( "Copying " + filecopyList . size ( ) + " file" + ( filecopyList . size ( ) == 1 ? "" : "s" ) + " to " + destDir . getAbsolutePath ( ) ) ; Enumeration enum = filecopyList . keys ( ) ; while ( enum . hasMoreElements ( ) ) { String fromFile = ( String ) enum . nextElement ( ) ; String toFile = ( String ) filecopyList . get ( fromFile ) ; try { project . copyFile ( fromFile , toFile , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } } } } private void scanDir ( File from , File to , String [ ] files ) { for ( int i = 0 ; i < files . length ; i ++ ) { String filename = files [ i ] ; File srcFile = new File ( from , filename ) ; File destFile ; if ( flatten ) { destFile = new File ( to , new File ( filename ) . getName ( ) ) ; } else { destFile = new File ( to , filename ) ; } if ( forceOverwrite || ( srcFile . lastModified ( ) > destFile . lastModified ( ) ) ) { filecopyList . put ( srcFile . getAbsolutePath ( ) , destFile . getAbsolutePath ( ) ) ; } } } } 	0	['8', '4', '0', '7', '35', '4', '0', '7', '7', '0.714285714', '265', '1', '0', '0.917647059', '0.46875', '3', '3', '31.375', '5', '1.375', '0']
package org . apache . tools . tar ; import java . io . * ; import java . util . * ; public class TarEntry implements TarConstants { private StringBuffer name ; private int mode ; private int userId ; private int groupId ; private long size ; private long modTime ; private int checkSum ; private byte linkFlag ; private StringBuffer linkName ; private StringBuffer magic ; private StringBuffer userName ; private StringBuffer groupName ; private int devMajor ; private int devMinor ; private File file ; private TarEntry ( ) { this . magic = new StringBuffer ( TMAGIC ) ; this . name = new StringBuffer ( ) ; this . linkName = new StringBuffer ( ) ; String user = System . getProperty ( "user.name" , "" ) ; if ( user . length ( ) > 31 ) { user = user . substring ( 0 , 31 ) ; } this . userId = 0 ; this . groupId = 0 ; this . userName = new StringBuffer ( user ) ; this . groupName = new StringBuffer ( "" ) ; this . file = null ; } public TarEntry ( String name ) { this ( ) ; boolean isDir = name . endsWith ( "/" ) ; this . checkSum = 0 ; this . devMajor = 0 ; this . devMinor = 0 ; this . name = new StringBuffer ( name ) ; this . mode = isDir ? 040755 : 0100644 ; this . linkFlag = isDir ? LF_DIR : LF_NORMAL ; this . userId = 0 ; this . groupId = 0 ; this . size = 0 ; this . checkSum = 0 ; this . modTime = ( new Date ( ) ) . getTime ( ) / 1000 ; this . linkName = new StringBuffer ( "" ) ; this . userName = new StringBuffer ( "" ) ; this . groupName = new StringBuffer ( "" ) ; this . devMajor = 0 ; this . devMinor = 0 ; } public TarEntry ( String name , byte linkFlag ) { this ( name ) ; this . linkFlag = linkFlag ; } public TarEntry ( File file ) { this ( ) ; this . file = file ; String name = file . getPath ( ) ; String osname = System . getProperty ( "os.name" ) ; if ( osname != null ) { String Win32Prefix = "Windows" ; String prefix = osname . substring ( 0 , Win32Prefix . length ( ) ) ; if ( prefix . equalsIgnoreCase ( Win32Prefix ) ) { if ( name . length ( ) > 2 ) { char ch1 = name . charAt ( 0 ) ; char ch2 = name . charAt ( 1 ) ; if ( ch2 == ':' && ( ( ch1 >= 'a' && ch1 <= 'z' ) || ( ch1 >= 'A' && ch1 <= 'Z' ) ) ) { name = name . substring ( 2 ) ; } } } } name = name . replace ( File . separatorChar , '/' ) ; while ( name . startsWith ( "/" ) ) { name = name . substring ( 1 ) ; } this . linkName = new StringBuffer ( "" ) ; this . name = new StringBuffer ( name ) ; if ( file . isDirectory ( ) ) { this . mode = 040755 ; this . linkFlag = LF_DIR ; if ( this . name . charAt ( this . name . length ( ) - 1 ) != '/' ) { this . name . append ( "/" ) ; } } else { this . mode = 0100644 ; this . linkFlag = LF_NORMAL ; } this . size = file . length ( ) ; this . modTime = file . lastModified ( ) / 1000 ; this . checkSum = 0 ; this . devMajor = 0 ; this . devMinor = 0 ; } public TarEntry ( byte [ ] headerBuf ) { this ( ) ; this . parseTarHeader ( headerBuf ) ; } public boolean equals ( TarEntry it ) { return this . getName ( ) . equals ( it . getName ( ) ) ; } public boolean isDescendent ( TarEntry desc ) { return desc . getName ( ) . startsWith ( this . getName ( ) ) ; } public String getName ( ) { return this . name . toString ( ) ; } public void setName ( String name ) { this . name = new StringBuffer ( name ) ; } public void setMode ( int mode ) { this . mode = mode ; } public int getUserId ( ) { return this . userId ; } public void setUserId ( int userId ) { this . userId = userId ; } public int getGroupId ( ) { return this . groupId ; } public void setGroupId ( int groupId ) { this . groupId = groupId ; } public String getUserName ( ) { return this . userName . toString ( ) ; } public void setUserName ( String userName ) { this . userName = new StringBuffer ( userName ) ; } public String getGroupName ( ) { return this . groupName . toString ( ) ; } public void setGroupName ( String groupName ) { this . groupName = new StringBuffer ( groupName ) ; } public void setIds ( int userId , int groupId ) { this . setUserId ( userId ) ; this . setGroupId ( groupId ) ; } public void setNames ( String userName , String groupName ) { this . setUserName ( userName ) ; this . setGroupName ( groupName ) ; } public void setModTime ( long time ) { this . modTime = time / 1000 ; } public void setModTime ( Date time ) { this . modTime = time . getTime ( ) / 1000 ; } public Date getModTime ( ) { return new Date ( this . modTime * 1000 ) ; } public File getFile ( ) { return this . file ; } public long getSize ( ) { return this . size ; } public void setSize ( long size ) { this . size = size ; } public boolean isGNULongNameEntry ( ) { return linkFlag == LF_GNUTYPE_LONGNAME && name . toString ( ) . equals ( GNU_LONGLINK ) ; } public boolean isDirectory ( ) { if ( this . file != null ) { return this . file . isDirectory ( ) ; } if ( this . linkFlag == LF_DIR ) { return true ; } if ( this . getName ( ) . endsWith ( "/" ) ) { return true ; } return false ; } public TarEntry [ ] getDirectoryEntries ( ) { if ( this . file == null || ! this . file . isDirectory ( ) ) { return new TarEntry [ 0 ] ; } String [ ] list = this . file . list ( ) ; TarEntry [ ] result = new TarEntry [ list . length ] ; for ( int i = 0 ; i < list . length ; ++ i ) { result [ i ] = new TarEntry ( new File ( this . file , list [ i ] ) ) ; } return result ; } public void writeEntryHeader ( byte [ ] outbuf ) { int offset = 0 ; offset = TarUtils . getNameBytes ( this . name , outbuf , offset , NAMELEN ) ; offset = TarUtils . getOctalBytes ( this . mode , outbuf , offset , MODELEN ) ; offset = TarUtils . getOctalBytes ( this . userId , outbuf , offset , UIDLEN ) ; offset = TarUtils . getOctalBytes ( this . groupId , outbuf , offset , GIDLEN ) ; offset = TarUtils . getLongOctalBytes ( this . size , outbuf , offset , SIZELEN ) ; offset = TarUtils . getLongOctalBytes ( this . modTime , outbuf , offset , MODTIMELEN ) ; int csOffset = offset ; for ( int c = 0 ; c < CHKSUMLEN ; ++ c ) { outbuf [ offset ++ ] = ( byte ) ' ' ; } outbuf [ offset ++ ] = this . linkFlag ; offset = TarUtils . getNameBytes ( this . linkName , outbuf , offset , NAMELEN ) ; offset = TarUtils . getNameBytes ( this . magic , outbuf , offset , MAGICLEN ) ; offset = TarUtils . getNameBytes ( this . userName , outbuf , offset , UNAMELEN ) ; offset = TarUtils . getNameBytes ( this . groupName , outbuf , offset , GNAMELEN ) ; offset = TarUtils . getOctalBytes ( this . devMajor , outbuf , offset , DEVLEN ) ; offset = TarUtils . getOctalBytes ( this . devMinor , outbuf , offset , DEVLEN ) ; while ( offset < outbuf . length ) { outbuf [ offset ++ ] = 0 ; } long checkSum = TarUtils . computeCheckSum ( outbuf ) ; TarUtils . getCheckSumOctalBytes ( checkSum , outbuf , csOffset , CHKSUMLEN ) ; } public void parseTarHeader ( byte [ ] header ) { int offset = 0 ; this . name = TarUtils . parseName ( header , offset , NAMELEN ) ; offset += NAMELEN ; this . mode = ( int ) TarUtils . parseOctal ( header , offset , MODELEN ) ; offset += MODELEN ; this . userId = ( int ) TarUtils . parseOctal ( header , offset , UIDLEN ) ; offset += UIDLEN ; this . groupId = ( int ) TarUtils . parseOctal ( header , offset , GIDLEN ) ; offset += GIDLEN ; this . size = TarUtils . parseOctal ( header , offset , SIZELEN ) ; offset += SIZELEN ; this . modTime = TarUtils . parseOctal ( header , offset , MODTIMELEN ) ; offset += MODTIMELEN ; this . checkSum = ( int ) TarUtils . parseOctal ( header , offset , CHKSUMLEN ) ; offset += CHKSUMLEN ; this . linkFlag = header [ offset ++ ] ; this . linkName = TarUtils . parseName ( header , offset , NAMELEN ) ; offset += NAMELEN ; this . magic = TarUtils . parseName ( header , offset , MAGICLEN ) ; offset += MAGICLEN ; this . userName = TarUtils . parseName ( header , offset , UNAMELEN ) ; offset += UNAMELEN ; this . groupName = TarUtils . parseName ( header , offset , GNAMELEN ) ; offset += GNAMELEN ; this . devMajor = ( int ) TarUtils . parseOctal ( header , offset , DEVLEN ) ; offset += DEVLEN ; this . devMinor = ( int ) TarUtils . parseOctal ( header , offset , DEVLEN ) ; } } 	0	['31', '1', '0', '6', '65', '243', '4', '2', '30', '0.726666667', '747', '1', '0', '0', '0.182795699', '1', '1', '22.61290323', '4', '1.1613', '0']
package org . apache . tools . tar ; import java . io . * ; public class TarOutputStream extends FilterOutputStream { static public final int LONGFILE_ERROR = 0 ; static public final int LONGFILE_TRUNCATE = 1 ; static public final int LONGFILE_GNU = 2 ; protected boolean debug ; protected int currSize ; protected int currBytes ; protected byte [ ] oneBuf ; protected byte [ ] recordBuf ; protected int assemLen ; protected byte [ ] assemBuf ; protected TarBuffer buffer ; protected int longFileMode = LONGFILE_ERROR ; public TarOutputStream ( OutputStream os ) { this ( os , TarBuffer . DEFAULT_BLKSIZE , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarOutputStream ( OutputStream os , int blockSize ) { this ( os , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarOutputStream ( OutputStream os , int blockSize , int recordSize ) { super ( os ) ; this . buffer = new TarBuffer ( os , blockSize , recordSize ) ; this . debug = false ; this . assemLen = 0 ; this . assemBuf = new byte [ recordSize ] ; this . recordBuf = new byte [ recordSize ] ; this . oneBuf = new byte [ 1 ] ; } public void setLongFileMode ( int longFileMode ) { this . longFileMode = longFileMode ; } public void setDebug ( boolean debugF ) { this . debug = debugF ; } public void setBufferDebug ( boolean debug ) { this . buffer . setDebug ( debug ) ; } public void finish ( ) throws IOException { this . writeEOFRecord ( ) ; } public void close ( ) throws IOException { this . finish ( ) ; this . buffer . close ( ) ; } public int getRecordSize ( ) { return this . buffer . getRecordSize ( ) ; } public void putNextEntry ( TarEntry entry ) throws IOException { if ( entry . getName ( ) . length ( ) >= TarConstants . NAMELEN ) { if ( longFileMode == LONGFILE_GNU ) { TarEntry longLinkEntry = new TarEntry ( TarConstants . GNU_LONGLINK , TarConstants . LF_GNUTYPE_LONGNAME ) ; longLinkEntry . setSize ( entry . getName ( ) . length ( ) + 1 ) ; putNextEntry ( longLinkEntry ) ; write ( entry . getName ( ) . getBytes ( ) ) ; write ( 0 ) ; closeEntry ( ) ; } else if ( longFileMode != LONGFILE_TRUNCATE ) { throw new RuntimeException ( "file name '" + entry . getName ( ) + "' is too long ( > " + TarConstants . NAMELEN + " bytes)" ) ; } } entry . writeEntryHeader ( this . recordBuf ) ; this . buffer . writeRecord ( this . recordBuf ) ; this . currBytes = 0 ; if ( entry . isDirectory ( ) ) { this . currSize = 0 ; } else { this . currSize = ( int ) entry . getSize ( ) ; } } public void closeEntry ( ) throws IOException { if ( this . assemLen > 0 ) { for ( int i = this . assemLen ; i < this . assemBuf . length ; ++ i ) { this . assemBuf [ i ] = 0 ; } this . buffer . writeRecord ( this . assemBuf ) ; this . currBytes += this . assemLen ; this . assemLen = 0 ; } if ( this . currBytes < this . currSize ) { throw new IOException ( "entry closed at '" + this . currBytes + "' before the '" + this . currSize + "' bytes specified in the header were written" ) ; } } public void write ( int b ) throws IOException { this . oneBuf [ 0 ] = ( byte ) b ; this . write ( this . oneBuf , 0 , 1 ) ; } public void write ( byte [ ] wBuf ) throws IOException { this . write ( wBuf , 0 , wBuf . length ) ; } public void write ( byte [ ] wBuf , int wOffset , int numToWrite ) throws IOException { if ( ( this . currBytes + numToWrite ) > this . currSize ) { throw new IOException ( "request to write '" + numToWrite + "' bytes exceeds size in header of '" + this . currSize + "' bytes" ) ; } if ( this . assemLen > 0 ) { if ( ( this . assemLen + numToWrite ) >= this . recordBuf . length ) { int aLen = this . recordBuf . length - this . assemLen ; System . arraycopy ( this . assemBuf , 0 , this . recordBuf , 0 , this . assemLen ) ; System . arraycopy ( wBuf , wOffset , this . recordBuf , this . assemLen , aLen ) ; this . buffer . writeRecord ( this . recordBuf ) ; this . currBytes += this . recordBuf . length ; wOffset += aLen ; numToWrite -= aLen ; this . assemLen = 0 ; } else { System . arraycopy ( wBuf , wOffset , this . assemBuf , this . assemLen , numToWrite ) ; wOffset += numToWrite ; this . assemLen += numToWrite ; numToWrite -= numToWrite ; } } while ( numToWrite > 0 ) { if ( numToWrite < this . recordBuf . length ) { System . arraycopy ( wBuf , wOffset , this . assemBuf , this . assemLen , numToWrite ) ; this . assemLen += numToWrite ; break ; } this . buffer . writeRecord ( wBuf , wOffset ) ; int num = this . recordBuf . length ; this . currBytes += num ; numToWrite -= num ; wOffset += num ; } } private void writeEOFRecord ( ) throws IOException { for ( int i = 0 ; i < this . recordBuf . length ; ++ i ) { this . recordBuf [ i ] = 0 ; } this . buffer . writeRecord ( this . recordBuf ) ; } } 	0	['15', '3', '0', '3', '37', '41', '1', '2', '14', '0.696428571', '437', '0.75', '1', '0.454545455', '0.311111111', '1', '2', '27.33333333', '1', '0.8', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; public class JikesOutputParser implements ExecuteStreamHandler { protected Task task ; protected boolean errorFlag = false ; protected int errors , warnings ; protected boolean error = false ; protected boolean emacsMode ; protected BufferedReader br ; public void setProcessInputStream ( OutputStream os ) { } public void setProcessErrorStream ( InputStream is ) { } public void setProcessOutputStream ( InputStream is ) throws IOException { br = new BufferedReader ( new InputStreamReader ( is ) ) ; } public void start ( ) throws IOException { parseOutput ( br ) ; } public void stop ( ) { } protected JikesOutputParser ( Task task , boolean emacsMode ) { super ( ) ; this . task = task ; this . emacsMode = emacsMode ; } protected void parseOutput ( BufferedReader reader ) throws IOException { if ( emacsMode ) parseEmacsOutput ( reader ) ; else parseStandardOutput ( reader ) ; } private void parseStandardOutput ( BufferedReader reader ) throws IOException { String line ; String lower ; while ( ( line = reader . readLine ( ) ) != null ) { lower = line . toLowerCase ( ) ; if ( line . trim ( ) . equals ( "" ) ) continue ; if ( lower . indexOf ( "error" ) != - 1 ) setError ( true ) ; else if ( lower . indexOf ( "warning" ) != - 1 ) setError ( false ) ; else { if ( emacsMode ) setError ( true ) ; } log ( line ) ; } } private void parseEmacsOutput ( BufferedReader reader ) throws IOException { parseStandardOutput ( reader ) ; } private void setError ( boolean err ) { error = err ; if ( error ) errorFlag = true ; } private void log ( String line ) { if ( ! emacsMode ) { task . log ( "" , ( error ? Project . MSG_ERR : Project . MSG_WARN ) ) ; } task . log ( line , ( error ? Project . MSG_ERR : Project . MSG_WARN ) ) ; } protected boolean getErrorFlag ( ) { return errorFlag ; } } 	0	['12', '1', '0', '3', '21', '44', '1', '2', '5', '0.805194805', '147', '1', '1', '0', '0.261904762', '0', '0', '10.66666667', '4', '1.25', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . * ; public class Sj extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using symantec java compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupJavacCommand ( ) ; cmd . setExecutable ( "sj" ) ; int firstFileName = cmd . size ( ) - compileList . length ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } } 	0	['2', '2', '0', '6', '9', '1', '1', '5', '2', '2', '33', '0', '0', '0.958333333', '1', '0', '0', '15.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import java . util . Enumeration ; import java . util . Properties ; import java . io . File ; import java . io . FileInputStream ; import org . apache . tools . ant . * ; public class Filter extends Task { private String token ; private String value ; private File filtersFile ; public void setToken ( String token ) { this . token = token ; } public void setValue ( String value ) { this . value = value ; } public void setFiltersfile ( File filtersFile ) { this . filtersFile = filtersFile ; } public void execute ( ) throws BuildException { boolean isFiltersFromFile = filtersFile != null && token == null && value == null ; boolean isSingleFilter = filtersFile == null && token != null && value != null ; if ( ! isFiltersFromFile && ! isSingleFilter ) { throw new BuildException ( "both token and value parameters, or only a filtersFile parameter is required" , location ) ; } if ( isSingleFilter ) { project . getGlobalFilterSet ( ) . addFilter ( token , value ) ; } if ( isFiltersFromFile ) { readFilters ( ) ; } } protected void readFilters ( ) throws BuildException { log ( "Reading filters from " + filtersFile , Project . MSG_VERBOSE ) ; project . getGlobalFilterSet ( ) . readFiltersFromFile ( filtersFile ) ; } } 	0	['6', '3', '0', '6', '16', '5', '0', '6', '5', '0.733333333', '95', '1', '0', '0.880952381', '0.5', '0', '0', '14.33333333', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . EnumeratedAttribute ; import java . io . * ; public class Echo extends Task { protected String message = "" ; protected File file = null ; protected boolean append = false ; protected int logLevel = Project . MSG_WARN ; public void execute ( ) throws BuildException { if ( file == null ) { log ( message , logLevel ) ; } else { FileWriter out = null ; try { out = new FileWriter ( file . getAbsolutePath ( ) , append ) ; out . write ( message , 0 , message . length ( ) ) ; } catch ( IOException ioe ) { throw new BuildException ( ioe , location ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( IOException ioex ) { } } } } } public void setMessage ( String msg ) { this . message = msg ; } public void setFile ( File file ) { this . file = file ; } public void setAppend ( boolean append ) { this . append = append ; } public void addText ( String msg ) { message += ProjectHelper . replaceProperties ( project , msg , project . getProperties ( ) ) ; } public void setLevel ( EchoLevel echoLevel ) { String option = echoLevel . getValue ( ) ; if ( option . equals ( "error" ) ) { logLevel = Project . MSG_ERR ; } else if ( option . equals ( "warning" ) ) { logLevel = Project . MSG_WARN ; } else if ( option . equals ( "info" ) ) { logLevel = Project . MSG_INFO ; } else if ( option . equals ( "verbose" ) ) { logLevel = Project . MSG_VERBOSE ; } else { logLevel = Project . MSG_DEBUG ; } } public static class EchoLevel extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "error" , "warning" , "info" , "verbose" , "debug" } ; } } } 	0	['7', '3', '0', '8', '22', '0', '0', '8', '7', '0.625', '147', '1', '0', '0.860465116', '0.342857143', '1', '1', '19.42857143', '5', '1.4286', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . util . * ; import java . text . * ; import java . lang . RuntimeException ; public class Parallel extends Task implements TaskContainer { private Vector nestedTasks = new Vector ( ) ; public void addTask ( Task nestedTask ) throws BuildException { nestedTasks . addElement ( nestedTask ) ; } public void execute ( ) throws BuildException { TaskThread [ ] threads = new TaskThread [ nestedTasks . size ( ) ] ; int threadNumber = 0 ; for ( Enumeration e = nestedTasks . elements ( ) ; e . hasMoreElements ( ) ; threadNumber ++ ) { Task nestedTask = ( Task ) e . nextElement ( ) ; threads [ threadNumber ] = new TaskThread ( threadNumber , nestedTask ) ; } for ( int i = 0 ; i < threads . length ; ++ i ) { threads [ i ] . start ( ) ; } for ( int i = 0 ; i < threads . length ; ++ i ) { try { threads [ i ] . join ( ) ; } catch ( InterruptedException ie ) { } } StringBuffer exceptionMessage = new StringBuffer ( ) ; String lSep = System . getProperty ( "line.separator" ) ; int numExceptions = 0 ; Throwable firstException = null ; Location firstLocation = Location . UNKNOWN_LOCATION ; ; for ( int i = 0 ; i < threads . length ; ++ i ) { Throwable t = threads [ i ] . getException ( ) ; if ( t != null ) { numExceptions ++ ; if ( firstException == null ) { firstException = t ; } if ( t instanceof BuildException && firstLocation == Location . UNKNOWN_LOCATION ) { firstLocation = ( ( BuildException ) t ) . getLocation ( ) ; } exceptionMessage . append ( lSep ) ; exceptionMessage . append ( t . getMessage ( ) ) ; } } if ( numExceptions == 1 ) { if ( firstException instanceof BuildException ) { throw ( BuildException ) firstException ; } else { throw new BuildException ( firstException ) ; } } else if ( numExceptions > 1 ) { throw new BuildException ( exceptionMessage . toString ( ) , firstLocation ) ; } } class TaskThread extends Thread { private Throwable exception ; private Task task ; private int taskNumber ; TaskThread ( int taskNumber , Task task ) { this . task = task ; this . taskNumber = taskNumber ; } public void run ( ) { try { task . perform ( ) ; } catch ( Throwable t ) { exception = t ; } } public Throwable getException ( ) { return exception ; } } } 	0	['3', '3', '0', '5', '22', '0', '1', '5', '3', '0', '149', '1', '0', '0.948717949', '0.666666667', '0', '0', '48.33333333', '1', '0.6667', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import java . io . File ; import java . util . Vector ; import java . util . StringTokenizer ; public class Commandline implements Cloneable { private Vector arguments = new Vector ( ) ; private String executable = null ; public Commandline ( String to_process ) { super ( ) ; String [ ] tmp = translateCommandline ( to_process ) ; if ( tmp != null && tmp . length > 0 ) { setExecutable ( tmp [ 0 ] ) ; for ( int i = 1 ; i < tmp . length ; i ++ ) { createArgument ( ) . setValue ( tmp [ i ] ) ; } } } public Commandline ( ) { super ( ) ; } public class Argument { private String [ ] parts ; public void setValue ( String value ) { parts = new String [ ] { value } ; } public void setLine ( String line ) { parts = translateCommandline ( line ) ; } public void setPath ( Path value ) { parts = new String [ ] { value . toString ( ) } ; } public void setFile ( File value ) { parts = new String [ ] { value . getAbsolutePath ( ) } ; } public String [ ] getParts ( ) { return parts ; } } public class Marker { private int position ; private int realPos = - 1 ; Marker ( int position ) { this . position = position ; } public int getPosition ( ) { if ( realPos == - 1 ) { realPos = ( executable == null ? 0 : 1 ) ; for ( int i = 0 ; i < position ; i ++ ) { Argument arg = ( Argument ) arguments . elementAt ( i ) ; realPos += arg . getParts ( ) . length ; } } return realPos ; } } public Argument createArgument ( ) { Argument argument = new Argument ( ) ; arguments . addElement ( argument ) ; return argument ; } public void setExecutable ( String executable ) { if ( executable == null || executable . length ( ) == 0 ) return ; this . executable = executable . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; } public String getExecutable ( ) { return executable ; } public void addArguments ( String [ ] line ) { for ( int i = 0 ; i < line . length ; i ++ ) { createArgument ( ) . setValue ( line [ i ] ) ; } } public String [ ] getCommandline ( ) { final String [ ] args = getArguments ( ) ; if ( executable == null ) return args ; final String [ ] result = new String [ args . length + 1 ] ; result [ 0 ] = executable ; System . arraycopy ( args , 0 , result , 1 , args . length ) ; return result ; } public String [ ] getArguments ( ) { Vector result = new Vector ( arguments . size ( ) * 2 ) ; for ( int i = 0 ; i < arguments . size ( ) ; i ++ ) { Argument arg = ( Argument ) arguments . elementAt ( i ) ; String [ ] s = arg . getParts ( ) ; for ( int j = 0 ; j < s . length ; j ++ ) { result . addElement ( s [ j ] ) ; } } String [ ] res = new String [ result . size ( ) ] ; result . copyInto ( res ) ; return res ; } public String toString ( ) { return toString ( getCommandline ( ) ) ; } public static String quoteArgument ( String argument ) { if ( argument . indexOf ( "\"" ) > - 1 ) { if ( argument . indexOf ( "\'" ) > - 1 ) { throw new BuildException ( "Can\'t handle single and double quotes in same argument" ) ; } else { return '\'' + argument + '\'' ; } } else if ( argument . indexOf ( "\'" ) > - 1 || argument . indexOf ( " " ) > - 1 ) { return '\"' + argument + '\"' ; } else { return argument ; } } public static String toString ( String [ ] line ) { if ( line == null || line . length == 0 ) return "" ; final StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < line . length ; i ++ ) { if ( i > 0 ) { result . append ( ' ' ) ; } result . append ( quoteArgument ( line [ i ] ) ) ; } return result . toString ( ) ; } public static String [ ] translateCommandline ( String to_process ) { if ( to_process == null || to_process . length ( ) == 0 ) { return new String [ 0 ] ; } final int normal = 0 ; final int inQuote = 1 ; final int inDoubleQuote = 2 ; int state = normal ; StringTokenizer tok = new StringTokenizer ( to_process , "\"\' " , true ) ; Vector v = new Vector ( ) ; StringBuffer current = new StringBuffer ( ) ; while ( tok . hasMoreTokens ( ) ) { String nextTok = tok . nextToken ( ) ; switch ( state ) { case inQuote : if ( "\'" . equals ( nextTok ) ) { state = normal ; } else { current . append ( nextTok ) ; } break ; case inDoubleQuote : if ( "\"" . equals ( nextTok ) ) { state = normal ; } else { current . append ( nextTok ) ; } break ; default : if ( "\'" . equals ( nextTok ) ) { state = inQuote ; } else if ( "\"" . equals ( nextTok ) ) { state = inDoubleQuote ; } else if ( " " . equals ( nextTok ) ) { if ( current . length ( ) != 0 ) { v . addElement ( current . toString ( ) ) ; current . setLength ( 0 ) ; } } else { current . append ( nextTok ) ; } break ; } } if ( current . length ( ) != 0 ) { v . addElement ( current . toString ( ) ) ; } if ( state == inQuote || state == inDoubleQuote ) { throw new BuildException ( "unbalanced quotes in " + to_process ) ; } String [ ] args = new String [ v . size ( ) ] ; v . copyInto ( args ) ; return args ; } public int size ( ) { return getCommandline ( ) . length ; } public Object clone ( ) { Commandline c = new Commandline ( ) ; c . setExecutable ( executable ) ; c . addArguments ( getArguments ( ) ) ; return c ; } public void clear ( ) { executable = null ; arguments . removeAllElements ( ) ; } public void clearArgs ( ) { arguments . removeAllElements ( ) ; } public Marker createMarker ( ) { return new Marker ( arguments . size ( ) ) ; } } 	0	['19', '1', '0', '30', '46', '65', '29', '3', '17', '0.416666667', '448', '1', '0', '0', '0.289473684', '0', '0', '22.47368421', '16', '2.4211', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import java . io . OutputStream ; import java . io . InputStream ; import java . io . IOException ; public class LogStreamHandler extends PumpStreamHandler { public LogStreamHandler ( Task task , int outlevel , int errlevel ) { super ( new LogOutputStream ( task , outlevel ) , new LogOutputStream ( task , errlevel ) ) ; } public void stop ( ) { super . stop ( ) ; try { getErr ( ) . close ( ) ; getOut ( ) . close ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } } 	0	['2', '2', '0', '10', '9', '1', '6', '4', '2', '2', '31', '0', '0', '0.923076923', '0.666666667', '0', '0', '14.5', '1', '0.5', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . PathTokenizer ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . util . Stack ; import java . util . Vector ; import java . text . CharacterIterator ; import java . text . StringCharacterIterator ; public class Path extends DataType implements Cloneable { private Vector elements ; private Project project ; public static Path systemClasspath = new Path ( null , System . getProperty ( "java.class.path" ) ) ; public class PathElement { private String [ ] parts ; public void setLocation ( File loc ) { parts = new String [ ] { translateFile ( loc . getAbsolutePath ( ) ) } ; } public void setPath ( String path ) { parts = Path . translatePath ( project , path ) ; } public String [ ] getParts ( ) { return parts ; } } public Path ( Project p , String path ) { this ( p ) ; createPathElement ( ) . setPath ( path ) ; } public Path ( Project project ) { this . project = project ; elements = new Vector ( ) ; } public void setProject ( Project p ) { this . project = p ; } public Project getProject ( ) { return project ; } public void setLocation ( File location ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createPathElement ( ) . setLocation ( location ) ; } public void setPath ( String path ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createPathElement ( ) . setPath ( path ) ; } public void setRefid ( Reference r ) throws BuildException { if ( ! elements . isEmpty ( ) ) { throw tooManyAttributes ( ) ; } elements . addElement ( r ) ; super . setRefid ( r ) ; } public PathElement createPathElement ( ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } PathElement pe = new PathElement ( ) ; elements . addElement ( pe ) ; return pe ; } public void addFileset ( FileSet fs ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } elements . addElement ( fs ) ; checked = false ; } public Path createPath ( ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } Path p = new Path ( project ) ; elements . addElement ( p ) ; checked = false ; return p ; } public void append ( Path other ) { if ( other == null ) return ; String [ ] l = other . list ( ) ; for ( int i = 0 ; i < l . length ; i ++ ) { if ( elements . indexOf ( l [ i ] ) == - 1 ) { elements . addElement ( l [ i ] ) ; } } } public void addExisting ( Path source ) { String [ ] list = source . list ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { File f = null ; if ( project != null ) { f = project . resolveFile ( list [ i ] ) ; } else { f = new File ( list [ i ] ) ; } if ( f . exists ( ) ) { setLocation ( f ) ; } } } public String [ ] list ( ) { if ( ! checked ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , project ) ; } Vector result = new Vector ( 2 * elements . size ( ) ) ; for ( int i = 0 ; i < elements . size ( ) ; i ++ ) { Object o = elements . elementAt ( i ) ; if ( o instanceof Reference ) { Reference r = ( Reference ) o ; o = r . getReferencedObject ( project ) ; if ( ! ( o instanceof Path ) ) { String msg = r . getRefId ( ) + " doesn\'t denote a path" ; throw new BuildException ( msg ) ; } } if ( o instanceof String ) { addUnlessPresent ( result , ( String ) o ) ; } else if ( o instanceof PathElement ) { String [ ] parts = ( ( PathElement ) o ) . getParts ( ) ; if ( parts == null ) { throw new BuildException ( "You must either set location or path on <pathelement>" ) ; } for ( int j = 0 ; j < parts . length ; j ++ ) { addUnlessPresent ( result , parts [ j ] ) ; } } else if ( o instanceof Path ) { Path p = ( Path ) o ; if ( p . getProject ( ) == null ) { p . setProject ( project ) ; } String [ ] parts = p . list ( ) ; for ( int j = 0 ; j < parts . length ; j ++ ) { addUnlessPresent ( result , parts [ j ] ) ; } } else if ( o instanceof FileSet ) { FileSet fs = ( FileSet ) o ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; String [ ] s = ds . getIncludedFiles ( ) ; File dir = fs . getDir ( project ) ; for ( int j = 0 ; j < s . length ; j ++ ) { File f = new File ( dir , s [ j ] ) ; String absolutePath = f . getAbsolutePath ( ) ; addUnlessPresent ( result , translateFile ( absolutePath ) ) ; } } } String [ ] res = new String [ result . size ( ) ] ; result . copyInto ( res ) ; return res ; } public String toString ( ) { final String [ ] list = list ( ) ; if ( list . length == 0 ) return "" ; final StringBuffer result = new StringBuffer ( list [ 0 ] . toString ( ) ) ; for ( int i = 1 ; i < list . length ; i ++ ) { result . append ( File . pathSeparatorChar ) ; result . append ( list [ i ] ) ; } return result . toString ( ) ; } public static String [ ] translatePath ( Project project , String source ) { final Vector result = new Vector ( ) ; if ( source == null ) return new String [ 0 ] ; PathTokenizer tok = new PathTokenizer ( source ) ; StringBuffer element = new StringBuffer ( ) ; while ( tok . hasMoreTokens ( ) ) { element . setLength ( 0 ) ; String pathElement = tok . nextToken ( ) ; try { element . append ( resolveFile ( project , pathElement ) ) ; } catch ( BuildException e ) { project . log ( "Dropping path element " + pathElement + " as it is not valid relative to the project" , Project . MSG_VERBOSE ) ; } for ( int i = 0 ; i < element . length ( ) ; i ++ ) { translateFileSep ( element , i ) ; } result . addElement ( element . toString ( ) ) ; } String [ ] res = new String [ result . size ( ) ] ; result . copyInto ( res ) ; return res ; } public static String translateFile ( String source ) { if ( source == null ) return "" ; final StringBuffer result = new StringBuffer ( source ) ; for ( int i = 0 ; i < result . length ( ) ; i ++ ) { translateFileSep ( result , i ) ; } return result . toString ( ) ; } protected static boolean translateFileSep ( StringBuffer buffer , int pos ) { if ( buffer . charAt ( pos ) == '/' || buffer . charAt ( pos ) == '\\' ) { buffer . setCharAt ( pos , File . separatorChar ) ; return true ; } return false ; } public int size ( ) { return list ( ) . length ; } public Object clone ( ) { Path p = new Path ( project ) ; p . append ( this ) ; return p ; } protected void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( checked ) { return ; } Enumeration enum = elements . elements ( ) ; while ( enum . hasMoreElements ( ) ) { Object o = enum . nextElement ( ) ; if ( o instanceof Reference ) { o = ( ( Reference ) o ) . getReferencedObject ( p ) ; } if ( o instanceof DataType ) { if ( stk . contains ( o ) ) { throw circularReference ( ) ; } else { stk . push ( o ) ; ( ( DataType ) o ) . dieOnCircularReference ( stk , p ) ; stk . pop ( ) ; } } } checked = true ; } private static String resolveFile ( Project project , String relativeName ) { if ( project != null ) { File f = project . resolveFile ( relativeName ) ; return f . getAbsolutePath ( ) ; } return relativeName ; } private static void addUnlessPresent ( Vector v , String s ) { if ( v . indexOf ( s ) == - 1 ) { v . addElement ( s ) ; } } public Path concatSystemClasspath ( ) { return concatSystemClasspath ( "last" ) ; } public Path concatSystemClasspath ( String defValue ) { Path result = new Path ( project ) ; String order = defValue ; if ( project != null ) { String o = project . getProperty ( "build.sysclasspath" ) ; if ( o != null ) { order = o ; } } if ( order . equals ( "only" ) ) { result . addExisting ( Path . systemClasspath ) ; } else if ( order . equals ( "first" ) ) { result . addExisting ( Path . systemClasspath ) ; result . addExisting ( this ) ; } else if ( order . equals ( "ignore" ) ) { result . addExisting ( this ) ; } else { if ( ! order . equals ( "last" ) ) { project . log ( "invalid value for build.sysclasspath: " + order , Project . MSG_WARN ) ; } result . addExisting ( this ) ; result . addExisting ( Path . systemClasspath ) ; } return result ; } } 	0	['26', '3', '0', '33', '80', '201', '26', '8', '20', '0.573333333', '719', '0.666666667', '2', '0.566037736', '0.152727273', '2', '11', '26.53846154', '14', '2.2692', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . util . * ; import java . text . * ; import java . lang . RuntimeException ; public class Sequential extends Task implements TaskContainer { private Vector nestedTasks = new Vector ( ) ; public void addTask ( Task nestedTask ) { nestedTasks . addElement ( nestedTask ) ; } public void execute ( ) throws BuildException { for ( Enumeration e = nestedTasks . elements ( ) ; e . hasMoreElements ( ) ; ) { Task nestedTask = ( Task ) e . nextElement ( ) ; nestedTask . perform ( ) ; } } } 	0	['3', '3', '0', '3', '10', '0', '0', '3', '3', '0', '32', '1', '0', '0.948717949', '0.666666667', '0', '0', '9.333333333', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . * ; import java . io . File ; public class Gcj extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { Commandline cmd ; attributes . log ( "Using gcj compiler" , Project . MSG_VERBOSE ) ; cmd = setupGCJCommand ( ) ; int firstFileName = cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } protected Commandline setupGCJCommand ( ) { Commandline cmd = new Commandline ( ) ; Path classpath = new Path ( project ) ; if ( bootclasspath != null ) { classpath . append ( bootclasspath ) ; } addExtdirsToClasspath ( classpath ) ; if ( ( bootclasspath == null ) || ( bootclasspath . size ( ) == 0 ) ) { includeJavaRuntime = true ; } classpath . append ( getCompileClasspath ( ) ) ; classpath . append ( src ) ; cmd . setExecutable ( "gcj" ) ; if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; if ( destDir . mkdirs ( ) ) { throw new BuildException ( "Can't make output directories. Maybe permission is wrong. " ) ; } ; } cmd . createArgument ( ) . setValue ( "-classpath" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; if ( encoding != null ) { attributes . log ( "gcj doesn't support -encoding option." , Project . MSG_WARN ) ; } if ( debug ) { cmd . createArgument ( ) . setValue ( "-g1" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O" ) ; } cmd . createArgument ( ) . setValue ( "-C" ) ; return cmd ; } } 	0	['3', '2', '0', '9', '22', '3', '1', '8', '2', '2', '128', '0', '0', '0.92', '1', '1', '1', '41.66666667', '9', '3.3333', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . Commandline ; import java . io . File ; import java . io . IOException ; public class Patch extends Task { private File originalFile ; private boolean havePatchfile = false ; private Commandline cmd = new Commandline ( ) ; public void setOriginalfile ( File file ) { originalFile = file ; } public void setPatchfile ( File file ) { if ( ! file . exists ( ) ) { throw new BuildException ( "patchfile " + file + " doesn\'t exist" , location ) ; } cmd . createArgument ( ) . setValue ( "-i" ) ; cmd . createArgument ( ) . setFile ( file ) ; havePatchfile = true ; } public void setBackups ( boolean backups ) { if ( backups ) { cmd . createArgument ( ) . setValue ( "-b" ) ; } } public void setIgnorewhitespace ( boolean ignore ) { if ( ignore ) { cmd . createArgument ( ) . setValue ( "-l" ) ; } } public void setStrip ( int num ) throws BuildException { if ( num < 0 ) { throw new BuildException ( "strip has to be >= 0" , location ) ; } cmd . createArgument ( ) . setValue ( "-p" + num ) ; } public void setQuiet ( boolean q ) { if ( q ) { cmd . createArgument ( ) . setValue ( "-s" ) ; } } public void setReverse ( boolean r ) { if ( r ) { cmd . createArgument ( ) . setValue ( "-R" ) ; } } public void execute ( ) throws BuildException { if ( ! havePatchfile ) { throw new BuildException ( "patchfile argument is required" , location ) ; } Commandline toExecute = ( Commandline ) cmd . clone ( ) ; toExecute . setExecutable ( "patch" ) ; if ( originalFile != null ) { toExecute . createArgument ( ) . setFile ( originalFile ) ; } Execute exe = new Execute ( new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) , null ) ; exe . setCommandline ( toExecute . getCommandline ( ) ) ; try { exe . execute ( ) ; } catch ( IOException e ) { throw new BuildException ( e , location ) ; } } } 	0	['9', '3', '0', '9', '29', '0', '0', '9', '9', '0.583333333', '168', '1', '1', '0.822222222', '0.444444444', '0', '0', '17.33333333', '2', '1.4444', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; import java . util . zip . * ; public class GUnzip extends Task { private File source ; private File dest ; public void setSrc ( String src ) { source = project . resolveFile ( src ) ; } public void setDest ( String dest ) { this . dest = project . resolveFile ( dest ) ; } public void execute ( ) throws BuildException { if ( source == null ) { throw new BuildException ( "No source for gunzip specified" , location ) ; } if ( ! source . exists ( ) ) { throw new BuildException ( "source doesn't exist" , location ) ; } if ( source . isDirectory ( ) ) { throw new BuildException ( "Cannot expand a directory" , location ) ; } if ( dest == null ) { dest = new File ( source . getParent ( ) ) ; } if ( dest . isDirectory ( ) ) { String sourceName = source . getName ( ) ; int len = sourceName . length ( ) ; if ( len > 3 && ".gz" . equalsIgnoreCase ( sourceName . substring ( len - 3 ) ) ) { dest = new File ( dest , sourceName . substring ( 0 , len - 3 ) ) ; } else { dest = new File ( dest , sourceName ) ; } } if ( source . lastModified ( ) > dest . lastModified ( ) ) { log ( "Expanding " + source . getAbsolutePath ( ) + " to " + dest . getAbsolutePath ( ) ) ; FileOutputStream out = null ; GZIPInputStream zIn = null ; try { out = new FileOutputStream ( dest ) ; zIn = new GZIPInputStream ( new FileInputStream ( source ) ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { out . write ( buffer , 0 , count ) ; count = zIn . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } catch ( IOException ioe ) { String msg = "Problem expanding gzip " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( IOException ioex ) { } } if ( zIn != null ) { try { zIn . close ( ) ; } catch ( IOException ioex ) { } } } } } } 	0	['4', '3', '0', '5', '32', '2', '0', '5', '4', '0.666666667', '215', '1', '0', '0.925', '0.75', '1', '1', '52.25', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public class StreamPumper implements Runnable { private final static int SLEEP = 5 ; private final static int SIZE = 128 ; private InputStream is ; private OutputStream os ; public StreamPumper ( InputStream is , OutputStream os ) { this . is = is ; this . os = os ; } public void run ( ) { final byte [ ] buf = new byte [ SIZE ] ; int length ; try { while ( ( length = is . read ( buf ) ) > 0 ) { os . write ( buf , 0 , length ) ; try { Thread . sleep ( SLEEP ) ; } catch ( InterruptedException e ) { } } } catch ( IOException e ) { } } } 	0	['2', '1', '0', '1', '6', '0', '1', '0', '2', '1', '39', '1', '0', '0', '0.666666667', '0', '0', '16.5', '2', '1', '0']
package org . apache . tools . ant ; import java . util . * ; import java . io . * ; public class PathTokenizer { private StringTokenizer tokenizer ; private String lookahead = null ; private boolean dosStyleFilesystem ; public PathTokenizer ( String path ) { tokenizer = new StringTokenizer ( path , ":;" , false ) ; dosStyleFilesystem = File . pathSeparatorChar == ';' ; } public boolean hasMoreTokens ( ) { if ( lookahead != null ) { return true ; } return tokenizer . hasMoreTokens ( ) ; } public String nextToken ( ) throws NoSuchElementException { String token = null ; if ( lookahead != null ) { token = lookahead ; lookahead = null ; } else { token = tokenizer . nextToken ( ) . trim ( ) ; } if ( token . length ( ) == 1 && Character . isLetter ( token . charAt ( 0 ) ) && dosStyleFilesystem && tokenizer . hasMoreTokens ( ) ) { String nextToken = tokenizer . nextToken ( ) . trim ( ) ; if ( nextToken . startsWith ( "\\" ) || nextToken . startsWith ( "/" ) ) { token += ":" + nextToken ; } else { lookahead = nextToken ; } } return token ; } } 	0	['3', '1', '0', '2', '15', '0', '2', '0', '3', '0.166666667', '100', '1', '0', '0', '0.666666667', '0', '0', '31.33333333', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . util . * ; import java . io . * ; public abstract class Definer extends Task { private String name ; private String value ; private Path classpath ; private File file ; private String resource ; private boolean reverseLoader = false ; public void setReverseLoader ( boolean reverseLoader ) { this . reverseLoader = reverseLoader ; log ( "The reverseloader attribute is DEPRECATED. It will be removed" , Project . MSG_WARN ) ; } public void setClasspath ( Path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( project ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void execute ( ) throws BuildException { AntClassLoader al = createLoader ( ) ; if ( file == null && resource == null ) { if ( name == null || value == null ) { String msg = "name or classname attributes of " + getTaskName ( ) + " element " + "are undefined" ; throw new BuildException ( msg ) ; } addDefinition ( al , name , value ) ; } else { try { if ( name != null || value != null ) { String msg = "You must not specify name or value " + "together with file or resource." ; throw new BuildException ( msg , location ) ; } if ( file != null && resource != null ) { String msg = "You must not specify both, file and resource." ; throw new BuildException ( msg , location ) ; } Properties props = new Properties ( ) ; InputStream is = null ; if ( file != null ) { log ( "Loading definitions from file " + file , Project . MSG_VERBOSE ) ; is = new FileInputStream ( file ) ; if ( is == null ) { log ( "Could not load definitions from file " + file + ". It doesn\'t exist." , Project . MSG_WARN ) ; } } if ( resource != null ) { log ( "Loading definitions from resource " + resource , Project . MSG_VERBOSE ) ; is = al . getResourceAsStream ( resource ) ; if ( is == null ) { log ( "Could not load definitions from resource " + resource + ". It could not be found." , Project . MSG_WARN ) ; } } if ( is != null ) { props . load ( is ) ; Enumeration keys = props . keys ( ) ; while ( keys . hasMoreElements ( ) ) { String n = ( String ) keys . nextElement ( ) ; String v = props . getProperty ( n ) ; addDefinition ( al , n , v ) ; } } } catch ( IOException ex ) { throw new BuildException ( ex , location ) ; } } } private void addDefinition ( ClassLoader al , String name , String value ) { try { Class c = al . loadClass ( value ) ; AntClassLoader . initializeClass ( c ) ; addDefinition ( name , c ) ; } catch ( ClassNotFoundException cnfe ) { String msg = getTaskName ( ) + " class " + value + " cannot be found" ; throw new BuildException ( msg , cnfe , location ) ; } catch ( NoClassDefFoundError ncdfe ) { String msg = getTaskName ( ) + " class " + value + " cannot be found" ; throw new BuildException ( msg , ncdfe , location ) ; } } private AntClassLoader createLoader ( ) { AntClassLoader al = null ; if ( classpath != null ) { al = new AntClassLoader ( project , classpath , ! reverseLoader ) ; } else { al = new AntClassLoader ( project , Path . systemClasspath , ! reverseLoader ) ; } al . addSystemPackageRoot ( "org.apache.tools.ant" ) ; return al ; } public void setFile ( File file ) { this . file = file ; } public void setResource ( String res ) { this . resource = res ; } public void setName ( String name ) { this . name = name ; } public String getClassname ( ) { return value ; } public void setClassname ( String v ) { value = v ; } protected abstract void addDefinition ( String name , Class c ) ; } 	0	['14', '3', '2', '11', '41', '67', '3', '8', '11', '0.846153846', '366', '1', '1', '0.74', '0.223214286', '1', '1', '24.71428571', '4', '1.2857', '0']
package org . apache . tools . ant ; import java . io . * ; import java . util . * ; import org . xml . sax . * ; import org . w3c . dom . * ; import org . apache . tools . ant . taskdefs . * ; import javax . xml . parsers . * ; public class ProjectHelper { private static SAXParserFactory parserFactory = null ; private org . xml . sax . Parser parser ; private Project project ; private File buildFile ; private File buildFileParent ; private Locator locator ; public static void configureProject ( Project project , File buildFile ) throws BuildException { new ProjectHelper ( project , buildFile ) . parse ( ) ; } private ProjectHelper ( Project project , File buildFile ) { this . project = project ; this . buildFile = new File ( buildFile . getAbsolutePath ( ) ) ; buildFileParent = new File ( this . buildFile . getParent ( ) ) ; } private void parse ( ) throws BuildException { FileInputStream inputStream = null ; InputSource inputSource = null ; try { SAXParser saxParser = getParserFactory ( ) . newSAXParser ( ) ; parser = saxParser . getParser ( ) ; String uri = "file:" + buildFile . getAbsolutePath ( ) . replace ( '\\' , '/' ) ; for ( int index = uri . indexOf ( '#' ) ; index != - 1 ; index = uri . indexOf ( '#' ) ) { uri = uri . substring ( 0 , index ) + "%23" + uri . substring ( index + 1 ) ; } inputStream = new FileInputStream ( buildFile ) ; inputSource = new InputSource ( inputStream ) ; inputSource . setSystemId ( uri ) ; project . log ( "parsing buildfile " + buildFile + " with URI = " + uri , Project . MSG_VERBOSE ) ; saxParser . parse ( inputSource , new RootHandler ( ) ) ; } catch ( ParserConfigurationException exc ) { throw new BuildException ( "Parser has not been configured correctly" , exc ) ; } catch ( SAXParseException exc ) { Location location = new Location ( buildFile . toString ( ) , exc . getLineNumber ( ) , exc . getColumnNumber ( ) ) ; Throwable t = exc . getException ( ) ; if ( t instanceof BuildException ) { BuildException be = ( BuildException ) t ; if ( be . getLocation ( ) == Location . UNKNOWN_LOCATION ) { be . setLocation ( location ) ; } throw be ; } throw new BuildException ( exc . getMessage ( ) , t , location ) ; } catch ( SAXException exc ) { Throwable t = exc . getException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( exc . getMessage ( ) , t ) ; } catch ( FileNotFoundException exc ) { throw new BuildException ( exc ) ; } catch ( IOException exc ) { throw new BuildException ( "Error reading project file" , exc ) ; } finally { if ( inputStream != null ) { try { inputStream . close ( ) ; } catch ( IOException ioe ) { } } } } private class AbstractHandler extends HandlerBase { protected DocumentHandler parentHandler ; public AbstractHandler ( DocumentHandler parentHandler ) { this . parentHandler = parentHandler ; parser . setDocumentHandler ( this ) ; } public void startElement ( String tag , AttributeList attrs ) throws SAXParseException { throw new SAXParseException ( "Unexpected element \"" + tag + "\"" , locator ) ; } public void characters ( char [ ] buf , int start , int end ) throws SAXParseException { String s = new String ( buf , start , end ) . trim ( ) ; if ( s . length ( ) > 0 ) { throw new SAXParseException ( "Unexpected text \"" + s + "\"" , locator ) ; } } protected void finished ( ) { } public void endElement ( String name ) throws SAXException { finished ( ) ; parser . setDocumentHandler ( parentHandler ) ; } } private class RootHandler extends HandlerBase { public InputSource resolveEntity ( String publicId , String systemId ) { project . log ( "resolving systemId: " + systemId , Project . MSG_VERBOSE ) ; if ( systemId . startsWith ( "file:" ) ) { String path = systemId . substring ( 5 ) ; int index = path . indexOf ( "file:" ) ; while ( index != - 1 ) { path = path . substring ( 0 , index ) + path . substring ( index + 5 ) ; index = path . indexOf ( "file:" ) ; } String entitySystemId = path ; index = path . indexOf ( "%23" ) ; while ( index != - 1 ) { path = path . substring ( 0 , index ) + "#" + path . substring ( index + 3 ) ; index = path . indexOf ( "%23" ) ; } File file = new File ( path ) ; if ( ! file . isAbsolute ( ) ) { file = new File ( buildFileParent , path ) ; } try { InputSource inputSource = new InputSource ( new FileInputStream ( file ) ) ; inputSource . setSystemId ( "file:" + entitySystemId ) ; return inputSource ; } catch ( FileNotFoundException fne ) { project . log ( file . getAbsolutePath ( ) + " could not be found" , Project . MSG_WARN ) ; } } return null ; } public void startElement ( String tag , AttributeList attrs ) throws SAXParseException { if ( tag . equals ( "project" ) ) { new ProjectHandler ( this ) . init ( tag , attrs ) ; } else { throw new SAXParseException ( "Config file is not of expected XML type" , locator ) ; } } public void setDocumentLocator ( Locator locator ) { ProjectHelper . this . locator = locator ; } } private class ProjectHandler extends AbstractHandler { public ProjectHandler ( DocumentHandler parentHandler ) { super ( parentHandler ) ; } public void init ( String tag , AttributeList attrs ) throws SAXParseException { String def = null ; String name = null ; String id = null ; String baseDir = null ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String key = attrs . getName ( i ) ; String value = attrs . getValue ( i ) ; if ( key . equals ( "default" ) ) { def = value ; } else if ( key . equals ( "name" ) ) { name = value ; } else if ( key . equals ( "id" ) ) { id = value ; } else if ( key . equals ( "basedir" ) ) { baseDir = value ; } else { throw new SAXParseException ( "Unexpected attribute \"" + attrs . getName ( i ) + "\"" , locator ) ; } } if ( def == null ) { throw new SAXParseException ( "The default attribute of project is required" , locator ) ; } project . setDefaultTarget ( def ) ; if ( name != null ) { project . setName ( name ) ; project . addReference ( name , project ) ; } if ( id != null ) project . addReference ( id , project ) ; if ( project . getProperty ( "basedir" ) != null ) { project . setBasedir ( project . getProperty ( "basedir" ) ) ; } else { if ( baseDir == null ) { project . setBasedir ( buildFileParent . getAbsolutePath ( ) ) ; } else { if ( ( new File ( baseDir ) ) . isAbsolute ( ) ) { project . setBasedir ( baseDir ) ; } else { project . setBaseDir ( project . resolveFile ( baseDir , buildFileParent ) ) ; } } } } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { if ( name . equals ( "taskdef" ) ) { handleTaskdef ( name , attrs ) ; } else if ( name . equals ( "property" ) ) { handleProperty ( name , attrs ) ; } else if ( name . equals ( "target" ) ) { handleTarget ( name , attrs ) ; } else if ( project . getDataTypeDefinitions ( ) . get ( name ) != null ) { handleDataType ( name , attrs ) ; } else { throw new SAXParseException ( "Unexpected element \"" + name + "\"" , locator ) ; } } private void handleTaskdef ( String name , AttributeList attrs ) throws SAXParseException { ( new TaskHandler ( this , null , null ) ) . init ( name , attrs ) ; } private void handleProperty ( String name , AttributeList attrs ) throws SAXParseException { ( new TaskHandler ( this , null , null ) ) . init ( name , attrs ) ; } private void handleTarget ( String tag , AttributeList attrs ) throws SAXParseException { new TargetHandler ( this ) . init ( tag , attrs ) ; } private void handleDataType ( String name , AttributeList attrs ) throws SAXParseException { new DataTypeHandler ( this ) . init ( name , attrs ) ; } } private class TargetHandler extends AbstractHandler { private Target target ; public TargetHandler ( DocumentHandler parentHandler ) { super ( parentHandler ) ; } public void init ( String tag , AttributeList attrs ) throws SAXParseException { String name = null ; String depends = "" ; String ifCond = null ; String unlessCond = null ; String id = null ; String description = null ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String key = attrs . getName ( i ) ; String value = attrs . getValue ( i ) ; if ( key . equals ( "name" ) ) { name = value ; } else if ( key . equals ( "depends" ) ) { depends = value ; } else if ( key . equals ( "if" ) ) { ifCond = value ; } else if ( key . equals ( "unless" ) ) { unlessCond = value ; } else if ( key . equals ( "id" ) ) { id = value ; } else if ( key . equals ( "description" ) ) { description = value ; } else { throw new SAXParseException ( "Unexpected attribute \"" + key + "\"" , locator ) ; } } if ( name == null ) { throw new SAXParseException ( "target element appears without a name attribute" , locator ) ; } target = new Target ( ) ; target . setName ( name ) ; target . setIf ( ifCond ) ; target . setUnless ( unlessCond ) ; target . setDescription ( description ) ; project . addTarget ( name , target ) ; if ( id != null && ! id . equals ( "" ) ) project . addReference ( id , target ) ; if ( depends . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( depends , "," , false ) ; while ( tok . hasMoreTokens ( ) ) { target . addDependency ( tok . nextToken ( ) . trim ( ) ) ; } } } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { if ( project . getDataTypeDefinitions ( ) . get ( name ) != null ) { new DataTypeHandler ( this , target ) . init ( name , attrs ) ; } else { new TaskHandler ( this , target , target ) . init ( name , attrs ) ; } } } private class TaskHandler extends AbstractHandler { private Target target ; private TaskContainer container ; private Task task ; private RuntimeConfigurable wrapper = null ; public TaskHandler ( DocumentHandler parentHandler , TaskContainer container , Target target ) { super ( parentHandler ) ; this . container = container ; this . target = target ; } public void init ( String tag , AttributeList attrs ) throws SAXParseException { try { task = project . createTask ( tag ) ; } catch ( BuildException e ) { } if ( task == null ) { task = new UnknownElement ( tag ) ; task . setProject ( project ) ; task . setTaskType ( tag ) ; task . setTaskName ( tag ) ; } task . setLocation ( new Location ( buildFile . toString ( ) , locator . getLineNumber ( ) , locator . getColumnNumber ( ) ) ) ; configureId ( task , attrs ) ; if ( target != null ) { task . setOwningTarget ( target ) ; container . addTask ( task ) ; task . init ( ) ; wrapper = task . getRuntimeConfigurableWrapper ( ) ; wrapper . setAttributes ( attrs ) ; } else { task . init ( ) ; configure ( task , attrs , project ) ; } } protected void finished ( ) { if ( task != null && target == null ) { task . execute ( ) ; } } public void characters ( char [ ] buf , int start , int end ) throws SAXParseException { if ( wrapper == null ) { try { addText ( project , task , buf , start , end ) ; } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , locator , exc ) ; } } else { wrapper . addText ( buf , start , end ) ; } } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { if ( task instanceof TaskContainer ) { new TaskHandler ( this , ( TaskContainer ) task , target ) . init ( name , attrs ) ; } else { new NestedElementHandler ( this , task , wrapper , target ) . init ( name , attrs ) ; } } } private class NestedElementHandler extends AbstractHandler { private Object parent ; private Object child ; private RuntimeConfigurable parentWrapper ; private RuntimeConfigurable childWrapper = null ; private Target target ; public NestedElementHandler ( DocumentHandler parentHandler , Object parent , RuntimeConfigurable parentWrapper , Target target ) { super ( parentHandler ) ; if ( parent instanceof TaskAdapter ) { this . parent = ( ( TaskAdapter ) parent ) . getProxy ( ) ; } else { this . parent = parent ; } this . parentWrapper = parentWrapper ; this . target = target ; } public void init ( String propType , AttributeList attrs ) throws SAXParseException { Class parentClass = parent . getClass ( ) ; IntrospectionHelper ih = IntrospectionHelper . getHelper ( parentClass ) ; try { if ( parent instanceof UnknownElement ) { child = new UnknownElement ( propType . toLowerCase ( ) ) ; ( ( UnknownElement ) parent ) . addChild ( ( UnknownElement ) child ) ; } else { child = ih . createElement ( project , parent , propType . toLowerCase ( ) ) ; } configureId ( child , attrs ) ; if ( parentWrapper != null ) { childWrapper = new RuntimeConfigurable ( child , propType ) ; childWrapper . setAttributes ( attrs ) ; parentWrapper . addChild ( childWrapper ) ; } else { configure ( child , attrs , project ) ; ih . storeElement ( project , parent , child , propType . toLowerCase ( ) ) ; } } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , locator , exc ) ; } } public void characters ( char [ ] buf , int start , int end ) throws SAXParseException { if ( parentWrapper == null ) { try { addText ( project , child , buf , start , end ) ; } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , locator , exc ) ; } } else { childWrapper . addText ( buf , start , end ) ; } } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { if ( child instanceof TaskContainer ) { new TaskHandler ( this , ( TaskContainer ) child , target ) . init ( name , attrs ) ; } else { new NestedElementHandler ( this , child , childWrapper , target ) . init ( name , attrs ) ; } } } private class DataTypeHandler extends AbstractHandler { private Target target ; private Object element ; private RuntimeConfigurable wrapper = null ; public DataTypeHandler ( DocumentHandler parentHandler ) { this ( parentHandler , null ) ; } public DataTypeHandler ( DocumentHandler parentHandler , Target target ) { super ( parentHandler ) ; this . target = target ; } public void init ( String propType , AttributeList attrs ) throws SAXParseException { try { element = project . createDataType ( propType ) ; if ( element == null ) { throw new BuildException ( "Unknown data type " + propType ) ; } if ( target != null ) { wrapper = new RuntimeConfigurable ( element , propType ) ; wrapper . setAttributes ( attrs ) ; target . addDataType ( wrapper ) ; } else { configure ( element , attrs , project ) ; configureId ( element , attrs ) ; } } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , locator , exc ) ; } } public void characters ( char [ ] buf , int start , int end ) throws SAXParseException { try { addText ( project , element , buf , start , end ) ; } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , locator , exc ) ; } } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { new NestedElementHandler ( this , element , wrapper , target ) . init ( name , attrs ) ; } } public static void configure ( Object target , AttributeList attrs , Project project ) throws BuildException { if ( target instanceof TaskAdapter ) target = ( ( TaskAdapter ) target ) . getProxy ( ) ; IntrospectionHelper ih = IntrospectionHelper . getHelper ( target . getClass ( ) ) ; project . addBuildListener ( ih ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String value = replaceProperties ( project , attrs . getValue ( i ) , project . getProperties ( ) ) ; try { ih . setAttribute ( project , target , attrs . getName ( i ) . toLowerCase ( ) , value ) ; } catch ( BuildException be ) { if ( ! attrs . getName ( i ) . equals ( "id" ) ) { throw be ; } } } } public static void addText ( Project project , Object target , char [ ] buf , int start , int end ) throws BuildException { addText ( project , target , new String ( buf , start , end ) ) ; } public static void addText ( Project project , Object target , String text ) throws BuildException { if ( text == null || text . trim ( ) . length ( ) == 0 ) { return ; } if ( target instanceof TaskAdapter ) target = ( ( TaskAdapter ) target ) . getProxy ( ) ; IntrospectionHelper . getHelper ( target . getClass ( ) ) . addText ( project , target , text ) ; } public static void storeChild ( Project project , Object parent , Object child , String tag ) { IntrospectionHelper ih = IntrospectionHelper . getHelper ( parent . getClass ( ) ) ; ih . storeElement ( project , parent , child , tag ) ; } public static String replaceProperties ( Project project , String value , Hashtable keys ) throws BuildException { if ( value == null ) { return null ; } Vector fragments = new Vector ( ) ; Vector propertyRefs = new Vector ( ) ; parsePropertyString ( value , fragments , propertyRefs ) ; StringBuffer sb = new StringBuffer ( ) ; Enumeration i = fragments . elements ( ) ; Enumeration j = propertyRefs . elements ( ) ; while ( i . hasMoreElements ( ) ) { String fragment = ( String ) i . nextElement ( ) ; if ( fragment == null ) { String propertyName = ( String ) j . nextElement ( ) ; if ( ! keys . containsKey ( propertyName ) ) { project . log ( "Property ${" + propertyName + "} has not been set" , Project . MSG_VERBOSE ) ; } fragment = ( keys . containsKey ( propertyName ) ) ? ( String ) keys . get ( propertyName ) : "${" + propertyName + "}" ; } sb . append ( fragment ) ; } return sb . toString ( ) ; } public static void parsePropertyString ( String value , Vector fragments , Vector propertyRefs ) throws BuildException { int prev = 0 ; int pos ; while ( ( pos = value . indexOf ( "$" , prev ) ) >= 0 ) { if ( pos > 0 ) { fragments . addElement ( value . substring ( prev , pos ) ) ; } if ( pos == ( value . length ( ) - 1 ) ) { fragments . addElement ( "$" ) ; prev = pos + 1 ; } else if ( value . charAt ( pos + 1 ) != '{' ) { fragments . addElement ( value . substring ( pos + 1 , pos + 2 ) ) ; prev = pos + 2 ; } else { int endName = value . indexOf ( '}' , pos ) ; if ( endName < 0 ) { throw new BuildException ( "Syntax error in property: " + value ) ; } String propertyName = value . substring ( pos + 2 , endName ) ; fragments . addElement ( null ) ; propertyRefs . addElement ( propertyName ) ; prev = endName + 1 ; } } if ( prev < value . length ( ) ) { fragments . addElement ( value . substring ( prev ) ) ; } } private static SAXParserFactory getParserFactory ( ) { if ( parserFactory == null ) { parserFactory = SAXParserFactory . newInstance ( ) ; } return parserFactory ; } private void configureId ( Object target , AttributeList attr ) { String id = attr . getValue ( "id" ) ; if ( id != null ) { project . addReference ( id , target ) ; } } } 	0	['19', '1', '0', '24', '81', '147', '17', '8', '7', '0.861111111', '560', '1', '1', '0', '0.171296296', '0', '0', '28.15789474', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; import java . util . * ; public class KeySubst extends Task { private File source = null ; private File dest = null ; private String sep = "*" ; private Hashtable replacements = new Hashtable ( ) ; public void execute ( ) throws BuildException { log ( "!! KeySubst is deprecated. Use Filter + CopyDir instead. !!" ) ; log ( "Performing Substitions" ) ; if ( source == null || dest == null ) { log ( "Source and destinations must not be null" ) ; return ; } BufferedReader br = null ; BufferedWriter bw = null ; try { br = new BufferedReader ( new FileReader ( source ) ) ; dest . delete ( ) ; bw = new BufferedWriter ( new FileWriter ( dest ) ) ; String line = null ; String newline = null ; int length ; line = br . readLine ( ) ; while ( line != null ) { if ( line . length ( ) == 0 ) { bw . newLine ( ) ; } else { newline = KeySubst . replace ( line , replacements ) ; bw . write ( newline ) ; bw . newLine ( ) ; } line = br . readLine ( ) ; } bw . flush ( ) ; bw . close ( ) ; br . close ( ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } } public void setSrc ( File s ) { this . source = s ; } public void setDest ( File dest ) { this . dest = dest ; } public void setSep ( String sep ) { this . sep = sep ; } public void setKeys ( String keys ) { if ( keys != null && keys . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( keys , this . sep , false ) ; while ( tok . hasMoreTokens ( ) ) { String token = tok . nextToken ( ) . trim ( ) ; StringTokenizer itok = new StringTokenizer ( token , "=" , false ) ; String name = itok . nextToken ( ) ; String value = itok . nextToken ( ) ; replacements . put ( name , value ) ; } } } public static void main ( String [ ] args ) { try { Hashtable hash = new Hashtable ( ) ; hash . put ( "VERSION" , "1.0.3" ) ; hash . put ( "b" , "ffff" ) ; System . out . println ( KeySubst . replace ( "$f ${VERSION} f ${b} jj $" , hash ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public static String replace ( String origString , Hashtable keys ) throws BuildException { StringBuffer finalString = new StringBuffer ( ) ; int index = 0 ; int i = 0 ; String key = null ; while ( ( index = origString . indexOf ( "${" , i ) ) > - 1 ) { key = origString . substring ( index + 2 , origString . indexOf ( "}" , index + 3 ) ) ; finalString . append ( origString . substring ( i , index ) ) ; if ( keys . containsKey ( key ) ) { finalString . append ( keys . get ( key ) ) ; } else { finalString . append ( "${" ) ; finalString . append ( key ) ; finalString . append ( "}" ) ; } i = index + 3 + key . length ( ) ; } finalString . append ( origString . substring ( i ) ) ; return finalString . toString ( ) ; } } 	0	['8', '3', '0', '2', '39', '10', '0', '2', '8', '0.714285714', '265', '1', '0', '0.840909091', '0.325', '1', '1', '31.625', '4', '1.25', '0']
package org . apache . tools . ant ; import java . io . * ; import java . util . * ; public class DirectoryScanner implements FileScanner { protected final static String [ ] DEFAULTEXCLUDES = { "**/*~" , "**/#*#" , "**/.#*" , "**/%*%" , "**/CVS" , "**/CVS/**" , "**/.cvsignore" , "**/SCCS" , "**/SCCS/**" , "**/vssver.scc" } ; protected File basedir ; protected String [ ] includes ; protected String [ ] excludes ; protected Vector filesIncluded ; protected Vector filesNotIncluded ; protected Vector filesExcluded ; protected Vector dirsIncluded ; protected Vector dirsNotIncluded ; protected Vector dirsExcluded ; protected boolean haveSlowResults = false ; public DirectoryScanner ( ) { } protected static boolean matchPatternStart ( String pattern , String str ) { if ( str . startsWith ( File . separator ) != pattern . startsWith ( File . separator ) ) { return false ; } Vector patDirs = new Vector ( ) ; StringTokenizer st = new StringTokenizer ( pattern , File . separator ) ; while ( st . hasMoreTokens ( ) ) { patDirs . addElement ( st . nextToken ( ) ) ; } Vector strDirs = new Vector ( ) ; st = new StringTokenizer ( str , File . separator ) ; while ( st . hasMoreTokens ( ) ) { strDirs . addElement ( st . nextToken ( ) ) ; } int patIdxStart = 0 ; int patIdxEnd = patDirs . size ( ) - 1 ; int strIdxStart = 0 ; int strIdxEnd = strDirs . size ( ) - 1 ; while ( patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd ) { String patDir = ( String ) patDirs . elementAt ( patIdxStart ) ; if ( patDir . equals ( "**" ) ) { break ; } if ( ! match ( patDir , ( String ) strDirs . elementAt ( strIdxStart ) ) ) { return false ; } patIdxStart ++ ; strIdxStart ++ ; } if ( strIdxStart > strIdxEnd ) { return true ; } else if ( patIdxStart > patIdxEnd ) { return false ; } else { return true ; } } protected static boolean matchPath ( String pattern , String str ) { if ( str . startsWith ( File . separator ) != pattern . startsWith ( File . separator ) ) { return false ; } Vector patDirs = new Vector ( ) ; StringTokenizer st = new StringTokenizer ( pattern , File . separator ) ; while ( st . hasMoreTokens ( ) ) { patDirs . addElement ( st . nextToken ( ) ) ; } Vector strDirs = new Vector ( ) ; st = new StringTokenizer ( str , File . separator ) ; while ( st . hasMoreTokens ( ) ) { strDirs . addElement ( st . nextToken ( ) ) ; } int patIdxStart = 0 ; int patIdxEnd = patDirs . size ( ) - 1 ; int strIdxStart = 0 ; int strIdxEnd = strDirs . size ( ) - 1 ; while ( patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd ) { String patDir = ( String ) patDirs . elementAt ( patIdxStart ) ; if ( patDir . equals ( "**" ) ) { break ; } if ( ! match ( patDir , ( String ) strDirs . elementAt ( strIdxStart ) ) ) { return false ; } patIdxStart ++ ; strIdxStart ++ ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( ! patDirs . elementAt ( i ) . equals ( "**" ) ) { return false ; } } return true ; } else { if ( patIdxStart > patIdxEnd ) { return false ; } } while ( patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd ) { String patDir = ( String ) patDirs . elementAt ( patIdxEnd ) ; if ( patDir . equals ( "**" ) ) { break ; } if ( ! match ( patDir , ( String ) strDirs . elementAt ( strIdxEnd ) ) ) { return false ; } patIdxEnd -- ; strIdxEnd -- ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( ! patDirs . elementAt ( i ) . equals ( "**" ) ) { return false ; } } return true ; } while ( patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd ) { int patIdxTmp = - 1 ; for ( int i = patIdxStart + 1 ; i <= patIdxEnd ; i ++ ) { if ( patDirs . elementAt ( i ) . equals ( "**" ) ) { patIdxTmp = i ; break ; } } if ( patIdxTmp == patIdxStart + 1 ) { patIdxStart ++ ; continue ; } int patLength = ( patIdxTmp - patIdxStart - 1 ) ; int strLength = ( strIdxEnd - strIdxStart + 1 ) ; int foundIdx = - 1 ; strLoop : for ( int i = 0 ; i <= strLength - patLength ; i ++ ) { for ( int j = 0 ; j < patLength ; j ++ ) { String subPat = ( String ) patDirs . elementAt ( patIdxStart + j + 1 ) ; String subStr = ( String ) strDirs . elementAt ( strIdxStart + i + j ) ; if ( ! match ( subPat , subStr ) ) { continue strLoop ; } } foundIdx = strIdxStart + i ; break ; } if ( foundIdx == - 1 ) { return false ; } patIdxStart = patIdxTmp ; strIdxStart = foundIdx + patLength ; } for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( ! patDirs . elementAt ( i ) . equals ( "**" ) ) { return false ; } } return true ; } protected static boolean match ( String pattern , String str ) { char [ ] patArr = pattern . toCharArray ( ) ; char [ ] strArr = str . toCharArray ( ) ; int patIdxStart = 0 ; int patIdxEnd = patArr . length - 1 ; int strIdxStart = 0 ; int strIdxEnd = strArr . length - 1 ; char ch ; boolean containsStar = false ; for ( int i = 0 ; i < patArr . length ; i ++ ) { if ( patArr [ i ] == '*' ) { containsStar = true ; break ; } } if ( ! containsStar ) { if ( patIdxEnd != strIdxEnd ) { return false ; } for ( int i = 0 ; i <= patIdxEnd ; i ++ ) { ch = patArr [ i ] ; if ( ch != '?' && ch != strArr [ i ] ) { return false ; } } return true ; } if ( patIdxEnd == 0 ) { return true ; } while ( ( ch = patArr [ patIdxStart ] ) != '*' && strIdxStart <= strIdxEnd ) { if ( ch != '?' && ch != strArr [ strIdxStart ] ) { return false ; } patIdxStart ++ ; strIdxStart ++ ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != '*' ) { return false ; } } return true ; } while ( ( ch = patArr [ patIdxEnd ] ) != '*' && strIdxStart <= strIdxEnd ) { if ( ch != '?' && ch != strArr [ strIdxEnd ] ) { return false ; } patIdxEnd -- ; strIdxEnd -- ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != '*' ) { return false ; } } return true ; } while ( patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd ) { int patIdxTmp = - 1 ; for ( int i = patIdxStart + 1 ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] == '*' ) { patIdxTmp = i ; break ; } } if ( patIdxTmp == patIdxStart + 1 ) { patIdxStart ++ ; continue ; } int patLength = ( patIdxTmp - patIdxStart - 1 ) ; int strLength = ( strIdxEnd - strIdxStart + 1 ) ; int foundIdx = - 1 ; strLoop : for ( int i = 0 ; i <= strLength - patLength ; i ++ ) { for ( int j = 0 ; j < patLength ; j ++ ) { ch = patArr [ patIdxStart + j + 1 ] ; if ( ch != '?' && ch != strArr [ strIdxStart + i + j ] ) { continue strLoop ; } } foundIdx = strIdxStart + i ; break ; } if ( foundIdx == - 1 ) { return false ; } patIdxStart = patIdxTmp ; strIdxStart = foundIdx + patLength ; } for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != '*' ) { return false ; } } return true ; } public void setBasedir ( String basedir ) { setBasedir ( new File ( basedir . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ) ) ; } public void setBasedir ( File basedir ) { this . basedir = basedir ; } public File getBasedir ( ) { return basedir ; } public void setIncludes ( String [ ] includes ) { if ( includes == null ) { this . includes = null ; } else { this . includes = new String [ includes . length ] ; for ( int i = 0 ; i < includes . length ; i ++ ) { String pattern ; pattern = includes [ i ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( pattern . endsWith ( File . separator ) ) { pattern += "**" ; } this . includes [ i ] = pattern ; } } } public void setExcludes ( String [ ] excludes ) { if ( excludes == null ) { this . excludes = null ; } else { this . excludes = new String [ excludes . length ] ; for ( int i = 0 ; i < excludes . length ; i ++ ) { String pattern ; pattern = excludes [ i ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( pattern . endsWith ( File . separator ) ) { pattern += "**" ; } this . excludes [ i ] = pattern ; } } } public void scan ( ) { if ( basedir == null ) { throw new IllegalStateException ( "No basedir set" ) ; } if ( ! basedir . exists ( ) ) { throw new IllegalStateException ( "basedir " + basedir + " does not exist" ) ; } if ( ! basedir . isDirectory ( ) ) { throw new IllegalStateException ( "basedir " + basedir + " is not a directory" ) ; } if ( includes == null ) { includes = new String [ 1 ] ; includes [ 0 ] = "**" ; } if ( excludes == null ) { excludes = new String [ 0 ] ; } filesIncluded = new Vector ( ) ; filesNotIncluded = new Vector ( ) ; filesExcluded = new Vector ( ) ; dirsIncluded = new Vector ( ) ; dirsNotIncluded = new Vector ( ) ; dirsExcluded = new Vector ( ) ; if ( isIncluded ( "" ) ) { if ( ! isExcluded ( "" ) ) { dirsIncluded . addElement ( "" ) ; } else { dirsExcluded . addElement ( "" ) ; } } else { dirsNotIncluded . addElement ( "" ) ; } scandir ( basedir , "" , true ) ; } protected void slowScan ( ) { if ( haveSlowResults ) { return ; } String [ ] excl = new String [ dirsExcluded . size ( ) ] ; dirsExcluded . copyInto ( excl ) ; String [ ] notIncl = new String [ dirsNotIncluded . size ( ) ] ; dirsNotIncluded . copyInto ( notIncl ) ; for ( int i = 0 ; i < excl . length ; i ++ ) { if ( ! couldHoldIncluded ( excl [ i ] ) ) { scandir ( new File ( basedir , excl [ i ] ) , excl [ i ] + File . separator , false ) ; } } for ( int i = 0 ; i < notIncl . length ; i ++ ) { if ( ! couldHoldIncluded ( notIncl [ i ] ) ) { scandir ( new File ( basedir , notIncl [ i ] ) , notIncl [ i ] + File . separator , false ) ; } } haveSlowResults = true ; } protected void scandir ( File dir , String vpath , boolean fast ) { String [ ] newfiles = dir . list ( ) ; if ( newfiles == null ) { throw new BuildException ( "IO error scanning directory " + dir . getAbsolutePath ( ) ) ; } for ( int i = 0 ; i < newfiles . length ; i ++ ) { String name = vpath + newfiles [ i ] ; File file = new File ( dir , newfiles [ i ] ) ; if ( file . isDirectory ( ) ) { if ( isIncluded ( name ) ) { if ( ! isExcluded ( name ) ) { dirsIncluded . addElement ( name ) ; if ( fast ) { scandir ( file , name + File . separator , fast ) ; } } else { dirsExcluded . addElement ( name ) ; if ( fast && couldHoldIncluded ( name ) ) { scandir ( file , name + File . separator , fast ) ; } } } else { dirsNotIncluded . addElement ( name ) ; if ( fast && couldHoldIncluded ( name ) ) { scandir ( file , name + File . separator , fast ) ; } } if ( ! fast ) { scandir ( file , name + File . separator , fast ) ; } } else if ( file . isFile ( ) ) { if ( isIncluded ( name ) ) { if ( ! isExcluded ( name ) ) { filesIncluded . addElement ( name ) ; } else { filesExcluded . addElement ( name ) ; } } else { filesNotIncluded . addElement ( name ) ; } } } } protected boolean isIncluded ( String name ) { for ( int i = 0 ; i < includes . length ; i ++ ) { if ( matchPath ( includes [ i ] , name ) ) { return true ; } } return false ; } protected boolean couldHoldIncluded ( String name ) { for ( int i = 0 ; i < includes . length ; i ++ ) { if ( matchPatternStart ( includes [ i ] , name ) ) { return true ; } } return false ; } protected boolean isExcluded ( String name ) { for ( int i = 0 ; i < excludes . length ; i ++ ) { if ( matchPath ( excludes [ i ] , name ) ) { return true ; } } return false ; } public String [ ] getIncludedFiles ( ) { int count = filesIncluded . size ( ) ; String [ ] files = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { files [ i ] = ( String ) filesIncluded . elementAt ( i ) ; } return files ; } public String [ ] getNotIncludedFiles ( ) { slowScan ( ) ; int count = filesNotIncluded . size ( ) ; String [ ] files = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { files [ i ] = ( String ) filesNotIncluded . elementAt ( i ) ; } return files ; } public String [ ] getExcludedFiles ( ) { slowScan ( ) ; int count = filesExcluded . size ( ) ; String [ ] files = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { files [ i ] = ( String ) filesExcluded . elementAt ( i ) ; } return files ; } public String [ ] getIncludedDirectories ( ) { int count = dirsIncluded . size ( ) ; String [ ] directories = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { directories [ i ] = ( String ) dirsIncluded . elementAt ( i ) ; } return directories ; } public String [ ] getNotIncludedDirectories ( ) { slowScan ( ) ; int count = dirsNotIncluded . size ( ) ; String [ ] directories = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { directories [ i ] = ( String ) dirsNotIncluded . elementAt ( i ) ; } return directories ; } public String [ ] getExcludedDirectories ( ) { slowScan ( ) ; int count = dirsExcluded . size ( ) ; String [ ] directories = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { directories [ i ] = ( String ) dirsExcluded . elementAt ( i ) ; } return directories ; } public void addDefaultExcludes ( ) { int excludesLength = excludes == null ? 0 : excludes . length ; String [ ] newExcludes ; newExcludes = new String [ excludesLength + DEFAULTEXCLUDES . length ] ; if ( excludesLength > 0 ) { System . arraycopy ( excludes , 0 , newExcludes , 0 , excludesLength ) ; } for ( int i = 0 ; i < DEFAULTEXCLUDES . length ; i ++ ) { newExcludes [ i + excludesLength ] = DEFAULTEXCLUDES [ i ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; } excludes = newExcludes ; } } 	0	['23', '1', '1', '25', '52', '181', '23', '2', '14', '0.731404959', '1489', '1', '0', '0', '0.290909091', '0', '0', '63.26086957', '35', '6.087', '0']
package org . apache . tools . ant . types ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class FilterSetCollection { private Vector filterSets = new Vector ( ) ; public FilterSetCollection ( ) { } public FilterSetCollection ( FilterSet filterSet ) { addFilterSet ( filterSet ) ; } public void addFilterSet ( FilterSet filterSet ) { filterSets . addElement ( filterSet ) ; } public String replaceTokens ( String line ) { String replacedLine = line ; for ( Enumeration e = filterSets . elements ( ) ; e . hasMoreElements ( ) ; ) { FilterSet filterSet = ( FilterSet ) e . nextElement ( ) ; replacedLine = filterSet . replaceTokens ( replacedLine ) ; } return replacedLine ; } public boolean hasFilters ( ) { for ( Enumeration e = filterSets . elements ( ) ; e . hasMoreElements ( ) ; ) { FilterSet filterSet = ( FilterSet ) e . nextElement ( ) ; if ( filterSet . hasFilters ( ) ) { return true ; } } return false ; } } 	0	['5', '1', '0', '5', '13', '0', '4', '1', '5', '0', '69', '1', '0', '0', '0.533333333', '0', '0', '12.6', '3', '1.2', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . * ; public class JavacExternal extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using external javac compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = new Commandline ( ) ; cmd . setExecutable ( "javac" ) ; setupJavacCommandlineSwitches ( cmd ) ; int firstFileName = cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } } 	0	['2', '2', '0', '6', '11', '1', '1', '5', '2', '2', '37', '0', '0', '0.958333333', '1', '0', '0', '17.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; public class Transform extends ExecuteOn { } 	0	['1', '5', '0', '1', '2', '0', '0', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . tools . ant . util ; public class GlobPatternMapper implements FileNameMapper { protected String fromPrefix = null ; protected String fromPostfix = null ; protected int prefixLength ; protected int postfixLength ; protected String toPrefix = null ; protected String toPostfix = null ; public void setFrom ( String from ) { int index = from . lastIndexOf ( "*" ) ; if ( index == - 1 ) { fromPrefix = from ; fromPostfix = "" ; } else { fromPrefix = from . substring ( 0 , index ) ; fromPostfix = from . substring ( index + 1 ) ; } prefixLength = fromPrefix . length ( ) ; postfixLength = fromPostfix . length ( ) ; } public void setTo ( String to ) { int index = to . lastIndexOf ( "*" ) ; if ( index == - 1 ) { toPrefix = to ; toPostfix = "" ; } else { toPrefix = to . substring ( 0 , index ) ; toPostfix = to . substring ( index + 1 ) ; } } public String [ ] mapFileName ( String sourceFileName ) { if ( fromPrefix == null || ! sourceFileName . startsWith ( fromPrefix ) || ! sourceFileName . endsWith ( fromPostfix ) ) { return null ; } return new String [ ] { toPrefix + extractVariablePart ( sourceFileName ) + toPostfix } ; } protected String extractVariablePart ( String name ) { return name . substring ( prefixLength , name . length ( ) - postfixLength ) ; } } 	0	['5', '1', '0', '2', '15', '0', '1', '1', '4', '0.5', '137', '1', '0', '0', '0.9', '0', '0', '25.2', '4', '1.8', '0']
package org . apache . tools . ant . util ; public class MergingMapper implements FileNameMapper { protected String [ ] mergedFile = null ; public void setFrom ( String from ) { } public void setTo ( String to ) { mergedFile = new String [ ] { to } ; } public String [ ] mapFileName ( String sourceFileName ) { return mergedFile ; } } 	0	['4', '1', '0', '4', '5', '0', '3', '1', '4', '0.333333333', '24', '1', '0', '0', '0.875', '0', '0', '4.75', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . io . * ; import java . util . * ; public abstract class MatchingTask extends Task { protected boolean useDefaultExcludes = true ; protected FileSet fileset = new FileSet ( ) ; public PatternSet . NameEntry createInclude ( ) { return fileset . createInclude ( ) ; } public PatternSet . NameEntry createIncludesFile ( ) { return fileset . createIncludesFile ( ) ; } public PatternSet . NameEntry createExclude ( ) { return fileset . createExclude ( ) ; } public PatternSet . NameEntry createExcludesFile ( ) { return fileset . createExcludesFile ( ) ; } public PatternSet createPatternSet ( ) { return fileset . createPatternSet ( ) ; } public void setIncludes ( String includes ) { fileset . setIncludes ( includes ) ; } public void XsetItems ( String itemString ) { log ( "The items attribute is deprecated. " + "Please use the includes attribute." , Project . MSG_WARN ) ; if ( itemString == null || itemString . equals ( "*" ) || itemString . equals ( "." ) ) { createInclude ( ) . setName ( "**" ) ; } else { StringTokenizer tok = new StringTokenizer ( itemString , ", " ) ; while ( tok . hasMoreTokens ( ) ) { String pattern = tok . nextToken ( ) . trim ( ) ; if ( pattern . length ( ) > 0 ) { createInclude ( ) . setName ( pattern + "/**" ) ; } } } } public void setExcludes ( String excludes ) { fileset . setExcludes ( excludes ) ; } public void XsetIgnore ( String ignoreString ) { log ( "The ignore attribute is deprecated." + "Please use the excludes attribute." , Project . MSG_WARN ) ; if ( ignoreString != null && ignoreString . length ( ) > 0 ) { Vector tmpExcludes = new Vector ( ) ; StringTokenizer tok = new StringTokenizer ( ignoreString , ", " , false ) ; while ( tok . hasMoreTokens ( ) ) { createExclude ( ) . setName ( "**/" + tok . nextToken ( ) . trim ( ) + "/**" ) ; } } } public void setDefaultexcludes ( boolean useDefaultExcludes ) { this . useDefaultExcludes = useDefaultExcludes ; } protected DirectoryScanner getDirectoryScanner ( File baseDir ) { fileset . setDir ( baseDir ) ; fileset . setDefaultexcludes ( useDefaultExcludes ) ; return fileset . getDirectoryScanner ( project ) ; } public void setIncludesfile ( File includesfile ) { fileset . setIncludesfile ( includesfile ) ; } public void setExcludesfile ( File excludesfile ) { fileset . setExcludesfile ( excludesfile ) ; } } 	0	['14', '3', '12', '20', '41', '0', '13', '7', '13', '0.461538462', '174', '1', '1', '0.74', '0.392857143', '0', '0', '11.28571429', '6', '1.5', '0']
package org . apache . tools . ant . util ; public class IdentityMapper implements FileNameMapper { public void setFrom ( String from ) { } public void setTo ( String to ) { } public String [ ] mapFileName ( String sourceFileName ) { return new String [ ] { sourceFileName } ; } } 	0	['4', '1', '0', '2', '5', '6', '1', '1', '4', '2', '16', '0', '0', '0', '0.875', '0', '0', '3', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ExitException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . CommandlineJava ; import org . apache . tools . ant . types . Path ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . io . * ; public class ExecuteJava { private Commandline javaCommand = null ; private Path classpath = null ; private CommandlineJava . SysProperties sysProperties = null ; public void setJavaCommand ( Commandline javaCommand ) { this . javaCommand = javaCommand ; } public void setClasspath ( Path p ) { classpath = p ; } public void setSystemProperties ( CommandlineJava . SysProperties s ) { sysProperties = s ; } public void setOutput ( PrintStream out ) { } public void execute ( Project project ) throws BuildException { final String classname = javaCommand . getExecutable ( ) ; final Object [ ] argument = { javaCommand . getArguments ( ) } ; AntClassLoader loader = null ; try { if ( sysProperties != null ) { sysProperties . setSystem ( ) ; } final Class [ ] param = { Class . forName ( "[Ljava.lang.String;" ) } ; Class target = null ; if ( classpath == null ) { target = Class . forName ( classname ) ; } else { loader = new AntClassLoader ( project . getCoreLoader ( ) , project , classpath , false ) ; loader . setIsolated ( true ) ; loader . setThreadContextLoader ( ) ; target = loader . forceLoadClass ( classname ) ; AntClassLoader . initializeClass ( target ) ; } final Method main = target . getMethod ( "main" , param ) ; main . invoke ( null , argument ) ; } catch ( NullPointerException e ) { throw new BuildException ( "Could not find main() method in " + classname ) ; } catch ( ClassNotFoundException e ) { throw new BuildException ( "Could not find " + classname + ". Make sure you have it in your classpath" ) ; } catch ( InvocationTargetException e ) { Throwable t = e . getTargetException ( ) ; if ( ! ( t instanceof SecurityException ) ) { throw new BuildException ( t ) ; } else { throw ( SecurityException ) t ; } } catch ( Exception e ) { throw new BuildException ( e ) ; } finally { if ( loader != null ) { loader . resetThreadContextLoader ( ) ; loader . cleanup ( ) ; } if ( sysProperties != null ) { sysProperties . restoreSystem ( ) ; } } } } 	0	['6', '1', '0', '7', '28', '1', '1', '6', '6', '0.6', '173', '1', '3', '0', '0.305555556', '0', '0', '27.33333333', '1', '0.8333', '0']
package org . apache . tools . ant ; public abstract class Task extends ProjectComponent { protected Target target = null ; protected String description = null ; protected Location location = Location . UNKNOWN_LOCATION ; protected String taskName = null ; protected String taskType = null ; protected RuntimeConfigurable wrapper ; public void setOwningTarget ( Target target ) { this . target = target ; } public Target getOwningTarget ( ) { return target ; } public void setTaskName ( String name ) { this . taskName = name ; } public String getTaskName ( ) { return taskName ; } void setTaskType ( String type ) { this . taskType = type ; } public void setDescription ( String desc ) { description = desc ; } public String getDescription ( ) { return description ; } public void init ( ) throws BuildException { } public void execute ( ) throws BuildException { } public Location getLocation ( ) { return location ; } public void setLocation ( Location location ) { this . location = location ; } public RuntimeConfigurable getRuntimeConfigurableWrapper ( ) { if ( wrapper == null ) { wrapper = new RuntimeConfigurable ( this , getTaskName ( ) ) ; } return wrapper ; } protected void setRuntimeConfigurableWrapper ( RuntimeConfigurable wrapper ) { this . wrapper = wrapper ; } public void maybeConfigure ( ) throws BuildException { if ( wrapper != null ) { wrapper . maybeConfigure ( project ) ; } } protected void handleOutput ( String line ) { log ( line , Project . MSG_INFO ) ; } protected void handleErrorOutput ( String line ) { log ( line , Project . MSG_ERR ) ; } public void log ( String msg ) { log ( msg , Project . MSG_INFO ) ; } public void log ( String msg , int msgLevel ) { project . log ( this , msg , msgLevel ) ; } public final void perform ( ) { try { project . fireTaskStarted ( this ) ; maybeConfigure ( ) ; execute ( ) ; project . fireTaskFinished ( this , null ) ; } catch ( RuntimeException exc ) { if ( exc instanceof BuildException ) { BuildException be = ( BuildException ) exc ; if ( be . getLocation ( ) == Location . UNKNOWN_LOCATION ) { be . setLocation ( getLocation ( ) ) ; } } project . fireTaskFinished ( this , exc ) ; throw exc ; } } } 	0	['20', '2', '40', '100', '28', '158', '96', '6', '16', '0.877192982', '164', '1', '3', '0.321428571', '0.258333333', '1', '3', '6.9', '3', '1.1', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; public class Reference { private String refid ; public Reference ( ) { super ( ) ; } public Reference ( String id ) { this ( ) ; setRefId ( id ) ; } public void setRefId ( String id ) { refid = id ; } public String getRefId ( ) { return refid ; } public Object getReferencedObject ( Project project ) throws BuildException { if ( refid == null ) { throw new BuildException ( "No reference specified" ) ; } Object o = project . getReferences ( ) . get ( refid ) ; if ( o == null ) { throw new BuildException ( "Reference " + refid + " not found." ) ; } return o ; } } 	0	['5', '1', '0', '19', '12', '4', '17', '2', '5', '0.25', '55', '1', '0', '0', '0.533333333', '0', '0', '9.8', '1', '0.6', '0']
package org . apache . tools . mail ; import java . io . * ; import java . net . * ; import java . util . * ; public class MailMessage { String host ; String from ; Vector to , cc ; Hashtable headers ; MailPrintStream out ; SmtpResponseReader in ; Socket socket ; public MailMessage ( ) throws IOException { this ( "localhost" ) ; } public MailMessage ( String host ) throws IOException { this . host = host ; to = new Vector ( ) ; cc = new Vector ( ) ; headers = new Hashtable ( ) ; setHeader ( "X-Mailer" , "org.apache.tools.mail.MailMessage (jakarta.apache.org)" ) ; connect ( ) ; sendHelo ( ) ; } public void from ( String from ) throws IOException { sendFrom ( from ) ; this . from = from ; } public void to ( String to ) throws IOException { sendRcpt ( to ) ; this . to . addElement ( to ) ; } public void cc ( String cc ) throws IOException { sendRcpt ( cc ) ; this . cc . addElement ( cc ) ; } public void bcc ( String bcc ) throws IOException { sendRcpt ( bcc ) ; } public void setSubject ( String subj ) { headers . put ( "Subject" , subj ) ; } public void setHeader ( String name , String value ) { headers . put ( name , value ) ; } public PrintStream getPrintStream ( ) throws IOException { setFromHeader ( ) ; setToHeader ( ) ; setCcHeader ( ) ; sendData ( ) ; flushHeaders ( ) ; return out ; } void setFromHeader ( ) { setHeader ( "From" , from ) ; } void setToHeader ( ) { setHeader ( "To" , vectorToList ( to ) ) ; } void setCcHeader ( ) { setHeader ( "Cc" , vectorToList ( cc ) ) ; } String vectorToList ( Vector v ) { StringBuffer buf = new StringBuffer ( ) ; Enumeration e = v . elements ( ) ; while ( e . hasMoreElements ( ) ) { buf . append ( e . nextElement ( ) ) ; if ( e . hasMoreElements ( ) ) { buf . append ( ", " ) ; } } return buf . toString ( ) ; } void flushHeaders ( ) throws IOException { Enumeration e = headers . keys ( ) ; while ( e . hasMoreElements ( ) ) { String name = ( String ) e . nextElement ( ) ; String value = ( String ) headers . get ( name ) ; out . println ( name + ": " + value ) ; } out . println ( ) ; out . flush ( ) ; } public void sendAndClose ( ) throws IOException { sendDot ( ) ; sendQuit ( ) ; disconnect ( ) ; } static String sanitizeAddress ( String s ) { int paramDepth = 0 ; int start = 0 ; int end = 0 ; int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = s . charAt ( i ) ; if ( c == '(' ) { paramDepth ++ ; if ( start == 0 ) { end = i ; } } else if ( c == ')' ) { paramDepth -- ; if ( end == 0 ) { start = i + 1 ; } } else if ( paramDepth == 0 && c == '<' ) { start = i + 1 ; } else if ( paramDepth == 0 && c == '>' ) { end = i ; } } if ( end == 0 ) { end = len ; } return s . substring ( start , end ) ; } void connect ( ) throws IOException { socket = new Socket ( host , 25 ) ; out = new MailPrintStream ( new BufferedOutputStream ( socket . getOutputStream ( ) ) ) ; in = new SmtpResponseReader ( socket . getInputStream ( ) ) ; getReady ( ) ; } void getReady ( ) throws IOException { String response = in . getResponse ( ) ; int [ ] ok = { 220 } ; if ( ! isResponseOK ( response , ok ) ) { throw new IOException ( "Didn't get introduction from server: " + response ) ; } } void sendHelo ( ) throws IOException { String local = InetAddress . getLocalHost ( ) . getHostName ( ) ; int [ ] ok = { 250 } ; send ( "HELO " + local , ok ) ; } void sendFrom ( String from ) throws IOException { int [ ] ok = { 250 } ; send ( "MAIL FROM: " + "<" + sanitizeAddress ( from ) + ">" , ok ) ; } void sendRcpt ( String rcpt ) throws IOException { int [ ] ok = { 250 , 251 } ; send ( "RCPT TO: " + "<" + sanitizeAddress ( rcpt ) + ">" , ok ) ; } void sendData ( ) throws IOException { int [ ] ok = { 354 } ; send ( "DATA" , ok ) ; } void sendDot ( ) throws IOException { int [ ] ok = { 250 } ; send ( "\r\n." , ok ) ; } void sendQuit ( ) throws IOException { int [ ] ok = { 221 } ; send ( "QUIT" , ok ) ; } void send ( String msg , int [ ] ok ) throws IOException { out . rawPrint ( msg + "\r\n" ) ; String response = in . getResponse ( ) ; if ( ! isResponseOK ( response , ok ) ) { throw new IOException ( "Unexpected reply to command: " + msg + ": " + response ) ; } } boolean isResponseOK ( String response , int [ ] ok ) { for ( int i = 0 ; i < ok . length ; i ++ ) { if ( response . startsWith ( "" + ok [ i ] ) ) { return true ; } } return false ; } void disconnect ( ) throws IOException { if ( out != null ) out . close ( ) ; if ( in != null ) in . close ( ) ; if ( socket != null ) socket . close ( ) ; } } class MailPrintStream extends PrintStream { int lastChar ; public MailPrintStream ( OutputStream out ) { super ( out , true ) ; } public void write ( int b ) { if ( b == '\n' && lastChar != '\r' ) { rawWrite ( '\r' ) ; rawWrite ( b ) ; } else if ( b == '.' && lastChar == '\n' ) { rawWrite ( '.' ) ; rawWrite ( b ) ; } else { rawWrite ( b ) ; } lastChar = b ; } public void write ( byte buf [ ] , int off , int len ) { for ( int i = 0 ; i < len ; i ++ ) { write ( buf [ off + i ] ) ; } } void rawWrite ( int b ) { super . write ( b ) ; } void rawPrint ( String s ) { int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { rawWrite ( s . charAt ( i ) ) ; } } } 	0	['27', '1', '0', '3', '63', '297', '1', '2', '10', '0.778846154', '527', '0', '2', '0', '0.37962963', '0', '0', '18.22222222', '11', '1.4444', '0']
package org . apache . tools . ant ; import java . util . EventListener ; public interface BuildListener extends EventListener { public void buildStarted ( BuildEvent event ) ; public void buildFinished ( BuildEvent event ) ; public void targetStarted ( BuildEvent event ) ; public void targetFinished ( BuildEvent event ) ; public void taskStarted ( BuildEvent event ) ; public void taskFinished ( BuildEvent event ) ; public void messageLogged ( BuildEvent event ) ; } 	0	['7', '1', '0', '11', '7', '21', '10', '1', '7', '2', '7', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . ZipFileSet ; import org . apache . tools . zip . * ; import java . io . * ; import java . util . Vector ; public class Ear extends Jar { private File deploymentDescriptor ; private boolean descriptorAdded ; public Ear ( ) { super ( ) ; archiveType = "ear" ; emptyBehavior = "create" ; } public void setEarfile ( File earFile ) { super . setZipfile ( earFile ) ; } public void setAppxml ( File descr ) { deploymentDescriptor = descr ; if ( ! deploymentDescriptor . exists ( ) ) throw new BuildException ( "Deployment descriptor: " + deploymentDescriptor + " does not exist." ) ; ZipFileSet fs = new ZipFileSet ( ) ; fs . setDir ( new File ( deploymentDescriptor . getParent ( ) ) ) ; fs . setIncludes ( deploymentDescriptor . getName ( ) ) ; fs . setFullpath ( "META-INF/application.xml" ) ; super . addFileset ( fs ) ; } public void addArchives ( ZipFileSet fs ) { log ( "addArchives called" , Project . MSG_DEBUG ) ; fs . setPrefix ( "/" ) ; super . addFileset ( fs ) ; } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( deploymentDescriptor == null ) { throw new BuildException ( "appxml attribute is required" , location ) ; } super . initZipOutputStream ( zOut ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath ) throws IOException { if ( vPath . equalsIgnoreCase ( "META-INF/aplication.xml" ) ) { if ( deploymentDescriptor == null || ! deploymentDescriptor . equals ( file ) || descriptorAdded ) { log ( "Warning: selected " + archiveType + " files include a META-INF/application.xml which will be ignored " + "(please use appxml attribute to " + archiveType + " task)" , Project . MSG_WARN ) ; } else { super . zipFile ( file , zOut , vPath ) ; descriptorAdded = true ; } } else { super . zipFile ( file , zOut , vPath ) ; } } protected void cleanUp ( ) { descriptorAdded = false ; super . cleanUp ( ) ; } } 	0	['7', '6', '0', '8', '31', '13', '0', '8', '4', '0.75', '151', '1', '0', '0.9625', '0.4', '4', '9', '20.28571429', '2', '1', '0']
package org . apache . tools . ant . util . regexp ; import org . apache . tools . ant . BuildException ; import java . util . Vector ; public interface RegexpMatcher { public void setPattern ( String pattern ) throws BuildException ; public String getPattern ( ) ; public boolean matches ( String argument ) ; public Vector getGroups ( String argument ) ; } 	0	['4', '1', '0', '5', '4', '6', '4', '1', '4', '2', '4', '0', '0', '0', '0.875', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . PatternSet ; import java . util . * ; public class CompileTask extends Javac { protected Vector taskList = new Vector ( ) ; public Taskdef createTaskdef ( ) { Taskdef task = new Taskdef ( ) ; taskList . addElement ( task ) ; return task ; } public void init ( ) { log ( "!! CompileTask is deprecated. !!" ) ; log ( "Use <taskdef> elements nested into <target>s instead" ) ; for ( Enumeration e = taskList . elements ( ) ; e . hasMoreElements ( ) ; ) { Taskdef task = ( Taskdef ) e . nextElement ( ) ; String source = task . getClassname ( ) . replace ( '.' , '/' ) + ".java" ; PatternSet . NameEntry include = super . createInclude ( ) ; include . setName ( "**/" + source ) ; } super . init ( ) ; super . execute ( ) ; for ( Enumeration e = taskList . elements ( ) ; e . hasMoreElements ( ) ; ) { Taskdef task = ( Taskdef ) e . nextElement ( ) ; task . init ( ) ; } } public void execute ( ) { } } 	0	['4', '5', '0', '6', '21', '0', '0', '6', '4', '0.333333333', '87', '1', '0', '0.98089172', '1', '1', '1', '20.5', '3', '1.25', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . rmic . * ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . * ; import java . io . File ; import java . io . IOException ; import java . rmi . Remote ; import java . util . Vector ; public class Rmic extends MatchingTask { private static final String FAIL_MSG = "Rmic failed, messages should have been provided." ; private File baseDir ; private String classname ; private File sourceBase ; private String stubVersion ; private Path compileClasspath ; private Path extdirs ; private boolean verify = false ; private boolean filtering = false ; private boolean iiop = false ; private String iiopopts ; private boolean idl = false ; private String idlopts ; private boolean debug = false ; private boolean includeAntRuntime = true ; private boolean includeJavaRuntime = false ; private Vector compileList = new Vector ( ) ; private ClassLoader loader = null ; public void setBase ( File base ) { this . baseDir = base ; } public File getBase ( ) { return this . baseDir ; } public void setClassname ( String classname ) { this . classname = classname ; } public String getClassname ( ) { return classname ; } public void setSourceBase ( File sourceBase ) { this . sourceBase = sourceBase ; } public File getSourceBase ( ) { return sourceBase ; } public void setStubVersion ( String stubVersion ) { this . stubVersion = stubVersion ; } public String getStubVersion ( ) { return stubVersion ; } public void setFiltering ( boolean filter ) { filtering = filter ; } public boolean getFiltering ( ) { return filtering ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public boolean getDebug ( ) { return debug ; } public void setClasspath ( Path classpath ) { if ( compileClasspath == null ) { compileClasspath = classpath ; } else { compileClasspath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( compileClasspath == null ) { compileClasspath = new Path ( project ) ; } return compileClasspath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public Path getClasspath ( ) { return compileClasspath ; } public void setVerify ( boolean verify ) { this . verify = verify ; } public boolean getVerify ( ) { return verify ; } public void setIiop ( boolean iiop ) { this . iiop = iiop ; } public boolean getIiop ( ) { return iiop ; } public void setIiopopts ( String iiopopts ) { this . iiopopts = iiopopts ; } public String getIiopopts ( ) { return iiopopts ; } public void setIdl ( boolean idl ) { this . idl = idl ; } public boolean getIdl ( ) { return idl ; } public void setIdlopts ( String idlopts ) { this . idlopts = idlopts ; } public String getIdlopts ( ) { return idlopts ; } public Vector getFileList ( ) { return compileList ; } public void setIncludeantruntime ( boolean include ) { includeAntRuntime = include ; } public boolean getIncludeantruntime ( ) { return includeAntRuntime ; } public void setIncludejavaruntime ( boolean include ) { includeJavaRuntime = include ; } public boolean getIncludejavaruntime ( ) { return includeJavaRuntime ; } public void setExtdirs ( Path extdirs ) { if ( this . extdirs == null ) { this . extdirs = extdirs ; } else { this . extdirs . append ( extdirs ) ; } } public Path createExtdirs ( ) { if ( extdirs == null ) { extdirs = new Path ( project ) ; } return extdirs . createPath ( ) ; } public Path getExtdirs ( ) { return extdirs ; } public Vector getCompileList ( ) { return compileList ; } public void execute ( ) throws BuildException { if ( baseDir == null ) { throw new BuildException ( "base attribute must be set!" , location ) ; } if ( ! baseDir . exists ( ) ) { throw new BuildException ( "base does not exist!" , location ) ; } if ( verify ) { log ( "Verify has been turned on." , Project . MSG_INFO ) ; } String compiler = project . getProperty ( "build.rmic" ) ; RmicAdapter adapter = RmicAdapterFactory . getRmic ( compiler , this ) ; adapter . setRmic ( this ) ; Path classpath = adapter . getClasspath ( ) ; loader = new AntClassLoader ( project , classpath ) ; if ( classname == null ) { DirectoryScanner ds = this . getDirectoryScanner ( baseDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( baseDir , files , adapter . getMapper ( ) ) ; } else { scanDir ( baseDir , new String [ ] { classname . replace ( '.' , File . separatorChar ) + ".class" } , adapter . getMapper ( ) ) ; } int fileCount = compileList . size ( ) ; if ( fileCount > 0 ) { log ( "RMI Compiling " + fileCount + " class" + ( fileCount > 1 ? "es" : "" ) + " to " + baseDir , Project . MSG_INFO ) ; if ( ! adapter . execute ( ) ) { throw new BuildException ( FAIL_MSG , location ) ; } } if ( null != sourceBase && ! baseDir . equals ( sourceBase ) ) { if ( idl ) { log ( "Cannot determine sourcefiles in idl mode, " , Project . MSG_WARN ) ; log ( "sourcebase attribute will be ignored." , Project . MSG_WARN ) ; } else { for ( int j = 0 ; j < fileCount ; j ++ ) { moveGeneratedFile ( baseDir , sourceBase , ( String ) compileList . elementAt ( j ) , adapter ) ; } } } compileList . removeAllElements ( ) ; } private void moveGeneratedFile ( File baseDir , File sourceBaseFile , String classname , RmicAdapter adapter ) throws BuildException { String classFileName = classname . replace ( '.' , File . separatorChar ) + ".class" ; String [ ] generatedFiles = adapter . getMapper ( ) . mapFileName ( classFileName ) ; for ( int i = 0 ; i < generatedFiles . length ; i ++ ) { String sourceFileName = classFileName . substring ( 0 , classFileName . length ( ) - 6 ) + ".java" ; File oldFile = new File ( baseDir , sourceFileName ) ; File newFile = new File ( sourceBaseFile , sourceFileName ) ; try { project . copyFile ( oldFile , newFile , filtering ) ; oldFile . delete ( ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + oldFile + " to " + newFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } } } protected void scanDir ( File baseDir , String files [ ] , FileNameMapper mapper ) { String [ ] newFiles = files ; if ( idl ) { log ( "will leave uptodate test to rmic implementation in idl mode." , Project . MSG_VERBOSE ) ; } else if ( iiop && iiopopts != null && iiopopts . indexOf ( "-always" ) > - 1 ) { log ( "no uptodate test as -always option has been specified" , Project . MSG_VERBOSE ) ; } else { SourceFileScanner sfs = new SourceFileScanner ( this ) ; newFiles = sfs . restrict ( files , baseDir , baseDir , mapper ) ; } for ( int i = 0 ; i < newFiles . length ; i ++ ) { String classname = newFiles [ i ] . replace ( File . separatorChar , '.' ) ; classname = classname . substring ( 0 , classname . lastIndexOf ( ".class" ) ) ; compileList . addElement ( classname ) ; } } public boolean isValidRmiRemote ( String classname ) { try { Class testClass = loader . loadClass ( classname ) ; if ( testClass . isInterface ( ) && ! iiop && ! idl ) { return false ; } return isValidRmiRemote ( testClass ) ; } catch ( ClassNotFoundException e ) { log ( "Unable to verify class " + classname + ". It could not be found." , Project . MSG_WARN ) ; } catch ( NoClassDefFoundError e ) { log ( "Unable to verify class " + classname + ". It is not defined." , Project . MSG_WARN ) ; } catch ( Throwable t ) { log ( "Unable to verify class " + classname + ". Loading caused Exception: " + t . getMessage ( ) , Project . MSG_WARN ) ; } return false ; } public Class getRemoteInterface ( Class testClass ) { if ( Remote . class . isAssignableFrom ( testClass ) ) { Class [ ] interfaces = testClass . getInterfaces ( ) ; if ( interfaces != null ) { for ( int i = 0 ; i < interfaces . length ; i ++ ) { if ( Remote . class . isAssignableFrom ( interfaces [ i ] ) ) { return interfaces [ i ] ; } } } } return null ; } private boolean isValidRmiRemote ( Class testClass ) { return getRemoteInterface ( testClass ) != null ; } public ClassLoader getLoader ( ) { return loader ; } } 	0	['44', '4', '0', '19', '91', '802', '6', '14', '40', '0.94369645', '724', '0.947368421', '2', '0.644628099', '0.156818182', '3', '3', '15.02272727', '7', '1.4091', '0']
package org . apache . tools . ant ; import java . util . Vector ; public class UnknownElement extends Task { private String elementName ; private Task realTask ; private Vector children = new Vector ( ) ; public UnknownElement ( String elementName ) { this . elementName = elementName ; } public String getTag ( ) { return elementName ; } public void maybeConfigure ( ) throws BuildException { realTask = makeTask ( this , wrapper ) ; wrapper . setProxy ( realTask ) ; realTask . setRuntimeConfigurableWrapper ( wrapper ) ; handleChildren ( realTask , wrapper ) ; realTask . maybeConfigure ( ) ; target . replaceTask ( this , realTask ) ; } public void execute ( ) { if ( realTask == null ) { throw new BuildException ( "Could not create task of type: " + elementName , location ) ; } realTask . execute ( ) ; } public void addChild ( UnknownElement child ) { children . addElement ( child ) ; } protected void handleChildren ( Object parent , RuntimeConfigurable parentWrapper ) throws BuildException { if ( parent instanceof TaskAdapter ) { parent = ( ( TaskAdapter ) parent ) . getProxy ( ) ; } Class parentClass = parent . getClass ( ) ; IntrospectionHelper ih = IntrospectionHelper . getHelper ( parentClass ) ; for ( int i = 0 ; i < children . size ( ) ; i ++ ) { RuntimeConfigurable childWrapper = parentWrapper . getChild ( i ) ; UnknownElement child = ( UnknownElement ) children . elementAt ( i ) ; Object realChild = null ; if ( parent instanceof TaskContainer ) { realChild = makeTask ( child , childWrapper ) ; ( ( TaskContainer ) parent ) . addTask ( ( Task ) realChild ) ; } else { realChild = ih . createElement ( project , parent , child . getTag ( ) ) ; } childWrapper . setProxy ( realChild ) ; if ( realChild instanceof Task ) { ( ( Task ) realChild ) . setRuntimeConfigurableWrapper ( childWrapper ) ; } child . handleChildren ( realChild , childWrapper ) ; if ( realChild instanceof Task ) { ( ( Task ) realChild ) . maybeConfigure ( ) ; } } } protected Task makeTask ( UnknownElement ue , RuntimeConfigurable w ) { Task task = project . createTask ( ue . getTag ( ) ) ; if ( task == null ) { log ( "Could not create task of type: " + elementName + " Common solutions" + " are adding the task to defaults.properties and executing bin/bootstrap" , Project . MSG_DEBUG ) ; throw new BuildException ( "Could not create task of type: " + elementName + ". Common solutions are to use taskdef to declare" + " your task, or, if this is an optional task," + " to put the optional.jar in the lib directory of" + " your ant installation (ANT_HOME)." , location ) ; } task . setLocation ( getLocation ( ) ) ; String id = w . getAttributes ( ) . getValue ( "id" ) ; if ( id != null ) { project . addReference ( id , task ) ; } task . setOwningTarget ( target ) ; task . init ( ) ; return task ; } public String getTaskName ( ) { return realTask == null ? super . getTaskName ( ) : realTask . getTaskName ( ) ; } } 	0	['8', '3', '0', '12', '38', '4', '3', '10', '6', '0.523809524', '243', '1', '1', '0.840909091', '0.35', '1', '4', '29', '3', '1.375', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; public class CVSPass extends Task { private String cvsRoot = null ; private File passFile = null ; private String password = null ; private final String EOL = System . getProperty ( "line.separator" ) ; private final char shifts [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 114 , 120 , 53 , 79 , 96 , 109 , 72 , 108 , 70 , 64 , 76 , 67 , 116 , 74 , 68 , 87 , 111 , 52 , 75 , 119 , 49 , 34 , 82 , 81 , 95 , 65 , 112 , 86 , 118 , 110 , 122 , 105 , 41 , 57 , 83 , 43 , 46 , 102 , 40 , 89 , 38 , 103 , 45 , 50 , 42 , 123 , 91 , 35 , 125 , 55 , 54 , 66 , 124 , 126 , 59 , 47 , 92 , 71 , 115 , 78 , 88 , 107 , 106 , 56 , 36 , 121 , 117 , 104 , 101 , 100 , 69 , 73 , 99 , 63 , 94 , 93 , 39 , 37 , 61 , 48 , 58 , 113 , 32 , 90 , 44 , 98 , 60 , 51 , 33 , 97 , 62 , 77 , 84 , 80 , 85 , 223 , 225 , 216 , 187 , 166 , 229 , 189 , 222 , 188 , 141 , 249 , 148 , 200 , 184 , 136 , 248 , 190 , 199 , 170 , 181 , 204 , 138 , 232 , 218 , 183 , 255 , 234 , 220 , 247 , 213 , 203 , 226 , 193 , 174 , 172 , 228 , 252 , 217 , 201 , 131 , 230 , 197 , 211 , 145 , 238 , 161 , 179 , 160 , 212 , 207 , 221 , 254 , 173 , 202 , 146 , 224 , 151 , 140 , 196 , 205 , 130 , 135 , 133 , 143 , 246 , 192 , 159 , 244 , 239 , 185 , 168 , 215 , 144 , 139 , 165 , 180 , 157 , 147 , 186 , 214 , 176 , 227 , 231 , 219 , 169 , 175 , 156 , 206 , 198 , 129 , 164 , 150 , 210 , 154 , 177 , 134 , 127 , 182 , 128 , 158 , 208 , 162 , 132 , 167 , 209 , 149 , 241 , 153 , 251 , 237 , 236 , 171 , 195 , 243 , 233 , 253 , 240 , 194 , 250 , 191 , 155 , 142 , 137 , 245 , 235 , 163 , 242 , 178 , 152 } ; public CVSPass ( ) { passFile = new File ( System . getProperty ( "user.home" ) + "/.cvspass" ) ; } public final void execute ( ) throws BuildException { if ( cvsRoot == null ) throw new BuildException ( "cvsroot is required" ) ; if ( password == null ) throw new BuildException ( "password is required" ) ; log ( "cvsRoot: " + cvsRoot , project . MSG_DEBUG ) ; log ( "password: " + password , project . MSG_DEBUG ) ; log ( "passFile: " + passFile , project . MSG_DEBUG ) ; try { StringBuffer buf = new StringBuffer ( ) ; if ( passFile . exists ( ) ) { BufferedReader reader = new BufferedReader ( new FileReader ( passFile ) ) ; String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { if ( ! line . startsWith ( cvsRoot ) ) { buf . append ( line + EOL ) ; } } reader . close ( ) ; } String pwdfile = buf . toString ( ) + cvsRoot + " A" + mangle ( password ) ; log ( "Writing -> " + pwdfile , project . MSG_DEBUG ) ; PrintWriter writer = new PrintWriter ( new FileWriter ( passFile ) ) ; writer . println ( pwdfile ) ; writer . close ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } private final String mangle ( String password ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < password . length ( ) ; i ++ ) { buf . append ( shifts [ password . charAt ( i ) ] ) ; } return buf . toString ( ) ; } public void setCvsroot ( String cvsRoot ) { this . cvsRoot = cvsRoot ; } public void setPassfile ( File passFile ) { this . passFile = passFile ; } public void setPassword ( String password ) { this . password = password ; } } 	0	['6', '3', '0', '2', '29', '0', '0', '2', '5', '0.64', '1260', '1', '0', '0.880952381', '0.555555556', '1', '1', '208.1666667', '2', '1', '0']
package org . apache . tools . ant ; public abstract class ProjectComponent { protected Project project = null ; public void setProject ( Project project ) { this . project = project ; } public Project getProject ( ) { return project ; } public void log ( String msg ) { log ( msg , Project . MSG_INFO ) ; } public void log ( String msg , int msgLevel ) { if ( project != null ) { project . log ( msg , msgLevel ) ; } } } 	0	['5', '1', '2', '59', '7', '0', '59', '1', '5', '0', '33', '1', '1', '0', '0.45', '0', '0', '5.4', '2', '1', '0']
package org . apache . tools . ant ; import java . io . * ; import java . util . * ; import javax . xml . parsers . * ; import org . w3c . dom . * ; import org . apache . tools . ant . util . DOMElementWriter ; public class XmlLogger implements BuildListener { private static final DocumentBuilder builder = getDocumentBuilder ( ) ; private static DocumentBuilder getDocumentBuilder ( ) { try { return DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; } catch ( Exception exc ) { throw new ExceptionInInitializerError ( exc ) ; } } private static final String BUILD_TAG = "build" ; private static final String TARGET_TAG = "target" ; private static final String TASK_TAG = "task" ; private static final String MESSAGE_TAG = "message" ; private static final String NAME_ATTR = "name" ; private static final String TIME_ATTR = "time" ; private static final String PRIORITY_ATTR = "priority" ; private static final String LOCATION_ATTR = "location" ; private static final String ERROR_ATTR = "error" ; private Document doc ; private Hashtable tasks = new Hashtable ( ) ; private Hashtable targets = new Hashtable ( ) ; private Hashtable threadStacks = new Hashtable ( ) ; private TimedElement buildElement = null ; static private class TimedElement { long startTime ; Element element ; } public XmlLogger ( ) { } public void buildStarted ( BuildEvent event ) { buildElement = new TimedElement ( ) ; buildElement . startTime = System . currentTimeMillis ( ) ; doc = builder . newDocument ( ) ; buildElement . element = doc . createElement ( BUILD_TAG ) ; } public void buildFinished ( BuildEvent event ) { long totalTime = System . currentTimeMillis ( ) - buildElement . startTime ; buildElement . element . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; if ( event . getException ( ) != null ) { buildElement . element . setAttribute ( ERROR_ATTR , event . getException ( ) . toString ( ) ) ; } try { String outFilename = event . getProject ( ) . getProperty ( "XmlLogger.file" ) ; if ( outFilename == null ) { outFilename = "log.xml" ; } Writer out = new OutputStreamWriter ( new FileOutputStream ( outFilename ) , "UTF8" ) ; out . write ( "<?xml:stylesheet type=\"text/xsl\" href=\"log.xsl\"?>\n\n" ) ; ( new DOMElementWriter ( ) ) . write ( buildElement . element , out , 0 , "\t" ) ; out . flush ( ) ; out . close ( ) ; } catch ( IOException exc ) { throw new BuildException ( "Unable to close log file" , exc ) ; } buildElement = null ; } private Stack getStack ( ) { Stack threadStack = ( Stack ) threadStacks . get ( Thread . currentThread ( ) ) ; if ( threadStack == null ) { threadStack = new Stack ( ) ; threadStacks . put ( Thread . currentThread ( ) , threadStack ) ; } return threadStack ; } public void targetStarted ( BuildEvent event ) { Target target = event . getTarget ( ) ; TimedElement targetElement = new TimedElement ( ) ; targetElement . startTime = System . currentTimeMillis ( ) ; targetElement . element = doc . createElement ( TARGET_TAG ) ; targetElement . element . setAttribute ( NAME_ATTR , target . getName ( ) ) ; targets . put ( target , targetElement ) ; getStack ( ) . push ( targetElement ) ; } public void targetFinished ( BuildEvent event ) { Target target = event . getTarget ( ) ; TimedElement targetElement = ( TimedElement ) targets . get ( target ) ; if ( targetElement != null ) { long totalTime = System . currentTimeMillis ( ) - targetElement . startTime ; targetElement . element . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; TimedElement parentElement = null ; Stack threadStack = getStack ( ) ; if ( ! threadStack . empty ( ) ) { TimedElement poppedStack = ( TimedElement ) threadStack . pop ( ) ; if ( poppedStack != targetElement ) { throw new RuntimeException ( "Mismatch - popped element = " + poppedStack . element + " finished task element = " + targetElement . element ) ; } if ( ! threadStack . empty ( ) ) { parentElement = ( TimedElement ) threadStack . peek ( ) ; } } if ( parentElement == null ) { buildElement . element . appendChild ( targetElement . element ) ; } else { parentElement . element . appendChild ( targetElement . element ) ; } } } public void taskStarted ( BuildEvent event ) { Task task = event . getTask ( ) ; TimedElement taskElement = new TimedElement ( ) ; taskElement . startTime = System . currentTimeMillis ( ) ; taskElement . element = doc . createElement ( TASK_TAG ) ; String name = task . getClass ( ) . getName ( ) ; int pos = name . lastIndexOf ( "." ) ; if ( pos != - 1 ) { name = name . substring ( pos + 1 ) ; } taskElement . element . setAttribute ( NAME_ATTR , name ) ; taskElement . element . setAttribute ( LOCATION_ATTR , event . getTask ( ) . getLocation ( ) . toString ( ) ) ; tasks . put ( task , taskElement ) ; getStack ( ) . push ( taskElement ) ; } public void taskFinished ( BuildEvent event ) { Task task = event . getTask ( ) ; TimedElement taskElement = ( TimedElement ) tasks . get ( task ) ; if ( taskElement != null ) { long totalTime = System . currentTimeMillis ( ) - taskElement . startTime ; taskElement . element . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; Target target = task . getOwningTarget ( ) ; TimedElement targetElement = ( TimedElement ) targets . get ( target ) ; if ( targetElement == null ) { buildElement . element . appendChild ( taskElement . element ) ; } else { targetElement . element . appendChild ( taskElement . element ) ; } Stack threadStack = getStack ( ) ; if ( ! threadStack . empty ( ) ) { TimedElement poppedStack = ( TimedElement ) threadStack . pop ( ) ; if ( poppedStack != taskElement ) { throw new RuntimeException ( "Mismatch - popped element = " + poppedStack . element + " finished task element = " + taskElement . element ) ; } } } } public void messageLogged ( BuildEvent event ) { Element messageElement = doc . createElement ( MESSAGE_TAG ) ; String name = "debug" ; switch ( event . getPriority ( ) ) { case Project . MSG_ERR : name = "error" ; break ; case Project . MSG_WARN : name = "warn" ; break ; case Project . MSG_INFO : name = "info" ; break ; default : name = "debug" ; break ; } messageElement . setAttribute ( PRIORITY_ATTR , name ) ; Text messageText = doc . createCDATASection ( event . getMessage ( ) ) ; messageElement . appendChild ( messageText ) ; TimedElement parentElement = null ; Task task = event . getTask ( ) ; Target target = event . getTarget ( ) ; if ( task != null ) { parentElement = ( TimedElement ) tasks . get ( task ) ; } if ( parentElement == null && target != null ) { parentElement = ( TimedElement ) targets . get ( target ) ; } if ( parentElement == null ) { Stack threadStack = ( Stack ) threadStacks . get ( Thread . currentThread ( ) ) ; if ( threadStack != null ) { if ( ! threadStack . empty ( ) ) { parentElement = ( TimedElement ) threadStack . peek ( ) ; } } } if ( parentElement != null ) { parentElement . element . appendChild ( messageElement ) ; } else { buildElement . element . appendChild ( messageElement ) ; } } } 	0	['11', '1', '0', '11', '61', '0', '0', '11', '8', '0.913333333', '517', '1', '1', '0', '0.8', '0', '0', '44.63636364', '9', '2.7273', '0']
package org . apache . tools . ant . util ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . regexp . RegexpMatcher ; import org . apache . tools . ant . util . regexp . RegexpMatcherFactory ; import java . util . Enumeration ; import java . util . Vector ; public class RegexpPatternMapper implements FileNameMapper { protected RegexpMatcher reg = null ; protected char [ ] to = null ; protected StringBuffer result = new StringBuffer ( ) ; public RegexpPatternMapper ( ) throws BuildException { reg = ( new RegexpMatcherFactory ( ) ) . newRegexpMatcher ( ) ; } public void setFrom ( String from ) throws BuildException { try { reg . setPattern ( from ) ; } catch ( NoClassDefFoundError e ) { throw new BuildException ( "Cannot load regular expression matcher" , e ) ; } } public void setTo ( String to ) { this . to = to . toCharArray ( ) ; } public String [ ] mapFileName ( String sourceFileName ) { if ( reg == null || to == null || ! reg . matches ( sourceFileName ) ) { return null ; } return new String [ ] { replaceReferences ( sourceFileName ) } ; } protected String replaceReferences ( String source ) { Vector v = reg . getGroups ( source ) ; result . setLength ( 0 ) ; for ( int i = 0 ; i < to . length ; i ++ ) { if ( to [ i ] == '\\' ) { if ( ++ i < to . length ) { int value = Character . digit ( to [ i ] , 10 ) ; if ( value > - 1 ) { result . append ( ( String ) v . elementAt ( value ) ) ; } else { result . append ( to [ i ] ) ; } } else { result . append ( '\\' ) ; } } else { result . append ( to [ i ] ) ; } } return result . toString ( ) ; } } 	0	['5', '1', '0', '4', '20', '0', '0', '4', '4', '0.333333333', '144', '1', '1', '0', '0.9', '0', '0', '27.2', '5', '2.2', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; public class ManifestException extends Exception { public ManifestException ( String msg ) { super ( msg ) ; } } 	0	['1', '3', '0', '4', '2', '0', '4', '0', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . FileUtils ; public class XSLTProcess extends MatchingTask { private File destDir = null ; private File baseDir = null ; private String xslFile = null ; private String targetExtension = ".html" ; private Vector params = new Vector ( ) ; private File inFile = null ; private File outFile = null ; private String processor ; private Path classpath = null ; private XSLTLiaison liaison ; private boolean stylesheetLoaded = false ; private boolean force = false ; private FileUtils fileUtils ; public XSLTProcess ( ) { fileUtils = FileUtils . newFileUtils ( ) ; } public void execute ( ) throws BuildException { DirectoryScanner scanner ; String [ ] list ; String [ ] dirs ; if ( xslFile == null ) { throw new BuildException ( "no stylesheet specified" , location ) ; } if ( baseDir == null ) { baseDir = project . resolveFile ( "." ) ; } liaison = getLiaison ( ) ; log ( "Using " + liaison . getClass ( ) . toString ( ) , Project . MSG_VERBOSE ) ; File stylesheet = project . resolveFile ( xslFile ) ; if ( ! stylesheet . exists ( ) ) { stylesheet = fileUtils . resolveFile ( baseDir , xslFile ) ; if ( stylesheet . exists ( ) ) { log ( "DEPRECATED - the style attribute should be relative to the project\'s" ) ; log ( "             basedir, not the tasks\'s basedir." ) ; } } if ( inFile != null && outFile != null ) { process ( inFile , outFile , stylesheet ) ; return ; } if ( destDir == null ) { String msg = "destdir attributes must be set!" ; throw new BuildException ( msg ) ; } scanner = getDirectoryScanner ( baseDir ) ; log ( "Transforming into " + destDir , Project . MSG_INFO ) ; list = scanner . getIncludedFiles ( ) ; for ( int i = 0 ; i < list . length ; ++ i ) { process ( baseDir , list [ i ] , destDir , stylesheet ) ; } dirs = scanner . getIncludedDirectories ( ) ; for ( int j = 0 ; j < dirs . length ; ++ j ) { list = new File ( baseDir , dirs [ j ] ) . list ( ) ; for ( int i = 0 ; i < list . length ; ++ i ) process ( baseDir , list [ i ] , destDir , stylesheet ) ; } } public void setForce ( boolean force ) { this . force = force ; } public void setBasedir ( File dir ) { baseDir = dir ; } public void setDestdir ( File dir ) { destDir = dir ; } public void setExtension ( String name ) { targetExtension = name ; } public void setStyle ( String xslFile ) { this . xslFile = xslFile ; } public void setClasspath ( Path classpath ) { createClasspath ( ) . append ( classpath ) ; } public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( project ) ; } return classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setProcessor ( String processor ) { this . processor = processor ; } private void resolveProcessor ( String proc ) throws Exception { if ( proc . equals ( "trax" ) ) { final Class clazz = loadClass ( "org.apache.tools.ant.taskdefs.optional.TraXLiaison" ) ; liaison = ( XSLTLiaison ) clazz . newInstance ( ) ; } else if ( proc . equals ( "xslp" ) ) { log ( "DEPRECATED - xslp processor is deprecated. Use trax or xalan instead." ) ; final Class clazz = loadClass ( "org.apache.tools.ant.taskdefs.optional.XslpLiaison" ) ; liaison = ( XSLTLiaison ) clazz . newInstance ( ) ; } else if ( proc . equals ( "xalan" ) ) { final Class clazz = loadClass ( "org.apache.tools.ant.taskdefs.optional.XalanLiaison" ) ; liaison = ( XSLTLiaison ) clazz . newInstance ( ) ; } else { liaison = ( XSLTLiaison ) loadClass ( proc ) . newInstance ( ) ; } } private Class loadClass ( String classname ) throws Exception { if ( classpath == null ) { return Class . forName ( classname ) ; } else { AntClassLoader al = new AntClassLoader ( project , classpath ) ; Class c = al . loadClass ( classname ) ; AntClassLoader . initializeClass ( c ) ; return c ; } } public void setOut ( File outFile ) { this . outFile = outFile ; } public void setIn ( File inFile ) { this . inFile = inFile ; } private void process ( File baseDir , String xmlFile , File destDir , File stylesheet ) throws BuildException { String fileExt = targetExtension ; File outFile = null ; File inFile = null ; try { long styleSheetLastModified = stylesheet . lastModified ( ) ; inFile = new File ( baseDir , xmlFile ) ; int dotPos = xmlFile . lastIndexOf ( '.' ) ; if ( dotPos > 0 ) { outFile = new File ( destDir , xmlFile . substring ( 0 , xmlFile . lastIndexOf ( '.' ) ) + fileExt ) ; } else { outFile = new File ( destDir , xmlFile + fileExt ) ; } if ( force || inFile . lastModified ( ) > outFile . lastModified ( ) || styleSheetLastModified > outFile . lastModified ( ) ) { ensureDirectoryFor ( outFile ) ; log ( "Transforming into " + destDir ) ; configureLiaison ( stylesheet ) ; liaison . transform ( inFile , outFile ) ; } } catch ( Exception ex ) { log ( "Failed to process " + inFile , Project . MSG_INFO ) ; if ( outFile != null ) { outFile . delete ( ) ; } throw new BuildException ( ex ) ; } } private void process ( File inFile , File outFile , File stylesheet ) throws BuildException { try { long styleSheetLastModified = stylesheet . lastModified ( ) ; log ( "In file " + inFile + " time: " + inFile . lastModified ( ) , Project . MSG_DEBUG ) ; log ( "Out file " + outFile + " time: " + outFile . lastModified ( ) , Project . MSG_DEBUG ) ; log ( "Style file " + xslFile + " time: " + styleSheetLastModified , Project . MSG_DEBUG ) ; if ( force || inFile . lastModified ( ) > outFile . lastModified ( ) || styleSheetLastModified > outFile . lastModified ( ) ) { ensureDirectoryFor ( outFile ) ; log ( "Processing " + inFile + " to " + outFile , Project . MSG_INFO ) ; configureLiaison ( stylesheet ) ; liaison . transform ( inFile , outFile ) ; } } catch ( Exception ex ) { log ( "Failed to process " + inFile , Project . MSG_INFO ) ; if ( outFile != null ) outFile . delete ( ) ; throw new BuildException ( ex ) ; } } private void ensureDirectoryFor ( File targetFile ) throws BuildException { File directory = new File ( targetFile . getParent ( ) ) ; if ( ! directory . exists ( ) ) { if ( ! directory . mkdirs ( ) ) { throw new BuildException ( "Unable to create directory: " + directory . getAbsolutePath ( ) ) ; } } } protected XSLTLiaison getLiaison ( ) { if ( liaison == null ) { if ( processor != null ) { try { resolveProcessor ( processor ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } else { try { resolveProcessor ( "trax" ) ; } catch ( Throwable e1 ) { try { resolveProcessor ( "xslp" ) ; } catch ( Throwable e2 ) { try { resolveProcessor ( "xalan" ) ; } catch ( Throwable e3 ) { e3 . printStackTrace ( ) ; e2 . printStackTrace ( ) ; throw new BuildException ( e1 ) ; } } } } } return liaison ; } public Param createParam ( ) { Param p = new Param ( ) ; params . addElement ( p ) ; return p ; } public class Param { private String name = null ; private String expression = null ; public void setName ( String name ) { this . name = name ; } public void setExpression ( String expression ) { this . expression = expression ; } public String getName ( ) throws BuildException { if ( name == null ) throw new BuildException ( "Name attribute is missing." ) ; return name ; } public String getExpression ( ) throws BuildException { if ( expression == null ) throw new BuildException ( "Expression attribute is missing." ) ; return expression ; } } protected void configureLiaison ( File stylesheet ) throws BuildException { if ( stylesheetLoaded ) { return ; } stylesheetLoaded = true ; try { log ( "Loading stylesheet " + stylesheet , Project . MSG_INFO ) ; liaison . setStylesheet ( stylesheet ) ; for ( Enumeration e = params . elements ( ) ; e . hasMoreElements ( ) ; ) { Param p = ( Param ) e . nextElement ( ) ; liaison . addParam ( p . getName ( ) , p . getExpression ( ) ) ; } } catch ( Exception ex ) { log ( "Failed to read stylesheet " + stylesheet , Project . MSG_INFO ) ; throw new BuildException ( ex ) ; } } } 	0	['21', '4', '0', '13', '73', '128', '1', '13', '14', '0.85', '737', '1', '3', '0.795918367', '0.301587302', '3', '3', '33.47619048', '3', '1.0952', '0']
package org . apache . tools . ant . taskdefs ; import java . util . * ; import java . io . * ; import org . apache . tools . ant . BuildException ; public class Manifest { static public final String ATTRIBUTE_MANIFEST_VERSION = "Manifest-Version" ; static public final String ATTRIBUTE_SIGNATURE_VERSION = "Signature-Version" ; static public final String ATTRIBUTE_NAME = "Name" ; static public final String ATTRIBUTE_FROM = "From" ; static public final String DEFAULT_MANIFEST_VERSION = "1.0" ; static public final int MAX_LINE_LENGTH = 70 ; static public class Attribute { private String name = null ; private String value = null ; public Attribute ( ) { } public Attribute ( String line ) throws ManifestException { parse ( line ) ; } public Attribute ( String name , String value ) { this . name = name ; this . value = value ; } public boolean equals ( Object rhs ) { if ( ! ( rhs instanceof Attribute ) ) { return false ; } Attribute rhsAttribute = ( Attribute ) rhs ; return ( name != null && rhsAttribute . name != null && name . toLowerCase ( ) . equals ( rhsAttribute . name . toLowerCase ( ) ) && value != null && value . equals ( rhsAttribute . value ) ) ; } public void parse ( String line ) throws ManifestException { int index = line . indexOf ( ": " ) ; if ( index == - 1 ) { throw new ManifestException ( "Manifest line \"" + line + "\" is not valid" ) ; } name = line . substring ( 0 , index ) ; value = line . substring ( index + 2 ) ; } public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } public void addContinuation ( String line ) { value += line . substring ( 1 ) ; } public void write ( PrintWriter writer ) throws IOException { String line = name + ": " + value ; while ( line . getBytes ( ) . length > MAX_LINE_LENGTH ) { int breakIndex = MAX_LINE_LENGTH ; String section = line . substring ( 0 , breakIndex ) ; while ( section . getBytes ( ) . length > MAX_LINE_LENGTH && breakIndex > 0 ) { breakIndex -- ; section = line . substring ( 0 , breakIndex ) ; } if ( breakIndex == 0 ) { throw new IOException ( "Unable to write manifest line " + name + ": " + value ) ; } writer . println ( section ) ; line = " " + line . substring ( breakIndex ) ; } writer . println ( line ) ; } } static public class Section { private Vector warnings = new Vector ( ) ; private String name = null ; private Hashtable attributes = new Hashtable ( ) ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public String read ( BufferedReader reader ) throws ManifestException , IOException { Attribute attribute = null ; while ( true ) { String line = reader . readLine ( ) ; if ( line == null || line . length ( ) == 0 ) { return null ; } if ( line . charAt ( 0 ) == ' ' ) { if ( attribute == null ) { throw new ManifestException ( "Can't start an attribute with a continuation line " + line ) ; } attribute . addContinuation ( line ) ; } else { attribute = new Attribute ( line ) ; String nameReadAhead = addAttributeAndCheck ( attribute ) ; if ( nameReadAhead != null ) { return nameReadAhead ; } } } } public void merge ( Section section ) throws ManifestException { if ( name == null && section . getName ( ) != null || name != null && ! ( name . equalsIgnoreCase ( section . getName ( ) ) ) ) { throw new ManifestException ( "Unable to merge sections with different names" ) ; } for ( Enumeration e = section . attributes . keys ( ) ; e . hasMoreElements ( ) ; ) { String attributeName = ( String ) e . nextElement ( ) ; attributes . put ( attributeName , section . attributes . get ( attributeName ) ) ; } for ( Enumeration e = section . warnings . elements ( ) ; e . hasMoreElements ( ) ; ) { warnings . addElement ( e . nextElement ( ) ) ; } } public void write ( PrintWriter writer ) throws IOException { if ( name != null ) { Attribute nameAttr = new Attribute ( ATTRIBUTE_NAME , name ) ; nameAttr . write ( writer ) ; } for ( Enumeration e = attributes . elements ( ) ; e . hasMoreElements ( ) ; ) { Attribute attribute = ( Attribute ) e . nextElement ( ) ; attribute . write ( writer ) ; } writer . println ( ) ; } public String getAttributeValue ( String attributeName ) { Attribute attribute = ( Attribute ) attributes . get ( attributeName . toLowerCase ( ) ) ; if ( attribute == null ) { return null ; } return attribute . getValue ( ) ; } public void removeAttribute ( String attributeName ) { attributes . remove ( attributeName . toLowerCase ( ) ) ; } public void addConfiguredAttribute ( Attribute attribute ) throws ManifestException { String check = addAttributeAndCheck ( attribute ) ; if ( check != null ) { throw new BuildException ( "Use the \"name\" attribute of the <section> element rather than using " + "the \"Name\" attribute" ) ; } } public String addAttributeAndCheck ( Attribute attribute ) throws ManifestException { if ( attribute . getName ( ) == null || attribute . getValue ( ) == null ) { throw new BuildException ( "Attributes must have name and value" ) ; } if ( attribute . getName ( ) . equalsIgnoreCase ( ATTRIBUTE_NAME ) ) { warnings . addElement ( "\"" + ATTRIBUTE_NAME + "\" attributes should not occur in the " + "main section and must be the first element in all " + "other sections: \"" + attribute . getName ( ) + ": " + attribute . getValue ( ) + "\"" ) ; return attribute . getValue ( ) ; } if ( attribute . getName ( ) . toLowerCase ( ) . startsWith ( ATTRIBUTE_FROM . toLowerCase ( ) ) ) { warnings . addElement ( "Manifest attributes should not start with \"" + ATTRIBUTE_FROM + "\" in \"" + attribute . getName ( ) + ": " + attribute . getValue ( ) + "\"" ) ; } else if ( attributes . containsKey ( attribute . getName ( ) . toLowerCase ( ) ) ) { throw new ManifestException ( "The attribute \"" + attribute . getName ( ) + "\" may not " + "occur more than once in the same section" ) ; } else { attributes . put ( attribute . getName ( ) . toLowerCase ( ) , attribute ) ; } return null ; } public Enumeration getWarnings ( ) { return warnings . elements ( ) ; } public boolean equals ( Object rhs ) { if ( ! ( rhs instanceof Section ) ) { return false ; } Section rhsSection = ( Section ) rhs ; if ( attributes . size ( ) != rhsSection . attributes . size ( ) ) { return false ; } for ( Enumeration e = attributes . elements ( ) ; e . hasMoreElements ( ) ; ) { Attribute attribute = ( Attribute ) e . nextElement ( ) ; Attribute rshAttribute = ( Attribute ) rhsSection . attributes . get ( attribute . getName ( ) . toLowerCase ( ) ) ; if ( ! attribute . equals ( rshAttribute ) ) { return false ; } } return true ; } } private String manifestVersion = DEFAULT_MANIFEST_VERSION ; private Section mainSection = new Section ( ) ; private Hashtable sections = new Hashtable ( ) ; public Manifest ( ) { } public Manifest ( InputStream is ) throws ManifestException , IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( is ) ) ; String nextSectionName = mainSection . read ( reader ) ; String readManifestVersion = mainSection . getAttributeValue ( ATTRIBUTE_MANIFEST_VERSION ) ; if ( readManifestVersion != null ) { manifestVersion = readManifestVersion ; mainSection . removeAttribute ( ATTRIBUTE_MANIFEST_VERSION ) ; } String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { if ( line . length ( ) == 0 ) { continue ; } Section section = new Section ( ) ; if ( nextSectionName == null ) { Attribute sectionName = new Attribute ( line ) ; if ( ! sectionName . getName ( ) . equalsIgnoreCase ( ATTRIBUTE_NAME ) ) { throw new ManifestException ( "Manifest sections should start with a \"" + ATTRIBUTE_NAME + "\" attribute and not \"" + sectionName . getName ( ) + "\"" ) ; } nextSectionName = sectionName . getValue ( ) ; } else { Attribute firstAttribute = new Attribute ( line ) ; section . addAttributeAndCheck ( firstAttribute ) ; } section . setName ( nextSectionName ) ; nextSectionName = section . read ( reader ) ; addConfiguredSection ( section ) ; } } public void addConfiguredSection ( Section section ) throws ManifestException { if ( section . getName ( ) == null ) { throw new BuildException ( "Sections must have a name" ) ; } sections . put ( section . getName ( ) . toLowerCase ( ) , section ) ; } public void addConfiguredAttribute ( Attribute attribute ) throws ManifestException { mainSection . addConfiguredAttribute ( attribute ) ; } public void merge ( Manifest other ) throws ManifestException { manifestVersion = other . manifestVersion ; mainSection . merge ( other . mainSection ) ; for ( Enumeration e = other . sections . keys ( ) ; e . hasMoreElements ( ) ; ) { String sectionName = ( String ) e . nextElement ( ) ; Section ourSection = ( Section ) sections . get ( sectionName ) ; Section otherSection = ( Section ) other . sections . get ( sectionName ) ; if ( ourSection == null ) { sections . put ( sectionName . toLowerCase ( ) , otherSection ) ; } else { ourSection . merge ( otherSection ) ; } } } public void write ( PrintWriter writer ) throws IOException { writer . println ( ATTRIBUTE_MANIFEST_VERSION + ": " + manifestVersion ) ; String signatureVersion = mainSection . getAttributeValue ( ATTRIBUTE_SIGNATURE_VERSION ) ; if ( signatureVersion != null ) { writer . println ( ATTRIBUTE_SIGNATURE_VERSION + ": " + signatureVersion ) ; mainSection . removeAttribute ( ATTRIBUTE_SIGNATURE_VERSION ) ; } mainSection . write ( writer ) ; if ( signatureVersion != null ) { try { mainSection . addConfiguredAttribute ( new Attribute ( ATTRIBUTE_SIGNATURE_VERSION , signatureVersion ) ) ; } catch ( ManifestException e ) { } } for ( Enumeration e = sections . elements ( ) ; e . hasMoreElements ( ) ; ) { Section section = ( Section ) e . nextElement ( ) ; section . write ( writer ) ; } } public String toString ( ) { StringWriter sw = new StringWriter ( ) ; try { write ( new PrintWriter ( sw ) ) ; } catch ( IOException e ) { return null ; } return sw . toString ( ) ; } public Enumeration getWarnings ( ) { Vector warnings = new Vector ( ) ; for ( Enumeration e2 = mainSection . getWarnings ( ) ; e2 . hasMoreElements ( ) ; ) { warnings . addElement ( e2 . nextElement ( ) ) ; } for ( Enumeration e = sections . elements ( ) ; e . hasMoreElements ( ) ; ) { Section section = ( Section ) e . nextElement ( ) ; for ( Enumeration e2 = section . getWarnings ( ) ; e2 . hasMoreElements ( ) ; ) { warnings . addElement ( e2 . nextElement ( ) ) ; } } return warnings . elements ( ) ; } public boolean equals ( Object rhs ) { if ( ! ( rhs instanceof Manifest ) ) { return false ; } Manifest rhsManifest = ( Manifest ) rhs ; if ( ! manifestVersion . equals ( rhsManifest . manifestVersion ) ) { return false ; } if ( sections . size ( ) != rhsManifest . sections . size ( ) ) { return false ; } if ( ! mainSection . equals ( rhsManifest . mainSection ) ) { return false ; } for ( Enumeration e = sections . elements ( ) ; e . hasMoreElements ( ) ; ) { Section section = ( Section ) e . nextElement ( ) ; Section rhsSection = ( Section ) rhsManifest . sections . get ( section . getName ( ) . toLowerCase ( ) ) ; if ( ! section . equals ( rhsSection ) ) { return false ; } } return true ; } } 	0	['9', '1', '0', '5', '53', '0', '1', '4', '9', '0.819444444', '396', '0.333333333', '1', '0', '0.238095238', '0', '0', '42', '7', '1.7778', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; class JavacOutputStream extends OutputStream { private Task task ; private StringBuffer line ; private boolean errorFlag = false ; JavacOutputStream ( Task task ) { this . task = task ; line = new StringBuffer ( ) ; } public void write ( int c ) throws IOException { char cc = ( char ) c ; if ( cc == '\r' || cc == '\n' ) { if ( line . length ( ) > 0 ) { processLine ( ) ; } } else { line . append ( cc ) ; } } private void processLine ( ) { String s = line . toString ( ) ; if ( s . indexOf ( "error" ) > - 1 ) { errorFlag = true ; } task . log ( s ) ; line = new StringBuffer ( ) ; } boolean getErrorFlag ( ) { return errorFlag ; } } 	0	['4', '2', '0', '1', '11', '0', '0', '1', '1', '0.222222222', '68', '1', '1', '0.625', '0.5', '1', '1', '15.25', '2', '1', '0']
package org . apache . tools . ant ; import java . io . * ; import java . util . * ; import java . text . * ; import org . apache . tools . ant . types . FilterSet ; import org . apache . tools . ant . types . FilterSetCollection ; import org . apache . tools . ant . util . FileUtils ; public class Project { public static final int MSG_ERR = 0 ; public static final int MSG_WARN = 1 ; public static final int MSG_INFO = 2 ; public static final int MSG_VERBOSE = 3 ; public static final int MSG_DEBUG = 4 ; private static final String VISITING = "VISITING" ; private static final String VISITED = "VISITED" ; private static String javaVersion ; public static final String JAVA_1_0 = "1.0" ; public static final String JAVA_1_1 = "1.1" ; public static final String JAVA_1_2 = "1.2" ; public static final String JAVA_1_3 = "1.3" ; public static final String JAVA_1_4 = "1.4" ; public static final String TOKEN_START = FilterSet . DEFAULT_TOKEN_START ; public static final String TOKEN_END = FilterSet . DEFAULT_TOKEN_END ; private String name ; private String description ; private Hashtable properties = new Hashtable ( ) ; private Hashtable userProperties = new Hashtable ( ) ; private Hashtable references = new Hashtable ( ) ; private String defaultTarget ; private Hashtable dataClassDefinitions = new Hashtable ( ) ; private Hashtable taskClassDefinitions = new Hashtable ( ) ; private Hashtable targets = new Hashtable ( ) ; private FilterSet globalFilterSet = new FilterSet ( ) ; private FilterSetCollection globalFilters = new FilterSetCollection ( globalFilterSet ) ; private File baseDir ; private Vector listeners = new Vector ( ) ; private ClassLoader coreLoader = null ; private Hashtable threadTasks = new Hashtable ( ) ; static { try { javaVersion = JAVA_1_0 ; Class . forName ( "java.lang.Void" ) ; javaVersion = JAVA_1_1 ; Class . forName ( "java.lang.ThreadLocal" ) ; javaVersion = JAVA_1_2 ; Class . forName ( "java.lang.StrictMath" ) ; javaVersion = JAVA_1_3 ; Class . forName ( "java.lang.CharSequence" ) ; javaVersion = JAVA_1_4 ; } catch ( ClassNotFoundException cnfe ) { } } private FileUtils fileUtils ; public Project ( ) { fileUtils = FileUtils . newFileUtils ( ) ; } public void init ( ) throws BuildException { setJavaVersionProperty ( ) ; String defs = "/org/apache/tools/ant/taskdefs/defaults.properties" ; try { Properties props = new Properties ( ) ; InputStream in = this . getClass ( ) . getResourceAsStream ( defs ) ; if ( in == null ) { throw new BuildException ( "Can't load default task list" ) ; } props . load ( in ) ; in . close ( ) ; Enumeration enum = props . propertyNames ( ) ; while ( enum . hasMoreElements ( ) ) { String key = ( String ) enum . nextElement ( ) ; String value = props . getProperty ( key ) ; try { Class taskClass = Class . forName ( value ) ; addTaskDefinition ( key , taskClass ) ; } catch ( NoClassDefFoundError ncdfe ) { } catch ( ClassNotFoundException cnfe ) { } } } catch ( IOException ioe ) { throw new BuildException ( "Can't load default task list" ) ; } String dataDefs = "/org/apache/tools/ant/types/defaults.properties" ; try { Properties props = new Properties ( ) ; InputStream in = this . getClass ( ) . getResourceAsStream ( dataDefs ) ; if ( in == null ) { throw new BuildException ( "Can't load default datatype list" ) ; } props . load ( in ) ; in . close ( ) ; Enumeration enum = props . propertyNames ( ) ; while ( enum . hasMoreElements ( ) ) { String key = ( String ) enum . nextElement ( ) ; String value = props . getProperty ( key ) ; try { Class dataClass = Class . forName ( value ) ; addDataTypeDefinition ( key , dataClass ) ; } catch ( NoClassDefFoundError ncdfe ) { } catch ( ClassNotFoundException cnfe ) { } } } catch ( IOException ioe ) { throw new BuildException ( "Can't load default datatype list" ) ; } setSystemProperties ( ) ; } public void setCoreLoader ( ClassLoader coreLoader ) { this . coreLoader = coreLoader ; } public ClassLoader getCoreLoader ( ) { return coreLoader ; } public void addBuildListener ( BuildListener listener ) { listeners . addElement ( listener ) ; } public void removeBuildListener ( BuildListener listener ) { listeners . removeElement ( listener ) ; } public Vector getBuildListeners ( ) { return listeners ; } public void log ( String msg ) { log ( msg , MSG_INFO ) ; } public void log ( String msg , int msgLevel ) { fireMessageLogged ( this , msg , msgLevel ) ; } public void log ( Task task , String msg , int msgLevel ) { fireMessageLogged ( task , msg , msgLevel ) ; } public void log ( Target target , String msg , int msgLevel ) { fireMessageLogged ( target , msg , msgLevel ) ; } public FilterSet getGlobalFilterSet ( ) { return globalFilterSet ; } public void setProperty ( String name , String value ) { if ( null != userProperties . get ( name ) ) { log ( "Override ignored for user property " + name , MSG_VERBOSE ) ; return ; } log ( "Setting project property: " + name + " -> " + value , MSG_DEBUG ) ; properties . put ( name , value ) ; } public void setUserProperty ( String name , String value ) { log ( "Setting ro project property: " + name + " -> " + value , MSG_DEBUG ) ; userProperties . put ( name , value ) ; properties . put ( name , value ) ; } public String getProperty ( String name ) { if ( name == null ) return null ; String property = ( String ) properties . get ( name ) ; return property ; } public String getUserProperty ( String name ) { if ( name == null ) return null ; String property = ( String ) userProperties . get ( name ) ; return property ; } public Hashtable getProperties ( ) { return properties ; } public Hashtable getUserProperties ( ) { return userProperties ; } public void setDefaultTarget ( String defaultTarget ) { this . defaultTarget = defaultTarget ; } public String getDefaultTarget ( ) { return defaultTarget ; } public void setDefault ( String defaultTarget ) { this . defaultTarget = defaultTarget ; } public void setName ( String name ) { setUserProperty ( "ant.project.name" , name ) ; this . name = name ; } public String getName ( ) { return name ; } public void setDescription ( String description ) { this . description = description ; } public String getDescription ( ) { return description ; } public void addFilter ( String token , String value ) { if ( token == null ) { return ; } globalFilterSet . addFilter ( new FilterSet . Filter ( token , value ) ) ; } public Hashtable getFilters ( ) { return globalFilterSet . getFilterHash ( ) ; } public void setBasedir ( String baseD ) throws BuildException { setBaseDir ( new File ( baseD ) ) ; } public void setBaseDir ( File baseDir ) throws BuildException { baseDir = fileUtils . normalize ( baseDir . getAbsolutePath ( ) ) ; if ( ! baseDir . exists ( ) ) throw new BuildException ( "Basedir " + baseDir . getAbsolutePath ( ) + " does not exist" ) ; if ( ! baseDir . isDirectory ( ) ) throw new BuildException ( "Basedir " + baseDir . getAbsolutePath ( ) + " is not a directory" ) ; this . baseDir = baseDir ; setProperty ( "basedir" , this . baseDir . getPath ( ) ) ; String msg = "Project base dir set to: " + this . baseDir ; log ( msg , MSG_VERBOSE ) ; } public File getBaseDir ( ) { if ( baseDir == null ) { try { setBasedir ( "." ) ; } catch ( BuildException ex ) { ex . printStackTrace ( ) ; } } return baseDir ; } public static String getJavaVersion ( ) { return javaVersion ; } public void setJavaVersionProperty ( ) { setProperty ( "ant.java.version" , javaVersion ) ; if ( javaVersion == JAVA_1_0 ) { throw new BuildException ( "Ant cannot work on Java 1.0" ) ; } log ( "Detected Java version: " + javaVersion + " in: " + System . getProperty ( "java.home" ) , MSG_VERBOSE ) ; log ( "Detected OS: " + System . getProperty ( "os.name" ) , MSG_VERBOSE ) ; } public void setSystemProperties ( ) { Properties systemP = System . getProperties ( ) ; Enumeration e = systemP . keys ( ) ; while ( e . hasMoreElements ( ) ) { Object name = e . nextElement ( ) ; String value = systemP . get ( name ) . toString ( ) ; this . setProperty ( name . toString ( ) , value ) ; } } public void addTaskDefinition ( String taskName , Class taskClass ) { String msg = " +User task: " + taskName + "     " + taskClass . getName ( ) ; log ( msg , MSG_DEBUG ) ; taskClassDefinitions . put ( taskName , taskClass ) ; } public Hashtable getTaskDefinitions ( ) { return taskClassDefinitions ; } public void addDataTypeDefinition ( String typeName , Class typeClass ) { String msg = " +User datatype: " + typeName + "     " + typeClass . getName ( ) ; log ( msg , MSG_DEBUG ) ; dataClassDefinitions . put ( typeName , typeClass ) ; } public Hashtable getDataTypeDefinitions ( ) { return dataClassDefinitions ; } public void addTarget ( Target target ) { String name = target . getName ( ) ; if ( targets . get ( name ) != null ) { throw new BuildException ( "Duplicate target: `" + name + "'" ) ; } addOrReplaceTarget ( name , target ) ; } public void addTarget ( String targetName , Target target ) throws BuildException { if ( targets . get ( targetName ) != null ) { throw new BuildException ( "Duplicate target: `" + targetName + "'" ) ; } addOrReplaceTarget ( targetName , target ) ; } public void addOrReplaceTarget ( Target target ) { addOrReplaceTarget ( target . getName ( ) , target ) ; } public void addOrReplaceTarget ( String targetName , Target target ) { String msg = " +Target: " + targetName ; log ( msg , MSG_DEBUG ) ; target . setProject ( this ) ; targets . put ( targetName , target ) ; } public Hashtable getTargets ( ) { return targets ; } public Task createTask ( String taskType ) throws BuildException { Class c = ( Class ) taskClassDefinitions . get ( taskType ) ; if ( c == null ) return null ; try { Object o = c . newInstance ( ) ; Task task = null ; if ( o instanceof Task ) { task = ( Task ) o ; } else { TaskAdapter taskA = new TaskAdapter ( ) ; taskA . setProxy ( o ) ; task = taskA ; } task . setProject ( this ) ; task . setTaskType ( taskType ) ; task . setTaskName ( taskType ) ; String msg = "   +Task: " + taskType ; log ( msg , MSG_DEBUG ) ; return task ; } catch ( Throwable t ) { String msg = "Could not create task of type: " + taskType + " due to " + t ; throw new BuildException ( msg , t ) ; } } public Object createDataType ( String typeName ) throws BuildException { Class c = ( Class ) dataClassDefinitions . get ( typeName ) ; if ( c == null ) return null ; try { java . lang . reflect . Constructor ctor = null ; boolean noArg = false ; try { ctor = c . getConstructor ( new Class [ 0 ] ) ; noArg = true ; } catch ( NoSuchMethodException nse ) { ctor = c . getConstructor ( new Class [ ] { getClass ( ) } ) ; noArg = false ; } Object o = null ; if ( noArg ) { o = ctor . newInstance ( new Object [ 0 ] ) ; } else { o = ctor . newInstance ( new Object [ ] { this } ) ; } if ( o instanceof ProjectComponent ) { ( ( ProjectComponent ) o ) . setProject ( this ) ; } String msg = "   +DataType: " + typeName ; log ( msg , MSG_DEBUG ) ; return o ; } catch ( java . lang . reflect . InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; String msg = "Could not create datatype of type: " + typeName + " due to " + t ; throw new BuildException ( msg , t ) ; } catch ( Throwable t ) { String msg = "Could not create datatype of type: " + typeName + " due to " + t ; throw new BuildException ( msg , t ) ; } } public void executeTargets ( Vector targetNames ) throws BuildException { Throwable error = null ; for ( int i = 0 ; i < targetNames . size ( ) ; i ++ ) { executeTarget ( ( String ) targetNames . elementAt ( i ) ) ; } } public void demuxOutput ( String line , boolean isError ) { Task task = ( Task ) threadTasks . get ( Thread . currentThread ( ) ) ; if ( task == null ) { fireMessageLogged ( this , line , isError ? MSG_ERR : MSG_INFO ) ; } else { if ( isError ) { task . handleErrorOutput ( line ) ; } else { task . handleOutput ( line ) ; } } } public void executeTarget ( String targetName ) throws BuildException { if ( targetName == null ) { String msg = "No target specified" ; throw new BuildException ( msg ) ; } Vector sortedTargets = topoSort ( targetName , targets ) ; int curidx = 0 ; Target curtarget ; do { curtarget = ( Target ) sortedTargets . elementAt ( curidx ++ ) ; curtarget . performTasks ( ) ; } while ( ! curtarget . getName ( ) . equals ( targetName ) ) ; } public File resolveFile ( String fileName , File rootDir ) { return fileUtils . resolveFile ( rootDir , fileName ) ; } public File resolveFile ( String fileName ) { return fileUtils . resolveFile ( baseDir , fileName ) ; } static public String translatePath ( String to_process ) { if ( to_process == null || to_process . length ( ) == 0 ) { return "" ; } StringBuffer path = new StringBuffer ( to_process . length ( ) + 50 ) ; PathTokenizer tokenizer = new PathTokenizer ( to_process ) ; while ( tokenizer . hasMoreTokens ( ) ) { String pathComponent = tokenizer . nextToken ( ) ; pathComponent = pathComponent . replace ( '/' , File . separatorChar ) ; pathComponent = pathComponent . replace ( '\\' , File . separatorChar ) ; if ( path . length ( ) != 0 ) { path . append ( File . pathSeparatorChar ) ; } path . append ( pathComponent ) ; } return path . toString ( ) ; } public void copyFile ( String sourceFile , String destFile ) throws IOException { fileUtils . copyFile ( sourceFile , destFile ) ; } public void copyFile ( String sourceFile , String destFile , boolean filtering ) throws IOException { fileUtils . copyFile ( sourceFile , destFile , filtering ? globalFilters : null ) ; } public void copyFile ( String sourceFile , String destFile , boolean filtering , boolean overwrite ) throws IOException { fileUtils . copyFile ( sourceFile , destFile , filtering ? globalFilters : null , overwrite ) ; } public void copyFile ( String sourceFile , String destFile , boolean filtering , boolean overwrite , boolean preserveLastModified ) throws IOException { fileUtils . copyFile ( sourceFile , destFile , filtering ? globalFilters : null , overwrite , preserveLastModified ) ; } public void copyFile ( File sourceFile , File destFile ) throws IOException { fileUtils . copyFile ( sourceFile , destFile ) ; } public void copyFile ( File sourceFile , File destFile , boolean filtering ) throws IOException { fileUtils . copyFile ( sourceFile , destFile , filtering ? globalFilters : null ) ; } public void copyFile ( File sourceFile , File destFile , boolean filtering , boolean overwrite ) throws IOException { fileUtils . copyFile ( sourceFile , destFile , filtering ? globalFilters : null , overwrite ) ; } public void copyFile ( File sourceFile , File destFile , boolean filtering , boolean overwrite , boolean preserveLastModified ) throws IOException { fileUtils . copyFile ( sourceFile , destFile , filtering ? globalFilters : null , overwrite , preserveLastModified ) ; } public void setFileLastModified ( File file , long time ) throws BuildException { if ( getJavaVersion ( ) == JAVA_1_1 ) { log ( "Cannot change the modification time of " + file + " in JDK 1.1" , Project . MSG_WARN ) ; return ; } fileUtils . setFileLastModified ( file , time ) ; log ( "Setting modification time for " + file , MSG_VERBOSE ) ; } public static boolean toBoolean ( String s ) { return ( s . equalsIgnoreCase ( "on" ) || s . equalsIgnoreCase ( "true" ) || s . equalsIgnoreCase ( "yes" ) ) ; } public final Vector topoSort ( String root , Hashtable targets ) throws BuildException { Vector ret = new Vector ( ) ; Hashtable state = new Hashtable ( ) ; Stack visiting = new Stack ( ) ; tsort ( root , targets , state , visiting , ret ) ; log ( "Build sequence for target `" + root + "' is " + ret , MSG_VERBOSE ) ; for ( Enumeration en = targets . keys ( ) ; en . hasMoreElements ( ) ; ) { String curTarget = ( String ) ( en . nextElement ( ) ) ; String st = ( String ) state . get ( curTarget ) ; if ( st == null ) { tsort ( curTarget , targets , state , visiting , ret ) ; } else if ( st == VISITING ) { throw new RuntimeException ( "Unexpected node in visiting state: " + curTarget ) ; } } log ( "Complete build sequence is " + ret , MSG_VERBOSE ) ; return ret ; } private final void tsort ( String root , Hashtable targets , Hashtable state , Stack visiting , Vector ret ) throws BuildException { state . put ( root , VISITING ) ; visiting . push ( root ) ; Target target = ( Target ) ( targets . get ( root ) ) ; if ( target == null ) { StringBuffer sb = new StringBuffer ( "Target `" ) ; sb . append ( root ) ; sb . append ( "' does not exist in this project. " ) ; visiting . pop ( ) ; if ( ! visiting . empty ( ) ) { String parent = ( String ) visiting . peek ( ) ; sb . append ( "It is used from target `" ) ; sb . append ( parent ) ; sb . append ( "'." ) ; } throw new BuildException ( new String ( sb ) ) ; } for ( Enumeration en = target . getDependencies ( ) ; en . hasMoreElements ( ) ; ) { String cur = ( String ) en . nextElement ( ) ; String m = ( String ) state . get ( cur ) ; if ( m == null ) { tsort ( cur , targets , state , visiting , ret ) ; } else if ( m == VISITING ) { throw makeCircularException ( cur , visiting ) ; } } String p = ( String ) visiting . pop ( ) ; if ( root != p ) { throw new RuntimeException ( "Unexpected internal error: expected to pop " + root + " but got " + p ) ; } state . put ( root , VISITED ) ; ret . addElement ( target ) ; } private static BuildException makeCircularException ( String end , Stack stk ) { StringBuffer sb = new StringBuffer ( "Circular dependency: " ) ; sb . append ( end ) ; String c ; do { c = ( String ) stk . pop ( ) ; sb . append ( " <- " ) ; sb . append ( c ) ; } while ( ! c . equals ( end ) ) ; return new BuildException ( new String ( sb ) ) ; } public void addReference ( String name , Object value ) { if ( null != references . get ( name ) ) { log ( "Overriding previous definition of reference to " + name , MSG_WARN ) ; } log ( "Adding reference: " + name + " -> " + value , MSG_DEBUG ) ; references . put ( name , value ) ; } public Hashtable getReferences ( ) { return references ; } protected void fireBuildStarted ( ) { BuildEvent event = new BuildEvent ( this ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { BuildListener listener = ( BuildListener ) listeners . elementAt ( i ) ; listener . buildStarted ( event ) ; } } protected void fireBuildFinished ( Throwable exception ) { BuildEvent event = new BuildEvent ( this ) ; event . setException ( exception ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { BuildListener listener = ( BuildListener ) listeners . elementAt ( i ) ; listener . buildFinished ( event ) ; } } protected void fireTargetStarted ( Target target ) { BuildEvent event = new BuildEvent ( target ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { BuildListener listener = ( BuildListener ) listeners . elementAt ( i ) ; listener . targetStarted ( event ) ; } } protected void fireTargetFinished ( Target target , Throwable exception ) { BuildEvent event = new BuildEvent ( target ) ; event . setException ( exception ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { BuildListener listener = ( BuildListener ) listeners . elementAt ( i ) ; listener . targetFinished ( event ) ; } } protected void fireTaskStarted ( Task task ) { threadTasks . put ( Thread . currentThread ( ) , task ) ; BuildEvent event = new BuildEvent ( task ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { BuildListener listener = ( BuildListener ) listeners . elementAt ( i ) ; listener . taskStarted ( event ) ; } } protected void fireTaskFinished ( Task task , Throwable exception ) { threadTasks . remove ( Thread . currentThread ( ) ) ; System . out . flush ( ) ; System . err . flush ( ) ; BuildEvent event = new BuildEvent ( task ) ; event . setException ( exception ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { BuildListener listener = ( BuildListener ) listeners . elementAt ( i ) ; listener . taskFinished ( event ) ; } } private void fireMessageLoggedEvent ( BuildEvent event , String message , int priority ) { event . setMessage ( message , priority ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { BuildListener listener = ( BuildListener ) listeners . elementAt ( i ) ; listener . messageLogged ( event ) ; } } protected void fireMessageLogged ( Project project , String message , int priority ) { BuildEvent event = new BuildEvent ( project ) ; fireMessageLoggedEvent ( event , message , priority ) ; } protected void fireMessageLogged ( Target target , String message , int priority ) { BuildEvent event = new BuildEvent ( target ) ; fireMessageLoggedEvent ( event , message , priority ) ; } protected void fireMessageLogged ( Task task , String message , int priority ) { BuildEvent event = new BuildEvent ( task ) ; fireMessageLoggedEvent ( event , message , priority ) ; } } 	0	['76', '1', '0', '120', '177', '2446', '114', '12', '63', '0.969462366', '1776', '0.612903226', '3', '0', '0.118518519', '0', '0', '21.96052632', '5', '1.3289', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; import java . util . * ; public class RecorderEntry implements BuildLogger { private String filename = null ; private boolean record = true ; private int loglevel = Project . MSG_INFO ; private PrintStream out = null ; private long targetStartTime = 0l ; private static String lSep = System . getProperty ( "line.separator" ) ; protected RecorderEntry ( String name ) { filename = name ; } public String getFilename ( ) { return filename ; } public void setRecordState ( Boolean state ) { if ( state != null ) record = state . booleanValue ( ) ; } public void buildStarted ( BuildEvent event ) { log ( "> BUILD STARTED" , Project . MSG_DEBUG ) ; } public void buildFinished ( BuildEvent event ) { log ( "< BUILD FINISHED" , Project . MSG_DEBUG ) ; Throwable error = event . getException ( ) ; if ( error == null ) { out . println ( lSep + "BUILD SUCCESSFUL" ) ; } else { out . println ( lSep + "BUILD FAILED" + lSep ) ; error . printStackTrace ( out ) ; } out . flush ( ) ; out . close ( ) ; } public void targetStarted ( BuildEvent event ) { log ( ">> TARGET STARTED -- " + event . getTarget ( ) , Project . MSG_DEBUG ) ; log ( lSep + event . getTarget ( ) . getName ( ) + ":" , Project . MSG_INFO ) ; targetStartTime = System . currentTimeMillis ( ) ; } public void targetFinished ( BuildEvent event ) { log ( "<< TARGET FINISHED -- " + event . getTarget ( ) , Project . MSG_DEBUG ) ; String time = formatTime ( System . currentTimeMillis ( ) - targetStartTime ) ; log ( event . getTarget ( ) + ":  duration " + time , Project . MSG_VERBOSE ) ; out . flush ( ) ; } public void taskStarted ( BuildEvent event ) { log ( ">>> TAST STARTED -- " + event . getTask ( ) , Project . MSG_DEBUG ) ; } public void taskFinished ( BuildEvent event ) { log ( "<<< TASK FINISHED -- " + event . getTask ( ) , Project . MSG_DEBUG ) ; out . flush ( ) ; } public void messageLogged ( BuildEvent event ) { log ( "--- MESSAGE LOGGED" , Project . MSG_DEBUG ) ; StringBuffer buf = new StringBuffer ( ) ; if ( event . getTask ( ) != null ) { String name = "[" + event . getTask ( ) . getTaskName ( ) + "]" ; for ( int i = 0 ; i < ( 12 - name . length ( ) ) ; i ++ ) { buf . append ( " " ) ; } buf . append ( name ) ; } buf . append ( event . getMessage ( ) ) ; log ( buf . toString ( ) , event . getPriority ( ) ) ; } private void log ( String mesg , int level ) { if ( record && ( level <= loglevel ) ) { out . println ( mesg ) ; } } public void setMessageOutputLevel ( int level ) { if ( level >= Project . MSG_ERR && level <= Project . MSG_DEBUG ) loglevel = level ; } public void setOutputPrintStream ( PrintStream output ) { out = output ; } public void setEmacsMode ( boolean emacsMode ) { throw new java . lang . RuntimeException ( "Method setEmacsMode() not yet implemented." ) ; } public void setErrorPrintStream ( PrintStream err ) { out = err ; } private static String formatTime ( long millis ) { long seconds = millis / 1000 ; long minutes = seconds / 60 ; if ( minutes > 0 ) { return Long . toString ( minutes ) + " minute" + ( minutes == 1 ? " " : "s " ) + Long . toString ( seconds % 60 ) + " second" + ( seconds % 60 == 1 ? "" : "s" ) ; } else { return Long . toString ( seconds ) + " second" + ( seconds % 60 == 1 ? "" : "s" ) ; } } } 	0	['17', '1', '0', '5', '39', '74', '1', '4', '13', '0.65625', '359', '1', '0', '0', '0.2421875', '0', '0', '19.76470588', '5', '1.5882', '0']
package org . apache . tools . ant ; public class ExitException extends SecurityException { private int status ; public ExitException ( int status ) { super ( "ExitException: status " + status ) ; this . status = status ; } public int getStatus ( ) { return status ; } } 	0	['2', '5', '0', '1', '7', '0', '1', '0', '2', '0', '20', '1', '0', '0.928571429', '0.75', '0', '0', '8.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import java . util . * ; import org . apache . tools . ant . * ; import org . apache . tools . ant . util . * ; import org . apache . tools . tar . * ; import org . apache . tools . ant . types . * ; public class Tar extends MatchingTask { static public final String WARN = "warn" ; static public final String FAIL = "fail" ; static public final String TRUNCATE = "truncate" ; static public final String GNU = "gnu" ; static public final String OMIT = "omit" ; private String [ ] validModes = new String [ ] { WARN , FAIL , TRUNCATE , GNU , OMIT } ; File tarFile ; File baseDir ; String longFileMode = WARN ; Vector filesets = new Vector ( ) ; Vector fileSetFiles = new Vector ( ) ; private boolean longWarningGiven = false ; public TarFileSet createTarFileSet ( ) { TarFileSet fileset = new TarFileSet ( ) ; filesets . addElement ( fileset ) ; return fileset ; } public void setTarfile ( File tarFile ) { this . tarFile = tarFile ; } public void setBasedir ( File baseDir ) { this . baseDir = baseDir ; } public void setLongfile ( String mode ) { for ( int i = 0 ; i < validModes . length ; ++ i ) { if ( mode . equalsIgnoreCase ( validModes [ i ] ) ) { this . longFileMode = mode ; return ; } } throw new BuildException ( "The longfile value " + mode + " is not a valid value" ) ; } public void execute ( ) throws BuildException { if ( tarFile == null ) { throw new BuildException ( "tarfile attribute must be set!" , location ) ; } if ( tarFile . exists ( ) && tarFile . isDirectory ( ) ) { throw new BuildException ( "tarfile is a directory!" , location ) ; } if ( tarFile . exists ( ) && ! tarFile . canWrite ( ) ) { throw new BuildException ( "Can not write to the specified tarfile!" , location ) ; } if ( baseDir != null ) { if ( ! baseDir . exists ( ) ) { throw new BuildException ( "basedir does not exist!" , location ) ; } TarFileSet mainFileSet = new TarFileSet ( fileset ) ; mainFileSet . setDir ( baseDir ) ; filesets . addElement ( mainFileSet ) ; } if ( filesets . size ( ) == 0 ) { throw new BuildException ( "You must supply either a basdir attribute or some nested filesets." , location ) ; } boolean upToDate = true ; for ( Enumeration e = filesets . elements ( ) ; e . hasMoreElements ( ) ; ) { TarFileSet fs = ( TarFileSet ) e . nextElement ( ) ; String [ ] files = fs . getFiles ( project ) ; if ( ! archiveIsUpToDate ( files ) ) { upToDate = false ; } for ( int i = 0 ; i < files . length ; ++ i ) { if ( tarFile . equals ( new File ( fs . getDir ( project ) , files [ i ] ) ) ) { throw new BuildException ( "A tar file cannot include itself" , location ) ; } } } if ( upToDate ) { log ( "Nothing to do: " + tarFile . getAbsolutePath ( ) + " is up to date." , Project . MSG_INFO ) ; return ; } log ( "Building tar: " + tarFile . getAbsolutePath ( ) , Project . MSG_INFO ) ; TarOutputStream tOut = null ; try { tOut = new TarOutputStream ( new FileOutputStream ( tarFile ) ) ; tOut . setDebug ( true ) ; if ( longFileMode . equalsIgnoreCase ( TRUNCATE ) ) { tOut . setLongFileMode ( TarOutputStream . LONGFILE_TRUNCATE ) ; } else if ( longFileMode . equalsIgnoreCase ( FAIL ) || longFileMode . equalsIgnoreCase ( OMIT ) ) { tOut . setLongFileMode ( TarOutputStream . LONGFILE_ERROR ) ; } else { tOut . setLongFileMode ( TarOutputStream . LONGFILE_GNU ) ; } longWarningGiven = false ; for ( Enumeration e = filesets . elements ( ) ; e . hasMoreElements ( ) ; ) { TarFileSet fs = ( TarFileSet ) e . nextElement ( ) ; String [ ] files = fs . getFiles ( project ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File f = new File ( fs . getDir ( project ) , files [ i ] ) ; String name = files [ i ] . replace ( File . separatorChar , '/' ) ; tarFile ( f , tOut , name , fs ) ; } } } catch ( IOException ioe ) { String msg = "Problem creating TAR: " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } finally { if ( tOut != null ) { try { tOut . close ( ) ; } catch ( IOException e ) { } } } } protected void tarFile ( File file , TarOutputStream tOut , String vPath , TarFileSet tarFileSet ) throws IOException { FileInputStream fIn = null ; if ( vPath . length ( ) <= 0 ) { return ; } if ( file . isDirectory ( ) && ! vPath . endsWith ( "/" ) ) { vPath += "/" ; } try { if ( vPath . length ( ) >= TarConstants . NAMELEN ) { if ( longFileMode . equalsIgnoreCase ( OMIT ) ) { log ( "Omitting: " + vPath , Project . MSG_INFO ) ; return ; } else if ( longFileMode . equalsIgnoreCase ( WARN ) ) { log ( "Entry: " + vPath + " longer than " + TarConstants . NAMELEN + " characters." , Project . MSG_WARN ) ; if ( ! longWarningGiven ) { log ( "Resulting tar file can only be processed successfully" + " by GNU compatible tar commands" , Project . MSG_WARN ) ; longWarningGiven = true ; } } else if ( longFileMode . equalsIgnoreCase ( FAIL ) ) { throw new BuildException ( "Entry: " + vPath + " longer than " + TarConstants . NAMELEN + "characters." , location ) ; } } TarEntry te = new TarEntry ( vPath ) ; te . setModTime ( file . lastModified ( ) ) ; if ( ! file . isDirectory ( ) ) { te . setSize ( file . length ( ) ) ; te . setMode ( tarFileSet . getMode ( ) ) ; } te . setUserName ( tarFileSet . getUserName ( ) ) ; te . setGroupName ( tarFileSet . getGroup ( ) ) ; tOut . putNextEntry ( te ) ; if ( ! file . isDirectory ( ) ) { fIn = new FileInputStream ( file ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { tOut . write ( buffer , 0 , count ) ; count = fIn . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } tOut . closeEntry ( ) ; } finally { if ( fIn != null ) fIn . close ( ) ; } } protected boolean archiveIsUpToDate ( String [ ] files ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; MergingMapper mm = new MergingMapper ( ) ; mm . setTo ( tarFile . getAbsolutePath ( ) ) ; return sfs . restrict ( files , baseDir , null , mm ) . length == 0 ; } static public class TarFileSet extends FileSet { private String [ ] files = null ; private int mode = 0100644 ; private String userName = "" ; private String groupName = "" ; public TarFileSet ( FileSet fileset ) { super ( fileset ) ; } public TarFileSet ( ) { super ( ) ; } public String [ ] getFiles ( Project p ) { if ( files == null ) { DirectoryScanner ds = getDirectoryScanner ( p ) ; String [ ] directories = ds . getIncludedDirectories ( ) ; String [ ] filesPerSe = ds . getIncludedFiles ( ) ; files = new String [ directories . length + filesPerSe . length ] ; System . arraycopy ( directories , 0 , files , 0 , directories . length ) ; System . arraycopy ( filesPerSe , 0 , files , directories . length , filesPerSe . length ) ; } return files ; } public void setMode ( String octalString ) { this . mode = 0100000 | Integer . parseInt ( octalString , 8 ) ; } public int getMode ( ) { return mode ; } public void setUserName ( String userName ) { this . userName = userName ; } public String getUserName ( ) { return userName ; } public void setGroup ( String groupName ) { this . groupName = groupName ; } public String getGroup ( ) { return groupName ; } } } 	0	['8', '4', '0', '13', '65', '2', '0', '13', '6', '0.916666667', '608', '0.166666667', '0', '0.917647059', '0.333333333', '2', '2', '73.5', '3', '1.25', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . BuildException ; import java . io . * ; import java . util . Enumeration ; import java . util . Stack ; import java . util . StringTokenizer ; import java . util . Vector ; public class PatternSet extends DataType { private Vector includeList = new Vector ( ) ; private Vector excludeList = new Vector ( ) ; private Vector includesFileList = new Vector ( ) ; private Vector excludesFileList = new Vector ( ) ; public class NameEntry { private String name ; private String ifCond ; private String unlessCond ; public void setName ( String name ) { this . name = name ; } public void setIf ( String cond ) { ifCond = cond ; } public void setUnless ( String cond ) { unlessCond = cond ; } public String getName ( ) { return name ; } public String evalName ( Project p ) { return valid ( p ) ? name : null ; } private boolean valid ( Project p ) { if ( ifCond != null && p . getProperty ( ifCond ) == null ) { return false ; } else if ( unlessCond != null && p . getProperty ( unlessCond ) != null ) { return false ; } return true ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( name ) ; if ( ( ifCond != null ) || ( unlessCond != null ) ) { buf . append ( ":" ) ; String connector = "" ; if ( ifCond != null ) { buf . append ( "if->" ) ; buf . append ( ifCond ) ; connector = ";" ; } if ( unlessCond != null ) { buf . append ( connector ) ; buf . append ( "unless->" ) ; buf . append ( unlessCond ) ; } } return buf . toString ( ) ; } } public PatternSet ( ) { super ( ) ; } public void setRefid ( Reference r ) throws BuildException { if ( ! includeList . isEmpty ( ) || ! excludeList . isEmpty ( ) ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public NameEntry createInclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return addPatternToList ( includeList ) ; } public NameEntry createIncludesFile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return addPatternToList ( includesFileList ) ; } public NameEntry createExclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return addPatternToList ( excludeList ) ; } public NameEntry createExcludesFile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return addPatternToList ( excludesFileList ) ; } public void setIncludes ( String includes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( includes != null && includes . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( includes , ", " , false ) ; while ( tok . hasMoreTokens ( ) ) { createInclude ( ) . setName ( tok . nextToken ( ) ) ; } } } public void setExcludes ( String excludes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( excludes != null && excludes . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( excludes , ", " , false ) ; while ( tok . hasMoreTokens ( ) ) { createExclude ( ) . setName ( tok . nextToken ( ) ) ; } } } private NameEntry addPatternToList ( Vector list ) { NameEntry result = new NameEntry ( ) ; list . addElement ( result ) ; return result ; } public void setIncludesfile ( File includesFile ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createIncludesFile ( ) . setName ( includesFile . getAbsolutePath ( ) ) ; } public void setExcludesfile ( File excludesFile ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createExcludesFile ( ) . setName ( excludesFile . getAbsolutePath ( ) ) ; } private void readPatterns ( File patternfile , Vector patternlist , Project p ) throws BuildException { try { BufferedReader patternReader = new BufferedReader ( new FileReader ( patternfile ) ) ; String line = patternReader . readLine ( ) ; while ( line != null ) { if ( line . length ( ) > 0 ) { line = ProjectHelper . replaceProperties ( p , line , p . getProperties ( ) ) ; addPatternToList ( patternlist ) . setName ( line ) ; } line = patternReader . readLine ( ) ; } } catch ( IOException ioe ) { String msg = "An error occured while reading from pattern file: " + patternfile ; throw new BuildException ( msg , ioe ) ; } } public void append ( PatternSet other , Project p ) { if ( isReference ( ) ) { throw new BuildException ( "Cannot append to a reference" ) ; } String [ ] incl = other . getIncludePatterns ( p ) ; if ( incl != null ) { for ( int i = 0 ; i < incl . length ; i ++ ) { createInclude ( ) . setName ( incl [ i ] ) ; } } String [ ] excl = other . getExcludePatterns ( p ) ; if ( excl != null ) { for ( int i = 0 ; i < excl . length ; i ++ ) { createExclude ( ) . setName ( excl [ i ] ) ; } } } public String [ ] getIncludePatterns ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getIncludePatterns ( p ) ; } else { readFiles ( p ) ; return makeArray ( includeList , p ) ; } } public String [ ] getExcludePatterns ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getExcludePatterns ( p ) ; } else { readFiles ( p ) ; return makeArray ( excludeList , p ) ; } } boolean hasPatterns ( ) { return includesFileList . size ( ) > 0 || excludesFileList . size ( ) > 0 || includeList . size ( ) > 0 || excludeList . size ( ) > 0 ; } private PatternSet getRef ( Project p ) { if ( ! checked ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , p ) ; } Object o = ref . getReferencedObject ( p ) ; if ( ! ( o instanceof PatternSet ) ) { String msg = ref . getRefId ( ) + " doesn\'t denote a patternset" ; throw new BuildException ( msg ) ; } else { return ( PatternSet ) o ; } } private String [ ] makeArray ( Vector list , Project p ) { if ( list . size ( ) == 0 ) return null ; Vector tmpNames = new Vector ( ) ; for ( Enumeration e = list . elements ( ) ; e . hasMoreElements ( ) ; ) { NameEntry ne = ( NameEntry ) e . nextElement ( ) ; String pattern = ne . evalName ( p ) ; if ( pattern != null && pattern . length ( ) > 0 ) { tmpNames . addElement ( pattern ) ; } } String result [ ] = new String [ tmpNames . size ( ) ] ; tmpNames . copyInto ( result ) ; return result ; } private void readFiles ( Project p ) { if ( includesFileList . size ( ) > 0 ) { Enumeration e = includesFileList . elements ( ) ; while ( e . hasMoreElements ( ) ) { NameEntry ne = ( NameEntry ) e . nextElement ( ) ; String fileName = ne . evalName ( p ) ; if ( fileName != null ) { File inclFile = p . resolveFile ( fileName ) ; if ( ! inclFile . exists ( ) ) throw new BuildException ( "Includesfile " + inclFile . getAbsolutePath ( ) + " not found." ) ; readPatterns ( inclFile , includeList , p ) ; } } includesFileList . removeAllElements ( ) ; } if ( excludesFileList . size ( ) > 0 ) { Enumeration e = excludesFileList . elements ( ) ; while ( e . hasMoreElements ( ) ) { NameEntry ne = ( NameEntry ) e . nextElement ( ) ; String fileName = ne . evalName ( p ) ; if ( fileName != null ) { File exclFile = p . resolveFile ( fileName ) ; if ( ! exclFile . exists ( ) ) throw new BuildException ( "Excludesfile " + exclFile . getAbsolutePath ( ) + " not found." ) ; readPatterns ( exclFile , excludeList , p ) ; } } excludesFileList . removeAllElements ( ) ; } } public String toString ( ) { return "patternSet{ includes: " + includeList + " excludes: " + excludeList + " }" ; } } 	0	['20', '3', '0', '10', '60', '114', '5', '6', '14', '0.605263158', '557', '1', '0', '0.612244898', '0.264285714', '1', '1', '26.65', '9', '2.8', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ExitException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . * ; import java . io . * ; import java . lang . reflect . * ; import java . util . * ; public class Java extends Task { private CommandlineJava cmdl = new CommandlineJava ( ) ; private boolean fork = false ; private File dir = null ; private File out ; private PrintStream outStream = null ; private boolean failOnError = false ; public void execute ( ) throws BuildException { int err = - 1 ; if ( ( err = executeJava ( ) ) != 0 ) { if ( failOnError ) { throw new BuildException ( "Java returned: " + err , location ) ; } else { log ( "Java Result: " + err , Project . MSG_ERR ) ; } } } public int executeJava ( ) throws BuildException { String classname = cmdl . getClassname ( ) ; if ( classname == null && cmdl . getJar ( ) == null ) { throw new BuildException ( "Classname must not be null." ) ; } if ( ! fork && cmdl . getJar ( ) != null ) { throw new BuildException ( "Cannot execute a jar in non-forked mode. Please set fork='true'. " ) ; } if ( fork ) { log ( "Forking " + cmdl . toString ( ) , Project . MSG_VERBOSE ) ; return run ( cmdl . getCommandline ( ) ) ; } else { if ( cmdl . getVmCommand ( ) . size ( ) > 1 ) { log ( "JVM args ignored when same JVM is used." , Project . MSG_WARN ) ; } if ( dir != null ) { log ( "Working directory ignored when same JVM is used." , Project . MSG_WARN ) ; } log ( "Running in same VM " + cmdl . getJavaCommand ( ) . toString ( ) , Project . MSG_VERBOSE ) ; try { run ( cmdl ) ; return 0 ; } catch ( ExitException ex ) { return ex . getStatus ( ) ; } } } public void setClasspath ( Path s ) { createClasspath ( ) . append ( s ) ; } public Path createClasspath ( ) { return cmdl . createClasspath ( project ) . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setJar ( File jarfile ) throws BuildException { if ( cmdl . getClassname ( ) != null ) { throw new BuildException ( "Cannot use 'jar' and 'classname' attributes in same command." ) ; } cmdl . setJar ( jarfile . getAbsolutePath ( ) ) ; } public void setClassname ( String s ) throws BuildException { if ( cmdl . getJar ( ) != null ) { throw new BuildException ( "Cannot use 'jar' and 'classname' attributes in same command" ) ; } cmdl . setClassname ( s ) ; } public void setArgs ( String s ) { log ( "The args attribute is deprecated. " + "Please use nested arg elements." , Project . MSG_WARN ) ; cmdl . createArgument ( ) . setLine ( s ) ; } public Commandline . Argument createArg ( ) { return cmdl . createArgument ( ) ; } public void setFork ( boolean s ) { this . fork = s ; } public void setJvmargs ( String s ) { log ( "The jvmargs attribute is deprecated. " + "Please use nested jvmarg elements." , Project . MSG_WARN ) ; cmdl . createVmArgument ( ) . setLine ( s ) ; } public Commandline . Argument createJvmarg ( ) { return cmdl . createVmArgument ( ) ; } public void setJvm ( String s ) { cmdl . setVm ( s ) ; } public void addSysproperty ( Environment . Variable sysp ) { cmdl . addSysproperty ( sysp ) ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } public void setDir ( File d ) { this . dir = d ; } public void setOutput ( File out ) { this . out = out ; } public void setMaxmemory ( String max ) { cmdl . setMaxmemory ( max ) ; } public void setJVMVersion ( String value ) { cmdl . setVmversion ( value ) ; } protected void handleOutput ( String line ) { if ( outStream != null ) { outStream . println ( line ) ; } else { super . handleOutput ( line ) ; } } protected void handleErrorOutput ( String line ) { if ( outStream != null ) { outStream . println ( line ) ; } else { super . handleErrorOutput ( line ) ; } } private void run ( CommandlineJava command ) throws BuildException { ExecuteJava exe = new ExecuteJava ( ) ; exe . setJavaCommand ( command . getJavaCommand ( ) ) ; exe . setClasspath ( command . getClasspath ( ) ) ; exe . setSystemProperties ( command . getSystemProperties ( ) ) ; if ( out != null ) { try { outStream = new PrintStream ( new FileOutputStream ( out ) ) ; exe . execute ( project ) ; } catch ( IOException io ) { throw new BuildException ( io , location ) ; } finally { if ( outStream != null ) { outStream . close ( ) ; } } } else { exe . execute ( project ) ; } } private int run ( String [ ] command ) throws BuildException { FileOutputStream fos = null ; try { Execute exe = null ; if ( out == null ) { exe = new Execute ( new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) , null ) ; } else { fos = new FileOutputStream ( out ) ; exe = new Execute ( new PumpStreamHandler ( fos ) , null ) ; } exe . setAntRun ( project ) ; if ( dir == null ) { dir = project . getBaseDir ( ) ; } else if ( ! dir . exists ( ) || ! dir . isDirectory ( ) ) { throw new BuildException ( dir . getAbsolutePath ( ) + " is not a valid directory" , location ) ; } exe . setWorkingDirectory ( dir ) ; exe . setCommandline ( command ) ; try { return exe . execute ( ) ; } catch ( IOException e ) { throw new BuildException ( e , location ) ; } } catch ( IOException io ) { throw new BuildException ( io , location ) ; } finally { if ( fos != null ) { try { fos . close ( ) ; } catch ( IOException io ) { } } } } protected void run ( String classname , Vector args ) throws BuildException { CommandlineJava cmdj = new CommandlineJava ( ) ; cmdj . setClassname ( classname ) ; for ( int i = 0 ; i < args . size ( ) ; i ++ ) { cmdj . createArgument ( ) . setValue ( ( String ) args . elementAt ( i ) ) ; } run ( cmdj ) ; } public void clearArgs ( ) { cmdl . clearJavaArgs ( ) ; } } 	0	['26', '3', '0', '19', '87', '105', '0', '19', '21', '0.773333333', '514', '1', '1', '0.596774194', '0.176923077', '1', '3', '18.53846154', '2', '1.0385', '0']
package org . apache . tools . ant . util ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import java . io . File ; import java . util . Vector ; public class SourceFileScanner { protected Task task ; public SourceFileScanner ( Task task ) { this . task = task ; } public String [ ] restrict ( String [ ] files , File srcDir , File destDir , FileNameMapper mapper ) { long now = ( new java . util . Date ( ) ) . getTime ( ) ; StringBuffer targetList = new StringBuffer ( ) ; String osname = System . getProperty ( "os.name" ) . toLowerCase ( ) ; if ( osname . indexOf ( "windows" ) >= 0 ) { now += 2000 ; } Vector v = new Vector ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { String [ ] targets = mapper . mapFileName ( files [ i ] ) ; if ( targets == null || targets . length == 0 ) { task . log ( files [ i ] + " skipped - don\'t know how to handle it" , Project . MSG_VERBOSE ) ; continue ; } File src = new File ( srcDir , files [ i ] ) ; if ( src . lastModified ( ) > now ) { task . log ( "Warning: " + files [ i ] + " modified in the future." , Project . MSG_WARN ) ; } boolean added = false ; targetList . setLength ( 0 ) ; for ( int j = 0 ; ! added && j < targets . length ; j ++ ) { File dest = null ; if ( destDir == null ) { dest = new File ( targets [ j ] ) ; } else { dest = new File ( destDir , targets [ j ] ) ; } if ( ! dest . exists ( ) ) { task . log ( files [ i ] + " added as " + dest . getAbsolutePath ( ) + " doesn\'t exist." , Project . MSG_VERBOSE ) ; v . addElement ( files [ i ] ) ; added = true ; } else if ( src . lastModified ( ) > dest . lastModified ( ) ) { task . log ( files [ i ] + " added as " + dest . getAbsolutePath ( ) + " is outdated." , Project . MSG_VERBOSE ) ; v . addElement ( files [ i ] ) ; added = true ; } else { if ( targetList . length ( ) > 0 ) { targetList . append ( ", " ) ; } targetList . append ( dest . getAbsolutePath ( ) ) ; } } if ( ! added ) { task . log ( files [ i ] + " omitted as " + targetList . toString ( ) + ( targets . length == 1 ? " is" : " are " ) + " up to date." , Project . MSG_VERBOSE ) ; } } String [ ] result = new String [ v . size ( ) ] ; v . copyInto ( result ) ; return result ; } public File [ ] restrictAsFiles ( String [ ] files , File srcDir , File destDir , FileNameMapper mapper ) { String [ ] res = restrict ( files , srcDir , destDir , mapper ) ; File [ ] result = new File [ res . length ] ; for ( int i = 0 ; i < res . length ; i ++ ) { result [ i ] = new File ( srcDir , res [ i ] ) ; } return result ; } } 	0	['3', '1', '0', '9', '25', '1', '7', '2', '3', '0', '277', '1', '1', '0', '0.666666667', '0', '0', '91', '14', '5.3333', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; public abstract class EnumeratedAttribute { protected String value ; public abstract String [ ] getValues ( ) ; public EnumeratedAttribute ( ) { } public final void setValue ( String value ) throws BuildException { if ( ! containsValue ( value ) ) { throw new BuildException ( value + " is not a legal value for this attribute" ) ; } this . value = value ; } public final boolean containsValue ( String value ) { String [ ] values = getValues ( ) ; if ( values == null || value == null ) { return false ; } for ( int i = 0 ; i < values . length ; i ++ ) { if ( value . equals ( values [ i ] ) ) { return true ; } } return false ; } public final String getValue ( ) { return value ; } } 	0	['5', '1', '11', '21', '11', '8', '20', '1', '5', '0.75', '59', '1', '0', '0', '0.7', '0', '0', '10.6', '5', '1.6', '0']
package org . apache . tools . zip ; import java . util . Hashtable ; import java . util . Vector ; import java . util . zip . ZipException ; public class ExtraFieldUtils { private static Hashtable implementations ; static { implementations = new Hashtable ( ) ; register ( AsiExtraField . class ) ; } public static void register ( Class c ) { try { ZipExtraField ze = ( ZipExtraField ) c . newInstance ( ) ; implementations . put ( ze . getHeaderId ( ) , c ) ; } catch ( ClassCastException cc ) { throw new RuntimeException ( c + " doesn\'t implement ZipExtraField" ) ; } catch ( InstantiationException ie ) { throw new RuntimeException ( c + " is not a concrete class" ) ; } catch ( IllegalAccessException ie ) { throw new RuntimeException ( c + "\'s no-arg constructor is not public" ) ; } } public static ZipExtraField createExtraField ( ZipShort headerId ) throws InstantiationException , IllegalAccessException { Class c = ( Class ) implementations . get ( headerId ) ; if ( c != null ) { return ( ZipExtraField ) c . newInstance ( ) ; } UnrecognizedExtraField u = new UnrecognizedExtraField ( ) ; u . setHeaderId ( headerId ) ; return u ; } public static ZipExtraField [ ] parse ( byte [ ] data ) throws ZipException { Vector v = new Vector ( ) ; int start = 0 ; while ( start <= data . length - 4 ) { ZipShort headerId = new ZipShort ( data , start ) ; int length = ( new ZipShort ( data , start + 2 ) ) . getValue ( ) ; if ( start + 4 + length > data . length ) { throw new ZipException ( "data starting at " + start + " is in unknown format" ) ; } try { ZipExtraField ze = createExtraField ( headerId ) ; ze . parseFromLocalFileData ( data , start + 4 , length ) ; v . addElement ( ze ) ; } catch ( InstantiationException ie ) { throw new ZipException ( ie . getMessage ( ) ) ; } catch ( IllegalAccessException iae ) { throw new ZipException ( iae . getMessage ( ) ) ; } start += ( length + 4 ) ; } if ( start != data . length ) { throw new ZipException ( "data starting at " + start + " is in unknown format" ) ; } ZipExtraField [ ] result = new ZipExtraField [ v . size ( ) ] ; v . copyInto ( result ) ; return result ; } public static byte [ ] mergeLocalFileDataData ( ZipExtraField [ ] data ) { int sum = 4 * data . length ; for ( int i = 0 ; i < data . length ; i ++ ) { sum += data [ i ] . getLocalFileDataLength ( ) . getValue ( ) ; } byte [ ] result = new byte [ sum ] ; int start = 0 ; for ( int i = 0 ; i < data . length ; i ++ ) { System . arraycopy ( data [ i ] . getHeaderId ( ) . getBytes ( ) , 0 , result , start , 2 ) ; System . arraycopy ( data [ i ] . getLocalFileDataLength ( ) . getBytes ( ) , 0 , result , start + 2 , 2 ) ; byte [ ] local = data [ i ] . getLocalFileDataData ( ) ; System . arraycopy ( local , 0 , result , start + 4 , local . length ) ; start += ( local . length + 4 ) ; } return result ; } public static byte [ ] mergeCentralDirectoryData ( ZipExtraField [ ] data ) { int sum = 4 * data . length ; for ( int i = 0 ; i < data . length ; i ++ ) { sum += data [ i ] . getCentralDirectoryLength ( ) . getValue ( ) ; } byte [ ] result = new byte [ sum ] ; int start = 0 ; for ( int i = 0 ; i < data . length ; i ++ ) { System . arraycopy ( data [ i ] . getHeaderId ( ) . getBytes ( ) , 0 , result , start , 2 ) ; System . arraycopy ( data [ i ] . getCentralDirectoryLength ( ) . getBytes ( ) , 0 , result , start + 2 , 2 ) ; byte [ ] local = data [ i ] . getCentralDirectoryData ( ) ; System . arraycopy ( local , 0 , result , start + 4 , local . length ) ; start += ( local . length + 4 ) ; } return result ; } } 	0	['8', '1', '0', '4', '39', '22', '1', '3', '6', '0.785714286', '377', '0.5', '0', '0', '0.166666667', '0', '0', '45.875', '3', '1.25', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Javac ; public interface CompilerAdapter { public void setJavac ( Javac attributes ) ; public boolean execute ( ) throws BuildException ; } 	0	['2', '1', '0', '4', '2', '1', '3', '2', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import org . apache . tools . ant . util . * ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . text . DateFormat ; import java . text . ParseException ; import java . util . Date ; import java . util . Enumeration ; import java . util . Locale ; import java . util . Vector ; public class Touch extends Task { private File file ; private long millis = - 1 ; private String dateTime ; private Vector filesets = new Vector ( ) ; private FileUtils fileUtils ; public Touch ( ) { fileUtils = FileUtils . newFileUtils ( ) ; } public void setFile ( File file ) { this . file = file ; } public void setMillis ( long millis ) { this . millis = millis ; } public void setDatetime ( String dateTime ) { this . dateTime = dateTime ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void execute ( ) throws BuildException { if ( file == null && filesets . size ( ) == 0 ) { throw new BuildException ( "Specify at least one source - a file or a fileset." ) ; } if ( file != null && file . exists ( ) && file . isDirectory ( ) ) { throw new BuildException ( "Use a fileset to touch directories." ) ; } if ( dateTime != null ) { DateFormat df = DateFormat . getDateTimeInstance ( DateFormat . SHORT , DateFormat . SHORT , Locale . US ) ; try { setMillis ( df . parse ( dateTime ) . getTime ( ) ) ; if ( millis < 0 ) { throw new BuildException ( "Date of " + dateTime + " results in negative milliseconds value relative to epoch (January 1, 1970, 00:00:00 GMT)." ) ; } } catch ( ParseException pe ) { throw new BuildException ( pe . getMessage ( ) , pe , location ) ; } } touch ( ) ; } protected void touch ( ) throws BuildException { if ( file != null ) { if ( ! file . exists ( ) ) { log ( "Creating " + file , Project . MSG_INFO ) ; try { FileOutputStream fos = new FileOutputStream ( file ) ; fos . write ( new byte [ 0 ] ) ; fos . close ( ) ; } catch ( IOException ioe ) { throw new BuildException ( "Could not create " + file , ioe , location ) ; } } touch ( file ) ; } if ( millis >= 0 && project . getJavaVersion ( ) == Project . JAVA_1_1 ) { log ( "modification time of files cannot be set in JDK 1.1" , Project . MSG_WARN ) ; return ; } for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; File fromDir = fs . getDir ( project ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; String [ ] srcDirs = ds . getIncludedDirectories ( ) ; for ( int j = 0 ; j < srcFiles . length ; j ++ ) { touch ( new File ( fromDir , srcFiles [ j ] ) ) ; } for ( int j = 0 ; j < srcDirs . length ; j ++ ) { touch ( new File ( fromDir , srcDirs [ j ] ) ) ; } } } protected void touch ( File file ) throws BuildException { if ( ! file . canWrite ( ) ) { throw new BuildException ( "Can not change modification date of read-only file " + file ) ; } if ( project . getJavaVersion ( ) == Project . JAVA_1_1 ) { return ; } if ( millis < 0 ) { fileUtils . setFileLastModified ( file , System . currentTimeMillis ( ) ) ; } else { fileUtils . setFileLastModified ( file , millis ) ; } } } 	0	['8', '3', '0', '11', '39', '0', '3', '8', '6', '0.657142857', '294', '1', '1', '0.840909091', '0.325', '0', '0', '35.125', '1', '0.875', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import org . apache . tools . ant . * ; import java . util . Random ; public class Jikes { protected JikesOutputParser jop ; protected String command ; protected Project project ; protected Jikes ( JikesOutputParser jop , String command , Project project ) { super ( ) ; this . jop = jop ; this . command = command ; this . project = project ; } protected void compile ( String [ ] args ) { String [ ] commandArray = null ; File tmpFile = null ; try { String myos = System . getProperty ( "os.name" ) ; if ( myos . toLowerCase ( ) . indexOf ( "windows" ) >= 0 && args . length > 250 ) { PrintWriter out = null ; try { tmpFile = new File ( "jikes" + ( new Random ( System . currentTimeMillis ( ) ) ) . nextLong ( ) ) ; out = new PrintWriter ( new FileWriter ( tmpFile ) ) ; for ( int i = 0 ; i < args . length ; i ++ ) { out . println ( args [ i ] ) ; } out . flush ( ) ; commandArray = new String [ ] { command , "@" + tmpFile . getAbsolutePath ( ) } ; } catch ( IOException e ) { throw new BuildException ( "Error creating temporary file" , e ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( Throwable t ) { } } } } else { commandArray = new String [ args . length + 1 ] ; commandArray [ 0 ] = command ; System . arraycopy ( args , 0 , commandArray , 1 , args . length ) ; } try { Execute exe = new Execute ( jop ) ; exe . setAntRun ( project ) ; exe . setWorkingDirectory ( project . getBaseDir ( ) ) ; exe . setCommandline ( commandArray ) ; exe . execute ( ) ; } catch ( IOException e ) { throw new BuildException ( "Error running Jikes compiler" , e ) ; } } finally { if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } } 	0	['2', '1', '0', '5', '29', '0', '0', '5', '0', '0', '176', '1', '2', '0', '0.6', '0', '0', '85.5', '10', '5', '0']
package org . apache . tools . zip ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . Vector ; import java . util . zip . ZipException ; public class ZipEntry extends java . util . zip . ZipEntry { private int internalAttributes = 0 ; private long externalAttributes = 0 ; private Vector extraFields = new Vector ( ) ; public ZipEntry ( String name ) { super ( name ) ; } public ZipEntry ( java . util . zip . ZipEntry entry ) throws ZipException { super ( entry . getName ( ) ) ; setComment ( entry . getComment ( ) ) ; setMethod ( entry . getMethod ( ) ) ; setTime ( entry . getTime ( ) ) ; long size = entry . getSize ( ) ; if ( size > 0 ) { setSize ( size ) ; } long cSize = entry . getCompressedSize ( ) ; if ( cSize > 0 ) { setComprSize ( cSize ) ; } long crc = entry . getCrc ( ) ; if ( crc > 0 ) { setCrc ( crc ) ; } byte [ ] extra = entry . getExtra ( ) ; if ( extra != null ) { setExtraFields ( ExtraFieldUtils . parse ( extra ) ) ; } else { setExtra ( ) ; } } public ZipEntry ( ZipEntry entry ) throws ZipException { this ( ( java . util . zip . ZipEntry ) entry ) ; setInternalAttributes ( entry . getInternalAttributes ( ) ) ; setExternalAttributes ( entry . getExternalAttributes ( ) ) ; setExtraFields ( entry . getExtraFields ( ) ) ; } public Object clone ( ) { ZipEntry e = null ; try { e = new ZipEntry ( ( java . util . zip . ZipEntry ) super . clone ( ) ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } e . setInternalAttributes ( getInternalAttributes ( ) ) ; e . setExternalAttributes ( getExternalAttributes ( ) ) ; e . setExtraFields ( getExtraFields ( ) ) ; return e ; } public int getInternalAttributes ( ) { return internalAttributes ; } public void setInternalAttributes ( int value ) { internalAttributes = value ; } public long getExternalAttributes ( ) { return externalAttributes ; } public void setExternalAttributes ( long value ) { externalAttributes = value ; } public void setExtraFields ( ZipExtraField [ ] fields ) { extraFields . removeAllElements ( ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { extraFields . addElement ( fields [ i ] ) ; } setExtra ( ) ; } public ZipExtraField [ ] getExtraFields ( ) { ZipExtraField [ ] result = new ZipExtraField [ extraFields . size ( ) ] ; extraFields . copyInto ( result ) ; return result ; } public void addExtraField ( ZipExtraField ze ) { ZipShort type = ze . getHeaderId ( ) ; boolean done = false ; for ( int i = 0 ; ! done && i < extraFields . size ( ) ; i ++ ) { if ( ( ( ZipExtraField ) extraFields . elementAt ( i ) ) . getHeaderId ( ) . equals ( type ) ) { extraFields . setElementAt ( ze , i ) ; done = true ; } } if ( ! done ) { extraFields . addElement ( ze ) ; } setExtra ( ) ; } public void removeExtraField ( ZipShort type ) { boolean done = false ; for ( int i = 0 ; ! done && i < extraFields . size ( ) ; i ++ ) { if ( ( ( ZipExtraField ) extraFields . elementAt ( i ) ) . getHeaderId ( ) . equals ( type ) ) { extraFields . removeElementAt ( i ) ; done = true ; } } if ( ! done ) { throw new java . util . NoSuchElementException ( ) ; } setExtra ( ) ; } public void setExtra ( byte [ ] extra ) throws RuntimeException { try { setExtraFields ( ExtraFieldUtils . parse ( extra ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e . getMessage ( ) ) ; } } protected void setExtra ( ) { super . setExtra ( ExtraFieldUtils . mergeLocalFileDataData ( getExtraFields ( ) ) ) ; } public byte [ ] getLocalFileDataExtra ( ) { byte [ ] extra = getExtra ( ) ; return extra != null ? extra : new byte [ 0 ] ; } public byte [ ] getCentralDirectoryExtra ( ) { return ExtraFieldUtils . mergeCentralDirectoryData ( getExtraFields ( ) ) ; } private Long compressedSize = null ; public void setComprSize ( long size ) { if ( haveSetCompressedSize ( ) ) { performSetCompressedSize ( this , size ) ; } else { compressedSize = new Long ( size ) ; } } public long getCompressedSize ( ) { if ( compressedSize != null ) { return compressedSize . longValue ( ) ; } return super . getCompressedSize ( ) ; } private static Method setCompressedSizeMethod = null ; private static Object lockReflection = new Object ( ) ; private static boolean triedToGetMethod = false ; private static boolean haveSetCompressedSize ( ) { checkSCS ( ) ; return setCompressedSizeMethod != null ; } private static void performSetCompressedSize ( ZipEntry ze , long size ) { Long [ ] s = { new Long ( size ) } ; try { setCompressedSizeMethod . invoke ( ze , s ) ; } catch ( InvocationTargetException ite ) { Throwable nested = ite . getTargetException ( ) ; throw new RuntimeException ( "Exception setting the compressed size " + "of " + ze + ": " + nested . getMessage ( ) ) ; } catch ( Throwable other ) { throw new RuntimeException ( "Exception setting the compressed size " + "of " + ze + ": " + other . getMessage ( ) ) ; } } private static void checkSCS ( ) { if ( ! triedToGetMethod ) { synchronized ( lockReflection ) { triedToGetMethod = true ; try { setCompressedSizeMethod = java . util . zip . ZipEntry . class . getMethod ( "setCompressedSize" , new Class [ ] { Long . TYPE } ) ; } catch ( NoSuchMethodException nse ) { } } } } } 	0	['23', '2', '0', '5', '68', '181', '2', '3', '17', '0.806818182', '462', '0.875', '0', '0.547619048', '0.140909091', '0', '0', '18.73913043', '5', '1.4783', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import java . net . * ; import java . util . * ; import org . apache . tools . ant . * ; public class Get extends Task { private URL source ; private File dest ; private boolean verbose = false ; private boolean useTimestamp = false ; private boolean ignoreErrors = false ; public void execute ( ) throws BuildException { if ( source == null ) { throw new BuildException ( "src attribute is required" , location ) ; } if ( dest == null ) { throw new BuildException ( "dest attribute is required" , location ) ; } if ( dest . exists ( ) && dest . isDirectory ( ) ) { throw new BuildException ( "The specified destination is a directory" , location ) ; } if ( dest . exists ( ) && ! dest . canWrite ( ) ) { throw new BuildException ( "Can't write to " + dest . getAbsolutePath ( ) , location ) ; } try { log ( "Getting: " + source ) ; long timestamp = 0 ; boolean hasTimestamp = false ; if ( useTimestamp && dest . exists ( ) ) { timestamp = dest . lastModified ( ) ; if ( verbose ) { Date t = new Date ( timestamp ) ; log ( "local file date : " + t . toString ( ) ) ; } hasTimestamp = true ; } URLConnection connection = source . openConnection ( ) ; if ( useTimestamp && hasTimestamp ) { connection . setIfModifiedSince ( timestamp ) ; } connection . connect ( ) ; if ( connection instanceof HttpURLConnection ) { HttpURLConnection httpConnection = ( HttpURLConnection ) connection ; if ( httpConnection . getResponseCode ( ) == HttpURLConnection . HTTP_NOT_MODIFIED ) { log ( "Not modified - so not downloaded" ) ; return ; } } FileOutputStream fos = new FileOutputStream ( dest ) ; InputStream is = null ; for ( int i = 0 ; i < 3 ; i ++ ) { try { is = connection . getInputStream ( ) ; break ; } catch ( IOException ex ) { log ( "Error opening connection " + ex ) ; } } if ( is == null ) { log ( "Can't get " + source + " to " + dest ) ; if ( ignoreErrors ) return ; throw new BuildException ( "Can't get " + source + " to " + dest , location ) ; } byte [ ] buffer = new byte [ 100 * 1024 ] ; int length ; while ( ( length = is . read ( buffer ) ) >= 0 ) { fos . write ( buffer , 0 , length ) ; if ( verbose ) System . out . print ( "." ) ; } if ( verbose ) System . out . println ( ) ; fos . close ( ) ; is . close ( ) ; if ( useTimestamp ) { long remoteTimestamp = connection . getLastModified ( ) ; if ( verbose ) { Date t = new Date ( remoteTimestamp ) ; log ( "last modified = " + t . toString ( ) + ( ( remoteTimestamp == 0 ) ? " - using current time instead" : "" ) ) ; } if ( remoteTimestamp != 0 ) touchFile ( dest , remoteTimestamp ) ; } } catch ( IOException ioe ) { log ( "Error getting " + source + " to " + dest ) ; if ( ignoreErrors ) return ; throw new BuildException ( ioe , location ) ; } } protected boolean touchFile ( File file , long timemillis ) throws BuildException { if ( project . getJavaVersion ( ) != Project . JAVA_1_1 ) { Touch touch = ( Touch ) project . createTask ( "touch" ) ; touch . setOwningTarget ( target ) ; touch . setTaskName ( getTaskName ( ) ) ; touch . setLocation ( getLocation ( ) ) ; touch . setFile ( file ) ; touch . setMillis ( timemillis ) ; touch . touch ( ) ; return true ; } else { return false ; } } public void setSrc ( URL u ) { this . source = u ; } public void setDest ( File dest ) { this . dest = dest ; } public void setVerbose ( boolean v ) { verbose = v ; } public void setIgnoreErrors ( boolean v ) { ignoreErrors = v ; } public void setUseTimestamp ( boolean v ) { if ( project . getJavaVersion ( ) != Project . JAVA_1_1 ) { useTimestamp = v ; } } } 	0	['8', '3', '0', '7', '46', '10', '0', '7', '7', '0.771428571', '394', '1', '0', '0.840909091', '0.375', '1', '1', '47.625', '2', '1', '0']
package org . apache . tools . ant ; import java . io . * ; public interface FileScanner { public void addDefaultExcludes ( ) ; public File getBasedir ( ) ; public String [ ] getExcludedDirectories ( ) ; public String [ ] getExcludedFiles ( ) ; public String [ ] getIncludedDirectories ( ) ; public String [ ] getIncludedFiles ( ) ; public String [ ] getNotIncludedDirectories ( ) ; public String [ ] getNotIncludedFiles ( ) ; public void scan ( ) ; public void setBasedir ( String basedir ) ; public void setBasedir ( File basedir ) ; public void setExcludes ( String [ ] excludes ) ; public void setIncludes ( String [ ] includes ) ; } 	0	['13', '1', '0', '5', '13', '78', '5', '0', '13', '2', '13', '0', '0', '0', '0.326923077', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class FilterSet extends DataType { public static class Filter { String token ; String value ; public Filter ( String token , String value ) { this . token = token ; this . value = value ; } public Filter ( ) { } public void setToken ( String token ) { this . token = token ; } public void setValue ( String value ) { this . value = value ; } public String getToken ( ) { return token ; } public String getValue ( ) { return value ; } } public class FiltersFile { public FiltersFile ( ) { } public void setFile ( File file ) { readFiltersFromFile ( file ) ; } } public static final String DEFAULT_TOKEN_START = "@" ; public static final String DEFAULT_TOKEN_END = "@" ; private String startOfToken = DEFAULT_TOKEN_START ; private String endOfToken = DEFAULT_TOKEN_END ; private Vector filters = new Vector ( ) ; public FilterSet ( ) { } protected FilterSet ( FilterSet filterset ) { super ( ) ; this . filters = ( Vector ) filterset . getFilters ( ) . clone ( ) ; } protected Vector getFilters ( ) { if ( isReference ( ) ) { return getRef ( ) . getFilters ( ) ; } return filters ; } protected FilterSet getRef ( ) { return ( FilterSet ) getCheckedRef ( FilterSet . class , "filterset" ) ; } public Hashtable getFilterHash ( ) { int filterSize = getFilters ( ) . size ( ) ; Hashtable filterHash = new Hashtable ( filterSize ) ; for ( Enumeration e = getFilters ( ) . elements ( ) ; e . hasMoreElements ( ) ; ) { Filter filter = ( Filter ) e . nextElement ( ) ; filterHash . put ( filter . getToken ( ) , filter . getValue ( ) ) ; } return filterHash ; } public void setFiltersfile ( File filtersFile ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } readFiltersFromFile ( filtersFile ) ; } public void setBeginToken ( String startOfToken ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . startOfToken = startOfToken ; } public String getBeginToken ( ) { if ( isReference ( ) ) { return getRef ( ) . getBeginToken ( ) ; } return startOfToken ; } public void setEndToken ( String endOfToken ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . endOfToken = endOfToken ; } public String getEndToken ( ) { if ( isReference ( ) ) { return getRef ( ) . getEndToken ( ) ; } return endOfToken ; } public void readFiltersFromFile ( File filtersFile ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( filtersFile . isFile ( ) ) { log ( "Reading filters from " + filtersFile , Project . MSG_VERBOSE ) ; FileInputStream in = null ; try { Properties props = new Properties ( ) ; in = new FileInputStream ( filtersFile ) ; props . load ( in ) ; Enumeration enum = props . propertyNames ( ) ; Vector filters = getFilters ( ) ; while ( enum . hasMoreElements ( ) ) { String strPropName = ( String ) enum . nextElement ( ) ; String strValue = props . getProperty ( strPropName ) ; filters . addElement ( new Filter ( strPropName , strValue ) ) ; } } catch ( Exception e ) { throw new BuildException ( "Could not read filters from file: " + filtersFile ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( IOException ioex ) { } } } } else { throw new BuildException ( "Must specify a file not a directory in the filtersfile attribute:" + filtersFile ) ; } } public String replaceTokens ( String line ) { String beginToken = getBeginToken ( ) ; String endToken = getEndToken ( ) ; int index = line . indexOf ( beginToken ) ; if ( index > - 1 ) { Hashtable tokens = getFilterHash ( ) ; try { StringBuffer b = new StringBuffer ( ) ; int i = 0 ; String token = null ; String value = null ; do { int endIndex = line . indexOf ( endToken , index + beginToken . length ( ) + 1 ) ; if ( endIndex == - 1 ) { break ; } token = line . substring ( index + beginToken . length ( ) , endIndex ) ; b . append ( line . substring ( i , index ) ) ; if ( tokens . containsKey ( token ) ) { value = ( String ) tokens . get ( token ) ; log ( "Replacing: " + beginToken + token + endToken + " -> " + value , Project . MSG_VERBOSE ) ; b . append ( value ) ; i = index + beginToken . length ( ) + token . length ( ) + endToken . length ( ) ; } else { b . append ( beginToken ) ; i = index + beginToken . length ( ) ; } } while ( ( index = line . indexOf ( beginToken , i ) ) > - 1 ) ; b . append ( line . substring ( i ) ) ; return b . toString ( ) ; } catch ( StringIndexOutOfBoundsException e ) { return line ; } } else { return line ; } } public void addFilter ( Filter filter ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } filters . addElement ( filter ) ; } public FiltersFile createFiltersfile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return new FiltersFile ( ) ; } public void addFilter ( String token , String value ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } filters . addElement ( new Filter ( token , value ) ) ; } public void addFilterSet ( FilterSet filterSet ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } for ( Enumeration e = filterSet . getFilters ( ) . elements ( ) ; e . hasMoreElements ( ) ; ) { filters . addElement ( ( Filter ) e . nextElement ( ) ) ; } } public boolean hasFilters ( ) { return getFilters ( ) . size ( ) > 0 ; } } 	0	['18', '3', '0', '10', '59', '103', '6', '5', '14', '0.774509804', '466', '0.5', '0', '0.652173913', '0.3', '0', '0', '24.55555556', '5', '1.8333', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Stack ; import java . util . StringTokenizer ; import java . util . Vector ; import java . util . zip . CRC32 ; import java . util . zip . ZipInputStream ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import org . apache . tools . ant . util . * ; import org . apache . tools . zip . * ; public class Zip extends MatchingTask { private File zipFile ; private File baseDir ; private boolean doCompress = true ; private boolean doUpdate = false ; private boolean doFilesonly = false ; protected String archiveType = "zip" ; private static long emptyCrc = new CRC32 ( ) . getValue ( ) ; protected String emptyBehavior = "skip" ; private Vector filesets = new Vector ( ) ; private Hashtable addedDirs = new Hashtable ( ) ; private Vector addedFiles = new Vector ( ) ; private boolean addingNewFiles ; private String encoding = null ; public void setZipfile ( File zipFile ) { this . zipFile = zipFile ; } public void setBasedir ( File baseDir ) { this . baseDir = baseDir ; } public void setCompress ( boolean c ) { doCompress = c ; } public void setFilesonly ( boolean f ) { doFilesonly = f ; } public void setUpdate ( boolean c ) { doUpdate = c ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void addZipfileset ( ZipFileSet set ) { filesets . addElement ( set ) ; } public static class WhenEmpty extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "fail" , "skip" , "create" } ; } } public void setWhenempty ( WhenEmpty we ) { emptyBehavior = we . getValue ( ) ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public void execute ( ) throws BuildException { if ( baseDir == null && filesets . size ( ) == 0 && "zip" . equals ( archiveType ) ) { throw new BuildException ( "basedir attribute must be set, or at least " + "one fileset must be given!" ) ; } if ( zipFile == null ) { throw new BuildException ( "You must specify the " + archiveType + " file to create!" ) ; } File renamedFile = null ; addingNewFiles = true ; boolean reallyDoUpdate = false ; if ( doUpdate && zipFile . exists ( ) ) { reallyDoUpdate = true ; int i ; for ( i = 0 ; i < 1000 ; i ++ ) { renamedFile = new File ( zipFile . getParent ( ) , "tmp." + i ) ; if ( ! renamedFile . exists ( ) ) { break ; } } if ( i == 1000 ) { throw new BuildException ( "Can't find available temporary filename to which to rename old file." ) ; } try { if ( ! zipFile . renameTo ( renamedFile ) ) { throw new BuildException ( "Unable to rename old file to temporary file" ) ; } } catch ( SecurityException e ) { throw new BuildException ( "Not allowed to rename old file to temporary file" ) ; } } Vector dss = new Vector ( ) ; if ( baseDir != null ) { dss . addElement ( getDirectoryScanner ( baseDir ) ) ; } for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; dss . addElement ( fs . getDirectoryScanner ( project ) ) ; } int dssSize = dss . size ( ) ; FileScanner [ ] scanners = new FileScanner [ dssSize ] ; dss . copyInto ( scanners ) ; if ( isUpToDate ( scanners , zipFile ) ) { return ; } String action = reallyDoUpdate ? "Updating " : "Building " ; log ( action + archiveType + ": " + zipFile . getAbsolutePath ( ) ) ; boolean success = false ; try { ZipOutputStream zOut = new ZipOutputStream ( new FileOutputStream ( zipFile ) ) ; zOut . setEncoding ( encoding ) ; try { if ( doCompress ) { zOut . setMethod ( ZipOutputStream . DEFLATED ) ; } else { zOut . setMethod ( ZipOutputStream . STORED ) ; } initZipOutputStream ( zOut ) ; if ( baseDir != null ) { addFiles ( getDirectoryScanner ( baseDir ) , zOut , "" , "" ) ; } addFiles ( filesets , zOut ) ; if ( reallyDoUpdate ) { addingNewFiles = false ; ZipFileSet oldFiles = new ZipFileSet ( ) ; oldFiles . setSrc ( renamedFile ) ; StringBuffer exclusionPattern = new StringBuffer ( ) ; for ( int i = 0 ; i < addedFiles . size ( ) ; i ++ ) { if ( i != 0 ) { exclusionPattern . append ( "," ) ; } exclusionPattern . append ( ( String ) addedFiles . elementAt ( i ) ) ; } oldFiles . setExcludes ( exclusionPattern . toString ( ) ) ; Vector tmp = new Vector ( ) ; tmp . addElement ( oldFiles ) ; addFiles ( tmp , zOut ) ; } finalizeZipOutputStream ( zOut ) ; success = true ; } finally { try { if ( zOut != null ) { zOut . close ( ) ; } } catch ( IOException ex ) { if ( success ) throw ex ; } } } catch ( IOException ioe ) { String msg = "Problem creating " + archiveType + ": " + ioe . getMessage ( ) ; if ( ! zipFile . delete ( ) ) { msg += " (and the archive is probably corrupt but I could not delete it)" ; } if ( reallyDoUpdate ) { if ( ! renamedFile . renameTo ( zipFile ) ) { msg += " (and I couldn't rename the temporary file " + renamedFile . getName ( ) + " back)" ; } } throw new BuildException ( msg , ioe , location ) ; } finally { cleanUp ( ) ; } if ( success && reallyDoUpdate ) { if ( ! renamedFile . delete ( ) ) { log ( "Warning: unable to delete temporary file " + renamedFile . getName ( ) , Project . MSG_WARN ) ; } } } protected boolean isAddingNewFiles ( ) { return addingNewFiles ; } protected void addFiles ( FileScanner scanner , ZipOutputStream zOut , String prefix , String fullpath ) throws IOException { if ( prefix . length ( ) > 0 && fullpath . length ( ) > 0 ) throw new BuildException ( "Both prefix and fullpath attributes may not be set on the same fileset." ) ; File thisBaseDir = scanner . getBasedir ( ) ; String [ ] dirs = scanner . getIncludedDirectories ( ) ; if ( dirs . length > 0 && fullpath . length ( ) > 0 ) throw new BuildException ( "fullpath attribute may only be specified for filesets that specify a single file." ) ; for ( int i = 0 ; i < dirs . length ; i ++ ) { if ( "" . equals ( dirs [ i ] ) ) { continue ; } String name = dirs [ i ] . replace ( File . separatorChar , '/' ) ; if ( ! name . endsWith ( "/" ) ) { name += "/" ; } addParentDirs ( thisBaseDir , name , zOut , prefix ) ; } String [ ] files = scanner . getIncludedFiles ( ) ; if ( files . length > 1 && fullpath . length ( ) > 0 ) throw new BuildException ( "fullpath attribute may only be specified for filesets that specify a single file." ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File f = new File ( thisBaseDir , files [ i ] ) ; if ( fullpath . length ( ) > 0 ) { addParentDirs ( null , fullpath , zOut , "" ) ; zipFile ( f , zOut , fullpath ) ; } else { String name = files [ i ] . replace ( File . separatorChar , '/' ) ; addParentDirs ( thisBaseDir , name , zOut , prefix ) ; zipFile ( f , zOut , prefix + name ) ; } } } protected void addZipEntries ( ZipFileSet fs , DirectoryScanner ds , ZipOutputStream zOut , String prefix ) throws IOException { ZipScanner zipScanner = ( ZipScanner ) ds ; File zipSrc = fs . getSrc ( ) ; ZipEntry entry ; java . util . zip . ZipEntry origEntry ; ZipInputStream in = null ; try { in = new ZipInputStream ( new FileInputStream ( zipSrc ) ) ; while ( ( origEntry = in . getNextEntry ( ) ) != null ) { entry = new ZipEntry ( origEntry ) ; String vPath = entry . getName ( ) ; if ( zipScanner . match ( vPath ) ) { addParentDirs ( null , vPath , zOut , prefix ) ; if ( ! entry . isDirectory ( ) ) { zipFile ( in , zOut , prefix + vPath , entry . getTime ( ) ) ; } } } } finally { if ( in != null ) { in . close ( ) ; } } } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { } protected void finalizeZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { } protected boolean createEmptyZip ( File zipFile ) { log ( "Note: creating empty " + archiveType + " archive " + zipFile , Project . MSG_INFO ) ; try { OutputStream os = new FileOutputStream ( zipFile ) ; try { byte [ ] empty = new byte [ 22 ] ; empty [ 0 ] = 80 ; empty [ 1 ] = 75 ; empty [ 2 ] = 5 ; empty [ 3 ] = 6 ; os . write ( empty ) ; } finally { os . close ( ) ; } } catch ( IOException ioe ) { throw new BuildException ( "Could not create empty ZIP archive" , ioe , location ) ; } return true ; } protected boolean isUpToDate ( FileScanner [ ] scanners , File zipFile ) throws BuildException { String [ ] [ ] fileNames = grabFileNames ( scanners ) ; File [ ] files = grabFiles ( scanners , fileNames ) ; if ( files . length == 0 ) { if ( emptyBehavior . equals ( "skip" ) ) { log ( "Warning: skipping " + archiveType + " archive " + zipFile + " because no files were included." , Project . MSG_WARN ) ; return true ; } else if ( emptyBehavior . equals ( "fail" ) ) { throw new BuildException ( "Cannot create " + archiveType + " archive " + zipFile + ": no files were included." , location ) ; } else { return createEmptyZip ( zipFile ) ; } } else { for ( int i = 0 ; i < files . length ; ++ i ) { if ( files [ i ] . equals ( zipFile ) ) { throw new BuildException ( "A zip file cannot include itself" , location ) ; } } if ( ! zipFile . exists ( ) ) return false ; SourceFileScanner sfs = new SourceFileScanner ( this ) ; MergingMapper mm = new MergingMapper ( ) ; mm . setTo ( zipFile . getAbsolutePath ( ) ) ; for ( int i = 0 ; i < scanners . length ; i ++ ) { if ( sfs . restrict ( fileNames [ i ] , scanners [ i ] . getBasedir ( ) , null , mm ) . length > 0 ) { return false ; } } return true ; } } protected static File [ ] grabFiles ( FileScanner [ ] scanners ) { return grabFiles ( scanners , grabFileNames ( scanners ) ) ; } protected static File [ ] grabFiles ( FileScanner [ ] scanners , String [ ] [ ] fileNames ) { Vector files = new Vector ( ) ; for ( int i = 0 ; i < fileNames . length ; i ++ ) { File thisBaseDir = scanners [ i ] . getBasedir ( ) ; for ( int j = 0 ; j < fileNames [ i ] . length ; j ++ ) files . addElement ( new File ( thisBaseDir , fileNames [ i ] [ j ] ) ) ; } File [ ] toret = new File [ files . size ( ) ] ; files . copyInto ( toret ) ; return toret ; } protected static String [ ] [ ] grabFileNames ( FileScanner [ ] scanners ) { String [ ] [ ] result = new String [ scanners . length ] [ ] ; for ( int i = 0 ; i < scanners . length ; i ++ ) { String [ ] files = scanners [ i ] . getIncludedFiles ( ) ; String [ ] dirs = scanners [ i ] . getIncludedDirectories ( ) ; result [ i ] = new String [ files . length + dirs . length ] ; System . arraycopy ( files , 0 , result [ i ] , 0 , files . length ) ; System . arraycopy ( dirs , 0 , result [ i ] , files . length , dirs . length ) ; } return result ; } protected void zipDir ( File dir , ZipOutputStream zOut , String vPath ) throws IOException { if ( addedDirs . get ( vPath ) != null ) { return ; } addedDirs . put ( vPath , vPath ) ; ZipEntry ze = new ZipEntry ( vPath ) ; if ( dir != null && dir . exists ( ) ) { ze . setTime ( dir . lastModified ( ) ) ; } else { ze . setTime ( System . currentTimeMillis ( ) ) ; } ze . setSize ( 0 ) ; ze . setMethod ( ZipEntry . STORED ) ; ze . setCrc ( emptyCrc ) ; ze . setExternalAttributes ( 0x41FD0010L ) ; zOut . putNextEntry ( ze ) ; } protected void zipFile ( InputStream in , ZipOutputStream zOut , String vPath , long lastModified ) throws IOException { ZipEntry ze = new ZipEntry ( vPath ) ; ze . setTime ( lastModified ) ; if ( ! doCompress ) { long size = 0 ; CRC32 cal = new CRC32 ( ) ; if ( ! in . markSupported ( ) ) { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { size += count ; cal . update ( buffer , 0 , count ) ; bos . write ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; in = new ByteArrayInputStream ( bos . toByteArray ( ) ) ; } else { in . mark ( Integer . MAX_VALUE ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { size += count ; cal . update ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; in . reset ( ) ; } ze . setSize ( size ) ; ze . setCrc ( cal . getValue ( ) ) ; } zOut . putNextEntry ( ze ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { if ( count != 0 ) { zOut . write ( buffer , 0 , count ) ; } count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; addedFiles . addElement ( vPath ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath ) throws IOException { if ( file . equals ( zipFile ) ) { throw new BuildException ( "A zip file cannot include itself" , location ) ; } FileInputStream fIn = new FileInputStream ( file ) ; try { zipFile ( fIn , zOut , vPath , file . lastModified ( ) ) ; } finally { fIn . close ( ) ; } } protected void addParentDirs ( File baseDir , String entry , ZipOutputStream zOut , String prefix ) throws IOException { if ( ! doFilesonly ) { Stack directories = new Stack ( ) ; int slashPos = entry . length ( ) ; while ( ( slashPos = entry . lastIndexOf ( ( int ) '/' , slashPos - 1 ) ) != - 1 ) { String dir = entry . substring ( 0 , slashPos + 1 ) ; if ( addedDirs . get ( prefix + dir ) != null ) { break ; } directories . push ( dir ) ; } while ( ! directories . isEmpty ( ) ) { String dir = ( String ) directories . pop ( ) ; File f = null ; if ( baseDir != null ) { f = new File ( baseDir , dir ) ; } else { f = new File ( dir ) ; } zipDir ( f , zOut , prefix + dir ) ; } } } protected void addFiles ( Vector filesets , ZipOutputStream zOut ) throws IOException { for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; String prefix = "" ; String fullpath = "" ; if ( fs instanceof ZipFileSet ) { ZipFileSet zfs = ( ZipFileSet ) fs ; prefix = zfs . getPrefix ( ) ; fullpath = zfs . getFullpath ( ) ; } if ( prefix . length ( ) > 0 && ! prefix . endsWith ( "/" ) && ! prefix . endsWith ( "\\" ) ) { prefix += "/" ; } if ( prefix . length ( ) > 0 ) { addParentDirs ( null , prefix , zOut , "" ) ; zipDir ( null , zOut , prefix ) ; } else if ( fullpath . length ( ) > 0 ) { addParentDirs ( null , fullpath , zOut , "" ) ; } if ( fs instanceof ZipFileSet && ( ( ZipFileSet ) fs ) . getSrc ( ) != null ) { addZipEntries ( ( ZipFileSet ) fs , ds , zOut , prefix ) ; } else { addFiles ( ds , zOut , prefix , fullpath ) ; } } } protected void cleanUp ( ) { addedDirs = new Hashtable ( ) ; addedFiles = new Vector ( ) ; } } 	0	['28', '4', '1', '21', '123', '302', '3', '18', '11', '0.868945869', '1423', '1', '0', '0.75', '0.158024691', '4', '5', '49.35714286', '3', '1.1071', '0']
package org . apache . tools . zip ; public interface UnixStat { public static final int PERM_MASK = 07777 ; public static final int LINK_FLAG = 0120000 ; public static final int FILE_FLAG = 0100000 ; public static final int DIR_FLAG = 040000 ; public static final int DEFAULT_LINK_PERM = 0777 ; public static final int DEFAULT_DIR_PERM = 0755 ; public static final int DEFAULT_FILE_PERM = 0644 ; } 	0	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '7', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . tools . ant . util . regexp ; import org . apache . regexp . * ; import org . apache . tools . ant . BuildException ; import java . util . Vector ; public class JakartaRegexpMatcher implements RegexpMatcher { protected RE reg = null ; private String pattern ; public void setPattern ( String pattern ) throws BuildException { try { this . pattern = pattern ; reg = new RE ( pattern ) ; } catch ( RESyntaxException e ) { throw new BuildException ( e ) ; } } public String getPattern ( ) { return pattern ; } public boolean matches ( String argument ) { return reg . match ( argument ) ; } public Vector getGroups ( String argument ) { if ( ! matches ( argument ) ) { return null ; } Vector v = new Vector ( ) ; for ( int i = 0 ; i < reg . getParenCount ( ) ; i ++ ) { v . addElement ( reg . getParen ( i ) ) ; } return v ; } } 	0	['5', '1', '0', '4', '13', '0', '0', '4', '5', '0.5', '65', '1', '0', '0', '0.8', '0', '0', '11.6', '3', '1.2', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . types . Commandline ; import java . lang . reflect . Method ; import java . io . * ; public class Javac13 extends DefaultCompilerAdapter { private static final int MODERN_COMPILER_SUCCESS = 0 ; public boolean execute ( ) throws BuildException { attributes . log ( "Using modern compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupJavacCommand ( ) ; try { Class c = Class . forName ( "com.sun.tools.javac.Main" ) ; Object compiler = c . newInstance ( ) ; Method compile = c . getMethod ( "compile" , new Class [ ] { ( new String [ ] { } ) . getClass ( ) } ) ; int result = ( ( Integer ) compile . invoke ( compiler , new Object [ ] { cmd . getArguments ( ) } ) ) . intValue ( ) ; return ( result == MODERN_COMPILER_SUCCESS ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting modern compiler" , ex , location ) ; } } } } 	0	['2', '2', '0', '7', '13', '1', '1', '6', '2', '2', '66', '1', '0', '0.958333333', '1', '0', '0', '31.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . types . Commandline ; import java . io . * ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; public class Javac12 extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using classic compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupJavacCommand ( ) ; OutputStream logstr = new LogOutputStream ( attributes , Project . MSG_WARN ) ; try { Class c = Class . forName ( "sun.tools.javac.Main" ) ; Constructor cons = c . getConstructor ( new Class [ ] { OutputStream . class , String . class } ) ; Object compiler = cons . newInstance ( new Object [ ] { logstr , "javac" } ) ; Method compile = c . getMethod ( "compile" , new Class [ ] { String [ ] . class } ) ; Boolean ok = ( Boolean ) compile . invoke ( compiler , new Object [ ] { cmd . getArguments ( ) } ) ; return ok . booleanValue ( ) ; } catch ( ClassNotFoundException ex ) { throw new BuildException ( "Cannot use classic compiler, as it is not available" + " A common solution is to set the environment variable" + " JAVA_HOME to your jdk directory." , location ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting classic compiler: " , ex , location ) ; } } finally { try { logstr . close ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } } } 	0	['3', '2', '0', '8', '20', '3', '1', '7', '2', '1', '150', '0', '0', '0.92', '0.5', '0', '0', '48', '1', '0.6667', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . FileScanner ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import java . io . File ; import java . util . Stack ; import java . util . Vector ; public class FileSet extends DataType { private PatternSet defaultPatterns = new PatternSet ( ) ; private Vector additionalPatterns = new Vector ( ) ; private File dir ; private boolean useDefaultExcludes = true ; public FileSet ( ) { super ( ) ; } protected FileSet ( FileSet fileset ) { this . dir = fileset . dir ; this . defaultPatterns = fileset . defaultPatterns ; this . additionalPatterns = fileset . additionalPatterns ; this . useDefaultExcludes = fileset . useDefaultExcludes ; } public void setRefid ( Reference r ) throws BuildException { if ( dir != null || defaultPatterns . hasPatterns ( ) ) { throw tooManyAttributes ( ) ; } if ( ! additionalPatterns . isEmpty ( ) ) { throw noChildrenAllowed ( ) ; } super . setRefid ( r ) ; } public void setDir ( File dir ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . dir = dir ; } public File getDir ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getDir ( p ) ; } return dir ; } public PatternSet createPatternSet ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } PatternSet patterns = new PatternSet ( ) ; additionalPatterns . addElement ( patterns ) ; return patterns ; } public PatternSet . NameEntry createInclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return defaultPatterns . createInclude ( ) ; } public PatternSet . NameEntry createIncludesFile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return defaultPatterns . createIncludesFile ( ) ; } public PatternSet . NameEntry createExclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return defaultPatterns . createExclude ( ) ; } public PatternSet . NameEntry createExcludesFile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return defaultPatterns . createExcludesFile ( ) ; } public void setIncludes ( String includes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } defaultPatterns . setIncludes ( includes ) ; } public void setExcludes ( String excludes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } defaultPatterns . setExcludes ( excludes ) ; } public void setIncludesfile ( File incl ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } defaultPatterns . setIncludesfile ( incl ) ; } public void setExcludesfile ( File excl ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } defaultPatterns . setExcludesfile ( excl ) ; } public void setDefaultexcludes ( boolean useDefaultExcludes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . useDefaultExcludes = useDefaultExcludes ; } public DirectoryScanner getDirectoryScanner ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getDirectoryScanner ( p ) ; } if ( dir == null ) { throw new BuildException ( "No directory specified for fileset." ) ; } if ( ! dir . exists ( ) ) { throw new BuildException ( dir . getAbsolutePath ( ) + " not found." ) ; } if ( ! dir . isDirectory ( ) ) { throw new BuildException ( dir . getAbsolutePath ( ) + " is not a directory." ) ; } DirectoryScanner ds = new DirectoryScanner ( ) ; setupDirectoryScanner ( ds , p ) ; ds . scan ( ) ; return ds ; } public void setupDirectoryScanner ( FileScanner ds , Project p ) { if ( ds == null ) { throw new IllegalArgumentException ( "ds cannot be null" ) ; } ds . setBasedir ( dir ) ; for ( int i = 0 ; i < additionalPatterns . size ( ) ; i ++ ) { Object o = additionalPatterns . elementAt ( i ) ; defaultPatterns . append ( ( PatternSet ) o , p ) ; } p . log ( "FileSet: Setup file scanner in dir " + dir + " with " + defaultPatterns , p . MSG_DEBUG ) ; ds . setIncludes ( defaultPatterns . getIncludePatterns ( p ) ) ; ds . setExcludes ( defaultPatterns . getExcludePatterns ( p ) ) ; if ( useDefaultExcludes ) ds . addDefaultExcludes ( ) ; } protected FileSet getRef ( Project p ) { if ( ! checked ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , p ) ; } Object o = ref . getReferencedObject ( p ) ; if ( ! ( o instanceof FileSet ) ) { String msg = ref . getRefId ( ) + " doesn\'t denote a fileset" ; throw new BuildException ( msg ) ; } else { return ( FileSet ) o ; } } } 	0	['18', '3', '2', '31', '62', '0', '23', '8', '16', '0.617647059', '396', '1', '1', '0.652173913', '0.215277778', '1', '1', '20.77777778', '5', '1.8889', '0']
package org . apache . tools . zip ; import java . util . zip . CRC32 ; import java . util . zip . ZipException ; public class AsiExtraField implements ZipExtraField , UnixStat , Cloneable { private final static ZipShort HEADER_ID = new ZipShort ( 0x756E ) ; private int mode = 0 ; private int uid = 0 ; private int gid = 0 ; private String link = "" ; private boolean dirFlag = false ; private CRC32 crc = new CRC32 ( ) ; public AsiExtraField ( ) { } public ZipShort getHeaderId ( ) { return HEADER_ID ; } public ZipShort getLocalFileDataLength ( ) { return new ZipShort ( 4 + 2 + 4 + 2 + 2 + getLinkedFile ( ) . getBytes ( ) . length ) ; } public ZipShort getCentralDirectoryLength ( ) { return getLocalFileDataLength ( ) ; } public byte [ ] getLocalFileDataData ( ) { byte [ ] data = new byte [ getLocalFileDataLength ( ) . getValue ( ) - 4 ] ; System . arraycopy ( ( new ZipShort ( getMode ( ) ) ) . getBytes ( ) , 0 , data , 0 , 2 ) ; byte [ ] linkArray = getLinkedFile ( ) . getBytes ( ) ; System . arraycopy ( ( new ZipLong ( linkArray . length ) ) . getBytes ( ) , 0 , data , 2 , 4 ) ; System . arraycopy ( ( new ZipShort ( getUserId ( ) ) ) . getBytes ( ) , 0 , data , 6 , 2 ) ; System . arraycopy ( ( new ZipShort ( getGroupId ( ) ) ) . getBytes ( ) , 0 , data , 8 , 2 ) ; System . arraycopy ( linkArray , 0 , data , 10 , linkArray . length ) ; crc . reset ( ) ; crc . update ( data ) ; long checksum = crc . getValue ( ) ; byte [ ] result = new byte [ data . length + 4 ] ; System . arraycopy ( ( new ZipLong ( checksum ) ) . getBytes ( ) , 0 , result , 0 , 4 ) ; System . arraycopy ( data , 0 , result , 4 , data . length ) ; return result ; } public byte [ ] getCentralDirectoryData ( ) { return getLocalFileDataData ( ) ; } public void setUserId ( int uid ) { this . uid = uid ; } public int getUserId ( ) { return uid ; } public void setGroupId ( int gid ) { this . gid = gid ; } public int getGroupId ( ) { return gid ; } public void setLinkedFile ( String name ) { link = name ; mode = getMode ( mode ) ; } public String getLinkedFile ( ) { return link ; } public boolean isLink ( ) { return getLinkedFile ( ) . length ( ) != 0 ; } public void setMode ( int mode ) { this . mode = getMode ( mode ) ; } public int getMode ( ) { return mode ; } public void setDirectory ( boolean dirFlag ) { this . dirFlag = dirFlag ; mode = getMode ( mode ) ; } public boolean isDirectory ( ) { return dirFlag && ! isLink ( ) ; } public void parseFromLocalFileData ( byte [ ] data , int offset , int length ) throws ZipException { long givenChecksum = ( new ZipLong ( data , offset ) ) . getValue ( ) ; byte [ ] tmp = new byte [ length - 4 ] ; System . arraycopy ( data , offset + 4 , tmp , 0 , length - 4 ) ; crc . reset ( ) ; crc . update ( tmp ) ; long realChecksum = crc . getValue ( ) ; if ( givenChecksum != realChecksum ) { throw new ZipException ( "bad CRC checksum " + Long . toHexString ( givenChecksum ) + " instead of " + Long . toHexString ( realChecksum ) ) ; } int newMode = ( new ZipShort ( tmp , 0 ) ) . getValue ( ) ; byte [ ] linkArray = new byte [ ( int ) ( new ZipLong ( tmp , 2 ) ) . getValue ( ) ] ; uid = ( new ZipShort ( tmp , 6 ) ) . getValue ( ) ; gid = ( new ZipShort ( tmp , 8 ) ) . getValue ( ) ; if ( linkArray . length == 0 ) { link = "" ; } else { System . arraycopy ( tmp , 10 , linkArray , 0 , linkArray . length ) ; link = new String ( linkArray ) ; } setDirectory ( ( newMode & DIR_FLAG ) != 0 ) ; setMode ( newMode ) ; } protected int getMode ( int mode ) { int type = FILE_FLAG ; if ( isLink ( ) ) { type = LINK_FLAG ; } else if ( isDirectory ( ) ) { type = DIR_FLAG ; } return type | ( mode & PERM_MASK ) ; } } 	0	['20', '1', '0', '4', '42', '130', '0', '4', '18', '0.736842105', '376', '1', '1', '0', '0.284210526', '0', '0', '17.45', '3', '1.15', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . ZipFileSet ; import org . apache . tools . zip . * ; import java . io . * ; import java . util . Vector ; public class War extends Jar { private File deploymentDescriptor ; private boolean descriptorAdded ; public War ( ) { super ( ) ; archiveType = "war" ; emptyBehavior = "create" ; } public void setWarfile ( File warFile ) { super . setZipfile ( warFile ) ; } public void setWebxml ( File descr ) { deploymentDescriptor = descr ; if ( ! deploymentDescriptor . exists ( ) ) throw new BuildException ( "Deployment descriptor: " + deploymentDescriptor + " does not exist." ) ; ZipFileSet fs = new ZipFileSet ( ) ; fs . setDir ( new File ( deploymentDescriptor . getParent ( ) ) ) ; fs . setIncludes ( deploymentDescriptor . getName ( ) ) ; fs . setFullpath ( "WEB-INF/web.xml" ) ; super . addFileset ( fs ) ; } public void addLib ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/lib/" ) ; super . addFileset ( fs ) ; } public void addClasses ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/classes/" ) ; super . addFileset ( fs ) ; } public void addWebinf ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/" ) ; super . addFileset ( fs ) ; } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( deploymentDescriptor == null ) { throw new BuildException ( "webxml attribute is required" , location ) ; } super . initZipOutputStream ( zOut ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath ) throws IOException { if ( vPath . equalsIgnoreCase ( "WEB-INF/web.xml" ) ) { if ( deploymentDescriptor == null || ! deploymentDescriptor . equals ( file ) || descriptorAdded ) { log ( "Warning: selected " + archiveType + " files include a WEB-INF/web.xml which will be ignored " + "(please use webxml attribute to " + archiveType + " task)" , Project . MSG_WARN ) ; } else { super . zipFile ( file , zOut , vPath ) ; descriptorAdded = true ; } } else { super . zipFile ( file , zOut , vPath ) ; } } protected void cleanUp ( ) { descriptorAdded = false ; super . cleanUp ( ) ; } } 	0	['9', '6', '0', '8', '33', '28', '0', '8', '6', '0.8125', '163', '1', '0', '0.950617284', '0.4', '4', '9', '16.88888889', '2', '1', '0']
package org . apache . tools . ant ; import java . io . * ; import java . util . * ; import java . net . * ; import java . lang . reflect . * ; public class Launcher { static private File determineAntHome11 ( ) { String classpath = System . getProperty ( "java.class.path" ) ; StringTokenizer tokenizer = new StringTokenizer ( classpath , System . getProperty ( "path.separator" ) ) ; while ( tokenizer . hasMoreTokens ( ) ) { String path = tokenizer . nextToken ( ) ; if ( path . endsWith ( "ant.jar" ) ) { File antJarFile = new File ( path ) ; File libDirectory = new File ( antJarFile . getParent ( ) ) ; File antHome = new File ( libDirectory . getParent ( ) ) ; return antHome ; } } return null ; } static private File determineAntHome ( ClassLoader systemClassLoader ) { try { String className = Launcher . class . getName ( ) . replace ( '.' , '/' ) + ".class" ; URL classResource = systemClassLoader . getResource ( className ) ; String fileComponent = classResource . getFile ( ) ; if ( classResource . getProtocol ( ) . equals ( "file" ) ) { int classFileIndex = fileComponent . lastIndexOf ( className ) ; if ( classFileIndex != - 1 ) { fileComponent = fileComponent . substring ( 0 , classFileIndex ) ; } File classFilesDir = new File ( fileComponent ) ; File buildDir = new File ( classFilesDir . getParent ( ) ) ; File devAntHome = new File ( buildDir . getParent ( ) ) ; return devAntHome ; } else if ( classResource . getProtocol ( ) . equals ( "jar" ) ) { int classSeparatorIndex = fileComponent . lastIndexOf ( "!" ) ; if ( classSeparatorIndex != - 1 ) { fileComponent = fileComponent . substring ( 0 , classSeparatorIndex ) ; } URL antJarURL = new URL ( fileComponent ) ; File antJarFile = new File ( antJarURL . getFile ( ) ) ; File libDirectory = new File ( antJarFile . getParent ( ) ) ; File antHome = new File ( libDirectory . getParent ( ) ) ; return antHome ; } } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } return null ; } static private void addDirJars ( AntClassLoader classLoader , File jarDir ) { String [ ] fileList = jarDir . list ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { return name . endsWith ( ".jar" ) ; } } ) ; if ( fileList != null ) { for ( int i = 0 ; i < fileList . length ; ++ i ) { File jarFile = new File ( jarDir , fileList [ i ] ) ; classLoader . addPathElement ( jarFile . getAbsolutePath ( ) ) ; } } } static private void addToolsJar ( AntClassLoader antLoader ) { String javaHome = System . getProperty ( "java.home" ) ; if ( javaHome . endsWith ( "jre" ) ) { javaHome = javaHome . substring ( 0 , javaHome . length ( ) - 4 ) ; } System . out . println ( "Java home is " + javaHome ) ; File toolsJar = new File ( javaHome , "lib/tools.jar" ) ; if ( ! toolsJar . exists ( ) ) { System . out . println ( "Unable to find tools.jar at " + toolsJar . getPath ( ) ) ; } else { antLoader . addPathElement ( toolsJar . getAbsolutePath ( ) ) ; } } static public void main ( String [ ] args ) { File antHome = null ; ClassLoader systemClassLoader = Launcher . class . getClassLoader ( ) ; if ( systemClassLoader == null ) { antHome = determineAntHome11 ( ) ; } else { antHome = determineAntHome ( systemClassLoader ) ; } if ( antHome == null ) { System . err . println ( "Unable to determine ANT_HOME" ) ; System . exit ( 1 ) ; } System . out . println ( "ANT_HOME is " + antHome ) ; AntClassLoader antLoader = new AntClassLoader ( systemClassLoader , false ) ; addToolsJar ( antLoader ) ; File libDir = new File ( antHome , "lib" ) ; addDirJars ( antLoader , libDir ) ; File optionalDir = new File ( antHome , "lib/optional" ) ; addDirJars ( antLoader , optionalDir ) ; Properties launchProperties = new Properties ( ) ; launchProperties . put ( "ant.home" , antHome . getAbsolutePath ( ) ) ; try { Class mainClass = antLoader . loadClass ( "org.apache.tools.ant.Main" ) ; antLoader . initializeClass ( mainClass ) ; final Class [ ] param = { Class . forName ( "[Ljava.lang.String;" ) , Properties . class , ClassLoader . class } ; final Method startMethod = mainClass . getMethod ( "start" , param ) ; final Object [ ] argument = { args , launchProperties , systemClassLoader } ; startMethod . invoke ( null , argument ) ; } catch ( Exception e ) { System . out . println ( "Exception running Ant: " + e . getClass ( ) . getName ( ) + ": " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; } } } 	0	['7', '1', '0', '2', '52', '19', '0', '2', '2', '0.944444444', '412', '0', '0', '0', '0.166666667', '0', '0', '57.42857143', '6', '3', '0']
package org . apache . tools . ant . types ; import java . io . File ; import java . util . Stack ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; public class ZipFileSet extends FileSet { private File srcFile = null ; private String prefix = "" ; private String fullpath = "" ; private boolean hasDir = false ; public void setDir ( File dir ) throws BuildException { if ( srcFile != null ) { throw new BuildException ( "Cannot set both dir and src attributes" ) ; } else { super . setDir ( dir ) ; hasDir = true ; } } public void setSrc ( File srcFile ) { if ( hasDir ) { throw new BuildException ( "Cannot set both dir and src attributes" ) ; } this . srcFile = srcFile ; } public File getSrc ( ) { return srcFile ; } public void setPrefix ( String prefix ) { this . prefix = prefix ; } public String getPrefix ( ) { return prefix ; } public void setFullpath ( String fullpath ) { this . fullpath = fullpath ; } public String getFullpath ( ) { return fullpath ; } public DirectoryScanner getDirectoryScanner ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getDirectoryScanner ( p ) ; } if ( srcFile != null ) { ZipScanner zs = new ZipScanner ( ) ; zs . setSrc ( srcFile ) ; super . setDir ( p . getBaseDir ( ) ) ; setupDirectoryScanner ( zs , p ) ; zs . init ( ) ; return zs ; } else { return super . getDirectoryScanner ( p ) ; } } } 	0	['9', '5', '0', '11', '20', '4', '4', '7', '9', '0.6875', '108', '1', '0', '0.919191919', '0.388888889', '2', '7', '10.55555556', '3', '1.2222', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Vector ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . FileSet ; public class SignJar extends Task { protected String jar ; protected String alias ; protected String keystore ; protected String storepass ; protected String storetype ; protected String keypass ; protected String sigfile ; protected String signedjar ; protected boolean verbose ; protected boolean internalsf ; protected boolean sectionsonly ; protected Vector filesets = new Vector ( ) ; protected boolean lazy ; public void setJar ( final String jar ) { this . jar = jar ; } public void setAlias ( final String alias ) { this . alias = alias ; } public void setKeystore ( final String keystore ) { this . keystore = keystore ; } public void setStorepass ( final String storepass ) { this . storepass = storepass ; } public void setStoretype ( final String storetype ) { this . storetype = storetype ; } public void setKeypass ( final String keypass ) { this . keypass = keypass ; } public void setSigfile ( final String sigfile ) { this . sigfile = sigfile ; } public void setSignedjar ( final String signedjar ) { this . signedjar = signedjar ; } public void setVerbose ( final boolean verbose ) { this . verbose = verbose ; } public void setInternalsf ( final boolean internalsf ) { this . internalsf = internalsf ; } public void setSectionsonly ( final boolean sectionsonly ) { this . sectionsonly = sectionsonly ; } public void setLazy ( final boolean lazy ) { this . lazy = lazy ; } public void addFileset ( final FileSet set ) { filesets . addElement ( set ) ; } public void execute ( ) throws BuildException { if ( null == jar && null == filesets ) { throw new BuildException ( "jar must be set through jar attribute or nested filesets" ) ; } if ( null != jar ) { doOneJar ( jar , signedjar ) ; return ; } else { for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; String [ ] jarFiles = ds . getIncludedFiles ( ) ; for ( int j = 0 ; j < jarFiles . length ; j ++ ) { doOneJar ( jarFiles [ j ] , null ) ; } } } } private void doOneJar ( String jarSource , String jarTarget ) throws BuildException { if ( project . getJavaVersion ( ) . equals ( Project . JAVA_1_1 ) ) { throw new BuildException ( "The signjar task is only available on JDK versions 1.2 or greater" ) ; } if ( null == alias ) { throw new BuildException ( "alias attribute must be set" ) ; } if ( null == storepass ) { throw new BuildException ( "storepass attribute must be set" ) ; } if ( isUpToDate ( jarSource , jarTarget ) ) return ; final StringBuffer sb = new StringBuffer ( ) ; final ExecTask cmd = ( ExecTask ) project . createTask ( "exec" ) ; cmd . setExecutable ( "jarsigner" ) ; if ( null != keystore ) { cmd . createArg ( ) . setValue ( "-keystore" ) ; cmd . createArg ( ) . setValue ( keystore ) ; } if ( null != storepass ) { cmd . createArg ( ) . setValue ( "-storepass" ) ; cmd . createArg ( ) . setValue ( storepass ) ; } if ( null != storetype ) { cmd . createArg ( ) . setValue ( "-storetype" ) ; cmd . createArg ( ) . setValue ( storetype ) ; } if ( null != keypass ) { cmd . createArg ( ) . setValue ( "-keypass" ) ; cmd . createArg ( ) . setValue ( keypass ) ; } if ( null != sigfile ) { cmd . createArg ( ) . setValue ( "-sigfile" ) ; cmd . createArg ( ) . setValue ( sigfile ) ; } if ( null != jarTarget ) { cmd . createArg ( ) . setValue ( "-signedjar" ) ; cmd . createArg ( ) . setValue ( jarTarget ) ; } if ( verbose ) { cmd . createArg ( ) . setValue ( "-verbose" ) ; } if ( internalsf ) { cmd . createArg ( ) . setValue ( "-internalsf" ) ; } if ( sectionsonly ) { cmd . createArg ( ) . setValue ( "-sectionsonly" ) ; } cmd . createArg ( ) . setValue ( jarSource ) ; cmd . createArg ( ) . setValue ( alias ) ; log ( "Signing Jar : " + ( new File ( jarSource ) ) . getAbsolutePath ( ) ) ; cmd . setFailonerror ( true ) ; cmd . setTaskName ( getTaskName ( ) ) ; cmd . execute ( ) ; } protected boolean isUpToDate ( String jarSource , String jarTarget ) { if ( null == jarSource ) { return false ; } if ( null != jarTarget ) { final File jarFile = new File ( jarSource ) ; final File signedjarFile = new File ( jarTarget ) ; if ( ! jarFile . exists ( ) ) return false ; if ( ! signedjarFile . exists ( ) ) return false ; if ( jarFile . equals ( signedjarFile ) ) return false ; if ( signedjarFile . lastModified ( ) > jarFile . lastModified ( ) ) return true ; } else { if ( lazy ) { return isSigned ( jarSource ) ; } } return false ; } protected boolean isSigned ( String jarFilename ) { final String SIG_START = "META-INF/" ; final String SIG_END = ".SF" ; File file = new File ( jarFilename ) ; if ( ! file . exists ( ) ) { return false ; } ZipFile jarFile = null ; try { jarFile = new ZipFile ( file ) ; if ( null == alias ) { Enumeration entries = jarFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { String name = ( ( ZipEntry ) entries . nextElement ( ) ) . getName ( ) ; if ( name . startsWith ( SIG_START ) && name . endsWith ( SIG_END ) ) { return true ; } } return false ; } else { return jarFile . getEntry ( SIG_START + alias . toUpperCase ( ) + SIG_END ) != null ; } } catch ( IOException e ) { return false ; } finally { if ( jarFile != null ) { try { jarFile . close ( ) ; } catch ( IOException e ) { } } } } } 	0	['18', '3', '0', '8', '55', '119', '0', '8', '15', '0.882352941', '474', '1', '0', '0.685185185', '0.472222222', '0', '0', '24.61111111', '13', '2', '0']
package org . apache . tools . ant ; import java . io . * ; public interface BuildLogger extends BuildListener { public void setMessageOutputLevel ( int level ) ; public void setOutputPrintStream ( PrintStream output ) ; public void setEmacsMode ( boolean emacsMode ) ; public void setErrorPrintStream ( PrintStream err ) ; } 	0	['4', '1', '0', '4', '4', '6', '3', '1', '4', '2', '4', '0', '0', '0', '0.5', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . InputStream ; import java . io . IOException ; import java . io . OutputStream ; public interface ExecuteStreamHandler { public void setProcessInputStream ( OutputStream os ) throws IOException ; public void setProcessErrorStream ( InputStream is ) throws IOException ; public void setProcessOutputStream ( InputStream is ) throws IOException ; public void start ( ) throws IOException ; public void stop ( ) ; } 	0	['5', '1', '0', '10', '5', '10', '10', '0', '5', '2', '5', '0', '0', '0', '0.533333333', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; public class ExecuteWatchdog implements Runnable { private Process process ; private int timeout ; private boolean watch = false ; private Exception caught = null ; private boolean killedProcess = false ; public ExecuteWatchdog ( int timeout ) { if ( timeout < 1 ) { throw new IllegalArgumentException ( "timeout lesser than 1." ) ; } this . timeout = timeout ; } public synchronized void start ( Process process ) { if ( process == null ) { throw new NullPointerException ( "process is null." ) ; } if ( this . process != null ) { throw new IllegalStateException ( "Already running." ) ; } this . caught = null ; this . killedProcess = false ; this . watch = true ; this . process = process ; final Thread thread = new Thread ( this , "WATCHDOG" ) ; thread . setDaemon ( true ) ; thread . start ( ) ; } public synchronized void stop ( ) { watch = false ; notifyAll ( ) ; } public synchronized void run ( ) { try { final long until = System . currentTimeMillis ( ) + timeout ; long now ; while ( watch && until > ( now = System . currentTimeMillis ( ) ) ) { try { wait ( until - now ) ; } catch ( InterruptedException e ) { } } try { process . exitValue ( ) ; } catch ( IllegalThreadStateException e ) { if ( watch ) { killedProcess = true ; process . destroy ( ) ; } } } catch ( Exception e ) { caught = e ; } finally { cleanUp ( ) ; } } protected void cleanUp ( ) { watch = false ; process = null ; } public void checkException ( ) throws BuildException { if ( caught != null ) { throw new BuildException ( "Exception in ExecuteWatchdog.run: " + caught . getMessage ( ) , caught ) ; } } public boolean isWatching ( ) { return watch ; } public boolean killedProcess ( ) { return killedProcess ; } } 	0	['8', '1', '0', '6', '25', '0', '5', '1', '7', '0.6', '169', '1', '0', '0', '0.416666667', '0', '0', '19.5', '7', '1.875', '0']
package org . apache . tools . ant ; public interface TaskContainer { void addTask ( Task task ) ; } 	0	['1', '1', '0', '9', '1', '0', '8', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import java . util . Vector ; public class Environment { protected Vector variables ; public static class Variable { private String key , value ; public Variable ( ) { super ( ) ; } public void setKey ( String key ) { this . key = key ; } public void setValue ( String value ) { this . value = value ; } public String getKey ( ) { return this . key ; } public String getValue ( ) { return this . value ; } public void setPath ( Path path ) { this . value = path . toString ( ) ; } public void setFile ( java . io . File file ) { this . value = file . getAbsolutePath ( ) ; } public String getContent ( ) throws BuildException { if ( key == null || value == null ) { throw new BuildException ( "key and value must be specified for environment variables." ) ; } StringBuffer sb = new StringBuffer ( key . trim ( ) ) ; sb . append ( "=" ) . append ( value . trim ( ) ) ; return sb . toString ( ) ; } } public Environment ( ) { variables = new Vector ( ) ; } public void addVariable ( Variable var ) { variables . addElement ( var ) ; } public String [ ] getVariables ( ) throws BuildException { if ( variables . size ( ) == 0 ) { return null ; } String [ ] result = new String [ variables . size ( ) ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = ( ( Variable ) variables . elementAt ( i ) ) . getContent ( ) ; } return result ; } } 	0	['3', '1', '1', '6', '9', '0', '4', '2', '3', '0', '47', '1', '0', '0', '0.666666667', '0', '0', '14.33333333', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import java . util . * ; import org . apache . tools . ant . * ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . types . * ; public class Available extends Task implements Condition { private String property ; private String classname ; private File file ; private Path filepath ; private String resource ; private String type ; private Path classpath ; private AntClassLoader loader ; private String value = "true" ; public void setClasspath ( Path classpath ) { createClasspath ( ) . append ( classpath ) ; } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( project ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setFilepath ( Path filepath ) { createFilepath ( ) . append ( filepath ) ; } public Path createFilepath ( ) { if ( this . filepath == null ) { this . filepath = new Path ( project ) ; } return this . filepath . createPath ( ) ; } public void setProperty ( String property ) { this . property = property ; } public void setValue ( String value ) { this . value = value ; } public void setClassname ( String classname ) { if ( ! "" . equals ( classname ) ) { this . classname = classname ; } } public void setFile ( File file ) { this . file = file ; } public void setResource ( String resource ) { this . resource = resource ; } public void setType ( String type ) { this . type = type ; } public void execute ( ) throws BuildException { if ( property == null ) { throw new BuildException ( "property attribute is required" , location ) ; } if ( eval ( ) ) { this . project . setProperty ( property , value ) ; } } public boolean eval ( ) throws BuildException { if ( classname == null && file == null && resource == null ) { throw new BuildException ( "At least one of (classname|file|resource) is required" , location ) ; } if ( type != null ) { if ( ! type . equalsIgnoreCase ( "file" ) && ! type . equalsIgnoreCase ( "dir" ) ) { throw new BuildException ( "Type must be one of either dir or file" ) ; } } if ( classpath != null ) { classpath . setProject ( project ) ; this . loader = new AntClassLoader ( project , classpath ) ; } if ( ( classname != null ) && ! checkClass ( classname ) ) { log ( "Unable to load class " + classname + " to set property " + property , Project . MSG_VERBOSE ) ; return false ; } if ( ( file != null ) && ! checkFile ( ) ) { log ( "Unable to find " + file + " to set property " + property , Project . MSG_VERBOSE ) ; return false ; } if ( ( resource != null ) && ! checkResource ( resource ) ) { log ( "Unable to load resource " + resource + " to set property " + property , Project . MSG_VERBOSE ) ; return false ; } if ( loader != null ) { loader . cleanup ( ) ; } return true ; } private boolean checkFile ( ) { if ( filepath == null ) { return checkFile ( file ) ; } else { String [ ] paths = filepath . list ( ) ; for ( int i = 0 ; i < paths . length ; ++ i ) { log ( "Searching " + paths [ i ] , Project . MSG_VERBOSE ) ; if ( new File ( paths [ i ] , file . getName ( ) ) . isFile ( ) ) { return true ; } } } return false ; } private boolean checkFile ( File file ) { if ( type != null ) { if ( type . equalsIgnoreCase ( "dir" ) ) { return file . isDirectory ( ) ; } else if ( type . equalsIgnoreCase ( "file" ) ) { return file . isFile ( ) ; } } return file . exists ( ) ; } private boolean checkResource ( String resource ) { if ( loader != null ) { return ( loader . getResourceAsStream ( resource ) != null ) ; } else { ClassLoader cL = this . getClass ( ) . getClassLoader ( ) ; if ( cL != null ) { return ( cL . getResourceAsStream ( resource ) != null ) ; } else { return ( ClassLoader . getSystemResourceAsStream ( resource ) != null ) ; } } } private boolean checkClass ( String classname ) { try { if ( loader != null ) { loader . loadClass ( classname ) ; } else { ClassLoader l = this . getClass ( ) . getClassLoader ( ) ; if ( l != null ) { l . loadClass ( classname ) ; } else { Class . forName ( classname ) ; } } return true ; } catch ( ClassNotFoundException e ) { return false ; } catch ( NoClassDefFoundError e ) { return false ; } } } 	0	['18', '3', '0', '10', '49', '115', '1', '9', '14', '0.836601307', '397', '1', '3', '0.685185185', '0.333333333', '0', '0', '20.55555556', '6', '1.8333', '0']
package org . apache . tools . tar ; public class TarUtils { public static long parseOctal ( byte [ ] header , int offset , int length ) { long result = 0 ; boolean stillPadding = true ; int end = offset + length ; for ( int i = offset ; i < end ; ++ i ) { if ( header [ i ] == 0 ) { break ; } if ( header [ i ] == ( byte ) ' ' || header [ i ] == '0' ) { if ( stillPadding ) { continue ; } if ( header [ i ] == ( byte ) ' ' ) { break ; } } stillPadding = false ; result = ( result << 3 ) + ( header [ i ] - '0' ) ; } return result ; } public static StringBuffer parseName ( byte [ ] header , int offset , int length ) { StringBuffer result = new StringBuffer ( length ) ; int end = offset + length ; for ( int i = offset ; i < end ; ++ i ) { if ( header [ i ] == 0 ) { break ; } result . append ( ( char ) header [ i ] ) ; } return result ; } public static int getNameBytes ( StringBuffer name , byte [ ] buf , int offset , int length ) { int i ; for ( i = 0 ; i < length && i < name . length ( ) ; ++ i ) { buf [ offset + i ] = ( byte ) name . charAt ( i ) ; } for ( ; i < length ; ++ i ) { buf [ offset + i ] = 0 ; } return offset + length ; } public static int getOctalBytes ( long value , byte [ ] buf , int offset , int length ) { byte [ ] result = new byte [ length ] ; int idx = length - 1 ; buf [ offset + idx ] = 0 ; -- idx ; buf [ offset + idx ] = ( byte ) ' ' ; -- idx ; if ( value == 0 ) { buf [ offset + idx ] = ( byte ) '0' ; -- idx ; } else { for ( long val = value ; idx >= 0 && val > 0 ; -- idx ) { buf [ offset + idx ] = ( byte ) ( ( byte ) '0' + ( byte ) ( val & 7 ) ) ; val = val > > 3 ; } } for ( ; idx >= 0 ; -- idx ) { buf [ offset + idx ] = ( byte ) ' ' ; } return offset + length ; } public static int getLongOctalBytes ( long value , byte [ ] buf , int offset , int length ) { byte [ ] temp = new byte [ length + 1 ] ; getOctalBytes ( value , temp , 0 , length + 1 ) ; System . arraycopy ( temp , 0 , buf , offset , length ) ; return offset + length ; } public static int getCheckSumOctalBytes ( long value , byte [ ] buf , int offset , int length ) { getOctalBytes ( value , buf , offset , length ) ; buf [ offset + length - 1 ] = ( byte ) ' ' ; buf [ offset + length - 2 ] = 0 ; return offset + length ; } public static long computeCheckSum ( byte [ ] buf ) { long sum = 0 ; for ( int i = 0 ; i < buf . length ; ++ i ) { sum += 255 & buf [ i ] ; } return sum ; } } 	0	['8', '1', '0', '1', '14', '28', '1', '0', '8', '2', '274', '0', '0', '0', '0.45', '0', '0', '33.25', '7', '2.875', '0']
package org . apache . tools . ant ; import java . io . * ; import java . util . * ; public class Main { public static final String DEFAULT_BUILD_FILENAME = "build.xml" ; private int msgOutputLevel = Project . MSG_INFO ; private File buildFile ; private PrintStream out = System . out ; private PrintStream err = System . err ; private Vector targets = new Vector ( 5 ) ; private Properties definedProps = new Properties ( ) ; private Vector listeners = new Vector ( 5 ) ; private String loggerClassname = null ; private boolean emacsMode = false ; private boolean readyToRun = false ; private boolean projectHelp = false ; private static void printMessage ( Throwable t ) { String message = t . getMessage ( ) ; if ( message != null ) { System . err . println ( message ) ; } } public static void start ( String [ ] args , Properties additionalUserProperties , ClassLoader coreLoader ) { Main m = null ; try { m = new Main ( args ) ; } catch ( Throwable exc ) { printMessage ( exc ) ; System . exit ( 1 ) ; } if ( additionalUserProperties != null ) { for ( Enumeration e = additionalUserProperties . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; String property = additionalUserProperties . getProperty ( key ) ; m . definedProps . put ( key , property ) ; } } try { m . runBuild ( coreLoader ) ; System . exit ( 0 ) ; } catch ( BuildException be ) { if ( m . err != System . err ) { printMessage ( be ) ; } System . exit ( 1 ) ; } catch ( Throwable exc ) { printMessage ( exc ) ; System . exit ( 1 ) ; } } public static void main ( String [ ] args ) { start ( args , null , null ) ; } protected Main ( String [ ] args ) throws BuildException { String searchForThis = null ; for ( int i = 0 ; i < args . length ; i ++ ) { String arg = args [ i ] ; if ( arg . equals ( "-help" ) ) { printUsage ( ) ; return ; } else if ( arg . equals ( "-version" ) ) { printVersion ( ) ; return ; } else if ( arg . equals ( "-quiet" ) || arg . equals ( "-q" ) ) { msgOutputLevel = Project . MSG_WARN ; } else if ( arg . equals ( "-verbose" ) || arg . equals ( "-v" ) ) { printVersion ( ) ; msgOutputLevel = Project . MSG_VERBOSE ; } else if ( arg . equals ( "-debug" ) ) { printVersion ( ) ; msgOutputLevel = Project . MSG_DEBUG ; } else if ( arg . equals ( "-logfile" ) || arg . equals ( "-l" ) ) { try { File logFile = new File ( args [ i + 1 ] ) ; i ++ ; out = new PrintStream ( new FileOutputStream ( logFile ) ) ; err = out ; System . setOut ( out ) ; System . setErr ( out ) ; } catch ( IOException ioe ) { String msg = "Cannot write on the specified log file. " + "Make sure the path exists and you have write permissions." ; System . out . println ( msg ) ; return ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a log file when " + "using the -log argument" ; System . out . println ( msg ) ; return ; } } else if ( arg . equals ( "-buildfile" ) || arg . equals ( "-file" ) || arg . equals ( "-f" ) ) { try { buildFile = new File ( args [ i + 1 ] ) ; i ++ ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a buildfile when " + "using the -buildfile argument" ; System . out . println ( msg ) ; return ; } } else if ( arg . equals ( "-listener" ) ) { try { listeners . addElement ( args [ i + 1 ] ) ; i ++ ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a classname when " + "using the -listener argument" ; System . out . println ( msg ) ; return ; } } else if ( arg . startsWith ( "-D" ) ) { String name = arg . substring ( 2 , arg . length ( ) ) ; String value = null ; int posEq = name . indexOf ( "=" ) ; if ( posEq > 0 ) { value = name . substring ( posEq + 1 ) ; name = name . substring ( 0 , posEq ) ; } else if ( i < args . length - 1 ) value = args [ ++ i ] ; definedProps . put ( name , value ) ; } else if ( arg . equals ( "-logger" ) ) { if ( loggerClassname != null ) { System . out . println ( "Only one logger class may be specified." ) ; return ; } try { loggerClassname = args [ ++ i ] ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { System . out . println ( "You must specify a classname when " + "using the -logger argument" ) ; return ; } } else if ( arg . equals ( "-emacs" ) ) { emacsMode = true ; } else if ( arg . equals ( "-projecthelp" ) ) { projectHelp = true ; } else if ( arg . equals ( "-find" ) ) { if ( i < args . length - 1 ) { searchForThis = args [ ++ i ] ; } else { searchForThis = DEFAULT_BUILD_FILENAME ; } } else if ( arg . startsWith ( "-" ) ) { String msg = "Unknown argument: " + arg ; System . out . println ( msg ) ; printUsage ( ) ; return ; } else { targets . addElement ( arg ) ; } } if ( buildFile == null ) { if ( searchForThis != null ) { buildFile = findBuildFile ( System . getProperty ( "user.dir" ) , searchForThis ) ; } else { buildFile = new File ( DEFAULT_BUILD_FILENAME ) ; } } if ( ! buildFile . exists ( ) ) { System . out . println ( "Buildfile: " + buildFile + " does not exist!" ) ; throw new BuildException ( "Build failed" ) ; } if ( buildFile . isDirectory ( ) ) { System . out . println ( "What? Buildfile: " + buildFile + " is a dir!" ) ; throw new BuildException ( "Build failed" ) ; } readyToRun = true ; } private File getParentFile ( File file ) { String filename = file . getAbsolutePath ( ) ; file = new File ( filename ) ; filename = file . getParent ( ) ; if ( filename != null && msgOutputLevel >= Project . MSG_VERBOSE ) { System . out . println ( "Searching in " + filename ) ; } return ( filename == null ) ? null : new File ( filename ) ; } private File findBuildFile ( String start , String suffix ) throws BuildException { if ( msgOutputLevel >= Project . MSG_INFO ) { System . out . println ( "Searching for " + suffix + " ..." ) ; } File parent = new File ( new File ( start ) . getAbsolutePath ( ) ) ; File file = new File ( parent , suffix ) ; while ( ! file . exists ( ) ) { parent = getParentFile ( parent ) ; if ( parent == null ) { throw new BuildException ( "Could not locate a build file!" ) ; } file = new File ( parent , suffix ) ; } return file ; } private void runBuild ( ClassLoader coreLoader ) throws BuildException { if ( ! readyToRun ) { return ; } if ( msgOutputLevel >= Project . MSG_INFO ) { System . out . println ( "Buildfile: " + buildFile ) ; } final Project project = new Project ( ) ; project . setCoreLoader ( coreLoader ) ; Throwable error = null ; try { addBuildListeners ( project ) ; PrintStream err = System . err ; PrintStream out = System . out ; SecurityManager oldsm = System . getSecurityManager ( ) ; try { System . setOut ( new PrintStream ( new DemuxOutputStream ( project , false ) ) ) ; System . setErr ( new PrintStream ( new DemuxOutputStream ( project , true ) ) ) ; project . fireBuildStarted ( ) ; project . init ( ) ; project . setUserProperty ( "ant.version" , getAntVersion ( ) ) ; Enumeration e = definedProps . keys ( ) ; while ( e . hasMoreElements ( ) ) { String arg = ( String ) e . nextElement ( ) ; String value = ( String ) definedProps . get ( arg ) ; project . setUserProperty ( arg , value ) ; } project . setUserProperty ( "ant.file" , buildFile . getAbsolutePath ( ) ) ; String noParserMessage = "No JAXP compliant XML parser found. Please visit http://xml.apache.org for a suitable parser" ; try { Class . forName ( "javax.xml.parsers.SAXParserFactory" ) ; ProjectHelper . configureProject ( project , buildFile ) ; } catch ( NoClassDefFoundError ncdfe ) { throw new BuildException ( noParserMessage , ncdfe ) ; } catch ( ClassNotFoundException cnfe ) { throw new BuildException ( noParserMessage , cnfe ) ; } catch ( NullPointerException npe ) { throw new BuildException ( noParserMessage , npe ) ; } if ( targets . size ( ) == 0 ) { targets . addElement ( project . getDefaultTarget ( ) ) ; } if ( ! projectHelp ) { project . executeTargets ( targets ) ; } } finally { System . setOut ( out ) ; System . setErr ( err ) ; } if ( projectHelp ) { printDescription ( project ) ; printTargets ( project ) ; } } catch ( RuntimeException exc ) { error = exc ; throw exc ; } catch ( Error err ) { error = err ; throw err ; } finally { project . fireBuildFinished ( error ) ; } } protected void addBuildListeners ( Project project ) { project . addBuildListener ( createLogger ( ) ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { String className = ( String ) listeners . elementAt ( i ) ; try { BuildListener listener = ( BuildListener ) Class . forName ( className ) . newInstance ( ) ; project . addBuildListener ( listener ) ; } catch ( Throwable exc ) { throw new BuildException ( "Unable to instantiate listener " + className , exc ) ; } } } private BuildLogger createLogger ( ) { BuildLogger logger = null ; if ( loggerClassname != null ) { try { logger = ( BuildLogger ) ( Class . forName ( loggerClassname ) . newInstance ( ) ) ; } catch ( ClassCastException e ) { System . err . println ( "The specified logger class " + loggerClassname + " does not implement the BuildLogger interface" ) ; throw new RuntimeException ( ) ; } catch ( Exception e ) { System . err . println ( "Unable to instantiate specified logger class " + loggerClassname + " : " + e . getClass ( ) . getName ( ) ) ; throw new RuntimeException ( ) ; } } else { logger = new DefaultLogger ( ) ; } logger . setMessageOutputLevel ( msgOutputLevel ) ; logger . setOutputPrintStream ( out ) ; logger . setErrorPrintStream ( err ) ; logger . setEmacsMode ( emacsMode ) ; return logger ; } private static void printUsage ( ) { String lSep = System . getProperty ( "line.separator" ) ; StringBuffer msg = new StringBuffer ( ) ; msg . append ( "ant [options] [target [target2 [target3] ...]]" + lSep ) ; msg . append ( "Options: " + lSep ) ; msg . append ( "  -help                  print this message" + lSep ) ; msg . append ( "  -projecthelp           print project help information" + lSep ) ; msg . append ( "  -version               print the version information and exit" + lSep ) ; msg . append ( "  -quiet                 be extra quiet" + lSep ) ; msg . append ( "  -verbose               be extra verbose" + lSep ) ; msg . append ( "  -debug                 print debugging information" + lSep ) ; msg . append ( "  -emacs                 produce logging information without adornments" + lSep ) ; msg . append ( "  -logfile <file>        use given file for log" + lSep ) ; msg . append ( "  -logger <classname>    the class which is to perform logging" + lSep ) ; msg . append ( "  -listener <classname>  add an instance of class as a project listener" + lSep ) ; msg . append ( "  -buildfile <file>      use given buildfile" + lSep ) ; msg . append ( "  -D<property>=<value>   use value for given property" + lSep ) ; msg . append ( "  -find <file>           search for buildfile towards the root of the" + lSep ) ; msg . append ( "                         filesystem and use it" + lSep ) ; System . out . println ( msg . toString ( ) ) ; } private static void printVersion ( ) throws BuildException { System . out . println ( getAntVersion ( ) ) ; } private static String antVersion = null ; public synchronized static String getAntVersion ( ) throws BuildException { if ( antVersion == null ) { try { Properties props = new Properties ( ) ; InputStream in = Main . class . getResourceAsStream ( "/org/apache/tools/ant/version.txt" ) ; props . load ( in ) ; in . close ( ) ; String lSep = System . getProperty ( "line.separator" ) ; StringBuffer msg = new StringBuffer ( ) ; msg . append ( "Ant version " ) ; msg . append ( props . getProperty ( "VERSION" ) ) ; msg . append ( " compiled on " ) ; msg . append ( props . getProperty ( "DATE" ) ) ; antVersion = msg . toString ( ) ; } catch ( IOException ioe ) { throw new BuildException ( "Could not load the version information:" + ioe . getMessage ( ) ) ; } catch ( NullPointerException npe ) { throw new BuildException ( "Could not load the version information." ) ; } } return antVersion ; } private static void printDescription ( Project project ) { if ( project . getDescription ( ) != null ) { System . out . println ( project . getDescription ( ) ) ; } } private static void printTargets ( Project project ) { int maxLength = 0 ; Enumeration ptargets = project . getTargets ( ) . elements ( ) ; String targetName ; String targetDescription ; Target currentTarget ; Vector topNames = new Vector ( ) ; Vector topDescriptions = new Vector ( ) ; Vector subNames = new Vector ( ) ; while ( ptargets . hasMoreElements ( ) ) { currentTarget = ( Target ) ptargets . nextElement ( ) ; targetName = currentTarget . getName ( ) ; targetDescription = currentTarget . getDescription ( ) ; if ( targetDescription == null ) { int pos = findTargetPosition ( subNames , targetName ) ; subNames . insertElementAt ( targetName , pos ) ; } else { int pos = findTargetPosition ( topNames , targetName ) ; topNames . insertElementAt ( targetName , pos ) ; topDescriptions . insertElementAt ( targetDescription , pos ) ; if ( targetName . length ( ) > maxLength ) { maxLength = targetName . length ( ) ; } } } String defaultTarget = project . getDefaultTarget ( ) ; if ( defaultTarget != null && ! "" . equals ( defaultTarget ) ) { Vector defaultName = new Vector ( ) ; Vector defaultDesc = null ; defaultName . addElement ( defaultTarget ) ; int indexOfDefDesc = topNames . indexOf ( defaultTarget ) ; if ( indexOfDefDesc >= 0 ) { defaultDesc = new Vector ( ) ; defaultDesc . addElement ( topDescriptions . elementAt ( indexOfDefDesc ) ) ; } printTargets ( defaultName , defaultDesc , "Default target:" , maxLength ) ; } printTargets ( topNames , topDescriptions , "Main targets:" , maxLength ) ; printTargets ( subNames , null , "Subtargets:" , 0 ) ; } private static int findTargetPosition ( Vector names , String name ) { int res = names . size ( ) ; for ( int i = 0 ; i < names . size ( ) && res == names . size ( ) ; i ++ ) { if ( name . compareTo ( ( String ) names . elementAt ( i ) ) < 0 ) { res = i ; } } return res ; } private static void printTargets ( Vector names , Vector descriptions , String heading , int maxlen ) { String lSep = System . getProperty ( "line.separator" ) ; String spaces = "    " ; while ( spaces . length ( ) < maxlen ) { spaces += spaces ; } StringBuffer msg = new StringBuffer ( ) ; msg . append ( heading + lSep + lSep ) ; for ( int i = 0 ; i < names . size ( ) ; i ++ ) { msg . append ( " " ) ; msg . append ( names . elementAt ( i ) ) ; if ( descriptions != null ) { msg . append ( spaces . substring ( 0 , maxlen - ( ( String ) names . elementAt ( i ) ) . length ( ) + 2 ) ) ; msg . append ( descriptions . elementAt ( i ) ) ; } msg . append ( lSep ) ; } System . out . println ( msg . toString ( ) ) ; } } 	0	['18', '1', '0', '8', '91', '123', '0', '8', '3', '0.806722689', '1400', '0.857142857', '0', '0', '0.141176471', '0', '0', '76', '7', '2.1111', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . File ; public class Mkdir extends Task { private File dir ; public void execute ( ) throws BuildException { if ( dir == null ) { throw new BuildException ( "dir attribute is required" , location ) ; } if ( dir . isFile ( ) ) { throw new BuildException ( "Unable to create directory as a file already exists with that name: " + dir . getAbsolutePath ( ) ) ; } if ( ! dir . exists ( ) ) { boolean result = dir . mkdirs ( ) ; if ( result == false ) { String msg = "Directory " + dir . getAbsolutePath ( ) + " creation was not " + "successful for an unknown reason" ; throw new BuildException ( msg , location ) ; } log ( "Created dir: " + dir . getAbsolutePath ( ) ) ; } } public void setDir ( File dir ) { this . dir = dir ; } } 	0	['3', '3', '0', '3', '14', '1', '0', '3', '3', '0.5', '84', '1', '0', '0.948717949', '0.666666667', '1', '1', '26.66666667', '1', '0.6667', '0']
package org . apache . tools . ant . util ; public interface FileNameMapper { public void setFrom ( String from ) ; public void setTo ( String to ) ; public String [ ] mapFileName ( String sourceFileName ) ; } 	0	['3', '1', '0', '17', '3', '3', '17', '0', '3', '2', '3', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . EnumeratedAttribute ; import java . io . * ; import java . util . * ; public class FixCRLF extends MatchingTask { private static final int UNDEF = - 1 ; private static final int NOTJAVA = 0 ; private static final int LOOKING = 1 ; private static final int IN_CHAR_CONST = 2 ; private static final int IN_STR_CONST = 3 ; private static final int IN_SINGLE_COMMENT = 4 ; private static final int IN_MULTI_COMMENT = 5 ; private static final int ASIS = 0 ; private static final int CR = 1 ; private static final int LF = 2 ; private static final int CRLF = 3 ; private static final int ADD = 1 ; private static final int REMOVE = - 1 ; private static final int SPACES = - 1 ; private static final int TABS = 1 ; private static final int INBUFLEN = 8192 ; private static final int LINEBUFLEN = 200 ; private static final char CTRLZ = '' ; private int tablength = 8 ; private String spaces = "        " ; private StringBuffer linebuf = new StringBuffer ( 1024 ) ; private StringBuffer linebuf2 = new StringBuffer ( 1024 ) ; private int eol ; private String eolstr ; private int ctrlz ; private int tabs ; private boolean javafiles = false ; private File srcDir ; private File destDir = null ; public FixCRLF ( ) { tabs = ASIS ; if ( System . getProperty ( "path.separator" ) . equals ( ":" ) ) { ctrlz = REMOVE ; if ( System . getProperty ( "os.name" ) . indexOf ( "Mac" ) > - 1 ) { eol = CR ; eolstr = "\r" ; } else { eol = LF ; eolstr = "\n" ; } } else { ctrlz = ASIS ; eol = CRLF ; eolstr = "\r\n" ; } } public void setSrcdir ( File srcDir ) { this . srcDir = srcDir ; } public void setDestdir ( File destDir ) { this . destDir = destDir ; } public void setJavafiles ( boolean javafiles ) { this . javafiles = javafiles ; } public void setEol ( CrLf attr ) { String option = attr . getValue ( ) ; if ( option . equals ( "asis" ) ) { eol = ASIS ; } else if ( option . equals ( "cr" ) ) { eol = CR ; eolstr = "\r" ; } else if ( option . equals ( "lf" ) ) { eol = LF ; eolstr = "\n" ; } else { eol = CRLF ; eolstr = "\r\n" ; } } public void setCr ( AddAsisRemove attr ) { log ( "DEPRECATED: The cr attribute has been deprecated," , Project . MSG_WARN ) ; log ( "Please us the eol attribute instead" , Project . MSG_WARN ) ; String option = attr . getValue ( ) ; CrLf c = new CrLf ( ) ; if ( option . equals ( "remove" ) ) { c . setValue ( "lf" ) ; } else if ( option . equals ( "asis" ) ) { c . setValue ( "asis" ) ; } else { c . setValue ( "crlf" ) ; } setEol ( c ) ; } public void setTab ( AddAsisRemove attr ) { String option = attr . getValue ( ) ; if ( option . equals ( "remove" ) ) { tabs = SPACES ; } else if ( option . equals ( "asis" ) ) { tabs = ASIS ; } else { tabs = TABS ; } } public void setTablength ( int tlength ) throws BuildException { if ( tlength < 2 || tlength > 80 ) { throw new BuildException ( "tablength must be between 2 and 80" , location ) ; } tablength = tlength ; StringBuffer sp = new StringBuffer ( ) ; for ( int i = 0 ; i < tablength ; i ++ ) { sp . append ( ' ' ) ; } spaces = sp . toString ( ) ; } public void setEof ( AddAsisRemove attr ) { String option = attr . getValue ( ) ; if ( option . equals ( "remove" ) ) { ctrlz = REMOVE ; } else if ( option . equals ( "asis" ) ) { ctrlz = ASIS ; } else { ctrlz = ADD ; } } public void execute ( ) throws BuildException { if ( srcDir == null ) { throw new BuildException ( "srcdir attribute must be set!" ) ; } if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir does not exist!" ) ; } if ( ! srcDir . isDirectory ( ) ) { throw new BuildException ( "srcdir is not a directory!" ) ; } if ( destDir != null ) { if ( ! destDir . exists ( ) ) { throw new BuildException ( "destdir does not exist!" ) ; } if ( ! destDir . isDirectory ( ) ) { throw new BuildException ( "destdir is not a directory!" ) ; } } log ( "options:" + " eol=" + ( eol == ASIS ? "asis" : eol == CR ? "cr" : eol == LF ? "lf" : "crlf" ) + " tab=" + ( tabs == TABS ? "add" : tabs == ASIS ? "asis" : "remove" ) + " eof=" + ( ctrlz == ADD ? "add" : ctrlz == ASIS ? "asis" : "remove" ) + " tablength=" + tablength , Project . MSG_VERBOSE ) ; DirectoryScanner ds = super . getDirectoryScanner ( srcDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { processFile ( files [ i ] ) ; } } private File createTempFile ( ) { String name = "fixcrlf" + ( new Random ( System . currentTimeMillis ( ) ) ) . nextLong ( ) ; if ( destDir == null ) { return new File ( srcDir , name ) ; } else { return new File ( destDir , name ) ; } } private boolean filesEqual ( File file1 , File file2 ) { BufferedReader reader1 ; BufferedReader reader2 ; char buf1 [ ] = new char [ INBUFLEN ] ; char buf2 [ ] = new char [ INBUFLEN ] ; int buflen ; if ( file1 . length ( ) != file2 . length ( ) ) { return false ; } try { reader1 = new BufferedReader ( new FileReader ( file1 ) , INBUFLEN ) ; reader2 = new BufferedReader ( new FileReader ( file2 ) , INBUFLEN ) ; while ( ( buflen = reader1 . read ( buf1 , 0 , INBUFLEN ) ) != - 1 ) { reader2 . read ( buf2 , 0 , INBUFLEN ) ; for ( int i = 0 ; i < buflen ; i ++ ) { if ( buf1 [ i ] != buf2 [ i ] ) { reader1 . close ( ) ; reader2 . close ( ) ; return false ; } } } reader1 . close ( ) ; reader2 . close ( ) ; return true ; } catch ( IOException e ) { throw new BuildException ( "IOException in filesEqual: " + file1 + " : " + file2 ) ; } } private void processFile ( String file ) throws BuildException { File srcFile = new File ( srcDir , file ) ; File tmpFile = null ; BufferedWriter outWriter ; OneLiner . BufferLine line ; OneLiner lines = new OneLiner ( srcFile ) ; try { try { tmpFile = createTempFile ( ) ; FileWriter writer = new FileWriter ( tmpFile ) ; outWriter = new BufferedWriter ( writer ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } while ( lines . hasMoreElements ( ) ) { int endComment ; try { line = ( OneLiner . BufferLine ) lines . nextElement ( ) ; } catch ( NoSuchElementException e ) { throw new BuildException ( e ) ; } String lineString = line . getLineString ( ) ; int linelen = line . length ( ) ; if ( tabs == ASIS ) { try { outWriter . write ( lineString ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } else { int ptr ; while ( ( ptr = line . getNext ( ) ) < linelen ) { switch ( lines . getState ( ) ) { case NOTJAVA : notInConstant ( line , line . length ( ) , outWriter ) ; break ; case IN_MULTI_COMMENT : if ( ( endComment = lineString . indexOf ( "*/" , line . getNext ( ) ) ) >= 0 ) { endComment += 2 ; lines . setState ( LOOKING ) ; } else { endComment = linelen ; } notInConstant ( line , endComment , outWriter ) ; break ; case IN_SINGLE_COMMENT : notInConstant ( line , line . length ( ) , outWriter ) ; lines . setState ( LOOKING ) ; break ; case IN_CHAR_CONST : case IN_STR_CONST : int begin = line . getNext ( ) ; char terminator = ( lines . getState ( ) == IN_STR_CONST ? '\"' : '\'' ) ; endOfCharConst ( line , terminator ) ; while ( line . getNext ( ) < line . getLookahead ( ) ) { if ( line . getNextCharInc ( ) == '\t' ) { line . setColumn ( line . getColumn ( ) + tablength - line . getColumn ( ) % tablength ) ; } else { line . incColumn ( ) ; } } try { outWriter . write ( line . substring ( begin , line . getNext ( ) ) ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } lines . setState ( LOOKING ) ; break ; case LOOKING : nextStateChange ( line ) ; notInConstant ( line , line . getLookahead ( ) , outWriter ) ; break ; } } } try { outWriter . write ( eolstr ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } try { if ( ctrlz == ASIS ) { outWriter . write ( lines . getEofStr ( ) ) ; } else if ( ctrlz == ADD ) { outWriter . write ( CTRLZ ) ; } outWriter . close ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } File destFile = new File ( destDir == null ? srcDir : destDir , file ) ; try { lines . close ( ) ; lines = null ; } catch ( IOException e ) { throw new BuildException ( "Unable to close source file " + srcFile ) ; } if ( destFile . exists ( ) ) { log ( "destFile exists" , Project . MSG_DEBUG ) ; if ( ! filesEqual ( destFile , tmpFile ) ) { log ( destFile + " is being written" , Project . MSG_DEBUG ) ; if ( ! destFile . delete ( ) ) { throw new BuildException ( "Unable to delete " + destFile ) ; } if ( ! tmpFile . renameTo ( destFile ) ) { throw new BuildException ( "Failed to transform " + srcFile + " to " + destFile + ". Couldn't rename temporary file: " + tmpFile ) ; } } else { log ( destFile + " is not written, as the contents are identical" , Project . MSG_DEBUG ) ; if ( ! tmpFile . delete ( ) ) { throw new BuildException ( "Unable to delete " + tmpFile ) ; } } } else { log ( "destFile does not exist" , Project . MSG_DEBUG ) ; if ( ! tmpFile . renameTo ( destFile ) ) { throw new BuildException ( "Failed to transform " + srcFile + " to " + destFile + ". Couldn't rename temporary file: " + tmpFile ) ; } } tmpFile = null ; } finally { try { if ( lines != null ) { lines . close ( ) ; } } catch ( IOException io ) { log ( "Error closing " + srcFile , Project . MSG_ERR ) ; } if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } private void nextStateChange ( OneLiner . BufferLine bufline ) throws BuildException { int eol = bufline . length ( ) ; int ptr = bufline . getNext ( ) ; while ( ptr < eol ) { switch ( bufline . getChar ( ptr ++ ) ) { case '\'' : bufline . setState ( IN_CHAR_CONST ) ; bufline . setLookahead ( -- ptr ) ; return ; case '\"' : bufline . setState ( IN_STR_CONST ) ; bufline . setLookahead ( -- ptr ) ; return ; case '/' : if ( ptr < eol ) { if ( bufline . getChar ( ptr ) == '*' ) { bufline . setState ( IN_MULTI_COMMENT ) ; bufline . setLookahead ( -- ptr ) ; return ; } else if ( bufline . getChar ( ptr ) == '/' ) { bufline . setState ( IN_SINGLE_COMMENT ) ; bufline . setLookahead ( -- ptr ) ; return ; } } break ; } } bufline . setLookahead ( ptr ) ; } private void endOfCharConst ( OneLiner . BufferLine bufline , char terminator ) throws BuildException { int ptr = bufline . getNext ( ) ; int eol = bufline . length ( ) ; char c ; ptr ++ ; while ( ptr < eol ) { if ( ( c = bufline . getChar ( ptr ++ ) ) == '\\' ) { ptr ++ ; } else { if ( c == terminator ) { bufline . setLookahead ( ptr ) ; return ; } } } throw new BuildException ( "endOfCharConst: unterminated char constant" ) ; } private void notInConstant ( OneLiner . BufferLine bufline , int end , BufferedWriter outWriter ) { int nextTab ; int nextStop ; int tabspaces ; String line = bufline . substring ( bufline . getNext ( ) , end ) ; int place = 0 ; int col = bufline . getColumn ( ) ; linebuf . setLength ( 0 ) ; while ( ( nextTab = line . indexOf ( ( int ) '\t' , place ) ) >= 0 ) { linebuf . append ( line . substring ( place , nextTab ) ) ; col += nextTab - place ; tabspaces = tablength - ( col % tablength ) ; linebuf . append ( spaces . substring ( 0 , tabspaces ) ) ; col += tabspaces ; place = nextTab + 1 ; } linebuf . append ( line . substring ( place , line . length ( ) ) ) ; String linestring = new String ( linebuf . toString ( ) ) ; if ( tabs == REMOVE ) { try { outWriter . write ( linestring ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } else { int tabCol ; linebuf2 . setLength ( 0 ) ; place = 0 ; col = bufline . getColumn ( ) ; int placediff = col - 0 ; nextStop = col + ( tablength - col % tablength ) ; if ( nextStop - col < 2 ) { linebuf2 . append ( linestring . substring ( place , nextStop - placediff ) ) ; place = nextStop - placediff ; nextStop += tablength ; } for ( ; nextStop - placediff <= linestring . length ( ) ; nextStop += tablength ) { for ( tabCol = nextStop ; -- tabCol - placediff >= place && linestring . charAt ( tabCol - placediff ) == ' ' ; ) { ; } if ( nextStop - tabCol > 2 ) { linebuf2 . append ( linestring . substring ( place , ++ tabCol - placediff ) ) ; linebuf2 . append ( '\t' ) ; } else { linebuf2 . append ( linestring . substring ( place , nextStop - placediff ) ) ; } place = nextStop - placediff ; } linebuf2 . append ( linestring . substring ( place , linestring . length ( ) ) ) ; try { outWriter . write ( linebuf2 . toString ( ) ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } bufline . setColumn ( bufline . getColumn ( ) + linestring . length ( ) ) ; bufline . setNext ( end ) ; } class OneLiner implements Enumeration { private int state = javafiles ? LOOKING : NOTJAVA ; private StringBuffer eolStr = new StringBuffer ( LINEBUFLEN ) ; private StringBuffer eofStr = new StringBuffer ( ) ; private BufferedReader reader ; private String line ; public OneLiner ( File srcFile ) throws BuildException { try { reader = new BufferedReader ( new FileReader ( srcFile ) , INBUFLEN ) ; nextLine ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } protected void nextLine ( ) throws BuildException { int ch ; int eolcount = 0 ; eolStr . setLength ( 0 ) ; try { int linelen ; reader . mark ( INBUFLEN ) ; line = reader . readLine ( ) ; if ( line == null ) { linelen = 0 ; } else { linelen = line . length ( ) ; } reader . reset ( ) ; reader . skip ( ( long ) linelen ) ; reader . mark ( INBUFLEN ) ; ch = reader . read ( ) ; switch ( ( char ) ch ) { case '\r' : ++ eolcount ; eolStr . append ( '\r' ) ; switch ( ( char ) ( ch = reader . read ( ) ) ) { case '\r' : if ( ( char ) ( ch = reader . read ( ) ) == '\n' ) { eolcount += 2 ; eolStr . append ( "\r\n" ) ; } break ; case '\n' : ++ eolcount ; eolStr . append ( '\n' ) ; break ; } break ; case '\n' : ++ eolcount ; eolStr . append ( '\n' ) ; break ; } reader . reset ( ) ; reader . skip ( ( long ) eolcount ) ; if ( line != null && eolcount == 0 ) { int i = linelen ; while ( -- i >= 0 && line . charAt ( i ) == CTRLZ ) { } if ( i < linelen - 1 ) { eofStr . append ( line . substring ( i + 1 ) ) ; line = i < 0 ? null : line . substring ( 0 , i + 1 ) ; } } } catch ( IOException e ) { throw new BuildException ( e ) ; } } public String getEofStr ( ) { return eofStr . toString ( ) ; } public int getState ( ) { return state ; } public void setState ( int state ) { this . state = state ; } public boolean hasMoreElements ( ) { return line != null ; } public Object nextElement ( ) throws NoSuchElementException { if ( ! hasMoreElements ( ) ) { throw new NoSuchElementException ( "OneLiner" ) ; } BufferLine tmpLine = new BufferLine ( line , eolStr . toString ( ) ) ; nextLine ( ) ; return tmpLine ; } public void close ( ) throws IOException { if ( reader != null ) { reader . close ( ) ; } } class BufferLine { private int next = 0 ; private int column = 0 ; private int lookahead = UNDEF ; private String line ; private String eolStr ; public BufferLine ( String line , String eolStr ) throws BuildException { next = 0 ; column = 0 ; this . line = line ; this . eolStr = eolStr ; } public int getNext ( ) { return next ; } public void setNext ( int next ) { this . next = next ; } public int getLookahead ( ) { return lookahead ; } public void setLookahead ( int lookahead ) { this . lookahead = lookahead ; } public char getChar ( int i ) { return line . charAt ( i ) ; } public char getNextChar ( ) { return getChar ( next ) ; } public char getNextCharInc ( ) { return getChar ( next ++ ) ; } public int getColumn ( ) { return column ; } public void setColumn ( int col ) { column = col ; } public int incColumn ( ) { return column ++ ; } public int length ( ) { return line . length ( ) ; } public int getEolLength ( ) { return eolStr . length ( ) ; } public String getLineString ( ) { return line ; } public String getEol ( ) { return eolStr ; } public String substring ( int begin ) { return line . substring ( begin ) ; } public String substring ( int begin , int end ) { return line . substring ( begin , end ) ; } public void setState ( int state ) { OneLiner . this . setState ( state ) ; } public int getState ( ) { return OneLiner . this . getState ( ) ; } } } public static class AddAsisRemove extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "add" , "asis" , "remove" } ; } } public static class CrLf extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "asis" , "cr" , "lf" , "crlf" } ; } } } 	0	['17', '4', '0', '10', '83', '70', '1', '10', '10', '0.965517241', '1273', '1', '0', '0.829787234', '0.176470588', '2', '2', '72.17647059', '8', '2.1765', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import java . util . * ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . * ; public class Javadoc extends Task { public class DocletParam { private String name ; private String value ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } } public class DocletInfo { private String name ; private Path path ; private Vector params = new Vector ( ) ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setPath ( Path path ) { if ( this . path == null ) { this . path = path ; } else { this . path . append ( path ) ; } } public Path getPath ( ) { return path ; } public Path createPath ( ) { if ( path == null ) { path = new Path ( getProject ( ) ) ; } return path . createPath ( ) ; } public void setPathRef ( Reference r ) { createPath ( ) . setRefid ( r ) ; } public DocletParam createParam ( ) { DocletParam param = new DocletParam ( ) ; params . addElement ( param ) ; return param ; } public Enumeration getParams ( ) { return params . elements ( ) ; } } public static class PackageName { private String name ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public String toString ( ) { return getName ( ) ; } } public static class SourceFile { private File file ; public void setFile ( File file ) { this . file = file ; } public File getFile ( ) { return file ; } } public static class Html { private StringBuffer text = new StringBuffer ( ) ; public void addText ( String t ) { text . append ( t ) ; } public String getText ( ) { return text . toString ( ) ; } } public static class AccessType extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "protected" , "public" , "package" , "private" } ; } } private Commandline cmd = new Commandline ( ) ; private static boolean javadoc1 = ( Project . getJavaVersion ( ) == Project . JAVA_1_1 ) ; private void addArgIf ( boolean b , String arg ) { if ( b ) { cmd . createArgument ( ) . setValue ( arg ) ; } } private void add12ArgIfNotEmpty ( String key , String value ) { if ( ! javadoc1 ) { if ( value != null && value . length ( ) != 0 ) { cmd . createArgument ( ) . setValue ( key ) ; cmd . createArgument ( ) . setValue ( value ) ; } else { project . log ( this , "Warning: Leaving out empty argument '" + key + "'" , Project . MSG_WARN ) ; } } } private void add11ArgIf ( boolean b , String arg ) { if ( javadoc1 && b ) { cmd . createArgument ( ) . setValue ( arg ) ; } } private void add12ArgIf ( boolean b , String arg ) { if ( ! javadoc1 && b ) { cmd . createArgument ( ) . setValue ( arg ) ; } } private boolean foundJavaFile = false ; private boolean failOnError = false ; private Path sourcePath = null ; private File destDir = null ; private Vector sourceFiles = new Vector ( ) ; private Vector packageNames = new Vector ( 5 ) ; private Vector excludePackageNames = new Vector ( 1 ) ; private boolean author = true ; private boolean version = true ; private DocletInfo doclet = null ; private Path classpath = null ; private Path bootclasspath = null ; private String group = null ; private Vector compileList = new Vector ( 10 ) ; private String packageList = null ; private Vector links = new Vector ( 2 ) ; private Vector groups = new Vector ( 2 ) ; private boolean useDefaultExcludes = true ; private Html doctitle = null ; private Html header = null ; private Html footer = null ; private Html bottom = null ; private boolean useExternalFile = false ; private File tmpList = null ; public void setUseExternalFile ( boolean b ) { if ( ! javadoc1 ) { useExternalFile = b ; } } public void setDefaultexcludes ( boolean useDefaultExcludes ) { this . useDefaultExcludes = useDefaultExcludes ; } public void setMaxmemory ( String max ) { if ( javadoc1 ) { cmd . createArgument ( ) . setValue ( "-J-mx" + max ) ; } else { cmd . createArgument ( ) . setValue ( "-J-Xmx" + max ) ; } } public void setAdditionalparam ( String add ) { cmd . createArgument ( ) . setLine ( add ) ; } public void setSourcepath ( Path src ) { if ( sourcePath == null ) { sourcePath = src ; } else { sourcePath . append ( src ) ; } } public Path createSourcepath ( ) { if ( sourcePath == null ) { sourcePath = new Path ( project ) ; } return sourcePath . createPath ( ) ; } public void setSourcepathRef ( Reference r ) { createSourcepath ( ) . setRefid ( r ) ; } public void setDestdir ( File dir ) { destDir = dir ; cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } public void setSourcefiles ( String src ) { StringTokenizer tok = new StringTokenizer ( src , "," ) ; while ( tok . hasMoreTokens ( ) ) { String f = tok . nextToken ( ) ; SourceFile sf = new SourceFile ( ) ; sf . setFile ( project . resolveFile ( f ) ) ; addSource ( sf ) ; } } public void addSource ( SourceFile sf ) { sourceFiles . addElement ( sf ) ; } public void setPackagenames ( String src ) { StringTokenizer tok = new StringTokenizer ( src , "," ) ; while ( tok . hasMoreTokens ( ) ) { String p = tok . nextToken ( ) ; PackageName pn = new PackageName ( ) ; pn . setName ( p ) ; addPackage ( pn ) ; } } public void addPackage ( PackageName pn ) { packageNames . addElement ( pn ) ; } public void setExcludePackageNames ( String src ) { StringTokenizer tok = new StringTokenizer ( src , "," ) ; while ( tok . hasMoreTokens ( ) ) { String p = tok . nextToken ( ) ; PackageName pn = new PackageName ( ) ; pn . setName ( p ) ; addExcludePackage ( pn ) ; } } public void addExcludePackage ( PackageName pn ) { excludePackageNames . addElement ( pn ) ; } public void setOverview ( File f ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-overview" ) ; cmd . createArgument ( ) . setFile ( f ) ; } } public void setPublic ( boolean b ) { addArgIf ( b , "-public" ) ; } public void setProtected ( boolean b ) { addArgIf ( b , "-protected" ) ; } public void setPackage ( boolean b ) { addArgIf ( b , "-package" ) ; } public void setPrivate ( boolean b ) { addArgIf ( b , "-private" ) ; } public void setAccess ( AccessType at ) { cmd . createArgument ( ) . setValue ( "-" + at . getValue ( ) ) ; } public void setDoclet ( String src ) { if ( doclet == null ) { doclet = new DocletInfo ( ) ; } doclet . setName ( src ) ; } public void setDocletPath ( Path src ) { if ( doclet == null ) { doclet = new DocletInfo ( ) ; } doclet . setPath ( src ) ; } public void setDocletPathRef ( Reference r ) { if ( doclet == null ) { doclet = new DocletInfo ( ) ; } doclet . createPath ( ) . setRefid ( r ) ; } public DocletInfo createDoclet ( ) { doclet = new DocletInfo ( ) ; return doclet ; } public void setOld ( boolean b ) { add12ArgIf ( b , "-1.1" ) ; } public void setClasspath ( Path src ) { if ( classpath == null ) { classpath = src ; } else { classpath . append ( src ) ; } } public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( project ) ; } return classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setBootclasspath ( Path src ) { if ( bootclasspath == null ) { bootclasspath = src ; } else { bootclasspath . append ( src ) ; } } public Path createBootclasspath ( ) { if ( bootclasspath == null ) { bootclasspath = new Path ( project ) ; } return bootclasspath . createPath ( ) ; } public void setBootClasspathRef ( Reference r ) { createBootclasspath ( ) . setRefid ( r ) ; } public void setExtdirs ( String src ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-extdirs" ) ; cmd . createArgument ( ) . setValue ( src ) ; } } public void setVerbose ( boolean b ) { add12ArgIf ( b , "-verbose" ) ; } public void setLocale ( String src ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-locale" ) ; cmd . createArgument ( ) . setValue ( src ) ; } } public void setEncoding ( String enc ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( enc ) ; } public void setVersion ( boolean src ) { version = src ; } public void setUse ( boolean b ) { add12ArgIf ( b , "-use" ) ; } public void setAuthor ( boolean src ) { author = src ; } public void setSplitindex ( boolean b ) { add12ArgIf ( b , "-splitindex" ) ; } public void setWindowtitle ( String src ) { add12ArgIfNotEmpty ( "-windowtitle" , src ) ; } public void setDoctitle ( String src ) { Html h = new Html ( ) ; h . addText ( src ) ; addDoctitle ( h ) ; } public void addDoctitle ( Html text ) { if ( ! javadoc1 ) { doctitle = text ; } } public void setHeader ( String src ) { Html h = new Html ( ) ; h . addText ( src ) ; addHeader ( h ) ; } public void addHeader ( Html text ) { if ( ! javadoc1 ) { header = text ; } } public void setFooter ( String src ) { Html h = new Html ( ) ; h . addText ( src ) ; addFooter ( h ) ; } public void addFooter ( Html text ) { if ( ! javadoc1 ) { footer = text ; } } public void setBottom ( String src ) { Html h = new Html ( ) ; h . addText ( src ) ; addBottom ( h ) ; } public void addBottom ( Html text ) { if ( ! javadoc1 ) { bottom = text ; } } public void setLinkoffline ( String src ) { if ( ! javadoc1 ) { LinkArgument le = createLink ( ) ; le . setOffline ( true ) ; String linkOfflineError = "The linkoffline attribute must include a URL and " + "a package-list file location separated by a space" ; if ( src . trim ( ) . length ( ) == 0 ) { throw new BuildException ( linkOfflineError ) ; } StringTokenizer tok = new StringTokenizer ( src , " " , false ) ; le . setHref ( tok . nextToken ( ) ) ; if ( ! tok . hasMoreTokens ( ) ) { throw new BuildException ( linkOfflineError ) ; } le . setPackagelistLoc ( project . resolveFile ( tok . nextToken ( ) ) ) ; } } public void setGroup ( String src ) { group = src ; } public void setLink ( String src ) { if ( ! javadoc1 ) { createLink ( ) . setHref ( src ) ; } } public void setNodeprecated ( boolean b ) { addArgIf ( b , "-nodeprecated" ) ; } public void setNodeprecatedlist ( boolean b ) { add12ArgIf ( b , "-nodeprecatedlist" ) ; } public void setNotree ( boolean b ) { addArgIf ( b , "-notree" ) ; } public void setNoindex ( boolean b ) { addArgIf ( b , "-noindex" ) ; } public void setNohelp ( boolean b ) { add12ArgIf ( b , "-nohelp" ) ; } public void setNonavbar ( boolean b ) { add12ArgIf ( b , "-nonavbar" ) ; } public void setSerialwarn ( boolean b ) { add12ArgIf ( b , "-serialwarn" ) ; } public void setStylesheetfile ( File f ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-stylesheetfile" ) ; cmd . createArgument ( ) . setFile ( f ) ; } } public void setHelpfile ( File f ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-helpfile" ) ; cmd . createArgument ( ) . setFile ( f ) ; } } public void setDocencoding ( String enc ) { cmd . createArgument ( ) . setValue ( "-docencoding" ) ; cmd . createArgument ( ) . setValue ( enc ) ; } public void setPackageList ( String src ) { packageList = src ; } public LinkArgument createLink ( ) { LinkArgument la = new LinkArgument ( ) ; links . addElement ( la ) ; return la ; } public class LinkArgument { private String href ; private boolean offline = false ; private File packagelistLoc ; public LinkArgument ( ) { } public void setHref ( String hr ) { href = hr ; } public String getHref ( ) { return href ; } public void setPackagelistLoc ( File src ) { packagelistLoc = src ; } public File getPackagelistLoc ( ) { return packagelistLoc ; } public void setOffline ( boolean offline ) { this . offline = offline ; } public boolean isLinkOffline ( ) { return offline ; } } public GroupArgument createGroup ( ) { GroupArgument ga = new GroupArgument ( ) ; groups . addElement ( ga ) ; return ga ; } public class GroupArgument { private Html title ; private Vector packages = new Vector ( 3 ) ; public GroupArgument ( ) { } public void setTitle ( String src ) { Html h = new Html ( ) ; h . addText ( src ) ; addTitle ( h ) ; } public void addTitle ( Html text ) { title = text ; } public String getTitle ( ) { return title != null ? title . getText ( ) : null ; } public void setPackages ( String src ) { StringTokenizer tok = new StringTokenizer ( src , "," ) ; while ( tok . hasMoreTokens ( ) ) { String p = tok . nextToken ( ) ; PackageName pn = new PackageName ( ) ; pn . setName ( p ) ; addPackage ( pn ) ; } } public void addPackage ( PackageName pn ) { packages . addElement ( pn ) ; } public String getPackages ( ) { StringBuffer p = new StringBuffer ( ) ; for ( int i = 0 ; i < packages . size ( ) ; i ++ ) { if ( i > 0 ) { p . append ( ":" ) ; } p . append ( packages . elementAt ( i ) . toString ( ) ) ; } return p . toString ( ) ; } } public void setCharset ( String src ) { this . add12ArgIfNotEmpty ( "-charset" , src ) ; } public void setFailonerror ( boolean b ) { failOnError = b ; } public void execute ( ) throws BuildException { if ( "javadoc2" . equals ( taskType ) ) { log ( "!! javadoc2 is deprecated. Use javadoc instead. !!" ) ; } if ( sourcePath == null ) { String msg = "sourcePath attribute must be set!" ; throw new BuildException ( msg ) ; } log ( "Generating Javadoc" , Project . MSG_INFO ) ; if ( doctitle != null ) { cmd . createArgument ( ) . setValue ( "-doctitle" ) ; cmd . createArgument ( ) . setValue ( expand ( doctitle . getText ( ) ) ) ; } if ( header != null ) { cmd . createArgument ( ) . setValue ( "-header" ) ; cmd . createArgument ( ) . setValue ( expand ( header . getText ( ) ) ) ; } if ( footer != null ) { cmd . createArgument ( ) . setValue ( "-footer" ) ; cmd . createArgument ( ) . setValue ( expand ( footer . getText ( ) ) ) ; } if ( bottom != null ) { cmd . createArgument ( ) . setValue ( "-bottom" ) ; cmd . createArgument ( ) . setValue ( expand ( bottom . getText ( ) ) ) ; } Commandline toExecute = ( Commandline ) cmd . clone ( ) ; toExecute . setExecutable ( getJavadocExecutableName ( ) ) ; if ( classpath == null ) classpath = Path . systemClasspath ; else classpath = classpath . concatSystemClasspath ( "ignore" ) ; if ( ! javadoc1 ) { toExecute . createArgument ( ) . setValue ( "-classpath" ) ; toExecute . createArgument ( ) . setPath ( classpath ) ; toExecute . createArgument ( ) . setValue ( "-sourcepath" ) ; toExecute . createArgument ( ) . setPath ( sourcePath ) ; } else { toExecute . createArgument ( ) . setValue ( "-classpath" ) ; toExecute . createArgument ( ) . setValue ( sourcePath . toString ( ) + System . getProperty ( "path.separator" ) + classpath . toString ( ) ) ; } if ( version && doclet == null ) toExecute . createArgument ( ) . setValue ( "-version" ) ; if ( author && doclet == null ) toExecute . createArgument ( ) . setValue ( "-author" ) ; if ( javadoc1 || doclet == null ) { if ( destDir == null ) { String msg = "destDir attribute must be set!" ; throw new BuildException ( msg ) ; } } if ( ! javadoc1 ) { if ( doclet != null ) { if ( doclet . getName ( ) == null ) { throw new BuildException ( "The doclet name must be specified." , location ) ; } else { toExecute . createArgument ( ) . setValue ( "-doclet" ) ; toExecute . createArgument ( ) . setValue ( doclet . getName ( ) ) ; if ( doclet . getPath ( ) != null ) { toExecute . createArgument ( ) . setValue ( "-docletpath" ) ; toExecute . createArgument ( ) . setPath ( doclet . getPath ( ) ) ; } for ( Enumeration e = doclet . getParams ( ) ; e . hasMoreElements ( ) ; ) { DocletParam param = ( DocletParam ) e . nextElement ( ) ; if ( param . getName ( ) == null ) { throw new BuildException ( "Doclet parameters must have a name" ) ; } toExecute . createArgument ( ) . setValue ( param . getName ( ) ) ; if ( param . getValue ( ) != null ) { toExecute . createArgument ( ) . setValue ( param . getValue ( ) ) ; } } } } if ( bootclasspath != null ) { toExecute . createArgument ( ) . setValue ( "-bootclasspath" ) ; toExecute . createArgument ( ) . setPath ( bootclasspath ) ; } if ( links . size ( ) != 0 ) { for ( Enumeration e = links . elements ( ) ; e . hasMoreElements ( ) ; ) { LinkArgument la = ( LinkArgument ) e . nextElement ( ) ; if ( la . getHref ( ) == null ) { throw new BuildException ( "Links must provide the URL to the external class documentation." ) ; } if ( la . isLinkOffline ( ) ) { File packageListLocation = la . getPackagelistLoc ( ) ; if ( packageListLocation == null ) { throw new BuildException ( "The package list location for link " + la . getHref ( ) + " must be provided because the link is offline" ) ; } File packageList = new File ( packageListLocation , "package-list" ) ; if ( packageList . exists ( ) ) { toExecute . createArgument ( ) . setValue ( "-linkoffline" ) ; toExecute . createArgument ( ) . setValue ( la . getHref ( ) ) ; toExecute . createArgument ( ) . setValue ( packageListLocation . getAbsolutePath ( ) ) ; } else { log ( "Warning: No package list was found at " + packageListLocation , Project . MSG_VERBOSE ) ; } } else { toExecute . createArgument ( ) . setValue ( "-link" ) ; toExecute . createArgument ( ) . setValue ( la . getHref ( ) ) ; } } } if ( group != null ) { StringTokenizer tok = new StringTokenizer ( group , "," , false ) ; while ( tok . hasMoreTokens ( ) ) { String grp = tok . nextToken ( ) . trim ( ) ; int space = grp . indexOf ( " " ) ; if ( space > 0 ) { String name = grp . substring ( 0 , space ) ; String pkgList = grp . substring ( space + 1 ) ; toExecute . createArgument ( ) . setValue ( "-group" ) ; toExecute . createArgument ( ) . setValue ( name ) ; toExecute . createArgument ( ) . setValue ( pkgList ) ; } } } if ( groups . size ( ) != 0 ) { for ( Enumeration e = groups . elements ( ) ; e . hasMoreElements ( ) ; ) { GroupArgument ga = ( GroupArgument ) e . nextElement ( ) ; String title = ga . getTitle ( ) ; String packages = ga . getPackages ( ) ; if ( title == null || packages == null ) { throw new BuildException ( "The title and packages must be specified for group elements." ) ; } toExecute . createArgument ( ) . setValue ( "-group" ) ; toExecute . createArgument ( ) . setValue ( expand ( title ) ) ; toExecute . createArgument ( ) . setValue ( packages ) ; } } } tmpList = null ; if ( packageNames . size ( ) > 0 ) { Vector packages = new Vector ( ) ; Enumeration enum = packageNames . elements ( ) ; while ( enum . hasMoreElements ( ) ) { PackageName pn = ( PackageName ) enum . nextElement ( ) ; String name = pn . getName ( ) . trim ( ) ; if ( name . endsWith ( ".*" ) ) { packages . addElement ( name ) ; } else { toExecute . createArgument ( ) . setValue ( name ) ; } } Vector excludePackages = new Vector ( ) ; if ( excludePackageNames . size ( ) > 0 ) { enum = excludePackageNames . elements ( ) ; while ( enum . hasMoreElements ( ) ) { PackageName pn = ( PackageName ) enum . nextElement ( ) ; excludePackages . addElement ( pn . getName ( ) . trim ( ) ) ; } } if ( packages . size ( ) > 0 ) { evaluatePackages ( toExecute , sourcePath , packages , excludePackages ) ; } } if ( sourceFiles . size ( ) > 0 ) { PrintWriter srcListWriter = null ; try { if ( useExternalFile ) { if ( tmpList == null ) { tmpList = createTempFile ( ) ; toExecute . createArgument ( ) . setValue ( "@" + tmpList . getAbsolutePath ( ) ) ; } srcListWriter = new PrintWriter ( new FileWriter ( tmpList . getAbsolutePath ( ) , true ) ) ; } Enumeration enum = sourceFiles . elements ( ) ; while ( enum . hasMoreElements ( ) ) { SourceFile sf = ( SourceFile ) enum . nextElement ( ) ; String sourceFileName = sf . getFile ( ) . getAbsolutePath ( ) ; if ( useExternalFile ) { srcListWriter . println ( sourceFileName ) ; } else { toExecute . createArgument ( ) . setValue ( sourceFileName ) ; } } } catch ( IOException e ) { throw new BuildException ( "Error creating temporary file" , e , location ) ; } finally { if ( srcListWriter != null ) { srcListWriter . close ( ) ; } } } if ( packageList != null ) { toExecute . createArgument ( ) . setValue ( "@" + packageList ) ; } log ( "Javadoc args: " + toExecute , Project . MSG_VERBOSE ) ; log ( "Javadoc execution" , Project . MSG_INFO ) ; JavadocOutputStream out = new JavadocOutputStream ( Project . MSG_INFO ) ; JavadocOutputStream err = new JavadocOutputStream ( Project . MSG_WARN ) ; Execute exe = new Execute ( new PumpStreamHandler ( out , err ) ) ; exe . setAntRun ( project ) ; exe . setWorkingDirectory ( null ) ; try { exe . setCommandline ( toExecute . getCommandline ( ) ) ; int ret = exe . execute ( ) ; if ( ret != 0 && failOnError ) { throw new BuildException ( "Javadoc returned " + ret , location ) ; } } catch ( IOException e ) { throw new BuildException ( "Javadoc failed: " + e , e , location ) ; } finally { if ( tmpList != null ) { tmpList . delete ( ) ; tmpList = null ; } out . logFlush ( ) ; err . logFlush ( ) ; try { out . close ( ) ; err . close ( ) ; } catch ( IOException e ) { } } } private void evaluatePackages ( Commandline toExecute , Path sourcePath , Vector packages , Vector excludePackages ) { log ( "Source path = " + sourcePath . toString ( ) , Project . MSG_VERBOSE ) ; StringBuffer msg = new StringBuffer ( "Packages = " ) ; for ( int i = 0 ; i < packages . size ( ) ; i ++ ) { if ( i > 0 ) { msg . append ( "," ) ; } msg . append ( packages . elementAt ( i ) ) ; } log ( msg . toString ( ) , Project . MSG_VERBOSE ) ; msg . setLength ( 0 ) ; msg . append ( "Exclude Packages = " ) ; for ( int i = 0 ; i < excludePackages . size ( ) ; i ++ ) { if ( i > 0 ) { msg . append ( "," ) ; } msg . append ( excludePackages . elementAt ( i ) ) ; } log ( msg . toString ( ) , Project . MSG_VERBOSE ) ; Vector addedPackages = new Vector ( ) ; String [ ] list = sourcePath . list ( ) ; if ( list == null ) list = new String [ 0 ] ; FileSet fs = new FileSet ( ) ; fs . setDefaultexcludes ( useDefaultExcludes ) ; Enumeration e = packages . elements ( ) ; while ( e . hasMoreElements ( ) ) { String pkg = ( String ) e . nextElement ( ) ; pkg = pkg . replace ( '.' , '/' ) ; if ( pkg . endsWith ( "*" ) ) { pkg += "*" ; } fs . createInclude ( ) . setName ( pkg ) ; } e = excludePackages . elements ( ) ; while ( e . hasMoreElements ( ) ) { String pkg = ( String ) e . nextElement ( ) ; pkg = pkg . replace ( '.' , '/' ) ; if ( pkg . endsWith ( "*" ) ) { pkg += "*" ; } fs . createExclude ( ) . setName ( pkg ) ; } PrintWriter packageListWriter = null ; try { if ( useExternalFile ) { tmpList = createTempFile ( ) ; toExecute . createArgument ( ) . setValue ( "@" + tmpList . getAbsolutePath ( ) ) ; packageListWriter = new PrintWriter ( new FileWriter ( tmpList ) ) ; } for ( int j = 0 ; j < list . length ; j ++ ) { File source = project . resolveFile ( list [ j ] ) ; fs . setDir ( source ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; String [ ] packageDirs = ds . getIncludedDirectories ( ) ; for ( int i = 0 ; i < packageDirs . length ; i ++ ) { File pd = new File ( source , packageDirs [ i ] ) ; String [ ] files = pd . list ( new FilenameFilter ( ) { public boolean accept ( File dir1 , String name ) { if ( name . endsWith ( ".java" ) ) { return true ; } return false ; } } ) ; if ( files . length > 0 ) { String pkgDir = packageDirs [ i ] . replace ( '/' , '.' ) . replace ( '\\' , '.' ) ; if ( ! addedPackages . contains ( pkgDir ) ) { if ( useExternalFile ) { packageListWriter . println ( pkgDir ) ; } else { toExecute . createArgument ( ) . setValue ( pkgDir ) ; } addedPackages . addElement ( pkgDir ) ; } } } } } catch ( IOException ioex ) { throw new BuildException ( "Error creating temporary file" , ioex , location ) ; } finally { if ( packageListWriter != null ) { packageListWriter . close ( ) ; } } } private class JavadocOutputStream extends LogOutputStream { JavadocOutputStream ( int level ) { super ( Javadoc . this , level ) ; } private String queuedLine = null ; protected void processLine ( String line , int messageLevel ) { if ( messageLevel == Project . MSG_INFO && line . startsWith ( "Generating " ) ) { if ( queuedLine != null ) { super . processLine ( queuedLine , Project . MSG_VERBOSE ) ; } queuedLine = line ; } else { if ( queuedLine != null ) { if ( line . startsWith ( "Building " ) ) super . processLine ( queuedLine , Project . MSG_VERBOSE ) ; else super . processLine ( queuedLine , Project . MSG_INFO ) ; queuedLine = null ; } super . processLine ( line , messageLevel ) ; } } protected void logFlush ( ) { if ( queuedLine != null ) { super . processLine ( queuedLine , Project . MSG_VERBOSE ) ; queuedLine = null ; } } } protected String expand ( String content ) { return ProjectHelper . replaceProperties ( project , content , project . getProperties ( ) ) ; } private File createTempFile ( ) { return new File ( "javadoc" + ( new Random ( System . currentTimeMillis ( ) ) ) . nextLong ( ) ) ; } private String getJavadocExecutableName ( ) { String os = System . getProperty ( "os.name" ) . toLowerCase ( ) ; boolean dosBased = os . indexOf ( "windows" ) >= 0 || os . indexOf ( "os/2" ) >= 0 ; String extension = dosBased ? ".exe" : "" ; File jdocExecutable = new File ( System . getProperty ( "java.home" ) + "/../bin/javadoc" + extension ) ; if ( jdocExecutable . exists ( ) ) { return jdocExecutable . getAbsolutePath ( ) ; } else { log ( "Unable to locate " + jdocExecutable . getAbsolutePath ( ) + ". Using \"javadoc\" instead." , Project . MSG_VERBOSE ) ; return "javadoc" ; } } } 	0	['77', '3', '0', '28', '196', '2320', '6', '28', '68', '0.935222672', '2040', '1', '9', '0.330357143', '0.161184211', '3', '3', '25.15584416', '19', '1.7143', '0']
package org . apache . tools . zip ; import java . util . zip . ZipException ; public interface ZipExtraField { public ZipShort getHeaderId ( ) ; public ZipShort getLocalFileDataLength ( ) ; public ZipShort getCentralDirectoryLength ( ) ; public byte [ ] getLocalFileDataData ( ) ; public byte [ ] getCentralDirectoryData ( ) ; public void parseFromLocalFileData ( byte [ ] data , int offset , int length ) throws ZipException ; } 	0	['6', '1', '0', '5', '6', '15', '4', '1', '6', '2', '6', '0', '0', '0', '0.444444444', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import java . io . File ; public class Rename extends Task { private File src ; private File dest ; private boolean replace = true ; public void setSrc ( File src ) { this . src = src ; } public void setDest ( File dest ) { this . dest = dest ; } public void setReplace ( String replace ) { this . replace = project . toBoolean ( replace ) ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The rename task is deprecated.  Use move instead." ) ; if ( dest == null ) { throw new BuildException ( "dest attribute is required" , location ) ; } if ( src == null ) { throw new BuildException ( "src attribute is required" , location ) ; } if ( replace && dest . exists ( ) ) { if ( ! dest . delete ( ) ) { throw new BuildException ( "Unable to remove existing file " + dest ) ; } } if ( ! src . renameTo ( dest ) ) { throw new BuildException ( "Unable to rename " + src + " to " + dest ) ; } } } 	0	['5', '3', '0', '4', '17', '0', '0', '4', '5', '0.666666667', '101', '1', '0', '0.902439024', '0.533333333', '1', '1', '18.6', '1', '0.8', '0']
package org . apache . tools . ant ; import java . util . EventObject ; public class BuildEvent extends EventObject { private Project project ; private Target target ; private Task task ; private String message ; private int priority = Project . MSG_VERBOSE ; private Throwable exception ; public BuildEvent ( Project project ) { super ( project ) ; this . project = project ; this . target = null ; this . task = null ; } public BuildEvent ( Target target ) { super ( target ) ; this . project = target . getProject ( ) ; this . target = target ; this . task = null ; } public BuildEvent ( Task task ) { super ( task ) ; this . project = task . getProject ( ) ; this . target = task . getOwningTarget ( ) ; this . task = task ; } public void setMessage ( String message , int priority ) { this . message = message ; this . priority = priority ; } public void setException ( Throwable exception ) { this . exception = exception ; } public Project getProject ( ) { return project ; } public Target getTarget ( ) { return target ; } public Task getTask ( ) { return task ; } public String getMessage ( ) { return message ; } public int getPriority ( ) { return priority ; } public Throwable getException ( ) { return exception ; } } 	0	['11', '2', '0', '12', '15', '13', '9', '4', '11', '0.75', '97', '1', '3', '0.2', '0.220779221', '0', '0', '7.272727273', '1', '0.7273', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . ZipFileSet ; import org . apache . tools . zip . * ; import java . io . * ; import java . util . Enumeration ; public class Jar extends Zip { private File manifestFile ; private Manifest manifest ; private Manifest execManifest ; private boolean buildFileManifest = false ; public Jar ( ) { super ( ) ; archiveType = "jar" ; emptyBehavior = "create" ; setEncoding ( "UTF8" ) ; } public void setJarfile ( File jarFile ) { super . setZipfile ( jarFile ) ; } public void addConfiguredManifest ( Manifest newManifest ) throws ManifestException { if ( manifest == null ) { manifest = getDefaultManifest ( ) ; } manifest . merge ( newManifest ) ; buildFileManifest = true ; } public void setManifest ( File manifestFile ) { if ( ! manifestFile . exists ( ) ) { throw new BuildException ( "Manifest file: " + manifestFile + " does not exist." , getLocation ( ) ) ; } this . manifestFile = manifestFile ; InputStream is = null ; try { is = new FileInputStream ( manifestFile ) ; Manifest newManifest = new Manifest ( is ) ; if ( manifest == null ) { manifest = getDefaultManifest ( ) ; } manifest . merge ( newManifest ) ; } catch ( ManifestException e ) { log ( "Manifest is invalid: " + e . getMessage ( ) , Project . MSG_ERR ) ; throw new BuildException ( "Invalid Manifest: " + manifestFile , e , getLocation ( ) ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to read manifest file: " + manifestFile , e ) ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( IOException e ) { } } } } public void addMetainf ( ZipFileSet fs ) { fs . setPrefix ( "META-INF/" ) ; super . addFileset ( fs ) ; } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { try { if ( manifest == null ) { execManifest = null ; } else { execManifest = new Manifest ( ) ; execManifest . merge ( manifest ) ; } zipDir ( null , zOut , "META-INF/" ) ; super . initZipOutputStream ( zOut ) ; } catch ( ManifestException e ) { log ( "Manifest is invalid: " + e . getMessage ( ) , Project . MSG_ERR ) ; throw new BuildException ( "Invalid Manifest" , e , getLocation ( ) ) ; } } private Manifest getDefaultManifest ( ) { try { String s = "/org/apache/tools/ant/defaultManifest.mf" ; InputStream in = this . getClass ( ) . getResourceAsStream ( s ) ; if ( in == null ) { throw new BuildException ( "Could not find default manifest: " + s ) ; } return new Manifest ( in ) ; } catch ( ManifestException e ) { throw new BuildException ( "Default manifest is invalid !!" ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to read default manifest" , e ) ; } } protected void finalizeZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( execManifest == null ) { execManifest = getDefaultManifest ( ) ; } for ( Enumeration e = execManifest . getWarnings ( ) ; e . hasMoreElements ( ) ; ) { log ( "Manifest warning: " + ( String ) e . nextElement ( ) , Project . MSG_WARN ) ; } ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; PrintWriter writer = new PrintWriter ( baos ) ; execManifest . write ( writer ) ; writer . flush ( ) ; ByteArrayInputStream bais = new ByteArrayInputStream ( baos . toByteArray ( ) ) ; super . zipFile ( bais , zOut , "META-INF/MANIFEST.MF" , System . currentTimeMillis ( ) ) ; super . finalizeZipOutputStream ( zOut ) ; } private void zipManifestEntry ( InputStream is ) throws IOException { try { if ( execManifest == null ) { execManifest = new Manifest ( is ) ; } else if ( isAddingNewFiles ( ) ) { execManifest . merge ( new Manifest ( is ) ) ; } } catch ( ManifestException e ) { log ( "Manifest is invalid: " + e . getMessage ( ) , Project . MSG_ERR ) ; throw new BuildException ( "Invalid Manifest" , e , getLocation ( ) ) ; } } protected void zipFile ( File file , ZipOutputStream zOut , String vPath ) throws IOException { if ( vPath . equalsIgnoreCase ( "META-INF/MANIFEST.MF" ) ) { InputStream is = null ; try { is = new FileInputStream ( file ) ; zipManifestEntry ( is ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to read manifest file: " + file , e ) ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( IOException e ) { } } } } else { super . zipFile ( file , zOut , vPath ) ; } } protected void zipFile ( InputStream is , ZipOutputStream zOut , String vPath , long lastModified ) throws IOException { if ( vPath . equalsIgnoreCase ( "META-INF/MANIFEST.MF" ) ) { try { zipManifestEntry ( is ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to read manifest file: " , e ) ; } } else { super . zipFile ( is , zOut , vPath , lastModified ) ; } } protected boolean isUpToDate ( FileScanner [ ] scanners , File zipFile ) throws BuildException { if ( buildFileManifest || manifestFile == null ) { java . util . zip . ZipFile theZipFile = null ; try { theZipFile = new java . util . zip . ZipFile ( zipFile ) ; java . util . zip . ZipEntry entry = theZipFile . getEntry ( "META-INF/MANIFEST.MF" ) ; if ( entry == null ) { log ( "Updating jar since the current jar has no manifest" , Project . MSG_VERBOSE ) ; return false ; } Manifest currentManifest = new Manifest ( theZipFile . getInputStream ( entry ) ) ; if ( manifest == null ) { manifest = getDefaultManifest ( ) ; } if ( ! currentManifest . equals ( manifest ) ) { log ( "Updating jar since jar manifest has changed" , Project . MSG_VERBOSE ) ; return false ; } } catch ( Exception e ) { log ( "Updating jar since cannot read current jar manifest: " + e . getClass ( ) . getName ( ) + e . getMessage ( ) , Project . MSG_VERBOSE ) ; return false ; } finally { if ( theZipFile != null ) { try { theZipFile . close ( ) ; } catch ( IOException e ) { } } } } else if ( manifestFile . lastModified ( ) > zipFile . lastModified ( ) ) { return false ; } return super . isUpToDate ( scanners , zipFile ) ; } protected boolean createEmptyZip ( File zipFile ) { return false ; } protected void cleanUp ( ) { super . cleanUp ( ) ; } } 	0	['14', '5', '2', '12', '64', '69', '2', '10', '5', '0.807692308', '531', '1', '2', '0.905797101', '0.246031746', '2', '7', '36.64285714', '6', '1.3571', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . io . * ; import java . util . * ; public class Delete extends MatchingTask { protected File file = null ; protected File dir = null ; protected Vector filesets = new Vector ( ) ; protected boolean usedMatchingTask = false ; protected boolean includeEmpty = false ; private int verbosity = Project . MSG_VERBOSE ; private boolean quiet = false ; private boolean failonerror = true ; public void setFile ( File file ) { this . file = file ; } public void setDir ( File dir ) { this . dir = dir ; } public void setVerbose ( boolean verbose ) { if ( verbose ) { this . verbosity = Project . MSG_INFO ; } else { this . verbosity = Project . MSG_VERBOSE ; } } public void setQuiet ( boolean quiet ) { this . quiet = quiet ; if ( quiet ) { this . failonerror = false ; } } public void setFailOnError ( boolean failonerror ) { this . failonerror = failonerror ; } public void setIncludeEmptyDirs ( boolean includeEmpty ) { this . includeEmpty = includeEmpty ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public PatternSet . NameEntry createInclude ( ) { usedMatchingTask = true ; return super . createInclude ( ) ; } public PatternSet . NameEntry createExclude ( ) { usedMatchingTask = true ; return super . createExclude ( ) ; } public PatternSet createPatternSet ( ) { usedMatchingTask = true ; return super . createPatternSet ( ) ; } public void setIncludes ( String includes ) { usedMatchingTask = true ; super . setIncludes ( includes ) ; } public void setExcludes ( String excludes ) { usedMatchingTask = true ; super . setExcludes ( excludes ) ; } public void setDefaultexcludes ( boolean useDefaultExcludes ) { usedMatchingTask = true ; super . setDefaultexcludes ( useDefaultExcludes ) ; } public void setIncludesfile ( File includesfile ) { usedMatchingTask = true ; super . setIncludesfile ( includesfile ) ; } public void setExcludesfile ( File excludesfile ) { usedMatchingTask = true ; super . setExcludesfile ( excludesfile ) ; } public void execute ( ) throws BuildException { if ( usedMatchingTask ) { log ( "DEPRECATED - Use of the implicit FileSet is deprecated.  Use a nested fileset element instead." ) ; } if ( file == null && dir == null && filesets . size ( ) == 0 ) { throw new BuildException ( "At least one of the file or dir attributes, or a fileset element, must be set." ) ; } if ( quiet && failonerror ) { throw new BuildException ( "quiet and failonerror cannot both be set to true" , location ) ; } if ( file != null ) { if ( file . exists ( ) ) { if ( file . isDirectory ( ) ) { log ( "Directory " + file . getAbsolutePath ( ) + " cannot be removed using the file attribute.  Use dir instead." ) ; } else { log ( "Deleting: " + file . getAbsolutePath ( ) ) ; if ( ! file . delete ( ) ) { String message = "Unable to delete file " + file . getAbsolutePath ( ) ; if ( failonerror ) throw new BuildException ( message ) ; else log ( message , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } } } else { log ( "Could not find file " + file . getAbsolutePath ( ) + " to delete." , Project . MSG_VERBOSE ) ; } } if ( dir != null && dir . exists ( ) && dir . isDirectory ( ) && ! usedMatchingTask ) { if ( verbosity == Project . MSG_VERBOSE ) { log ( "Deleting directory " + dir . getAbsolutePath ( ) ) ; } removeDir ( dir ) ; } for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; try { DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; String [ ] files = ds . getIncludedFiles ( ) ; String [ ] dirs = ds . getIncludedDirectories ( ) ; removeFiles ( fs . getDir ( project ) , files , dirs ) ; } catch ( BuildException be ) { if ( failonerror ) { throw be ; } else { log ( be . getMessage ( ) , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } } } if ( usedMatchingTask && dir != null ) { try { DirectoryScanner ds = super . getDirectoryScanner ( dir ) ; String [ ] files = ds . getIncludedFiles ( ) ; String [ ] dirs = ds . getIncludedDirectories ( ) ; removeFiles ( dir , files , dirs ) ; } catch ( BuildException be ) { if ( failonerror ) { throw be ; } else { log ( be . getMessage ( ) , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } } } } protected void removeDir ( File d ) { String [ ] list = d . list ( ) ; if ( list == null ) list = new String [ 0 ] ; for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( d , s ) ; if ( f . isDirectory ( ) ) { removeDir ( f ) ; } else { log ( "Deleting " + f . getAbsolutePath ( ) , verbosity ) ; if ( ! f . delete ( ) ) { String message = "Unable to delete file " + f . getAbsolutePath ( ) ; if ( failonerror ) throw new BuildException ( message ) ; else log ( message , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } } } log ( "Deleting directory " + d . getAbsolutePath ( ) , verbosity ) ; if ( ! d . delete ( ) ) { String message = "Unable to delete directory " + dir . getAbsolutePath ( ) ; if ( failonerror ) throw new BuildException ( message ) ; else log ( message , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } } protected void removeFiles ( File d , String [ ] files , String [ ] dirs ) { if ( files . length > 0 ) { log ( "Deleting " + files . length + " files from " + d . getAbsolutePath ( ) ) ; for ( int j = 0 ; j < files . length ; j ++ ) { File f = new File ( d , files [ j ] ) ; log ( "Deleting " + f . getAbsolutePath ( ) , verbosity ) ; if ( ! f . delete ( ) ) { String message = "Unable to delete file " + f . getAbsolutePath ( ) ; if ( failonerror ) throw new BuildException ( message ) ; else log ( message , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } } } if ( dirs . length > 0 && includeEmpty ) { int dirCount = 0 ; for ( int j = dirs . length - 1 ; j >= 0 ; j -- ) { File dir = new File ( d , dirs [ j ] ) ; String [ ] dirFiles = dir . list ( ) ; if ( dirFiles == null || dirFiles . length == 0 ) { log ( "Deleting " + dir . getAbsolutePath ( ) , verbosity ) ; if ( ! dir . delete ( ) ) { String message = "Unable to delete directory " + dir . getAbsolutePath ( ) ; if ( failonerror ) throw new BuildException ( message ) ; else log ( message , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } else { dirCount ++ ; } } } if ( dirCount > 0 ) { log ( "Deleted " + dirCount + " director" + ( dirCount == 1 ? "y" : "ies" ) + " from " + d . getAbsolutePath ( ) ) ; } } } } 	0	['19', '4', '0', '10', '52', '27', '0', '10', '17', '0.777777778', '699', '1', '0', '0.8125', '0.298245614', '3', '4', '35.36842105', '16', '2.3158', '0']
package org . apache . tools . ant . util ; public class FlatFileNameMapper implements FileNameMapper { public void setFrom ( String from ) { } public void setTo ( String to ) { } public String [ ] mapFileName ( String sourceFileName ) { return new String [ ] { new java . io . File ( sourceFileName ) . getName ( ) } ; } } 	0	['4', '1', '0', '2', '7', '6', '1', '1', '4', '2', '20', '0', '0', '0', '0.875', '0', '0', '4', '1', '0.75', '0']
package org . apache . tools . ant ; import java . io . * ; public class BuildException extends RuntimeException { private Throwable cause ; private Location location = Location . UNKNOWN_LOCATION ; public BuildException ( ) { super ( ) ; } public BuildException ( String msg ) { super ( msg ) ; } public BuildException ( String msg , Throwable cause ) { super ( msg ) ; this . cause = cause ; } public BuildException ( String msg , Throwable cause , Location location ) { this ( msg , cause ) ; this . location = location ; } public BuildException ( Throwable cause ) { super ( cause . toString ( ) ) ; this . cause = cause ; } public BuildException ( String msg , Location location ) { super ( msg ) ; this . location = location ; } public BuildException ( Throwable cause , Location location ) { this ( cause ) ; this . location = location ; } public Throwable getException ( ) { return cause ; } public String toString ( ) { return location . toString ( ) + getMessage ( ) ; } public void setLocation ( Location location ) { this . location = location ; } public Location getLocation ( ) { return location ; } public void printStackTrace ( ) { printStackTrace ( System . err ) ; } public void printStackTrace ( PrintStream ps ) { synchronized ( ps ) { super . printStackTrace ( ps ) ; if ( cause != null ) { ps . println ( "--- Nested Exception ---" ) ; cause . printStackTrace ( ps ) ; } } } public void printStackTrace ( PrintWriter pw ) { synchronized ( pw ) { super . printStackTrace ( pw ) ; if ( cause != null ) { pw . println ( "--- Nested Exception ---" ) ; cause . printStackTrace ( pw ) ; } } } } 	0	['14', '4', '0', '136', '26', '0', '135', '1', '14', '0.384615385', '153', '1', '1', '0.65', '0.333333333', '1', '2', '9.785714286', '2', '0.6429', '0']
package org . apache . tools . ant . util . regexp ; import org . apache . oro . text . regex . * ; import org . apache . tools . ant . BuildException ; import java . util . Vector ; public class JakartaOroMatcher implements RegexpMatcher { protected Perl5Matcher reg = new Perl5Matcher ( ) ; protected Perl5Compiler comp = new Perl5Compiler ( ) ; private Pattern pattern ; public void setPattern ( String pattern ) throws BuildException { try { this . pattern = comp . compile ( pattern ) ; } catch ( MalformedPatternException e ) { throw new BuildException ( e ) ; } } public String getPattern ( ) { return pattern . getPattern ( ) ; } public boolean matches ( String argument ) { return reg . contains ( argument , pattern ) ; } public Vector getGroups ( String argument ) { if ( ! matches ( argument ) ) { return null ; } Vector v = new Vector ( ) ; MatchResult mr = reg . getMatch ( ) ; for ( int i = 0 ; i < mr . groups ( ) ; i ++ ) { v . addElement ( mr . group ( i ) ) ; } return v ; } } 	0	['5', '1', '0', '7', '17', '0', '0', '7', '5', '0.5', '75', '1', '0', '0', '0.8', '0', '0', '13.4', '3', '1.2', '0']
package org . apache . tools . ant ; import java . util . * ; public class Target implements TaskContainer { private String name ; private String ifCondition = "" ; private String unlessCondition = "" ; private Vector dependencies = new Vector ( 2 ) ; private Vector children = new Vector ( 5 ) ; private Project project ; private String description = null ; public void setProject ( Project project ) { this . project = project ; } public Project getProject ( ) { return project ; } public void setDepends ( String depS ) { if ( depS . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( depS , "," , false ) ; while ( tok . hasMoreTokens ( ) ) { addDependency ( tok . nextToken ( ) . trim ( ) ) ; } } } public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void addTask ( Task task ) { children . addElement ( task ) ; } public void addDataType ( RuntimeConfigurable r ) { children . addElement ( r ) ; } public Task [ ] getTasks ( ) { Vector tasks = new Vector ( children . size ( ) ) ; Enumeration enum = children . elements ( ) ; while ( enum . hasMoreElements ( ) ) { Object o = enum . nextElement ( ) ; if ( o instanceof Task ) { tasks . addElement ( o ) ; } } Task [ ] retval = new Task [ tasks . size ( ) ] ; tasks . copyInto ( retval ) ; return retval ; } public void addDependency ( String dependency ) { dependencies . addElement ( dependency ) ; } public Enumeration getDependencies ( ) { return dependencies . elements ( ) ; } public void setIf ( String property ) { this . ifCondition = ( property == null ) ? "" : property ; } public void setUnless ( String property ) { this . unlessCondition = ( property == null ) ? "" : property ; } public void setDescription ( String description ) { this . description = description ; } public String getDescription ( ) { return description ; } public String toString ( ) { return name ; } public void execute ( ) throws BuildException { if ( testIfCondition ( ) && testUnlessCondition ( ) ) { Enumeration enum = children . elements ( ) ; while ( enum . hasMoreElements ( ) ) { Object o = enum . nextElement ( ) ; if ( o instanceof Task ) { Task task = ( Task ) o ; task . perform ( ) ; } else { RuntimeConfigurable r = ( RuntimeConfigurable ) o ; r . maybeConfigure ( project ) ; } } } else if ( ! testIfCondition ( ) ) { project . log ( this , "Skipped because property '" + this . ifCondition + "' not set." , Project . MSG_VERBOSE ) ; } else { project . log ( this , "Skipped because property '" + this . unlessCondition + "' set." , Project . MSG_VERBOSE ) ; } } public final void performTasks ( ) { try { project . fireTargetStarted ( this ) ; execute ( ) ; project . fireTargetFinished ( this , null ) ; } catch ( RuntimeException exc ) { project . fireTargetFinished ( this , exc ) ; throw exc ; } } void replaceTask ( UnknownElement el , Task t ) { int index = - 1 ; while ( ( index = children . indexOf ( el ) ) >= 0 ) { children . setElementAt ( t , index ) ; } } private boolean testIfCondition ( ) { if ( "" . equals ( ifCondition ) ) { return true ; } String test = ProjectHelper . replaceProperties ( getProject ( ) , ifCondition , getProject ( ) . getProperties ( ) ) ; return project . getProperty ( test ) != null ; } private boolean testUnlessCondition ( ) { if ( "" . equals ( unlessCondition ) ) { return true ; } String test = ProjectHelper . replaceProperties ( getProject ( ) , unlessCondition , getProject ( ) . getProperties ( ) ) ; return project . getProperty ( test ) == null ; } } 	0	['21', '1', '0', '24', '48', '116', '20', '7', '18', '0.814285714', '322', '1', '1', '0', '0.253968254', '0', '0', '14', '3', '1.4762', '0']
package org . apache . tools . ant . taskdefs ; public class Typedef extends Definer { protected void addDefinition ( String name , Class c ) { project . addDataTypeDefinition ( name , c ) ; } } 	0	['2', '6', '0', '3', '4', '1', '0', '3', '1', '2', '11', '0', '0', '0.987179487', '0.666666667', '0', '0', '4.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; public class Sleep extends Task { private boolean failOnError = true ; private int seconds = 0 ; private int hours = 0 ; private int minutes = 0 ; private int milliseconds = 0 ; public Sleep ( ) { } public void setSeconds ( int seconds ) { this . seconds = seconds ; } public void setHours ( int hours ) { this . hours = hours ; } public void setMinutes ( int minutes ) { this . minutes = minutes ; } public void setMilliseconds ( int milliseconds ) { this . milliseconds = milliseconds ; } public void doSleep ( long millis ) { try { Thread . currentThread ( ) . sleep ( millis ) ; } catch ( InterruptedException ie ) { } } public void setFailOnError ( boolean failOnError ) { this . failOnError = failOnError ; } private long getSleepTime ( ) { return ( ( ( ( long ) hours * 60 ) + minutes ) * 60 + seconds ) * 1000 + milliseconds ; } public void validate ( ) throws BuildException { long sleepTime = getSleepTime ( ) ; if ( getSleepTime ( ) < 0 ) { throw new BuildException ( "Negative sleep periods are not supported" ) ; } } public void execute ( ) throws BuildException { try { validate ( ) ; long sleepTime = getSleepTime ( ) ; log ( "sleeping for " + sleepTime + " milliseconds" , Project . MSG_VERBOSE ) ; doSleep ( sleepTime ) ; } catch ( Exception e ) { if ( failOnError ) { throw new BuildException ( e ) ; } else { String text = e . toString ( ) ; log ( text , Project . MSG_ERR ) ; } } } } 	0	['10', '3', '0', '2', '21', '21', '0', '2', '9', '0.6', '135', '1', '0', '0.804347826', '0.4', '1', '1', '12', '1', '0.9', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . * ; public class Jikes extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using jikes compiler" , Project . MSG_VERBOSE ) ; Path classpath = new Path ( project ) ; if ( bootclasspath != null ) { classpath . append ( bootclasspath ) ; } addExtdirsToClasspath ( classpath ) ; if ( ( bootclasspath == null ) || ( bootclasspath . size ( ) == 0 ) ) { includeJavaRuntime = true ; } else { } classpath . append ( getCompileClasspath ( ) ) ; classpath . append ( src ) ; String jikesPath = System . getProperty ( "jikes.class.path" ) ; if ( jikesPath != null ) { classpath . append ( new Path ( project , jikesPath ) ) ; } Commandline cmd = new Commandline ( ) ; cmd . setExecutable ( "jikes" ) ; if ( deprecation == true ) cmd . createArgument ( ) . setValue ( "-deprecation" ) ; if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "-classpath" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; if ( encoding != null ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( encoding ) ; } if ( debug ) { cmd . createArgument ( ) . setValue ( "-g" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O" ) ; } if ( verbose ) { cmd . createArgument ( ) . setValue ( "-verbose" ) ; } if ( depend ) { cmd . createArgument ( ) . setValue ( "-depend" ) ; } String emacsProperty = project . getProperty ( "build.compiler.emacs" ) ; if ( emacsProperty != null && Project . toBoolean ( emacsProperty ) ) { cmd . createArgument ( ) . setValue ( "+E" ) ; } String warningsProperty = project . getProperty ( "build.compiler.warnings" ) ; if ( warningsProperty != null ) { attributes . log ( "!! the build.compiler.warnings property is deprecated. !!" , Project . MSG_WARN ) ; attributes . log ( "!! Use the nowarn attribute instead. !!" , Project . MSG_WARN ) ; if ( ! Project . toBoolean ( warningsProperty ) ) { cmd . createArgument ( ) . setValue ( "-nowarn" ) ; } } if ( attributes . getNowarn ( ) ) { cmd . createArgument ( ) . setValue ( "-nowarn" ) ; } String pedanticProperty = project . getProperty ( "build.compiler.pedantic" ) ; if ( pedanticProperty != null && Project . toBoolean ( pedanticProperty ) ) { cmd . createArgument ( ) . setValue ( "+P" ) ; } String fullDependProperty = project . getProperty ( "build.compiler.fulldepend" ) ; if ( fullDependProperty != null && Project . toBoolean ( fullDependProperty ) ) { cmd . createArgument ( ) . setValue ( "+F" ) ; } int firstFileName = cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } } 	0	['2', '2', '0', '9', '24', '1', '1', '8', '2', '2', '222', '0', '0', '0.958333333', '1', '1', '1', '110', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; import java . io . * ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; public class Kjc extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using kjc compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupKjcCommand ( ) ; try { Class c = Class . forName ( "at.dms.kjc.Main" ) ; Method compile = c . getMethod ( "compile" , new Class [ ] { String [ ] . class } ) ; Boolean ok = ( Boolean ) compile . invoke ( null , new Object [ ] { cmd . getArguments ( ) } ) ; return ok . booleanValue ( ) ; } catch ( ClassNotFoundException ex ) { throw new BuildException ( "Cannot use kjc compiler, as it is not available" + " A common solution is to set the environment variable" + " CLASSPATH to your kjc archive (kjc.jar)." , location ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting kjc compiler: " , ex , location ) ; } } } protected Commandline setupKjcCommand ( ) { Commandline cmd = new Commandline ( ) ; Path classpath = getCompileClasspath ( ) ; if ( deprecation == true ) { cmd . createArgument ( ) . setValue ( "-deprecation" ) ; } if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "-classpath" ) ; Path cp = new Path ( project ) ; if ( bootclasspath != null ) { cp . append ( bootclasspath ) ; } if ( extdirs != null ) { addExtdirsToClasspath ( cp ) ; } cp . append ( classpath ) ; cp . append ( src ) ; cmd . createArgument ( ) . setPath ( cp ) ; if ( encoding != null ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( encoding ) ; } if ( debug ) { cmd . createArgument ( ) . setValue ( "-g" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O2" ) ; } if ( verbose ) { cmd . createArgument ( ) . setValue ( "-verbose" ) ; } logAndAddFilesToCompile ( cmd ) ; return cmd ; } } 	0	['4', '2', '0', '10', '25', '6', '1', '9', '2', '1', '183', '0', '0', '0.884615385', '0.5', '0', '0', '44.5', '9', '2.75', '0']
package org . apache . tools . ant ; import java . io . * ; import java . util . * ; public class DemuxOutputStream extends OutputStream { static private final int MAX_SIZE = 1024 ; private Hashtable buffers = new Hashtable ( ) ; private boolean skip = false ; private Project project ; private boolean isErrorStream ; public DemuxOutputStream ( Project project , boolean isErrorStream ) { this . project = project ; this . isErrorStream = isErrorStream ; } private ByteArrayOutputStream getBuffer ( ) { Thread current = Thread . currentThread ( ) ; ByteArrayOutputStream buffer = ( ByteArrayOutputStream ) buffers . get ( current ) ; if ( buffer == null ) { buffer = new ByteArrayOutputStream ( ) ; buffers . put ( current , buffer ) ; } return buffer ; } private void resetBuffer ( ) { Thread current = Thread . currentThread ( ) ; buffers . remove ( current ) ; } public void write ( int cc ) throws IOException { final byte c = ( byte ) cc ; if ( ( c == '\n' ) || ( c == '\r' ) ) { if ( ! skip ) { processBuffer ( ) ; } } else { ByteArrayOutputStream buffer = getBuffer ( ) ; buffer . write ( cc ) ; if ( buffer . size ( ) > MAX_SIZE ) { processBuffer ( ) ; } } skip = ( c == '\r' ) ; } protected void processBuffer ( ) { String output = getBuffer ( ) . toString ( ) ; project . demuxOutput ( output , isErrorStream ) ; resetBuffer ( ) ; } public void close ( ) throws IOException { flush ( ) ; } public void flush ( ) throws IOException { if ( getBuffer ( ) . size ( ) > 0 ) { processBuffer ( ) ; } } } 	0	['7', '2', '0', '2', '18', '11', '1', '1', '4', '0.633333333', '118', '1', '1', '0.454545455', '0.357142857', '1', '1', '15.14285714', '2', '1', '0']
package org . apache . tools . tar ; import java . io . * ; public class TarInputStream extends FilterInputStream { protected boolean debug ; protected boolean hasHitEOF ; protected int entrySize ; protected int entryOffset ; protected byte [ ] oneBuf ; protected byte [ ] readBuf ; protected TarBuffer buffer ; protected TarEntry currEntry ; public TarInputStream ( InputStream is ) { this ( is , TarBuffer . DEFAULT_BLKSIZE , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarInputStream ( InputStream is , int blockSize ) { this ( is , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarInputStream ( InputStream is , int blockSize , int recordSize ) { super ( is ) ; this . buffer = new TarBuffer ( is , blockSize , recordSize ) ; this . readBuf = null ; this . oneBuf = new byte [ 1 ] ; this . debug = false ; this . hasHitEOF = false ; } public void setDebug ( boolean debug ) { this . debug = debug ; this . buffer . setDebug ( debug ) ; } public void close ( ) throws IOException { this . buffer . close ( ) ; } public int getRecordSize ( ) { return this . buffer . getRecordSize ( ) ; } public int available ( ) throws IOException { return this . entrySize - this . entryOffset ; } public void skip ( int numToSkip ) throws IOException { byte [ ] skipBuf = new byte [ 8 * 1024 ] ; for ( int num = numToSkip ; num > 0 ; ) { int numRead = this . read ( skipBuf , 0 , ( num > skipBuf . length ? skipBuf . length : num ) ) ; if ( numRead == - 1 ) { break ; } num -= numRead ; } } public boolean markSupported ( ) { return false ; } public void mark ( int markLimit ) { } public void reset ( ) { } public TarEntry getNextEntry ( ) throws IOException { if ( this . hasHitEOF ) { return null ; } if ( this . currEntry != null ) { int numToSkip = this . entrySize - this . entryOffset ; if ( this . debug ) { System . err . println ( "TarInputStream: SKIP currENTRY '" + this . currEntry . getName ( ) + "' SZ " + this . entrySize + " OFF " + this . entryOffset + "  skipping " + numToSkip + " bytes" ) ; } if ( numToSkip > 0 ) { this . skip ( numToSkip ) ; } this . readBuf = null ; } byte [ ] headerBuf = this . buffer . readRecord ( ) ; if ( headerBuf == null ) { if ( this . debug ) { System . err . println ( "READ NULL RECORD" ) ; } this . hasHitEOF = true ; } else if ( this . buffer . isEOFRecord ( headerBuf ) ) { if ( this . debug ) { System . err . println ( "READ EOF RECORD" ) ; } this . hasHitEOF = true ; } if ( this . hasHitEOF ) { this . currEntry = null ; } else { this . currEntry = new TarEntry ( headerBuf ) ; if ( ! ( headerBuf [ 257 ] == 'u' && headerBuf [ 258 ] == 's' && headerBuf [ 259 ] == 't' && headerBuf [ 260 ] == 'a' && headerBuf [ 261 ] == 'r' ) ) { this . entrySize = 0 ; this . entryOffset = 0 ; this . currEntry = null ; throw new IOException ( "bad header in block " + this . buffer . getCurrentBlockNum ( ) + " record " + this . buffer . getCurrentRecordNum ( ) + ", " + "header magic is not 'ustar', but '" + headerBuf [ 257 ] + headerBuf [ 258 ] + headerBuf [ 259 ] + headerBuf [ 260 ] + headerBuf [ 261 ] + "', or (dec) " + ( ( int ) headerBuf [ 257 ] ) + ", " + ( ( int ) headerBuf [ 258 ] ) + ", " + ( ( int ) headerBuf [ 259 ] ) + ", " + ( ( int ) headerBuf [ 260 ] ) + ", " + ( ( int ) headerBuf [ 261 ] ) ) ; } if ( this . debug ) { System . err . println ( "TarInputStream: SET CURRENTRY '" + this . currEntry . getName ( ) + "' size = " + this . currEntry . getSize ( ) ) ; } this . entryOffset = 0 ; this . entrySize = ( int ) this . currEntry . getSize ( ) ; } if ( this . currEntry != null && this . currEntry . isGNULongNameEntry ( ) ) { StringBuffer longName = new StringBuffer ( ) ; byte [ ] buffer = new byte [ 256 ] ; int length = 0 ; while ( ( length = read ( buffer ) ) >= 0 ) { longName . append ( new String ( buffer , 0 , length ) ) ; } getNextEntry ( ) ; this . currEntry . setName ( longName . toString ( ) ) ; } return this . currEntry ; } public int read ( ) throws IOException { int num = this . read ( this . oneBuf , 0 , 1 ) ; if ( num == - 1 ) { return num ; } else { return ( int ) this . oneBuf [ 0 ] ; } } public int read ( byte [ ] buf ) throws IOException { return this . read ( buf , 0 , buf . length ) ; } public int read ( byte [ ] buf , int offset , int numToRead ) throws IOException { int totalRead = 0 ; if ( this . entryOffset >= this . entrySize ) { return - 1 ; } if ( ( numToRead + this . entryOffset ) > this . entrySize ) { numToRead = ( this . entrySize - this . entryOffset ) ; } if ( this . readBuf != null ) { int sz = ( numToRead > this . readBuf . length ) ? this . readBuf . length : numToRead ; System . arraycopy ( this . readBuf , 0 , buf , offset , sz ) ; if ( sz >= this . readBuf . length ) { this . readBuf = null ; } else { int newLen = this . readBuf . length - sz ; byte [ ] newBuf = new byte [ newLen ] ; System . arraycopy ( this . readBuf , sz , newBuf , 0 , newLen ) ; this . readBuf = newBuf ; } totalRead += sz ; numToRead -= sz ; offset += sz ; } while ( numToRead > 0 ) { byte [ ] rec = this . buffer . readRecord ( ) ; if ( rec == null ) { throw new IOException ( "unexpected EOF with " + numToRead + " bytes unread" ) ; } int sz = numToRead ; int recLen = rec . length ; if ( recLen > sz ) { System . arraycopy ( rec , 0 , buf , offset , sz ) ; this . readBuf = new byte [ recLen - sz ] ; System . arraycopy ( rec , sz , this . readBuf , 0 , recLen - sz ) ; } else { sz = recLen ; System . arraycopy ( rec , 0 , buf , offset , recLen ) ; } totalRead += sz ; numToRead -= sz ; offset += sz ; } this . entryOffset += totalRead ; return totalRead ; } public void copyEntryContents ( OutputStream out ) throws IOException { byte [ ] buf = new byte [ 32 * 1024 ] ; while ( true ) { int numRead = this . read ( buf , 0 , buf . length ) ; if ( numRead == - 1 ) { break ; } out . write ( buf , 0 , numRead ) ; } } } 	0	['16', '3', '0', '3', '40', '84', '1', '2', '16', '0.658333333', '604', '1', '2', '0.580645161', '0.291666667', '2', '7', '36.25', '1', '0.8125', '0']
package org . apache . tools . zip ; public class ZipShort implements Cloneable { private int value ; public ZipShort ( int value ) { this . value = value ; } public ZipShort ( byte [ ] bytes ) { this ( bytes , 0 ) ; } public ZipShort ( byte [ ] bytes , int offset ) { value = ( bytes [ offset + 1 ] << 8 ) & 0xFF00 ; value += ( bytes [ offset ] & 0xFF ) ; } public byte [ ] getBytes ( ) { byte [ ] result = new byte [ 2 ] ; result [ 0 ] = ( byte ) ( value & 0xFF ) ; result [ 1 ] = ( byte ) ( ( value & 0xFF00 ) > > 8 ) ; return result ; } public int getValue ( ) { return value ; } public boolean equals ( Object o ) { if ( o == null || ! ( o instanceof ZipShort ) ) { return false ; } return value == ( ( ZipShort ) o ) . getValue ( ) ; } public int hashCode ( ) { return value ; } } 	0	['7', '1', '0', '6', '8', '0', '6', '0', '7', '0', '89', '1', '0', '0', '0.428571429', '1', '1', '11.57142857', '4', '1', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . * ; import java . util . Properties ; import java . util . Stack ; public class Mapper extends DataType { protected Project p ; protected MapperType type = null ; public Mapper ( Project p ) { this . p = p ; } public void setType ( MapperType type ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . type = type ; } protected String classname = null ; public void setClassname ( String classname ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . classname = classname ; } protected Path classpath = null ; public void setClasspath ( Path classpath ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . classpath == null ) { this . classpath = new Path ( p ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createClasspath ( ) . setRefid ( r ) ; } protected String from = null ; public void setFrom ( String from ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . from = from ; } protected String to = null ; public void setTo ( String to ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . to = to ; } public void setRefid ( Reference r ) throws BuildException { if ( type != null || from != null || to != null ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public FileNameMapper getImplementation ( ) throws BuildException { if ( isReference ( ) ) { return getRef ( ) . getImplementation ( ) ; } if ( type == null && classname == null ) { throw new BuildException ( "one of the attributes type or classname is required" ) ; } if ( type != null && classname != null ) { throw new BuildException ( "must not specify both type and classname attribute" ) ; } try { if ( type != null ) { classname = type . getImplementation ( ) ; } Class c = null ; if ( classpath == null ) { c = Class . forName ( classname ) ; } else { AntClassLoader al = new AntClassLoader ( p , classpath ) ; c = al . loadClass ( classname ) ; AntClassLoader . initializeClass ( c ) ; } FileNameMapper m = ( FileNameMapper ) c . newInstance ( ) ; m . setFrom ( from ) ; m . setTo ( to ) ; return m ; } catch ( BuildException be ) { throw be ; } catch ( Throwable t ) { throw new BuildException ( t ) ; } finally { if ( type != null ) { classname = null ; } } } protected Mapper getRef ( ) { if ( ! checked ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , p ) ; } Object o = ref . getReferencedObject ( p ) ; if ( ! ( o instanceof Mapper ) ) { String msg = ref . getRefId ( ) + " doesn\'t denote a mapper" ; throw new BuildException ( msg ) ; } else { return ( Mapper ) o ; } } public static class MapperType extends EnumeratedAttribute { private Properties implementations ; public MapperType ( ) { implementations = new Properties ( ) ; implementations . put ( "identity" , "org.apache.tools.ant.util.IdentityMapper" ) ; implementations . put ( "flatten" , "org.apache.tools.ant.util.FlatFileNameMapper" ) ; implementations . put ( "glob" , "org.apache.tools.ant.util.GlobPatternMapper" ) ; implementations . put ( "merge" , "org.apache.tools.ant.util.MergingMapper" ) ; implementations . put ( "regexp" , "org.apache.tools.ant.util.RegexpPatternMapper" ) ; } public String [ ] getValues ( ) { return new String [ ] { "identity" , "flatten" , "glob" , "merge" , "regexp" } ; } public String getImplementation ( ) { return implementations . getProperty ( getValue ( ) ) ; } } } 	0	['11', '3', '0', '11', '38', '11', '3', '8', '10', '0.683333333', '287', '1', '3', '0.75', '0.287878788', '1', '1', '24.54545455', '3', '1.9091', '0']
package org . apache . tools . ant . taskdefs ; public class Taskdef extends Definer { protected void addDefinition ( String name , Class c ) { project . addTaskDefinition ( name , c ) ; } } 	0	['2', '6', '0', '4', '4', '1', '1', '3', '1', '2', '11', '0', '0', '0.987179487', '0.666666667', '0', '0', '4.5', '1', '0.5', '0']
package org . apache . tools . ant . util ; import java . io . * ; import java . lang . reflect . Method ; import java . util . StringTokenizer ; import java . util . Stack ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . FilterSetCollection ; public class FileUtils { private static Object lockReflection = new Object ( ) ; private static java . lang . reflect . Method setLastModified = null ; public static FileUtils newFileUtils ( ) { return new FileUtils ( ) ; } protected FileUtils ( ) { } public void copyFile ( String sourceFile , String destFile ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , null , false , false ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , false , false ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , boolean overwrite ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , overwrite , false ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , overwrite , preserveLastModified ) ; } public void copyFile ( File sourceFile , File destFile ) throws IOException { copyFile ( sourceFile , destFile , null , false , false ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters ) throws IOException { copyFile ( sourceFile , destFile , filters , false , false ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , boolean overwrite ) throws IOException { copyFile ( sourceFile , destFile , filters , overwrite , false ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified ) throws IOException { if ( overwrite || ! destFile . exists ( ) || destFile . lastModified ( ) < sourceFile . lastModified ( ) ) { if ( destFile . exists ( ) && destFile . isFile ( ) ) { destFile . delete ( ) ; } File parent = new File ( destFile . getParent ( ) ) ; if ( ! parent . exists ( ) ) { parent . mkdirs ( ) ; } if ( filters != null && filters . hasFilters ( ) ) { BufferedReader in = new BufferedReader ( new FileReader ( sourceFile ) ) ; BufferedWriter out = new BufferedWriter ( new FileWriter ( destFile ) ) ; int length ; String newline = null ; String line = in . readLine ( ) ; while ( line != null ) { if ( line . length ( ) == 0 ) { out . newLine ( ) ; } else { newline = filters . replaceTokens ( line ) ; out . write ( newline ) ; out . newLine ( ) ; } line = in . readLine ( ) ; } out . close ( ) ; in . close ( ) ; } else { FileInputStream in = new FileInputStream ( sourceFile ) ; FileOutputStream out = new FileOutputStream ( destFile ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { out . write ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; in . close ( ) ; out . close ( ) ; } if ( preserveLastModified ) { setFileLastModified ( destFile , sourceFile . lastModified ( ) ) ; } } } protected final Method getSetLastModified ( ) { if ( Project . getJavaVersion ( ) == Project . JAVA_1_1 ) { return null ; } if ( setLastModified == null ) { synchronized ( lockReflection ) { if ( setLastModified == null ) { try { setLastModified = java . io . File . class . getMethod ( "setLastModified" , new Class [ ] { Long . TYPE } ) ; } catch ( NoSuchMethodException nse ) { throw new BuildException ( "File.setlastModified not in JDK > 1.1?" , nse ) ; } } } } return setLastModified ; } public void setFileLastModified ( File file , long time ) throws BuildException { if ( Project . getJavaVersion ( ) == Project . JAVA_1_1 ) { return ; } Long [ ] times = new Long [ 1 ] ; if ( time < 0 ) { times [ 0 ] = new Long ( System . currentTimeMillis ( ) ) ; } else { times [ 0 ] = new Long ( time ) ; } try { getSetLastModified ( ) . invoke ( file , times ) ; } catch ( java . lang . reflect . InvocationTargetException ite ) { Throwable nested = ite . getTargetException ( ) ; throw new BuildException ( "Exception setting the modification time " + "of " + file , nested ) ; } catch ( Throwable other ) { throw new BuildException ( "Exception setting the modification time " + "of " + file , other ) ; } } public File resolveFile ( File file , String filename ) { filename = filename . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( filename . startsWith ( File . separator ) || ( filename . length ( ) >= 2 && Character . isLetter ( filename . charAt ( 0 ) ) && filename . charAt ( 1 ) == ':' ) ) { return normalize ( filename ) ; } if ( filename . length ( ) >= 2 && Character . isLetter ( filename . charAt ( 0 ) ) && filename . charAt ( 1 ) == ':' ) { return normalize ( filename ) ; } File helpFile = new File ( file . getAbsolutePath ( ) ) ; StringTokenizer tok = new StringTokenizer ( filename , File . separator ) ; while ( tok . hasMoreTokens ( ) ) { String part = tok . nextToken ( ) ; if ( part . equals ( ".." ) ) { String parentFile = helpFile . getParent ( ) ; if ( parentFile == null ) { String msg = "The file or path you specified (" + filename + ") is invalid relative to " + file . getPath ( ) ; throw new BuildException ( msg ) ; } helpFile = new File ( parentFile ) ; } else if ( part . equals ( "." ) ) { } else { helpFile = new File ( helpFile , part ) ; } } return new File ( helpFile . getAbsolutePath ( ) ) ; } public File normalize ( String path ) { String orig = path ; path = path . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( ! path . startsWith ( File . separator ) && ! ( path . length ( ) >= 2 && Character . isLetter ( path . charAt ( 0 ) ) && path . charAt ( 1 ) == ':' ) ) { String msg = path + " is not an absolute path" ; throw new BuildException ( msg ) ; } boolean dosWithDrive = false ; String root = null ; if ( path . length ( ) >= 2 && Character . isLetter ( path . charAt ( 0 ) ) && path . charAt ( 1 ) == ':' ) { dosWithDrive = true ; char [ ] ca = path . replace ( '/' , '\\' ) . toCharArray ( ) ; StringBuffer sb = new StringBuffer ( ) ; sb . append ( Character . toUpperCase ( ca [ 0 ] ) ) . append ( ':' ) ; for ( int i = 2 ; i < ca . length ; i ++ ) { if ( ( ca [ i ] != '\\' ) || ( ca [ i ] == '\\' && ca [ i - 1 ] != '\\' ) ) { sb . append ( ca [ i ] ) ; } } path = sb . toString ( ) . replace ( '\\' , File . separatorChar ) ; if ( path . length ( ) == 2 ) { root = path ; path = "" ; } else { root = path . substring ( 0 , 3 ) ; path = path . substring ( 3 ) ; } } else { if ( path . length ( ) == 1 ) { root = File . separator ; path = "" ; } else if ( path . charAt ( 1 ) == File . separatorChar ) { root = File . separator + File . separator ; path = path . substring ( 2 ) ; } else { root = File . separator ; path = path . substring ( 1 ) ; } } Stack s = new Stack ( ) ; s . push ( root ) ; StringTokenizer tok = new StringTokenizer ( path , File . separator ) ; while ( tok . hasMoreTokens ( ) ) { String thisToken = tok . nextToken ( ) ; if ( "." . equals ( thisToken ) ) { continue ; } else if ( ".." . equals ( thisToken ) ) { if ( s . size ( ) < 2 ) { throw new BuildException ( "Cannot resolve path " + orig ) ; } else { s . pop ( ) ; } } else { s . push ( thisToken ) ; } } StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( i > 1 ) { sb . append ( File . separatorChar ) ; } sb . append ( s . elementAt ( i ) ) ; } path = sb . toString ( ) ; if ( dosWithDrive ) { path = path . replace ( '/' , '\\' ) ; } return new File ( path ) ; } } 	0	['16', '1', '0', '7', '78', '118', '5', '3', '12', '0.888888889', '745', '0.666666667', '0', '0', '0.411111111', '0', '0', '45.375', '22', '3.125', '0']
package org . apache . tools . zip ; import java . io . * ; import java . util . Date ; import java . util . Hashtable ; import java . util . Vector ; import java . util . zip . CRC32 ; import java . util . zip . Deflater ; import java . util . zip . DeflaterOutputStream ; import java . util . zip . ZipException ; public class ZipOutputStream extends DeflaterOutputStream { private ZipEntry entry ; private String comment = "" ; private int level = Deflater . DEFAULT_COMPRESSION ; private int method = DEFLATED ; private Vector entries = new Vector ( ) ; private CRC32 crc = new CRC32 ( ) ; private long written = 0 ; private long dataStart = 0 ; private ZipLong cdOffset = new ZipLong ( 0 ) ; private ZipLong cdLength = new ZipLong ( 0 ) ; private static final byte [ ] ZERO = { 0 , 0 } ; private static final byte [ ] LZERO = { 0 , 0 , 0 , 0 } ; private Hashtable offsets = new Hashtable ( ) ; private String encoding = null ; public static final int DEFLATED = ZipEntry . DEFLATED ; public static final int STORED = ZipEntry . STORED ; public ZipOutputStream ( OutputStream out ) { super ( out , new Deflater ( Deflater . DEFAULT_COMPRESSION , true ) ) ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String getEncoding ( ) { return encoding ; } public void finish ( ) throws IOException { closeEntry ( ) ; cdOffset = new ZipLong ( written ) ; for ( int i = 0 ; i < entries . size ( ) ; i ++ ) { writeCentralFileHeader ( ( ZipEntry ) entries . elementAt ( i ) ) ; } cdLength = new ZipLong ( written - cdOffset . getValue ( ) ) ; writeCentralDirectoryEnd ( ) ; offsets . clear ( ) ; entries . removeAllElements ( ) ; } public void closeEntry ( ) throws IOException { if ( entry == null ) { return ; } long realCrc = crc . getValue ( ) ; crc . reset ( ) ; if ( entry . getMethod ( ) == DEFLATED ) { def . finish ( ) ; while ( ! def . finished ( ) ) { deflate ( ) ; } entry . setSize ( def . getTotalIn ( ) ) ; entry . setComprSize ( def . getTotalOut ( ) ) ; entry . setCrc ( realCrc ) ; def . reset ( ) ; written += entry . getCompressedSize ( ) ; } else { if ( entry . getCrc ( ) != realCrc ) { throw new ZipException ( "bad CRC checksum for entry " + entry . getName ( ) + ": " + Long . toHexString ( entry . getCrc ( ) ) + " instead of " + Long . toHexString ( realCrc ) ) ; } if ( entry . getSize ( ) != written - dataStart ) { throw new ZipException ( "bad size for entry " + entry . getName ( ) + ": " + entry . getSize ( ) + " instead of " + ( written - dataStart ) ) ; } } writeDataDescriptor ( entry ) ; entry = null ; } public void putNextEntry ( ZipEntry ze ) throws IOException { closeEntry ( ) ; entry = ze ; entries . addElement ( entry ) ; if ( entry . getMethod ( ) == - 1 ) { entry . setMethod ( method ) ; } if ( entry . getTime ( ) == - 1 ) { entry . setTime ( System . currentTimeMillis ( ) ) ; } if ( entry . getMethod ( ) == STORED ) { if ( entry . getSize ( ) == - 1 ) { throw new ZipException ( "uncompressed size is required for STORED method" ) ; } if ( entry . getCrc ( ) == - 1 ) { throw new ZipException ( "crc checksum is required for STORED method" ) ; } entry . setComprSize ( entry . getSize ( ) ) ; } else { def . setLevel ( level ) ; } writeLocalFileHeader ( entry ) ; } public void setComment ( String comment ) { this . comment = comment ; } public void setLevel ( int level ) { this . level = level ; } public void setMethod ( int method ) { this . method = method ; } public void write ( byte [ ] b , int offset , int length ) throws IOException { if ( entry . getMethod ( ) == DEFLATED ) { super . write ( b , offset , length ) ; } else { out . write ( b , offset , length ) ; written += length ; } crc . update ( b , offset , length ) ; } protected static final ZipLong LFH_SIG = new ZipLong ( 0X04034B50L ) ; protected static final ZipLong DD_SIG = new ZipLong ( 0X08074B50L ) ; protected static final ZipLong CFH_SIG = new ZipLong ( 0X02014B50L ) ; protected static final ZipLong EOCD_SIG = new ZipLong ( 0X06054B50L ) ; protected void writeLocalFileHeader ( ZipEntry ze ) throws IOException { offsets . put ( ze , new ZipLong ( written ) ) ; out . write ( LFH_SIG . getBytes ( ) ) ; written += 4 ; if ( ze . getMethod ( ) == DEFLATED ) { out . write ( ( new ZipShort ( 20 ) ) . getBytes ( ) ) ; out . write ( ( new ZipShort ( 8 ) ) . getBytes ( ) ) ; } else { out . write ( ( new ZipShort ( 10 ) ) . getBytes ( ) ) ; out . write ( ZERO ) ; } written += 4 ; out . write ( ( new ZipShort ( ze . getMethod ( ) ) ) . getBytes ( ) ) ; written += 2 ; out . write ( toDosTime ( new Date ( ze . getTime ( ) ) ) . getBytes ( ) ) ; written += 4 ; if ( ze . getMethod ( ) == DEFLATED ) { out . write ( LZERO ) ; out . write ( LZERO ) ; out . write ( LZERO ) ; } else { out . write ( ( new ZipLong ( ze . getCrc ( ) ) ) . getBytes ( ) ) ; out . write ( ( new ZipLong ( ze . getSize ( ) ) ) . getBytes ( ) ) ; out . write ( ( new ZipLong ( ze . getSize ( ) ) ) . getBytes ( ) ) ; } written += 12 ; byte [ ] name = getBytes ( ze . getName ( ) ) ; out . write ( ( new ZipShort ( name . length ) ) . getBytes ( ) ) ; written += 2 ; byte [ ] extra = ze . getLocalFileDataExtra ( ) ; out . write ( ( new ZipShort ( extra . length ) ) . getBytes ( ) ) ; written += 2 ; out . write ( name ) ; written += name . length ; out . write ( extra ) ; written += extra . length ; dataStart = written ; } protected void writeDataDescriptor ( ZipEntry ze ) throws IOException { if ( ze . getMethod ( ) != DEFLATED ) { return ; } out . write ( DD_SIG . getBytes ( ) ) ; out . write ( ( new ZipLong ( entry . getCrc ( ) ) ) . getBytes ( ) ) ; out . write ( ( new ZipLong ( entry . getCompressedSize ( ) ) ) . getBytes ( ) ) ; out . write ( ( new ZipLong ( entry . getSize ( ) ) ) . getBytes ( ) ) ; written += 16 ; } protected void writeCentralFileHeader ( ZipEntry ze ) throws IOException { out . write ( CFH_SIG . getBytes ( ) ) ; written += 4 ; out . write ( ( new ZipShort ( 20 ) ) . getBytes ( ) ) ; written += 2 ; if ( ze . getMethod ( ) == DEFLATED ) { out . write ( ( new ZipShort ( 20 ) ) . getBytes ( ) ) ; out . write ( ( new ZipShort ( 8 ) ) . getBytes ( ) ) ; } else { out . write ( ( new ZipShort ( 10 ) ) . getBytes ( ) ) ; out . write ( ZERO ) ; } written += 4 ; out . write ( ( new ZipShort ( ze . getMethod ( ) ) ) . getBytes ( ) ) ; written += 2 ; out . write ( toDosTime ( new Date ( ze . getTime ( ) ) ) . getBytes ( ) ) ; written += 4 ; out . write ( ( new ZipLong ( ze . getCrc ( ) ) ) . getBytes ( ) ) ; out . write ( ( new ZipLong ( ze . getCompressedSize ( ) ) ) . getBytes ( ) ) ; out . write ( ( new ZipLong ( ze . getSize ( ) ) ) . getBytes ( ) ) ; written += 12 ; byte [ ] name = getBytes ( ze . getName ( ) ) ; out . write ( ( new ZipShort ( name . length ) ) . getBytes ( ) ) ; written += 2 ; byte [ ] extra = ze . getCentralDirectoryExtra ( ) ; out . write ( ( new ZipShort ( extra . length ) ) . getBytes ( ) ) ; written += 2 ; String comm = ze . getComment ( ) ; if ( comm == null ) { comm = "" ; } byte [ ] comment = getBytes ( comm ) ; out . write ( ( new ZipShort ( comment . length ) ) . getBytes ( ) ) ; written += 2 ; out . write ( ZERO ) ; written += 2 ; out . write ( ( new ZipShort ( ze . getInternalAttributes ( ) ) ) . getBytes ( ) ) ; written += 2 ; out . write ( ( new ZipLong ( ze . getExternalAttributes ( ) ) ) . getBytes ( ) ) ; written += 4 ; out . write ( ( ( ZipLong ) offsets . get ( ze ) ) . getBytes ( ) ) ; written += 4 ; out . write ( name ) ; written += name . length ; out . write ( extra ) ; written += extra . length ; out . write ( comment ) ; written += comment . length ; } protected void writeCentralDirectoryEnd ( ) throws IOException { out . write ( EOCD_SIG . getBytes ( ) ) ; out . write ( ZERO ) ; out . write ( ZERO ) ; byte [ ] num = ( new ZipShort ( entries . size ( ) ) ) . getBytes ( ) ; out . write ( num ) ; out . write ( num ) ; out . write ( cdLength . getBytes ( ) ) ; out . write ( cdOffset . getBytes ( ) ) ; byte [ ] data = getBytes ( comment ) ; out . write ( ( new ZipShort ( data . length ) ) . getBytes ( ) ) ; out . write ( data ) ; } private static final ZipLong DOS_TIME_MIN = new ZipLong ( 0x00002100L ) ; protected static ZipLong toDosTime ( Date time ) { int year = time . getYear ( ) + 1900 ; int month = time . getMonth ( ) + 1 ; if ( year < 1980 ) { return DOS_TIME_MIN ; } long value = ( ( year - 1980 ) << 25 ) | ( month << 21 ) | ( time . getDate ( ) << 16 ) | ( time . getHours ( ) << 11 ) | ( time . getMinutes ( ) << 5 ) | ( time . getSeconds ( ) > > 1 ) ; byte [ ] result = new byte [ 4 ] ; result [ 0 ] = ( byte ) ( ( value & 0xFF ) ) ; result [ 1 ] = ( byte ) ( ( value & 0xFF00 ) > > 8 ) ; result [ 2 ] = ( byte ) ( ( value & 0xFF0000 ) > > 16 ) ; result [ 3 ] = ( byte ) ( ( value & 0xFF000000l ) > > 24 ) ; return new ZipLong ( result ) ; } protected byte [ ] getBytes ( String name ) throws ZipException { if ( encoding == null ) { return name . getBytes ( ) ; } else { try { return name . getBytes ( encoding ) ; } catch ( UnsupportedEncodingException uee ) { throw new ZipException ( uee . getMessage ( ) ) ; } } } } 	0	['17', '4', '0', '7', '81', '40', '4', '3', '10', '0.821428571', '1159', '0.904761905', '8', '0.516129032', '0.25', '2', '4', '65.94117647', '2', '0.9412', '0']
package org . apache . tools . zip ; public class UnrecognizedExtraField implements ZipExtraField { private ZipShort headerId ; public void setHeaderId ( ZipShort headerId ) { this . headerId = headerId ; } public ZipShort getHeaderId ( ) { return headerId ; } private byte [ ] localData ; public void setLocalFileDataData ( byte [ ] data ) { localData = data ; } public ZipShort getLocalFileDataLength ( ) { return new ZipShort ( localData . length ) ; } public byte [ ] getLocalFileDataData ( ) { return localData ; } private byte [ ] centralData ; public void setCentralDirectoryData ( byte [ ] data ) { centralData = data ; } public ZipShort getCentralDirectoryLength ( ) { if ( centralData != null ) { return new ZipShort ( centralData . length ) ; } return getLocalFileDataLength ( ) ; } public byte [ ] getCentralDirectoryData ( ) { if ( centralData != null ) { return centralData ; } return getLocalFileDataData ( ) ; } public void parseFromLocalFileData ( byte [ ] data , int offset , int length ) { byte [ ] tmp = new byte [ length ] ; System . arraycopy ( data , offset , tmp , 0 , length ) ; setLocalFileDataData ( tmp ) ; } } 	0	['10', '1', '0', '3', '13', '31', '1', '2', '10', '0.703703704', '76', '1', '1', '0', '0.375', '0', '0', '6.3', '2', '1.1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; public class TaskOutputStream extends OutputStream { private Task task ; private StringBuffer line ; private int msgOutputLevel ; TaskOutputStream ( Task task , int msgOutputLevel ) { this . task = task ; this . msgOutputLevel = msgOutputLevel ; line = new StringBuffer ( ) ; } public void write ( int c ) throws IOException { char cc = ( char ) c ; if ( cc == '\r' || cc == '\n' ) { if ( line . length ( ) > 0 ) { processLine ( ) ; } } else { line . append ( cc ) ; } } private void processLine ( ) { String s = line . toString ( ) ; task . log ( s , msgOutputLevel ) ; line = new StringBuffer ( ) ; } } 	0	['3', '2', '0', '1', '9', '0', '0', '1', '1', '0', '58', '1', '1', '0.714285714', '0.666666667', '1', '1', '17.33333333', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; import java . util . zip . * ; public class GZip extends Task { private File zipFile ; private File source ; public void setZipfile ( File zipFilename ) { zipFile = zipFilename ; } public void setSrc ( File src ) { source = src ; } public void execute ( ) throws BuildException { if ( zipFile == null ) { throw new BuildException ( "zipfile attribute is required" , location ) ; } if ( source == null ) { throw new BuildException ( "src attribute is required" , location ) ; } log ( "Building gzip: " + zipFile . getAbsolutePath ( ) ) ; GZIPOutputStream zOut = null ; try { zOut = new GZIPOutputStream ( new FileOutputStream ( zipFile ) ) ; if ( source . isDirectory ( ) ) { log ( "Cannot Gzip a directory!" , Project . MSG_ERR ) ; } else { zipFile ( source , zOut ) ; } } catch ( IOException ioe ) { String msg = "Problem creating gzip " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } finally { if ( zOut != null ) { try { zOut . close ( ) ; } catch ( IOException e ) { } } } } private void zipFile ( InputStream in , GZIPOutputStream zOut ) throws IOException { byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { zOut . write ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } private void zipFile ( File file , GZIPOutputStream zOut ) throws IOException { FileInputStream fIn = new FileInputStream ( file ) ; try { zipFile ( fIn , zOut ) ; } finally { fIn . close ( ) ; } } } 	0	['6', '3', '0', '3', '24', '11', '0', '3', '4', '0.8', '151', '1', '0', '0.880952381', '0.5', '2', '2', '23.83333333', '1', '0.8333', '0']
package org . apache . tools . ant ; public class Location { private String fileName ; private int lineNumber ; private int columnNumber ; public static final Location UNKNOWN_LOCATION = new Location ( ) ; private Location ( ) { this ( null , 0 , 0 ) ; } public Location ( String fileName ) { this ( fileName , 0 , 0 ) ; } public Location ( String fileName , int lineNumber , int columnNumber ) { this . fileName = fileName ; this . lineNumber = lineNumber ; this . columnNumber = columnNumber ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( fileName != null ) { buf . append ( fileName ) ; if ( lineNumber != 0 ) { buf . append ( ":" ) ; buf . append ( lineNumber ) ; } buf . append ( ": " ) ; } return buf . toString ( ) ; } } 	0	['5', '1', '0', '58', '10', '8', '58', '0', '3', '0.3125', '69', '0.75', '1', '0', '0.583333333', '0', '0', '12', '3', '0.6', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import java . io . IOException ; import java . io . OutputStream ; import java . io . ByteArrayOutputStream ; public class LogOutputStream extends OutputStream { private ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; private boolean skip = false ; private Task task ; private int level = Project . MSG_INFO ; public LogOutputStream ( Task task , int level ) { this . task = task ; this . level = level ; } public void write ( int cc ) throws IOException { final byte c = ( byte ) cc ; if ( ( c == '\n' ) || ( c == '\r' ) ) { if ( ! skip ) processBuffer ( ) ; } else buffer . write ( cc ) ; skip = ( c == '\r' ) ; } protected void processBuffer ( ) { processLine ( buffer . toString ( ) ) ; buffer . reset ( ) ; } protected void processLine ( String line ) { processLine ( line , level ) ; } protected void processLine ( String line , int level ) { task . log ( line , level ) ; } public void close ( ) throws IOException { if ( buffer . size ( ) > 0 ) processBuffer ( ) ; super . close ( ) ; } public int getMessageLevel ( ) { return level ; } } 	0	['7', '2', '1', '7', '15', '1', '6', '1', '4', '0.583333333', '92', '1', '1', '0.454545455', '0.464285714', '1', '1', '11.57142857', '1', '0.8571', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . * ; public class Jvc extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using jvc compiler" , Project . MSG_VERBOSE ) ; Path classpath = new Path ( project ) ; if ( bootclasspath != null ) { classpath . append ( bootclasspath ) ; } addExtdirsToClasspath ( classpath ) ; if ( ( bootclasspath == null ) || ( bootclasspath . size ( ) == 0 ) ) { includeJavaRuntime = true ; } else { } classpath . append ( getCompileClasspath ( ) ) ; classpath . append ( src ) ; Commandline cmd = new Commandline ( ) ; cmd . setExecutable ( "jvc" ) ; if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "/d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "/cp:p" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; cmd . createArgument ( ) . setValue ( "/x-" ) ; cmd . createArgument ( ) . setValue ( "/nomessage" ) ; cmd . createArgument ( ) . setValue ( "/nologo" ) ; if ( debug ) { cmd . createArgument ( ) . setValue ( "/g" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "/O" ) ; } if ( verbose ) { cmd . createArgument ( ) . setValue ( "/verbose" ) ; } int firstFileName = cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } } 	0	['2', '2', '0', '9', '19', '1', '1', '8', '2', '2', '120', '0', '0', '0.958333333', '1', '1', '1', '59', '1', '0.5', '0']
package org . apache . tools . zip ; public class ZipLong implements Cloneable { private long value ; public ZipLong ( long value ) { this . value = value ; } public ZipLong ( byte [ ] bytes ) { this ( bytes , 0 ) ; } public ZipLong ( byte [ ] bytes , int offset ) { value = ( bytes [ offset + 3 ] << 24 ) & 0xFF000000l ; value += ( bytes [ offset + 2 ] << 16 ) & 0xFF0000 ; value += ( bytes [ offset + 1 ] << 8 ) & 0xFF00 ; value += ( bytes [ offset ] & 0xFF ) ; } public byte [ ] getBytes ( ) { byte [ ] result = new byte [ 4 ] ; result [ 0 ] = ( byte ) ( ( value & 0xFF ) ) ; result [ 1 ] = ( byte ) ( ( value & 0xFF00 ) > > 8 ) ; result [ 2 ] = ( byte ) ( ( value & 0xFF0000 ) > > 16 ) ; result [ 3 ] = ( byte ) ( ( value & 0xFF000000l ) > > 24 ) ; return result ; } public long getValue ( ) { return value ; } public boolean equals ( Object o ) { if ( o == null || ! ( o instanceof ZipLong ) ) { return false ; } return value == ( ( ZipLong ) o ) . getValue ( ) ; } public int hashCode ( ) { return ( int ) value ; } } 	0	['7', '1', '0', '2', '8', '0', '2', '0', '7', '0', '147', '1', '0', '0', '0.342857143', '1', '1', '19.85714286', '4', '1', '0']
package org . apache . tools . ant ; import java . io . File ; import java . io . FilenameFilter ; import java . io . IOException ; public class DesirableFilter implements FilenameFilter { public boolean accept ( File dir , String name ) { if ( name . endsWith ( "~" ) ) { return false ; } if ( name . startsWith ( "#" ) && name . endsWith ( "#" ) ) { return false ; } if ( name . startsWith ( "%" ) && name . endsWith ( "%" ) ) { return false ; } if ( name . equals ( "CVS" ) ) { return false ; } if ( name . equals ( ".cvsignore" ) ) { return false ; } if ( name . startsWith ( ".#" ) ) { return false ; } if ( name . equals ( "SCCS" ) ) { return false ; } if ( name . equals ( "vssver.scc" ) ) { return false ; } return true ; } } 	0	['2', '1', '0', '0', '6', '1', '0', '0', '2', '2', '63', '0', '0', '0', '0.666666667', '0', '0', '30.5', '11', '5.5', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import java . util . * ; import org . apache . tools . ant . * ; public class Copyfile extends Task { private File srcFile ; private File destFile ; private boolean filtering = false ; private boolean forceOverwrite = false ; public void setSrc ( File src ) { srcFile = src ; } public void setForceoverwrite ( boolean force ) { forceOverwrite = force ; } public void setDest ( File dest ) { destFile = dest ; } public void setFiltering ( String filter ) { filtering = Project . toBoolean ( filter ) ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The copyfile task is deprecated.  Use copy instead." ) ; if ( srcFile == null ) { throw new BuildException ( "The src attribute must be present." , location ) ; } if ( ! srcFile . exists ( ) ) { throw new BuildException ( "src " + srcFile . toString ( ) + " does not exist." , location ) ; } if ( destFile == null ) { throw new BuildException ( "The dest attribute must be present." , location ) ; } if ( srcFile . equals ( destFile ) ) { log ( "Warning: src == dest" ) ; } if ( forceOverwrite || srcFile . lastModified ( ) > destFile . lastModified ( ) ) { try { project . copyFile ( srcFile , destFile , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Error copying file: " + srcFile . getAbsolutePath ( ) + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg ) ; } } } } 	0	['6', '3', '0', '5', '21', '1', '0', '5', '6', '0.7', '136', '1', '0', '0.880952381', '0.416666667', '2', '2', '21', '1', '0.8333', '0']
package org . apache . tools . ant ; interface Constants { } 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . tools . mail ; import java . io . * ; public class SmtpResponseReader { protected BufferedReader reader = null ; private StringBuffer result = new StringBuffer ( ) ; public SmtpResponseReader ( InputStream in ) { reader = new BufferedReader ( new InputStreamReader ( in ) ) ; } public String getResponse ( ) throws IOException { result . setLength ( 0 ) ; String line = reader . readLine ( ) ; if ( line != null ) { result . append ( line . substring ( 0 , 3 ) ) ; result . append ( " " ) ; } while ( line != null ) { append ( line ) ; if ( ! hasMoreLines ( line ) ) { break ; } line = reader . readLine ( ) ; } return result . toString ( ) . trim ( ) ; } public void close ( ) throws IOException { reader . close ( ) ; } protected boolean hasMoreLines ( String line ) { return line . charAt ( 3 ) == '-' ; } private void append ( String line ) { result . append ( line . substring ( 4 ) ) ; result . append ( " " ) ; } } 	0	['5', '1', '0', '1', '18', '0', '1', '0', '3', '0.5', '96', '1', '0', '0', '0.533333333', '0', '0', '17.8', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; public interface XSLTLiaison { public final static String FILE_PROTOCOL_PREFIX = "file:///" ; public void setStylesheet ( File stylesheet ) throws Exception ; public void addParam ( String name , String expression ) throws Exception ; public void transform ( File infile , File outfile ) throws Exception ; } 	0	['3', '1', '0', '2', '3', '3', '2', '0', '3', '1.5', '4', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . DirectoryScanner ; import java . io . File ; public class ZipScanner extends DirectoryScanner { protected File srcFile ; public void setSrc ( File srcFile ) { this . srcFile = srcFile ; } public String [ ] getIncludedFiles ( ) { String [ ] result = new String [ 1 ] ; result [ 0 ] = srcFile . getAbsolutePath ( ) ; return result ; } public String [ ] getIncludedDirectories ( ) { return new String [ 0 ] ; } public void init ( ) { if ( includes == null ) { includes = new String [ 1 ] ; includes [ 0 ] = "**" ; } if ( excludes == null ) { excludes = new String [ 0 ] ; } } public boolean match ( String path ) { String vpath = path . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; return isIncluded ( vpath ) && ! isExcluded ( vpath ) ; } } 	0	['6', '2', '0', '3', '11', '13', '2', '1', '6', '0.8', '68', '1', '0', '0.924242424', '0.444444444', '1', '5', '10.16666667', '3', '1.5', '0']
package org . apache . tools . tar ; import java . io . * ; public class TarBuffer { public static final int DEFAULT_RCDSIZE = ( 512 ) ; public static final int DEFAULT_BLKSIZE = ( DEFAULT_RCDSIZE * 20 ) ; private InputStream inStream ; private OutputStream outStream ; private byte [ ] blockBuffer ; private int currBlkIdx ; private int currRecIdx ; private int blockSize ; private int recordSize ; private int recsPerBlock ; private boolean debug ; public TarBuffer ( InputStream inStream ) { this ( inStream , TarBuffer . DEFAULT_BLKSIZE ) ; } public TarBuffer ( InputStream inStream , int blockSize ) { this ( inStream , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarBuffer ( InputStream inStream , int blockSize , int recordSize ) { this . inStream = inStream ; this . outStream = null ; this . initialize ( blockSize , recordSize ) ; } public TarBuffer ( OutputStream outStream ) { this ( outStream , TarBuffer . DEFAULT_BLKSIZE ) ; } public TarBuffer ( OutputStream outStream , int blockSize ) { this ( outStream , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarBuffer ( OutputStream outStream , int blockSize , int recordSize ) { this . inStream = null ; this . outStream = outStream ; this . initialize ( blockSize , recordSize ) ; } private void initialize ( int blockSize , int recordSize ) { this . debug = false ; this . blockSize = blockSize ; this . recordSize = recordSize ; this . recsPerBlock = ( this . blockSize / this . recordSize ) ; this . blockBuffer = new byte [ this . blockSize ] ; if ( this . inStream != null ) { this . currBlkIdx = - 1 ; this . currRecIdx = this . recsPerBlock ; } else { this . currBlkIdx = 0 ; this . currRecIdx = 0 ; } } public int getBlockSize ( ) { return this . blockSize ; } public int getRecordSize ( ) { return this . recordSize ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public boolean isEOFRecord ( byte [ ] record ) { for ( int i = 0 , sz = this . getRecordSize ( ) ; i < sz ; ++ i ) { if ( record [ i ] != 0 ) { return false ; } } return true ; } public void skipRecord ( ) throws IOException { if ( this . debug ) { System . err . println ( "SkipRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . inStream == null ) { throw new IOException ( "reading (via skip) from an output buffer" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { if ( ! this . readBlock ( ) ) { return ; } } this . currRecIdx ++ ; } public byte [ ] readRecord ( ) throws IOException { if ( this . debug ) { System . err . println ( "ReadRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . inStream == null ) { throw new IOException ( "reading from an output buffer" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { if ( ! this . readBlock ( ) ) { return null ; } } byte [ ] result = new byte [ this . recordSize ] ; System . arraycopy ( this . blockBuffer , ( this . currRecIdx * this . recordSize ) , result , 0 , this . recordSize ) ; this . currRecIdx ++ ; return result ; } private boolean readBlock ( ) throws IOException { if ( this . debug ) { System . err . println ( "ReadBlock: blkIdx = " + this . currBlkIdx ) ; } if ( this . inStream == null ) { throw new IOException ( "reading from an output buffer" ) ; } this . currRecIdx = 0 ; int offset = 0 ; int bytesNeeded = this . blockSize ; while ( bytesNeeded > 0 ) { long numBytes = this . inStream . read ( this . blockBuffer , offset , bytesNeeded ) ; if ( numBytes == - 1 ) { break ; } offset += numBytes ; bytesNeeded -= numBytes ; if ( numBytes != this . blockSize ) { if ( this . debug ) { System . err . println ( "ReadBlock: INCOMPLETE READ " + numBytes + " of " + this . blockSize + " bytes read." ) ; } } } this . currBlkIdx ++ ; return true ; } public int getCurrentBlockNum ( ) { return this . currBlkIdx ; } public int getCurrentRecordNum ( ) { return this . currRecIdx - 1 ; } public void writeRecord ( byte [ ] record ) throws IOException { if ( this . debug ) { System . err . println ( "WriteRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } if ( record . length != this . recordSize ) { throw new IOException ( "record to write has length '" + record . length + "' which is not the record size of '" + this . recordSize + "'" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { this . writeBlock ( ) ; } System . arraycopy ( record , 0 , this . blockBuffer , ( this . currRecIdx * this . recordSize ) , this . recordSize ) ; this . currRecIdx ++ ; } public void writeRecord ( byte [ ] buf , int offset ) throws IOException { if ( this . debug ) { System . err . println ( "WriteRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } if ( ( offset + this . recordSize ) > buf . length ) { throw new IOException ( "record has length '" + buf . length + "' with offset '" + offset + "' which is less than the record size of '" + this . recordSize + "'" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { this . writeBlock ( ) ; } System . arraycopy ( buf , offset , this . blockBuffer , ( this . currRecIdx * this . recordSize ) , this . recordSize ) ; this . currRecIdx ++ ; } private void writeBlock ( ) throws IOException { if ( this . debug ) { System . err . println ( "WriteBlock: blkIdx = " + this . currBlkIdx ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } this . outStream . write ( this . blockBuffer , 0 , this . blockSize ) ; this . outStream . flush ( ) ; this . currRecIdx = 0 ; this . currBlkIdx ++ ; } private void flushBlock ( ) throws IOException { if ( this . debug ) { System . err . println ( "TarBuffer.flushBlock() called." ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } if ( this . currRecIdx > 0 ) { this . writeBlock ( ) ; } } public void close ( ) throws IOException { if ( this . debug ) { System . err . println ( "TarBuffer.closeBuffer()." ) ; } if ( this . outStream != null ) { this . flushBlock ( ) ; if ( this . outStream != System . out && this . outStream != System . err ) { this . outStream . close ( ) ; this . outStream = null ; } } else if ( this . inStream != null ) { if ( this . inStream != System . in ) { this . inStream . close ( ) ; this . inStream = null ; } } } } 	0	['21', '1', '0', '2', '35', '38', '2', '0', '17', '0.631818182', '617', '0.818181818', '0', '0', '0.293650794', '0', '0', '27.85714286', '3', '0.8571', '0']
package org . apache . tools . ant . types ; import java . util . Stack ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; public abstract class DataType extends ProjectComponent { protected String description = null ; protected Reference ref = null ; protected boolean checked = true ; public void setDescription ( String desc ) { description = desc ; } public String getDescription ( ) { return description ; } public boolean isReference ( ) { return ref != null ; } public void setRefid ( Reference ref ) { this . ref = ref ; checked = false ; } protected void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( checked || ! isReference ( ) ) { return ; } Object o = ref . getReferencedObject ( p ) ; if ( o instanceof DataType ) { if ( stk . contains ( o ) ) { throw circularReference ( ) ; } else { stk . push ( o ) ; ( ( DataType ) o ) . dieOnCircularReference ( stk , p ) ; stk . pop ( ) ; } } checked = true ; } protected Object getCheckedRef ( Class requiredClass , String dataTypeName ) { if ( ! checked ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , getProject ( ) ) ; } Object o = ref . getReferencedObject ( getProject ( ) ) ; if ( ! ( requiredClass . isAssignableFrom ( o . getClass ( ) ) ) ) { String msg = ref . getRefId ( ) + " doesn\'t denote a " + dataTypeName ; throw new BuildException ( msg ) ; } else { return o ; } } protected BuildException tooManyAttributes ( ) { return new BuildException ( "You must not specify more than one attribute" + " when using refid" ) ; } protected BuildException noChildrenAllowed ( ) { return new BuildException ( "You must not specify nested elements when using refid" ) ; } protected BuildException circularReference ( ) { return new BuildException ( "This data type contains a circular reference." ) ; } } 	0	['10', '2', '7', '14', '24', '19', '10', '4', '5', '0.666666667', '146', '1', '1', '0.5', '0.266666667', '0', '0', '13.3', '3', '1.2', '0']
package org . apache . tools . ant ; import java . lang . reflect . * ; import java . util . * ; import java . util . zip . * ; import java . io . * ; import java . net . * ; import org . apache . tools . ant . types . Path ; public class AntClassLoader extends ClassLoader implements BuildListener { private class ResourceEnumeration implements Enumeration { private String resourceName ; private int pathElementsIndex ; private URL nextResource ; ResourceEnumeration ( String name ) { this . resourceName = name ; this . pathElementsIndex = 0 ; findNextResource ( ) ; } public boolean hasMoreElements ( ) { return ( this . nextResource != null ) ; } public Object nextElement ( ) { URL ret = this . nextResource ; findNextResource ( ) ; return ret ; } private void findNextResource ( ) { URL url = null ; while ( ( pathElementsIndex < pathComponents . size ( ) ) && ( url == null ) ) { try { File pathComponent = ( File ) pathComponents . elementAt ( pathElementsIndex ) ; url = getResourceURL ( pathComponent , this . resourceName ) ; pathElementsIndex ++ ; } catch ( BuildException e ) { } } this . nextResource = url ; } } static private final int BUFFER_SIZE = 8192 ; Vector pathComponents = new Vector ( ) ; private Project project ; private boolean parentFirst = true ; private Vector systemPackages = new Vector ( ) ; private Vector loaderPackages = new Vector ( ) ; private boolean ignoreBase = false ; private ClassLoader parent = null ; private Hashtable zipFiles = new Hashtable ( ) ; private ClassLoader savedContextLoader = null ; private boolean isContextLoaderSaved = false ; private static Method getProtectionDomain = null ; private static Method defineClassProtectionDomain = null ; private static Method getContextClassLoader = null ; private static Method setContextClassLoader = null ; static { try { getProtectionDomain = Class . class . getMethod ( "getProtectionDomain" , new Class [ 0 ] ) ; Class protectionDomain = Class . forName ( "java.security.ProtectionDomain" ) ; Class [ ] args = new Class [ ] { String . class , byte [ ] . class , Integer . TYPE , Integer . TYPE , protectionDomain } ; defineClassProtectionDomain = ClassLoader . class . getDeclaredMethod ( "defineClass" , args ) ; getContextClassLoader = Thread . class . getMethod ( "getContextClassLoader" , new Class [ 0 ] ) ; args = new Class [ ] { ClassLoader . class } ; setContextClassLoader = Thread . class . getMethod ( "setContextClassLoader" , args ) ; } catch ( Exception e ) { } } public AntClassLoader ( Project project , Path classpath ) { parent = AntClassLoader . class . getClassLoader ( ) ; this . project = project ; project . addBuildListener ( this ) ; if ( classpath != null ) { Path actualClasspath = classpath . concatSystemClasspath ( "ignore" ) ; String [ ] pathElements = actualClasspath . list ( ) ; for ( int i = 0 ; i < pathElements . length ; ++ i ) { try { addPathElement ( ( String ) pathElements [ i ] ) ; } catch ( BuildException e ) { } } } } public AntClassLoader ( ClassLoader parent , Project project , Path classpath , boolean parentFirst ) { this ( project , classpath ) ; if ( parent != null ) { this . parent = parent ; } this . parentFirst = parentFirst ; addSystemPackageRoot ( "java" ) ; addSystemPackageRoot ( "javax" ) ; } public AntClassLoader ( Project project , Path classpath , boolean parentFirst ) { this ( null , project , classpath , parentFirst ) ; } public AntClassLoader ( ClassLoader parent , boolean parentFirst ) { if ( parent != null ) { this . parent = parent ; } else { parent = AntClassLoader . class . getClassLoader ( ) ; } project = null ; this . parentFirst = parentFirst ; } protected void log ( String message , int priority ) { if ( project != null ) { project . log ( message , priority ) ; } } public void setThreadContextLoader ( ) { if ( isContextLoaderSaved ) { throw new BuildException ( "Context loader has not been reset" ) ; } if ( getContextClassLoader != null && setContextClassLoader != null ) { try { savedContextLoader = ( ClassLoader ) getContextClassLoader . invoke ( Thread . currentThread ( ) , new Object [ 0 ] ) ; Object [ ] args = new Object [ ] { this } ; setContextClassLoader . invoke ( Thread . currentThread ( ) , args ) ; isContextLoaderSaved = true ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; throw new BuildException ( t . toString ( ) ) ; } catch ( Exception e ) { throw new BuildException ( e . toString ( ) ) ; } } } public void resetThreadContextLoader ( ) { if ( isContextLoaderSaved && getContextClassLoader != null && setContextClassLoader != null ) { try { Object [ ] args = new Object [ ] { savedContextLoader } ; setContextClassLoader . invoke ( Thread . currentThread ( ) , args ) ; savedContextLoader = null ; isContextLoaderSaved = false ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; throw new BuildException ( t . toString ( ) ) ; } catch ( Exception e ) { throw new BuildException ( e . toString ( ) ) ; } } } public void addPathElement ( String pathElement ) throws BuildException { File pathComponent = project != null ? project . resolveFile ( pathElement ) : new File ( pathElement ) ; pathComponents . addElement ( pathComponent ) ; } public void setIsolated ( boolean isolated ) { ignoreBase = isolated ; } static public void initializeClass ( Class theClass ) { try { theClass . newInstance ( ) ; } catch ( Throwable t ) { } } public void addSystemPackageRoot ( String packageRoot ) { systemPackages . addElement ( packageRoot + "." ) ; } public void addLoaderPackageRoot ( String packageRoot ) { loaderPackages . addElement ( packageRoot + "." ) ; } public Class forceLoadClass ( String classname ) throws ClassNotFoundException { log ( "force loading " + classname , Project . MSG_DEBUG ) ; Class theClass = findLoadedClass ( classname ) ; if ( theClass == null ) { theClass = findClass ( classname ) ; } return theClass ; } public Class forceLoadSystemClass ( String classname ) throws ClassNotFoundException { log ( "force system loading " + classname , Project . MSG_DEBUG ) ; Class theClass = findLoadedClass ( classname ) ; if ( theClass == null ) { theClass = findBaseClass ( classname ) ; } return theClass ; } public InputStream getResourceAsStream ( String name ) { InputStream resourceStream = null ; if ( isParentFirst ( name ) ) { resourceStream = loadBaseResource ( name ) ; if ( resourceStream != null ) { log ( "ResourceStream for " + name + " loaded from parent loader" , Project . MSG_DEBUG ) ; } else { resourceStream = loadResource ( name ) ; if ( resourceStream != null ) { log ( "ResourceStream for " + name + " loaded from ant loader" , Project . MSG_DEBUG ) ; } } } else { resourceStream = loadResource ( name ) ; if ( resourceStream != null ) { log ( "ResourceStream for " + name + " loaded from ant loader" , Project . MSG_DEBUG ) ; } else { resourceStream = loadBaseResource ( name ) ; if ( resourceStream != null ) { log ( "ResourceStream for " + name + " loaded from parent loader" , Project . MSG_DEBUG ) ; } } } if ( resourceStream == null ) { log ( "Couldn't load ResourceStream for " + name , Project . MSG_DEBUG ) ; } return resourceStream ; } private InputStream loadResource ( String name ) { InputStream stream = null ; for ( Enumeration e = pathComponents . elements ( ) ; e . hasMoreElements ( ) && stream == null ; ) { File pathComponent = ( File ) e . nextElement ( ) ; stream = getResourceStream ( pathComponent , name ) ; } return stream ; } private InputStream loadBaseResource ( String name ) { if ( parent == null ) { return getSystemResourceAsStream ( name ) ; } else { return parent . getResourceAsStream ( name ) ; } } private InputStream getResourceStream ( File file , String resourceName ) { try { if ( ! file . exists ( ) ) { return null ; } if ( file . isDirectory ( ) ) { File resource = new File ( file , resourceName ) ; if ( resource . exists ( ) ) { return new FileInputStream ( resource ) ; } } else { ZipFile zipFile = ( ZipFile ) zipFiles . get ( file ) ; if ( zipFile == null ) { zipFile = new ZipFile ( file ) ; zipFiles . put ( file , zipFile ) ; } ZipEntry entry = zipFile . getEntry ( resourceName ) ; if ( entry != null ) { return zipFile . getInputStream ( entry ) ; } } } catch ( Exception e ) { log ( "Ignoring Exception " + e . getClass ( ) . getName ( ) + ": " + e . getMessage ( ) + " reading resource " + resourceName + " from " + file , Project . MSG_VERBOSE ) ; } return null ; } private boolean isParentFirst ( String resourceName ) { boolean useParentFirst = parentFirst ; for ( Enumeration e = systemPackages . elements ( ) ; e . hasMoreElements ( ) ; ) { String packageName = ( String ) e . nextElement ( ) ; if ( resourceName . startsWith ( packageName ) ) { useParentFirst = true ; break ; } } for ( Enumeration e = loaderPackages . elements ( ) ; e . hasMoreElements ( ) ; ) { String packageName = ( String ) e . nextElement ( ) ; if ( resourceName . startsWith ( packageName ) ) { useParentFirst = false ; break ; } } return useParentFirst ; } public URL getResource ( String name ) { URL url = null ; if ( isParentFirst ( name ) ) { url = ( parent == null ) ? super . getResource ( name ) : parent . getResource ( name ) ; } if ( url != null ) { log ( "Resource " + name + " loaded from parent loader" , Project . MSG_DEBUG ) ; } else { for ( Enumeration e = pathComponents . elements ( ) ; e . hasMoreElements ( ) && url == null ; ) { File pathComponent = ( File ) e . nextElement ( ) ; url = getResourceURL ( pathComponent , name ) ; if ( url != null ) { log ( "Resource " + name + " loaded from ant loader" , Project . MSG_DEBUG ) ; } } } if ( url == null && ! isParentFirst ( name ) ) { url = ( parent == null ) ? super . getResource ( name ) : parent . getResource ( name ) ; if ( url != null ) { log ( "Resource " + name + " loaded from parent loader" , Project . MSG_DEBUG ) ; } } if ( url == null ) { log ( "Couldn't load Resource " + name , Project . MSG_DEBUG ) ; } return url ; } protected Enumeration findResources ( String name ) throws IOException { return new ResourceEnumeration ( name ) ; } private URL getResourceURL ( File file , String resourceName ) { try { if ( ! file . exists ( ) ) { return null ; } if ( file . isDirectory ( ) ) { File resource = new File ( file , resourceName ) ; if ( resource . exists ( ) ) { try { return new URL ( "file:" + resource . toString ( ) ) ; } catch ( MalformedURLException ex ) { return null ; } } } else { ZipFile zipFile = ( ZipFile ) zipFiles . get ( file ) ; if ( zipFile == null ) { zipFile = new ZipFile ( file ) ; zipFiles . put ( file , zipFile ) ; } ZipEntry entry = zipFile . getEntry ( resourceName ) ; if ( entry != null ) { try { return new URL ( "jar:file:" + file . toString ( ) + "!/" + entry ) ; } catch ( MalformedURLException ex ) { return null ; } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; } protected Class loadClass ( String classname , boolean resolve ) throws ClassNotFoundException { Class theClass = findLoadedClass ( classname ) ; if ( theClass != null ) { return theClass ; } if ( isParentFirst ( classname ) ) { try { theClass = findBaseClass ( classname ) ; log ( "Class " + classname + " loaded from parent loader" , Project . MSG_DEBUG ) ; } catch ( ClassNotFoundException cnfe ) { theClass = findClass ( classname ) ; log ( "Class " + classname + " loaded from ant loader" , Project . MSG_DEBUG ) ; } } else { try { theClass = findClass ( classname ) ; log ( "Class " + classname + " loaded from ant loader" , Project . MSG_DEBUG ) ; } catch ( ClassNotFoundException cnfe ) { if ( ignoreBase ) { throw cnfe ; } theClass = findBaseClass ( classname ) ; log ( "Class " + classname + " loaded from parent loader" , Project . MSG_DEBUG ) ; } } if ( resolve ) { resolveClass ( theClass ) ; } return theClass ; } private String getClassFilename ( String classname ) { return classname . replace ( '.' , '/' ) + ".class" ; } private Class getClassFromStream ( InputStream stream , String classname ) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; int bytesRead = - 1 ; byte [ ] buffer = new byte [ BUFFER_SIZE ] ; while ( ( bytesRead = stream . read ( buffer , 0 , BUFFER_SIZE ) ) != - 1 ) { baos . write ( buffer , 0 , bytesRead ) ; } byte [ ] classData = baos . toByteArray ( ) ; if ( defineClassProtectionDomain != null ) { try { Object domain = getProtectionDomain . invoke ( Project . class , new Object [ 0 ] ) ; Object [ ] args = new Object [ ] { classname , classData , new Integer ( 0 ) , new Integer ( classData . length ) , domain } ; return ( Class ) defineClassProtectionDomain . invoke ( this , args ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof ClassFormatError ) { throw ( ClassFormatError ) t ; } else if ( t instanceof NoClassDefFoundError ) { throw ( NoClassDefFoundError ) t ; } else { throw new IOException ( t . toString ( ) ) ; } } catch ( Exception e ) { throw new IOException ( e . toString ( ) ) ; } } else { return defineClass ( classname , classData , 0 , classData . length ) ; } } public Class findClass ( String name ) throws ClassNotFoundException { log ( "Finding class " + name , Project . MSG_DEBUG ) ; return findClassInComponents ( name ) ; } private Class findClassInComponents ( String name ) throws ClassNotFoundException { InputStream stream = null ; String classFilename = getClassFilename ( name ) ; try { for ( Enumeration e = pathComponents . elements ( ) ; e . hasMoreElements ( ) ; ) { File pathComponent = ( File ) e . nextElement ( ) ; try { stream = getResourceStream ( pathComponent , classFilename ) ; if ( stream != null ) { return getClassFromStream ( stream , name ) ; } } catch ( IOException ioe ) { log ( "Exception reading component " + pathComponent , Project . MSG_VERBOSE ) ; } } throw new ClassNotFoundException ( name ) ; } finally { try { if ( stream != null ) { stream . close ( ) ; } } catch ( IOException e ) { } } } private Class findBaseClass ( String name ) throws ClassNotFoundException { if ( parent == null ) { return findSystemClass ( name ) ; } else { return parent . loadClass ( name ) ; } } public void cleanup ( ) { pathComponents = null ; project = null ; for ( Enumeration e = zipFiles . elements ( ) ; e . hasMoreElements ( ) ; ) { ZipFile zipFile = ( ZipFile ) e . nextElement ( ) ; try { zipFile . close ( ) ; } catch ( IOException ioe ) { } } zipFiles = new Hashtable ( ) ; } public void buildStarted ( BuildEvent event ) { } public void buildFinished ( BuildEvent event ) { cleanup ( ) ; } public void targetStarted ( BuildEvent event ) { } public void targetFinished ( BuildEvent event ) { } public void taskStarted ( BuildEvent event ) { } public void taskFinished ( BuildEvent event ) { } public void messageLogged ( BuildEvent event ) { } } 	0	['39', '2', '0', '15', '103', '609', '10', '6', '24', '0.886363636', '1377', '0.636363636', '1', '0.5', '0.184210526', '1', '5', '33.74358974', '12', '1.8462', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; public class Deltree extends Task { private File dir ; public void setDir ( File dir ) { this . dir = dir ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The deltree task is deprecated.  Use delete instead." ) ; if ( dir == null ) { throw new BuildException ( "dir attribute must be set!" , location ) ; } if ( dir . exists ( ) ) { if ( ! dir . isDirectory ( ) ) { if ( ! dir . delete ( ) ) { throw new BuildException ( "Unable to delete directory " + dir . getAbsolutePath ( ) , location ) ; } return ; } log ( "Deleting: " + dir . getAbsolutePath ( ) ) ; try { removeDir ( dir ) ; } catch ( IOException ioe ) { String msg = "Unable to delete " + dir . getAbsolutePath ( ) ; throw new BuildException ( msg , location ) ; } } } private void removeDir ( File dir ) throws IOException { String [ ] list = dir . list ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( dir , s ) ; if ( f . isDirectory ( ) ) { removeDir ( f ) ; } else { if ( ! f . delete ( ) ) { throw new BuildException ( "Unable to delete file " + f . getAbsolutePath ( ) ) ; } } } if ( ! dir . delete ( ) ) { throw new BuildException ( "Unable to delete directory " + dir . getAbsolutePath ( ) ) ; } } } 	0	['4', '3', '0', '3', '17', '4', '0', '3', '3', '0.666666667', '152', '1', '0', '0.925', '0.75', '1', '1', '36.75', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs . optional ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import org . apache . tools . ant . taskdefs . XSLTLiaison ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . Transformer ; import javax . xml . transform . Templates ; import javax . xml . transform . Source ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; public class TraXLiaison implements XSLTLiaison { private TransformerFactory tfactory = null ; private FileInputStream xslStream = null ; private Templates templates = null ; private Transformer transformer = null ; public TraXLiaison ( ) throws Exception { tfactory = TransformerFactory . newInstance ( ) ; } public void setStylesheet ( File stylesheet ) throws Exception { xslStream = new FileInputStream ( stylesheet ) ; StreamSource src = new StreamSource ( xslStream ) ; src . setSystemId ( getSystemId ( stylesheet ) ) ; templates = tfactory . newTemplates ( src ) ; transformer = templates . newTransformer ( ) ; } public void transform ( File infile , File outfile ) throws Exception { FileInputStream fis = null ; FileOutputStream fos = null ; try { fis = new FileInputStream ( infile ) ; fos = new FileOutputStream ( outfile ) ; StreamSource src = new StreamSource ( fis ) ; src . setSystemId ( getSystemId ( infile ) ) ; StreamResult res = new StreamResult ( fos ) ; res . setSystemId ( getSystemId ( outfile ) ) ; transformer . transform ( src , res ) ; } finally { try { if ( xslStream != null ) { xslStream . close ( ) ; } } catch ( IOException ignored ) { } try { if ( fis != null ) { fis . close ( ) ; } } catch ( IOException ignored ) { } try { if ( fos != null ) { fos . close ( ) ; } } catch ( IOException ignored ) { } } } protected String getSystemId ( File file ) { String path = file . getAbsolutePath ( ) ; path = path . replace ( '\\' , '/' ) ; return FILE_PROTOCOL_PREFIX + path ; } public void addParam ( String name , String value ) { transformer . setParameter ( name , value ) ; } } 	0	['5', '1', '0', '1', '24', '0', '0', '1', '4', '0.5625', '147', '1', '0', '0', '0.6', '0', '0', '27.6', '1', '0.8', '0']
package org . apache . tools . ant ; import java . util . Enumeration ; import java . util . Vector ; import org . xml . sax . AttributeList ; import org . xml . sax . helpers . AttributeListImpl ; public class RuntimeConfigurable { private String elementTag = null ; private Vector children = new Vector ( ) ; private Object wrappedObject = null ; private AttributeList attributes ; private StringBuffer characters = new StringBuffer ( ) ; public RuntimeConfigurable ( Object proxy , String elementTag ) { wrappedObject = proxy ; this . elementTag = elementTag ; } void setProxy ( Object proxy ) { wrappedObject = proxy ; } public void setAttributes ( AttributeList attributes ) { this . attributes = new AttributeListImpl ( attributes ) ; } public AttributeList getAttributes ( ) { return attributes ; } public void addChild ( RuntimeConfigurable child ) { children . addElement ( child ) ; } RuntimeConfigurable getChild ( int index ) { return ( RuntimeConfigurable ) children . elementAt ( index ) ; } public void addText ( String data ) { characters . append ( data ) ; } public void addText ( char [ ] buf , int start , int end ) { addText ( new String ( buf , start , end ) ) ; } public String getElementTag ( ) { return elementTag ; } public void maybeConfigure ( Project p ) throws BuildException { String id = null ; if ( attributes != null ) { ProjectHelper . configure ( wrappedObject , attributes , p ) ; id = attributes . getValue ( "id" ) ; attributes = null ; } if ( characters . length ( ) != 0 ) { ProjectHelper . addText ( p , wrappedObject , characters . toString ( ) ) ; characters . setLength ( 0 ) ; } Enumeration enum = children . elements ( ) ; while ( enum . hasMoreElements ( ) ) { RuntimeConfigurable child = ( RuntimeConfigurable ) enum . nextElement ( ) ; child . maybeConfigure ( p ) ; ProjectHelper . storeChild ( p , wrappedObject , child . wrappedObject , child . getElementTag ( ) . toLowerCase ( ) ) ; } if ( id != null ) { p . addReference ( id , wrappedObject ) ; } } } 	0	['10', '1', '0', '9', '30', '17', '6', '3', '8', '0.733333333', '149', '1', '0', '0', '0.25', '0', '0', '13.4', '1', '0.9', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import java . io . File ; import java . util . StringTokenizer ; import java . util . Enumeration ; import java . util . Stack ; import java . util . Vector ; public class FileList extends DataType { private Vector filenames = new Vector ( ) ; private File dir ; public FileList ( ) { super ( ) ; } protected FileList ( FileList filelist ) { this . dir = filelist . dir ; this . filenames = filelist . filenames ; } public void setRefid ( Reference r ) throws BuildException { if ( ( dir != null ) || ( filenames . size ( ) != 0 ) ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public void setDir ( File dir ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . dir = dir ; } public File getDir ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getDir ( p ) ; } return dir ; } public void setFiles ( String filenames ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( filenames != null && filenames . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( filenames , ", \t\n\r\f" , false ) ; while ( tok . hasMoreTokens ( ) ) { this . filenames . addElement ( tok . nextToken ( ) ) ; } } } public String [ ] getFiles ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getFiles ( p ) ; } if ( dir == null ) { throw new BuildException ( "No directory specified for filelist." ) ; } if ( filenames . size ( ) == 0 ) { throw new BuildException ( "No files specified for filelist." ) ; } String result [ ] = new String [ filenames . size ( ) ] ; filenames . copyInto ( result ) ; return result ; } protected FileList getRef ( Project p ) { if ( ! checked ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , p ) ; } Object o = ref . getReferencedObject ( p ) ; if ( ! ( o instanceof FileList ) ) { String msg = ref . getRefId ( ) + " doesn\'t denote a filelist" ; throw new BuildException ( msg ) ; } else { return ( FileList ) o ; } } } 	0	['8', '3', '0', '5', '29', '0', '1', '4', '6', '0.428571429', '177', '1', '0', '0.833333333', '0.3125', '1', '1', '20.875', '5', '2', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; public class Exec extends Task { private String os ; private String out ; private File dir ; private String command ; protected PrintWriter fos = null ; private boolean failOnError = false ; private static final int BUFFER_SIZE = 512 ; public void execute ( ) throws BuildException { run ( command ) ; } protected int run ( String command ) throws BuildException { int err = - 1 ; String myos = System . getProperty ( "os.name" ) ; log ( "Myos = " + myos , Project . MSG_VERBOSE ) ; if ( ( os != null ) && ( os . indexOf ( myos ) < 0 ) ) { log ( "Not found in " + os , Project . MSG_VERBOSE ) ; return 0 ; } if ( dir == null ) dir = project . getBaseDir ( ) ; if ( myos . toLowerCase ( ) . indexOf ( "windows" ) >= 0 ) { if ( ! dir . equals ( project . resolveFile ( "." ) ) ) { if ( myos . toLowerCase ( ) . indexOf ( "nt" ) >= 0 ) { command = "cmd /c cd " + dir + " && " + command ; } else { String ant = project . getProperty ( "ant.home" ) ; if ( ant == null ) { throw new BuildException ( "Property 'ant.home' not found" , location ) ; } String antRun = project . resolveFile ( ant + "/bin/antRun.bat" ) . toString ( ) ; command = antRun + " " + dir + " " + command ; } } } else { String ant = project . getProperty ( "ant.home" ) ; if ( ant == null ) throw new BuildException ( "Property 'ant.home' not found" , location ) ; String antRun = project . resolveFile ( ant + "/bin/antRun" ) . toString ( ) ; command = antRun + " " + dir + " " + command ; } try { log ( command , Project . MSG_VERBOSE ) ; Process proc = Runtime . getRuntime ( ) . exec ( command ) ; if ( out != null ) { fos = new PrintWriter ( new FileWriter ( out ) ) ; log ( "Output redirected to " + out , Project . MSG_VERBOSE ) ; } StreamPumper inputPumper = new StreamPumper ( proc . getInputStream ( ) , Project . MSG_INFO , this ) ; StreamPumper errorPumper = new StreamPumper ( proc . getErrorStream ( ) , Project . MSG_WARN , this ) ; inputPumper . start ( ) ; errorPumper . start ( ) ; proc . waitFor ( ) ; inputPumper . join ( ) ; errorPumper . join ( ) ; proc . destroy ( ) ; logFlush ( ) ; err = proc . exitValue ( ) ; if ( err != 0 ) { if ( failOnError ) { throw new BuildException ( "Exec returned: " + err , location ) ; } else { log ( "Result: " + err , Project . MSG_ERR ) ; } } } catch ( IOException ioe ) { throw new BuildException ( "Error exec: " + command , ioe , location ) ; } catch ( InterruptedException ex ) { } return err ; } public void setDir ( String d ) { this . dir = project . resolveFile ( d ) ; } public void setOs ( String os ) { this . os = os ; } public void setCommand ( String command ) { this . command = command ; } public void setOutput ( String out ) { this . out = out ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } protected void outputLog ( String line , int messageLevel ) { if ( fos == null ) { log ( line , messageLevel ) ; } else { fos . println ( line ) ; } } ; protected void logFlush ( ) { if ( fos != null ) fos . close ( ) ; } class StreamPumper extends Thread { private BufferedReader din ; private int messageLevel ; private boolean endOfStream = false ; private int SLEEP_TIME = 5 ; private Exec parent ; public StreamPumper ( InputStream is , int messageLevel , Exec parent ) { this . din = new BufferedReader ( new InputStreamReader ( is ) ) ; this . messageLevel = messageLevel ; this . parent = parent ; } public void pumpStream ( ) throws IOException { byte [ ] buf = new byte [ BUFFER_SIZE ] ; if ( ! endOfStream ) { String line = din . readLine ( ) ; if ( line != null ) { outputLog ( line , messageLevel ) ; } else { endOfStream = true ; } } } public void run ( ) { try { try { while ( ! endOfStream ) { pumpStream ( ) ; sleep ( SLEEP_TIME ) ; } } catch ( InterruptedException ie ) { } din . close ( ) ; } catch ( IOException ioe ) { } } } } 	0	['10', '3', '0', '6', '41', '21', '1', '6', '7', '0.793650794', '360', '1', '0', '0.804347826', '0.45', '0', '0', '34.3', '2', '1.1', '0']
package org . apache . tools . ant . util ; import java . io . * ; import org . w3c . dom . * ; public class DOMElementWriter { private static String lSep = System . getProperty ( "line.separator" ) ; private StringBuffer sb = new StringBuffer ( ) ; protected String [ ] knownEntities = { "gt" , "amp" , "lt" , "apos" , "quot" } ; public void write ( Element element , Writer out , int indent , String indentWith ) throws IOException { for ( int i = 0 ; i < indent ; i ++ ) { out . write ( indentWith ) ; } out . write ( "<" ) ; out . write ( element . getTagName ( ) ) ; NamedNodeMap attrs = element . getAttributes ( ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { Attr attr = ( Attr ) attrs . item ( i ) ; out . write ( " " ) ; out . write ( attr . getName ( ) ) ; out . write ( "=\"" ) ; out . write ( encode ( attr . getValue ( ) ) ) ; out . write ( "\"" ) ; } out . write ( ">" ) ; boolean hasChildren = false ; NodeList children = element . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node child = children . item ( i ) ; switch ( child . getNodeType ( ) ) { case Node . ELEMENT_NODE : if ( ! hasChildren ) { out . write ( lSep ) ; hasChildren = true ; } write ( ( Element ) child , out , indent + 1 , indentWith ) ; break ; case Node . TEXT_NODE : out . write ( encode ( child . getNodeValue ( ) ) ) ; break ; case Node . CDATA_SECTION_NODE : out . write ( "<![CDATA[" ) ; out . write ( ( ( Text ) child ) . getData ( ) ) ; out . write ( "]]>" ) ; break ; case Node . ENTITY_REFERENCE_NODE : out . write ( '&' ) ; out . write ( child . getNodeName ( ) ) ; out . write ( ';' ) ; break ; case Node . PROCESSING_INSTRUCTION_NODE : out . write ( "<?" ) ; out . write ( child . getNodeName ( ) ) ; String data = child . getNodeValue ( ) ; if ( data != null && data . length ( ) > 0 ) { out . write ( ' ' ) ; out . write ( data ) ; } out . write ( "?>" ) ; break ; } } if ( hasChildren ) { for ( int i = 0 ; i < indent ; i ++ ) { out . write ( indentWith ) ; } } out . write ( "</" ) ; out . write ( element . getTagName ( ) ) ; out . write ( ">" ) ; out . write ( lSep ) ; out . flush ( ) ; } public String encode ( String value ) { sb . setLength ( 0 ) ; for ( int i = 0 ; i < value . length ( ) ; i ++ ) { char c = value . charAt ( i ) ; switch ( c ) { case '<' : sb . append ( "&lt;" ) ; break ; case '>' : sb . append ( "&gt;" ) ; break ; case '\'' : sb . append ( "&apos;" ) ; break ; case '\"' : sb . append ( "&quot;" ) ; break ; case '&' : int nextSemi = value . indexOf ( ";" , i ) ; if ( nextSemi < 0 || ! isReference ( value . substring ( i , nextSemi + 1 ) ) ) { sb . append ( "&amp;" ) ; } else { sb . append ( '&' ) ; } break ; default : sb . append ( c ) ; break ; } } return sb . toString ( ) ; } public boolean isReference ( String ent ) { if ( ! ( ent . charAt ( 0 ) == '&' ) || ! ent . endsWith ( ";" ) ) { return false ; } if ( ent . charAt ( 1 ) == '#' ) { if ( ent . charAt ( 2 ) == 'x' ) { try { Integer . parseInt ( ent . substring ( 3 , ent . length ( ) - 1 ) , 16 ) ; return true ; } catch ( NumberFormatException nfe ) { return false ; } } else { try { Integer . parseInt ( ent . substring ( 2 , ent . length ( ) - 1 ) ) ; return true ; } catch ( NumberFormatException nfe ) { return false ; } } } String name = ent . substring ( 1 , ent . length ( ) - 1 ) ; for ( int i = 0 ; i < knownEntities . length ; i ++ ) { if ( name . equals ( knownEntities [ i ] ) ) { return true ; } } return false ; } } 	0	['5', '1', '0', '1', '36', '4', '1', '0', '4', '0.583333333', '375', '1', '0', '0', '0.5', '0', '0', '73.4', '10', '3.6', '0']
package org . apache . tools . ant . util . regexp ; import org . apache . tools . ant . BuildException ; public class RegexpMatcherFactory { public RegexpMatcherFactory ( ) { } public RegexpMatcher newRegexpMatcher ( ) throws BuildException { String systemDefault = System . getProperty ( "ant.regexp.matcherimpl" ) ; if ( systemDefault != null ) { return createInstance ( systemDefault ) ; } try { return createInstance ( "org.apache.tools.ant.util.regexp.Jdk14RegexpMatcher" ) ; } catch ( BuildException be ) { } try { return createInstance ( "org.apache.tools.ant.util.regexp.JakartaOroMatcher" ) ; } catch ( BuildException be ) { } try { return createInstance ( "org.apache.tools.ant.util.regexp.JakartaRegexpMatcher" ) ; } catch ( BuildException be ) { } throw new BuildException ( "No supported regular expression matcher found" ) ; } protected RegexpMatcher createInstance ( String className ) throws BuildException { try { Class implClass = Class . forName ( className ) ; return ( RegexpMatcher ) implClass . newInstance ( ) ; } catch ( Throwable t ) { throw new BuildException ( t ) ; } } } 	0	['3', '1', '0', '3', '9', '3', '1', '2', '2', '2', '48', '0', '0', '0', '0.666666667', '0', '0', '15', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; import java . util . * ; import java . text . * ; public class Tstamp extends Task { private Vector customFormats = new Vector ( ) ; public void execute ( ) throws BuildException { try { Date d = new Date ( ) ; SimpleDateFormat dstamp = new SimpleDateFormat ( "yyyyMMdd" ) ; project . setProperty ( "DSTAMP" , dstamp . format ( d ) ) ; SimpleDateFormat tstamp = new SimpleDateFormat ( "HHmm" ) ; project . setProperty ( "TSTAMP" , tstamp . format ( d ) ) ; SimpleDateFormat today = new SimpleDateFormat ( "MMMM d yyyy" , Locale . US ) ; project . setProperty ( "TODAY" , today . format ( d ) ) ; Enumeration i = customFormats . elements ( ) ; while ( i . hasMoreElements ( ) ) { CustomFormat cts = ( CustomFormat ) i . nextElement ( ) ; cts . execute ( project , d , location ) ; } } catch ( Exception e ) { throw new BuildException ( e ) ; } } public CustomFormat createFormat ( ) { CustomFormat cts = new CustomFormat ( ) ; customFormats . addElement ( cts ) ; return cts ; } public class CustomFormat { private String propertyName ; private String pattern ; private String language ; private String country ; private String variant ; private int offset = 0 ; private int field = Calendar . DATE ; public CustomFormat ( ) { } public void setProperty ( String propertyName ) { this . propertyName = propertyName ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public void setLocale ( String locale ) { StringTokenizer st = new StringTokenizer ( locale , " \t\n\r\f," ) ; try { language = st . nextToken ( ) ; if ( st . hasMoreElements ( ) ) { country = st . nextToken ( ) ; if ( st . hasMoreElements ( ) ) { country = st . nextToken ( ) ; if ( st . hasMoreElements ( ) ) { throw new BuildException ( "bad locale format" , getLocation ( ) ) ; } } } else { country = "" ; } } catch ( NoSuchElementException e ) { throw new BuildException ( "bad locale format" , e , getLocation ( ) ) ; } } public void setOffset ( int offset ) { this . offset = offset ; } public void setUnit ( String unit ) { if ( unit . equalsIgnoreCase ( "millisecond" ) ) { field = Calendar . MILLISECOND ; } else if ( unit . equalsIgnoreCase ( "second" ) ) { field = Calendar . SECOND ; } else if ( unit . equalsIgnoreCase ( "minute" ) ) { field = Calendar . MINUTE ; } else if ( unit . equalsIgnoreCase ( "hour" ) ) { field = Calendar . HOUR_OF_DAY ; } else if ( unit . equalsIgnoreCase ( "day" ) ) { field = Calendar . DATE ; } else if ( unit . equalsIgnoreCase ( "week" ) ) { field = Calendar . WEEK_OF_YEAR ; } else if ( unit . equalsIgnoreCase ( "month" ) ) { field = Calendar . MONTH ; } else if ( unit . equalsIgnoreCase ( "year" ) ) { field = Calendar . YEAR ; } else { throw new BuildException ( unit + " is not a unit supported by the tstamp task" , getLocation ( ) ) ; } } public void execute ( Project project , Date date , Location location ) { if ( propertyName == null ) { throw new BuildException ( "property attribute must be provided" , location ) ; } if ( pattern == null ) { throw new BuildException ( "pattern attribute must be provided" , location ) ; } SimpleDateFormat sdf ; if ( language == null ) { sdf = new SimpleDateFormat ( pattern ) ; } else if ( variant == null ) { sdf = new SimpleDateFormat ( pattern , new Locale ( language , country ) ) ; } else { sdf = new SimpleDateFormat ( pattern , new Locale ( language , country , variant ) ) ; } if ( offset != 0 ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( date ) ; calendar . add ( field , offset ) ; date = calendar . getTime ( ) ; } project . setProperty ( propertyName , sdf . format ( date ) ) ; } } } 	0	['3', '3', '0', '6', '17', '0', '1', '6', '3', '0', '91', '1', '0', '0.948717949', '1', '0', '0', '29', '1', '0.6667', '0']
package org . apache . tools . tar ; public interface TarConstants { public static final int NAMELEN = 100 ; public static final int MODELEN = 8 ; public static final int UIDLEN = 8 ; public static final int GIDLEN = 8 ; public static final int CHKSUMLEN = 8 ; public static final int SIZELEN = 12 ; public static final int MAGICLEN = 8 ; public static final int MODTIMELEN = 12 ; public static final int UNAMELEN = 32 ; public static final int GNAMELEN = 32 ; public static final int DEVLEN = 8 ; public static final byte LF_OLDNORM = 0 ; public static final byte LF_NORMAL = ( byte ) '0' ; public static final byte LF_LINK = ( byte ) '1' ; public static final byte LF_SYMLINK = ( byte ) '2' ; public static final byte LF_CHR = ( byte ) '3' ; public static final byte LF_BLK = ( byte ) '4' ; public static final byte LF_DIR = ( byte ) '5' ; public static final byte LF_FIFO = ( byte ) '6' ; public static final byte LF_CONTIG = ( byte ) '7' ; public static final String TMAGIC = "ustar" ; public static final String GNU_TMAGIC = "ustar  " ; public static final String GNU_LONGLINK = "././@LongLink" ; public static final byte LF_GNUTYPE_LONGNAME = ( byte ) 'L' ; } 	0	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '24', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . tools . ant ; import java . lang . reflect . * ; import java . util . * ; public class TaskAdapter extends Task { Object proxy ; public void execute ( ) throws BuildException { Method setProjectM = null ; try { Class c = proxy . getClass ( ) ; setProjectM = c . getMethod ( "setProject" , new Class [ ] { Project . class } ) ; if ( setProjectM != null ) { setProjectM . invoke ( proxy , new Object [ ] { project } ) ; } } catch ( Exception ex ) { log ( "Error setting project in " + proxy . getClass ( ) , Project . MSG_ERR ) ; throw new BuildException ( ex ) ; } Method executeM = null ; try { Class c = proxy . getClass ( ) ; executeM = c . getMethod ( "execute" , new Class [ 0 ] ) ; if ( executeM == null ) { log ( "No execute in " + proxy . getClass ( ) , Project . MSG_ERR ) ; throw new BuildException ( "No execute in " + proxy . getClass ( ) ) ; } executeM . invoke ( proxy , null ) ; return ; } catch ( Exception ex ) { log ( "Error in " + proxy . getClass ( ) , Project . MSG_ERR ) ; throw new BuildException ( ex ) ; } } public void setProxy ( Object o ) { this . proxy = o ; } public Object getProxy ( ) { return this . proxy ; } } 	0	['5', '3', '0', '7', '19', '4', '4', '4', '4', '0.75', '151', '0', '0', '0.902439024', '0.4', '1', '1', '28.8', '1', '0.8', '0']
package org . apache . tools . ant . taskdefs . rmic ; import org . apache . tools . ant . * ; import org . apache . tools . ant . taskdefs . * ; import org . apache . tools . ant . types . * ; import org . apache . tools . ant . util . * ; import java . io . File ; import java . util . Random ; import java . util . Vector ; public abstract class DefaultRmicAdapter implements RmicAdapter { private Rmic attributes ; private FileNameMapper mapper ; public DefaultRmicAdapter ( ) { } public void setRmic ( Rmic attributes ) { this . attributes = attributes ; mapper = new RmicFileNameMapper ( ) ; } public Rmic getRmic ( ) { return attributes ; } protected String getStubClassSuffix ( ) { return "_Stub" ; } protected String getSkelClassSuffix ( ) { return "_Skel" ; } protected String getTieClassSuffix ( ) { return "_Tie" ; } public FileNameMapper getMapper ( ) { return mapper ; } public Path getClasspath ( ) { return getCompileClasspath ( ) ; } protected Path getCompileClasspath ( ) { Path classpath = new Path ( attributes . getProject ( ) ) ; classpath . setLocation ( attributes . getBase ( ) ) ; if ( attributes . getClasspath ( ) == null ) { if ( attributes . getIncludeantruntime ( ) ) { classpath . addExisting ( Path . systemClasspath ) ; } } else { if ( attributes . getIncludeantruntime ( ) ) { classpath . addExisting ( attributes . getClasspath ( ) . concatSystemClasspath ( "last" ) ) ; } else { classpath . addExisting ( attributes . getClasspath ( ) . concatSystemClasspath ( "ignore" ) ) ; } } if ( attributes . getIncludejavaruntime ( ) ) { if ( System . getProperty ( "java.vendor" ) . toLowerCase ( ) . indexOf ( "microsoft" ) >= 0 ) { FileSet msZipFiles = new FileSet ( ) ; msZipFiles . setDir ( new File ( System . getProperty ( "java.home" ) + File . separator + "Packages" ) ) ; msZipFiles . setIncludes ( "*.ZIP" ) ; classpath . addFileset ( msZipFiles ) ; } else if ( Project . getJavaVersion ( ) == Project . JAVA_1_1 ) { classpath . addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + "classes.zip" ) ) ; } else if ( System . getProperty ( "java.vm.name" ) . equals ( "Kaffe" ) ) { FileSet kaffeJarFiles = new FileSet ( ) ; kaffeJarFiles . setDir ( new File ( System . getProperty ( "java.home" ) + File . separator + "share" + File . separator + "kaffe" ) ) ; kaffeJarFiles . setIncludes ( "*.jar" ) ; classpath . addFileset ( kaffeJarFiles ) ; } else { classpath . addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + "rt.jar" ) ) ; classpath . addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "jre" + File . separator + "lib" + File . separator + "rt.jar" ) ) ; classpath . addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + ".." + File . separator + "Classes" + File . separator + "classes.jar" ) ) ; classpath . addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + ".." + File . separator + "Classes" + File . separator + "ui.jar" ) ) ; } } return classpath ; } protected Commandline setupRmicCommand ( ) { return setupRmicCommand ( null ) ; } protected Commandline setupRmicCommand ( String [ ] options ) { Commandline cmd = new Commandline ( ) ; if ( options != null ) { for ( int i = 0 ; i < options . length ; i ++ ) { cmd . createArgument ( ) . setValue ( options [ i ] ) ; } } Path classpath = getCompileClasspath ( ) ; cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( attributes . getBase ( ) ) ; if ( attributes . getExtdirs ( ) != null ) { if ( Project . getJavaVersion ( ) . startsWith ( "1.1" ) ) { addExtdirsToClasspath ( classpath ) ; } else { cmd . createArgument ( ) . setValue ( "-extdirs" ) ; cmd . createArgument ( ) . setPath ( attributes . getExtdirs ( ) ) ; } } cmd . createArgument ( ) . setValue ( "-classpath" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; String stubVersion = attributes . getStubVersion ( ) ; if ( null != stubVersion ) { if ( "1.1" . equals ( stubVersion ) ) cmd . createArgument ( ) . setValue ( "-v1.1" ) ; else if ( "1.2" . equals ( stubVersion ) ) cmd . createArgument ( ) . setValue ( "-v1.2" ) ; else cmd . createArgument ( ) . setValue ( "-vcompat" ) ; } if ( null != attributes . getSourceBase ( ) ) { cmd . createArgument ( ) . setValue ( "-keepgenerated" ) ; } if ( attributes . getIiop ( ) ) { attributes . log ( "IIOP has been turned on." , Project . MSG_INFO ) ; cmd . createArgument ( ) . setValue ( "-iiop" ) ; if ( attributes . getIiopopts ( ) != null ) { attributes . log ( "IIOP Options: " + attributes . getIiopopts ( ) , Project . MSG_INFO ) ; cmd . createArgument ( ) . setValue ( attributes . getIiopopts ( ) ) ; } } if ( attributes . getIdl ( ) ) { cmd . createArgument ( ) . setValue ( "-idl" ) ; attributes . log ( "IDL has been turned on." , Project . MSG_INFO ) ; if ( attributes . getIdlopts ( ) != null ) { cmd . createArgument ( ) . setValue ( attributes . getIdlopts ( ) ) ; attributes . log ( "IDL Options: " + attributes . getIdlopts ( ) , Project . MSG_INFO ) ; } } if ( attributes . getDebug ( ) ) { cmd . createArgument ( ) . setValue ( "-g" ) ; } logAndAddFilesToCompile ( cmd ) ; return cmd ; } protected void logAndAddFilesToCompile ( Commandline cmd ) { Vector compileList = attributes . getCompileList ( ) ; attributes . log ( "Compilation args: " + cmd . toString ( ) , Project . MSG_VERBOSE ) ; StringBuffer niceSourceList = new StringBuffer ( "File" ) ; if ( compileList . size ( ) != 1 ) { niceSourceList . append ( "s" ) ; } niceSourceList . append ( " to be compiled:" ) ; for ( int i = 0 ; i < compileList . size ( ) ; i ++ ) { String arg = ( String ) compileList . elementAt ( i ) ; cmd . createArgument ( ) . setValue ( arg ) ; niceSourceList . append ( "    " + arg ) ; } attributes . log ( niceSourceList . toString ( ) , Project . MSG_VERBOSE ) ; } protected void addExtdirsToClasspath ( Path classpath ) { Path extdirs = attributes . getExtdirs ( ) ; if ( extdirs == null ) { String extProp = System . getProperty ( "java.ext.dirs" ) ; if ( extProp != null ) { extdirs = new Path ( attributes . getProject ( ) , extProp ) ; } else { return ; } } String [ ] dirs = extdirs . list ( ) ; for ( int i = 0 ; i < dirs . length ; i ++ ) { if ( ! dirs [ i ] . endsWith ( File . separator ) ) { dirs [ i ] += File . separator ; } File dir = attributes . getProject ( ) . resolveFile ( dirs [ i ] ) ; FileSet fs = new FileSet ( ) ; fs . setDir ( dir ) ; fs . setIncludes ( "*" ) ; classpath . addFileset ( fs ) ; } } private final static Random rand = new Random ( ) ; private class RmicFileNameMapper implements FileNameMapper { RmicFileNameMapper ( ) { } public void setFrom ( String s ) { } public void setTo ( String s ) { } public String [ ] mapFileName ( String name ) { if ( name == null || ! name . endsWith ( ".class" ) || name . endsWith ( getStubClassSuffix ( ) + ".class" ) || name . endsWith ( getSkelClassSuffix ( ) + ".class" ) || name . endsWith ( getTieClassSuffix ( ) + ".class" ) ) { return null ; } String base = name . substring ( 0 , name . indexOf ( ".class" ) ) ; String classname = base . replace ( File . separatorChar , '.' ) ; if ( attributes . getVerify ( ) && ! attributes . isValidRmiRemote ( classname ) ) { return null ; } String [ ] target = new String [ ] { name + ".tmp." + rand . nextLong ( ) } ; if ( ! attributes . getIiop ( ) && ! attributes . getIdl ( ) ) { if ( "1.2" . equals ( attributes . getStubVersion ( ) ) ) { target = new String [ ] { base + getStubClassSuffix ( ) + ".class" } ; } else { target = new String [ ] { base + getStubClassSuffix ( ) + ".class" , base + getSkelClassSuffix ( ) + ".class" , } ; } } else if ( ! attributes . getIdl ( ) ) { int lastSlash = base . lastIndexOf ( File . separatorChar ) ; String dirname = "" ; int index = - 1 ; if ( lastSlash == - 1 ) { index = 0 ; } else { index = lastSlash + 1 ; dirname = base . substring ( 0 , index ) ; } String filename = base . substring ( index ) ; try { Class c = attributes . getLoader ( ) . loadClass ( classname ) ; if ( c . isInterface ( ) ) { target = new String [ ] { dirname + "_" + filename + getStubClassSuffix ( ) + ".class" } ; } else { Class interf = attributes . getRemoteInterface ( c ) ; String iName = interf . getName ( ) ; String iDir = "" ; int iIndex = - 1 ; int lastDot = iName . lastIndexOf ( "." ) ; if ( lastDot == - 1 ) { iIndex = 0 ; } else { iIndex = lastDot + 1 ; iDir = iName . substring ( 0 , iIndex ) ; iDir = iDir . replace ( '.' , File . separatorChar ) ; } target = new String [ ] { dirname + "_" + filename + getTieClassSuffix ( ) + ".class" , iDir + "_" + iName . substring ( iIndex ) + getStubClassSuffix ( ) + ".class" } ; } } catch ( ClassNotFoundException e ) { attributes . log ( "Unable to verify class " + classname + ". It could not be found." , Project . MSG_WARN ) ; } catch ( NoClassDefFoundError e ) { attributes . log ( "Unable to verify class " + classname + ". It is not defined." , Project . MSG_WARN ) ; } catch ( Throwable t ) { attributes . log ( "Unable to verify class " + classname + ". Loading caused Exception: " + t . getMessage ( ) , Project . MSG_WARN ) ; } } return target ; } } } 	0	['17', '1', '3', '15', '66', '90', '4', '12', '6', '0.791666667', '630', '1', '2', '0', '0.197916667', '0', '0', '35.88235294', '14', '2.4118', '0']
package org . apache . tools . ant ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . ant . types . EnumeratedAttribute ; import java . lang . reflect . * ; import java . io . File ; import java . util . * ; public class IntrospectionHelper implements BuildListener { private Hashtable attributeTypes ; private Hashtable attributeSetters ; private Hashtable nestedTypes ; private Hashtable nestedCreators ; private Hashtable nestedStorers ; private Method addText = null ; private Class bean ; private static Hashtable helpers = new Hashtable ( ) ; private IntrospectionHelper ( final Class bean ) { attributeTypes = new Hashtable ( ) ; attributeSetters = new Hashtable ( ) ; nestedTypes = new Hashtable ( ) ; nestedCreators = new Hashtable ( ) ; nestedStorers = new Hashtable ( ) ; this . bean = bean ; Method [ ] methods = bean . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { final Method m = methods [ i ] ; final String name = m . getName ( ) ; Class returnType = m . getReturnType ( ) ; Class [ ] args = m . getParameterTypes ( ) ; if ( org . apache . tools . ant . Task . class . isAssignableFrom ( bean ) && args . length == 1 && ( ( "setLocation" . equals ( name ) && org . apache . tools . ant . Location . class . equals ( args [ 0 ] ) ) || ( "setTaskType" . equals ( name ) && java . lang . String . class . equals ( args [ 0 ] ) ) ) ) { continue ; } if ( org . apache . tools . ant . TaskContainer . class . isAssignableFrom ( bean ) && args . length == 1 && "addTask" . equals ( name ) && org . apache . tools . ant . Task . class . equals ( args [ 0 ] ) ) { continue ; } if ( "addText" . equals ( name ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && java . lang . String . class . equals ( args [ 0 ] ) ) { addText = methods [ i ] ; } else if ( name . startsWith ( "set" ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && ! args [ 0 ] . isArray ( ) ) { String propName = getPropertyName ( name , "set" ) ; AttributeSetter as = createAttributeSetter ( m , args [ 0 ] ) ; if ( as != null ) { attributeTypes . put ( propName , args [ 0 ] ) ; attributeSetters . put ( propName , as ) ; } } else if ( name . startsWith ( "create" ) && ! returnType . isArray ( ) && ! returnType . isPrimitive ( ) && args . length == 0 ) { String propName = getPropertyName ( name , "create" ) ; nestedTypes . put ( propName , returnType ) ; nestedCreators . put ( propName , new NestedCreator ( ) { public Object create ( Object parent ) throws InvocationTargetException , IllegalAccessException { return m . invoke ( parent , new Object [ ] { } ) ; } } ) ; } else if ( name . startsWith ( "addConfigured" ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && ! java . lang . String . class . equals ( args [ 0 ] ) && ! args [ 0 ] . isArray ( ) && ! args [ 0 ] . isPrimitive ( ) ) { try { final Constructor c = args [ 0 ] . getConstructor ( new Class [ ] { } ) ; String propName = getPropertyName ( name , "addConfigured" ) ; nestedTypes . put ( propName , args [ 0 ] ) ; nestedCreators . put ( propName , new NestedCreator ( ) { public Object create ( Object parent ) throws InvocationTargetException , IllegalAccessException , InstantiationException { Object o = c . newInstance ( new Object [ ] { } ) ; return o ; } } ) ; nestedStorers . put ( propName , new NestedStorer ( ) { public void store ( Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException { m . invoke ( parent , new Object [ ] { child } ) ; } } ) ; } catch ( NoSuchMethodException nse ) { } } else if ( name . startsWith ( "add" ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && ! java . lang . String . class . equals ( args [ 0 ] ) && ! args [ 0 ] . isArray ( ) && ! args [ 0 ] . isPrimitive ( ) ) { try { final Constructor c = args [ 0 ] . getConstructor ( new Class [ ] { } ) ; String propName = getPropertyName ( name , "add" ) ; nestedTypes . put ( propName , args [ 0 ] ) ; nestedCreators . put ( propName , new NestedCreator ( ) { public Object create ( Object parent ) throws InvocationTargetException , IllegalAccessException , InstantiationException { Object o = c . newInstance ( new Object [ ] { } ) ; m . invoke ( parent , new Object [ ] { o } ) ; return o ; } } ) ; } catch ( NoSuchMethodException nse ) { } } } } public synchronized static IntrospectionHelper getHelper ( Class c ) { IntrospectionHelper ih = ( IntrospectionHelper ) helpers . get ( c ) ; if ( ih == null ) { ih = new IntrospectionHelper ( c ) ; helpers . put ( c , ih ) ; } return ih ; } public void setAttribute ( Project p , Object element , String attributeName , String value ) throws BuildException { AttributeSetter as = ( AttributeSetter ) attributeSetters . get ( attributeName ) ; if ( as == null ) { String msg = getElementName ( p , element ) + " doesn't support the \"" + attributeName + "\" attribute." ; throw new BuildException ( msg ) ; } try { as . set ( p , element , value ) ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public void addText ( Project project , Object element , String text ) { if ( addText == null ) { String msg = getElementName ( project , element ) + " doesn't support nested text data." ; throw new BuildException ( msg ) ; } try { addText . invoke ( element , new String [ ] { text } ) ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public Object createElement ( Project project , Object element , String elementName ) throws BuildException { NestedCreator nc = ( NestedCreator ) nestedCreators . get ( elementName ) ; if ( nc == null ) { String msg = getElementName ( project , element ) + " doesn't support the nested \"" + elementName + "\" element." ; throw new BuildException ( msg ) ; } try { Object nestedElement = nc . create ( element ) ; if ( nestedElement instanceof DataType ) { ( ( DataType ) nestedElement ) . setProject ( project ) ; } return nestedElement ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InstantiationException ine ) { throw new BuildException ( ine ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public void storeElement ( Project project , Object element , Object child , String elementName ) throws BuildException { if ( elementName == null ) { return ; } NestedStorer ns = ( NestedStorer ) nestedStorers . get ( elementName ) ; if ( ns == null ) { return ; } try { ns . store ( element , child ) ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InstantiationException ine ) { throw new BuildException ( ine ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public Class getElementType ( String elementName ) throws BuildException { Class nt = ( Class ) nestedTypes . get ( elementName ) ; if ( nt == null ) { String msg = "Class " + bean . getName ( ) + " doesn't support the nested \"" + elementName + "\" element." ; throw new BuildException ( msg ) ; } return nt ; } public Class getAttributeType ( String attributeName ) throws BuildException { Class at = ( Class ) attributeTypes . get ( attributeName ) ; if ( at == null ) { String msg = "Class " + bean . getName ( ) + " doesn't support the \"" + attributeName + "\" attribute." ; throw new BuildException ( msg ) ; } return at ; } public boolean supportsCharacters ( ) { return addText != null ; } public Enumeration getAttributes ( ) { return attributeSetters . keys ( ) ; } public Enumeration getNestedElements ( ) { return nestedTypes . keys ( ) ; } private AttributeSetter createAttributeSetter ( final Method m , final Class arg ) { if ( java . lang . String . class . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new String [ ] { value } ) ; } } ; } else if ( java . lang . Character . class . equals ( arg ) || java . lang . Character . TYPE . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Character [ ] { new Character ( value . charAt ( 0 ) ) } ) ; } } ; } else if ( java . lang . Byte . TYPE . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Byte [ ] { new Byte ( value ) } ) ; } } ; } else if ( java . lang . Short . TYPE . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Short [ ] { new Short ( value ) } ) ; } } ; } else if ( java . lang . Integer . TYPE . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Integer [ ] { new Integer ( value ) } ) ; } } ; } else if ( java . lang . Long . TYPE . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Long [ ] { new Long ( value ) } ) ; } } ; } else if ( java . lang . Float . TYPE . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Float [ ] { new Float ( value ) } ) ; } } ; } else if ( java . lang . Double . TYPE . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Double [ ] { new Double ( value ) } ) ; } } ; } else if ( java . lang . Boolean . class . equals ( arg ) || java . lang . Boolean . TYPE . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Boolean [ ] { new Boolean ( Project . toBoolean ( value ) ) } ) ; } } ; } else if ( java . lang . Class . class . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException { try { m . invoke ( parent , new Class [ ] { Class . forName ( value ) } ) ; } catch ( ClassNotFoundException ce ) { throw new BuildException ( ce ) ; } } } ; } else if ( java . io . File . class . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new File [ ] { p . resolveFile ( value ) } ) ; } } ; } else if ( org . apache . tools . ant . types . Path . class . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Path [ ] { new Path ( p , value ) } ) ; } } ; } else if ( org . apache . tools . ant . types . EnumeratedAttribute . class . isAssignableFrom ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException { try { org . apache . tools . ant . types . EnumeratedAttribute ea = ( org . apache . tools . ant . types . EnumeratedAttribute ) arg . newInstance ( ) ; ea . setValue ( value ) ; m . invoke ( parent , new EnumeratedAttribute [ ] { ea } ) ; } catch ( InstantiationException ie ) { throw new BuildException ( ie ) ; } } } ; } else { try { final Constructor c = arg . getConstructor ( new Class [ ] { java . lang . String . class } ) ; return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException { try { Object attribute = c . newInstance ( new String [ ] { value } ) ; if ( attribute instanceof DataType ) { ( ( DataType ) attribute ) . setProject ( p ) ; } m . invoke ( parent , new Object [ ] { attribute } ) ; } catch ( InstantiationException ie ) { throw new BuildException ( ie ) ; } } } ; } catch ( NoSuchMethodException nme ) { } } return null ; } protected String getElementName ( Project project , Object element ) { Hashtable elements = project . getTaskDefinitions ( ) ; String typeName = "task" ; if ( ! elements . contains ( element . getClass ( ) ) ) { elements = project . getDataTypeDefinitions ( ) ; typeName = "data type" ; if ( ! elements . contains ( element . getClass ( ) ) ) { elements = null ; } } if ( elements != null ) { Enumeration e = elements . keys ( ) ; while ( e . hasMoreElements ( ) ) { String elementName = ( String ) e . nextElement ( ) ; Class elementClass = ( Class ) elements . get ( elementName ) ; if ( element . getClass ( ) . equals ( elementClass ) ) { return "The <" + elementName + "> " + typeName ; } } } return "Class " + element . getClass ( ) . getName ( ) ; } private String getPropertyName ( String methodName , String prefix ) { int start = prefix . length ( ) ; return methodName . substring ( start ) . toLowerCase ( ) ; } private interface NestedCreator { public Object create ( Object parent ) throws InvocationTargetException , IllegalAccessException , InstantiationException ; } private interface NestedStorer { public void store ( Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException ; } private interface AttributeSetter { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException ; } public void buildStarted ( BuildEvent event ) { } public void buildFinished ( BuildEvent event ) { attributeTypes . clear ( ) ; attributeSetters . clear ( ) ; nestedTypes . clear ( ) ; nestedCreators . clear ( ) ; addText = null ; helpers . clear ( ) ; } public void targetStarted ( BuildEvent event ) { } public void targetFinished ( BuildEvent event ) { } public void taskStarted ( BuildEvent event ) { } public void taskFinished ( BuildEvent event ) { } public void messageLogged ( BuildEvent event ) { } } 	0	['23', '1', '0', '31', '82', '201', '22', '27', '17', '0.893939394', '1093', '0.444444444', '0', '0', '0.318181818', '0', '0', '45.73913043', '24', '2.3043', '0']
package org . apache . tools . ant ; public class NoBannerLogger extends DefaultLogger { protected String targetName ; public void targetStarted ( BuildEvent event ) { targetName = event . getTarget ( ) . getName ( ) ; } public void targetFinished ( BuildEvent event ) { targetName = null ; } public void messageLogged ( BuildEvent event ) { if ( event . getPriority ( ) > msgOutputLevel || null == event . getMessage ( ) || "" . equals ( event . getMessage ( ) . trim ( ) ) ) { return ; } if ( null != targetName ) { out . println ( lSep + targetName + ":" ) ; targetName = null ; } super . messageLogged ( event ) ; } } 	0	['4', '2', '0', '3', '16', '0', '0', '3', '4', '0.333333333', '59', '1', '0', '0.842105263', '0.875', '1', '1', '13.5', '5', '1.75', '0']
