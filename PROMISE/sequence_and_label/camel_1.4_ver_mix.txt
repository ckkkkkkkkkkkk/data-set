package org . apache . camel . component . cxf . feature ; import java . util . concurrent . Executor ; import org . apache . camel . component . cxf . MessageInvoker ; import org . apache . cxf . endpoint . Endpoint ; import org . apache . cxf . message . Exchange ; import org . apache . cxf . message . Message ; import org . apache . cxf . phase . AbstractPhaseInterceptor ; import org . apache . cxf . phase . Phase ; import org . apache . cxf . service . Service ; public class MessageInvokerInterceptor extends AbstractPhaseInterceptor < Message > { public MessageInvokerInterceptor ( ) { super ( Phase . INVOKE ) ; } public void handleMessage ( final Message message ) { final Exchange exchange = message . getExchange ( ) ; final Endpoint endpoint = exchange . get ( Endpoint . class ) ; final Service service = endpoint . getService ( ) ; final MessageInvoker invoker = ( MessageInvoker ) service . getInvoker ( ) ; Runnable invocation = new Runnable ( ) { public void run ( ) { Exchange runableEx = message . getExchange ( ) ; invoker . invoke ( runableEx ) ; if ( ! exchange . isOneWay ( ) ) { Endpoint ep = exchange . get ( Endpoint . class ) ; Message outMessage = runableEx . getOutMessage ( ) ; copyJaxwsProperties ( message , outMessage ) ; if ( outMessage == null ) { outMessage = ep . getBinding ( ) . createMessage ( ) ; exchange . setOutMessage ( outMessage ) ; } } } } ; Executor executor = getExecutor ( endpoint ) ; if ( exchange . get ( Executor . class ) == executor ) { invocation . run ( ) ; } else { exchange . put ( Executor . class , executor ) ; executor . execute ( invocation ) ; } } private Executor getExecutor ( final Endpoint endpoint ) { return endpoint . getService ( ) . getExecutor ( ) ; } private void copyJaxwsProperties ( Message inMsg , Message outMsg ) { outMsg . put ( Message . WSDL_OPERATION , inMsg . get ( Message . WSDL_OPERATION ) ) ; outMsg . put ( Message . WSDL_SERVICE , inMsg . get ( Message . WSDL_SERVICE ) ) ; outMsg . put ( Message . WSDL_INTERFACE , inMsg . get ( Message . WSDL_INTERFACE ) ) ; outMsg . put ( Message . WSDL_PORT , inMsg . get ( Message . WSDL_PORT ) ) ; outMsg . put ( Message . WSDL_DESCRIPTION , inMsg . get ( Message . WSDL_DESCRIPTION ) ) ; } } 	0	['5', '0', '0', '9', '17', '10', '2', '8', '2', '2', '97', '0', '0', '0', '0.45', '0', '0', '18.4', '2', '1', '0']
package org . apache . camel . view ; import java . io . PrintWriter ; import java . util . List ; import java . util . Map ; import java . util . Set ; import org . apache . camel . model . FromType ; import org . apache . camel . model . MulticastType ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . model . RouteType ; import static org . apache . camel . util . ObjectHelper . isNotNullAndNonEmpty ; public class RouteDotGenerator extends GraphGeneratorSupport { public RouteDotGenerator ( String dir ) { super ( dir , ".dot" ) ; } protected void printRoutes ( PrintWriter writer , Map < String , List < RouteType > > map ) { Set < Map . Entry < String , List < RouteType > > > entries = map . entrySet ( ) ; for ( Map . Entry < String , List < RouteType > > entry : entries ) { String group = entry . getKey ( ) ; printRoutes ( writer , group , entry . getValue ( ) ) ; } } protected void printRoutes ( PrintWriter writer , String group , List < RouteType > routes ) { if ( group != null ) { writer . println ( "subgraph cluster_" + ( clusterCounter ++ ) + " {" ) ; writer . println ( "label = \"" + group + "\";" ) ; writer . println ( "color = grey;" ) ; writer . println ( "style = \"dashed\";" ) ; writer . println ( "URL = \"" + group + ".html\";" ) ; writer . println ( ) ; } for ( RouteType route : routes ) { List < FromType > inputs = route . getInputs ( ) ; for ( FromType input : inputs ) { printRoute ( writer , route , input ) ; } writer . println ( ) ; } if ( group != null ) { writer . println ( "}" ) ; writer . println ( ) ; } } protected String escapeNodeId ( String text ) { return text . replace ( '.' , '_' ) . replace ( "$" , "_" ) ; } protected void printRoute ( PrintWriter writer , final RouteType route , FromType input ) { NodeData nodeData = getNodeData ( input ) ; printNode ( writer , nodeData ) ; NodeData from = nodeData ; for ( ProcessorType output : route . getOutputs ( ) ) { NodeData newData = printNode ( writer , from , output ) ; from = newData ; } } protected NodeData printNode ( PrintWriter writer , NodeData fromData , ProcessorType node ) { if ( node instanceof MulticastType ) { List < ProcessorType > outputs = node . getOutputs ( ) ; for ( ProcessorType output : outputs ) { printNode ( writer , fromData , output ) ; } return fromData ; } NodeData toData = getNodeData ( node ) ; printNode ( writer , toData ) ; if ( fromData != null ) { writer . print ( fromData . id ) ; writer . print ( " -> " ) ; writer . print ( toData . id ) ; writer . println ( " [" ) ; String label = fromData . edgeLabel ; if ( isNotNullAndNonEmpty ( label ) ) { writer . println ( "label = \"" + label + "\"" ) ; } writer . println ( "];" ) ; } List < ProcessorType > outputs = toData . outputs ; if ( outputs != null ) { for ( ProcessorType output : outputs ) { NodeData newData = printNode ( writer , toData , output ) ; if ( ! isMulticastNode ( node ) ) { toData = newData ; } } } return toData ; } protected void printNode ( PrintWriter writer , NodeData data ) { if ( ! data . nodeWritten ) { data . nodeWritten = true ; writer . println ( ) ; writer . print ( data . id ) ; writer . println ( " [" ) ; writer . println ( "label = \"" + data . label + "\"" ) ; writer . println ( "tooltip = \"" + data . tooltop + "\"" ) ; if ( data . url != null ) { writer . println ( "URL = \"" + data . url + "\"" ) ; } String image = data . image ; if ( image != null ) { writer . println ( "shapefile = \"" + image + "\"" ) ; writer . println ( "peripheries=0" ) ; } String shape = data . shape ; if ( shape == null && image != null ) { shape = "custom" ; } if ( shape != null ) { writer . println ( "shape = \"" + shape + "\"" ) ; } writer . println ( "];" ) ; writer . println ( ) ; } } protected void generateFile ( PrintWriter writer , Map < String , List < RouteType > > map ) { writer . println ( "digraph CamelRoutes {" ) ; writer . println ( ) ; writer . println ( "node [style = \"rounded,filled\", fillcolor = yellow, " + "fontname=\"Helvetica-Oblique\"];" ) ; writer . println ( ) ; printRoutes ( writer , map ) ; writer . println ( "}" ) ; } } 	1	['8', '2', '0', '8', '31', '28', '1', '7', '1', '2', '394', '0', '0', '0.588235294', '0.347222222', '1', '1', '48.25', '7', '3.125', '1']
package org . apache . camel . builder . script ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import org . apache . camel . language . LanguageAnnotation ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . PARAMETER } ) @ LanguageAnnotation ( language = "groovy" ) public @ interface Groovy { String value ( ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . processor ; import java . io . Serializable ; import java . util . Random ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class RedeliveryPolicy implements Cloneable , Serializable { protected static transient Random randomNumberGenerator ; private static final transient Log LOG = LogFactory . getLog ( RedeliveryPolicy . class ) ; protected int maximumRedeliveries = 6 ; protected long initialRedeliveryDelay = 1000L ; protected long maximumRedeliveryDelay = 60 * 1000L ; protected double backOffMultiplier = 2 ; protected boolean useExponentialBackOff ; protected double collisionAvoidanceFactor = 0.15d ; protected boolean useCollisionAvoidance ; public RedeliveryPolicy ( ) { } @ Override public String toString ( ) { return "RedeliveryPolicy[maximumRedeliveries=" + maximumRedeliveries + "]" ; } public RedeliveryPolicy copy ( ) { try { return ( RedeliveryPolicy ) clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeException ( "Could not clone: " + e , e ) ; } } public boolean shouldRedeliver ( int redeliveryCounter ) { if ( getMaximumRedeliveries ( ) < 0 ) { return true ; } return redeliveryCounter < getMaximumRedeliveries ( ) ; } public long sleep ( long redeliveryDelay ) { redeliveryDelay = getRedeliveryDelay ( redeliveryDelay ) ; if ( redeliveryDelay > 0 ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Sleeping for: " + redeliveryDelay + " millis until attempting redelivery" ) ; } try { Thread . sleep ( redeliveryDelay ) ; } catch ( InterruptedException e ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Thread interrupted: " + e , e ) ; } } } return redeliveryDelay ; } public long getRedeliveryDelay ( long previousDelay ) { long redeliveryDelay ; if ( previousDelay == 0 ) { redeliveryDelay = initialRedeliveryDelay ; } else if ( useExponentialBackOff && backOffMultiplier > 1 ) { redeliveryDelay = Math . round ( backOffMultiplier * previousDelay ) ; } else { redeliveryDelay = previousDelay ; } if ( useCollisionAvoidance ) { Random random = getRandomNumberGenerator ( ) ; double variance = ( random . nextBoolean ( ) ? collisionAvoidanceFactor : - collisionAvoidanceFactor ) * random . nextDouble ( ) ; redeliveryDelay += redeliveryDelay * variance ; } if ( maximumRedeliveryDelay > 0 && redeliveryDelay > maximumRedeliveryDelay ) { redeliveryDelay = maximumRedeliveryDelay ; } return redeliveryDelay ; } public RedeliveryPolicy maximumRedeliveries ( int maximumRedeliveries ) { setMaximumRedeliveries ( maximumRedeliveries ) ; return this ; } public RedeliveryPolicy initialRedeliveryDelay ( long initialRedeliveryDelay ) { setInitialRedeliveryDelay ( initialRedeliveryDelay ) ; return this ; } public RedeliveryPolicy useCollisionAvoidance ( ) { setUseCollisionAvoidance ( true ) ; return this ; } public RedeliveryPolicy useExponentialBackOff ( ) { setUseExponentialBackOff ( true ) ; return this ; } public RedeliveryPolicy backOffMultiplier ( double multiplier ) { useExponentialBackOff ( ) ; setBackOffMultiplier ( multiplier ) ; return this ; } public RedeliveryPolicy collisionAvoidancePercent ( double collisionAvoidancePercent ) { useCollisionAvoidance ( ) ; setCollisionAvoidancePercent ( collisionAvoidancePercent ) ; return this ; } public RedeliveryPolicy maximumRedeliveryDelay ( long maximumRedeliveryDelay ) { setMaximumRedeliveryDelay ( maximumRedeliveryDelay ) ; return this ; } public double getBackOffMultiplier ( ) { return backOffMultiplier ; } public void setBackOffMultiplier ( double backOffMultiplier ) { this . backOffMultiplier = backOffMultiplier ; } public short getCollisionAvoidancePercent ( ) { return ( short ) Math . round ( collisionAvoidanceFactor * 100 ) ; } public void setCollisionAvoidancePercent ( double collisionAvoidancePercent ) { this . collisionAvoidanceFactor = collisionAvoidancePercent * 0.01d ; } public double getCollisionAvoidanceFactor ( ) { return collisionAvoidanceFactor ; } public void setCollisionAvoidanceFactor ( double collisionAvoidanceFactor ) { this . collisionAvoidanceFactor = collisionAvoidanceFactor ; } public long getInitialRedeliveryDelay ( ) { return initialRedeliveryDelay ; } public void setInitialRedeliveryDelay ( long initialRedeliveryDelay ) { this . initialRedeliveryDelay = initialRedeliveryDelay ; } public int getMaximumRedeliveries ( ) { return maximumRedeliveries ; } public void setMaximumRedeliveries ( int maximumRedeliveries ) { this . maximumRedeliveries = maximumRedeliveries ; } public long getMaximumRedeliveryDelay ( ) { return maximumRedeliveryDelay ; } public void setMaximumRedeliveryDelay ( long maximumRedeliveryDelay ) { this . maximumRedeliveryDelay = maximumRedeliveryDelay ; } public boolean isUseCollisionAvoidance ( ) { return useCollisionAvoidance ; } public void setUseCollisionAvoidance ( boolean useCollisionAvoidance ) { this . useCollisionAvoidance = useCollisionAvoidance ; } public boolean isUseExponentialBackOff ( ) { return useExponentialBackOff ; } public void setUseExponentialBackOff ( boolean useExponentialBackOff ) { this . useExponentialBackOff = useExponentialBackOff ; } protected static synchronized Random getRandomNumberGenerator ( ) { if ( randomNumberGenerator == null ) { randomNumberGenerator = new Random ( ) ; } return randomNumberGenerator ; } } 	1	['31', '1', '0', '10', '49', '379', '8', '2', '29', '0.855555556', '328', '1', '0', '0', '0.3', '0', '0', '9.290322581', '8', '1.3548', '4']
package org . apache . camel . component . jhc ; import java . io . IOException ; import java . io . InterruptedIOException ; import java . net . InetSocketAddress ; import java . net . SocketAddress ; import java . util . Arrays ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . util . AsyncProcessorHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . http . Header ; import org . apache . http . HttpEntity ; import org . apache . http . HttpException ; import org . apache . http . HttpRequest ; import org . apache . http . HttpResponse ; import org . apache . http . entity . ByteArrayEntity ; import org . apache . http . impl . DefaultConnectionReuseStrategy ; import org . apache . http . impl . nio . DefaultClientIOEventDispatch ; import org . apache . http . impl . nio . reactor . DefaultConnectingIOReactor ; import org . apache . http . message . BasicHttpEntityEnclosingRequest ; import org . apache . http . message . BasicHttpRequest ; import org . apache . http . nio . NHttpConnection ; import org . apache . http . nio . protocol . BufferingHttpClientHandler ; import org . apache . http . nio . protocol . EventListener ; import org . apache . http . nio . protocol . HttpRequestExecutionHandler ; import org . apache . http . nio . reactor . ConnectingIOReactor ; import org . apache . http . nio . reactor . IOEventDispatch ; import org . apache . http . nio . reactor . SessionRequest ; import org . apache . http . nio . reactor . SessionRequestCallback ; import org . apache . http . params . HttpParams ; import org . apache . http . protocol . BasicHttpProcessor ; import org . apache . http . protocol . HttpContext ; import org . apache . http . protocol . RequestConnControl ; import org . apache . http . protocol . RequestContent ; import org . apache . http . protocol . RequestExpectContinue ; import org . apache . http . protocol . RequestTargetHost ; import org . apache . http . protocol . RequestUserAgent ; import org . apache . http . util . concurrent . ThreadFactory ; public class JhcProducer extends DefaultProducer < JhcExchange > implements AsyncProcessor { public static final String HTTP_RESPONSE_CODE = "http.responseCode" ; public static final Set < String > HEADERS_TO_SKIP = new HashSet < String > ( Arrays . asList ( "content-length" , "content-type" , HTTP_RESPONSE_CODE . toLowerCase ( ) ) ) ; private static final transient Log LOG = LogFactory . getLog ( JhcProducer . class ) ; private int nbThreads = 2 ; private ConnectingIOReactor ioReactor ; private ThreadFactory threadFactory ; private Thread runner ; public JhcProducer ( JhcEndpoint endpoint ) { super ( endpoint ) ; } @ Override public JhcEndpoint getEndpoint ( ) { return ( JhcEndpoint ) super . getEndpoint ( ) ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; HttpParams params = getEndpoint ( ) . getParams ( ) ; ioReactor = new DefaultConnectingIOReactor ( nbThreads , threadFactory , params ) ; BasicHttpProcessor httpproc = new BasicHttpProcessor ( ) ; httpproc . addInterceptor ( new RequestContent ( ) ) ; httpproc . addInterceptor ( new RequestTargetHost ( ) ) ; httpproc . addInterceptor ( new RequestConnControl ( ) ) ; httpproc . addInterceptor ( new RequestUserAgent ( ) ) ; httpproc . addInterceptor ( new RequestExpectContinue ( ) ) ; BufferingHttpClientHandler handler = new BufferingHttpClientHandler ( httpproc , new MyHttpRequestExecutionHandler ( ) , new DefaultConnectionReuseStrategy ( ) , params ) ; handler . setEventListener ( new EventLogger ( ) ) ; final IOEventDispatch ioEventDispatch = new DefaultClientIOEventDispatch ( handler , params ) ; runner = new Thread ( new Runnable ( ) { public void run ( ) { try { ioReactor . execute ( ioEventDispatch ) ; } catch ( InterruptedIOException ex ) { LOG . info ( "Interrupted" ) ; } catch ( IOException e ) { LOG . warn ( "I/O error: " + e . getMessage ( ) ) ; } LOG . debug ( "Shutdown" ) ; } } ) ; runner . start ( ) ; } @ Override protected void doStop ( ) throws Exception { ioReactor . shutdown ( ) ; runner . join ( ) ; super . doStop ( ) ; } public void process ( Exchange exchange ) throws Exception { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "process: " + exchange ) ; } AsyncProcessorHelper . process ( this , exchange ) ; } public boolean process ( Exchange exchange , AsyncCallback callback ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "processAsync: " + exchange ) ; } SocketAddress addr = new InetSocketAddress ( getEndpoint ( ) . getHost ( ) , getEndpoint ( ) . getPort ( ) ) ; exchange . setProperty ( AsyncCallback . class . getName ( ) , callback ) ; SessionRequest req = ioReactor . connect ( addr , null , exchange , new MySessionRequestCallback ( ) ) ; return false ; } protected HttpRequest createRequest ( Exchange exchange ) { String uri = getEndpoint ( ) . getEndpointUri ( ) ; HttpEntity entity = createEntity ( exchange ) ; HttpRequest req ; if ( entity == null ) { req = new BasicHttpRequest ( "GET" , getEndpoint ( ) . getPath ( ) ) ; } else { req = new BasicHttpEntityEnclosingRequest ( "POST" , getEndpoint ( ) . getPath ( ) ) ; ( ( BasicHttpEntityEnclosingRequest ) req ) . setEntity ( entity ) ; } for ( String headerName : exchange . getIn ( ) . getHeaders ( ) . keySet ( ) ) { String headerValue = exchange . getIn ( ) . getHeader ( headerName , String . class ) ; if ( shouldHeaderBePropagated ( headerName , headerValue ) ) { req . addHeader ( headerName , headerValue ) ; } } return req ; } protected HttpEntity createEntity ( Exchange exchange ) { Message in = exchange . getIn ( ) ; HttpEntity entity = in . getBody ( HttpEntity . class ) ; if ( entity == null ) { byte [ ] data = in . getBody ( byte [ ] . class ) ; if ( data == null ) { return null ; } entity = new ByteArrayEntity ( data ) ; String contentType = in . getHeader ( "Content-Type" , String . class ) ; if ( contentType != null ) { ( ( ByteArrayEntity ) entity ) . setContentType ( contentType ) ; } String contentEncoding = in . getHeader ( "Content-Encoding" , String . class ) ; if ( contentEncoding != null ) { ( ( ByteArrayEntity ) entity ) . setContentEncoding ( contentEncoding ) ; } } return entity ; } protected boolean shouldHeaderBePropagated ( String headerName , String headerValue ) { if ( headerValue == null ) { return false ; } if ( headerName . startsWith ( "org.apache.camel" ) ) { return false ; } if ( HEADERS_TO_SKIP . contains ( headerName . toLowerCase ( ) ) ) { return false ; } return true ; } static class MySessionRequestCallback implements SessionRequestCallback { public void completed ( SessionRequest sessionRequest ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Completed" ) ; } } public void failed ( SessionRequest sessionRequest ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Failed" ) ; } } public void timeout ( SessionRequest sessionRequest ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Timeout" ) ; } } public void cancelled ( SessionRequest sessionRequest ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Cancelled" ) ; } } } class MyHttpRequestExecutionHandler implements HttpRequestExecutionHandler { private static final String REQUEST_SENT = "request-sent" ; private static final String RESPONSE_RECEIVED = "response-received" ; public void initalizeContext ( HttpContext httpContext , Object o ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Initialize context" ) ; } httpContext . setAttribute ( Exchange . class . getName ( ) , ( Exchange ) o ) ; } public HttpRequest submitRequest ( HttpContext httpContext ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Submit request: " + httpContext ) ; } Object flag = httpContext . getAttribute ( REQUEST_SENT ) ; if ( flag == null ) { httpContext . setAttribute ( REQUEST_SENT , Boolean . TRUE ) ; Exchange e = ( Exchange ) httpContext . getAttribute ( Exchange . class . getName ( ) ) ; return createRequest ( e ) ; } else { return null ; } } public void handleResponse ( HttpResponse httpResponse , HttpContext httpContext ) throws IOException { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Handle response" ) ; } httpContext . setAttribute ( RESPONSE_RECEIVED , Boolean . TRUE ) ; Exchange e = ( Exchange ) httpContext . getAttribute ( Exchange . class . getName ( ) ) ; e . getOut ( ) . setBody ( httpResponse . getEntity ( ) ) ; for ( Iterator it = httpResponse . headerIterator ( ) ; it . hasNext ( ) ; ) { Header h = ( Header ) it . next ( ) ; e . getOut ( ) . setHeader ( h . getName ( ) , h . getValue ( ) ) ; } e . getOut ( ) . setHeader ( HTTP_RESPONSE_CODE , httpResponse . getStatusLine ( ) . getStatusCode ( ) ) ; AsyncCallback callback = ( AsyncCallback ) e . removeProperty ( AsyncCallback . class . getName ( ) ) ; callback . done ( false ) ; } public void finalizeContext ( HttpContext httpContext ) { } } static class EventLogger implements EventListener { public void connectionOpen ( final NHttpConnection conn ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Connection open: " + conn ) ; } } public void connectionTimeout ( final NHttpConnection conn ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Connection timed out: " + conn ) ; } } public void connectionClosed ( final NHttpConnection conn ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Connection closed: " + conn ) ; } } public void fatalIOException ( final IOException ex , final NHttpConnection conn ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "I/O error: " + ex . getMessage ( ) ) ; } } public void fatalProtocolException ( final HttpException ex , final NHttpConnection conn ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "HTTP error: " + ex . getMessage ( ) ) ; } } } } 	0	['13', '3', '0', '41', '73', '50', '5', '41', '5', '0.892857143', '344', '0.714285714', '0', '0.64516129', '0.25', '1', '1', '24.92307692', '5', '1.6154', '0']
package org . apache . camel . processor ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . converter . ObjectConverter ; import org . apache . camel . impl . ProducerCache ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . processor . aggregate . UseLatestAggregationStrategy ; import org . apache . camel . util . ExchangeHelper ; import static org . apache . camel . util . ObjectHelper . notNull ; public class RecipientList extends ServiceSupport implements Processor { private final Expression < Exchange > expression ; private ProducerCache < Exchange > producerCache = new ProducerCache < Exchange > ( ) ; public RecipientList ( Expression < Exchange > expression ) { notNull ( expression , "expression" ) ; this . expression = expression ; } @ Override public String toString ( ) { return "RecipientList[" + expression + "]" ; } public void process ( Exchange exchange ) throws Exception { Object receipientList = expression . evaluate ( exchange ) ; Iterator iter = ObjectConverter . iterator ( receipientList ) ; List < Processor > processors = new ArrayList < Processor > ( ) ; while ( iter . hasNext ( ) ) { Object recipient = iter . next ( ) ; Endpoint < Exchange > endpoint = resolveEndpoint ( exchange , recipient ) ; Producer < Exchange > producer = producerCache . getProducer ( endpoint ) ; processors . add ( producer ) ; } MulticastProcessor mp = new MulticastProcessor ( processors , new UseLatestAggregationStrategy ( ) ) ; mp . process ( exchange ) ; } protected Endpoint < Exchange > resolveEndpoint ( Exchange exchange , Object recipient ) { return ExchangeHelper . resolveEndpoint ( exchange , recipient ) ; } protected void doStop ( ) throws Exception { producerCache . stop ( ) ; } protected void doStart ( ) throws Exception { } } 	1	['6', '2', '0', '15', '25', '5', '2', '13', '3', '0.6', '88', '1', '2', '0.722222222', '0.416666667', '1', '1', '13.33333333', '1', '0.8333', '2']
package org . apache . camel . bam . model ; import javax . persistence . CascadeType ; import javax . persistence . Entity ; import javax . persistence . FetchType ; import javax . persistence . GeneratedValue ; import javax . persistence . Id ; import javax . persistence . ManyToOne ; import javax . persistence . UniqueConstraint ; @ Entity @ UniqueConstraint ( columnNames = { "name" } ) public class ActivityDefinition extends EntitySupport { private String name ; private ProcessDefinition processDefinition ; @ Override @ Id @ GeneratedValue public Long getId ( ) { return super . getId ( ) ; } @ Override public String toString ( ) { return "Activity[" + getId ( ) + " name: " + getName ( ) + "]" ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } @ ManyToOne ( fetch = FetchType . LAZY , cascade = { CascadeType . PERSIST , CascadeType . MERGE } ) public ProcessDefinition getProcessDefinition ( ) { return processDefinition ; } public void setProcessDefinition ( ProcessDefinition processDefinition ) { this . processDefinition = processDefinition ; } } 	0	['7', '2', '0', '6', '13', '17', '4', '2', '7', '0.75', '46', '1', '1', '0.333333333', '0.428571429', '0', '0', '5.285714286', '1', '0.8571', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Predicate ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . FilterProcessor ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "when" ) public class WhenType < Type extends ProcessorType > extends ExpressionNode { public WhenType ( ) { } public WhenType ( Predicate predicate ) { super ( predicate ) ; } public WhenType ( ExpressionType expression ) { super ( expression ) ; } @ Override public String toString ( ) { return "When[ " + getExpression ( ) + " -> " + getOutputs ( ) + "]" ; } @ Override public String getShortName ( ) { return "when" ; } @ Override public FilterProcessor createProcessor ( RouteContext routeContext ) throws Exception { return createFilterProcessor ( routeContext ) ; } } 	1	['7', '4', '0', '9', '16', '21', '3', '6', '7', '2', '45', '0', '0', '0.975308642', '0.392857143', '3', '4', '5.428571429', '1', '0.5714', '1']
package org . apache . camel . impl ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . util . ObjectHelper ; public abstract class ExpressionSupport < E extends Exchange > implements Expression < E > , Predicate < E > { public boolean matches ( E exchange ) { Object value = evaluate ( exchange ) ; return ObjectHelper . evaluateValuePredicate ( value ) ; } public void assertMatches ( String text , E exchange ) { if ( ! matches ( exchange ) ) { throw new AssertionError ( text + " " + assertionFailureMessage ( exchange ) + " for exchange: " + exchange ) ; } } protected abstract String assertionFailureMessage ( E exchange ) ; } 	0	['6', '1', '6', '11', '14', '15', '7', '4', '5', '2', '52', '0', '0', '0', '0.541666667', '0', '0', '7.666666667', '2', '1', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . builder . ExpressionBuilder ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . SetHeaderProcessor ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "setHeader" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class SetHeaderType extends ExpressionNode { @ XmlAttribute private String headerName ; @ XmlAttribute ( required = false ) private String value ; public SetHeaderType ( ) { } public SetHeaderType ( String headerName , ExpressionType expression ) { super ( expression ) ; setHeaderName ( headerName ) ; } public SetHeaderType ( String headerName , Expression expression ) { super ( expression ) ; setHeaderName ( headerName ) ; } public SetHeaderType ( String headerName , String value ) { super ( ExpressionBuilder . constantExpression ( value ) ) ; setHeaderName ( headerName ) ; } @ Override public String toString ( ) { return "SetHeader[ " + getHeaderName ( ) + ", " + getExpression ( ) + "]" ; } @ Override public String getShortName ( ) { return "setHeader" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { Expression expr ; if ( getValue ( ) == null ) { expr = getExpression ( ) . createExpression ( routeContext ) ; } else { expr = ExpressionBuilder . constantExpression ( getValue ( ) ) ; } Processor childProcessor = routeContext . createProcessor ( this ) ; return new SetHeaderProcessor ( getHeaderName ( ) , expr , childProcessor ) ; } public void setHeaderName ( String headerName ) { this . headerName = headerName ; } public String getHeaderName ( ) { return headerName ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } } 	1	['11', '4', '0', '8', '23', '51', '1', '8', '11', '0.6', '96', '1', '0', '0.957575758', '0.345454545', '2', '3', '7.545454545', '1', '0.6364', '1']
package org . apache . camel . component . file . remote ; import java . io . IOException ; import org . apache . camel . Processor ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . commons . net . ftp . FTPClient ; public class FtpEndpoint extends RemoteFileEndpoint < RemoteFileExchange > { private static final transient Log LOG = LogFactory . getLog ( FtpEndpoint . class ) ; public FtpEndpoint ( String uri , RemoteFileComponent remoteFileComponent , RemoteFileConfiguration configuration ) { super ( uri , remoteFileComponent , configuration ) ; } public FtpEndpoint ( String endpointUri ) { super ( endpointUri ) ; } public FtpProducer createProducer ( ) throws Exception { return new FtpProducer ( this , createFtpClient ( ) ) ; } public FtpConsumer createConsumer ( Processor processor ) throws Exception { final FtpConsumer consumer = new FtpConsumer ( this , processor , createFtpClient ( ) ) ; configureConsumer ( consumer ) ; return consumer ; } protected FTPClient createFtpClient ( ) { final FTPClient client = new FTPClient ( ) ; return client ; } public void connect ( FTPClient client ) throws IOException { RemoteFileConfiguration config = getConfiguration ( ) ; String host = config . getHost ( ) ; int port = config . getPort ( ) ; client . connect ( host , port ) ; if ( null != config . getUsername ( ) ) { client . login ( config . getUsername ( ) , config . getPassword ( ) ) ; } else { client . login ( "anonymous" , null ) ; } client . setFileType ( config . isBinary ( ) ? FTPClient . BINARY_FILE_TYPE : FTPClient . ASCII_FILE_TYPE ) ; } public void disconnect ( FTPClient client ) throws IOException { client . disconnect ( ) ; } } 	0	['10', '4', '0', '11', '25', '45', '3', '11', '8', '1', '101', '1', '0', '0.844444444', '0.314814815', '0', '0', '9', '1', '0.7', '0']
package org . apache . camel . converter . stream ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import javax . xml . transform . TransformerException ; import javax . xml . transform . stream . StreamSource ; import org . apache . camel . Converter ; import org . apache . camel . converter . IOConverter ; import org . apache . camel . converter . jaxp . StringSource ; import org . apache . camel . converter . jaxp . XmlConverter ; @ Converter public class StreamCacheConverter { private XmlConverter converter = new XmlConverter ( ) ; @ Converter public StreamCache convertToStreamCache ( StreamSource source ) throws TransformerException { return new StreamSourceCache ( converter . toString ( source ) ) ; } @ Converter public StreamCache convertToStreamCache ( InputStream stream ) throws IOException { return new InputStreamCache ( IOConverter . toBytes ( stream ) ) ; } private class StreamSourceCache extends StringSource implements StreamCache { private static final long serialVersionUID = 4147248494104812945L ; public StreamSourceCache ( String text ) { super ( text ) ; } } private class InputStreamCache extends ByteArrayInputStream implements StreamCache { public InputStreamCache ( byte [ ] data ) { super ( data ) ; } } } 	1	['3', '1', '0', '5', '9', '1', '2', '5', '3', '0.5', '28', '1', '1', '0', '0.555555556', '0', '0', '8', '1', '0.6667', '6']
package org . apache . camel . spring ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . CamelContextAware ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . EndpointInject ; import org . apache . camel . MessageDriven ; import org . apache . camel . PollingConsumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . Service ; import org . apache . camel . component . bean . BeanProcessor ; import org . apache . camel . impl . DefaultProducerTemplate ; import org . apache . camel . spring . util . ReflectionUtils ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . NoSuchBeanDefinitionException ; import org . springframework . beans . factory . config . BeanPostProcessor ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import static org . apache . camel . util . ObjectHelper . isNotNullAndNonEmpty ; import static org . apache . camel . util . ObjectHelper . isNullOrBlank ; @ XmlRootElement ( name = "beanPostProcessor" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class CamelBeanPostProcessor implements BeanPostProcessor , ApplicationContextAware { private static final transient Log LOG = LogFactory . getLog ( CamelBeanPostProcessor . class ) ; @ XmlTransient private SpringCamelContext camelContext ; @ XmlTransient private ApplicationContext applicationContext ; public CamelBeanPostProcessor ( ) { } public Object postProcessBeforeInitialization ( Object bean , String beanName ) throws BeansException { injectFields ( bean ) ; injectMethods ( bean ) ; if ( bean instanceof CamelContextAware ) { CamelContextAware contextAware = ( CamelContextAware ) bean ; if ( camelContext == null ) { LOG . warn ( "No CamelContext defined yet so cannot inject into: " + bean ) ; } else { contextAware . setCamelContext ( camelContext ) ; } } return bean ; } public Object postProcessAfterInitialization ( Object bean , String beanName ) throws BeansException { return bean ; } public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { this . applicationContext = applicationContext ; } public SpringCamelContext getCamelContext ( ) { return camelContext ; } public void setCamelContext ( SpringCamelContext camelContext ) { this . camelContext = camelContext ; } protected void injectFields ( final Object bean ) { ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { public void doWith ( Field field ) throws IllegalArgumentException , IllegalAccessException { EndpointInject annotation = field . getAnnotation ( EndpointInject . class ) ; if ( annotation != null ) { ReflectionUtils . setField ( field , bean , getEndpointInjectionValue ( annotation , field . getType ( ) , field . getName ( ) ) ) ; } } } ) ; } protected void injectMethods ( final Object bean ) { ReflectionUtils . doWithMethods ( bean . getClass ( ) , new ReflectionUtils . MethodCallback ( ) { @ SuppressWarnings ( "unchecked" ) public void doWith ( Method method ) throws IllegalArgumentException , IllegalAccessException { setterInjection ( method , bean ) ; consumerInjection ( method , bean ) ; } } ) ; } protected void setterInjection ( Method method , Object bean ) { EndpointInject annoation = method . getAnnotation ( EndpointInject . class ) ; if ( annoation != null ) { Class < ? > [ ] parameterTypes = method . getParameterTypes ( ) ; if ( parameterTypes != null ) { if ( parameterTypes . length != 1 ) { LOG . warn ( "Ignoring badly annotated method for injection due to incorrect number of parameters: " + method ) ; } else { String propertyName = ObjectHelper . getPropertyName ( method ) ; Object value = getEndpointInjectionValue ( annoation , parameterTypes [ 0 ] , propertyName ) ; ObjectHelper . invokeMethod ( method , bean , value ) ; } } } } protected void consumerInjection ( final Object bean ) { ReflectionUtils . doWithMethods ( bean . getClass ( ) , new ReflectionUtils . MethodCallback ( ) { @ SuppressWarnings ( "unchecked" ) public void doWith ( Method method ) throws IllegalArgumentException , IllegalAccessException { } } ) ; } protected void consumerInjection ( Method method , Object bean ) { MessageDriven annotation = method . getAnnotation ( MessageDriven . class ) ; if ( annotation != null ) { LOG . info ( "Creating a consumer for: " + annotation ) ; String injectionPointName = method . getName ( ) ; Endpoint endpoint = getEndpointInjection ( annotation . uri ( ) , annotation . name ( ) , injectionPointName ) ; if ( endpoint != null ) { try { Processor processor = createConsumerProcessor ( bean , method , endpoint ) ; LOG . info ( "Created processor: " + processor ) ; Consumer consumer = endpoint . createConsumer ( processor ) ; startService ( consumer ) ; } catch ( Exception e ) { LOG . warn ( e ) ; throw new RuntimeCamelException ( e ) ; } } } } protected void startService ( Service service ) throws Exception { camelContext . addService ( service ) ; } protected Processor createConsumerProcessor ( final Object pojo , final Method method , final Endpoint endpoint ) { BeanProcessor answer = new BeanProcessor ( pojo , getCamelContext ( ) ) ; answer . setMethodObject ( method ) ; return answer ; } protected Object getEndpointInjectionValue ( EndpointInject annotation , Class < ? > type , String injectionPointName ) { Endpoint endpoint = getEndpointInjection ( annotation . uri ( ) , annotation . name ( ) , injectionPointName ) ; if ( endpoint != null ) { if ( type . isInstance ( endpoint ) ) { return endpoint ; } else if ( type . isAssignableFrom ( Producer . class ) ) { return createInjectionProducer ( endpoint ) ; } else if ( type . isAssignableFrom ( DefaultProducerTemplate . class ) ) { return new DefaultProducerTemplate ( getCamelContext ( ) , endpoint ) ; } else if ( type . isAssignableFrom ( PollingConsumer . class ) ) { return createInjectionPollingConsumer ( endpoint ) ; } else { throw new IllegalArgumentException ( "Invalid type: " + type . getName ( ) + " which cannot be injected via @EndpointInject for " + endpoint ) ; } } return null ; } protected PollingConsumer createInjectionPollingConsumer ( Endpoint endpoint ) { try { PollingConsumer pollingConsumer = endpoint . createPollingConsumer ( ) ; startService ( pollingConsumer ) ; return pollingConsumer ; } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } } protected Producer createInjectionProducer ( Endpoint endpoint ) { try { Producer producer = endpoint . createProducer ( ) ; startService ( producer ) ; return producer ; } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } } protected Endpoint getEndpointInjection ( String uri , String name , String injectionPointName ) { Endpoint endpoint = null ; if ( isNotNullAndNonEmpty ( uri ) ) { endpoint = camelContext . getEndpoint ( uri ) ; } else { if ( isNullOrBlank ( name ) ) { name = injectionPointName ; } endpoint = ( Endpoint ) applicationContext . getBean ( name ) ; if ( endpoint == null ) { throw new NoSuchBeanDefinitionException ( name ) ; } } return endpoint ; } } 	0	['18', '1', '0', '29', '59', '119', '4', '28', '6', '0.705882353', '350', '1', '1', '0', '0.235294118', '0', '0', '18.27777778', '6', '1.6111', '0']
package org . apache . camel . converter ; import java . io . BufferedInputStream ; import java . io . BufferedOutputStream ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . ObjectInput ; import java . io . ObjectInputStream ; import java . io . ObjectOutput ; import java . io . ObjectOutputStream ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . Reader ; import java . io . StringReader ; import java . io . Writer ; import java . net . URL ; import java . util . Properties ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . Source ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerException ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . stream . StreamResult ; import org . apache . camel . Converter ; import org . apache . camel . util . CollectionStringBuffer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; @ Converter public final class IOConverter { private static final transient Log LOG = LogFactory . getLog ( IOConverter . class ) ; private IOConverter ( ) { } @ Converter public static InputStream toInputStream ( URL url ) throws IOException { return url . openStream ( ) ; } @ Converter public static InputStream toInputStream ( File file ) throws FileNotFoundException { return new BufferedInputStream ( new FileInputStream ( file ) ) ; } @ Converter public static BufferedReader toReader ( File file ) throws FileNotFoundException { return new BufferedReader ( new FileReader ( file ) ) ; } @ Converter public static File toFile ( String name ) throws FileNotFoundException { return new File ( name ) ; } @ Converter public static OutputStream toOutputStream ( File file ) throws FileNotFoundException { return new BufferedOutputStream ( new FileOutputStream ( file ) ) ; } @ Converter public static BufferedWriter toWriter ( File file ) throws IOException { return new BufferedWriter ( new FileWriter ( file ) ) ; } @ Converter public static Reader toReader ( InputStream in ) throws FileNotFoundException { return new InputStreamReader ( in ) ; } @ Converter public static Writer toWriter ( OutputStream out ) throws FileNotFoundException { return new OutputStreamWriter ( out ) ; } @ Converter public static StringReader toReader ( String text ) { return new StringReader ( text ) ; } @ Converter public static InputStream toInputStream ( String text ) { return toInputStream ( text . getBytes ( ) ) ; } @ Converter public static InputStream toInputStream ( BufferedReader buffer ) throws IOException { return toInputStream ( toString ( buffer ) ) ; } @ Converter public static InputStream toInputStrean ( DOMSource source ) throws TransformerException , IOException { ByteArrayInputStream bais = new ByteArrayInputStream ( toString ( source ) . getBytes ( ) ) ; return bais ; } @ Converter public static String toString ( byte [ ] data ) { return new String ( data ) ; } @ Converter public static String toString ( File file ) throws IOException { return toString ( toReader ( file ) ) ; } @ Converter public static String toString ( URL url ) throws IOException { return toString ( toInputStream ( url ) ) ; } @ Converter public static String toString ( Reader reader ) throws IOException { if ( reader instanceof BufferedReader ) { return toString ( ( BufferedReader ) reader ) ; } else { return toString ( new BufferedReader ( reader ) ) ; } } @ Converter public static String toString ( BufferedReader reader ) throws IOException { if ( reader == null ) { return null ; } try { CollectionStringBuffer builder = new CollectionStringBuffer ( "\n" ) ; while ( true ) { String line = reader . readLine ( ) ; if ( line == null ) { return builder . toString ( ) ; } builder . append ( line ) ; } } finally { try { reader . close ( ) ; } catch ( IOException e ) { LOG . warn ( "Failed to close stream: " + e , e ) ; } } } @ Converter public static String toString ( InputStream in ) throws IOException { return toString ( toReader ( in ) ) ; } public static String toString ( Source source ) throws TransformerException , IOException { return toString ( source , null ) ; } public static String toString ( Source source , Properties props ) throws TransformerException , IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; StreamResult sr = new StreamResult ( bos ) ; Transformer trans = TransformerFactory . newInstance ( ) . newTransformer ( ) ; if ( props == null ) { props = new Properties ( ) ; props . put ( OutputKeys . OMIT_XML_DECLARATION , "yes" ) ; } trans . setOutputProperties ( props ) ; trans . transform ( source , sr ) ; bos . close ( ) ; return bos . toString ( ) ; } @ Converter public static InputStream toInputStream ( byte [ ] data ) { return new ByteArrayInputStream ( data ) ; } @ Converter public static ObjectOutput toObjectOutput ( OutputStream stream ) throws IOException { if ( stream instanceof ObjectOutput ) { return ( ObjectOutput ) stream ; } else { return new ObjectOutputStream ( stream ) ; } } @ Converter public static ObjectInput toObjectInput ( InputStream stream ) throws IOException { if ( stream instanceof ObjectInput ) { return ( ObjectInput ) stream ; } else { return new ObjectInputStream ( stream ) ; } } @ Converter public static byte [ ] toBytes ( InputStream stream ) throws IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; copy ( stream , bos ) ; return bos . toByteArray ( ) ; } protected static void copy ( InputStream stream , ByteArrayOutputStream bos ) throws IOException { byte [ ] data = new byte [ 4096 ] ; int read = stream . read ( data ) ; while ( read != - 1 ) { bos . write ( data , 0 , read ) ; read = stream . read ( data ) ; } bos . flush ( ) ; } } 	1	['27', '1', '0', '12', '71', '349', '9', '3', '24', '0.807692308', '292', '1', '0', '0', '0.082840237', '0', '0', '9.777777778', '1', '0.9259', '3']
package org . apache . camel . component . cxf . feature ; import java . util . logging . Logger ; import org . apache . camel . component . cxf . interceptors . FaultOutInterceptor ; import org . apache . camel . component . cxf . interceptors . RawMessageContentRedirectInterceptor ; import org . apache . cxf . Bus ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . endpoint . Client ; import org . apache . cxf . endpoint . Server ; import org . apache . cxf . phase . Phase ; public class MessageDataFormatFeature extends AbstractDataFormatFeature { private static final Logger LOG = LogUtils . getL7dLogger ( MessageDataFormatFeature . class ) ; private static final String [ ] REMAINING_IN_PHASES = { Phase . RECEIVE , Phase . POST_INVOKE } ; private static final String [ ] REMAINING_OUT_PHASES = { Phase . PREPARE_SEND , Phase . WRITE , Phase . SEND , Phase . PREPARE_SEND_ENDING } ; @ Override public void initialize ( Client client , Bus bus ) { removeInterceptorWhichIsOutThePhases ( client . getInInterceptors ( ) , REMAINING_IN_PHASES ) ; removeInterceptorWhichIsOutThePhases ( client . getEndpoint ( ) . getInInterceptors ( ) , REMAINING_IN_PHASES ) ; client . getEndpoint ( ) . getBinding ( ) . getInInterceptors ( ) . clear ( ) ; removeInterceptorWhichIsOutThePhases ( client . getOutInterceptors ( ) , REMAINING_OUT_PHASES ) ; removeInterceptorWhichIsOutThePhases ( client . getEndpoint ( ) . getOutInterceptors ( ) , REMAINING_OUT_PHASES ) ; client . getEndpoint ( ) . getBinding ( ) . getOutInterceptors ( ) . clear ( ) ; client . getEndpoint ( ) . getOutInterceptors ( ) . add ( new RawMessageContentRedirectInterceptor ( ) ) ; client . getEndpoint ( ) . getBinding ( ) . getOutFaultInterceptors ( ) . add ( new FaultOutInterceptor ( ) ) ; } @ Override public void initialize ( Server server , Bus bus ) { removeInterceptorWhichIsOutThePhases ( server . getEndpoint ( ) . getService ( ) . getInInterceptors ( ) , REMAINING_IN_PHASES ) ; removeInterceptorWhichIsOutThePhases ( server . getEndpoint ( ) . getInInterceptors ( ) , REMAINING_IN_PHASES ) ; server . getEndpoint ( ) . getBinding ( ) . getInInterceptors ( ) . clear ( ) ; removeInterceptorWhichIsOutThePhases ( server . getEndpoint ( ) . getService ( ) . getOutInterceptors ( ) , REMAINING_OUT_PHASES ) ; removeInterceptorWhichIsOutThePhases ( server . getEndpoint ( ) . getOutInterceptors ( ) , REMAINING_OUT_PHASES ) ; server . getEndpoint ( ) . getBinding ( ) . getOutInterceptors ( ) . clear ( ) ; server . getEndpoint ( ) . getBinding ( ) . getOutFaultInterceptors ( ) . add ( new FaultOutInterceptor ( ) ) ; resetServiceInvokerInterceptor ( server ) ; server . getEndpoint ( ) . getOutInterceptors ( ) . add ( new RawMessageContentRedirectInterceptor ( ) ) ; } @ Override protected Logger getLogger ( ) { return LOG ; } } 	0	['5', '1', '0', '12', '26', '2', '2', '10', '3', '0.583333333', '154', '1', '0', '0.571428571', '0.5', '1', '1', '29.2', '1', '0.6', '0']
package org . apache . camel . spi ; import java . util . List ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Intercept ; import org . apache . camel . Processor ; import org . apache . camel . model . FromType ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . model . RouteType ; public interface RouteContext { Endpoint < ? extends Exchange > getEndpoint ( ) ; FromType getFrom ( ) ; RouteType getRoute ( ) ; CamelContext getCamelContext ( ) ; Processor createProcessor ( ProcessorType node ) throws Exception ; Endpoint < ? extends Exchange > resolveEndpoint ( String uri ) ; Endpoint < ? extends Exchange > resolveEndpoint ( String uri , String ref ) ; < T > T lookup ( String name , Class < T > type ) ; void commit ( ) ; void addEventDrivenProcessor ( Processor processor ) ; void intercept ( Intercept interceptor ) ; Processor createProceedProcessor ( ) ; List < InterceptStrategy > getInterceptStrategies ( ) ; void setInterceptStrategies ( List < InterceptStrategy > interceptStrategies ) ; void addInterceptStrategy ( InterceptStrategy interceptStrategy ) ; ErrorHandlerWrappingStrategy getErrorHandlerWrappingStrategy ( ) ; void setErrorHandlerWrappingStrategy ( ErrorHandlerWrappingStrategy strategy ) ; void setIsRouteAdded ( boolean value ) ; boolean isRouteAdded ( ) ; } 	1	['19', '1', '0', '72', '19', '171', '67', '9', '19', '2', '19', '0', '0', '0', '0.157894737', '0', '0', '0', '1', '1', '1']
package org . apache . camel . spring ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . model . IdentifiedType ; @ XmlRootElement ( name = "export" ) public class CamelServiceExporterType extends IdentifiedType { @ XmlAttribute private String uri ; @ XmlAttribute private String serviceRef ; @ XmlAttribute private Class serviceInterface ; } 	0	['1', '2', '0', '1', '2', '0', '0', '1', '1', '2', '7', '1', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public class Throttler extends DelayProcessorSupport { private long maximumRequestsPerPeriod ; private long timePeriodMillis ; private long startTimeMillis ; private long requestCount ; public Throttler ( Processor processor , long maximumRequestsPerPeriod ) { this ( processor , maximumRequestsPerPeriod , 1000 ) ; } public Throttler ( Processor processor , long maximumRequestsPerPeriod , long timePeriodMillis ) { super ( processor ) ; this . maximumRequestsPerPeriod = maximumRequestsPerPeriod ; this . timePeriodMillis = timePeriodMillis ; } @ Override public String toString ( ) { return "Throttler[requests: " + maximumRequestsPerPeriod + " per: " + timePeriodMillis + " (ms) to: " + getProcessor ( ) + "]" ; } public long getMaximumRequestsPerPeriod ( ) { return maximumRequestsPerPeriod ; } public void setMaximumRequestsPerPeriod ( long maximumRequestsPerPeriod ) { this . maximumRequestsPerPeriod = maximumRequestsPerPeriod ; } public long getTimePeriodMillis ( ) { return timePeriodMillis ; } public void setTimePeriodMillis ( long timePeriodMillis ) { this . timePeriodMillis = timePeriodMillis ; } public long getRequestCount ( ) { return requestCount ; } public long getStartTimeMillis ( ) { return startTimeMillis ; } protected void delay ( Exchange exchange ) throws Exception { long now = currentSystemTime ( ) ; if ( startTimeMillis == 0 ) { startTimeMillis = now ; } if ( now - startTimeMillis > timePeriodMillis ) { requestCount = 1 ; startTimeMillis = now ; } else { if ( ++ requestCount > maximumRequestsPerPeriod ) { long time = startTimeMillis + timePeriodMillis ; waitUntil ( time , exchange ) ; } } } } 	1	['10', '4', '0', '4', '19', '7', '1', '3', '9', '0.666666667', '120', '1', '0', '0.789473684', '0.425', '1', '2', '10.6', '1', '0.8', '3']
package org . apache . camel . component . rmi ; import java . rmi . NotBoundException ; import java . rmi . RemoteException ; import org . apache . camel . Exchange ; import org . apache . camel . component . bean . BeanExchange ; import org . apache . camel . component . bean . BeanHolder ; import org . apache . camel . component . bean . BeanProcessor ; import org . apache . camel . impl . DefaultProducer ; public class RmiProducer extends DefaultProducer < BeanExchange > { private BeanProcessor beanProcessor ; public RmiProducer ( RmiEndpoint endpoint ) throws RemoteException , NotBoundException { super ( endpoint ) ; BeanHolder holder = new RmiRegistryBean ( endpoint . getCamelContext ( ) , endpoint . getName ( ) , endpoint . getRegistry ( ) ) ; beanProcessor = new BeanProcessor ( holder ) ; String method = endpoint . getMethod ( ) ; if ( method != null ) { beanProcessor . setMethod ( method ) ; } } public void process ( Exchange exchange ) throws Exception { beanProcessor . process ( exchange ) ; } } 	0	['2', '3', '0', '8', '11', '0', '1', '8', '2', '0', '37', '1', '1', '0.952380952', '0.666666667', '0', '0', '17', '1', '0.5', '0']
package org . apache . camel . model . dataformat ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . util . ObjectHelper ; @ XmlRootElement ( name = "jaxb" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class JaxbDataFormat extends DataFormatType { @ XmlAttribute ( required = true ) private String contextPath ; @ XmlAttribute ( required = false ) private Boolean prettyPrint ; public JaxbDataFormat ( ) { super ( "org.apache.camel.converter.jaxb.JaxbDataFormat" ) ; } public JaxbDataFormat ( boolean prettyPrint ) { this ( ) ; setPrettyPrint ( prettyPrint ) ; } public String getContextPath ( ) { return contextPath ; } public void setContextPath ( String contextPath ) { this . contextPath = contextPath ; } public Boolean getPrettyPrint ( ) { return prettyPrint ; } public void setPrettyPrint ( Boolean prettyPrint ) { this . prettyPrint = prettyPrint ; } @ Override protected void configureDataFormat ( DataFormat dataFormat ) { Boolean answer = ObjectHelper . toBoolean ( getPrettyPrint ( ) ) ; if ( answer != null && answer . booleanValue ( ) ) { setProperty ( dataFormat , "prettyPrint" , Boolean . TRUE ) ; } setProperty ( dataFormat , "contextPath" , contextPath ) ; } } 	1	['7', '3', '0', '4', '12', '13', '1', '3', '6', '0.583333333', '55', '1', '0', '0.642857143', '0.314285714', '1', '2', '6.571428571', '3', '1', '2']
package org . apache . camel . model ; import java . util . Collection ; import java . util . Collections ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Intercept ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . builder . PredicateBuilder ; import org . apache . camel . processor . Interceptor ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "intercept" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class InterceptType extends OutputType < ProcessorType > { @ XmlTransient private ProceedType proceed = new ProceedType ( ) ; @ XmlTransient private Boolean stop = Boolean . FALSE ; @ XmlTransient private Boolean usePredicate = Boolean . FALSE ; @ Override public String toString ( ) { return "Intercept[" + getOutputs ( ) + "]" ; } @ Override public String getShortName ( ) { return "intercept" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { Interceptor interceptor = new Interceptor ( ) ; routeContext . intercept ( interceptor ) ; final Processor interceptRoute = createOutputsProcessor ( routeContext ) ; interceptor . setInterceptorLogic ( interceptRoute ) ; return interceptor ; } public ChoiceType when ( Predicate predicate ) { usePredicate = Boolean . TRUE ; ChoiceType choice = choice ( ) . when ( PredicateBuilder . not ( predicate ) ) ; choice . addOutput ( proceed ) ; return choice . otherwise ( ) ; } public ProceedType getProceed ( ) { return proceed ; } public void stopIntercept ( ) { stop = Boolean . TRUE ; } public InterceptType createProxy ( ) { InterceptType answer = new InterceptType ( ) ; answer . getOutputs ( ) . addAll ( this . getOutputs ( ) ) ; if ( answer . getOutputs ( ) . size ( ) > 0 ) { ChoiceType choice = null ; for ( ProcessorType processor : answer . getOutputs ( ) ) { if ( processor instanceof ChoiceType ) { choice = ( ChoiceType ) processor ; if ( usePredicate . booleanValue ( ) && stop . booleanValue ( ) ) { WhenType when = choice . getWhenClauses ( ) . get ( 0 ) ; when . getOutputs ( ) . remove ( this . getProceed ( ) ) ; } addProceedProxy ( this . getProceed ( ) , answer . getProceed ( ) , choice . getWhenClauses ( ) . get ( choice . getWhenClauses ( ) . size ( ) - 1 ) , usePredicate . booleanValue ( ) && ! stop . booleanValue ( ) ) ; addProceedProxy ( this . getProceed ( ) , answer . getProceed ( ) , choice . getOtherwise ( ) , ! stop . booleanValue ( ) ) ; if ( stop . booleanValue ( ) ) { addProceedProxy ( this . getProceed ( ) , answer . getProceed ( ) , choice . getWhenClauses ( ) . get ( choice . getWhenClauses ( ) . size ( ) - 1 ) , usePredicate . booleanValue ( ) ) ; } break ; } } if ( choice == null ) { addProceedProxy ( this . getProceed ( ) , answer . getProceed ( ) , answer , ! stop . booleanValue ( ) ) ; } } return answer ; } private void addProceedProxy ( ProceedType orig , ProceedType proxy , ProcessorType < ? > processor , boolean force ) { int index = processor . getOutputs ( ) . indexOf ( orig ) ; if ( index >= 0 ) { processor . addOutput ( proxy ) ; List < ProcessorType < ? > > outs = processor . getOutputs ( ) ; outs . remove ( proxy ) ; outs . set ( index , proxy ) ; } else if ( force ) { processor . addOutput ( proxy ) ; } } } 	0	['9', '4', '0', '14', '40', '22', '3', '12', '8', '0.708333333', '244', '1', '1', '0.950310559', '0.259259259', '1', '2', '25.77777778', '11', '2.2222', '0']
package org . apache . camel . component . file ; import java . io . File ; import java . io . IOException ; import java . lang . reflect . Method ; import java . util . Properties ; import org . apache . camel . Consumer ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . component . file . strategy . FileProcessStrategySupport ; import org . apache . camel . impl . ScheduledPollEndpoint ; import org . apache . camel . util . FactoryFinder ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . UuidGenerator ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class FileEndpoint extends ScheduledPollEndpoint < FileExchange > { private static final transient Log LOG = LogFactory . getLog ( FileEndpoint . class ) ; private static final String DEFAULT_STRATEGYFACTORY_CLASS = "org.apache.camel.component.file.strategy.FileProcessStrategyFactory" ; private File file ; private FileProcessStrategy fileProcessStrategy ; private boolean autoCreate = true ; private boolean lock = true ; private boolean delete ; private boolean noop ; private boolean append = true ; private String moveNamePrefix ; private String moveNamePostfix ; private String [ ] excludedNamePrefixes = { "." } ; private String [ ] excludedNamePostfixes = { FileProcessStrategySupport . DEFAULT_LOCK_FILE_POSTFIX } ; private int bufferSize = 128 * 1024 ; private boolean ignoreFileNameHeader ; protected FileEndpoint ( File file , String endpointUri , FileComponent component ) { super ( endpointUri , component ) ; this . file = file ; } public FileEndpoint ( String endpointUri , File file ) { super ( endpointUri ) ; this . file = file ; } public FileEndpoint ( File file ) { this . file = file ; } public FileEndpoint ( ) { } public Producer < FileExchange > createProducer ( ) throws Exception { Producer < FileExchange > result = new FileProducer ( this ) ; return result ; } public Consumer < FileExchange > createConsumer ( Processor processor ) throws Exception { Consumer < FileExchange > result = new FileConsumer ( this , processor ) ; configureConsumer ( result ) ; return result ; } public FileExchange createExchange ( File file ) { return new FileExchange ( getCamelContext ( ) , getExchangePattern ( ) , file ) ; } @ Override public FileExchange createExchange ( ) { return createExchange ( getFile ( ) ) ; } @ Override public FileExchange createExchange ( ExchangePattern pattern ) { return new FileExchange ( getCamelContext ( ) , pattern , file ) ; } public String getGeneratedFileName ( Message message ) { return getFileFriendlyMessageId ( message . getMessageId ( ) ) ; } public void configureMessage ( File file , Message message ) { message . setBody ( file ) ; String relativePath = file . getPath ( ) . substring ( getFile ( ) . getPath ( ) . length ( ) ) ; if ( relativePath . startsWith ( File . separator ) || relativePath . startsWith ( "/" ) ) { relativePath = relativePath . substring ( 1 ) ; } message . setHeader ( FileComponent . HEADER_FILE_NAME , relativePath ) ; } public File getFile ( ) { ObjectHelper . notNull ( file , "file" ) ; if ( autoCreate && ! file . exists ( ) ) { file . mkdirs ( ) ; } return file ; } public void setFile ( File file ) { this . file = file ; } public boolean isSingleton ( ) { return true ; } public boolean isAutoCreate ( ) { return this . autoCreate ; } public void setAutoCreate ( boolean autoCreate ) { this . autoCreate = autoCreate ; } public FileProcessStrategy getFileStrategy ( ) { if ( fileProcessStrategy == null ) { fileProcessStrategy = createFileStrategy ( ) ; LOG . debug ( "Using file process strategy: " + fileProcessStrategy ) ; } return fileProcessStrategy ; } public void setFileStrategy ( FileProcessStrategy fileProcessStrategy ) { this . fileProcessStrategy = fileProcessStrategy ; } public boolean isDelete ( ) { return delete ; } public void setDelete ( boolean delete ) { this . delete = delete ; } public boolean isLock ( ) { return lock ; } public void setLock ( boolean lock ) { this . lock = lock ; } public String getMoveNamePostfix ( ) { return moveNamePostfix ; } public void setMoveNamePostfix ( String moveNamePostfix ) { this . moveNamePostfix = moveNamePostfix ; } public String getMoveNamePrefix ( ) { return moveNamePrefix ; } public void setMoveNamePrefix ( String moveNamePrefix ) { this . moveNamePrefix = moveNamePrefix ; } public String [ ] getExcludedNamePrefixes ( ) { return excludedNamePrefixes ; } public void setExcludedNamePrefixes ( String [ ] excludedNamePrefixes ) { this . excludedNamePrefixes = excludedNamePrefixes ; } public String [ ] getExcludedNamePostfixes ( ) { return excludedNamePostfixes ; } public void setExcludedNamePostfixes ( String [ ] excludedNamePostfixes ) { this . excludedNamePostfixes = excludedNamePostfixes ; } public boolean isNoop ( ) { return noop ; } public void setNoop ( boolean noop ) { this . noop = noop ; } public boolean isAppend ( ) { return append ; } public void setAppend ( boolean append ) { this . append = append ; } public int getBufferSize ( ) { return bufferSize ; } public void setBufferSize ( int bufferSize ) { this . bufferSize = bufferSize ; } public boolean isIgnoreFileNameHeader ( ) { return ignoreFileNameHeader ; } public void setIgnoreFileNameHeader ( boolean ignoreFileNameHeader ) { this . ignoreFileNameHeader = ignoreFileNameHeader ; } protected FileProcessStrategy createFileStrategy ( ) { Class < ? > factory = null ; try { FactoryFinder finder = new FactoryFinder ( "META-INF/services/org/apache/camel/component/" ) ; factory = finder . findClass ( "file" , "strategy.factory." ) ; } catch ( ClassNotFoundException e ) { LOG . debug ( "'strategy.factory.class' not found" , e ) ; } catch ( IOException e ) { LOG . debug ( "No strategy factory defined in 'META-INF/services/org/apache/camel/component/file'" , e ) ; } if ( factory == null ) { factory = ObjectHelper . loadClass ( DEFAULT_STRATEGYFACTORY_CLASS ) ; if ( factory == null ) { throw new TypeNotPresentException ( "FileProcessStrategyFactory class not found" , null ) ; } } try { Method factoryMethod = factory . getMethod ( "createFileProcessStrategy" , Properties . class ) ; return ( FileProcessStrategy ) ObjectHelper . invokeMethod ( factoryMethod , null , getParamsAsProperties ( ) ) ; } catch ( NoSuchMethodException e ) { throw new TypeNotPresentException ( factory . getSimpleName ( ) + ".createFileProcessStrategy(Properties params) method not found" , e ) ; } } protected Properties getParamsAsProperties ( ) { Properties params = new Properties ( ) ; if ( isNoop ( ) ) { params . setProperty ( "noop" , Boolean . toString ( true ) ) ; } if ( isDelete ( ) ) { params . setProperty ( "delete" , Boolean . toString ( true ) ) ; } if ( isAppend ( ) ) { params . setProperty ( "append" , Boolean . toString ( true ) ) ; } if ( isLock ( ) ) { params . setProperty ( "lock" , Boolean . toString ( true ) ) ; } if ( moveNamePrefix != null ) { params . setProperty ( "moveNamePrefix" , moveNamePrefix ) ; } if ( moveNamePostfix != null ) { params . setProperty ( "moveNamePostfix" , moveNamePostfix ) ; } return params ; } @ Override protected String createEndpointUri ( ) { return "file://" + getFile ( ) . getAbsolutePath ( ) ; } protected String getFileFriendlyMessageId ( String id ) { return UuidGenerator . generateSanitizedId ( id ) ; } } 	1	['45', '3', '0', '22', '81', '814', '7', '19', '39', '0.909090909', '555', '1', '1', '0.402985075', '0.146694215', '1', '2', '11', '7', '1.1778', '5']
package org . apache . camel . impl ; import org . apache . camel . Exchange ; import org . apache . camel . spi . ExchangeConverter ; public class DefaultExchangeConverter implements ExchangeConverter { public < T > T convertTo ( Class < T > type , Exchange exchange ) { throw new UnsupportedOperationException ( "Not implemented yet" ) ; } } 	0	['2', '1', '0', '3', '4', '1', '1', '2', '2', '2', '10', '0', '0', '0', '0.666666667', '0', '0', '4', '1', '0.5', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . Delayer ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "delayer" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class DelayerType extends ExpressionNode { private Long delay = 0L ; public DelayerType ( ) { } public DelayerType ( Expression processAtExpression ) { super ( processAtExpression ) ; } public DelayerType ( ExpressionType processAtExpression ) { super ( processAtExpression ) ; } public DelayerType ( Expression processAtExpression , long delay ) { super ( processAtExpression ) ; this . delay = delay ; } @ Override public String toString ( ) { return "Delayer[ " + getExpression ( ) + " -> " + getOutputs ( ) + "]" ; } @ Override public String getShortName ( ) { return "delayer" ; } public Long getDelay ( ) { return delay ; } public void setDelay ( Long delay ) { this . delay = delay ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { Processor childProcessor = routeContext . createProcessor ( this ) ; Expression processAtExpression = getExpression ( ) != null ? getExpression ( ) . createExpression ( routeContext ) : null ; return new Delayer ( childProcessor , processAtExpression , delay ) ; } } 	1	['9', '4', '0', '9', '23', '0', '3', '7', '9', '0.25', '94', '1', '0', '0.969325153', '0.277777778', '2', '3', '9.333333333', '1', '0.5556', '3']
package org . apache . camel . component . jms ; public enum ConsumerType { Simple , Default , ServerSessionPool } 	0	['4', '2', '0', '4', '7', '4', '3', '1', '2', '0.916666667', '56', '0.25', '4', '0.857142857', '0.444444444', '1', '1', '12', '1', '0.5', '0']
package org . apache . camel . component . file . strategy ; import java . io . File ; import org . apache . camel . component . file . FileEndpoint ; import org . apache . camel . component . file . FileExchange ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class RenameFileProcessStrategy extends FileProcessStrategySupport { private static final transient Log LOG = LogFactory . getLog ( RenameFileProcessStrategy . class ) ; private FileRenamer renamer ; public RenameFileProcessStrategy ( ) { this ( true ) ; } public RenameFileProcessStrategy ( boolean lock ) { this ( lock , ".camel/" , "" ) ; } public RenameFileProcessStrategy ( boolean lock , String namePrefix , String namePostfix ) { this ( lock , new DefaultFileRenamer ( namePrefix , namePostfix ) ) ; } public RenameFileProcessStrategy ( boolean lock , FileRenamer renamer ) { super ( lock ) ; this . renamer = renamer ; } @ Override public void commit ( FileEndpoint endpoint , FileExchange exchange , File file ) throws Exception { File newName = renamer . renameFile ( file ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Renaming file: " + file + " to: " + newName ) ; } if ( newName . exists ( ) ) { newName . delete ( ) ; } newName . getParentFile ( ) . mkdirs ( ) ; boolean renamed = file . renameTo ( newName ) ; if ( ! renamed ) { LOG . warn ( "Could not rename file from: " + file + " to " + newName ) ; } super . commit ( endpoint , exchange , file ) ; } public FileRenamer getRenamer ( ) { return renamer ; } public void setRenamer ( FileRenamer renamer ) { this . renamer = renamer ; } } 	1	['8', '2', '0', '8', '25', '14', '1', '7', '7', '0.642857143', '105', '1', '1', '0.666666667', '0.326530612', '0', '0', '11.875', '1', '0.375', '1']
package org . apache . camel . component . irc ; import org . apache . commons . logging . Log ; import org . schwering . irc . lib . IRCEventAdapter ; import org . schwering . irc . lib . IRCModeParser ; import org . schwering . irc . lib . IRCUser ; public class IrcErrorLogger extends IRCEventAdapter { private Log log ; public IrcErrorLogger ( Log log ) { this . log = log ; } @ Override public void onRegistered ( ) { super . onRegistered ( ) ; log . info ( "onRegistered" ) ; } @ Override public void onDisconnected ( ) { super . onDisconnected ( ) ; log . info ( "onDisconnected" ) ; } @ Override public void onMode ( String string , IRCUser ircUser , IRCModeParser ircModeParser ) { super . onMode ( string , ircUser , ircModeParser ) ; log . info ( "onMode.string = " + string ) ; log . info ( "onMode.ircUser = " + ircUser ) ; log . info ( "onMode.ircModeParser = " + ircModeParser ) ; } @ Override public void onMode ( IRCUser ircUser , String string , String string1 ) { super . onMode ( ircUser , string , string1 ) ; log . info ( "onMode.ircUser = " + ircUser ) ; log . info ( "onMode.string = " + string ) ; log . info ( "onMode.string1 = " + string1 ) ; } @ Override public void onPing ( String string ) { super . onPing ( string ) ; log . info ( "onPing.string = " + string ) ; } @ Override public void onError ( String string ) { log . info ( "onError.string = " + string ) ; } @ Override public void onError ( int i , String string ) { super . onError ( i , string ) ; log . error ( "onError.i = " + i ) ; log . error ( "onError.string = " + string ) ; } @ Override public void unknown ( String string , String string1 , String string2 , String string3 ) { super . unknown ( string , string1 , string2 , string3 ) ; log . error ( "unknown.string = " + string ) ; log . error ( "unknown.string1 = " + string1 ) ; log . error ( "unknown.string2 = " + string2 ) ; log . error ( "unknown.string3 = " + string3 ) ; } } 	0	['9', '0', '0', '5', '24', '0', '1', '4', '9', '0', '213', '1', '0', '0', '0.37037037', '0', '0', '22.55555556', '1', '0.8889', '0']
package org . apache . camel . processor . validation ; import java . io . File ; import java . io . IOException ; import java . net . URL ; import javax . xml . XMLConstants ; import javax . xml . transform . Source ; import javax . xml . transform . dom . DOMResult ; import javax . xml . transform . dom . DOMSource ; import javax . xml . validation . Schema ; import javax . xml . validation . SchemaFactory ; import javax . xml . validation . Validator ; import org . xml . sax . SAXException ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public class ValidatingProcessor implements Processor { private Schema schema ; private ValidatorErrorHandler errorHandler = new DefaultValidationErrorHandler ( ) ; private String schemaLanguage = XMLConstants . W3C_XML_SCHEMA_NS_URI ; private Source schemaSource ; private SchemaFactory schemaFactory ; private URL schemaUrl ; private File schemaFile ; public void process ( Exchange exchange ) throws Exception { Schema schema = getSchema ( ) ; Validator validator = schema . newValidator ( ) ; Source source = exchange . getIn ( ) . getBody ( DOMSource . class ) ; if ( source == null ) { throw new NoXmlBodyValidationException ( exchange ) ; } errorHandler . reset ( ) ; validator . setErrorHandler ( errorHandler ) ; DOMResult result = new DOMResult ( ) ; validator . validate ( source , result ) ; errorHandler . handleErrors ( exchange , schema , result ) ; } public Schema getSchema ( ) throws IOException , SAXException { if ( schema == null ) { schema = createSchema ( ) ; } return schema ; } public void setSchema ( Schema schema ) { this . schema = schema ; } public String getSchemaLanguage ( ) { return schemaLanguage ; } public void setSchemaLanguage ( String schemaLanguage ) { this . schemaLanguage = schemaLanguage ; } public Source getSchemaSource ( ) throws IOException { if ( schemaSource == null ) { schemaSource = createSchemaSource ( ) ; } return schemaSource ; } public void setSchemaSource ( Source schemaSource ) { this . schemaSource = schemaSource ; } public URL getSchemaUrl ( ) { return schemaUrl ; } public void setSchemaUrl ( URL schemaUrl ) { this . schemaUrl = schemaUrl ; } public File getSchemaFile ( ) { return schemaFile ; } public void setSchemaFile ( File schemaFile ) { this . schemaFile = schemaFile ; } public SchemaFactory getSchemaFactory ( ) { if ( schemaFactory == null ) { schemaFactory = createSchemaFactory ( ) ; } return schemaFactory ; } public void setSchemaFactory ( SchemaFactory schemaFactory ) { this . schemaFactory = schemaFactory ; } public ValidatorErrorHandler getErrorHandler ( ) { return errorHandler ; } public void setErrorHandler ( ValidatorErrorHandler errorHandler ) { this . errorHandler = errorHandler ; } protected SchemaFactory createSchemaFactory ( ) { return SchemaFactory . newInstance ( schemaLanguage ) ; } protected Source createSchemaSource ( ) throws IOException { throw new IllegalArgumentException ( "You must specify a schema, " + "schemaFile, schemaSource or schemaUrl property" ) ; } protected Schema createSchema ( ) throws SAXException , IOException { SchemaFactory factory = getSchemaFactory ( ) ; URL url = getSchemaUrl ( ) ; if ( url != null ) { return factory . newSchema ( url ) ; } File file = getSchemaFile ( ) ; if ( file != null ) { return factory . newSchema ( file ) ; } return factory . newSchema ( getSchemaSource ( ) ) ; } } 	1	['19', '1', '1', '7', '35', '137', '1', '6', '16', '0.857142857', '183', '1', '1', '0', '0.157894737', '0', '0', '8.263157895', '2', '1', '1']
package org . apache . camel . component . cxf . transport ; import java . io . IOException ; import java . io . OutputStream ; import java . util . List ; import java . util . Map ; import java . util . logging . Level ; import java . util . logging . Logger ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Processor ; import org . apache . camel . ProducerTemplate ; import org . apache . camel . component . cxf . CxfConstants ; import org . apache . camel . component . cxf . CxfSoapBinding ; import org . apache . camel . impl . DefaultCamelContext ; import org . apache . cxf . Bus ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . configuration . Configurable ; import org . apache . cxf . configuration . Configurer ; import org . apache . cxf . helpers . CastUtils ; import org . apache . cxf . io . CachedOutputStream ; import org . apache . cxf . message . Message ; import org . apache . cxf . service . Service ; import org . apache . cxf . service . model . EndpointInfo ; import org . apache . cxf . transport . AbstractConduit ; import org . apache . cxf . transport . Conduit ; import org . apache . cxf . transport . Destination ; import org . apache . cxf . transport . MessageObserver ; import org . apache . cxf . ws . addressing . EndpointReferenceType ; public class CamelConduit extends AbstractConduit implements Configurable { protected static final String BASE_BEAN_NAME_SUFFIX = ".camel-conduit" ; private static final Logger LOG = LogUtils . getL7dLogger ( CamelConduit . class ) ; private CamelContext camelContext ; private EndpointInfo endpointInfo ; private String targetCamelEndpointUri ; private ProducerTemplate < Exchange > camelTemplate ; private Bus bus ; public CamelConduit ( CamelContext context , Bus b , EndpointInfo endpointInfo ) { this ( context , b , endpointInfo , null ) ; } public CamelConduit ( CamelContext context , Bus b , EndpointInfo epInfo , EndpointReferenceType targetReference ) { super ( targetReference ) ; String address = epInfo . getAddress ( ) ; if ( address != null ) { targetCamelEndpointUri = address . substring ( CxfConstants . CAMEL_TRANSPORT_PREFIX . length ( ) ) ; if ( targetCamelEndpointUri . startsWith ( "//" ) ) { targetCamelEndpointUri = targetCamelEndpointUri . substring ( 2 ) ; } } camelContext = context ; endpointInfo = epInfo ; bus = b ; initConfig ( ) ; } public void setCamelContext ( CamelContext context ) { camelContext = context ; } public CamelContext getCamelContext ( ) { return camelContext ; } public void prepare ( Message message ) throws IOException { getLogger ( ) . log ( Level . FINE , "CamelConduit send message" ) ; message . setContent ( OutputStream . class , new CamelOutputStream ( message ) ) ; } public void close ( ) { getLogger ( ) . log ( Level . FINE , "CamelConduit closed " ) ; } protected Logger getLogger ( ) { return LOG ; } public String getBeanName ( ) { if ( endpointInfo == null || endpointInfo . getName ( ) == null ) { return "default" + BASE_BEAN_NAME_SUFFIX ; } return endpointInfo . getName ( ) . toString ( ) + BASE_BEAN_NAME_SUFFIX ; } private void initConfig ( ) { if ( bus != null ) { Configurer configurer = bus . getExtension ( Configurer . class ) ; if ( null != configurer ) { configurer . configureBean ( this ) ; } } } public ProducerTemplate < Exchange > getCamelTemplate ( ) { if ( camelTemplate == null ) { CamelContext ctx = camelContext != null ? camelContext : new DefaultCamelContext ( ) ; camelTemplate = ctx . createProducerTemplate ( ) ; } return camelTemplate ; } public void setCamelTemplate ( ProducerTemplate < Exchange > template ) { camelTemplate = template ; } private class CamelOutputStream extends CachedOutputStream { private Message outMessage ; private boolean isOneWay ; public CamelOutputStream ( Message m ) { outMessage = m ; } protected void doFlush ( ) throws IOException { } protected void doClose ( ) throws IOException { isOneWay = outMessage . getExchange ( ) . isOneWay ( ) ; commitOutputMessage ( ) ; } protected void onWrite ( ) throws IOException { } private void commitOutputMessage ( ) { ExchangePattern pattern ; if ( isOneWay ) { pattern = ExchangePattern . InOnly ; } else { pattern = ExchangePattern . InOut ; } getLogger ( ) . log ( Level . FINE , "send the message to endpoint" + targetCamelEndpointUri ) ; org . apache . camel . Exchange exchange = getCamelTemplate ( ) . send ( targetCamelEndpointUri , pattern , new Processor ( ) { public void process ( org . apache . camel . Exchange ex ) throws IOException { CachedOutputStream outputStream = ( CachedOutputStream ) outMessage . getContent ( OutputStream . class ) ; Map < String , List < String > > protocolHeader = CastUtils . cast ( ( Map < ? , ? > ) outMessage . get ( Message . PROTOCOL_HEADERS ) ) ; CxfSoapBinding . setProtocolHeader ( ex . getIn ( ) . getHeaders ( ) , protocolHeader ) ; ex . getIn ( ) . setBody ( outputStream . getBytes ( ) ) ; getLogger ( ) . log ( Level . FINE , "template sending request: " , ex . getIn ( ) ) ; } } ) ; exchange . setProperty ( CxfConstants . CXF_EXCHANGE , outMessage . getExchange ( ) ) ; if ( ! isOneWay ) { handleResponse ( exchange ) ; } } private void handleResponse ( org . apache . camel . Exchange exchange ) { org . apache . cxf . message . Message inMessage = CxfSoapBinding . getCxfInMessage ( exchange , true ) ; incomingObserver . onMessage ( inMessage ) ; } } protected class DecoupledDestination implements Destination { protected MessageObserver decoupledMessageObserver ; private EndpointReferenceType address ; DecoupledDestination ( EndpointReferenceType ref , MessageObserver incomingObserver ) { address = ref ; decoupledMessageObserver = incomingObserver ; } public EndpointReferenceType getAddress ( ) { return address ; } public Conduit getBackChannel ( Message inMessage , Message partialResponse , EndpointReferenceType addr ) throws IOException { return null ; } public void shutdown ( ) { } public synchronized void setMessageObserver ( MessageObserver observer ) { decoupledMessageObserver = observer ; } public synchronized MessageObserver getMessageObserver ( ) { return decoupledMessageObserver ; } } } 	0	['14', '0', '0', '16', '32', '69', '4', '13', '9', '0.857142857', '165', '1', '2', '0', '0.221153846', '0', '0', '10.28571429', '3', '1.2143', '0']
package org . apache . camel . component . file ; import java . io . File ; import java . util . concurrent . ConcurrentHashMap ; import org . apache . camel . AsyncCallback ; import org . apache . camel . Processor ; import org . apache . camel . impl . ScheduledPollConsumer ; import org . apache . camel . processor . DeadLetterChannel ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class FileConsumer extends ScheduledPollConsumer < FileExchange > { private static final transient Log LOG = LogFactory . getLog ( FileConsumer . class ) ; private FileEndpoint endpoint ; private ConcurrentHashMap < File , File > filesBeingProcessed = new ConcurrentHashMap < File , File > ( ) ; private ConcurrentHashMap < File , Long > fileSizes = new ConcurrentHashMap < File , Long > ( ) ; private ConcurrentHashMap < File , Long > noopMap = new ConcurrentHashMap < File , Long > ( ) ; private boolean generateEmptyExchangeWhenIdle ; private boolean recursive = true ; private String regexPattern = "" ; private long lastPollTime ; private int unchangedDelay ; private boolean unchangedSize ; public FileConsumer ( final FileEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; } protected synchronized void poll ( ) throws Exception { int rc = pollFileOrDirectory ( endpoint . getFile ( ) , isRecursive ( ) ) ; if ( rc == 0 && generateEmptyExchangeWhenIdle ) { final FileExchange exchange = endpoint . createExchange ( ( File ) null ) ; getAsyncProcessor ( ) . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { } } ) ; } lastPollTime = System . currentTimeMillis ( ) ; } protected int pollFileOrDirectory ( File fileOrDirectory , boolean processDir ) { if ( ! fileOrDirectory . isDirectory ( ) ) { return pollFile ( fileOrDirectory ) ; } else if ( processDir ) { int rc = 0 ; if ( isValidFile ( fileOrDirectory ) ) { LOG . debug ( "Polling directory " + fileOrDirectory ) ; File [ ] files = fileOrDirectory . listFiles ( ) ; for ( File file : files ) { rc += pollFileOrDirectory ( file , isRecursive ( ) ) ; } } return rc ; } else { LOG . debug ( "Skipping directory " + fileOrDirectory ) ; return 0 ; } } protected int pollFile ( final File file ) { if ( ! file . exists ( ) ) { return 0 ; } if ( ! isValidFile ( file ) ) { return 0 ; } if ( ! endpoint . isNoop ( ) ) { if ( filesBeingProcessed . contains ( file ) ) { return 1 ; } filesBeingProcessed . put ( file , file ) ; } final FileProcessStrategy processStrategy = endpoint . getFileStrategy ( ) ; final FileExchange exchange = endpoint . createExchange ( file ) ; endpoint . configureMessage ( file , exchange . getIn ( ) ) ; try { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "About to process file: " + file + " using exchange: " + exchange ) ; } if ( processStrategy . begin ( endpoint , exchange , file ) ) { getAsyncProcessor ( ) . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { boolean failed = exchange . isFailed ( ) ; boolean handled = DeadLetterChannel . isFailureHandled ( exchange ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Done processing file: " + file + ". Status is: " + ( failed ? "failed: " + failed + ", handled by failure processor: " + handled : "OK" ) ) ; } if ( ! failed || handled ) { processStrategyCommit ( processStrategy , exchange , file , handled ) ; } else if ( failed && ! handled ) { handleException ( exchange . getException ( ) ) ; } filesBeingProcessed . remove ( file ) ; } } ) ; } else { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( endpoint + " cannot process file: " + file ) ; } } } catch ( Throwable e ) { handleException ( e ) ; } return 1 ; } protected void processStrategyCommit ( FileProcessStrategy processStrategy , FileExchange exchange , File file , boolean failureHandled ) { try { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Committing file strategy: " + processStrategy + " for file: " + file + ( failureHandled ? " that was handled by the failure processor." : "" ) ) ; } processStrategy . commit ( endpoint , exchange , file ) ; } catch ( Exception e ) { LOG . warn ( "Error committing file strategy: " + processStrategy , e ) ; handleException ( e ) ; } } protected boolean isValidFile ( File file ) { boolean result = false ; if ( file != null && file . exists ( ) ) { if ( isMatched ( file ) && isChanged ( file ) ) { result = true ; } } return result ; } protected boolean isChanged ( File file ) { if ( file == null ) { return false ; } else if ( file . isDirectory ( ) ) { return true ; } else { boolean lastModifiedCheck = false ; long modifiedDuration = 0 ; if ( getUnchangedDelay ( ) > 0 ) { modifiedDuration = System . currentTimeMillis ( ) - file . lastModified ( ) ; lastModifiedCheck = modifiedDuration >= getUnchangedDelay ( ) ; } long fileModified = file . lastModified ( ) ; Long previousModified = noopMap . get ( file ) ; noopMap . put ( file , fileModified ) ; if ( previousModified == null || fileModified > previousModified ) { lastModifiedCheck = true ; } boolean sizeCheck = false ; long sizeDifference = 0 ; if ( isUnchangedSize ( ) ) { Long value = fileSizes . get ( file ) ; if ( value == null ) { sizeCheck = true ; } else { sizeCheck = file . length ( ) != value ; } } boolean answer = lastModifiedCheck || sizeCheck ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "file:" + file + " isChanged:" + answer + " " + "sizeCheck:" + sizeCheck + "(" + sizeDifference + ") " + "lastModifiedCheck:" + lastModifiedCheck + "(" + modifiedDuration + ")" ) ; } if ( isUnchangedSize ( ) ) { if ( answer ) { fileSizes . put ( file , file . length ( ) ) ; } else { fileSizes . remove ( file ) ; } } return answer ; } } protected boolean isMatched ( File file ) { String name = file . getName ( ) ; if ( regexPattern != null && regexPattern . length ( ) > 0 ) { if ( ! name . matches ( getRegexPattern ( ) ) ) { return false ; } } String [ ] prefixes = endpoint . getExcludedNamePrefixes ( ) ; if ( prefixes != null ) { for ( String prefix : prefixes ) { if ( name . startsWith ( prefix ) ) { return false ; } } } String [ ] postfixes = endpoint . getExcludedNamePostfixes ( ) ; if ( postfixes != null ) { for ( String postfix : postfixes ) { if ( name . endsWith ( postfix ) ) { return false ; } } } return true ; } public boolean isRecursive ( ) { return this . recursive ; } public void setRecursive ( boolean recursive ) { this . recursive = recursive ; } public String getRegexPattern ( ) { return this . regexPattern ; } public void setRegexPattern ( String regexPattern ) { this . regexPattern = regexPattern ; } public boolean isGenerateEmptyExchangeWhenIdle ( ) { return generateEmptyExchangeWhenIdle ; } public void setGenerateEmptyExchangeWhenIdle ( boolean generateEmptyExchangeWhenIdle ) { this . generateEmptyExchangeWhenIdle = generateEmptyExchangeWhenIdle ; } public int getUnchangedDelay ( ) { return unchangedDelay ; } public void setUnchangedDelay ( int unchangedDelay ) { this . unchangedDelay = unchangedDelay ; } public boolean isUnchangedSize ( ) { return unchangedSize ; } public void setUnchangedSize ( boolean unchangedSize ) { this . unchangedSize = unchangedSize ; } } 	1	['22', '4', '0', '14', '66', '151', '3', '14', '11', '0.852813853', '603', '1', '1', '0.62962963', '0.164502165', '1', '1', '25.90909091', '15', '2.6818', '8']
package org . apache . camel . component . xmpp ; import org . jivesoftware . smack . XMPPException ; public class RuntimeXmppException extends RuntimeException { private static final long serialVersionUID = - 2141493732308871761L ; public RuntimeXmppException ( XMPPException cause ) { super ( cause ) ; } public RuntimeXmppException ( String message , XMPPException cause ) { super ( message , cause ) ; } } 	0	['2', '4', '0', '3', '4', '1', '2', '1', '2', '2', '12', '1', '0', '1', '0.833333333', '0', '0', '4.5', '0', '0', '0']
package org . apache . camel . impl ; import java . net . URI ; import java . util . Map ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . ScheduledThreadPoolExecutor ; import java . util . concurrent . ThreadFactory ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . ResolveEndpointFailedException ; import org . apache . camel . spi . Injector ; import org . apache . camel . spi . Registry ; import org . apache . camel . util . CamelContextHelper ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . URISupport ; import org . apache . camel . util . UnsafeUriCharactersEncoder ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public abstract class DefaultComponent < E extends Exchange > extends ServiceSupport implements Component < E > { private static final transient Log LOG = LogFactory . getLog ( DefaultComponent . class ) ; private int defaultThreadPoolSize = 5 ; private CamelContext camelContext ; private ScheduledExecutorService executorService ; public DefaultComponent ( ) { } public DefaultComponent ( CamelContext context ) { this . camelContext = context ; } public Endpoint < E > createEndpoint ( String uri ) throws Exception { ObjectHelper . notNull ( getCamelContext ( ) , "camelContext" ) ; URI u = new URI ( UnsafeUriCharactersEncoder . encode ( uri ) ) ; String path = u . getSchemeSpecificPart ( ) ; if ( path . startsWith ( "//" ) ) { path = path . substring ( 2 ) ; } int idx = path . indexOf ( '?' ) ; if ( idx > 0 ) { path = path . substring ( 0 , idx ) ; } Map parameters = URISupport . parseParameters ( u ) ; validateURI ( uri , path , parameters ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Creating endpoint uri=[" + uri + "], path=[" + path + "], parameters=[" + parameters + "]" ) ; } Endpoint < E > endpoint = createEndpoint ( uri , path , parameters ) ; if ( endpoint == null ) { return null ; } if ( parameters != null ) { endpoint . configureProperties ( parameters ) ; if ( useIntrospectionOnEndpoint ( ) ) { setProperties ( endpoint , parameters ) ; } if ( parameters . size ( ) > 0 ) { throw new ResolveEndpointFailedException ( uri , "There are " + parameters . size ( ) + " parameters that couldn't be set on the endpoint." + " Check the uri if the parameters are spelt correctly and that they are properties of the endpoint." + " Unknown parameters=[" + parameters + "]" ) ; } } return endpoint ; } protected void validateURI ( String uri , String path , Map parameters ) throws ResolveEndpointFailedException { if ( uri . contains ( "&" ) && ! uri . contains ( "?" ) ) { throw new ResolveEndpointFailedException ( uri , "Invalid uri syntax: no ? marker however the uri " + "has & parameter separators. Check the uri if its missing a ? marker." ) ; } if ( uri . contains ( "&&" ) ) { throw new ResolveEndpointFailedException ( uri , "Invalid uri syntax: Double && marker found. " + "Check the uri and remove the duplicate & marker." ) ; } } public CamelContext getCamelContext ( ) { return camelContext ; } public void setCamelContext ( CamelContext context ) { this . camelContext = context ; } public ScheduledExecutorService getExecutorService ( ) { if ( executorService == null ) { executorService = createExecutorService ( ) ; } return executorService ; } public void setExecutorService ( ScheduledExecutorService executorService ) { this . executorService = executorService ; } protected ScheduledExecutorService createExecutorService ( ) { return new ScheduledThreadPoolExecutor ( defaultThreadPoolSize , new ThreadFactory ( ) { int counter ; public synchronized Thread newThread ( Runnable runnable ) { Thread thread = new Thread ( runnable ) ; thread . setName ( "Thread: " + ( ++ counter ) + " " + DefaultComponent . this . toString ( ) ) ; return thread ; } } ) ; } protected void doStart ( ) throws Exception { } protected void doStop ( ) throws Exception { if ( executorService != null ) { executorService . shutdown ( ) ; } } protected abstract Endpoint < E > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception ; protected void setProperties ( Object bean , Map parameters ) throws Exception { IntrospectionSupport . setProperties ( getCamelContext ( ) . getTypeConverter ( ) , bean , parameters ) ; } protected boolean useIntrospectionOnEndpoint ( ) { return true ; } public < T > T convertTo ( Class < T > type , Object value ) { return CamelContextHelper . convertTo ( getCamelContext ( ) , type , value ) ; } public < T > T mandatoryConvertTo ( Class < T > type , Object value ) { return CamelContextHelper . mandatoryConvertTo ( getCamelContext ( ) , type , value ) ; } public < T > T newInstance ( Class < T > beanType ) { return getCamelContext ( ) . getInjector ( ) . newInstance ( beanType ) ; } public Object lookup ( String name ) { return getCamelContext ( ) . getRegistry ( ) . lookup ( name ) ; } public < T > T lookup ( String name , Class < T > beanType ) { return getCamelContext ( ) . getRegistry ( ) . lookup ( name , beanType ) ; } public Object mandatoryLookup ( String name ) { return CamelContextHelper . mandatoryLookup ( getCamelContext ( ) , name ) ; } public < T > T mandatoryLookup ( String name , Class < T > beanType ) { return CamelContextHelper . mandatoryLookup ( getCamelContext ( ) , name , beanType ) ; } public < T > T getAndRemoveParameter ( Map parameters , String key , Class < T > type ) { return getAndRemoveParameter ( parameters , key , type , null ) ; } public < T > T getAndRemoveParameter ( Map parameters , String key , Class < T > type , T defaultValue ) { Object value = parameters . remove ( key ) ; if ( value == null ) { value = defaultValue ; } if ( value == null ) { return null ; } return convertTo ( type , value ) ; } } 	1	['24', '2', '36', '53', '61', '256', '38', '16', '16', '0.804347826', '301', '1', '1', '0.382352941', '0.316770186', '1', '1', '11.375', '3', '1', '5']
package org . apache . camel . component . cxf ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . converter . AsyncProcessorTypeConverter ; import org . apache . camel . util . AsyncProcessorHelper ; public class AsyncProcessorDecorator implements AsyncProcessor { private final AsyncProcessor processor ; private final Processor before ; private final Processor after ; public AsyncProcessorDecorator ( Processor processor , Processor before , Processor after ) { this . processor = AsyncProcessorTypeConverter . convert ( processor ) ; this . before = before ; this . after = after ; } public void process ( Exchange exchange ) throws Exception { AsyncProcessorHelper . process ( this , exchange ) ; } public boolean process ( final Exchange exchange , final AsyncCallback callback ) { try { before . process ( exchange ) ; } catch ( Throwable t ) { exchange . setException ( t ) ; callback . done ( true ) ; return true ; } return processor . process ( exchange , new AsyncCallback ( ) { public void done ( boolean doneSynchronously ) { try { after . process ( exchange ) ; callback . done ( doneSynchronously ) ; } catch ( Throwable t ) { exchange . setException ( t ) ; } } } ) ; } } 	0	['4', '1', '0', '9', '12', '2', '3', '7', '3', '0.666666667', '52', '1', '3', '0', '0.4', '0', '0', '11.25', '1', '0.75', '0']
package org . apache . camel . component . file . strategy ; import java . io . File ; import java . io . RandomAccessFile ; import java . nio . channels . Channel ; import java . nio . channels . FileChannel ; import java . nio . channels . FileLock ; import org . apache . camel . component . file . FileEndpoint ; import org . apache . camel . component . file . FileExchange ; import org . apache . camel . component . file . FileProcessStrategy ; import org . apache . camel . util . ExchangeHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public abstract class FileProcessStrategySupport implements FileProcessStrategy { public static final String DEFAULT_LOCK_FILE_POSTFIX = ".cameLock" ; private static final transient Log LOG = LogFactory . getLog ( FileProcessStrategySupport . class ) ; private boolean lockFile ; private FileRenamer lockFileRenamer ; protected FileProcessStrategySupport ( ) { this ( true ) ; } protected FileProcessStrategySupport ( boolean lockFile ) { this ( lockFile , new DefaultFileRenamer ( null , DEFAULT_LOCK_FILE_POSTFIX ) ) ; } protected FileProcessStrategySupport ( boolean lockFile , FileRenamer lockFileRenamer ) { this . lockFile = lockFile ; this . lockFileRenamer = lockFileRenamer ; } public boolean begin ( FileEndpoint endpoint , FileExchange exchange , File file ) throws Exception { if ( isLockFile ( ) ) { File newFile = lockFileRenamer . renameFile ( file ) ; String lockFileName = newFile . getAbsolutePath ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Locking the file: " + file + " using the lock file name: " + lockFileName ) ; } FileChannel channel = new RandomAccessFile ( lockFileName , "rw" ) . getChannel ( ) ; FileLock lock = channel . lock ( ) ; if ( lock != null ) { exchange . setProperty ( "org.apache.camel.fileChannel" , channel ) ; exchange . setProperty ( "org.apache.camel.file.lock" , lock ) ; exchange . setProperty ( "org.apache.camel.file.lock.name" , lockFileName ) ; return true ; } return false ; } return true ; } public void commit ( FileEndpoint endpoint , FileExchange exchange , File file ) throws Exception { if ( isLockFile ( ) ) { Channel channel = ExchangeHelper . getMandatoryProperty ( exchange , "org.apache.camel.fileChannel" , Channel . class ) ; String lockfile = ExchangeHelper . getMandatoryProperty ( exchange , "org.apache.camel.file.lock.name" , String . class ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Unlocking file: " + file ) ; } channel . close ( ) ; File lock = new File ( lockfile ) ; lock . delete ( ) ; } } public boolean isLockFile ( ) { return lockFile ; } public void setLockFile ( boolean lockFile ) { this . lockFile = lockFile ; } public FileRenamer getLockFileRenamer ( ) { return lockFileRenamer ; } public void setLockFileRenamer ( FileRenamer lockFileRenamer ) { this . lockFileRenamer = lockFileRenamer ; } } 	1	['10', '1', '3', '12', '29', '21', '3', '9', '6', '0.722222222', '151', '0.75', '1', '0', '0.37037037', '0', '0', '13.7', '1', '0.6', '2']
package org . apache . camel . util ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; import java . util . SortedSet ; import java . util . TreeSet ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . TimeUnit ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DefaultTimeoutMap implements TimeoutMap , Runnable { private static final transient Log LOG = LogFactory . getLog ( DefaultTimeoutMap . class ) ; private final Map map = new HashMap ( ) ; private SortedSet index = new TreeSet ( ) ; private ScheduledExecutorService executor ; private long purgePollTime ; public DefaultTimeoutMap ( ) { this ( null , 1000L ) ; } public DefaultTimeoutMap ( ScheduledExecutorService executor , long requestMapPollTimeMillis ) { this . executor = executor ; this . purgePollTime = requestMapPollTimeMillis ; schedulePoll ( ) ; } public Object get ( Object key ) { TimeoutMapEntry entry = null ; synchronized ( map ) { entry = ( TimeoutMapEntry ) map . get ( key ) ; if ( entry == null ) { return null ; } index . remove ( entry ) ; updateExpireTime ( entry ) ; index . add ( entry ) ; } return entry . getValue ( ) ; } public void put ( Object key , Object value , long timeoutMillis ) { TimeoutMapEntry entry = new TimeoutMapEntry ( key , value , timeoutMillis ) ; synchronized ( map ) { Object oldValue = map . put ( key , entry ) ; if ( oldValue != null ) { index . remove ( oldValue ) ; } updateExpireTime ( entry ) ; index . add ( entry ) ; } } public void remove ( Object id ) { synchronized ( map ) { TimeoutMapEntry entry = ( TimeoutMapEntry ) map . remove ( id ) ; if ( entry != null ) { index . remove ( entry ) ; } } } public Object [ ] getKeys ( ) { Object [ ] keys = null ; synchronized ( map ) { Set keySet = map . keySet ( ) ; keys = new Object [ keySet . size ( ) ] ; keySet . toArray ( keys ) ; } return keys ; } public int size ( ) { synchronized ( map ) { return map . size ( ) ; } } public void run ( ) { purge ( ) ; schedulePoll ( ) ; } public void purge ( ) { long now = currentTime ( ) ; synchronized ( map ) { for ( Iterator iter = index . iterator ( ) ; iter . hasNext ( ) ; ) { TimeoutMapEntry entry = ( TimeoutMapEntry ) iter . next ( ) ; if ( entry == null ) { break ; } if ( entry . getExpireTime ( ) < now ) { if ( isValidForEviction ( entry ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Evicting inactive request for correlationID: " + entry ) ; } map . remove ( entry . getKey ( ) ) ; iter . remove ( ) ; } } else { break ; } } } } public long getPurgePollTime ( ) { return purgePollTime ; } public void setPurgePollTime ( long purgePollTime ) { this . purgePollTime = purgePollTime ; } public ScheduledExecutorService getExecutor ( ) { return executor ; } public void setExecutor ( ScheduledExecutorService executor ) { this . executor = executor ; } protected void schedulePoll ( ) { if ( executor != null ) { executor . schedule ( this , purgePollTime , TimeUnit . MILLISECONDS ) ; } } protected boolean isValidForEviction ( TimeoutMapEntry entry ) { return true ; } protected void updateExpireTime ( TimeoutMapEntry entry ) { long now = currentTime ( ) ; entry . setExpireTime ( entry . getTimeout ( ) + now ) ; } protected long currentTime ( ) { return System . currentTimeMillis ( ) ; } } 	0	['18', '1', '0', '5', '49', '87', '1', '4', '13', '0.694117647', '317', '1', '0', '0', '0.317647059', '0', '0', '16.33333333', '5', '1.2778', '0']
package org . apache . camel . builder ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import java . util . StringTokenizer ; import java . util . regex . Pattern ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Message ; public final class ExpressionBuilder { private ExpressionBuilder ( ) { } public static < E extends Exchange > Expression < E > headerExpression ( final String headerName ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { Object header = exchange . getIn ( ) . getHeader ( headerName ) ; if ( header == null ) { header = exchange . getProperty ( headerName ) ; } return header ; } @ Override public String toString ( ) { return "header(" + headerName + ")" ; } } ; } public static < E extends Exchange > Expression < E > headersExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getIn ( ) . getHeaders ( ) ; } @ Override public String toString ( ) { return "headers" ; } } ; } public static < E extends Exchange > Expression < E > outHeaderExpression ( final String headerName ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { Message out = exchange . getOut ( false ) ; if ( out == null ) { return null ; } Object header = out . getHeader ( headerName ) ; if ( header == null ) { header = exchange . getProperty ( headerName ) ; } return header ; } @ Override public String toString ( ) { return "outHeader(" + headerName + ")" ; } } ; } public static < E extends Exchange > Expression < E > outHeadersExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getOut ( ) . getHeaders ( ) ; } @ Override public String toString ( ) { return "outHeaders" ; } } ; } public static < E extends Exchange > Expression < E > propertyExpression ( final String propertyName ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getProperty ( propertyName ) ; } @ Override public String toString ( ) { return "property(" + propertyName + ")" ; } } ; } public static < E extends Exchange > Expression < E > propertiesExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getProperties ( ) ; } @ Override public String toString ( ) { return "properties" ; } } ; } public static < E extends Exchange > Expression < E > systemPropertyExpression ( final String propertyName ) { return systemPropertyExpression ( propertyName , null ) ; } public static < E extends Exchange > Expression < E > systemPropertyExpression ( final String propertyName , final String defaultValue ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return System . getProperty ( propertyName , defaultValue ) ; } @ Override public String toString ( ) { return "systemProperty(" + propertyName + ")" ; } } ; } public static < E extends Exchange > Expression < E > constantExpression ( final Object value ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return value ; } @ Override public String toString ( ) { return "" + value ; } } ; } public static < E extends Exchange > Expression < E > bodyExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getIn ( ) . getBody ( ) ; } @ Override public String toString ( ) { return "body" ; } } ; } public static < E extends Exchange , T > Expression < E > bodyExpression ( final Class < T > type ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getIn ( ) . getBody ( type ) ; } @ Override public String toString ( ) { return "bodyAs[" + type . getName ( ) + "]" ; } } ; } public static < E extends Exchange > Expression < E > outBodyExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { Message out = exchange . getOut ( false ) ; if ( out == null ) { return null ; } return out . getBody ( ) ; } @ Override public String toString ( ) { return "outBody" ; } } ; } public static < E extends Exchange , T > Expression < E > outBodyExpression ( final Class < T > type ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { Message out = exchange . getOut ( false ) ; if ( out == null ) { return null ; } return out . getBody ( type ) ; } @ Override public String toString ( ) { return "outBodyAs[" + type . getName ( ) + "]" ; } } ; } public static < E extends Exchange > Expression < E > faultBodyExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getFault ( ) . getBody ( ) ; } @ Override public String toString ( ) { return "faultBody" ; } } ; } public static < E extends Exchange , T > Expression < E > faultBodyExpression ( final Class < T > type ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getFault ( ) . getBody ( type ) ; } @ Override public String toString ( ) { return "faultBodyAs[" + type . getName ( ) + "]" ; } } ; } public static < E extends Exchange > Expression < E > exchangeExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange ; } @ Override public String toString ( ) { return "exchange" ; } } ; } public static < E extends Exchange > Expression < E > inMessageExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getIn ( ) ; } @ Override public String toString ( ) { return "inMessage" ; } } ; } public static < E extends Exchange > Expression < E > outMessageExpression ( ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return exchange . getOut ( ) ; } @ Override public String toString ( ) { return "outMessage" ; } } ; } public static < E extends Exchange > Expression < E > convertTo ( final Expression expression , final Class type ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { Object value = expression . evaluate ( exchange ) ; return exchange . getContext ( ) . getTypeConverter ( ) . convertTo ( type , value ) ; } @ Override public String toString ( ) { return "" + expression + ".convertTo(" + type . getName ( ) + ".class)" ; } } ; } public static < E extends Exchange > Expression < E > tokenizeExpression ( final Expression < E > expression , final String token ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { String text = evaluateStringExpression ( expression , exchange ) ; if ( text == null ) { return null ; } StringTokenizer iter = new StringTokenizer ( text , token ) ; List < String > answer = new ArrayList < String > ( ) ; while ( iter . hasMoreTokens ( ) ) { answer . add ( iter . nextToken ( ) ) ; } return answer ; } @ Override public String toString ( ) { return "tokenize(" + expression + ", " + token + ")" ; } } ; } public static < E extends Exchange > Expression < E > regexTokenize ( final Expression < E > expression , String regexTokenizer ) { final Pattern pattern = Pattern . compile ( regexTokenizer ) ; return new Expression < E > ( ) { public Object evaluate ( E exchange ) { String text = evaluateStringExpression ( expression , exchange ) ; if ( text == null ) { return null ; } return Arrays . asList ( pattern . split ( text ) ) ; } @ Override public String toString ( ) { return "regexTokenize(" + expression + ", " + pattern . pattern ( ) + ")" ; } } ; } public static < E extends Exchange > Expression < E > regexReplaceAll ( final Expression < E > expression , String regex , final String replacement ) { final Pattern pattern = Pattern . compile ( regex ) ; return new Expression < E > ( ) { public Object evaluate ( E exchange ) { String text = evaluateStringExpression ( expression , exchange ) ; if ( text == null ) { return null ; } return pattern . matcher ( text ) . replaceAll ( replacement ) ; } @ Override public String toString ( ) { return "regexReplaceAll(" + expression + ", " + pattern . pattern ( ) + ")" ; } } ; } public static < E extends Exchange > Expression < E > regexReplaceAll ( final Expression < E > expression , String regex , final Expression < E > replacementExpression ) { final Pattern pattern = Pattern . compile ( regex ) ; return new Expression < E > ( ) { public Object evaluate ( E exchange ) { String text = evaluateStringExpression ( expression , exchange ) ; String replacement = evaluateStringExpression ( replacementExpression , exchange ) ; if ( text == null || replacement == null ) { return null ; } return pattern . matcher ( text ) . replaceAll ( replacement ) ; } @ Override public String toString ( ) { return "regexReplaceAll(" + expression + ", " + pattern . pattern ( ) + ")" ; } } ; } public static < E extends Exchange > Expression < E > append ( final Expression < E > left , final Expression < E > right ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return evaluateStringExpression ( left , exchange ) + evaluateStringExpression ( right , exchange ) ; } @ Override public String toString ( ) { return "append(" + left + ", " + right + ")" ; } } ; } public static < E extends Exchange > String evaluateStringExpression ( Expression < E > expression , E exchange ) { Object value = expression . evaluate ( exchange ) ; return exchange . getContext ( ) . getTypeConverter ( ) . convertTo ( String . class , value ) ; } public static < E extends Exchange > Expression < E > systemProperty ( final String name ) { return systemProperty ( name , null ) ; } public static < E extends Exchange > Expression < E > systemProperty ( final String name , final String defaultValue ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { return System . getProperty ( name , defaultValue ) ; } } ; } public static < E extends Exchange > Expression < E > concatExpression ( final Collection < Expression > expressions ) { return concatExpression ( expressions , null ) ; } public static < E extends Exchange > Expression < E > concatExpression ( final Collection < Expression > expressions , final String expression ) { return new Expression < E > ( ) { public Object evaluate ( E exchange ) { StringBuffer buffer = new StringBuffer ( ) ; for ( Expression < E > expression : expressions ) { String text = evaluateStringExpression ( expression , exchange ) ; if ( text != null ) { buffer . append ( text ) ; } } return buffer . toString ( ) ; } @ Override public String toString ( ) { if ( expression != null ) { return expression ; } else { return "concat" + expressions ; } } } ; } } 	1	['30', '1', '0', '41', '61', '435', '18', '29', '29', '2', '193', '0', '0', '0', '0.133333333', '0', '0', '5.433333333', '1', '0.9667', '3']
package org . apache . camel . spring . factory ; import org . apache . camel . component . bean . BeanEndpoint ; import org . springframework . beans . factory . FactoryBean ; public class BeanEndpointFactory implements FactoryBean { private boolean singleton = true ; public Object getObject ( ) throws Exception { return new BeanEndpoint ( ) ; } public Class getObjectType ( ) { return BeanEndpoint . class ; } public boolean isSingleton ( ) { return singleton ; } protected void setSingleton ( boolean singleton ) { this . singleton = singleton ; } } 	0	['5', '1', '0', '2', '7', '4', '0', '2', '4', '0.5', '25', '1', '0', '0', '0.6', '0', '0', '3.8', '1', '0.8', '0']
package org . apache . camel . component . seda ; import java . util . concurrent . TimeUnit ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Consumer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . impl . converter . AsyncProcessorTypeConverter ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class SedaConsumer extends ServiceSupport implements Consumer , Runnable { private static final transient Log LOG = LogFactory . getLog ( SedaConsumer . class ) ; private SedaEndpoint endpoint ; private AsyncProcessor processor ; private Thread thread ; public SedaConsumer ( SedaEndpoint endpoint , Processor processor ) { this . endpoint = endpoint ; this . processor = AsyncProcessorTypeConverter . convert ( processor ) ; } @ Override public String toString ( ) { return "SedaConsumer: " + endpoint . getEndpointUri ( ) ; } public void run ( ) { while ( isRunAllowed ( ) ) { final Exchange exchange ; try { exchange = endpoint . getQueue ( ) . poll ( 1000 , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException e ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Interupted: " + e , e ) ; } continue ; } if ( exchange != null && isRunAllowed ( ) ) { try { processor . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { } } ) ; } catch ( Exception e ) { LOG . error ( "Seda queue caught: " + e , e ) ; } } } } protected void doStart ( ) throws Exception { thread = new Thread ( this , getThreadName ( endpoint . getEndpointUri ( ) ) ) ; thread . setDaemon ( true ) ; thread . start ( ) ; } protected void doStop ( ) throws Exception { thread . join ( ) ; } } 	1	['6', '2', '0', '11', '27', '0', '2', '11', '3', '0.7', '115', '1', '2', '0.764705882', '0.466666667', '1', '2', '17.5', '2', '0.8333', '2']
package org . apache . camel . management ; import java . util . Map ; import org . apache . camel . Processor ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . spi . InterceptStrategy ; public class InstrumentationInterceptStrategy implements InterceptStrategy { private Map < ProcessorType , PerformanceCounter > counterMap ; public InstrumentationInterceptStrategy ( Map < ProcessorType , PerformanceCounter > counterMap ) { this . counterMap = counterMap ; } public Processor wrapProcessorInInterceptors ( ProcessorType processorType , Processor target ) throws Exception { Processor retval = target ; PerformanceCounter counter = counterMap . get ( processorType ) ; if ( counter != null ) { InstrumentationProcessor wrapper = new InstrumentationProcessor ( counter ) ; wrapper . setProcessor ( target ) ; retval = wrapper ; } return retval ; } } 	0	['2', '1', '0', '6', '6', '0', '1', '5', '2', '0', '31', '1', '0', '0', '0.625', '0', '0', '14', '1', '0.5', '0']
package org . apache . camel . model ; import java . util . HashMap ; import java . util . Map ; import java . util . concurrent . atomic . AtomicInteger ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlID ; import javax . xml . bind . annotation . XmlTransient ; import javax . xml . bind . annotation . XmlType ; import javax . xml . bind . annotation . adapters . CollapsedStringAdapter ; import javax . xml . bind . annotation . adapters . XmlJavaTypeAdapter ; @ XmlType ( name = "optionalIdentifiedType" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public abstract class OptionalIdentifiedType < T extends OptionalIdentifiedType > { @ XmlTransient protected static Map < String , AtomicInteger > nodeCounters = new HashMap < String , AtomicInteger > ( ) ; @ XmlAttribute ( required = false ) @ XmlJavaTypeAdapter ( CollapsedStringAdapter . class ) @ XmlID private String id ; @ XmlElement ( required = false ) private Description description ; public String getId ( ) { return id ; } public void setId ( String value ) { this . id = value ; } public Description getDescription ( ) { return description ; } public void setDescription ( Description description ) { this . description = description ; } public String getShortName ( ) { return "node" ; } public T description ( String text ) { if ( description == null ) { description = new Description ( ) ; } description . setText ( text ) ; return ( T ) this ; } public T description ( String text , String lang ) { description ( text ) ; description . setLang ( lang ) ; return ( T ) this ; } public T id ( String id ) { setId ( id ) ; return ( T ) this ; } public String idOrCreate ( ) { if ( id == null ) { setId ( createId ( ) ) ; } return getId ( ) ; } protected String createId ( ) { String key = getShortName ( ) ; return key + getNodeCounter ( key ) . incrementAndGet ( ) ; } protected static synchronized AtomicInteger getNodeCounter ( String key ) { AtomicInteger answer = nodeCounters . get ( key ) ; if ( answer == null ) { answer = new AtomicInteger ( 0 ) ; nodeCounters . put ( key , answer ) ; } return answer ; } } 	1	['13', '1', '3', '4', '26', '58', '3', '1', '10', '0.777777778', '112', '1', '1', '0', '0.472222222', '0', '0', '7.384615385', '2', '1.0769', '1']
package org . apache . camel . processor ; import org . apache . camel . Processor ; public interface ErrorHandler extends Processor { } 	0	['0', '1', '0', '2', '0', '0', '1', '1', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . util ; import java . io . Closeable ; import java . io . IOException ; import java . io . InputStream ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . nio . charset . Charset ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . apache . camel . RuntimeCamelException ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public final class ObjectHelper { private static final transient Log LOG = LogFactory . getLog ( ObjectHelper . class ) ; private ObjectHelper ( ) { } @ Deprecated public static boolean equals ( Object a , Object b ) { return equal ( a , b ) ; } public static boolean equal ( Object a , Object b ) { if ( a == b ) { return true ; } if ( a instanceof byte [ ] && b instanceof byte [ ] ) { return equalByteArray ( ( byte [ ] ) a , ( byte [ ] ) b ) ; } return a != null && b != null && a . equals ( b ) ; } public static boolean equalByteArray ( byte [ ] a , byte [ ] b ) { if ( a == b ) { return true ; } if ( a != null && b != null && a . length == b . length ) { for ( int i = 0 ; i < a . length ; i ++ ) { if ( a [ i ] != b [ i ] ) { return false ; } } return true ; } return false ; } public static boolean isEqualToAny ( Object object , Object ... values ) { for ( Object value : values ) { if ( equal ( object , value ) ) { return true ; } } return false ; } public static int compare ( Object a , Object b ) { if ( a == b ) { return 0 ; } if ( a == null ) { return - 1 ; } if ( b == null ) { return 1 ; } if ( a instanceof Comparable ) { Comparable comparable = ( Comparable ) a ; return comparable . compareTo ( b ) ; } else { int answer = a . getClass ( ) . getName ( ) . compareTo ( b . getClass ( ) . getName ( ) ) ; if ( answer == 0 ) { answer = a . hashCode ( ) - b . hashCode ( ) ; } return answer ; } } public static Boolean toBoolean ( Object value ) { if ( value instanceof Boolean ) { return ( Boolean ) value ; } if ( value instanceof String ) { return "true" . equalsIgnoreCase ( value . toString ( ) ) ? Boolean . TRUE : Boolean . FALSE ; } if ( value instanceof Integer ) { return ( Integer ) value > 0 ? Boolean . TRUE : Boolean . FALSE ; } return null ; } public static void notNull ( Object value , String name ) { if ( value == null ) { throw new IllegalArgumentException ( name + " must be specified" ) ; } } public static String [ ] splitOnCharacter ( String value , String needle , int count ) { String rc [ ] = new String [ count ] ; rc [ 0 ] = value ; for ( int i = 1 ; i < count ; i ++ ) { String v = rc [ i - 1 ] ; int p = v . indexOf ( needle ) ; if ( p < 0 ) { return rc ; } rc [ i - 1 ] = v . substring ( 0 , p ) ; rc [ i ] = v . substring ( p + 1 ) ; } return rc ; } public static String removeStartingCharacters ( String text , char ch ) { int idx = 0 ; while ( text . charAt ( idx ) == ch ) { idx ++ ; } if ( idx > 0 ) { return text . substring ( idx ) ; } return text ; } public static String capitalize ( String text ) { if ( text == null ) { return null ; } int length = text . length ( ) ; if ( length == 0 ) { return text ; } String answer = text . substring ( 0 , 1 ) . toUpperCase ( ) ; if ( length > 1 ) { answer += text . substring ( 1 , length ) ; } return answer ; } @ SuppressWarnings ( "unchecked" ) public static boolean contains ( Object collectionOrArray , Object value ) { if ( collectionOrArray instanceof Collection ) { Collection collection = ( Collection ) collectionOrArray ; return collection . contains ( value ) ; } else if ( collectionOrArray instanceof String && value instanceof String ) { String str = ( String ) collectionOrArray ; String subStr = ( String ) value ; return str . contains ( subStr ) ; } else { Iterator iter = createIterator ( collectionOrArray ) ; while ( iter . hasNext ( ) ) { if ( equal ( value , iter . next ( ) ) ) { return true ; } } } return false ; } @ SuppressWarnings ( "unchecked" ) public static Iterator createIterator ( Object value ) { if ( value == null ) { return Collections . EMPTY_LIST . iterator ( ) ; } else if ( value instanceof Collection ) { Collection collection = ( Collection ) value ; return collection . iterator ( ) ; } else if ( value . getClass ( ) . isArray ( ) ) { List < Object > list = Arrays . asList ( ( Object [ ] ) value ) ; return list . iterator ( ) ; } else if ( value instanceof NodeList ) { final NodeList nodeList = ( NodeList ) value ; return new Iterator < Node > ( ) { int idx = - 1 ; public boolean hasNext ( ) { return ++ idx < nodeList . getLength ( ) ; } public Node next ( ) { return nodeList . item ( idx ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } else { return Collections . singletonList ( value ) . iterator ( ) ; } } public static boolean matches ( List list ) { if ( ! list . isEmpty ( ) ) { Object value = list . get ( 0 ) ; if ( value instanceof Boolean ) { Boolean flag = ( Boolean ) value ; return flag . booleanValue ( ) ; } else { return true ; } } return false ; } public static boolean isNotNullAndNonEmpty ( String text ) { return text != null && text . trim ( ) . length ( ) > 0 ; } public static boolean isNullOrBlank ( String text ) { return text == null || text . trim ( ) . length ( ) <= 0 ; } public static String getSystemProperty ( String name , String defaultValue ) { try { return System . getProperty ( name , defaultValue ) ; } catch ( Exception e ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Caught security exception accessing system property: " + name + ". Reason: " + e , e ) ; } return defaultValue ; } } public static String name ( Class type ) { return type != null ? type . getName ( ) : null ; } public static String className ( Object value ) { return name ( value != null ? value . getClass ( ) : null ) ; } public static Class < ? > loadClass ( String name ) { return loadClass ( name , ObjectHelper . class . getClassLoader ( ) ) ; } public static Class < ? > loadClass ( String name , ClassLoader loader ) { ClassLoader contextClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( contextClassLoader != null ) { try { return contextClassLoader . loadClass ( name ) ; } catch ( ClassNotFoundException e ) { try { return loader . loadClass ( name ) ; } catch ( ClassNotFoundException e1 ) { LOG . debug ( "Could not find class: " + name + ". Reason: " + e ) ; } } } return null ; } public static InputStream loadResourceAsStream ( String name ) { InputStream in = null ; ClassLoader contextClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( contextClassLoader != null ) { in = contextClassLoader . getResourceAsStream ( name ) ; } if ( in == null ) { in = ObjectHelper . class . getClassLoader ( ) . getResourceAsStream ( name ) ; } return in ; } public static Object invokeMethod ( Method method , Object instance , Object ... parameters ) { try { return method . invoke ( instance , parameters ) ; } catch ( IllegalAccessException e ) { throw new RuntimeCamelException ( e ) ; } catch ( InvocationTargetException e ) { throw new RuntimeCamelException ( e . getCause ( ) ) ; } } public static List < Method > findMethodsWithAnnotation ( Class < ? > type , Class < ? extends Annotation > annotationType ) { List < Method > answer = new ArrayList < Method > ( ) ; do { Method [ ] methods = type . getDeclaredMethods ( ) ; for ( Method method : methods ) { if ( method . getAnnotation ( annotationType ) != null ) { answer . add ( method ) ; } } type = type . getSuperclass ( ) ; } while ( type != null ) ; return answer ; } public static String asString ( Object [ ] objects ) { if ( objects == null ) { return "null" ; } else { StringBuffer buffer = new StringBuffer ( "{" ) ; int counter = 0 ; for ( Object object : objects ) { if ( counter ++ > 0 ) { buffer . append ( ", " ) ; } String text = ( object == null ) ? "null" : object . toString ( ) ; buffer . append ( text ) ; } buffer . append ( "}" ) ; return buffer . toString ( ) ; } } public static boolean isAssignableFrom ( Class a , Class b ) { a = convertPrimitiveTypeToWrapperType ( a ) ; b = convertPrimitiveTypeToWrapperType ( b ) ; return a . isAssignableFrom ( b ) ; } public static Class convertPrimitiveTypeToWrapperType ( Class type ) { Class rc = type ; if ( type . isPrimitive ( ) ) { if ( type == int . class ) { rc = Integer . class ; } else if ( type == long . class ) { rc = Long . class ; } else if ( type == double . class ) { rc = Double . class ; } else if ( type == float . class ) { rc = Float . class ; } else if ( type == short . class ) { rc = Short . class ; } else if ( type == byte . class ) { rc = Byte . class ; } } return rc ; } public static String getDefaultCharacterSet ( ) { return Charset . defaultCharset ( ) . name ( ) ; } public static String getPropertyName ( Method method ) { String propertyName = method . getName ( ) ; if ( propertyName . startsWith ( "set" ) && method . getParameterTypes ( ) . length == 1 ) { propertyName = propertyName . substring ( 3 , 4 ) . toLowerCase ( ) + propertyName . substring ( 4 ) ; } return propertyName ; } public static boolean hasAnnotation ( Annotation [ ] annotations , Class < ? > type ) { for ( Annotation annotation : annotations ) { if ( type . isInstance ( annotation ) ) { return true ; } } return false ; } public static void close ( Closeable closeable , String name , Log log ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( IOException e ) { if ( log != null ) { log . warn ( "Could not close: " + name + ". Reason: " + e , e ) ; } } } } public static < T > T cast ( Class < T > toType , Object value ) { if ( toType == boolean . class ) { return ( T ) cast ( Boolean . class , value ) ; } else if ( toType . isPrimitive ( ) ) { Class newType = convertPrimitiveTypeToWrapperType ( toType ) ; if ( newType != toType ) { return ( T ) cast ( newType , value ) ; } } try { return toType . cast ( value ) ; } catch ( ClassCastException e ) { throw new IllegalArgumentException ( "Failed to convert: " + value + " to type: " + toType . getName ( ) + " due to: " + e , e ) ; } } public static < T > T newInstance ( Class < T > type ) { try { return type . newInstance ( ) ; } catch ( InstantiationException e ) { throw new RuntimeCamelException ( e . getCause ( ) ) ; } catch ( IllegalAccessException e ) { throw new RuntimeCamelException ( e ) ; } } public static < T > T newInstance ( Class < ? > actualType , Class < T > expectedType ) { try { Object value = actualType . newInstance ( ) ; return cast ( expectedType , value ) ; } catch ( InstantiationException e ) { throw new RuntimeCamelException ( e . getCause ( ) ) ; } catch ( IllegalAccessException e ) { throw new RuntimeCamelException ( e ) ; } } public static boolean isJavaIdentifier ( String name ) { if ( name == null ) { return false ; } int size = name . length ( ) ; if ( size < 1 ) { return false ; } if ( Character . isJavaIdentifierStart ( name . charAt ( 0 ) ) ) { for ( int i = 1 ; i < size ; i ++ ) { if ( ! Character . isJavaIdentifierPart ( name . charAt ( i ) ) ) { return false ; } } return true ; } return false ; } public static Object type ( Object bean ) { return bean != null ? bean . getClass ( ) : null ; } public static boolean evaluateValuePredicate ( Object value ) { if ( value instanceof Boolean ) { Boolean aBoolean = ( Boolean ) value ; return aBoolean . booleanValue ( ) ; } return value != null ; } } 	1	['38', '1', '0', '109', '111', '697', '105', '4', '36', '0.918918919', '923', '1', '0', '0', '0.090733591', '0', '0', '23.26315789', '8', '3.1579', '5']
package org . apache . camel . component . rmi ; import java . rmi . registry . Registry ; import org . apache . camel . CamelContext ; import org . apache . camel . component . bean . ParameterMappingStrategy ; import org . apache . camel . component . bean . RegistryBean ; public class RmiRegistryBean extends RegistryBean { private final Registry registry ; public RmiRegistryBean ( CamelContext context , String name , Registry registry ) { super ( context , name ) ; this . registry = registry ; } public RmiRegistryBean ( CamelContext context , String name , ParameterMappingStrategy parameterMappingStrategy , Registry registry ) { super ( context , name , parameterMappingStrategy ) ; this . registry = registry ; } @ Override protected Object lookupBean ( ) throws Exception { return registry . lookup ( getName ( ) ) ; } } 	0	['3', '2', '0', '4', '7', '0', '1', '3', '2', '0', '27', '1', '0', '0.928571429', '0.666666667', '1', '1', '7.666666667', '1', '0.3333', '0']
package org . apache . camel . component . bean ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . Arrays ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . util . ExchangeHelper ; import org . apache . camel . util . ObjectHelper ; public class MethodInfo { private Class type ; private Method method ; private final List < ParameterInfo > parameters ; private final List < ParameterInfo > bodyParameters ; private final boolean hasCustomAnnotation ; private Expression parametersExpression ; public MethodInfo ( Class type , Method method , List < ParameterInfo > parameters , List < ParameterInfo > bodyParameters , boolean hasCustomAnnotation ) { this . type = type ; this . method = method ; this . parameters = parameters ; this . bodyParameters = bodyParameters ; this . hasCustomAnnotation = hasCustomAnnotation ; this . parametersExpression = createParametersExpression ( ) ; } public String toString ( ) { return method . toString ( ) ; } public MethodInvocation createMethodInvocation ( final Object pojo , final Exchange messageExchange ) { final Object [ ] arguments = ( Object [ ] ) parametersExpression . evaluate ( messageExchange ) ; return new MethodInvocation ( ) { public Method getMethod ( ) { return method ; } public Object [ ] getArguments ( ) { return arguments ; } public Object proceed ( ) throws Throwable { return invoke ( method , pojo , arguments , messageExchange ) ; } public Object getThis ( ) { return pojo ; } public AccessibleObject getStaticPart ( ) { return method ; } } ; } public Class getType ( ) { return type ; } public Method getMethod ( ) { return method ; } public Expression getParametersExpression ( ) { return parametersExpression ; } public List < ParameterInfo > getBodyParameters ( ) { return bodyParameters ; } public Class getBodyParameterType ( ) { ParameterInfo parameterInfo = bodyParameters . get ( 0 ) ; return parameterInfo . getType ( ) ; } public boolean bodyParameterMatches ( Class bodyType ) { Class actualType = getBodyParameterType ( ) ; return actualType != null && ObjectHelper . isAssignableFrom ( bodyType , actualType ) ; } public List < ParameterInfo > getParameters ( ) { return parameters ; } public boolean hasBodyParameter ( ) { return ! bodyParameters . isEmpty ( ) ; } public boolean isHasCustomAnnotation ( ) { return hasCustomAnnotation ; } public boolean isReturnTypeVoid ( ) { return method . getReturnType ( ) . getName ( ) . equals ( "void" ) ; } protected Object invoke ( Method mth , Object pojo , Object [ ] arguments , Exchange exchange ) throws IllegalAccessException , InvocationTargetException { return mth . invoke ( pojo , arguments ) ; } protected Expression createParametersExpression ( ) { final int size = parameters . size ( ) ; final Expression [ ] expressions = new Expression [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { Expression parameterExpression = parameters . get ( i ) . getExpression ( ) ; expressions [ i ] = parameterExpression ; } return new Expression < Exchange > ( ) { public Object evaluate ( Exchange exchange ) { Object [ ] answer = new Object [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { Object value = expressions [ i ] . evaluate ( exchange ) ; Class expectedType = parameters . get ( i ) . getType ( ) ; value = ExchangeHelper . convertToType ( exchange , expectedType , value ) ; answer [ i ] = value ; } return answer ; } @ Override public String toString ( ) { return "ParametersExpression: " + Arrays . asList ( expressions ) ; } } ; } } 	1	['17', '1', '0', '8', '32', '82', '3', '7', '13', '0.84375', '162', '1', '1', '0', '0.183006536', '0', '0', '8.176470588', '3', '1.1765', '5']
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class SetHeaderProcessor extends DelegateProcessor implements Processor { private static final transient Log LOG = LogFactory . getLog ( SetHeaderProcessor . class ) ; private String name ; private Expression expression ; public SetHeaderProcessor ( String name , Expression expression ) { this . name = name ; this . expression = expression ; } public SetHeaderProcessor ( String name , Expression expression , Processor childProcessor ) { super ( childProcessor ) ; this . name = name ; this . expression = expression ; } public void process ( Exchange exchange ) throws Exception { Object value = expression . evaluate ( exchange ) ; if ( value == null ) { LOG . warn ( "Expression: " + expression + " on exchange: " + exchange + " evaluated to null." ) ; } exchange . getIn ( ) . setHeader ( name , value ) ; super . process ( exchange ) ; } @ Override public String toString ( ) { return "setHeader(" + name + ", " + expression + ")" ; } } 	0	['5', '3', '0', '8', '17', '0', '1', '7', '4', '0.416666667', '82', '1', '1', '0.913043478', '0.5', '0', '0', '14.8', '1', '0.4', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Processor ; import org . apache . camel . component . bean . BeanProcessor ; import org . apache . camel . component . bean . RegistryBean ; import org . apache . camel . spi . RouteContext ; import org . apache . camel . util . CamelContextHelper ; import org . apache . camel . util . ObjectHelper ; @ XmlRootElement ( name = "bean" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class BeanRef extends OutputType < ProcessorType > { @ XmlAttribute ( required = false ) private String ref ; @ XmlAttribute ( required = false ) private String method ; @ XmlAttribute ( required = false ) private Class beanType ; @ XmlTransient private Object bean ; public BeanRef ( ) { } public BeanRef ( String ref ) { this . ref = ref ; } public BeanRef ( String ref , String method ) { this . ref = ref ; this . method = method ; } @ Override public String toString ( ) { return "Bean[" + getLabel ( ) + "]" ; } @ Override public String getShortName ( ) { return "bean" ; } public String getRef ( ) { return ref ; } public void setRef ( String ref ) { this . ref = ref ; } public String getMethod ( ) { return method ; } public void setMethod ( String method ) { this . method = method ; } public void setBean ( Object bean ) { this . bean = bean ; } public Class getBeanType ( ) { return beanType ; } public void setBeanType ( Class beanType ) { this . beanType = beanType ; } @ Override public Processor createProcessor ( RouteContext routeContext ) { BeanProcessor answer ; if ( ref != null ) { answer = new BeanProcessor ( new RegistryBean ( routeContext . getCamelContext ( ) , ref ) ) ; } else { if ( bean == null ) { ObjectHelper . notNull ( beanType , "bean, ref or beanType" ) ; bean = CamelContextHelper . newInstance ( routeContext . getCamelContext ( ) , beanType ) ; } answer = new BeanProcessor ( bean , routeContext . getCamelContext ( ) ) ; } if ( method != null ) { answer . setMethod ( method ) ; } return answer ; } @ Override public String getLabel ( ) { if ( ref != null ) { String methodText = "" ; if ( method != null ) { methodText = " method: " + method ; } return "ref: " + ref + methodText ; } else if ( bean != null ) { return bean . toString ( ) ; } else if ( beanType != null ) { return beanType . getName ( ) ; } else { return "" ; } } } 	1	['14', '4', '0', '10', '27', '33', '1', '9', '14', '0.653846154', '167', '1', '0', '0.932926829', '0.3', '1', '1', '10.64285714', '5', '1.2857', '1']
package org . apache . camel . component . validator ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . component . ResourceBasedComponent ; import org . apache . camel . impl . ProcessorEndpoint ; import org . springframework . core . io . Resource ; public class ValidatorComponent extends ResourceBasedComponent { protected Endpoint < Exchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { SpringValidator validator = new SpringValidator ( ) ; Resource resource = resolveMandatoryResource ( remaining ) ; validator . setSchemaResource ( resource ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( this + " using schema resource: " + resource ) ; } configureValidator ( validator , uri , remaining , parameters ) ; return new ProcessorEndpoint ( uri , this , validator ) ; } protected void configureValidator ( SpringValidator validator , String uri , String remaining , Map parameters ) throws Exception { setProperties ( validator , parameters ) ; } } 	0	['3', '4', '0', '8', '15', '3', '0', '8', '1', '2', '52', '0', '0', '0.948717949', '0.666666667', '2', '2', '16.33333333', '1', '0.6667', '0']
package org . apache . camel . impl ; import java . util . ArrayList ; import java . util . Collection ; import java . util . concurrent . atomic . AtomicBoolean ; import org . apache . camel . Service ; import org . apache . camel . util . ServiceHelper ; public abstract class ServiceSupport implements Service { private static int threadCounter ; private AtomicBoolean started = new AtomicBoolean ( false ) ; private AtomicBoolean starting = new AtomicBoolean ( false ) ; private AtomicBoolean stopping = new AtomicBoolean ( false ) ; private AtomicBoolean stopped = new AtomicBoolean ( false ) ; private Collection childServices ; public void start ( ) throws Exception { if ( started . compareAndSet ( false , true ) ) { starting . set ( true ) ; try { if ( childServices != null ) { ServiceHelper . startServices ( childServices ) ; } doStart ( ) ; } finally { starting . set ( false ) ; } } } public void stop ( ) throws Exception { if ( started . get ( ) && stopping . compareAndSet ( false , true ) ) { try { doStop ( ) ; } finally { if ( childServices != null ) { ServiceHelper . stopServices ( childServices ) ; } stopped . set ( true ) ; started . set ( false ) ; stopping . set ( false ) ; } } } public boolean isStarted ( ) { return started . get ( ) ; } public boolean isStarting ( ) { return starting . get ( ) ; } public boolean isStopping ( ) { return stopping . get ( ) ; } protected boolean isRunAllowed ( ) { return ! ( stopping . get ( ) || stopped . get ( ) ) ; } public boolean isStopped ( ) { return stopped . get ( ) ; } protected abstract void doStart ( ) throws Exception ; protected abstract void doStop ( ) throws Exception ; protected String getThreadName ( String prefix ) { return prefix + " thread:" + nextThreadCounter ( ) ; } protected static synchronized int nextThreadCounter ( ) { return ++ threadCounter ; } protected void addChildService ( Object childService ) { if ( childServices == null ) { childServices = new ArrayList ( ) ; } childServices . add ( childService ) ; } protected boolean removeChildService ( Object childService ) { if ( childServices != null ) { return childServices . remove ( childService ) ; } else { return false ; } } } 	1	['14', '1', '31', '35', '28', '49', '33', '2', '7', '0.807692308', '200', '1', '0', '0', '0.380952381', '0', '0', '12.85714286', '3', '1.2143', '1']
package org . apache . camel . processor ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ServiceHelper ; public class ChoiceProcessor extends ServiceSupport implements Processor { private List < FilterProcessor > filters = new ArrayList < FilterProcessor > ( ) ; private Processor otherwise ; public ChoiceProcessor ( List < FilterProcessor > filters , Processor otherwise ) { this . filters = filters ; this . otherwise = otherwise ; } public void process ( Exchange exchange ) throws Exception { for ( FilterProcessor filterProcessor : filters ) { Predicate < Exchange > predicate = filterProcessor . getPredicate ( ) ; if ( predicate != null && predicate . matches ( exchange ) ) { filterProcessor . processNext ( exchange ) ; return ; } } if ( otherwise != null ) { otherwise . process ( exchange ) ; } } @ Override public String toString ( ) { StringBuilder builder = new StringBuilder ( "choice{" ) ; boolean first = true ; for ( FilterProcessor processor : filters ) { if ( first ) { first = false ; } else { builder . append ( ", " ) ; } builder . append ( "when " ) ; builder . append ( processor . getPredicate ( ) . toString ( ) ) ; builder . append ( ": " ) ; builder . append ( processor . getProcessor ( ) ) ; } if ( otherwise != null ) { builder . append ( ", otherwise: " ) ; builder . append ( otherwise ) ; } builder . append ( "}" ) ; return builder . toString ( ) ; } public List < FilterProcessor > getFilters ( ) { return filters ; } public Processor getOtherwise ( ) { return otherwise ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( filters ) ; ServiceHelper . startServices ( otherwise ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( otherwise ) ; ServiceHelper . stopServices ( filters ) ; } } 	0	['7', '2', '0', '7', '26', '0', '1', '6', '5', '0.166666667', '152', '1', '1', '0.684210526', '0.357142857', '1', '1', '20.42857143', '4', '1.2857', '0']
package org . apache . camel . converter . stream ; import org . apache . camel . processor . interceptor . StreamCachingInterceptor ; public interface StreamCache { } 	1	['0', '1', '0', '3', '0', '0', '3', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '2']
package org . apache . camel . processor . loadbalancer ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public class TopicLoadBalancer extends LoadBalancerSupport { public void process ( Exchange exchange ) throws Exception { List < Processor > list = getProcessors ( ) ; for ( Processor processor : list ) { Exchange copy = copyExchangeStrategy ( processor , exchange ) ; processor . process ( copy ) ; } } protected Exchange copyExchangeStrategy ( Processor processor , Exchange exchange ) { return exchange . copy ( ) ; } } 	0	['3', '3', '0', '7', '10', '3', '4', '3', '2', '2', '32', '0', '0', '0.9', '0.666666667', '0', '0', '9.666666667', '1', '0.6667', '0']
package org . apache . camel . converter . jaxp ; import java . io . ByteArrayInputStream ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import javax . xml . transform . stream . StreamSource ; public class BytesSource extends StreamSource { private byte [ ] data ; public BytesSource ( byte [ ] data ) { this . data = data ; } public BytesSource ( byte [ ] data , String systemId ) { this . data = data ; setSystemId ( systemId ) ; } public InputStream getInputStream ( ) { return new ByteArrayInputStream ( data ) ; } public Reader getReader ( ) { return new InputStreamReader ( getInputStream ( ) ) ; } public byte [ ] getData ( ) { return data ; } public String toString ( ) { return "BytesSource[" + new String ( data ) + "]" ; } } 	1	['6', '2', '0', '2', '14', '0', '2', '0', '6', '0', '52', '1', '0', '0.692307692', '0.5', '0', '0', '7.5', '1', '0.6667', '1']
package org . apache . camel . processor ; import java . io . InputStream ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . util . ExchangeHelper ; public class UnmarshalProcessor implements Processor { private final DataFormat dataFormat ; public UnmarshalProcessor ( DataFormat dataFormat ) { this . dataFormat = dataFormat ; } public void process ( Exchange exchange ) throws Exception { InputStream stream = ExchangeHelper . getMandatoryInBody ( exchange , InputStream . class ) ; try { Message out = exchange . getOut ( true ) ; out . copyFrom ( exchange . getIn ( ) ) ; Object result = dataFormat . unmarshal ( exchange , stream ) ; out . setBody ( result ) ; } finally { if ( null != stream ) { stream . close ( ) ; } } } } 	0	['2', '1', '0', '6', '10', '0', '1', '5', '2', '0', '46', '1', '1', '0', '0.666666667', '0', '0', '21.5', '1', '0.5', '0']
package org . apache . camel . component . bean ; import java . lang . reflect . Proxy ; import org . apache . camel . Endpoint ; import org . apache . camel . Producer ; public final class ProxyHelper { private ProxyHelper ( ) { } public static Object createProxy ( final Endpoint endpoint , ClassLoader cl , Class interfaces [ ] ) throws Exception { final Producer producer = endpoint . createProducer ( ) ; return Proxy . newProxyInstance ( cl , interfaces , new CamelInvocationHandler ( endpoint , producer ) ) ; } public static Object createProxy ( Endpoint endpoint , Class interfaces [ ] ) throws Exception { if ( interfaces . length < 1 ) { throw new IllegalArgumentException ( "You must provide at least 1 interface class." ) ; } return createProxy ( endpoint , interfaces [ 0 ] . getClassLoader ( ) , interfaces ) ; } @ SuppressWarnings ( "unchecked" ) public static < T > T createProxy ( Endpoint endpoint , ClassLoader cl , Class < T > interfaceClass ) throws Exception { return ( T ) createProxy ( endpoint , cl , new Class [ ] { interfaceClass } ) ; } @ SuppressWarnings ( "unchecked" ) public static < T > T createProxy ( Endpoint endpoint , Class < T > interfaceClass ) throws Exception { return ( T ) createProxy ( endpoint , new Class [ ] { interfaceClass } ) ; } } 	1	['5', '1', '0', '4', '11', '10', '1', '3', '4', '2', '56', '0', '0', '0', '0.44', '0', '0', '10.2', '1', '0.8', '2']
package org . apache . camel . util ; public class ValueHolder < V > { private V value ; public ValueHolder ( ) { } public ValueHolder ( V val ) { value = val ; } public V get ( ) { return value ; } public void set ( V val ) { value = val ; } } 	0	['4', '1', '0', '2', '5', '0', '2', '0', '4', '0.333333333', '21', '1', '0', '0', '0.75', '0', '0', '4', '1', '0.5', '0']
package org . apache . camel . model ; import java . util . Collection ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . builder . ExpressionClause ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . Aggregator ; import org . apache . camel . processor . aggregate . AggregationCollection ; import org . apache . camel . processor . aggregate . AggregationStrategy ; import org . apache . camel . processor . aggregate . UseLatestAggregationStrategy ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "aggregator" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class AggregatorType extends ExpressionNode { @ XmlTransient private AggregationStrategy aggregationStrategy ; @ XmlTransient private AggregationCollection aggregationCollection ; @ XmlAttribute ( required = false ) private Integer batchSize ; @ XmlAttribute ( required = false ) private Long batchTimeout ; @ XmlAttribute ( required = false ) private String strategyRef ; @ XmlElement ( name = "completedPredicate" , required = false ) private CompletedPredicate completedPredicate ; public AggregatorType ( ) { } public AggregatorType ( Expression correlationExpression ) { super ( correlationExpression ) ; } public AggregatorType ( ExpressionType correlationExpression ) { super ( correlationExpression ) ; } public AggregatorType ( Expression correlationExpression , AggregationStrategy aggregationStrategy ) { super ( correlationExpression ) ; this . aggregationStrategy = aggregationStrategy ; } @ Override public String toString ( ) { return "Aggregator[ " + getExpression ( ) + " -> " + getOutputs ( ) + "]" ; } @ Override public String getShortName ( ) { return "aggregator" ; } @ SuppressWarnings ( "unchecked" ) @ Override public void addRoutes ( RouteContext routeContext , Collection < Route > routes ) throws Exception { final Aggregator aggregator = createAggregator ( routeContext ) ; doAddRoute ( routeContext , routes , aggregator ) ; } private void doAddRoute ( RouteContext routeContext , Collection < Route > routes , final Aggregator aggregator ) throws Exception { Route route = new Route < Exchange > ( aggregator . getEndpoint ( ) , aggregator ) { @ Override public String toString ( ) { return "AggregatorRoute[" + getEndpoint ( ) + " -> " + aggregator . getProcessor ( ) + "]" ; } } ; routes . add ( route ) ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { final Aggregator aggregator = createAggregator ( routeContext ) ; doAddRoute ( routeContext , routeContext . getCamelContext ( ) . getRoutes ( ) , aggregator ) ; routeContext . setIsRouteAdded ( true ) ; return aggregator ; } protected Aggregator createAggregator ( RouteContext routeContext ) throws Exception { Endpoint from = routeContext . getEndpoint ( ) ; final Processor processor = routeContext . createProcessor ( this ) ; final Aggregator aggregator ; if ( aggregationCollection != null ) { aggregator = new Aggregator ( from , processor , aggregationCollection ) ; } else { AggregationStrategy strategy = getAggregationStrategy ( ) ; if ( strategy == null && strategyRef != null ) { strategy = routeContext . lookup ( strategyRef , AggregationStrategy . class ) ; } if ( strategy == null ) { strategy = new UseLatestAggregationStrategy ( ) ; } Expression aggregateExpression = getExpression ( ) . createExpression ( routeContext ) ; Predicate predicate = null ; if ( completedPredicate != null ) { predicate = completedPredicate . createPredicate ( routeContext ) ; } if ( predicate != null ) { aggregator = new Aggregator ( from , processor , aggregateExpression , strategy , predicate ) ; } else { aggregator = new Aggregator ( from , processor , aggregateExpression , strategy ) ; } } if ( batchSize != null ) { aggregator . setBatchSize ( batchSize ) ; } if ( batchTimeout != null ) { aggregator . setBatchTimeout ( batchTimeout ) ; } return aggregator ; } public AggregationCollection getAggregationCollection ( ) { return aggregationCollection ; } public void setAggregationCollection ( AggregationCollection aggregationCollection ) { this . aggregationCollection = aggregationCollection ; } public AggregationStrategy getAggregationStrategy ( ) { return aggregationStrategy ; } public void setAggregationStrategy ( AggregationStrategy aggregationStrategy ) { this . aggregationStrategy = aggregationStrategy ; } public Integer getBatchSize ( ) { return batchSize ; } public void setBatchSize ( Integer batchSize ) { this . batchSize = batchSize ; } public Long getBatchTimeout ( ) { return batchTimeout ; } public void setBatchTimeout ( Long batchTimeout ) { this . batchTimeout = batchTimeout ; } public String getStrategyRef ( ) { return strategyRef ; } public void setStrategyRef ( String strategyRef ) { this . strategyRef = strategyRef ; } public CompletedPredicate getCompletePredicate ( ) { return completedPredicate ; } public void setCompletePredicate ( CompletedPredicate completedPredicate ) { this . completedPredicate = completedPredicate ; } public AggregatorType batchSize ( int batchSize ) { setBatchSize ( batchSize ) ; return this ; } public AggregatorType batchTimeout ( long batchTimeout ) { setBatchTimeout ( batchTimeout ) ; return this ; } public ExpressionClause < AggregatorType > completedPredicate ( ) { checkNoCompletedPredicate ( ) ; ExpressionClause < AggregatorType > clause = new ExpressionClause < AggregatorType > ( this ) ; completedPredicate = new CompletedPredicate ( clause ) ; return clause ; } public AggregatorType completedPredicate ( Predicate predicate ) { checkNoCompletedPredicate ( ) ; completedPredicate = new CompletedPredicate ( predicate ) ; return this ; } protected void checkNoCompletedPredicate ( ) { if ( completedPredicate != null ) { throw new IllegalArgumentException ( "There already is a completedPredicate defined for this aggregator: " + this ) ; } } } 	1	['27', '4', '0', '18', '60', '291', '3', '17', '24', '0.820512821', '303', '1', '3', '0.872928177', '0.116049383', '2', '3', '10', '2', '0.8889', '7']
package org . apache . camel . component . cxf ; import java . io . InputStream ; import java . util . Collections ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import javax . xml . transform . Source ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . cxf . helpers . CastUtils ; import org . apache . cxf . message . ExchangeImpl ; import org . apache . cxf . message . Message ; import org . apache . cxf . message . MessageImpl ; public final class CxfSoapBinding { private static final Log LOG = LogFactory . getLog ( CxfSoapBinding . class ) ; private CxfSoapBinding ( ) { } public static org . apache . cxf . message . Message getCxfInMessage ( org . apache . camel . Exchange exchange , boolean isClient ) { MessageImpl answer = new MessageImpl ( ) ; org . apache . cxf . message . Exchange cxfExchange = exchange . getProperty ( CxfConstants . CXF_EXCHANGE , org . apache . cxf . message . Exchange . class ) ; org . apache . camel . Message message = null ; if ( isClient ) { message = exchange . getOut ( ) ; } else { message = exchange . getIn ( ) ; } assert message != null ; if ( cxfExchange == null ) { cxfExchange = new ExchangeImpl ( ) ; exchange . setProperty ( CxfConstants . CXF_EXCHANGE , cxfExchange ) ; } Map < String , Object > headers = null ; if ( isClient ) { headers = exchange . getOut ( ) . getHeaders ( ) ; } else { headers = exchange . getIn ( ) . getHeaders ( ) ; } answer . put ( Message . PROTOCOL_HEADERS , getProtocolHeader ( headers ) ) ; Object body = message . getBody ( InputStream . class ) ; if ( body instanceof InputStream ) { answer . setContent ( InputStream . class , body ) ; } else { LOG . warn ( "Can't get right InputStream object here, the message body is " + message . getBody ( ) ) ; } answer . putAll ( message . getHeaders ( ) ) ; answer . setExchange ( cxfExchange ) ; cxfExchange . setInMessage ( answer ) ; return answer ; } public static org . apache . cxf . message . Message getCxfOutMessage ( org . apache . camel . Exchange exchange , boolean isClient ) { org . apache . cxf . message . Exchange cxfExchange = exchange . getProperty ( CxfConstants . CXF_EXCHANGE , org . apache . cxf . message . Exchange . class ) ; assert cxfExchange != null ; org . apache . cxf . endpoint . Endpoint cxfEndpoint = cxfExchange . get ( org . apache . cxf . endpoint . Endpoint . class ) ; org . apache . cxf . message . Message outMessage = cxfEndpoint . getBinding ( ) . createMessage ( ) ; outMessage . setExchange ( cxfExchange ) ; cxfExchange . setOutMessage ( outMessage ) ; org . apache . camel . Message message = null ; if ( isClient ) { message = exchange . getIn ( ) ; } else { message = exchange . getOut ( ) ; } Map < String , Object > headers = null ; if ( isClient ) { headers = exchange . getIn ( ) . getHeaders ( ) ; } else { headers = exchange . getOut ( ) . getHeaders ( ) ; } outMessage . put ( Message . PROTOCOL_HEADERS , getProtocolHeader ( headers ) ) ; Object body = message . getBody ( Source . class ) ; if ( body instanceof Source ) { outMessage . setContent ( Source . class , body ) ; } else { LOG . warn ( "Can't get right Source object here, the message body is " + message . getBody ( ) ) ; } outMessage . putAll ( message . getHeaders ( ) ) ; return outMessage ; } private static Map < String , List < String > > getProtocolHeader ( Map < String , Object > headers ) { Map < String , List < String > > protocolHeader = new HashMap < String , List < String > > ( ) ; Iterator headersKeySetIterator = headers . keySet ( ) . iterator ( ) ; while ( headersKeySetIterator . hasNext ( ) ) { String key = ( String ) headersKeySetIterator . next ( ) ; Object value = headers . get ( key ) ; if ( value != null ) { protocolHeader . put ( key , Collections . singletonList ( value . toString ( ) ) ) ; } else { protocolHeader . put ( key , null ) ; } } return protocolHeader ; } public static void setProtocolHeader ( Map < String , Object > headers , Map < String , List < String > > protocolHeader ) { if ( protocolHeader != null ) { StringBuilder value = new StringBuilder ( 256 ) ; for ( Map . Entry < String , List < String > > entry : protocolHeader . entrySet ( ) ) { value . setLength ( 0 ) ; boolean first = true ; for ( String s : entry . getValue ( ) ) { if ( ! first ) { value . append ( "; " ) ; } value . append ( s ) ; first = false ; } headers . put ( entry . getKey ( ) , value . toString ( ) ) ; } } } } 	0	['6', '1', '0', '16', '52', '9', '6', '10', '3', '0.6', '297', '0.5', '0', '0', '0.35', '0', '0', '48.16666667', '7', '3.5', '0']
package org . apache . camel . component . bean ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . Method ; public interface MethodInvocation { Method getMethod ( ) ; Object [ ] getArguments ( ) ; Object proceed ( ) throws Throwable ; Object getThis ( ) ; AccessibleObject getStaticPart ( ) ; } 	1	['5', '1', '0', '4', '5', '10', '4', '0', '5', '2', '5', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . camel . component . ibatis ; import java . io . IOException ; import java . io . InputStream ; import java . util . Map ; import com . ibatis . sqlmap . client . SqlMapClient ; import com . ibatis . sqlmap . client . SqlMapClientBuilder ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . core . io . ClassPathResource ; import org . springframework . core . io . Resource ; public class IBatisComponent extends DefaultComponent { public static final String DEFAULT_CONFIG_URI = "SqlMapConfig.xml" ; private static final transient Log LOG = LogFactory . getLog ( IBatisComponent . class ) ; private SqlMapClient sqlMapClient ; private Resource sqlMapResource ; public IBatisComponent ( ) { } public IBatisComponent ( SqlMapClient sqlMapClient ) { this . sqlMapClient = sqlMapClient ; } public SqlMapClient getSqlMapClient ( ) throws IOException { if ( sqlMapClient == null ) { sqlMapClient = createSqlMapClient ( ) ; } return sqlMapClient ; } public void setSqlMapClient ( SqlMapClient sqlMapClient ) { this . sqlMapClient = sqlMapClient ; } public Resource getSqlMapResource ( ) { if ( sqlMapResource == null ) { sqlMapResource = new ClassPathResource ( DEFAULT_CONFIG_URI ) ; LOG . debug ( "Defaulting to use the iBatis configuration from: " + sqlMapResource ) ; } return sqlMapResource ; } public void setSqlMapResource ( Resource sqlMapResource ) { this . sqlMapResource = sqlMapResource ; } protected Endpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { return new IBatisEndpoint ( uri , this , remaining ) ; } protected SqlMapClient createSqlMapClient ( ) throws IOException { InputStream in = getSqlMapResource ( ) . getInputStream ( ) ; return SqlMapClientBuilder . buildSqlMapClient ( in ) ; } } 	0	['9', '3', '0', '9', '20', '26', '1', '9', '6', '0.84375', '81', '0.75', '0', '0.85', '0.325', '1', '1', '7.555555556', '2', '0.7778', '0']
package org . apache . camel . util ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . lang . annotation . Annotation ; import java . lang . reflect . Method ; import java . net . URL ; import java . net . URLDecoder ; import java . util . Arrays ; import java . util . Enumeration ; import java . util . HashSet ; import java . util . Set ; import java . util . jar . JarEntry ; import java . util . jar . JarInputStream ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class ResolverUtil < T > { protected static final transient Log LOG = LogFactory . getLog ( ResolverUtil . class ) ; public static interface Test { boolean matches ( Class type ) ; } public static class IsA implements Test { private Class parent ; public IsA ( Class parentType ) { this . parent = parentType ; } public boolean matches ( Class type ) { return type != null && parent . isAssignableFrom ( type ) ; } @ Override public String toString ( ) { return "is assignable to " + parent . getSimpleName ( ) ; } } public static class AnnotatedWith implements Test { private Class < ? extends Annotation > annotation ; public AnnotatedWith ( Class < ? extends Annotation > annotation ) { this . annotation = annotation ; } public boolean matches ( Class type ) { return type != null && type . isAnnotationPresent ( annotation ) ; } @ Override public String toString ( ) { return "annotated with @" + annotation . getSimpleName ( ) ; } } private Set < Class < ? extends T > > matches = new HashSet < Class < ? extends T > > ( ) ; private Set < ClassLoader > classLoaders ; public Set < Class < ? extends T > > getClasses ( ) { return matches ; } public Set < ClassLoader > getClassLoaders ( ) { if ( classLoaders == null ) { classLoaders = new HashSet < ClassLoader > ( ) ; classLoaders . add ( Thread . currentThread ( ) . getContextClassLoader ( ) ) ; classLoaders . add ( ResolverUtil . class . getClassLoader ( ) ) ; } return classLoaders ; } public void setClassLoaders ( Set < ClassLoader > classLoaders ) { this . classLoaders = classLoaders ; } public void findImplementations ( Class parent , String ... packageNames ) { if ( packageNames == null ) { return ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Searching for implementations of " + parent . getName ( ) + " in packages: " + Arrays . asList ( packageNames ) ) ; } Test test = new IsA ( parent ) ; for ( String pkg : packageNames ) { find ( test , pkg ) ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Found: " + getClasses ( ) ) ; } } public void findAnnotated ( Class < ? extends Annotation > annotation , String ... packageNames ) { if ( packageNames == null ) { return ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Searching for annotations of " + annotation . getName ( ) + " in packages: " + Arrays . asList ( packageNames ) ) ; } Test test = new AnnotatedWith ( annotation ) ; for ( String pkg : packageNames ) { find ( test , pkg ) ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Found: " + getClasses ( ) ) ; } } public void find ( Test test , String packageName ) { packageName = packageName . replace ( '.' , '/' ) ; Set < ClassLoader > set = getClassLoaders ( ) ; for ( ClassLoader classLoader : set ) { find ( test , packageName , classLoader ) ; } } protected void find ( Test test , String packageName , ClassLoader loader ) { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Searching for: " + test + " in package: " + packageName + " using classloader: " + loader . getClass ( ) . getName ( ) ) ; } if ( loader . getClass ( ) . getName ( ) . endsWith ( "org.apache.felix.framework.searchpolicy.ContentClassLoader" ) ) { LOG . trace ( "This is not an URL classloader, skipping" ) ; return ; } try { Method mth = loader . getClass ( ) . getMethod ( "getBundle" , new Class [ ] { } ) ; if ( mth != null ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Loading from osgi buindle using classloader: " + loader ) ; } loadImplementationsInBundle ( test , packageName , loader , mth ) ; return ; } } catch ( NoSuchMethodException e ) { LOG . trace ( "It's not an osgi bundle classloader" ) ; } Enumeration < URL > urls ; try { urls = getResources ( loader , packageName ) ; if ( ! urls . hasMoreElements ( ) ) { LOG . trace ( "No URLs returned by classloader" ) ; } } catch ( IOException ioe ) { LOG . warn ( "Could not read package: " + packageName , ioe ) ; return ; } while ( urls . hasMoreElements ( ) ) { URL url = null ; try { url = urls . nextElement ( ) ; if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "URL from classloader: " + url ) ; } String urlPath = url . getFile ( ) ; urlPath = URLDecoder . decode ( urlPath , "UTF-8" ) ; if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Decoded urlPath: " + urlPath ) ; } if ( urlPath . startsWith ( "file:" ) ) { urlPath = urlPath . substring ( 5 ) ; } if ( urlPath . startsWith ( "bundle:" ) ) { LOG . trace ( "It's a virtual osgi bundle, skipping" ) ; continue ; } if ( urlPath . indexOf ( '!' ) > 0 ) { urlPath = urlPath . substring ( 0 , urlPath . indexOf ( '!' ) ) ; } if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Scanning for classes in [" + urlPath + "] matching criteria: " + test ) ; } File file = new File ( urlPath ) ; if ( file . isDirectory ( ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Loading from directory: " + file ) ; } loadImplementationsInDirectory ( test , packageName , file ) ; } else { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Loading from jar: " + file ) ; } loadImplementationsInJar ( test , packageName , file ) ; } } catch ( IOException ioe ) { LOG . warn ( "Could not read entries in url: " + url , ioe ) ; } } } protected Enumeration < URL > getResources ( ClassLoader loader , String packageName ) throws IOException { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Getting resource URL for package: " + packageName + " with classloader: " + loader ) ; } return loader . getResources ( packageName ) ; } private void loadImplementationsInBundle ( Test test , String packageName , ClassLoader loader , Method mth ) { Set < String > urls = OsgiUtil . getImplementationsInBundle ( test , packageName , loader , mth ) ; if ( urls != null ) { for ( String url : urls ) { addIfMatching ( test , url ) ; } } } private static final class OsgiUtil { private OsgiUtil ( ) { } static Set < String > getImplementationsInBundle ( Test test , String packageName , ClassLoader loader , Method mth ) { try { org . osgi . framework . Bundle bundle = ( org . osgi . framework . Bundle ) mth . invoke ( loader ) ; org . osgi . framework . Bundle [ ] bundles = bundle . getBundleContext ( ) . getBundles ( ) ; Set < String > urls = new HashSet < String > ( ) ; for ( org . osgi . framework . Bundle bd : bundles ) { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Searching in bundle:" + bd ) ; } Enumeration < URL > paths = bd . findEntries ( "/" + packageName , "*.class" , true ) ; while ( paths != null && paths . hasMoreElements ( ) ) { URL path = paths . nextElement ( ) ; urls . add ( path . getPath ( ) . substring ( 1 ) ) ; } } return urls ; } catch ( Throwable t ) { LOG . error ( "Could not search osgi bundles for classes matching criteria: " + test + "due to an Exception: " + t . getMessage ( ) ) ; return null ; } } } private void loadImplementationsInDirectory ( Test test , String parent , File location ) { File [ ] files = location . listFiles ( ) ; StringBuilder builder = null ; for ( File file : files ) { builder = new StringBuilder ( 100 ) ; String name = file . getName ( ) ; if ( name != null ) { name = name . trim ( ) ; builder . append ( parent ) . append ( "/" ) . append ( name ) ; String packageOrClass = parent == null ? name : builder . toString ( ) ; if ( file . isDirectory ( ) ) { loadImplementationsInDirectory ( test , packageOrClass , file ) ; } else if ( name . endsWith ( ".class" ) ) { addIfMatching ( test , packageOrClass ) ; } } } } private void loadImplementationsInJar ( Test test , String parent , File jarfile ) { JarInputStream jarStream = null ; try { jarStream = new JarInputStream ( new FileInputStream ( jarfile ) ) ; JarEntry entry ; while ( ( entry = jarStream . getNextJarEntry ( ) ) != null ) { String name = entry . getName ( ) ; if ( name != null ) { name = name . trim ( ) ; if ( ! entry . isDirectory ( ) && name . startsWith ( parent ) && name . endsWith ( ".class" ) ) { addIfMatching ( test , name ) ; } } } } catch ( IOException ioe ) { LOG . error ( "Could not search jar file '" + jarfile + "' for classes matching criteria: " + test + " due to an IOException: " + ioe . getMessage ( ) , ioe ) ; } finally { ObjectHelper . close ( jarStream , jarfile . getPath ( ) , LOG ) ; } } protected void addIfMatching ( Test test , String fqn ) { try { String externalName = fqn . substring ( 0 , fqn . indexOf ( '.' ) ) . replace ( '/' , '.' ) ; Set < ClassLoader > set = getClassLoaders ( ) ; boolean found = false ; for ( ClassLoader classLoader : set ) { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Testing for class " + externalName + " matches criteria [" + test + "]" ) ; } try { Class type = classLoader . loadClass ( externalName ) ; if ( test . matches ( type ) ) { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Found class: " + type + " in classloader: " + classLoader ) ; } matches . add ( ( Class < T > ) type ) ; } found = true ; break ; } catch ( ClassNotFoundException e ) { LOG . debug ( "Could not find class '" + fqn + "' in classloader: " + classLoader + ". Reason: " + e , e ) ; } catch ( NoClassDefFoundError e ) { LOG . debug ( "Could not find the class defintion '" + fqn + "' in classloader: " + classLoader + ". Reason: " + e , e ) ; } } if ( ! found ) { LOG . warn ( "Could not find class '" + fqn + "' in any classloaders: " + set ) ; } } catch ( Throwable t ) { LOG . warn ( "Could not examine class '" + fqn + "' due to a " + t . getClass ( ) . getName ( ) + " with message: " + t . getMessage ( ) , t ) ; } } } 	1	['14', '1', '1', '10', '71', '41', '4', '7', '7', '0.512820513', '799', '1', '0', '0', '0.316239316', '0', '0', '55.85714286', '14', '3.3571', '3']
package org . apache . camel . component . bean ; import java . util . Collection ; import org . apache . camel . CamelExchangeException ; import org . apache . camel . Exchange ; public class AmbiguousMethodCallException extends CamelExchangeException { private final Collection < MethodInfo > methods ; public AmbiguousMethodCallException ( Exchange exchange , Collection < MethodInfo > methods ) { super ( "Ambiguous method invocations possible: " + methods , exchange ) ; this . methods = methods ; } public Collection < MethodInfo > getMethods ( ) { return methods ; } } 	0	['2', '5', '0', '3', '7', '0', '1', '2', '2', '0', '21', '1', '0', '0.95', '0.666666667', '0', '0', '9', '1', '0.5', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlElements ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Processor ; import org . apache . camel . model . dataformat . ArtixDSDataFormat ; import org . apache . camel . model . dataformat . CsvDataFormat ; import org . apache . camel . model . dataformat . DataFormatType ; import org . apache . camel . model . dataformat . JaxbDataFormat ; import org . apache . camel . model . dataformat . SerializationDataFormat ; import org . apache . camel . model . dataformat . StringDataFormat ; import org . apache . camel . model . dataformat . XMLBeansDataFormat ; import org . apache . camel . processor . UnmarshalProcessor ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "unmarshal" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class UnmarshalType extends OutputType < ProcessorType > { @ XmlAttribute ( required = false ) private String ref ; @ XmlElements ( { @ XmlElement ( required = false , name = "artixDS" , type = ArtixDSDataFormat . class ) , @ XmlElement ( required = false , name = "csv" , type = CsvDataFormat . class ) , @ XmlElement ( required = false , name = "jaxb" , type = JaxbDataFormat . class ) , @ XmlElement ( required = false , name = "serialization" , type = SerializationDataFormat . class ) , @ XmlElement ( required = false , name = "string" , type = StringDataFormat . class ) , @ XmlElement ( required = false , name = "xmlBeans" , type = XMLBeansDataFormat . class ) } ) private DataFormatType dataFormatType ; public UnmarshalType ( ) { } public UnmarshalType ( DataFormatType dataFormatType ) { this . dataFormatType = dataFormatType ; } public UnmarshalType ( String ref ) { this . ref = ref ; } @ Override public String toString ( ) { if ( dataFormatType != null ) { return "Marshal[" + dataFormatType + "]" ; } else { return "Marshal[ref:  " + ref + "]" ; } } @ Override public String getShortName ( ) { return "unmarshal" ; } public String getRef ( ) { return ref ; } public void setRef ( String ref ) { this . ref = ref ; } public DataFormatType getDataFormatType ( ) { return dataFormatType ; } public void setDataFormatType ( DataFormatType dataFormatType ) { this . dataFormatType = dataFormatType ; } @ Override public Processor createProcessor ( RouteContext routeContext ) { DataFormat dataFormat = DataFormatType . getDataFormat ( routeContext , getDataFormatType ( ) , ref ) ; return new UnmarshalProcessor ( dataFormat ) ; } } 	1	['10', '4', '0', '7', '17', '13', '1', '6', '10', '0.555555556', '82', '1', '1', '0.95625', '0.375', '1', '1', '7', '2', '0.8', '1']
package org . apache . camel . processor ; import java . io . ByteArrayOutputStream ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . spi . DataFormat ; public class MarshalProcessor implements Processor { private final DataFormat dataFormat ; public MarshalProcessor ( DataFormat dataFormat ) { this . dataFormat = dataFormat ; } public void process ( Exchange exchange ) throws Exception { ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; Message in = exchange . getIn ( ) ; Object body = in . getBody ( ) ; Message out = exchange . getOut ( true ) ; out . copyFrom ( in ) ; dataFormat . marshal ( exchange , body , buffer ) ; byte [ ] data = buffer . toByteArray ( ) ; out . setBody ( data ) ; } } 	0	['2', '1', '0', '5', '11', '0', '1', '4', '2', '0', '39', '1', '1', '0', '0.666666667', '0', '0', '18', '1', '0.5', '0']
package org . apache . camel . builder ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . NoSuchEndpointException ; import org . apache . camel . processor . LoggingLevel ; import org . apache . camel . processor . SendProcessor ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public abstract class BuilderSupport { private CamelContext context ; private ErrorHandlerBuilder errorHandlerBuilder ; private boolean inheritErrorHandler = true ; protected BuilderSupport ( CamelContext context ) { this . context = context ; } protected BuilderSupport ( BuilderSupport parent ) { this . context = parent . getContext ( ) ; this . inheritErrorHandler = parent . inheritErrorHandler ; if ( inheritErrorHandler && parent . errorHandlerBuilder != null ) { this . errorHandlerBuilder = parent . errorHandlerBuilder . copy ( ) ; } } public ValueBuilder header ( String name ) { return Builder . header ( name ) ; } public ValueBuilder body ( ) { return Builder . body ( ) ; } public < T > ValueBuilder body ( Class < T > type ) { return Builder . bodyAs ( type ) ; } public ValueBuilder outBody ( ) { return Builder . outBody ( ) ; } public < T > ValueBuilder outBody ( Class < T > type ) { return Builder . outBodyAs ( type ) ; } public ValueBuilder faultBody ( ) { return Builder . faultBody ( ) ; } public < T > ValueBuilder faultBodyAs ( Class < T > type ) { return Builder . faultBodyAs ( type ) ; } public ValueBuilder systemProperty ( String name ) { return Builder . systemProperty ( name ) ; } public ValueBuilder systemProperty ( String name , String defaultValue ) { return Builder . systemProperty ( name , defaultValue ) ; } public ValueBuilder constant ( Object value ) { return Builder . constant ( value ) ; } public Endpoint endpoint ( String uri ) throws NoSuchEndpointException { ObjectHelper . notNull ( uri , "uri" ) ; Endpoint endpoint = getContext ( ) . getEndpoint ( uri ) ; if ( endpoint == null ) { throw new NoSuchEndpointException ( uri ) ; } return endpoint ; } public < T extends Endpoint > T endpoint ( String uri , Class < T > type ) throws NoSuchEndpointException { ObjectHelper . notNull ( uri , "uri" ) ; T endpoint = getContext ( ) . getEndpoint ( uri , type ) ; if ( endpoint == null ) { throw new NoSuchEndpointException ( uri ) ; } return endpoint ; } public List < Endpoint > endpoints ( String ... uris ) throws NoSuchEndpointException { List < Endpoint > endpoints = new ArrayList < Endpoint > ( ) ; for ( String uri : uris ) { endpoints . add ( endpoint ( uri ) ) ; } return endpoints ; } public List < Endpoint > endpoints ( Endpoint ... endpoints ) { List < Endpoint > answer = new ArrayList < Endpoint > ( ) ; answer . addAll ( Arrays . asList ( endpoints ) ) ; return answer ; } public NoErrorHandlerBuilder noErrorHandler ( ) { return new NoErrorHandlerBuilder ( ) ; } public LoggingErrorHandlerBuilder loggingErrorHandler ( ) { return new LoggingErrorHandlerBuilder ( ) ; } public LoggingErrorHandlerBuilder loggingErrorHandler ( String log ) { return loggingErrorHandler ( LogFactory . getLog ( log ) ) ; } public LoggingErrorHandlerBuilder loggingErrorHandler ( Log log ) { return new LoggingErrorHandlerBuilder ( log ) ; } public LoggingErrorHandlerBuilder loggingErrorHandler ( Log log , LoggingLevel level ) { return new LoggingErrorHandlerBuilder ( log , level ) ; } public DeadLetterChannelBuilder deadLetterChannel ( ) { return new DeadLetterChannelBuilder ( ) ; } public DeadLetterChannelBuilder deadLetterChannel ( String deadLetterUri ) { return deadLetterChannel ( endpoint ( deadLetterUri ) ) ; } public DeadLetterChannelBuilder deadLetterChannel ( Endpoint deadLetterEndpoint ) { return new DeadLetterChannelBuilder ( new SendProcessor ( deadLetterEndpoint ) ) ; } public CamelContext getContext ( ) { return context ; } public void setContext ( CamelContext context ) { this . context = context ; } public ErrorHandlerBuilder getErrorHandlerBuilder ( ) { if ( errorHandlerBuilder == null ) { errorHandlerBuilder = createErrorHandlerBuilder ( ) ; } return errorHandlerBuilder ; } protected ErrorHandlerBuilder createErrorHandlerBuilder ( ) { if ( isInheritErrorHandler ( ) ) { return new DeadLetterChannelBuilder ( ) ; } else { return new NoErrorHandlerBuilder ( ) ; } } public void setErrorHandlerBuilder ( ErrorHandlerBuilder errorHandlerBuilder ) { this . errorHandlerBuilder = errorHandlerBuilder ; } public boolean isInheritErrorHandler ( ) { return inheritErrorHandler ; } public void setInheritErrorHandler ( boolean inheritErrorHandler ) { this . inheritErrorHandler = inheritErrorHandler ; } } 	1	['31', '1', '1', '16', '59', '437', '1', '15', '28', '0.855555556', '251', '1', '2', '0', '0.133995037', '0', '0', '7', '2', '1', '3']
package org . apache . camel . util ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public final class PackageHelper { private static final transient Log LOG = LogFactory . getLog ( PackageHelper . class ) ; private PackageHelper ( ) { } public static boolean isValidVersion ( String packageName , double minimumVersion ) { try { Package spring = Package . getPackage ( packageName ) ; String value = spring . getImplementationVersion ( ) ; if ( value != null ) { int idx = value . indexOf ( '.' ) ; if ( idx >= 0 ) { StringBuffer buffer = new StringBuffer ( value . substring ( 0 , ++ idx ) ) ; int i = idx ; for ( int size = value . length ( ) ; i < size ; i ++ ) { char ch = value . charAt ( i ) ; if ( Character . isDigit ( ch ) ) { buffer . append ( ch ) ; } } value = buffer . toString ( ) ; } double number = Double . parseDouble ( value ) ; return number >= minimumVersion ; } } catch ( Exception e ) { LOG . debug ( "Failed to find out " + packageName + " version: " + e , e ) ; } return true ; } } 	0	['3', '1', '0', '3', '21', '1', '1', '2', '1', '0.5', '88', '1', '0', '0', '0.5', '0', '0', '28', '5', '1.6667', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . ThreadPoolExecutor ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Processor ; import org . apache . camel . processor . Pipeline ; import org . apache . camel . processor . ThreadProcessor ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "thread" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ThreadType extends ProcessorType < ProcessorType > { @ XmlAttribute ( required = false ) private Integer coreSize = 1 ; @ XmlAttribute ( required = false ) private Boolean daemon = Boolean . TRUE ; @ XmlAttribute ( required = false ) private Long keepAliveTime ; @ XmlAttribute ( required = false ) private Integer maxSize = 1 ; @ XmlAttribute ( required = false ) private String name = "Thread Processor" ; @ XmlAttribute ( required = false ) private Integer priority = Thread . NORM_PRIORITY ; @ XmlAttribute ( required = false ) private Long stackSize ; @ XmlElementRef private List < ProcessorType < ? > > outputs = new ArrayList < ProcessorType < ? > > ( ) ; @ XmlTransient private BlockingQueue < Runnable > taskQueue ; @ XmlTransient private ThreadGroup threadGroup ; @ XmlTransient private ThreadPoolExecutor executor ; public ThreadType ( ) { } public ThreadType ( int coreSize ) { this . coreSize = coreSize ; this . maxSize = coreSize ; } public ThreadType ( ThreadPoolExecutor executor ) { this . executor = executor ; } @ Override public List < ProcessorType < ? > > getOutputs ( ) { return outputs ; } @ Override public String toString ( ) { return "Thread[" + getLabel ( ) + "]" ; } @ Override public String getShortName ( ) { return "thread" ; } @ Override public String getLabel ( ) { return "coreSize=" + coreSize ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { ThreadProcessor thread = new ThreadProcessor ( ) ; thread . setExecutor ( executor ) ; if ( coreSize != null ) { thread . setCoreSize ( coreSize ) ; } if ( daemon != null ) { thread . setDaemon ( daemon ) ; } if ( keepAliveTime != null ) { thread . setKeepAliveTime ( keepAliveTime ) ; } if ( maxSize != null ) { thread . setMaxSize ( maxSize ) ; } thread . setName ( name ) ; thread . setPriority ( priority ) ; if ( stackSize != null ) { thread . setStackSize ( stackSize ) ; } thread . setTaskQueue ( taskQueue ) ; thread . setThreadGroup ( threadGroup ) ; ArrayList < Processor > pipe = new ArrayList < Processor > ( 2 ) ; pipe . add ( thread ) ; pipe . add ( createOutputsProcessor ( routeContext , outputs ) ) ; return new Pipeline ( pipe ) ; } public ThreadType coreSize ( int coreSize ) { setCoreSize ( coreSize ) ; return this ; } public ThreadType daemon ( boolean daemon ) { setDaemon ( daemon ) ; return this ; } public ThreadType keepAliveTime ( long keepAliveTime ) { setKeepAliveTime ( keepAliveTime ) ; return this ; } public ThreadType maxSize ( int maxSize ) { setMaxSize ( maxSize ) ; return this ; } public ThreadType name ( String name ) { setName ( name ) ; return this ; } public ThreadType priority ( int priority ) { setPriority ( priority ) ; return this ; } public ThreadType stackSize ( long stackSize ) { setStackSize ( stackSize ) ; return this ; } public ThreadType taskQueue ( BlockingQueue < Runnable > taskQueue ) { setTaskQueue ( taskQueue ) ; return this ; } public ThreadType threadGroup ( ThreadGroup threadGroup ) { setThreadGroup ( threadGroup ) ; return this ; } public ThreadType executor ( ThreadPoolExecutor executor ) { setExecutor ( executor ) ; return this ; } public void setCoreSize ( int coreSize ) { this . coreSize = coreSize ; } public void setDaemon ( boolean daemon ) { this . daemon = daemon ; } public void setKeepAliveTime ( long keepAliveTime ) { this . keepAliveTime = keepAliveTime ; } public void setMaxSize ( int maxSize ) { this . maxSize = maxSize ; } public void setName ( String name ) { this . name = name ; } public void setPriority ( int priority ) { this . priority = priority ; } public void setStackSize ( long stackSize ) { this . stackSize = stackSize ; } public void setTaskQueue ( BlockingQueue < Runnable > taskQueue ) { this . taskQueue = taskQueue ; } public void setThreadGroup ( ThreadGroup threadGroup ) { this . threadGroup = threadGroup ; } public ThreadPoolExecutor getExecutor ( ) { return executor ; } public void setExecutor ( ThreadPoolExecutor executor ) { this . executor = executor ; } } 	1	['29', '3', '0', '5', '56', '318', '1', '5', '29', '0.86038961', '342', '1', '0', '0.852272727', '0.199233716', '1', '3', '10.4137931', '1', '0.8966', '1']
package org . apache . camel . component . seda ; import java . util . Collection ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultProducer ; public class CollectionProducer extends DefaultProducer implements AsyncProcessor { private final Collection < Exchange > queue ; public CollectionProducer ( Endpoint endpoint , Collection < Exchange > queue ) { super ( endpoint ) ; this . queue = queue ; } public void process ( Exchange exchange ) throws Exception { queue . add ( exchange . copy ( ) ) ; } public boolean process ( Exchange exchange , AsyncCallback callback ) { queue . add ( exchange . copy ( ) ) ; callback . done ( true ) ; return true ; } } 	0	['3', '3', '0', '6', '7', '0', '1', '5', '3', '0', '29', '1', '0', '0.909090909', '0.533333333', '0', '0', '8.333333333', '1', '0.6667', '0']
package org . apache . camel . util ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . NoSuchEndpointException ; import org . apache . camel . spi . Injector ; import org . apache . camel . spi . Language ; import org . apache . camel . spi . Registry ; import static org . apache . camel . util . ObjectHelper . notNull ; public final class CamelContextHelper { private CamelContextHelper ( ) { } public static Endpoint getMandatoryEndpoint ( CamelContext camelContext , String uri ) throws NoSuchEndpointException { Endpoint endpoint = camelContext . getEndpoint ( uri ) ; if ( endpoint == null ) { throw new NoSuchEndpointException ( uri ) ; } else { return endpoint ; } } public static < T extends Endpoint > T getMandatoryEndpoint ( CamelContext camelContext , String uri , Class < T > type ) { Endpoint endpoint = getMandatoryEndpoint ( camelContext , uri ) ; return ObjectHelper . cast ( type , endpoint ) ; } public static < T > List < T > getSingletonEndpoints ( CamelContext camelContext , Class < T > type ) { List < T > answer = new ArrayList < T > ( ) ; Collection < Endpoint > endpoints = camelContext . getSingletonEndpoints ( ) ; for ( Endpoint endpoint : endpoints ) { if ( type . isInstance ( endpoint ) ) { T value = type . cast ( endpoint ) ; answer . add ( value ) ; } } return answer ; } public static < T > T convertTo ( CamelContext context , Class < T > type , Object value ) { notNull ( context , "camelContext" ) ; return context . getTypeConverter ( ) . convertTo ( type , value ) ; } public static < T > T mandatoryConvertTo ( CamelContext context , Class < T > type , Object value ) { T answer = convertTo ( context , type , value ) ; if ( answer == null ) { throw new IllegalArgumentException ( "Value " + value + " converted to " + type . getName ( ) + " cannot be null" ) ; } return answer ; } public static < T > T newInstance ( CamelContext context , Class < T > beanType ) { return context . getInjector ( ) . newInstance ( beanType ) ; } public static Object lookup ( CamelContext context , String name ) { return context . getRegistry ( ) . lookup ( name ) ; } public static < T > T lookup ( CamelContext context , String name , Class < T > beanType ) { return context . getRegistry ( ) . lookup ( name , beanType ) ; } public static Object mandatoryLookup ( CamelContext context , String name ) { Object answer = lookup ( context , name ) ; notNull ( answer , "registry entry called " + name ) ; return answer ; } public static < T > T mandatoryLookup ( CamelContext context , String name , Class < T > beanType ) { T answer = lookup ( context , name , beanType ) ; notNull ( answer , "registry entry called " + name + " of type " + beanType . getName ( ) ) ; return answer ; } public static Language resolveMandatoryLanguage ( CamelContext camelContext , String languageName ) { notNull ( camelContext , "camelContext" ) ; notNull ( languageName , "languageName" ) ; Language language = camelContext . resolveLanguage ( languageName ) ; if ( language == null ) { throw new IllegalArgumentException ( "Could not resolve language: " + languageName ) ; } return language ; } public static Expression resolveMandatoryExpression ( CamelContext camelContext , String languageName , String expressionText ) { notNull ( expressionText , "expressionText" ) ; Language language = resolveMandatoryLanguage ( camelContext , languageName ) ; Expression < Exchange > expression = language . createExpression ( expressionText ) ; if ( expression == null ) { throw new IllegalArgumentException ( "Could not create expression: " + expressionText + " with language: " + language ) ; } return expression ; } } 	1	['13', '1', '0', '24', '41', '78', '15', '9', '12', '2', '218', '0', '0', '0', '0.461538462', '0', '0', '15.76923077', '2', '1.2308', '1']
package org . apache . camel . dataformat . xstream ; import java . io . InputStream ; import java . io . OutputStream ; import javax . xml . stream . XMLStreamException ; import javax . xml . stream . XMLStreamReader ; import javax . xml . stream . XMLStreamWriter ; import com . thoughtworks . xstream . XStream ; import com . thoughtworks . xstream . io . HierarchicalStreamReader ; import com . thoughtworks . xstream . io . HierarchicalStreamWriter ; import com . thoughtworks . xstream . io . xml . QNameMap ; import com . thoughtworks . xstream . io . xml . StaxReader ; import com . thoughtworks . xstream . io . xml . StaxWriter ; import org . apache . camel . Exchange ; import org . apache . camel . converter . jaxp . StaxConverter ; import org . apache . camel . spi . DataFormat ; public class XStreamDataFormat implements DataFormat { private XStream xstream ; private StaxConverter staxConverter ; public void marshal ( Exchange exchange , Object body , OutputStream stream ) throws Exception { HierarchicalStreamWriter writer = createHierarchicalStreamWriter ( exchange , body , stream ) ; getXStream ( ) . marshal ( body , writer ) ; } public Object unmarshal ( Exchange exchange , InputStream stream ) throws Exception { HierarchicalStreamReader reader = createHierarchicalStreamReader ( exchange , stream ) ; return getXStream ( ) . unmarshal ( reader ) ; } public XStream getXStream ( ) { if ( xstream == null ) { xstream = createXStream ( ) ; } return xstream ; } public void setXStream ( XStream xstream ) { this . xstream = xstream ; } public StaxConverter getStaxConverter ( ) { if ( staxConverter == null ) { staxConverter = new StaxConverter ( ) ; } return staxConverter ; } public void setStaxConverter ( StaxConverter staxConverter ) { this . staxConverter = staxConverter ; } protected XStream createXStream ( ) { return new XStream ( ) ; } protected HierarchicalStreamWriter createHierarchicalStreamWriter ( Exchange exchange , Object body , OutputStream stream ) throws XMLStreamException { XMLStreamWriter xmlWriter = getStaxConverter ( ) . createXMLStreamWriter ( stream ) ; return new StaxWriter ( new QNameMap ( ) , xmlWriter ) ; } protected HierarchicalStreamReader createHierarchicalStreamReader ( Exchange exchange , InputStream stream ) throws XMLStreamException { XMLStreamReader xmlReader = getStaxConverter ( ) . createXMLStreamReader ( stream ) ; return new StaxReader ( new QNameMap ( ) , xmlReader ) ; } } 	0	['10', '1', '0', '9', '20', '41', '0', '9', '7', '0.666666667', '96', '1', '1', '0', '0.314285714', '0', '0', '8.4', '2', '1.1', '0']
package org . apache . camel . processor ; import java . util . Collection ; import java . util . Iterator ; import java . util . List ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . impl . converter . AsyncProcessorTypeConverter ; import org . apache . camel . util . AsyncProcessorHelper ; import org . apache . camel . util . ExchangeHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class Pipeline extends MulticastProcessor implements AsyncProcessor { private static final transient Log LOG = LogFactory . getLog ( Pipeline . class ) ; public Pipeline ( Collection < Processor > processors ) { super ( processors ) ; } public static Processor newInstance ( List < Processor > processors ) { if ( processors . isEmpty ( ) ) { return null ; } else if ( processors . size ( ) == 1 ) { return processors . get ( 0 ) ; } return new Pipeline ( processors ) ; } public void process ( Exchange exchange ) throws Exception { AsyncProcessorHelper . process ( this , exchange ) ; } public boolean process ( Exchange original , AsyncCallback callback ) { Iterator < Processor > processors = getProcessors ( ) . iterator ( ) ; Exchange nextExchange = original ; boolean first = true ; while ( true ) { if ( nextExchange . isFailed ( ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Message exchange has failed so breaking out of pipeline: " + nextExchange + " exception: " + nextExchange . getException ( ) + " fault: " + nextExchange . getFault ( false ) ) ; } break ; } if ( ! processors . hasNext ( ) ) { break ; } AsyncProcessor processor = AsyncProcessorTypeConverter . convert ( processors . next ( ) ) ; if ( first ) { first = false ; } else { nextExchange = createNextExchange ( processor , nextExchange ) ; } boolean sync = process ( original , nextExchange , callback , processors , processor ) ; if ( ! sync ) { return false ; } } ExchangeHelper . copyResults ( original , nextExchange ) ; callback . done ( true ) ; return true ; } private boolean process ( final Exchange original , final Exchange exchange , final AsyncCallback callback , final Iterator < Processor > processors , AsyncProcessor processor ) { return processor . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { if ( sync ) { return ; } Exchange nextExchange = exchange ; while ( processors . hasNext ( ) ) { AsyncProcessor processor = AsyncProcessorTypeConverter . convert ( processors . next ( ) ) ; if ( nextExchange . isFailed ( ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Message exchange has failed so breaking out of pipeline: " + nextExchange + " exception: " + nextExchange . getException ( ) + " fault: " + nextExchange . getFault ( false ) ) ; } break ; } nextExchange = createNextExchange ( processor , nextExchange ) ; sync = process ( original , nextExchange , callback , processors , processor ) ; if ( ! sync ) { return ; } } ExchangeHelper . copyResults ( original , nextExchange ) ; callback . done ( false ) ; } } ) ; } protected Exchange createNextExchange ( Processor producer , Exchange previousExchange ) { Exchange answer = previousExchange . newInstance ( ) ; answer . getProperties ( ) . putAll ( previousExchange . getProperties ( ) ) ; Message previousOut = previousExchange . getOut ( false ) ; Message in = answer . getIn ( ) ; if ( previousOut != null ) { in . copyFrom ( previousOut ) ; } else { in . copyFrom ( previousExchange . getIn ( ) ) ; } return answer ; } @ Override public String toString ( ) { return "Pipeline" + getProcessors ( ) ; } } 	1	['10', '3', '0', '15', '40', '39', '4', '12', '5', '0.777777778', '177', '1', '0', '0.741935484', '0.271604938', '0', '0', '16.6', '5', '1.5', '2']
package org . apache . camel . component . xmpp ; import java . util . Iterator ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . jivesoftware . smack . PacketListener ; import org . jivesoftware . smack . packet . Message ; import org . jivesoftware . smack . packet . Packet ; import org . jivesoftware . smack . packet . RosterPacket ; public class XmppConsumer extends DefaultConsumer < XmppExchange > implements PacketListener { private static final transient Log LOG = LogFactory . getLog ( XmppConsumer . class ) ; private final XmppEndpoint endpoint ; public XmppConsumer ( XmppEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; endpoint . getConnection ( ) . addPacketListener ( this , endpoint . getFilter ( ) ) ; } @ Override protected void doStop ( ) throws Exception { endpoint . getConnection ( ) . removePacketListener ( this ) ; super . doStop ( ) ; } public void processPacket ( Packet packet ) { if ( packet instanceof Message ) { Message message = ( Message ) packet ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "<<<< message: " + message . getBody ( ) ) ; } XmppExchange exchange = endpoint . createExchange ( message ) ; try { getProcessor ( ) . process ( exchange ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } else if ( packet instanceof RosterPacket ) { RosterPacket rosterPacket = ( RosterPacket ) packet ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Roster packet with : " + rosterPacket . getRosterItemCount ( ) + " item(s)" ) ; Iterator rosterItems = rosterPacket . getRosterItems ( ) ; while ( rosterItems . hasNext ( ) ) { Object item = rosterItems . next ( ) ; LOG . debug ( "Roster item: " + item ) ; } } } else { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "<<<< ignored packet: " + packet ) ; } } } } 	0	['5', '3', '0', '14', '29', '0', '1', '14', '2', '0.5', '129', '1', '1', '0.88', '0.4375', '1', '1', '24.4', '5', '1.4', '0']
package org . apache . camel . component . mock ; import java . beans . PropertyChangeListener ; import java . beans . PropertyChangeSupport ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . spi . BrowsableEndpoint ; import org . apache . camel . util . CamelContextHelper ; import org . apache . camel . util . ExpressionComparator ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class MockEndpoint extends DefaultEndpoint < Exchange > implements BrowsableEndpoint < Exchange > { private static final transient Log LOG = LogFactory . getLog ( MockEndpoint . class ) ; private int expectedCount ; private int counter ; private Processor defaultProcessor ; private Map < Integer , Processor > processors ; private List < Exchange > receivedExchanges ; private List < Throwable > failures ; private List < Runnable > tests ; private CountDownLatch latch ; private long sleepForEmptyTest ; private long resultWaitTime ; private int expectedMinimumCount ; private List expectedBodyValues ; private List actualBodyValues ; private PropertyChangeSupport propertyChangeSupport = new PropertyChangeSupport ( this ) ; private String headerName ; private String headerValue ; private Object actualHeader ; private Processor reporter ; public MockEndpoint ( String endpointUri , Component component ) { super ( endpointUri , component ) ; init ( ) ; } public MockEndpoint ( String endpointUri ) { super ( endpointUri ) ; init ( ) ; } public static MockEndpoint resolve ( CamelContext context , String uri ) { return CamelContextHelper . getMandatoryEndpoint ( context , uri , MockEndpoint . class ) ; } public static void assertWait ( long timeout , TimeUnit unit , MockEndpoint ... endpoints ) throws InterruptedException { long start = System . currentTimeMillis ( ) ; long left = unit . toMillis ( timeout ) ; long end = start + left ; for ( MockEndpoint endpoint : endpoints ) { if ( ! endpoint . await ( left , TimeUnit . MILLISECONDS ) ) { throw new AssertionError ( "Timeout waiting for endpoints to receive enough messages. " + endpoint . getEndpointUri ( ) + " timed out." ) ; } left = end - System . currentTimeMillis ( ) ; if ( left <= 0 ) { left = 0 ; } } } public static void assertIsSatisfied ( long timeout , TimeUnit unit , MockEndpoint ... endpoints ) throws InterruptedException { assertWait ( timeout , unit , endpoints ) ; for ( MockEndpoint endpoint : endpoints ) { endpoint . assertIsSatisfied ( ) ; } } public static void assertIsSatisfied ( MockEndpoint ... endpoints ) throws InterruptedException { for ( MockEndpoint endpoint : endpoints ) { endpoint . assertIsSatisfied ( ) ; } } public static void assertIsSatisfied ( CamelContext context ) throws InterruptedException { ObjectHelper . notNull ( context , "camelContext" ) ; Collection < Endpoint > endpoints = context . getSingletonEndpoints ( ) ; for ( Endpoint endpoint : endpoints ) { if ( endpoint instanceof MockEndpoint ) { MockEndpoint mockEndpoint = ( MockEndpoint ) endpoint ; mockEndpoint . assertIsSatisfied ( ) ; } } } public static void expectsMessageCount ( int count , MockEndpoint ... endpoints ) throws InterruptedException { for ( MockEndpoint endpoint : endpoints ) { MockEndpoint . expectsMessageCount ( count ) ; } } public List < Exchange > getExchanges ( ) { return getReceivedExchanges ( ) ; } public void addPropertyChangeListener ( PropertyChangeListener listener ) { propertyChangeSupport . addPropertyChangeListener ( listener ) ; } public void removePropertyChangeListener ( PropertyChangeListener listener ) { propertyChangeSupport . removePropertyChangeListener ( listener ) ; } public Consumer < Exchange > createConsumer ( Processor processor ) throws Exception { throw new UnsupportedOperationException ( "You cannot consume from this endpoint" ) ; } public Producer < Exchange > createProducer ( ) throws Exception { return new DefaultProducer < Exchange > ( this ) { public void process ( Exchange exchange ) { onExchange ( exchange ) ; } } ; } public void reset ( ) { init ( ) ; } public void whenExchangeReceived ( int index , Processor processor ) { this . processors . put ( index , processor ) ; } public void whenAnyExchangeReceived ( Processor processor ) { this . defaultProcessor = processor ; } public void assertIsSatisfied ( ) throws InterruptedException { assertIsSatisfied ( sleepForEmptyTest ) ; } public void assertIsSatisfied ( long timeoutForEmptyEndpoints ) throws InterruptedException { LOG . info ( "Asserting: " + this + " is satisfied" ) ; if ( expectedCount >= 0 ) { if ( expectedCount != getReceivedCounter ( ) ) { if ( expectedCount == 0 ) { if ( timeoutForEmptyEndpoints > 0 ) { LOG . debug ( "Sleeping for: " + timeoutForEmptyEndpoints + " millis to check there really are no messages received" ) ; Thread . sleep ( timeoutForEmptyEndpoints ) ; } } else { waitForCompleteLatch ( ) ; } } assertEquals ( "Received message count" , expectedCount , getReceivedCounter ( ) ) ; } else if ( expectedMinimumCount > 0 && getReceivedCounter ( ) < expectedMinimumCount ) { waitForCompleteLatch ( ) ; } if ( expectedMinimumCount >= 0 ) { int receivedCounter = getReceivedCounter ( ) ; assertTrue ( "Received message count " + receivedCounter + ", expected at least " + expectedCount , expectedCount <= receivedCounter ) ; } for ( Runnable test : tests ) { test . run ( ) ; } for ( Throwable failure : failures ) { if ( failure != null ) { LOG . error ( "Caught on " + getEndpointUri ( ) + " Exception: " + failure , failure ) ; fail ( "Failed due to caught exception: " + failure ) ; } } } public void assertIsNotSatisfied ( ) throws InterruptedException { try { assertIsSatisfied ( ) ; fail ( "Expected assertion failure!" ) ; } catch ( AssertionError e ) { LOG . info ( "Caught expected failure: " + e ) ; } } public void expectedMessageCount ( int expectedCount ) { setExpectedMessageCount ( expectedCount ) ; } public void expectedMinimumMessageCount ( int expectedCount ) { setMinimumExpectedMessageCount ( expectedCount ) ; } public void expectedHeaderReceived ( String name , String value ) { this . headerName = name ; this . headerValue = value ; expects ( new Runnable ( ) { public void run ( ) { assertTrue ( "No header with name " + headerName + " found." , actualHeader != null ) ; assertEquals ( "Header of message" , headerValue , actualHeader ) ; } } ) ; } public void expectedBodiesReceived ( final List bodies ) { expectedMessageCount ( bodies . size ( ) ) ; this . expectedBodyValues = bodies ; this . actualBodyValues = new ArrayList ( ) ; expects ( new Runnable ( ) { public void run ( ) { for ( int i = 0 ; i < expectedBodyValues . size ( ) ; i ++ ) { Exchange exchange = getReceivedExchanges ( ) . get ( i ) ; assertTrue ( "No exchange received for counter: " + i , exchange != null ) ; Object expectedBody = expectedBodyValues . get ( i ) ; Object actualBody = actualBodyValues . get ( i ) ; assertEquals ( "Body of message: " + i , expectedBody , actualBody ) ; } } } ) ; } public void expectedBodiesReceived ( Object ... bodies ) { List bodyList = new ArrayList ( ) ; bodyList . addAll ( Arrays . asList ( bodies ) ) ; expectedBodiesReceived ( bodyList ) ; } public void expectsAscending ( final Expression < Exchange > expression ) { expects ( new Runnable ( ) { public void run ( ) { assertMessagesAscending ( expression ) ; } } ) ; } public void expectsDescending ( final Expression < Exchange > expression ) { expects ( new Runnable ( ) { public void run ( ) { assertMessagesDescending ( expression ) ; } } ) ; } public void expectsNoDuplicates ( final Expression < Exchange > expression ) { expects ( new Runnable ( ) { public void run ( ) { assertNoDuplicates ( expression ) ; } } ) ; } public void assertMessagesAscending ( Expression < Exchange > expression ) { assertMessagesSorted ( expression , true ) ; } public void assertMessagesDescending ( Expression < Exchange > expression ) { assertMessagesSorted ( expression , false ) ; } protected void assertMessagesSorted ( Expression < Exchange > expression , boolean ascending ) { String type = ascending ? "ascending" : "descending" ; ExpressionComparator comparator = new ExpressionComparator ( expression ) ; List < Exchange > list = getReceivedExchanges ( ) ; for ( int i = 1 ; i < list . size ( ) ; i ++ ) { int j = i - 1 ; Exchange e1 = list . get ( j ) ; Exchange e2 = list . get ( i ) ; int result = comparator . compare ( e1 , e2 ) ; if ( result == 0 ) { fail ( "Messages not " + type + ". Messages" + j + " and " + i + " are equal with value: " + expression . evaluate ( e1 ) + " for expression: " + expression + ". Exchanges: " + e1 + " and " + e2 ) ; } else { if ( ! ascending ) { result = result * - 1 ; } if ( result > 0 ) { fail ( "Messages not " + type + ". Message " + j + " has value: " + expression . evaluate ( e1 ) + " and message " + i + " has value: " + expression . evaluate ( e2 ) + " for expression: " + expression + ". Exchanges: " + e1 + " and " + e2 ) ; } } } } public void assertNoDuplicates ( Expression < Exchange > expression ) { Map < Object , Exchange > map = new HashMap < Object , Exchange > ( ) ; List < Exchange > list = getReceivedExchanges ( ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { Exchange e2 = list . get ( i ) ; Object key = expression . evaluate ( e2 ) ; Exchange e1 = map . get ( key ) ; if ( e1 != null ) { fail ( "Duplicate message found on message " + i + " has value: " + key + " for expression: " + expression + ". Exchanges: " + e1 + " and " + e2 ) ; } else { map . put ( key , e2 ) ; } } } public void expects ( Runnable runnable ) { tests . add ( runnable ) ; } public AssertionClause message ( final int messageIndex ) { AssertionClause clause = new AssertionClause ( ) { public void run ( ) { applyAssertionOn ( MockEndpoint . this , messageIndex , assertExchangeReceived ( messageIndex ) ) ; } } ; expects ( clause ) ; return clause ; } public AssertionClause allMessages ( ) { AssertionClause clause = new AssertionClause ( ) { public void run ( ) { List < Exchange > list = getReceivedExchanges ( ) ; int index = 0 ; for ( Exchange exchange : list ) { applyAssertionOn ( MockEndpoint . this , index ++ , exchange ) ; } } } ; expects ( clause ) ; return clause ; } public Exchange assertExchangeReceived ( int index ) { int count = getReceivedCounter ( ) ; assertTrue ( "Not enough messages received. Was: " + count , count > index ) ; return getReceivedExchanges ( ) . get ( index ) ; } public List < Throwable > getFailures ( ) { return failures ; } public int getReceivedCounter ( ) { return getReceivedExchanges ( ) . size ( ) ; } public List < Exchange > getReceivedExchanges ( ) { return receivedExchanges ; } public int getExpectedCount ( ) { return expectedCount ; } public long getSleepForEmptyTest ( ) { return sleepForEmptyTest ; } public void setSleepForEmptyTest ( long sleepForEmptyTest ) { this . sleepForEmptyTest = sleepForEmptyTest ; } public long getResultWaitTime ( ) { return resultWaitTime ; } public void setResultWaitTime ( long resultWaitTime ) { this . resultWaitTime = resultWaitTime ; } public void setExpectedMessageCount ( int expectedCount ) { this . expectedCount = expectedCount ; if ( expectedCount <= 0 ) { latch = null ; } else { latch = new CountDownLatch ( expectedCount ) ; } } public void setMinimumExpectedMessageCount ( int expectedCount ) { this . expectedMinimumCount = expectedCount ; if ( expectedCount <= 0 ) { latch = null ; } else { latch = new CountDownLatch ( expectedMinimumCount ) ; } } public Processor getReporter ( ) { return reporter ; } public void setReporter ( Processor reporter ) { this . reporter = reporter ; } private void init ( ) { expectedCount = - 1 ; counter = 0 ; processors = new HashMap < Integer , Processor > ( ) ; receivedExchanges = new CopyOnWriteArrayList < Exchange > ( ) ; failures = new CopyOnWriteArrayList < Throwable > ( ) ; tests = new CopyOnWriteArrayList < Runnable > ( ) ; latch = null ; sleepForEmptyTest = 1000L ; resultWaitTime = 20000L ; expectedMinimumCount = - 1 ; expectedBodyValues = null ; actualBodyValues = new ArrayList ( ) ; } protected synchronized void onExchange ( Exchange exchange ) { try { if ( reporter != null ) { reporter . process ( exchange ) ; } performAssertions ( exchange ) ; } catch ( Throwable e ) { failures . add ( e ) ; } if ( latch != null ) { latch . countDown ( ) ; } } protected void performAssertions ( Exchange exchange ) throws Exception { Message in = exchange . getIn ( ) ; Object actualBody = in . getBody ( ) ; if ( headerName != null ) { actualHeader = in . getHeader ( headerName ) ; } if ( expectedBodyValues != null ) { int index = actualBodyValues . size ( ) ; if ( expectedBodyValues . size ( ) > index ) { Object expectedBody = expectedBodyValues . get ( index ) ; if ( expectedBody != null ) { actualBody = in . getBody ( expectedBody . getClass ( ) ) ; } actualBodyValues . add ( actualBody ) ; } } LOG . debug ( getEndpointUri ( ) + " >>>> " + ( ++ counter ) + " : " + exchange + " with body: " + actualBody ) ; receivedExchanges . add ( exchange ) ; Processor processor = processors . get ( getReceivedCounter ( ) ) != null ? processors . get ( getReceivedCounter ( ) ) : defaultProcessor ; if ( processor != null ) { processor . process ( exchange ) ; } } protected void waitForCompleteLatch ( ) throws InterruptedException { if ( latch == null ) { fail ( "Should have a latch!" ) ; } LOG . debug ( "Waiting on the latch for: " + resultWaitTime + " millis" ) ; latch . await ( resultWaitTime , TimeUnit . MILLISECONDS ) ; } protected void assertEquals ( String message , Object expectedValue , Object actualValue ) { if ( ! ObjectHelper . equal ( expectedValue , actualValue ) ) { fail ( message + ". Expected: <" + expectedValue + "> but was: <" + actualValue + ">" ) ; } } protected void assertTrue ( String message , boolean predicate ) { if ( ! predicate ) { fail ( message ) ; } } protected void fail ( Object message ) { if ( LOG . isDebugEnabled ( ) ) { List < Exchange > list = getReceivedExchanges ( ) ; int index = 0 ; for ( Exchange exchange : list ) { LOG . debug ( "Received[" + ( ++ index ) + "]: " + exchange ) ; } } throw new AssertionError ( getEndpointUri ( ) + " " + message ) ; } public int getExpectedMinimumCount ( ) { return expectedMinimumCount ; } public void await ( ) throws InterruptedException { if ( latch != null ) { latch . await ( ) ; } } public boolean await ( long timeout , TimeUnit unit ) throws InterruptedException { if ( latch != null ) { return latch . await ( timeout , unit ) ; } return true ; } public boolean isSingleton ( ) { return true ; } } 	1	['64', '2', '2', '28', '127', '1836', '12', '25', '50', '0.883876358', '1188', '1', '2', '0.273809524', '0.096119929', '0', '0', '17.265625', '6', '1.2031', '4']
package org . apache . camel . component . validator . jing ; import java . util . Map ; public class RelaxNGCompactSyntaxComponent extends JingComponent { protected void configureValidator ( JingValidator validator , String uri , String remaining , Map parameters ) throws Exception { validator . setCompactSyntax ( true ) ; super . configureValidator ( validator , uri , remaining , parameters ) ; } } 	0	['2', '5', '0', '2', '5', '1', '0', '2', '1', '2', '15', '0', '0', '0.975', '0.625', '1', '1', '6.5', '1', '0.5', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . processor . TransformProcessor ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "transform" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class TransformType extends ExpressionNode { public TransformType ( ) { } public TransformType ( Expression expression ) { super ( expression ) ; } @ Override public String toString ( ) { return "Transform[ " + getExpression ( ) + "]" ; } @ Override public String getShortName ( ) { return "transform" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { Expression expr = getExpression ( ) . createExpression ( routeContext ) ; Processor childProcessor = routeContext . createProcessor ( this ) ; return new TransformProcessor ( expr , childProcessor ) ; } } 	1	['5', '4', '0', '7', '15', '10', '1', '7', '5', '2', '41', '0', '0', '0.98136646', '0.466666667', '2', '3', '7.2', '1', '0.6', '1']
package org . apache . camel . impl . converter ; import java . lang . reflect . Method ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . TypeConverter ; import org . apache . camel . util . ObjectHelper ; public class InstanceMethodTypeConverter implements TypeConverter { private final CachingInjector injector ; private final Method method ; public InstanceMethodTypeConverter ( CachingInjector injector , Method method ) { this . injector = injector ; this . method = method ; } @ Override public String toString ( ) { return "InstanceMethodTypeConverter: " + method ; } public < T > T convertTo ( Class < T > type , Object value ) { Object instance = injector . newInstance ( ) ; if ( instance == null ) { throw new RuntimeCamelException ( "Could not instantiate an instance of: " + type . getName ( ) ) ; } return ( T ) ObjectHelper . invokeMethod ( method , instance , value ) ; } } 	0	['3', '1', '0', '5', '12', '0', '1', '4', '3', '0.25', '54', '1', '1', '0', '0.466666667', '0', '0', '16.33333333', '2', '1', '0']
package org . apache . camel . converter ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . nio . ByteBuffer ; import org . apache . camel . Converter ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; @ Converter public final class NIOConverter { private static final transient Log LOG = LogFactory . getLog ( NIOConverter . class ) ; private NIOConverter ( ) { } @ Converter public static byte [ ] toByteArray ( ByteBuffer buffer ) { return buffer . array ( ) ; } @ Converter public static String toString ( ByteBuffer buffer ) { return IOConverter . toString ( buffer . array ( ) ) ; } @ Converter public static ByteBuffer toByteBuffer ( byte [ ] data ) { return ByteBuffer . wrap ( data ) ; } @ Converter public static ByteBuffer toByteBuffer ( File file ) throws IOException { InputStream in = null ; try { byte [ ] buf = new byte [ ( int ) file . length ( ) ] ; in = new BufferedInputStream ( new FileInputStream ( file ) ) ; int sizeLeft = ( int ) file . length ( ) ; int offset = 0 ; while ( sizeLeft > 0 ) { int readSize = in . read ( buf , offset , sizeLeft ) ; sizeLeft -= readSize ; offset += readSize ; } return ByteBuffer . wrap ( buf ) ; } finally { try { if ( in != null ) { in . close ( ) ; } } catch ( IOException e ) { LOG . warn ( "Failed to close file stream: " + file . getPath ( ) , e ) ; } } } @ Converter public static ByteBuffer toByteBuffer ( String value ) { ByteBuffer buf = ByteBuffer . allocate ( value . length ( ) ) ; byte [ ] bytes = value . getBytes ( ) ; buf . put ( bytes ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Short value ) { ByteBuffer buf = ByteBuffer . allocate ( 2 ) ; buf . putShort ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Integer value ) { ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Long value ) { ByteBuffer buf = ByteBuffer . allocate ( 8 ) ; buf . putLong ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Float value ) { ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putFloat ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Double value ) { ByteBuffer buf = ByteBuffer . allocate ( 8 ) ; buf . putDouble ( value ) ; return buf ; } @ Converter public static InputStream toInputStream ( ByteBuffer bufferbuffer ) { return IOConverter . toInputStream ( toByteArray ( bufferbuffer ) ) ; } } 	1	['13', '1', '0', '6', '43', '76', '3', '3', '11', '0.916666667', '180', '1', '0', '0', '0.1', '0', '0', '12.76923077', '1', '0.8462', '2']
package org . apache . camel . component . jpa ; import java . lang . reflect . Method ; import java . util . List ; import javax . persistence . EntityManager ; import javax . persistence . LockModeType ; import javax . persistence . PersistenceException ; import javax . persistence . Query ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . ScheduledPollConsumer ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . orm . jpa . JpaCallback ; public class JpaConsumer extends ScheduledPollConsumer < Exchange > { private static final transient Log LOG = LogFactory . getLog ( JpaConsumer . class ) ; private final JpaEndpoint endpoint ; private final TransactionStrategy template ; private QueryFactory queryFactory ; private DeleteHandler < Object > deleteHandler ; private String query ; private String namedQuery ; private String nativeQuery ; public JpaConsumer ( JpaEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; this . template = endpoint . createTransactionStrategy ( ) ; } protected void poll ( ) throws Exception { template . execute ( new JpaCallback ( ) { public Object doInJpa ( EntityManager entityManager ) throws PersistenceException { Query query = getQueryFactory ( ) . createQuery ( entityManager ) ; configureParameters ( query ) ; List results = query . getResultList ( ) ; for ( Object result : results ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Processing new entity: " + result ) ; } if ( lockEntity ( result , entityManager ) ) { Exchange exchange = createExchange ( result ) ; try { getProcessor ( ) . process ( exchange ) ; } catch ( Exception e ) { throw new PersistenceException ( e ) ; } getDeleteHandler ( ) . deleteObject ( entityManager , result ) ; } } entityManager . flush ( ) ; return null ; } } ) ; } public JpaEndpoint getEndpoint ( ) { return endpoint ; } public QueryFactory getQueryFactory ( ) { if ( queryFactory == null ) { queryFactory = createQueryFactory ( ) ; if ( queryFactory == null ) { throw new IllegalArgumentException ( "No queryType property configured on this consumer, nor an entityType configured on the endpoint so cannot consume" ) ; } } return queryFactory ; } public void setQueryFactory ( QueryFactory queryFactory ) { this . queryFactory = queryFactory ; } public DeleteHandler getDeleteHandler ( ) { if ( deleteHandler == null ) { deleteHandler = createDeleteHandler ( ) ; } return deleteHandler ; } public void setDeleteHandler ( DeleteHandler deleteHandler ) { this . deleteHandler = deleteHandler ; } public String getNamedQuery ( ) { return namedQuery ; } public void setNamedQuery ( String namedQuery ) { this . namedQuery = namedQuery ; } public String getNativeQuery ( ) { return nativeQuery ; } public void setNativeQuery ( String nativeQuery ) { this . nativeQuery = nativeQuery ; } public String getQuery ( ) { return query ; } public void setQuery ( String query ) { this . query = query ; } protected boolean lockEntity ( Object entity , EntityManager entityManager ) { if ( ! getEndpoint ( ) . isConsumeDelete ( ) || ! getEndpoint ( ) . isConsumeLockEntity ( ) ) { return true ; } try { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Acquiring exclusive lock on entity: " + entity ) ; } entityManager . lock ( entity , LockModeType . WRITE ) ; return true ; } catch ( Exception e ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Failed to achieve lock on entity: " + entity + ". Reason: " + e , e ) ; } return false ; } } protected QueryFactory createQueryFactory ( ) { if ( query != null ) { return QueryBuilder . query ( query ) ; } else if ( namedQuery != null ) { return QueryBuilder . namedQuery ( namedQuery ) ; } else if ( nativeQuery != null ) { return QueryBuilder . nativeQuery ( nativeQuery ) ; } else { Class < ? > entityType = endpoint . getEntityType ( ) ; if ( entityType == null ) { return null ; } else { return QueryBuilder . query ( "select x from " + entityType . getName ( ) + " x" ) ; } } } protected DeleteHandler < Object > createDeleteHandler ( ) { Class < ? > entityType = getEndpoint ( ) . getEntityType ( ) ; if ( entityType != null ) { List < Method > methods = ObjectHelper . findMethodsWithAnnotation ( entityType , Consumed . class ) ; if ( methods . size ( ) > 1 ) { throw new IllegalArgumentException ( "Only one method can be annotated with the @Consumed annotation but found: " + methods ) ; } else if ( methods . size ( ) == 1 ) { final Method method = methods . get ( 0 ) ; return new DeleteHandler < Object > ( ) { public void deleteObject ( EntityManager entityManager , Object entityBean ) { ObjectHelper . invokeMethod ( method , entityBean ) ; } } ; } } if ( getEndpoint ( ) . isConsumeDelete ( ) ) { return new DeleteHandler < Object > ( ) { public void deleteObject ( EntityManager entityManager , Object entityBean ) { entityManager . remove ( entityBean ) ; } } ; } else { return new DeleteHandler < Object > ( ) { public void deleteObject ( EntityManager entityManager , Object entityBean ) { } } ; } } protected void configureParameters ( Query query ) { int maxResults = endpoint . getMaximumResults ( ) ; if ( maxResults > 0 ) { query . setMaxResults ( maxResults ) ; } } protected Exchange createExchange ( Object result ) { Exchange exchange = endpoint . createExchange ( ) ; exchange . getIn ( ) . setBody ( result ) ; return exchange ; } } 	0	['21', '4', '0', '19', '52', '160', '5', '19', '13', '0.8625', '287', '1', '4', '0.641509434', '0.166666667', '1', '2', '12.28571429', '5', '1.6667', '0']
package org . apache . camel . builder . xml ; import java . util . HashMap ; import java . util . Map ; import org . w3c . dom . Attr ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . apache . camel . model . language . XPathExpression ; import org . apache . camel . model . language . XQueryExpression ; import org . apache . camel . spi . NamespaceAware ; import org . apache . camel . util . ObjectHelper ; public class Namespaces { public static final String DEFAULT_NAMESPACE = "http://activemq.apache.org/camel/schema/spring" ; public static final String IN_NAMESPACE = "http://camel.apache.org/xml/in/" ; public static final String OUT_NAMESPACE = "http://camel.apache.org/xml/out/" ; public static final String SYSTEM_PROPERTIES_NAMESPACE = "http://camel.apache.org/xml/variables/system-properties" ; public static final String ENVIRONMENT_VARIABLES = "http://camel.apache.org/xml/variables/environment-variables" ; public static final String EXCHANGE_PROPERTY = "http://camel.apache.org/xml/variables/exchange-property" ; private Map < String , String > namespaces = new HashMap < String , String > ( ) ; public Namespaces ( Element element ) { add ( element ) ; } public Namespaces ( String prefix , String uri ) { add ( prefix , uri ) ; } public static boolean isMatchingNamespaceOrEmptyNamespace ( String namespaceURI , String expectedNamespace ) { return ObjectHelper . isNullOrBlank ( namespaceURI ) || namespaceURI . equals ( expectedNamespace ) ; } public Namespaces add ( String prefix , String uri ) { namespaces . put ( prefix , uri ) ; return this ; } public Namespaces add ( Element element ) { Node parentNode = element . getParentNode ( ) ; if ( parentNode instanceof org . w3c . dom . Element ) { add ( ( Element ) parentNode ) ; } NamedNodeMap attributes = element . getAttributes ( ) ; int size = attributes . getLength ( ) ; for ( int i = 0 ; i < size ; i ++ ) { Attr node = ( Attr ) attributes . item ( i ) ; String name = node . getName ( ) ; if ( name . startsWith ( "xmlns:" ) ) { String prefix = name . substring ( "xmlns:" . length ( ) ) ; String uri = node . getValue ( ) ; add ( prefix , uri ) ; } } return this ; } public XPathExpression xpath ( String expression ) { XPathExpression answer = new XPathExpression ( expression ) ; configure ( answer ) ; return answer ; } public XPathExpression xpath ( String expression , Class < ? > resultType ) { XPathExpression answer = xpath ( expression ) ; answer . setResultType ( resultType ) ; return answer ; } public XQueryExpression xquery ( String expression ) { XQueryExpression answer = new XQueryExpression ( expression ) ; configure ( answer ) ; return answer ; } public XQueryExpression xquery ( String expression , Class < ? > resultType ) { XQueryExpression answer = new XQueryExpression ( expression ) ; answer . setResultType ( resultType ) ; configure ( answer ) ; return answer ; } public Map < String , String > getNamespaces ( ) { return namespaces ; } public void configure ( NamespaceAware namespaceAware ) { namespaceAware . setNamespaces ( getNamespaces ( ) ) ; } } 	1	['11', '1', '0', '8', '30', '43', '4', '4', '11', '1.014285714', '163', '0.142857143', '0', '0', '0.4', '0', '0', '13.18181818', '4', '1.2727', '1']
package org . apache . camel . management ; import java . io . IOException ; import org . apache . camel . Service ; import org . apache . camel . impl . ServiceSupport ; import org . springframework . jmx . export . annotation . ManagedAttribute ; import org . springframework . jmx . export . annotation . ManagedOperation ; import org . springframework . jmx . export . annotation . ManagedResource ; @ ManagedResource ( description = "Managed Service" , currencyTimeLimit = 15 ) public class ManagedService { private ServiceSupport service ; public ManagedService ( ServiceSupport service ) { this . service = service ; } public Service getService ( ) { return service ; } @ ManagedAttribute ( description = "Service running state" ) public boolean isStarted ( ) throws IOException { return service . isStarted ( ) ; } @ ManagedOperation ( description = "Start Service" ) public void start ( ) throws IOException { try { service . start ( ) ; } catch ( Exception e ) { throw new IOException ( e . getMessage ( ) ) ; } } @ ManagedOperation ( description = "Stop Service" ) public void stop ( ) throws IOException { try { service . stop ( ) ; } catch ( Exception e ) { throw new IOException ( e . getMessage ( ) ) ; } } } 	0	['5', '1', '0', '4', '11', '0', '2', '2', '5', '0', '43', '1', '1', '0', '0.6', '0', '0', '7.4', '1', '0.8', '0']
package org . apache . camel . language . bean ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . builder . PredicateBuilder ; import org . apache . camel . spi . Language ; import org . apache . camel . util . ObjectHelper ; public class BeanLanguage implements Language { public Predicate < Exchange > createPredicate ( String expression ) { return PredicateBuilder . toPredicate ( createExpression ( expression ) ) ; } public Expression < Exchange > createExpression ( String expression ) { ObjectHelper . notNull ( expression , "expression" ) ; int idx = expression . lastIndexOf ( '.' ) ; String beanName = expression ; String method = null ; if ( idx > 0 ) { beanName = expression . substring ( 0 , idx ) ; method = expression . substring ( idx + 1 ) ; } return new BeanExpression ( beanName , method ) ; } } 	1	['3', '1', '0', '6', '10', '3', '0', '6', '3', '2', '41', '0', '0', '0', '0.833333333', '0', '0', '12.66666667', '2', '1', '1']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "simple" ) public class SimpleExpression extends ExpressionType { public SimpleExpression ( ) { } public SimpleExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "simple" ; } } 	0	['3', '2', '0', '1', '5', '3', '0', '1', '3', '2', '12', '0', '0', '0.956521739', '0.666666667', '1', '2', '3', '1', '0.3333', '0']
package org . apache . camel . processor ; import org . apache . camel . Endpoint ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . processor . aggregate . AggregationCollection ; import org . apache . camel . processor . aggregate . AggregationStrategy ; import org . apache . camel . processor . aggregate . PredicateAggregationCollection ; public class Aggregator extends BatchProcessor { private Predicate aggregationCompletedPredicate ; public Aggregator ( Endpoint endpoint , Processor processor , Expression correlationExpression , AggregationStrategy aggregationStrategy ) { this ( endpoint , processor , new AggregationCollection ( correlationExpression , aggregationStrategy ) ) ; } public Aggregator ( Endpoint endpoint , Processor processor , Expression correlationExpression , AggregationStrategy aggregationStrategy , Predicate aggregationCompletedPredicate ) { this ( endpoint , processor , new PredicateAggregationCollection ( correlationExpression , aggregationStrategy , aggregationCompletedPredicate ) ) ; this . aggregationCompletedPredicate = aggregationCompletedPredicate ; } public Aggregator ( Endpoint endpoint , Processor processor , AggregationCollection collection ) { super ( endpoint , processor , collection ) ; } @ Override public String toString ( ) { return "Aggregator[to: " + getProcessor ( ) + "]" ; } @ Override protected boolean isBatchCompleted ( int index ) { if ( aggregationCompletedPredicate != null ) { if ( getCollection ( ) . size ( ) > 0 ) { return true ; } } return super . isBatchCompleted ( index ) ; } } 	1	['5', '3', '0', '10', '16', '8', '2', '8', '4', '0.75', '61', '1', '1', '0.9375', '0.45', '1', '1', '11', '3', '0.8', '2']
package org . apache . camel . component . rmi ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . rmi . Remote ; import java . rmi . registry . Registry ; import java . rmi . server . UnicastRemoteObject ; import org . apache . camel . Processor ; import org . apache . camel . component . bean . BeanExchange ; import org . apache . camel . component . bean . BeanInvocation ; import org . apache . camel . impl . DefaultConsumer ; public class RmiConsumer extends DefaultConsumer < BeanExchange > implements InvocationHandler { private final RmiEndpoint endpoint ; private Remote stub ; private Remote proxy ; public RmiConsumer ( RmiEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; } @ Override protected void doStart ( ) throws Exception { Class [ ] interfaces = new Class [ endpoint . getRemoteInterfaces ( ) . size ( ) ] ; endpoint . getRemoteInterfaces ( ) . toArray ( interfaces ) ; proxy = ( Remote ) Proxy . newProxyInstance ( endpoint . getClassLoader ( ) , interfaces , this ) ; stub = UnicastRemoteObject . exportObject ( proxy , endpoint . getPort ( ) ) ; try { Registry registry = endpoint . getRegistry ( ) ; String name = endpoint . getName ( ) ; registry . bind ( name , stub ) ; } catch ( Exception e ) { try { UnicastRemoteObject . unexportObject ( stub , true ) ; } catch ( Throwable ignore ) { } stub = null ; throw e ; } super . doStart ( ) ; } @ Override protected void doStop ( ) throws Exception { super . doStop ( ) ; try { Registry registry = endpoint . getRegistry ( ) ; registry . unbind ( endpoint . getName ( ) ) ; } catch ( Throwable e ) { } UnicastRemoteObject . unexportObject ( proxy , true ) ; } public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { if ( ! isStarted ( ) ) { throw new IllegalStateException ( "The endpoint is not active: " + getEndpoint ( ) . getEndpointUri ( ) ) ; } BeanInvocation invocation = new BeanInvocation ( method , args ) ; BeanExchange exchange = getEndpoint ( ) . createExchange ( ) ; exchange . setInvocation ( invocation ) ; getProcessor ( ) . process ( exchange ) ; Throwable fault = exchange . getException ( ) ; if ( fault != null ) { throw new InvocationTargetException ( fault ) ; } return exchange . getOut ( ) . getBody ( ) ; } public Remote getProxy ( ) { return proxy ; } public Remote getStub ( ) { return stub ; } } 	0	['6', '3', '0', '8', '37', '3', '1', '8', '4', '0.666666667', '150', '1', '1', '0.814814815', '0.305555556', '1', '1', '23.5', '1', '0.8333', '0']
package org . apache . camel . processor ; import org . apache . camel . CamelException ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; public class HandleFaultProcessor extends DelegateProcessor { @ Override public void process ( Exchange exchange ) throws Exception { super . process ( exchange ) ; final Message faultMessage = exchange . getFault ( false ) ; if ( faultMessage != null ) { final Object faultBody = faultMessage . getBody ( ) ; if ( faultBody != null ) { if ( faultBody instanceof Throwable ) { exchange . setException ( ( Throwable ) faultBody ) ; } else { exchange . setException ( new CamelException ( "Message contains fault of type " + faultBody . getClass ( ) . getName ( ) + ":\n" + faultBody ) ) ; } } } } } 	1	['2', '3', '0', '5', '14', '1', '1', '4', '2', '2', '47', '0', '0', '0.954545455', '0.75', '0', '0', '22.5', '1', '0.5', '3']
package org . apache . camel . spring . spi ; import org . apache . camel . Processor ; import org . apache . camel . spi . Policy ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . transaction . PlatformTransactionManager ; import org . springframework . transaction . support . TransactionTemplate ; public class SpringTransactionPolicy < E > implements Policy < E > { private static final transient Log LOG = LogFactory . getLog ( SpringTransactionPolicy . class ) ; private TransactionTemplate template ; private String propagationBehaviorName ; private PlatformTransactionManager transactionManager ; public SpringTransactionPolicy ( ) { } public SpringTransactionPolicy ( TransactionTemplate template ) { this . template = template ; } public Processor wrap ( Processor processor ) { final TransactionTemplate transactionTemplate = getTemplate ( ) ; if ( transactionTemplate == null ) { LOG . warn ( "No TransactionTemplate available so transactions will not be enabled!" ) ; return processor ; } TransactionInterceptor answer = new TransactionInterceptor ( transactionTemplate ) ; answer . setProcessor ( processor ) ; return answer ; } public TransactionTemplate getTemplate ( ) { if ( template == null ) { template = new TransactionTemplate ( transactionManager ) ; if ( propagationBehaviorName != null ) { template . setPropagationBehaviorName ( propagationBehaviorName ) ; } } return template ; } public void setTemplate ( TransactionTemplate template ) { this . template = template ; } public void setTransactionManager ( PlatformTransactionManager transactionManager ) { this . transactionManager = transactionManager ; } public PlatformTransactionManager getTransactionManager ( ) { return transactionManager ; } public void setPropagationBehaviorName ( String propagationBehaviorName ) { this . propagationBehaviorName = propagationBehaviorName ; } public String getPropagationBehaviorName ( ) { return propagationBehaviorName ; } } 	0	['10', '1', '0', '8', '17', '25', '1', '7', '9', '0.722222222', '86', '1', '0', '0', '0.311111111', '0', '0', '7.2', '3', '1', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Processor ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "proceed" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ProceedType extends OutputType < ProcessorType > { @ Override public String getShortName ( ) { return "proceed" ; } public Processor createProcessor ( RouteContext routeContext ) throws Exception { return createOutputsProcessor ( routeContext ) ; } } 	1	['3', '4', '0', '6', '5', '3', '3', '3', '3', '2', '12', '0', '0', '0.987096774', '0.666666667', '1', '2', '3', '1', '0.6667', '1']
package org . apache . camel . spring ; import org . apache . camel . Endpoint ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . component . bean . BeanProcessor ; import org . apache . camel . component . event . EventComponent ; import org . apache . camel . component . event . EventEndpoint ; import org . apache . camel . impl . DefaultCamelContext ; import org . apache . camel . impl . ProcessorEndpoint ; import org . apache . camel . spi . Injector ; import org . apache . camel . spi . Registry ; import org . apache . camel . spring . spi . ApplicationContextRegistry ; import org . apache . camel . spring . spi . SpringInjector ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . DisposableBean ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . context . ApplicationEvent ; import org . springframework . context . ApplicationListener ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . context . event . ContextRefreshedEvent ; import org . springframework . context . support . ClassPathXmlApplicationContext ; public class SpringCamelContext extends DefaultCamelContext implements InitializingBean , DisposableBean , ApplicationContextAware , ApplicationListener { private static final transient Log LOG = LogFactory . getLog ( SpringCamelContext . class ) ; private ApplicationContext applicationContext ; private EventEndpoint eventEndpoint ; public SpringCamelContext ( ) { } public SpringCamelContext ( ApplicationContext applicationContext ) { setApplicationContext ( applicationContext ) ; } public static SpringCamelContext springCamelContext ( ApplicationContext applicationContext ) throws Exception { String [ ] names = applicationContext . getBeanNamesForType ( SpringCamelContext . class ) ; if ( names . length == 1 ) { return ( SpringCamelContext ) applicationContext . getBean ( names [ 0 ] , SpringCamelContext . class ) ; } SpringCamelContext answer = new SpringCamelContext ( ) ; answer . setApplicationContext ( applicationContext ) ; answer . afterPropertiesSet ( ) ; return answer ; } public static SpringCamelContext springCamelContext ( String configLocations ) throws Exception { return springCamelContext ( new ClassPathXmlApplicationContext ( configLocations ) ) ; } public void afterPropertiesSet ( ) throws Exception { start ( ) ; } public void destroy ( ) throws Exception { stop ( ) ; } public void onApplicationEvent ( ApplicationEvent event ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Publishing event: " + event ) ; } if ( event instanceof ContextRefreshedEvent ) { try { LOG . debug ( "Starting the CamelContext now that the ApplicationContext has started" ) ; start ( ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } if ( eventEndpoint != null ) { eventEndpoint . onApplicationEvent ( event ) ; } } else { if ( eventEndpoint != null ) { eventEndpoint . onApplicationEvent ( event ) ; } else { LOG . warn ( "No eventEndpoint enabled for event: " + event ) ; } } } public ApplicationContext getApplicationContext ( ) { return applicationContext ; } public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { this . applicationContext = applicationContext ; if ( applicationContext instanceof ConfigurableApplicationContext ) { addComponent ( "event" , new EventComponent ( applicationContext ) ) ; } } public EventEndpoint getEventEndpoint ( ) { return eventEndpoint ; } public void setEventEndpoint ( EventEndpoint eventEndpoint ) { this . eventEndpoint = eventEndpoint ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; if ( eventEndpoint == null ) { eventEndpoint = createEventEndpoint ( ) ; } } @ Override protected Injector createInjector ( ) { if ( applicationContext instanceof ConfigurableApplicationContext ) { return new SpringInjector ( ( ConfigurableApplicationContext ) applicationContext ) ; } else { LOG . warn ( "Cannot use SpringInjector as applicationContext is not a ConfigurableApplicationContext as its: " + applicationContext ) ; return super . createInjector ( ) ; } } protected EventEndpoint createEventEndpoint ( ) { EventEndpoint endpoint = getEndpoint ( "event:default" , EventEndpoint . class ) ; return endpoint ; } protected Endpoint convertBeanToEndpoint ( String uri , Object bean ) { Endpoint endpoint = getTypeConverter ( ) . convertTo ( Endpoint . class , bean ) ; if ( endpoint != null ) { endpoint . setCamelContext ( this ) ; return endpoint ; } Processor processor = new BeanProcessor ( bean , this ) ; return new ProcessorEndpoint ( uri , this , processor ) ; } @ Override protected Registry createRegistry ( ) { return new ApplicationContextRegistry ( getApplicationContext ( ) ) ; } } 	0	['17', '3', '1', '37', '45', '112', '10', '27', '11', '0.770833333', '230', '1', '1', '0.835294118', '0.229166667', '2', '3', '12.35294118', '5', '1.1765', '0']
package org . apache . camel . processor . aggregate ; import org . apache . camel . Exchange ; public class UseLatestAggregationStrategy implements AggregationStrategy { public Exchange aggregate ( Exchange oldExchange , Exchange newExchange ) { return newExchange ; } } 	1	['2', '1', '0', '6', '3', '1', '4', '2', '2', '2', '7', '0', '0', '0', '0.75', '0', '0', '2.5', '1', '0.5', '1']
package org . apache . camel . component . spring . integration . adapter ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . ProducerTemplate ; import org . apache . camel . component . spring . integration . SpringIntegrationBinding ; import org . apache . camel . component . spring . integration . SpringIntegrationExchange ; import org . apache . camel . impl . DefaultCamelContext ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . integration . message . Message ; public class CamelTargetAdapter extends AbstractCamelAdapter { private final Log logger = LogFactory . getLog ( this . getClass ( ) ) ; private ProducerTemplate < Exchange > camelTemplate ; private Endpoint camelEndpoint ; public ProducerTemplate < Exchange > getCamelTemplate ( ) { if ( camelTemplate == null ) { CamelContext ctx = getCamelContext ( ) ; if ( ctx == null ) { ctx = new DefaultCamelContext ( ) ; } camelTemplate = ctx . createProducerTemplate ( ) ; } return camelTemplate ; } public Message < ? > handle ( Message < ? > request ) { ExchangePattern pattern ; if ( isExpectReply ( ) ) { pattern = ExchangePattern . InOut ; } else { pattern = ExchangePattern . InOnly ; } Exchange inExchange = new SpringIntegrationExchange ( getCamelContext ( ) , pattern ) ; SpringIntegrationBinding . storeToCamelMessage ( request , inExchange . getIn ( ) ) ; Exchange outExchange = getCamelTemplate ( ) . send ( getCamelEndpointUri ( ) , inExchange ) ; Message response = null ; if ( isExpectReply ( ) ) { response = SpringIntegrationBinding . storeToSpringIntegrationMessage ( outExchange . getOut ( ) ) ; } return response ; } } 	0	['3', '2', '0', '13', '17', '3', '0', '13', '3', '1', '70', '1', '2', '0.75', '0.666666667', '0', '0', '21.33333333', '3', '2', '0']
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Message ; import org . apache . camel . Processor ; public final class ProcessorBuilder { private ProcessorBuilder ( ) { } public static Processor setBody ( final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object newBody = expression . evaluate ( exchange ) ; exchange . getIn ( ) . setBody ( newBody ) ; } @ Override public String toString ( ) { return "setBody(" + expression + ")" ; } } ; } public static Processor setOutBody ( final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object newBody = expression . evaluate ( exchange ) ; exchange . getOut ( ) . setBody ( newBody ) ; } @ Override public String toString ( ) { return "setOutBody(" + expression + ")" ; } } ; } public static Processor setFaultBody ( final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object newBody = expression . evaluate ( exchange ) ; exchange . getFault ( ) . setBody ( newBody ) ; } @ Override public String toString ( ) { return "setFaultBody(" + expression + ")" ; } } ; } public static Processor setHeader ( final String name , final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object value = expression . evaluate ( exchange ) ; exchange . getIn ( ) . setHeader ( name , value ) ; } @ Override public String toString ( ) { return "setHeader(" + name + ", " + expression + ")" ; } } ; } public static Processor setOutHeader ( final String name , final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object value = expression . evaluate ( exchange ) ; exchange . getOut ( ) . setHeader ( name , value ) ; } @ Override public String toString ( ) { return "setOutHeader(" + name + ", " + expression + ")" ; } } ; } public static Processor setFaultHeader ( final String name , final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object value = expression . evaluate ( exchange ) ; exchange . getFault ( ) . setHeader ( name , value ) ; } @ Override public String toString ( ) { return "setFaultHeader(" + name + ", " + expression + ")" ; } } ; } public static Processor setProperty ( final String name , final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object value = expression . evaluate ( exchange ) ; exchange . setProperty ( name , value ) ; } @ Override public String toString ( ) { return "setProperty(" + name + ", " + expression + ")" ; } } ; } public static Processor removeHeader ( final String name ) { return new Processor ( ) { public void process ( Exchange exchange ) { exchange . getIn ( ) . removeHeader ( name ) ; } @ Override public String toString ( ) { return "removeHeader(" + name + ")" ; } } ; } public static Processor removeOutHeader ( final String name ) { return new Processor ( ) { public void process ( Exchange exchange ) { Message out = exchange . getOut ( false ) ; if ( out != null ) { out . removeHeader ( name ) ; } } @ Override public String toString ( ) { return "removeOutHeader(" + name + ")" ; } } ; } public static Processor removeFaultHeader ( final String name ) { return new Processor ( ) { public void process ( Exchange exchange ) { exchange . getFault ( ) . removeHeader ( name ) ; } @ Override public String toString ( ) { return "removeFaultHeader(" + name + ")" ; } } ; } public static Processor removeProperty ( final String name ) { return new Processor ( ) { public void process ( Exchange exchange ) { exchange . removeProperty ( name ) ; } @ Override public String toString ( ) { return "removeProperty(" + name + ")" ; } } ; } public static Processor throwException ( final Exception ex ) { return new Processor ( ) { public void process ( Exchange exchange ) throws Exception { throw ex ; } @ Override public String toString ( ) { return "throwException(" + ex . toString ( ) + ")" ; } } ; } } 	1	['13', '1', '0', '16', '26', '78', '2', '14', '12', '2', '80', '0', '0', '0', '0.326923077', '0', '0', '5.153846154', '1', '0.9231', '2']
package org . apache . camel . component . spring . integration . adapter ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . component . spring . integration . SpringIntegrationBinding ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . integration . ConfigurationException ; import org . springframework . integration . bus . MessageBus ; import org . springframework . integration . bus . MessageBusAware ; import org . springframework . integration . channel . MessageChannel ; import org . springframework . integration . gateway . RequestReplyTemplate ; import org . springframework . integration . message . Message ; public class CamelSourceAdapter extends AbstractCamelAdapter implements InitializingBean , MessageBusAware { protected final Object lifecycleMonitor = new Object ( ) ; private final Log logger = LogFactory . getLog ( this . getClass ( ) ) ; private Consumer consumer ; private Endpoint camelEndpoint ; private MessageChannel requestChannel ; private RequestReplyTemplate requestReplyTemplate = new RequestReplyTemplate ( ) ; private volatile boolean initialized ; public void setRequestChannel ( MessageChannel channel ) { requestChannel = channel ; requestReplyTemplate . setRequestChannel ( requestChannel ) ; } public MessageChannel getChannel ( ) { return requestChannel ; } public void setReplyChannel ( MessageChannel channel ) { requestReplyTemplate . setReplyChannel ( channel ) ; } public void setRequestTimeout ( long requestTimeout ) { this . requestReplyTemplate . setRequestTimeout ( requestTimeout ) ; } public void setReplyTimeout ( long replyTimeout ) { this . requestReplyTemplate . setReplyTimeout ( replyTimeout ) ; } private void incoming ( Exchange exchange ) { org . springframework . integration . message . Message request = SpringIntegrationBinding . createSpringIntegrationMessage ( exchange ) ; org . springframework . integration . message . Message response = handle ( request ) ; if ( response != null ) { SpringIntegrationBinding . storeToCamelMessage ( response , exchange . getOut ( ) ) ; } } protected class ConsumerProcessor implements Processor { public void process ( Exchange exchange ) { try { incoming ( exchange ) ; } catch ( Throwable ex ) { ex . printStackTrace ( ) ; logger . warn ( "Failed to process incoming message : " + ex ) ; } } } public final void afterPropertiesSet ( ) throws Exception { synchronized ( this . lifecycleMonitor ) { if ( this . initialized ) { return ; } } this . initialize ( ) ; this . initialized = true ; } protected void initialize ( ) throws Exception { camelEndpoint = getCamelContext ( ) . getEndpoint ( getCamelEndpointUri ( ) ) ; consumer = camelEndpoint . createConsumer ( new ConsumerProcessor ( ) ) ; consumer . start ( ) ; } public final Message < ? > handle ( Message < ? > message ) { if ( ! this . initialized ) { try { this . afterPropertiesSet ( ) ; } catch ( Exception e ) { throw new ConfigurationException ( "unable to initialize " + this . getClass ( ) . getName ( ) , e ) ; } } if ( ! isExpectReply ( ) ) { boolean sent = this . requestReplyTemplate . send ( message ) ; if ( ! sent && logger . isWarnEnabled ( ) ) { logger . warn ( "failed to send message to channel within timeout" ) ; } return null ; } return this . requestReplyTemplate . request ( message ) ; } public void setMessageBus ( MessageBus bus ) { requestReplyTemplate . setMessageBus ( bus ) ; } } 	0	['13', '2', '0', '18', '42', '26', '1', '18', '9', '0.738095238', '183', '1', '2', '0.333333333', '0.230769231', '0', '0', '12.53846154', '5', '1.3077', '0']
package org . apache . camel . builder ; import java . util . Map ; import org . apache . camel . Expression ; import org . apache . camel . builder . xml . Namespaces ; import org . apache . camel . model . ExpressionNode ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . model . language . MethodCallExpression ; import org . apache . camel . model . language . XPathExpression ; import org . apache . camel . model . language . XQueryExpression ; public class ExpressionClause < T > extends ExpressionType { private T result ; private String language ; public ExpressionClause ( T result ) { this . result = result ; } public static < T extends ExpressionNode > ExpressionClause < T > createAndSetExpression ( T result ) { ExpressionClause < T > clause = new ExpressionClause < T > ( result ) ; result . setExpression ( clause ) ; return clause ; } public T expression ( Expression expression ) { setExpressionValue ( expression ) ; return result ; } public T constant ( Object value ) { return expression ( ExpressionBuilder . constantExpression ( value ) ) ; } public T exchange ( ) { return expression ( ExpressionBuilder . exchangeExpression ( ) ) ; } public T inMessage ( ) { return expression ( ExpressionBuilder . inMessageExpression ( ) ) ; } public T outMessage ( ) { return expression ( ExpressionBuilder . outMessageExpression ( ) ) ; } public T body ( ) { return expression ( ExpressionBuilder . bodyExpression ( ) ) ; } public T body ( Class expectedType ) { return expression ( ExpressionBuilder . bodyExpression ( expectedType ) ) ; } public T outBody ( ) { return expression ( ExpressionBuilder . outBodyExpression ( ) ) ; } public T outBody ( Class expectedType ) { return expression ( ExpressionBuilder . outBodyExpression ( expectedType ) ) ; } public T header ( String name ) { return expression ( ExpressionBuilder . headerExpression ( name ) ) ; } public T headers ( ) { return expression ( ExpressionBuilder . headersExpression ( ) ) ; } public T outHeader ( String name ) { return expression ( ExpressionBuilder . outHeaderExpression ( name ) ) ; } public T outHeaders ( ) { return expression ( ExpressionBuilder . outHeadersExpression ( ) ) ; } public T property ( String name ) { return expression ( ExpressionBuilder . propertyExpression ( name ) ) ; } public T properties ( ) { return expression ( ExpressionBuilder . propertiesExpression ( ) ) ; } public T method ( String bean ) { MethodCallExpression expression = new MethodCallExpression ( bean ) ; setExpressionType ( expression ) ; return result ; } public T method ( String bean , String method ) { MethodCallExpression expression = new MethodCallExpression ( bean , method ) ; setExpressionType ( expression ) ; return result ; } public T el ( String text ) { return language ( "el" , text ) ; } public T groovy ( String text ) { return language ( "groovy" , text ) ; } public T javaScript ( String text ) { return language ( "js" , text ) ; } public T jxpath ( String text ) { return language ( "jxpath" , text ) ; } public T ognl ( String text ) { return language ( "ognl" , text ) ; } public T php ( String text ) { return language ( "php" , text ) ; } public T python ( String text ) { return language ( "python" , text ) ; } public T ruby ( String text ) { return language ( "ruby" , text ) ; } public T sql ( String text ) { return language ( "sql" , text ) ; } public T simple ( String text ) { return language ( "simple" , text ) ; } public T xpath ( String text ) { return language ( "xpath" , text ) ; } public T xpath ( String text , Class resultType ) { XPathExpression expression = new XPathExpression ( text ) ; expression . setResultType ( resultType ) ; setExpressionType ( expression ) ; return result ; } public T xpath ( String text , Class resultType , Namespaces namespaces ) { return xpath ( text , resultType , namespaces . getNamespaces ( ) ) ; } public T xpath ( String text , Class resultType , Map < String , String > namespaces ) { XPathExpression expression = new XPathExpression ( text ) ; expression . setResultType ( resultType ) ; expression . setNamespaces ( namespaces ) ; setExpressionType ( expression ) ; return result ; } public T xpath ( String text , Namespaces namespaces ) { return xpath ( text , namespaces . getNamespaces ( ) ) ; } public T xpath ( String text , Map < String , String > namespaces ) { XPathExpression expression = new XPathExpression ( text ) ; expression . setNamespaces ( namespaces ) ; setExpressionType ( expression ) ; return result ; } public T xquery ( String text ) { return language ( "xquery" , text ) ; } public T xquery ( String text , Class resultType ) { XQueryExpression expression = new XQueryExpression ( text ) ; expression . setResultType ( resultType ) ; setExpressionType ( expression ) ; return result ; } public T xquery ( String text , Class resultType , Namespaces namespaces ) { return xquery ( text , resultType , namespaces . getNamespaces ( ) ) ; } public T xquery ( String text , Class resultType , Map < String , String > namespaces ) { XQueryExpression expression = new XQueryExpression ( text ) ; expression . setResultType ( resultType ) ; expression . setNamespaces ( namespaces ) ; setExpressionType ( expression ) ; return result ; } public T xquery ( String text , Namespaces namespaces ) { return xquery ( text , namespaces . getNamespaces ( ) ) ; } public T xquery ( String text , Map < String , String > namespaces ) { XQueryExpression expression = new XQueryExpression ( text ) ; expression . setNamespaces ( namespaces ) ; setExpressionType ( expression ) ; return result ; } public T language ( String language , String expression ) { setLanguage ( language ) ; setExpression ( expression ) ; return result ; } public String getLanguage ( ) { return language ; } public void setLanguage ( String language ) { this . language = language ; } } 	1	['44', '2', '0', '12', '72', '834', '4', '8', '44', '0.5', '345', '1', '0', '0.338461538', '0.261363636', '1', '2', '6.795454545', '1', '0.9773', '3']
package org . apache . camel . spring ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . CamelContext ; import org . apache . camel . CamelContextAware ; import org . apache . camel . Endpoint ; import org . apache . camel . NoSuchEndpointException ; import org . apache . camel . model . IdentifiedType ; import org . springframework . beans . factory . FactoryBean ; import static org . apache . camel . util . ObjectHelper . notNull ; @ XmlRootElement ( name = "endpoint" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class EndpointFactoryBean extends IdentifiedType implements FactoryBean , CamelContextAware { @ XmlAttribute private String uri ; @ XmlTransient private CamelContext context ; @ XmlTransient private Endpoint endpoint ; @ XmlTransient private boolean singleton ; public Object getObject ( ) throws Exception { if ( endpoint == null ) { endpoint = createEndpoint ( ) ; } return endpoint ; } public Class getObjectType ( ) { return Endpoint . class ; } public boolean isSingleton ( ) { return singleton ; } public CamelContext getCamelContext ( ) { return context ; } public void setCamelContext ( CamelContext context ) { this . context = context ; } public Endpoint getEndpoint ( ) { return endpoint ; } public void setEndpoint ( Endpoint endpoint ) { this . endpoint = endpoint ; } public void setSingleton ( boolean singleton ) { this . singleton = singleton ; } public String getUri ( ) { return uri ; } public void setUri ( String uri ) { this . uri = uri ; } protected Endpoint createEndpoint ( ) { notNull ( context , "context" ) ; notNull ( uri , "uri" ) ; Endpoint endpoint = context . getEndpoint ( uri ) ; if ( endpoint == null ) { throw new NoSuchEndpointException ( uri ) ; } return endpoint ; } } 	0	['12', '2', '0', '7', '16', '46', '0', '7', '11', '0.795454545', '83', '1', '2', '0.153846154', '0.266666667', '0', '0', '5.583333333', '2', '1', '0']
package org . apache . camel . processor ; public enum LoggingLevel { DEBUG , ERROR , FATAL , INFO , TRACE , WARN } 	1	['4', '2', '0', '13', '7', '4', '12', '1', '2', '0.952380952', '89', '0.142857143', '7', '0.857142857', '0.444444444', '1', '1', '19.5', '1', '0.5', '1']
package org . apache . camel . util ; import org . apache . camel . converter . ObjectConverter ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public final class SystemHelper { private static final transient Log LOG = LogFactory . getLog ( SystemHelper . class ) ; private SystemHelper ( ) { } public static String getSystemProperty ( String name ) { try { return System . getProperty ( name ) ; } catch ( Exception e ) { LOG . debug ( "Caught exception looking for system property: " + name + " exception: " + e , e ) ; return null ; } } public static boolean isSystemProperty ( String name ) { String text = getSystemProperty ( name ) ; return ObjectConverter . toBool ( text ) ; } } 	0	['4', '1', '0', '4', '13', '4', '1', '3', '2', '0.333333333', '39', '1', '0', '0', '0.5', '0', '0', '8.5', '1', '0.5', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Processor ; import org . apache . camel . processor . CatchProcessor ; import org . apache . camel . processor . TryProcessor ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "try" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class TryType extends OutputType < TryType > { @ XmlTransient private List < CatchType > catchClauses ; @ XmlTransient private FinallyType finallyClause ; @ XmlTransient private boolean initialized ; @ XmlTransient private List < ProcessorType < ? > > outputsWithoutCatches ; @ Override public String toString ( ) { return "Try[ " + getOutputs ( ) + "]" ; } @ Override public String getShortName ( ) { return "try" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { Processor tryProcessor = createOutputsProcessor ( routeContext , getOutputsWithoutCatches ( ) ) ; Processor finallyProcessor = null ; if ( finallyClause != null ) { finallyProcessor = finallyClause . createProcessor ( routeContext ) ; } List < CatchProcessor > catchProcessors = new ArrayList < CatchProcessor > ( ) ; if ( catchClauses != null ) { for ( CatchType catchClause : catchClauses ) { catchProcessors . add ( catchClause . createProcessor ( routeContext ) ) ; } } return new TryProcessor ( tryProcessor , catchProcessors , finallyProcessor ) ; } public TryType handle ( Class < ? > exceptionType ) { popBlock ( ) ; CatchType answer = new CatchType ( exceptionType ) ; addOutput ( answer ) ; pushBlock ( answer ) ; return this ; } @ Deprecated public TryType handleAll ( ) { return finallyBlock ( ) ; } public TryType finallyBlock ( ) { popBlock ( ) ; FinallyType answer = new FinallyType ( ) ; addOutput ( answer ) ; pushBlock ( answer ) ; return this ; } @ Override public ProcessorType < ? extends ProcessorType > end ( ) { popBlock ( ) ; return super . end ( ) ; } public List < CatchType > getCatchClauses ( ) { if ( catchClauses == null ) { checkInitialized ( ) ; } return catchClauses ; } public FinallyType getFinallyClause ( ) { if ( finallyClause == null ) { checkInitialized ( ) ; } return finallyClause ; } public List < ProcessorType < ? > > getOutputsWithoutCatches ( ) { if ( outputsWithoutCatches == null ) { checkInitialized ( ) ; } return outputsWithoutCatches ; } public void setOutputs ( List < ProcessorType < ? > > outputs ) { initialized = false ; super . setOutputs ( outputs ) ; } @ Override public void addOutput ( ProcessorType output ) { initialized = false ; super . addOutput ( output ) ; } protected void checkInitialized ( ) { if ( ! initialized ) { initialized = true ; outputsWithoutCatches = new ArrayList < ProcessorType < ? > > ( ) ; catchClauses = new ArrayList < CatchType > ( ) ; finallyClause = null ; for ( ProcessorType output : outputs ) { if ( output instanceof CatchType ) { catchClauses . add ( ( CatchType ) output ) ; } else if ( output instanceof FinallyType ) { if ( finallyClause != null ) { throw new IllegalArgumentException ( "Multiple finally clauses added: " + finallyClause + " and " + output ) ; } else { finallyClause = ( FinallyType ) output ; } } else { outputsWithoutCatches . add ( output ) ; } } } } } 	1	['14', '4', '0', '9', '37', '73', '1', '9', '13', '0.634615385', '236', '1', '1', '0.921686747', '0.257142857', '1', '15', '15.57142857', '6', '1.5', '1']
package org . apache . camel . language ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import org . apache . camel . component . bean . DefaultAnnotationExpressionFactory ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . ANNOTATION_TYPE } ) public @ interface LanguageAnnotation { String language ( ) ; Class < ? > factory ( ) default DefaultAnnotationExpressionFactory . class ; } 	0	['2', '1', '0', '5', '2', '1', '5', '0', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . impl ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Exchange ; import org . apache . camel . spi . ComponentResolver ; import org . apache . camel . util . FactoryFinder ; import org . apache . camel . util . NoFactoryAvailableException ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DefaultComponentResolver < E extends Exchange > implements ComponentResolver < E > { protected static final FactoryFinder COMPONENT_FACTORY = new FactoryFinder ( "META-INF/services/org/apache/camel/component/" ) ; private static final transient Log LOG = LogFactory . getLog ( DefaultComponentResolver . class ) ; public Component < E > resolveComponent ( String name , CamelContext context ) { Object bean = null ; try { bean = context . getRegistry ( ) . lookup ( name ) ; if ( bean != null && LOG . isDebugEnabled ( ) ) { LOG . debug ( "Found component: " + name + " in registry: " + bean ) ; } } catch ( Exception e ) { LOG . debug ( "Ignored error looking up bean: " + name + ". Error: " + e ) ; } if ( bean != null ) { if ( bean instanceof Component ) { return ( Component ) bean ; } } Class type ; try { type = COMPONENT_FACTORY . findClass ( name ) ; } catch ( NoFactoryAvailableException e ) { return null ; } catch ( Throwable e ) { throw new IllegalArgumentException ( "Invalid URI, no Component registered for scheme : " + name , e ) ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Found component: " + name + " via type: " + type . getName ( ) + " via " + COMPONENT_FACTORY . getPath ( ) + name ) ; } if ( type == null ) { return null ; } if ( Component . class . isAssignableFrom ( type ) ) { return ( Component < E > ) context . getInjector ( ) . newInstance ( type ) ; } else { throw new IllegalArgumentException ( "Type is not a Component implementation. Found: " + type . getName ( ) ) ; } } } 	1	['3', '1', '0', '10', '22', '1', '1', '9', '2', '0.5', '141', '1', '1', '0', '0.666666667', '0', '0', '45.33333333', '6', '2', '1']
package org . apache . camel . component . spring . integration ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . impl . ScheduledPollConsumer ; import org . apache . camel . spring . SpringCamelContext ; import org . apache . camel . util . ObjectHelper ; import org . springframework . integration . channel . ChannelRegistry ; import org . springframework . integration . channel . MessageChannel ; import org . springframework . integration . config . MessageBusParser ; public class SpringIntegrationConsumer extends ScheduledPollConsumer < SpringIntegrationExchange > { private SpringCamelContext context ; private MessageChannel inputChannel ; private MessageChannel outputChannel ; private String inputChannelName ; private ChannelRegistry channelRegistry ; private SpringIntegrationEndpoint endpoint ; public SpringIntegrationConsumer ( SpringIntegrationEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; context = ( SpringCamelContext ) endpoint . getCamelContext ( ) ; if ( context != null && endpoint . getMessageChannel ( ) == null ) { channelRegistry = ( ChannelRegistry ) context . getApplicationContext ( ) . getBean ( MessageBusParser . MESSAGE_BUS_BEAN_NAME ) ; inputChannelName = endpoint . getDefaultChannel ( ) ; if ( ObjectHelper . isNullOrBlank ( inputChannelName ) ) { inputChannelName = endpoint . getInputChannel ( ) ; } if ( ! ObjectHelper . isNullOrBlank ( inputChannelName ) ) { inputChannel = ( MessageChannel ) channelRegistry . lookupChannel ( inputChannelName ) ; ObjectHelper . notNull ( inputChannel , "The inputChannel with the name [" + inputChannelName + "]" ) ; } else { throw new RuntimeCamelException ( "Can't find the right inputChannelName, , please check your configuration." ) ; } } else { if ( endpoint . getMessageChannel ( ) != null ) { inputChannel = endpoint . getMessageChannel ( ) ; } else { throw new RuntimeCamelException ( "Can't find the right message channel, please check your configuration." ) ; } } if ( endpoint . isInOut ( ) ) { endpoint . setExchangePattern ( ExchangePattern . InOut ) ; } } @ Override protected void poll ( ) throws Exception { org . springframework . integration . message . Message siInMessage = inputChannel . receive ( this . getDelay ( ) ) ; SpringIntegrationExchange exchange = getEndpoint ( ) . createExchange ( ) ; exchange . setIn ( new SpringIntegrationMessage ( siInMessage ) ) ; getProcessor ( ) . process ( exchange ) ; if ( endpoint . isInOut ( ) ) { Object returnAddress = siInMessage . getHeader ( ) . getReturnAddress ( ) ; MessageChannel reply = null ; if ( returnAddress != null ) { if ( returnAddress instanceof String ) { reply = ( MessageChannel ) context . getApplicationContext ( ) . getBean ( ( String ) returnAddress ) ; } else if ( returnAddress instanceof MessageChannel ) { reply = ( MessageChannel ) returnAddress ; } } else { if ( outputChannel != null ) { reply = outputChannel ; } else { if ( ObjectHelper . isNullOrBlank ( endpoint . getOutputChannel ( ) ) ) { outputChannel = ( MessageChannel ) channelRegistry . lookupChannel ( endpoint . getOutputChannel ( ) ) ; ObjectHelper . notNull ( inputChannel , "The outputChannel with the name [" + endpoint . getOutputChannel ( ) + "]" ) ; reply = outputChannel ; } else { throw new RuntimeCamelException ( "Can't find the right outputChannelName" ) ; } } } org . springframework . integration . message . Message siOutMessage = SpringIntegrationBinding . storeToSpringIntegrationMessage ( exchange . getOut ( ) ) ; reply . send ( siOutMessage ) ; } } } 	0	['2', '4', '0', '20', '32', '0', '1', '20', '1', '0.333333333', '202', '1', '2', '0.971428571', '0.666666667', '1', '1', '97', '1', '0.5', '0']
package org . apache . camel . util ; import java . io . BufferedInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Properties ; import java . util . concurrent . ConcurrentHashMap ; import org . apache . camel . spi . Injector ; public class FactoryFinder { private final String path ; private final ConcurrentHashMap classMap = new ConcurrentHashMap ( ) ; public FactoryFinder ( ) { this ( "META-INF/services/org/apache/camel/" ) ; } public FactoryFinder ( String path ) { this . path = path ; } public Object newInstance ( String key ) throws IllegalAccessException , InstantiationException , IOException , ClassNotFoundException { return newInstance ( key , ( String ) null ) ; } public Object newInstance ( String key , String propertyPrefix ) throws IllegalAccessException , InstantiationException , IOException , ClassNotFoundException { Class clazz = findClass ( key , propertyPrefix ) ; return clazz . newInstance ( ) ; } public Object newInstance ( String key , Injector injector ) throws IOException , ClassNotFoundException { return newInstance ( key , injector , ( String ) null ) ; } public Object newInstance ( String key , Injector injector , String propertyPrefix ) throws IOException , ClassNotFoundException { Class type = findClass ( key , propertyPrefix ) ; return injector . newInstance ( type ) ; } public < T > T newInstance ( String key , Injector injector , Class < T > expectedType ) throws IOException , ClassNotFoundException { return newInstance ( key , injector , null , expectedType ) ; } public < T > T newInstance ( String key , Injector injector , String propertyPrefix , Class < T > expectedType ) throws IOException , ClassNotFoundException { Class type = findClass ( key , propertyPrefix ) ; Object value = injector . newInstance ( type ) ; if ( expectedType . isInstance ( value ) ) { return expectedType . cast ( value ) ; } else { throw new ClassCastException ( "Not instanceof " + expectedType . getName ( ) + " value: " + value ) ; } } public < T > List < T > newInstances ( String key , Injector injector , Class < T > type ) throws IOException , ClassNotFoundException { List < Class > list = findClasses ( key ) ; List < T > answer = new ArrayList < T > ( list . size ( ) ) ; answer . add ( newInstance ( key , injector , type ) ) ; return answer ; } public Class findClass ( String key ) throws ClassNotFoundException , IOException { return findClass ( key , null ) ; } public Class findClass ( String key , String propertyPrefix ) throws ClassNotFoundException , IOException { if ( propertyPrefix == null ) { propertyPrefix = "" ; } Class clazz = ( Class ) classMap . get ( propertyPrefix + key ) ; if ( clazz == null ) { clazz = newInstance ( doFindFactoryProperties ( key ) , propertyPrefix ) ; classMap . put ( propertyPrefix + key , clazz ) ; } return clazz ; } public List < Class > findClasses ( String key ) throws ClassNotFoundException , IOException { return findClasses ( key , null ) ; } public List < Class > findClasses ( String key , String propertyPrefix ) throws ClassNotFoundException , IOException { Class type = findClass ( key , propertyPrefix ) ; return Collections . singletonList ( type ) ; } public String getPath ( ) { return path ; } private Class newInstance ( Properties properties , String propertyPrefix ) throws ClassNotFoundException , IOException { String className = properties . getProperty ( propertyPrefix + "class" ) ; if ( className == null ) { throw new IOException ( "Expected property is missing: " + propertyPrefix + "class" ) ; } return ObjectHelper . loadClass ( className ) ; } private Properties doFindFactoryProperties ( String key ) throws IOException { String uri = path + key ; InputStream in = ObjectHelper . loadResourceAsStream ( uri ) ; if ( in == null ) { throw new NoFactoryAvailableException ( uri ) ; } BufferedInputStream reader = null ; try { reader = new BufferedInputStream ( in ) ; Properties properties = new Properties ( ) ; properties . load ( reader ) ; return properties ; } finally { ObjectHelper . close ( reader , key , null ) ; ObjectHelper . close ( in , key , null ) ; } } } 	1	['16', '1', '0', '9', '43', '112', '5', '4', '14', '0.6', '273', '1', '0', '0', '0.4875', '0', '0', '15.9375', '1', '0.875', '1']
package org . apache . camel . component . cxf . transport ; public final class CamelConstants { public static final String TEXT_MESSAGE_TYPE = "text" ; public static final String BINARY_MESSAGE_TYPE = "binary" ; public static final String CAMEL_TARGET_ENDPOINT_URI = "org.apache.cxf.camel.target.endpoint.uri" ; public static final String CAMEL_SERVER_REQUEST_HEADERS = "org.apache.cxf.camel.server.request.headers" ; public static final String CAMEL_SERVER_RESPONSE_HEADERS = "org.apache.cxf.camel.server.response.headers" ; public static final String CAMEL_REQUEST_MESSAGE = "org.apache.cxf.camel.request.message" ; public static final String CAMEL_RESPONSE_MESSAGE = "org.apache.cxf.camel.reponse.message" ; public static final String CAMEL_CLIENT_REQUEST_HEADERS = "org.apache.cxf.camel.template.request.headers" ; public static final String CAMEL_CLIENT_RESPONSE_HEADERS = "org.apache.cxf.camel.template.response.headers" ; public static final String CAMEL_CLIENT_RECEIVE_TIMEOUT = "org.apache.cxf.camel.template.timeout" ; public static final String CAMEL_SERVER_CONFIGURATION_URI = "http://cxf.apache.org/configuration/transport/camel-server" ; public static final String CAMEL_CLIENT_CONFIGURATION_URI = "http://cxf.apache.org/configuration/transport/camel-template" ; public static final String ENDPOINT_CONFIGURATION_URI = "http://cxf.apache.org/jaxws/endpoint-config" ; public static final String SERVICE_CONFIGURATION_URI = "http://cxf.apache.org/jaxws/service-config" ; public static final String PORT_CONFIGURATION_URI = "http://cxf.apache.org/jaxws/port-config" ; public static final String CAMEL_CLIENT_CONFIG_ID = "camel-template" ; public static final String CAMEL_SERVER_CONFIG_ID = "camel-server" ; public static final String CAMEL_REBASED_REPLY_TO = "org.apache.cxf.camel.server.replyto" ; public static final String CAMEL_CORRELATION_ID = "org.apache.cxf.camel.correlationId" ; private CamelConstants ( ) { } } 	0	['1', '1', '0', '0', '2', '0', '0', '0', '0', '2', '23', '0', '0', '0', '1', '0', '0', '3', '0', '0', '0']
package org . apache . camel . processor ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . spi . Policy ; import org . apache . camel . util . AsyncProcessorHelper ; import org . apache . camel . util . ServiceHelper ; public class DelegateAsyncProcessor extends ServiceSupport implements AsyncProcessor { protected AsyncProcessor processor ; public DelegateAsyncProcessor ( ) { } public DelegateAsyncProcessor ( AsyncProcessor processor ) { this . processor = processor ; } @ Override public String toString ( ) { return "Delegate(" + processor + ")" ; } public AsyncProcessor getProcessor ( ) { return processor ; } public void setProcessor ( AsyncProcessor processor ) { this . processor = processor ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( processor ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( processor ) ; } public boolean process ( final Exchange exchange , final AsyncCallback callback ) { return processor . process ( exchange , callback ) ; } public void process ( Exchange exchange ) throws Exception { AsyncProcessorHelper . process ( this , exchange ) ; } } 	1	['9', '2', '1', '7', '18', '0', '1', '6', '7', '0.25', '66', '1', '1', '0.65', '0.388888889', '1', '1', '6.222222222', '1', '0.7778', '1']
package org . apache . camel . component . file ; import java . io . File ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; public class FileExchange extends DefaultExchange { private File file ; public FileExchange ( CamelContext camelContext , ExchangePattern pattern , File file ) { super ( camelContext , pattern ) ; setIn ( new FileMessage ( file ) ) ; this . file = file ; } public FileExchange ( DefaultExchange parent , File file ) { super ( parent ) ; this . file = file ; } public File getFile ( ) { return this . file ; } public void setFile ( File file ) { this . file = file ; } public Exchange newInstance ( ) { return new FileExchange ( this , getFile ( ) ) ; } } 	0	['5', '2', '0', '14', '9', '0', '9', '6', '5', '0', '41', '1', '0', '0.926829268', '0.44', '1', '1', '7', '1', '0.6', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . HashSet ; import java . util . LinkedList ; import java . util . List ; import java . util . Set ; import java . util . concurrent . ThreadPoolExecutor ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . CamelContext ; import org . apache . camel . CamelException ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . builder . DataFormatClause ; import org . apache . camel . builder . DeadLetterChannelBuilder ; import org . apache . camel . builder . ErrorHandlerBuilder ; import org . apache . camel . builder . ErrorHandlerBuilderRef ; import org . apache . camel . builder . ExpressionClause ; import org . apache . camel . builder . NoErrorHandlerBuilder ; import org . apache . camel . builder . ProcessorBuilder ; import org . apache . camel . impl . DefaultCamelContext ; import org . apache . camel . model . dataformat . DataFormatType ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . model . language . LanguageExpression ; import org . apache . camel . processor . ConvertBodyProcessor ; import org . apache . camel . processor . DelegateProcessor ; import org . apache . camel . processor . Pipeline ; import org . apache . camel . processor . aggregate . AggregationCollection ; import org . apache . camel . processor . aggregate . AggregationStrategy ; import org . apache . camel . processor . idempotent . MessageIdRepository ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . spi . ErrorHandlerWrappingStrategy ; import org . apache . camel . spi . InterceptStrategy ; import org . apache . camel . spi . Policy ; import org . apache . camel . spi . RouteContext ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; @ XmlAccessorType ( XmlAccessType . PROPERTY ) public abstract class ProcessorType < Type extends ProcessorType > extends OptionalIdentifiedType < Type > implements Block { public static final String DEFAULT_TRACE_CATEGORY = "org.apache.camel.TRACE" ; private static final transient Log LOG = LogFactory . getLog ( ProcessorType . class ) ; private ErrorHandlerBuilder errorHandlerBuilder ; private Boolean inheritErrorHandlerFlag ; private NodeFactory nodeFactory ; private LinkedList < Block > blocks = new LinkedList < Block > ( ) ; private ProcessorType < ? extends ProcessorType > parent ; private List < InterceptorType > interceptors = new ArrayList < InterceptorType > ( ) ; private String errorHandlerRef ; public abstract List < ProcessorType < ? > > getOutputs ( ) ; public Processor createProcessor ( RouteContext routeContext ) throws Exception { throw new UnsupportedOperationException ( "Not implemented yet for class: " + getClass ( ) . getName ( ) ) ; } public Processor createOutputsProcessor ( RouteContext routeContext ) throws Exception { Collection < ProcessorType < ? > > outputs = getOutputs ( ) ; return createOutputsProcessor ( routeContext , outputs ) ; } public void addRoutes ( RouteContext routeContext , Collection < Route > routes ) throws Exception { Processor processor = makeProcessor ( routeContext ) ; if ( ! routeContext . isRouteAdded ( ) ) { routeContext . addEventDrivenProcessor ( processor ) ; } } public Processor wrapProcessor ( RouteContext routeContext , Processor processor ) throws Exception { processor = wrapProcessorInInterceptors ( routeContext , processor ) ; return wrapInErrorHandler ( routeContext , processor ) ; } public Type to ( String uri ) { addOutput ( new ToType ( uri ) ) ; return ( Type ) this ; } public Type to ( Endpoint endpoint ) { addOutput ( new ToType ( endpoint ) ) ; return ( Type ) this ; } public Type to ( String ... uris ) { for ( String uri : uris ) { addOutput ( new ToType ( uri ) ) ; } return ( Type ) this ; } public Type to ( Endpoint ... endpoints ) { for ( Endpoint endpoint : endpoints ) { addOutput ( new ToType ( endpoint ) ) ; } return ( Type ) this ; } public Type to ( Collection < Endpoint > endpoints ) { for ( Endpoint endpoint : endpoints ) { addOutput ( new ToType ( endpoint ) ) ; } return ( Type ) this ; } public MulticastType multicast ( ) { MulticastType answer = new MulticastType ( ) ; addOutput ( answer ) ; return answer ; } public MulticastType multicast ( AggregationStrategy aggregationStrategy , boolean parallelProcessing ) { MulticastType answer = new MulticastType ( ) ; addOutput ( answer ) ; answer . setAggregationStrategy ( aggregationStrategy ) ; answer . setParallelProcessing ( parallelProcessing ) ; return answer ; } public MulticastType multicast ( AggregationStrategy aggregationStrategy ) { MulticastType answer = new MulticastType ( ) ; addOutput ( answer ) ; answer . setAggregationStrategy ( aggregationStrategy ) ; return answer ; } public Type pipeline ( String ... uris ) { return to ( uris ) ; } public Type pipeline ( Endpoint ... endpoints ) { return to ( endpoints ) ; } public Type pipeline ( Collection < Endpoint > endpoints ) { return to ( endpoints ) ; } public ProcessorType < ? extends ProcessorType > end ( ) { if ( blocks . isEmpty ( ) ) { if ( parent == null ) { throw new IllegalArgumentException ( "Root node with no active block" ) ; } return parent ; } popBlock ( ) ; return this ; } public ThreadType thread ( int coreSize ) { ThreadType answer = new ThreadType ( coreSize ) ; addOutput ( answer ) ; return answer ; } public ProcessorType < Type > thread ( ThreadPoolExecutor executor ) { ThreadType answer = new ThreadType ( executor ) ; addOutput ( answer ) ; return this ; } public IdempotentConsumerType idempotentConsumer ( Expression messageIdExpression , MessageIdRepository messageIdRepository ) { IdempotentConsumerType answer = new IdempotentConsumerType ( messageIdExpression , messageIdRepository ) ; addOutput ( answer ) ; return answer ; } public ExpressionClause < IdempotentConsumerType > idempotentConsumer ( MessageIdRepository messageIdRepository ) { IdempotentConsumerType answer = new IdempotentConsumerType ( ) ; answer . setMessageIdRepository ( messageIdRepository ) ; addOutput ( answer ) ; return ExpressionClause . createAndSetExpression ( answer ) ; } public ExpressionClause < FilterType > filter ( ) { FilterType filter = new FilterType ( ) ; addOutput ( filter ) ; return ExpressionClause . createAndSetExpression ( filter ) ; } public FilterType filter ( Predicate predicate ) { FilterType filter = new FilterType ( predicate ) ; addOutput ( filter ) ; return filter ; } public FilterType filter ( ExpressionType expression ) { FilterType filter = getNodeFactory ( ) . createFilter ( ) ; filter . setExpression ( expression ) ; addOutput ( filter ) ; return filter ; } public FilterType filter ( String language , String expression ) { return filter ( new LanguageExpression ( language , expression ) ) ; } public LoadBalanceType loadBalance ( ) { LoadBalanceType answer = new LoadBalanceType ( ) ; addOutput ( answer ) ; return answer ; } public ChoiceType choice ( ) { ChoiceType answer = new ChoiceType ( ) ; addOutput ( answer ) ; return answer ; } public TryType tryBlock ( ) { TryType answer = new TryType ( ) ; addOutput ( answer ) ; return answer ; } public Type recipientList ( Expression receipients ) { RecipientListType answer = new RecipientListType ( receipients ) ; addOutput ( answer ) ; return ( Type ) this ; } public ExpressionClause < ProcessorType < Type > > recipientList ( ) { RecipientListType answer = new RecipientListType ( ) ; addOutput ( answer ) ; ExpressionClause < ProcessorType < Type > > clause = new ExpressionClause < ProcessorType < Type > > ( ( Type ) this ) ; answer . setExpression ( clause ) ; return clause ; } public Type routingSlip ( String header , String uriDelimiter ) { RoutingSlipType answer = new RoutingSlipType ( header , uriDelimiter ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type routingSlip ( String header ) { RoutingSlipType answer = new RoutingSlipType ( header ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type routingSlip ( ) { RoutingSlipType answer = new RoutingSlipType ( ) ; addOutput ( answer ) ; return ( Type ) this ; } public SplitterType splitter ( Expression receipients ) { SplitterType answer = new SplitterType ( receipients ) ; addOutput ( answer ) ; return answer ; } public ExpressionClause < SplitterType > splitter ( ) { SplitterType answer = new SplitterType ( ) ; addOutput ( answer ) ; return ExpressionClause . createAndSetExpression ( answer ) ; } public SplitterType splitter ( Expression partsExpression , AggregationStrategy aggregationStrategy ) { SplitterType answer = new SplitterType ( partsExpression ) ; addOutput ( answer ) ; answer . setAggregationStrategy ( aggregationStrategy ) ; return answer ; } public ExpressionClause < SplitterType > splitter ( AggregationStrategy aggregationStrategy ) { SplitterType answer = new SplitterType ( ) ; addOutput ( answer ) ; answer . setAggregationStrategy ( aggregationStrategy ) ; return ExpressionClause . createAndSetExpression ( answer ) ; } public SplitterType splitter ( Expression receipients , boolean parallelProcessing ) { SplitterType answer = new SplitterType ( receipients ) ; addOutput ( answer ) ; answer . setParallelProcessing ( parallelProcessing ) ; return answer ; } public ExpressionClause < SplitterType > splitter ( boolean parallelProcessing ) { SplitterType answer = new SplitterType ( ) ; addOutput ( answer ) ; answer . setParallelProcessing ( parallelProcessing ) ; return ExpressionClause . createAndSetExpression ( answer ) ; } public SplitterType splitter ( Expression partsExpression , AggregationStrategy aggregationStrategy , boolean parallelProcessing ) { SplitterType answer = new SplitterType ( partsExpression ) ; addOutput ( answer ) ; answer . setAggregationStrategy ( aggregationStrategy ) ; answer . setParallelProcessing ( parallelProcessing ) ; return answer ; } public ExpressionClause < SplitterType > splitter ( AggregationStrategy aggregationStrategy , boolean parallelProcessing ) { SplitterType answer = new SplitterType ( ) ; addOutput ( answer ) ; answer . setAggregationStrategy ( aggregationStrategy ) ; answer . setParallelProcessing ( parallelProcessing ) ; return ExpressionClause . createAndSetExpression ( answer ) ; } public ExpressionClause < ResequencerType > resequencer ( ) { ResequencerType answer = new ResequencerType ( ) ; addOutput ( answer ) ; ExpressionClause < ResequencerType > clause = new ExpressionClause < ResequencerType > ( answer ) ; answer . expression ( clause ) ; return clause ; } public ResequencerType resequencer ( Expression < Exchange > expression ) { return resequencer ( Collections . < Expression > singletonList ( expression ) ) ; } public ResequencerType resequencer ( List < Expression > expressions ) { ResequencerType answer = new ResequencerType ( expressions ) ; addOutput ( answer ) ; return answer ; } public ResequencerType resequencer ( Expression ... expressions ) { List < Expression > list = new ArrayList < Expression > ( ) ; list . addAll ( Arrays . asList ( expressions ) ) ; return resequencer ( list ) ; } public ExpressionClause < AggregatorType > aggregator ( ) { AggregatorType answer = new AggregatorType ( ) ; addOutput ( answer ) ; return ExpressionClause . createAndSetExpression ( answer ) ; } public ExpressionClause < AggregatorType > aggregator ( AggregationStrategy aggregationStrategy ) { AggregatorType answer = new AggregatorType ( ) ; answer . setAggregationStrategy ( aggregationStrategy ) ; addOutput ( answer ) ; return ExpressionClause . createAndSetExpression ( answer ) ; } public ExpressionClause < AggregatorType > aggregator ( AggregationCollection aggregationCollection ) { AggregatorType answer = new AggregatorType ( ) ; answer . setAggregationCollection ( aggregationCollection ) ; addOutput ( answer ) ; return ExpressionClause . createAndSetExpression ( answer ) ; } public AggregatorType aggregator ( Expression correlationExpression ) { AggregatorType answer = new AggregatorType ( correlationExpression ) ; addOutput ( answer ) ; return answer ; } public AggregatorType aggregator ( Expression correlationExpression , AggregationStrategy aggregationStrategy ) { AggregatorType answer = new AggregatorType ( correlationExpression , aggregationStrategy ) ; addOutput ( answer ) ; return answer ; } public DelayerType delayer ( Expression < Exchange > processAtExpression ) { return delayer ( processAtExpression , 0L ) ; } public DelayerType delayer ( Expression < Exchange > processAtExpression , long delay ) { DelayerType answer = new DelayerType ( processAtExpression , delay ) ; addOutput ( answer ) ; return answer ; } public ExpressionClause < DelayerType > delayer ( ) { DelayerType answer = new DelayerType ( ) ; addOutput ( answer ) ; return ExpressionClause . createAndSetExpression ( answer ) ; } public DelayerType delayer ( long delay ) { return delayer ( null , delay ) ; } public ThrottlerType throttler ( long maximumRequestCount ) { ThrottlerType answer = new ThrottlerType ( maximumRequestCount ) ; addOutput ( answer ) ; return answer ; } public Type throwFault ( Throwable fault ) { ThrowFaultType answer = new ThrowFaultType ( ) ; answer . setFault ( fault ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type throwFault ( String message ) { return throwFault ( new CamelException ( message ) ) ; } public Type interceptor ( String ref ) { InterceptorRef interceptor = new InterceptorRef ( ref ) ; intercept ( interceptor ) ; return ( Type ) this ; } public Type intercept ( DelegateProcessor interceptor ) { intercept ( new InterceptorRef ( interceptor ) ) ; return ( Type ) this ; } public InterceptType intercept ( ) { InterceptType answer = new InterceptType ( ) ; addOutput ( answer ) ; return answer ; } public void intercept ( InterceptorType interceptor ) { addOutput ( interceptor ) ; pushBlock ( interceptor ) ; } public void addInterceptor ( InterceptorType interceptor ) { interceptors . add ( interceptor ) ; } public void addInterceptor ( DelegateProcessor interceptor ) { addInterceptor ( new InterceptorRef ( interceptor ) ) ; } protected void pushBlock ( Block block ) { blocks . add ( block ) ; } protected Block popBlock ( ) { return blocks . isEmpty ( ) ? null : blocks . removeLast ( ) ; } public Type proceed ( ) { ProceedType proceed = null ; ProcessorType currentProcessor = this ; if ( currentProcessor instanceof InterceptType ) { proceed = ( ( InterceptType ) currentProcessor ) . getProceed ( ) ; LOG . info ( "proceed() is the implied and hence not needed for an intercept()" ) ; } if ( proceed == null ) { for ( ProcessorType node = parent ; node != null ; node = node . getParent ( ) ) { if ( node instanceof InterceptType ) { InterceptType intercept = ( InterceptType ) node ; proceed = intercept . getProceed ( ) ; break ; } } if ( proceed == null ) { throw new IllegalArgumentException ( "Cannot use proceed() without being within an intercept() block" ) ; } } addOutput ( proceed ) ; return ( Type ) this ; } public Type stop ( ) { ProcessorType currentProcessor = this ; if ( currentProcessor instanceof InterceptType ) { ( ( InterceptType ) currentProcessor ) . stopIntercept ( ) ; } else { ProcessorType node ; for ( node = parent ; node != null ; node = node . getParent ( ) ) { if ( node instanceof InterceptType ) { ( ( InterceptType ) node ) . stopIntercept ( ) ; break ; } } if ( node == null ) { throw new IllegalArgumentException ( "Cannot use stop() without being within an intercept() block" ) ; } } return ( Type ) this ; } public ExceptionType exception ( Class exceptionType ) { ExceptionType answer = new ExceptionType ( exceptionType ) ; addOutput ( answer ) ; return answer ; } public ChoiceType intercept ( Predicate predicate ) { InterceptType answer = new InterceptType ( ) ; addOutput ( answer ) ; return answer . when ( predicate ) ; } public Type interceptors ( String ... refs ) { for ( String ref : refs ) { interceptor ( ref ) ; } return ( Type ) this ; } public Type trace ( ) { return trace ( DEFAULT_TRACE_CATEGORY ) ; } public Type trace ( String category ) { final Log log = LogFactory . getLog ( category ) ; return intercept ( new DelegateProcessor ( ) { @ Override public void process ( Exchange exchange ) throws Exception { log . trace ( exchange ) ; processNext ( exchange ) ; } } ) ; } public PolicyRef policies ( ) { PolicyRef answer = new PolicyRef ( ) ; addOutput ( answer ) ; return answer ; } public PolicyRef policy ( Policy policy ) { PolicyRef answer = new PolicyRef ( policy ) ; addOutput ( answer ) ; return answer ; } public Type handleFault ( ) { intercept ( new HandleFaultType ( ) ) ; return ( Type ) this ; } public Type errorHandler ( ErrorHandlerBuilder errorHandlerBuilder ) { setErrorHandlerBuilder ( errorHandlerBuilder ) ; return ( Type ) this ; } public Type inheritErrorHandler ( boolean condition ) { setInheritErrorHandlerFlag ( condition ) ; return ( Type ) this ; } public Type process ( Processor processor ) { ProcessorRef answer = new ProcessorRef ( processor ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type processRef ( String ref ) { ProcessorRef answer = new ProcessorRef ( ) ; answer . setRef ( ref ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type bean ( Object bean ) { BeanRef answer = new BeanRef ( ) ; answer . setBean ( bean ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type bean ( Object bean , String method ) { BeanRef answer = new BeanRef ( ) ; answer . setBean ( bean ) ; answer . setMethod ( method ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type bean ( Class beanType ) { BeanRef answer = new BeanRef ( ) ; answer . setBeanType ( beanType ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type bean ( Class beanType , String method ) { BeanRef answer = new BeanRef ( ) ; answer . setBeanType ( beanType ) ; answer . setMethod ( method ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type beanRef ( String ref ) { BeanRef answer = new BeanRef ( ref ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type beanRef ( String ref , String method ) { BeanRef answer = new BeanRef ( ref , method ) ; addOutput ( answer ) ; return ( Type ) this ; } public ExpressionClause < ProcessorType < Type > > setBody ( ) { ExpressionClause < ProcessorType < Type > > clause = new ExpressionClause < ProcessorType < Type > > ( ( Type ) this ) ; SetBodyType answer = new SetBodyType ( clause ) ; addOutput ( answer ) ; return clause ; } public Type setBody ( Expression expression ) { SetBodyType answer = new SetBodyType ( expression ) ; addOutput ( answer ) ; return ( Type ) this ; } @ Deprecated public Type setOutBody ( Expression expression ) { return transform ( expression ) ; } @ Deprecated public ExpressionClause < ProcessorType < Type > > setOutBody ( ) { return transform ( ) ; } public Type transform ( Expression expression ) { TransformType answer = new TransformType ( expression ) ; addOutput ( answer ) ; return ( Type ) this ; } public ExpressionClause < ProcessorType < Type > > transform ( ) { ExpressionClause < ProcessorType < Type > > clause = new ExpressionClause < ProcessorType < Type > > ( ( Type ) this ) ; TransformType answer = new TransformType ( clause ) ; addOutput ( answer ) ; return clause ; } public Type setFaultBody ( Expression expression ) { return process ( ProcessorBuilder . setFaultBody ( expression ) ) ; } public ExpressionClause < ProcessorType < Type > > setHeader ( String name ) { ExpressionClause < ProcessorType < Type > > clause = new ExpressionClause < ProcessorType < Type > > ( ( Type ) this ) ; SetHeaderType answer = new SetHeaderType ( name , clause ) ; addOutput ( answer ) ; return clause ; } public Type setHeader ( String name , Expression expression ) { SetHeaderType answer = new SetHeaderType ( name , expression ) ; addOutput ( answer ) ; return ( Type ) this ; } public Type setHeader ( String name , String value ) { SetHeaderType answer = new SetHeaderType ( name , value ) ; addOutput ( answer ) ; return ( Type ) this ; } public ExpressionClause < ProcessorType < Type > > setOutHeader ( String name ) { ExpressionClause < ProcessorType < Type > > clause = new ExpressionClause < ProcessorType < Type > > ( ( Type ) this ) ; process ( ProcessorBuilder . setOutHeader ( name , clause ) ) ; return clause ; } public Type setOutHeader ( String name , Expression expression ) { return process ( ProcessorBuilder . setOutHeader ( name , expression ) ) ; } public Type setOutHeader ( String name , String value ) { return ( Type ) setOutHeader ( name ) . constant ( value ) ; } public Type setFaultHeader ( String name , Expression expression ) { return process ( ProcessorBuilder . setFaultHeader ( name , expression ) ) ; } public Type setProperty ( String name , Expression expression ) { return process ( ProcessorBuilder . setProperty ( name , expression ) ) ; } public ExpressionClause < ProcessorType < Type > > setProperty ( String name ) { ExpressionClause < ProcessorType < Type > > clause = new ExpressionClause < ProcessorType < Type > > ( ( Type ) this ) ; process ( ProcessorBuilder . setProperty ( name , clause ) ) ; return clause ; } public Type removeHeader ( String name ) { return process ( ProcessorBuilder . removeHeader ( name ) ) ; } public Type removeOutHeader ( String name ) { return process ( ProcessorBuilder . removeOutHeader ( name ) ) ; } public Type removeFaultHeader ( String name ) { return process ( ProcessorBuilder . removeFaultHeader ( name ) ) ; } public Type removeProperty ( String name ) { return process ( ProcessorBuilder . removeProperty ( name ) ) ; } public Type convertBodyTo ( Class type ) { addOutput ( new ConvertBodyType ( type ) ) ; return ( Type ) this ; } @ Deprecated public Type convertOutBodyTo ( Class type ) { return process ( new ConvertBodyProcessor ( type ) ) ; } @ Deprecated public Type convertFaultBodyTo ( Class type ) { return process ( new ConvertBodyProcessor ( type ) ) ; } public DataFormatClause < ProcessorType < Type > > unmarshal ( ) { return new DataFormatClause < ProcessorType < Type > > ( this , DataFormatClause . Operation . Unmarshal ) ; } public Type unmarshal ( DataFormatType dataFormatType ) { addOutput ( new UnmarshalType ( dataFormatType ) ) ; return ( Type ) this ; } public Type unmarshal ( DataFormat dataFormat ) { return unmarshal ( new DataFormatType ( dataFormat ) ) ; } public Type unmarshal ( String dataTypeRef ) { addOutput ( new UnmarshalType ( dataTypeRef ) ) ; return ( Type ) this ; } public DataFormatClause < ProcessorType < Type > > marshal ( ) { return new DataFormatClause < ProcessorType < Type > > ( this , DataFormatClause . Operation . Marshal ) ; } public Type marshal ( DataFormatType dataFormatType ) { addOutput ( new MarshalType ( dataFormatType ) ) ; return ( Type ) this ; } public Type marshal ( DataFormat dataFormat ) { return marshal ( new DataFormatType ( dataFormat ) ) ; } public Type marshal ( String dataTypeRef ) { addOutput ( new MarshalType ( dataTypeRef ) ) ; return ( Type ) this ; } @ XmlTransient public ProcessorType < ? extends ProcessorType > getParent ( ) { return parent ; } public void setParent ( ProcessorType < ? extends ProcessorType > parent ) { this . parent = parent ; } @ XmlTransient public ErrorHandlerBuilder getErrorHandlerBuilder ( ) { if ( errorHandlerBuilder == null ) { errorHandlerBuilder = createErrorHandlerBuilder ( ) ; } return errorHandlerBuilder ; } public void setErrorHandlerBuilder ( ErrorHandlerBuilder errorHandlerBuilder ) { this . errorHandlerBuilder = errorHandlerBuilder ; } protected void setErrorHandlerBuilderIfNull ( ErrorHandlerBuilder errorHandlerBuilder ) { if ( this . errorHandlerBuilder == null ) { setErrorHandlerBuilder ( errorHandlerBuilder ) ; } } public String getErrorHandlerRef ( ) { return errorHandlerRef ; } @ XmlAttribute ( required = false ) public void setErrorHandlerRef ( String errorHandlerRef ) { this . errorHandlerRef = errorHandlerRef ; setErrorHandlerBuilder ( new ErrorHandlerBuilderRef ( errorHandlerRef ) ) ; } @ XmlTransient public boolean isInheritErrorHandler ( ) { return isInheritErrorHandler ( getInheritErrorHandlerFlag ( ) ) ; } public static boolean isInheritErrorHandler ( Boolean value ) { return value == null || value . booleanValue ( ) ; } @ XmlAttribute ( name = "inheritErrorHandler" , required = false ) public Boolean getInheritErrorHandlerFlag ( ) { return inheritErrorHandlerFlag ; } public void setInheritErrorHandlerFlag ( Boolean inheritErrorHandlerFlag ) { this . inheritErrorHandlerFlag = inheritErrorHandlerFlag ; } @ XmlTransient public NodeFactory getNodeFactory ( ) { if ( nodeFactory == null ) { nodeFactory = new NodeFactory ( ) ; } return nodeFactory ; } public void setNodeFactory ( NodeFactory nodeFactory ) { this . nodeFactory = nodeFactory ; } public String getLabel ( ) { return "" ; } protected Processor makeProcessor ( RouteContext routeContext ) throws Exception { Processor processor = createProcessor ( routeContext ) ; return wrapProcessor ( routeContext , processor ) ; } protected Processor wrapProcessorInInterceptors ( RouteContext routeContext , Processor target ) throws Exception { if ( target == null ) { throw new RuntimeCamelException ( "target not provided." ) ; } List < InterceptStrategy > strategies = new ArrayList < InterceptStrategy > ( ) ; CamelContext camelContext = routeContext . getCamelContext ( ) ; if ( camelContext instanceof DefaultCamelContext ) { DefaultCamelContext defaultCamelContext = ( DefaultCamelContext ) camelContext ; strategies . addAll ( defaultCamelContext . getInterceptStrategies ( ) ) ; } strategies . addAll ( routeContext . getInterceptStrategies ( ) ) ; for ( InterceptStrategy strategy : strategies ) { if ( strategy != null ) { target = strategy . wrapProcessorInInterceptors ( this , target ) ; } } List < InterceptorType > list = routeContext . getRoute ( ) . getInterceptors ( ) ; if ( interceptors != null ) { list . addAll ( interceptors ) ; } Collections . reverse ( list ) ; Set < Processor > interceptors = new HashSet < Processor > ( ) ; interceptors . add ( target ) ; for ( InterceptorType interceptorType : list ) { DelegateProcessor interceptor = interceptorType . createInterceptor ( routeContext ) ; if ( ! interceptors . contains ( interceptor ) ) { interceptors . add ( interceptor ) ; if ( interceptor . getProcessor ( ) != null ) { LOG . warn ( "Interceptor " + interceptor + " currently wraps target " + interceptor . getProcessor ( ) + " is attempting to change target " + target + " new wrapping has been denied." ) ; } else { interceptor . setProcessor ( target ) ; target = interceptor ; } } } return target ; } protected Processor wrapInErrorHandler ( RouteContext routeContext , Processor target ) throws Exception { if ( target == null ) { throw new RuntimeCamelException ( "target not provided." ) ; } ErrorHandlerWrappingStrategy strategy = routeContext . getErrorHandlerWrappingStrategy ( ) ; if ( strategy != null ) { return strategy . wrapProcessorInErrorHandler ( routeContext , this , target ) ; } return getErrorHandlerBuilder ( ) . createErrorHandler ( routeContext , target ) ; } protected ErrorHandlerBuilder createErrorHandlerBuilder ( ) { if ( errorHandlerRef != null ) { return new ErrorHandlerBuilderRef ( errorHandlerRef ) ; } if ( isInheritErrorHandler ( ) ) { return new DeadLetterChannelBuilder ( ) ; } else { return new NoErrorHandlerBuilder ( ) ; } } protected void configureChild ( ProcessorType output ) { output . setNodeFactory ( getNodeFactory ( ) ) ; } public void addOutput ( ProcessorType processorType ) { processorType . setParent ( this ) ; configureChild ( processorType ) ; if ( blocks . isEmpty ( ) ) { getOutputs ( ) . add ( processorType ) ; } else { Block block = blocks . getLast ( ) ; block . addOutput ( processorType ) ; } } protected Processor createCompositeProcessor ( List < Processor > list ) { return new Pipeline ( list ) ; } protected Processor createOutputsProcessor ( RouteContext routeContext , Collection < ProcessorType < ? > > outputs ) throws Exception { List < Processor > list = new ArrayList < Processor > ( ) ; for ( ProcessorType output : outputs ) { Processor processor = output . createProcessor ( routeContext ) ; processor = output . wrapProcessorInInterceptors ( routeContext , processor ) ; ProcessorType currentProcessor = this ; if ( ! ( currentProcessor instanceof ExceptionType || currentProcessor instanceof TryType ) ) { processor = output . wrapInErrorHandler ( routeContext , processor ) ; } list . add ( processor ) ; } Processor processor = null ; if ( ! list . isEmpty ( ) ) { if ( list . size ( ) == 1 ) { processor = list . get ( 0 ) ; } else { processor = createCompositeProcessor ( list ) ; } } return processor ; } public void clearOutput ( ) { getOutputs ( ) . clear ( ) ; blocks . clear ( ) ; } } 	1	['141', '2', '13', '102', '286', '9792', '59', '69', '130', '0.895238095', '1747', '0.888888889', '3', '0.073333333', '0.057142857', '0', '0', '11.32624113', '6', '1.156', '17']
package org . apache . camel . spring ; import java . lang . reflect . Modifier ; import java . util . List ; import java . util . Map ; import java . util . Set ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . util . ResolverUtil ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . factory . config . BeanPostProcessor ; import org . springframework . context . ApplicationContext ; public class RouteBuilderFinder { private static final transient Log LOG = LogFactory . getLog ( RouteBuilderFinder . class ) ; private final SpringCamelContext camelContext ; private final String [ ] packages ; private ApplicationContext applicationContext ; private ResolverUtil resolver = new ResolverUtil ( ) ; private BeanPostProcessor beanPostProcessor ; public RouteBuilderFinder ( SpringCamelContext camelContext , String [ ] packages , ClassLoader classLoader , BeanPostProcessor postProcessor ) { this . camelContext = camelContext ; this . applicationContext = camelContext . getApplicationContext ( ) ; this . packages = packages ; this . beanPostProcessor = postProcessor ; Set set = resolver . getClassLoaders ( ) ; set . clear ( ) ; set . add ( classLoader ) ; } public String [ ] getPackages ( ) { return packages ; } public ApplicationContext getApplicationContext ( ) { return applicationContext ; } public void appendBuilders ( List < RouteBuilder > list ) throws IllegalAccessException , InstantiationException { resolver . findImplementations ( RouteBuilder . class , packages ) ; Set < Class > classes = resolver . getClasses ( ) ; for ( Class aClass : classes ) { if ( shouldIgnoreBean ( aClass ) ) { continue ; } if ( isValidClass ( aClass ) ) { RouteBuilder builder = instantiateBuilder ( aClass ) ; if ( beanPostProcessor != null ) { beanPostProcessor . postProcessBeforeInitialization ( builder , builder . toString ( ) ) ; } list . add ( builder ) ; } } } public void destroy ( ) throws Exception { } protected boolean shouldIgnoreBean ( Class type ) { Map beans = applicationContext . getBeansOfType ( type , true , true ) ; if ( beans == null || beans . isEmpty ( ) ) { return false ; } return true ; } protected boolean isValidClass ( Class type ) { if ( ! Modifier . isAbstract ( type . getModifiers ( ) ) && ! type . isInterface ( ) ) { return true ; } return false ; } protected RouteBuilder instantiateBuilder ( Class type ) throws IllegalAccessException , InstantiationException { return ( RouteBuilder ) camelContext . getInjector ( ) . newInstance ( type ) ; } } 	0	['9', '1', '0', '9', '31', '22', '1', '8', '5', '0.8125', '140', '1', '2', '0', '0.285714286', '0', '0', '13.88888889', '3', '1.2222', '0']
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . util . ExpressionHelper ; public class Delayer extends DelayProcessorSupport { private Expression < Exchange > timeExpression ; private long delay ; public Delayer ( Processor processor , Expression < Exchange > timeExpression , long delay ) { super ( processor ) ; this . timeExpression = timeExpression ; this . delay = delay ; } @ Override public String toString ( ) { return "Delayer[on: " + timeExpression + " delay: " + delay + " to: " + getProcessor ( ) + "]" ; } public long getDelay ( ) { return delay ; } public void setDelay ( long delay ) { this . delay = delay ; } protected void delay ( Exchange exchange ) throws Exception { long time = 0 ; if ( timeExpression != null ) { Long longValue = ExpressionHelper . evaluateAsType ( timeExpression , exchange , Long . class ) ; if ( longValue != null ) { time = longValue . longValue ( ) ; } } if ( time <= 0 ) { time = defaultProcessTime ( exchange ) ; } time += delay ; waitUntil ( time , exchange ) ; } protected long defaultProcessTime ( Exchange exchange ) { return currentSystemTime ( ) ; } } 	1	['6', '4', '0', '6', '17', '0', '1', '5', '4', '0.4', '85', '1', '1', '0.857142857', '0.4', '1', '2', '12.83333333', '1', '0.8333', '1']
package org . apache . camel . bam . model ; import javax . persistence . GeneratedValue ; import javax . persistence . Id ; public class EntitySupport { private Long id ; @ Id @ GeneratedValue public Long getId ( ) { return id ; } public void setId ( Long id ) { this . id = id ; } public String toString ( ) { return getClass ( ) . getName ( ) + "[" + id + "]" ; } } 	0	['4', '1', '3', '3', '11', '0', '3', '0', '4', '0.333333333', '31', '1', '0', '0', '0.625', '0', '0', '6.5', '1', '0.75', '0']
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . util . ServiceHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class LoggingErrorHandler extends ErrorHandlerSupport { private Processor output ; private Log log ; private LoggingLevel level ; public LoggingErrorHandler ( Processor output ) { this ( output , LogFactory . getLog ( LoggingErrorHandler . class ) , LoggingLevel . INFO ) ; } public LoggingErrorHandler ( Processor output , Log log , LoggingLevel level ) { this . output = output ; this . log = log ; this . level = level ; } @ Override public String toString ( ) { return "LoggingErrorHandler[" + output + "]" ; } public void process ( Exchange exchange ) throws Exception { try { output . process ( exchange ) ; } catch ( Throwable e ) { if ( ! customProcessorForException ( exchange , e ) ) { logError ( exchange , e ) ; } } } public Processor getOutput ( ) { return output ; } public LoggingLevel getLevel ( ) { return level ; } public void setLevel ( LoggingLevel level ) { this . level = level ; } public Log getLog ( ) { return log ; } public void setLog ( Log log ) { this . log = log ; } protected void logError ( Exchange exchange , Throwable e ) { switch ( level ) { case DEBUG : if ( log . isDebugEnabled ( ) ) { log . debug ( logMessage ( exchange , e ) , e ) ; } break ; case ERROR : if ( log . isErrorEnabled ( ) ) { log . error ( logMessage ( exchange , e ) , e ) ; } break ; case FATAL : if ( log . isFatalEnabled ( ) ) { log . fatal ( logMessage ( exchange , e ) , e ) ; } break ; case INFO : if ( log . isInfoEnabled ( ) ) { log . debug ( logMessage ( exchange , e ) , e ) ; } break ; case TRACE : if ( log . isTraceEnabled ( ) ) { log . trace ( logMessage ( exchange , e ) , e ) ; } break ; case WARN : if ( log . isWarnEnabled ( ) ) { log . warn ( logMessage ( exchange , e ) , e ) ; } break ; default : log . error ( "Unknown level: " + level + " when trying to log exchange: " + logMessage ( exchange , e ) , e ) ; } } protected Object logMessage ( Exchange exchange , Throwable e ) { return e + " while processing exchange: " + exchange ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( output ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( output ) ; } } 	1	['13', '3', '0', '9', '35', '26', '1', '8', '9', '0.555555556', '214', '1', '2', '0.620689655', '0.307692308', '1', '1', '15.23076923', '8', '1.3846', '2']
package org . apache . camel . component . http ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; public class HttpExchange extends DefaultExchange { private final HttpEndpoint endpoint ; private HttpServletRequest request ; private HttpServletResponse response ; public HttpExchange ( HttpEndpoint endpoint , ExchangePattern pattern ) { super ( endpoint . getCamelContext ( ) , pattern ) ; this . endpoint = endpoint ; } public HttpExchange ( HttpEndpoint endpoint , HttpServletRequest request , HttpServletResponse response ) { this ( endpoint , getPatternFromRequest ( request ) ) ; this . request = request ; this . response = response ; setIn ( new HttpMessage ( this , request ) ) ; } public HttpServletRequest getRequest ( ) { return request ; } public HttpServletResponse getResponse ( ) { return response ; } public HttpEndpoint getEndpoint ( ) { return endpoint ; } protected static ExchangePattern getPatternFromRequest ( HttpServletRequest request ) { return ExchangePattern . InOut ; } } 	0	['6', '2', '0', '11', '10', '9', '7', '6', '5', '0.733333333', '48', '1', '1', '0.904761905', '0.366666667', '0', '0', '6.5', '1', '0.6667', '0']
package org . apache . camel . processor ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . LinkedBlockingQueue ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . processor . resequencer . ResequencerEngine ; import org . apache . camel . processor . resequencer . SequenceElementComparator ; import org . apache . camel . processor . resequencer . SequenceSender ; public class StreamResequencer extends DelegateProcessor implements Processor { private ResequencerEngine < Exchange > reseq ; private BlockingQueue < Exchange > queue ; private SequenceSender sender ; public StreamResequencer ( Processor processor , SequenceElementComparator < Exchange > comparator , int capacity ) { super ( processor ) ; queue = new LinkedBlockingQueue < Exchange > ( ) ; reseq = new ResequencerEngine < Exchange > ( comparator , capacity ) ; reseq . setOutQueue ( queue ) ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; sender = new SequenceSender ( getProcessor ( ) ) ; sender . setQueue ( queue ) ; sender . start ( ) ; } @ Override protected void doStop ( ) throws Exception { reseq . stop ( ) ; sender . cancel ( ) ; super . doStop ( ) ; } @ Override public void process ( Exchange exchange ) throws Exception { reseq . put ( exchange ) ; } public long getTimeout ( ) { return reseq . getTimeout ( ) ; } public void setTimeout ( long timeout ) { reseq . setTimeout ( timeout ) ; } @ Override public String toString ( ) { return "StreamResequencer[to: " + getProcessor ( ) + "]" ; } } 	1	['7', '3', '0', '7', '26', '0', '1', '6', '5', '0.666666667', '84', '1', '2', '0.777777778', '0.285714286', '1', '1', '10.57142857', '1', '0.8571', '2']
package org . apache . camel . language . juel ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . spi . Language ; public class JuelLanguage implements Language { public Predicate < Exchange > createPredicate ( String expression ) { return new JuelExpression ( expression , Boolean . class ) ; } public Expression < Exchange > createExpression ( String expression ) { return new JuelExpression ( expression , Object . class ) ; } } 	0	['3', '1', '0', '4', '5', '3', '0', '4', '3', '2', '18', '0', '0', '0', '0.833333333', '0', '0', '5', '1', '0.6667', '0']
package org . apache . camel . processor . interceptor ; import org . apache . camel . Exchange ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . processor . DelegateProcessor ; import org . apache . camel . processor . Logger ; import org . apache . camel . processor . LoggingLevel ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class TraceInterceptor extends DelegateProcessor implements ExchangeFormatter { private final ProcessorType node ; private Predicate traceFilter ; private boolean traceExceptions = true ; private Logger logger = new Logger ( LogFactory . getLog ( TraceInterceptor . class ) , this ) ; private TraceFormatter formatter ; public TraceInterceptor ( ProcessorType node , Processor target , TraceFormatter formatter ) { super ( target ) ; this . node = node ; this . formatter = formatter ; } @ Override public String toString ( ) { return "TraceInterceptor[" + node + "]" ; } public void process ( Exchange exchange ) throws Exception { try { if ( shouldLogExchange ( exchange ) ) { logExchange ( exchange ) ; } super . proceed ( exchange ) ; } catch ( Exception e ) { logException ( exchange , e ) ; throw e ; } catch ( Error e ) { logException ( exchange , e ) ; throw e ; } } public Object format ( Exchange exchange ) { return formatter . format ( this , exchange ) ; } public ProcessorType getNode ( ) { return node ; } public Predicate getTraceFilter ( ) { return traceFilter ; } public void setTraceFilter ( Predicate traceFilter ) { this . traceFilter = traceFilter ; } public boolean isTraceExceptions ( ) { return traceExceptions ; } public void setTraceExceptions ( boolean traceExceptions ) { this . traceExceptions = traceExceptions ; } public Logger getLogger ( ) { return logger ; } public TraceFormatter getFormatter ( ) { return formatter ; } public void setFormatter ( TraceFormatter formatter ) { this . formatter = formatter ; } public LoggingLevel getLevel ( ) { return getLogger ( ) . getLevel ( ) ; } public Log getLog ( ) { return getLogger ( ) . getLog ( ) ; } public void setLog ( Log log ) { getLogger ( ) . setLog ( log ) ; } public void setLevel ( LoggingLevel level ) { getLogger ( ) . setLevel ( level ) ; } protected void logExchange ( Exchange exchange ) { logger . process ( exchange ) ; } protected void logException ( Exchange exchange , Throwable throwable ) { logger . process ( exchange , throwable ) ; } protected boolean shouldLogExchange ( Exchange exchange ) { return traceFilter == null || traceFilter . matches ( exchange ) ; } } 	1	['19', '3', '0', '13', '35', '129', '3', '11', '16', '0.8', '157', '1', '4', '0.538461538', '0.173684211', '1', '1', '7', '3', '1.0526', '2']
package org . apache . camel . component . jcr ; import java . io . InputStream ; import java . util . Calendar ; import javax . jcr . Value ; import org . apache . camel . Converter ; import org . apache . jackrabbit . value . BinaryValue ; import org . apache . jackrabbit . value . BooleanValue ; import org . apache . jackrabbit . value . DateValue ; import org . apache . jackrabbit . value . StringValue ; @ Converter public class JcrConverter { @ Converter public Value toValue ( Boolean bool ) { return new BooleanValue ( bool ) ; } @ Converter public Value toValue ( InputStream stream ) { return new BinaryValue ( stream ) ; } @ Converter public Value toValue ( Calendar calendar ) { return new DateValue ( calendar ) ; } @ Converter public Value toValue ( String value ) { return new StringValue ( value ) ; } } 	0	['5', '1', '0', '4', '10', '10', '0', '4', '5', '2', '28', '0', '0', '0', '0.36', '0', '0', '4.6', '1', '0.8', '0']
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; public class ValueBuilder < E extends Exchange > implements Expression < E > { private Expression < E > expression ; public ValueBuilder ( Expression < E > expression ) { this . expression = expression ; } public Object evaluate ( E exchange ) { return expression . evaluate ( exchange ) ; } public Expression < E > getExpression ( ) { return expression ; } @ Override public String toString ( ) { return expression . toString ( ) ; } public Predicate < E > isNotEqualTo ( Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isNotEqualTo ( expression , right ) ) ; } public Predicate < E > isEqualTo ( Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isEqualTo ( expression , right ) ) ; } public Predicate < E > isLessThan ( Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isLessThan ( expression , right ) ) ; } public Predicate < E > isLessThanOrEqualTo ( Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isLessThanOrEqualTo ( expression , right ) ) ; } public Predicate < E > isGreaterThan ( Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isGreaterThan ( expression , right ) ) ; } public Predicate < E > isGreaterThanOrEqualTo ( Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isGreaterThanOrEqualTo ( expression , right ) ) ; } public Predicate < E > isInstanceOf ( Class type ) { return onNewPredicate ( PredicateBuilder . isInstanceOf ( expression , type ) ) ; } public Predicate < E > matchesRegex ( String regex ) { return onNewPredicate ( PredicateBuilder . regex ( expression , regex ) ) ; } public Predicate < E > isNull ( ) { return onNewPredicate ( PredicateBuilder . isNull ( expression ) ) ; } public Predicate < E > isNotNull ( ) { return onNewPredicate ( PredicateBuilder . isNotNull ( expression ) ) ; } public Predicate < E > contains ( Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . contains ( expression , right ) ) ; } public Predicate < E > regex ( String regex ) { return onNewPredicate ( PredicateBuilder . regex ( expression , regex ) ) ; } public ValueBuilder < E > tokenize ( ) { return tokenize ( "\n" ) ; } public ValueBuilder < E > tokenize ( String token ) { Expression < E > newExp = ExpressionBuilder . tokenizeExpression ( expression , token ) ; return new ValueBuilder < E > ( newExp ) ; } public ValueBuilder < E > regexTokenize ( String regex ) { Expression < E > newExp = ExpressionBuilder . regexTokenize ( expression , regex ) ; return new ValueBuilder < E > ( newExp ) ; } public ValueBuilder < E > regexReplaceAll ( String regex , String replacement ) { Expression < E > newExp = ExpressionBuilder . regexReplaceAll ( expression , regex , replacement ) ; return new ValueBuilder < E > ( newExp ) ; } public ValueBuilder < E > regexReplaceAll ( String regex , Expression < E > replacement ) { Expression < E > newExp = ExpressionBuilder . regexReplaceAll ( expression , regex , replacement ) ; return new ValueBuilder < E > ( newExp ) ; } public ValueBuilder < E > convertTo ( Class type ) { Expression < E > newExp = ExpressionBuilder . convertTo ( expression , type ) ; return new ValueBuilder < E > ( newExp ) ; } public ValueBuilder < E > convertToString ( ) { return convertTo ( String . class ) ; } public ValueBuilder < E > append ( Object value ) { return new ValueBuilder < E > ( ExpressionBuilder . append ( expression , asExpression ( value ) ) ) ; } protected Predicate < E > onNewPredicate ( Predicate < E > predicate ) { return predicate ; } protected Expression < E > asExpression ( Object value ) { if ( value instanceof Expression ) { return ( Expression < E > ) value ; } else { return ExpressionBuilder . constantExpression ( value ) ; } } } 	1	['26', '1', '1', '9', '47', '0', '4', '5', '24', '0.08', '236', '1', '1', '0', '0.258241758', '0', '0', '8.038461538', '2', '1', '3']
package org . apache . camel . impl ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import org . apache . camel . Exchange ; import org . apache . camel . converter . IOConverter ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . util . ExchangeHelper ; public class StringDataFormat implements DataFormat { private String charset ; public StringDataFormat ( String charset ) { this . charset = charset ; } public void marshal ( Exchange exchange , Object graph , OutputStream stream ) throws IOException { String text = ExchangeHelper . convertToType ( exchange , String . class , graph ) ; byte [ ] bytes ; if ( charset != null ) { bytes = text . getBytes ( charset ) ; } else { bytes = text . getBytes ( ) ; } stream . write ( bytes ) ; } public Object unmarshal ( Exchange exchange , InputStream stream ) throws IOException , ClassNotFoundException { byte [ ] bytes = IOConverter . toBytes ( stream ) ; String answer ; if ( charset != null ) { answer = new String ( bytes , charset ) ; } else { answer = new String ( bytes ) ; } return answer ; } } 	0	['3', '1', '0', '5', '11', '0', '1', '4', '3', '0', '53', '1', '0', '0', '0.5', '0', '0', '16.33333333', '1', '0.6667', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Processor ; import org . apache . camel . processor . CatchProcessor ; import org . apache . camel . spi . RouteContext ; import org . apache . camel . util . ObjectHelper ; @ XmlRootElement ( name = "catch" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class CatchType extends ProcessorType < ProcessorType > { @ XmlElement ( name = "exception" ) private List < String > exceptions = new ArrayList < String > ( ) ; @ XmlElementRef private List < ProcessorType < ? > > outputs = new ArrayList < ProcessorType < ? > > ( ) ; @ XmlTransient private List < Class > exceptionClasses ; public CatchType ( ) { } public CatchType ( List < Class > exceptionClasses ) { this . exceptionClasses = exceptionClasses ; } public CatchType ( Class exceptionType ) { exceptionClasses = new ArrayList < Class > ( ) ; exceptionClasses . add ( exceptionType ) ; } @ Override public String toString ( ) { return "Catch[ " + getExceptionClasses ( ) + " -> " + getOutputs ( ) + "]" ; } @ Override public String getShortName ( ) { return "catch" ; } @ Override public String getLabel ( ) { return getExceptionClasses ( ) . toString ( ) ; } @ Override public CatchProcessor createProcessor ( RouteContext routeContext ) throws Exception { Processor childProcessor = routeContext . createProcessor ( this ) ; return new CatchProcessor ( getExceptionClasses ( ) , childProcessor ) ; } public List < ProcessorType < ? > > getOutputs ( ) { return outputs ; } public void setOutputs ( List < ProcessorType < ? > > outputs ) { this . outputs = outputs ; } public List < Class > getExceptionClasses ( ) { if ( exceptionClasses == null ) { exceptionClasses = createExceptionClasses ( ) ; } return exceptionClasses ; } public void setExceptionClasses ( List < Class > exceptionClasses ) { this . exceptionClasses = exceptionClasses ; } public List < String > getExceptions ( ) { return exceptions ; } public void setExceptions ( List < String > exceptions ) { this . exceptions = exceptions ; } protected List < Class > createExceptionClasses ( ) { List < String > list = getExceptions ( ) ; List < Class > answer = new ArrayList < Class > ( list . size ( ) ) ; for ( String name : list ) { Class type = ObjectHelper . loadClass ( name , getClass ( ) . getClassLoader ( ) ) ; answer . add ( type ) ; } return answer ; } } 	1	['15', '3', '0', '6', '32', '61', '1', '5', '14', '0.595238095', '168', '1', '0', '0.925925926', '0.366666667', '1', '2', '10', '2', '0.9333', '1']
package org . apache . camel . processor . resequencer ; public interface TimeoutHandler { void timeout ( Timeout timeout ) ; } 	0	['1', '1', '0', '3', '1', '0', '3', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlElements ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Processor ; import org . apache . camel . model . dataformat . ArtixDSDataFormat ; import org . apache . camel . model . dataformat . CsvDataFormat ; import org . apache . camel . model . dataformat . DataFormatType ; import org . apache . camel . model . dataformat . JaxbDataFormat ; import org . apache . camel . model . dataformat . SerializationDataFormat ; import org . apache . camel . model . dataformat . StringDataFormat ; import org . apache . camel . model . dataformat . XMLBeansDataFormat ; import org . apache . camel . processor . MarshalProcessor ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "marshal" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class MarshalType extends OutputType < ProcessorType > { @ XmlAttribute ( required = false ) private String ref ; @ XmlElements ( { @ XmlElement ( required = false , name = "artixDS" , type = ArtixDSDataFormat . class ) , @ XmlElement ( required = false , name = "csv" , type = CsvDataFormat . class ) , @ XmlElement ( required = false , name = "jaxb" , type = JaxbDataFormat . class ) , @ XmlElement ( required = false , name = "serialization" , type = SerializationDataFormat . class ) , @ XmlElement ( required = false , name = "string" , type = StringDataFormat . class ) , @ XmlElement ( required = false , name = "xmlBeans" , type = XMLBeansDataFormat . class ) } ) private DataFormatType dataFormatType ; public MarshalType ( ) { } public MarshalType ( DataFormatType dataFormatType ) { this . dataFormatType = dataFormatType ; } public MarshalType ( String ref ) { this . ref = ref ; } @ Override public String toString ( ) { if ( dataFormatType != null ) { return "Marshal[" + dataFormatType + "]" ; } else { return "Marshal[ref:  " + ref + "]" ; } } @ Override public String getShortName ( ) { return "marshal" ; } public String getRef ( ) { return ref ; } public void setRef ( String ref ) { this . ref = ref ; } public DataFormatType getDataFormatType ( ) { return dataFormatType ; } public void setDataFormatType ( DataFormatType dataFormatType ) { this . dataFormatType = dataFormatType ; } @ Override public Processor createProcessor ( RouteContext routeContext ) { DataFormat dataFormat = DataFormatType . getDataFormat ( routeContext , getDataFormatType ( ) , ref ) ; return new MarshalProcessor ( dataFormat ) ; } } 	1	['10', '4', '0', '7', '17', '13', '1', '6', '10', '0.555555556', '82', '1', '1', '0.95625', '0.375', '1', '1', '7', '2', '0.8', '1']
package org . apache . camel . component . cxf ; import java . util . ArrayList ; import java . util . List ; import javax . xml . ws . WebServiceProvider ; import org . apache . camel . Processor ; import org . apache . camel . component . cxf . feature . MessageDataFormatFeature ; import org . apache . camel . component . cxf . feature . PayLoadDataFormatFeature ; import org . apache . camel . component . cxf . spring . CxfEndpointBean ; import org . apache . camel . component . cxf . util . CxfEndpointUtils ; import org . apache . camel . impl . DefaultConsumer ; import org . apache . cxf . Bus ; import org . apache . cxf . BusFactory ; import org . apache . cxf . bus . spring . SpringBusFactory ; import org . apache . cxf . common . classloader . ClassLoaderUtils ; import org . apache . cxf . endpoint . Server ; import org . apache . cxf . feature . AbstractFeature ; import org . apache . cxf . frontend . ServerFactoryBean ; public class CxfConsumer extends DefaultConsumer < CxfExchange > { private CxfEndpoint endpoint ; private Server server ; public CxfConsumer ( CxfEndpoint endpoint , Processor processor ) throws Exception { super ( endpoint , processor ) ; Bus bus = null ; this . endpoint = endpoint ; boolean isWebServiceProvider = false ; if ( endpoint . getApplicationContext ( ) != null ) { SpringBusFactory bf = new SpringBusFactory ( endpoint . getApplicationContext ( ) ) ; bus = bf . createBus ( ) ; if ( CxfEndpointUtils . getSetDefaultBus ( endpoint ) ) { BusFactory . setDefaultBus ( bus ) ; } } else { bus = BusFactory . getDefaultBus ( ) ; } ServerFactoryBean svrBean = null ; if ( endpoint . isSpringContextEndpoint ( ) ) { CxfEndpointBean endpointBean = endpoint . getCxfEndpointBean ( ) ; svrBean = CxfEndpointUtils . getServerFactoryBean ( endpointBean . getServiceClass ( ) ) ; isWebServiceProvider = CxfEndpointUtils . hasAnnotation ( endpointBean . getServiceClass ( ) , WebServiceProvider . class ) ; endpoint . configure ( svrBean ) ; } else { Class serviceClass = ClassLoaderUtils . loadClass ( endpoint . getServiceClass ( ) , this . getClass ( ) ) ; svrBean = CxfEndpointUtils . getServerFactoryBean ( serviceClass ) ; isWebServiceProvider = CxfEndpointUtils . hasAnnotation ( serviceClass , WebServiceProvider . class ) ; svrBean . setAddress ( endpoint . getAddress ( ) ) ; svrBean . setServiceClass ( serviceClass ) ; if ( endpoint . getServiceName ( ) != null ) { svrBean . setServiceName ( CxfEndpointUtils . getServiceName ( endpoint ) ) ; } if ( endpoint . getPortName ( ) != null ) { svrBean . setEndpointName ( CxfEndpointUtils . getPortName ( endpoint ) ) ; } if ( endpoint . getWsdlURL ( ) != null ) { svrBean . setWsdlURL ( endpoint . getWsdlURL ( ) ) ; } } DataFormat dataFormat = CxfEndpointUtils . getDataFormat ( endpoint ) ; svrBean . setInvoker ( new CamelInvoker ( this ) ) ; if ( ! dataFormat . equals ( DataFormat . POJO ) && ! isWebServiceProvider ) { List < AbstractFeature > features = new ArrayList < AbstractFeature > ( ) ; if ( dataFormat . equals ( DataFormat . PAYLOAD ) ) { features . add ( new PayLoadDataFormatFeature ( ) ) ; } else if ( dataFormat . equals ( DataFormat . MESSAGE ) ) { features . add ( new MessageDataFormatFeature ( ) ) ; } svrBean . setFeatures ( features ) ; } svrBean . setBus ( bus ) ; svrBean . setStart ( false ) ; server = svrBean . create ( ) ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; server . start ( ) ; } @ Override protected void doStop ( ) throws Exception { server . stop ( ) ; super . doStop ( ) ; } public CxfEndpoint getEndpoint ( ) { return endpoint ; } } 	0	['5', '3', '0', '18', '47', '2', '2', '18', '3', '0.5', '172', '1', '1', '0.846153846', '0.466666667', '1', '1', '33', '1', '0.8', '0']
package org . apache . camel . processor ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import java . util . concurrent . ArrayBlockingQueue ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . RejectedExecutionException ; import java . util . concurrent . RejectedExecutionHandler ; import java . util . concurrent . ThreadPoolExecutor ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import org . apache . camel . AsyncCallback ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . processor . aggregate . AggregationStrategy ; import org . apache . camel . util . ExchangeHelper ; import org . apache . camel . util . ServiceHelper ; import static org . apache . camel . util . ObjectHelper . notNull ; public class MulticastProcessor extends ServiceSupport implements Processor { static class ProcessorExchangePair { private final Processor processor ; private final Exchange exchange ; public ProcessorExchangePair ( Processor processor , Exchange exchange ) { this . processor = processor ; this . exchange = exchange ; } public Processor getProcessor ( ) { return processor ; } public Exchange getExchange ( ) { return exchange ; } } private Collection < Processor > processors ; private AggregationStrategy aggregationStrategy ; private boolean isParallelProcessing ; private ThreadPoolExecutor executor ; private final AtomicBoolean shutdown = new AtomicBoolean ( true ) ; public MulticastProcessor ( Collection < Processor > processors ) { this ( processors , null ) ; } public MulticastProcessor ( Collection < Processor > processors , AggregationStrategy aggregationStrategy ) { this ( processors , aggregationStrategy , false , null ) ; } public MulticastProcessor ( Collection < Processor > processors , AggregationStrategy aggregationStrategy , boolean parallelProcessing , ThreadPoolExecutor executor ) { notNull ( processors , "processors" ) ; this . processors = processors ; this . aggregationStrategy = aggregationStrategy ; this . isParallelProcessing = parallelProcessing ; if ( isParallelProcessing ) { if ( executor != null ) { this . executor = executor ; } else { this . executor = new ThreadPoolExecutor ( processors . size ( ) , processors . size ( ) , 0 , TimeUnit . MILLISECONDS , new ArrayBlockingQueue < Runnable > ( processors . size ( ) ) ) ; } } } public static < E extends Exchange > Collection < Processor > toProducers ( Collection < Endpoint > endpoints ) throws Exception { Collection < Processor > answer = new ArrayList < Processor > ( ) ; for ( Endpoint endpoint : endpoints ) { answer . add ( endpoint . createProducer ( ) ) ; } return answer ; } @ Override public String toString ( ) { return "Multicast" + getProcessors ( ) ; } class ProcessCall implements Runnable { private final Exchange exchange ; private final AsyncCallback callback ; private final Processor processor ; public ProcessCall ( Exchange exchange , Processor processor , AsyncCallback callback ) { this . exchange = exchange ; this . callback = callback ; this . processor = processor ; } public void run ( ) { if ( shutdown . get ( ) ) { exchange . setException ( new RejectedExecutionException ( ) ) ; callback . done ( false ) ; } else { try { processor . process ( exchange ) ; } catch ( Exception ex ) { exchange . setException ( ex ) ; } callback . done ( false ) ; } } } public void process ( Exchange exchange ) throws Exception { Exchange result = null ; List < ProcessorExchangePair > pairs = createProcessorExchangePairs ( exchange ) ; if ( isParallelProcessing ) { Exchange [ ] exchanges = new Exchange [ pairs . size ( ) ] ; final CountDownLatch completedExchanges = new CountDownLatch ( pairs . size ( ) ) ; int i = 0 ; for ( ProcessorExchangePair pair : pairs ) { Processor producer = pair . getProcessor ( ) ; exchanges [ i ] = pair . getExchange ( ) ; updateNewExchange ( exchanges [ i ] , i , pairs ) ; ProcessCall call = new ProcessCall ( exchanges [ i ] , producer , new AsyncCallback ( ) { public void done ( boolean doneSynchronously ) { completedExchanges . countDown ( ) ; } } ) ; executor . execute ( call ) ; i ++ ; } completedExchanges . await ( ) ; if ( aggregationStrategy != null ) { for ( Exchange resultExchange : exchanges ) { if ( result == null ) { result = resultExchange ; } else { result = aggregationStrategy . aggregate ( result , resultExchange ) ; } } } } else { int i = 0 ; for ( ProcessorExchangePair pair : pairs ) { Processor producer = pair . getProcessor ( ) ; Exchange subExchange = pair . getExchange ( ) ; updateNewExchange ( subExchange , i , pairs ) ; producer . process ( subExchange ) ; if ( aggregationStrategy != null ) { if ( result == null ) { result = subExchange ; } else { result = aggregationStrategy . aggregate ( result , subExchange ) ; } } i ++ ; } } if ( result != null ) { ExchangeHelper . copyResults ( exchange , result ) ; } } protected void updateNewExchange ( Exchange exchange , int i , List < ProcessorExchangePair > allPairs ) { } protected List < ProcessorExchangePair > createProcessorExchangePairs ( Exchange exchange ) { List < ProcessorExchangePair > result = new ArrayList < ProcessorExchangePair > ( processors . size ( ) ) ; Processor [ ] processorsArray = processors . toArray ( new Processor [ processors . size ( ) ] ) ; for ( int i = 0 ; i < processorsArray . length ; i ++ ) { result . add ( new ProcessorExchangePair ( processorsArray [ i ] , exchange . copy ( ) ) ) ; } return result ; } protected void doStop ( ) throws Exception { shutdown . set ( true ) ; if ( executor != null ) { executor . shutdown ( ) ; executor . awaitTermination ( 0 , TimeUnit . SECONDS ) ; } ServiceHelper . stopServices ( processors ) ; } protected void doStart ( ) throws Exception { shutdown . set ( false ) ; if ( executor != null ) { executor . setRejectedExecutionHandler ( new RejectedExecutionHandler ( ) { public void rejectedExecution ( Runnable runnable , ThreadPoolExecutor executor ) { ProcessCall call = ( ProcessCall ) runnable ; call . exchange . setException ( new RejectedExecutionException ( ) ) ; call . callback . done ( false ) ; } } ) ; } ServiceHelper . startServices ( processors ) ; } public Collection < Processor > getProcessors ( ) { return processors ; } public AggregationStrategy getAggregationStrategy ( ) { return aggregationStrategy ; } } 	1	['13', '2', '2', '18', '53', '42', '7', '14', '8', '0.666666667', '340', '1', '1', '0.565217391', '0.213675214', '1', '1', '24.76923077', '2', '0.8462', '4']
package org . apache . camel . component . atom ; import java . util . Date ; import org . apache . abdera . model . Document ; import org . apache . abdera . model . Entry ; import org . apache . abdera . model . Feed ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class UpdatedDateFilter implements EntryFilter { private static final transient Log LOG = LogFactory . getLog ( UpdatedDateFilter . class ) ; private Date lastUpdate ; public UpdatedDateFilter ( Date lastUpdate ) { this . lastUpdate = lastUpdate ; } public boolean isValidEntry ( AtomEndpoint endpoint , Document < Feed > feed , Entry entry ) { Date updated = entry . getUpdated ( ) ; if ( updated == null ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "No updated time for entry so assuming its valid: entry=[" + entry + "]" ) ; } return true ; } if ( lastUpdate != null ) { if ( lastUpdate . after ( updated ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Entry is older than lastupdate=[" + lastUpdate + "], no valid entry=[" + entry + "]" ) ; } return false ; } } lastUpdate = updated ; return true ; } } 	0	['3', '1', '0', '7', '13', '0', '1', '6', '2', '0.5', '72', '1', '0', '0', '0.6', '0', '0', '22.33333333', '6', '2', '0']
package org . apache . camel . impl ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . Callable ; import javax . naming . Context ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . ProducerTemplate ; import org . apache . camel . ResolveEndpointFailedException ; import org . apache . camel . Route ; import org . apache . camel . Routes ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . Service ; import org . apache . camel . TypeConverter ; import org . apache . camel . builder . ErrorHandlerBuilder ; import org . apache . camel . impl . converter . DefaultTypeConverter ; import org . apache . camel . management . InstrumentationLifecycleStrategy ; import org . apache . camel . management . JmxSystemPropertyKeys ; import org . apache . camel . model . RouteType ; import org . apache . camel . processor . interceptor . Tracer ; import org . apache . camel . spi . ComponentResolver ; import org . apache . camel . spi . ExchangeConverter ; import org . apache . camel . spi . Injector ; import org . apache . camel . spi . InterceptStrategy ; import org . apache . camel . spi . Language ; import org . apache . camel . spi . LanguageResolver ; import org . apache . camel . spi . LifecycleStrategy ; import org . apache . camel . spi . Registry ; import org . apache . camel . util . FactoryFinder ; import org . apache . camel . util . NoFactoryAvailableException ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . ReflectionInjector ; import org . apache . camel . util . SystemHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import static org . apache . camel . util . ServiceHelper . startServices ; import static org . apache . camel . util . ServiceHelper . stopServices ; public class DefaultCamelContext extends ServiceSupport implements CamelContext , Service { private static final transient Log LOG = LogFactory . getLog ( DefaultCamelContext . class ) ; private static final String NAME_PREFIX = "camel-" ; private static int nameSuffix ; private String name ; private final Map < String , Endpoint > endpoints = new HashMap < String , Endpoint > ( ) ; private final Map < String , Component > components = new HashMap < String , Component > ( ) ; private List < Route > routes ; private List < Service > servicesToClose = new ArrayList < Service > ( ) ; private TypeConverter typeConverter ; private ExchangeConverter exchangeConverter ; private Injector injector ; private ComponentResolver componentResolver ; private boolean autoCreateComponents = true ; private LanguageResolver languageResolver = new DefaultLanguageResolver ( ) ; private Registry registry ; private LifecycleStrategy lifecycleStrategy ; private List < RouteType > routeDefinitions = new ArrayList < RouteType > ( ) ; private List < InterceptStrategy > interceptStrategies = new ArrayList < InterceptStrategy > ( ) ; private Boolean trace ; private ErrorHandlerBuilder errorHandlerBuilder ; public DefaultCamelContext ( ) { name = NAME_PREFIX + ++ nameSuffix ; if ( Boolean . getBoolean ( JmxSystemPropertyKeys . DISABLED ) ) { LOG . info ( "JMX is disabled. Using DefaultLifecycleStrategy." ) ; lifecycleStrategy = new DefaultLifecycleStrategy ( ) ; } else { try { LOG . info ( "JMX enabled. Using InstrumentationLifecycleStrategy." ) ; lifecycleStrategy = new InstrumentationLifecycleStrategy ( ) ; } catch ( NoClassDefFoundError e ) { LOG . warn ( "Could not find needed classes for JMX lifecycle strategy." + " Are you missing spring-context.jar by any chance? NoClassDefFoundError: " + e . getMessage ( ) ) ; } catch ( Exception e ) { LOG . warn ( "Could not create JMX lifecycle strategy, caused by: " + e . getMessage ( ) ) ; } if ( lifecycleStrategy == null ) { LOG . warn ( "Not possible to use JMX lifecycle strategy. Using DefaultLifecycleStrategy instead." ) ; lifecycleStrategy = new DefaultLifecycleStrategy ( ) ; } } } public DefaultCamelContext ( Context jndiContext ) { this ( new JndiRegistry ( jndiContext ) ) ; } public DefaultCamelContext ( Registry registry ) { this ( ) ; this . registry = registry ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public void addComponent ( String componentName , final Component component ) { if ( component == null ) { throw new IllegalArgumentException ( "Component cannot be null" ) ; } synchronized ( components ) { if ( components . containsKey ( componentName ) ) { throw new IllegalArgumentException ( "Component previously added: " + componentName ) ; } component . setCamelContext ( this ) ; components . put ( componentName , component ) ; } } public Component getComponent ( String name ) { synchronized ( components ) { Component component = components . get ( name ) ; if ( component == null && autoCreateComponents ) { try { component = getComponentResolver ( ) . resolveComponent ( name , this ) ; if ( component != null ) { addComponent ( name , component ) ; if ( isStarted ( ) ) { startServices ( component ) ; } } } catch ( Exception e ) { throw new RuntimeCamelException ( "Could not auto create component: " + name , e ) ; } } return component ; } } public < T extends Component > T getComponent ( String name , Class < T > componentType ) { Component component = getComponent ( name ) ; if ( componentType . isInstance ( component ) ) { return componentType . cast ( component ) ; } else { throw new IllegalArgumentException ( "The component is not of type: " + componentType + " but is: " + component ) ; } } public Component removeComponent ( String componentName ) { synchronized ( components ) { return components . remove ( componentName ) ; } } public Component getOrCreateComponent ( String componentName , Callable < Component > factory ) { synchronized ( components ) { Component component = components . get ( componentName ) ; if ( component == null ) { try { component = factory . call ( ) ; if ( component == null ) { throw new RuntimeCamelException ( "Factory failed to create the " + componentName + " component, it returned null." ) ; } components . put ( componentName , component ) ; component . setCamelContext ( this ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( "Factory failed to create the " + componentName + " component" , e ) ; } } return component ; } } public Collection < Endpoint > getSingletonEndpoints ( ) { synchronized ( endpoints ) { return new ArrayList < Endpoint > ( endpoints . values ( ) ) ; } } public Endpoint addSingletonEndpoint ( String uri , Endpoint endpoint ) throws Exception { Endpoint oldEndpoint ; synchronized ( endpoints ) { startServices ( endpoint ) ; oldEndpoint = endpoints . remove ( uri ) ; endpoints . put ( uri , endpoint ) ; stopServices ( oldEndpoint ) ; } return oldEndpoint ; } public Endpoint removeSingletonEndpoint ( String uri ) throws Exception { Endpoint oldEndpoint ; synchronized ( endpoints ) { oldEndpoint = endpoints . remove ( uri ) ; stopServices ( oldEndpoint ) ; } return oldEndpoint ; } public Endpoint getEndpoint ( String uri ) { Endpoint answer ; synchronized ( endpoints ) { answer = endpoints . get ( uri ) ; if ( answer == null ) { try { String splitURI [ ] = ObjectHelper . splitOnCharacter ( uri , ":" , 2 ) ; if ( splitURI [ 1 ] != null ) { String scheme = splitURI [ 0 ] ; Component component = getComponent ( scheme ) ; if ( component != null ) { answer = component . createEndpoint ( uri ) ; if ( answer != null && LOG . isDebugEnabled ( ) ) { LOG . debug ( uri + " converted to endpoint: " + answer + " by component: " + component ) ; } } } if ( answer == null ) { answer = createEndpoint ( uri ) ; } if ( answer != null ) { addService ( answer ) ; if ( answer . isSingleton ( ) ) { endpoints . put ( uri , answer ) ; lifecycleStrategy . onEndpointAdd ( answer ) ; } } } catch ( Exception e ) { LOG . debug ( "Failed to resolve endpoint " + uri + ". Reason: " + e , e ) ; throw new ResolveEndpointFailedException ( uri , e ) ; } } } return answer ; } public < T extends Endpoint > T getEndpoint ( String name , Class < T > endpointType ) { Endpoint endpoint = getEndpoint ( name ) ; if ( endpointType . isInstance ( endpoint ) ) { return endpointType . cast ( endpoint ) ; } else { throw new IllegalArgumentException ( "The endpoint is not of type: " + endpointType + " but is: " + endpoint ) ; } } public List < Route > getRoutes ( ) { if ( routes == null ) { routes = new ArrayList < Route > ( ) ; } return routes ; } public void setRoutes ( List < Route > routes ) { this . routes = routes ; } public void addRoutes ( Collection < Route > routes ) throws Exception { if ( this . routes == null ) { this . routes = new ArrayList < Route > ( routes ) ; } else { this . routes . addAll ( routes ) ; } lifecycleStrategy . onRoutesAdd ( routes ) ; if ( shouldStartRoutes ( ) ) { startRoutes ( routes ) ; } } public void addRoutes ( Routes builder ) throws Exception { builder . setContext ( this ) ; List < Route > routeList = builder . getRouteList ( ) ; LOG . debug ( "Adding routes from: " + builder + " routes: " + routeList ) ; addRoutes ( routeList ) ; } public void addRouteDefinitions ( Collection < RouteType > routeDefinitions ) throws Exception { this . routeDefinitions . addAll ( routeDefinitions ) ; if ( shouldStartRoutes ( ) ) { startRouteDefinitions ( routeDefinitions ) ; } } public void addService ( Object object ) throws Exception { if ( object instanceof Service ) { Service service = ( Service ) object ; service . start ( ) ; servicesToClose . add ( service ) ; } } public Language resolveLanguage ( String language ) { return getLanguageResolver ( ) . resolveLanguage ( language , this ) ; } public ExchangeConverter getExchangeConverter ( ) { if ( exchangeConverter == null ) { exchangeConverter = createExchangeConverter ( ) ; } return exchangeConverter ; } public void setExchangeConverter ( ExchangeConverter exchangeConverter ) { this . exchangeConverter = exchangeConverter ; } public TypeConverter getTypeConverter ( ) { if ( typeConverter == null ) { typeConverter = createTypeConverter ( ) ; } return typeConverter ; } public void setTypeConverter ( TypeConverter typeConverter ) { this . typeConverter = typeConverter ; } public Injector getInjector ( ) { if ( injector == null ) { injector = createInjector ( ) ; } return injector ; } public void setInjector ( Injector injector ) { this . injector = injector ; } public ComponentResolver getComponentResolver ( ) { if ( componentResolver == null ) { componentResolver = createComponentResolver ( ) ; } return componentResolver ; } public void setComponentResolver ( ComponentResolver componentResolver ) { this . componentResolver = componentResolver ; } public LanguageResolver getLanguageResolver ( ) { return languageResolver ; } public void setLanguageResolver ( LanguageResolver languageResolver ) { this . languageResolver = languageResolver ; } public boolean isAutoCreateComponents ( ) { return autoCreateComponents ; } public void setAutoCreateComponents ( boolean autoCreateComponents ) { this . autoCreateComponents = autoCreateComponents ; } public Registry getRegistry ( ) { if ( registry == null ) { registry = createRegistry ( ) ; } return registry ; } public void setRegistry ( Registry registry ) { this . registry = registry ; } public LifecycleStrategy getLifecycleStrategy ( ) { return lifecycleStrategy ; } public void setLifecycleStrategy ( LifecycleStrategy lifecycleStrategy ) { this . lifecycleStrategy = lifecycleStrategy ; } public List < RouteType > getRouteDefinitions ( ) { return routeDefinitions ; } public List < InterceptStrategy > getInterceptStrategies ( ) { return interceptStrategies ; } public void setInterceptStrategies ( List < InterceptStrategy > interceptStrategies ) { this . interceptStrategies = interceptStrategies ; } public void addInterceptStrategy ( InterceptStrategy interceptStrategy ) { getInterceptStrategies ( ) . add ( interceptStrategy ) ; } public boolean getTrace ( ) { final Boolean value = getTracing ( ) ; if ( value != null ) { return value ; } else { return SystemHelper . isSystemProperty ( "canel.trace" ) ; } } public Boolean getTracing ( ) { return trace ; } public void setTrace ( Boolean trace ) { this . trace = trace ; } public < E extends Exchange > ProducerTemplate < E > createProducerTemplate ( ) { return new DefaultProducerTemplate < E > ( this ) ; } public ErrorHandlerBuilder getErrorHandlerBuilder ( ) { return errorHandlerBuilder ; } public void setErrorHandlerBuilder ( ErrorHandlerBuilder errorHandlerBuilder ) { this . errorHandlerBuilder = errorHandlerBuilder ; } protected void doStart ( ) throws Exception { if ( getTrace ( ) ) { boolean found = false ; final List < InterceptStrategy > list = getInterceptStrategies ( ) ; for ( InterceptStrategy strategy : list ) { if ( strategy instanceof Tracer ) { found = true ; } } if ( ! found ) { addInterceptStrategy ( new Tracer ( ) ) ; } } lifecycleStrategy . onContextStart ( this ) ; forceLazyInitialization ( ) ; if ( components != null ) { for ( Component component : components . values ( ) ) { startServices ( component ) ; } } startRouteDefinitions ( routeDefinitions ) ; startRoutes ( routes ) ; } protected void startRouteDefinitions ( Collection < RouteType > list ) throws Exception { if ( list != null ) { Collection < Route > routes = new ArrayList < Route > ( ) ; for ( RouteType route : list ) { route . addRoutes ( this , routes ) ; } addRoutes ( routes ) ; } } protected void doStop ( ) throws Exception { stopServices ( servicesToClose ) ; if ( components != null ) { for ( Component component : components . values ( ) ) { stopServices ( component ) ; } } } protected void startRoutes ( Collection < Route > routeList ) throws Exception { if ( routeList != null ) { for ( Route < Exchange > route : routeList ) { List < Service > services = route . getServicesForRoute ( ) ; for ( Service service : services ) { addService ( service ) ; } } } } protected void forceLazyInitialization ( ) { getExchangeConverter ( ) ; getInjector ( ) ; getLanguageResolver ( ) ; getTypeConverter ( ) ; } protected ExchangeConverter createExchangeConverter ( ) { return new DefaultExchangeConverter ( ) ; } protected TypeConverter createTypeConverter ( ) { return new DefaultTypeConverter ( getInjector ( ) ) ; } protected Injector createInjector ( ) { FactoryFinder finder = new FactoryFinder ( ) ; try { return ( Injector ) finder . newInstance ( "Injector" ) ; } catch ( NoFactoryAvailableException e ) { return new ReflectionInjector ( ) ; } catch ( IllegalAccessException e ) { throw new RuntimeCamelException ( e ) ; } catch ( InstantiationException e ) { throw new RuntimeCamelException ( e ) ; } catch ( IOException e ) { throw new RuntimeCamelException ( e ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeCamelException ( e ) ; } } protected ComponentResolver createComponentResolver ( ) { return new DefaultComponentResolver ( ) ; } protected Registry createRegistry ( ) { return new JndiRegistry ( ) ; } protected Endpoint createEndpoint ( String uri ) { Object value = getRegistry ( ) . lookup ( uri ) ; if ( value instanceof Endpoint ) { return ( Endpoint ) value ; } else if ( value instanceof Processor ) { return new ProcessorEndpoint ( uri , this , ( Processor ) value ) ; } else if ( value != null ) { return convertBeanToEndpoint ( uri , value ) ; } return null ; } protected Endpoint convertBeanToEndpoint ( String uri , Object bean ) { throw new IllegalArgumentException ( "uri: " + uri + " bean: " + bean + " could not be converted to an Endpoint" ) ; } protected boolean shouldStartRoutes ( ) { return isStarted ( ) && ! isStarting ( ) ; } } 	1	['62', '2', '1', '50', '135', '1723', '12', '40', '48', '0.930327869', '1182', '1', '8', '0.183098592', '0.075260805', '1', '1', '17.74193548', '7', '1.3548', '6']
package org . apache . camel . builder . script ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import org . apache . camel . language . LanguageAnnotation ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . PARAMETER } ) @ LanguageAnnotation ( language = "python" ) public @ interface Python { String value ( ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; public final class Builder { private Builder ( ) { } public static < E extends Exchange > ValueBuilder < E > constant ( Object value ) { Expression < E > expression = ExpressionBuilder . constantExpression ( value ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange > ValueBuilder < E > header ( String name ) { Expression < E > expression = ExpressionBuilder . headerExpression ( name ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange > ValueBuilder < E > body ( ) { Expression < E > expression = ExpressionBuilder . bodyExpression ( ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange , T > ValueBuilder < E > bodyAs ( Class < T > type ) { Expression < E > expression = ExpressionBuilder . < E , T > bodyExpression ( type ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange > ValueBuilder < E > outBody ( ) { Expression < E > expression = ExpressionBuilder . outBodyExpression ( ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange , T > ValueBuilder < E > outBodyAs ( Class < T > type ) { Expression < E > expression = ExpressionBuilder . < E , T > outBodyExpression ( type ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange > ValueBuilder < E > faultBody ( ) { Expression < E > expression = ExpressionBuilder . faultBodyExpression ( ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange , T > ValueBuilder < E > faultBodyAs ( Class < T > type ) { Expression < E > expression = ExpressionBuilder . < E , T > faultBodyExpression ( type ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange > ValueBuilder < E > systemProperty ( final String name ) { return systemProperty ( name , null ) ; } public static < E extends Exchange > ValueBuilder < E > systemProperty ( final String name , final String defaultValue ) { return new ValueBuilder < E > ( ExpressionBuilder . < E > systemProperty ( name , defaultValue ) ) ; } } 	1	['11', '1', '0', '4', '22', '55', '1', '3', '10', '2', '86', '0', '0', '0', '0.181818182', '0', '0', '6.818181818', '1', '0.9091', '2']
package org . apache . camel . component . quartz ; import java . util . Date ; import java . util . Map ; import java . util . Set ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . processor . loadbalancer . LoadBalancer ; import org . apache . camel . processor . loadbalancer . RoundRobinLoadBalancer ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . quartz . JobDetail ; import org . quartz . JobExecutionContext ; import org . quartz . JobExecutionException ; import org . quartz . Scheduler ; import org . quartz . SchedulerException ; import org . quartz . SimpleTrigger ; import org . quartz . Trigger ; public class QuartzEndpoint extends DefaultEndpoint < QuartzExchange > { public static final String ENDPOINT_KEY = "org.apache.camel.quartz" ; private static final transient Log LOG = LogFactory . getLog ( QuartzEndpoint . class ) ; private Scheduler scheduler ; private LoadBalancer loadBalancer ; private Trigger trigger ; private JobDetail jobDetail ; private boolean started ; public QuartzEndpoint ( String endpointUri , QuartzComponent component , Scheduler scheduler ) { super ( endpointUri , component ) ; this . scheduler = scheduler ; } public QuartzEndpoint ( String endpointUri , Scheduler scheduler ) { super ( endpointUri ) ; this . scheduler = scheduler ; } public void addTriggers ( Map < Trigger , JobDetail > triggerMap ) throws SchedulerException { if ( triggerMap != null ) { Set < Map . Entry < Trigger , JobDetail > > entries = triggerMap . entrySet ( ) ; for ( Map . Entry < Trigger , JobDetail > entry : entries ) { Trigger key = entry . getKey ( ) ; JobDetail value = entry . getValue ( ) ; ObjectHelper . notNull ( key , "key" ) ; ObjectHelper . notNull ( value , "value" ) ; addTrigger ( key , value ) ; } } } public void addTrigger ( Trigger trigger , JobDetail detail ) throws SchedulerException { if ( trigger . getName ( ) == null ) { trigger . setName ( detail . getName ( ) ) ; } if ( trigger . getGroup ( ) == null ) { trigger . setGroup ( detail . getGroup ( ) ) ; } if ( trigger . getStartTime ( ) == null ) { trigger . setStartTime ( new Date ( ) ) ; } detail . getJobDataMap ( ) . put ( ENDPOINT_KEY , this ) ; Class jobClass = detail . getJobClass ( ) ; if ( jobClass == null ) { detail . setJobClass ( CamelJob . class ) ; } if ( detail . getName ( ) == null ) { detail . setName ( getEndpointUri ( ) ) ; } getScheduler ( ) . scheduleJob ( detail , trigger ) ; } public void removeTrigger ( Trigger trigger , JobDetail jobDetail ) throws SchedulerException { getScheduler ( ) . unscheduleJob ( trigger . getName ( ) , trigger . getGroup ( ) ) ; } public void onJobExecute ( JobExecutionContext jobExecutionContext ) throws JobExecutionException { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Firing Quartz Job with context: " + jobExecutionContext ) ; } QuartzExchange exchange = createExchange ( jobExecutionContext ) ; try { getLoadBalancer ( ) . process ( exchange ) ; } catch ( JobExecutionException e ) { throw e ; } catch ( Exception e ) { throw new JobExecutionException ( e ) ; } } @ Override public QuartzExchange createExchange ( ExchangePattern pattern ) { return new QuartzExchange ( getCamelContext ( ) , pattern , null ) ; } public QuartzExchange createExchange ( JobExecutionContext jobExecutionContext ) { return new QuartzExchange ( getCamelContext ( ) , getExchangePattern ( ) , jobExecutionContext ) ; } public Producer < QuartzExchange > createProducer ( ) throws Exception { throw new UnsupportedOperationException ( "You cannot send messages to this endpoint" ) ; } public QuartzConsumer createConsumer ( Processor processor ) throws Exception { return new QuartzConsumer ( this , processor ) ; } @ Override public QuartzComponent getComponent ( ) { return ( QuartzComponent ) super . getComponent ( ) ; } public boolean isSingleton ( ) { return true ; } public Scheduler getScheduler ( ) { return scheduler ; } public LoadBalancer getLoadBalancer ( ) { if ( loadBalancer == null ) { loadBalancer = createLoadBalancer ( ) ; } return loadBalancer ; } public void setLoadBalancer ( LoadBalancer loadBalancer ) { this . loadBalancer = loadBalancer ; } public JobDetail getJobDetail ( ) { if ( jobDetail == null ) { jobDetail = createJobDetail ( ) ; } return jobDetail ; } public void setJobDetail ( JobDetail jobDetail ) { this . jobDetail = jobDetail ; } public Trigger getTrigger ( ) { if ( trigger == null ) { trigger = createTrigger ( ) ; } return trigger ; } public void setTrigger ( Trigger trigger ) { this . trigger = trigger ; } public synchronized void consumerStarted ( QuartzConsumer consumer ) throws SchedulerException { getLoadBalancer ( ) . addProcessor ( consumer . getProcessor ( ) ) ; if ( ! started ) { addTrigger ( getTrigger ( ) , getJobDetail ( ) ) ; started = true ; } } public synchronized void consumerStopped ( QuartzConsumer consumer ) throws SchedulerException { getLoadBalancer ( ) . removeProcessor ( consumer . getProcessor ( ) ) ; if ( getLoadBalancer ( ) . getProcessors ( ) . isEmpty ( ) && started ) { removeTrigger ( getTrigger ( ) , getJobDetail ( ) ) ; started = false ; } } protected LoadBalancer createLoadBalancer ( ) { return new RoundRobinLoadBalancer ( ) ; } protected JobDetail createJobDetail ( ) { return new JobDetail ( ) ; } protected Trigger createTrigger ( ) { return new SimpleTrigger ( ) ; } } 	0	['28', '2', '0', '25', '74', '362', '3', '24', '24', '0.91005291', '323', '0.857142857', '1', '0.479166667', '0.148148148', '1', '2', '10.28571429', '2', '1', '0']
package org . apache . camel . component . log ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . camel . converter . ObjectConverter ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . impl . ProcessorEndpoint ; import org . apache . camel . processor . Logger ; import org . apache . camel . processor . LoggingLevel ; import org . apache . camel . processor . ThroughputLogger ; public class LogComponent extends DefaultComponent < Exchange > { protected Endpoint < Exchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { LoggingLevel level = getLoggingLevel ( parameters ) ; Integer groupSize = getAndRemoveParameter ( parameters , "groupSize" , Integer . class ) ; Logger logger ; if ( groupSize != null ) { logger = new ThroughputLogger ( remaining , level , ObjectConverter . toInteger ( groupSize ) ) ; } else { LogFormatter formatter = new LogFormatter ( ) ; IntrospectionSupport . setProperties ( formatter , parameters ) ; logger = new Logger ( remaining ) ; logger . setLevel ( level ) ; logger . setFormatter ( formatter ) ; } return new ProcessorEndpoint ( uri , this , logger ) ; } protected LoggingLevel getLoggingLevel ( Map parameters ) { String levelText = getAndRemoveParameter ( parameters , "level" , String . class , "INFO" ) ; return LoggingLevel . valueOf ( levelText . toUpperCase ( ) ) ; } } 	1	['3', '3', '0', '12', '17', '3', '0', '12', '1', '2', '67', '0', '0', '0.944444444', '0.666666667', '1', '3', '21.33333333', '1', '0.6667', '1']
package org . apache . camel . osgi ; import java . io . BufferedInputStream ; import java . net . URL ; import java . util . Enumeration ; import java . util . HashMap ; import java . util . Map ; import java . util . Properties ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . spi . ComponentResolver ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . osgi . framework . Bundle ; import org . osgi . framework . BundleContext ; import org . osgi . framework . BundleEvent ; import org . osgi . framework . SynchronousBundleListener ; import org . springframework . osgi . util . BundleDelegatingClassLoader ; public class OsgiComponentResolver implements ComponentResolver { private static final transient Log LOG = LogFactory . getLog ( OsgiComponentResolver . class ) ; private BundleContext bundleContext ; private Map < String , ComponentEntry > components ; private class BundleListener implements SynchronousBundleListener { public void bundleChanged ( BundleEvent event ) { try { Bundle bundle = event . getBundle ( ) ; if ( event . getType ( ) == BundleEvent . RESOLVED ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Bundle resolved: " + bundle . getSymbolicName ( ) ) ; } mayBeAddComponentFor ( bundle ) ; } else if ( event . getType ( ) == BundleEvent . UNRESOLVED ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Bundle unresolved: " + bundle . getSymbolicName ( ) ) ; } mayBeRemoveComponentFor ( bundle ) ; } } catch ( Throwable e ) { LOG . fatal ( "Exception handing bundle changed event" , e ) ; } } } private class ComponentEntry { Bundle bundle ; String path ; String name ; Class type ; } public OsgiComponentResolver ( BundleContext bundleContext ) { this . bundleContext = bundleContext ; } protected void init ( ) { if ( components != null ) { return ; } LOG . debug ( "Initializing OsgiComponentResolver" ) ; components = new HashMap < String , ComponentEntry > ( ) ; bundleContext . addBundleListener ( new BundleListener ( ) ) ; Bundle [ ] previousBundles = bundleContext . getBundles ( ) ; for ( int i = 0 ; i < previousBundles . length ; i ++ ) { int state = previousBundles [ i ] . getState ( ) ; if ( state == Bundle . RESOLVED || state == Bundle . ACTIVE ) { try { mayBeAddComponentFor ( previousBundles [ i ] ) ; } catch ( Exception e ) { LOG . error ( "Component " + previousBundles [ i ] + " not added due to " + e . toString ( ) , e ) ; } } } } protected synchronized void mayBeAddComponentFor ( Bundle bundle ) { Enumeration e = bundle . getEntryPaths ( "/META-INF/services/org/apache/camel/component/" ) ; if ( e != null ) { while ( e . hasMoreElements ( ) ) { String path = ( String ) e . nextElement ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Found entry: " + path + " in bundle " + bundle . getSymbolicName ( ) ) ; } ComponentEntry entry = new ComponentEntry ( ) ; entry . bundle = bundle ; entry . path = path ; entry . name = path . substring ( path . lastIndexOf ( "/" ) + 1 ) ; components . put ( entry . name , entry ) ; } } } protected synchronized void mayBeRemoveComponentFor ( Bundle bundle ) { for ( ComponentEntry entry : components . values ( ) ) { if ( entry . bundle == bundle ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Removing entry: " + entry . path + " in bundle " + bundle . getSymbolicName ( ) ) ; } components . remove ( entry . name ) ; } } } protected synchronized Class getComponent ( String name ) throws Exception { ComponentEntry entry = components . get ( name ) ; if ( entry == null ) { return null ; } if ( entry . type == null ) { URL url = entry . bundle . getEntry ( entry . path ) ; Properties properties = new Properties ( ) ; BufferedInputStream reader = null ; try { reader = new BufferedInputStream ( url . openStream ( ) ) ; properties . load ( reader ) ; } finally { try { reader . close ( ) ; } catch ( Exception ignore ) { } } String classname = ( String ) properties . get ( "class" ) ; ClassLoader loader = BundleDelegatingClassLoader . createBundleClassLoaderFor ( entry . bundle ) ; entry . type = loader . loadClass ( classname ) ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Found component: " + name + " via type: " + entry . type . getName ( ) ) ; } return entry . type ; } public Component resolveComponent ( String name , CamelContext context ) throws Exception { Object bean = null ; try { bean = context . getRegistry ( ) . lookup ( name ) ; if ( bean != null && LOG . isDebugEnabled ( ) ) { LOG . debug ( "Found component: " + name + " in registry: " + bean ) ; } } catch ( Exception e ) { LOG . debug ( "Ignored error looking up bean: " + name + ". Error: " + e ) ; } if ( bean != null ) { if ( bean instanceof Component ) { return ( Component ) bean ; } } init ( ) ; Class type = null ; try { type = getComponent ( name ) ; } catch ( Throwable e ) { throw new IllegalArgumentException ( "Invalid URI, no Component registered for scheme : " + name , e ) ; } if ( type == null ) { return null ; } if ( Component . class . isAssignableFrom ( type ) ) { return ( Component ) context . getInjector ( ) . newInstance ( type ) ; } else { throw new IllegalArgumentException ( "Type is not a Component implementation. Found: " + type . getName ( ) ) ; } } } 	0	['8', '1', '0', '15', '54', '0', '3', '14', '2', '0.428571429', '378', '1', '0', '0', '0.342857143', '0', '0', '45.875', '5', '1.875', '0']
package org . apache . camel . converter . jaxp ; import java . io . ByteArrayInputStream ; import java . io . Externalizable ; import java . io . IOException ; import java . io . InputStream ; import java . io . ObjectInput ; import java . io . ObjectOutput ; import java . io . Reader ; import java . io . StringReader ; import java . io . UnsupportedEncodingException ; import javax . xml . transform . stream . StreamSource ; public class StringSource extends StreamSource implements Externalizable { private String text ; private String encoding = "UTF-8" ; public StringSource ( ) { } public StringSource ( String text ) { if ( text == null ) { throw new NullPointerException ( "text can not be null" ) ; } this . text = text ; } public StringSource ( String text , String systemId ) { this ( text ) ; setSystemId ( systemId ) ; } public StringSource ( String text , String systemId , String encoding ) { this . text = text ; this . encoding = encoding ; setSystemId ( systemId ) ; } public InputStream getInputStream ( ) { try { return new ByteArrayInputStream ( text . getBytes ( encoding ) ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } public Reader getReader ( ) { return new StringReader ( text ) ; } public String toString ( ) { return "StringSource[" + text + "]" ; } public String getText ( ) { return text ; } public String getEncoding ( ) { return encoding ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public void setText ( String text ) { this . text = text ; } public void writeExternal ( ObjectOutput out ) throws IOException { out . writeUTF ( text ) ; out . writeUTF ( encoding ) ; out . writeUTF ( getPublicId ( ) ) ; out . writeUTF ( getSystemId ( ) ) ; } public void readExternal ( ObjectInput in ) throws IOException , ClassNotFoundException { text = in . readUTF ( ) ; encoding = in . readUTF ( ) ; setPublicId ( in . readUTF ( ) ) ; setSystemId ( in . readUTF ( ) ) ; } } 	1	['13', '2', '1', '3', '28', '0', '3', '0', '13', '0.291666667', '140', '1', '0', '0.5', '0.384615385', '0', '0', '9.615384615', '1', '0.6923', '2']
package org . apache . camel . component . jms . requestor ; import javax . jms . JMSException ; import javax . jms . Message ; import org . apache . camel . RuntimeCamelException ; public class FailedToProcessResponse extends RuntimeCamelException { private final Message response ; public FailedToProcessResponse ( Message response , JMSException e ) { super ( "Failed to process response: " + e + ". Message: " + response , e ) ; this . response = response ; } public Message getResponse ( ) { return response ; } } 	0	['2', '5', '0', '3', '7', '0', '2', '1', '2', '0', '25', '1', '0', '0.944444444', '0.666666667', '0', '0', '11', '1', '0.5', '0']
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . util . ExchangeHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class ConvertBodyProcessor implements Processor { private static final transient Log LOG = LogFactory . getLog ( ConvertBodyProcessor . class ) ; private final Class type ; public ConvertBodyProcessor ( Class type ) { this . type = type ; } public void process ( Exchange exchange ) throws Exception { Message in = exchange . getIn ( ) ; Object value = in . getBody ( type ) ; if ( value == null ) { LOG . warn ( "Could not convert body of IN message: " + in + " to type: " + type . getName ( ) ) ; } if ( exchange . getPattern ( ) . isOutCapable ( ) ) { Message out = exchange . getOut ( ) ; out . copyFrom ( in ) ; out . setBody ( value ) ; } else { in . setBody ( value ) ; } } } 	1	['3', '1', '0', '8', '18', '0', '2', '6', '2', '0.5', '59', '1', '0', '0', '0.666666667', '0', '0', '18', '1', '0.3333', '1']
package org . apache . camel . component . uface ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; public class UFaceComponent extends DefaultComponent { protected Endpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { return new UFaceEndpoint ( uri , this ) ; } } 	0	['2', '3', '1', '4', '4', '1', '2', '3', '1', '2', '11', '0', '0', '0.971428571', '0.666666667', '1', '1', '4.5', '1', '0.5', '0']
package org . apache . camel . impl ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . CountDownLatch ; import org . apache . camel . AsyncCallback ; import org . apache . camel . Exchange ; import org . apache . camel . spi . Synchronization ; import org . apache . camel . spi . UnitOfWork ; import org . apache . camel . util . UuidGenerator ; public class DefaultUnitOfWork implements UnitOfWork { private static final UuidGenerator DEFAULT_ID_GENERATOR = new UuidGenerator ( ) ; private String id ; private List < Synchronization > synchronizations ; private List < AsyncCallback > asyncCallbacks ; private CountDownLatch latch ; public DefaultUnitOfWork ( ) { } public synchronized void addSynchronization ( Synchronization synchronization ) { if ( synchronizations == null ) { synchronizations = new ArrayList < Synchronization > ( ) ; } synchronizations . add ( synchronization ) ; } public synchronized void removeSynchronization ( Synchronization synchronization ) { if ( synchronizations != null ) { synchronizations . remove ( synchronization ) ; } } public void reset ( ) { } public void done ( Exchange exchange ) { if ( synchronizations != null ) { boolean failed = exchange . isFailed ( ) ; for ( Synchronization synchronization : synchronizations ) { if ( failed ) { synchronization . onFailure ( exchange ) ; } else { synchronization . onComplete ( exchange ) ; } } } } public boolean isSynchronous ( ) { return asyncCallbacks == null || asyncCallbacks . isEmpty ( ) ; } public String getId ( ) { if ( id == null ) { id = DEFAULT_ID_GENERATOR . generateId ( ) ; } return id ; } } 	1	['8', '1', '0', '5', '21', '20', '1', '4', '7', '0.942857143', '94', '1', '1', '0', '0.476190476', '0', '0', '10.125', '4', '1.75', '1']
package org . apache . camel . builder ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . util . ObjectHelper ; import static org . apache . camel . util . ObjectHelper . compare ; import static org . apache . camel . util . ObjectHelper . notNull ; public final class PredicateBuilder { private PredicateBuilder ( ) { } public static < E extends Exchange > Predicate < E > toPredicate ( final Expression < E > expression ) { return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { Object value = expression . evaluate ( exchange ) ; return ObjectHelper . evaluateValuePredicate ( value ) ; } @ Override public String toString ( ) { return expression . toString ( ) ; } } ; } public static < E extends Exchange > Predicate < E > not ( final Predicate < E > predicate ) { notNull ( predicate , "predicate" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { return ! predicate . matches ( exchange ) ; } @ Override public String toString ( ) { return "not " + predicate ; } } ; } public static < E extends Exchange > Predicate < E > and ( final Predicate < E > left , final Predicate < E > right ) { notNull ( left , "left" ) ; notNull ( right , "right" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { return left . matches ( exchange ) && right . matches ( exchange ) ; } @ Override public String toString ( ) { return "(" + left + ") and (" + right + ")" ; } } ; } public static < E extends Exchange > Predicate < E > or ( final Predicate < E > left , final Predicate < E > right ) { notNull ( left , "left" ) ; notNull ( right , "right" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { return left . matches ( exchange ) || right . matches ( exchange ) ; } @ Override public String toString ( ) { return "(" + left + ") or (" + right + ")" ; } } ; } public static < E extends Exchange > Predicate < E > isEqualTo ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return ObjectHelper . equal ( leftValue , rightValue ) ; } protected String getOperationText ( ) { return "==" ; } } ; } public static < E extends Exchange > Predicate < E > isNotEqualTo ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return ! ObjectHelper . equal ( leftValue , rightValue ) ; } protected String getOperationText ( ) { return "!=" ; } } ; } public static < E extends Exchange > Predicate < E > isLessThan ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return compare ( leftValue , rightValue ) < 0 ; } protected String getOperationText ( ) { return "<" ; } } ; } public static < E extends Exchange > Predicate < E > isLessThanOrEqualTo ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return compare ( leftValue , rightValue ) <= 0 ; } protected String getOperationText ( ) { return "<=" ; } } ; } public static < E extends Exchange > Predicate < E > isGreaterThan ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return compare ( leftValue , rightValue ) > 0 ; } protected String getOperationText ( ) { return ">" ; } } ; } public static < E extends Exchange > Predicate < E > isGreaterThanOrEqualTo ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return compare ( leftValue , rightValue ) >= 0 ; } protected String getOperationText ( ) { return ">=" ; } } ; } public static < E extends Exchange > Predicate < E > contains ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return ObjectHelper . contains ( leftValue , rightValue ) ; } protected String getOperationText ( ) { return "contains" ; } } ; } public static < E extends Exchange > Predicate < E > isNull ( final Expression < E > expression ) { return isEqualTo ( expression , ExpressionBuilder . < E > constantExpression ( null ) ) ; } public static < E extends Exchange > Predicate < E > isNotNull ( final Expression < E > expression ) { return isNotEqualTo ( expression , ExpressionBuilder . < E > constantExpression ( null ) ) ; } public static < E extends Exchange > Predicate < E > isInstanceOf ( final Expression < E > expression , final Class type ) { notNull ( expression , "expression" ) ; notNull ( type , "type" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { Object value = expression . evaluate ( exchange ) ; return type . isInstance ( value ) ; } @ Override public String toString ( ) { return expression + " instanceof " + type . getName ( ) ; } @ Override protected String assertionFailureMessage ( E exchange ) { return super . assertionFailureMessage ( exchange ) + " for <" + expression . evaluate ( exchange ) + ">" ; } } ; } public static < E extends Exchange > Predicate < E > regex ( final Expression < E > expression , final String regex ) { return regex ( expression , Pattern . compile ( regex ) ) ; } public static < E extends Exchange > Predicate < E > regex ( final Expression < E > expression , final Pattern pattern ) { notNull ( expression , "expression" ) ; notNull ( pattern , "pattern" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { Object value = expression . evaluate ( exchange ) ; if ( value != null ) { Matcher matcher = pattern . matcher ( value . toString ( ) ) ; return matcher . matches ( ) ; } return false ; } @ Override public String toString ( ) { return expression + ".matches(" + pattern + ")" ; } @ Override protected String assertionFailureMessage ( E exchange ) { return super . assertionFailureMessage ( exchange ) + " for <" + expression . evaluate ( exchange ) + ">" ; } } ; } } 	0	['17', '1', '0', '21', '34', '136', '4', '17', '16', '2', '138', '0', '0', '0', '0.196078431', '0', '0', '7.117647059', '1', '0.9412', '0']
package org . apache . camel . model ; public class NodeFactory { public FilterType createFilter ( ) { return new FilterType ( ) ; } public RouteType createRoute ( ) { return new RouteType ( ) ; } } 	1	['3', '1', '0', '3', '6', '3', '1', '2', '3', '2', '14', '0', '0', '0', '1', '0', '0', '3.666666667', '1', '0.6667', '1']
package org . apache . camel . language . ognl ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . spi . Language ; public class OgnlLanguage implements Language { public Predicate < Exchange > createPredicate ( String expression ) { return new OgnlExpression ( this , expression , Boolean . class ) ; } public Expression < Exchange > createExpression ( String expression ) { return new OgnlExpression ( this , expression , Object . class ) ; } } 	0	['3', '1', '0', '4', '5', '3', '1', '4', '3', '2', '20', '0', '0', '0', '0.833333333', '0', '0', '5.666666667', '1', '0.6667', '0']
package org . apache . camel . component . bean ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; public class BeanExchange extends DefaultExchange { public BeanExchange ( CamelContext context , ExchangePattern pattern ) { super ( context , pattern ) ; } public BeanExchange ( DefaultExchange parent ) { super ( parent ) ; } public BeanInvocation getInvocation ( ) { return getIn ( ) . getBody ( BeanInvocation . class ) ; } public void setInvocation ( BeanInvocation invocation ) { getIn ( ) . setBody ( invocation ) ; } @ Override public Exchange newInstance ( ) { return new BeanExchange ( this ) ; } } 	1	['5', '2', '0', '9', '10', '10', '3', '6', '5', '2', '30', '0', '0', '0.926829268', '0.36', '1', '1', '5', '1', '0.6', '1']
package org . apache . camel . component . mina ; import java . net . SocketAddress ; import org . apache . camel . Consumer ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . mina . common . IoAcceptor ; import org . apache . mina . common . IoAcceptorConfig ; import org . apache . mina . common . IoConnector ; import org . apache . mina . common . IoConnectorConfig ; import org . apache . mina . common . IoSession ; public class MinaEndpoint extends DefaultEndpoint < MinaExchange > { private static final long DEFAULT_TIMEOUT = 30000 ; private long timeout = DEFAULT_TIMEOUT ; private final IoAcceptor acceptor ; private final SocketAddress address ; private final IoConnector connector ; private final IoAcceptorConfig acceptorConfig ; private final IoConnectorConfig connectorConfig ; private final boolean lazySessionCreation ; private final boolean transferExchange ; public MinaEndpoint ( String endpointUri , MinaComponent component , SocketAddress address , IoAcceptor acceptor , IoAcceptorConfig acceptorConfig , IoConnector connector , IoConnectorConfig connectorConfig , boolean lazySessionCreation , long timeout , boolean transferExchange ) { super ( endpointUri , component ) ; this . address = address ; this . acceptor = acceptor ; this . acceptorConfig = acceptorConfig ; this . connectorConfig = connectorConfig ; this . connector = connector ; this . lazySessionCreation = lazySessionCreation ; if ( timeout > 0 ) { this . timeout = timeout ; } this . transferExchange = transferExchange ; } @ SuppressWarnings ( { "unchecked" } ) public Producer < MinaExchange > createProducer ( ) throws Exception { return new MinaProducer ( this ) ; } public Consumer < MinaExchange > createConsumer ( Processor processor ) throws Exception { return new MinaConsumer ( this , processor ) ; } @ Override public MinaExchange createExchange ( ExchangePattern pattern ) { return new MinaExchange ( getCamelContext ( ) , pattern , null ) ; } public MinaExchange createExchange ( IoSession session , Object payload ) { MinaExchange exchange = new MinaExchange ( getCamelContext ( ) , getExchangePattern ( ) , session ) ; MinaPayloadHelper . setIn ( exchange , payload ) ; return exchange ; } public IoAcceptor getAcceptor ( ) { return acceptor ; } public SocketAddress getAddress ( ) { return address ; } public IoConnector getConnector ( ) { return connector ; } public boolean isLazySessionCreation ( ) { return lazySessionCreation ; } public IoAcceptorConfig getAcceptorConfig ( ) { return acceptorConfig ; } public IoConnectorConfig getConnectorConfig ( ) { return connectorConfig ; } public boolean isSingleton ( ) { return true ; } public long getTimeout ( ) { return timeout ; } public boolean isTransferExchange ( ) { return transferExchange ; } } 	0	['15', '2', '0', '20', '21', '89', '6', '18', '15', '0.944444444', '123', '1', '0', '0.621621622', '0.138095238', '1', '1', '6.6', '1', '0.9333', '0']
package org . apache . camel . builder ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . processor . DeadLetterChannel ; import org . apache . camel . processor . ErrorHandlerSupport ; import org . apache . camel . processor . Logger ; import org . apache . camel . processor . LoggingLevel ; import org . apache . camel . processor . RecipientList ; import org . apache . camel . processor . RedeliveryPolicy ; import org . apache . camel . processor . exceptionpolicy . ExceptionPolicyStrategy ; import org . apache . camel . spi . RouteContext ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DeadLetterChannelBuilder extends ErrorHandlerBuilderSupport { private RedeliveryPolicy redeliveryPolicy = new RedeliveryPolicy ( ) ; private ExceptionPolicyStrategy exceptionPolicyStrategy = ErrorHandlerSupport . createDefaultExceptionPolicyStrategy ( ) ; private ProcessorFactory deadLetterFactory ; private Processor defaultDeadLetterEndpoint ; private Expression defaultDeadLetterEndpointExpression ; private String defaultDeadLetterEndpointUri = "log:org.apache.camel.DeadLetterChannel?level=error" ; private Logger logger = DeadLetterChannel . createDefaultLogger ( ) ; public DeadLetterChannelBuilder ( ) { } public DeadLetterChannelBuilder ( Processor processor ) { this ( new ConstantProcessorBuilder ( processor ) ) ; } public DeadLetterChannelBuilder ( ProcessorFactory deadLetterFactory ) { this . deadLetterFactory = deadLetterFactory ; } public ErrorHandlerBuilder copy ( ) { DeadLetterChannelBuilder answer = new DeadLetterChannelBuilder ( deadLetterFactory ) ; answer . setRedeliveryPolicy ( getRedeliveryPolicy ( ) . copy ( ) ) ; return answer ; } public Processor createErrorHandler ( RouteContext routeContext , Processor processor ) throws Exception { Processor deadLetter = getDeadLetterFactory ( ) . createProcessor ( ) ; DeadLetterChannel answer = new DeadLetterChannel ( processor , deadLetter , getRedeliveryPolicy ( ) , getLogger ( ) , getExceptionPolicyStrategy ( ) ) ; configure ( answer ) ; return answer ; } public DeadLetterChannelBuilder backOffMultiplier ( double backOffMultiplier ) { getRedeliveryPolicy ( ) . backOffMultiplier ( backOffMultiplier ) ; return this ; } public DeadLetterChannelBuilder collisionAvoidancePercent ( short collisionAvoidancePercent ) { getRedeliveryPolicy ( ) . collisionAvoidancePercent ( collisionAvoidancePercent ) ; return this ; } public DeadLetterChannelBuilder initialRedeliveryDelay ( long initialRedeliveryDelay ) { getRedeliveryPolicy ( ) . initialRedeliveryDelay ( initialRedeliveryDelay ) ; return this ; } public DeadLetterChannelBuilder maximumRedeliveries ( int maximumRedeliveries ) { getRedeliveryPolicy ( ) . maximumRedeliveries ( maximumRedeliveries ) ; return this ; } public DeadLetterChannelBuilder maximumRedeliveryDelay ( long maximumRedeliveryDelay ) { getRedeliveryPolicy ( ) . maximumRedeliveryDelay ( maximumRedeliveryDelay ) ; return this ; } public DeadLetterChannelBuilder useCollisionAvoidance ( ) { getRedeliveryPolicy ( ) . useCollisionAvoidance ( ) ; return this ; } public DeadLetterChannelBuilder useExponentialBackOff ( ) { getRedeliveryPolicy ( ) . useExponentialBackOff ( ) ; return this ; } public DeadLetterChannelBuilder logger ( Logger logger ) { setLogger ( logger ) ; return this ; } public DeadLetterChannelBuilder loggingLevel ( LoggingLevel level ) { getLogger ( ) . setLevel ( level ) ; return this ; } public DeadLetterChannelBuilder log ( Log log ) { getLogger ( ) . setLog ( log ) ; return this ; } public DeadLetterChannelBuilder log ( String log ) { return log ( LogFactory . getLog ( log ) ) ; } public DeadLetterChannelBuilder log ( Class log ) { return log ( LogFactory . getLog ( log ) ) ; } public ErrorHandlerBuilderSupport exceptionPolicyStrategy ( ExceptionPolicyStrategy exceptionPolicyStrategy ) { setExceptionPolicyStrategy ( exceptionPolicyStrategy ) ; return this ; } public RedeliveryPolicy getRedeliveryPolicy ( ) { return redeliveryPolicy ; } public void setRedeliveryPolicy ( RedeliveryPolicy redeliveryPolicy ) { this . redeliveryPolicy = redeliveryPolicy ; } public ProcessorFactory getDeadLetterFactory ( ) { if ( deadLetterFactory == null ) { deadLetterFactory = new ProcessorFactory ( ) { public Processor createProcessor ( ) { return getDefaultDeadLetterEndpoint ( ) ; } } ; } return deadLetterFactory ; } public void setDeadLetterFactory ( ProcessorFactory deadLetterFactory ) { this . deadLetterFactory = deadLetterFactory ; } public Processor getDefaultDeadLetterEndpoint ( ) { if ( defaultDeadLetterEndpoint == null ) { defaultDeadLetterEndpoint = new RecipientList ( getDefaultDeadLetterEndpointExpression ( ) ) ; } return defaultDeadLetterEndpoint ; } public void setDefaultDeadLetterEndpoint ( Processor defaultDeadLetterEndpoint ) { this . defaultDeadLetterEndpoint = defaultDeadLetterEndpoint ; } public Expression getDefaultDeadLetterEndpointExpression ( ) { if ( defaultDeadLetterEndpointExpression == null ) { defaultDeadLetterEndpointExpression = ExpressionBuilder . constantExpression ( getDefaultDeadLetterEndpointUri ( ) ) ; } return defaultDeadLetterEndpointExpression ; } public void setDefaultDeadLetterEndpointExpression ( Expression defaultDeadLetterEndpointExpression ) { this . defaultDeadLetterEndpointExpression = defaultDeadLetterEndpointExpression ; } public String getDefaultDeadLetterEndpointUri ( ) { return defaultDeadLetterEndpointUri ; } public void setDefaultDeadLetterEndpointUri ( String defaultDeadLetterEndpointUri ) { this . defaultDeadLetterEndpointUri = defaultDeadLetterEndpointUri ; } public Logger getLogger ( ) { return logger ; } public void setLogger ( Logger logger ) { this . logger = logger ; } public ExceptionPolicyStrategy getExceptionPolicyStrategy ( ) { return exceptionPolicyStrategy ; } public void setExceptionPolicyStrategy ( ExceptionPolicyStrategy exceptionPolicyStrategy ) { this . exceptionPolicyStrategy = exceptionPolicyStrategy ; } } 	1	['32', '2', '0', '20', '55', '438', '3', '18', '32', '0.792626728', '273', '1', '6', '0.09375', '0.10546875', '0', '0', '7.3125', '2', '1', '4']
package org . apache . camel . processor . loadbalancer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; public class LoadBalancerConsumer extends DefaultConsumer < Exchange > { private final LoadBalancer loadBalancer ; public LoadBalancerConsumer ( Endpoint endpoint , Processor processor , LoadBalancer loadBalancer ) { super ( endpoint , processor ) ; this . loadBalancer = loadBalancer ; } @ Override protected void doStart ( ) throws Exception { loadBalancer . addProcessor ( getProcessor ( ) ) ; } @ Override protected void doStop ( ) throws Exception { loadBalancer . removeProcessor ( getProcessor ( ) ) ; } } 	0	['3', '3', '0', '5', '7', '0', '1', '4', '1', '0', '24', '1', '1', '0.916666667', '0.5', '1', '1', '6.666666667', '1', '0.6667', '0']
package org . apache . camel . processor ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . ProducerCache ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . model . RoutingSlipType ; import org . apache . camel . util . CollectionStringBuffer ; import org . apache . camel . util . ExchangeHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import static org . apache . camel . util . ObjectHelper . notNull ; public class RoutingSlip extends ServiceSupport implements Processor { private static final transient Log LOG = LogFactory . getLog ( RoutingSlip . class ) ; private final String header ; private final String uriDelimiter ; private ProducerCache < Exchange > producerCache = new ProducerCache < Exchange > ( ) ; public RoutingSlip ( String header ) { this ( header , RoutingSlipType . DEFAULT_DELIMITER ) ; } public RoutingSlip ( String header , String uriDelimiter ) { notNull ( header , "header" ) ; notNull ( uriDelimiter , "uriDelimiter" ) ; this . header = header ; this . uriDelimiter = uriDelimiter ; } @ Override public String toString ( ) { return "RoutingSlip[header=" + header + " uriDelimiter=" + uriDelimiter + "]" ; } public void process ( Exchange exchange ) throws Exception { Message message = exchange . getIn ( ) ; String [ ] recipients = recipients ( message ) ; Exchange current = exchange ; for ( String nextRecipient : recipients ) { Endpoint < Exchange > endpoint = resolveEndpoint ( exchange , nextRecipient ) ; Producer < Exchange > producer = producerCache . getProducer ( endpoint ) ; Exchange ex = endpoint . createExchange ( ExchangePattern . InOut ) ; updateRoutingSlip ( current ) ; copyOutToIn ( ex , current ) ; producer . process ( ex ) ; current = ex ; } ExchangeHelper . copyResults ( exchange , current ) ; } protected Endpoint < Exchange > resolveEndpoint ( Exchange exchange , Object recipient ) { return ExchangeHelper . resolveEndpoint ( exchange , recipient ) ; } protected void doStop ( ) throws Exception { producerCache . stop ( ) ; } protected void doStart ( ) throws Exception { } private void updateRoutingSlip ( Exchange current ) { Message message = getResultMessage ( current ) ; message . setHeader ( header , removeFirstElement ( recipients ( message ) ) ) ; } private Message getResultMessage ( Exchange exchange ) { Message message = exchange . getOut ( false ) ; if ( message == null ) { message = exchange . getIn ( ) ; } return message ; } private String [ ] recipients ( Message message ) { Object headerValue = message . getHeader ( header ) ; if ( headerValue != null && ! headerValue . equals ( "" ) ) { return headerValue . toString ( ) . split ( uriDelimiter ) ; } return new String [ ] { } ; } private String removeFirstElement ( String [ ] elements ) { CollectionStringBuffer updatedElements = new CollectionStringBuffer ( uriDelimiter ) ; for ( int i = 1 ; i < elements . length ; i ++ ) { updatedElements . append ( elements [ i ] ) ; } return updatedElements . toString ( ) ; } private void copyOutToIn ( Exchange result , Exchange source ) { result . setException ( source . getException ( ) ) ; Message fault = source . getFault ( false ) ; if ( fault != null ) { result . getFault ( true ) . copyFrom ( fault ) ; } result . setIn ( getResultMessage ( source ) ) ; result . getProperties ( ) . clear ( ) ; result . getProperties ( ) . putAll ( source . getProperties ( ) ) ; } } 	1	['13', '2', '0', '14', '44', '54', '1', '13', '4', '0.708333333', '223', '1', '1', '0.565217391', '0.305555556', '1', '1', '15.84615385', '3', '1.1538', '2']
package org . apache . camel . language . bean ; import org . apache . camel . Exchange ; import org . apache . camel . RuntimeExpressionException ; public class RuntimeBeanExpressionException extends RuntimeExpressionException { private final Exchange exchange ; private final String bean ; private final String method ; public RuntimeBeanExpressionException ( Exchange exchange , String bean , String method , Throwable e ) { super ( "Failed to invoke method: " + method + " on " + bean + " due to: " + e , e ) ; this . exchange = exchange ; this . bean = bean ; this . method = method ; } public String getBean ( ) { return bean ; } public Exchange getExchange ( ) { return exchange ; } public String getMethod ( ) { return method ; } } 	0	['4', '6', '0', '3', '9', '0', '1', '2', '4', '0.666666667', '45', '1', '1', '0.85', '0.4375', '0', '0', '9.5', '1', '0.75', '0']
package org . apache . camel . component . log ; import org . apache . camel . processor . interceptor . ExchangeFormatter ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . util . ObjectHelper ; public class LogFormatter implements ExchangeFormatter { private boolean showExchangeId ; private boolean showProperties ; private boolean showHeaders ; private boolean showBodyType = true ; private boolean showBody = true ; private boolean showOut ; private boolean showAll ; private boolean multiline ; public Object format ( Exchange exchange ) { Message in = exchange . getIn ( ) ; StringBuilder sb = new StringBuilder ( "" ) ; if ( showAll || showExchangeId ) { if ( multiline ) sb . append ( '\n' ) ; sb . append ( ", Id:" ) . append ( exchange . getExchangeId ( ) ) ; } if ( showAll || showProperties ) { if ( multiline ) sb . append ( '\n' ) ; sb . append ( ", Properties:" ) . append ( exchange . getProperties ( ) ) ; } if ( showAll || showHeaders ) { if ( multiline ) sb . append ( '\n' ) ; sb . append ( ", Headers:" ) . append ( in . getHeaders ( ) ) ; } if ( showAll || showBodyType ) { if ( multiline ) sb . append ( '\n' ) ; sb . append ( ", BodyType:" ) . append ( getBodyTypeAsString ( in ) ) ; } if ( showAll || showBody ) { if ( multiline ) sb . append ( '\n' ) ; sb . append ( ", Body:" ) . append ( getBodyAsString ( in ) ) ; } Message out = exchange . getOut ( false ) ; if ( showAll || showOut ) { if ( out != null ) { if ( showAll || showHeaders ) { if ( multiline ) sb . append ( '\n' ) ; sb . append ( ", OutHeaders:" ) . append ( out . getHeaders ( ) ) ; } if ( showAll || showBodyType ) { if ( multiline ) sb . append ( '\n' ) ; sb . append ( ", OutBodyType:" ) . append ( getBodyTypeAsString ( out ) ) ; } if ( showAll || showBody ) { if ( multiline ) sb . append ( '\n' ) ; sb . append ( ", OutBody:" ) . append ( getBodyAsString ( out ) ) ; } } else { if ( multiline ) sb . append ( '\n' ) ; sb . append ( ", Out: null" ) ; } } return "Exchange[" + ( multiline ? sb . append ( ']' ) . toString ( ) : sb . toString ( ) . substring ( 2 ) + "]" ) ; } public boolean isShowExchangeId ( ) { return showExchangeId ; } public void setShowExchangeId ( boolean showExchangeId ) { this . showExchangeId = showExchangeId ; } public boolean isShowProperties ( ) { return showProperties ; } public void setShowProperties ( boolean showProperties ) { this . showProperties = showProperties ; } public boolean isShowHeaders ( ) { return showHeaders ; } public void setShowHeaders ( boolean showHeaders ) { this . showHeaders = showHeaders ; } public boolean isShowBodyType ( ) { return showBodyType ; } public void setShowBodyType ( boolean showBodyType ) { this . showBodyType = showBodyType ; } public boolean isShowBody ( ) { return showBody ; } public void setShowBody ( boolean showBody ) { this . showBody = showBody ; } public boolean isShowOut ( ) { return showOut ; } public void setShowOut ( boolean showOut ) { this . showOut = showOut ; } public boolean isShowAll ( ) { return showAll ; } public void setShowAll ( boolean showAll ) { this . showAll = showAll ; } public boolean isMultiline ( ) { return multiline ; } public void setMultiline ( boolean multiline ) { this . multiline = multiline ; } protected Object getBodyAsString ( Message message ) { Object answer = message . getBody ( String . class ) ; if ( answer == null ) { answer = message . getBody ( ) ; } return answer ; } protected Object getBodyTypeAsString ( Message message ) { String answer = ObjectHelper . className ( message . getBody ( ) ) ; if ( answer . startsWith ( "java.lang." ) ) { return answer . substring ( 10 ) ; } return answer ; } } 	1	['20', '1', '0', '5', '37', '132', '1', '4', '18', '0.881578947', '341', '1', '0', '0', '0.3875', '0', '0', '15.65', '30', '2.5', '2']
package org . apache . camel . spi ; import org . apache . camel . Processor ; public interface Policy < E > { Processor wrap ( Processor processor ) ; } 	0	['1', '1', '0', '5', '1', '0', '4', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . processor . idempotent . IdempotentConsumer ; import org . apache . camel . processor . idempotent . MessageIdRepository ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "idempotentConsumer" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class IdempotentConsumerType extends ExpressionNode { @ XmlAttribute private String messageIdRepositoryRef ; @ XmlTransient private MessageIdRepository messageIdRepository ; public IdempotentConsumerType ( ) { } public IdempotentConsumerType ( Expression messageIdExpression , MessageIdRepository messageIdRepository ) { super ( messageIdExpression ) ; this . messageIdRepository = messageIdRepository ; } @ Override public String toString ( ) { return "IdempotentConsumer[ " + getExpression ( ) + " -> " + getOutputs ( ) + "]" ; } @ Override public String getShortName ( ) { return "idempotentConsumer" ; } public String getMessageIdRepositoryRef ( ) { return messageIdRepositoryRef ; } public void setMessageIdRepositoryRef ( String messageIdRepositoryRef ) { this . messageIdRepositoryRef = messageIdRepositoryRef ; } public MessageIdRepository getMessageIdRepository ( ) { return messageIdRepository ; } public void setMessageIdRepository ( MessageIdRepository messageIdRepository ) { this . messageIdRepository = messageIdRepository ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { Processor childProcessor = routeContext . createProcessor ( this ) ; MessageIdRepository messageIdRepository = resolveMessageIdRepository ( routeContext ) ; return new IdempotentConsumer ( getExpression ( ) . createExpression ( routeContext ) , messageIdRepository , childProcessor ) ; } public MessageIdRepository resolveMessageIdRepository ( RouteContext routeContext ) { if ( messageIdRepository == null ) { messageIdRepository = routeContext . lookup ( messageIdRepositoryRef , MessageIdRepository . class ) ; } return messageIdRepository ; } } 	1	['10', '4', '0', '8', '22', '27', '1', '8', '10', '0.611111111', '87', '1', '1', '0.951807229', '0.32', '2', '3', '7.5', '2', '0.9', '3']
package org . apache . camel . spi ; import java . util . Map ; public interface NamespaceAware { void setNamespaces ( Map < String , String > namespaces ) ; } 	0	['1', '1', '0', '6', '1', '0', '6', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel ; import java . util . List ; public interface Routes { CamelContext getContext ( ) ; void setContext ( CamelContext context ) ; List < Route > getRouteList ( ) throws Exception ; } 	1	['3', '1', '0', '5', '3', '3', '5', '1', '3', '2', '3', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '1']
package org . apache . camel . model . dataformat ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . spi . DataFormat ; @ XmlRootElement ( name = "xstream" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class XStreamDataFormat extends DataFormatType { @ XmlAttribute ( required = false ) private Boolean prettyPrint ; public XStreamDataFormat ( ) { super ( "org.apache.camel.dataformat.xstream.XStreamDataFormat" ) ; } public Boolean getPrettyPrint ( ) { return prettyPrint ; } public void setPrettyPrint ( Boolean prettyPrint ) { this . prettyPrint = prettyPrint ; } } 	0	['3', '3', '0', '2', '4', '1', '1', '1', '3', '0.5', '15', '1', '0', '0.818181818', '0.666666667', '0', '0', '3.666666667', '1', '0.6667', '0']
package org . apache . camel . processor . interceptor ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . spi . UnitOfWork ; import org . apache . camel . util . ObjectHelper ; public class TraceFormatter { private boolean showBreadCrumb = true ; private boolean showNode = true ; private boolean showExchangeId ; private boolean showProperties = true ; private boolean showHeaders = true ; private boolean showBody = true ; private boolean showBodyType = true ; public Object format ( TraceInterceptor interceptor , Exchange exchange ) { Message in = exchange . getIn ( ) ; Throwable exception = exchange . getException ( ) ; return ( showBreadCrumb ? getBreadCrumbID ( exchange ) + " " : "" ) + "-> " + getNodeMessage ( interceptor ) + " " + ( showNode ? interceptor . getNode ( ) + " " : "" ) + exchange . getPattern ( ) + ( showExchangeId ? " Id: " + exchange . getExchangeId ( ) : "" ) + ( showProperties ? " Properties:" + exchange . getProperties ( ) : "" ) + ( showHeaders ? " Headers:" + in . getHeaders ( ) : "" ) + ( showBodyType ? " BodyType:" + getBodyTypeAsString ( in ) : "" ) + ( showBody ? " Body:" + getBodyAsString ( in ) : "" ) + ( exception != null ? " Exception: " + exception : "" ) ; } public boolean isShowBody ( ) { return showBody ; } public void setShowBody ( boolean showBody ) { this . showBody = showBody ; } public boolean isShowBodyType ( ) { return showBodyType ; } public void setShowBodyType ( boolean showBodyType ) { this . showBodyType = showBodyType ; } public boolean isShowBreadCrumb ( ) { return showBreadCrumb ; } public void setShowBreadCrumb ( boolean showBreadCrumb ) { this . showBreadCrumb = showBreadCrumb ; } public boolean isShowExchangeId ( ) { return showExchangeId ; } public void setShowExchangeId ( boolean showExchangeId ) { this . showExchangeId = showExchangeId ; } public boolean isShowHeaders ( ) { return showHeaders ; } public void setShowHeaders ( boolean showHeaders ) { this . showHeaders = showHeaders ; } public boolean isShowProperties ( ) { return showProperties ; } public void setShowProperties ( boolean showProperties ) { this . showProperties = showProperties ; } public boolean isShowNode ( ) { return showNode ; } public void setShowNode ( boolean showNode ) { this . showNode = showNode ; } protected Object getBreadCrumbID ( Exchange exchange ) { UnitOfWork unitOfWork = exchange . getUnitOfWork ( ) ; return unitOfWork . getId ( ) ; } protected Object getBodyAsString ( Message in ) { Object answer = in . getBody ( String . class ) ; if ( answer == null ) { answer = in . getBody ( ) ; } return answer ; } protected Object getBodyTypeAsString ( Message message ) { String answer = ObjectHelper . className ( message . getBody ( ) ) ; if ( answer . startsWith ( "java.lang." ) ) { return answer . substring ( 10 ) ; } return answer ; } protected String getNodeMessage ( TraceInterceptor interceptor ) { return interceptor . getNode ( ) . idOrCreate ( ) ; } } 	1	['20', '1', '0', '9', '40', '122', '3', '7', '16', '0.84962406', '275', '1', '0', '0', '0.33', '0', '0', '12.4', '9', '1.45', '3']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlValue ; @ XmlRootElement ( name = "description" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class Description { @ XmlAttribute ( required = false ) private String lang ; @ XmlValue private String text ; public String getLang ( ) { return lang ; } public void setLang ( String lang ) { this . lang = lang ; } public String getText ( ) { return text ; } public void setText ( String text ) { this . text = text ; } } 	0	['5', '1', '0', '1', '6', '6', '1', '0', '5', '0.75', '24', '1', '0', '0', '0.7', '0', '0', '3.4', '1', '0.8', '0']
package org . apache . camel . component . bean ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import org . apache . camel . Endpoint ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Producer ; public class CamelInvocationHandler implements InvocationHandler { private final Endpoint endpoint ; private final Producer producer ; public CamelInvocationHandler ( Endpoint endpoint , Producer producer ) { this . endpoint = endpoint ; this . producer = producer ; } public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { BeanInvocation invocation = new BeanInvocation ( method , args ) ; BeanExchange exchange = new BeanExchange ( endpoint . getCamelContext ( ) , ExchangePattern . InOut ) ; exchange . setInvocation ( invocation ) ; producer . process ( exchange ) ; Throwable fault = exchange . getException ( ) ; if ( fault != null ) { throw new InvocationTargetException ( fault ) ; } return exchange . getOut ( true ) . getBody ( ) ; } } 	1	['2', '1', '0', '10', '12', '0', '2', '8', '2', '0', '49', '1', '2', '0', '0.583333333', '0', '0', '22.5', '1', '0.5', '2']
package org . apache . camel . component . validator . jing ; import java . io . IOException ; import java . io . InputStream ; import javax . xml . XMLConstants ; import javax . xml . transform . Source ; import javax . xml . transform . sax . SAXSource ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; import com . thaiopensource . relaxng . SchemaFactory ; import com . thaiopensource . util . PropertyMap ; import com . thaiopensource . util . PropertyMapBuilder ; import com . thaiopensource . validate . IncorrectSchemaException ; import com . thaiopensource . validate . Schema ; import com . thaiopensource . validate . ValidateProperty ; import com . thaiopensource . validate . Validator ; import com . thaiopensource . xml . sax . Jaxp11XMLReaderCreator ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . processor . validation . DefaultValidationErrorHandler ; import org . apache . camel . util . ExchangeHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . core . io . Resource ; public class JingValidator implements Processor { private static final transient Log LOG = LogFactory . getLog ( JingValidator . class ) ; private Schema schema ; private SchemaFactory schemaFactory ; private String schemaNamespace = XMLConstants . RELAXNG_NS_URI ; private Resource schemaResource ; private InputSource inputSource ; private boolean compactSyntax ; public void process ( Exchange exchange ) throws Exception { Jaxp11XMLReaderCreator xmlCreator = new Jaxp11XMLReaderCreator ( ) ; DefaultValidationErrorHandler errorHandler = new DefaultValidationErrorHandler ( ) ; PropertyMapBuilder mapBuilder = new PropertyMapBuilder ( ) ; mapBuilder . put ( ValidateProperty . XML_READER_CREATOR , xmlCreator ) ; mapBuilder . put ( ValidateProperty . ERROR_HANDLER , errorHandler ) ; PropertyMap propertyMap = mapBuilder . toPropertyMap ( ) ; Validator validator = getSchema ( ) . createValidator ( propertyMap ) ; Message in = exchange . getIn ( ) ; SAXSource saxSource = in . getBody ( SAXSource . class ) ; if ( saxSource == null ) { Source source = ExchangeHelper . getMandatoryInBody ( exchange , Source . class ) ; saxSource = ExchangeHelper . convertToMandatoryType ( exchange , SAXSource . class , source ) ; } InputSource bodyInput = saxSource . getInputSource ( ) ; XMLReader reader = xmlCreator . createXMLReader ( ) ; reader . setContentHandler ( validator . getContentHandler ( ) ) ; reader . setDTDHandler ( validator . getDTDHandler ( ) ) ; reader . setErrorHandler ( errorHandler ) ; reader . parse ( bodyInput ) ; errorHandler . handleErrors ( exchange , schema ) ; } public Schema getSchema ( ) throws IOException , IncorrectSchemaException , SAXException { if ( schema == null ) { SchemaFactory factory = getSchemaFactory ( ) ; schema = factory . createSchema ( getInputSource ( ) ) ; } return schema ; } public void setSchema ( Schema schema ) { this . schema = schema ; } public InputSource getInputSource ( ) throws IOException { if ( inputSource == null ) { Resource resource = getSchemaResource ( ) ; if ( resource == null ) { throw new IllegalArgumentException ( "No schemaResource or inputSource specified" ) ; } else { InputStream inputStream = resource . getInputStream ( ) ; if ( inputStream == null ) { throw new IllegalArgumentException ( "No inputStream available for: " + resource ) ; } inputSource = new InputSource ( inputStream ) ; } } return inputSource ; } public void setInputSource ( InputSource inputSource ) { this . inputSource = inputSource ; } public SchemaFactory getSchemaFactory ( ) { if ( schemaFactory == null ) { schemaFactory = new SchemaFactory ( ) ; schemaFactory . setCompactSyntax ( compactSyntax ) ; schemaFactory . setXMLReaderCreator ( new Jaxp11XMLReaderCreator ( ) ) ; } return schemaFactory ; } public void setSchemaFactory ( SchemaFactory schemaFactory ) { this . schemaFactory = schemaFactory ; } public Resource getSchemaResource ( ) { return schemaResource ; } public void setSchemaResource ( Resource schemaResource ) { this . schemaResource = schemaResource ; } public String getSchemaNamespace ( ) { return schemaNamespace ; } public void setSchemaNamespace ( String schemaNamespace ) { this . schemaNamespace = schemaNamespace ; } public boolean isCompactSyntax ( ) { return compactSyntax ; } public void setCompactSyntax ( boolean compactSyntax ) { this . compactSyntax = compactSyntax ; } } 	0	['15', '1', '0', '22', '47', '81', '2', '20', '14', '0.867346939', '218', '1', '0', '0', '0.1875', '0', '0', '13.06666667', '2', '0.9333', '0']
package org . apache . camel ; @ Deprecated public class InvalidHeaderTypeException extends RuntimeCamelException { private static final long serialVersionUID = - 8417806626073055262L ; private final Object headerValue ; public InvalidHeaderTypeException ( Throwable cause , Object headerValue ) { super ( cause . getMessage ( ) + " headerValue is: " + headerValue + " of type: " + typeName ( headerValue ) , cause ) ; this . headerValue = headerValue ; } public InvalidHeaderTypeException ( String message , Object headerValue ) { super ( message ) ; this . headerValue = headerValue ; } public Object getHeaderValue ( ) { return headerValue ; } protected static String typeName ( Object headerValue ) { return ( headerValue != null ) ? headerValue . getClass ( ) . getName ( ) : "null" ; } } 	1	['4', '5', '0', '1', '13', '0', '0', '1', '3', '0.833333333', '47', '1', '0', '0.894736842', '0.5', '0', '0', '10.25', '2', '0.75', '1']
package org . apache . camel ; public class NoTypeConversionAvailableException extends RuntimeCamelException { private final Object value ; private final Class type ; public NoTypeConversionAvailableException ( Object value , Class type ) { super ( "No type converter available to convert from type: " + ( value != null ? value . getClass ( ) : null ) + " to the required type " + type . getName ( ) + " with value " + value ) ; this . value = value ; this . type = type ; } public Object getValue ( ) { return value ; } public Class getType ( ) { return type ; } public Class getFromType ( ) { if ( value != null ) { return value . getClass ( ) ; } else { return null ; } } } 	0	['4', '5', '0', '2', '11', '0', '1', '1', '4', '0.5', '52', '1', '0', '0.85', '0.5', '0', '0', '11.5', '2', '1', '0']
package org . apache . camel ; import java . util . Map ; import org . apache . camel . spi . UnitOfWork ; public interface Exchange { ExchangePattern getPattern ( ) ; void setPattern ( ExchangePattern pattern ) ; Object getProperty ( String name ) ; < T > T getProperty ( String name , Class < T > type ) ; void setProperty ( String name , Object value ) ; Object removeProperty ( String name ) ; Map < String , Object > getProperties ( ) ; Message getIn ( ) ; void setIn ( Message in ) ; Message getOut ( ) ; Message getOut ( boolean lazyCreate ) ; void setOut ( Message out ) ; Message getFault ( ) ; Message getFault ( boolean lazyCreate ) ; Throwable getException ( ) ; void setException ( Throwable e ) ; boolean isFailed ( ) ; boolean isTransacted ( ) ; CamelContext getContext ( ) ; Exchange newInstance ( ) ; Exchange copy ( ) ; void copyFrom ( Exchange source ) ; UnitOfWork getUnitOfWork ( ) ; void setUnitOfWork ( UnitOfWork unitOfWork ) ; String getExchangeId ( ) ; void setExchangeId ( String id ) ; } 	1	['26', '1', '0', '389', '26', '325', '387', '4', '26', '2', '26', '0', '0', '0', '0.157692308', '0', '0', '0', '1', '1', '4']
package org . apache . camel . component . spring . integration . adapter ; import org . apache . camel . CamelContext ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . springframework . integration . handler . MessageHandler ; public abstract class AbstractCamelAdapter implements MessageHandler { private CamelContext camelContext ; private String camelEndpointUri ; private volatile boolean expectReply = true ; public void setCamelContext ( CamelContext context ) { camelContext = context ; } public CamelContext getCamelContext ( ) { return camelContext ; } public String getCamelEndpointUri ( ) { return camelEndpointUri ; } public void setCamelEndpointUri ( String uri ) { camelEndpointUri = uri ; } public void setExpectReply ( boolean expectReply ) { this . expectReply = expectReply ; } public boolean isExpectReply ( ) { return expectReply ; } } 	0	['7', '1', '2', '4', '8', '11', '2', '2', '7', '0.777777778', '37', '1', '1', '0', '0.357142857', '0', '0', '3.857142857', '1', '0.8571', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . processor . RedeliveryPolicy ; @ XmlRootElement ( name = "redeliveryPolicy" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class RedeliveryPolicyType { private Integer maximumRedeliveries ; private Long initialRedeliveryDelay ; private Double backOffMultiplier ; private Boolean useExponentialBackOff ; private Double collisionAvoidanceFactor ; private Boolean useCollisionAvoidance ; public RedeliveryPolicy createRedeliveryPolicy ( RedeliveryPolicy parentPolicy ) { RedeliveryPolicy answer = parentPolicy . copy ( ) ; if ( maximumRedeliveries != null ) { answer . setMaximumRedeliveries ( maximumRedeliveries ) ; } if ( initialRedeliveryDelay != null ) { answer . setInitialRedeliveryDelay ( initialRedeliveryDelay ) ; } if ( backOffMultiplier != null ) { answer . setBackOffMultiplier ( backOffMultiplier ) ; } if ( useExponentialBackOff != null ) { answer . setUseExponentialBackOff ( useExponentialBackOff ) ; } if ( collisionAvoidanceFactor != null ) { answer . setCollisionAvoidanceFactor ( collisionAvoidanceFactor ) ; } if ( useCollisionAvoidance != null ) { answer . setUseCollisionAvoidance ( useCollisionAvoidance ) ; } return answer ; } public String toString ( ) { return "RedeliveryPolicy[maxRedeliveries: " + maximumRedeliveries + "]" ; } public RedeliveryPolicyType backOffMultiplier ( double backOffMultiplier ) { setBackOffMultiplier ( backOffMultiplier ) ; return this ; } public RedeliveryPolicyType collisionAvoidancePercent ( double collisionAvoidancePercent ) { setCollisionAvoidanceFactor ( collisionAvoidancePercent * 0.01d ) ; return this ; } public RedeliveryPolicyType collisionAvoidanceFactor ( double collisionAvoidanceFactor ) { setCollisionAvoidanceFactor ( collisionAvoidanceFactor ) ; return this ; } public RedeliveryPolicyType initialRedeliveryDelay ( long initialRedeliveryDelay ) { setInitialRedeliveryDelay ( initialRedeliveryDelay ) ; return this ; } public RedeliveryPolicyType maximumRedeliveries ( int maximumRedeliveries ) { setMaximumRedeliveries ( maximumRedeliveries ) ; return this ; } public RedeliveryPolicyType useCollisionAvoidance ( ) { setUseCollisionAvoidance ( Boolean . TRUE ) ; return this ; } public RedeliveryPolicyType useExponentialBackOff ( ) { setUseExponentialBackOff ( Boolean . TRUE ) ; return this ; } public Double getBackOffMultiplier ( ) { return backOffMultiplier ; } public void setBackOffMultiplier ( Double backOffMultiplier ) { this . backOffMultiplier = backOffMultiplier ; } public Double getCollisionAvoidanceFactor ( ) { return collisionAvoidanceFactor ; } public void setCollisionAvoidanceFactor ( Double collisionAvoidanceFactor ) { this . collisionAvoidanceFactor = collisionAvoidanceFactor ; } public Long getInitialRedeliveryDelay ( ) { return initialRedeliveryDelay ; } public void setInitialRedeliveryDelay ( Long initialRedeliveryDelay ) { this . initialRedeliveryDelay = initialRedeliveryDelay ; } public Integer getMaximumRedeliveries ( ) { return maximumRedeliveries ; } public void setMaximumRedeliveries ( Integer maximumRedeliveries ) { this . maximumRedeliveries = maximumRedeliveries ; } public Boolean getUseCollisionAvoidance ( ) { return useCollisionAvoidance ; } public void setUseCollisionAvoidance ( Boolean useCollisionAvoidance ) { this . useCollisionAvoidance = useCollisionAvoidance ; } public Boolean getUseExponentialBackOff ( ) { return useExponentialBackOff ; } public void setUseExponentialBackOff ( Boolean useExponentialBackOff ) { this . useExponentialBackOff = useExponentialBackOff ; } } 	1	['22', '1', '0', '2', '41', '189', '1', '1', '22', '0.841269841', '180', '1', '0', '0', '0.171717172', '0', '0', '6.909090909', '7', '1.2273', '2']
package org . apache . camel ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . PARAMETER } ) public @ interface Headers { } 	0	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . builder ; import org . apache . camel . Processor ; import org . apache . camel . processor . Logger ; import org . apache . camel . processor . LoggingErrorHandler ; import org . apache . camel . processor . LoggingLevel ; import org . apache . camel . spi . RouteContext ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class LoggingErrorHandlerBuilder extends ErrorHandlerBuilderSupport { private Log log = LogFactory . getLog ( Logger . class ) ; private LoggingLevel level = LoggingLevel . INFO ; public LoggingErrorHandlerBuilder ( ) { } public LoggingErrorHandlerBuilder ( Log log ) { this . log = log ; } public LoggingErrorHandlerBuilder ( Log log , LoggingLevel level ) { this . log = log ; this . level = level ; } public ErrorHandlerBuilder copy ( ) { LoggingErrorHandlerBuilder answer = new LoggingErrorHandlerBuilder ( ) ; answer . setLog ( getLog ( ) ) ; answer . setLevel ( getLevel ( ) ) ; return answer ; } public Processor createErrorHandler ( RouteContext routeContext , Processor processor ) { LoggingErrorHandler handler = new LoggingErrorHandler ( processor , log , level ) ; configure ( handler ) ; return handler ; } public LoggingLevel getLevel ( ) { return level ; } public void setLevel ( LoggingLevel level ) { this . level = level ; } public Log getLog ( ) { return log ; } public void setLog ( Log log ) { this . log = log ; } } 	1	['9', '2', '0', '10', '13', '0', '1', '9', '9', '0.25', '92', '1', '1', '0.333333333', '0.355555556', '0', '0', '9', '1', '0.6667', '2']
package org . apache . camel . spring . handler ; import org . w3c . dom . Element ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . xml . ParserContext ; import org . springframework . util . xml . DomUtils ; public class ScriptDefinitionParser extends LazyLoadingBeanDefinitionParser { private final String scriptEngineName ; public ScriptDefinitionParser ( String scriptEngineName ) { super ( "org.apache.camel.builder.script.ScriptBuilder" , "camel-script" ) ; this . scriptEngineName = scriptEngineName ; } @ Override protected void doParse ( Element element , ParserContext parserContext , BeanDefinitionBuilder builder ) { String engine = scriptEngineName ; if ( engine == null ) { engine = element . getAttribute ( "language" ) ; } builder . addConstructorArgValue ( engine ) ; super . doParse ( element , parserContext , builder ) ; String scriptText = DomUtils . getTextValue ( element ) . trim ( ) ; if ( scriptText . length ( ) > 0 ) { builder . addPropertyValue ( "scriptText" , scriptText ) ; } } } 	0	['2', '2', '0', '5', '10', '0', '1', '4', '1', '0', '42', '1', '0', '0.875', '0.6', '0', '0', '19.5', '3', '1.5', '0']
package org . apache . camel . impl ; import java . lang . reflect . ParameterizedType ; import java . lang . reflect . Type ; import java . util . Map ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . ScheduledThreadPoolExecutor ; import org . apache . camel . CamelContext ; import org . apache . camel . CamelContextAware ; import org . apache . camel . Component ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . PollingConsumer ; import org . apache . camel . util . ObjectHelper ; public abstract class DefaultEndpoint < E extends Exchange > implements Endpoint < E > , CamelContextAware { private String endpointUri ; private CamelContext camelContext ; private Component component ; private ScheduledExecutorService executorService ; private ExchangePattern exchangePattern = ExchangePattern . InOnly ; protected DefaultEndpoint ( String endpointUri , Component component ) { this ( endpointUri , component . getCamelContext ( ) ) ; this . component = component ; } protected DefaultEndpoint ( String endpointUri , CamelContext camelContext ) { this ( endpointUri ) ; this . camelContext = camelContext ; } protected DefaultEndpoint ( String endpointUri ) { this . setEndpointUri ( endpointUri ) ; } protected DefaultEndpoint ( ) { } public int hashCode ( ) { return getEndpointUri ( ) . hashCode ( ) * 37 + 1 ; } @ Override public boolean equals ( Object object ) { if ( object instanceof DefaultEndpoint ) { DefaultEndpoint that = ( DefaultEndpoint ) object ; return ObjectHelper . equal ( this . getEndpointUri ( ) , that . getEndpointUri ( ) ) ; } return false ; } @ Override public String toString ( ) { return "Endpoint[" + getEndpointUri ( ) + "]" ; } public String getEndpointUri ( ) { if ( endpointUri == null ) { endpointUri = createEndpointUri ( ) ; if ( endpointUri == null ) { throw new IllegalArgumentException ( "endpointUri is not specified and " + getClass ( ) . getName ( ) + " does not implement createEndpointUri() to create a default value" ) ; } } return endpointUri ; } public CamelContext getCamelContext ( ) { return camelContext ; } public Component getComponent ( ) { return component ; } public void setCamelContext ( CamelContext camelContext ) { this . camelContext = camelContext ; } public synchronized ScheduledExecutorService getExecutorService ( ) { if ( executorService == null ) { Component c = getComponent ( ) ; if ( c != null && c instanceof DefaultComponent ) { DefaultComponent dc = ( DefaultComponent ) c ; executorService = dc . getExecutorService ( ) ; } if ( executorService == null ) { executorService = createExecutorService ( ) ; } } return executorService ; } public synchronized void setExecutorService ( ScheduledExecutorService executorService ) { this . executorService = executorService ; } public PollingConsumer < E > createPollingConsumer ( ) throws Exception { return new EventDrivenPollingConsumer < E > ( this ) ; } public E convertTo ( Class < E > type , Exchange exchange ) { if ( type . isInstance ( exchange ) ) { return type . cast ( exchange ) ; } return getCamelContext ( ) . getExchangeConverter ( ) . convertTo ( type , exchange ) ; } public E createExchange ( Exchange exchange ) { Class < E > exchangeType = getExchangeType ( ) ; if ( exchangeType != null ) { if ( exchangeType . isInstance ( exchange ) ) { return exchangeType . cast ( exchange ) ; } } E answer = createExchange ( ) ; answer . copyFrom ( exchange ) ; return answer ; } public Class < E > getExchangeType ( ) { Type type = getClass ( ) . getGenericSuperclass ( ) ; if ( type instanceof ParameterizedType ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ; Type [ ] arguments = parameterizedType . getActualTypeArguments ( ) ; if ( arguments . length > 0 ) { Type argumentType = arguments [ 0 ] ; if ( argumentType instanceof Class ) { return ( Class < E > ) argumentType ; } } } return null ; } public E createExchange ( ) { return createExchange ( getExchangePattern ( ) ) ; } public E createExchange ( ExchangePattern pattern ) { return ( E ) new DefaultExchange ( getCamelContext ( ) , pattern ) ; } public ExchangePattern getExchangePattern ( ) { return exchangePattern ; } public void setExchangePattern ( ExchangePattern exchangePattern ) { this . exchangePattern = exchangePattern ; } protected ScheduledThreadPoolExecutor createExecutorService ( ) { return new ScheduledThreadPoolExecutor ( 10 ) ; } public void configureProperties ( Map options ) { } protected String createEndpointUri ( ) { return null ; } protected void setEndpointUri ( String endpointUri ) { this . endpointUri = endpointUri ; } @ Deprecated public CamelContext getContext ( ) { return getCamelContext ( ) ; } @ Deprecated public void setContext ( CamelContext context ) { setCamelContext ( context ) ; } } 	1	['27', '1', '20', '41', '48', '327', '29', '12', '20', '0.846153846', '278', '1', '3', '0', '0.159259259', '1', '1', '9.111111111', '5', '1.3333', '2']
package org . apache . camel . processor . interceptor ; import org . apache . camel . Exchange ; public class Breakpoint { public void waitForBreakpoint ( Exchange exchange ) { } } 	0	['2', '1', '0', '3', '3', '1', '2', '1', '2', '2', '6', '0', '0', '0', '0.75', '0', '0', '2', '1', '0.5', '0']
package org . apache . camel . processor ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultUnitOfWork ; public final class UnitOfWorkProcessor extends DelegateAsyncProcessor { public UnitOfWorkProcessor ( AsyncProcessor processor ) { super ( processor ) ; } public boolean process ( final Exchange exchange , final AsyncCallback callback ) { if ( exchange . getUnitOfWork ( ) == null ) { exchange . setUnitOfWork ( new DefaultUnitOfWork ( ) ) ; return processor . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { callback . done ( sync ) ; exchange . getUnitOfWork ( ) . done ( exchange ) ; exchange . setUnitOfWork ( null ) ; } } ) ; } else { return processor . process ( exchange , callback ) ; } } } 	1	['2', '3', '0', '8', '8', '1', '2', '7', '2', '2', '31', '0', '0', '0.952380952', '0.625', '0', '0', '14.5', '2', '1', '1']
package org . apache . camel . management ; import java . util . Date ; import java . util . concurrent . atomic . AtomicLong ; import org . springframework . jmx . export . annotation . ManagedAttribute ; import org . springframework . jmx . export . annotation . ManagedOperation ; import org . springframework . jmx . export . annotation . ManagedResource ; @ ManagedResource ( description = "PerformanceCounter" , currencyTimeLimit = 15 ) public class PerformanceCounter extends Counter { private AtomicLong numCompleted = new AtomicLong ( 0L ) ; private double minProcessingTime = - 1.0 ; private double maxProcessingTime ; private double totalProcessingTime ; private Date lastExchangeCompletionTime ; private Date lastExchangeFailureTime ; private Date firstExchangeCompletionTime ; private Date firstExchangeFailureTime ; @ Override @ ManagedOperation ( description = "Reset counters" ) public synchronized void reset ( ) { super . reset ( ) ; numCompleted . set ( 0L ) ; minProcessingTime = - 1.0 ; maxProcessingTime = 0.0 ; totalProcessingTime = 0.0 ; lastExchangeCompletionTime = null ; lastExchangeFailureTime = null ; firstExchangeCompletionTime = null ; firstExchangeFailureTime = null ; } @ ManagedAttribute ( description = "Number of successful exchanges" ) public long getNumCompleted ( ) throws Exception { return numCompleted . get ( ) ; } @ ManagedAttribute ( description = "Number of failed exchanges" ) public long getNumFailed ( ) throws Exception { return numExchanges . get ( ) - numCompleted . get ( ) ; } @ ManagedAttribute ( description = "Min Processing Time [milliseconds]" ) public synchronized double getMinProcessingTimeMillis ( ) throws Exception { return minProcessingTime ; } @ ManagedAttribute ( description = "Mean Processing Time [milliseconds]" ) public synchronized double getMeanProcessingTimeMillis ( ) throws Exception { long count = numCompleted . get ( ) ; return count > 0 ? totalProcessingTime / count : 0.0 ; } @ ManagedAttribute ( description = "Max Processing Time [milliseconds]" ) public synchronized double getMaxProcessingTimeMillis ( ) throws Exception { return maxProcessingTime ; } @ ManagedAttribute ( description = "Total Processing Time [milliseconds]" ) public synchronized double getTotalProcessingTimeMillis ( ) throws Exception { return totalProcessingTime ; } @ ManagedAttribute ( description = "Last Exchange Completed Timestamp" ) public synchronized Date getLastExchangeCompletionTime ( ) { return lastExchangeCompletionTime ; } @ ManagedAttribute ( description = "First Exchange Completed Timestamp" ) public synchronized Date getFirstExchangeCompletionTime ( ) { return firstExchangeCompletionTime ; } @ ManagedAttribute ( description = "Last Exchange Failed Timestamp" ) public synchronized Date getLastExchangeFailureTime ( ) { return lastExchangeFailureTime ; } @ ManagedAttribute ( description = "First Exchange Failed Timestamp" ) public synchronized Date getFirstExchangeFailureTime ( ) { return firstExchangeFailureTime ; } public synchronized void completedExchange ( double time ) { increment ( ) ; numCompleted . incrementAndGet ( ) ; totalProcessingTime += time ; if ( minProcessingTime < 0 || time < minProcessingTime ) { minProcessingTime = time ; } if ( time > maxProcessingTime ) { maxProcessingTime = time ; } Date timestamp = new Date ( ) ; if ( firstExchangeCompletionTime == null ) { firstExchangeCompletionTime = timestamp ; } lastExchangeCompletionTime = timestamp ; } public synchronized void failedExchange ( ) { increment ( ) ; Date timestamp = new Date ( ) ; if ( firstExchangeFailureTime == null ) { firstExchangeFailureTime = timestamp ; } lastExchangeFailureTime = timestamp ; } } 	0	['14', '2', '1', '6', '22', '27', '5', '1', '14', '0.798076923', '176', '1', '0', '0.1875', '0.535714286', '0', '0', '11', '5', '1.2857', '0']
package org . apache . camel . impl ; import java . io . IOException ; import java . io . InputStream ; import java . io . ObjectInput ; import java . io . ObjectOutput ; import java . io . OutputStream ; import org . apache . camel . Exchange ; import org . apache . camel . converter . IOConverter ; import org . apache . camel . spi . DataFormat ; public class SerializationDataFormat implements DataFormat { public void marshal ( Exchange exchange , Object graph , OutputStream stream ) throws IOException { ObjectOutput out = IOConverter . toObjectOutput ( stream ) ; out . writeObject ( graph ) ; out . flush ( ) ; } public Object unmarshal ( Exchange exchange , InputStream stream ) throws IOException , ClassNotFoundException { ObjectInput in = IOConverter . toObjectInput ( stream ) ; return in . readObject ( ) ; } } 	1	['3', '1', '0', '4', '9', '3', '1', '3', '3', '2', '21', '0', '0', '0', '0.533333333', '0', '0', '6', '1', '0.6667', '1']
package org . apache . camel . processor . interceptor ; import org . apache . camel . Exchange ; public interface ExchangeFormatter { Object format ( Exchange exchange ) ; } 	0	['1', '1', '0', '6', '1', '0', '5', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . impl ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Intercept ; import org . apache . camel . NoSuchEndpointException ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . impl . converter . AsyncProcessorTypeConverter ; import org . apache . camel . model . FromType ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . model . RouteType ; import org . apache . camel . processor . Interceptor ; import org . apache . camel . processor . Pipeline ; import org . apache . camel . processor . ProceedProcessor ; import org . apache . camel . processor . UnitOfWorkProcessor ; import org . apache . camel . spi . ErrorHandlerWrappingStrategy ; import org . apache . camel . spi . InterceptStrategy ; import org . apache . camel . spi . RouteContext ; public class DefaultRouteContext implements RouteContext { private RouteType route ; private FromType from ; private Collection < Route > routes ; private Endpoint < ? extends Exchange > endpoint ; private List < Processor > eventDrivenProcessors = new ArrayList < Processor > ( ) ; private Interceptor lastInterceptor ; private CamelContext camelContext ; private List < InterceptStrategy > interceptStrategies = new ArrayList < InterceptStrategy > ( ) ; private ErrorHandlerWrappingStrategy errorHandlerWrappingStrategy ; private boolean routeAdded ; public DefaultRouteContext ( RouteType route , FromType from , Collection < Route > routes ) { this . route = route ; this . from = from ; this . routes = routes ; } public DefaultRouteContext ( CamelContext camelContext ) { this . camelContext = camelContext ; routes = new ArrayList < Route > ( ) ; route = new RouteType ( "temporary" ) ; } public Endpoint < ? extends Exchange > getEndpoint ( ) { if ( endpoint == null ) { endpoint = from . resolveEndpoint ( this ) ; } return endpoint ; } public FromType getFrom ( ) { return from ; } public RouteType getRoute ( ) { return route ; } public CamelContext getCamelContext ( ) { if ( camelContext == null ) { camelContext = getRoute ( ) . getCamelContext ( ) ; } return camelContext ; } public Processor createProcessor ( ProcessorType node ) throws Exception { return node . createOutputsProcessor ( this ) ; } public Endpoint < ? extends Exchange > resolveEndpoint ( String uri ) { return route . resolveEndpoint ( uri ) ; } public Endpoint < ? extends Exchange > resolveEndpoint ( String uri , String ref ) { Endpoint < ? extends Exchange > endpoint = null ; if ( uri != null ) { endpoint = resolveEndpoint ( uri ) ; if ( endpoint == null ) { throw new NoSuchEndpointException ( uri ) ; } } if ( ref != null ) { endpoint = lookup ( ref , Endpoint . class ) ; if ( endpoint == null ) { throw new NoSuchEndpointException ( "ref:" + ref ) ; } } if ( endpoint == null ) { throw new IllegalArgumentException ( "Either 'uri' or 'ref' must be specified on: " + this ) ; } else { return endpoint ; } } public < T > T lookup ( String name , Class < T > type ) { return getCamelContext ( ) . getRegistry ( ) . lookup ( name , type ) ; } public void commit ( ) { if ( ! eventDrivenProcessors . isEmpty ( ) ) { Processor processor = Pipeline . newInstance ( eventDrivenProcessors ) ; final AsyncProcessor asyncProcessor = AsyncProcessorTypeConverter . convert ( processor ) ; Processor unitOfWorkProcessor = new UnitOfWorkProcessor ( asyncProcessor ) ; Route edcr = new EventDrivenConsumerRoute ( getEndpoint ( ) , unitOfWorkProcessor ) ; edcr . getProperties ( ) . put ( Route . PARENT_PROPERTY , Integer . toHexString ( route . hashCode ( ) ) ) ; if ( route . getGroup ( ) != null ) { edcr . getProperties ( ) . put ( Route . GROUP_PROPERTY , route . getGroup ( ) ) ; } routes . add ( edcr ) ; } } public void addEventDrivenProcessor ( Processor processor ) { eventDrivenProcessors . add ( processor ) ; } public void intercept ( Intercept interceptor ) { lastInterceptor = ( Interceptor ) interceptor ; } public Processor createProceedProcessor ( ) { if ( lastInterceptor == null ) { throw new IllegalArgumentException ( "Cannot proceed() from outside of an interceptor!" ) ; } else { return new ProceedProcessor ( lastInterceptor ) ; } } public List < InterceptStrategy > getInterceptStrategies ( ) { return interceptStrategies ; } public void setInterceptStrategies ( List < InterceptStrategy > interceptStrategies ) { this . interceptStrategies = interceptStrategies ; } public void addInterceptStrategy ( InterceptStrategy interceptStrategy ) { getInterceptStrategies ( ) . add ( interceptStrategy ) ; } public ErrorHandlerWrappingStrategy getErrorHandlerWrappingStrategy ( ) { return errorHandlerWrappingStrategy ; } public void setErrorHandlerWrappingStrategy ( ErrorHandlerWrappingStrategy strategy ) { errorHandlerWrappingStrategy = strategy ; } public boolean isRouteAdded ( ) { return routeAdded ; } public void setIsRouteAdded ( boolean b ) { routeAdded = b ; } } 	1	['21', '1', '0', '22', '49', '160', '3', '20', '21', '0.875', '280', '1', '6', '0', '0.12244898', '0', '0', '11.85714286', '6', '1.381', '1']
package org . apache . camel . processor . idempotent ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ExpressionHelper ; import org . apache . camel . util . ServiceHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class IdempotentConsumer extends ServiceSupport implements Processor { private static final transient Log LOG = LogFactory . getLog ( IdempotentConsumer . class ) ; private Expression < Exchange > messageIdExpression ; private Processor nextProcessor ; private MessageIdRepository messageIdRepository ; public IdempotentConsumer ( Expression < Exchange > messageIdExpression , MessageIdRepository messageIdRepository , Processor nextProcessor ) { this . messageIdExpression = messageIdExpression ; this . messageIdRepository = messageIdRepository ; this . nextProcessor = nextProcessor ; } @ Override public String toString ( ) { return "IdempotentConsumer[expression=" + messageIdExpression + ", repository=" + messageIdRepository + ", processor=" + nextProcessor + "]" ; } public void process ( Exchange exchange ) throws Exception { String messageId = ExpressionHelper . evaluateAsString ( messageIdExpression , exchange ) ; if ( messageId == null ) { throw new NoMessageIdException ( exchange , messageIdExpression ) ; } if ( ! messageIdRepository . contains ( messageId ) ) { nextProcessor . process ( exchange ) ; } else { onDuplicateMessage ( exchange , messageId ) ; } } public Expression < Exchange > getMessageIdExpression ( ) { return messageIdExpression ; } public MessageIdRepository getMessageIdRepository ( ) { return messageIdRepository ; } public Processor getNextProcessor ( ) { return nextProcessor ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( nextProcessor ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( nextProcessor ) ; } protected void onDuplicateMessage ( Exchange exchange , String messageId ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Ignoring duplicate message with id: " + messageId + " for exchange: " + exchange ) ; } } } 	0	['10', '2', '0', '11', '24', '1', '1', '10', '6', '0.638888889', '126', '1', '3', '0.619047619', '0.277777778', '1', '1', '11.2', '2', '0.9', '0']
package org . apache . camel . management ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . processor . DelegateProcessor ; import org . apache . camel . util . AsyncProcessorHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class InstrumentationProcessor extends DelegateProcessor implements AsyncProcessor { private static final transient Log LOG = LogFactory . getLog ( InstrumentationProcessor . class ) ; private PerformanceCounter counter ; public InstrumentationProcessor ( PerformanceCounter counter ) { this . counter = counter ; } public InstrumentationProcessor ( ) { } public void setCounter ( PerformanceCounter counter ) { this . counter = counter ; } public void process ( Exchange exchange ) throws Exception { AsyncProcessorHelper . process ( this , exchange ) ; } public boolean process ( final Exchange exchange , final AsyncCallback callback ) { final long startTime = System . nanoTime ( ) ; if ( processor instanceof AsyncProcessor ) { return ( ( AsyncProcessor ) processor ) . process ( exchange , new AsyncCallback ( ) { public void done ( boolean doneSynchronously ) { if ( counter != null ) { recordTime ( exchange , ( System . nanoTime ( ) - startTime ) / 1000000.0 ) ; } callback . done ( doneSynchronously ) ; } } ) ; } try { processor . process ( exchange ) ; } catch ( Exception e ) { exchange . setException ( e ) ; } if ( counter != null ) { recordTime ( exchange , ( System . nanoTime ( ) - startTime ) / 1000000.0 ) ; } callback . done ( true ) ; return true ; } protected void recordTime ( Exchange exchange , double duration ) { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Recording duration: " + duration + " millis for exchange: " + exchange ) ; } if ( ! exchange . isFailed ( ) && exchange . getException ( ) == null ) { counter . completedExchange ( duration ) ; } else { counter . failedExchange ( ) ; } } } 	1	['8', '3', '0', '12', '28', '6', '3', '10', '5', '0.571428571', '111', '1', '1', '0.807692308', '0.333333333', '0', '0', '12.625', '4', '1.25', '2']
package org . apache . camel . component . jhc ; import java . io . IOException ; import org . apache . camel . AsyncCallback ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . http . HttpEntity ; import org . apache . http . HttpEntityEnclosingRequest ; import org . apache . http . HttpException ; import org . apache . http . HttpRequest ; import org . apache . http . HttpResponse ; import org . apache . http . HttpResponseFactory ; import org . apache . http . HttpStatus ; import org . apache . http . HttpVersion ; import org . apache . http . ProtocolVersion ; import org . apache . http . impl . DefaultHttpResponseFactory ; import org . apache . http . nio . NHttpConnection ; import org . apache . http . nio . protocol . EventListener ; import org . apache . http . params . HttpParams ; import org . apache . http . params . HttpParamsLinker ; import org . apache . http . protocol . HttpContext ; import org . apache . http . protocol . HttpRequestHandler ; public class JhcConsumer extends DefaultConsumer < JhcExchange > { private static final Log LOG = LogFactory . getLog ( JhcConsumer . class ) ; private JhcServerEngine engine ; private MyHandler handler ; public JhcConsumer ( JhcEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; engine = JhcServerEngineFactory . getJhcServerEngine ( endpoint . getParams ( ) , endpoint . getPort ( ) , endpoint . getProtocol ( ) ) ; handler = new MyHandler ( endpoint . getParams ( ) , endpoint . getPath ( ) ) ; } public JhcEndpoint getEndpoint ( ) { return ( JhcEndpoint ) super . getEndpoint ( ) ; } protected void doStart ( ) throws Exception { super . doStart ( ) ; engine . register ( handler . getPath ( ) + "*" , handler ) ; if ( ! engine . isStarted ( ) ) { engine . start ( ) ; } } protected void doStop ( ) throws Exception { engine . unregister ( handler . getPath ( ) + "*" ) ; if ( engine . getReferenceCounter ( ) == 0 ) { engine . stop ( ) ; } super . doStop ( ) ; } class MyHttpRequestHandler implements HttpRequestHandler { public void handle ( HttpRequest httpRequest , HttpResponse httpResponse , HttpContext httpContext ) throws HttpException , IOException { LOG . debug ( "handle" ) ; } } static class EventLogger implements EventListener { public void connectionOpen ( final NHttpConnection conn ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Connection open: " + conn ) ; } } public void connectionTimeout ( final NHttpConnection conn ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Connection timed out: " + conn ) ; } } public void connectionClosed ( final NHttpConnection conn ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Connection closed: " + conn ) ; } } public void fatalIOException ( final IOException ex , final NHttpConnection conn ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "I/O error: " + ex . getMessage ( ) ) ; } } public void fatalProtocolException ( final HttpException ex , final NHttpConnection conn ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "HTTP error: " + ex . getMessage ( ) ) ; } } } class MyHandler implements AsyncHttpRequestHandler { private final HttpParams params ; private final HttpResponseFactory responseFactory ; private final String path ; public MyHandler ( HttpParams params , String path ) { this ( params , path , new DefaultHttpResponseFactory ( ) ) ; } public MyHandler ( HttpParams params , String path , HttpResponseFactory responseFactory ) { this . params = params ; this . path = path ; this . responseFactory = responseFactory ; } public String getPath ( ) { return path ; } public void handle ( final HttpRequest request , final HttpContext context , final AsyncResponseHandler handler ) throws HttpException , IOException { final Exchange exchange = getEndpoint ( ) . createExchange ( ) ; exchange . getIn ( ) . setHeader ( "http.uri" , request . getRequestLine ( ) . getUri ( ) ) ; if ( request instanceof HttpEntityEnclosingRequest ) { exchange . getIn ( ) . setBody ( ( ( HttpEntityEnclosingRequest ) request ) . getEntity ( ) ) ; } getAsyncProcessor ( ) . process ( exchange , new AsyncCallback ( ) { public void done ( boolean doneSynchronously ) { LOG . debug ( "handleExchange" ) ; ProtocolVersion httpVersion = ( HttpVersion ) request . getRequestLine ( ) . getProtocolVersion ( ) ; HttpResponse response = responseFactory . newHttpResponse ( httpVersion , HttpStatus . SC_OK , context ) ; HttpParamsLinker . link ( response , params ) ; HttpEntity entity = exchange . getOut ( ) . getBody ( HttpEntity . class ) ; response . setEntity ( entity ) ; response . setParams ( getEndpoint ( ) . getParams ( ) ) ; try { handler . sendResponse ( response ) ; } catch ( Exception e ) { LOG . info ( e ) ; } } } ) ; } public void handle ( HttpRequest request , HttpResponse response , HttpContext context ) throws HttpException , IOException { } } } 	0	['7', '3', '0', '14', '27', '13', '5', '11', '3', '0.722222222', '95', '1', '2', '0.814814815', '0.388888889', '1', '1', '12.14285714', '1', '0.7143', '0']
package org . apache . camel . impl . converter ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . lang . reflect . Method ; import java . net . URL ; import java . util . Enumeration ; import java . util . HashSet ; import java . util . Set ; import java . util . StringTokenizer ; import static java . lang . reflect . Modifier . isAbstract ; import static java . lang . reflect . Modifier . isPublic ; import static java . lang . reflect . Modifier . isStatic ; import org . apache . camel . Converter ; import org . apache . camel . TypeConverter ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . ResolverUtil ; import org . apache . camel . util . WebSphereResolverUtil ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class AnnotationTypeConverterLoader implements TypeConverterLoader { public static final String META_INF_SERVICES = "META-INF/services/org/apache/camel/TypeConverter" ; private static final transient Log LOG = LogFactory . getLog ( AnnotationTypeConverterLoader . class ) ; private ResolverUtil resolver = new ResolverUtil ( ) ; private Set < Class > visitedClasses = new HashSet < Class > ( ) ; public AnnotationTypeConverterLoader ( ) { if ( WebSphereResolverUtil . isWebSphereClassLoader ( this . getClass ( ) . getClassLoader ( ) ) ) { LOG . info ( "Using WebSphere specific ResolverUtil" ) ; resolver = new WebSphereResolverUtil ( META_INF_SERVICES ) ; } } public void load ( TypeConverterRegistry registry ) throws Exception { String [ ] packageNames = findPackageNames ( ) ; resolver . findAnnotated ( Converter . class , packageNames ) ; Set < Class > classes = resolver . getClasses ( ) ; for ( Class type : classes ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Loading converter class: " + ObjectHelper . name ( type ) ) ; } loadConverterMethods ( registry , type ) ; } } protected String [ ] findPackageNames ( ) throws IOException { Set < String > packages = new HashSet < String > ( ) ; findPackages ( packages , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; findPackages ( packages , getClass ( ) . getClassLoader ( ) ) ; return packages . toArray ( new String [ packages . size ( ) ] ) ; } protected void findPackages ( Set < String > packages , ClassLoader classLoader ) throws IOException { Enumeration < URL > resources = classLoader . getResources ( META_INF_SERVICES ) ; while ( resources . hasMoreElements ( ) ) { URL url = resources . nextElement ( ) ; if ( url != null ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( url . openStream ( ) ) ) ; try { while ( true ) { String line = reader . readLine ( ) ; if ( line == null ) { break ; } line = line . trim ( ) ; if ( line . startsWith ( "#" ) || line . length ( ) == 0 ) { continue ; } tokenize ( packages , line ) ; } } finally { ObjectHelper . close ( reader , null , LOG ) ; } } } } protected void tokenize ( Set < String > packages , String line ) { StringTokenizer iter = new StringTokenizer ( line , "," ) ; while ( iter . hasMoreTokens ( ) ) { String name = iter . nextToken ( ) . trim ( ) ; if ( name . length ( ) > 0 ) { packages . add ( name ) ; } } } protected void loadConverterMethods ( TypeConverterRegistry registry , Class type ) { if ( visitedClasses . contains ( type ) ) { return ; } visitedClasses . add ( type ) ; try { Method [ ] methods = type . getDeclaredMethods ( ) ; CachingInjector injector = null ; for ( Method method : methods ) { Converter annotation = method . getAnnotation ( Converter . class ) ; if ( annotation != null ) { Class < ? > [ ] parameterTypes = method . getParameterTypes ( ) ; if ( parameterTypes == null || parameterTypes . length != 1 ) { LOG . warn ( "Ignoring bad converter on type: " + type . getName ( ) + " method: " + method + " as a converter method should have one parameter" ) ; } else { int modifiers = method . getModifiers ( ) ; if ( isAbstract ( modifiers ) || ! isPublic ( modifiers ) ) { LOG . warn ( "Ignoring bad converter on type: " + type . getName ( ) + " method: " + method + " as a converter method is not a public and concrete method" ) ; } else { Class toType = method . getReturnType ( ) ; if ( toType . equals ( Void . class ) ) { LOG . warn ( "Ignoring bad converter on type: " + type . getName ( ) + " method: " + method + " as a converter method returns a void method" ) ; } else { Class fromType = parameterTypes [ 0 ] ; if ( isStatic ( modifiers ) ) { registerTypeConverter ( registry , method , toType , fromType , new StaticMethodTypeConverter ( method ) ) ; } else { if ( injector == null ) { injector = new CachingInjector ( registry , type ) ; } registerTypeConverter ( registry , method , toType , fromType , new InstanceMethodTypeConverter ( injector , method ) ) ; } } } } } } Class superclass = type . getSuperclass ( ) ; if ( superclass != null && ! superclass . equals ( Object . class ) ) { loadConverterMethods ( registry , superclass ) ; } } catch ( NoClassDefFoundError e ) { LOG . debug ( "Ignoring converter type: " + type . getName ( ) + " as a dependent class could not be found: " + e , e ) ; } } protected void registerTypeConverter ( TypeConverterRegistry registry , Method method , Class toType , Class fromType , TypeConverter typeConverter ) { registry . addTypeConverter ( toType , fromType , typeConverter ) ; } } 	1	['8', '1', '1', '14', '66', '8', '2', '12', '2', '0.75', '380', '0.75', '1', '0', '0.321428571', '0', '0', '46', '11', '2.125', '1']
package org . apache . camel . builder ; public class NoRouteBuilder extends RouteBuilder { private static final NoRouteBuilder INSTANCE = new NoRouteBuilder ( ) ; public static NoRouteBuilder getInstance ( ) { return INSTANCE ; } public void configure ( ) throws Exception { } } 	0	['4', '3', '0', '1', '5', '4', '0', '1', '3', '0.666666667', '16', '1', '1', '0.962264151', '0.666666667', '1', '1', '2.75', '1', '0.5', '0']
package org . apache . camel . builder ; import org . apache . camel . Processor ; import org . apache . camel . model . ExceptionType ; import org . apache . camel . spi . RouteContext ; public interface ErrorHandlerBuilder { ErrorHandlerBuilder copy ( ) ; Processor createErrorHandler ( RouteContext routeContext , Processor processor ) throws Exception ; void addErrorHandlers ( ExceptionType exception ) ; } 	1	['3', '1', '0', '19', '3', '3', '17', '3', '3', '2', '3', '0', '0', '0', '0.5', '0', '0', '0', '1', '1', '1']
package org . apache . camel . impl . converter ; import org . apache . camel . TypeConverter ; public class ToStringTypeConverter implements TypeConverter { public < T > T convertTo ( Class < T > toType , Object value ) { if ( value != null ) { if ( toType . equals ( String . class ) ) { return ( T ) value . toString ( ) ; } } return null ; } } 	0	['2', '1', '0', '2', '5', '1', '1', '1', '2', '2', '16', '0', '0', '0', '0.666666667', '0', '0', '7', '3', '1.5', '0']
package org . apache . camel . model . dataformat ; import java . io . InputStream ; import java . io . OutputStream ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlTransient ; import javax . xml . bind . annotation . XmlType ; import org . apache . camel . Exchange ; import org . apache . camel . model . IdentifiedType ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . spi . RouteContext ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . camel . util . ObjectHelper ; import static org . apache . camel . util . ObjectHelper . notNull ; @ XmlType ( name = "dataFormatType" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class DataFormatType extends IdentifiedType implements DataFormat { @ XmlTransient private DataFormat dataFormat ; @ XmlTransient private String dataFormatTypeName ; public DataFormatType ( ) { } public DataFormatType ( DataFormat dataFormat ) { this . dataFormat = dataFormat ; } protected DataFormatType ( String dataFormatTypeName ) { this . dataFormatTypeName = dataFormatTypeName ; } public static DataFormat getDataFormat ( RouteContext routeContext , DataFormatType type , String ref ) { if ( type == null ) { notNull ( ref , "ref or dataFormatType" ) ; DataFormat dataFormat = routeContext . lookup ( ref , DataFormat . class ) ; if ( dataFormat instanceof DataFormatType ) { type = ( DataFormatType ) dataFormat ; } else { return dataFormat ; } } return type . getDataFormat ( routeContext ) ; } public void marshal ( Exchange exchange , Object graph , OutputStream stream ) throws Exception { ObjectHelper . notNull ( dataFormat , "dataFormat" ) ; dataFormat . marshal ( exchange , graph , stream ) ; } public Object unmarshal ( Exchange exchange , InputStream stream ) throws Exception { ObjectHelper . notNull ( dataFormat , "dataFormat" ) ; return dataFormat . unmarshal ( exchange , stream ) ; } public DataFormat getDataFormat ( RouteContext routeContext ) { if ( dataFormat == null ) { dataFormat = createDataFormat ( routeContext ) ; ObjectHelper . notNull ( dataFormat , "dataFormat" ) ; configureDataFormat ( dataFormat ) ; } return dataFormat ; } protected DataFormat createDataFormat ( RouteContext routeContext ) { if ( dataFormatTypeName != null ) { Class type = ObjectHelper . loadClass ( dataFormatTypeName , getClass ( ) . getClassLoader ( ) ) ; if ( type == null ) { throw new IllegalArgumentException ( "The class " + dataFormatTypeName + " is not on the classpath! Cannot use the dataFormat " + this ) ; } return ( DataFormat ) ObjectHelper . newInstance ( type ) ; } return null ; } protected void configureDataFormat ( DataFormat dataFormat ) { } protected void setProperty ( Object bean , String name , Object value ) { try { IntrospectionSupport . setProperty ( bean , name , value ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Failed to set property " + name + " on " + bean + ". Reason: " + e , e ) ; } } } 	1	['10', '2', '7', '17', '26', '31', '11', '6', '6', '0.666666667', '156', '1', '1', '0.222222222', '0.266666667', '0', '0', '14.4', '3', '1.2', '1']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Processor ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "pipeline" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class PipelineType extends OutputType < ProcessorType > { @ Override public String getShortName ( ) { return "pipeline" ; } public Processor createProcessor ( RouteContext routeContext ) throws Exception { return createOutputsProcessor ( routeContext ) ; } } 	0	['3', '4', '0', '3', '5', '3', '0', '3', '3', '2', '12', '0', '0', '0.987096774', '0.666666667', '1', '2', '3', '1', '0.6667', '0']
package org . apache . camel . impl ; import java . util . HashMap ; import java . util . Map ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . ExchangeProperty ; import org . apache . camel . Message ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . spi . UnitOfWork ; import org . apache . camel . util . UuidGenerator ; public class DefaultExchange implements Exchange { private static final UuidGenerator DEFAULT_ID_GENERATOR = new UuidGenerator ( ) ; protected final CamelContext context ; private Map < String , Object > properties ; private Message in ; private Message out ; private Message fault ; private Throwable exception ; private String exchangeId ; private UnitOfWork unitOfWork ; private ExchangePattern pattern ; public DefaultExchange ( CamelContext context ) { this ( context , ExchangePattern . InOnly ) ; } public DefaultExchange ( CamelContext context , ExchangePattern pattern ) { this . context = context ; this . pattern = pattern ; } public DefaultExchange ( DefaultExchange parent ) { this ( parent . getContext ( ) , parent . getPattern ( ) ) ; this . unitOfWork = parent . getUnitOfWork ( ) ; } @ Override public String toString ( ) { return "Exchange[" + in + "]" ; } public Exchange copy ( ) { Exchange exchange = newInstance ( ) ; exchange . copyFrom ( this ) ; return exchange ; } public void copyFrom ( Exchange exchange ) { if ( exchange == this ) { return ; } setProperties ( safeCopy ( exchange . getProperties ( ) ) ) ; safeCopy ( getIn ( ) , exchange , exchange . getIn ( ) ) ; Message copyOut = exchange . getOut ( false ) ; if ( copyOut != null ) { safeCopy ( getOut ( true ) , exchange , copyOut ) ; } Message copyFault = exchange . getFault ( false ) ; if ( copyFault != null ) { safeCopy ( getFault ( true ) , exchange , copyFault ) ; } setException ( exchange . getException ( ) ) ; unitOfWork = exchange . getUnitOfWork ( ) ; pattern = exchange . getPattern ( ) ; } private static void safeCopy ( Message message , Exchange exchange , Message that ) { if ( message != null ) { message . copyFrom ( that ) ; } } private static Map < String , Object > safeCopy ( Map < String , Object > properties ) { if ( properties == null ) { return null ; } return new HashMap < String , Object > ( properties ) ; } private static Message safeCopy ( Exchange exchange , Message message ) { if ( message == null ) { return null ; } Message answer = message . copy ( ) ; if ( answer instanceof MessageSupport ) { MessageSupport messageSupport = ( MessageSupport ) answer ; messageSupport . setExchange ( exchange ) ; } return answer ; } public Exchange newInstance ( ) { return new DefaultExchange ( this ) ; } public CamelContext getContext ( ) { return context ; } public Object getProperty ( String name ) { if ( properties != null ) { return properties . get ( name ) ; } return null ; } public < T > T getProperty ( String name , Class < T > type ) { Object value = getProperty ( name ) ; ExchangeProperty < ? > property = ExchangeProperty . getByName ( name ) ; if ( property != null ) { validateExchangePropertyIsExpectedType ( property , type , value ) ; } return getContext ( ) . getTypeConverter ( ) . convertTo ( type , value ) ; } public void setProperty ( String name , Object value ) { ExchangeProperty < ? > property = ExchangeProperty . getByName ( name ) ; if ( property != null ) { Class type = value . getClass ( ) ; validateExchangePropertyIsExpectedType ( property , type , value ) ; } getProperties ( ) . put ( name , value ) ; } private < T > void validateExchangePropertyIsExpectedType ( ExchangeProperty < ? > property , Class < T > type , Object value ) { if ( value != null && property != null && ! property . type ( ) . isAssignableFrom ( type ) ) { throw new RuntimeCamelException ( "Type cast exception while getting an " + "Exchange Property value '" + value . toString ( ) + "' on Exchange " + this + " for a well known Exchange Property with these traits: " + property ) ; } } public Object removeProperty ( String name ) { return getProperties ( ) . remove ( name ) ; } public Map < String , Object > getProperties ( ) { if ( properties == null ) { properties = new HashMap < String , Object > ( ) ; } return properties ; } public void setProperties ( Map < String , Object > properties ) { this . properties = properties ; } public Message getIn ( ) { if ( in == null ) { in = createInMessage ( ) ; configureMessage ( in ) ; } return in ; } public void setIn ( Message in ) { this . in = in ; configureMessage ( in ) ; } public Message getOut ( ) { return getOut ( true ) ; } public Message getOut ( boolean lazyCreate ) { if ( out == null && lazyCreate ) { out = createOutMessage ( ) ; configureMessage ( out ) ; } return out ; } public void setOut ( Message out ) { this . out = out ; configureMessage ( out ) ; } public Throwable getException ( ) { return exception ; } public void setException ( Throwable exception ) { this . exception = exception ; } public ExchangePattern getPattern ( ) { return pattern ; } public void setPattern ( ExchangePattern pattern ) { this . pattern = pattern ; } public void throwException ( ) throws Exception { if ( exception == null ) { return ; } if ( exception instanceof RuntimeException ) { throw ( RuntimeException ) exception ; } if ( exception instanceof Exception ) { throw ( Exception ) exception ; } throw new RuntimeCamelException ( exception ) ; } public Message getFault ( ) { return getFault ( true ) ; } public Message getFault ( boolean lazyCreate ) { if ( fault == null && lazyCreate ) { fault = createFaultMessage ( ) ; configureMessage ( fault ) ; } return fault ; } public void setFault ( Message fault ) { this . fault = fault ; configureMessage ( fault ) ; } public String getExchangeId ( ) { if ( exchangeId == null ) { exchangeId = DefaultExchange . DEFAULT_ID_GENERATOR . generateId ( ) ; } return exchangeId ; } public void setExchangeId ( String id ) { this . exchangeId = id ; } public boolean isFailed ( ) { Message faultMessage = getFault ( false ) ; if ( faultMessage != null ) { Object faultBody = faultMessage . getBody ( ) ; if ( faultBody != null ) { return true ; } } return getException ( ) != null ; } public boolean isTransacted ( ) { ExchangeProperty < ? > property = ExchangeProperty . get ( "transacted" ) ; return property != null && property . get ( this ) == Boolean . TRUE ; } public UnitOfWork getUnitOfWork ( ) { return unitOfWork ; } public void setUnitOfWork ( UnitOfWork unitOfWork ) { this . unitOfWork = unitOfWork ; } protected Message createInMessage ( ) { return new DefaultMessage ( ) ; } protected Message createOutMessage ( ) { return new DefaultMessage ( ) ; } protected Message createFaultMessage ( ) { return new DefaultMessage ( ) ; } protected void configureMessage ( Message message ) { if ( message instanceof MessageSupport ) { MessageSupport messageSupport = ( MessageSupport ) message ; messageSupport . setExchange ( this ) ; } } } 	1	['42', '1', '14', '27', '78', '809', '16', '11', '33', '0.909756098', '489', '1', '7', '0', '0.118466899', '0', '0', '10.4047619', '4', '1.5238', '1']
package org . apache . camel . model ; import java . util . List ; import javax . xml . bind . annotation . XmlElementRef ; public interface RouteContainer { @ XmlElementRef List < RouteType > getRoutes ( ) ; void setRoutes ( List < RouteType > routes ) ; } 	0	['2', '1', '0', '2', '2', '1', '2', '0', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . camel . model ; import java . util . Collection ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlElements ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . model . loadbalancer . LoadBalancerType ; import org . apache . camel . model . loadbalancer . RandomLoadBalanceStrategy ; import org . apache . camel . model . loadbalancer . RoundRobinLoadBalanceStrategy ; import org . apache . camel . model . loadbalancer . StickyLoadBalanceStrategy ; import org . apache . camel . model . loadbalancer . TopicLoadBalanceStrategy ; import org . apache . camel . processor . SendProcessor ; import org . apache . camel . processor . loadbalancer . LoadBalancer ; import org . apache . camel . processor . loadbalancer . RandomLoadBalancer ; import org . apache . camel . processor . loadbalancer . RoundRobinLoadBalancer ; import org . apache . camel . processor . loadbalancer . StickyLoadBalancer ; import org . apache . camel . processor . loadbalancer . TopicLoadBalancer ; import org . apache . camel . spi . RouteContext ; import org . apache . camel . util . CollectionStringBuffer ; @ XmlRootElement ( name = "loadBalance" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class LoadBalanceType extends OutputType < LoadBalanceType > { @ XmlAttribute ( required = false ) private String ref ; @ XmlElements ( { @ XmlElement ( required = false , name = "roundRobin" , type = RoundRobinLoadBalanceStrategy . class ) , @ XmlElement ( required = false , name = "random" , type = RandomLoadBalanceStrategy . class ) , @ XmlElement ( required = false , name = "sticky" , type = StickyLoadBalanceStrategy . class ) , @ XmlElement ( required = false , name = "topic" , type = TopicLoadBalanceStrategy . class ) } ) private LoadBalancerType loadBalancerType ; public LoadBalanceType ( ) { } @ Override public String getShortName ( ) { return "loadbalance" ; } public String getRef ( ) { return ref ; } public void setRef ( String ref ) { this . ref = ref ; } public LoadBalancerType getLoadBalancerType ( ) { return loadBalancerType ; } public void setLoadBalancerType ( LoadBalancerType loadbalancer ) { loadBalancerType = loadbalancer ; } protected Processor createOutputsProcessor ( RouteContext routeContext , Collection < ProcessorType < ? > > outputs ) throws Exception { LoadBalancer loadBalancer = LoadBalancerType . getLoadBalancer ( routeContext , loadBalancerType , ref ) ; for ( ProcessorType processorType : outputs ) { SendProcessor processor = ( SendProcessor ) processorType . createProcessor ( routeContext ) ; loadBalancer . addProcessor ( processor ) ; } return loadBalancer ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { LoadBalancer loadBalancer = LoadBalancerType . getLoadBalancer ( routeContext , loadBalancerType , ref ) ; for ( ProcessorType processorType : getOutputs ( ) ) { SendProcessor processor = ( SendProcessor ) processorType . createProcessor ( routeContext ) ; loadBalancer . addProcessor ( processor ) ; } return loadBalancer ; } public LoadBalanceType setLoadBalancer ( LoadBalancer loadBalancer ) { loadBalancerType = new LoadBalancerType ( loadBalancer ) ; return this ; } public LoadBalanceType roundRobin ( ) { loadBalancerType = new LoadBalancerType ( new RoundRobinLoadBalancer ( ) ) ; return this ; } public LoadBalanceType random ( ) { loadBalancerType = new LoadBalancerType ( new RandomLoadBalancer ( ) ) ; return this ; } public LoadBalanceType sticky ( Expression < Exchange > correlationExpression ) { loadBalancerType = new LoadBalancerType ( new StickyLoadBalancer ( correlationExpression ) ) ; return this ; } public LoadBalanceType topic ( ) { loadBalancerType = new LoadBalancerType ( new TopicLoadBalancer ( ) ) ; return this ; } @ Override public String getLabel ( ) { CollectionStringBuffer buffer = new CollectionStringBuffer ( ) ; List < ProcessorType < ? > > list = getOutputs ( ) ; for ( ProcessorType < ? > processorType : list ) { buffer . append ( processorType . getLabel ( ) ) ; } return buffer . toString ( ) ; } @ Override public String toString ( ) { String result ; if ( loadBalancerType != null ) { result = "LoadBalanceType[" + loadBalancerType + ", " ; } else { result = "LoadBalanceType[" + ref + ", " ; } result = result + getOutputs ( ) + "]" ; return result ; } } 	1	['15', '4', '0', '15', '37', '1', '3', '13', '14', '0.535714286', '209', '1', '1', '0.916167665', '0.20952381', '1', '1', '12.8', '2', '1.0667', '3']
package org . apache . camel . spi ; public interface ExceptionHandler { void handleException ( Throwable exception ) ; } 	0	['1', '1', '0', '5', '1', '0', '5', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . processor . aggregate ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; public class PredicateAggregationCollection extends AggregationCollection { private Predicate aggregationCompletedPredicate ; private List < Exchange > collection = new ArrayList < Exchange > ( ) ; public PredicateAggregationCollection ( Expression < Exchange > correlationExpression , AggregationStrategy aggregationStrategy , Predicate aggregationCompletedPredicate ) { super ( correlationExpression , aggregationStrategy ) ; this . aggregationCompletedPredicate = aggregationCompletedPredicate ; } @ Override protected void onAggregation ( Object correlationKey , Exchange newExchange ) { if ( aggregationCompletedPredicate . matches ( newExchange ) ) { super . getMap ( ) . remove ( correlationKey ) ; collection . add ( newExchange ) ; } } @ Override public Iterator < Exchange > iterator ( ) { return collection . iterator ( ) ; } @ Override public int size ( ) { return collection . size ( ) ; } @ Override public void clear ( ) { collection . clear ( ) ; super . clear ( ) ; } } 	1	['5', '3', '0', '6', '15', '0', '1', '5', '4', '0.375', '50', '1', '1', '0.84', '0.333333333', '2', '6', '8.6', '2', '1', '2']
package org . apache . camel . component . rmi ; import java . util . Map ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . component . bean . BeanExchange ; import org . apache . camel . impl . DefaultComponent ; public class RmiComponent extends DefaultComponent < BeanExchange > { public RmiComponent ( ) { } public RmiComponent ( CamelContext context ) { super ( context ) ; } @ Override protected Endpoint < BeanExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { return new RmiEndpoint ( uri , this ) ; } } 	0	['3', '3', '0', '4', '6', '3', '1', '4', '2', '2', '16', '0', '0', '0.971428571', '0.5', '1', '1', '4.333333333', '1', '0.3333', '0']
package org . apache . camel . component . bean ; import java . lang . annotation . Annotation ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; import org . apache . camel . Body ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Header ; import org . apache . camel . Headers ; import org . apache . camel . Message ; import org . apache . camel . OutHeaders ; import org . apache . camel . Properties ; import org . apache . camel . Property ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . builder . ExpressionBuilder ; import org . apache . camel . language . LanguageAnnotation ; import org . apache . camel . spi . Registry ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import static org . apache . camel . util . ExchangeHelper . convertToType ; public class BeanInfo { private static final transient Log LOG = LogFactory . getLog ( BeanInfo . class ) ; private final CamelContext camelContext ; private Class type ; private ParameterMappingStrategy strategy ; private Map < String , MethodInfo > operations = new ConcurrentHashMap < String , MethodInfo > ( ) ; private MethodInfo defaultMethod ; private List < MethodInfo > operationsWithBody = new ArrayList < MethodInfo > ( ) ; private List < MethodInfo > operationsWithCustomAnnotation = new ArrayList < MethodInfo > ( ) ; public BeanInfo ( CamelContext camelContext , Class type ) { this ( camelContext , type , createParameterMappingStrategy ( camelContext ) ) ; } public BeanInfo ( CamelContext camelContext , Class type , ParameterMappingStrategy strategy ) { this . camelContext = camelContext ; this . type = type ; this . strategy = strategy ; introspect ( getType ( ) ) ; if ( operations . size ( ) == 1 ) { Collection < MethodInfo > methodInfos = operations . values ( ) ; for ( MethodInfo methodInfo : methodInfos ) { defaultMethod = methodInfo ; } } } public Class getType ( ) { return type ; } public CamelContext getCamelContext ( ) { return camelContext ; } public MethodInvocation createInvocation ( Method method , Object pojo , Exchange exchange ) throws RuntimeCamelException { MethodInfo methodInfo = introspect ( type , method ) ; if ( methodInfo != null ) { return methodInfo . createMethodInvocation ( pojo , exchange ) ; } return null ; } public MethodInvocation createInvocation ( Object pojo , Exchange exchange ) throws RuntimeCamelException , AmbiguousMethodCallException { MethodInfo methodInfo = null ; String name = exchange . getIn ( ) . getHeader ( BeanProcessor . METHOD_NAME , String . class ) ; if ( name != null ) { methodInfo = operations . get ( name ) ; } if ( methodInfo == null ) { methodInfo = chooseMethod ( pojo , exchange ) ; } if ( methodInfo == null ) { methodInfo = defaultMethod ; } if ( methodInfo != null ) { return methodInfo . createMethodInvocation ( pojo , exchange ) ; } return null ; } protected void introspect ( Class clazz ) { Method [ ] methods = clazz . getDeclaredMethods ( ) ; for ( Method method : methods ) { if ( isValidMethod ( clazz , method ) ) { introspect ( clazz , method ) ; } } Class superclass = clazz . getSuperclass ( ) ; if ( superclass != null && ! superclass . equals ( Object . class ) ) { introspect ( superclass ) ; } } protected MethodInfo introspect ( Class clazz , Method method ) { Class [ ] parameterTypes = method . getParameterTypes ( ) ; Annotation [ ] [ ] parametersAnnotations = method . getParameterAnnotations ( ) ; List < ParameterInfo > parameters = new ArrayList < ParameterInfo > ( ) ; List < ParameterInfo > bodyParameters = new ArrayList < ParameterInfo > ( ) ; boolean hasCustomAnnotation = false ; for ( int i = 0 ; i < parameterTypes . length ; i ++ ) { Class parameterType = parameterTypes [ i ] ; Annotation [ ] parameterAnnotations = parametersAnnotations [ i ] ; Expression expression = createParameterUnmarshalExpression ( clazz , method , parameterType , parameterAnnotations ) ; hasCustomAnnotation |= expression != null ; ParameterInfo parameterInfo = new ParameterInfo ( i , parameterType , parameterAnnotations , expression ) ; parameters . add ( parameterInfo ) ; if ( expression == null ) { hasCustomAnnotation |= ObjectHelper . hasAnnotation ( parameterAnnotations , Body . class ) ; if ( bodyParameters . isEmpty ( ) ) { if ( Exchange . class . isAssignableFrom ( parameterType ) ) { expression = ExpressionBuilder . exchangeExpression ( ) ; } else { expression = ExpressionBuilder . bodyExpression ( parameterType ) ; } parameterInfo . setExpression ( expression ) ; bodyParameters . add ( parameterInfo ) ; } else { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "No expression available for method: " + method . toString ( ) + " which already has a body so ignoring parameter: " + i + " so ignoring method" ) ; } return null ; } } } String opName = method . getName ( ) ; MethodInfo methodInfo = new MethodInfo ( clazz , method , parameters , bodyParameters , hasCustomAnnotation ) ; operations . put ( opName , methodInfo ) ; if ( methodInfo . hasBodyParameter ( ) ) { operationsWithBody . add ( methodInfo ) ; } if ( methodInfo . isHasCustomAnnotation ( ) && ! methodInfo . hasBodyParameter ( ) ) { operationsWithCustomAnnotation . add ( methodInfo ) ; } return methodInfo ; } protected MethodInfo chooseMethod ( Object pojo , Exchange exchange ) throws AmbiguousMethodCallException { if ( operationsWithBody . size ( ) == 1 ) { return operationsWithBody . get ( 0 ) ; } else if ( ! operationsWithBody . isEmpty ( ) ) { return chooseMethodWithMatchingBody ( exchange , operationsWithBody ) ; } else if ( operationsWithCustomAnnotation . size ( ) == 1 ) { return operationsWithCustomAnnotation . get ( 0 ) ; } return null ; } protected MethodInfo chooseMethodWithMatchingBody ( Exchange exchange , Collection < MethodInfo > operationList ) throws AmbiguousMethodCallException { Message in = exchange . getIn ( ) ; Object body = in . getBody ( ) ; if ( body != null ) { Class bodyType = body . getClass ( ) ; List < MethodInfo > possibles = new ArrayList < MethodInfo > ( ) ; for ( MethodInfo methodInfo : operationList ) { boolean out = exchange . getPattern ( ) . isOutCapable ( ) ; if ( out && methodInfo . isReturnTypeVoid ( ) ) { continue ; } if ( methodInfo . bodyParameterMatches ( bodyType ) ) { possibles . add ( methodInfo ) ; } } if ( possibles . size ( ) == 1 ) { return possibles . get ( 0 ) ; } else if ( possibles . isEmpty ( ) ) { Object newBody = null ; MethodInfo matched = null ; for ( MethodInfo methodInfo : operationList ) { Object value = convertToType ( exchange , methodInfo . getBodyParameterType ( ) , body ) ; if ( value != null ) { if ( newBody != null ) { throw new AmbiguousMethodCallException ( exchange , Arrays . asList ( matched , methodInfo ) ) ; } else { newBody = value ; matched = methodInfo ; } } } if ( matched != null ) { in . setBody ( newBody ) ; return matched ; } } else { if ( operationsWithCustomAnnotation . size ( ) == 1 ) { return operationsWithCustomAnnotation . get ( 0 ) ; } return chooseMethodWithCustomAnnotations ( exchange , possibles ) ; } } return null ; } protected MethodInfo chooseMethodWithCustomAnnotations ( Exchange exchange , Collection < MethodInfo > possibles ) throws AmbiguousMethodCallException { MethodInfo chosen = null ; for ( MethodInfo possible : possibles ) { if ( possible . isHasCustomAnnotation ( ) ) { if ( chosen != null ) { chosen = null ; break ; } else { chosen = possible ; } } } if ( chosen != null ) { return chosen ; } throw new AmbiguousMethodCallException ( exchange , possibles ) ; } protected Expression createParameterUnmarshalExpression ( Class clazz , Method method , Class parameterType , Annotation [ ] parameterAnnotation ) { for ( Annotation annotation : parameterAnnotation ) { Expression answer = createParameterUnmarshalExpressionForAnnotation ( clazz , method , parameterType , annotation ) ; if ( answer != null ) { return answer ; } } return strategy . getDefaultParameterTypeExpression ( parameterType ) ; } protected boolean isPossibleBodyParameter ( Annotation [ ] annotations ) { if ( annotations != null ) { for ( Annotation annotation : annotations ) { if ( ( annotation instanceof Property ) || ( annotation instanceof Header ) || ( annotation instanceof Headers ) || ( annotation instanceof OutHeaders ) || ( annotation instanceof Properties ) ) { return false ; } LanguageAnnotation languageAnnotation = annotation . annotationType ( ) . getAnnotation ( LanguageAnnotation . class ) ; if ( languageAnnotation != null ) { return false ; } } } return true ; } protected Expression createParameterUnmarshalExpressionForAnnotation ( Class clazz , Method method , Class parameterType , Annotation annotation ) { if ( annotation instanceof Property ) { Property propertyAnnotation = ( Property ) annotation ; return ExpressionBuilder . propertyExpression ( propertyAnnotation . name ( ) ) ; } else if ( annotation instanceof Properties ) { return ExpressionBuilder . propertiesExpression ( ) ; } else if ( annotation instanceof Header ) { Header headerAnnotation = ( Header ) annotation ; return ExpressionBuilder . headerExpression ( headerAnnotation . name ( ) ) ; } else if ( annotation instanceof Headers ) { return ExpressionBuilder . headersExpression ( ) ; } else if ( annotation instanceof OutHeaders ) { return ExpressionBuilder . outHeadersExpression ( ) ; } else { LanguageAnnotation languageAnnotation = annotation . annotationType ( ) . getAnnotation ( LanguageAnnotation . class ) ; if ( languageAnnotation != null ) { Class < ? > type = languageAnnotation . factory ( ) ; Object object = camelContext . getInjector ( ) . newInstance ( type ) ; if ( object instanceof AnnotationExpressionFactory ) { AnnotationExpressionFactory expressionFactory = ( AnnotationExpressionFactory ) object ; return expressionFactory . createExpression ( camelContext , annotation , languageAnnotation , parameterType ) ; } else { LOG . error ( "Ignoring bad annotation: " + languageAnnotation + "on method: " + method + " which declares a factory: " + type . getName ( ) + " which does not implement " + AnnotationExpressionFactory . class . getName ( ) ) ; } } } return null ; } protected boolean isValidMethod ( Class clazz , Method method ) { if ( ! Modifier . isPublic ( method . getModifiers ( ) ) ) { return false ; } if ( method . getReturnType ( ) != null && Exchange . class . isAssignableFrom ( method . getReturnType ( ) ) ) { return false ; } return true ; } public static ParameterMappingStrategy createParameterMappingStrategy ( CamelContext camelContext ) { Registry registry = camelContext . getRegistry ( ) ; ParameterMappingStrategy answer = registry . lookup ( ParameterMappingStrategy . class . getName ( ) , ParameterMappingStrategy . class ) ; if ( answer == null ) { answer = new DefaultParameterMappingStrategy ( ) ; } return answer ; } } 	1	['17', '1', '0', '31', '91', '100', '5', '26', '7', '0.7265625', '741', '1', '3', '0', '0.275', '0', '0', '42.11764706', '10', '2.8235', '7']
package org . apache . camel . component . cxf . transport ; import java . io . IOException ; import java . io . OutputStream ; import java . util . List ; import java . util . Map ; import java . util . logging . Level ; import java . util . logging . Logger ; import org . apache . camel . CamelContext ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . ProducerTemplate ; import org . apache . camel . component . cxf . CxfConstants ; import org . apache . camel . component . cxf . CxfSoapBinding ; import org . apache . camel . impl . DefaultCamelContext ; import org . apache . cxf . Bus ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . configuration . Configurable ; import org . apache . cxf . configuration . Configurer ; import org . apache . cxf . helpers . CastUtils ; import org . apache . cxf . io . CachedOutputStream ; import org . apache . cxf . message . Message ; import org . apache . cxf . message . MessageImpl ; import org . apache . cxf . service . model . EndpointInfo ; import org . apache . cxf . transport . AbstractConduit ; import org . apache . cxf . transport . AbstractDestination ; import org . apache . cxf . transport . Conduit ; import org . apache . cxf . transport . ConduitInitiator ; import org . apache . cxf . transport . MessageObserver ; import org . apache . cxf . ws . addressing . EndpointReferenceType ; import org . apache . cxf . wsdl . EndpointReferenceUtils ; public class CamelDestination extends AbstractDestination implements Configurable { protected static final String BASE_BEAN_NAME_SUFFIX = ".camel-destination" ; private static final Logger LOG = LogUtils . getL7dLogger ( CamelDestination . class ) ; final ConduitInitiator conduitInitiator ; CamelContext camelContext ; Consumer consumer ; String camelDestinationUri ; private ProducerTemplate < Exchange > camelTemplate ; private Endpoint distinationEndpoint ; public CamelDestination ( CamelContext camelContext , Bus bus , ConduitInitiator ci , EndpointInfo info ) throws IOException { super ( bus , getTargetReference ( info , bus ) , info ) ; this . camelContext = camelContext ; conduitInitiator = ci ; camelDestinationUri = endpointInfo . getAddress ( ) . substring ( CxfConstants . CAMEL_TRANSPORT_PREFIX . length ( ) ) ; if ( camelDestinationUri . startsWith ( "//" ) ) { camelDestinationUri = camelDestinationUri . substring ( 2 ) ; } initConfig ( ) ; } protected Logger getLogger ( ) { return LOG ; } protected Conduit getInbuiltBackChannel ( Message inMessage ) { return new BackChannelConduit ( inMessage ) ; } public void activate ( ) { getLogger ( ) . log ( Level . FINE , "CamelDestination activate().... " ) ; try { getLogger ( ) . log ( Level . FINE , "establishing Camel connection" ) ; distinationEndpoint = camelContext . getEndpoint ( camelDestinationUri ) ; consumer = distinationEndpoint . createConsumer ( new ConsumerProcessor ( ) ) ; consumer . start ( ) ; } catch ( Exception ex ) { getLogger ( ) . log ( Level . SEVERE , "Camel connect failed with Exception : " , ex ) ; } } public void deactivate ( ) { try { consumer . stop ( ) ; } catch ( Exception e ) { getLogger ( ) . log ( Level . SEVERE , "Camel stop failed with Exception : " , e ) ; } } public void shutdown ( ) { getLogger ( ) . log ( Level . FINE , "CamelDestination shutdown()" ) ; this . deactivate ( ) ; } public ProducerTemplate < Exchange > getCamelTemplate ( ) { if ( camelTemplate == null ) { CamelContext ctx = camelContext != null ? camelContext : new DefaultCamelContext ( ) ; camelTemplate = ctx . createProducerTemplate ( ) ; } return camelTemplate ; } public void setCamelTemplate ( ProducerTemplate < Exchange > template ) { camelTemplate = template ; } public void setCamelContext ( CamelContext context ) { camelContext = context ; } public CamelContext getCamelContext ( ) { return camelContext ; } protected void incoming ( org . apache . camel . Exchange camelExchange ) { getLogger ( ) . log ( Level . FINE , "server received request: " , camelExchange ) ; org . apache . cxf . message . Message inMessage = CxfSoapBinding . getCxfInMessage ( camelExchange , false ) ; inMessage . put ( CxfConstants . CAMEL_EXCHANGE , camelExchange ) ; ( ( MessageImpl ) inMessage ) . setDestination ( this ) ; incomingObserver . onMessage ( inMessage ) ; } public String getBeanName ( ) { if ( endpointInfo == null || endpointInfo . getName ( ) == null ) { return "default" + BASE_BEAN_NAME_SUFFIX ; } return endpointInfo . getName ( ) . toString ( ) + BASE_BEAN_NAME_SUFFIX ; } private void initConfig ( ) { if ( bus != null ) { Configurer configurer = bus . getExtension ( Configurer . class ) ; if ( null != configurer ) { configurer . configureBean ( this ) ; } } } protected class ConsumerProcessor implements Processor { public void process ( Exchange exchange ) { try { incoming ( exchange ) ; } catch ( Throwable ex ) { getLogger ( ) . log ( Level . WARNING , "Failed to process incoming message : " , ex ) ; } } } protected class BackChannelConduit extends AbstractConduit { protected Message inMessage ; Exchange camelExchange ; org . apache . cxf . message . Exchange cxfExchange ; BackChannelConduit ( Message message ) { super ( EndpointReferenceUtils . getAnonymousEndpointReference ( ) ) ; inMessage = message ; cxfExchange = inMessage . getExchange ( ) ; camelExchange = cxfExchange . get ( Exchange . class ) ; } public void setMessageObserver ( MessageObserver observer ) { } public void prepare ( Message message ) throws IOException { message . put ( CxfConstants . CAMEL_EXCHANGE , inMessage . get ( CxfConstants . CAMEL_EXCHANGE ) ) ; message . setContent ( OutputStream . class , new CamelOutputStream ( message ) ) ; } protected Logger getLogger ( ) { return LOG ; } } protected boolean markPartialResponse ( Message partialResponse , EndpointReferenceType decoupledTarget ) { return true ; } protected ConduitInitiator getConduitInitiator ( ) { return conduitInitiator ; } private class CamelOutputStream extends CachedOutputStream { private Message outMessage ; public CamelOutputStream ( Message m ) { super ( ) ; outMessage = m ; } private void commitOutputMessage ( ) throws IOException { Exchange camelExchange = ( Exchange ) outMessage . get ( CxfConstants . CAMEL_EXCHANGE ) ; Map < String , List < String > > protocolHeader = CastUtils . cast ( ( Map < ? , ? > ) outMessage . get ( Message . PROTOCOL_HEADERS ) ) ; CxfSoapBinding . setProtocolHeader ( camelExchange . getOut ( ) . getHeaders ( ) , protocolHeader ) ; CachedOutputStream outputStream = ( CachedOutputStream ) outMessage . getContent ( OutputStream . class ) ; camelExchange . getOut ( ) . setBody ( outputStream . getBytes ( ) ) ; getLogger ( ) . log ( Level . FINE , "send the response message: " + outputStream ) ; } @ Override protected void doFlush ( ) throws IOException { } @ Override protected void doClose ( ) throws IOException { commitOutputMessage ( ) ; } @ Override protected void onWrite ( ) throws IOException { } } } 	0	['17', '0', '0', '25', '46', '102', '4', '23', '9', '0.890625', '229', '0.5', '4', '0', '0.173611111', '0', '0', '12', '3', '1.2353', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Predicate ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . FilterProcessor ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "filter" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class FilterType extends ExpressionNode implements Block { public FilterType ( ) { } public FilterType ( ExpressionType expression ) { super ( expression ) ; } public FilterType ( Predicate predicate ) { super ( predicate ) ; } @ Override public String toString ( ) { return "Filter[ " + getExpression ( ) + " -> " + getOutputs ( ) + "]" ; } @ Override public String getShortName ( ) { return "filter" ; } @ Override public FilterProcessor createProcessor ( RouteContext routeContext ) throws Exception { return createFilterProcessor ( routeContext ) ; } } 	1	['7', '4', '0', '11', '16', '21', '4', '7', '7', '2', '45', '0', '0', '0.975308642', '0.392857143', '3', '4', '5.428571429', '1', '0.5714', '1']
package org . apache . camel . component . bean ; import java . io . Serializable ; import java . lang . reflect . Method ; public class MethodBean implements Serializable { private String name ; private Class < ? > type ; private Class < ? > [ ] parameterTypes ; public MethodBean ( ) { } public MethodBean ( Method method ) { this . name = method . getName ( ) ; this . type = method . getDeclaringClass ( ) ; this . parameterTypes = method . getParameterTypes ( ) ; } public Method getMethod ( ) throws NoSuchMethodException { return type . getMethod ( name , parameterTypes ) ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public Class < ? > [ ] getParameterTypes ( ) { return parameterTypes ; } public void setParameterTypes ( Class < ? > [ ] parameterTypes ) { this . parameterTypes = parameterTypes ; } public Class < ? > getType ( ) { return type ; } public void setType ( Class < ? > type ) { this . type = type ; } } 	0	['9', '1', '0', '1', '14', '4', '1', '0', '9', '0.625', '59', '1', '0', '0', '0.288888889', '0', '0', '5.222222222', '1', '0.7778', '0']
package org . apache . camel . component . seda ; import java . util . List ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . impl . PollingConsumerSupport ; @ Deprecated public class ListPollingConsumer extends PollingConsumerSupport { private final List < Exchange > exchanges ; public ListPollingConsumer ( Endpoint endpoint , List < Exchange > exchanges ) { super ( endpoint ) ; this . exchanges = exchanges ; } public Exchange receive ( ) { return receiveNoWait ( ) ; } public Exchange receiveNoWait ( ) { if ( exchanges . isEmpty ( ) ) { return null ; } else { return exchanges . remove ( 0 ) ; } } public Exchange receive ( long timeout ) { return receiveNoWait ( ) ; } protected void doStart ( ) throws Exception { } protected void doStop ( ) throws Exception { } } 	1	['6', '3', '0', '3', '9', '13', '0', '3', '4', '0.4', '34', '1', '0', '0.782608696', '0.375', '1', '1', '4.5', '2', '1', '1']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . model . language . ExpressionType ; @ XmlRootElement ( name = "serviceActivation" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ServiceActivationType { @ XmlAttribute private String group = "default" ; @ XmlElementRef private List < ExpressionType > uris = new ArrayList < ExpressionType > ( ) ; public String getGroup ( ) { return group ; } public void setGroup ( String group ) { this . group = group ; } public List < ExpressionType > getUris ( ) { return uris ; } public void setUris ( List < ExpressionType > uris ) { this . uris = uris ; } } 	0	['5', '1', '0', '0', '7', '0', '0', '0', '5', '0.5', '32', '1', '0', '0', '0.466666667', '0', '0', '5', '1', '0.8', '0']
package org . apache . camel . impl ; import org . apache . camel . processor . Logger ; import org . apache . camel . processor . LoggingLevel ; import org . apache . camel . spi . ExceptionHandler ; import org . apache . commons . logging . LogFactory ; public class LoggingExceptionHandler implements ExceptionHandler { private final Logger logger ; public LoggingExceptionHandler ( Class ownerType ) { this ( new Logger ( LogFactory . getLog ( ownerType ) , LoggingLevel . ERROR ) ) ; } public LoggingExceptionHandler ( Logger logger ) { this . logger = logger ; } public void handleException ( Throwable exception ) { logger . log ( exception . getMessage ( ) , exception ) ; } } 	1	['3', '1', '0', '9', '8', '1', '4', '5', '3', '0', '26', '1', '1', '0', '0.5', '0', '0', '7.333333333', '1', '0.3333', '1']
package org . apache . camel . util . jndi ; import java . util . Hashtable ; import javax . naming . Context ; import javax . naming . NamingException ; import javax . naming . spi . InitialContextFactory ; public class CamelInitialContextFactory implements InitialContextFactory { public Context getInitialContext ( Hashtable environment ) throws NamingException { try { return new JndiContext ( environment ) ; } catch ( NamingException e ) { throw e ; } catch ( Exception e ) { NamingException exception = new NamingException ( e . getMessage ( ) ) ; exception . initCause ( e ) ; throw exception ; } } } 	0	['2', '1', '0', '1', '7', '1', '0', '1', '2', '2', '26', '0', '0', '0', '0.75', '0', '0', '12', '1', '0.5', '0']
package org . apache . camel . component . file ; import java . io . File ; import java . util . Map ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; public class FileComponent extends DefaultComponent < FileExchange > { public static final String HEADER_FILE_NAME = "org.apache.camel.file.name" ; public static final String HEADER_FILE_NAME_PRODUCED = "org.apache.camel.file.name.produced" ; public FileComponent ( ) { } public FileComponent ( CamelContext context ) { super ( context ) ; } protected Endpoint < FileExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { File file = new File ( remaining ) ; FileEndpoint result = new FileEndpoint ( file , uri , this ) ; setProperties ( result , parameters ) ; return result ; } } 	1	['3', '3', '0', '4', '8', '3', '1', '4', '2', '1.5', '30', '0', '0', '0.971428571', '0.5', '1', '2', '8.333333333', '1', '0.3333', '5']
package org . apache . camel . processor . validation ; import java . util . List ; import org . xml . sax . SAXParseException ; import org . apache . camel . Exchange ; import org . apache . camel . ValidationException ; public class SchemaValidationException extends ValidationException { private final Object schema ; private final List < SAXParseException > fatalErrors ; private final List < SAXParseException > errors ; private final List < SAXParseException > warnings ; public SchemaValidationException ( Exchange exchange , Object schema , List < SAXParseException > fatalErrors , List < SAXParseException > errors , List < SAXParseException > warnings ) { super ( exchange , message ( schema , fatalErrors , errors , warnings ) ) ; this . schema = schema ; this . fatalErrors = fatalErrors ; this . errors = errors ; this . warnings = warnings ; } public Object getSchema ( ) { return schema ; } public List < SAXParseException > getErrors ( ) { return errors ; } public List < SAXParseException > getFatalErrors ( ) { return fatalErrors ; } public List < SAXParseException > getWarnings ( ) { return warnings ; } protected static String message ( Object schema , List < SAXParseException > fatalErrors , List < SAXParseException > errors , List < SAXParseException > warnings ) { StringBuffer buffer = new StringBuffer ( "Validation failed for: " + schema ) ; if ( ! fatalErrors . isEmpty ( ) ) { buffer . append ( " fatal errors: " ) ; buffer . append ( fatalErrors ) ; } if ( ! errors . isEmpty ( ) ) { buffer . append ( " errors: " ) ; buffer . append ( errors ) ; } return buffer . toString ( ) ; } } 	0	['6', '6', '0', '3', '16', '7', '1', '2', '5', '0.8', '80', '1', '0', '0.791666667', '0.416666667', '0', '0', '11.66666667', '3', '1.1667', '0']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "expression" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class LanguageExpression extends ExpressionType { @ XmlAttribute private String language ; public LanguageExpression ( ) { } public LanguageExpression ( String language , String expression ) { setLanguage ( language ) ; setExpression ( expression ) ; } public String getLanguage ( ) { return language ; } public void setLanguage ( String language ) { this . language = language ; } } 	1	['4', '2', '0', '2', '6', '4', '1', '1', '4', '0.333333333', '24', '1', '0', '0.916666667', '0.75', '1', '2', '4.75', '1', '0.5', '1']
package org . apache . camel . impl ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; import org . apache . camel . TypeConverter ; import org . apache . camel . impl . converter . AnnotationTypeConverterLoader ; import org . apache . camel . impl . converter . TypeConverterRegistry ; import org . apache . camel . util . ObjectHelper ; public class ReportingTypeConverterLoader extends AnnotationTypeConverterLoader { private static final Comparator < TypeMapping > COMPARE_LAST_LOADED_FIRST = new Comparator < TypeMapping > ( ) { public int compare ( TypeMapping t1 , TypeMapping t2 ) { if ( ObjectHelper . equal ( t1 . fromType , t2 . fromType ) ) { return ObjectHelper . equal ( t1 . toType , t2 . toType ) ? t1 . index - t2 . index : ObjectHelper . compare ( getTypeName ( t1 . toType ) , getTypeName ( t2 . toType ) ) ; } return ObjectHelper . compare ( getTypeName ( t1 . fromType ) , getTypeName ( t2 . fromType ) ) ; } } ; private List < TypeMapping > typeMappings = new ArrayList < TypeMapping > ( ) ; public TypeMapping [ ] getTypeConversions ( ) { Collections . sort ( typeMappings , COMPARE_LAST_LOADED_FIRST ) ; return typeMappings . toArray ( new TypeMapping [ typeMappings . size ( ) ] ) ; } protected void registerTypeConverter ( TypeConverterRegistry registry , Method method , Class toType , Class fromType , TypeConverter typeConverter ) { TypeMapping mapping = new TypeMapping ( toType , fromType , typeConverter . getClass ( ) , method ) ; typeMappings . add ( mapping ) ; } private static String getTypeName ( Class type ) { return type != null ? type . getName ( ) : null ; } public static class TypeMapping { private static int counter ; private Class toType ; private Class fromType ; private Class converterType ; private Method method ; private int index ; public TypeMapping ( Class toType , Class fromType , Class converterType , Method method ) { this . toType = toType ; this . fromType = fromType ; this . converterType = converterType ; this . method = method ; this . index = counter ++ ; } public Class getFromType ( ) { return fromType ; } public Class getToType ( ) { return toType ; } public Class getConverterType ( ) { return converterType ; } public Method getMethod ( ) { return method ; } public int getIndex ( ) { return index ; } @ Override public boolean equals ( Object object ) { if ( object instanceof TypeMapping ) { TypeMapping that = ( TypeMapping ) object ; return this . index == that . index ; } return false ; } @ Override public int hashCode ( ) { int answer = toType . hashCode ( ) ; if ( fromType != null ) { answer *= 37 + fromType . hashCode ( ) ; } return answer ; } @ Override public String toString ( ) { return "[" + fromType . getSimpleName ( ) + "=>" + toType . getSimpleName ( ) + "]" ; } } } 	0	['6', '2', '0', '5', '16', '7', '1', '5', '2', '0.7', '59', '1', '0', '0.6', '0.36', '1', '1', '8.5', '2', '0.8333', '0']
package org . apache . camel . processor . interceptor ; import org . apache . camel . Processor ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . spi . InterceptStrategy ; public class Tracer implements InterceptStrategy { private TraceFormatter formatter = new TraceFormatter ( ) ; public Processor wrapProcessorInInterceptors ( ProcessorType processorType , Processor target ) throws Exception { String id = processorType . idOrCreate ( ) ; return new TraceInterceptor ( processorType , target , formatter ) ; } public TraceFormatter getFormatter ( ) { return formatter ; } public void setFormatter ( TraceFormatter formatter ) { this . formatter = formatter ; } } 	1	['4', '1', '0', '7', '8', '0', '2', '5', '4', '0', '31', '1', '1', '0', '0.4375', '0', '0', '6.5', '1', '0.75', '2']
package org . apache . camel . component . mail ; import java . io . IOException ; import javax . mail . BodyPart ; import javax . mail . Message ; import javax . mail . MessagingException ; import javax . mail . Multipart ; import javax . mail . internet . MimeMultipart ; import org . apache . camel . Converter ; @ Converter public class MailConverters { @ Converter public String toString ( Message message ) throws MessagingException , IOException { Object content = message . getContent ( ) ; if ( content instanceof MimeMultipart ) { MimeMultipart multipart = ( MimeMultipart ) content ; if ( multipart . getCount ( ) > 0 ) { BodyPart part = multipart . getBodyPart ( 0 ) ; content = part . getContent ( ) ; } } if ( content != null ) { return content . toString ( ) ; } return null ; } @ Converter public static String toString ( Multipart multipart ) throws MessagingException , IOException { int size = multipart . getCount ( ) ; for ( int i = 0 ; i < size ; i ++ ) { BodyPart part = multipart . getBodyPart ( i ) ; if ( part . getContentType ( ) . startsWith ( "text" ) ) { return part . getContent ( ) . toString ( ) ; } } return null ; } } 	0	['3', '1', '0', '0', '13', '3', '0', '0', '3', '2', '57', '0', '0', '0', '0.444444444', '0', '0', '18', '1', '0.6667', '0']
package org . apache . camel . component . jmx ; import javax . management . Notification ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; public class JMXExchange extends DefaultExchange { public JMXExchange ( CamelContext camelContext , ExchangePattern pattern , Notification notification ) { super ( camelContext , pattern ) ; setIn ( new JMXMessage ( notification ) ) ; } } 	1	['1', '2', '0', '7', '4', '0', '3', '5', '1', '2', '12', '0', '0', '1', '1', '0', '0', '11', '0', '0', '1']
package org . apache . camel . spi ; import org . apache . camel . Exchange ; public interface ExchangeConverter { < T > T convertTo ( Class < T > type , Exchange exchange ) ; } 	0	['1', '1', '0', '5', '1', '0', '4', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . language . bean . BeanExpression ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "methodCall" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class MethodCallExpression extends ExpressionType { @ XmlAttribute ( required = false ) private String bean ; @ XmlAttribute ( required = false ) private String method ; public MethodCallExpression ( ) { } public MethodCallExpression ( String beanName ) { super ( beanName ) ; } public MethodCallExpression ( String beanName , String method ) { super ( beanName ) ; this . method = method ; } public String getLanguage ( ) { return "bean" ; } public String getMethod ( ) { return method ; } public void setMethod ( String method ) { this . method = method ; } @ Override public Expression createExpression ( RouteContext routeContext ) { return new BeanExpression ( beanName ( ) , getMethod ( ) ) ; } @ Override public Predicate < Exchange > createPredicate ( RouteContext routeContext ) { return new BeanExpression < Exchange > ( beanName ( ) , getMethod ( ) ) ; } protected String beanName ( ) { if ( bean != null ) { return bean ; } return getExpression ( ) ; } } 	1	['9', '2', '0', '6', '13', '30', '1', '5', '8', '0.625', '59', '1', '0', '0.785714286', '0.518518519', '1', '4', '5.333333333', '2', '0.7778', '1']
package org . apache . camel . component . dataset ; import java . util . HashMap ; import java . util . Map ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . util . ExchangeHelper ; public abstract class DataSetSupport implements DataSet { private Map < String , Object > defaultHeaders ; private Processor outputTransformer ; private long size = 10 ; private long reportCount = - 1 ; public DataSetSupport ( ) { } public DataSetSupport ( int size ) { setSize ( size ) ; } public void populateMessage ( Exchange exchange , long messageIndex ) throws Exception { Message in = exchange . getIn ( ) ; in . setBody ( createMessageBody ( messageIndex ) ) ; in . setHeaders ( getDefaultHeaders ( ) ) ; applyHeaders ( exchange , messageIndex ) ; if ( outputTransformer != null ) { outputTransformer . process ( exchange ) ; } } public void assertMessageExpected ( DataSetEndpoint dataSetEndpoint , Exchange expected , Exchange actual , long index ) throws Exception { Object expectedBody = expected . getIn ( ) . getBody ( ) ; Object actualBody = actual . getIn ( ) . getBody ( ) ; if ( expectedBody != null ) { actualBody = ExchangeHelper . getMandatoryInBody ( actual , expectedBody . getClass ( ) ) ; } DataSetEndpoint . assertEquals ( "message body" , expectedBody , actualBody , actual ) ; } public long getSize ( ) { return size ; } public void setSize ( long size ) { this . size = size ; } public long getReportCount ( ) { if ( reportCount <= 0 ) { reportCount = getSize ( ) / 5 ; } return reportCount ; } public void setReportCount ( long reportCount ) { this . reportCount = reportCount ; } public Map < String , Object > getDefaultHeaders ( ) { if ( defaultHeaders == null ) { defaultHeaders = new HashMap < String , Object > ( ) ; populateDefaultHeaders ( defaultHeaders ) ; } return defaultHeaders ; } public void setDefaultHeaders ( Map < String , Object > defaultHeaders ) { this . defaultHeaders = defaultHeaders ; } public Processor getOutputTransformer ( ) { return outputTransformer ; } public void setOutputTransformer ( Processor outputTransformer ) { this . outputTransformer = outputTransformer ; } protected abstract Object createMessageBody ( long messageIndex ) ; protected void applyHeaders ( Exchange exchange , long messageIndex ) { } protected void populateDefaultHeaders ( Map < String , Object > map ) { } } 	0	['15', '1', '1', '7', '25', '75', '1', '6', '12', '0.803571429', '139', '1', '1', '0', '0.276190476', '0', '0', '8', '2', '1', '0']
package org . apache . camel . util ; import java . lang . reflect . Array ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import java . util . Map ; import org . w3c . dom . NodeList ; public final class CollectionHelper { private CollectionHelper ( ) { } public static Integer size ( Object value ) { if ( value != null ) { if ( value instanceof Collection ) { Collection collection = ( Collection ) value ; return collection . size ( ) ; } else if ( value instanceof Map ) { Map map = ( Map ) value ; return map . size ( ) ; } else if ( value instanceof Object [ ] ) { Object [ ] array = ( Object [ ] ) value ; return array . length ; } else if ( value . getClass ( ) . isArray ( ) ) { return Array . getLength ( value ) ; } else if ( value instanceof NodeList ) { NodeList nodeList = ( NodeList ) value ; return nodeList . getLength ( ) ; } } return null ; } public static void appendValue ( Map map , Object key , Object value ) { Object oldValue = map . get ( key ) ; if ( oldValue != null ) { List list ; if ( oldValue instanceof List ) { list = ( List ) oldValue ; } else { list = new ArrayList ( ) ; list . add ( oldValue ) ; } list . add ( value ) ; } else { map . put ( key , value ) ; } } } 	1	['3', '1', '0', '2', '15', '3', '2', '0', '2', '2', '91', '0', '0', '0', '0.444444444', '0', '0', '29.33333333', '7', '3.3333', '1']
package org . apache . camel . component . jms ; import javax . jms . JMSException ; import javax . jms . Session ; import javax . jms . TemporaryQueue ; import javax . jms . TemporaryTopic ; import org . springframework . jms . core . JmsOperations ; import org . springframework . jms . core . SessionCallback ; public class JmsProviderMetadata { private Class < ? extends TemporaryQueue > temporaryQueueType ; private Class < ? extends TemporaryTopic > temporaryTopicType ; public Class < ? extends TemporaryQueue > getTemporaryQueueType ( JmsOperations template ) { Class < ? extends TemporaryQueue > answer = getTemporaryQueueType ( ) ; if ( answer == null ) { loadTemporaryDestinationTypes ( template ) ; answer = getTemporaryQueueType ( ) ; } return answer ; } public Class < ? extends TemporaryTopic > getTemporaryTopicType ( JmsOperations template ) { Class < ? extends TemporaryTopic > answer = getTemporaryTopicType ( ) ; if ( answer == null ) { loadTemporaryDestinationTypes ( template ) ; answer = getTemporaryTopicType ( ) ; } return answer ; } public Class < ? extends TemporaryQueue > getTemporaryQueueType ( ) { return temporaryQueueType ; } public void setTemporaryQueueType ( Class < ? extends TemporaryQueue > temporaryQueueType ) { this . temporaryQueueType = temporaryQueueType ; } public Class < ? extends TemporaryTopic > getTemporaryTopicType ( ) { return temporaryTopicType ; } public void setTemporaryTopicType ( Class < ? extends TemporaryTopic > temporaryTopicType ) { this . temporaryTopicType = temporaryTopicType ; } protected void loadTemporaryDestinationTypes ( JmsOperations template ) { if ( template == null ) { throw new IllegalArgumentException ( "No JmsTemplate supplied!" ) ; } template . execute ( new SessionCallback ( ) { public Object doInJms ( Session session ) throws JMSException { TemporaryQueue queue = session . createTemporaryQueue ( ) ; setTemporaryQueueType ( queue . getClass ( ) ) ; TemporaryTopic topic = session . createTemporaryTopic ( ) ; setTemporaryTopicType ( topic . getClass ( ) ) ; queue . delete ( ) ; topic . delete ( ) ; return null ; } } ) ; } } 	0	['8', '1', '0', '5', '12', '24', '3', '3', '7', '0.714285714', '68', '1', '0', '0', '0.541666667', '0', '0', '7.25', '2', '1.25', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . builder . ProcessorBuilder ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "setBody" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class SetBodyType extends ExpressionNode { public SetBodyType ( ) { } public SetBodyType ( Expression expression ) { super ( expression ) ; } @ Override public String toString ( ) { return "SetBody[ " + getExpression ( ) + "]" ; } @ Override public String getShortName ( ) { return "setBody" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { Expression expr = getExpression ( ) . createExpression ( routeContext ) ; return ProcessorBuilder . setBody ( expr ) ; } } 	1	['5', '4', '0', '7', '14', '10', '1', '6', '5', '2', '34', '0', '0', '0.98136646', '0.466666667', '2', '4', '5.8', '1', '0.6', '1']
package org . apache . camel . component . jms . requestor ; import java . util . concurrent . FutureTask ; import javax . jms . JMSException ; import javax . jms . Message ; import org . apache . camel . component . jms . JmsConfiguration . MessageSentCallback ; import org . apache . camel . component . jms . JmsProducer ; import org . apache . camel . util . TimeoutMap ; import org . apache . camel . util . UuidGenerator ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DeferredRequestReplyMap { private static final transient Log LOG = LogFactory . getLog ( DeferredRequestReplyMap . class ) ; private Requestor requestor ; private JmsProducer producer ; private TimeoutMap deferredRequestMap ; private TimeoutMap deferredReplyMap ; public static class DeferredMessageSentCallback implements MessageSentCallback { private DeferredRequestReplyMap map ; private String transitionalID ; private Message message ; private Object monitor ; public DeferredMessageSentCallback ( DeferredRequestReplyMap map , UuidGenerator uuidGenerator , Object monitor ) { transitionalID = uuidGenerator . generateId ( ) ; this . map = map ; this . monitor = monitor ; } public DeferredRequestReplyMap getDeferredRequestReplyMap ( ) { return map ; } public String getID ( ) { return transitionalID ; } public Message getMessage ( ) { return message ; } public void sent ( Message message ) { this . message = message ; map . processDeferredReplies ( monitor , getID ( ) , message ) ; } } public DeferredRequestReplyMap ( Requestor requestor , JmsProducer producer , TimeoutMap deferredRequestMap , TimeoutMap deferredReplyMap ) { this . requestor = requestor ; this . producer = producer ; this . deferredRequestMap = deferredRequestMap ; this . deferredReplyMap = deferredReplyMap ; } public long getRequestTimeout ( ) { return producer . getRequestTimeout ( ) ; } public DeferredMessageSentCallback createDeferredMessageSentCallback ( ) { return new DeferredMessageSentCallback ( this , getUuidGenerator ( ) , requestor ) ; } public void put ( DeferredMessageSentCallback callback , FutureTask futureTask ) { deferredRequestMap . put ( callback . getID ( ) , futureTask , getRequestTimeout ( ) ) ; } public void processDeferredRequests ( String correlationID , Message inMessage ) { processDeferredRequests ( requestor , deferredRequestMap , deferredReplyMap , correlationID , requestor . getMaxRequestTimeout ( ) , inMessage ) ; } public static void processDeferredRequests ( Object monitor , TimeoutMap requestMap , TimeoutMap replyMap , String correlationID , long timeout , Message inMessage ) { synchronized ( monitor ) { try { Object handler = requestMap . get ( correlationID ) ; if ( handler == null ) { if ( requestMap . size ( ) > replyMap . size ( ) ) { replyMap . put ( correlationID , inMessage , timeout ) ; } else { LOG . warn ( "Response received for unknown correlationID: " + correlationID + "; response: " + inMessage ) ; } } if ( handler != null && handler instanceof ReplyHandler ) { ReplyHandler replyHandler = ( ReplyHandler ) handler ; boolean complete = replyHandler . handle ( inMessage ) ; if ( complete ) { requestMap . remove ( correlationID ) ; } } } catch ( JMSException e ) { throw new FailedToProcessResponse ( inMessage , e ) ; } } } public void processDeferredReplies ( Object monitor , String transitionalID , Message outMessage ) { synchronized ( monitor ) { try { Object handler = deferredRequestMap . get ( transitionalID ) ; if ( handler == null ) { return ; } deferredRequestMap . remove ( transitionalID ) ; String correlationID = outMessage . getJMSMessageID ( ) ; Object in = deferredReplyMap . get ( correlationID ) ; if ( in != null && in instanceof Message ) { Message inMessage = ( Message ) in ; if ( handler instanceof ReplyHandler ) { ReplyHandler replyHandler = ( ReplyHandler ) handler ; try { boolean complete = replyHandler . handle ( inMessage ) ; if ( complete ) { deferredReplyMap . remove ( correlationID ) ; } } catch ( JMSException e ) { throw new FailedToProcessResponse ( inMessage , e ) ; } } } else { deferredRequestMap . put ( correlationID , handler , getRequestTimeout ( ) ) ; } } catch ( JMSException e ) { throw new FailedToProcessResponse ( outMessage , e ) ; } } } protected UuidGenerator getUuidGenerator ( ) { return producer . getUuidGenerator ( ) ; } } 	0	['9', '1', '0', '9', '28', '12', '3', '9', '7', '0.65', '224', '1', '4', '0', '0.275', '0', '0', '23.33333333', '4', '1.3333', '0']
package org . apache . camel . processor . exceptionpolicy ; import java . util . Map ; import java . util . Set ; import org . apache . camel . Exchange ; import org . apache . camel . model . ExceptionType ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DefaultExceptionPolicyStrategy implements ExceptionPolicyStrategy { private static final transient Log LOG = LogFactory . getLog ( DefaultExceptionPolicyStrategy . class ) ; public ExceptionType getExceptionPolicy ( Map < Class , ExceptionType > exceptionPolicices , Exchange exchange , Throwable exception ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Finding best suited exception policy for thrown exception " + exception . getClass ( ) . getName ( ) ) ; } int targetLevel = getInheritanceLevel ( exception . getClass ( ) ) ; ExceptionType candidate = null ; int candidateDiff = Integer . MAX_VALUE ; Set < Map . Entry < Class , ExceptionType > > entries = exceptionPolicices . entrySet ( ) ; for ( Map . Entry < Class , ExceptionType > entry : entries ) { Class clazz = entry . getKey ( ) ; ExceptionType type = entry . getValue ( ) ; if ( clazz . isInstance ( exception ) ) { if ( clazz . equals ( exception . getClass ( ) ) ) { candidate = type ; break ; } int level = getInheritanceLevel ( clazz ) ; int diff = targetLevel - level ; if ( diff < candidateDiff ) { candidate = type ; candidateDiff = diff ; } } } if ( LOG . isDebugEnabled ( ) ) { if ( candidate != null ) { LOG . debug ( "Using " + candidate + " as the exception policy" ) ; } else { LOG . debug ( "No candidate found to be used as exception policy" ) ; } } return candidate ; } private static int getInheritanceLevel ( Class clazz ) { if ( clazz == null || "java.lang.Object" . equals ( clazz . getName ( ) ) ) { return 0 ; } return 1 + getInheritanceLevel ( clazz . getSuperclass ( ) ) ; } } 	1	['4', '1', '0', '6', '24', '4', '1', '5', '2', '0.666666667', '121', '1', '0', '0', '0.4', '0', '0', '29', '6', '2.25', '2']
package org . apache . camel . component . file . remote ; import java . io . ByteArrayOutputStream ; import org . apache . camel . CamelContext ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; public class RemoteFileExchange < T extends RemoteFileBinding > extends DefaultExchange { private T binding ; public RemoteFileExchange ( CamelContext context , ExchangePattern pattern , T binding ) { super ( context , pattern ) ; this . binding = binding ; } public RemoteFileExchange ( CamelContext context , ExchangePattern pattern , T binding , String host , String fullFileName , ByteArrayOutputStream outputStream ) { this ( context , pattern , binding ) ; setIn ( new RemoteFileMessage ( host , fullFileName , outputStream ) ) ; } public T getBinding ( ) { return binding ; } public void setBinding ( T binding ) { this . binding = binding ; } } 	0	['4', '2', '0', '11', '7', '0', '7', '6', '4', '0', '34', '1', '1', '0.95', '0.541666667', '0', '0', '7.25', '1', '0.5', '0']
package org . apache . camel . util ; import java . io . UnsupportedEncodingException ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URLDecoder ; import java . net . URLEncoder ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class URISupport { public static class CompositeData { public String host ; String scheme ; String path ; URI components [ ] ; Map parameters ; String fragment ; public URI [ ] getComponents ( ) { return components ; } public String getFragment ( ) { return fragment ; } public Map getParameters ( ) { return parameters ; } public String getScheme ( ) { return scheme ; } public String getPath ( ) { return path ; } public String getHost ( ) { return host ; } public URI toURI ( ) throws URISyntaxException { StringBuffer sb = new StringBuffer ( ) ; if ( scheme != null ) { sb . append ( scheme ) ; sb . append ( ':' ) ; } if ( host != null && host . length ( ) != 0 ) { sb . append ( host ) ; } else { sb . append ( '(' ) ; for ( int i = 0 ; i < components . length ; i ++ ) { if ( i != 0 ) { sb . append ( ',' ) ; } sb . append ( components [ i ] . toString ( ) ) ; } sb . append ( ')' ) ; } if ( path != null ) { sb . append ( '/' ) ; sb . append ( path ) ; } if ( ! parameters . isEmpty ( ) ) { sb . append ( "?" ) ; sb . append ( createQueryString ( parameters ) ) ; } if ( fragment != null ) { sb . append ( "#" ) ; sb . append ( fragment ) ; } return new URI ( sb . toString ( ) ) ; } } public static Map parseQuery ( String uri ) throws URISyntaxException { try { Map rc = new HashMap ( ) ; if ( uri != null ) { String [ ] parameters = uri . split ( "&" ) ; for ( String parameter : parameters ) { int p = parameter . indexOf ( "=" ) ; if ( p >= 0 ) { String name = URLDecoder . decode ( parameter . substring ( 0 , p ) , "UTF-8" ) ; String value = URLDecoder . decode ( parameter . substring ( p + 1 ) , "UTF-8" ) ; rc . put ( name , value ) ; } else { rc . put ( parameter , null ) ; } } } return rc ; } catch ( UnsupportedEncodingException e ) { throw ( URISyntaxException ) new URISyntaxException ( e . toString ( ) , "Invalid encoding" ) . initCause ( e ) ; } } public static Map parseParameters ( URI uri ) throws URISyntaxException { String query = uri . getQuery ( ) ; if ( query == null ) { String schemeSpecificPart = uri . getSchemeSpecificPart ( ) ; int idx = schemeSpecificPart . lastIndexOf ( '?' ) ; if ( idx < 0 ) { return Collections . EMPTY_MAP ; } else { query = schemeSpecificPart . substring ( idx + 1 ) ; } } else { query = stripPrefix ( query , "?" ) ; } return parseQuery ( query ) ; } public static URI removeQuery ( URI uri ) throws URISyntaxException { return createURIWithQuery ( uri , null ) ; } public static URI createURIWithQuery ( URI uri , String query ) throws URISyntaxException { return new URI ( uri . getScheme ( ) , uri . getUserInfo ( ) , uri . getHost ( ) , uri . getPort ( ) , uri . getPath ( ) , query , uri . getFragment ( ) ) ; } public static CompositeData parseComposite ( URI uri ) throws URISyntaxException { CompositeData rc = new CompositeData ( ) ; rc . scheme = uri . getScheme ( ) ; String ssp = stripPrefix ( uri . getSchemeSpecificPart ( ) . trim ( ) , "//" ) . trim ( ) ; parseComposite ( uri , rc , ssp ) ; rc . fragment = uri . getFragment ( ) ; return rc ; } private static void parseComposite ( URI uri , CompositeData rc , String ssp ) throws URISyntaxException { String componentString ; String params ; if ( ! checkParenthesis ( ssp ) ) { throw new URISyntaxException ( uri . toString ( ) , "Not a matching number of '(' and ')' parenthesis" ) ; } int p ; int intialParen = ssp . indexOf ( "(" ) ; if ( intialParen == 0 ) { rc . host = ssp . substring ( 0 , intialParen ) ; p = rc . host . indexOf ( "/" ) ; if ( p >= 0 ) { rc . path = rc . host . substring ( p ) ; rc . host = rc . host . substring ( 0 , p ) ; } p = ssp . lastIndexOf ( ")" ) ; componentString = ssp . substring ( intialParen + 1 , p ) ; params = ssp . substring ( p + 1 ) . trim ( ) ; } else { componentString = ssp ; params = "" ; } String components [ ] = splitComponents ( componentString ) ; rc . components = new URI [ components . length ] ; for ( int i = 0 ; i < components . length ; i ++ ) { rc . components [ i ] = new URI ( components [ i ] . trim ( ) ) ; } p = params . indexOf ( "?" ) ; if ( p >= 0 ) { if ( p > 0 ) { rc . path = stripPrefix ( params . substring ( 0 , p ) , "/" ) ; } rc . parameters = parseQuery ( params . substring ( p + 1 ) ) ; } else { if ( params . length ( ) > 0 ) { rc . path = stripPrefix ( params , "/" ) ; } rc . parameters = Collections . EMPTY_MAP ; } } private static String [ ] splitComponents ( String str ) { ArrayList l = new ArrayList ( ) ; int last = 0 ; int depth = 0 ; char chars [ ] = str . toCharArray ( ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { switch ( chars [ i ] ) { case '(' : depth ++ ; break ; case ')' : depth -- ; break ; case ',' : if ( depth == 0 ) { String s = str . substring ( last , i ) ; l . add ( s ) ; last = i + 1 ; } break ; default : } } String s = str . substring ( last ) ; if ( s . length ( ) != 0 ) { l . add ( s ) ; } String rc [ ] = new String [ l . size ( ) ] ; l . toArray ( rc ) ; return rc ; } public static String stripPrefix ( String value , String prefix ) { if ( value . startsWith ( prefix ) ) { return value . substring ( prefix . length ( ) ) ; } return value ; } public static URI stripScheme ( URI uri ) throws URISyntaxException { return new URI ( stripPrefix ( uri . getSchemeSpecificPart ( ) . trim ( ) , "//" ) ) ; } public static String createQueryString ( Map options ) throws URISyntaxException { try { if ( options . size ( ) > 0 ) { StringBuffer rc = new StringBuffer ( ) ; boolean first = true ; for ( Iterator iter = options . keySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { if ( first ) { first = false ; } else { rc . append ( "&" ) ; } String key = ( String ) iter . next ( ) ; String value = ( String ) options . get ( key ) ; rc . append ( URLEncoder . encode ( key , "UTF-8" ) ) ; rc . append ( "=" ) ; rc . append ( URLEncoder . encode ( value , "UTF-8" ) ) ; } return rc . toString ( ) ; } else { return "" ; } } catch ( UnsupportedEncodingException e ) { throw ( URISyntaxException ) new URISyntaxException ( e . toString ( ) , "Invalid encoding" ) . initCause ( e ) ; } } public static URI createRemainingURI ( URI originalURI , Map params ) throws URISyntaxException { String s = createQueryString ( params ) ; if ( s . length ( ) == 0 ) { s = null ; } return createURIWithQuery ( originalURI , s ) ; } public static URI changeScheme ( URI bindAddr , String scheme ) throws URISyntaxException { return new URI ( scheme , bindAddr . getUserInfo ( ) , bindAddr . getHost ( ) , bindAddr . getPort ( ) , bindAddr . getPath ( ) , bindAddr . getQuery ( ) , bindAddr . getFragment ( ) ) ; } public static boolean checkParenthesis ( String str ) { boolean result = true ; if ( str != null ) { int open = 0 ; int closed = 0 ; int i = 0 ; while ( ( i = str . indexOf ( '(' , i ) ) >= 0 ) { i ++ ; open ++ ; } i = 0 ; while ( ( i = str . indexOf ( ')' , i ) ) >= 0 ) { i ++ ; closed ++ ; } result = open == closed ; } return result ; } @ Deprecated public int indexOfParenthesisMatch ( String str ) { int result = - 1 ; return result ; } } 	1	['15', '1', '0', '3', '59', '105', '3', '1', '13', '2', '519', '0', '0', '0', '0.28', '0', '0', '33.6', '5', '1.5333', '1']
package org . apache . camel . component . uface ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . component . list . ListEndpoint ; import org . apache . camel . util . ObjectHelper ; import org . eclipse . core . databinding . observable . Realm ; import org . eclipse . core . databinding . observable . list . WritableList ; public class UFaceEndpoint extends ListEndpoint { public UFaceEndpoint ( String uri , UFaceComponent component ) { super ( uri , component ) ; } public UFaceEndpoint ( String endpointUri ) { super ( endpointUri ) ; } @ Override protected List < Exchange > createExchangeList ( ) { Realm realm = Realm . getDefault ( ) ; ObjectHelper . notNull ( realm , "DataBinding Realm" ) ; return new WritableList ( realm ) ; } } 	0	['3', '3', '0', '6', '8', '3', '1', '6', '2', '2', '22', '0', '0', '0.970588235', '0.666666667', '1', '1', '6.333333333', '1', '0.3333', '0']
package org . apache . camel . processor ; import java . util . Collection ; import java . util . Iterator ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . PollingConsumer ; import org . apache . camel . Processor ; import org . apache . camel . impl . LoggingExceptionHandler ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . spi . ExceptionHandler ; import org . apache . camel . util . ServiceHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class BatchProcessor extends ServiceSupport implements Runnable , Processor { public static final long DEFAULT_BATCH_TIMEOUT = 1000L ; public static final int DEFAULT_BATCH_SIZE = 100 ; private static final transient Log LOG = LogFactory . getLog ( BatchProcessor . class ) ; private Endpoint endpoint ; private Processor processor ; private Collection < Exchange > collection ; private long batchTimeout = DEFAULT_BATCH_TIMEOUT ; private int batchSize = DEFAULT_BATCH_SIZE ; private PollingConsumer consumer ; private ExceptionHandler exceptionHandler ; public BatchProcessor ( Endpoint endpoint , Processor processor , Collection < Exchange > collection ) { this . endpoint = endpoint ; this . processor = processor ; this . collection = collection ; } @ Override public String toString ( ) { return "BatchProcessor[to: " + processor + "]" ; } public void run ( ) { LOG . debug ( "Starting thread for " + this ) ; while ( isRunAllowed ( ) ) { try { processBatch ( ) ; } catch ( Exception e ) { getExceptionHandler ( ) . handleException ( e ) ; } } collection . clear ( ) ; } public ExceptionHandler getExceptionHandler ( ) { if ( exceptionHandler == null ) { exceptionHandler = new LoggingExceptionHandler ( getClass ( ) ) ; } return exceptionHandler ; } public void setExceptionHandler ( ExceptionHandler exceptionHandler ) { this . exceptionHandler = exceptionHandler ; } public int getBatchSize ( ) { return batchSize ; } public void setBatchSize ( int batchSize ) { this . batchSize = batchSize ; } public long getBatchTimeout ( ) { return batchTimeout ; } public void setBatchTimeout ( long batchTimeout ) { this . batchTimeout = batchTimeout ; } public Endpoint getEndpoint ( ) { return endpoint ; } public Processor getProcessor ( ) { return processor ; } protected synchronized void processBatch ( ) throws Exception { long start = System . currentTimeMillis ( ) ; long end = start + batchTimeout ; for ( int i = 0 ; ! isBatchCompleted ( i ) ; i ++ ) { long timeout = end - System . currentTimeMillis ( ) ; if ( timeout < 0L ) { LOG . debug ( "batch timeout expired at batch index:" + i ) ; break ; } Exchange exchange = consumer . receive ( timeout ) ; if ( exchange == null ) { LOG . debug ( "receive with timeout: " + timeout + " expired at batch index:" + i ) ; break ; } collection . add ( exchange ) ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Finished batch size: " + batchSize + " timeout: " + batchTimeout + " so sending set: " + collection ) ; } Iterator < Exchange > iter = collection . iterator ( ) ; while ( iter . hasNext ( ) ) { Exchange exchange = iter . next ( ) ; iter . remove ( ) ; processExchange ( exchange ) ; } } protected boolean isBatchCompleted ( int index ) { return index >= batchSize ; } protected void processExchange ( Exchange exchange ) throws Exception { processor . process ( exchange ) ; } protected void doStart ( ) throws Exception { consumer = endpoint . createPollingConsumer ( ) ; ServiceHelper . startServices ( processor , consumer ) ; Thread thread = new Thread ( this , this + " Polling Thread" ) ; thread . start ( ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( consumer , processor ) ; collection . clear ( ) ; } protected Collection < Exchange > getCollection ( ) { return collection ; } public void process ( Exchange exchange ) throws Exception { } } 	1	['19', '2', '2', '12', '47', '83', '2', '10', '12', '0.855555556', '297', '0.8', '4', '0.433333333', '0.1875', '1', '1', '14.10526316', '2', '1.0526', '6']
package org . apache . camel . component . mina ; import java . net . InetSocketAddress ; import java . net . SocketAddress ; import java . net . URI ; import java . nio . charset . CharacterCodingException ; import java . nio . charset . Charset ; import java . nio . charset . CharsetEncoder ; import java . util . Map ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultComponent ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . mina . common . ByteBuffer ; import org . apache . mina . common . IoAcceptor ; import org . apache . mina . common . IoConnector ; import org . apache . mina . common . IoServiceConfig ; import org . apache . mina . common . IoSession ; import org . apache . mina . filter . LoggingFilter ; import org . apache . mina . filter . codec . ProtocolCodecFactory ; import org . apache . mina . filter . codec . ProtocolCodecFilter ; import org . apache . mina . filter . codec . ProtocolDecoder ; import org . apache . mina . filter . codec . ProtocolDecoderOutput ; import org . apache . mina . filter . codec . ProtocolEncoder ; import org . apache . mina . filter . codec . ProtocolEncoderOutput ; import org . apache . mina . filter . codec . serialization . ObjectSerializationCodecFactory ; import org . apache . mina . filter . codec . textline . TextLineCodecFactory ; import org . apache . mina . transport . socket . nio . DatagramAcceptor ; import org . apache . mina . transport . socket . nio . DatagramAcceptorConfig ; import org . apache . mina . transport . socket . nio . DatagramConnector ; import org . apache . mina . transport . socket . nio . DatagramConnectorConfig ; import org . apache . mina . transport . socket . nio . SocketAcceptor ; import org . apache . mina . transport . socket . nio . SocketAcceptorConfig ; import org . apache . mina . transport . socket . nio . SocketConnector ; import org . apache . mina . transport . socket . nio . SocketConnectorConfig ; import org . apache . mina . transport . vmpipe . VmPipeAcceptor ; import org . apache . mina . transport . vmpipe . VmPipeAddress ; import org . apache . mina . transport . vmpipe . VmPipeConnector ; public class MinaComponent extends DefaultComponent < MinaExchange > { private static final transient Log LOG = LogFactory . getLog ( MinaComponent . class ) ; private static final long DEFAULT_CONNECT_TIMEOUT = 30000 ; private CharsetEncoder encoder ; public MinaComponent ( ) { } public MinaComponent ( CamelContext context ) { super ( context ) ; } @ Override protected Endpoint < MinaExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Creating MinaEndpoint from uri: " + uri ) ; } URI u = new URI ( remaining ) ; String protocol = u . getScheme ( ) ; if ( protocol != null ) { if ( protocol . equals ( "tcp" ) ) { return createSocketEndpoint ( uri , u , parameters ) ; } else if ( protocol . equals ( "udp" ) || protocol . equals ( "mcast" ) || protocol . equals ( "multicast" ) ) { return createDatagramEndpoint ( uri , u , parameters ) ; } else if ( protocol . equals ( "vm" ) ) { return createVmEndpoint ( uri , u ) ; } } throw new IllegalArgumentException ( "Unrecognised MINA protocol: " + protocol + " for uri: " + uri ) ; } protected MinaEndpoint createVmEndpoint ( String uri , URI connectUri ) { IoAcceptor acceptor = new VmPipeAcceptor ( ) ; SocketAddress address = new VmPipeAddress ( connectUri . getPort ( ) ) ; IoConnector connector = new VmPipeConnector ( ) ; return new MinaEndpoint ( uri , this , address , acceptor , null , connector , null , false , 0 , false ) ; } protected MinaEndpoint createSocketEndpoint ( String uri , URI connectUri , Map parameters ) { IoAcceptor acceptor = new SocketAcceptor ( ) ; SocketAddress address = new InetSocketAddress ( connectUri . getHost ( ) , connectUri . getPort ( ) ) ; IoConnector connector = new SocketConnector ( ) ; boolean lazySessionCreation = getAndRemoveParameter ( parameters , "lazySessionCreation" , Boolean . class , false ) ; long timeout = getAndRemoveParameter ( parameters , "timeout" , Long . class , 0L ) ; boolean transferExchange = getAndRemoveParameter ( parameters , "transferExchange" , Boolean . class , false ) ; boolean sync = getAndRemoveParameter ( parameters , "sync" , Boolean . class , false ) ; boolean minaLogger = getAndRemoveParameter ( parameters , "minaLogger" , Boolean . class , false ) ; boolean textline = getAndRemoveParameter ( parameters , "textline" , Boolean . class , false ) ; String encoding = getAndRemoveParameter ( parameters , "encoding" , String . class ) ; String codec = getAndRemoveParameter ( parameters , "codec" , String . class ) ; SocketConnectorConfig connectorConfig = new SocketConnectorConfig ( ) ; configureSocketCodecFactory ( "MinaProducer" , connectorConfig , textline , encoding , codec ) ; if ( minaLogger ) { connectorConfig . getFilterChain ( ) . addLast ( "logger" , new LoggingFilter ( ) ) ; } long connectTimeout = timeout > 0 ? timeout : DEFAULT_CONNECT_TIMEOUT ; connectorConfig . setConnectTimeout ( ( int ) ( connectTimeout / 1000 ) ) ; SocketAcceptorConfig acceptorConfig = new SocketAcceptorConfig ( ) ; configureSocketCodecFactory ( "MinaConsumer" , acceptorConfig , textline , encoding , codec ) ; acceptorConfig . setReuseAddress ( true ) ; acceptorConfig . setDisconnectOnUnbind ( true ) ; if ( minaLogger ) { acceptorConfig . getFilterChain ( ) . addLast ( "logger" , new LoggingFilter ( ) ) ; } MinaEndpoint endpoint = new MinaEndpoint ( uri , this , address , acceptor , acceptorConfig , connector , connectorConfig , lazySessionCreation , timeout , transferExchange ) ; if ( sync ) { endpoint . setExchangePattern ( ExchangePattern . InOut ) ; } else { endpoint . setExchangePattern ( ExchangePattern . InOnly ) ; } return endpoint ; } protected void configureSocketCodecFactory ( String type , IoServiceConfig config , boolean textline , String encoding , String codec ) { ProtocolCodecFactory codecFactory = getCodecFactory ( type , codec ) ; if ( codecFactory == null ) { if ( textline ) { Charset charset = getEncodingParameter ( type , encoding ) ; codecFactory = new TextLineCodecFactory ( charset ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( type + ": Using TextLineCodecFactory: " + codecFactory + " using encoding: " + encoding ) ; } } else { codecFactory = new ObjectSerializationCodecFactory ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( type + ": Using ObjectSerializationCodecFactory: " + codecFactory ) ; } } } addCodecFactory ( config , codecFactory ) ; } protected MinaEndpoint createDatagramEndpoint ( String uri , URI connectUri , Map parameters ) { IoAcceptor acceptor = new DatagramAcceptor ( ) ; SocketAddress address = new InetSocketAddress ( connectUri . getHost ( ) , connectUri . getPort ( ) ) ; IoConnector connector = new DatagramConnector ( ) ; boolean lazySessionCreation = getAndRemoveParameter ( parameters , "lazySessionCreation" , Boolean . class , false ) ; long timeout = getAndRemoveParameter ( parameters , "timeout" , Long . class , 0L ) ; boolean transferExchange = false ; boolean sync = getAndRemoveParameter ( parameters , "sync" , Boolean . class , false ) ; boolean minaLogger = getAndRemoveParameter ( parameters , "minaLogger" , Boolean . class , false ) ; String encoding = getAndRemoveParameter ( parameters , "encoding" , String . class ) ; String codec = getAndRemoveParameter ( parameters , "codec" , String . class ) ; DatagramConnectorConfig connectorConfig = new DatagramConnectorConfig ( ) ; configureDataGramCodecFactory ( "MinaProducer" , connectorConfig , encoding , codec ) ; if ( minaLogger ) { connectorConfig . getFilterChain ( ) . addLast ( "logger" , new LoggingFilter ( ) ) ; } long connectTimeout = timeout > 0 ? timeout : DEFAULT_CONNECT_TIMEOUT ; connectorConfig . setConnectTimeout ( ( int ) ( connectTimeout / 1000 ) ) ; DatagramAcceptorConfig acceptorConfig = new DatagramAcceptorConfig ( ) ; configureDataGramCodecFactory ( "MinaConsumer" , acceptorConfig , encoding , codec ) ; acceptorConfig . setDisconnectOnUnbind ( true ) ; if ( minaLogger ) { acceptorConfig . getFilterChain ( ) . addLast ( "logger" , new LoggingFilter ( ) ) ; } MinaEndpoint endpoint = new MinaEndpoint ( uri , this , address , acceptor , acceptorConfig , connector , connectorConfig , lazySessionCreation , timeout , transferExchange ) ; if ( sync ) { endpoint . setExchangePattern ( ExchangePattern . InOut ) ; } else { endpoint . setExchangePattern ( ExchangePattern . InOnly ) ; } return endpoint ; } private Charset getEncodingParameter ( String type , String encoding ) { if ( encoding == null ) { encoding = Charset . defaultCharset ( ) . name ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( type + ": No encoding parameter using default charset: " + encoding ) ; } } if ( ! Charset . isSupported ( encoding ) ) { throw new IllegalArgumentException ( "The encoding: " + encoding + " is not supported" ) ; } return Charset . forName ( encoding ) ; } protected void configureDataGramCodecFactory ( String type , IoServiceConfig config , String encoding , String codec ) { ProtocolCodecFactory codecFactory = getCodecFactory ( type , codec ) ; if ( codecFactory == null ) { codecFactory = new ProtocolCodecFactory ( ) { public ProtocolEncoder getEncoder ( ) throws Exception { return new ProtocolEncoder ( ) { public void encode ( IoSession session , Object message , ProtocolEncoderOutput out ) throws Exception { ByteBuffer buf = toByteBuffer ( message ) ; buf . flip ( ) ; out . write ( buf ) ; } public void dispose ( IoSession session ) throws Exception { } } ; } public ProtocolDecoder getDecoder ( ) throws Exception { return new ProtocolDecoder ( ) { public void decode ( IoSession session , ByteBuffer in , ProtocolDecoderOutput out ) throws Exception { in . acquire ( ) ; out . write ( in ) ; } public void finishDecode ( IoSession session , ProtocolDecoderOutput out ) throws Exception { } public void dispose ( IoSession session ) throws Exception { } } ; } } ; Charset charset = getEncodingParameter ( type , encoding ) ; encoder = charset . newEncoder ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( type + ": Using CodecFactory: " + codecFactory + " using encoding: " + encoding ) ; } } addCodecFactory ( config , codecFactory ) ; } protected ByteBuffer toByteBuffer ( Object message ) throws CharacterCodingException { ByteBuffer answer = convertTo ( ByteBuffer . class , message ) ; if ( answer == null ) { String value = convertTo ( String . class , message ) ; answer = ByteBuffer . allocate ( value . length ( ) ) . setAutoExpand ( true ) ; answer . putString ( value , encoder ) ; } return answer ; } protected ProtocolCodecFactory getCodecFactory ( String type , String codec ) { ProtocolCodecFactory codecFactory = null ; if ( codec != null ) { codecFactory = getCamelContext ( ) . getRegistry ( ) . lookup ( codec , ProtocolCodecFactory . class ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( type + ": Using custom CodecFactory: " + codecFactory ) ; } } return codecFactory ; } protected void addCodecFactory ( IoServiceConfig config , ProtocolCodecFactory codecFactory ) { config . getFilterChain ( ) . addLast ( "codec" , new ProtocolCodecFilter ( codecFactory ) ) ; } } 	0	['13', '3', '0', '34', '77', '46', '3', '33', '2', '0.777777778', '672', '1', '0', '0.772727273', '0.305555556', '2', '2', '50.46153846', '5', '2.1538', '0']
package org . apache . camel . component . seda ; import java . util . concurrent . BlockingQueue ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class QueueComponent extends SedaComponent { private static final transient Log LOG = LogFactory . getLog ( QueueComponent . class ) ; public QueueComponent ( ) { LOG . warn ( "This component has been deprecated; please use the seda: URI format instead of queue:" ) ; } } 	1	['2', '4', '0', '3', '5', '0', '0', '3', '1', '0', '13', '1', '0', '1', '1', '0', '0', '5', '0', '0', '1']
package org . apache . camel . spi ; public interface Registry { < T > T lookup ( String name , Class < T > type ) ; Object lookup ( String name ) ; } 	0	['2', '1', '0', '18', '2', '1', '18', '0', '2', '2', '2', '0', '0', '0', '0.833333333', '0', '0', '0', '1', '1', '0']
package org . apache . camel ; import java . util . Map ; public interface Endpoint < E extends Exchange > { boolean isSingleton ( ) ; String getEndpointUri ( ) ; E createExchange ( ) ; E createExchange ( ExchangePattern pattern ) ; E createExchange ( Exchange exchange ) ; CamelContext getCamelContext ( ) ; Producer < E > createProducer ( ) throws Exception ; Consumer < E > createConsumer ( Processor processor ) throws Exception ; PollingConsumer < E > createPollingConsumer ( ) throws Exception ; void configureProperties ( Map options ) ; void setCamelContext ( CamelContext context ) ; @ Deprecated CamelContext getContext ( ) ; @ Deprecated void setContext ( CamelContext context ) ; } 	1	['13', '1', '0', '176', '13', '78', '171', '7', '13', '2', '13', '0', '0', '0', '0.243589744', '0', '0', '0', '1', '1', '2']
package org . apache . camel . component . mail . security ; import java . security . cert . CertificateException ; import java . security . cert . X509Certificate ; import javax . net . ssl . X509TrustManager ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DummyTrustManager implements X509TrustManager { private static final transient Log LOG = LogFactory . getLog ( DummyTrustManager . class ) ; public void checkClientTrusted ( X509Certificate [ ] chain , String authType ) throws CertificateException { logCertificateChain ( "Client" , chain ) ; } public void checkServerTrusted ( X509Certificate [ ] chain , String authType ) throws CertificateException { logCertificateChain ( "Server" , chain ) ; } public X509Certificate [ ] getAcceptedIssuers ( ) { return new X509Certificate [ 0 ] ; } private static void logCertificateChain ( String type , X509Certificate [ ] chain ) { if ( LOG . isDebugEnabled ( ) ) { for ( X509Certificate certificate : chain ) { LOG . debug ( type + " certificate is trusted: " + certificate ) ; } } } } 	0	['6', '1', '0', '3', '14', '13', '1', '2', '4', '0.4', '57', '1', '0', '0', '0.666666667', '0', '0', '8.333333333', '3', '1', '0']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . RecipientList ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "recipientList" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class RecipientListType extends ExpressionNode { public RecipientListType ( ) { } public RecipientListType ( ExpressionType expression ) { super ( expression ) ; } public RecipientListType ( Expression expression ) { super ( expression ) ; } @ Override public String toString ( ) { return "RecipientList[ " + getExpression ( ) + "]" ; } @ Override public String getShortName ( ) { return "recipientList" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { return new RecipientList ( getExpression ( ) . createExpression ( routeContext ) ) ; } } 	1	['6', '4', '0', '8', '16', '15', '2', '6', '6', '2', '39', '0', '0', '0.98136646', '0.375', '2', '3', '5.5', '1', '0.5', '1']
package org . apache . camel . component . cxf . spring ; import org . springframework . beans . factory . xml . NamespaceHandlerSupport ; public class NamespaceHandler extends NamespaceHandlerSupport { public void init ( ) { registerBeanDefinitionParser ( "cxfEndpoint" , new CxfEndpointBeanDefinitionParser ( ) ) ; } } 	0	['2', '0', '0', '3', '5', '1', '0', '3', '2', '2', '12', '0', '0', '0', '1', '0', '0', '5', '1', '0.5', '0']
package org . apache . camel . model ; import java . util . Collections ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Processor ; import org . apache . camel . processor . ConvertBodyProcessor ; import org . apache . camel . spi . RouteContext ; import org . apache . camel . util . ObjectHelper ; @ XmlRootElement ( name = "convertBodyTo" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ConvertBodyType extends ProcessorType < ProcessorType > { @ XmlAttribute private String type ; @ XmlTransient private Class typeClass ; public ConvertBodyType ( ) { } public ConvertBodyType ( String type ) { setType ( type ) ; } public ConvertBodyType ( Class typeClass ) { setTypeClass ( typeClass ) ; } @ Override public String toString ( ) { return "convertBodyTo[ " + getType ( ) + "]" ; } @ Override public String getShortName ( ) { return "convertBodyTo" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { return new ConvertBodyProcessor ( getTypeClass ( ) ) ; } @ Override public List < ProcessorType < ? > > getOutputs ( ) { return Collections . EMPTY_LIST ; } protected Class createTypeClass ( ) { return ObjectHelper . loadClass ( getType ( ) , getClass ( ) . getClassLoader ( ) ) ; } public void setType ( String type ) { this . type = type ; } public String getType ( ) { return type ; } public void setTypeClass ( Class typeClass ) { this . typeClass = typeClass ; } public Class getTypeClass ( ) { if ( typeClass == null ) { setTypeClass ( createTypeClass ( ) ) ; } return typeClass ; } } 	1	['12', '3', '0', '5', '20', '62', '1', '5', '11', '0.636363636', '79', '1', '0', '0.943396226', '0.354166667', '1', '2', '5.416666667', '2', '0.8333', '3']
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "xpath" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class XPathExpression extends NamespaceAwareExpression { @ XmlAttribute ( required = false ) private Class resultType ; public XPathExpression ( ) { } public XPathExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "xpath" ; } public Class getResultType ( ) { return resultType ; } public void setResultType ( Class resultType ) { this . resultType = resultType ; } @ Override protected void configureExpression ( RouteContext routeContext , Expression expression ) { super . configureExpression ( routeContext , expression ) ; if ( resultType != null ) { setProperty ( expression , "resultType" , resultType ) ; } } @ Override protected void configurePredicate ( RouteContext routeContext , Predicate predicate ) { super . configurePredicate ( routeContext , predicate ) ; if ( resultType != null ) { setProperty ( predicate , "resultType" , resultType ) ; } } } 	0	['7', '3', '0', '6', '12', '9', '2', '4', '5', '0.5', '52', '1', '0', '0.84375', '0.30952381', '1', '4', '6.285714286', '2', '1', '0']
package org . apache . camel ; import java . util . Map ; public interface ProducerTemplate < E extends Exchange > extends Service { E send ( E exchange ) ; E send ( Processor processor ) ; Object sendBody ( Object body ) ; Object sendBodyAndHeader ( Object body , String header , Object headerValue ) ; Object sendBodyAndHeaders ( Object body , Map < String , Object > headers ) ; E send ( String endpointUri , E exchange ) ; E send ( String endpointUri , Processor processor ) ; E send ( String endpointUri , ExchangePattern pattern , Processor processor ) ; E send ( String endpointUri , Processor processor , AsyncCallback callback ) ; E send ( Endpoint < E > endpoint , E exchange ) ; E send ( Endpoint < E > endpoint , Processor processor ) ; E send ( Endpoint < E > endpoint , ExchangePattern pattern , Processor processor ) ; E send ( Endpoint < E > endpoint , Processor processor , AsyncCallback callback ) ; Object sendBody ( Endpoint < E > endpoint , Object body ) ; Object sendBody ( String endpointUri , Object body ) ; Object sendBody ( Endpoint < E > endpoint , ExchangePattern pattern , Object body ) ; Object sendBody ( String endpointUri , ExchangePattern pattern , Object body ) ; Object sendBodyAndHeader ( String endpointUri , Object body , String header , Object headerValue ) ; Object sendBodyAndHeader ( Endpoint endpoint , Object body , String header , Object headerValue ) ; Object sendBodyAndHeader ( Endpoint endpoint , ExchangePattern pattern , Object body , String header , Object headerValue ) ; Object sendBodyAndHeader ( String endpoint , ExchangePattern pattern , Object body , String header , Object headerValue ) ; Object sendBodyAndHeaders ( String endpointUri , Object body , Map < String , Object > headers ) ; Object sendBodyAndHeaders ( Endpoint endpoint , Object body , Map < String , Object > headers ) ; E request ( Endpoint < E > endpoint , Processor processor ) ; Object requestBody ( Endpoint < E > endpoint , Object body ) ; Object requestBodyAndHeader ( Endpoint < E > endpoint , Object body , String header , Object headerValue ) ; E request ( String endpointUri , Processor processor ) ; Object requestBody ( String endpointUri , Object body ) ; Object requestBodyAndHeader ( String endpointUri , Object body , String header , Object headerValue ) ; } 	1	['29', '1', '0', '14', '29', '406', '8', '6', '29', '2', '29', '0', '0', '0', '0.37164751', '0', '0', '0', '1', '1', '3']
package org . apache . camel . language ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import org . apache . camel . component . bean . XPathAnnotationExpressionFactory ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . PARAMETER } ) @ LanguageAnnotation ( language = "xpath" , factory = XPathAnnotationExpressionFactory . class ) public @ interface XPath { String value ( ) ; NamespacePrefix [ ] namespaces ( ) default { @ NamespacePrefix ( prefix = "soap" , uri = "http://www.w3.org/2003/05/soap-envelope" ) , @ NamespacePrefix ( prefix = "xsd" , uri = "http://www.w3.org/2001/XMLSchema" ) } ; } 	0	['2', '1', '0', '2', '2', '1', '1', '1', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . component . file ; import java . io . File ; import java . io . FileOutputStream ; import java . io . InputStream ; import java . io . RandomAccessFile ; import java . nio . ByteBuffer ; import java . nio . channels . FileChannel ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . util . ExchangeHelper ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . UuidGenerator ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class FileProducer extends DefaultProducer { private static final transient Log LOG = LogFactory . getLog ( FileProducer . class ) ; private FileEndpoint endpoint ; public FileProducer ( FileEndpoint endpoint ) { super ( endpoint ) ; this . endpoint = endpoint ; } public FileEndpoint getEndpoint ( ) { return ( FileEndpoint ) super . getEndpoint ( ) ; } public void process ( Exchange exchange ) throws Exception { FileExchange fileExchange = endpoint . createExchange ( exchange ) ; process ( fileExchange ) ; ExchangeHelper . copyResults ( exchange , fileExchange ) ; } public void process ( FileExchange exchange ) throws Exception { InputStream in = ExchangeHelper . getMandatoryInBody ( exchange , InputStream . class ) ; File file = createFileName ( exchange . getIn ( ) ) ; buildDirectory ( file ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "About to write to: " + file + " from exchange: " + exchange ) ; } FileChannel fc = null ; try { if ( getEndpoint ( ) . isAppend ( ) ) { fc = new RandomAccessFile ( file , "rw" ) . getChannel ( ) ; fc . position ( fc . size ( ) ) ; } else { fc = new FileOutputStream ( file ) . getChannel ( ) ; } int size = getEndpoint ( ) . getBufferSize ( ) ; byte [ ] buffer = new byte [ size ] ; ByteBuffer byteBuffer = ByteBuffer . wrap ( buffer ) ; while ( true ) { int count = in . read ( buffer ) ; if ( count <= 0 ) { break ; } else if ( count < size ) { byteBuffer = ByteBuffer . wrap ( buffer , 0 , count ) ; fc . write ( byteBuffer ) ; break ; } else { fc . write ( byteBuffer ) ; byteBuffer . clear ( ) ; } } } finally { ObjectHelper . close ( in , file . getName ( ) , LOG ) ; ObjectHelper . close ( fc , file . getName ( ) , LOG ) ; } } protected File createFileName ( Message message ) { File answer ; String name = null ; if ( ! endpoint . isIgnoreFileNameHeader ( ) ) { name = message . getHeader ( FileComponent . HEADER_FILE_NAME , String . class ) ; } File endpointFile = endpoint . getFile ( ) ; if ( endpointFile . isDirectory ( ) ) { if ( name != null ) { answer = new File ( endpointFile , name ) ; if ( answer . isDirectory ( ) ) { answer = new File ( answer , endpoint . getGeneratedFileName ( message ) ) ; } } else { answer = new File ( endpointFile , endpoint . getGeneratedFileName ( message ) ) ; } } else { if ( name == null ) { answer = endpointFile ; } else { answer = new File ( endpointFile , name ) ; } } message . setHeader ( FileComponent . HEADER_FILE_NAME_PRODUCED , answer . getAbsolutePath ( ) ) ; return answer ; } private void buildDirectory ( File file ) { String dirName = file . getAbsolutePath ( ) ; int index = dirName . lastIndexOf ( File . separatorChar ) ; if ( index > 0 ) { dirName = dirName . substring ( 0 , index ) ; File dir = new File ( dirName ) ; dir . mkdirs ( ) ; } } } 	1	['8', '3', '0', '10', '47', '20', '1', '10', '5', '0.642857143', '250', '1', '1', '0.769230769', '0.285714286', '0', '0', '30', '6', '1.5', '2']
package org . apache . camel . builder . xml ; import java . io . StringReader ; import java . util . List ; import java . util . Map ; import javax . xml . namespace . QName ; import javax . xml . transform . dom . DOMSource ; import javax . xml . xpath . XPath ; import javax . xml . xpath . XPathConstants ; import javax . xml . xpath . XPathExpression ; import javax . xml . xpath . XPathExpressionException ; import javax . xml . xpath . XPathFactory ; import javax . xml . xpath . XPathFactoryConfigurationException ; import javax . xml . xpath . XPathFunction ; import javax . xml . xpath . XPathFunctionException ; import javax . xml . xpath . XPathFunctionResolver ; import org . w3c . dom . Document ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . xml . sax . InputSource ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Message ; import org . apache . camel . Predicate ; import org . apache . camel . RuntimeExpressionException ; import org . apache . camel . spi . NamespaceAware ; import org . apache . camel . util . ExchangeHelper ; import static org . apache . camel . builder . xml . Namespaces . DEFAULT_NAMESPACE ; import static org . apache . camel . builder . xml . Namespaces . IN_NAMESPACE ; import static org . apache . camel . builder . xml . Namespaces . OUT_NAMESPACE ; import static org . apache . camel . builder . xml . Namespaces . isMatchingNamespaceOrEmptyNamespace ; import static org . apache . camel . converter . ObjectConverter . toBoolean ; public class XPathBuilder < E extends Exchange > implements Expression < E > , Predicate < E > , NamespaceAware { private final String text ; private XPathFactory xpathFactory ; private Class documentType = Document . class ; private Class resultType ; private QName resultQName = XPathConstants . NODESET ; private String objectModelUri ; private DefaultNamespaceContext namespaceContext ; private XPathFunctionResolver functionResolver ; private XPathExpression expression ; private MessageVariableResolver variableResolver = new MessageVariableResolver ( ) ; private E exchange ; private XPathFunction bodyFunction ; private XPathFunction headerFunction ; private XPathFunction outBodyFunction ; private XPathFunction outHeaderFunction ; public XPathBuilder ( String text ) { this . text = text ; } public static XPathBuilder xpath ( String text ) { return new XPathBuilder ( text ) ; } @ Override public String toString ( ) { return "XPath: " + text ; } public boolean matches ( E exchange ) { Object booleanResult = evaluateAs ( exchange , XPathConstants . BOOLEAN ) ; return toBoolean ( booleanResult ) ; } public void assertMatches ( String text , E exchange ) throws AssertionError { Object booleanResult = evaluateAs ( exchange , XPathConstants . BOOLEAN ) ; if ( ! toBoolean ( booleanResult ) ) { throw new AssertionError ( this + " failed on " + exchange + " as returned <" + booleanResult + ">" ) ; } } public Object evaluate ( E exchange ) { Object answer = evaluateAs ( exchange , resultQName ) ; if ( resultType != null ) { return ExchangeHelper . convertToType ( exchange , resultType , answer ) ; } return answer ; } public XPathBuilder < E > booleanResult ( ) { resultQName = XPathConstants . BOOLEAN ; return this ; } public XPathBuilder < E > nodeResult ( ) { resultQName = XPathConstants . NODE ; return this ; } public XPathBuilder < E > nodeSetResult ( ) { resultQName = XPathConstants . NODESET ; return this ; } public XPathBuilder < E > numberResult ( ) { resultQName = XPathConstants . NUMBER ; return this ; } public XPathBuilder < E > stringResult ( ) { resultQName = XPathConstants . STRING ; return this ; } public XPathBuilder < E > resultType ( Class resultType ) { setResultType ( resultType ) ; return this ; } public XPathBuilder < E > objectModel ( String uri ) { this . objectModelUri = uri ; return this ; } public XPathBuilder < E > functionResolver ( XPathFunctionResolver functionResolver ) { this . functionResolver = functionResolver ; return this ; } public XPathBuilder < E > namespace ( String prefix , String uri ) { getNamespaceContext ( ) . add ( prefix , uri ) ; return this ; } public XPathBuilder < E > namespaces ( Namespaces namespaces ) { namespaces . configure ( this ) ; return this ; } public XPathBuilder < E > variable ( String name , Object value ) { variableResolver . addVariable ( name , value ) ; return this ; } public XPathFactory getXPathFactory ( ) throws XPathFactoryConfigurationException { if ( xpathFactory == null ) { if ( objectModelUri != null ) { xpathFactory = XPathFactory . newInstance ( objectModelUri ) ; } xpathFactory = XPathFactory . newInstance ( ) ; } return xpathFactory ; } public void setXPathFactory ( XPathFactory xpathFactory ) { this . xpathFactory = xpathFactory ; } public Class getDocumentType ( ) { return documentType ; } public void setDocumentType ( Class documentType ) { this . documentType = documentType ; } public String getText ( ) { return text ; } public QName getResultQName ( ) { return resultQName ; } public void setResultQName ( QName resultQName ) { this . resultQName = resultQName ; } public DefaultNamespaceContext getNamespaceContext ( ) { if ( namespaceContext == null ) { try { DefaultNamespaceContext defaultNamespaceContext = new DefaultNamespaceContext ( getXPathFactory ( ) ) ; populateDefaultNamespaces ( defaultNamespaceContext ) ; namespaceContext = defaultNamespaceContext ; } catch ( XPathFactoryConfigurationException e ) { throw new RuntimeExpressionException ( e ) ; } } return namespaceContext ; } public void setNamespaceContext ( DefaultNamespaceContext namespaceContext ) { this . namespaceContext = namespaceContext ; } public XPathFunctionResolver getFunctionResolver ( ) { return functionResolver ; } public void setFunctionResolver ( XPathFunctionResolver functionResolver ) { this . functionResolver = functionResolver ; } public XPathExpression getExpression ( ) throws XPathFactoryConfigurationException , XPathExpressionException { if ( expression == null ) { expression = createXPathExpression ( ) ; } return expression ; } public void setNamespaces ( Map < String , String > namespaces ) { getNamespaceContext ( ) . setNamespaces ( namespaces ) ; } public XPathFunction getBodyFunction ( ) { if ( bodyFunction == null ) { bodyFunction = new XPathFunction ( ) { public Object evaluate ( List list ) throws XPathFunctionException { if ( exchange == null ) { return null ; } return exchange . getIn ( ) . getBody ( ) ; } } ; } return bodyFunction ; } public void setBodyFunction ( XPathFunction bodyFunction ) { this . bodyFunction = bodyFunction ; } public XPathFunction getHeaderFunction ( ) { if ( headerFunction == null ) { headerFunction = new XPathFunction ( ) { public Object evaluate ( List list ) throws XPathFunctionException { if ( exchange != null && ! list . isEmpty ( ) ) { Object value = list . get ( 0 ) ; if ( value != null ) { return exchange . getIn ( ) . getHeader ( value . toString ( ) ) ; } } return null ; } } ; } return headerFunction ; } public void setHeaderFunction ( XPathFunction headerFunction ) { this . headerFunction = headerFunction ; } public XPathFunction getOutBodyFunction ( ) { if ( outBodyFunction == null ) { outBodyFunction = new XPathFunction ( ) { public Object evaluate ( List list ) throws XPathFunctionException { if ( exchange != null ) { Message out = exchange . getOut ( false ) ; if ( out != null ) { return out . getBody ( ) ; } } return null ; } } ; } return outBodyFunction ; } public void setOutBodyFunction ( XPathFunction outBodyFunction ) { this . outBodyFunction = outBodyFunction ; } public XPathFunction getOutHeaderFunction ( ) { if ( outHeaderFunction == null ) { outHeaderFunction = new XPathFunction ( ) { public Object evaluate ( List list ) throws XPathFunctionException { if ( exchange != null && ! list . isEmpty ( ) ) { Object value = list . get ( 0 ) ; if ( value != null ) { return exchange . getOut ( ) . getHeader ( value . toString ( ) ) ; } } return null ; } } ; } return outHeaderFunction ; } public void setOutHeaderFunction ( XPathFunction outHeaderFunction ) { this . outHeaderFunction = outHeaderFunction ; } public Class getResultType ( ) { return resultType ; } public void setResultType ( Class resultType ) { this . resultType = resultType ; if ( Number . class . isAssignableFrom ( resultType ) ) { numberResult ( ) ; } else if ( String . class . isAssignableFrom ( resultType ) ) { stringResult ( ) ; } else if ( Boolean . class . isAssignableFrom ( resultType ) ) { booleanResult ( ) ; } else if ( Node . class . isAssignableFrom ( resultType ) ) { nodeResult ( ) ; } else if ( NodeList . class . isAssignableFrom ( resultType ) ) { nodeSetResult ( ) ; } } protected synchronized Object evaluateAs ( E exchange , QName resultQName ) { this . exchange = exchange ; variableResolver . setExchange ( exchange ) ; try { Object document = getDocument ( exchange ) ; if ( resultQName != null ) { if ( document instanceof InputSource ) { InputSource inputSource = ( InputSource ) document ; return getExpression ( ) . evaluate ( inputSource , resultQName ) ; } else if ( document instanceof DOMSource ) { DOMSource source = ( DOMSource ) document ; return getExpression ( ) . evaluate ( source . getNode ( ) , resultQName ) ; } else { return getExpression ( ) . evaluate ( document , resultQName ) ; } } else { if ( document instanceof InputSource ) { InputSource inputSource = ( InputSource ) document ; return getExpression ( ) . evaluate ( inputSource ) ; } else if ( document instanceof DOMSource ) { DOMSource source = ( DOMSource ) document ; return getExpression ( ) . evaluate ( source . getNode ( ) ) ; } else { return getExpression ( ) . evaluate ( document ) ; } } } catch ( XPathExpressionException e ) { throw new InvalidXPathExpression ( getText ( ) , e ) ; } catch ( XPathFactoryConfigurationException e ) { throw new InvalidXPathExpression ( getText ( ) , e ) ; } } protected XPathExpression createXPathExpression ( ) throws XPathExpressionException , XPathFactoryConfigurationException { XPath xPath = getXPathFactory ( ) . newXPath ( ) ; xpathFactory = null ; xPath . setNamespaceContext ( getNamespaceContext ( ) ) ; xPath . setXPathVariableResolver ( variableResolver ) ; XPathFunctionResolver parentResolver = getFunctionResolver ( ) ; if ( parentResolver == null ) { parentResolver = xPath . getXPathFunctionResolver ( ) ; } xPath . setXPathFunctionResolver ( createDefaultFunctionResolver ( parentResolver ) ) ; return xPath . compile ( text ) ; } protected void populateDefaultNamespaces ( DefaultNamespaceContext context ) { setNamespaceIfNotPresent ( context , "in" , IN_NAMESPACE ) ; setNamespaceIfNotPresent ( context , "out" , OUT_NAMESPACE ) ; setNamespaceIfNotPresent ( context , "env" , Namespaces . ENVIRONMENT_VARIABLES ) ; setNamespaceIfNotPresent ( context , "system" , Namespaces . SYSTEM_PROPERTIES_NAMESPACE ) ; } protected void setNamespaceIfNotPresent ( DefaultNamespaceContext context , String prefix , String uri ) { if ( context != null ) { String current = context . getNamespaceURI ( prefix ) ; if ( current == null ) { context . add ( prefix , uri ) ; } } } protected XPathFunctionResolver createDefaultFunctionResolver ( final XPathFunctionResolver parent ) { return new XPathFunctionResolver ( ) { public XPathFunction resolveFunction ( QName qName , int argumentCount ) { XPathFunction answer = null ; if ( parent != null ) { answer = parent . resolveFunction ( qName , argumentCount ) ; } if ( answer == null ) { if ( isMatchingNamespaceOrEmptyNamespace ( qName . getNamespaceURI ( ) , IN_NAMESPACE ) || isMatchingNamespaceOrEmptyNamespace ( qName . getNamespaceURI ( ) , DEFAULT_NAMESPACE ) ) { String localPart = qName . getLocalPart ( ) ; if ( localPart . equals ( "body" ) && argumentCount == 0 ) { return getBodyFunction ( ) ; } if ( localPart . equals ( "header" ) && argumentCount == 1 ) { return getHeaderFunction ( ) ; } } if ( isMatchingNamespaceOrEmptyNamespace ( qName . getNamespaceURI ( ) , OUT_NAMESPACE ) ) { String localPart = qName . getLocalPart ( ) ; if ( localPart . equals ( "body" ) && argumentCount == 0 ) { return getOutBodyFunction ( ) ; } if ( localPart . equals ( "header" ) && argumentCount == 1 ) { return getOutHeaderFunction ( ) ; } } if ( isMatchingNamespaceOrEmptyNamespace ( qName . getNamespaceURI ( ) , DEFAULT_NAMESPACE ) ) { String localPart = qName . getLocalPart ( ) ; if ( localPart . equals ( "out-body" ) && argumentCount == 0 ) { return getOutBodyFunction ( ) ; } if ( localPart . equals ( "out-header" ) && argumentCount == 1 ) { return getOutHeaderFunction ( ) ; } } } return answer ; } } ; } protected Object getDocument ( E exchange ) { Message in = exchange . getIn ( ) ; Class type = getDocumentType ( ) ; Object answer = null ; if ( type != null ) { answer = in . getBody ( type ) ; } if ( answer == null ) { answer = in . getBody ( ) ; } if ( answer instanceof String ) { answer = new InputSource ( new StringReader ( answer . toString ( ) ) ) ; } return answer ; } } 	0	['49', '1', '0', '20', '93', '1044', '8', '17', '42', '0.915277778', '620', '1', '3', '0', '0.128728414', '0', '0', '11.34693878', '6', '1.4082', '0']
package org . apache . camel . language . simple ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . builder . ExpressionBuilder ; import org . apache . camel . builder . PredicateBuilder ; import org . apache . camel . language . IllegalSyntaxException ; import org . apache . camel . spi . Language ; import org . apache . camel . util . ObjectHelper ; public class SimpleLanguage implements Language { public static Expression simple ( String expression ) { SimpleLanguage language = new SimpleLanguage ( ) ; return language . createExpression ( expression ) ; } public Predicate < Exchange > createPredicate ( String expression ) { return PredicateBuilder . toPredicate ( createExpression ( expression ) ) ; } public Expression < Exchange > createExpression ( String expression ) { if ( expression . indexOf ( "${" ) >= 0 ) { return createComplexExpression ( expression ) ; } return createSimpleExpression ( expression ) ; } protected Expression < Exchange > createComplexExpression ( String expression ) { List < Expression > results = new ArrayList < Expression > ( ) ; int pivot = 0 ; int size = expression . length ( ) ; while ( pivot < size ) { int idx = expression . indexOf ( "${" , pivot ) ; if ( idx < 0 ) { results . add ( createConstantExpression ( expression , pivot , size ) ) ; break ; } else { if ( pivot < idx ) { results . add ( createConstantExpression ( expression , pivot , idx ) ) ; } pivot = idx + 2 ; int endIdx = expression . indexOf ( "}" , pivot ) ; if ( endIdx < 0 ) { throw new IllegalArgumentException ( "Expecting } but found end of string for simple expression: " + expression ) ; } String simpleText = expression . substring ( pivot , endIdx ) ; Expression simpleExpression = createSimpleExpression ( simpleText ) ; results . add ( simpleExpression ) ; pivot = endIdx + 1 ; } } return ExpressionBuilder . concatExpression ( results , expression ) ; } protected Expression createConstantExpression ( String expression , int start , int end ) { return ExpressionBuilder . constantExpression ( expression . substring ( start , end ) ) ; } protected Expression < Exchange > createSimpleExpression ( String expression ) { if ( ObjectHelper . isEqualToAny ( expression , "body" , "in.body" ) ) { return ExpressionBuilder . bodyExpression ( ) ; } else if ( ObjectHelper . equal ( expression , "out.body" ) ) { return ExpressionBuilder . outBodyExpression ( ) ; } String remainder = ifStartsWithReturnRemainder ( "in.header." , expression ) ; if ( remainder == null ) { remainder = ifStartsWithReturnRemainder ( "header." , expression ) ; } if ( remainder == null ) { remainder = ifStartsWithReturnRemainder ( "headers." , expression ) ; } if ( remainder == null ) { remainder = ifStartsWithReturnRemainder ( "in.headers." , expression ) ; } if ( remainder != null ) { return ExpressionBuilder . headerExpression ( remainder ) ; } remainder = ifStartsWithReturnRemainder ( "out.header." , expression ) ; if ( remainder == null ) { remainder = ifStartsWithReturnRemainder ( "out.headers." , expression ) ; } if ( remainder != null ) { return ExpressionBuilder . outHeaderExpression ( remainder ) ; } remainder = ifStartsWithReturnRemainder ( "property." , expression ) ; if ( remainder != null ) { return ExpressionBuilder . propertyExpression ( remainder ) ; } remainder = ifStartsWithReturnRemainder ( "sys." , expression ) ; if ( remainder != null ) { return ExpressionBuilder . propertyExpression ( remainder ) ; } throw new IllegalSyntaxException ( this , expression ) ; } protected String ifStartsWithReturnRemainder ( String prefix , String text ) { if ( text . startsWith ( prefix ) ) { String remainder = text . substring ( prefix . length ( ) ) ; if ( remainder . length ( ) > 0 ) { return remainder ; } } return null ; } } 	1	['8', '1', '0', '7', '32', '28', '0', '7', '4', '2', '237', '0', '0', '0', '0.625', '0', '0', '28.625', '11', '3', '1']
package org . apache . camel . management ; import java . io . IOException ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Route ; import org . springframework . jmx . export . annotation . ManagedAttribute ; import org . springframework . jmx . export . annotation . ManagedOperation ; import org . springframework . jmx . export . annotation . ManagedResource ; @ ManagedResource ( description = "Managed Route" , currencyTimeLimit = 15 ) public class ManagedRoute extends PerformanceCounter { public static final String VALUE_UNKNOWN = "Unknown" ; private Route < ? extends Exchange > route ; private String description ; ManagedRoute ( Route < ? extends Exchange > route ) { this . route = route ; this . description = route . toString ( ) ; } public Route < ? extends Exchange > getRoute ( ) { return route ; } @ ManagedAttribute ( description = "Route Endpoint Uri" ) public String getEndpointUri ( ) { Endpoint < ? extends Exchange > ep = route . getEndpoint ( ) ; return ep != null ? ep . getEndpointUri ( ) : VALUE_UNKNOWN ; } @ ManagedAttribute ( description = "Route description" ) public String getDescription ( ) { return description ; } @ ManagedOperation ( description = "Start Route" ) public void start ( ) throws IOException { throw new IOException ( "Not supported" ) ; } @ ManagedOperation ( description = "Stop Route" ) public void stop ( ) throws IOException { throw new IOException ( "Not supported" ) ; } } 	0	['6', '3', '0', '5', '11', '7', '2', '3', '5', '0.866666667', '46', '0.666666667', '1', '0.761904762', '0.583333333', '0', '0', '6.166666667', '2', '1', '0']
package org . apache . camel . component . file ; import java . io . File ; public interface FileProcessStrategy { boolean begin ( FileEndpoint endpoint , FileExchange exchange , File file ) throws Exception ; void commit ( FileEndpoint endpoint , FileExchange exchange , File file ) throws Exception ; } 	1	['2', '1', '0', '6', '2', '1', '5', '2', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . camel . component . http ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; public class HttpConsumer extends DefaultConsumer < HttpExchange > { private final HttpEndpoint endpoint ; public HttpConsumer ( HttpEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; } @ Override public HttpEndpoint getEndpoint ( ) { return ( HttpEndpoint ) super . getEndpoint ( ) ; } public HttpBinding getBinding ( ) { return endpoint . getBinding ( ) ; } public String getPath ( ) { return endpoint . getPath ( ) ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; endpoint . connect ( this ) ; } @ Override protected void doStop ( ) throws Exception { endpoint . disconnect ( this ) ; super . doStop ( ) ; } } 	0	['7', '3', '0', '10', '14', '1', '6', '5', '5', '0.333333333', '45', '1', '1', '0.785714286', '0.428571429', '1', '1', '5.285714286', '1', '0.8571', '0']
package org . apache . camel . component . jmx ; import javax . management . MBeanServer ; import javax . management . Notification ; import javax . management . ObjectName ; import javax . management . monitor . CounterMonitor ; import org . apache . camel . Consumer ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class JMXEndpoint extends DefaultEndpoint < JMXExchange > { private static final transient Log LOG = LogFactory . getLog ( JMXEndpoint . class ) ; private String name ; private ObjectName ourName ; private String observedObjectName ; private String attributeName ; private long granularityPeriod = 5000 ; private Number threshold ; private Number offset ; private MBeanServer mbeanServer ; private CounterMonitor counterMonitor = new CounterMonitor ( ) ; protected JMXEndpoint ( String endpointUri , JMXComponent component ) { super ( endpointUri , component ) ; observedObjectName = endpointUri ; } public JMXEndpoint ( String endpointUri ) { super ( endpointUri ) ; } public Producer < JMXExchange > createProducer ( ) throws Exception { throw new UnsupportedOperationException ( "Producer not supported" ) ; } public Consumer < JMXExchange > createConsumer ( Processor proc ) throws Exception { ObjectName observedName = new ObjectName ( observedObjectName ) ; if ( name == null ) { String type = observedName . getKeyProperty ( "type" ) ; type = type != null ? type : "UNKNOWN" ; name = mbeanServer . getDefaultDomain ( ) + ":type=CounterMonitor_" + type ; } JMXConsumer result = new JMXConsumer ( this , proc ) ; ourName = new ObjectName ( name ) ; counterMonitor . setNotify ( true ) ; counterMonitor . addObservedObject ( observedName ) ; counterMonitor . setObservedAttribute ( attributeName ) ; counterMonitor . setGranularityPeriod ( granularityPeriod ) ; counterMonitor . setDifferenceMode ( false ) ; counterMonitor . setInitThreshold ( threshold ) ; counterMonitor . setOffset ( offset ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Registering and adding notification listener for [" + counterMonitor + "] with name [" + ourName + "]" ) ; } mbeanServer . registerMBean ( counterMonitor , ourName ) ; mbeanServer . addNotificationListener ( ourName , result , null , new Object ( ) ) ; return result ; } public boolean isSingleton ( ) { return true ; } public JMXExchange createExchange ( Notification notification ) { return new JMXExchange ( getCamelContext ( ) , getExchangePattern ( ) , notification ) ; } public JMXExchange createExchange ( ) { return new JMXExchange ( getCamelContext ( ) , getExchangePattern ( ) , null ) ; } public JMXExchange createExchange ( ExchangePattern pattern ) { return new JMXExchange ( getCamelContext ( ) , pattern , null ) ; } public String getAttributeName ( ) { return attributeName ; } public void setAttributeName ( String attributeName ) { this . attributeName = attributeName ; } public long getGranularityPeriod ( ) { return granularityPeriod ; } public void setGranularityPeriod ( long granularityPeriod ) { this . granularityPeriod = granularityPeriod ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public Number getOffset ( ) { return offset ; } public void setOffset ( Number offset ) { this . offset = offset ; } public Number getThreshold ( ) { return threshold ; } public void setThreshold ( Number threshold ) { this . threshold = threshold ; } public MBeanServer getMbeanServer ( ) { return mbeanServer ; } public void setMbeanServer ( MBeanServer mbeanServer ) { this . mbeanServer = mbeanServer ; } } 	1	['23', '2', '0', '13', '49', '201', '2', '13', '21', '0.918181818', '266', '1', '0', '0.534883721', '0.176767677', '1', '1', '10.13043478', '1', '0.8696', '1']
package org . apache . camel . component . spring . integration ; import org . apache . camel . CamelContext ; import org . apache . camel . Consumer ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . impl . ScheduledPollEndpoint ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . integration . channel . MessageChannel ; public class SpringIntegrationEndpoint extends ScheduledPollEndpoint < SpringIntegrationExchange > { private static final Log LOG = LogFactory . getLog ( SpringIntegrationEndpoint . class ) ; private String inputChannel ; private String outputChannel ; private String defaultChannel ; private MessageChannel messageChannel ; private boolean inOut ; public SpringIntegrationEndpoint ( String uri , String channel , SpringIntegrationComponent component ) { super ( uri , component ) ; defaultChannel = channel ; } public SpringIntegrationEndpoint ( String uri , MessageChannel channel , CamelContext context ) { super ( uri , context ) ; messageChannel = channel ; } public SpringIntegrationEndpoint ( String endpointUri , MessageChannel messageChannel ) { super ( endpointUri ) ; this . messageChannel = messageChannel ; } public Producer < SpringIntegrationExchange > createProducer ( ) throws Exception { return new SpringIntegrationProducer ( this ) ; } public Consumer < SpringIntegrationExchange > createConsumer ( Processor processor ) throws Exception { return new SpringIntegrationConsumer ( this , processor ) ; } public SpringIntegrationExchange createExchange ( ) { return createExchange ( getExchangePattern ( ) ) ; } public SpringIntegrationExchange createExchange ( ExchangePattern pattern ) { return new SpringIntegrationExchange ( getCamelContext ( ) , pattern ) ; } public void setInputChannel ( String input ) { inputChannel = input ; } public String getInputChannel ( ) { return inputChannel ; } public void setOutputChannel ( String output ) { outputChannel = output ; } public String getOutputChannel ( ) { return outputChannel ; } public String getDefaultChannel ( ) { return defaultChannel ; } public MessageChannel getMessageChannel ( ) { return messageChannel ; } public boolean isSingleton ( ) { return false ; } public void setInOut ( boolean inOut ) { this . inOut = inOut ; } public boolean isInOut ( ) { return this . inOut ; } } 	0	['19', '3', '0', '16', '26', '157', '4', '15', '18', '0.944444444', '111', '1', '0', '0.642857143', '0.215277778', '1', '1', '4.526315789', '1', '0.7895', '0']
package org . apache . camel ; import java . util . Collection ; import java . util . List ; import java . util . concurrent . Callable ; import org . apache . camel . model . RouteType ; import org . apache . camel . spi . ExchangeConverter ; import org . apache . camel . spi . Injector ; import org . apache . camel . spi . InterceptStrategy ; import org . apache . camel . spi . Language ; import org . apache . camel . spi . LifecycleStrategy ; import org . apache . camel . spi . Registry ; public interface CamelContext extends Service { String getName ( ) ; void addComponent ( String componentName , Component component ) ; Component getComponent ( String componentName ) ; < T extends Component > T getComponent ( String name , Class < T > componentType ) ; Component removeComponent ( String componentName ) ; Component getOrCreateComponent ( String componentName , Callable < Component > factory ) ; Endpoint getEndpoint ( String uri ) ; < T extends Endpoint > T getEndpoint ( String name , Class < T > endpointType ) ; Collection < Endpoint > getSingletonEndpoints ( ) ; Endpoint addSingletonEndpoint ( String uri , Endpoint endpoint ) throws Exception ; Endpoint removeSingletonEndpoint ( String uri ) throws Exception ; List < RouteType > getRouteDefinitions ( ) ; List < Route > getRoutes ( ) ; void setRoutes ( List < Route > routes ) ; void addRoutes ( Collection < Route > routes ) throws Exception ; void addRoutes ( Routes builder ) throws Exception ; void addRouteDefinitions ( Collection < RouteType > routeDefinitions ) throws Exception ; ExchangeConverter getExchangeConverter ( ) ; TypeConverter getTypeConverter ( ) ; Registry getRegistry ( ) ; Injector getInjector ( ) ; LifecycleStrategy getLifecycleStrategy ( ) ; Language resolveLanguage ( String language ) ; < E extends Exchange > ProducerTemplate < E > createProducerTemplate ( ) ; void addInterceptStrategy ( InterceptStrategy interceptStrategy ) ; } 	1	['25', '1', '0', '149', '25', '300', '141', '12', '25', '2', '25', '0', '0', '0', '0.18', '0', '0', '0', '1', '1', '6']
package org . apache . camel . builder . script ; import java . io . File ; import java . io . IOException ; import java . io . InputStreamReader ; import java . net . URL ; import javax . script . Compilable ; import javax . script . CompiledScript ; import javax . script . ScriptContext ; import javax . script . ScriptEngine ; import javax . script . ScriptEngineManager ; import javax . script . ScriptException ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . converter . ObjectConverter ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . core . io . FileSystemResource ; import org . springframework . core . io . Resource ; import org . springframework . core . io . UrlResource ; public class ScriptBuilder < E extends Exchange > implements Expression < E > , Predicate < E > , Processor { private static final transient Log LOG = LogFactory . getLog ( ScriptBuilder . class ) ; private String scriptEngineName ; private Resource scriptResource ; private String scriptText ; private ScriptEngine engine ; private CompiledScript compiledScript ; public ScriptBuilder ( String scriptEngineName ) { this . scriptEngineName = scriptEngineName ; } public ScriptBuilder ( String scriptEngineName , String scriptText ) { this ( scriptEngineName ) ; this . scriptText = scriptText ; } public ScriptBuilder ( String scriptEngineName , Resource scriptResource ) { this ( scriptEngineName ) ; this . scriptResource = scriptResource ; } @ Override public String toString ( ) { return getScriptDescription ( ) ; } public Object evaluate ( E exchange ) { return evaluateScript ( exchange ) ; } public boolean matches ( E exchange ) { Object scriptValue = evaluateScript ( exchange ) ; return matches ( exchange , scriptValue ) ; } public void assertMatches ( String text , E exchange ) throws AssertionError { Object scriptValue = evaluateScript ( exchange ) ; if ( ! matches ( exchange , scriptValue ) ) { throw new AssertionError ( this + " failed on " + exchange + " as script returned <" + scriptValue + ">" ) ; } } public void process ( Exchange exchange ) { evaluateScript ( exchange ) ; } public ScriptBuilder attribute ( String name , Object value ) { getScriptContext ( ) . setAttribute ( name , value , ScriptContext . ENGINE_SCOPE ) ; return this ; } public static ScriptBuilder script ( String language , String scriptText ) { return new ScriptBuilder ( language , scriptText ) ; } public static ScriptBuilder script ( String language , Resource scriptResource ) { return new ScriptBuilder ( language , scriptResource ) ; } public static ScriptBuilder script ( String language , File scriptFile ) { return new ScriptBuilder ( language , new FileSystemResource ( scriptFile ) ) ; } public static ScriptBuilder script ( String language , URL scriptURL ) { return new ScriptBuilder ( language , new UrlResource ( scriptURL ) ) ; } public static ScriptBuilder groovy ( String scriptText ) { return new ScriptBuilder ( "groovy" , scriptText ) ; } public static ScriptBuilder groovy ( Resource scriptResource ) { return new ScriptBuilder ( "groovy" , scriptResource ) ; } public static ScriptBuilder groovy ( File scriptFile ) { return new ScriptBuilder ( "groovy" , new FileSystemResource ( scriptFile ) ) ; } public static ScriptBuilder groovy ( URL scriptURL ) { return new ScriptBuilder ( "groovy" , new UrlResource ( scriptURL ) ) ; } public static ScriptBuilder javaScript ( String scriptText ) { return new ScriptBuilder ( "js" , scriptText ) ; } public static ScriptBuilder javaScript ( Resource scriptResource ) { return new ScriptBuilder ( "js" , scriptResource ) ; } public static ScriptBuilder javaScript ( File scriptFile ) { return new ScriptBuilder ( "js" , new FileSystemResource ( scriptFile ) ) ; } public static ScriptBuilder javaScript ( URL scriptURL ) { return new ScriptBuilder ( "js" , new UrlResource ( scriptURL ) ) ; } public static ScriptBuilder php ( String scriptText ) { return new ScriptBuilder ( "php" , scriptText ) ; } public static ScriptBuilder php ( Resource scriptResource ) { return new ScriptBuilder ( "php" , scriptResource ) ; } public static ScriptBuilder php ( File scriptFile ) { return new ScriptBuilder ( "php" , new FileSystemResource ( scriptFile ) ) ; } public static ScriptBuilder php ( URL scriptURL ) { return new ScriptBuilder ( "php" , new UrlResource ( scriptURL ) ) ; } public static ScriptBuilder python ( String scriptText ) { return new ScriptBuilder ( "python" , scriptText ) ; } public static ScriptBuilder python ( Resource scriptResource ) { return new ScriptBuilder ( "python" , scriptResource ) ; } public static ScriptBuilder python ( File scriptFile ) { return new ScriptBuilder ( "python" , new FileSystemResource ( scriptFile ) ) ; } public static ScriptBuilder python ( URL scriptURL ) { return new ScriptBuilder ( "python" , new UrlResource ( scriptURL ) ) ; } public static ScriptBuilder ruby ( String scriptText ) { return new ScriptBuilder ( "jruby" , scriptText ) ; } public static ScriptBuilder ruby ( Resource scriptResource ) { return new ScriptBuilder ( "jruby" , scriptResource ) ; } public static ScriptBuilder ruby ( File scriptFile ) { return new ScriptBuilder ( "jruby" , new FileSystemResource ( scriptFile ) ) ; } public static ScriptBuilder ruby ( URL scriptURL ) { return new ScriptBuilder ( "jruby" , new UrlResource ( scriptURL ) ) ; } public ScriptEngine getEngine ( ) { checkInitialised ( ) ; if ( engine == null ) { throw new IllegalArgumentException ( "No script engine could be created for: " + getScriptEngineName ( ) ) ; } return engine ; } public CompiledScript getCompiledScript ( ) { return compiledScript ; } public String getScriptText ( ) { return scriptText ; } public void setScriptText ( String scriptText ) { this . scriptText = scriptText ; } public String getScriptEngineName ( ) { return scriptEngineName ; } public String getScriptDescription ( ) { if ( scriptText != null ) { return scriptEngineName + ": " + scriptText ; } else if ( scriptResource != null ) { return scriptEngineName + ": " + scriptResource . getDescription ( ) ; } else { return scriptEngineName + ": null script" ; } } public ScriptContext getScriptContext ( ) { return getEngine ( ) . getContext ( ) ; } public void setScriptContext ( ScriptContext scriptContext ) { getEngine ( ) . setContext ( scriptContext ) ; } public Resource getScriptResource ( ) { return scriptResource ; } public void setScriptResource ( Resource scriptResource ) { this . scriptResource = scriptResource ; } protected void checkInitialised ( ) { if ( scriptText == null && scriptResource == null ) { throw new IllegalArgumentException ( "Neither scriptText or scriptResource are specified" ) ; } if ( engine == null ) { engine = createScriptEngine ( ) ; } if ( compiledScript == null ) { if ( engine instanceof Compilable ) { compileScript ( ( Compilable ) engine ) ; } } } protected boolean matches ( E exchange , Object scriptValue ) { return ObjectConverter . toBool ( scriptValue ) ; } protected ScriptEngine createScriptEngine ( ) { ScriptEngineManager manager = new ScriptEngineManager ( ) ; ScriptEngine engine = manager . getEngineByName ( scriptEngineName ) ; if ( isPython ( ) ) { ScriptContext context = engine . getContext ( ) ; context . setAttribute ( "com.sun.script.jython.comp.mode" , "eval" , ScriptContext . ENGINE_SCOPE ) ; } return engine ; } protected void compileScript ( Compilable compilable ) { try { if ( scriptText != null ) { compiledScript = compilable . compile ( scriptText ) ; } else if ( scriptResource != null ) { compiledScript = compilable . compile ( createScriptReader ( ) ) ; } } catch ( ScriptException e ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Script compile failed: " + e , e ) ; } throw createScriptCompileException ( e ) ; } catch ( IOException e ) { throw createScriptCompileException ( e ) ; } } protected synchronized Object evaluateScript ( Exchange exchange ) { try { getScriptContext ( ) ; populateBindings ( getEngine ( ) , exchange ) ; Object result = runScript ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "The script evaluation result is: " + result ) ; } return result ; } catch ( ScriptException e ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Script evaluation failed: " + e , e ) ; } throw createScriptEvaluationException ( e . getCause ( ) ) ; } catch ( IOException e ) { throw createScriptEvaluationException ( e ) ; } } protected Object runScript ( ) throws ScriptException , IOException { checkInitialised ( ) ; Object result = null ; if ( compiledScript != null ) { result = compiledScript . eval ( ) ; } else { if ( scriptText != null ) { result = getEngine ( ) . eval ( scriptText ) ; } else { result = getEngine ( ) . eval ( createScriptReader ( ) ) ; } } return result ; } protected void populateBindings ( ScriptEngine engine , Exchange exchange ) { ScriptContext context = engine . getContext ( ) ; int scope = ScriptContext . ENGINE_SCOPE ; context . setAttribute ( "context" , exchange . getContext ( ) , scope ) ; context . setAttribute ( "exchange" , exchange , scope ) ; context . setAttribute ( "request" , exchange . getIn ( ) , scope ) ; context . setAttribute ( "response" , exchange . getOut ( ) , scope ) ; } protected InputStreamReader createScriptReader ( ) throws IOException { return new InputStreamReader ( scriptResource . getInputStream ( ) ) ; } protected ScriptEvaluationException createScriptCompileException ( Exception e ) { return new ScriptEvaluationException ( "Failed to compile: " + getScriptDescription ( ) + ". Cause: " + e , e ) ; } protected ScriptEvaluationException createScriptEvaluationException ( Throwable e ) { if ( e . getClass ( ) . getName ( ) . equals ( "org.jruby.exceptions.RaiseException" ) ) { try { Object ex = e . getClass ( ) . getMethod ( "getException" ) . invoke ( e ) ; return new ScriptEvaluationException ( "Failed to evaluate: " + getScriptDescription ( ) + ".  Error: " + ex + ". Cause: " + e , e ) ; } catch ( Exception e1 ) { } } return new ScriptEvaluationException ( "Failed to evaluate: " + getScriptDescription ( ) + ". Cause: " + e , e ) ; } protected boolean isPython ( ) { return "python" . equals ( scriptEngineName ) || "jython" . equals ( scriptEngineName ) ; } } 	0	['57', '1', '0', '14', '94', '1484', '1', '13', '45', '0.666666667', '738', '1', '0', '0', '0.125', '0', '0', '11.84210526', '6', '1.2105', '0']
package org . apache . camel . processor ; import java . util . concurrent . RejectedExecutionException ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangeProperty ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . impl . converter . AsyncProcessorTypeConverter ; import org . apache . camel . model . ExceptionType ; import org . apache . camel . processor . exceptionpolicy . ExceptionPolicyStrategy ; import org . apache . camel . util . AsyncProcessorHelper ; import org . apache . camel . util . ServiceHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DeadLetterChannel extends ErrorHandlerSupport implements AsyncProcessor { public static final String REDELIVERY_COUNTER = "org.apache.camel.RedeliveryCounter" ; public static final String REDELIVERED = "org.apache.camel.Redelivered" ; public static final String EXCEPTION_CAUSE_PROPERTY = "CamelCauseException" ; private class RedeliveryData { int redeliveryCounter ; long redeliveryDelay ; boolean sync = true ; RedeliveryPolicy currentRedeliveryPolicy = redeliveryPolicy ; Processor failureProcessor = deadLetter ; } private static final transient Log LOG = LogFactory . getLog ( DeadLetterChannel . class ) ; private static final String FAILURE_HANDLED_PROPERTY = DeadLetterChannel . class . getName ( ) + ".FAILURE_HANDLED" ; private Processor output ; private Processor deadLetter ; private AsyncProcessor outputAsync ; private RedeliveryPolicy redeliveryPolicy ; private Logger logger ; public DeadLetterChannel ( Processor output , Processor deadLetter ) { this ( output , deadLetter , new RedeliveryPolicy ( ) , DeadLetterChannel . createDefaultLogger ( ) , ErrorHandlerSupport . createDefaultExceptionPolicyStrategy ( ) ) ; } public DeadLetterChannel ( Processor output , Processor deadLetter , RedeliveryPolicy redeliveryPolicy , Logger logger , ExceptionPolicyStrategy exceptionPolicyStrategy ) { this . deadLetter = deadLetter ; this . output = output ; this . outputAsync = AsyncProcessorTypeConverter . convert ( output ) ; this . redeliveryPolicy = redeliveryPolicy ; this . logger = logger ; setExceptionPolicy ( exceptionPolicyStrategy ) ; } public static < E extends Exchange > Logger createDefaultLogger ( ) { return new Logger ( LOG , LoggingLevel . ERROR ) ; } @ Override public String toString ( ) { return "DeadLetterChannel[" + output + ", " + deadLetter + ", " + redeliveryPolicy + "]" ; } public boolean process ( Exchange exchange , final AsyncCallback callback ) { return process ( exchange , callback , new RedeliveryData ( ) ) ; } public boolean process ( final Exchange exchange , final AsyncCallback callback , final RedeliveryData data ) { while ( true ) { if ( ! isRunAllowed ( ) ) { if ( exchange . getException ( ) == null ) { exchange . setException ( new RejectedExecutionException ( ) ) ; } callback . done ( data . sync ) ; return data . sync ; } if ( exchange . isTransacted ( ) && exchange . getException ( ) != null ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Transacted Exchange, this DeadLetterChannel is bypassed: " + exchange ) ; } return data . sync ; } if ( exchange . getException ( ) != null ) { Throwable e = exchange . getException ( ) ; exchange . setException ( null ) ; logger . log ( "Failed delivery for exchangeId: " + exchange . getExchangeId ( ) + ". On delivery attempt: " + data . redeliveryCounter + " caught: " + e , e ) ; data . redeliveryCounter = incrementRedeliveryCounter ( exchange , e ) ; ExceptionType exceptionPolicy = getExceptionPolicy ( exchange , e ) ; if ( exceptionPolicy != null ) { data . currentRedeliveryPolicy = exceptionPolicy . createRedeliveryPolicy ( data . currentRedeliveryPolicy ) ; Processor processor = exceptionPolicy . getErrorHandler ( ) ; if ( processor != null ) { data . failureProcessor = processor ; } } } if ( ! data . currentRedeliveryPolicy . shouldRedeliver ( data . redeliveryCounter ) ) { setFailureHandled ( exchange , true ) ; AsyncProcessor afp = AsyncProcessorTypeConverter . convert ( data . failureProcessor ) ; boolean sync = afp . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { restoreExceptionOnExchange ( exchange ) ; callback . done ( data . sync ) ; } } ) ; restoreExceptionOnExchange ( exchange ) ; logger . log ( "Failed delivery for exchangeId: " + exchange . getExchangeId ( ) + ". Handled by the failure processor: " + data . failureProcessor ) ; return sync ; } if ( data . redeliveryCounter > 0 ) { data . redeliveryDelay = data . currentRedeliveryPolicy . sleep ( data . redeliveryDelay ) ; } exchange . setProperty ( EXCEPTION_CAUSE_PROPERTY , exchange . getException ( ) ) ; exchange . setException ( null ) ; boolean sync = outputAsync . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { if ( sync ) { return ; } data . sync = false ; if ( exchange . getException ( ) != null ) { process ( exchange , callback , data ) ; } else { callback . done ( sync ) ; } } } ) ; if ( ! sync ) { return false ; } if ( exchange . getException ( ) == null || isFailureHandled ( exchange ) ) { callback . done ( true ) ; return true ; } } } public static boolean isFailureHandled ( Exchange exchange ) { return exchange . getProperty ( FAILURE_HANDLED_PROPERTY ) != null ; } public static void setFailureHandled ( Exchange exchange , boolean isHandled ) { if ( isHandled ) { exchange . setProperty ( FAILURE_HANDLED_PROPERTY , exchange . getException ( ) ) ; exchange . setException ( null ) ; } else { exchange . setException ( exchange . getProperty ( FAILURE_HANDLED_PROPERTY , Throwable . class ) ) ; exchange . removeProperty ( FAILURE_HANDLED_PROPERTY ) ; } } public static void restoreExceptionOnExchange ( Exchange exchange ) { exchange . setException ( exchange . getProperty ( FAILURE_HANDLED_PROPERTY , Throwable . class ) ) ; } public void process ( Exchange exchange ) throws Exception { AsyncProcessorHelper . process ( this , exchange ) ; } public Processor getOutput ( ) { return output ; } public Processor getDeadLetter ( ) { return deadLetter ; } public RedeliveryPolicy getRedeliveryPolicy ( ) { return redeliveryPolicy ; } public void setRedeliveryPolicy ( RedeliveryPolicy redeliveryPolicy ) { this . redeliveryPolicy = redeliveryPolicy ; } public Logger getLogger ( ) { return logger ; } public void setLogger ( Logger logger ) { this . logger = logger ; } protected int incrementRedeliveryCounter ( Exchange exchange , Throwable e ) { Message in = exchange . getIn ( ) ; Integer counter = in . getHeader ( REDELIVERY_COUNTER , Integer . class ) ; int next = 1 ; if ( counter != null ) { next = counter + 1 ; } in . setHeader ( REDELIVERY_COUNTER , next ) ; in . setHeader ( REDELIVERED , Boolean . TRUE ) ; exchange . setException ( e ) ; return next ; } @ Override protected void doStart ( ) throws Exception { ServiceHelper . startServices ( output , deadLetter ) ; } @ Override protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( deadLetter , output ) ; } } 	1	['22', '3', '0', '22', '67', '145', '6', '19', '16', '0.861904762', '434', '0.7', '5', '0.486486486', '0.155844156', '1', '1', '18.27272727', '13', '1.5455', '13']
package org . apache . camel . component . cxf . interceptors ; import java . util . ResourceBundle ; import java . util . logging . Logger ; import org . apache . cxf . binding . soap . SoapMessage ; import org . apache . cxf . binding . soap . interceptor . CheckFaultInterceptor ; import org . apache . cxf . binding . soap . interceptor . SoapActionInInterceptor ; import org . apache . cxf . common . i18n . BundleUtils ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . interceptor . Fault ; import org . apache . cxf . message . Message ; import org . apache . cxf . message . XMLMessage ; import org . apache . cxf . phase . AbstractPhaseInterceptor ; import org . apache . cxf . phase . Phase ; public class DOMInInterceptor extends AbstractPhaseInterceptor < Message > { private static final Logger LOG = LogUtils . getL7dLogger ( DOMOutInterceptor . class ) ; private final XMLMessageInInterceptor xmlInterceptor = new XMLMessageInInterceptor ( ) ; private final SoapMessageInInterceptor soapInterceptor = new SoapMessageInInterceptor ( ) ; public DOMInInterceptor ( ) { super ( Phase . POST_PROTOCOL ) ; this . addAfter ( CheckFaultInterceptor . class . getName ( ) ) ; } public boolean isRequestor ( Message message ) { return Boolean . TRUE . equals ( message . get ( Message . REQUESTOR_ROLE ) ) ; } public void handleMessage ( Message message ) throws Fault { if ( message instanceof XMLMessage ) { xmlInterceptor . handleMessage ( ( XMLMessage ) message ) ; } else if ( message instanceof SoapMessage ) { soapInterceptor . handleMessage ( ( SoapMessage ) message ) ; } else { throw new Fault ( new org . apache . cxf . common . i18n . Message ( "NOT_SUPPORTED_MESSAGE" , LOG , message . getClass ( ) . getName ( ) ) ) ; } } } 	0	['4', '0', '0', '10', '17', '2', '1', '9', '3', '0.666666667', '71', '1', '2', '0', '0.833333333', '0', '0', '16', '1', '0.5', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . builder . ErrorHandlerBuilder ; import org . apache . camel . processor . CatchProcessor ; import org . apache . camel . processor . RedeliveryPolicy ; import org . apache . camel . spi . RouteContext ; import org . apache . camel . util . ObjectHelper ; @ XmlRootElement ( name = "onException" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ExceptionType extends ProcessorType < ProcessorType > { @ XmlElement ( name = "exception" ) private List < String > exceptions = new ArrayList < String > ( ) ; @ XmlElement ( name = "redeliveryPolicy" , required = false ) private RedeliveryPolicyType redeliveryPolicy ; @ XmlElementRef private List < ProcessorType < ? > > outputs = new ArrayList < ProcessorType < ? > > ( ) ; @ XmlTransient private List < Class > exceptionClasses ; @ XmlTransient private Processor errorHandler ; public ExceptionType ( ) { } public ExceptionType ( List < Class > exceptionClasses ) { this . exceptionClasses = exceptionClasses ; } public ExceptionType ( Class exceptionType ) { exceptionClasses = new ArrayList < Class > ( ) ; exceptionClasses . add ( exceptionType ) ; } @ Override public String toString ( ) { return "Exception[ " + getExceptionClasses ( ) + " -> " + getOutputs ( ) + "]" ; } public RedeliveryPolicy createRedeliveryPolicy ( RedeliveryPolicy parentPolicy ) { if ( redeliveryPolicy != null ) { return redeliveryPolicy . createRedeliveryPolicy ( parentPolicy ) ; } else if ( errorHandler != null ) { RedeliveryPolicy answer = parentPolicy . copy ( ) ; answer . setMaximumRedeliveries ( 0 ) ; return answer ; } return parentPolicy ; } public void addRoutes ( RouteContext routeContext , Collection < Route > routes ) throws Exception { errorHandler = routeContext . createProcessor ( this ) ; ErrorHandlerBuilder builder = routeContext . getRoute ( ) . getErrorHandlerBuilder ( ) ; builder . addErrorHandlers ( this ) ; } @ Override public CatchProcessor createProcessor ( RouteContext routeContext ) throws Exception { Processor childProcessor = routeContext . createProcessor ( this ) ; return new CatchProcessor ( getExceptionClasses ( ) , childProcessor ) ; } public ExceptionType backOffMultiplier ( double backOffMultiplier ) { getOrCreateRedeliveryPolicy ( ) . backOffMultiplier ( backOffMultiplier ) ; return this ; } public ExceptionType collisionAvoidanceFactor ( double collisionAvoidanceFactor ) { getOrCreateRedeliveryPolicy ( ) . collisionAvoidanceFactor ( collisionAvoidanceFactor ) ; return this ; } public ExceptionType collisionAvoidancePercent ( short collisionAvoidancePercent ) { getOrCreateRedeliveryPolicy ( ) . collisionAvoidancePercent ( collisionAvoidancePercent ) ; return this ; } public ExceptionType initialRedeliveryDelay ( long initialRedeliveryDelay ) { getOrCreateRedeliveryPolicy ( ) . initialRedeliveryDelay ( initialRedeliveryDelay ) ; return this ; } public ExceptionType maximumRedeliveries ( int maximumRedeliveries ) { getOrCreateRedeliveryPolicy ( ) . maximumRedeliveries ( maximumRedeliveries ) ; return this ; } public ExceptionType useCollisionAvoidance ( ) { getOrCreateRedeliveryPolicy ( ) . useCollisionAvoidance ( ) ; return this ; } public ExceptionType useExponentialBackOff ( ) { getOrCreateRedeliveryPolicy ( ) . useExponentialBackOff ( ) ; return this ; } public List < ProcessorType < ? > > getOutputs ( ) { return outputs ; } public void setOutputs ( List < ProcessorType < ? > > outputs ) { this . outputs = outputs ; } public List < Class > getExceptionClasses ( ) { if ( exceptionClasses == null ) { exceptionClasses = createExceptionClasses ( ) ; } return exceptionClasses ; } public void setExceptionClasses ( List < Class > exceptionClasses ) { this . exceptionClasses = exceptionClasses ; } public List < String > getExceptions ( ) { return exceptions ; } public void setExceptions ( List < String > exceptions ) { this . exceptions = exceptions ; } public Processor getErrorHandler ( ) { return errorHandler ; } public RedeliveryPolicyType getRedeliveryPolicy ( ) { return redeliveryPolicy ; } public void setRedeliveryPolicy ( RedeliveryPolicyType redeliveryPolicy ) { this . redeliveryPolicy = redeliveryPolicy ; } protected RedeliveryPolicyType getOrCreateRedeliveryPolicy ( ) { if ( redeliveryPolicy == null ) { redeliveryPolicy = new RedeliveryPolicyType ( ) ; } return redeliveryPolicy ; } protected List < Class > createExceptionClasses ( ) { List < String > list = getExceptions ( ) ; List < Class > answer = new ArrayList < Class > ( list . size ( ) ) ; for ( String name : list ) { Class type = ObjectHelper . loadClass ( name , getClass ( ) . getClassLoader ( ) ) ; answer . add ( type ) ; } return answer ; } } 	1	['26', '3', '0', '18', '56', '263', '11', '9', '24', '0.776', '278', '1', '2', '0.867052023', '0.146853147', '1', '2', '9.5', '3', '1.0769', '10']
package org . apache . camel . builder . script ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import org . apache . camel . language . LanguageAnnotation ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . PARAMETER } ) @ LanguageAnnotation ( language = "js" ) public @ interface JavaScript { String value ( ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultExchangeFormatter ; import org . apache . camel . processor . interceptor . ExchangeFormatter ; import org . apache . camel . processor . interceptor . TraceInterceptor ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class Logger implements Processor { private Log log ; private LoggingLevel level ; private ExchangeFormatter formatter = DefaultExchangeFormatter . getInstance ( ) ; public Logger ( ) { this ( LogFactory . getLog ( Logger . class ) ) ; } public Logger ( Log log ) { this ( log , LoggingLevel . INFO ) ; } public Logger ( Log log , LoggingLevel level ) { this . log = log ; this . level = level ; } public Logger ( String logName ) { this ( LogFactory . getLog ( logName ) ) ; } public Logger ( String logName , LoggingLevel level ) { this ( LogFactory . getLog ( logName ) , level ) ; } public Logger ( Log log , ExchangeFormatter formatter ) { this ( log ) ; this . formatter = formatter ; } @ Override public String toString ( ) { return "Logger[" + log + "]" ; } public void process ( Exchange exchange ) { switch ( level ) { case DEBUG : if ( log . isDebugEnabled ( ) ) { log . debug ( logMessage ( exchange ) ) ; } break ; case ERROR : if ( log . isErrorEnabled ( ) ) { log . error ( logMessage ( exchange ) ) ; } break ; case FATAL : if ( log . isFatalEnabled ( ) ) { log . fatal ( logMessage ( exchange ) ) ; } break ; case INFO : if ( log . isInfoEnabled ( ) ) { log . info ( logMessage ( exchange ) ) ; } break ; case TRACE : if ( log . isTraceEnabled ( ) ) { log . trace ( logMessage ( exchange ) ) ; } break ; case WARN : if ( log . isWarnEnabled ( ) ) { log . warn ( logMessage ( exchange ) ) ; } break ; default : log . error ( "Unknown level: " + level + " when trying to log exchange: " + logMessage ( exchange ) ) ; } } public void process ( Exchange exchange , Throwable exception ) { switch ( level ) { case DEBUG : if ( log . isDebugEnabled ( ) ) { log . debug ( logMessage ( exchange ) , exception ) ; } break ; case ERROR : if ( log . isErrorEnabled ( ) ) { log . error ( logMessage ( exchange ) , exception ) ; } break ; case FATAL : if ( log . isFatalEnabled ( ) ) { log . fatal ( logMessage ( exchange ) , exception ) ; } break ; case INFO : if ( log . isInfoEnabled ( ) ) { log . info ( logMessage ( exchange ) , exception ) ; } break ; case TRACE : if ( log . isTraceEnabled ( ) ) { log . trace ( logMessage ( exchange ) , exception ) ; } break ; case WARN : if ( log . isWarnEnabled ( ) ) { log . warn ( logMessage ( exchange ) , exception ) ; } break ; default : log . error ( "Unknown level: " + level + " when trying to log exchange: " + logMessage ( exchange ) ) ; } } public void log ( String message ) { switch ( level ) { case DEBUG : if ( log . isDebugEnabled ( ) ) { log . debug ( message ) ; } break ; case ERROR : if ( log . isErrorEnabled ( ) ) { log . error ( message ) ; } break ; case FATAL : if ( log . isFatalEnabled ( ) ) { log . fatal ( message ) ; } break ; case INFO : if ( log . isInfoEnabled ( ) ) { log . debug ( message ) ; } break ; case TRACE : if ( log . isTraceEnabled ( ) ) { log . trace ( message ) ; } break ; case WARN : if ( log . isWarnEnabled ( ) ) { log . warn ( message ) ; } break ; default : log . error ( "Unknown level: " + level + " when trying to log exchange: " + message ) ; } } public void log ( String message , Throwable exception ) { switch ( level ) { case DEBUG : if ( log . isDebugEnabled ( ) ) { log . debug ( message , exception ) ; } break ; case ERROR : if ( log . isErrorEnabled ( ) ) { log . error ( message , exception ) ; } break ; case FATAL : if ( log . isFatalEnabled ( ) ) { log . fatal ( message , exception ) ; } break ; case INFO : if ( log . isInfoEnabled ( ) ) { log . debug ( message , exception ) ; } break ; case TRACE : if ( log . isTraceEnabled ( ) ) { log . trace ( message , exception ) ; } break ; case WARN : if ( log . isWarnEnabled ( ) ) { log . warn ( message , exception ) ; } break ; default : log . error ( "Unknown level: " + level + " when trying to log exchange: " + message , exception ) ; } } protected Object logMessage ( Exchange exchange ) { return formatter . format ( exchange ) ; } public Log getLog ( ) { return log ; } public void setLog ( Log log ) { this . log = log ; } public LoggingLevel getLevel ( ) { return level ; } public void setLevel ( LoggingLevel level ) { this . level = level ; } public void setFormatter ( ExchangeFormatter formatter ) { this . formatter = formatter ; } } 	1	['17', '1', '1', '15', '45', '46', '7', '8', '16', '0.395833333', '444', '1', '2', '0', '0.294117647', '0', '0', '24.94117647', '8', '2.2941', '1']
package org . apache . camel . converter . xmlbeans ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . Reader ; import java . nio . ByteBuffer ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . Source ; import javax . xml . transform . TransformerException ; import org . w3c . dom . Document ; import org . w3c . dom . Node ; import org . xml . sax . SAXException ; import org . apache . camel . Converter ; import org . apache . camel . converter . IOConverter ; import org . apache . camel . converter . NIOConverter ; import org . apache . camel . converter . jaxp . XmlConverter ; import org . apache . xmlbeans . XmlException ; import org . apache . xmlbeans . XmlObject ; import org . apache . xmlbeans . impl . piccolo . xml . XMLStreamReader ; @ Converter public class XmlBeansConverter { private XmlConverter xmlConverter = new XmlConverter ( ) ; @ Converter public static XmlObject toXmlObject ( File value ) throws IOException , XmlException { return XmlObject . Factory . parse ( value ) ; } @ Converter public static XmlObject toXmlObject ( Reader value ) throws IOException , XmlException { return XmlObject . Factory . parse ( value ) ; } @ Converter public static XmlObject toXmlObject ( Node value ) throws IOException , XmlException { return XmlObject . Factory . parse ( value ) ; } @ Converter public static XmlObject toXmlObject ( InputStream value ) throws IOException , XmlException { return XmlObject . Factory . parse ( value ) ; } @ Converter public static XmlObject toXmlObject ( String value ) throws IOException , XmlException { return toXmlObject ( IOConverter . toInputStream ( value ) ) ; } @ Converter public static XmlObject toXmlObject ( byte [ ] value ) throws IOException , XmlException { return toXmlObject ( IOConverter . toInputStream ( value ) ) ; } @ Converter public static XmlObject toXmlObject ( ByteBuffer value ) throws IOException , XmlException { return toXmlObject ( NIOConverter . toInputStream ( value ) ) ; } @ Converter public static XmlObject toXmlObject ( XMLStreamReader value ) throws IOException , XmlException { return XmlObject . Factory . parse ( value ) ; } @ Converter public XmlObject toXmlObject ( Source value ) throws IOException , XmlException , TransformerException , ParserConfigurationException , SAXException { Document document = getXmlConverter ( ) . toDOMDocument ( value ) ; return toXmlObject ( document ) ; } public XmlConverter getXmlConverter ( ) { return xmlConverter ; } public void setXmlConverter ( XmlConverter xmlConverter ) { this . xmlConverter = xmlConverter ; } } 	0	['12', '1', '0', '7', '22', '60', '0', '7', '12', '0.727272727', '63', '1', '1', '0', '0.106060606', '0', '0', '4.166666667', '1', '0.9167', '0']
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class TransformProcessor extends DelegateProcessor implements Processor { private static final transient Log LOG = LogFactory . getLog ( TransformProcessor . class ) ; private Expression expression ; public TransformProcessor ( Expression expression ) { this . expression = expression ; } public TransformProcessor ( Expression expression , Processor childProcessor ) { super ( childProcessor ) ; this . expression = expression ; } public void process ( Exchange exchange ) throws Exception { Object newBody = expression . evaluate ( exchange ) ; exchange . getOut ( ) . setBody ( newBody ) ; exchange . getOut ( ) . getHeaders ( ) . putAll ( exchange . getIn ( ) . getHeaders ( ) ) ; super . process ( exchange ) ; } @ Override public String toString ( ) { return "transform(" + expression + ")" ; } } 	1	['5', '3', '0', '8', '19', '0', '1', '7', '4', '0.625', '56', '1', '1', '0.913043478', '0.5', '0', '0', '9.8', '1', '0.4', '1']
package org . apache . camel . component . quartz ; import org . quartz . Job ; import org . quartz . JobExecutionContext ; import org . quartz . JobExecutionException ; public class CamelJob implements Job { public void execute ( JobExecutionContext context ) throws JobExecutionException { QuartzEndpoint component = ( QuartzEndpoint ) context . getJobDetail ( ) . getJobDataMap ( ) . get ( QuartzEndpoint . ENDPOINT_KEY ) ; if ( component == null ) { throw new JobExecutionException ( "No quartz endpoint available for key: " + QuartzEndpoint . ENDPOINT_KEY + ". Bad job data map" ) ; } component . onJobExecute ( context ) ; } } 	0	['2', '1', '0', '6', '8', '1', '0', '6', '2', '2', '23', '0', '0', '0', '0.75', '0', '0', '10.5', '1', '0.5', '0']
package org . apache . camel . processor ; import java . util . Comparator ; import java . util . List ; import java . util . Set ; import java . util . TreeSet ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . util . ExpressionComparator ; import org . apache . camel . util . ExpressionListComparator ; public class Resequencer extends BatchProcessor { public Resequencer ( Endpoint endpoint , Processor processor , Expression < Exchange > expression ) { this ( endpoint , processor , createSet ( expression ) ) ; } public Resequencer ( Endpoint endpoint , Processor processor , List < Expression > expressions ) { this ( endpoint , processor , createSet ( expressions ) ) ; } public Resequencer ( Endpoint endpoint , Processor processor , Set < Exchange > collection ) { super ( endpoint , processor , collection ) ; } @ Override public String toString ( ) { return "Resequencer[to: " + getProcessor ( ) + "]" ; } protected static Set < Exchange > createSet ( Expression < Exchange > expression ) { return createSet ( new ExpressionComparator < Exchange > ( expression ) ) ; } protected static Set < Exchange > createSet ( List < Expression > expressions ) { if ( expressions . size ( ) == 1 ) { return createSet ( expressions . get ( 0 ) ) ; } return createSet ( new ExpressionListComparator ( expressions ) ) ; } protected static Set < Exchange > createSet ( Comparator < ? super Exchange > comparator ) { return new TreeSet < Exchange > ( comparator ) ; } } 	1	['7', '3', '0', '8', '18', '21', '2', '6', '4', '2', '66', '0', '0', '0.882352941', '0.326530612', '0', '0', '8.428571429', '2', '0.7143', '1']
package org . apache . camel . component . stream ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . Writer ; import java . net . URL ; import java . net . URLConnection ; import java . nio . charset . Charset ; import java . util . Arrays ; import java . util . List ; import org . apache . camel . CamelExchangeException ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class StreamProducer extends DefaultProducer < Exchange > { private static final transient Log LOG = LogFactory . getLog ( StreamProducer . class ) ; private static final String TYPES = "out,err,file,header,url" ; private static final String INVALID_URI = "Invalid uri, valid form: 'stream:{" + TYPES + "}'" ; private static final List < String > TYPES_LIST = Arrays . asList ( TYPES . split ( "," ) ) ; private OutputStream outputStream = System . out ; private StreamEndpoint endpoint ; private String uri ; public StreamProducer ( StreamEndpoint endpoint , String uri ) throws Exception { super ( endpoint ) ; this . endpoint = endpoint ; validateUri ( uri ) ; } @ Override public void doStop ( ) throws Exception { super . doStop ( ) ; } public void process ( Exchange exchange ) throws Exception { delay ( endpoint . getDelay ( ) ) ; if ( "out" . equals ( uri ) ) { outputStream = System . out ; } else if ( "err" . equals ( uri ) ) { outputStream = System . err ; } else if ( "file" . equals ( uri ) ) { outputStream = resolveStreamFromFile ( ) ; } else if ( "header" . equals ( uri ) ) { outputStream = resolveStreamFromHeader ( exchange . getIn ( ) . getHeader ( "stream" ) , exchange ) ; } else if ( "url" . equals ( uri ) ) { outputStream = resolveStreamFromUrl ( ) ; } writeToStream ( exchange ) ; } private OutputStream resolveStreamFromUrl ( ) throws IOException { String u = endpoint . getUrl ( ) ; URL url = new URL ( u ) ; URLConnection c = url . openConnection ( ) ; return c . getOutputStream ( ) ; } private OutputStream resolveStreamFromFile ( ) throws IOException { String fileName = endpoint . getFile ( ) != null ? endpoint . getFile ( ) . trim ( ) : "_file" ; File f = new File ( fileName ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "About to write to file: " + f ) ; } f . createNewFile ( ) ; return new FileOutputStream ( f ) ; } private OutputStream resolveStreamFromHeader ( Object o , Exchange exchange ) throws CamelExchangeException { if ( o != null && o instanceof OutputStream ) { return ( OutputStream ) o ; } else { throw new CamelExchangeException ( "Expected OutputStream in header('stream'), found: " + o , exchange ) ; } } private void delay ( long ms ) throws InterruptedException { if ( ms == 0 ) { return ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Delaying " + ms + " millis" ) ; } Thread . sleep ( ms ) ; } private void writeToStream ( Exchange exchange ) throws IOException , CamelExchangeException { Object body = exchange . getIn ( ) . getBody ( ) ; if ( body instanceof String ) { Charset charset = endpoint . getCharset ( ) ; Writer writer = new OutputStreamWriter ( outputStream , charset ) ; BufferedWriter bw = new BufferedWriter ( writer ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Writing as text: " + body + " to " + outputStream + " using encoding:" + charset ) ; } bw . write ( ( String ) body ) ; bw . write ( "\n" ) ; bw . flush ( ) ; } else if ( body instanceof byte [ ] ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Writing as text: " + body + " to " + outputStream ) ; } outputStream . write ( ( byte [ ] ) body ) ; } else { throw new CamelExchangeException ( "The body is neither a String or byte array. " + "Can not write body to output stream" , exchange ) ; } } private void validateUri ( String uri ) throws Exception { String [ ] s = uri . split ( ":" ) ; if ( s . length < 2 ) { throw new IllegalArgumentException ( INVALID_URI ) ; } String [ ] t = s [ 1 ] . split ( "\\?" ) ; if ( t . length < 1 ) { throw new IllegalArgumentException ( INVALID_URI ) ; } this . uri = t [ 0 ] . trim ( ) ; if ( ! TYPES_LIST . contains ( this . uri ) ) { throw new IllegalArgumentException ( INVALID_URI ) ; } } } 	0	['10', '3', '0', '8', '46', '11', '1', '8', '3', '0.80952381', '334', '1', '1', '0.714285714', '0.314814815', '1', '1', '31.7', '1', '0.8', '0']
package org . apache . camel . view ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . model . AggregatorType ; import org . apache . camel . model . ChoiceType ; import org . apache . camel . model . FilterType ; import org . apache . camel . model . FromType ; import org . apache . camel . model . OtherwiseType ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . model . RecipientListType ; import org . apache . camel . model . ResequencerType ; import org . apache . camel . model . RoutingSlipType ; import org . apache . camel . model . SplitterType ; import org . apache . camel . model . ToType ; import org . apache . camel . model . WhenType ; import static org . apache . camel . util . ObjectHelper . isNotNullAndNonEmpty ; import static org . apache . camel . util . ObjectHelper . isNullOrBlank ; public class NodeData { public String id ; public String image ; public String label ; public String shape ; public String edgeLabel ; public String tooltop ; public String nodeType ; public boolean nodeWritten ; public String url ; public List < ProcessorType > outputs ; public String association = "property" ; private final String imagePrefix ; public NodeData ( String id , Object node , String imagePrefix ) { this . id = id ; this . imagePrefix = imagePrefix ; if ( node instanceof ProcessorType ) { ProcessorType processorType = ( ProcessorType ) node ; this . edgeLabel = processorType . getLabel ( ) ; } if ( node instanceof FromType ) { FromType fromType = ( FromType ) node ; this . tooltop = fromType . getLabel ( ) ; this . label = removeQueryString ( this . tooltop ) ; this . url = "http://activemq.apache.org/camel/message-endpoint.html" ; } else if ( node instanceof ToType ) { ToType toType = ( ToType ) node ; this . tooltop = toType . getLabel ( ) ; this . label = removeQueryString ( this . tooltop ) ; this . edgeLabel = "" ; this . url = "http://activemq.apache.org/camel/message-endpoint.html" ; } else if ( node instanceof FilterType ) { this . image = imagePrefix + "MessageFilterIcon.png" ; this . nodeType = "Message Filter" ; } else if ( node instanceof WhenType ) { this . image = imagePrefix + "MessageFilterIcon.png" ; this . nodeType = "When Filter" ; this . url = "http://activemq.apache.org/camel/content-based-router.html" ; } else if ( node instanceof OtherwiseType ) { this . nodeType = "Otherwise" ; this . edgeLabel = "" ; this . url = "http://activemq.apache.org/camel/content-based-router.html" ; this . tooltop = "Otherwise" ; } else if ( node instanceof ChoiceType ) { this . image = imagePrefix + "ContentBasedRouterIcon.png" ; this . nodeType = "Content Based Router" ; this . label = "" ; this . edgeLabel = "" ; ChoiceType choice = ( ChoiceType ) node ; List < ProcessorType > outputs = new ArrayList < ProcessorType > ( choice . getWhenClauses ( ) ) ; if ( choice . getOtherwise ( ) != null ) { outputs . add ( choice . getOtherwise ( ) ) ; } this . outputs = outputs ; } else if ( node instanceof RecipientListType ) { this . image = imagePrefix + "RecipientListIcon.png" ; this . nodeType = "Recipient List" ; } else if ( node instanceof RoutingSlipType ) { this . image = imagePrefix + "RoutingTableIcon.png" ; this . nodeType = "Routing Slip" ; this . url = "http://activemq.apache.org/camel/routing-slip.html" ; this . tooltop = ( ( RoutingSlipType ) node ) . getHeaderName ( ) ; } else if ( node instanceof SplitterType ) { this . image = imagePrefix + "SplitterIcon.png" ; this . nodeType = "Splitter" ; } else if ( node instanceof AggregatorType ) { this . image = imagePrefix + "AggregatorIcon.png" ; this . nodeType = "Aggregator" ; } else if ( node instanceof ResequencerType ) { this . image = imagePrefix + "ResequencerIcon.png" ; this . nodeType = "Resequencer" ; } if ( isNullOrBlank ( this . nodeType ) && node != null ) { String name = node . getClass ( ) . getName ( ) ; int idx = name . lastIndexOf ( '.' ) ; if ( idx > 0 ) { name = name . substring ( idx + 1 ) ; } if ( name . endsWith ( "Type" ) ) { name = name . substring ( 0 , name . length ( ) - 4 ) ; } this . nodeType = insertSpacesBetweenCamelCase ( name ) ; } if ( this . label == null ) { if ( isNullOrBlank ( this . image ) ) { this . label = this . nodeType ; this . shape = "box" ; } else if ( isNotNullAndNonEmpty ( this . edgeLabel ) ) { this . label = "" ; } else { this . label = node . toString ( ) ; } } if ( isNullOrBlank ( this . tooltop ) ) { if ( isNotNullAndNonEmpty ( this . nodeType ) ) { String description = isNotNullAndNonEmpty ( this . edgeLabel ) ? this . edgeLabel : this . label ; this . tooltop = this . nodeType + ": " + description ; } else { this . tooltop = this . label ; } } if ( isNullOrBlank ( this . url ) && isNotNullAndNonEmpty ( this . nodeType ) ) { this . url = "http://activemq.apache.org/camel/" + this . nodeType . toLowerCase ( ) . replace ( ' ' , '-' ) + ".html" ; } if ( node instanceof ProcessorType && this . outputs == null ) { ProcessorType processorType = ( ProcessorType ) node ; this . outputs = processorType . getOutputs ( ) ; } } protected String removeQueryString ( String text ) { int idx = text . indexOf ( "?" ) ; if ( idx <= 0 ) { return text ; } else { return text . substring ( 0 , idx ) ; } } public static String insertSpacesBetweenCamelCase ( String name ) { boolean lastCharacterLowerCase = false ; StringBuffer buffer = new StringBuffer ( ) ; int i = 0 ; for ( int size = name . length ( ) ; i < size ; i ++ ) { char ch = name . charAt ( i ) ; if ( Character . isUpperCase ( ch ) ) { if ( lastCharacterLowerCase ) { buffer . append ( ' ' ) ; } lastCharacterLowerCase = false ; } else { lastCharacterLowerCase = true ; } buffer . append ( ch ) ; } return buffer . toString ( ) ; } } 	1	['3', '1', '0', '16', '34', '3', '3', '13', '2', '1.041666667', '461', '0.083333333', '0', '0', '0.666666667', '0', '0', '148.6666667', '4', '2', '1']
package org . apache . camel . spring ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . model . IdentifiedType ; @ XmlRootElement ( name = "jmxAgent" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class CamelJMXAgentType extends IdentifiedType { @ XmlAttribute ( required = false ) private Boolean disabled ; @ XmlAttribute ( required = false ) private Integer registryPort ; @ XmlAttribute ( required = false ) private Integer connectorPort ; @ XmlAttribute ( required = false ) private String mbeanServerDefaultDomain ; @ XmlAttribute ( required = false ) private String mbeanObjectDomainName ; @ XmlAttribute ( required = false ) private String serviceUrlPath ; @ XmlAttribute ( required = false ) private Boolean createConnector ; @ XmlAttribute ( required = false ) private Boolean usePlatformMBeanServer ; public Integer getConnectorPort ( ) { return connectorPort ; } public void setConnectorPort ( Integer value ) { connectorPort = value ; } public Integer getRegistryPort ( ) { return registryPort ; } public void setRegistryPort ( Integer value ) { registryPort = value ; } public String getMbeanServerDefaultDomain ( ) { return mbeanServerDefaultDomain ; } public void setMbeanServerDefaultDomain ( String value ) { mbeanServerDefaultDomain = value ; } public String getMbeanObjectDomainName ( ) { return mbeanObjectDomainName ; } public void setMbeanObjectDomainName ( String value ) { mbeanObjectDomainName = value ; } public String getServiceUrlPath ( ) { return serviceUrlPath ; } public void setServiceUrlPath ( String value ) { serviceUrlPath = value ; } public Boolean isCreateConnector ( ) { return createConnector ; } public void setCreateConnector ( Boolean value ) { createConnector = value ; } public Boolean isUsePlatformMBeanServer ( ) { return usePlatformMBeanServer ; } public void setUsePlatformMBeanServer ( Boolean value ) { usePlatformMBeanServer = value ; } public Boolean isDisabled ( ) { return disabled ; } public void setDisabled ( Boolean value ) { disabled = value ; } } 	0	['17', '2', '0', '2', '18', '120', '1', '1', '17', '0.9375', '84', '1', '0', '0.111111111', '0.367647059', '0', '0', '3.470588235', '1', '0.9412', '0']
package org . apache . camel . component . jmx ; import javax . management . Notification ; import org . apache . camel . impl . DefaultMessage ; public class JMXMessage extends DefaultMessage { private Notification notification ; public JMXMessage ( ) { this ( null ) ; } public JMXMessage ( Notification notification ) { this . notification = notification ; } @ Override public String toString ( ) { return "JMXMessage: " + notification ; } @ Override public JMXExchange getExchange ( ) { return ( JMXExchange ) super . getExchange ( ) ; } @ Override public JMXMessage newInstance ( ) { return new JMXMessage ( ) ; } public Notification getNotification ( ) { return notification ; } } 	1	['9', '3', '0', '4', '12', '30', '1', '4', '9', '0.25', '50', '1', '0', '0.833333333', '0.555555556', '2', '5', '4.444444444', '1', '0.7778', '1']
package org . apache . camel . component . jhc ; import org . apache . camel . CamelContext ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; import org . apache . http . HttpRequest ; import org . apache . http . HttpResponse ; public class JhcExchange extends DefaultExchange { public JhcExchange ( CamelContext context ) { super ( context ) ; } public JhcExchange ( CamelContext context , ExchangePattern pattern ) { super ( context , pattern ) ; } } 	0	['2', '2', '0', '3', '4', '1', '0', '3', '2', '2', '11', '0', '0', '1', '0.833333333', '0', '0', '4.5', '0', '0', '0']
package org . apache . camel . converter ; import java . util . Collection ; import java . util . Iterator ; import org . apache . camel . Converter ; import org . apache . camel . util . ObjectHelper ; @ Converter public final class ObjectConverter { private ObjectConverter ( ) { } public static boolean isCollection ( Object value ) { return value instanceof Collection || ( value != null && value . getClass ( ) . isArray ( ) ) ; } @ SuppressWarnings ( "unchecked" ) @ Converter @ Deprecated public static Iterator iterator ( Object value ) { return ObjectHelper . createIterator ( value ) ; } @ Converter public static boolean toBool ( Object value ) { Boolean answer = toBoolean ( value ) ; if ( answer != null ) { return answer . booleanValue ( ) ; } return false ; } @ Converter public static Boolean toBoolean ( Object value ) { return ObjectHelper . toBoolean ( value ) ; } @ Converter public static Boolean toBoolean ( Boolean value ) { if ( value != null ) { return value ; } return Boolean . FALSE ; } @ Converter public static Byte toByte ( Object value ) { if ( value instanceof Byte ) { return ( Byte ) value ; } else if ( value instanceof Number ) { Number number = ( Number ) value ; return Byte . valueOf ( number . byteValue ( ) ) ; } else if ( value instanceof String ) { return Byte . valueOf ( ( String ) value ) ; } else { return null ; } } @ Converter public static byte [ ] toByteArray ( String value ) { return value . getBytes ( ) ; } @ Converter public static char [ ] toCharArray ( String value ) { return value . toCharArray ( ) ; } @ Converter public static String fromCharArray ( char [ ] value ) { return new String ( value ) ; } @ Converter public static Short toShort ( Object value ) { if ( value instanceof Short ) { return ( Short ) value ; } else if ( value instanceof Number ) { Number number = ( Number ) value ; return Short . valueOf ( number . shortValue ( ) ) ; } else if ( value instanceof String ) { return Short . valueOf ( ( String ) value ) ; } else { return null ; } } @ Converter public static Integer toInteger ( Object value ) { if ( value instanceof Integer ) { return ( Integer ) value ; } else if ( value instanceof Number ) { Number number = ( Number ) value ; return Integer . valueOf ( number . intValue ( ) ) ; } else if ( value instanceof String ) { return Integer . valueOf ( ( String ) value ) ; } else { return null ; } } @ Converter public static Long toLong ( Object value ) { if ( value instanceof Long ) { return ( Long ) value ; } else if ( value instanceof Number ) { Number number = ( Number ) value ; return Long . valueOf ( number . longValue ( ) ) ; } else if ( value instanceof String ) { return Long . valueOf ( ( String ) value ) ; } else { return null ; } } @ Converter public static Float toFloat ( Object value ) { if ( value instanceof Float ) { return ( Float ) value ; } else if ( value instanceof Number ) { Number number = ( Number ) value ; return Float . valueOf ( number . floatValue ( ) ) ; } else if ( value instanceof String ) { return Float . valueOf ( ( String ) value ) ; } else { return null ; } } @ Converter public static Double toDouble ( Object value ) { if ( value instanceof Double ) { return ( Double ) value ; } else if ( value instanceof Number ) { Number number = ( Number ) value ; return Double . valueOf ( number . doubleValue ( ) ) ; } else if ( value instanceof String ) { return Double . valueOf ( ( String ) value ) ; } else { return null ; } } } 	1	['15', '1', '0', '11', '42', '105', '10', '1', '14', '2', '214', '0', '0', '0', '0.2', '0', '0', '13.26666667', '4', '2.4667', '2']
package org . apache . camel . component . uface ; import java . beans . PropertyChangeListener ; import java . beans . PropertyChangeSupport ; import java . util . Collection ; import java . util . List ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultCamelContext ; import org . apache . camel . impl . DelegateLifecycleStrategy ; import org . apache . camel . spi . BrowsableEndpoint ; import org . apache . camel . util . CamelContextHelper ; import org . apache . camel . util . ObjectHelper ; import org . eclipse . core . databinding . observable . Realm ; import org . eclipse . core . databinding . observable . list . IObservableList ; import org . eclipse . core . databinding . observable . list . WritableList ; import org . eclipse . core . databinding . observable . value . WritableValue ; import org . ufacekit . model . ModelHelper ; import org . ufacekit . ui . AttributeDescriptor ; import org . ufacekit . ui . UIComposite ; import org . ufacekit . ui . UIFactory ; import org . ufacekit . ui . beanform . BeanForm ; import org . ufacekit . ui . controls . CellLabelProvider ; import org . ufacekit . ui . controls . UITable ; import org . ufacekit . ui . controls . UITableColumn ; import org . ufacekit . ui . layouts . GridLayoutData ; public class UFaceBrowser { private final DefaultCamelContext camelContext ; private IObservableList endpoints ; private PropertyChangeSupport propertyChangeSupport = new PropertyChangeSupport ( this ) ; public UFaceBrowser ( DefaultCamelContext camelContext ) { ObjectHelper . notNull ( camelContext , "camelContext" ) ; this . camelContext = camelContext ; this . endpoints = new WritableList ( Realm . getDefault ( ) ) ; List < BrowsableEndpoint > list = CamelContextHelper . getSingletonEndpoints ( camelContext , BrowsableEndpoint . class ) ; for ( BrowsableEndpoint endpoint : list ) { if ( ! endpoints . contains ( endpoint ) ) { endpoints . add ( endpoint ) ; } } camelContext . setLifecycleStrategy ( new DelegateLifecycleStrategy ( camelContext . getLifecycleStrategy ( ) ) { @ Override public void onEndpointAdd ( Endpoint < ? extends Exchange > endpoint ) { super . onEndpointAdd ( endpoint ) ; if ( endpoint instanceof BrowsableEndpoint ) { onBrowsableEndpoint ( ( BrowsableEndpoint ) endpoint ) ; } } } ) ; } public void addPropertyChangeListener ( PropertyChangeListener listener ) { propertyChangeSupport . addPropertyChangeListener ( listener ) ; } public void removePropertyChangeListener ( PropertyChangeListener listener ) { propertyChangeSupport . removePropertyChangeListener ( listener ) ; } public IObservableList getEndpoints ( ) { return endpoints ; } public DefaultCamelContext getCamelContext ( ) { return camelContext ; } public void createBrowserUI ( UIComposite root ) { UIFactory ui = root . getFactory ( ) ; UIComposite splitter = ui . newHorizontalSplitPanel ( root , new GridLayoutData ( GridLayoutData . ALIGN_CENTER , GridLayoutData . ALIGN_CENTER ) ) ; UITable tree = createEndpointTableUI ( splitter ) ; BeanForm selectionForm = new BeanForm ( ) ; UITable table = ui . newTable ( splitter , new UITable . TableUIInfo ( new GridLayoutData ( GridLayoutData . ALIGN_FILL , GridLayoutData . ALIGN_FILL , true , true ) ) ) ; selectionForm . add ( table , new UITable . TableBindingInfo ( selectionForm . detailList ( "exchanges" , Collection . class ) ) ) ; ui . newTableColumn ( table , new UITableColumn . TableColumnUIInfo ( null , new CellLabelProvider ( ) { public String getLabel ( Object object ) { Exchange exchange = ( Exchange ) object ; return exchange . getIn ( ) . getBody ( String . class ) ; } } ) ) ; ui . newTableColumn ( table , new UITableColumn . TableColumnUIInfo ( null , new CellLabelProvider ( ) { public String getLabel ( Object object ) { Exchange exchange = ( Exchange ) object ; return exchange . getIn ( ) . getHeaders ( ) . toString ( ) ; } } ) ) ; selectionForm . bind ( tree . getSelectionObservable ( ) ) ; } protected UITable createEndpointTableUI ( UIComposite root ) { BeanForm form = new BeanForm ( ) ; UIFactory ui = root . getFactory ( ) ; AttributeDescriptor bindingData = form . detailList ( "endpoints" , Collection . class ) ; UITable table = ui . newTable ( root , new UITable . TableUIInfo ( null ) ) ; form . add ( table , new UITable . TableBindingInfo ( bindingData ) ) ; ui . newTableColumn ( table , new UITableColumn . TableColumnUIInfo ( null , new CellLabelProvider ( ) { public String getLabel ( Object object ) { BrowsableEndpoint endpoint = ( BrowsableEndpoint ) object ; return endpoint . getEndpointUri ( ) ; } } ) ) ; WritableValue value = ModelHelper . createWritableValue ( this ) ; form . bind ( value ) ; return table ; } protected void onBrowsableEndpoint ( BrowsableEndpoint endpoint ) { endpoints . add ( endpoint ) ; } } 	0	['8', '1', '1', '31', '42', '14', '5', '30', '6', '0.761904762', '207', '1', '1', '0', '0.35', '0', '0', '24.5', '1', '0.875', '0']
package org . apache . camel . processor . resequencer ; import java . util . Queue ; import java . util . Timer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class ResequencerEngine < E > implements TimeoutHandler { private static final transient Log LOG = LogFactory . getLog ( ResequencerEngine . class ) ; private long timeout ; private int capacity ; private Queue < E > outQueue ; private Element < E > lastDelivered ; private Sequence < Element < E > > sequence ; private Timer timer ; public ResequencerEngine ( SequenceElementComparator < E > comparator ) { this ( comparator , Integer . MAX_VALUE ) ; } public ResequencerEngine ( SequenceElementComparator < E > comparator , int capacity ) { this . timer = new Timer ( "Resequencer Timer" ) ; this . sequence = createSequence ( comparator ) ; this . capacity = capacity ; this . timeout = 2000L ; this . lastDelivered = null ; } public void stop ( ) { this . timer . cancel ( ) ; } public Queue < E > getOutQueue ( ) { return outQueue ; } public void setOutQueue ( Queue < E > outQueue ) { this . outQueue = outQueue ; } public long getTimeout ( ) { return timeout ; } public void setTimeout ( long timeout ) { this . timeout = timeout ; } public synchronized void timeout ( Timeout timout ) { try { while ( deliver ( ) ) { } } catch ( RuntimeException e ) { LOG . error ( "error during delivery" , e ) ; } } public synchronized void add ( E o ) { if ( sequence . size ( ) >= capacity ) { throw new IllegalStateException ( "maximum capacity is reached" ) ; } insert ( o ) ; } public synchronized void put ( E o ) throws InterruptedException { if ( sequence . size ( ) >= capacity ) { wait ( ) ; } insert ( o ) ; } E getLastDelivered ( ) { if ( lastDelivered == null ) { return null ; } return lastDelivered . getObject ( ) ; } void setLastDelivered ( E o ) { lastDelivered = new Element < E > ( o ) ; } private void insert ( E o ) { Element < E > element = new Element < E > ( o ) ; sequence . add ( element ) ; Element < E > successor = sequence . successor ( element ) ; if ( successor != null ) { successor . cancel ( ) ; } if ( successorOfLastDelivered ( element ) ) { } else if ( sequence . predecessor ( element ) != null ) { } else { Timeout t = defineTimeout ( ) ; element . schedule ( t ) ; } while ( deliver ( ) ) { } } private boolean deliver ( ) { if ( sequence . size ( ) == 0 ) { return false ; } Element < E > element = sequence . first ( ) ; if ( element . scheduled ( ) ) { return false ; } sequence . remove ( element ) ; lastDelivered = element ; notify ( ) ; outQueue . add ( element . getObject ( ) ) ; return true ; } private boolean successorOfLastDelivered ( Element < E > element ) { if ( lastDelivered == null ) { return false ; } if ( sequence . comparator ( ) . successor ( element , lastDelivered ) ) { return true ; } return false ; } private Timeout defineTimeout ( ) { Timeout result = new Timeout ( timer , timeout ) ; result . addTimeoutHandler ( this ) ; return result ; } private static < E > Sequence < Element < E > > createSequence ( SequenceElementComparator < E > comparator ) { return new Sequence < Element < E > > ( new ElementComparator < E > ( comparator ) ) ; } } 	1	['18', '1', '0', '9', '44', '85', '1', '8', '10', '0.739495798', '242', '1', '2', '0', '0.205882353', '0', '0', '12.05555556', '5', '1.3889', '2']
package org . apache . camel . spi ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Exchange ; public interface ComponentResolver < E extends Exchange > { Component < E > resolveComponent ( String name , CamelContext context ) throws Exception ; } 	0	['1', '1', '0', '6', '1', '0', '4', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . processor ; import java . text . NumberFormat ; import java . util . concurrent . atomic . AtomicInteger ; import org . apache . camel . Exchange ; import org . apache . commons . logging . Log ; public class ThroughputLogger extends Logger { private int groupSize = 100 ; private long startTime ; private long groupStartTime ; private AtomicInteger receivedCounter = new AtomicInteger ( ) ; private NumberFormat numberFormat = NumberFormat . getNumberInstance ( ) ; private String action = "Received" ; private String logMessage ; public ThroughputLogger ( ) { } public ThroughputLogger ( Log log ) { super ( log ) ; } public ThroughputLogger ( Log log , LoggingLevel level ) { super ( log , level ) ; } public ThroughputLogger ( String logName ) { super ( logName ) ; } public ThroughputLogger ( String logName , LoggingLevel level ) { super ( logName , level ) ; } public ThroughputLogger ( String logName , LoggingLevel level , int groupSize ) { super ( logName , level ) ; setGroupSize ( groupSize ) ; } public ThroughputLogger ( String logName , int groupSize ) { super ( logName ) ; setGroupSize ( groupSize ) ; } public ThroughputLogger ( int groupSize ) { setGroupSize ( groupSize ) ; } @ Override public void process ( Exchange exchange ) { if ( startTime == 0 ) { startTime = System . currentTimeMillis ( ) ; } int receivedCount = receivedCounter . incrementAndGet ( ) ; if ( receivedCount % groupSize == 0 ) { logMessage = createLogMessage ( exchange , receivedCount ) ; super . process ( exchange ) ; } } public int getGroupSize ( ) { return groupSize ; } public void setGroupSize ( int groupSize ) { if ( groupSize == 0 ) { throw new IllegalArgumentException ( "groupSize cannot be zero!" ) ; } this . groupSize = groupSize ; } public NumberFormat getNumberFormat ( ) { return numberFormat ; } public void setNumberFormat ( NumberFormat numberFormat ) { this . numberFormat = numberFormat ; } public String getAction ( ) { return action ; } public void setAction ( String action ) { this . action = action ; } @ Override protected Object logMessage ( Exchange exchange ) { return logMessage ; } protected String createLogMessage ( Exchange exchange , int receivedCount ) { long time = System . currentTimeMillis ( ) ; if ( groupStartTime == 0 ) { groupStartTime = startTime ; } double rate = messagesPerSecond ( groupSize , groupStartTime , time ) ; double average = messagesPerSecond ( receivedCount , startTime , time ) ; groupStartTime = time ; return getAction ( ) + ": " + receivedCount + " messages so far. Last group took: " + ( time - groupStartTime ) + " millis which is: " + numberFormat . format ( rate ) + " messages per second. average: " + numberFormat . format ( average ) ; } protected double messagesPerSecond ( long messageCount , long startTime , long endTime ) { double rate = messageCount * 1000.0 ; rate /= endTime - startTime ; return rate ; } } 	1	['18', '2', '0', '7', '35', '0', '3', '4', '15', '0.638655462', '315', '1', '0', '0.523809524', '0.263888889', '1', '1', '16.11111111', '3', '0.7778', '2']
package org . apache . camel . component . jpa ; public interface Callback < R , P > { R callback ( P parameter ) ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . camel . processor . aggregate ; import java . util . AbstractCollection ; import java . util . Collection ; import java . util . Iterator ; import java . util . LinkedHashMap ; import java . util . Map ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class AggregationCollection extends AbstractCollection < Exchange > { private static final transient Log LOG = LogFactory . getLog ( AggregationCollection . class ) ; private final Expression < Exchange > correlationExpression ; private final AggregationStrategy aggregationStrategy ; private Map < Object , Exchange > map = new LinkedHashMap < Object , Exchange > ( ) ; public AggregationCollection ( Expression < Exchange > correlationExpression , AggregationStrategy aggregationStrategy ) { this . correlationExpression = correlationExpression ; this . aggregationStrategy = aggregationStrategy ; } protected Map < Object , Exchange > getMap ( ) { return map ; } @ Override public boolean add ( Exchange exchange ) { Object correlationKey = correlationExpression . evaluate ( exchange ) ; Exchange oldExchange = map . get ( correlationKey ) ; Exchange newExchange = exchange ; if ( oldExchange != null ) { newExchange = aggregationStrategy . aggregate ( oldExchange , newExchange ) ; } if ( newExchange != oldExchange ) { LOG . debug ( "put exchange:" + newExchange + " for key:" + correlationKey ) ; map . put ( correlationKey , newExchange ) ; } onAggregation ( correlationKey , newExchange ) ; return true ; } public Iterator < Exchange > iterator ( ) { return map . values ( ) . iterator ( ) ; } public int size ( ) { return map . size ( ) ; } @ Override public void clear ( ) { map . clear ( ) ; } protected void onAggregation ( Object correlationKey , Exchange newExchange ) { } } 	1	['9', '2', '1', '9', '25', '4', '4', '5', '6', '0.625', '103', '1', '2', '0.666666667', '0.35', '1', '5', '10', '3', '1', '2']
package org . apache . camel . component . file . remote ; import java . io . OutputStream ; import java . util . Map ; import org . apache . camel . impl . DefaultMessage ; public class RemoteFileMessage extends DefaultMessage { private OutputStream outputStream ; private String fullFileName ; private String hostname ; public RemoteFileMessage ( ) { } public RemoteFileMessage ( String hostname , String fullFileName , OutputStream outputStream ) { this . hostname = hostname ; this . fullFileName = fullFileName ; this . outputStream = outputStream ; setMessageId ( hostname + ":" + fullFileName ) ; } public String getHostname ( ) { return hostname ; } public void setHostname ( String hostname ) { this . hostname = hostname ; } public String getFullFileName ( ) { return fullFileName ; } public void setFullFileName ( String fullFileName ) { this . fullFileName = fullFileName ; } public OutputStream getOutputStream ( ) { return outputStream ; } public void setOutputStream ( OutputStream outputStream ) { this . outputStream = outputStream ; } @ Override public RemoteFileExchange getExchange ( ) { return ( RemoteFileExchange ) super . getExchange ( ) ; } @ Override protected Object createBody ( ) { if ( outputStream != null ) { return getExchange ( ) . getBinding ( ) . extractBodyFromOutputStream ( getExchange ( ) , outputStream ) ; } return null ; } @ Override public RemoteFileMessage newInstance ( ) { return new RemoteFileMessage ( ) ; } @ Override protected void populateInitialHeaders ( Map < String , Object > map ) { super . populateInitialHeaders ( map ) ; map . put ( "file.remote.host" , hostname ) ; map . put ( "file.remote.name" , fullFileName ) ; } } 	0	['15', '3', '0', '5', '22', '71', '1', '5', '13', '0.785714286', '113', '1', '0', '0.729166667', '0.35', '2', '6', '6.333333333', '2', '0.9333', '0']
package org . apache . camel . util ; import java . util . HashMap ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . InvalidPayloadException ; import org . apache . camel . InvalidTypeException ; import org . apache . camel . Message ; import org . apache . camel . NoSuchBeanException ; import org . apache . camel . NoSuchEndpointException ; import org . apache . camel . NoSuchHeaderException ; import org . apache . camel . NoSuchPropertyException ; public final class ExchangeHelper { private ExchangeHelper ( ) { } public static < T > T getExchangeProperty ( Exchange exchange , String propertyName , Class < T > type , T defaultValue ) { T answer = exchange . getProperty ( propertyName , type ) ; if ( answer == null ) { return defaultValue ; } return answer ; } @ SuppressWarnings ( { "unchecked" } ) public static < E extends Exchange > Endpoint < E > resolveEndpoint ( E exchange , Object value ) throws NoSuchEndpointException { Endpoint < E > endpoint ; if ( value instanceof Endpoint ) { endpoint = ( Endpoint < E > ) value ; } else { String uri = value . toString ( ) ; endpoint = CamelContextHelper . getMandatoryEndpoint ( exchange . getContext ( ) , uri ) ; } return endpoint ; } public static < T > T getMandatoryProperty ( Exchange exchange , String propertyName , Class < T > type ) throws NoSuchPropertyException { T answer = exchange . getProperty ( propertyName , type ) ; if ( answer == null ) { throw new NoSuchPropertyException ( exchange , propertyName , type ) ; } return answer ; } public static < T > T getMandatoryHeader ( Exchange exchange , String propertyName , Class < T > type ) throws NoSuchHeaderException { T answer = exchange . getIn ( ) . getHeader ( propertyName , type ) ; if ( answer == null ) { throw new NoSuchHeaderException ( exchange , propertyName , type ) ; } return answer ; } public static Object getMandatoryInBody ( Exchange exchange ) throws InvalidPayloadException { Object answer = exchange . getIn ( ) . getBody ( ) ; if ( answer == null ) { throw new InvalidPayloadException ( exchange , Object . class ) ; } return answer ; } public static < T > T getMandatoryInBody ( Exchange exchange , Class < T > type ) throws InvalidPayloadException { T answer = exchange . getIn ( ) . getBody ( type ) ; if ( answer == null ) { throw new InvalidPayloadException ( exchange , type ) ; } return answer ; } public static Object getMandatoryOutBody ( Exchange exchange ) throws InvalidPayloadException { Message out = exchange . getOut ( ) ; Object answer = out . getBody ( ) ; if ( answer == null ) { throw new InvalidPayloadException ( exchange , Object . class , out ) ; } return answer ; } public static < T > T getMandatoryOutBody ( Exchange exchange , Class < T > type ) throws InvalidPayloadException { Message out = exchange . getOut ( ) ; T answer = out . getBody ( type ) ; if ( answer == null ) { throw new InvalidPayloadException ( exchange , type , out ) ; } return answer ; } public static < T > T convertToMandatoryType ( Exchange exchange , Class < T > type , Object value ) throws InvalidTypeException { T answer = convertToType ( exchange , type , value ) ; if ( answer == null ) { throw new InvalidTypeException ( exchange , value , type ) ; } return answer ; } public static < T > T convertToType ( Exchange exchange , Class < T > type , Object value ) { return exchange . getContext ( ) . getTypeConverter ( ) . convertTo ( type , value ) ; } public static void copyResults ( Exchange result , Exchange source ) { if ( result != source ) { result . setException ( source . getException ( ) ) ; Message fault = source . getFault ( false ) ; if ( fault != null ) { result . getFault ( true ) . copyFrom ( fault ) ; } Message out = source . getOut ( false ) ; if ( out != null ) { result . getOut ( true ) . copyFrom ( out ) ; } else { result . getOut ( true ) . copyFrom ( source . getIn ( ) ) ; } result . getProperties ( ) . clear ( ) ; result . getProperties ( ) . putAll ( source . getProperties ( ) ) ; } } public static boolean isInCapable ( Exchange exchange ) { ExchangePattern pattern = exchange . getPattern ( ) ; return pattern != null && pattern . isInCapable ( ) ; } public static boolean isOutCapable ( Exchange exchange ) { ExchangePattern pattern = exchange . getPattern ( ) ; return pattern != null && pattern . isOutCapable ( ) ; } public static < T > T newInstance ( Exchange exchange , Class < T > type ) { return exchange . getContext ( ) . getInjector ( ) . newInstance ( type ) ; } public static Map createVariableMap ( Exchange exchange ) { Map answer = new HashMap ( ) ; populateVariableMap ( exchange , answer ) ; return answer ; } public static void populateVariableMap ( Exchange exchange , Map map ) { map . put ( "exchange" , exchange ) ; Message in = exchange . getIn ( ) ; map . put ( "in" , in ) ; map . put ( "request" , in ) ; map . put ( "headers" , in . getHeaders ( ) ) ; map . put ( "body" , in . getBody ( ) ) ; if ( isOutCapable ( exchange ) ) { Message out = exchange . getOut ( true ) ; map . put ( "out" , out ) ; map . put ( "response" , out ) ; } map . put ( "camelContext" , exchange . getContext ( ) ) ; } public static String getContentType ( Exchange exchange ) { return exchange . getIn ( ) . getHeader ( "Content-Type" , String . class ) ; } public static Object lookupMandatoryBean ( Exchange exchange , String name ) { Object value = lookupBean ( exchange , name ) ; if ( value == null ) { throw new NoSuchBeanException ( name ) ; } return value ; } public static < T > T lookupMandatoryBean ( Exchange exchange , String name , Class < T > type ) { T value = lookupBean ( exchange , name , type ) ; if ( value == null ) { throw new NoSuchBeanException ( name ) ; } return value ; } public static Object lookupBean ( Exchange exchange , String name ) { return exchange . getContext ( ) . getRegistry ( ) . lookup ( name ) ; } public static < T > T lookupBean ( Exchange exchange , String name , Class < T > type ) { return exchange . getContext ( ) . getRegistry ( ) . lookup ( name , type ) ; } } 	1	['22', '1', '0', '39', '59', '231', '24', '15', '21', '2', '358', '0', '0', '0', '0.333333333', '0', '0', '15.27272727', '4', '1.4545', '1']
package org . apache . camel . spi ; import org . apache . camel . Exchange ; public interface UnitOfWork { void addSynchronization ( Synchronization synchronization ) ; void removeSynchronization ( Synchronization synchronization ) ; void done ( Exchange exchange ) ; String getId ( ) ; } 	0	['4', '1', '0', '7', '4', '6', '6', '2', '4', '2', '4', '0', '0', '0', '0.583333333', '0', '0', '0', '1', '1', '0']
package org . apache . camel ; public class NoSuchEndpointException extends RuntimeCamelException { private static final long serialVersionUID = - 8721487431101572630L ; private final String uri ; public NoSuchEndpointException ( String uri ) { super ( "No endpoint could be found for: " + uri ) ; this . uri = uri ; } public String getUri ( ) { return uri ; } } 	1	['2', '5', '0', '8', '6', '0', '7', '1', '2', '1', '21', '1', '0', '0.944444444', '0.75', '0', '0', '8.5', '1', '0.5', '1']
package org . apache . camel . impl ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . TypeConverter ; import org . apache . camel . impl . converter . TypeConverterRegistry ; import org . apache . camel . spi . Injector ; public class ReportingTypeConverterRegistry implements TypeConverterRegistry { private List < String > errors = new ArrayList < String > ( ) ; public String [ ] getErrors ( ) { return errors . toArray ( new String [ errors . size ( ) ] ) ; } public void addTypeConverter ( Class toType , Class fromType , TypeConverter typeConverter ) { if ( errors . size ( ) == 0 ) { errors . add ( "Method should not be invoked." ) ; } } public Injector getInjector ( ) { return null ; } } 	0	['4', '1', '0', '3', '9', '0', '0', '3', '4', '0.333333333', '34', '1', '0', '0', '0.5', '0', '0', '7.25', '2', '1', '0']
package org . apache . camel . impl ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . converter . AsyncProcessorTypeConverter ; import org . apache . camel . spi . ExceptionHandler ; import org . apache . camel . util . ServiceHelper ; public class DefaultConsumer < E extends Exchange > extends ServiceSupport implements Consumer < E > { private Endpoint < E > endpoint ; private Processor processor ; private AsyncProcessor asyncProcessor ; private ExceptionHandler exceptionHandler ; public DefaultConsumer ( Endpoint < E > endpoint , Processor processor ) { this . endpoint = endpoint ; this . processor = processor ; } @ Override public String toString ( ) { return "Consumer on " + endpoint ; } public Endpoint < E > getEndpoint ( ) { return endpoint ; } public Processor getProcessor ( ) { return processor ; } public AsyncProcessor getAsyncProcessor ( ) { if ( asyncProcessor == null ) { asyncProcessor = AsyncProcessorTypeConverter . convert ( processor ) ; } return asyncProcessor ; } public ExceptionHandler getExceptionHandler ( ) { if ( exceptionHandler == null ) { exceptionHandler = new LoggingExceptionHandler ( getClass ( ) ) ; } return exceptionHandler ; } public void setExceptionHandler ( ExceptionHandler exceptionHandler ) { this . exceptionHandler = exceptionHandler ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( processor ) ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( processor ) ; } protected void handleException ( Throwable t ) { getExceptionHandler ( ) . handleException ( t ) ; } } 	1	['10', '2', '17', '27', '21', '17', '18', '9', '7', '0.777777778', '90', '1', '4', '0.590909091', '0.28', '1', '1', '7.6', '2', '1.1', '1']
package org . apache . camel . component . spring . integration ; import org . apache . camel . Exchange ; import org . springframework . integration . message . GenericMessage ; public final class SpringIntegrationBinding { private SpringIntegrationBinding ( ) { } @ SuppressWarnings ( "unchecked" ) public static org . springframework . integration . message . Message createSpringIntegrationMessage ( Exchange exchange ) { org . apache . camel . Message message = exchange . getIn ( ) ; GenericMessage siMessage = new GenericMessage ( message . getBody ( ) ) ; return siMessage ; } @ SuppressWarnings ( "unchecked" ) public static org . springframework . integration . message . Message storeToSpringIntegrationMessage ( org . apache . camel . Message message ) { GenericMessage siMessage = new GenericMessage ( message . getBody ( ) ) ; return siMessage ; } public static void storeToCamelMessage ( org . springframework . integration . message . Message siMessage , org . apache . camel . Message cMessage ) { cMessage . setBody ( siMessage . getPayload ( ) ) ; } } 	0	['4', '1', '0', '8', '10', '6', '4', '4', '3', '2', '31', '0', '0', '0', '0.3125', '0', '0', '6.75', '1', '0.75', '0']
package org . apache . camel . component . bean ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . ServiceHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class BeanProcessor extends ServiceSupport implements Processor { public static final String METHOD_NAME = "org.apache.camel.MethodName" ; private static final transient Log LOG = LogFactory . getLog ( BeanProcessor . class ) ; private Method methodObject ; private String method ; private BeanHolder beanHolder ; public BeanProcessor ( Object pojo , BeanInfo beanInfo ) { this ( new ConstantBeanHolder ( pojo , beanInfo ) ) ; } public BeanProcessor ( Object pojo , CamelContext camelContext , ParameterMappingStrategy parameterMappingStrategy ) { this ( pojo , new BeanInfo ( camelContext , pojo . getClass ( ) , parameterMappingStrategy ) ) ; } public BeanProcessor ( Object pojo , CamelContext camelContext ) { this ( pojo , camelContext , BeanInfo . createParameterMappingStrategy ( camelContext ) ) ; } public BeanProcessor ( BeanHolder beanHolder ) { this . beanHolder = beanHolder ; } @ Override public String toString ( ) { String description = methodObject != null ? " " + methodObject : "" ; return "BeanProcessor[" + beanHolder + description + "]" ; } public void process ( Exchange exchange ) throws Exception { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( ">>>> invoking method for: " + exchange ) ; } Object bean = beanHolder . getBean ( ) ; exchange . setProperty ( "org.apache.camel.bean.BeanHolder" , beanHolder ) ; Processor processor = getProcessor ( ) ; BeanInfo beanInfo = beanHolder . getBeanInfo ( ) ; if ( processor != null ) { processor . process ( exchange ) ; return ; } Message in = exchange . getIn ( ) ; BeanInvocation beanInvoke = in . getBody ( BeanInvocation . class ) ; if ( beanInvoke != null ) { beanInvoke . invoke ( bean , exchange ) ; return ; } boolean isExplicitMethod = false ; String prevMethod = null ; MethodInvocation invocation ; if ( methodObject != null ) { invocation = beanInfo . createInvocation ( methodObject , bean , exchange ) ; } else { if ( ObjectHelper . isNotNullAndNonEmpty ( method ) ) { prevMethod = in . getHeader ( METHOD_NAME , String . class ) ; in . setHeader ( METHOD_NAME , method ) ; isExplicitMethod = true ; } invocation = beanInfo . createInvocation ( bean , exchange ) ; } if ( invocation == null ) { throw new IllegalStateException ( "No method invocation could be created, " + "no maching method could be found on: " + bean ) ; } try { Object value = invocation . proceed ( ) ; if ( value != null ) { if ( exchange . getPattern ( ) . isOutCapable ( ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Setting bean invocation value on OUT message: " + value ) ; } exchange . getOut ( true ) . setBody ( value ) ; } else { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Setting bean invocation value on IN message: " + value ) ; } exchange . getIn ( ) . setBody ( value ) ; } } } catch ( InvocationTargetException e ) { Throwable cause = e . getCause ( ) ; if ( cause instanceof Exception ) { throw ( Exception ) cause ; } else { throw e ; } } catch ( Exception e ) { throw e ; } catch ( Throwable throwable ) { throw new Exception ( throwable ) ; } finally { if ( isExplicitMethod ) { in . setHeader ( METHOD_NAME , prevMethod ) ; } } } protected Processor getProcessor ( ) { return beanHolder . getProcessor ( ) ; } public Method getMethodObject ( ) { return methodObject ; } public void setMethodObject ( Method methodObject ) { this . methodObject = methodObject ; } public String getMethod ( ) { return method ; } public void setMethod ( String method ) { this . method = method ; } @ Deprecated public void setMethodName ( String method ) { setMethod ( method ) ; } protected void doStart ( ) throws Exception { ServiceHelper . startService ( getProcessor ( ) ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopService ( getProcessor ( ) ) ; } } 	1	['15', '2', '0', '24', '50', '75', '8', '16', '11', '0.8', '299', '0.8', '1', '0.565217391', '0.206349206', '1', '1', '18.6', '2', '0.7333', '2']
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Processor ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "finally" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class FinallyType extends OutputType < ProcessorType > implements Block { @ Override public String toString ( ) { return "Finally[" + getOutputs ( ) + "]" ; } @ Override public String getShortName ( ) { return "finally" ; } @ Override public String getLabel ( ) { return "" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { return routeContext . createProcessor ( this ) ; } } 	0	['5', '4', '0', '6', '12', '10', '1', '5', '5', '2', '28', '0', '0', '0.974522293', '0.6', '1', '1', '4.6', '1', '0.8', '0']
package org . apache . camel ; import org . apache . camel . impl . DefaultProducerTemplate ; @ Deprecated public class CamelTemplate < E extends Exchange > extends DefaultProducerTemplate < E > { public CamelTemplate ( CamelContext context ) { super ( context ) ; } public CamelTemplate ( CamelContext context , Endpoint defaultEndpoint ) { super ( context , defaultEndpoint ) ; } } 	1	['2', '3', '0', '3', '4', '1', '0', '3', '2', '2', '11', '0', '0', '1', '0.833333333', '0', '0', '4.5', '0', '0', '1']
package org . apache . camel . util ; public class CollectionStringBuffer { private StringBuffer buffer = new StringBuffer ( ) ; private String separator ; private boolean first = true ; public CollectionStringBuffer ( ) { this ( ", " ) ; } public CollectionStringBuffer ( String separator ) { this . separator = separator ; } @ Override public String toString ( ) { return buffer . toString ( ) ; } public void append ( Object value ) { if ( first ) { first = false ; } else { buffer . append ( separator ) ; } buffer . append ( value ) ; } public String getSeparator ( ) { return separator ; } public void setSeparator ( String separator ) { this . separator = separator ; } } 	0	['6', '1', '0', '6', '11', '0', '6', '0', '6', '0.4', '57', '1', '0', '0', '0.5', '0', '0', '8', '2', '0.8333', '0']
package org . apache . camel . component . file . strategy ; import java . io . File ; import org . apache . camel . component . file . FileEndpoint ; import org . apache . camel . component . file . FileExchange ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DeleteFileProcessStrategy extends FileProcessStrategySupport { private static final transient Log LOG = LogFactory . getLog ( DeleteFileProcessStrategy . class ) ; public DeleteFileProcessStrategy ( ) { } public DeleteFileProcessStrategy ( boolean lockFile ) { super ( lockFile ) ; } @ Override public void commit ( FileEndpoint endpoint , FileExchange exchange , File file ) throws Exception { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Deleting file: " + file ) ; } boolean deleted = file . delete ( ) ; if ( ! deleted ) { LOG . warn ( "Could not delete file: " + file ) ; } super . commit ( endpoint , exchange , file ) ; } } 	1	['4', '2', '0', '6', '16', '4', '1', '5', '3', '0.666666667', '50', '1', '0', '0.857142857', '0.466666667', '0', '0', '11.25', '1', '0.25', '1']
@ javax . xml . bind . annotation . XmlSchema ( namespace = "http://activemq.apache.org/camel/schema/spring" , elementFormDefault = javax . xml . bind . annotation . XmlNsForm . QUALIFIED ) package org . apache . camel . model . dataformat ; 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . processor . validation ; import java . util . ArrayList ; import java . util . List ; import javax . xml . transform . dom . DOMResult ; import javax . xml . validation . Schema ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import org . apache . camel . Exchange ; import org . apache . camel . ValidationException ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DefaultValidationErrorHandler implements ValidatorErrorHandler { private static final transient Log LOG = LogFactory . getLog ( DefaultValidationErrorHandler . class ) ; private List < SAXParseException > warnings = new ArrayList < SAXParseException > ( ) ; private List < SAXParseException > errors = new ArrayList < SAXParseException > ( ) ; private List < SAXParseException > fatalErrors = new ArrayList < SAXParseException > ( ) ; public void warning ( SAXParseException e ) throws SAXException { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "warning: " + e , e ) ; } warnings . add ( e ) ; } public void error ( SAXParseException e ) throws SAXException { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "error: " + e , e ) ; } errors . add ( e ) ; } public void fatalError ( SAXParseException e ) throws SAXException { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "fatalError: " + e , e ) ; } fatalErrors . add ( e ) ; } public void reset ( ) { warnings . clear ( ) ; errors . clear ( ) ; fatalErrors . clear ( ) ; } public boolean isValid ( ) { return errors . isEmpty ( ) && fatalErrors . isEmpty ( ) ; } public void handleErrors ( Exchange exchange , Schema schema , DOMResult result ) throws ValidationException { if ( ! isValid ( ) ) { throw new SchemaValidationException ( exchange , schema , fatalErrors , errors , warnings ) ; } } public void handleErrors ( Exchange exchange , Object schema ) throws ValidationException { if ( ! isValid ( ) ) { throw new SchemaValidationException ( exchange , schema , fatalErrors , errors , warnings ) ; } } } 	1	['9', '1', '0', '8', '22', '0', '2', '6', '8', '0.46875', '149', '1', '0', '0', '0.333333333', '0', '0', '15.11111111', '3', '1', '1']
package org . apache . camel . component . cxf . interceptors ; import java . util . logging . Level ; import java . util . logging . Logger ; import org . apache . cxf . binding . soap . SoapFault ; import org . apache . cxf . binding . soap . SoapMessage ; import org . apache . cxf . binding . xml . XMLFault ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . interceptor . Fault ; import org . apache . cxf . message . Message ; import org . apache . cxf . message . XMLMessage ; import org . apache . cxf . phase . AbstractPhaseInterceptor ; import org . apache . cxf . phase . Phase ; import org . apache . cxf . service . model . BindingOperationInfo ; public class FaultOutInterceptor extends AbstractPhaseInterceptor < Message > { private static final Logger LOG = LogUtils . getL7dLogger ( FaultOutInterceptor . class ) ; public FaultOutInterceptor ( ) { super ( Phase . PREPARE_SEND ) ; } @ SuppressWarnings ( "unchecked" ) public void handleMessage ( Message message ) throws Fault { checkBindingOperationInfor ( message ) ; Exception ex = message . getContent ( Exception . class ) ; if ( ex != null ) { if ( ! ( ex instanceof Fault ) ) { ex = new Fault ( ex ) ; } if ( message instanceof XMLMessage ) { if ( LOG . isLoggable ( Level . INFO ) ) { LOG . info ( "FaultOutInterceptor Creating XMLFault" ) ; } ex = XMLFault . createFault ( ( Fault ) ex ) ; } else if ( message instanceof SoapMessage ) { if ( LOG . isLoggable ( Level . INFO ) ) { LOG . info ( "FaultOutInterceptor Creating SoapFault" ) ; } SoapMessage sm = ( SoapMessage ) message ; ex = SoapFault . createFault ( ( Fault ) ex , sm . getVersion ( ) ) ; } message . setContent ( Exception . class , ex ) ; } } private void checkBindingOperationInfor ( Message message ) { BindingOperationInfo bop = message . getExchange ( ) . get ( BindingOperationInfo . class ) ; if ( bop == null ) { bop = new FakeBindingOperationInfo ( ) ; message . getExchange ( ) . put ( BindingOperationInfo . class , bop ) ; } } } 	0	['4', '0', '0', '14', '18', '4', '2', '12', '2', '0.666666667', '88', '1', '0', '0', '0.833333333', '0', '0', '20.75', '2', '0.75', '0']
package org . apache . camel . model ; import java . util . concurrent . LinkedBlockingQueue ; import java . util . concurrent . ThreadPoolExecutor ; import java . util . concurrent . TimeUnit ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . Splitter ; import org . apache . camel . processor . aggregate . AggregationStrategy ; import org . apache . camel . processor . aggregate . UseLatestAggregationStrategy ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "splitter" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class SplitterType extends ExpressionNode { @ XmlTransient private AggregationStrategy aggregationStrategy ; @ XmlAttribute ( required = false ) private Boolean parallelProcessing ; @ XmlTransient private ThreadPoolExecutor threadPoolExecutor ; public SplitterType ( ) { } public SplitterType ( Expression expression ) { super ( expression ) ; } public SplitterType ( ExpressionType expression ) { super ( expression ) ; } @ Override public String toString ( ) { return "Splitter[ " + getExpression ( ) + " -> " + getOutputs ( ) + "]" ; } @ Override public String getShortName ( ) { return "splitter" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { Processor childProcessor = routeContext . createProcessor ( this ) ; if ( aggregationStrategy == null ) { aggregationStrategy = new UseLatestAggregationStrategy ( ) ; } if ( threadPoolExecutor == null ) { threadPoolExecutor = new ThreadPoolExecutor ( 4 , 16 , 0L , TimeUnit . MILLISECONDS , new LinkedBlockingQueue ( ) ) ; } return new Splitter ( getExpression ( ) . createExpression ( routeContext ) , childProcessor , aggregationStrategy , isParallelProcessing ( ) , threadPoolExecutor ) ; } public AggregationStrategy getAggregationStrategy ( ) { return aggregationStrategy ; } public void setAggregationStrategy ( AggregationStrategy aggregationStrategy ) { this . aggregationStrategy = aggregationStrategy ; } public boolean isParallelProcessing ( ) { return parallelProcessing != null ? parallelProcessing : false ; } public void setParallelProcessing ( boolean parallelProcessing ) { this . parallelProcessing = parallelProcessing ; } public ThreadPoolExecutor getThreadPoolExecutor ( ) { return threadPoolExecutor ; } public void setThreadPoolExecutor ( ThreadPoolExecutor threadPoolExecutor ) { this . threadPoolExecutor = threadPoolExecutor ; } } 	1	['12', '4', '0', '12', '29', '52', '4', '9', '12', '0.818181818', '115', '1', '1', '0.946107784', '0.214285714', '2', '3', '8.333333333', '2', '0.8333', '3']
package org . apache . camel . component . jmx ; import javax . management . Notification ; import javax . management . NotificationListener ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; public class JMXConsumer extends DefaultConsumer implements NotificationListener { private JMXEndpoint jmxEndpoint ; public JMXConsumer ( JMXEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . jmxEndpoint = endpoint ; } public void handleNotification ( Notification notification , Object handback ) { try { getProcessor ( ) . process ( jmxEndpoint . createExchange ( notification ) ) ; } catch ( Throwable e ) { handleException ( e ) ; } } } 	0	['2', '3', '0', '6', '7', '0', '1', '6', '2', '0', '24', '1', '1', '0.956521739', '0.6', '0', '0', '10.5', '1', '0.5', '0']
package org . apache . camel . impl ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import javax . activation . DataHandler ; import org . apache . camel . Message ; public class DefaultMessage extends MessageSupport { private Map < String , Object > headers ; private Map < String , DataHandler > attachments ; @ Override public String toString ( ) { return "Message: " + getBody ( ) ; } public Object getHeader ( String name ) { return getHeaders ( ) . get ( name ) ; } public < T > T getHeader ( String name , Class < T > type ) { Object value = getHeader ( name ) ; return getExchange ( ) . getContext ( ) . getTypeConverter ( ) . convertTo ( type , value ) ; } public void setHeader ( String name , Object value ) { if ( headers == null ) { headers = createHeaders ( ) ; } headers . put ( name , value ) ; } public Object removeHeader ( String name ) { if ( headers != null ) { return headers . remove ( name ) ; } else { return null ; } } public Map < String , Object > getHeaders ( ) { if ( headers == null ) { headers = createHeaders ( ) ; } return headers ; } public void setHeaders ( Map < String , Object > headers ) { this . headers = headers ; } public DefaultMessage newInstance ( ) { return new DefaultMessage ( ) ; } protected Map < String , Object > createHeaders ( ) { HashMap < String , Object > map = new HashMap < String , Object > ( ) ; populateInitialHeaders ( map ) ; return map ; } protected void populateInitialHeaders ( Map < String , Object > map ) { } protected Map < String , DataHandler > createAttachments ( ) { HashMap < String , DataHandler > map = new HashMap < String , DataHandler > ( ) ; populateInitialAttachments ( map ) ; return map ; } protected void populateInitialAttachments ( Map < String , DataHandler > map ) { } public void addAttachment ( String id , DataHandler content ) { if ( attachments == null ) { attachments = createAttachments ( ) ; } attachments . put ( id , content ) ; } public DataHandler getAttachment ( String id ) { return getAttachments ( ) . get ( id ) ; } public Set < String > getAttachmentNames ( ) { if ( attachments == null ) { attachments = createAttachments ( ) ; } return attachments . keySet ( ) ; } public void removeAttachment ( String id ) { if ( attachments != null && attachments . containsKey ( id ) ) { attachments . remove ( id ) ; } } public Map < String , DataHandler > getAttachments ( ) { if ( attachments == null ) { attachments = createAttachments ( ) ; } return attachments ; } public void setAttachments ( Map < String , DataHandler > attachments ) { this . attachments = attachments ; } public boolean hasAttachments ( ) { return this . attachments != null && this . attachments . size ( ) > 0 ; } protected boolean hasPopulatedHeaders ( ) { return headers != null ; } } 	1	['22', '2', '13', '20', '38', '181', '15', '5', '17', '0.714285714', '196', '1', '0', '0.4', '0.272727273', '1', '2', '7.818181818', '3', '1.4545', '1']
package org . apache . camel . spring . remoting ; import org . aopalliance . intercept . MethodInterceptor ; import org . aopalliance . intercept . MethodInvocation ; import org . apache . camel . CamelContext ; import org . apache . camel . CamelContextAware ; import org . apache . camel . Endpoint ; import org . apache . camel . Producer ; import org . apache . camel . component . bean . CamelInvocationHandler ; import org . apache . camel . util . CamelContextHelper ; import org . springframework . beans . factory . DisposableBean ; import org . springframework . beans . factory . InitializingBean ; import static org . apache . camel . util . ObjectHelper . notNull ; public class SendBeforeInterceptor implements MethodInterceptor , CamelContextAware , InitializingBean , DisposableBean { private String uri ; private CamelContext camelContext ; private CamelInvocationHandler invocationHandler ; private Producer producer ; public Object invoke ( MethodInvocation invocation ) throws Throwable { invocationHandler . invoke ( invocation . getThis ( ) , invocation . getMethod ( ) , invocation . getArguments ( ) ) ; return invocation . proceed ( ) ; } public void afterPropertiesSet ( ) throws Exception { notNull ( uri , "uri" ) ; notNull ( camelContext , "camelContext" ) ; Endpoint endpoint = CamelContextHelper . getMandatoryEndpoint ( camelContext , uri ) ; producer = endpoint . createProducer ( ) ; producer . start ( ) ; invocationHandler = new CamelInvocationHandler ( endpoint , producer ) ; } public void destroy ( ) throws Exception { if ( producer != null ) { producer . stop ( ) ; } } public void setCamelContext ( CamelContext camelContext ) { this . camelContext = camelContext ; } public String getUri ( ) { return uri ; } public void setUri ( String uri ) { this . uri = uri ; } } 	0	['7', '1', '0', '11', '19', '9', '0', '11', '7', '0.791666667', '75', '1', '3', '0', '0.357142857', '0', '0', '9.142857143', '1', '0.8571', '0']
package org . apache . camel . processor . interceptor ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . converter . stream . StreamCache ; import org . apache . camel . model . InterceptorRef ; import org . apache . camel . model . InterceptorType ; import org . apache . camel . processor . Interceptor ; public class StreamCachingInterceptor extends Interceptor { public StreamCachingInterceptor ( ) { super ( ) ; setInterceptorLogic ( new Processor ( ) { public void process ( Exchange exchange ) throws Exception { Object newBody = exchange . getIn ( ) . getBody ( StreamCache . class ) ; if ( newBody != null ) { exchange . getIn ( ) . setBody ( newBody ) ; } proceed ( exchange ) ; } } ) ; } public StreamCachingInterceptor ( Processor processor ) { this ( ) ; setProcessor ( processor ) ; } @ Override public String toString ( ) { return "StreamCachingInterceptor" ; } public static void noStreamCaching ( List < InterceptorType > interceptors ) { for ( int i = 0 ; i < interceptors . size ( ) ; i ++ ) { InterceptorType interceptor = interceptors . get ( i ) ; if ( interceptor instanceof InterceptorRef && ( ( InterceptorRef ) interceptor ) . getInterceptor ( ) instanceof StreamCachingInterceptor ) { interceptors . remove ( interceptor ) ; } } } } 	1	['4', '4', '0', '9', '12', '6', '4', '6', '4', '2', '47', '0', '0', '0.928571429', '0.416666667', '0', '0', '10.75', '4', '1.25', '3']
@ javax . xml . bind . annotation . XmlSchema ( namespace = "http://activemq.apache.org/camel/schema/osgi" , elementFormDefault = javax . xml . bind . annotation . XmlNsForm . QUALIFIED ) package org . apache . camel . osgi ; 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . camel . processor ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import java . util . concurrent . ThreadPoolExecutor ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . converter . ObjectConverter ; import org . apache . camel . processor . aggregate . AggregationStrategy ; import org . apache . camel . util . CollectionHelper ; import static org . apache . camel . util . ObjectHelper . notNull ; public class Splitter extends MulticastProcessor implements Processor { public static final String SPLIT_SIZE = "org.apache.camel.splitSize" ; public static final String SPLIT_COUNTER = "org.apache.camel.splitCounter" ; private final Expression expression ; public Splitter ( Expression expression , Processor destination , AggregationStrategy aggregationStrategy ) { this ( expression , destination , aggregationStrategy , false , null ) ; } public Splitter ( Expression expression , Processor destination , AggregationStrategy aggregationStrategy , boolean parallelProcessing , ThreadPoolExecutor threadPoolExecutor ) { super ( Collections . singleton ( destination ) , aggregationStrategy , parallelProcessing , threadPoolExecutor ) ; this . expression = expression ; notNull ( expression , "expression" ) ; notNull ( destination , "destination" ) ; } @ Override public String toString ( ) { return "Splitter[on: " + expression + " to: " + getProcessors ( ) . iterator ( ) . next ( ) + " aggregate: " + getAggregationStrategy ( ) + "]" ; } @ Override protected List < ProcessorExchangePair > createProcessorExchangePairs ( Exchange exchange ) { Object value = expression . evaluate ( exchange ) ; Integer collectionSize = CollectionHelper . size ( value ) ; List < ProcessorExchangePair > result ; if ( collectionSize != null ) { result = new ArrayList < ProcessorExchangePair > ( collectionSize ) ; } else { result = new ArrayList < ProcessorExchangePair > ( ) ; } Iterator < Object > iter = ObjectConverter . iterator ( value ) ; while ( iter . hasNext ( ) ) { Object part = iter . next ( ) ; Exchange newExchange = exchange . copy ( ) ; Message in = newExchange . getIn ( ) ; in . setBody ( part ) ; result . add ( new ProcessorExchangePair ( getProcessors ( ) . iterator ( ) . next ( ) , newExchange ) ) ; } return result ; } @ Override protected void updateNewExchange ( Exchange exchange , int i , List < ProcessorExchangePair > allPairs ) { exchange . getIn ( ) . setHeader ( SPLIT_COUNTER , i ) ; exchange . getIn ( ) . setHeader ( SPLIT_SIZE , allPairs . size ( ) ) ; } } 	1	['5', '3', '0', '11', '31', '4', '1', '10', '3', '0.916666667', '125', '0.333333333', '1', '0.884615385', '0.377777778', '1', '2', '23.4', '3', '1', '1']
package org . apache . camel . processor . idempotent ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . RuntimeCamelException ; public class NoMessageIdException extends RuntimeCamelException { private final Exchange exchange ; private final Expression expression ; public NoMessageIdException ( Exchange exchange , Expression expression ) { super ( "No message ID could be found using expression: " + expression + " on message exchange: " + exchange ) ; this . exchange = exchange ; this . expression = expression ; } public Exchange getExchange ( ) { return exchange ; } public Expression getExpression ( ) { return expression ; } } 	0	['3', '5', '0', '4', '8', '0', '1', '3', '3', '0.5', '32', '1', '2', '0.894736842', '0.555555556', '0', '0', '9', '1', '0.6667', '0']
package org . apache . camel . model ; import java . util . List ; import java . util . concurrent . ThreadPoolExecutor ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Processor ; import org . apache . camel . processor . MulticastProcessor ; import org . apache . camel . processor . aggregate . AggregationStrategy ; import org . apache . camel . processor . aggregate . UseLatestAggregationStrategy ; import org . apache . camel . processor . interceptor . StreamCachingInterceptor ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "multicast" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class MulticastType extends OutputType < ProcessorType > { @ XmlAttribute ( required = false ) private Boolean parallelProcessing ; @ XmlTransient private AggregationStrategy aggregationStrategy ; @ XmlTransient private ThreadPoolExecutor threadPoolExecutor ; @ Override public String toString ( ) { return "Multicast[" + getOutputs ( ) + "]" ; } @ Override public String getShortName ( ) { return "multicast" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { return createOutputsProcessor ( routeContext ) ; } protected Processor createCompositeProcessor ( List < Processor > list ) { if ( aggregationStrategy == null ) { aggregationStrategy = new UseLatestAggregationStrategy ( ) ; } return new MulticastProcessor ( list , aggregationStrategy , isParallelProcessing ( ) , threadPoolExecutor ) ; } public AggregationStrategy getAggregationStrategy ( ) { return aggregationStrategy ; } public MulticastType setAggregationStrategy ( AggregationStrategy aggregationStrategy ) { this . aggregationStrategy = aggregationStrategy ; return this ; } public boolean isParallelProcessing ( ) { return parallelProcessing != null ? parallelProcessing : false ; } public MulticastType setParallelProcessing ( boolean parallelProcessing ) { this . parallelProcessing = parallelProcessing ; return this ; } public ThreadPoolExecutor getThreadPoolExecutor ( ) { return threadPoolExecutor ; } public MulticastType setThreadPoolExecutor ( ThreadPoolExecutor executor ) { this . threadPoolExecutor = executor ; return this ; } @ Override protected Processor wrapProcessorInInterceptors ( RouteContext routeContext , Processor target ) throws Exception { return new StreamCachingInterceptor ( target ) ; } } 	1	['12', '4', '0', '14', '24', '52', '7', '7', '10', '0.818181818', '91', '1', '1', '0.932926829', '0.226190476', '1', '5', '6.333333333', '2', '1.0833', '3']
package org . apache . camel . util ; import java . util . concurrent . CountDownLatch ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; public final class AsyncProcessorHelper { private AsyncProcessorHelper ( ) { } public static void process ( AsyncProcessor processor , Exchange exchange ) throws Exception { final CountDownLatch latch = new CountDownLatch ( 1 ) ; boolean sync = processor . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { if ( ! sync ) { latch . countDown ( ) ; } } } ) ; if ( ! sync ) { latch . await ( ) ; } } } 	0	['2', '1', '0', '12', '7', '1', '8', '4', '1', '2', '23', '0', '0', '0', '0.5', '0', '0', '10.5', '1', '0.5', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . model . config . BatchResequencerConfig ; import org . apache . camel . model . config . StreamResequencerConfig ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . Resequencer ; import org . apache . camel . processor . StreamResequencer ; import org . apache . camel . spi . RouteContext ; @ XmlRootElement ( name = "resequencer" ) public class ResequencerType extends ProcessorType < ProcessorType > { @ XmlElementRef private List < ExpressionType > expressions = new ArrayList < ExpressionType > ( ) ; @ XmlElementRef private List < ProcessorType < ? > > outputs = new ArrayList < ProcessorType < ? > > ( ) ; private BatchResequencerConfig batchConfig ; private StreamResequencerConfig streamConfig ; @ XmlTransient private List < Expression > expressionList ; public ResequencerType ( ) { this ( null ) ; } public ResequencerType ( List < Expression > expressions ) { this . expressionList = expressions ; this . batch ( ) ; } @ Override public String getShortName ( ) { return "resequencer" ; } public ResequencerType stream ( ) { return stream ( StreamResequencerConfig . getDefault ( ) ) ; } public ResequencerType batch ( ) { return batch ( BatchResequencerConfig . getDefault ( ) ) ; } public ResequencerType stream ( StreamResequencerConfig config ) { this . streamConfig = config ; this . batchConfig = null ; return this ; } public ResequencerType batch ( BatchResequencerConfig config ) { this . batchConfig = config ; this . streamConfig = null ; return this ; } public ResequencerType expression ( ExpressionType expression ) { expressions . add ( expression ) ; return this ; } @ Override public String toString ( ) { return "Resequencer[ " + getExpressions ( ) + " -> " + getOutputs ( ) + "]" ; } @ Override public String getLabel ( ) { return ExpressionType . getLabel ( getExpressions ( ) ) ; } public List < ExpressionType > getExpressions ( ) { return expressions ; } public List < ProcessorType < ? > > getOutputs ( ) { return outputs ; } public void setOutputs ( List < ProcessorType < ? > > outputs ) { this . outputs = outputs ; } public BatchResequencerConfig getBatchConfig ( ) { return batchConfig ; } public BatchResequencerConfig getBatchConfig ( BatchResequencerConfig defaultConfig ) { return batchConfig ; } public StreamResequencerConfig getStreamConfig ( ) { return streamConfig ; } @ XmlElement ( name = "batch-config" , required = false ) public void setBatchConfig ( BatchResequencerConfig batchConfig ) { batch ( batchConfig ) ; } @ XmlElement ( name = "stream-config" , required = false ) public void setStreamConfig ( StreamResequencerConfig streamConfig ) { stream ( streamConfig ) ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { if ( batchConfig != null ) { return createBatchResequencer ( routeContext , batchConfig ) ; } else { return createStreamResequencer ( routeContext , streamConfig ) ; } } @ Override public void addRoutes ( RouteContext routeContext , Collection < Route > routes ) throws Exception { if ( batchConfig != null ) { routes . add ( createBatchResequencerRoute ( routeContext ) ) ; } else { super . addRoutes ( routeContext , routes ) ; } } private Route < ? extends Exchange > createBatchResequencerRoute ( RouteContext routeContext ) throws Exception { final Resequencer resequencer = createBatchResequencer ( routeContext , batchConfig ) ; return new Route ( routeContext . getEndpoint ( ) , resequencer ) { @ Override public String toString ( ) { return "BatchResequencerRoute[" + getEndpoint ( ) + " -> " + resequencer . getProcessor ( ) + "]" ; } } ; } protected Resequencer createBatchResequencer ( RouteContext routeContext , BatchResequencerConfig config ) throws Exception { Processor processor = routeContext . createProcessor ( this ) ; Resequencer resequencer = new Resequencer ( routeContext . getEndpoint ( ) , processor , resolveExpressionList ( routeContext ) ) ; resequencer . setBatchSize ( config . getBatchSize ( ) ) ; resequencer . setBatchTimeout ( config . getBatchTimeout ( ) ) ; return resequencer ; } protected StreamResequencer createStreamResequencer ( RouteContext routeContext , StreamResequencerConfig config ) throws Exception { config . getComparator ( ) . setExpressions ( resolveExpressionList ( routeContext ) ) ; Processor processor = routeContext . createProcessor ( this ) ; StreamResequencer resequencer = new StreamResequencer ( processor , config . getComparator ( ) , config . getCapacity ( ) ) ; resequencer . setTimeout ( config . getTimeout ( ) ) ; return resequencer ; } private List < Expression > resolveExpressionList ( RouteContext routeContext ) { if ( expressionList == null ) { expressionList = new ArrayList < Expression > ( ) ; for ( ExpressionType expression : expressions ) { expressionList . add ( expression . createExpression ( routeContext ) ) ; } } if ( expressionList . isEmpty ( ) ) { throw new IllegalArgumentException ( "No expressions configured for: " + this ) ; } return expressionList ; } } 	1	['24', '3', '0', '18', '56', '210', '5', '15', '20', '0.713043478', '280', '1', '2', '0.872093023', '0.244047619', '1', '2', '10.45833333', '4', '1.0417', '3']
package org . apache . camel . impl . converter ; public class CachingInjector < T > { private final TypeConverterRegistry repository ; private final Class < T > type ; private T instance ; public CachingInjector ( TypeConverterRegistry repository , Class < T > type ) { this . repository = repository ; this . type = type ; } public synchronized T newInstance ( ) { if ( instance == null ) { instance = createInstance ( type ) ; } return instance ; } protected T createInstance ( Class < T > t ) { return repository . getInjector ( ) . newInstance ( t ) ; } } 	0	['3', '1', '0', '4', '6', '0', '2', '2', '2', '0.5', '33', '1', '1', '0', '0.666666667', '0', '0', '9', '2', '1', '0']
package org . apache . camel . impl ; import java . util . HashMap ; import java . util . Map ; import org . apache . camel . AsyncCallback ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Message ; import org . apache . camel . NoSuchEndpointException ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . ProducerTemplate ; import org . apache . camel . util . ObjectHelper ; public class DefaultProducerTemplate < E extends Exchange > extends ServiceSupport implements ProducerTemplate < E > { private CamelContext context ; private final ProducerCache < E > producerCache = new ProducerCache < E > ( ) ; private boolean useEndpointCache = true ; private final Map < String , Endpoint < E > > endpointCache = new HashMap < String , Endpoint < E > > ( ) ; private Endpoint < E > defaultEndpoint ; public DefaultProducerTemplate ( CamelContext context ) { this . context = context ; } public DefaultProducerTemplate ( CamelContext context , Endpoint defaultEndpoint ) { this ( context ) ; this . defaultEndpoint = defaultEndpoint ; } public E send ( String endpointUri , E exchange ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; return send ( endpoint , exchange ) ; } public E send ( String endpointUri , Processor processor ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; return send ( endpoint , processor ) ; } public E send ( String endpointUri , Processor processor , AsyncCallback callback ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; return send ( endpoint , processor , callback ) ; } public E send ( String endpointUri , ExchangePattern pattern , Processor processor ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; return send ( endpoint , pattern , processor ) ; } public E send ( Endpoint < E > endpoint , E exchange ) { E convertedExchange = exchange ; producerCache . send ( endpoint , convertedExchange ) ; return convertedExchange ; } public E send ( Endpoint < E > endpoint , Processor processor ) { return producerCache . send ( endpoint , processor ) ; } public E send ( Endpoint < E > endpoint , Processor processor , AsyncCallback callback ) { return producerCache . send ( endpoint , processor , callback ) ; } public E send ( Endpoint < E > endpoint , ExchangePattern pattern , Processor processor ) { return producerCache . send ( endpoint , pattern , processor ) ; } public Object sendBody ( Endpoint < E > endpoint , ExchangePattern pattern , Object body ) { E result = send ( endpoint , pattern , createSetBodyProcessor ( body ) ) ; return extractResultBody ( result , pattern ) ; } public Object sendBody ( Endpoint < E > endpoint , Object body ) { E result = send ( endpoint , createSetBodyProcessor ( body ) ) ; return extractResultBody ( result ) ; } public Object sendBody ( String endpointUri , Object body ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; return sendBody ( endpoint , body ) ; } public Object sendBody ( String endpointUri , ExchangePattern pattern , Object body ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; return sendBody ( endpoint , pattern , body ) ; } public Object sendBodyAndHeader ( String endpointUri , final Object body , final String header , final Object headerValue ) { return sendBodyAndHeader ( resolveMandatoryEndpoint ( endpointUri ) , body , header , headerValue ) ; } public Object sendBodyAndHeader ( Endpoint endpoint , final Object body , final String header , final Object headerValue ) { E result = send ( endpoint , createBodyAndHeaderProcessor ( body , header , headerValue ) ) ; return extractResultBody ( result ) ; } public Object sendBodyAndHeader ( Endpoint endpoint , ExchangePattern pattern , final Object body , final String header , final Object headerValue ) { E result = send ( endpoint , pattern , createBodyAndHeaderProcessor ( body , header , headerValue ) ) ; return extractResultBody ( result , pattern ) ; } public Object sendBodyAndHeader ( String endpoint , ExchangePattern pattern , final Object body , final String header , final Object headerValue ) { E result = send ( endpoint , pattern , createBodyAndHeaderProcessor ( body , header , headerValue ) ) ; return extractResultBody ( result , pattern ) ; } public Object sendBodyAndHeaders ( String endpointUri , final Object body , final Map < String , Object > headers ) { return sendBodyAndHeaders ( resolveMandatoryEndpoint ( endpointUri ) , body , headers ) ; } public Object sendBodyAndHeaders ( Endpoint endpoint , final Object body , final Map < String , Object > headers ) { E result = send ( endpoint , new Processor ( ) { public void process ( Exchange exchange ) { Message in = exchange . getIn ( ) ; for ( Map . Entry < String , Object > header : headers . entrySet ( ) ) { in . setHeader ( header . getKey ( ) , header . getValue ( ) ) ; } in . setBody ( body ) ; } } ) ; return extractResultBody ( result ) ; } public E request ( Endpoint < E > endpoint , Processor processor ) { return send ( endpoint , ExchangePattern . InOut , processor ) ; } public Object requestBody ( Endpoint < E > endpoint , Object body ) { return sendBody ( endpoint , ExchangePattern . InOut , body ) ; } public Object requestBodyAndHeader ( Endpoint < E > endpoint , Object body , String header , Object headerValue ) { return sendBodyAndHeader ( endpoint , ExchangePattern . InOut , body , header , headerValue ) ; } public E request ( String endpoint , Processor processor ) { return send ( endpoint , ExchangePattern . InOut , processor ) ; } public Object requestBody ( String endpoint , Object body ) { return sendBody ( endpoint , ExchangePattern . InOut , body ) ; } public Object requestBodyAndHeader ( String endpoint , Object body , String header , Object headerValue ) { return sendBodyAndHeader ( endpoint , ExchangePattern . InOut , body , header , headerValue ) ; } public Object sendBody ( Object body ) { return sendBody ( getMandatoryDefaultEndpoint ( ) , body ) ; } public E send ( E exchange ) { return send ( getMandatoryDefaultEndpoint ( ) , exchange ) ; } public E send ( Processor processor ) { return send ( getMandatoryDefaultEndpoint ( ) , processor ) ; } public Object sendBodyAndHeader ( Object body , String header , Object headerValue ) { return sendBodyAndHeader ( getMandatoryDefaultEndpoint ( ) , body , header , headerValue ) ; } public Object sendBodyAndHeaders ( Object body , Map < String , Object > headers ) { return sendBodyAndHeaders ( getMandatoryDefaultEndpoint ( ) , body , headers ) ; } public Producer < E > getProducer ( Endpoint < E > endpoint ) { return producerCache . getProducer ( endpoint ) ; } public CamelContext getContext ( ) { return context ; } public Endpoint < E > getDefaultEndpoint ( ) { return defaultEndpoint ; } public void setDefaultEndpoint ( Endpoint < E > defaultEndpoint ) { this . defaultEndpoint = defaultEndpoint ; } public void setDefaultEndpointUri ( String endpointUri ) { setDefaultEndpoint ( getContext ( ) . getEndpoint ( endpointUri ) ) ; } public boolean isUseEndpointCache ( ) { return useEndpointCache ; } public void setUseEndpointCache ( boolean useEndpointCache ) { this . useEndpointCache = useEndpointCache ; } public < T extends Endpoint < ? > > T getResolvedEndpoint ( String endpointUri , Class < T > expectedClass ) { Endpoint < ? > e = null ; synchronized ( endpointCache ) { e = endpointCache . get ( endpointUri ) ; } if ( e != null && expectedClass . isAssignableFrom ( e . getClass ( ) ) ) { return expectedClass . asSubclass ( expectedClass ) . cast ( e ) ; } return null ; } protected Processor createBodyAndHeaderProcessor ( final Object body , final String header , final Object headerValue ) { return new Processor ( ) { public void process ( Exchange exchange ) { Message in = exchange . getIn ( ) ; in . setHeader ( header , headerValue ) ; in . setBody ( body ) ; } } ; } protected Processor createSetBodyProcessor ( final Object body ) { return new Processor ( ) { public void process ( Exchange exchange ) { Message in = exchange . getIn ( ) ; in . setBody ( body ) ; } } ; } protected Endpoint resolveMandatoryEndpoint ( String endpointUri ) { Endpoint endpoint = null ; if ( isUseEndpointCache ( ) ) { synchronized ( endpointCache ) { endpoint = endpointCache . get ( endpointUri ) ; if ( endpoint == null ) { endpoint = context . getEndpoint ( endpointUri ) ; if ( endpoint != null ) { endpointCache . put ( endpointUri , endpoint ) ; } } } } else { endpoint = context . getEndpoint ( endpointUri ) ; } if ( endpoint == null ) { throw new NoSuchEndpointException ( endpointUri ) ; } return endpoint ; } protected Endpoint < E > getMandatoryDefaultEndpoint ( ) { Endpoint < E > answer = getDefaultEndpoint ( ) ; ObjectHelper . notNull ( answer , "defaultEndpoint" ) ; return answer ; } protected void doStart ( ) throws Exception { producerCache . start ( ) ; } protected void doStop ( ) throws Exception { producerCache . stop ( ) ; endpointCache . clear ( ) ; } protected Object extractResultBody ( E result ) { return extractResultBody ( result , null ) ; } protected Object extractResultBody ( E result , ExchangePattern pattern ) { Object answer = null ; if ( result != null ) { boolean notOut = pattern != null && ! pattern . isOutCapable ( ) ; boolean hasOut = result . getOut ( false ) != null ; if ( hasOut && ! notOut ) { answer = result . getOut ( ) . getBody ( ) ; } else { answer = result . getIn ( ) . getBody ( ) ; } } return answer ; } } 	1	['47', '2', '1', '20', '75', '999', '7', '16', '39', '0.691304348', '529', '1', '3', '0.224137931', '0.232269504', '1', '1', '10.14893617', '7', '1.2128', '4']
package org . apache . camel . component . cxf . transport ; import java . io . IOException ; import java . util . Collection ; import java . util . HashSet ; import java . util . Set ; import javax . annotation . PostConstruct ; import javax . annotation . Resource ; import org . apache . camel . CamelContext ; import org . apache . cxf . Bus ; import org . apache . cxf . service . model . EndpointInfo ; import org . apache . cxf . transport . AbstractTransportFactory ; import org . apache . cxf . transport . Conduit ; import org . apache . cxf . transport . ConduitInitiator ; import org . apache . cxf . transport . ConduitInitiatorManager ; import org . apache . cxf . transport . Destination ; import org . apache . cxf . transport . DestinationFactory ; import org . apache . cxf . transport . DestinationFactoryManager ; import org . apache . cxf . ws . addressing . EndpointReferenceType ; public class CamelTransportFactory extends AbstractTransportFactory implements ConduitInitiator , DestinationFactory { public static final String TRANSPORT_ID = "http://cxf.apache.org/transports/camel" ; private static final Set < String > URI_PREFIXES = new HashSet < String > ( ) ; private Collection < String > activationNamespaces ; static { URI_PREFIXES . add ( "camel://" ) ; } private Bus bus ; private CamelContext camelContext ; @ Resource ( name = "bus" ) public void setBus ( Bus b ) { bus = b ; } public Bus getBus ( ) { return bus ; } @ Resource public void setActivationNamespaces ( Collection < String > ans ) { activationNamespaces = ans ; } public CamelContext getCamelContext ( ) { return camelContext ; } @ Resource ( name = "camelContext" ) public void setCamelContext ( CamelContext camelContext ) { this . camelContext = camelContext ; } public Conduit getConduit ( EndpointInfo targetInfo ) throws IOException { return getConduit ( targetInfo , null ) ; } public Conduit getConduit ( EndpointInfo endpointInfo , EndpointReferenceType target ) throws IOException { return new CamelConduit ( camelContext , bus , endpointInfo , target ) ; } public Destination getDestination ( EndpointInfo endpointInfo ) throws IOException { return new CamelDestination ( camelContext , bus , this , endpointInfo ) ; } public Set < String > getUriPrefixes ( ) { return URI_PREFIXES ; } @ PostConstruct void registerWithBindingManager ( ) { if ( null == bus ) { return ; } ConduitInitiatorManager cim = bus . getExtension ( ConduitInitiatorManager . class ) ; if ( null != cim && null != activationNamespaces ) { for ( String ns : activationNamespaces ) { cim . registerConduitInitiator ( ns , this ) ; } } DestinationFactoryManager dfm = bus . getExtension ( DestinationFactoryManager . class ) ; if ( null != dfm && null != activationNamespaces ) { for ( String ns : activationNamespaces ) { dfm . registerDestinationFactory ( ns , this ) ; } } } } 	0	['12', '0', '0', '13', '23', '32', '0', '13', '10', '0.818181818', '138', '0.8', '1', '0', '0.272727273', '0', '0', '10.08333333', '8', '1.4167', '0']
package org . apache . camel . component . mock ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . builder . ExpressionClause ; import org . apache . camel . builder . ValueBuilder ; import static org . apache . camel . builder . ExpressionBuilder . bodyExpression ; import static org . apache . camel . builder . ExpressionBuilder . headerExpression ; public abstract class AssertionClause implements Runnable { private List < Predicate < Exchange > > predicates = new ArrayList < Predicate < Exchange > > ( ) ; public AssertionClause predicate ( Predicate < Exchange > predicate ) { addPredicate ( predicate ) ; return this ; } public ExpressionClause < AssertionClause > predicate ( ) { ExpressionClause < AssertionClause > clause = new ExpressionClause < AssertionClause > ( this ) ; addPredicate ( clause ) ; return clause ; } public ValueBuilder < Exchange > header ( String name ) { Expression < Exchange > expression = headerExpression ( name ) ; return new PredicateValueBuilder ( expression ) ; } public PredicateValueBuilder body ( ) { Expression < Exchange > expression = bodyExpression ( ) ; return new PredicateValueBuilder ( expression ) ; } public < T > PredicateValueBuilder bodyAs ( Class < T > type ) { Expression < Exchange > expression = bodyExpression ( type ) ; return new PredicateValueBuilder ( expression ) ; } public PredicateValueBuilder outBody ( ) { Expression < Exchange > expression = bodyExpression ( ) ; return new PredicateValueBuilder ( expression ) ; } public < T > PredicateValueBuilder outBody ( Class < T > type ) { Expression < Exchange > expression = bodyExpression ( type ) ; return new PredicateValueBuilder ( expression ) ; } protected void applyAssertionOn ( MockEndpoint endpoint , int index , Exchange exchange ) { for ( Predicate < Exchange > predicate : predicates ) { predicate . assertMatches ( endpoint . getEndpointUri ( ) + " " , exchange ) ; } } protected void addPredicate ( Predicate < Exchange > predicate ) { predicates . add ( predicate ) ; } public class PredicateValueBuilder extends ValueBuilder < Exchange > { public PredicateValueBuilder ( Expression < Exchange > expression ) { super ( expression ) ; } protected Predicate < Exchange > onNewPredicate ( Predicate < Exchange > predicate ) { addPredicate ( predicate ) ; return predicate ; } } } 	1	['10', '1', '2', '10', '26', '39', '4', '8', '8', '0.555555556', '108', '1', '0', '0', '0.257142857', '0', '0', '9.7', '2', '1', '1']
package org . apache . camel . component . cxf . util ; import java . util . logging . Logger ; import javax . xml . stream . XMLStreamException ; import javax . xml . transform . Source ; import javax . xml . transform . dom . DOMSource ; import org . w3c . dom . Document ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . interceptor . AbstractInDatabindingInterceptor ; import org . apache . cxf . interceptor . Fault ; import org . apache . cxf . message . Message ; import org . apache . cxf . phase . Phase ; import org . apache . cxf . staxutils . DepthXMLStreamReader ; import org . apache . cxf . staxutils . StaxUtils ; public class DataInInterceptor extends AbstractInDatabindingInterceptor { private static final Logger LOG = LogUtils . getL7dLogger ( DataInInterceptor . class ) ; public DataInInterceptor ( ) { super ( Phase . UNMARSHAL ) ; } public void handleMessage ( Message message ) throws Fault { DepthXMLStreamReader xmlReader = getXMLStreamReader ( message ) ; try { Document doc = StaxUtils . read ( xmlReader ) ; message . setContent ( Source . class , new DOMSource ( doc ) ) ; } catch ( XMLStreamException e ) { throw new Fault ( new org . apache . cxf . common . i18n . Message ( "XMLSTREAM_EXCEPTION" , LOG ) , e ) ; } } } 	0	['3', '0', '0', '8', '11', '1', '1', '7', '2', '0.5', '41', '1', '0', '0', '0.75', '0', '0', '12.33333333', '1', '0.3333', '0']
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . Predicate ; import org . apache . camel . builder . ErrorHandlerBuilder ; import org . apache . camel . processor . DelegateProcessor ; @ XmlRootElement ( name = "routes" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class RoutesType extends OptionalIdentifiedType < RoutesType > implements RouteContainer { @ XmlAttribute private Boolean inheritErrorHandlerFlag ; @ XmlElementRef private List < RouteType > routes = new ArrayList < RouteType > ( ) ; @ XmlElementRef private List < ServiceActivationType > activations = new ArrayList < ServiceActivationType > ( ) ; @ XmlTransient private List < InterceptorType > interceptors = new ArrayList < InterceptorType > ( ) ; @ XmlTransient private List < InterceptType > intercepts = new ArrayList < InterceptType > ( ) ; @ XmlTransient private List < ExceptionType > exceptions = new ArrayList < ExceptionType > ( ) ; @ XmlTransient private CamelContext camelContext ; @ XmlTransient private ErrorHandlerBuilder errorHandlerBuilder ; @ Override public String toString ( ) { return "Routes: " + routes ; } public List < RouteType > getRoutes ( ) { return routes ; } public void setRoutes ( List < RouteType > routes ) { this . routes = routes ; } public List < InterceptorType > getInterceptors ( ) { return interceptors ; } public void setInterceptors ( List < InterceptorType > interceptors ) { this . interceptors = interceptors ; } public List < InterceptType > getIntercepts ( ) { return intercepts ; } public void setIntercepts ( List < InterceptType > intercepts ) { this . intercepts = intercepts ; } public List < ExceptionType > getExceptions ( ) { return exceptions ; } public void setExceptions ( List < ExceptionType > exceptions ) { this . exceptions = exceptions ; } public CamelContext getCamelContext ( ) { return camelContext ; } public void setCamelContext ( CamelContext camelContext ) { this . camelContext = camelContext ; } public boolean isInheritErrorHandler ( ) { return ProcessorType . isInheritErrorHandler ( getInheritErrorHandlerFlag ( ) ) ; } public Boolean getInheritErrorHandlerFlag ( ) { return inheritErrorHandlerFlag ; } public void setInheritErrorHandlerFlag ( Boolean inheritErrorHandlerFlag ) { this . inheritErrorHandlerFlag = inheritErrorHandlerFlag ; } public ErrorHandlerBuilder getErrorHandlerBuilder ( ) { return errorHandlerBuilder ; } public void setErrorHandlerBuilder ( ErrorHandlerBuilder errorHandlerBuilder ) { this . errorHandlerBuilder = errorHandlerBuilder ; } public RouteType route ( ) { RouteType route = createRoute ( ) ; return route ( route ) ; } public RouteType from ( String uri ) { RouteType route = createRoute ( ) ; route . from ( uri ) ; return route ( route ) ; } public RouteType from ( Endpoint endpoint ) { RouteType route = createRoute ( ) ; route . from ( endpoint ) ; return route ( route ) ; } public RouteType route ( RouteType route ) { route . setCamelContext ( getCamelContext ( ) ) ; route . setInheritErrorHandlerFlag ( getInheritErrorHandlerFlag ( ) ) ; List < InterceptorType > list = getInterceptors ( ) ; for ( InterceptorType interceptorType : list ) { route . addInterceptor ( interceptorType ) ; } List < InterceptType > intercepts = getIntercepts ( ) ; for ( InterceptType intercept : intercepts ) { InterceptType proxy = intercept . createProxy ( ) ; route . addOutput ( proxy ) ; route . pushBlock ( proxy . getProceed ( ) ) ; } route . getOutputs ( ) . addAll ( getExceptions ( ) ) ; getRoutes ( ) . add ( route ) ; return route ; } public RoutesType intercept ( DelegateProcessor interceptor ) { getInterceptors ( ) . add ( new InterceptorRef ( interceptor ) ) ; return this ; } public InterceptType intercept ( ) { InterceptType answer = new InterceptType ( ) ; getIntercepts ( ) . add ( answer ) ; return answer ; } public ChoiceType intercept ( Predicate predicate ) { InterceptType answer = new InterceptType ( ) ; getIntercepts ( ) . add ( answer ) ; return answer . when ( predicate ) ; } public ExceptionType exception ( Class exceptionType ) { ExceptionType answer = new ExceptionType ( exceptionType ) ; getExceptions ( ) . add ( answer ) ; return answer ; } protected RouteType createRoute ( ) { RouteType route = new RouteType ( ) ; ErrorHandlerBuilder handler = getErrorHandlerBuilder ( ) ; if ( isInheritErrorHandler ( ) && handler != null ) { route . setErrorHandlerBuilderIfNull ( handler ) ; } return route ; } } 	1	['26', '2', '0', '17', '54', '289', '1', '16', '25', '0.875', '279', '1', '2', '0.305555556', '0.136363636', '0', '0', '9.423076923', '3', '1.1154', '2']
package org . apache . camel . component . cxf . util ; import java . lang . annotation . Annotation ; import java . net . URI ; import java . net . URL ; import java . util . logging . Logger ; import javax . jws . WebService ; import javax . xml . namespace . QName ; import javax . xml . ws . WebServiceProvider ; import org . apache . camel . CamelException ; import org . apache . camel . component . cxf . CxfConstants ; import org . apache . camel . component . cxf . CxfEndpoint ; import org . apache . camel . component . cxf . DataFormat ; import org . apache . camel . component . cxf . spring . CxfEndpointBean ; import org . apache . cxf . Bus ; import org . apache . cxf . common . classloader . ClassLoaderUtils ; import org . apache . cxf . common . i18n . Message ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . frontend . ClientFactoryBean ; import org . apache . cxf . frontend . ServerFactoryBean ; import org . apache . cxf . jaxws . JaxWsClientFactoryBean ; import org . apache . cxf . jaxws . JaxWsServerFactoryBean ; import org . apache . cxf . jaxws . support . JaxWsServiceFactoryBean ; import org . apache . cxf . service . Service ; import org . apache . cxf . service . factory . AbstractServiceFactoryBean ; import org . apache . cxf . service . factory . ReflectionServiceFactoryBean ; import org . apache . cxf . service . model . EndpointInfo ; import org . apache . cxf . wsdl11 . WSDLServiceFactory ; public final class CxfEndpointUtils { public static final String PROP_NAME_PORT = "port" ; public static final String PROP_NAME_SERVICE = "service" ; public static final String PROP_NAME_SERVICECLASS = "serviceClass" ; public static final String PROP_NAME_DATAFORMAT = "dataFormat" ; public static final String DATAFORMAT_POJO = "pojo" ; public static final String DATAFORMAT_MESSAGE = "message" ; public static final String DATAFORMAT_PAYLOAD = "payload" ; private static final Logger LOG = LogUtils . getL7dLogger ( CxfEndpointUtils . class ) ; private CxfEndpointUtils ( ) { } static QName getQName ( final String name ) { QName qName = null ; if ( name != null ) { try { qName = QName . valueOf ( name ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } return qName ; } public static QName getPortName ( final CxfEndpoint endpoint ) { return getQName ( endpoint . getPortName ( ) ) ; } public static QName getServiceName ( final CxfEndpoint endpoint ) { return getQName ( endpoint . getServiceName ( ) ) ; } public static EndpointInfo getEndpointInfo ( final Service service , final CxfEndpoint endpoint ) { EndpointInfo endpointInfo = null ; final java . util . Collection < EndpointInfo > endpoints = service . getServiceInfos ( ) . get ( 0 ) . getEndpoints ( ) ; if ( endpoints . size ( ) == 1 ) { endpointInfo = endpoints . iterator ( ) . next ( ) ; } else { final String port = endpoint . getPortName ( ) ; if ( port != null ) { final QName endpointName = QName . valueOf ( port ) ; endpointInfo = service . getServiceInfos ( ) . get ( 0 ) . getEndpoint ( endpointName ) ; } } return endpointInfo ; } public static Class getSEIClass ( String className ) throws ClassNotFoundException { if ( className == null ) { return null ; } else { return ClassLoaderUtils . loadClass ( className , CxfEndpointUtils . class ) ; } } public static boolean hasWebServiceAnnotation ( Class < ? > cls ) { return hasAnnotation ( cls , WebService . class ) || hasAnnotation ( cls , WebServiceProvider . class ) ; } public static boolean hasAnnotation ( Class < ? > cls , Class < ? extends Annotation > annotation ) { if ( cls == null || cls == Object . class ) { return false ; } if ( null != cls . getAnnotation ( annotation ) ) { return true ; } for ( Class < ? > interfaceClass : cls . getInterfaces ( ) ) { if ( null != interfaceClass . getAnnotation ( annotation ) ) { return true ; } } return hasAnnotation ( cls . getSuperclass ( ) , annotation ) ; } public static ServerFactoryBean getServerFactoryBean ( Class < ? > cls ) throws CamelException { ServerFactoryBean serverFactory = null ; try { if ( cls == null ) { serverFactory = new ServerFactoryBean ( ) ; serverFactory . setServiceFactory ( new WSDLSoapServiceFactoryBean ( ) ) ; } else { boolean isJSR181SEnabled = CxfEndpointUtils . hasWebServiceAnnotation ( cls ) ; serverFactory = isJSR181SEnabled ? new JaxWsServerFactoryBean ( ) : new ServerFactoryBean ( ) ; } return serverFactory ; } catch ( Exception e ) { throw new CamelException ( e ) ; } } public static ClientFactoryBean getClientFactoryBean ( Class < ? > cls ) throws CamelException { ClientFactoryBean clientFactory = null ; try { if ( cls == null ) { clientFactory = new ClientFactoryBean ( ) ; clientFactory . setServiceFactory ( new WSDLSoapServiceFactoryBean ( ) ) ; } else { boolean isJSR181SEnabled = CxfEndpointUtils . hasWebServiceAnnotation ( cls ) ; clientFactory = isJSR181SEnabled ? new JaxWsClientFactoryBean ( ) : new ClientFactoryBean ( ) ; } return clientFactory ; } catch ( Exception e ) { throw new CamelException ( e ) ; } } public static void checkEndpiontIntegration ( CxfEndpoint endpoint , Bus bus ) throws CamelException { String wsdlLocation = endpoint . getWsdlURL ( ) ; QName serviceQName = CxfEndpointUtils . getQName ( endpoint . getServiceName ( ) ) ; String serviceClassName = endpoint . getServiceClass ( ) ; DataFormat dataFormat = CxfEndpointUtils . getDataFormat ( endpoint ) ; URL wsdlUrl = null ; if ( wsdlLocation != null ) { try { wsdlUrl = UriUtils . getWsdlUrl ( new URI ( wsdlLocation ) ) ; } catch ( Exception e ) { throw new CamelException ( e ) ; } } if ( serviceQName == null ) { throw new CamelException ( new Message ( "SVC_QNAME_NOT_FOUND_X" , LOG , endpoint . getServiceName ( ) ) . toString ( ) ) ; } if ( serviceClassName == null && dataFormat == DataFormat . POJO ) { throw new CamelException ( new Message ( "SVC_CLASS_PROP_IS_REQUIRED_X" , LOG ) . toString ( ) ) ; } AbstractServiceFactoryBean serviceFactory = null ; try { if ( serviceClassName != null ) { Class < ? > cls = ClassLoaderUtils . loadClass ( serviceClassName , CxfEndpointUtils . class ) ; boolean isJSR181SEnabled = CxfEndpointUtils . hasWebServiceAnnotation ( cls ) ; serviceFactory = isJSR181SEnabled ? new JaxWsServiceFactoryBean ( ) : new ReflectionServiceFactoryBean ( ) ; serviceFactory . setBus ( bus ) ; if ( wsdlUrl != null ) { ( ( ReflectionServiceFactoryBean ) serviceFactory ) . setWsdlURL ( wsdlUrl ) ; } if ( serviceQName != null ) { ( ( ReflectionServiceFactoryBean ) serviceFactory ) . setServiceName ( serviceQName ) ; } ( ( ReflectionServiceFactoryBean ) serviceFactory ) . setServiceClass ( cls ) ; } else { if ( wsdlUrl == null ) { throw new CamelException ( new Message ( "SVC_WSDL_URL_IS_NULL_X" , LOG , wsdlLocation ) . toString ( ) ) ; } serviceFactory = new WSDLServiceFactory ( bus , wsdlUrl , serviceQName ) ; } } catch ( ClassNotFoundException cnfe ) { throw new CamelException ( new Message ( "CLASS_X_NOT_FOUND " , LOG , serviceClassName ) . toString ( ) , cnfe ) ; } catch ( Exception e ) { throw new CamelException ( e ) ; } } public static boolean getSetDefaultBus ( CxfEndpoint endpoint ) { Boolean isSetDefaultBus = null ; CxfEndpointBean cxfEndpointBean = endpoint . getCxfEndpointBean ( ) ; if ( cxfEndpointBean != null && cxfEndpointBean . getProperties ( ) != null ) { String value = ( String ) cxfEndpointBean . getProperties ( ) . get ( CxfConstants . SET_DEFAULT_BUS ) ; isSetDefaultBus = Boolean . valueOf ( value ) ; } if ( isSetDefaultBus != null && endpoint . isSetDefaultBus ( ) == null ) { return isSetDefaultBus . booleanValue ( ) ; } else if ( endpoint . isSetDefaultBus ( ) != null ) { return endpoint . isSetDefaultBus ( ) . booleanValue ( ) ; } else { return false ; } } public static DataFormat getDataFormat ( CxfEndpoint endpoint ) throws CamelException { String dataFormatString = endpoint . getDataFormat ( ) ; if ( dataFormatString == null ) { CxfEndpointBean cxfEndpointBean = endpoint . getCxfEndpointBean ( ) ; if ( cxfEndpointBean != null && cxfEndpointBean . getProperties ( ) != null ) { dataFormatString = ( String ) cxfEndpointBean . getProperties ( ) . get ( CxfConstants . DATA_FORMAT ) ; } } if ( dataFormatString == null ) { return DataFormat . POJO ; } DataFormat retval = DataFormat . asEnum ( dataFormatString ) ; if ( retval == DataFormat . UNKNOWN ) { throw new CamelException ( new Message ( "INVALID_MESSAGE_FORMAT_XXXX" , LOG , dataFormatString ) . toString ( ) ) ; } return retval ; } } 	0	['14', '1', '0', '25', '62', '85', '4', '21', '11', '1.048076923', '461', '0.125', '0', '0', '0.192307692', '0', '0', '31.35714286', '6', '1.9286', '0']
package org . apache . camel . builder ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . model . ExceptionType ; import org . apache . camel . processor . ErrorHandlerSupport ; public abstract class ErrorHandlerBuilderSupport implements ErrorHandlerBuilder { private List < ExceptionType > exceptions = new ArrayList < ExceptionType > ( ) ; public void addErrorHandlers ( ExceptionType exception ) { exceptions . add ( exception ) ; } protected void configure ( ErrorHandlerSupport handler ) { for ( ExceptionType exception : exceptions ) { handler . addExceptionPolicy ( exception ) ; } } public List < ExceptionType > getExceptions ( ) { return exceptions ; } } 	1	['4', '1', '5', '8', '11', '0', '5', '3', '3', '0', '38', '1', '0', '0', '0.5', '0', '0', '8.25', '2', '1', '2']
package org . apache . camel . component . event ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; public class EventConsumer extends DefaultConsumer < Exchange > { private EventEndpoint endpoint ; public EventConsumer ( EventEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; endpoint . consumerStarted ( this ) ; } @ Override protected void doStop ( ) throws Exception { endpoint . consumerStopped ( this ) ; super . doStop ( ) ; } } 	0	['3', '3', '0', '4', '8', '0', '1', '4', '1', '0', '26', '1', '1', '0.916666667', '0.555555556', '1', '1', '7.333333333', '1', '0.6667', '0']
package org . apache . camel . component . file . strategy ; public class NoOpFileProcessStrategy extends FileProcessStrategySupport { public NoOpFileProcessStrategy ( ) { super ( true ) ; } public NoOpFileProcessStrategy ( boolean isLock ) { super ( isLock ) ; } } 	1	['2', '2', '0', '2', '3', '1', '1', '1', '2', '2', '10', '0', '0', '1', '0.75', '0', '0', '4', '0', '0', '1']
package org . apache . camel . component . validator . jing ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . component . ResourceBasedComponent ; import org . apache . camel . impl . ProcessorEndpoint ; import org . springframework . core . io . Resource ; public class JingComponent extends ResourceBasedComponent { protected Endpoint < Exchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { JingValidator validator = new JingValidator ( ) ; Resource resource = resolveMandatoryResource ( remaining ) ; validator . setSchemaResource ( resource ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( this + " using schema resource: " + resource ) ; } configureValidator ( validator , uri , remaining , parameters ) ; return new ProcessorEndpoint ( uri , this , validator ) ; } protected void configureValidator ( JingValidator validator , String uri , String remaining , Map parameters ) throws Exception { setProperties ( validator , parameters ) ; } } 	0	['3', '4', '1', '9', '15', '3', '1', '8', '1', '2', '52', '0', '0', '0.948717949', '0.666666667', '2', '2', '16.33333333', '1', '0.6667', '0']
package org . apache . camel . builder ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . atomic . AtomicBoolean ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . Predicate ; import org . apache . camel . Route ; import org . apache . camel . Routes ; import org . apache . camel . impl . DefaultCamelContext ; import org . apache . camel . model . ChoiceType ; import org . apache . camel . model . ExceptionType ; import org . apache . camel . model . InterceptType ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . model . RouteType ; import org . apache . camel . model . RoutesType ; import org . apache . camel . processor . DelegateProcessor ; import org . apache . camel . processor . interceptor . StreamCachingInterceptor ; public abstract class RouteBuilder extends BuilderSupport implements Routes { private AtomicBoolean initialized = new AtomicBoolean ( false ) ; private RoutesType routeCollection = new RoutesType ( ) ; private List < Route > routes = new ArrayList < Route > ( ) ; public RouteBuilder ( ) { this ( null ) ; } public RouteBuilder ( CamelContext context ) { super ( context ) ; } @ Override public String toString ( ) { return routeCollection . toString ( ) ; } public abstract void configure ( ) throws Exception ; public RouteType from ( String uri ) { RouteType answer = routeCollection . from ( uri ) ; configureRoute ( answer ) ; return answer ; } public RouteType from ( Endpoint endpoint ) { RouteType answer = routeCollection . from ( endpoint ) ; configureRoute ( answer ) ; return answer ; } public RouteBuilder errorHandler ( ErrorHandlerBuilder errorHandlerBuilder ) { setErrorHandlerBuilder ( errorHandlerBuilder ) ; return this ; } public RouteBuilder inheritErrorHandler ( boolean value ) { routeCollection . setInheritErrorHandlerFlag ( value ) ; return this ; } public RouteBuilder intercept ( DelegateProcessor interceptor ) { routeCollection . intercept ( interceptor ) ; return this ; } public InterceptType intercept ( ) { return routeCollection . intercept ( ) ; } public ChoiceType intercept ( Predicate predicate ) { return routeCollection . intercept ( predicate ) ; } public ExceptionType exception ( Class exceptionType ) { return routeCollection . exception ( exceptionType ) ; } public CamelContext getContext ( ) { CamelContext context = super . getContext ( ) ; if ( context == null ) { context = createContainer ( ) ; setContext ( context ) ; } return context ; } public List < Route > getRouteList ( ) throws Exception { checkInitialized ( ) ; return routes ; } @ Override public void setInheritErrorHandler ( boolean inheritErrorHandler ) { super . setInheritErrorHandler ( inheritErrorHandler ) ; routeCollection . setInheritErrorHandlerFlag ( inheritErrorHandler ) ; } @ Override public void setErrorHandlerBuilder ( ErrorHandlerBuilder errorHandlerBuilder ) { super . setErrorHandlerBuilder ( errorHandlerBuilder ) ; routeCollection . setErrorHandlerBuilder ( getErrorHandlerBuilder ( ) ) ; } protected void checkInitialized ( ) throws Exception { if ( initialized . compareAndSet ( false , true ) ) { configure ( ) ; populateRoutes ( routes ) ; } } protected void populateRoutes ( List < Route > routes ) throws Exception { CamelContext camelContext = getContext ( ) ; if ( camelContext == null ) { throw new IllegalArgumentException ( "No CamelContext has been injected!" ) ; } routeCollection . setCamelContext ( camelContext ) ; camelContext . addRouteDefinitions ( routeCollection . getRoutes ( ) ) ; } public void setRouteCollection ( RoutesType routeCollection ) { this . routeCollection = routeCollection ; } public RoutesType getRouteCollection ( ) { return this . routeCollection ; } public void noStreamCaching ( ) { StreamCachingInterceptor . noStreamCaching ( routeCollection . getInterceptors ( ) ) ; } public void streamCaching ( ) { routeCollection . intercept ( new StreamCachingInterceptor ( ) ) ; } protected CamelContext createContainer ( ) { return new DefaultCamelContext ( ) ; } protected void configureRoute ( RouteType route ) { route . setGroup ( getClass ( ) . getName ( ) ) ; } } 	1	['24', '2', '6', '27', '55', '30', '13', '14', '20', '0.652173913', '207', '1', '1', '0.568627451', '0.128472222', '1', '3', '7.5', '2', '0.9583', '7']
package org . apache . camel . component . list ; import java . beans . PropertyChangeListener ; import java . beans . PropertyChangeSupport ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Consumer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . processor . loadbalancer . LoadBalancerConsumer ; import org . apache . camel . processor . loadbalancer . TopicLoadBalancer ; import org . apache . camel . spi . BrowsableEndpoint ; public class ListEndpoint extends DefaultEndpoint < Exchange > implements BrowsableEndpoint < Exchange > { private List < Exchange > exchanges ; private TopicLoadBalancer loadBalancer = new TopicLoadBalancer ( ) ; private PropertyChangeSupport propertyChangeSupport = new PropertyChangeSupport ( this ) ; public ListEndpoint ( String uri , CamelContext camelContext ) { super ( uri , camelContext ) ; reset ( ) ; } public ListEndpoint ( String uri , Component component ) { super ( uri , component ) ; reset ( ) ; } public ListEndpoint ( String endpointUri ) { super ( endpointUri ) ; reset ( ) ; } public boolean isSingleton ( ) { return true ; } public List < Exchange > getExchanges ( ) { return exchanges ; } public TopicLoadBalancer getLoadBalancer ( ) { return loadBalancer ; } public void addPropertyChangeListener ( PropertyChangeListener listener ) { propertyChangeSupport . addPropertyChangeListener ( listener ) ; } public void removePropertyChangeListener ( PropertyChangeListener listener ) { propertyChangeSupport . removePropertyChangeListener ( listener ) ; } public Producer < Exchange > createProducer ( ) throws Exception { return new DefaultProducer < Exchange > ( this ) { public void process ( Exchange exchange ) throws Exception { onExchange ( exchange ) ; } } ; } public Consumer < Exchange > createConsumer ( Processor processor ) throws Exception { return new LoadBalancerConsumer ( this , processor , loadBalancer ) ; } public void reset ( ) { exchanges = createExchangeList ( ) ; } protected List < Exchange > createExchangeList ( ) { return new CopyOnWriteArrayList < Exchange > ( ) ; } protected void onExchange ( Exchange exchange ) throws Exception { exchanges . add ( exchange ) ; loadBalancer . process ( exchange ) ; } } 	0	['13', '2', '1', '15', '25', '28', '3', '13', '11', '0.611111111', '120', '1', '1', '0.696969697', '0.241758242', '0', '0', '8', '1', '0.7692', '0']
package org . apache . camel . util ; import java . beans . PropertyEditor ; import java . beans . PropertyEditorManager ; import java . lang . reflect . Field ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . net . URI ; import java . net . URISyntaxException ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Iterator ; import java . util . LinkedHashMap ; import java . util . Map ; import java . util . Set ; import org . apache . camel . TypeConverter ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public final class IntrospectionSupport { private static final transient Log LOG = LogFactory . getLog ( IntrospectionSupport . class ) ; private IntrospectionSupport ( ) { } public static boolean getProperties ( Object target , Map props , String optionPrefix ) { boolean rc = false ; if ( target == null ) { throw new IllegalArgumentException ( "target was null." ) ; } if ( props == null ) { throw new IllegalArgumentException ( "props was null." ) ; } if ( optionPrefix == null ) { optionPrefix = "" ; } Class clazz = target . getClass ( ) ; Method [ ] methods = clazz . getMethods ( ) ; for ( Method method : methods ) { String name = method . getName ( ) ; Class type = method . getReturnType ( ) ; Class params [ ] = method . getParameterTypes ( ) ; if ( name . startsWith ( "get" ) && params . length == 0 && type != null && isSettableType ( type ) ) { try { Object value = method . invoke ( target ) ; if ( value == null ) { continue ; } String strValue = convertToString ( value , type ) ; if ( strValue == null ) { continue ; } name = name . substring ( 3 , 4 ) . toLowerCase ( ) + name . substring ( 4 ) ; props . put ( optionPrefix + name , strValue ) ; rc = true ; } catch ( Throwable ignore ) { } } } return rc ; } public static Object getProperty ( Object target , String prop ) throws SecurityException , NoSuchMethodException , IllegalArgumentException , IllegalAccessException , InvocationTargetException { if ( target == null ) { throw new IllegalArgumentException ( "target was null." ) ; } if ( prop == null ) { throw new IllegalArgumentException ( "prop was null." ) ; } prop = prop . substring ( 0 , 1 ) . toUpperCase ( ) + prop . substring ( 1 ) ; Class clazz = target . getClass ( ) ; Method method = getPropertyGetter ( clazz , prop ) ; return method . invoke ( target ) ; } public static Method getPropertyGetter ( Class type , String propertyName ) throws NoSuchMethodException { Method method = type . getMethod ( "get" + ObjectHelper . capitalize ( propertyName ) ) ; return method ; } public static boolean setProperties ( Object target , Map props , String optionPrefix ) throws Exception { boolean rc = false ; if ( target == null ) { throw new IllegalArgumentException ( "target was null." ) ; } if ( props == null ) { throw new IllegalArgumentException ( "props was null." ) ; } for ( Iterator iter = props . keySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { String name = ( String ) iter . next ( ) ; if ( name . startsWith ( optionPrefix ) ) { Object value = props . get ( name ) ; name = name . substring ( optionPrefix . length ( ) ) ; if ( setProperty ( target , name , value ) ) { iter . remove ( ) ; rc = true ; } } } return rc ; } public static Map extractProperties ( Map props , String optionPrefix ) { if ( props == null ) { throw new IllegalArgumentException ( "props was null." ) ; } HashMap rc = new HashMap ( props . size ( ) ) ; for ( Iterator iter = props . keySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { String name = ( String ) iter . next ( ) ; if ( name . startsWith ( optionPrefix ) ) { Object value = props . get ( name ) ; name = name . substring ( optionPrefix . length ( ) ) ; rc . put ( name , value ) ; iter . remove ( ) ; } } return rc ; } public static boolean setProperties ( TypeConverter typeConverter , Object target , Map props ) throws Exception { boolean rc = false ; if ( target == null ) { throw new IllegalArgumentException ( "target was null." ) ; } if ( props == null ) { throw new IllegalArgumentException ( "props was null." ) ; } for ( Iterator iter = props . entrySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) iter . next ( ) ; if ( setProperty ( typeConverter , target , ( String ) entry . getKey ( ) , entry . getValue ( ) ) ) { iter . remove ( ) ; rc = true ; } } return rc ; } public static boolean setProperties ( Object target , Map props ) throws Exception { return setProperties ( null , target , props ) ; } public static boolean setProperty ( TypeConverter typeConverter , Object target , String name , Object value ) throws Exception { try { Class clazz = target . getClass ( ) ; Method setter = findSetterMethod ( typeConverter , clazz , name , value ) ; if ( setter == null ) { return false ; } if ( value == null || value . getClass ( ) == setter . getParameterTypes ( ) [ 0 ] ) { setter . invoke ( target , value ) ; } else { Object convertedValue = convert ( typeConverter , setter . getParameterTypes ( ) [ 0 ] , value ) ; setter . invoke ( target , convertedValue ) ; } return true ; } catch ( InvocationTargetException e ) { Throwable throwable = e . getTargetException ( ) ; if ( throwable instanceof Exception ) { Exception exception = ( Exception ) throwable ; throw exception ; } else { Error error = ( Error ) throwable ; throw error ; } } } public static boolean setProperty ( Object target , String name , Object value ) throws Exception { return setProperty ( null , target , name , value ) ; } private static Object convert ( TypeConverter typeConverter , Class type , Object value ) throws URISyntaxException { if ( typeConverter != null ) { Object answer = typeConverter . convertTo ( type , value ) ; if ( answer == null ) { throw new IllegalArgumentException ( "Could not convert \"" + value + "\" to " + type . getName ( ) ) ; } return answer ; } PropertyEditor editor = PropertyEditorManager . findEditor ( type ) ; if ( editor != null ) { editor . setAsText ( value . toString ( ) ) ; return editor . getValue ( ) ; } if ( type == URI . class ) { return new URI ( value . toString ( ) ) ; } return null ; } private static String convertToString ( Object value , Class type ) throws URISyntaxException { PropertyEditor editor = PropertyEditorManager . findEditor ( type ) ; if ( editor != null ) { editor . setValue ( value ) ; return editor . getAsText ( ) ; } if ( type == URI . class ) { return value . toString ( ) ; } return null ; } private static Method findSetterMethod ( TypeConverter typeConverter , Class clazz , String name , Object value ) { name = "set" + ObjectHelper . capitalize ( name ) ; while ( clazz != Object . class ) { Method [ ] methods = clazz . getMethods ( ) ; for ( Method method : methods ) { Class params [ ] = method . getParameterTypes ( ) ; if ( method . getName ( ) . equals ( name ) && params . length == 1 ) { Class paramType = params [ 0 ] ; if ( typeConverter != null || isSettableType ( paramType ) || paramType . isInstance ( value ) ) { return method ; } } } clazz = clazz . getSuperclass ( ) ; } return null ; } private static boolean isSettableType ( Class clazz ) { if ( PropertyEditorManager . findEditor ( clazz ) != null ) { return true ; } if ( clazz == URI . class ) { return true ; } if ( clazz == Boolean . class ) { return true ; } return false ; } public static String toString ( Object target ) { return toString ( target , Object . class ) ; } public static String toString ( Object target , Class stopClass ) { LinkedHashMap map = new LinkedHashMap ( ) ; addFields ( target , target . getClass ( ) , stopClass , map ) ; StringBuffer buffer = new StringBuffer ( simpleName ( target . getClass ( ) ) ) ; buffer . append ( " {" ) ; Set entrySet = map . entrySet ( ) ; boolean first = true ; for ( Iterator iter = entrySet . iterator ( ) ; iter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) iter . next ( ) ; if ( first ) { first = false ; } else { buffer . append ( ", " ) ; } buffer . append ( entry . getKey ( ) ) ; buffer . append ( " = " ) ; appendToString ( buffer , entry . getValue ( ) ) ; } buffer . append ( "}" ) ; return buffer . toString ( ) ; } protected static void appendToString ( StringBuffer buffer , Object value ) { buffer . append ( value ) ; } public static String simpleName ( Class clazz ) { String name = clazz . getName ( ) ; int p = name . lastIndexOf ( "." ) ; if ( p >= 0 ) { name = name . substring ( p + 1 ) ; } return name ; } private static void addFields ( Object target , Class startClass , Class stopClass , LinkedHashMap map ) { if ( startClass != stopClass ) { addFields ( target , startClass . getSuperclass ( ) , stopClass , map ) ; } Field [ ] fields = startClass . getDeclaredFields ( ) ; for ( Field field : fields ) { if ( Modifier . isStatic ( field . getModifiers ( ) ) || Modifier . isTransient ( field . getModifiers ( ) ) || Modifier . isPrivate ( field . getModifiers ( ) ) ) { continue ; } try { field . setAccessible ( true ) ; Object o = field . get ( target ) ; if ( o != null && o . getClass ( ) . isArray ( ) ) { try { o = Arrays . asList ( ( Object [ ] ) o ) ; } catch ( Throwable e ) { } } map . put ( field . getName ( ) , o ) ; } catch ( Throwable e ) { LOG . debug ( "Error adding fields" , e ) ; } } } } 	1	['20', '1', '0', '18', '86', '188', '14', '4', '12', '0.894736842', '739', '1', '0', '0', '0.276315789', '0', '0', '35.9', '11', '2.5', '1']
