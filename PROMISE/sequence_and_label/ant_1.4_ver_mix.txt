package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . * ; import java . util . * ; import java . io . File ; public class PathConvert extends Task { public class MapEntry { public void setFrom ( String from ) { this . from = from ; } public void setTo ( String to ) { this . to = to ; } public String apply ( String elem ) { if ( from == null || to == null ) { throw new BuildException ( "Both 'from' and 'to' must be set in a map entry" ) ; } String cmpElem = onWindows ? elem . toLowerCase ( ) : elem ; String cmpFrom = onWindows ? from . toLowerCase ( ) : from ; if ( cmpElem . startsWith ( cmpFrom ) ) { int len = from . length ( ) ; if ( len >= elem . length ( ) ) { elem = to ; } else { elem = to + elem . substring ( len ) ; } } return elem ; } private String from = null ; private String to = null ; } public Path createPath ( ) { if ( isReference ( ) ) throw noChildrenAllowed ( ) ; if ( path == null ) { path = new Path ( getProject ( ) ) ; } return path . createPath ( ) ; } public MapEntry createMap ( ) { MapEntry entry = new MapEntry ( ) ; prefixMap . addElement ( entry ) ; return entry ; } public void setTargetos ( String target ) { targetOS = target . toLowerCase ( ) ; if ( ! targetOS . equals ( "windows" ) && ! target . equals ( "unix" ) ) { throw new BuildException ( "targetos must be one of 'unix' or 'windows'" ) ; } targetWindows = targetOS . equals ( "windows" ) ; } public void setProperty ( String p ) { property = p ; } public void setRefid ( Reference r ) { if ( path != null ) throw noChildrenAllowed ( ) ; refid = r ; } public void setPathSep ( String sep ) { pathSep = sep ; } public void setDirSep ( String sep ) { dirSep = sep ; } public boolean isReference ( ) { return refid != null ; } public void execute ( ) throws BuildException { if ( isReference ( ) ) { path = new Path ( getProject ( ) ) . createPath ( ) ; Object obj = refid . getReferencedObject ( getProject ( ) ) ; if ( obj instanceof Path ) { path . setRefid ( refid ) ; } else if ( obj instanceof FileSet ) { FileSet fs = ( FileSet ) obj ; path . addFileset ( fs ) ; } else { throw new BuildException ( "'refid' does not refer to a path or fileset" ) ; } } validateSetup ( ) ; String osname = System . getProperty ( "os.name" ) . toLowerCase ( ) ; onWindows = ( osname . indexOf ( "windows" ) >= 0 ) ; char fromDirSep = onWindows ? '\\' : '/' ; char toDirSep = dirSep . charAt ( 0 ) ; StringBuffer rslt = new StringBuffer ( 100 ) ; String [ ] elems = path . list ( ) ; for ( int i = 0 ; i < elems . length ; i ++ ) { String elem = elems [ i ] ; elem = mapElement ( elem ) ; elem = elem . replace ( fromDirSep , toDirSep ) ; if ( i != 0 ) rslt . append ( pathSep ) ; rslt . append ( elem ) ; } String value = rslt . toString ( ) ; log ( "Set property " + property + " = " + value , Project . MSG_VERBOSE ) ; getProject ( ) . setProperty ( property , value ) ; } private String mapElement ( String elem ) { int size = prefixMap . size ( ) ; if ( size != 0 ) { for ( int i = 0 ; i < size ; i ++ ) { MapEntry entry = ( MapEntry ) prefixMap . elementAt ( i ) ; String newElem = entry . apply ( elem ) ; if ( newElem != elem ) { elem = newElem ; break ; } } } return elem ; } private void validateSetup ( ) throws BuildException { if ( path == null ) throw new BuildException ( "You must specify a path to convert" ) ; if ( property == null ) throw new BuildException ( "You must specify a property" ) ; if ( targetOS == null && pathSep == null && dirSep == null ) throw new BuildException ( "You must specify at least one of targetOS, dirSep, or pathSep" ) ; String dsep = File . separator ; String psep = File . pathSeparator ; if ( targetOS != null ) { psep = targetWindows ? ";" : ":" ; dsep = targetWindows ? "\\" : "/" ; } if ( pathSep != null ) { psep = pathSep ; } if ( dirSep != null ) { dsep = dirSep ; } pathSep = psep ; dirSep = dsep ; } private BuildException noChildrenAllowed ( ) { return new BuildException ( "You must not specify nested PATH elements when using refid" ) ; } private Path path = null ; private Reference refid = null ; private String targetOS = null ; private boolean targetWindows = false ; private boolean onWindows = false ; private String property = null ; private Vector prefixMap = new Vector ( ) ; private String pathSep = null ; private String dirSep = null ; } 	0	['14', '3', '0', '8', '41', '33', '1', '8', '10', '0.760683761', '385', '1', '2', '0.74', '0.357142857', '1', '1', '25.85714286', '4', '1.5714', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import org . apache . tools . ant . util . * ; import java . util . Hashtable ; import java . util . Vector ; import java . io . File ; import java . io . IOException ; public class ExecuteOn extends ExecTask { protected Vector filesets = new Vector ( ) ; private boolean parallel = false ; protected String type = "file" ; protected Commandline . Marker srcFilePos = null ; private boolean skipEmpty = false ; protected Commandline . Marker targetFilePos = null ; protected Mapper mapperElement = null ; protected FileNameMapper mapper = null ; protected File destDir = null ; protected boolean srcIsFirst = true ; public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void setParallel ( boolean parallel ) { this . parallel = parallel ; } public void setType ( FileDirBoth type ) { this . type = type . getValue ( ) ; } public void setSkipEmptyFilesets ( boolean skip ) { skipEmpty = skip ; } public void setDest ( File destDir ) { this . destDir = destDir ; } public Commandline . Marker createSrcfile ( ) { if ( srcFilePos != null ) { throw new BuildException ( taskType + " doesn\'t support multiple srcfile elements." , location ) ; } srcFilePos = cmdl . createMarker ( ) ; return srcFilePos ; } public Commandline . Marker createTargetfile ( ) { if ( targetFilePos != null ) { throw new BuildException ( taskType + " doesn\'t support multiple targetfile elements." , location ) ; } targetFilePos = cmdl . createMarker ( ) ; srcIsFirst = ( srcFilePos != null ) ; return targetFilePos ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" , location ) ; } mapperElement = new Mapper ( project ) ; return mapperElement ; } protected void checkConfiguration ( ) { if ( "execon" . equals ( taskName ) ) { log ( "!! execon is deprecated. Use apply instead. !!" ) ; } super . checkConfiguration ( ) ; if ( filesets . size ( ) == 0 ) { throw new BuildException ( "no filesets specified" , location ) ; } if ( targetFilePos != null || mapperElement != null || destDir != null ) { if ( mapperElement == null ) { throw new BuildException ( "no mapper specified" , location ) ; } if ( mapperElement == null ) { throw new BuildException ( "no dest attribute specified" , location ) ; } mapper = mapperElement . getImplementation ( ) ; } } protected void runExec ( Execute exe ) throws BuildException { try { Vector fileNames = new Vector ( ) ; Vector baseDirs = new Vector ( ) ; for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; File base = fs . getDir ( project ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; if ( ! "dir" . equals ( type ) ) { String [ ] s = getFiles ( base , ds ) ; for ( int j = 0 ; j < s . length ; j ++ ) { fileNames . addElement ( s [ j ] ) ; baseDirs . addElement ( base ) ; } } if ( ! "file" . equals ( type ) ) { String [ ] s = getDirs ( base , ds ) ; ; for ( int j = 0 ; j < s . length ; j ++ ) { fileNames . addElement ( s [ j ] ) ; baseDirs . addElement ( base ) ; } } if ( fileNames . size ( ) == 0 && skipEmpty ) { log ( "Skipping fileset for directory " + base + ". It is empty." , Project . MSG_INFO ) ; continue ; } if ( ! parallel ) { String [ ] s = new String [ fileNames . size ( ) ] ; fileNames . copyInto ( s ) ; for ( int j = 0 ; j < s . length ; j ++ ) { String [ ] command = getCommandline ( s [ j ] , base ) ; log ( "Executing " + Commandline . toString ( command ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( command ) ; runExecute ( exe ) ; } fileNames . removeAllElements ( ) ; baseDirs . removeAllElements ( ) ; } } if ( parallel ) { String [ ] s = new String [ fileNames . size ( ) ] ; fileNames . copyInto ( s ) ; File [ ] b = new File [ baseDirs . size ( ) ] ; baseDirs . copyInto ( b ) ; String [ ] command = getCommandline ( s , b ) ; log ( "Executing " + Commandline . toString ( command ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( command ) ; runExecute ( exe ) ; } } catch ( IOException e ) { throw new BuildException ( "Execute failed: " + e , e , location ) ; } finally { logFlush ( ) ; } } protected String [ ] getCommandline ( String [ ] srcFiles , File [ ] baseDirs ) { Vector targets = new Vector ( ) ; if ( targetFilePos != null ) { Hashtable addedFiles = new Hashtable ( ) ; for ( int i = 0 ; i < srcFiles . length ; i ++ ) { String [ ] subTargets = mapper . mapFileName ( srcFiles [ i ] ) ; if ( subTargets != null ) { for ( int j = 0 ; j < subTargets . length ; j ++ ) { String name = ( new File ( destDir , subTargets [ j ] ) ) . getAbsolutePath ( ) ; if ( ! addedFiles . contains ( name ) ) { targets . addElement ( name ) ; addedFiles . put ( name , name ) ; } } } } } String [ ] targetFiles = new String [ targets . size ( ) ] ; targets . copyInto ( targetFiles ) ; String [ ] orig = cmdl . getCommandline ( ) ; String [ ] result = new String [ orig . length + srcFiles . length + targetFiles . length ] ; int srcIndex = orig . length ; if ( srcFilePos != null ) { srcIndex = srcFilePos . getPosition ( ) ; } if ( targetFilePos != null ) { int targetIndex = targetFilePos . getPosition ( ) ; if ( srcIndex < targetIndex || ( srcIndex == targetIndex && srcIsFirst ) ) { System . arraycopy ( orig , 0 , result , 0 , srcIndex ) ; System . arraycopy ( orig , srcIndex , result , srcIndex + srcFiles . length , targetIndex - srcIndex ) ; System . arraycopy ( targetFiles , 0 , result , targetIndex + srcFiles . length , targetFiles . length ) ; System . arraycopy ( orig , targetIndex , result , targetIndex + srcFiles . length + targetFiles . length , orig . length - targetIndex ) ; } else { System . arraycopy ( orig , 0 , result , 0 , targetIndex ) ; System . arraycopy ( targetFiles , 0 , result , targetIndex , targetFiles . length ) ; System . arraycopy ( orig , targetIndex , result , targetIndex + targetFiles . length , srcIndex - targetIndex ) ; System . arraycopy ( orig , srcIndex , result , srcIndex + srcFiles . length + targetFiles . length , orig . length - srcIndex ) ; srcIndex += targetFiles . length ; } } else { System . arraycopy ( orig , 0 , result , 0 , srcIndex ) ; System . arraycopy ( orig , srcIndex , result , srcIndex + srcFiles . length , orig . length - srcIndex ) ; } for ( int i = 0 ; i < srcFiles . length ; i ++ ) { result [ srcIndex + i ] = ( new File ( baseDirs [ i ] , srcFiles [ i ] ) ) . getAbsolutePath ( ) ; } return result ; } protected String [ ] getCommandline ( String srcFile , File baseDir ) { return getCommandline ( new String [ ] { srcFile } , new File [ ] { baseDir } ) ; } protected String [ ] getFiles ( File baseDir , DirectoryScanner ds ) { if ( mapper != null ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; return sfs . restrict ( ds . getIncludedFiles ( ) , baseDir , destDir , mapper ) ; } else { return ds . getIncludedFiles ( ) ; } } protected String [ ] getDirs ( File baseDir , DirectoryScanner ds ) { if ( mapper != null ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; return sfs . restrict ( ds . getIncludedDirectories ( ) , baseDir , destDir , mapper ) ; } else { return ds . getIncludedDirectories ( ) ; } } public static class FileDirBoth extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "file" , "dir" , "both" } ; } } } 	1	['15', '4', '2', '18', '55', '37', '2', '16', '9', '0.728571429', '730', '1', '4', '0.846153846', '0.193333333', '3', '7', '47', '12', '2.4667', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . tar . * ; import java . io . * ; public class Untar extends Task { private File dest ; private File source ; private boolean overwrite = true ; public void execute ( ) throws BuildException { Touch touch = ( Touch ) project . createTask ( "touch" ) ; touch . setOwningTarget ( target ) ; touch . setTaskName ( getTaskName ( ) ) ; touch . setLocation ( getLocation ( ) ) ; File srcF = source ; TarInputStream tis = null ; try { if ( source == null ) { throw new BuildException ( "No source specified" , location ) ; } if ( ! srcF . exists ( ) ) { throw new BuildException ( "source " + srcF + " doesn't exist" , location ) ; } if ( dest == null ) { throw new BuildException ( "No destination specified" , location ) ; } File dir = dest ; log ( "Expanding: " + srcF + " into " + dir , Project . MSG_INFO ) ; tis = new TarInputStream ( new FileInputStream ( srcF ) ) ; TarEntry te = null ; while ( ( te = tis . getNextEntry ( ) ) != null ) { try { File f = new File ( dir , project . translatePath ( te . getName ( ) ) ) ; if ( ! overwrite && f . exists ( ) && f . lastModified ( ) >= te . getModTime ( ) . getTime ( ) ) { log ( "Skipping " + f + " as it is up-to-date" , Project . MSG_DEBUG ) ; continue ; } log ( "expanding " + te . getName ( ) + " to " + f , Project . MSG_VERBOSE ) ; File dirF = new File ( f . getParent ( ) ) ; dirF . mkdirs ( ) ; if ( te . isDirectory ( ) ) { f . mkdirs ( ) ; } else { byte [ ] buffer = new byte [ 1024 ] ; int length = 0 ; FileOutputStream fos = new FileOutputStream ( f ) ; while ( ( length = tis . read ( buffer ) ) >= 0 ) { fos . write ( buffer , 0 , length ) ; } fos . close ( ) ; } if ( project . getJavaVersion ( ) != Project . JAVA_1_1 ) { touch . setFile ( f ) ; touch . setMillis ( te . getModTime ( ) . getTime ( ) ) ; touch . touch ( ) ; } } catch ( FileNotFoundException ex ) { log ( "FileNotFoundException: " + te . getName ( ) , Project . MSG_WARN ) ; } } } catch ( IOException ioe ) { throw new BuildException ( "Error while expanding " + srcF . getPath ( ) , ioe , location ) ; } finally { if ( tis != null ) { try { tis . close ( ) ; } catch ( IOException e ) { } } } } public void setDest ( File d ) { this . dest = d ; } public void setSrc ( File s ) { this . source = s ; } public void setOverwrite ( boolean b ) { overwrite = b ; } } 	0	['5', '3', '0', '9', '43', '0', '0', '9', '5', '0.666666667', '276', '1', '0', '0.902439024', '0.533333333', '2', '3', '53.6', '1', '0.8', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . io . * ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . util . Vector ; import java . util . Properties ; import java . util . zip . * ; import java . sql . * ; public class SQLExec extends Task { static public class DelimiterType extends EnumeratedAttribute { static public final String NORMAL = "normal" ; static public final String ROW = "row" ; public String [ ] getValues ( ) { return new String [ ] { NORMAL , ROW } ; } } private int goodSql = 0 , totalSql = 0 ; private Path classpath ; private AntClassLoader loader ; private Vector filesets = new Vector ( ) ; private Connection conn = null ; private boolean autocommit = false ; private Statement statement = null ; private String driver = null ; private String url = null ; private String userId = null ; private String password = null ; private File srcFile = null ; private String sqlCommand = "" ; private Vector transactions = new Vector ( ) ; private String delimiter = ";" ; private String delimiterType = DelimiterType . NORMAL ; private boolean print = false ; private boolean showheaders = true ; private File output = null ; private String rdbms = null ; private String version = null ; private String onError = "abort" ; public void setClasspath ( Path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( project ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setSrc ( File srcFile ) { this . srcFile = srcFile ; } public void addText ( String sql ) { this . sqlCommand += sql ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public Transaction createTransaction ( ) { Transaction t = new Transaction ( ) ; transactions . addElement ( t ) ; return t ; } public void setDriver ( String driver ) { this . driver = driver ; } public void setUrl ( String url ) { this . url = url ; } public void setUserid ( String userId ) { this . userId = userId ; } public void setPassword ( String password ) { this . password = password ; } public void setAutocommit ( boolean autocommit ) { this . autocommit = autocommit ; } public void setDelimiter ( String delimiter ) { this . delimiter = delimiter ; } public void setDelimiterType ( DelimiterType delimiterType ) { this . delimiterType = delimiterType . getValue ( ) ; } public void setPrint ( boolean print ) { this . print = print ; } public void setShowheaders ( boolean showheaders ) { this . showheaders = showheaders ; } public void setOutput ( File output ) { this . output = output ; } public void setRdbms ( String vendor ) { this . rdbms = vendor . toLowerCase ( ) ; } public void setVersion ( String version ) { this . version = version . toLowerCase ( ) ; } public void setOnerror ( OnError action ) { this . onError = action . getValue ( ) ; } public void execute ( ) throws BuildException { sqlCommand = sqlCommand . trim ( ) ; if ( srcFile == null && sqlCommand . length ( ) == 0 && filesets . isEmpty ( ) ) { if ( transactions . size ( ) == 0 ) { throw new BuildException ( "Source file or fileset, transactions or sql statement must be set!" , location ) ; } } else { for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; File srcDir = fs . getDir ( project ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; for ( int j = 0 ; j < srcFiles . length ; j ++ ) { Transaction t = createTransaction ( ) ; t . setSrc ( new File ( srcDir , srcFiles [ j ] ) ) ; } } Transaction t = createTransaction ( ) ; t . setSrc ( srcFile ) ; t . addText ( sqlCommand ) ; } if ( driver == null ) { throw new BuildException ( "Driver attribute must be set!" , location ) ; } if ( userId == null ) { throw new BuildException ( "User Id attribute must be set!" , location ) ; } if ( password == null ) { throw new BuildException ( "Password attribute must be set!" , location ) ; } if ( url == null ) { throw new BuildException ( "Url attribute must be set!" , location ) ; } if ( srcFile != null && ! srcFile . exists ( ) ) { throw new BuildException ( "Source file does not exist!" , location ) ; } Driver driverInstance = null ; try { Class dc ; if ( classpath != null ) { log ( "Loading " + driver + " using AntClassLoader with classpath " + classpath , Project . MSG_VERBOSE ) ; loader = new AntClassLoader ( project , classpath ) ; dc = loader . loadClass ( driver ) ; } else { log ( "Loading " + driver + " using system loader." , Project . MSG_VERBOSE ) ; dc = Class . forName ( driver ) ; } driverInstance = ( Driver ) dc . newInstance ( ) ; } catch ( ClassNotFoundException e ) { throw new BuildException ( "Class Not Found: JDBC driver " + driver + " could not be loaded" , location ) ; } catch ( IllegalAccessException e ) { throw new BuildException ( "Illegal Access: JDBC driver " + driver + " could not be loaded" , location ) ; } catch ( InstantiationException e ) { throw new BuildException ( "Instantiation Exception: JDBC driver " + driver + " could not be loaded" , location ) ; } try { log ( "connecting to " + url , Project . MSG_VERBOSE ) ; Properties info = new Properties ( ) ; info . put ( "user" , userId ) ; info . put ( "password" , password ) ; conn = driverInstance . connect ( url , info ) ; if ( conn == null ) { throw new SQLException ( "No suitable Driver for " + url ) ; } if ( ! isValidRdbms ( conn ) ) return ; conn . setAutoCommit ( autocommit ) ; statement = conn . createStatement ( ) ; PrintStream out = System . out ; try { if ( output != null ) { log ( "Opening PrintStream to output file " + output , Project . MSG_VERBOSE ) ; out = new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( output ) ) ) ; } for ( Enumeration e = transactions . elements ( ) ; e . hasMoreElements ( ) ; ) { ( ( Transaction ) e . nextElement ( ) ) . runTransaction ( out ) ; if ( ! autocommit ) { log ( "Commiting transaction" , Project . MSG_VERBOSE ) ; conn . commit ( ) ; } } } finally { if ( out != null && out != System . out ) { out . close ( ) ; } } } catch ( IOException e ) { if ( ! autocommit && conn != null && onError . equals ( "abort" ) ) { try { conn . rollback ( ) ; } catch ( SQLException ex ) { } } throw new BuildException ( e , location ) ; } catch ( SQLException e ) { if ( ! autocommit && conn != null && onError . equals ( "abort" ) ) { try { conn . rollback ( ) ; } catch ( SQLException ex ) { } } throw new BuildException ( e , location ) ; } finally { try { if ( statement != null ) { statement . close ( ) ; } if ( conn != null ) { conn . close ( ) ; } } catch ( SQLException e ) { } } log ( goodSql + " of " + totalSql + " SQL statements executed successfully" ) ; } protected void runStatements ( Reader reader , PrintStream out ) throws SQLException , IOException { String sql = "" ; String line = "" ; BufferedReader in = new BufferedReader ( reader ) ; try { while ( ( line = in . readLine ( ) ) != null ) { line = line . trim ( ) ; line = ProjectHelper . replaceProperties ( project , line , project . getProperties ( ) ) ; if ( line . startsWith ( "//" ) ) continue ; if ( line . startsWith ( "--" ) ) continue ; if ( line . length ( ) > 2 && line . substring ( 0 , 3 ) . equalsIgnoreCase ( "REM" ) ) continue ; sql += " " + line ; sql = sql . trim ( ) ; if ( line . indexOf ( "--" ) >= 0 ) sql += "\n" ; if ( delimiterType . equals ( DelimiterType . NORMAL ) && sql . endsWith ( delimiter ) || delimiterType . equals ( DelimiterType . ROW ) && line . equals ( delimiter ) ) { log ( "SQL: " + sql , Project . MSG_VERBOSE ) ; execSQL ( sql . substring ( 0 , sql . length ( ) - delimiter . length ( ) ) , out ) ; sql = "" ; } } if ( ! sql . equals ( "" ) ) { execSQL ( sql , out ) ; } } catch ( SQLException e ) { throw e ; } } protected boolean isValidRdbms ( Connection conn ) { if ( rdbms == null && version == null ) return true ; try { DatabaseMetaData dmd = conn . getMetaData ( ) ; if ( rdbms != null ) { String theVendor = dmd . getDatabaseProductName ( ) . toLowerCase ( ) ; log ( "RDBMS = " + theVendor , Project . MSG_VERBOSE ) ; if ( theVendor == null || theVendor . indexOf ( rdbms ) < 0 ) { log ( "Not the required RDBMS: " + rdbms , Project . MSG_VERBOSE ) ; return false ; } } if ( version != null ) { String theVersion = dmd . getDatabaseProductVersion ( ) . toLowerCase ( ) ; log ( "Version = " + theVersion , Project . MSG_VERBOSE ) ; if ( theVersion == null || ! ( theVersion . startsWith ( version ) || theVersion . indexOf ( " " + version ) >= 0 ) ) { log ( "Not the required version: \"" + version + "\"" , Project . MSG_VERBOSE ) ; return false ; } } } catch ( SQLException e ) { log ( "Failed to obtain required RDBMS information" , Project . MSG_ERR ) ; return false ; } return true ; } protected void execSQL ( String sql , PrintStream out ) throws SQLException { if ( "" . equals ( sql . trim ( ) ) ) return ; try { totalSql ++ ; if ( ! statement . execute ( sql ) ) { log ( statement . getUpdateCount ( ) + " rows affected" , Project . MSG_VERBOSE ) ; } else { if ( print ) { printResults ( out ) ; } } SQLWarning warning = conn . getWarnings ( ) ; while ( warning != null ) { log ( warning + " sql warning" , Project . MSG_VERBOSE ) ; warning = warning . getNextWarning ( ) ; } conn . clearWarnings ( ) ; goodSql ++ ; } catch ( SQLException e ) { log ( "Failed to execute: " + sql , Project . MSG_ERR ) ; if ( ! onError . equals ( "continue" ) ) throw e ; log ( e . toString ( ) , Project . MSG_ERR ) ; } } protected void printResults ( PrintStream out ) throws java . sql . SQLException { ResultSet rs = null ; do { rs = statement . getResultSet ( ) ; if ( rs != null ) { log ( "Processing new result set." , Project . MSG_VERBOSE ) ; ResultSetMetaData md = rs . getMetaData ( ) ; int columnCount = md . getColumnCount ( ) ; StringBuffer line = new StringBuffer ( ) ; if ( showheaders ) { for ( int col = 1 ; col < columnCount ; col ++ ) { line . append ( md . getColumnName ( col ) ) ; line . append ( "," ) ; } line . append ( md . getColumnName ( columnCount ) ) ; out . println ( line ) ; line . setLength ( 0 ) ; } while ( rs . next ( ) ) { boolean first = true ; for ( int col = 1 ; col <= columnCount ; col ++ ) { String columnValue = rs . getString ( col ) ; if ( columnValue != null ) { columnValue = columnValue . trim ( ) ; } if ( first ) { first = false ; } else { line . append ( "," ) ; } line . append ( columnValue ) ; } out . println ( line ) ; line . setLength ( 0 ) ; } } } while ( statement . getMoreResults ( ) ) ; out . println ( ) ; } public static class OnError extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "continue" , "stop" , "abort" } ; } } public class Transaction { private File tSrcFile = null ; private String tSqlCommand = "" ; public void setSrc ( File src ) { this . tSrcFile = src ; } public void addText ( String sql ) { this . tSqlCommand += sql ; } private void runTransaction ( PrintStream out ) throws IOException , SQLException { if ( tSqlCommand . length ( ) != 0 ) { log ( "Executing commands" , Project . MSG_INFO ) ; runStatements ( new StringReader ( tSqlCommand ) , out ) ; } if ( tSrcFile != null ) { log ( "Executing file: " + tSrcFile . getAbsolutePath ( ) , Project . MSG_INFO ) ; FileReader reader = new FileReader ( tSrcFile ) ; runStatements ( reader , out ) ; reader . close ( ) ; } } } } 	1	['26', '3', '0', '15', '108', '233', '1', '15', '22', '0.902608696', '1156', '1', '2', '0.596774194', '0.16025641', '3', '3', '42.57692308', '7', '1.2692', '1']
package org . apache . tools . ant . taskdefs ; import java . io . InputStream ; import java . io . IOException ; import java . io . OutputStream ; public class PumpStreamHandler implements ExecuteStreamHandler { private Thread inputThread ; private Thread errorThread ; private OutputStream out , err ; public PumpStreamHandler ( OutputStream out , OutputStream err ) { this . out = out ; this . err = err ; } public PumpStreamHandler ( OutputStream outAndErr ) { this ( outAndErr , outAndErr ) ; } public PumpStreamHandler ( ) { this ( System . out , System . err ) ; } public void setProcessOutputStream ( InputStream is ) { createProcessOutputPump ( is , out ) ; } public void setProcessErrorStream ( InputStream is ) { createProcessErrorPump ( is , err ) ; } public void setProcessInputStream ( OutputStream os ) { } public void start ( ) { inputThread . start ( ) ; errorThread . start ( ) ; } public void stop ( ) { try { inputThread . join ( ) ; } catch ( InterruptedException e ) { } try { errorThread . join ( ) ; } catch ( InterruptedException e ) { } try { err . flush ( ) ; } catch ( IOException e ) { } try { out . flush ( ) ; } catch ( IOException e ) { } } protected OutputStream getErr ( ) { return err ; } protected OutputStream getOut ( ) { return out ; } protected void createProcessOutputPump ( InputStream is , OutputStream os ) { inputThread = createPump ( is , os ) ; } protected void createProcessErrorPump ( InputStream is , OutputStream os ) { errorThread = createPump ( is , os ) ; } protected Thread createPump ( InputStream is , OutputStream os ) { final Thread result = new Thread ( new StreamPumper ( is , os ) ) ; result . setDaemon ( true ) ; return result ; } } 	0	['13', '1', '1', '8', '20', '46', '6', '2', '8', '0.666666667', '111', '1', '0', '0', '0.615384615', '0', '0', '7.230769231', '1', '0.7692', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . Enumeration ; import java . util . Vector ; import java . util . Date ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . FileList ; public class DependSet extends MatchingTask { private Vector sourceFileSets = new Vector ( ) ; private Vector sourceFileLists = new Vector ( ) ; private Vector targetFileSets = new Vector ( ) ; private Vector targetFileLists = new Vector ( ) ; public DependSet ( ) { } public void addSrcfileset ( FileSet fs ) { sourceFileSets . addElement ( fs ) ; } public void addSrcfilelist ( FileList fl ) { sourceFileLists . addElement ( fl ) ; } public void addTargetfileset ( FileSet fs ) { targetFileSets . addElement ( fs ) ; } public void addTargetfilelist ( FileList fl ) { targetFileLists . addElement ( fl ) ; } public void execute ( ) throws BuildException { if ( ( sourceFileSets . size ( ) == 0 ) && ( sourceFileLists . size ( ) == 0 ) ) { throw new BuildException ( "At least one <srcfileset> or <srcfilelist> element must be set" ) ; } if ( ( targetFileSets . size ( ) == 0 ) && ( targetFileLists . size ( ) == 0 ) ) { throw new BuildException ( "At least one <targetfileset> or <targetfilelist> element must be set" ) ; } long now = ( new Date ( ) ) . getTime ( ) ; String osname = System . getProperty ( "os.name" ) . toLowerCase ( ) ; if ( osname . indexOf ( "windows" ) >= 0 ) { now += 2000 ; } Vector allTargets = new Vector ( ) ; Enumeration enumTargetSets = targetFileSets . elements ( ) ; while ( enumTargetSets . hasMoreElements ( ) ) { FileSet targetFS = ( FileSet ) enumTargetSets . nextElement ( ) ; DirectoryScanner targetDS = targetFS . getDirectoryScanner ( project ) ; String [ ] targetFiles = targetDS . getIncludedFiles ( ) ; for ( int i = 0 ; i < targetFiles . length ; i ++ ) { File dest = new File ( targetFS . getDir ( project ) , targetFiles [ i ] ) ; allTargets . addElement ( dest ) ; if ( dest . lastModified ( ) > now ) { log ( "Warning: " + targetFiles [ i ] + " modified in the future." , Project . MSG_WARN ) ; } } } boolean upToDate = true ; Enumeration enumTargetLists = targetFileLists . elements ( ) ; while ( enumTargetLists . hasMoreElements ( ) ) { FileList targetFL = ( FileList ) enumTargetLists . nextElement ( ) ; String [ ] targetFiles = targetFL . getFiles ( project ) ; for ( int i = 0 ; i < targetFiles . length ; i ++ ) { File dest = new File ( targetFL . getDir ( project ) , targetFiles [ i ] ) ; if ( ! dest . exists ( ) ) { log ( targetFiles [ i ] + " does not exist." , Project . MSG_VERBOSE ) ; upToDate = false ; continue ; } else { allTargets . addElement ( dest ) ; } if ( dest . lastModified ( ) > now ) { log ( "Warning: " + targetFiles [ i ] + " modified in the future." , Project . MSG_WARN ) ; } } } if ( upToDate ) { Enumeration enumSourceSets = sourceFileSets . elements ( ) ; while ( upToDate && enumSourceSets . hasMoreElements ( ) ) { FileSet sourceFS = ( FileSet ) enumSourceSets . nextElement ( ) ; DirectoryScanner sourceDS = sourceFS . getDirectoryScanner ( project ) ; String [ ] sourceFiles = sourceDS . getIncludedFiles ( ) ; int i = 0 ; do { File src = new File ( sourceFS . getDir ( project ) , sourceFiles [ i ] ) ; if ( src . lastModified ( ) > now ) { log ( "Warning: " + sourceFiles [ i ] + " modified in the future." , Project . MSG_WARN ) ; } Enumeration enumTargets = allTargets . elements ( ) ; while ( upToDate && enumTargets . hasMoreElements ( ) ) { File dest = ( File ) enumTargets . nextElement ( ) ; if ( src . lastModified ( ) > dest . lastModified ( ) ) { log ( dest . getPath ( ) + " is out of date with respect to " + sourceFiles [ i ] , Project . MSG_VERBOSE ) ; upToDate = false ; } } } while ( upToDate && ( ++ i < sourceFiles . length ) ) ; } } if ( upToDate ) { Enumeration enumSourceLists = sourceFileLists . elements ( ) ; while ( upToDate && enumSourceLists . hasMoreElements ( ) ) { FileList sourceFL = ( FileList ) enumSourceLists . nextElement ( ) ; String [ ] sourceFiles = sourceFL . getFiles ( project ) ; int i = 0 ; do { File src = new File ( sourceFL . getDir ( project ) , sourceFiles [ i ] ) ; if ( src . lastModified ( ) > now ) { log ( "Warning: " + sourceFiles [ i ] + " modified in the future." , Project . MSG_WARN ) ; } if ( ! src . exists ( ) ) { log ( sourceFiles [ i ] + " does not exist." , Project . MSG_VERBOSE ) ; upToDate = false ; break ; } Enumeration enumTargets = allTargets . elements ( ) ; while ( upToDate && enumTargets . hasMoreElements ( ) ) { File dest = ( File ) enumTargets . nextElement ( ) ; if ( src . lastModified ( ) > dest . lastModified ( ) ) { log ( dest . getPath ( ) + " is out of date with respect to " + sourceFiles [ i ] , Project . MSG_VERBOSE ) ; upToDate = false ; } } } while ( upToDate && ( ++ i < sourceFiles . length ) ) ; } } if ( ! upToDate ) { log ( "Deleting all target files. " , Project . MSG_VERBOSE ) ; for ( Enumeration e = allTargets . elements ( ) ; e . hasMoreElements ( ) ; ) { File fileToRemove = ( File ) e . nextElement ( ) ; log ( "Deleting file " + fileToRemove . getAbsolutePath ( ) , Project . MSG_VERBOSE ) ; fileToRemove . delete ( ) ; } } } } 	1	['6', '4', '0', '8', '34', '0', '0', '8', '6', '0.6', '493', '1', '0', '0.939759036', '0.555555556', '1', '1', '80.5', '1', '0.8333', '2']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import java . util . * ; import org . apache . tools . ant . * ; public class Copydir extends MatchingTask { private File srcDir ; private File destDir ; private boolean filtering = false ; private boolean flatten = false ; private boolean forceOverwrite = false ; private Hashtable filecopyList = new Hashtable ( ) ; public void setSrc ( File src ) { srcDir = src ; } public void setDest ( File dest ) { destDir = dest ; } public void setFiltering ( boolean filter ) { filtering = filter ; } public void setFlatten ( boolean flatten ) { this . flatten = flatten ; } public void setForceoverwrite ( boolean force ) { forceOverwrite = force ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The copydir task is deprecated.  Use copy instead." ) ; if ( srcDir == null ) { throw new BuildException ( "src attribute must be set!" , location ) ; } if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir " + srcDir . toString ( ) + " does not exist!" , location ) ; } if ( destDir == null ) { throw new BuildException ( "The dest attribute must be set." , location ) ; } if ( srcDir . equals ( destDir ) ) { log ( "Warning: src == dest" ) ; } DirectoryScanner ds = super . getDirectoryScanner ( srcDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( srcDir , destDir , files ) ; if ( filecopyList . size ( ) > 0 ) { log ( "Copying " + filecopyList . size ( ) + " file" + ( filecopyList . size ( ) == 1 ? "" : "s" ) + " to " + destDir . getAbsolutePath ( ) ) ; Enumeration enum = filecopyList . keys ( ) ; while ( enum . hasMoreElements ( ) ) { String fromFile = ( String ) enum . nextElement ( ) ; String toFile = ( String ) filecopyList . get ( fromFile ) ; try { project . copyFile ( fromFile , toFile , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } } } } private void scanDir ( File from , File to , String [ ] files ) { for ( int i = 0 ; i < files . length ; i ++ ) { String filename = files [ i ] ; File srcFile = new File ( from , filename ) ; File destFile ; if ( flatten ) { destFile = new File ( to , new File ( filename ) . getName ( ) ) ; } else { destFile = new File ( to , filename ) ; } if ( forceOverwrite || ( srcFile . lastModified ( ) > destFile . lastModified ( ) ) ) { filecopyList . put ( srcFile . getAbsolutePath ( ) , destFile . getAbsolutePath ( ) ) ; } } } } 	0	['8', '4', '0', '7', '35', '4', '0', '7', '7', '0.714285714', '265', '1', '0', '0.917647059', '0.46875', '3', '3', '31.375', '5', '1.375', '0']
package org . apache . tools . ant . taskdefs ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . Commandline ; public class GenerateKey extends Task { public static class DnameParam { private String name ; private String value ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } } public static class DistinguishedName { private String name ; private String path ; private Vector params = new Vector ( ) ; public Object createParam ( ) { DnameParam param = new DnameParam ( ) ; params . addElement ( param ) ; return param ; } public Enumeration getParams ( ) { return params . elements ( ) ; } public String toString ( ) { final int size = params . size ( ) ; final StringBuffer sb = new StringBuffer ( ) ; boolean firstPass = true ; for ( int i = 0 ; i < size ; i ++ ) { if ( ! firstPass ) { sb . append ( " ," ) ; } firstPass = false ; final DnameParam param = ( DnameParam ) params . elementAt ( i ) ; sb . append ( encode ( param . getName ( ) ) ) ; sb . append ( '=' ) ; sb . append ( encode ( param . getValue ( ) ) ) ; } return sb . toString ( ) ; } public String encode ( final String string ) { int end = string . indexOf ( ',' ) ; if ( - 1 == end ) return string ; final StringBuffer sb = new StringBuffer ( ) ; int start = 0 ; while ( - 1 != end ) { sb . append ( string . substring ( start , end ) ) ; sb . append ( "\\," ) ; start = end + 1 ; end = string . indexOf ( ',' , start ) ; } sb . append ( string . substring ( start ) ) ; return sb . toString ( ) ; } } protected String alias ; protected String keystore ; protected String storepass ; protected String storetype ; protected String keypass ; protected String sigalg ; protected String keyalg ; protected String dname ; protected DistinguishedName expandedDname ; protected int keysize ; protected int validity ; protected boolean verbose ; public DistinguishedName createDname ( ) throws BuildException { if ( null != expandedDname ) { throw new BuildException ( "DName sub-element can only be specified once." ) ; } if ( null != dname ) { throw new BuildException ( "It is not possible to specify dname both " + "as attribute and element." ) ; } expandedDname = new DistinguishedName ( ) ; return expandedDname ; } public void setDname ( final String dname ) { if ( null != expandedDname ) { throw new BuildException ( "It is not possible to specify dname both " + "as attribute and element." ) ; } this . dname = dname ; } public void setAlias ( final String alias ) { this . alias = alias ; } public void setKeystore ( final String keystore ) { this . keystore = keystore ; } public void setStorepass ( final String storepass ) { this . storepass = storepass ; } public void setStoretype ( final String storetype ) { this . storetype = storetype ; } public void setKeypass ( final String keypass ) { this . keypass = keypass ; } public void setSigalg ( final String sigalg ) { this . sigalg = sigalg ; } public void setKeyalg ( final String keyalg ) { this . keyalg = keyalg ; } public void setKeysize ( final String keysize ) throws BuildException { try { this . keysize = Integer . parseInt ( keysize ) ; } catch ( final NumberFormatException nfe ) { throw new BuildException ( "KeySize attribute should be a integer" ) ; } } public void setValidity ( final String validity ) throws BuildException { try { this . validity = Integer . parseInt ( validity ) ; } catch ( final NumberFormatException nfe ) { throw new BuildException ( "Validity attribute should be a integer" ) ; } } public void setVerbose ( final boolean verbose ) { this . verbose = verbose ; } public void execute ( ) throws BuildException { if ( project . getJavaVersion ( ) . equals ( Project . JAVA_1_1 ) ) { throw new BuildException ( "The genkey task is only available on JDK" + " versions 1.2 or greater" ) ; } if ( null == alias ) { throw new BuildException ( "alias attribute must be set" ) ; } if ( null == storepass ) { throw new BuildException ( "storepass attribute must be set" ) ; } if ( null == dname && null == expandedDname ) { throw new BuildException ( "dname must be set" ) ; } final StringBuffer sb = new StringBuffer ( ) ; sb . append ( "keytool -genkey " ) ; if ( verbose ) { sb . append ( "-v " ) ; } sb . append ( "-alias \"" ) ; sb . append ( alias ) ; sb . append ( "\" " ) ; if ( null != dname ) { sb . append ( "-dname \"" ) ; sb . append ( dname ) ; sb . append ( "\" " ) ; } if ( null != expandedDname ) { sb . append ( "-dname \"" ) ; sb . append ( expandedDname ) ; sb . append ( "\" " ) ; } if ( null != keystore ) { sb . append ( "-keystore \"" ) ; sb . append ( keystore ) ; sb . append ( "\" " ) ; } if ( null != storepass ) { sb . append ( "-storepass \"" ) ; sb . append ( storepass ) ; sb . append ( "\" " ) ; } if ( null != storetype ) { sb . append ( "-storetype \"" ) ; sb . append ( storetype ) ; sb . append ( "\" " ) ; } sb . append ( "-keypass \"" ) ; if ( null != keypass ) { sb . append ( keypass ) ; } else { sb . append ( storepass ) ; } sb . append ( "\" " ) ; if ( null != sigalg ) { sb . append ( "-sigalg \"" ) ; sb . append ( sigalg ) ; sb . append ( "\" " ) ; } if ( null != keyalg ) { sb . append ( "-keyalg \"" ) ; sb . append ( keyalg ) ; sb . append ( "\" " ) ; } if ( 0 < keysize ) { sb . append ( "-keysize \"" ) ; sb . append ( keysize ) ; sb . append ( "\" " ) ; } if ( 0 < validity ) { sb . append ( "-validity \"" ) ; sb . append ( validity ) ; sb . append ( "\" " ) ; } log ( "Generating Key for " + alias ) ; final ExecTask cmd = ( ExecTask ) project . createTask ( "exec" ) ; cmd . setCommand ( new Commandline ( sb . toString ( ) ) ) ; cmd . setFailonerror ( true ) ; cmd . setTaskName ( getTaskName ( ) ) ; cmd . execute ( ) ; } } 	1	['14', '3', '0', '7', '33', '65', '0', '7', '14', '0.91025641', '404', '1', '1', '0.74', '0.595238095', '2', '3', '27', '2', '1', '1']
package org . apache . tools . tar ; import java . io . * ; import java . util . * ; public class TarEntry implements TarConstants { private StringBuffer name ; private int mode ; private int userId ; private int groupId ; private long size ; private long modTime ; private int checkSum ; private byte linkFlag ; private StringBuffer linkName ; private StringBuffer magic ; private StringBuffer userName ; private StringBuffer groupName ; private int devMajor ; private int devMinor ; private File file ; private TarEntry ( ) { this . magic = new StringBuffer ( TMAGIC ) ; this . name = new StringBuffer ( ) ; this . linkName = new StringBuffer ( ) ; String user = System . getProperty ( "user.name" , "" ) ; if ( user . length ( ) > 31 ) { user = user . substring ( 0 , 31 ) ; } this . userId = 0 ; this . groupId = 0 ; this . userName = new StringBuffer ( user ) ; this . groupName = new StringBuffer ( "" ) ; this . file = null ; } public TarEntry ( String name ) { this ( ) ; boolean isDir = name . endsWith ( "/" ) ; this . checkSum = 0 ; this . devMajor = 0 ; this . devMinor = 0 ; this . name = new StringBuffer ( name ) ; this . mode = isDir ? 040755 : 0100644 ; this . linkFlag = isDir ? LF_DIR : LF_NORMAL ; this . userId = 0 ; this . groupId = 0 ; this . size = 0 ; this . checkSum = 0 ; this . modTime = ( new Date ( ) ) . getTime ( ) / 1000 ; this . linkName = new StringBuffer ( "" ) ; this . userName = new StringBuffer ( "" ) ; this . groupName = new StringBuffer ( "" ) ; this . devMajor = 0 ; this . devMinor = 0 ; } public TarEntry ( String name , byte linkFlag ) { this ( name ) ; this . linkFlag = linkFlag ; } public TarEntry ( File file ) { this ( ) ; this . file = file ; String name = file . getPath ( ) ; String osname = System . getProperty ( "os.name" ) ; if ( osname != null ) { String Win32Prefix = "Windows" ; String prefix = osname . substring ( 0 , Win32Prefix . length ( ) ) ; if ( prefix . equalsIgnoreCase ( Win32Prefix ) ) { if ( name . length ( ) > 2 ) { char ch1 = name . charAt ( 0 ) ; char ch2 = name . charAt ( 1 ) ; if ( ch2 == ':' && ( ( ch1 >= 'a' && ch1 <= 'z' ) || ( ch1 >= 'A' && ch1 <= 'Z' ) ) ) { name = name . substring ( 2 ) ; } } } } name = name . replace ( File . separatorChar , '/' ) ; while ( name . startsWith ( "/" ) ) { name = name . substring ( 1 ) ; } this . linkName = new StringBuffer ( "" ) ; this . name = new StringBuffer ( name ) ; if ( file . isDirectory ( ) ) { this . mode = 040755 ; this . linkFlag = LF_DIR ; if ( this . name . charAt ( this . name . length ( ) - 1 ) != '/' ) { this . name . append ( "/" ) ; } } else { this . mode = 0100644 ; this . linkFlag = LF_NORMAL ; } this . size = file . length ( ) ; this . modTime = file . lastModified ( ) / 1000 ; this . checkSum = 0 ; this . devMajor = 0 ; this . devMinor = 0 ; } public TarEntry ( byte [ ] headerBuf ) { this ( ) ; this . parseTarHeader ( headerBuf ) ; } public boolean equals ( TarEntry it ) { return this . getName ( ) . equals ( it . getName ( ) ) ; } public boolean isDescendent ( TarEntry desc ) { return desc . getName ( ) . startsWith ( this . getName ( ) ) ; } public String getName ( ) { return this . name . toString ( ) ; } public void setName ( String name ) { this . name = new StringBuffer ( name ) ; } public void setMode ( int mode ) { this . mode = mode ; } public int getUserId ( ) { return this . userId ; } public void setUserId ( int userId ) { this . userId = userId ; } public int getGroupId ( ) { return this . groupId ; } public void setGroupId ( int groupId ) { this . groupId = groupId ; } public String getUserName ( ) { return this . userName . toString ( ) ; } public void setUserName ( String userName ) { this . userName = new StringBuffer ( userName ) ; } public String getGroupName ( ) { return this . groupName . toString ( ) ; } public void setGroupName ( String groupName ) { this . groupName = new StringBuffer ( groupName ) ; } public void setIds ( int userId , int groupId ) { this . setUserId ( userId ) ; this . setGroupId ( groupId ) ; } public void setNames ( String userName , String groupName ) { this . setUserName ( userName ) ; this . setGroupName ( groupName ) ; } public void setModTime ( long time ) { this . modTime = time / 1000 ; } public void setModTime ( Date time ) { this . modTime = time . getTime ( ) / 1000 ; } public Date getModTime ( ) { return new Date ( this . modTime * 1000 ) ; } public File getFile ( ) { return this . file ; } public long getSize ( ) { return this . size ; } public void setSize ( long size ) { this . size = size ; } public boolean isGNULongNameEntry ( ) { return linkFlag == LF_GNUTYPE_LONGNAME && name . toString ( ) . equals ( GNU_LONGLINK ) ; } public boolean isDirectory ( ) { if ( this . file != null ) { return this . file . isDirectory ( ) ; } if ( this . linkFlag == LF_DIR ) { return true ; } if ( this . getName ( ) . endsWith ( "/" ) ) { return true ; } return false ; } public TarEntry [ ] getDirectoryEntries ( ) { if ( this . file == null || ! this . file . isDirectory ( ) ) { return new TarEntry [ 0 ] ; } String [ ] list = this . file . list ( ) ; TarEntry [ ] result = new TarEntry [ list . length ] ; for ( int i = 0 ; i < list . length ; ++ i ) { result [ i ] = new TarEntry ( new File ( this . file , list [ i ] ) ) ; } return result ; } public void writeEntryHeader ( byte [ ] outbuf ) { int offset = 0 ; offset = TarUtils . getNameBytes ( this . name , outbuf , offset , NAMELEN ) ; offset = TarUtils . getOctalBytes ( this . mode , outbuf , offset , MODELEN ) ; offset = TarUtils . getOctalBytes ( this . userId , outbuf , offset , UIDLEN ) ; offset = TarUtils . getOctalBytes ( this . groupId , outbuf , offset , GIDLEN ) ; offset = TarUtils . getLongOctalBytes ( this . size , outbuf , offset , SIZELEN ) ; offset = TarUtils . getLongOctalBytes ( this . modTime , outbuf , offset , MODTIMELEN ) ; int csOffset = offset ; for ( int c = 0 ; c < CHKSUMLEN ; ++ c ) { outbuf [ offset ++ ] = ( byte ) ' ' ; } outbuf [ offset ++ ] = this . linkFlag ; offset = TarUtils . getNameBytes ( this . linkName , outbuf , offset , NAMELEN ) ; offset = TarUtils . getNameBytes ( this . magic , outbuf , offset , MAGICLEN ) ; offset = TarUtils . getNameBytes ( this . userName , outbuf , offset , UNAMELEN ) ; offset = TarUtils . getNameBytes ( this . groupName , outbuf , offset , GNAMELEN ) ; offset = TarUtils . getOctalBytes ( this . devMajor , outbuf , offset , DEVLEN ) ; offset = TarUtils . getOctalBytes ( this . devMinor , outbuf , offset , DEVLEN ) ; while ( offset < outbuf . length ) { outbuf [ offset ++ ] = 0 ; } long checkSum = TarUtils . computeCheckSum ( outbuf ) ; TarUtils . getCheckSumOctalBytes ( checkSum , outbuf , csOffset , CHKSUMLEN ) ; } public void parseTarHeader ( byte [ ] header ) { int offset = 0 ; this . name = TarUtils . parseName ( header , offset , NAMELEN ) ; offset += NAMELEN ; this . mode = ( int ) TarUtils . parseOctal ( header , offset , MODELEN ) ; offset += MODELEN ; this . userId = ( int ) TarUtils . parseOctal ( header , offset , UIDLEN ) ; offset += UIDLEN ; this . groupId = ( int ) TarUtils . parseOctal ( header , offset , GIDLEN ) ; offset += GIDLEN ; this . size = TarUtils . parseOctal ( header , offset , SIZELEN ) ; offset += SIZELEN ; this . modTime = TarUtils . parseOctal ( header , offset , MODTIMELEN ) ; offset += MODTIMELEN ; this . checkSum = ( int ) TarUtils . parseOctal ( header , offset , CHKSUMLEN ) ; offset += CHKSUMLEN ; this . linkFlag = header [ offset ++ ] ; this . linkName = TarUtils . parseName ( header , offset , NAMELEN ) ; offset += NAMELEN ; this . magic = TarUtils . parseName ( header , offset , MAGICLEN ) ; offset += MAGICLEN ; this . userName = TarUtils . parseName ( header , offset , UNAMELEN ) ; offset += UNAMELEN ; this . groupName = TarUtils . parseName ( header , offset , GNAMELEN ) ; offset += GNAMELEN ; this . devMajor = ( int ) TarUtils . parseOctal ( header , offset , DEVLEN ) ; offset += DEVLEN ; this . devMinor = ( int ) TarUtils . parseOctal ( header , offset , DEVLEN ) ; } } 	0	['31', '1', '0', '6', '65', '243', '4', '2', '30', '0.726666667', '747', '1', '0', '0', '0.182795699', '1', '1', '22.61290323', '4', '1.1613', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . BufferedReader ; import java . io . StringReader ; import java . io . ByteArrayOutputStream ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . Vector ; public class Execute { public final static int INVALID = Integer . MAX_VALUE ; private String [ ] cmdl = null ; private String [ ] env = null ; private int exitValue = INVALID ; private ExecuteStreamHandler streamHandler ; private ExecuteWatchdog watchdog ; private File workingDirectory = null ; private Project project = null ; private boolean newEnvironment = false ; private boolean useVMLauncher = true ; private static String antWorkingDirectory = System . getProperty ( "user.dir" ) ; private static CommandLauncher vmLauncher = null ; private static CommandLauncher shellLauncher = null ; private static Vector procEnvironment = null ; static { try { vmLauncher = new Java13CommandLauncher ( ) ; } catch ( NoSuchMethodException exc ) { } String osname = System . getProperty ( "os.name" ) . toLowerCase ( ) ; if ( osname . indexOf ( "mac os" ) >= 0 ) { shellLauncher = new MacCommandLauncher ( new CommandLauncher ( ) ) ; } else if ( osname . indexOf ( "os/2" ) >= 0 ) { shellLauncher = new WinNTCommandLauncher ( new CommandLauncher ( ) ) ; } else if ( osname . indexOf ( "windows" ) >= 0 ) { CommandLauncher baseLauncher ; if ( System . getProperty ( "java.version" ) . startsWith ( "1.1" ) ) { baseLauncher = new Java11CommandLauncher ( ) ; } else { baseLauncher = new CommandLauncher ( ) ; } if ( osname . indexOf ( "nt" ) >= 0 || osname . indexOf ( "2000" ) >= 0 ) { shellLauncher = new WinNTCommandLauncher ( baseLauncher ) ; } else { shellLauncher = new ScriptCommandLauncher ( "bin/antRun.bat" , baseLauncher ) ; } } else { shellLauncher = new ScriptCommandLauncher ( "bin/antRun" , new CommandLauncher ( ) ) ; } } public static synchronized Vector getProcEnvironment ( ) { if ( procEnvironment != null ) return procEnvironment ; procEnvironment = new Vector ( ) ; try { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; Execute exe = new Execute ( new PumpStreamHandler ( out ) ) ; exe . setCommandline ( getProcEnvCommand ( ) ) ; exe . setNewenvironment ( true ) ; int retval = exe . execute ( ) ; if ( retval != 0 ) { } BufferedReader in = new BufferedReader ( new StringReader ( out . toString ( ) ) ) ; String var = null ; String line , lineSep = System . getProperty ( "line.separator" ) ; while ( ( line = in . readLine ( ) ) != null ) { if ( line . indexOf ( '=' ) == - 1 ) { if ( var == null ) { var = lineSep + line ; } else { var += lineSep + line ; } } else { if ( var != null ) { procEnvironment . addElement ( var ) ; } var = line ; } } procEnvironment . addElement ( var ) ; } catch ( java . io . IOException exc ) { exc . printStackTrace ( ) ; } return procEnvironment ; } private static String [ ] getProcEnvCommand ( ) { String osname = System . getProperty ( "os.name" ) . toLowerCase ( ) ; if ( osname . indexOf ( "mac os" ) >= 0 ) { try { String version = System . getProperty ( "os.version" ) ; int majorVersion = Integer . parseInt ( version . substring ( 0 , version . indexOf ( '.' ) ) ) ; if ( majorVersion >= 10 ) { String [ ] cmd = { "/usr/bin/env" } ; return cmd ; } } catch ( NumberFormatException e ) { } String [ ] cmd = null ; return cmd ; } else if ( osname . indexOf ( "os/2" ) >= 0 ) { String [ ] cmd = { "cmd" , "/c" , "set" } ; return cmd ; } else if ( osname . indexOf ( "indows" ) >= 0 ) { if ( osname . indexOf ( "nt" ) >= 0 || osname . indexOf ( "2000" ) >= 0 ) { String [ ] cmd = { "cmd" , "/c" , "set" } ; return cmd ; } else { String [ ] cmd = { "command.com" , "/c" , "set" } ; return cmd ; } } else { String [ ] cmd = { "/usr/bin/env" } ; return cmd ; } } public Execute ( ) { this ( new PumpStreamHandler ( ) , null ) ; } public Execute ( ExecuteStreamHandler streamHandler ) { this ( streamHandler , null ) ; } public Execute ( ExecuteStreamHandler streamHandler , ExecuteWatchdog watchdog ) { this . streamHandler = streamHandler ; this . watchdog = watchdog ; } public String [ ] getCommandline ( ) { return cmdl ; } public void setCommandline ( String [ ] commandline ) { cmdl = commandline ; } public void setNewenvironment ( boolean newenv ) { newEnvironment = newenv ; } public String [ ] getEnvironment ( ) { if ( env == null || newEnvironment ) return env ; return patchEnvironment ( ) ; } public void setEnvironment ( String [ ] env ) { this . env = env ; } public void setWorkingDirectory ( File wd ) { if ( wd == null || wd . getAbsolutePath ( ) . equals ( antWorkingDirectory ) ) workingDirectory = null ; else workingDirectory = wd ; } public void setAntRun ( Project project ) throws BuildException { this . project = project ; } public void setVMLauncher ( boolean useVMLauncher ) { this . useVMLauncher = useVMLauncher ; } public int execute ( ) throws IOException { CommandLauncher launcher = vmLauncher != null ? vmLauncher : shellLauncher ; if ( ! useVMLauncher ) { launcher = shellLauncher ; } final Process process = launcher . exec ( project , getCommandline ( ) , getEnvironment ( ) , workingDirectory ) ; try { streamHandler . setProcessInputStream ( process . getOutputStream ( ) ) ; streamHandler . setProcessOutputStream ( process . getInputStream ( ) ) ; streamHandler . setProcessErrorStream ( process . getErrorStream ( ) ) ; } catch ( IOException e ) { process . destroy ( ) ; throw e ; } streamHandler . start ( ) ; if ( watchdog != null ) watchdog . start ( process ) ; waitFor ( process ) ; if ( watchdog != null ) watchdog . stop ( ) ; streamHandler . stop ( ) ; if ( watchdog != null ) watchdog . checkException ( ) ; return getExitValue ( ) ; } protected void waitFor ( Process process ) { try { process . waitFor ( ) ; setExitValue ( process . exitValue ( ) ) ; } catch ( InterruptedException e ) { } } protected void setExitValue ( int value ) { exitValue = value ; } public int getExitValue ( ) { return exitValue ; } private String [ ] patchEnvironment ( ) { Vector osEnv = ( Vector ) getProcEnvironment ( ) . clone ( ) ; for ( int i = 0 ; i < env . length ; i ++ ) { int pos = env [ i ] . indexOf ( '=' ) ; String key = env [ i ] . substring ( 0 , pos + 1 ) ; int size = osEnv . size ( ) ; for ( int j = 0 ; j < size ; j ++ ) { if ( ( ( String ) osEnv . elementAt ( j ) ) . startsWith ( key ) ) { osEnv . removeElementAt ( j ) ; break ; } } osEnv . addElement ( env [ i ] ) ; } String [ ] result = new String [ osEnv . size ( ) ] ; osEnv . copyInto ( result ) ; return result ; } public static void runCommand ( Task task , String [ ] cmdline ) throws BuildException { try { task . log ( Commandline . toString ( cmdline ) , Project . MSG_VERBOSE ) ; Execute exe = new Execute ( new LogStreamHandler ( task , Project . MSG_INFO , Project . MSG_ERR ) ) ; exe . setAntRun ( task . getProject ( ) ) ; exe . setCommandline ( cmdline ) ; int retval = exe . execute ( ) ; if ( retval != 0 ) { throw new BuildException ( cmdline [ 0 ] + " failed with return code " + retval , task . getLocation ( ) ) ; } } catch ( java . io . IOException exc ) { throw new BuildException ( "Could not launch " + cmdline [ 0 ] + ": " + exc , task . getLocation ( ) ) ; } } private static class CommandLauncher { public Process exec ( Project project , String [ ] cmd , String [ ] env ) throws IOException { if ( project != null ) { project . log ( "Execute:CommandLauncher: " + Commandline . toString ( cmd ) , Project . MSG_DEBUG ) ; } return Runtime . getRuntime ( ) . exec ( cmd , env ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } throw new IOException ( "Cannot execute a process in different directory under this JVM" ) ; } } private static class Java11CommandLauncher extends CommandLauncher { public Process exec ( Project project , String [ ] cmd , String [ ] env ) throws IOException { String [ ] newcmd = new String [ cmd . length ] ; for ( int i = 0 ; i < cmd . length ; i ++ ) { newcmd [ i ] = Commandline . quoteArgument ( cmd [ i ] ) ; } if ( project != null ) { project . log ( "Execute:Java11CommandLauncher: " + Commandline . toString ( newcmd ) , Project . MSG_DEBUG ) ; } return Runtime . getRuntime ( ) . exec ( newcmd , env ) ; } } private static class Java13CommandLauncher extends CommandLauncher { public Java13CommandLauncher ( ) throws NoSuchMethodException { _execWithCWD = Runtime . class . getMethod ( "exec" , new Class [ ] { String [ ] . class , String [ ] . class , File . class } ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { try { if ( project != null ) { project . log ( "Execute:Java13CommandLauncher: " + Commandline . toString ( cmd ) , Project . MSG_DEBUG ) ; } Object [ ] arguments = { cmd , env , workingDir } ; return ( Process ) _execWithCWD . invoke ( Runtime . getRuntime ( ) , arguments ) ; } catch ( InvocationTargetException exc ) { Throwable realexc = exc . getTargetException ( ) ; if ( realexc instanceof ThreadDeath ) { throw ( ThreadDeath ) realexc ; } else if ( realexc instanceof IOException ) { throw ( IOException ) realexc ; } else { throw new BuildException ( "Unable to execute command" , realexc ) ; } } catch ( Exception exc ) { throw new BuildException ( "Unable to execute command" , exc ) ; } } private Method _execWithCWD ; } private static class CommandLauncherProxy extends CommandLauncher { CommandLauncherProxy ( CommandLauncher launcher ) { _launcher = launcher ; } public Process exec ( Project project , String [ ] cmd , String [ ] env ) throws IOException { return _launcher . exec ( project , cmd , env ) ; } private CommandLauncher _launcher ; } private static class WinNTCommandLauncher extends CommandLauncherProxy { WinNTCommandLauncher ( CommandLauncher launcher ) { super ( launcher ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { File commandDir = workingDir ; if ( workingDir == null ) { if ( project != null ) { commandDir = project . getBaseDir ( ) ; } else { return exec ( project , cmd , env ) ; } } final int preCmdLength = 6 ; String [ ] newcmd = new String [ cmd . length + preCmdLength ] ; newcmd [ 0 ] = "cmd" ; newcmd [ 1 ] = "/c" ; newcmd [ 2 ] = "cd" ; newcmd [ 3 ] = "/d" ; newcmd [ 4 ] = commandDir . getAbsolutePath ( ) ; newcmd [ 5 ] = "&&" ; System . arraycopy ( cmd , 0 , newcmd , preCmdLength , cmd . length ) ; return exec ( project , newcmd , env ) ; } } private static class MacCommandLauncher extends CommandLauncherProxy { MacCommandLauncher ( CommandLauncher launcher ) { super ( launcher ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } System . getProperties ( ) . put ( "user.dir" , workingDir . getAbsolutePath ( ) ) ; try { return exec ( project , cmd , env ) ; } finally { System . getProperties ( ) . put ( "user.dir" , antWorkingDirectory ) ; } } } private static class ScriptCommandLauncher extends CommandLauncherProxy { ScriptCommandLauncher ( String script , CommandLauncher launcher ) { super ( launcher ) ; _script = script ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( project == null ) { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } throw new IOException ( "Cannot locate antRun script: No project provided" ) ; } String antHome = project . getProperty ( "ant.home" ) ; if ( antHome == null ) { throw new IOException ( "Cannot locate antRun script: Property 'ant.home' not found" ) ; } String antRun = project . resolveFile ( antHome + File . separator + _script ) . toString ( ) ; File commandDir = workingDir ; if ( workingDir == null && project != null ) { commandDir = project . getBaseDir ( ) ; } String [ ] newcmd = new String [ cmd . length + 2 ] ; newcmd [ 0 ] = antRun ; newcmd [ 1 ] = commandDir . getAbsolutePath ( ) ; System . arraycopy ( cmd , 0 , newcmd , 2 , cmd . length ) ; return exec ( project , newcmd , env ) ; } private String _script ; } } 	1	['21', '1', '0', '27', '78', '158', '11', '17', '15', '0.735714286', '659', '0.928571429', '5', '0', '0.145', '0', '0', '29.71428571', '7', '1.6667', '1']
package org . apache . tools . tar ; import java . io . * ; public class TarOutputStream extends FilterOutputStream { static public final int LONGFILE_ERROR = 0 ; static public final int LONGFILE_TRUNCATE = 1 ; static public final int LONGFILE_GNU = 2 ; protected boolean debug ; protected int currSize ; protected int currBytes ; protected byte [ ] oneBuf ; protected byte [ ] recordBuf ; protected int assemLen ; protected byte [ ] assemBuf ; protected TarBuffer buffer ; protected int longFileMode = LONGFILE_ERROR ; public TarOutputStream ( OutputStream os ) { this ( os , TarBuffer . DEFAULT_BLKSIZE , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarOutputStream ( OutputStream os , int blockSize ) { this ( os , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarOutputStream ( OutputStream os , int blockSize , int recordSize ) { super ( os ) ; this . buffer = new TarBuffer ( os , blockSize , recordSize ) ; this . debug = false ; this . assemLen = 0 ; this . assemBuf = new byte [ recordSize ] ; this . recordBuf = new byte [ recordSize ] ; this . oneBuf = new byte [ 1 ] ; } public void setLongFileMode ( int longFileMode ) { this . longFileMode = longFileMode ; } public void setDebug ( boolean debugF ) { this . debug = debugF ; } public void setBufferDebug ( boolean debug ) { this . buffer . setDebug ( debug ) ; } public void finish ( ) throws IOException { this . writeEOFRecord ( ) ; } public void close ( ) throws IOException { this . finish ( ) ; this . buffer . close ( ) ; } public int getRecordSize ( ) { return this . buffer . getRecordSize ( ) ; } public void putNextEntry ( TarEntry entry ) throws IOException { if ( entry . getName ( ) . length ( ) >= TarConstants . NAMELEN ) { if ( longFileMode == LONGFILE_GNU ) { TarEntry longLinkEntry = new TarEntry ( TarConstants . GNU_LONGLINK , TarConstants . LF_GNUTYPE_LONGNAME ) ; longLinkEntry . setSize ( entry . getName ( ) . length ( ) + 1 ) ; putNextEntry ( longLinkEntry ) ; write ( entry . getName ( ) . getBytes ( ) ) ; write ( 0 ) ; closeEntry ( ) ; } else if ( longFileMode != LONGFILE_TRUNCATE ) { throw new RuntimeException ( "file name '" + entry . getName ( ) + "' is too long ( > " + TarConstants . NAMELEN + " bytes)" ) ; } } entry . writeEntryHeader ( this . recordBuf ) ; this . buffer . writeRecord ( this . recordBuf ) ; this . currBytes = 0 ; if ( entry . isDirectory ( ) ) { this . currSize = 0 ; } else { this . currSize = ( int ) entry . getSize ( ) ; } } public void closeEntry ( ) throws IOException { if ( this . assemLen > 0 ) { for ( int i = this . assemLen ; i < this . assemBuf . length ; ++ i ) { this . assemBuf [ i ] = 0 ; } this . buffer . writeRecord ( this . assemBuf ) ; this . currBytes += this . assemLen ; this . assemLen = 0 ; } if ( this . currBytes < this . currSize ) { throw new IOException ( "entry closed at '" + this . currBytes + "' before the '" + this . currSize + "' bytes specified in the header were written" ) ; } } public void write ( int b ) throws IOException { this . oneBuf [ 0 ] = ( byte ) b ; this . write ( this . oneBuf , 0 , 1 ) ; } public void write ( byte [ ] wBuf ) throws IOException { this . write ( wBuf , 0 , wBuf . length ) ; } public void write ( byte [ ] wBuf , int wOffset , int numToWrite ) throws IOException { if ( ( this . currBytes + numToWrite ) > this . currSize ) { throw new IOException ( "request to write '" + numToWrite + "' bytes exceeds size in header of '" + this . currSize + "' bytes" ) ; } if ( this . assemLen > 0 ) { if ( ( this . assemLen + numToWrite ) >= this . recordBuf . length ) { int aLen = this . recordBuf . length - this . assemLen ; System . arraycopy ( this . assemBuf , 0 , this . recordBuf , 0 , this . assemLen ) ; System . arraycopy ( wBuf , wOffset , this . recordBuf , this . assemLen , aLen ) ; this . buffer . writeRecord ( this . recordBuf ) ; this . currBytes += this . recordBuf . length ; wOffset += aLen ; numToWrite -= aLen ; this . assemLen = 0 ; } else { System . arraycopy ( wBuf , wOffset , this . assemBuf , this . assemLen , numToWrite ) ; wOffset += numToWrite ; this . assemLen += numToWrite ; numToWrite -= numToWrite ; } } while ( numToWrite > 0 ) { if ( numToWrite < this . recordBuf . length ) { System . arraycopy ( wBuf , wOffset , this . assemBuf , this . assemLen , numToWrite ) ; this . assemLen += numToWrite ; break ; } this . buffer . writeRecord ( wBuf , wOffset ) ; int num = this . recordBuf . length ; this . currBytes += num ; numToWrite -= num ; wOffset += num ; } } private void writeEOFRecord ( ) throws IOException { for ( int i = 0 ; i < this . recordBuf . length ; ++ i ) { this . recordBuf [ i ] = 0 ; } this . buffer . writeRecord ( this . recordBuf ) ; } } 	0	['15', '3', '0', '3', '37', '41', '1', '2', '14', '0.696428571', '437', '0.75', '1', '0.454545455', '0.311111111', '1', '2', '27.33333333', '1', '0.8', '0']
package org . apache . tools . ant ; import java . io . * ; public class DefaultLogger implements BuildLogger { private static int LEFT_COLUMN_SIZE = 12 ; protected PrintStream out ; protected PrintStream err ; protected int msgOutputLevel = Project . MSG_ERR ; private long startTime = System . currentTimeMillis ( ) ; protected static String lSep = System . getProperty ( "line.separator" ) ; protected boolean emacsMode = false ; public void setMessageOutputLevel ( int level ) { this . msgOutputLevel = level ; } public void setOutputPrintStream ( PrintStream output ) { this . out = output ; } public void setErrorPrintStream ( PrintStream err ) { this . err = err ; } public void setEmacsMode ( boolean emacsMode ) { this . emacsMode = emacsMode ; } public void buildStarted ( BuildEvent event ) { startTime = System . currentTimeMillis ( ) ; } public void buildFinished ( BuildEvent event ) { Throwable error = event . getException ( ) ; if ( error == null ) { out . println ( lSep + "BUILD SUCCESSFUL" ) ; } else { err . println ( lSep + "BUILD FAILED" + lSep ) ; if ( Project . MSG_VERBOSE <= msgOutputLevel || ! ( error instanceof BuildException ) ) { error . printStackTrace ( err ) ; } else { if ( error instanceof BuildException ) { err . println ( error . toString ( ) ) ; } else { err . println ( error . getMessage ( ) ) ; } } } out . println ( lSep + "Total time: " + formatTime ( System . currentTimeMillis ( ) - startTime ) ) ; } public void targetStarted ( BuildEvent event ) { if ( Project . MSG_INFO <= msgOutputLevel ) { out . println ( lSep + event . getTarget ( ) . getName ( ) + ":" ) ; } } public void targetFinished ( BuildEvent event ) { } public void taskStarted ( BuildEvent event ) { } public void taskFinished ( BuildEvent event ) { } public void messageLogged ( BuildEvent event ) { PrintStream logTo = event . getPriority ( ) == Project . MSG_ERR ? err : out ; if ( event . getPriority ( ) <= msgOutputLevel ) { if ( event . getTask ( ) != null ) { String name = event . getTask ( ) . getTaskName ( ) ; if ( ! emacsMode ) { String msg = "[" + name + "] " ; for ( int i = 0 ; i < ( LEFT_COLUMN_SIZE - msg . length ( ) ) ; i ++ ) { logTo . print ( " " ) ; } logTo . print ( msg ) ; } } logTo . println ( event . getMessage ( ) ) ; } } protected static String formatTime ( long millis ) { long seconds = millis / 1000 ; long minutes = seconds / 60 ; if ( minutes > 0 ) { return Long . toString ( minutes ) + " minute" + ( minutes == 1 ? " " : "s " ) + Long . toString ( seconds % 60 ) + " second" + ( seconds % 60 == 1 ? "" : "s" ) ; } else { return Long . toString ( seconds ) + " second" + ( seconds % 60 == 1 ? "" : "s" ) ; } } } 	1	['14', '1', '1', '9', '34', '47', '4', '5', '12', '0.824175824', '279', '1', '0', '0', '0.307692308', '0', '0', '18.42857143', '6', '1.8571', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; public class JikesOutputParser implements ExecuteStreamHandler { protected Task task ; protected boolean errorFlag = false ; protected int errors , warnings ; protected boolean error = false ; protected boolean emacsMode ; protected BufferedReader br ; public void setProcessInputStream ( OutputStream os ) { } public void setProcessErrorStream ( InputStream is ) { } public void setProcessOutputStream ( InputStream is ) throws IOException { br = new BufferedReader ( new InputStreamReader ( is ) ) ; } public void start ( ) throws IOException { parseOutput ( br ) ; } public void stop ( ) { } protected JikesOutputParser ( Task task , boolean emacsMode ) { super ( ) ; this . task = task ; this . emacsMode = emacsMode ; } protected void parseOutput ( BufferedReader reader ) throws IOException { if ( emacsMode ) parseEmacsOutput ( reader ) ; else parseStandardOutput ( reader ) ; } private void parseStandardOutput ( BufferedReader reader ) throws IOException { String line ; String lower ; while ( ( line = reader . readLine ( ) ) != null ) { lower = line . toLowerCase ( ) ; if ( line . trim ( ) . equals ( "" ) ) continue ; if ( lower . indexOf ( "error" ) != - 1 ) setError ( true ) ; else if ( lower . indexOf ( "warning" ) != - 1 ) setError ( false ) ; else { if ( emacsMode ) setError ( true ) ; } log ( line ) ; } } private void parseEmacsOutput ( BufferedReader reader ) throws IOException { parseStandardOutput ( reader ) ; } private void setError ( boolean err ) { error = err ; if ( error ) errorFlag = true ; } private void log ( String line ) { if ( ! emacsMode ) { task . log ( "" , ( error ? Project . MSG_ERR : Project . MSG_WARN ) ) ; } task . log ( line , ( error ? Project . MSG_ERR : Project . MSG_WARN ) ) ; } protected boolean getErrorFlag ( ) { return errorFlag ; } } 	0	['12', '1', '0', '3', '21', '44', '1', '2', '5', '0.805194805', '147', '1', '1', '0', '0.261904762', '0', '0', '10.66666667', '4', '1.25', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; public interface Condition { public boolean eval ( ) throws BuildException ; } 	1	['1', '1', '0', '9', '1', '0', '8', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . * ; public class Sj extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using symantec java compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupJavacCommand ( ) ; cmd . setExecutable ( "sj" ) ; int firstFileName = cmd . size ( ) - compileList . length ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } } 	0	['2', '2', '0', '6', '9', '1', '1', '5', '2', '2', '33', '0', '0', '0.958333333', '1', '0', '0', '15.5', '1', '0.5', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . Project ; public class Description extends DataType { public void addText ( String text ) { String currentDescription = project . getDescription ( ) ; if ( currentDescription == null ) { project . setDescription ( text ) ; } else { project . setDescription ( currentDescription + text ) ; } } } 	1	['2', '3', '0', '3', '8', '1', '0', '3', '2', '2', '28', '0', '0', '0.967741935', '0.75', '0', '0', '13', '2', '1', '1']
package org . apache . tools . ant . taskdefs ; import java . util . Enumeration ; import java . util . Properties ; import java . io . File ; import java . io . FileInputStream ; import org . apache . tools . ant . * ; public class Filter extends Task { private String token ; private String value ; private File filtersFile ; public void setToken ( String token ) { this . token = token ; } public void setValue ( String value ) { this . value = value ; } public void setFiltersfile ( File filtersFile ) { this . filtersFile = filtersFile ; } public void execute ( ) throws BuildException { boolean isFiltersFromFile = filtersFile != null && token == null && value == null ; boolean isSingleFilter = filtersFile == null && token != null && value != null ; if ( ! isFiltersFromFile && ! isSingleFilter ) { throw new BuildException ( "both token and value parameters, or only a filtersFile parameter is required" , location ) ; } if ( isSingleFilter ) { project . getGlobalFilterSet ( ) . addFilter ( token , value ) ; } if ( isFiltersFromFile ) { readFilters ( ) ; } } protected void readFilters ( ) throws BuildException { log ( "Reading filters from " + filtersFile , Project . MSG_VERBOSE ) ; project . getGlobalFilterSet ( ) . readFiltersFromFile ( filtersFile ) ; } } 	0	['6', '3', '0', '6', '16', '5', '0', '6', '5', '0.733333333', '95', '1', '0', '0.880952381', '0.5', '0', '0', '14.33333333', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; public class Equals implements Condition { private String arg1 , arg2 ; public void setArg1 ( String a1 ) { arg1 = a1 ; } public void setArg2 ( String a2 ) { arg2 = a2 ; } public boolean eval ( ) throws BuildException { if ( arg1 == null || arg2 == null ) { throw new BuildException ( "both arg1 and arg2 are required in equals" ) ; } return arg1 . equals ( arg2 ) ; } } 	1	['4', '1', '0', '3', '7', '2', '1', '2', '4', '0.666666667', '34', '1', '0', '0', '0.75', '0', '0', '7', '1', '0.75', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . EnumeratedAttribute ; import java . io . * ; public class Echo extends Task { protected String message = "" ; protected File file = null ; protected boolean append = false ; protected int logLevel = Project . MSG_WARN ; public void execute ( ) throws BuildException { if ( file == null ) { log ( message , logLevel ) ; } else { FileWriter out = null ; try { out = new FileWriter ( file . getAbsolutePath ( ) , append ) ; out . write ( message , 0 , message . length ( ) ) ; } catch ( IOException ioe ) { throw new BuildException ( ioe , location ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( IOException ioex ) { } } } } } public void setMessage ( String msg ) { this . message = msg ; } public void setFile ( File file ) { this . file = file ; } public void setAppend ( boolean append ) { this . append = append ; } public void addText ( String msg ) { message += ProjectHelper . replaceProperties ( project , msg , project . getProperties ( ) ) ; } public void setLevel ( EchoLevel echoLevel ) { String option = echoLevel . getValue ( ) ; if ( option . equals ( "error" ) ) { logLevel = Project . MSG_ERR ; } else if ( option . equals ( "warning" ) ) { logLevel = Project . MSG_WARN ; } else if ( option . equals ( "info" ) ) { logLevel = Project . MSG_INFO ; } else if ( option . equals ( "verbose" ) ) { logLevel = Project . MSG_VERBOSE ; } else { logLevel = Project . MSG_DEBUG ; } } public static class EchoLevel extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "error" , "warning" , "info" , "verbose" , "debug" } ; } } } 	0	['7', '3', '0', '8', '22', '0', '0', '8', '7', '0.625', '147', '1', '0', '0.860465116', '0.342857143', '1', '1', '19.42857143', '5', '1.4286', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; public class Not extends ConditionBase implements Condition { public boolean eval ( ) throws BuildException { if ( countConditions ( ) > 1 ) { throw new BuildException ( "You must not nest more than one condition into <not>" ) ; } if ( countConditions ( ) < 1 ) { throw new BuildException ( "You must nest a condition into <not>" ) ; } return ! ( ( Condition ) getConditions ( ) . nextElement ( ) ) . eval ( ) ; } } 	1	['2', '3', '0', '3', '8', '1', '1', '3', '2', '2', '33', '0', '0', '0.96969697', '1', '0', '0', '15.5', '1', '0.5', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . util . * ; import java . text . * ; import java . lang . RuntimeException ; public class Parallel extends Task implements TaskContainer { private Vector nestedTasks = new Vector ( ) ; public void addTask ( Task nestedTask ) throws BuildException { nestedTasks . addElement ( nestedTask ) ; } public void execute ( ) throws BuildException { TaskThread [ ] threads = new TaskThread [ nestedTasks . size ( ) ] ; int threadNumber = 0 ; for ( Enumeration e = nestedTasks . elements ( ) ; e . hasMoreElements ( ) ; threadNumber ++ ) { Task nestedTask = ( Task ) e . nextElement ( ) ; threads [ threadNumber ] = new TaskThread ( threadNumber , nestedTask ) ; } for ( int i = 0 ; i < threads . length ; ++ i ) { threads [ i ] . start ( ) ; } for ( int i = 0 ; i < threads . length ; ++ i ) { try { threads [ i ] . join ( ) ; } catch ( InterruptedException ie ) { } } StringBuffer exceptionMessage = new StringBuffer ( ) ; String lSep = System . getProperty ( "line.separator" ) ; int numExceptions = 0 ; Throwable firstException = null ; Location firstLocation = Location . UNKNOWN_LOCATION ; ; for ( int i = 0 ; i < threads . length ; ++ i ) { Throwable t = threads [ i ] . getException ( ) ; if ( t != null ) { numExceptions ++ ; if ( firstException == null ) { firstException = t ; } if ( t instanceof BuildException && firstLocation == Location . UNKNOWN_LOCATION ) { firstLocation = ( ( BuildException ) t ) . getLocation ( ) ; } exceptionMessage . append ( lSep ) ; exceptionMessage . append ( t . getMessage ( ) ) ; } } if ( numExceptions == 1 ) { if ( firstException instanceof BuildException ) { throw ( BuildException ) firstException ; } else { throw new BuildException ( firstException ) ; } } else if ( numExceptions > 1 ) { throw new BuildException ( exceptionMessage . toString ( ) , firstLocation ) ; } } class TaskThread extends Thread { private Throwable exception ; private Task task ; private int taskNumber ; TaskThread ( int taskNumber , Task task ) { this . task = task ; this . taskNumber = taskNumber ; } public void run ( ) { try { task . perform ( ) ; } catch ( Throwable t ) { exception = t ; } } public Throwable getException ( ) { return exception ; } } } 	0	['3', '3', '0', '5', '22', '0', '1', '5', '3', '0', '149', '1', '0', '0.948717949', '0.666666667', '0', '0', '48.33333333', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; public class Exit extends Task { private String message ; public void setMessage ( String value ) { this . message = value ; } public void execute ( ) throws BuildException { if ( message != null && message . length ( ) > 0 ) { throw new BuildException ( message ) ; } else { throw new BuildException ( "No message" ) ; } } public void addText ( String msg ) { message += ProjectHelper . replaceProperties ( project , msg , project . getProperties ( ) ) ; } } 	1	['4', '3', '0', '5', '12', '0', '0', '5', '4', '0.333333333', '48', '1', '0', '0.925', '0.75', '0', '0', '10.75', '1', '0.75', '2']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import java . io . File ; import java . util . Vector ; import java . util . StringTokenizer ; public class Commandline implements Cloneable { private Vector arguments = new Vector ( ) ; private String executable = null ; public Commandline ( String to_process ) { super ( ) ; String [ ] tmp = translateCommandline ( to_process ) ; if ( tmp != null && tmp . length > 0 ) { setExecutable ( tmp [ 0 ] ) ; for ( int i = 1 ; i < tmp . length ; i ++ ) { createArgument ( ) . setValue ( tmp [ i ] ) ; } } } public Commandline ( ) { super ( ) ; } public class Argument { private String [ ] parts ; public void setValue ( String value ) { parts = new String [ ] { value } ; } public void setLine ( String line ) { parts = translateCommandline ( line ) ; } public void setPath ( Path value ) { parts = new String [ ] { value . toString ( ) } ; } public void setFile ( File value ) { parts = new String [ ] { value . getAbsolutePath ( ) } ; } public String [ ] getParts ( ) { return parts ; } } public class Marker { private int position ; private int realPos = - 1 ; Marker ( int position ) { this . position = position ; } public int getPosition ( ) { if ( realPos == - 1 ) { realPos = ( executable == null ? 0 : 1 ) ; for ( int i = 0 ; i < position ; i ++ ) { Argument arg = ( Argument ) arguments . elementAt ( i ) ; realPos += arg . getParts ( ) . length ; } } return realPos ; } } public Argument createArgument ( ) { Argument argument = new Argument ( ) ; arguments . addElement ( argument ) ; return argument ; } public void setExecutable ( String executable ) { if ( executable == null || executable . length ( ) == 0 ) return ; this . executable = executable . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; } public String getExecutable ( ) { return executable ; } public void addArguments ( String [ ] line ) { for ( int i = 0 ; i < line . length ; i ++ ) { createArgument ( ) . setValue ( line [ i ] ) ; } } public String [ ] getCommandline ( ) { final String [ ] args = getArguments ( ) ; if ( executable == null ) return args ; final String [ ] result = new String [ args . length + 1 ] ; result [ 0 ] = executable ; System . arraycopy ( args , 0 , result , 1 , args . length ) ; return result ; } public String [ ] getArguments ( ) { Vector result = new Vector ( arguments . size ( ) * 2 ) ; for ( int i = 0 ; i < arguments . size ( ) ; i ++ ) { Argument arg = ( Argument ) arguments . elementAt ( i ) ; String [ ] s = arg . getParts ( ) ; for ( int j = 0 ; j < s . length ; j ++ ) { result . addElement ( s [ j ] ) ; } } String [ ] res = new String [ result . size ( ) ] ; result . copyInto ( res ) ; return res ; } public String toString ( ) { return toString ( getCommandline ( ) ) ; } public static String quoteArgument ( String argument ) { if ( argument . indexOf ( "\"" ) > - 1 ) { if ( argument . indexOf ( "\'" ) > - 1 ) { throw new BuildException ( "Can\'t handle single and double quotes in same argument" ) ; } else { return '\'' + argument + '\'' ; } } else if ( argument . indexOf ( "\'" ) > - 1 || argument . indexOf ( " " ) > - 1 ) { return '\"' + argument + '\"' ; } else { return argument ; } } public static String toString ( String [ ] line ) { if ( line == null || line . length == 0 ) return "" ; final StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < line . length ; i ++ ) { if ( i > 0 ) { result . append ( ' ' ) ; } result . append ( quoteArgument ( line [ i ] ) ) ; } return result . toString ( ) ; } public static String [ ] translateCommandline ( String to_process ) { if ( to_process == null || to_process . length ( ) == 0 ) { return new String [ 0 ] ; } final int normal = 0 ; final int inQuote = 1 ; final int inDoubleQuote = 2 ; int state = normal ; StringTokenizer tok = new StringTokenizer ( to_process , "\"\' " , true ) ; Vector v = new Vector ( ) ; StringBuffer current = new StringBuffer ( ) ; while ( tok . hasMoreTokens ( ) ) { String nextTok = tok . nextToken ( ) ; switch ( state ) { case inQuote : if ( "\'" . equals ( nextTok ) ) { state = normal ; } else { current . append ( nextTok ) ; } break ; case inDoubleQuote : if ( "\"" . equals ( nextTok ) ) { state = normal ; } else { current . append ( nextTok ) ; } break ; default : if ( "\'" . equals ( nextTok ) ) { state = inQuote ; } else if ( "\"" . equals ( nextTok ) ) { state = inDoubleQuote ; } else if ( " " . equals ( nextTok ) ) { if ( current . length ( ) != 0 ) { v . addElement ( current . toString ( ) ) ; current . setLength ( 0 ) ; } } else { current . append ( nextTok ) ; } break ; } } if ( current . length ( ) != 0 ) { v . addElement ( current . toString ( ) ) ; } if ( state == inQuote || state == inDoubleQuote ) { throw new BuildException ( "unbalanced quotes in " + to_process ) ; } String [ ] args = new String [ v . size ( ) ] ; v . copyInto ( args ) ; return args ; } public int size ( ) { return getCommandline ( ) . length ; } public Object clone ( ) { Commandline c = new Commandline ( ) ; c . setExecutable ( executable ) ; c . addArguments ( getArguments ( ) ) ; return c ; } public void clear ( ) { executable = null ; arguments . removeAllElements ( ) ; } public void clearArgs ( ) { arguments . removeAllElements ( ) ; } public Marker createMarker ( ) { return new Marker ( arguments . size ( ) ) ; } } 	0	['19', '1', '0', '30', '46', '65', '29', '3', '17', '0.416666667', '448', '1', '0', '0', '0.289473684', '0', '0', '22.47368421', '16', '2.4211', '0']
package org . apache . tools . ant . taskdefs . rmic ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . types . Commandline ; import java . io . * ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; public class SunRmic extends DefaultRmicAdapter { public boolean execute ( ) throws BuildException { getRmic ( ) . log ( "Using SUN rmic compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupRmicCommand ( ) ; LogOutputStream logstr = new LogOutputStream ( getRmic ( ) , Project . MSG_WARN ) ; try { Class c = Class . forName ( "sun.rmi.rmic.Main" ) ; Constructor cons = c . getConstructor ( new Class [ ] { OutputStream . class , String . class } ) ; Object rmic = cons . newInstance ( new Object [ ] { logstr , "rmic" } ) ; Method doRmic = c . getMethod ( "compile" , new Class [ ] { String [ ] . class } ) ; Boolean ok = ( Boolean ) doRmic . invoke ( rmic , ( new Object [ ] { cmd . getArguments ( ) } ) ) ; return ok . booleanValue ( ) ; } catch ( ClassNotFoundException ex ) { throw new BuildException ( "Cannot use SUN rmic, as it is not available" + " A common solution is to set the environment variable" + " JAVA_HOME or CLASSPATH." , getRmic ( ) . getLocation ( ) ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting SUN rmic: " , ex , getRmic ( ) . getLocation ( ) ) ; } } finally { try { logstr . close ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } } } 	1	['3', '2', '0', '8', '22', '3', '1', '7', '2', '1', '152', '0', '0', '0.866666667', '0.5', '0', '0', '48.66666667', '1', '0.6667', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import java . io . OutputStream ; import java . io . InputStream ; import java . io . IOException ; public class LogStreamHandler extends PumpStreamHandler { public LogStreamHandler ( Task task , int outlevel , int errlevel ) { super ( new LogOutputStream ( task , outlevel ) , new LogOutputStream ( task , errlevel ) ) ; } public void stop ( ) { super . stop ( ) ; try { getErr ( ) . close ( ) ; getOut ( ) . close ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } } 	0	['2', '2', '0', '10', '9', '1', '6', '4', '2', '2', '31', '0', '0', '0.923076923', '0.666666667', '0', '0', '14.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . IntrospectionHelper ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . types . EnumeratedAttribute ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import java . io . * ; public class AntStructure extends Task { private final String lSep = System . getProperty ( "line.separator" ) ; private final String BOOLEAN = "%boolean;" ; private final String TASKS = "%tasks;" ; private final String TYPES = "%types;" ; private Hashtable visited = new Hashtable ( ) ; private File output ; public void setOutput ( File output ) { this . output = output ; } public void execute ( ) throws BuildException { if ( output == null ) { throw new BuildException ( "output attribute is required" , location ) ; } PrintWriter out = null ; try { try { out = new PrintWriter ( new OutputStreamWriter ( new FileOutputStream ( output ) , "UTF8" ) ) ; } catch ( UnsupportedEncodingException ue ) { out = new PrintWriter ( new FileWriter ( output ) ) ; } printHead ( out , project . getTaskDefinitions ( ) . keys ( ) , project . getDataTypeDefinitions ( ) . keys ( ) ) ; printTargetDecl ( out ) ; Enumeration dataTypes = project . getDataTypeDefinitions ( ) . keys ( ) ; while ( dataTypes . hasMoreElements ( ) ) { String typeName = ( String ) dataTypes . nextElement ( ) ; printElementDecl ( out , typeName , ( Class ) project . getDataTypeDefinitions ( ) . get ( typeName ) ) ; } Enumeration tasks = project . getTaskDefinitions ( ) . keys ( ) ; while ( tasks . hasMoreElements ( ) ) { String taskName = ( String ) tasks . nextElement ( ) ; printElementDecl ( out , taskName , ( Class ) project . getTaskDefinitions ( ) . get ( taskName ) ) ; } printTail ( out ) ; } catch ( IOException ioe ) { throw new BuildException ( "Error writing " + output . getAbsolutePath ( ) , ioe , location ) ; } finally { if ( out != null ) { out . close ( ) ; } } } private void printHead ( PrintWriter out , Enumeration tasks , Enumeration types ) { out . println ( "<?xml version=\"1.0\" ?>" ) ; out . println ( "<!ENTITY % boolean \"(true|false|on|off|yes|no)\">" ) ; out . print ( "<!ENTITY % tasks \"" ) ; boolean first = true ; while ( tasks . hasMoreElements ( ) ) { String taskName = ( String ) tasks . nextElement ( ) ; if ( ! first ) { out . print ( " | " ) ; } else { first = false ; } out . print ( taskName ) ; } out . println ( "\">" ) ; out . print ( "<!ENTITY % types \"" ) ; first = true ; while ( types . hasMoreElements ( ) ) { String typeName = ( String ) types . nextElement ( ) ; if ( ! first ) { out . print ( " | " ) ; } else { first = false ; } out . print ( typeName ) ; } out . println ( "\">" ) ; out . println ( "" ) ; out . print ( "<!ELEMENT project (target | property | taskdef | " ) ; out . print ( TYPES ) ; out . println ( ")*>" ) ; out . println ( "<!ATTLIST project" ) ; out . println ( "          name    CDATA #REQUIRED" ) ; out . println ( "          default CDATA #REQUIRED" ) ; out . println ( "          basedir CDATA #IMPLIED>" ) ; out . println ( "" ) ; } private void printTargetDecl ( PrintWriter out ) { out . print ( "<!ELEMENT target (" ) ; out . print ( TASKS ) ; out . print ( " | " ) ; out . print ( TYPES ) ; out . println ( ")*>" ) ; out . println ( "" ) ; out . println ( "<!ATTLIST target" ) ; out . println ( "          id          ID    #IMPLIED" ) ; out . println ( "          name        CDATA #REQUIRED" ) ; out . println ( "          if          CDATA #IMPLIED" ) ; out . println ( "          unless      CDATA #IMPLIED" ) ; out . println ( "          depends     CDATA #IMPLIED" ) ; out . println ( "          description CDATA #IMPLIED>" ) ; out . println ( "" ) ; } private void printElementDecl ( PrintWriter out , String name , Class element ) throws BuildException { if ( visited . containsKey ( name ) ) { return ; } visited . put ( name , "" ) ; IntrospectionHelper ih = null ; try { ih = IntrospectionHelper . getHelper ( element ) ; } catch ( Throwable t ) { return ; } StringBuffer sb = new StringBuffer ( "<!ELEMENT " ) ; sb . append ( name ) . append ( " " ) ; if ( org . apache . tools . ant . types . Reference . class . equals ( element ) ) { sb . append ( "EMPTY>" ) . append ( lSep ) ; sb . append ( "<!ATTLIST " ) . append ( name ) ; sb . append ( lSep ) . append ( "          id ID #IMPLIED" ) ; sb . append ( lSep ) . append ( "          refid IDREF #IMPLIED" ) ; sb . append ( ">" ) . append ( lSep ) ; out . println ( sb ) ; return ; } Vector v = new Vector ( ) ; if ( ih . supportsCharacters ( ) ) { v . addElement ( "#PCDATA" ) ; } if ( TaskContainer . class . isAssignableFrom ( element ) ) { v . addElement ( TASKS ) ; } Enumeration enum = ih . getNestedElements ( ) ; while ( enum . hasMoreElements ( ) ) { v . addElement ( ( String ) enum . nextElement ( ) ) ; } if ( v . isEmpty ( ) ) { sb . append ( "EMPTY" ) ; } else { sb . append ( "(" ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( i != 0 ) { sb . append ( " | " ) ; } sb . append ( v . elementAt ( i ) ) ; } sb . append ( ")" ) ; if ( v . size ( ) > 1 || ! v . elementAt ( 0 ) . equals ( "#PCDATA" ) ) { sb . append ( "*" ) ; } } sb . append ( ">" ) ; out . println ( sb ) ; sb . setLength ( 0 ) ; sb . append ( "<!ATTLIST " ) . append ( name ) ; sb . append ( lSep ) . append ( "          id ID #IMPLIED" ) ; enum = ih . getAttributes ( ) ; while ( enum . hasMoreElements ( ) ) { String attrName = ( String ) enum . nextElement ( ) ; if ( "id" . equals ( attrName ) ) continue ; sb . append ( lSep ) . append ( "          " ) . append ( attrName ) . append ( " " ) ; Class type = ih . getAttributeType ( attrName ) ; if ( type . equals ( java . lang . Boolean . class ) || type . equals ( java . lang . Boolean . TYPE ) ) { sb . append ( BOOLEAN ) . append ( " " ) ; } else if ( org . apache . tools . ant . types . Reference . class . isAssignableFrom ( type ) ) { sb . append ( "IDREF " ) ; } else if ( org . apache . tools . ant . types . EnumeratedAttribute . class . isAssignableFrom ( type ) ) { try { EnumeratedAttribute ea = ( EnumeratedAttribute ) type . newInstance ( ) ; String [ ] values = ea . getValues ( ) ; if ( values == null || values . length == 0 || ! areNmtokens ( values ) ) { sb . append ( "CDATA " ) ; } else { sb . append ( "(" ) ; for ( int i = 0 ; i < values . length ; i ++ ) { if ( i != 0 ) { sb . append ( " | " ) ; } sb . append ( values [ i ] ) ; } sb . append ( ") " ) ; } } catch ( InstantiationException ie ) { sb . append ( "CDATA " ) ; } catch ( IllegalAccessException ie ) { sb . append ( "CDATA " ) ; } } else { sb . append ( "CDATA " ) ; } sb . append ( "#IMPLIED" ) ; } sb . append ( ">" ) . append ( lSep ) ; out . println ( sb ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { String nestedName = ( String ) v . elementAt ( i ) ; if ( ! "#PCDATA" . equals ( nestedName ) && ! TASKS . equals ( nestedName ) && ! TYPES . equals ( nestedName ) ) { printElementDecl ( out , nestedName , ih . getElementType ( nestedName ) ) ; } } } private void printTail ( PrintWriter out ) { } protected boolean isNmtoken ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( ! Character . isLetterOrDigit ( c ) && c != '.' && c != '-' && c != '_' && c != ':' ) { return false ; } } return true ; } protected boolean areNmtokens ( String [ ] s ) { for ( int i = 0 ; i < s . length ; i ++ ) { if ( ! isNmtoken ( s [ i ] ) ) { return false ; } } return true ; } } 	1	['10', '3', '0', '7', '60', '41', '0', '7', '3', '0.9', '748', '0.6', '0', '0.804347826', '0.285714286', '0', '0', '72.8', '7', '2.1', '1']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . PathTokenizer ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . util . Stack ; import java . util . Vector ; import java . text . CharacterIterator ; import java . text . StringCharacterIterator ; public class Path extends DataType implements Cloneable { private Vector elements ; private Project project ; public static Path systemClasspath = new Path ( null , System . getProperty ( "java.class.path" ) ) ; public class PathElement { private String [ ] parts ; public void setLocation ( File loc ) { parts = new String [ ] { translateFile ( loc . getAbsolutePath ( ) ) } ; } public void setPath ( String path ) { parts = Path . translatePath ( project , path ) ; } public String [ ] getParts ( ) { return parts ; } } public Path ( Project p , String path ) { this ( p ) ; createPathElement ( ) . setPath ( path ) ; } public Path ( Project project ) { this . project = project ; elements = new Vector ( ) ; } public void setProject ( Project p ) { this . project = p ; } public Project getProject ( ) { return project ; } public void setLocation ( File location ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createPathElement ( ) . setLocation ( location ) ; } public void setPath ( String path ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createPathElement ( ) . setPath ( path ) ; } public void setRefid ( Reference r ) throws BuildException { if ( ! elements . isEmpty ( ) ) { throw tooManyAttributes ( ) ; } elements . addElement ( r ) ; super . setRefid ( r ) ; } public PathElement createPathElement ( ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } PathElement pe = new PathElement ( ) ; elements . addElement ( pe ) ; return pe ; } public void addFileset ( FileSet fs ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } elements . addElement ( fs ) ; checked = false ; } public Path createPath ( ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } Path p = new Path ( project ) ; elements . addElement ( p ) ; checked = false ; return p ; } public void append ( Path other ) { if ( other == null ) return ; String [ ] l = other . list ( ) ; for ( int i = 0 ; i < l . length ; i ++ ) { if ( elements . indexOf ( l [ i ] ) == - 1 ) { elements . addElement ( l [ i ] ) ; } } } public void addExisting ( Path source ) { String [ ] list = source . list ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { File f = null ; if ( project != null ) { f = project . resolveFile ( list [ i ] ) ; } else { f = new File ( list [ i ] ) ; } if ( f . exists ( ) ) { setLocation ( f ) ; } } } public String [ ] list ( ) { if ( ! checked ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , project ) ; } Vector result = new Vector ( 2 * elements . size ( ) ) ; for ( int i = 0 ; i < elements . size ( ) ; i ++ ) { Object o = elements . elementAt ( i ) ; if ( o instanceof Reference ) { Reference r = ( Reference ) o ; o = r . getReferencedObject ( project ) ; if ( ! ( o instanceof Path ) ) { String msg = r . getRefId ( ) + " doesn\'t denote a path" ; throw new BuildException ( msg ) ; } } if ( o instanceof String ) { addUnlessPresent ( result , ( String ) o ) ; } else if ( o instanceof PathElement ) { String [ ] parts = ( ( PathElement ) o ) . getParts ( ) ; if ( parts == null ) { throw new BuildException ( "You must either set location or path on <pathelement>" ) ; } for ( int j = 0 ; j < parts . length ; j ++ ) { addUnlessPresent ( result , parts [ j ] ) ; } } else if ( o instanceof Path ) { Path p = ( Path ) o ; if ( p . getProject ( ) == null ) { p . setProject ( project ) ; } String [ ] parts = p . list ( ) ; for ( int j = 0 ; j < parts . length ; j ++ ) { addUnlessPresent ( result , parts [ j ] ) ; } } else if ( o instanceof FileSet ) { FileSet fs = ( FileSet ) o ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; String [ ] s = ds . getIncludedFiles ( ) ; File dir = fs . getDir ( project ) ; for ( int j = 0 ; j < s . length ; j ++ ) { File f = new File ( dir , s [ j ] ) ; String absolutePath = f . getAbsolutePath ( ) ; addUnlessPresent ( result , translateFile ( absolutePath ) ) ; } } } String [ ] res = new String [ result . size ( ) ] ; result . copyInto ( res ) ; return res ; } public String toString ( ) { final String [ ] list = list ( ) ; if ( list . length == 0 ) return "" ; final StringBuffer result = new StringBuffer ( list [ 0 ] . toString ( ) ) ; for ( int i = 1 ; i < list . length ; i ++ ) { result . append ( File . pathSeparatorChar ) ; result . append ( list [ i ] ) ; } return result . toString ( ) ; } public static String [ ] translatePath ( Project project , String source ) { final Vector result = new Vector ( ) ; if ( source == null ) return new String [ 0 ] ; PathTokenizer tok = new PathTokenizer ( source ) ; StringBuffer element = new StringBuffer ( ) ; while ( tok . hasMoreTokens ( ) ) { element . setLength ( 0 ) ; String pathElement = tok . nextToken ( ) ; try { element . append ( resolveFile ( project , pathElement ) ) ; } catch ( BuildException e ) { project . log ( "Dropping path element " + pathElement + " as it is not valid relative to the project" , Project . MSG_VERBOSE ) ; } for ( int i = 0 ; i < element . length ( ) ; i ++ ) { translateFileSep ( element , i ) ; } result . addElement ( element . toString ( ) ) ; } String [ ] res = new String [ result . size ( ) ] ; result . copyInto ( res ) ; return res ; } public static String translateFile ( String source ) { if ( source == null ) return "" ; final StringBuffer result = new StringBuffer ( source ) ; for ( int i = 0 ; i < result . length ( ) ; i ++ ) { translateFileSep ( result , i ) ; } return result . toString ( ) ; } protected static boolean translateFileSep ( StringBuffer buffer , int pos ) { if ( buffer . charAt ( pos ) == '/' || buffer . charAt ( pos ) == '\\' ) { buffer . setCharAt ( pos , File . separatorChar ) ; return true ; } return false ; } public int size ( ) { return list ( ) . length ; } public Object clone ( ) { Path p = new Path ( project ) ; p . append ( this ) ; return p ; } protected void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( checked ) { return ; } Enumeration enum = elements . elements ( ) ; while ( enum . hasMoreElements ( ) ) { Object o = enum . nextElement ( ) ; if ( o instanceof Reference ) { o = ( ( Reference ) o ) . getReferencedObject ( p ) ; } if ( o instanceof DataType ) { if ( stk . contains ( o ) ) { throw circularReference ( ) ; } else { stk . push ( o ) ; ( ( DataType ) o ) . dieOnCircularReference ( stk , p ) ; stk . pop ( ) ; } } } checked = true ; } private static String resolveFile ( Project project , String relativeName ) { if ( project != null ) { File f = project . resolveFile ( relativeName ) ; return f . getAbsolutePath ( ) ; } return relativeName ; } private static void addUnlessPresent ( Vector v , String s ) { if ( v . indexOf ( s ) == - 1 ) { v . addElement ( s ) ; } } public Path concatSystemClasspath ( ) { return concatSystemClasspath ( "last" ) ; } public Path concatSystemClasspath ( String defValue ) { Path result = new Path ( project ) ; String order = defValue ; if ( project != null ) { String o = project . getProperty ( "build.sysclasspath" ) ; if ( o != null ) { order = o ; } } if ( order . equals ( "only" ) ) { result . addExisting ( Path . systemClasspath ) ; } else if ( order . equals ( "first" ) ) { result . addExisting ( Path . systemClasspath ) ; result . addExisting ( this ) ; } else if ( order . equals ( "ignore" ) ) { result . addExisting ( this ) ; } else { if ( ! order . equals ( "last" ) ) { project . log ( "invalid value for build.sysclasspath: " + order , Project . MSG_WARN ) ; } result . addExisting ( this ) ; result . addExisting ( Path . systemClasspath ) ; } return result ; } } 	0	['26', '3', '0', '33', '80', '201', '26', '8', '20', '0.573333333', '719', '0.666666667', '2', '0.566037736', '0.152727273', '2', '11', '26.53846154', '14', '2.2692', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . taskdefs . * ; import java . io . * ; import java . util . * ; public class Replace extends MatchingTask { private File src = null ; private NestedString token = null ; private NestedString value = new NestedString ( ) ; private File propertyFile = null ; private Properties properties = null ; private Vector replacefilters = new Vector ( ) ; private File dir = null ; private int fileCount ; private int replaceCount ; private boolean summary = false ; public class NestedString { private StringBuffer buf = new StringBuffer ( ) ; public void addText ( String val ) { buf . append ( val ) ; } public String getText ( ) { return buf . toString ( ) ; } } public class Replacefilter { private String token ; private String value ; private String property ; public void validate ( ) throws BuildException { if ( token == null ) { String message = "token is a mandatory attribute " + "of replacefilter." ; throw new BuildException ( message ) ; } if ( "" . equals ( token ) ) { String message = "The token attribute must not be an empty string." ; throw new BuildException ( message ) ; } if ( ( value != null ) && ( property != null ) ) { String message = "Either value or property " + "can be specified, but a replacefilter " + "element cannot have both." ; throw new BuildException ( message ) ; } if ( ( property != null ) ) { if ( propertyFile == null ) { String message = "The replacefilter's property attribute " + "can only be used with the replacetask's " + "propertyFile attribute." ; throw new BuildException ( message ) ; } if ( properties == null || properties . getProperty ( property ) == null ) { String message = "property \"" + property + "\" was not found in " + propertyFile . getPath ( ) ; throw new BuildException ( message ) ; } } } public String getReplaceValue ( ) { if ( property != null ) { return ( String ) properties . getProperty ( property ) ; } else if ( value != null ) { return value ; } else if ( Replace . this . value != null ) { return Replace . this . value . getText ( ) ; } else { return new String ( "" ) ; } } public void setToken ( String token ) { this . token = token ; } public String getToken ( ) { return token ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } public void setProperty ( String property ) { this . property = property ; } public String getProperty ( ) { return property ; } } public void execute ( ) throws BuildException { validateAttributes ( ) ; if ( propertyFile != null ) { properties = getProperties ( propertyFile ) ; } validateReplacefilters ( ) ; fileCount = 0 ; replaceCount = 0 ; if ( src != null ) { processFile ( src ) ; } if ( dir != null ) { DirectoryScanner ds = super . getDirectoryScanner ( dir ) ; String [ ] srcs = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < srcs . length ; i ++ ) { File file = new File ( dir , srcs [ i ] ) ; processFile ( file ) ; } } if ( summary ) { log ( "Replaced " + replaceCount + " occurrences in " + fileCount + " files." , Project . MSG_INFO ) ; } } public void validateAttributes ( ) throws BuildException { if ( src == null && dir == null ) { String message = "Either the file or the dir attribute " + "must be specified" ; throw new BuildException ( message , location ) ; } if ( propertyFile != null && ! propertyFile . exists ( ) ) { String message = "Property file " + propertyFile . getPath ( ) + " does not exist." ; throw new BuildException ( message , location ) ; } if ( token == null && replacefilters . size ( ) == 0 ) { String message = "Either token or a nested replacefilter " + "must be specified" ; throw new BuildException ( message , location ) ; } if ( token != null && "" . equals ( token . getText ( ) ) ) { String message = "The token attribute must not be an empty string." ; throw new BuildException ( message , location ) ; } } public void validateReplacefilters ( ) throws BuildException { for ( int i = 0 ; i < replacefilters . size ( ) ; i ++ ) { Replacefilter element = ( Replacefilter ) replacefilters . elementAt ( i ) ; element . validate ( ) ; } } public Properties getProperties ( File propertyFile ) throws BuildException { Properties properties = new Properties ( ) ; try { properties . load ( new FileInputStream ( propertyFile ) ) ; } catch ( FileNotFoundException e ) { String message = "Property file (" + propertyFile . getPath ( ) + ") not found." ; throw new BuildException ( message ) ; } catch ( IOException e ) { String message = "Property file (" + propertyFile . getPath ( ) + ") cannot be loaded." ; throw new BuildException ( message ) ; } return properties ; } private void processFile ( File src ) throws BuildException { if ( ! src . exists ( ) ) { throw new BuildException ( "Replace: source file " + src . getPath ( ) + " doesn't exist" , location ) ; } File temp = new File ( src . getPath ( ) + ".temp" ) ; if ( temp . exists ( ) ) { throw new BuildException ( "Replace: temporary file " + temp . getPath ( ) + " already exists" , location ) ; } try { BufferedReader br = new BufferedReader ( new FileReader ( src ) ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( temp ) ) ; int fileLengthInBytes = ( int ) ( src . length ( ) ) ; StringBuffer tmpBuf = new StringBuffer ( fileLengthInBytes ) ; int readChar = 0 ; int totread = 0 ; while ( true ) { readChar = br . read ( ) ; if ( readChar < 0 ) { break ; } tmpBuf . append ( ( char ) readChar ) ; totread ++ ; } String buf = tmpBuf . toString ( ) ; String newString = new String ( buf ) ; if ( token != null ) { String linesep = System . getProperty ( "line.separator" ) ; String val = stringReplace ( value . getText ( ) , "\n" , linesep ) ; String tok = stringReplace ( token . getText ( ) , "\n" , linesep ) ; log ( "Replacing in " + src . getPath ( ) + ": " + token . getText ( ) + " --> " + value . getText ( ) , Project . MSG_VERBOSE ) ; newString = stringReplace ( newString , tok , val ) ; } if ( replacefilters . size ( ) > 0 ) { newString = processReplacefilters ( newString , src . getPath ( ) ) ; } boolean changes = ! newString . equals ( buf ) ; if ( changes ) { bw . write ( newString , 0 , newString . length ( ) ) ; bw . flush ( ) ; } bw . close ( ) ; br . close ( ) ; if ( changes ) { ++ fileCount ; src . delete ( ) ; temp . renameTo ( src ) ; } else { temp . delete ( ) ; } } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; throw new BuildException ( ioe , location ) ; } } private String processReplacefilters ( String buffer , String filename ) { String newString = new String ( buffer ) ; for ( int i = 0 ; i < replacefilters . size ( ) ; i ++ ) { Replacefilter filter = ( Replacefilter ) replacefilters . elementAt ( i ) ; log ( "Replacing in " + filename + ": " + filter . getToken ( ) + " --> " + filter . getReplaceValue ( ) , Project . MSG_VERBOSE ) ; newString = stringReplace ( newString , filter . getToken ( ) , filter . getReplaceValue ( ) ) ; } return newString ; } public void setFile ( File file ) { this . src = file ; } public void setSummary ( boolean summary ) { this . summary = summary ; } public void setDir ( File dir ) { this . dir = dir ; } public void setToken ( String token ) { createReplaceToken ( ) . addText ( token ) ; } public void setValue ( String value ) { createReplaceValue ( ) . addText ( value ) ; } public NestedString createReplaceToken ( ) { if ( token == null ) { token = new NestedString ( ) ; } return token ; } public NestedString createReplaceValue ( ) { return value ; } public void setPropertyFile ( File filename ) { propertyFile = filename ; } public Replacefilter createReplacefilter ( ) { Replacefilter filter = new Replacefilter ( ) ; replacefilters . addElement ( filter ) ; return filter ; } private String stringReplace ( String str , String str1 , String str2 ) { StringBuffer ret = new StringBuffer ( ) ; int start = 0 ; int found = str . indexOf ( str1 ) ; while ( found >= 0 ) { if ( found > start ) { ret . append ( str . substring ( start , found ) ) ; } if ( str2 != null ) { ret . append ( str2 ) ; } start = found + str1 . length ( ) ; found = str . indexOf ( str1 , start ) ; ++ replaceCount ; } if ( str . length ( ) > start ) { ret . append ( str . substring ( start , str . length ( ) ) ) ; } return ret . toString ( ) ; } } 	1	['20', '4', '0', '7', '71', '102', '2', '7', '14', '0.821052632', '677', '1', '2', '0.804123711', '0.3', '2', '2', '32.35', '5', '1.25', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . util . * ; import java . text . * ; import java . lang . RuntimeException ; public class Sequential extends Task implements TaskContainer { private Vector nestedTasks = new Vector ( ) ; public void addTask ( Task nestedTask ) { nestedTasks . addElement ( nestedTask ) ; } public void execute ( ) throws BuildException { for ( Enumeration e = nestedTasks . elements ( ) ; e . hasMoreElements ( ) ; ) { Task nestedTask = ( Task ) e . nextElement ( ) ; nestedTask . perform ( ) ; } } } 	0	['3', '3', '0', '3', '10', '0', '0', '3', '3', '0', '32', '1', '0', '0.948717949', '0.666666667', '0', '0', '9.333333333', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; public class Or extends ConditionBase implements Condition { public boolean eval ( ) throws BuildException { Enumeration enum = getConditions ( ) ; while ( enum . hasMoreElements ( ) ) { Condition c = ( Condition ) enum . nextElement ( ) ; if ( c . eval ( ) ) { return true ; } } return false ; } } 	1	['2', '3', '0', '3', '7', '1', '1', '3', '2', '2', '23', '0', '0', '0.96969697', '1', '0', '0', '10.5', '1', '0.5', '1']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . * ; import java . io . File ; public class Gcj extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { Commandline cmd ; attributes . log ( "Using gcj compiler" , Project . MSG_VERBOSE ) ; cmd = setupGCJCommand ( ) ; int firstFileName = cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } protected Commandline setupGCJCommand ( ) { Commandline cmd = new Commandline ( ) ; Path classpath = new Path ( project ) ; if ( bootclasspath != null ) { classpath . append ( bootclasspath ) ; } addExtdirsToClasspath ( classpath ) ; if ( ( bootclasspath == null ) || ( bootclasspath . size ( ) == 0 ) ) { includeJavaRuntime = true ; } classpath . append ( getCompileClasspath ( ) ) ; classpath . append ( src ) ; cmd . setExecutable ( "gcj" ) ; if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; if ( destDir . mkdirs ( ) ) { throw new BuildException ( "Can't make output directories. Maybe permission is wrong. " ) ; } ; } cmd . createArgument ( ) . setValue ( "-classpath" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; if ( encoding != null ) { attributes . log ( "gcj doesn't support -encoding option." , Project . MSG_WARN ) ; } if ( debug ) { cmd . createArgument ( ) . setValue ( "-g1" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O" ) ; } cmd . createArgument ( ) . setValue ( "-C" ) ; return cmd ; } } 	0	['3', '2', '0', '9', '22', '3', '1', '8', '2', '2', '128', '0', '0', '0.92', '1', '1', '1', '41.66666667', '9', '3.3333', '0']
package org . apache . tools . ant . taskdefs . rmic ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . types . Commandline ; import java . io . * ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; public class KaffeRmic extends DefaultRmicAdapter { public boolean execute ( ) throws BuildException { getRmic ( ) . log ( "Using Kaffe rmic" , Project . MSG_VERBOSE ) ; Commandline cmd = setupRmicCommand ( ) ; try { Class c = Class . forName ( "kaffe.rmi.rmic.RMIC" ) ; Constructor cons = c . getConstructor ( new Class [ ] { String [ ] . class } ) ; Object rmic = cons . newInstance ( new Object [ ] { cmd . getArguments ( ) } ) ; Method doRmic = c . getMethod ( "run" , null ) ; String str [ ] = cmd . getArguments ( ) ; Boolean ok = ( Boolean ) doRmic . invoke ( rmic , null ) ; return ok . booleanValue ( ) ; } catch ( ClassNotFoundException ex ) { throw new BuildException ( "Cannot use Kaffe rmic, as it is not available" + " A common solution is to set the environment variable" + " JAVA_HOME or CLASSPATH." , getRmic ( ) . getLocation ( ) ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting Kaffe rmic: " , ex , getRmic ( ) . getLocation ( ) ) ; } } } } 	1	['3', '2', '0', '7', '19', '3', '1', '6', '2', '1', '96', '0', '0', '0.866666667', '0.5', '0', '0', '30.66666667', '1', '0.6667', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . Commandline ; import java . io . File ; import java . io . IOException ; public class Patch extends Task { private File originalFile ; private boolean havePatchfile = false ; private Commandline cmd = new Commandline ( ) ; public void setOriginalfile ( File file ) { originalFile = file ; } public void setPatchfile ( File file ) { if ( ! file . exists ( ) ) { throw new BuildException ( "patchfile " + file + " doesn\'t exist" , location ) ; } cmd . createArgument ( ) . setValue ( "-i" ) ; cmd . createArgument ( ) . setFile ( file ) ; havePatchfile = true ; } public void setBackups ( boolean backups ) { if ( backups ) { cmd . createArgument ( ) . setValue ( "-b" ) ; } } public void setIgnorewhitespace ( boolean ignore ) { if ( ignore ) { cmd . createArgument ( ) . setValue ( "-l" ) ; } } public void setStrip ( int num ) throws BuildException { if ( num < 0 ) { throw new BuildException ( "strip has to be >= 0" , location ) ; } cmd . createArgument ( ) . setValue ( "-p" + num ) ; } public void setQuiet ( boolean q ) { if ( q ) { cmd . createArgument ( ) . setValue ( "-s" ) ; } } public void setReverse ( boolean r ) { if ( r ) { cmd . createArgument ( ) . setValue ( "-R" ) ; } } public void execute ( ) throws BuildException { if ( ! havePatchfile ) { throw new BuildException ( "patchfile argument is required" , location ) ; } Commandline toExecute = ( Commandline ) cmd . clone ( ) ; toExecute . setExecutable ( "patch" ) ; if ( originalFile != null ) { toExecute . createArgument ( ) . setFile ( originalFile ) ; } Execute exe = new Execute ( new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) , null ) ; exe . setCommandline ( toExecute . getCommandline ( ) ) ; try { exe . execute ( ) ; } catch ( IOException e ) { throw new BuildException ( e , location ) ; } } } 	0	['9', '3', '0', '9', '29', '0', '0', '9', '9', '0.583333333', '168', '1', '1', '0.822222222', '0.444444444', '0', '0', '17.33333333', '2', '1.4444', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . io . * ; import java . util . * ; public class Chmod extends ExecuteOn { private FileSet defaultSet = new FileSet ( ) ; private boolean defaultSetDefined = false ; private boolean havePerm = false ; public Chmod ( ) { super . setExecutable ( "chmod" ) ; super . setParallel ( true ) ; super . setSkipEmptyFilesets ( true ) ; } public void setFile ( File src ) { FileSet fs = new FileSet ( ) ; fs . setDir ( new File ( src . getParent ( ) ) ) ; fs . createInclude ( ) . setName ( src . getName ( ) ) ; addFileset ( fs ) ; } public void setDir ( File src ) { defaultSet . setDir ( src ) ; } public void setPerm ( String perm ) { createArg ( ) . setValue ( perm ) ; havePerm = true ; } public PatternSet . NameEntry createInclude ( ) { defaultSetDefined = true ; return defaultSet . createInclude ( ) ; } public PatternSet . NameEntry createExclude ( ) { defaultSetDefined = true ; return defaultSet . createExclude ( ) ; } public PatternSet createPatternSet ( ) { defaultSetDefined = true ; return defaultSet . createPatternSet ( ) ; } public void setIncludes ( String includes ) { defaultSetDefined = true ; defaultSet . setIncludes ( includes ) ; } public void setExcludes ( String excludes ) { defaultSetDefined = true ; defaultSet . setExcludes ( excludes ) ; } public void setDefaultexcludes ( boolean useDefaultExcludes ) { defaultSetDefined = true ; defaultSet . setDefaultexcludes ( useDefaultExcludes ) ; } protected void checkConfiguration ( ) { if ( ! havePerm ) { throw new BuildException ( "Required attribute perm not set in chmod" , location ) ; } if ( defaultSetDefined && defaultSet . getDir ( project ) != null ) { addFileset ( defaultSet ) ; } super . checkConfiguration ( ) ; } public void execute ( ) throws BuildException { if ( defaultSetDefined || defaultSet . getDir ( project ) == null ) { super . execute ( ) ; } else if ( isValidOs ( ) ) { createArg ( ) . setValue ( defaultSet . getDir ( project ) . getPath ( ) ) ; Execute execute = prepareExec ( ) ; try { execute . setCommandline ( cmdl . getCommandline ( ) ) ; runExecute ( execute ) ; } catch ( IOException e ) { throw new BuildException ( "Execute failed: " + e , e , location ) ; } finally { logFlush ( ) ; } } } public void setExecutable ( String e ) { throw new BuildException ( taskType + " doesn\'t support the executable attribute" , location ) ; } public void setCommand ( String e ) { throw new BuildException ( taskType + " doesn\'t support the command attribute" , location ) ; } public void setSkipEmptyFilesets ( boolean skip ) { throw new BuildException ( taskType + " doesn\'t support the skipemptyfileset attribute" , location ) ; } protected boolean isValidOs ( ) { return System . getProperty ( "path.separator" ) . equals ( ":" ) && ( ! System . getProperty ( "os.name" ) . startsWith ( "Mac" ) || System . getProperty ( "os.name" ) . endsWith ( "X" ) ) && super . isValidOs ( ) ; } } 	1	['16', '5', '0', '13', '55', '26', '0', '13', '14', '0.577777778', '275', '1', '1', '0.87704918', '0.390625', '3', '6', '16', '5', '1.375', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; import java . util . zip . * ; public class GUnzip extends Task { private File source ; private File dest ; public void setSrc ( String src ) { source = project . resolveFile ( src ) ; } public void setDest ( String dest ) { this . dest = project . resolveFile ( dest ) ; } public void execute ( ) throws BuildException { if ( source == null ) { throw new BuildException ( "No source for gunzip specified" , location ) ; } if ( ! source . exists ( ) ) { throw new BuildException ( "source doesn't exist" , location ) ; } if ( source . isDirectory ( ) ) { throw new BuildException ( "Cannot expand a directory" , location ) ; } if ( dest == null ) { dest = new File ( source . getParent ( ) ) ; } if ( dest . isDirectory ( ) ) { String sourceName = source . getName ( ) ; int len = sourceName . length ( ) ; if ( len > 3 && ".gz" . equalsIgnoreCase ( sourceName . substring ( len - 3 ) ) ) { dest = new File ( dest , sourceName . substring ( 0 , len - 3 ) ) ; } else { dest = new File ( dest , sourceName ) ; } } if ( source . lastModified ( ) > dest . lastModified ( ) ) { log ( "Expanding " + source . getAbsolutePath ( ) + " to " + dest . getAbsolutePath ( ) ) ; FileOutputStream out = null ; GZIPInputStream zIn = null ; try { out = new FileOutputStream ( dest ) ; zIn = new GZIPInputStream ( new FileInputStream ( source ) ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { out . write ( buffer , 0 , count ) ; count = zIn . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } catch ( IOException ioe ) { String msg = "Problem expanding gzip " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( IOException ioex ) { } } if ( zIn != null ) { try { zIn . close ( ) ; } catch ( IOException ioex ) { } } } } } } 	0	['4', '3', '0', '5', '32', '2', '0', '5', '4', '0.666666667', '215', '1', '0', '0.925', '0.75', '1', '1', '52.25', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . io . * ; public class ExecTask extends Task { private static String lSep = System . getProperty ( "line.separator" ) ; private String os ; private File out ; private File dir ; protected boolean failOnError = false ; protected boolean newEnvironment = false ; private Integer timeout = null ; private Environment env = new Environment ( ) ; protected Commandline cmdl = new Commandline ( ) ; private FileOutputStream fos = null ; private ByteArrayOutputStream baos = null ; private String outputprop ; private boolean vmLauncher = true ; public void setTimeout ( Integer value ) { timeout = value ; } public void setExecutable ( String value ) { cmdl . setExecutable ( value ) ; } public void setDir ( File d ) { this . dir = d ; } public void setOs ( String os ) { this . os = os ; } public void setCommand ( Commandline cmdl ) { log ( "The command attribute is deprecated. " + "Please use the executable attribute and nested arg elements." , Project . MSG_WARN ) ; this . cmdl = cmdl ; } public void setOutput ( File out ) { this . out = out ; } public void setOutputproperty ( String outputprop ) { this . outputprop = outputprop ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } public void setNewenvironment ( boolean newenv ) { newEnvironment = newenv ; } public void addEnv ( Environment . Variable var ) { env . addVariable ( var ) ; } public Commandline . Argument createArg ( ) { return cmdl . createArgument ( ) ; } public void execute ( ) throws BuildException { checkConfiguration ( ) ; if ( isValidOs ( ) ) { runExec ( prepareExec ( ) ) ; } } protected void checkConfiguration ( ) throws BuildException { if ( cmdl . getExecutable ( ) == null ) { throw new BuildException ( "no executable specified" , location ) ; } if ( dir != null && ! dir . exists ( ) ) { throw new BuildException ( "The directory you specified does not exist" ) ; } if ( dir != null && ! dir . isDirectory ( ) ) { throw new BuildException ( "The directory you specified is not a directory" ) ; } } protected boolean isValidOs ( ) { String myos = System . getProperty ( "os.name" ) ; log ( "Current OS is " + myos , Project . MSG_VERBOSE ) ; if ( ( os != null ) && ( os . indexOf ( myos ) < 0 ) ) { log ( "This OS, " + myos + " was not found in the specified list of valid OSes: " + os , Project . MSG_VERBOSE ) ; return false ; } return true ; } public void setVMLauncher ( boolean vmLauncher ) { this . vmLauncher = vmLauncher ; } protected Execute prepareExec ( ) throws BuildException { if ( dir == null ) dir = project . getBaseDir ( ) ; log ( cmdl . toString ( ) , Project . MSG_VERBOSE ) ; Execute exe = new Execute ( createHandler ( ) , createWatchdog ( ) ) ; exe . setAntRun ( project ) ; exe . setWorkingDirectory ( dir ) ; exe . setVMLauncher ( vmLauncher ) ; String [ ] environment = env . getVariables ( ) ; if ( environment != null ) { for ( int i = 0 ; i < environment . length ; i ++ ) { log ( "Setting environment variable: " + environment [ i ] , Project . MSG_VERBOSE ) ; } } exe . setNewenvironment ( newEnvironment ) ; exe . setEnvironment ( environment ) ; return exe ; } protected final void runExecute ( Execute exe ) throws IOException { int err = - 1 ; err = exe . execute ( ) ; if ( err != 0 ) { if ( failOnError ) { throw new BuildException ( taskType + " returned: " + err , location ) ; } else { log ( "Result: " + err , Project . MSG_ERR ) ; } } if ( baos != null ) { BufferedReader in = new BufferedReader ( new StringReader ( baos . toString ( ) ) ) ; String line = null ; StringBuffer val = new StringBuffer ( ) ; while ( ( line = in . readLine ( ) ) != null ) { if ( val . length ( ) != 0 ) { val . append ( lSep ) ; } val . append ( line ) ; } project . setProperty ( outputprop , val . toString ( ) ) ; } } protected void runExec ( Execute exe ) throws BuildException { exe . setCommandline ( cmdl . getCommandline ( ) ) ; try { runExecute ( exe ) ; } catch ( IOException e ) { throw new BuildException ( "Execute failed: " + e , e , location ) ; } finally { logFlush ( ) ; } } protected ExecuteStreamHandler createHandler ( ) throws BuildException { if ( out != null ) { try { fos = new FileOutputStream ( out ) ; log ( "Output redirected to " + out , Project . MSG_VERBOSE ) ; return new PumpStreamHandler ( fos ) ; } catch ( FileNotFoundException fne ) { throw new BuildException ( "Cannot write to " + out , fne , location ) ; } catch ( IOException ioe ) { throw new BuildException ( "Cannot write to " + out , ioe , location ) ; } } else if ( outputprop != null ) { baos = new ByteArrayOutputStream ( ) ; log ( "Output redirected to ByteArray" , Project . MSG_VERBOSE ) ; return new PumpStreamHandler ( baos ) ; } else { return new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) ; } } protected ExecuteWatchdog createWatchdog ( ) throws BuildException { if ( timeout == null ) return null ; return new ExecuteWatchdog ( timeout . intValue ( ) ) ; } protected void logFlush ( ) { try { if ( fos != null ) fos . close ( ) ; if ( baos != null ) baos . close ( ) ; } catch ( IOException io ) { } } } 	1	['23', '3', '1', '18', '69', '163', '4', '14', '14', '0.846153846', '514', '1', '2', '0.637931034', '0.198863636', '0', '0', '20.7826087', '3', '1.0435', '3']
package org . apache . tools . ant . taskdefs ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public class StreamPumper implements Runnable { private final static int SLEEP = 5 ; private final static int SIZE = 128 ; private InputStream is ; private OutputStream os ; public StreamPumper ( InputStream is , OutputStream os ) { this . is = is ; this . os = os ; } public void run ( ) { final byte [ ] buf = new byte [ SIZE ] ; int length ; try { while ( ( length = is . read ( buf ) ) > 0 ) { os . write ( buf , 0 , length ) ; try { Thread . sleep ( SLEEP ) ; } catch ( InterruptedException e ) { } } } catch ( IOException e ) { } } } 	0	['2', '1', '0', '1', '6', '0', '1', '0', '2', '1', '39', '1', '0', '0', '0.666666667', '0', '0', '16.5', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; import java . util . * ; public class Ant extends Task { private File dir = null ; private String antFile = null ; private String target = null ; private String output = null ; private boolean inheritAll = true ; Vector properties = new Vector ( ) ; Project p1 ; public void setInheritAll ( boolean inherit ) { inheritAll = inherit ; } public void init ( ) { p1 = new Project ( ) ; p1 . setJavaVersionProperty ( ) ; p1 . addTaskDefinition ( "property" , ( Class ) project . getTaskDefinitions ( ) . get ( "property" ) ) ; } private void reinit ( ) { init ( ) ; for ( int i = 0 ; i < properties . size ( ) ; i ++ ) { Property p = ( Property ) properties . elementAt ( i ) ; Property newP = ( Property ) p1 . createTask ( "property" ) ; newP . setName ( p . getName ( ) ) ; if ( p . getValue ( ) != null ) { newP . setValue ( p . getValue ( ) ) ; } if ( p . getFile ( ) != null ) { newP . setFile ( p . getFile ( ) ) ; } if ( p . getResource ( ) != null ) { newP . setResource ( p . getResource ( ) ) ; } properties . setElementAt ( newP , i ) ; } } private void initializeProject ( ) { Vector listeners = project . getBuildListeners ( ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { p1 . addBuildListener ( ( BuildListener ) listeners . elementAt ( i ) ) ; } if ( output != null ) { try { PrintStream out = new PrintStream ( new FileOutputStream ( output ) ) ; DefaultLogger logger = new DefaultLogger ( ) ; logger . setMessageOutputLevel ( Project . MSG_INFO ) ; logger . setOutputPrintStream ( out ) ; logger . setErrorPrintStream ( out ) ; p1 . addBuildListener ( logger ) ; } catch ( IOException ex ) { log ( "Ant: Can't set output to " + output ) ; } } Hashtable taskdefs = project . getTaskDefinitions ( ) ; Enumeration et = taskdefs . keys ( ) ; while ( et . hasMoreElements ( ) ) { String taskName = ( String ) et . nextElement ( ) ; Class taskClass = ( Class ) taskdefs . get ( taskName ) ; p1 . addTaskDefinition ( taskName , taskClass ) ; } Hashtable typedefs = project . getDataTypeDefinitions ( ) ; Enumeration e = typedefs . keys ( ) ; while ( e . hasMoreElements ( ) ) { String typeName = ( String ) e . nextElement ( ) ; Class typeClass = ( Class ) typedefs . get ( typeName ) ; p1 . addDataTypeDefinition ( typeName , typeClass ) ; } Hashtable prop1 ; if ( inheritAll == true ) { prop1 = project . getProperties ( ) ; } else { prop1 = project . getUserProperties ( ) ; project . setSystemProperties ( ) ; } e = prop1 . keys ( ) ; while ( e . hasMoreElements ( ) ) { String arg = ( String ) e . nextElement ( ) ; String value = ( String ) prop1 . get ( arg ) ; if ( inheritAll == true ) p1 . setProperty ( arg , value ) ; else p1 . setUserProperty ( arg , value ) ; } } protected void handleOutput ( String line ) { if ( p1 != null ) { p1 . demuxOutput ( line , false ) ; } else { super . handleOutput ( line ) ; } } protected void handleErrorOutput ( String line ) { if ( p1 != null ) { p1 . demuxOutput ( line , true ) ; } else { super . handleErrorOutput ( line ) ; } } public void execute ( ) throws BuildException { try { if ( p1 == null ) { reinit ( ) ; } if ( dir == null ) dir = project . getBaseDir ( ) ; initializeProject ( ) ; p1 . setBaseDir ( dir ) ; p1 . setUserProperty ( "basedir" , dir . getAbsolutePath ( ) ) ; Enumeration e = properties . elements ( ) ; while ( e . hasMoreElements ( ) ) { Property p = ( Property ) e . nextElement ( ) ; p . execute ( ) ; } if ( antFile == null ) antFile = "build.xml" ; File file = new File ( antFile ) ; if ( ! file . isAbsolute ( ) ) { antFile = ( new File ( dir , antFile ) ) . getAbsolutePath ( ) ; file = ( new File ( antFile ) ) ; if ( ! file . isFile ( ) ) { throw new BuildException ( "Build file " + file + " not found." ) ; } } p1 . setUserProperty ( "ant.file" , antFile ) ; ProjectHelper . configureProject ( p1 , new File ( antFile ) ) ; if ( target == null ) { target = p1 . getDefaultTarget ( ) ; } if ( p1 . getBaseDir ( ) . equals ( project . getBaseDir ( ) ) && p1 . getProperty ( "ant.file" ) . equals ( project . getProperty ( "ant.file" ) ) && getOwningTarget ( ) != null && target . equals ( this . getOwningTarget ( ) . getName ( ) ) ) { throw new BuildException ( "ant task calling its own parent target" ) ; } p1 . executeTarget ( target ) ; } finally { p1 = null ; } } public void setDir ( File d ) { this . dir = d ; } public void setAntfile ( String s ) { this . antFile = s ; } public void setTarget ( String s ) { this . target = s ; } public void setOutput ( String s ) { this . output = s ; } public Property createProperty ( ) { if ( p1 == null ) { reinit ( ) ; } Property p = ( Property ) p1 . createTask ( "property" ) ; p . setUserProperty ( true ) ; properties . addElement ( p ) ; return p ; } } 	1	['13', '3', '0', '10', '78', '8', '1', '9', '9', '0.75', '502', '0.714285714', '1', '0.755102041', '0.384615385', '2', '3', '37.07692308', '8', '2', '3']
package org . apache . tools . ant ; import java . util . * ; import java . io . * ; public class PathTokenizer { private StringTokenizer tokenizer ; private String lookahead = null ; private boolean dosStyleFilesystem ; public PathTokenizer ( String path ) { tokenizer = new StringTokenizer ( path , ":;" , false ) ; dosStyleFilesystem = File . pathSeparatorChar == ';' ; } public boolean hasMoreTokens ( ) { if ( lookahead != null ) { return true ; } return tokenizer . hasMoreTokens ( ) ; } public String nextToken ( ) throws NoSuchElementException { String token = null ; if ( lookahead != null ) { token = lookahead ; lookahead = null ; } else { token = tokenizer . nextToken ( ) . trim ( ) ; } if ( token . length ( ) == 1 && Character . isLetter ( token . charAt ( 0 ) ) && dosStyleFilesystem && tokenizer . hasMoreTokens ( ) ) { String nextToken = tokenizer . nextToken ( ) . trim ( ) ; if ( nextToken . startsWith ( "\\" ) || nextToken . startsWith ( "/" ) ) { token += ":" + nextToken ; } else { lookahead = nextToken ; } } return token ; } } 	0	['3', '1', '0', '2', '15', '0', '2', '0', '3', '0.166666667', '100', '1', '0', '0', '0.666666667', '0', '0', '31.33333333', '2', '1', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; public class And extends ConditionBase implements Condition { public boolean eval ( ) throws BuildException { Enumeration enum = getConditions ( ) ; while ( enum . hasMoreElements ( ) ) { Condition c = ( Condition ) enum . nextElement ( ) ; if ( ! c . eval ( ) ) { return false ; } } return true ; } } 	1	['2', '3', '0', '3', '7', '1', '1', '3', '2', '2', '23', '0', '0', '0.96969697', '1', '0', '0', '10.5', '1', '0.5', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . util . * ; import java . io . * ; public abstract class Definer extends Task { private String name ; private String value ; private Path classpath ; private File file ; private String resource ; private boolean reverseLoader = false ; public void setReverseLoader ( boolean reverseLoader ) { this . reverseLoader = reverseLoader ; log ( "The reverseloader attribute is DEPRECATED. It will be removed" , Project . MSG_WARN ) ; } public void setClasspath ( Path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( project ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void execute ( ) throws BuildException { AntClassLoader al = createLoader ( ) ; if ( file == null && resource == null ) { if ( name == null || value == null ) { String msg = "name or classname attributes of " + getTaskName ( ) + " element " + "are undefined" ; throw new BuildException ( msg ) ; } addDefinition ( al , name , value ) ; } else { try { if ( name != null || value != null ) { String msg = "You must not specify name or value " + "together with file or resource." ; throw new BuildException ( msg , location ) ; } if ( file != null && resource != null ) { String msg = "You must not specify both, file and resource." ; throw new BuildException ( msg , location ) ; } Properties props = new Properties ( ) ; InputStream is = null ; if ( file != null ) { log ( "Loading definitions from file " + file , Project . MSG_VERBOSE ) ; is = new FileInputStream ( file ) ; if ( is == null ) { log ( "Could not load definitions from file " + file + ". It doesn\'t exist." , Project . MSG_WARN ) ; } } if ( resource != null ) { log ( "Loading definitions from resource " + resource , Project . MSG_VERBOSE ) ; is = al . getResourceAsStream ( resource ) ; if ( is == null ) { log ( "Could not load definitions from resource " + resource + ". It could not be found." , Project . MSG_WARN ) ; } } if ( is != null ) { props . load ( is ) ; Enumeration keys = props . keys ( ) ; while ( keys . hasMoreElements ( ) ) { String n = ( String ) keys . nextElement ( ) ; String v = props . getProperty ( n ) ; addDefinition ( al , n , v ) ; } } } catch ( IOException ex ) { throw new BuildException ( ex , location ) ; } } } private void addDefinition ( ClassLoader al , String name , String value ) { try { Class c = al . loadClass ( value ) ; AntClassLoader . initializeClass ( c ) ; addDefinition ( name , c ) ; } catch ( ClassNotFoundException cnfe ) { String msg = getTaskName ( ) + " class " + value + " cannot be found" ; throw new BuildException ( msg , cnfe , location ) ; } catch ( NoClassDefFoundError ncdfe ) { String msg = getTaskName ( ) + " class " + value + " cannot be found" ; throw new BuildException ( msg , ncdfe , location ) ; } } private AntClassLoader createLoader ( ) { AntClassLoader al = null ; if ( classpath != null ) { al = new AntClassLoader ( project , classpath , ! reverseLoader ) ; } else { al = new AntClassLoader ( project , Path . systemClasspath , ! reverseLoader ) ; } al . addSystemPackageRoot ( "org.apache.tools.ant" ) ; return al ; } public void setFile ( File file ) { this . file = file ; } public void setResource ( String res ) { this . resource = res ; } public void setName ( String name ) { this . name = name ; } public String getClassname ( ) { return value ; } public void setClassname ( String v ) { value = v ; } protected abstract void addDefinition ( String name , Class c ) ; } 	0	['14', '3', '2', '11', '41', '67', '3', '8', '11', '0.846153846', '366', '1', '1', '0.74', '0.223214286', '1', '1', '24.71428571', '4', '1.2857', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . * ; import org . apache . tools . ant . util . * ; import org . apache . tools . ant . taskdefs . compilers . * ; import org . apache . tools . ant . Task ; import java . io . * ; import java . util . * ; public class Recorder extends Task { private String filename = null ; private Boolean append = null ; private Boolean start = null ; private int loglevel = - 1 ; private static Hashtable recorderEntries = new Hashtable ( ) ; public void setName ( String fname ) { filename = fname ; } public void setAction ( ActionChoices action ) { if ( action . getValue ( ) . equalsIgnoreCase ( "start" ) ) { start = Boolean . TRUE ; } else { start = Boolean . FALSE ; } } public void setAppend ( boolean append ) { this . append = new Boolean ( append ) ; } public void setLoglevel ( VerbosityLevelChoices level ) { String lev = level . getValue ( ) ; if ( lev . equalsIgnoreCase ( "error" ) ) { loglevel = Project . MSG_ERR ; } else if ( lev . equalsIgnoreCase ( "warn" ) ) { loglevel = Project . MSG_WARN ; } else if ( lev . equalsIgnoreCase ( "info" ) ) { loglevel = Project . MSG_INFO ; } else if ( lev . equalsIgnoreCase ( "verbose" ) ) { loglevel = Project . MSG_VERBOSE ; } else if ( lev . equalsIgnoreCase ( "debug" ) ) { loglevel = Project . MSG_DEBUG ; } } public void execute ( ) throws BuildException { if ( filename == null ) throw new BuildException ( "No filename specified" ) ; getProject ( ) . log ( "setting a recorder for name " + filename , Project . MSG_DEBUG ) ; RecorderEntry recorder = getRecorder ( filename , getProject ( ) ) ; recorder . setMessageOutputLevel ( loglevel ) ; recorder . setRecordState ( start ) ; } public static class ActionChoices extends EnumeratedAttribute { private static final String [ ] values = { "start" , "stop" } ; public String [ ] getValues ( ) { return values ; } } public static class VerbosityLevelChoices extends EnumeratedAttribute { private static final String [ ] values = { "error" , "warn" , "info" , "verbose" , "debug" } ; public String [ ] getValues ( ) { return values ; } } protected RecorderEntry getRecorder ( String name , Project proj ) throws BuildException { Object o = recorderEntries . get ( name ) ; RecorderEntry entry ; if ( o == null ) { try { entry = new RecorderEntry ( name ) ; PrintStream out = null ; if ( append == null ) { out = new PrintStream ( new FileOutputStream ( name ) ) ; } else { out = new PrintStream ( new FileOutputStream ( name , append . booleanValue ( ) ) ) ; } entry . setErrorPrintStream ( out ) ; entry . setOutputPrintStream ( out ) ; } catch ( IOException ioe ) { throw new BuildException ( "Problems creating a recorder entry" , ioe ) ; } proj . addBuildListener ( entry ) ; recorderEntries . put ( name , entry ) ; } else { entry = ( RecorderEntry ) o ; } return entry ; } } 	1	['8', '3', '0', '9', '32', '6', '0', '9', '6', '0.685714286', '201', '1', '0', '0.860465116', '0.30952381', '1', '1', '23.5', '6', '1.5', '1']
package org . apache . tools . ant ; import java . io . * ; import java . util . * ; import org . xml . sax . * ; import org . w3c . dom . * ; import org . apache . tools . ant . taskdefs . * ; import javax . xml . parsers . * ; public class ProjectHelper { private static SAXParserFactory parserFactory = null ; private org . xml . sax . Parser parser ; private Project project ; private File buildFile ; private File buildFileParent ; private Locator locator ; public static void configureProject ( Project project , File buildFile ) throws BuildException { new ProjectHelper ( project , buildFile ) . parse ( ) ; } private ProjectHelper ( Project project , File buildFile ) { this . project = project ; this . buildFile = new File ( buildFile . getAbsolutePath ( ) ) ; buildFileParent = new File ( this . buildFile . getParent ( ) ) ; } private void parse ( ) throws BuildException { FileInputStream inputStream = null ; InputSource inputSource = null ; try { SAXParser saxParser = getParserFactory ( ) . newSAXParser ( ) ; parser = saxParser . getParser ( ) ; String uri = "file:" + buildFile . getAbsolutePath ( ) . replace ( '\\' , '/' ) ; for ( int index = uri . indexOf ( '#' ) ; index != - 1 ; index = uri . indexOf ( '#' ) ) { uri = uri . substring ( 0 , index ) + "%23" + uri . substring ( index + 1 ) ; } inputStream = new FileInputStream ( buildFile ) ; inputSource = new InputSource ( inputStream ) ; inputSource . setSystemId ( uri ) ; project . log ( "parsing buildfile " + buildFile + " with URI = " + uri , Project . MSG_VERBOSE ) ; saxParser . parse ( inputSource , new RootHandler ( ) ) ; } catch ( ParserConfigurationException exc ) { throw new BuildException ( "Parser has not been configured correctly" , exc ) ; } catch ( SAXParseException exc ) { Location location = new Location ( buildFile . toString ( ) , exc . getLineNumber ( ) , exc . getColumnNumber ( ) ) ; Throwable t = exc . getException ( ) ; if ( t instanceof BuildException ) { BuildException be = ( BuildException ) t ; if ( be . getLocation ( ) == Location . UNKNOWN_LOCATION ) { be . setLocation ( location ) ; } throw be ; } throw new BuildException ( exc . getMessage ( ) , t , location ) ; } catch ( SAXException exc ) { Throwable t = exc . getException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( exc . getMessage ( ) , t ) ; } catch ( FileNotFoundException exc ) { throw new BuildException ( exc ) ; } catch ( IOException exc ) { throw new BuildException ( "Error reading project file" , exc ) ; } finally { if ( inputStream != null ) { try { inputStream . close ( ) ; } catch ( IOException ioe ) { } } } } private class AbstractHandler extends HandlerBase { protected DocumentHandler parentHandler ; public AbstractHandler ( DocumentHandler parentHandler ) { this . parentHandler = parentHandler ; parser . setDocumentHandler ( this ) ; } public void startElement ( String tag , AttributeList attrs ) throws SAXParseException { throw new SAXParseException ( "Unexpected element \"" + tag + "\"" , locator ) ; } public void characters ( char [ ] buf , int start , int end ) throws SAXParseException { String s = new String ( buf , start , end ) . trim ( ) ; if ( s . length ( ) > 0 ) { throw new SAXParseException ( "Unexpected text \"" + s + "\"" , locator ) ; } } protected void finished ( ) { } public void endElement ( String name ) throws SAXException { finished ( ) ; parser . setDocumentHandler ( parentHandler ) ; } } private class RootHandler extends HandlerBase { public InputSource resolveEntity ( String publicId , String systemId ) { project . log ( "resolving systemId: " + systemId , Project . MSG_VERBOSE ) ; if ( systemId . startsWith ( "file:" ) ) { String path = systemId . substring ( 5 ) ; int index = path . indexOf ( "file:" ) ; while ( index != - 1 ) { path = path . substring ( 0 , index ) + path . substring ( index + 5 ) ; index = path . indexOf ( "file:" ) ; } String entitySystemId = path ; index = path . indexOf ( "%23" ) ; while ( index != - 1 ) { path = path . substring ( 0 , index ) + "#" + path . substring ( index + 3 ) ; index = path . indexOf ( "%23" ) ; } File file = new File ( path ) ; if ( ! file . isAbsolute ( ) ) { file = new File ( buildFileParent , path ) ; } try { InputSource inputSource = new InputSource ( new FileInputStream ( file ) ) ; inputSource . setSystemId ( "file:" + entitySystemId ) ; return inputSource ; } catch ( FileNotFoundException fne ) { project . log ( file . getAbsolutePath ( ) + " could not be found" , Project . MSG_WARN ) ; } } return null ; } public void startElement ( String tag , AttributeList attrs ) throws SAXParseException { if ( tag . equals ( "project" ) ) { new ProjectHandler ( this ) . init ( tag , attrs ) ; } else { throw new SAXParseException ( "Config file is not of expected XML type" , locator ) ; } } public void setDocumentLocator ( Locator locator ) { ProjectHelper . this . locator = locator ; } } private class ProjectHandler extends AbstractHandler { public ProjectHandler ( DocumentHandler parentHandler ) { super ( parentHandler ) ; } public void init ( String tag , AttributeList attrs ) throws SAXParseException { String def = null ; String name = null ; String id = null ; String baseDir = null ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String key = attrs . getName ( i ) ; String value = attrs . getValue ( i ) ; if ( key . equals ( "default" ) ) { def = value ; } else if ( key . equals ( "name" ) ) { name = value ; } else if ( key . equals ( "id" ) ) { id = value ; } else if ( key . equals ( "basedir" ) ) { baseDir = value ; } else { throw new SAXParseException ( "Unexpected attribute \"" + attrs . getName ( i ) + "\"" , locator ) ; } } if ( def == null ) { throw new SAXParseException ( "The default attribute of project is required" , locator ) ; } project . setDefaultTarget ( def ) ; if ( name != null ) { project . setName ( name ) ; project . addReference ( name , project ) ; } if ( id != null ) project . addReference ( id , project ) ; if ( project . getProperty ( "basedir" ) != null ) { project . setBasedir ( project . getProperty ( "basedir" ) ) ; } else { if ( baseDir == null ) { project . setBasedir ( buildFileParent . getAbsolutePath ( ) ) ; } else { if ( ( new File ( baseDir ) ) . isAbsolute ( ) ) { project . setBasedir ( baseDir ) ; } else { project . setBaseDir ( project . resolveFile ( baseDir , buildFileParent ) ) ; } } } } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { if ( name . equals ( "taskdef" ) ) { handleTaskdef ( name , attrs ) ; } else if ( name . equals ( "property" ) ) { handleProperty ( name , attrs ) ; } else if ( name . equals ( "target" ) ) { handleTarget ( name , attrs ) ; } else if ( project . getDataTypeDefinitions ( ) . get ( name ) != null ) { handleDataType ( name , attrs ) ; } else { throw new SAXParseException ( "Unexpected element \"" + name + "\"" , locator ) ; } } private void handleTaskdef ( String name , AttributeList attrs ) throws SAXParseException { ( new TaskHandler ( this , null , null ) ) . init ( name , attrs ) ; } private void handleProperty ( String name , AttributeList attrs ) throws SAXParseException { ( new TaskHandler ( this , null , null ) ) . init ( name , attrs ) ; } private void handleTarget ( String tag , AttributeList attrs ) throws SAXParseException { new TargetHandler ( this ) . init ( tag , attrs ) ; } private void handleDataType ( String name , AttributeList attrs ) throws SAXParseException { new DataTypeHandler ( this ) . init ( name , attrs ) ; } } private class TargetHandler extends AbstractHandler { private Target target ; public TargetHandler ( DocumentHandler parentHandler ) { super ( parentHandler ) ; } public void init ( String tag , AttributeList attrs ) throws SAXParseException { String name = null ; String depends = "" ; String ifCond = null ; String unlessCond = null ; String id = null ; String description = null ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String key = attrs . getName ( i ) ; String value = attrs . getValue ( i ) ; if ( key . equals ( "name" ) ) { name = value ; } else if ( key . equals ( "depends" ) ) { depends = value ; } else if ( key . equals ( "if" ) ) { ifCond = value ; } else if ( key . equals ( "unless" ) ) { unlessCond = value ; } else if ( key . equals ( "id" ) ) { id = value ; } else if ( key . equals ( "description" ) ) { description = value ; } else { throw new SAXParseException ( "Unexpected attribute \"" + key + "\"" , locator ) ; } } if ( name == null ) { throw new SAXParseException ( "target element appears without a name attribute" , locator ) ; } target = new Target ( ) ; target . setName ( name ) ; target . setIf ( ifCond ) ; target . setUnless ( unlessCond ) ; target . setDescription ( description ) ; project . addTarget ( name , target ) ; if ( id != null && ! id . equals ( "" ) ) project . addReference ( id , target ) ; if ( depends . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( depends , "," , false ) ; while ( tok . hasMoreTokens ( ) ) { target . addDependency ( tok . nextToken ( ) . trim ( ) ) ; } } } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { if ( project . getDataTypeDefinitions ( ) . get ( name ) != null ) { new DataTypeHandler ( this , target ) . init ( name , attrs ) ; } else { new TaskHandler ( this , target , target ) . init ( name , attrs ) ; } } } private class TaskHandler extends AbstractHandler { private Target target ; private TaskContainer container ; private Task task ; private RuntimeConfigurable wrapper = null ; public TaskHandler ( DocumentHandler parentHandler , TaskContainer container , Target target ) { super ( parentHandler ) ; this . container = container ; this . target = target ; } public void init ( String tag , AttributeList attrs ) throws SAXParseException { try { task = project . createTask ( tag ) ; } catch ( BuildException e ) { } if ( task == null ) { task = new UnknownElement ( tag ) ; task . setProject ( project ) ; task . setTaskType ( tag ) ; task . setTaskName ( tag ) ; } task . setLocation ( new Location ( buildFile . toString ( ) , locator . getLineNumber ( ) , locator . getColumnNumber ( ) ) ) ; configureId ( task , attrs ) ; if ( target != null ) { task . setOwningTarget ( target ) ; container . addTask ( task ) ; task . init ( ) ; wrapper = task . getRuntimeConfigurableWrapper ( ) ; wrapper . setAttributes ( attrs ) ; } else { task . init ( ) ; configure ( task , attrs , project ) ; } } protected void finished ( ) { if ( task != null && target == null ) { task . execute ( ) ; } } public void characters ( char [ ] buf , int start , int end ) throws SAXParseException { if ( wrapper == null ) { try { addText ( project , task , buf , start , end ) ; } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , locator , exc ) ; } } else { wrapper . addText ( buf , start , end ) ; } } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { if ( task instanceof TaskContainer ) { new TaskHandler ( this , ( TaskContainer ) task , target ) . init ( name , attrs ) ; } else { new NestedElementHandler ( this , task , wrapper , target ) . init ( name , attrs ) ; } } } private class NestedElementHandler extends AbstractHandler { private Object parent ; private Object child ; private RuntimeConfigurable parentWrapper ; private RuntimeConfigurable childWrapper = null ; private Target target ; public NestedElementHandler ( DocumentHandler parentHandler , Object parent , RuntimeConfigurable parentWrapper , Target target ) { super ( parentHandler ) ; if ( parent instanceof TaskAdapter ) { this . parent = ( ( TaskAdapter ) parent ) . getProxy ( ) ; } else { this . parent = parent ; } this . parentWrapper = parentWrapper ; this . target = target ; } public void init ( String propType , AttributeList attrs ) throws SAXParseException { Class parentClass = parent . getClass ( ) ; IntrospectionHelper ih = IntrospectionHelper . getHelper ( parentClass ) ; try { if ( parent instanceof UnknownElement ) { child = new UnknownElement ( propType . toLowerCase ( ) ) ; ( ( UnknownElement ) parent ) . addChild ( ( UnknownElement ) child ) ; } else { child = ih . createElement ( project , parent , propType . toLowerCase ( ) ) ; } configureId ( child , attrs ) ; if ( parentWrapper != null ) { childWrapper = new RuntimeConfigurable ( child , propType ) ; childWrapper . setAttributes ( attrs ) ; parentWrapper . addChild ( childWrapper ) ; } else { configure ( child , attrs , project ) ; ih . storeElement ( project , parent , child , propType . toLowerCase ( ) ) ; } } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , locator , exc ) ; } } public void characters ( char [ ] buf , int start , int end ) throws SAXParseException { if ( parentWrapper == null ) { try { addText ( project , child , buf , start , end ) ; } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , locator , exc ) ; } } else { childWrapper . addText ( buf , start , end ) ; } } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { if ( child instanceof TaskContainer ) { new TaskHandler ( this , ( TaskContainer ) child , target ) . init ( name , attrs ) ; } else { new NestedElementHandler ( this , child , childWrapper , target ) . init ( name , attrs ) ; } } } private class DataTypeHandler extends AbstractHandler { private Target target ; private Object element ; private RuntimeConfigurable wrapper = null ; public DataTypeHandler ( DocumentHandler parentHandler ) { this ( parentHandler , null ) ; } public DataTypeHandler ( DocumentHandler parentHandler , Target target ) { super ( parentHandler ) ; this . target = target ; } public void init ( String propType , AttributeList attrs ) throws SAXParseException { try { element = project . createDataType ( propType ) ; if ( element == null ) { throw new BuildException ( "Unknown data type " + propType ) ; } if ( target != null ) { wrapper = new RuntimeConfigurable ( element , propType ) ; wrapper . setAttributes ( attrs ) ; target . addDataType ( wrapper ) ; } else { configure ( element , attrs , project ) ; configureId ( element , attrs ) ; } } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , locator , exc ) ; } } public void characters ( char [ ] buf , int start , int end ) throws SAXParseException { try { addText ( project , element , buf , start , end ) ; } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , locator , exc ) ; } } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { new NestedElementHandler ( this , element , wrapper , target ) . init ( name , attrs ) ; } } public static void configure ( Object target , AttributeList attrs , Project project ) throws BuildException { if ( target instanceof TaskAdapter ) target = ( ( TaskAdapter ) target ) . getProxy ( ) ; IntrospectionHelper ih = IntrospectionHelper . getHelper ( target . getClass ( ) ) ; project . addBuildListener ( ih ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String value = replaceProperties ( project , attrs . getValue ( i ) , project . getProperties ( ) ) ; try { ih . setAttribute ( project , target , attrs . getName ( i ) . toLowerCase ( ) , value ) ; } catch ( BuildException be ) { if ( ! attrs . getName ( i ) . equals ( "id" ) ) { throw be ; } } } } public static void addText ( Project project , Object target , char [ ] buf , int start , int end ) throws BuildException { addText ( project , target , new String ( buf , start , end ) ) ; } public static void addText ( Project project , Object target , String text ) throws BuildException { if ( text == null || text . trim ( ) . length ( ) == 0 ) { return ; } if ( target instanceof TaskAdapter ) target = ( ( TaskAdapter ) target ) . getProxy ( ) ; IntrospectionHelper . getHelper ( target . getClass ( ) ) . addText ( project , target , text ) ; } public static void storeChild ( Project project , Object parent , Object child , String tag ) { IntrospectionHelper ih = IntrospectionHelper . getHelper ( parent . getClass ( ) ) ; ih . storeElement ( project , parent , child , tag ) ; } public static String replaceProperties ( Project project , String value , Hashtable keys ) throws BuildException { if ( value == null ) { return null ; } Vector fragments = new Vector ( ) ; Vector propertyRefs = new Vector ( ) ; parsePropertyString ( value , fragments , propertyRefs ) ; StringBuffer sb = new StringBuffer ( ) ; Enumeration i = fragments . elements ( ) ; Enumeration j = propertyRefs . elements ( ) ; while ( i . hasMoreElements ( ) ) { String fragment = ( String ) i . nextElement ( ) ; if ( fragment == null ) { String propertyName = ( String ) j . nextElement ( ) ; if ( ! keys . containsKey ( propertyName ) ) { project . log ( "Property ${" + propertyName + "} has not been set" , Project . MSG_VERBOSE ) ; } fragment = ( keys . containsKey ( propertyName ) ) ? ( String ) keys . get ( propertyName ) : "${" + propertyName + "}" ; } sb . append ( fragment ) ; } return sb . toString ( ) ; } public static void parsePropertyString ( String value , Vector fragments , Vector propertyRefs ) throws BuildException { int prev = 0 ; int pos ; while ( ( pos = value . indexOf ( "$" , prev ) ) >= 0 ) { if ( pos > 0 ) { fragments . addElement ( value . substring ( prev , pos ) ) ; } if ( pos == ( value . length ( ) - 1 ) ) { fragments . addElement ( "$" ) ; prev = pos + 1 ; } else if ( value . charAt ( pos + 1 ) != '{' ) { fragments . addElement ( value . substring ( pos + 1 , pos + 2 ) ) ; prev = pos + 2 ; } else { int endName = value . indexOf ( '}' , pos ) ; if ( endName < 0 ) { throw new BuildException ( "Syntax error in property: " + value ) ; } String propertyName = value . substring ( pos + 2 , endName ) ; fragments . addElement ( null ) ; propertyRefs . addElement ( propertyName ) ; prev = endName + 1 ; } } if ( prev < value . length ( ) ) { fragments . addElement ( value . substring ( prev ) ) ; } } private static SAXParserFactory getParserFactory ( ) { if ( parserFactory == null ) { parserFactory = SAXParserFactory . newInstance ( ) ; } return parserFactory ; } private void configureId ( Object target , AttributeList attr ) { String id = attr . getValue ( "id" ) ; if ( id != null ) { project . addReference ( id , target ) ; } } } 	0	['19', '1', '0', '24', '81', '147', '17', '8', '7', '0.861111111', '560', '1', '1', '0', '0.171296296', '0', '0', '28.15789474', '2', '1', '0']
package org . apache . tools . ant . listener ; import org . apache . tools . ant . * ; import org . apache . log4j . Category ; import org . apache . log4j . helpers . NullEnumeration ; public class Log4jListener implements BuildListener { static final String LOG4J_CONFIG_PROPERTY = "log4j.configuration" ; private boolean initialized = false ; public Log4jListener ( ) { initialized = false ; Category cat = Category . getInstance ( "org.apache.tools.ant" ) ; Category rootCat = Category . getRoot ( ) ; if ( ! ( rootCat . getAllAppenders ( ) instanceof NullEnumeration ) ) { initialized = true ; } else { cat . error ( "No log4j.properties in build area" ) ; } } public void buildStarted ( BuildEvent event ) { if ( initialized ) { Category cat = Category . getInstance ( Project . class . getName ( ) ) ; cat . info ( "Build started." ) ; } } public void buildFinished ( BuildEvent event ) { if ( initialized ) { Category cat = Category . getInstance ( Project . class . getName ( ) ) ; if ( event . getException ( ) == null ) { cat . info ( "Build finished." ) ; } else { cat . error ( "Build finished with error." , event . getException ( ) ) ; } } } public void targetStarted ( BuildEvent event ) { if ( initialized ) { Category cat = Category . getInstance ( Target . class . getName ( ) ) ; cat . info ( "Target \"" + event . getTarget ( ) . getName ( ) + "\" started." ) ; } } public void targetFinished ( BuildEvent event ) { if ( initialized ) { String targetName = event . getTarget ( ) . getName ( ) ; Category cat = Category . getInstance ( Target . class . getName ( ) ) ; if ( event . getException ( ) == null ) { cat . info ( "Target \"" + event . getTarget ( ) . getName ( ) + "\" finished." ) ; } else { cat . error ( "Target \"" + event . getTarget ( ) . getName ( ) + "\" finished with error." , event . getException ( ) ) ; } } } public void taskStarted ( BuildEvent event ) { if ( initialized ) { Task task = event . getTask ( ) ; Category cat = Category . getInstance ( task . getClass ( ) . getName ( ) ) ; cat . info ( "Task \"" + task . getTaskName ( ) + "\" started." ) ; } } public void taskFinished ( BuildEvent event ) { if ( initialized ) { Task task = event . getTask ( ) ; Category cat = Category . getInstance ( task . getClass ( ) . getName ( ) ) ; if ( event . getException ( ) == null ) { cat . info ( "Task \"" + task . getTaskName ( ) + "\" finished." ) ; } else { cat . error ( "Task \"" + task . getTaskName ( ) + "\" finished with error." , event . getException ( ) ) ; } } } public void messageLogged ( BuildEvent event ) { if ( initialized ) { Object categoryObject = event . getTask ( ) ; if ( categoryObject == null ) { categoryObject = event . getTarget ( ) ; if ( categoryObject == null ) { categoryObject = event . getProject ( ) ; } } Category cat = Category . getInstance ( categoryObject . getClass ( ) . getName ( ) ) ; switch ( event . getPriority ( ) ) { case Project . MSG_ERR : cat . error ( event . getMessage ( ) ) ; break ; case Project . MSG_WARN : cat . warn ( event . getMessage ( ) ) ; break ; case Project . MSG_INFO : cat . info ( event . getMessage ( ) ) ; break ; case Project . MSG_VERBOSE : cat . debug ( event . getMessage ( ) ) ; break ; case Project . MSG_DEBUG : cat . debug ( event . getMessage ( ) ) ; break ; default : cat . error ( event . getMessage ( ) ) ; break ; } } } } 	1	['9', '1', '0', '7', '34', '0', '0', '7', '8', '0.75', '298', '0.25', '0', '0', '0.592592593', '0', '0', '31.66666667', '5', '2.7778', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; import java . util . * ; public class KeySubst extends Task { private File source = null ; private File dest = null ; private String sep = "*" ; private Hashtable replacements = new Hashtable ( ) ; public void execute ( ) throws BuildException { log ( "!! KeySubst is deprecated. Use Filter + CopyDir instead. !!" ) ; log ( "Performing Substitions" ) ; if ( source == null || dest == null ) { log ( "Source and destinations must not be null" ) ; return ; } BufferedReader br = null ; BufferedWriter bw = null ; try { br = new BufferedReader ( new FileReader ( source ) ) ; dest . delete ( ) ; bw = new BufferedWriter ( new FileWriter ( dest ) ) ; String line = null ; String newline = null ; int length ; line = br . readLine ( ) ; while ( line != null ) { if ( line . length ( ) == 0 ) { bw . newLine ( ) ; } else { newline = KeySubst . replace ( line , replacements ) ; bw . write ( newline ) ; bw . newLine ( ) ; } line = br . readLine ( ) ; } bw . flush ( ) ; bw . close ( ) ; br . close ( ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } } public void setSrc ( File s ) { this . source = s ; } public void setDest ( File dest ) { this . dest = dest ; } public void setSep ( String sep ) { this . sep = sep ; } public void setKeys ( String keys ) { if ( keys != null && keys . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( keys , this . sep , false ) ; while ( tok . hasMoreTokens ( ) ) { String token = tok . nextToken ( ) . trim ( ) ; StringTokenizer itok = new StringTokenizer ( token , "=" , false ) ; String name = itok . nextToken ( ) ; String value = itok . nextToken ( ) ; replacements . put ( name , value ) ; } } } public static void main ( String [ ] args ) { try { Hashtable hash = new Hashtable ( ) ; hash . put ( "VERSION" , "1.0.3" ) ; hash . put ( "b" , "ffff" ) ; System . out . println ( KeySubst . replace ( "$f ${VERSION} f ${b} jj $" , hash ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public static String replace ( String origString , Hashtable keys ) throws BuildException { StringBuffer finalString = new StringBuffer ( ) ; int index = 0 ; int i = 0 ; String key = null ; while ( ( index = origString . indexOf ( "${" , i ) ) > - 1 ) { key = origString . substring ( index + 2 , origString . indexOf ( "}" , index + 3 ) ) ; finalString . append ( origString . substring ( i , index ) ) ; if ( keys . containsKey ( key ) ) { finalString . append ( keys . get ( key ) ) ; } else { finalString . append ( "${" ) ; finalString . append ( key ) ; finalString . append ( "}" ) ; } i = index + 3 + key . length ( ) ; } finalString . append ( origString . substring ( i ) ) ; return finalString . toString ( ) ; } } 	0	['8', '3', '0', '2', '39', '10', '0', '2', '8', '0.714285714', '265', '1', '0', '0.840909091', '0.325', '1', '1', '31.625', '4', '1.25', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Environment ; import java . io . * ; public class Cvs extends Task { private Commandline cmd = new Commandline ( ) ; private String cvsRoot ; private String pack ; private String command = "checkout" ; private boolean quiet = false ; private boolean noexec = false ; private int port = 0 ; private File passFile = null ; private File dest ; private File output ; private File error ; private boolean failOnError = false ; public void execute ( ) throws BuildException { Commandline toExecute = new Commandline ( ) ; toExecute . setExecutable ( "cvs" ) ; if ( cvsRoot != null ) { toExecute . createArgument ( ) . setValue ( "-d" ) ; toExecute . createArgument ( ) . setValue ( cvsRoot ) ; } if ( noexec ) { toExecute . createArgument ( ) . setValue ( "-n" ) ; } if ( quiet ) { toExecute . createArgument ( ) . setValue ( "-q" ) ; } toExecute . createArgument ( ) . setLine ( command ) ; toExecute . addArguments ( cmd . getCommandline ( ) ) ; if ( pack != null ) { toExecute . createArgument ( ) . setLine ( pack ) ; } Environment env = new Environment ( ) ; if ( port > 0 ) { Environment . Variable var = new Environment . Variable ( ) ; var . setKey ( "CVS_CLIENT_PORT" ) ; var . setValue ( String . valueOf ( port ) ) ; env . addVariable ( var ) ; } if ( passFile != null ) { Environment . Variable var = new Environment . Variable ( ) ; var . setKey ( "CVS_PASSFILE" ) ; var . setValue ( String . valueOf ( passFile ) ) ; env . addVariable ( var ) ; } ExecuteStreamHandler streamhandler = null ; OutputStream outputstream = null ; OutputStream errorstream = null ; if ( error == null && output == null ) { streamhandler = new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) ; } else { if ( output != null ) { try { outputstream = new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( output ) ) ) ; } catch ( IOException e ) { throw new BuildException ( e , location ) ; } } else { outputstream = new LogOutputStream ( this , Project . MSG_INFO ) ; } if ( error != null ) { try { errorstream = new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( error ) ) ) ; } catch ( IOException e ) { throw new BuildException ( e , location ) ; } } else { errorstream = new LogOutputStream ( this , Project . MSG_WARN ) ; } streamhandler = new PumpStreamHandler ( outputstream , errorstream ) ; } Execute exe = new Execute ( streamhandler , null ) ; exe . setAntRun ( project ) ; if ( dest == null ) dest = project . getBaseDir ( ) ; exe . setWorkingDirectory ( dest ) ; exe . setCommandline ( toExecute . getCommandline ( ) ) ; exe . setEnvironment ( env . getVariables ( ) ) ; try { int retCode = exe . execute ( ) ; if ( failOnError && retCode != 0 ) throw new BuildException ( "cvs exited with error code " + retCode ) ; } catch ( IOException e ) { throw new BuildException ( e , location ) ; } finally { if ( output != null ) { try { outputstream . close ( ) ; } catch ( IOException e ) { } } if ( error != null ) { try { errorstream . close ( ) ; } catch ( IOException e ) { } } } } public void setCvsRoot ( String root ) { if ( root != null ) { if ( root . trim ( ) . equals ( "" ) ) root = null ; } this . cvsRoot = root ; } public void setPort ( int port ) { this . port = port ; } public void setPassfile ( File passFile ) { this . passFile = passFile ; } public void setDest ( File dest ) { this . dest = dest ; } public void setPackage ( String p ) { this . pack = p ; } public void setTag ( String p ) { if ( p != null && p . trim ( ) . length ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-r" ) ; cmd . createArgument ( ) . setValue ( p ) ; } } public void setDate ( String p ) { if ( p != null && p . trim ( ) . length ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-D" ) ; cmd . createArgument ( ) . setValue ( p ) ; } } public void setCommand ( String c ) { this . command = c ; } public void setQuiet ( boolean q ) { quiet = q ; } public void setNoexec ( boolean ne ) { noexec = ne ; } public void setOutput ( File output ) { this . output = output ; } public void setError ( File error ) { this . error = error ; } public void setFailOnError ( boolean failOnError ) { this . failOnError = failOnError ; } } 	1	['15', '3', '0', '15', '54', '59', '0', '15', '15', '0.880952381', '398', '1', '1', '0.725490196', '0.373333333', '0', '0', '24.73333333', '3', '1.3333', '1']
package org . apache . tools . ant ; import java . io . * ; import java . util . * ; public class DirectoryScanner implements FileScanner { protected final static String [ ] DEFAULTEXCLUDES = { "**/*~" , "**/#*#" , "**/.#*" , "**/%*%" , "**/CVS" , "**/CVS/**" , "**/.cvsignore" , "**/SCCS" , "**/SCCS/**" , "**/vssver.scc" } ; protected File basedir ; protected String [ ] includes ; protected String [ ] excludes ; protected Vector filesIncluded ; protected Vector filesNotIncluded ; protected Vector filesExcluded ; protected Vector dirsIncluded ; protected Vector dirsNotIncluded ; protected Vector dirsExcluded ; protected boolean haveSlowResults = false ; public DirectoryScanner ( ) { } protected static boolean matchPatternStart ( String pattern , String str ) { if ( str . startsWith ( File . separator ) != pattern . startsWith ( File . separator ) ) { return false ; } Vector patDirs = new Vector ( ) ; StringTokenizer st = new StringTokenizer ( pattern , File . separator ) ; while ( st . hasMoreTokens ( ) ) { patDirs . addElement ( st . nextToken ( ) ) ; } Vector strDirs = new Vector ( ) ; st = new StringTokenizer ( str , File . separator ) ; while ( st . hasMoreTokens ( ) ) { strDirs . addElement ( st . nextToken ( ) ) ; } int patIdxStart = 0 ; int patIdxEnd = patDirs . size ( ) - 1 ; int strIdxStart = 0 ; int strIdxEnd = strDirs . size ( ) - 1 ; while ( patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd ) { String patDir = ( String ) patDirs . elementAt ( patIdxStart ) ; if ( patDir . equals ( "**" ) ) { break ; } if ( ! match ( patDir , ( String ) strDirs . elementAt ( strIdxStart ) ) ) { return false ; } patIdxStart ++ ; strIdxStart ++ ; } if ( strIdxStart > strIdxEnd ) { return true ; } else if ( patIdxStart > patIdxEnd ) { return false ; } else { return true ; } } protected static boolean matchPath ( String pattern , String str ) { if ( str . startsWith ( File . separator ) != pattern . startsWith ( File . separator ) ) { return false ; } Vector patDirs = new Vector ( ) ; StringTokenizer st = new StringTokenizer ( pattern , File . separator ) ; while ( st . hasMoreTokens ( ) ) { patDirs . addElement ( st . nextToken ( ) ) ; } Vector strDirs = new Vector ( ) ; st = new StringTokenizer ( str , File . separator ) ; while ( st . hasMoreTokens ( ) ) { strDirs . addElement ( st . nextToken ( ) ) ; } int patIdxStart = 0 ; int patIdxEnd = patDirs . size ( ) - 1 ; int strIdxStart = 0 ; int strIdxEnd = strDirs . size ( ) - 1 ; while ( patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd ) { String patDir = ( String ) patDirs . elementAt ( patIdxStart ) ; if ( patDir . equals ( "**" ) ) { break ; } if ( ! match ( patDir , ( String ) strDirs . elementAt ( strIdxStart ) ) ) { return false ; } patIdxStart ++ ; strIdxStart ++ ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( ! patDirs . elementAt ( i ) . equals ( "**" ) ) { return false ; } } return true ; } else { if ( patIdxStart > patIdxEnd ) { return false ; } } while ( patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd ) { String patDir = ( String ) patDirs . elementAt ( patIdxEnd ) ; if ( patDir . equals ( "**" ) ) { break ; } if ( ! match ( patDir , ( String ) strDirs . elementAt ( strIdxEnd ) ) ) { return false ; } patIdxEnd -- ; strIdxEnd -- ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( ! patDirs . elementAt ( i ) . equals ( "**" ) ) { return false ; } } return true ; } while ( patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd ) { int patIdxTmp = - 1 ; for ( int i = patIdxStart + 1 ; i <= patIdxEnd ; i ++ ) { if ( patDirs . elementAt ( i ) . equals ( "**" ) ) { patIdxTmp = i ; break ; } } if ( patIdxTmp == patIdxStart + 1 ) { patIdxStart ++ ; continue ; } int patLength = ( patIdxTmp - patIdxStart - 1 ) ; int strLength = ( strIdxEnd - strIdxStart + 1 ) ; int foundIdx = - 1 ; strLoop : for ( int i = 0 ; i <= strLength - patLength ; i ++ ) { for ( int j = 0 ; j < patLength ; j ++ ) { String subPat = ( String ) patDirs . elementAt ( patIdxStart + j + 1 ) ; String subStr = ( String ) strDirs . elementAt ( strIdxStart + i + j ) ; if ( ! match ( subPat , subStr ) ) { continue strLoop ; } } foundIdx = strIdxStart + i ; break ; } if ( foundIdx == - 1 ) { return false ; } patIdxStart = patIdxTmp ; strIdxStart = foundIdx + patLength ; } for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( ! patDirs . elementAt ( i ) . equals ( "**" ) ) { return false ; } } return true ; } protected static boolean match ( String pattern , String str ) { char [ ] patArr = pattern . toCharArray ( ) ; char [ ] strArr = str . toCharArray ( ) ; int patIdxStart = 0 ; int patIdxEnd = patArr . length - 1 ; int strIdxStart = 0 ; int strIdxEnd = strArr . length - 1 ; char ch ; boolean containsStar = false ; for ( int i = 0 ; i < patArr . length ; i ++ ) { if ( patArr [ i ] == '*' ) { containsStar = true ; break ; } } if ( ! containsStar ) { if ( patIdxEnd != strIdxEnd ) { return false ; } for ( int i = 0 ; i <= patIdxEnd ; i ++ ) { ch = patArr [ i ] ; if ( ch != '?' && ch != strArr [ i ] ) { return false ; } } return true ; } if ( patIdxEnd == 0 ) { return true ; } while ( ( ch = patArr [ patIdxStart ] ) != '*' && strIdxStart <= strIdxEnd ) { if ( ch != '?' && ch != strArr [ strIdxStart ] ) { return false ; } patIdxStart ++ ; strIdxStart ++ ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != '*' ) { return false ; } } return true ; } while ( ( ch = patArr [ patIdxEnd ] ) != '*' && strIdxStart <= strIdxEnd ) { if ( ch != '?' && ch != strArr [ strIdxEnd ] ) { return false ; } patIdxEnd -- ; strIdxEnd -- ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != '*' ) { return false ; } } return true ; } while ( patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd ) { int patIdxTmp = - 1 ; for ( int i = patIdxStart + 1 ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] == '*' ) { patIdxTmp = i ; break ; } } if ( patIdxTmp == patIdxStart + 1 ) { patIdxStart ++ ; continue ; } int patLength = ( patIdxTmp - patIdxStart - 1 ) ; int strLength = ( strIdxEnd - strIdxStart + 1 ) ; int foundIdx = - 1 ; strLoop : for ( int i = 0 ; i <= strLength - patLength ; i ++ ) { for ( int j = 0 ; j < patLength ; j ++ ) { ch = patArr [ patIdxStart + j + 1 ] ; if ( ch != '?' && ch != strArr [ strIdxStart + i + j ] ) { continue strLoop ; } } foundIdx = strIdxStart + i ; break ; } if ( foundIdx == - 1 ) { return false ; } patIdxStart = patIdxTmp ; strIdxStart = foundIdx + patLength ; } for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != '*' ) { return false ; } } return true ; } public void setBasedir ( String basedir ) { setBasedir ( new File ( basedir . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ) ) ; } public void setBasedir ( File basedir ) { this . basedir = basedir ; } public File getBasedir ( ) { return basedir ; } public void setIncludes ( String [ ] includes ) { if ( includes == null ) { this . includes = null ; } else { this . includes = new String [ includes . length ] ; for ( int i = 0 ; i < includes . length ; i ++ ) { String pattern ; pattern = includes [ i ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( pattern . endsWith ( File . separator ) ) { pattern += "**" ; } this . includes [ i ] = pattern ; } } } public void setExcludes ( String [ ] excludes ) { if ( excludes == null ) { this . excludes = null ; } else { this . excludes = new String [ excludes . length ] ; for ( int i = 0 ; i < excludes . length ; i ++ ) { String pattern ; pattern = excludes [ i ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( pattern . endsWith ( File . separator ) ) { pattern += "**" ; } this . excludes [ i ] = pattern ; } } } public void scan ( ) { if ( basedir == null ) { throw new IllegalStateException ( "No basedir set" ) ; } if ( ! basedir . exists ( ) ) { throw new IllegalStateException ( "basedir " + basedir + " does not exist" ) ; } if ( ! basedir . isDirectory ( ) ) { throw new IllegalStateException ( "basedir " + basedir + " is not a directory" ) ; } if ( includes == null ) { includes = new String [ 1 ] ; includes [ 0 ] = "**" ; } if ( excludes == null ) { excludes = new String [ 0 ] ; } filesIncluded = new Vector ( ) ; filesNotIncluded = new Vector ( ) ; filesExcluded = new Vector ( ) ; dirsIncluded = new Vector ( ) ; dirsNotIncluded = new Vector ( ) ; dirsExcluded = new Vector ( ) ; if ( isIncluded ( "" ) ) { if ( ! isExcluded ( "" ) ) { dirsIncluded . addElement ( "" ) ; } else { dirsExcluded . addElement ( "" ) ; } } else { dirsNotIncluded . addElement ( "" ) ; } scandir ( basedir , "" , true ) ; } protected void slowScan ( ) { if ( haveSlowResults ) { return ; } String [ ] excl = new String [ dirsExcluded . size ( ) ] ; dirsExcluded . copyInto ( excl ) ; String [ ] notIncl = new String [ dirsNotIncluded . size ( ) ] ; dirsNotIncluded . copyInto ( notIncl ) ; for ( int i = 0 ; i < excl . length ; i ++ ) { if ( ! couldHoldIncluded ( excl [ i ] ) ) { scandir ( new File ( basedir , excl [ i ] ) , excl [ i ] + File . separator , false ) ; } } for ( int i = 0 ; i < notIncl . length ; i ++ ) { if ( ! couldHoldIncluded ( notIncl [ i ] ) ) { scandir ( new File ( basedir , notIncl [ i ] ) , notIncl [ i ] + File . separator , false ) ; } } haveSlowResults = true ; } protected void scandir ( File dir , String vpath , boolean fast ) { String [ ] newfiles = dir . list ( ) ; if ( newfiles == null ) { throw new BuildException ( "IO error scanning directory " + dir . getAbsolutePath ( ) ) ; } for ( int i = 0 ; i < newfiles . length ; i ++ ) { String name = vpath + newfiles [ i ] ; File file = new File ( dir , newfiles [ i ] ) ; if ( file . isDirectory ( ) ) { if ( isIncluded ( name ) ) { if ( ! isExcluded ( name ) ) { dirsIncluded . addElement ( name ) ; if ( fast ) { scandir ( file , name + File . separator , fast ) ; } } else { dirsExcluded . addElement ( name ) ; if ( fast && couldHoldIncluded ( name ) ) { scandir ( file , name + File . separator , fast ) ; } } } else { dirsNotIncluded . addElement ( name ) ; if ( fast && couldHoldIncluded ( name ) ) { scandir ( file , name + File . separator , fast ) ; } } if ( ! fast ) { scandir ( file , name + File . separator , fast ) ; } } else if ( file . isFile ( ) ) { if ( isIncluded ( name ) ) { if ( ! isExcluded ( name ) ) { filesIncluded . addElement ( name ) ; } else { filesExcluded . addElement ( name ) ; } } else { filesNotIncluded . addElement ( name ) ; } } } } protected boolean isIncluded ( String name ) { for ( int i = 0 ; i < includes . length ; i ++ ) { if ( matchPath ( includes [ i ] , name ) ) { return true ; } } return false ; } protected boolean couldHoldIncluded ( String name ) { for ( int i = 0 ; i < includes . length ; i ++ ) { if ( matchPatternStart ( includes [ i ] , name ) ) { return true ; } } return false ; } protected boolean isExcluded ( String name ) { for ( int i = 0 ; i < excludes . length ; i ++ ) { if ( matchPath ( excludes [ i ] , name ) ) { return true ; } } return false ; } public String [ ] getIncludedFiles ( ) { int count = filesIncluded . size ( ) ; String [ ] files = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { files [ i ] = ( String ) filesIncluded . elementAt ( i ) ; } return files ; } public String [ ] getNotIncludedFiles ( ) { slowScan ( ) ; int count = filesNotIncluded . size ( ) ; String [ ] files = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { files [ i ] = ( String ) filesNotIncluded . elementAt ( i ) ; } return files ; } public String [ ] getExcludedFiles ( ) { slowScan ( ) ; int count = filesExcluded . size ( ) ; String [ ] files = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { files [ i ] = ( String ) filesExcluded . elementAt ( i ) ; } return files ; } public String [ ] getIncludedDirectories ( ) { int count = dirsIncluded . size ( ) ; String [ ] directories = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { directories [ i ] = ( String ) dirsIncluded . elementAt ( i ) ; } return directories ; } public String [ ] getNotIncludedDirectories ( ) { slowScan ( ) ; int count = dirsNotIncluded . size ( ) ; String [ ] directories = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { directories [ i ] = ( String ) dirsNotIncluded . elementAt ( i ) ; } return directories ; } public String [ ] getExcludedDirectories ( ) { slowScan ( ) ; int count = dirsExcluded . size ( ) ; String [ ] directories = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { directories [ i ] = ( String ) dirsExcluded . elementAt ( i ) ; } return directories ; } public void addDefaultExcludes ( ) { int excludesLength = excludes == null ? 0 : excludes . length ; String [ ] newExcludes ; newExcludes = new String [ excludesLength + DEFAULTEXCLUDES . length ] ; if ( excludesLength > 0 ) { System . arraycopy ( excludes , 0 , newExcludes , 0 , excludesLength ) ; } for ( int i = 0 ; i < DEFAULTEXCLUDES . length ; i ++ ) { newExcludes [ i + excludesLength ] = DEFAULTEXCLUDES [ i ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; } excludes = newExcludes ; } } 	0	['23', '1', '1', '25', '52', '181', '23', '2', '14', '0.731404959', '1489', '1', '0', '0', '0.290909091', '0', '0', '63.26086957', '35', '6.087', '0']
package org . apache . tools . ant . types ; import java . util . * ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; public class CommandlineJava implements Cloneable { private Commandline vmCommand = new Commandline ( ) ; private Commandline javaCommand = new Commandline ( ) ; private SysProperties sysProperties = new SysProperties ( ) ; private Path classpath = null ; private String vmVersion ; private String maxMemory = null ; private boolean executeJar = false ; public static class SysProperties extends Environment implements Cloneable { Properties sys = null ; public String [ ] getVariables ( ) throws BuildException { String props [ ] = super . getVariables ( ) ; if ( props == null ) return null ; for ( int i = 0 ; i < props . length ; i ++ ) { props [ i ] = "-D" + props [ i ] ; } return props ; } public int size ( ) { return variables . size ( ) ; } public void setSystem ( ) throws BuildException { try { Properties p = new Properties ( sys = System . getProperties ( ) ) ; for ( Enumeration e = variables . elements ( ) ; e . hasMoreElements ( ) ; ) { Environment . Variable v = ( Environment . Variable ) e . nextElement ( ) ; p . put ( v . getKey ( ) , v . getValue ( ) ) ; } System . setProperties ( p ) ; } catch ( SecurityException e ) { throw new BuildException ( "Cannot modify system properties" , e ) ; } } public void restoreSystem ( ) throws BuildException { if ( sys == null ) throw new BuildException ( "Unbalanced nesting of SysProperties" ) ; try { System . setProperties ( sys ) ; sys = null ; } catch ( SecurityException e ) { throw new BuildException ( "Cannot modify system properties" , e ) ; } } public Object clone ( ) { try { SysProperties c = ( SysProperties ) super . clone ( ) ; c . variables = ( Vector ) variables . clone ( ) ; return c ; } catch ( CloneNotSupportedException e ) { return null ; } } } public CommandlineJava ( ) { setVm ( getJavaExecutableName ( ) ) ; setVmversion ( Project . getJavaVersion ( ) ) ; } public Commandline . Argument createArgument ( ) { return javaCommand . createArgument ( ) ; } public Commandline . Argument createVmArgument ( ) { return vmCommand . createArgument ( ) ; } public void addSysproperty ( Environment . Variable sysp ) { sysProperties . addVariable ( sysp ) ; } public void setVm ( String vm ) { vmCommand . setExecutable ( vm ) ; } public void setVmversion ( String value ) { vmVersion = value ; } public void setJar ( String jarpathname ) { javaCommand . setExecutable ( jarpathname ) ; executeJar = true ; } public String getJar ( ) { if ( executeJar ) { return javaCommand . getExecutable ( ) ; } return null ; } public void setClassname ( String classname ) { javaCommand . setExecutable ( classname ) ; executeJar = false ; } public String getClassname ( ) { if ( ! executeJar ) { return javaCommand . getExecutable ( ) ; } return null ; } public Path createClasspath ( Project p ) { if ( classpath == null ) { classpath = new Path ( p ) ; } return classpath ; } public String getVmversion ( ) { return vmVersion ; } public String [ ] getCommandline ( ) { String [ ] result = new String [ size ( ) ] ; int pos = 0 ; String [ ] vmArgs = getActualVMCommand ( ) . getCommandline ( ) ; result [ pos ++ ] = vmArgs [ 0 ] ; if ( executeJar ) { result [ pos ++ ] = "-jar" ; } System . arraycopy ( vmArgs , 1 , result , pos , vmArgs . length - 1 ) ; pos += vmArgs . length - 1 ; if ( sysProperties . size ( ) > 0 ) { System . arraycopy ( sysProperties . getVariables ( ) , 0 , result , pos , sysProperties . size ( ) ) ; pos += sysProperties . size ( ) ; } Path fullClasspath = classpath != null ? classpath . concatSystemClasspath ( "ignore" ) : null ; if ( fullClasspath != null && fullClasspath . toString ( ) . trim ( ) . length ( ) > 0 ) { result [ pos ++ ] = "-classpath" ; result [ pos ++ ] = fullClasspath . toString ( ) ; } System . arraycopy ( javaCommand . getCommandline ( ) , 0 , result , pos , javaCommand . size ( ) ) ; return result ; } public void setMaxmemory ( String max ) { this . maxMemory = max ; } public String toString ( ) { return Commandline . toString ( getCommandline ( ) ) ; } private Commandline getActualVMCommand ( ) { Commandline actualVMCommand = ( Commandline ) vmCommand . clone ( ) ; if ( maxMemory != null ) { if ( vmVersion . startsWith ( "1.1" ) ) { actualVMCommand . createArgument ( ) . setValue ( "-mx" + maxMemory ) ; } else { actualVMCommand . createArgument ( ) . setValue ( "-Xmx" + maxMemory ) ; } } return actualVMCommand ; } public int size ( ) { int size = getActualVMCommand ( ) . size ( ) + javaCommand . size ( ) + sysProperties . size ( ) ; Path fullClasspath = classpath != null ? classpath . concatSystemClasspath ( "ignore" ) : null ; if ( fullClasspath != null && fullClasspath . toString ( ) . trim ( ) . length ( ) > 0 ) { size += 2 ; } if ( executeJar ) { size ++ ; } return size ; } public Commandline getJavaCommand ( ) { return javaCommand ; } public Commandline getVmCommand ( ) { return getActualVMCommand ( ) ; } public Path getClasspath ( ) { return classpath ; } public void setSystemProperties ( ) throws BuildException { sysProperties . setSystem ( ) ; } public void restoreSystemProperties ( ) throws BuildException { sysProperties . restoreSystem ( ) ; } public SysProperties getSystemProperties ( ) { return sysProperties ; } public Object clone ( ) { CommandlineJava c = new CommandlineJava ( ) ; c . vmCommand = ( Commandline ) vmCommand . clone ( ) ; c . javaCommand = ( Commandline ) javaCommand . clone ( ) ; c . sysProperties = ( SysProperties ) sysProperties . clone ( ) ; c . maxMemory = maxMemory ; if ( classpath != null ) { c . classpath = ( Path ) classpath . clone ( ) ; } c . vmVersion = vmVersion ; c . executeJar = executeJar ; return c ; } public void clearJavaArgs ( ) { javaCommand . clearArgs ( ) ; } private String getJavaExecutableName ( ) { String os = System . getProperty ( "os.name" ) . toLowerCase ( ) ; boolean dosBased = os . indexOf ( "windows" ) >= 0 || os . indexOf ( "os/2" ) >= 0 ; String extension = dosBased ? ".exe" : "" ; java . io . File jExecutable = new java . io . File ( System . getProperty ( "java.home" ) + "/../bin/java" + extension ) ; if ( jExecutable . exists ( ) ) { return jExecutable . getAbsolutePath ( ) ; } else { return "java" ; } } } 	1	['26', '1', '0', '9', '62', '119', '1', '8', '24', '0.68', '437', '1', '4', '0', '0.317307692', '0', '0', '15.53846154', '6', '1.6923', '1']
package org . apache . tools . ant . types ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class FilterSetCollection { private Vector filterSets = new Vector ( ) ; public FilterSetCollection ( ) { } public FilterSetCollection ( FilterSet filterSet ) { addFilterSet ( filterSet ) ; } public void addFilterSet ( FilterSet filterSet ) { filterSets . addElement ( filterSet ) ; } public String replaceTokens ( String line ) { String replacedLine = line ; for ( Enumeration e = filterSets . elements ( ) ; e . hasMoreElements ( ) ; ) { FilterSet filterSet = ( FilterSet ) e . nextElement ( ) ; replacedLine = filterSet . replaceTokens ( replacedLine ) ; } return replacedLine ; } public boolean hasFilters ( ) { for ( Enumeration e = filterSets . elements ( ) ; e . hasMoreElements ( ) ; ) { FilterSet filterSet = ( FilterSet ) e . nextElement ( ) ; if ( filterSet . hasFilters ( ) ) { return true ; } } return false ; } } 	0	['5', '1', '0', '5', '13', '0', '4', '1', '5', '0', '69', '1', '0', '0', '0.533333333', '0', '0', '12.6', '3', '1.2', '0']
package org . apache . tools . ant . taskdefs . rmic ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; import java . io . * ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; public class WLRmic extends DefaultRmicAdapter { public boolean execute ( ) throws BuildException { getRmic ( ) . log ( "Using WebLogic rmic" , Project . MSG_VERBOSE ) ; Commandline cmd = setupRmicCommand ( new String [ ] { "-noexit" } ) ; try { Class c = Class . forName ( "weblogic.rmic" ) ; Method doRmic = c . getMethod ( "main" , new Class [ ] { String [ ] . class } ) ; doRmic . invoke ( null , new Object [ ] { cmd . getArguments ( ) } ) ; return true ; } catch ( ClassNotFoundException ex ) { throw new BuildException ( "Cannot use WebLogic rmic, as it is not available" + " A common solution is to set the environment variable" + " CLASSPATH." , getRmic ( ) . getLocation ( ) ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting WebLogic rmic: " , ex , getRmic ( ) . getLocation ( ) ) ; } } } public String getStubClassSuffix ( ) { return "_WLStub" ; } public String getSkelClassSuffix ( ) { return "_WLSkel" ; } } 	1	['5', '2', '0', '7', '18', '10', '1', '6', '4', '1', '95', '0', '0', '0.764705882', '0.5', '0', '0', '17.8', '1', '0.8', '1']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . * ; public class JavacExternal extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using external javac compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = new Commandline ( ) ; cmd . setExecutable ( "javac" ) ; setupJavacCommandlineSwitches ( cmd ) ; int firstFileName = cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } } 	0	['2', '2', '0', '6', '11', '1', '1', '5', '2', '2', '37', '0', '0', '0.958333333', '1', '0', '0', '17.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import org . apache . tools . ant . util . * ; import java . io . * ; import java . util . * ; public class Copy extends Task { protected File file = null ; protected File destFile = null ; protected File destDir = null ; protected Vector filesets = new Vector ( ) ; protected boolean filtering = false ; protected boolean preserveLastModified = false ; protected boolean forceOverwrite = false ; protected boolean flatten = false ; protected int verbosity = Project . MSG_VERBOSE ; protected boolean includeEmpty = true ; protected Hashtable fileCopyMap = new Hashtable ( ) ; protected Hashtable dirCopyMap = new Hashtable ( ) ; protected Mapper mapperElement = null ; private Vector filterSets = new Vector ( ) ; private FileUtils fileUtils ; public Copy ( ) { fileUtils = FileUtils . newFileUtils ( ) ; } protected FileUtils getFileUtils ( ) { return fileUtils ; } public void setFile ( File file ) { this . file = file ; } public void setTofile ( File destFile ) { this . destFile = destFile ; } public void setTodir ( File destDir ) { this . destDir = destDir ; } public FilterSet createFilterSet ( ) { FilterSet filterSet = new FilterSet ( ) ; filterSets . addElement ( filterSet ) ; return filterSet ; } public void setPreserveLastModified ( String preserve ) { preserveLastModified = Project . toBoolean ( preserve ) ; } protected Vector getFilterSets ( ) { return filterSets ; } public void setFiltering ( boolean filtering ) { this . filtering = filtering ; } public void setOverwrite ( boolean overwrite ) { this . forceOverwrite = overwrite ; } public void setFlatten ( boolean flatten ) { this . flatten = flatten ; } public void setVerbose ( boolean verbose ) { if ( verbose ) { this . verbosity = Project . MSG_INFO ; } else { this . verbosity = Project . MSG_VERBOSE ; } } public void setIncludeEmptyDirs ( boolean includeEmpty ) { this . includeEmpty = includeEmpty ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" , location ) ; } mapperElement = new Mapper ( project ) ; return mapperElement ; } public void execute ( ) throws BuildException { validateAttributes ( ) ; if ( file != null ) { if ( file . exists ( ) ) { if ( destFile == null ) { destFile = new File ( destDir , file . getName ( ) ) ; } if ( forceOverwrite || ( file . lastModified ( ) > destFile . lastModified ( ) ) ) { fileCopyMap . put ( file . getAbsolutePath ( ) , destFile . getAbsolutePath ( ) ) ; } else { log ( file + " omitted as " + destFile + " is up to date." , Project . MSG_VERBOSE ) ; } } else { String message = "Could not find file " + file . getAbsolutePath ( ) + " to copy." ; log ( message ) ; throw new BuildException ( message ) ; } } for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; File fromDir = fs . getDir ( project ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; String [ ] srcDirs = ds . getIncludedDirectories ( ) ; scan ( fromDir , destDir , srcFiles , srcDirs ) ; } doFileOperations ( ) ; if ( destFile != null ) { destDir = null ; } } protected void validateAttributes ( ) throws BuildException { if ( file == null && filesets . size ( ) == 0 ) { throw new BuildException ( "Specify at least one source - a file or a fileset." ) ; } if ( destFile != null && destDir != null ) { throw new BuildException ( "Only one of destfile and destdir may be set." ) ; } if ( destFile == null && destDir == null ) { throw new BuildException ( "One of destfile or destdir must be set." ) ; } if ( file != null && file . exists ( ) && file . isDirectory ( ) ) { throw new BuildException ( "Use a fileset to copy directories." ) ; } if ( destFile != null && filesets . size ( ) > 0 ) { throw new BuildException ( "Cannot concatenate multple files into a single file." ) ; } if ( destFile != null ) { destDir = new File ( destFile . getParent ( ) ) ; } } protected void scan ( File fromDir , File toDir , String [ ] files , String [ ] dirs ) { FileNameMapper mapper = null ; if ( mapperElement != null ) { mapper = mapperElement . getImplementation ( ) ; } else if ( flatten ) { mapper = new FlatFileNameMapper ( ) ; } else { mapper = new IdentityMapper ( ) ; } buildMap ( fromDir , toDir , files , mapper , fileCopyMap ) ; if ( includeEmpty ) { buildMap ( fromDir , toDir , dirs , mapper , dirCopyMap ) ; } } protected void buildMap ( File fromDir , File toDir , String [ ] names , FileNameMapper mapper , Hashtable map ) { String [ ] toCopy = null ; if ( forceOverwrite ) { Vector v = new Vector ( ) ; for ( int i = 0 ; i < names . length ; i ++ ) { if ( mapper . mapFileName ( names [ i ] ) != null ) { v . addElement ( names [ i ] ) ; } } toCopy = new String [ v . size ( ) ] ; v . copyInto ( toCopy ) ; } else { SourceFileScanner ds = new SourceFileScanner ( this ) ; toCopy = ds . restrict ( names , fromDir , toDir , mapper ) ; } for ( int i = 0 ; i < toCopy . length ; i ++ ) { File src = new File ( fromDir , toCopy [ i ] ) ; File dest = new File ( toDir , mapper . mapFileName ( toCopy [ i ] ) [ 0 ] ) ; map . put ( src . getAbsolutePath ( ) , dest . getAbsolutePath ( ) ) ; } } protected void doFileOperations ( ) { if ( fileCopyMap . size ( ) > 0 ) { log ( "Copying " + fileCopyMap . size ( ) + " file" + ( fileCopyMap . size ( ) == 1 ? "" : "s" ) + " to " + destDir . getAbsolutePath ( ) ) ; Enumeration e = fileCopyMap . keys ( ) ; while ( e . hasMoreElements ( ) ) { String fromFile = ( String ) e . nextElement ( ) ; String toFile = ( String ) fileCopyMap . get ( fromFile ) ; if ( fromFile . equals ( toFile ) ) { log ( "Skipping self-copy of " + fromFile , verbosity ) ; continue ; } try { log ( "Copying " + fromFile + " to " + toFile , verbosity ) ; FilterSetCollection executionFilters = new FilterSetCollection ( ) ; if ( filtering ) { executionFilters . addFilterSet ( project . getGlobalFilterSet ( ) ) ; } for ( Enumeration filterEnum = filterSets . elements ( ) ; filterEnum . hasMoreElements ( ) ; ) { executionFilters . addFilterSet ( ( FilterSet ) filterEnum . nextElement ( ) ) ; } fileUtils . copyFile ( fromFile , toFile , executionFilters , forceOverwrite , preserveLastModified ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } } } if ( includeEmpty ) { Enumeration e = dirCopyMap . elements ( ) ; int count = 0 ; while ( e . hasMoreElements ( ) ) { File d = new File ( ( String ) e . nextElement ( ) ) ; if ( ! d . exists ( ) ) { if ( ! d . mkdirs ( ) ) { log ( "Unable to create directory " + d . getAbsolutePath ( ) , Project . MSG_ERR ) ; } else { count ++ ; } } } if ( count > 0 ) { log ( "Copied " + count + " empty director" + ( count == 1 ? "y" : "ies" ) + " to " + destDir . getAbsolutePath ( ) ) ; } } } } 	1	['20', '3', '1', '16', '74', '92', '1', '15', '14', '0.824561404', '720', '1', '2', '0.660714286', '0.225', '2', '2', '34.25', '13', '1.95', '2']
package org . apache . tools . ant . taskdefs ; public class Transform extends ExecuteOn { } 	0	['1', '5', '0', '1', '2', '0', '0', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . tools . ant . taskdefs . rmic ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; public class RmicAdapterFactory { private RmicAdapterFactory ( ) { } public static RmicAdapter getRmic ( String rmicType , Task task ) throws BuildException { if ( rmicType == null ) { try { Class . forName ( "sun.rmi.rmic.Main" ) ; rmicType = "sun" ; } catch ( ClassNotFoundException cnfe ) { try { Class . forName ( "kaffe.rmi.rmic.RMIC" ) ; Class . forName ( "kaffe.tools.compiler.Compiler" ) ; rmicType = "kaffe" ; } catch ( ClassNotFoundException cnfk ) { throw new BuildException ( "Couldn\'t guess rmic implementation" ) ; } } } if ( rmicType . equalsIgnoreCase ( "sun" ) ) { return new SunRmic ( ) ; } else if ( rmicType . equalsIgnoreCase ( "kaffe" ) ) { return new KaffeRmic ( ) ; } else if ( rmicType . equalsIgnoreCase ( "weblogic" ) ) { return new WLRmic ( ) ; } return resolveClassName ( rmicType ) ; } private static RmicAdapter resolveClassName ( String className ) throws BuildException { try { Class c = Class . forName ( className ) ; Object o = c . newInstance ( ) ; return ( RmicAdapter ) o ; } catch ( ClassNotFoundException cnfe ) { throw new BuildException ( className + " can\'t be found." , cnfe ) ; } catch ( ClassCastException cce ) { throw new BuildException ( className + " isn\'t the classname of " + "a rmic adapter." , cce ) ; } catch ( Throwable t ) { throw new BuildException ( className + " caused an interesting " + "exception." , t ) ; } } } 	1	['3', '1', '0', '7', '15', '3', '1', '6', '1', '2', '112', '0', '0', '0', '0.444444444', '0', '0', '36.33333333', '1', '0.6667', '1']
package org . apache . tools . ant . util ; public class GlobPatternMapper implements FileNameMapper { protected String fromPrefix = null ; protected String fromPostfix = null ; protected int prefixLength ; protected int postfixLength ; protected String toPrefix = null ; protected String toPostfix = null ; public void setFrom ( String from ) { int index = from . lastIndexOf ( "*" ) ; if ( index == - 1 ) { fromPrefix = from ; fromPostfix = "" ; } else { fromPrefix = from . substring ( 0 , index ) ; fromPostfix = from . substring ( index + 1 ) ; } prefixLength = fromPrefix . length ( ) ; postfixLength = fromPostfix . length ( ) ; } public void setTo ( String to ) { int index = to . lastIndexOf ( "*" ) ; if ( index == - 1 ) { toPrefix = to ; toPostfix = "" ; } else { toPrefix = to . substring ( 0 , index ) ; toPostfix = to . substring ( index + 1 ) ; } } public String [ ] mapFileName ( String sourceFileName ) { if ( fromPrefix == null || ! sourceFileName . startsWith ( fromPrefix ) || ! sourceFileName . endsWith ( fromPostfix ) ) { return null ; } return new String [ ] { toPrefix + extractVariablePart ( sourceFileName ) + toPostfix } ; } protected String extractVariablePart ( String name ) { return name . substring ( prefixLength , name . length ( ) - postfixLength ) ; } } 	0	['5', '1', '0', '2', '15', '0', '1', '1', '4', '0.5', '137', '1', '0', '0', '0.9', '0', '0', '25.2', '4', '1.8', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . util . Enumeration ; import java . util . NoSuchElementException ; import java . util . Vector ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . Available ; import org . apache . tools . ant . taskdefs . UpToDate ; public abstract class ConditionBase { private Vector conditions = new Vector ( ) ; private Project project ; public void setProject ( Project p ) { this . project = p ; } protected Project getProject ( ) { return project ; } protected int countConditions ( ) { return conditions . size ( ) ; } protected final Enumeration getConditions ( ) { return new ConditionEnumeration ( ) ; } public void addAvailable ( Available a ) { conditions . addElement ( a ) ; } public void addUptodate ( UpToDate u ) { conditions . addElement ( u ) ; } public void addNot ( Not n ) { conditions . addElement ( n ) ; } public void addAnd ( And a ) { conditions . addElement ( a ) ; } public void addOr ( Or o ) { conditions . addElement ( o ) ; } public void addEquals ( Equals e ) { conditions . addElement ( e ) ; } public void addOs ( Os o ) { conditions . addElement ( o ) ; } private class ConditionEnumeration implements Enumeration { private int currentElement = 0 ; public boolean hasMoreElements ( ) { return countConditions ( ) > currentElement ; } public Object nextElement ( ) throws NoSuchElementException { Object o = null ; try { o = conditions . elementAt ( currentElement ++ ) ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new NoSuchElementException ( ) ; } if ( o instanceof Task ) { ( ( Task ) o ) . setProject ( getProject ( ) ) ; } else if ( o instanceof ConditionBase ) { ( ( ConditionBase ) o ) . setProject ( getProject ( ) ) ; } return o ; } } } 	1	['13', '1', '4', '11', '18', '0', '5', '10', '9', '0.583333333', '78', '1', '1', '0', '0.161538462', '0', '0', '4.846153846', '1', '0.9231', '1']
package org . apache . tools . ant . util ; public class MergingMapper implements FileNameMapper { protected String [ ] mergedFile = null ; public void setFrom ( String from ) { } public void setTo ( String to ) { mergedFile = new String [ ] { to } ; } public String [ ] mapFileName ( String sourceFileName ) { return mergedFile ; } } 	0	['4', '1', '0', '4', '5', '0', '3', '1', '4', '0.333333333', '24', '1', '0', '0', '0.875', '0', '0', '4.75', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; public class CallTarget extends Task { private Ant callee ; private String subTarget ; private boolean initialized = false ; private boolean inheritAll = true ; public void setInheritAll ( boolean inherit ) { inheritAll = inherit ; } public void init ( ) { callee = ( Ant ) project . createTask ( "ant" ) ; callee . setOwningTarget ( target ) ; callee . setTaskName ( getTaskName ( ) ) ; callee . setLocation ( location ) ; callee . init ( ) ; initialized = true ; } public void execute ( ) { if ( ! initialized ) { init ( ) ; } if ( subTarget == null ) { throw new BuildException ( "Attribute target is required." , location ) ; } callee . setDir ( project . getBaseDir ( ) ) ; callee . setAntfile ( project . getProperty ( "ant.file" ) ) ; callee . setTarget ( subTarget ) ; callee . setInheritAll ( inheritAll ) ; callee . execute ( ) ; } public Property createParam ( ) { return callee . createProperty ( ) ; } public void setTarget ( String target ) { subTarget = target ; } protected void handleOutput ( String line ) { if ( callee != null ) { callee . handleOutput ( line ) ; } else { super . handleOutput ( line ) ; } } protected void handleErrorOutput ( String line ) { if ( callee != null ) { callee . handleErrorOutput ( line ) ; } else { super . handleErrorOutput ( line ) ; } } } 	1	['8', '3', '0', '8', '28', '0', '0', '8', '6', '0.678571429', '128', '1', '1', '0.840909091', '0.5', '2', '4', '14.5', '3', '1.375', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . io . * ; import java . util . * ; public abstract class MatchingTask extends Task { protected boolean useDefaultExcludes = true ; protected FileSet fileset = new FileSet ( ) ; public PatternSet . NameEntry createInclude ( ) { return fileset . createInclude ( ) ; } public PatternSet . NameEntry createIncludesFile ( ) { return fileset . createIncludesFile ( ) ; } public PatternSet . NameEntry createExclude ( ) { return fileset . createExclude ( ) ; } public PatternSet . NameEntry createExcludesFile ( ) { return fileset . createExcludesFile ( ) ; } public PatternSet createPatternSet ( ) { return fileset . createPatternSet ( ) ; } public void setIncludes ( String includes ) { fileset . setIncludes ( includes ) ; } public void XsetItems ( String itemString ) { log ( "The items attribute is deprecated. " + "Please use the includes attribute." , Project . MSG_WARN ) ; if ( itemString == null || itemString . equals ( "*" ) || itemString . equals ( "." ) ) { createInclude ( ) . setName ( "**" ) ; } else { StringTokenizer tok = new StringTokenizer ( itemString , ", " ) ; while ( tok . hasMoreTokens ( ) ) { String pattern = tok . nextToken ( ) . trim ( ) ; if ( pattern . length ( ) > 0 ) { createInclude ( ) . setName ( pattern + "/**" ) ; } } } } public void setExcludes ( String excludes ) { fileset . setExcludes ( excludes ) ; } public void XsetIgnore ( String ignoreString ) { log ( "The ignore attribute is deprecated." + "Please use the excludes attribute." , Project . MSG_WARN ) ; if ( ignoreString != null && ignoreString . length ( ) > 0 ) { Vector tmpExcludes = new Vector ( ) ; StringTokenizer tok = new StringTokenizer ( ignoreString , ", " , false ) ; while ( tok . hasMoreTokens ( ) ) { createExclude ( ) . setName ( "**/" + tok . nextToken ( ) . trim ( ) + "/**" ) ; } } } public void setDefaultexcludes ( boolean useDefaultExcludes ) { this . useDefaultExcludes = useDefaultExcludes ; } protected DirectoryScanner getDirectoryScanner ( File baseDir ) { fileset . setDir ( baseDir ) ; fileset . setDefaultexcludes ( useDefaultExcludes ) ; return fileset . getDirectoryScanner ( project ) ; } public void setIncludesfile ( File includesfile ) { fileset . setIncludesfile ( includesfile ) ; } public void setExcludesfile ( File excludesfile ) { fileset . setExcludesfile ( excludesfile ) ; } } 	0	['14', '3', '12', '20', '41', '0', '13', '7', '13', '0.461538462', '174', '1', '1', '0.74', '0.392857143', '0', '0', '11.28571429', '6', '1.5', '0']
package org . apache . tools . ant . taskdefs . rmic ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Rmic ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileNameMapper ; public interface RmicAdapter { public void setRmic ( Rmic attributes ) ; public boolean execute ( ) throws BuildException ; public FileNameMapper getMapper ( ) ; public Path getClasspath ( ) ; } 	1	['4', '1', '0', '6', '4', '6', '3', '4', '4', '2', '4', '0', '0', '0', '0.625', '0', '0', '0', '1', '1', '1']
package org . apache . tools . ant . util ; public class IdentityMapper implements FileNameMapper { public void setFrom ( String from ) { } public void setTo ( String to ) { } public String [ ] mapFileName ( String sourceFileName ) { return new String [ ] { sourceFileName } ; } } 	0	['4', '1', '0', '2', '5', '6', '1', '1', '4', '2', '16', '0', '0', '0', '0.875', '0', '0', '3', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . types . * ; import org . apache . tools . ant . util . * ; import java . io . * ; import java . util . Enumeration ; import java . util . Date ; import java . util . Vector ; public class UpToDate extends MatchingTask implements Condition { private String _property ; private String _value ; private File _targetFile ; private Vector sourceFileSets = new Vector ( ) ; protected Mapper mapperElement = null ; public void setProperty ( String property ) { _property = property ; } public void setValue ( String value ) { _value = value ; } private String getValue ( ) { return ( _value != null ) ? _value : "true" ; } public void setTargetFile ( File file ) { _targetFile = file ; } public void addSrcfiles ( FileSet fs ) { sourceFileSets . addElement ( fs ) ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" , location ) ; } mapperElement = new Mapper ( project ) ; return mapperElement ; } public boolean eval ( ) { if ( sourceFileSets . size ( ) == 0 ) { throw new BuildException ( "At least one <srcfiles> element must be set" ) ; } if ( _targetFile == null && mapperElement == null ) { throw new BuildException ( "The targetfile attribute or a nested mapper element must be set" ) ; } if ( _targetFile != null && ! _targetFile . exists ( ) ) return false ; Enumeration enum = sourceFileSets . elements ( ) ; boolean upToDate = true ; while ( upToDate && enum . hasMoreElements ( ) ) { FileSet fs = ( FileSet ) enum . nextElement ( ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; upToDate = upToDate && scanDir ( fs . getDir ( project ) , ds . getIncludedFiles ( ) ) ; } return upToDate ; } public void execute ( ) throws BuildException { boolean upToDate = eval ( ) ; if ( upToDate ) { this . project . setProperty ( _property , this . getValue ( ) ) ; if ( mapperElement == null ) { log ( "File \"" + _targetFile . getAbsolutePath ( ) + "\" is up to date." , Project . MSG_VERBOSE ) ; } else { log ( "All target files have been up to date." , Project . MSG_VERBOSE ) ; } } } protected boolean scanDir ( File srcDir , String files [ ] ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; FileNameMapper mapper = null ; File dir = srcDir ; if ( mapperElement == null ) { MergingMapper mm = new MergingMapper ( ) ; mm . setTo ( _targetFile . getAbsolutePath ( ) ) ; mapper = mm ; dir = null ; } else { mapper = mapperElement . getImplementation ( ) ; } return sfs . restrict ( files , srcDir , dir , mapper ) . length == 0 ; } } 	1	['10', '4', '0', '14', '35', '11', '1', '13', '8', '0.711111111', '216', '1', '1', '0.896551724', '0.32', '1', '1', '20.1', '10', '2.1', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ExitException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . CommandlineJava ; import org . apache . tools . ant . types . Path ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . io . * ; public class ExecuteJava { private Commandline javaCommand = null ; private Path classpath = null ; private CommandlineJava . SysProperties sysProperties = null ; public void setJavaCommand ( Commandline javaCommand ) { this . javaCommand = javaCommand ; } public void setClasspath ( Path p ) { classpath = p ; } public void setSystemProperties ( CommandlineJava . SysProperties s ) { sysProperties = s ; } public void setOutput ( PrintStream out ) { } public void execute ( Project project ) throws BuildException { final String classname = javaCommand . getExecutable ( ) ; final Object [ ] argument = { javaCommand . getArguments ( ) } ; AntClassLoader loader = null ; try { if ( sysProperties != null ) { sysProperties . setSystem ( ) ; } final Class [ ] param = { Class . forName ( "[Ljava.lang.String;" ) } ; Class target = null ; if ( classpath == null ) { target = Class . forName ( classname ) ; } else { loader = new AntClassLoader ( project . getCoreLoader ( ) , project , classpath , false ) ; loader . setIsolated ( true ) ; loader . setThreadContextLoader ( ) ; target = loader . forceLoadClass ( classname ) ; AntClassLoader . initializeClass ( target ) ; } final Method main = target . getMethod ( "main" , param ) ; main . invoke ( null , argument ) ; } catch ( NullPointerException e ) { throw new BuildException ( "Could not find main() method in " + classname ) ; } catch ( ClassNotFoundException e ) { throw new BuildException ( "Could not find " + classname + ". Make sure you have it in your classpath" ) ; } catch ( InvocationTargetException e ) { Throwable t = e . getTargetException ( ) ; if ( ! ( t instanceof SecurityException ) ) { throw new BuildException ( t ) ; } else { throw ( SecurityException ) t ; } } catch ( Exception e ) { throw new BuildException ( e ) ; } finally { if ( loader != null ) { loader . resetThreadContextLoader ( ) ; loader . cleanup ( ) ; } if ( sysProperties != null ) { sysProperties . restoreSystem ( ) ; } } } } 	0	['6', '1', '0', '7', '28', '1', '1', '6', '6', '0.6', '173', '1', '3', '0', '0.305555556', '0', '0', '27.33333333', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . * ; import org . apache . tools . ant . util . * ; import org . apache . tools . ant . taskdefs . compilers . * ; import java . io . File ; public class Javac extends MatchingTask { private static final String FAIL_MSG = "Compile failed, messages should have been provided." ; private Path src ; private File destDir ; private Path compileClasspath ; private String encoding ; private boolean debug = false ; private boolean optimize = false ; private boolean deprecation = false ; private boolean depend = false ; private boolean verbose = false ; private String target ; private Path bootclasspath ; private Path extdirs ; private boolean includeAntRuntime = true ; private boolean includeJavaRuntime = false ; private boolean fork = false ; private boolean nowarn = false ; private String memoryInitialSize ; private String memoryMaximumSize ; protected boolean failOnError = true ; protected File [ ] compileList = new File [ 0 ] ; public Path createSrc ( ) { if ( src == null ) { src = new Path ( project ) ; } return src . createPath ( ) ; } public void setSrcdir ( Path srcDir ) { if ( src == null ) { src = srcDir ; } else { src . append ( srcDir ) ; } } public Path getSrcdir ( ) { return src ; } public void setDestdir ( File destDir ) { this . destDir = destDir ; } public File getDestdir ( ) { return destDir ; } public void setClasspath ( Path classpath ) { if ( compileClasspath == null ) { compileClasspath = classpath ; } else { compileClasspath . append ( classpath ) ; } } public Path getClasspath ( ) { return compileClasspath ; } public Path createClasspath ( ) { if ( compileClasspath == null ) { compileClasspath = new Path ( project ) ; } return compileClasspath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setBootclasspath ( Path bootclasspath ) { if ( this . bootclasspath == null ) { this . bootclasspath = bootclasspath ; } else { this . bootclasspath . append ( bootclasspath ) ; } } public Path getBootclasspath ( ) { return bootclasspath ; } public Path createBootclasspath ( ) { if ( bootclasspath == null ) { bootclasspath = new Path ( project ) ; } return bootclasspath . createPath ( ) ; } public void setBootClasspathRef ( Reference r ) { createBootclasspath ( ) . setRefid ( r ) ; } public void setExtdirs ( Path extdirs ) { if ( this . extdirs == null ) { this . extdirs = extdirs ; } else { this . extdirs . append ( extdirs ) ; } } public Path getExtdirs ( ) { return extdirs ; } public Path createExtdirs ( ) { if ( extdirs == null ) { extdirs = new Path ( project ) ; } return extdirs . createPath ( ) ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } public void setProceed ( boolean proceed ) { failOnError = ! proceed ; } public boolean getFailonerror ( ) { return failOnError ; } public void setDeprecation ( boolean deprecation ) { this . deprecation = deprecation ; } public boolean getDeprecation ( ) { return deprecation ; } public void setMemoryInitialSize ( String memoryInitialSize ) { this . memoryInitialSize = memoryInitialSize ; } public String getMemoryInitialSize ( ) { return memoryInitialSize ; } public void setMemoryMaximumSize ( String memoryMaximumSize ) { this . memoryMaximumSize = memoryMaximumSize ; } public String getMemoryMaximumSize ( ) { return memoryMaximumSize ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String getEncoding ( ) { return encoding ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public boolean getDebug ( ) { return debug ; } public void setOptimize ( boolean optimize ) { this . optimize = optimize ; } public boolean getOptimize ( ) { return optimize ; } public void setDepend ( boolean depend ) { this . depend = depend ; } public boolean getDepend ( ) { return depend ; } public void setVerbose ( boolean verbose ) { this . verbose = verbose ; } public boolean getVerbose ( ) { return verbose ; } public void setTarget ( String target ) { this . target = target ; } public String getTarget ( ) { return target ; } public void setIncludeantruntime ( boolean include ) { includeAntRuntime = include ; } public boolean getIncludeantruntime ( ) { return includeAntRuntime ; } public void setIncludejavaruntime ( boolean include ) { includeJavaRuntime = include ; } public boolean getIncludejavaruntime ( ) { return includeJavaRuntime ; } public void setFork ( boolean fork ) { this . fork = fork ; } public void setNowarn ( boolean flag ) { this . nowarn = flag ; } public boolean getNowarn ( ) { return nowarn ; } public void execute ( ) throws BuildException { if ( src == null ) { throw new BuildException ( "srcdir attribute must be set!" , location ) ; } String [ ] list = src . list ( ) ; if ( list . length == 0 ) { throw new BuildException ( "srcdir attribute must be set!" , location ) ; } if ( destDir != null && ! destDir . isDirectory ( ) ) { throw new BuildException ( "destination directory \"" + destDir + "\" does not exist or is not a directory" , location ) ; } resetFileLists ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { File srcDir = ( File ) project . resolveFile ( list [ i ] ) ; if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir \"" + srcDir . getPath ( ) + "\" does not exist!" , location ) ; } DirectoryScanner ds = this . getDirectoryScanner ( srcDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( srcDir , destDir != null ? destDir : srcDir , files ) ; } String compiler = project . getProperty ( "build.compiler" ) ; if ( fork ) { if ( compiler != null ) { if ( isJdkCompiler ( compiler ) ) { log ( "Since fork is true, ignoring build.compiler setting." , Project . MSG_WARN ) ; compiler = "extJavac" ; } else { log ( "Since build.compiler setting isn't classic or modern, ignoring fork setting." , Project . MSG_WARN ) ; } } else { compiler = "extJavac" ; } } if ( compiler == null ) { if ( Project . getJavaVersion ( ) != Project . JAVA_1_1 && Project . getJavaVersion ( ) != Project . JAVA_1_2 ) { compiler = "modern" ; } else { compiler = "classic" ; } } if ( compileList . length > 0 ) { CompilerAdapter adapter = CompilerAdapterFactory . getCompiler ( compiler , this ) ; log ( "Compiling " + compileList . length + " source file" + ( compileList . length == 1 ? "" : "s" ) + ( destDir != null ? " to " + destDir : "" ) ) ; adapter . setJavac ( this ) ; if ( ! adapter . execute ( ) ) { if ( failOnError ) { throw new BuildException ( FAIL_MSG , location ) ; } else { log ( FAIL_MSG , Project . MSG_ERR ) ; } } } } protected void resetFileLists ( ) { compileList = new File [ 0 ] ; } protected void scanDir ( File srcDir , File destDir , String files [ ] ) { GlobPatternMapper m = new GlobPatternMapper ( ) ; m . setFrom ( "*.java" ) ; m . setTo ( "*.class" ) ; SourceFileScanner sfs = new SourceFileScanner ( this ) ; File [ ] newFiles = sfs . restrictAsFiles ( files , srcDir , destDir , m ) ; if ( newFiles . length > 0 ) { File [ ] newCompileList = new File [ compileList . length + newFiles . length ] ; System . arraycopy ( compileList , 0 , newCompileList , 0 , compileList . length ) ; System . arraycopy ( newFiles , 0 , newCompileList , compileList . length , newFiles . length ) ; compileList = newCompileList ; } } public File [ ] getFileList ( ) { return compileList ; } protected boolean isJdkCompiler ( String compiler ) { return "modern" . equals ( compiler ) || "classic" . equals ( compiler ) || "javac1.1" . equals ( compiler ) || "javac1.2" . equals ( compiler ) || "javac1.3" . equals ( compiler ) || "javac1.4" . equals ( compiler ) ; } } 	1	['50', '4', '1', '24', '82', '1091', '11', '14', '47', '0.959183673', '646', '1', '4', '0.614173228', '0.214285714', '3', '3', '11.5', '7', '1.3', '1']
package org . apache . tools . ant ; public abstract class Task extends ProjectComponent { protected Target target = null ; protected String description = null ; protected Location location = Location . UNKNOWN_LOCATION ; protected String taskName = null ; protected String taskType = null ; protected RuntimeConfigurable wrapper ; public void setOwningTarget ( Target target ) { this . target = target ; } public Target getOwningTarget ( ) { return target ; } public void setTaskName ( String name ) { this . taskName = name ; } public String getTaskName ( ) { return taskName ; } void setTaskType ( String type ) { this . taskType = type ; } public void setDescription ( String desc ) { description = desc ; } public String getDescription ( ) { return description ; } public void init ( ) throws BuildException { } public void execute ( ) throws BuildException { } public Location getLocation ( ) { return location ; } public void setLocation ( Location location ) { this . location = location ; } public RuntimeConfigurable getRuntimeConfigurableWrapper ( ) { if ( wrapper == null ) { wrapper = new RuntimeConfigurable ( this , getTaskName ( ) ) ; } return wrapper ; } protected void setRuntimeConfigurableWrapper ( RuntimeConfigurable wrapper ) { this . wrapper = wrapper ; } public void maybeConfigure ( ) throws BuildException { if ( wrapper != null ) { wrapper . maybeConfigure ( project ) ; } } protected void handleOutput ( String line ) { log ( line , Project . MSG_INFO ) ; } protected void handleErrorOutput ( String line ) { log ( line , Project . MSG_ERR ) ; } public void log ( String msg ) { log ( msg , Project . MSG_INFO ) ; } public void log ( String msg , int msgLevel ) { project . log ( this , msg , msgLevel ) ; } public final void perform ( ) { try { project . fireTaskStarted ( this ) ; maybeConfigure ( ) ; execute ( ) ; project . fireTaskFinished ( this , null ) ; } catch ( RuntimeException exc ) { if ( exc instanceof BuildException ) { BuildException be = ( BuildException ) exc ; if ( be . getLocation ( ) == Location . UNKNOWN_LOCATION ) { be . setLocation ( getLocation ( ) ) ; } } project . fireTaskFinished ( this , exc ) ; throw exc ; } } } 	0	['20', '2', '40', '100', '28', '158', '96', '6', '16', '0.877192982', '164', '1', '3', '0.321428571', '0.258333333', '1', '3', '6.9', '3', '1.1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . io . * ; import java . util . * ; public class Move extends Copy { public Move ( ) { super ( ) ; forceOverwrite = true ; } protected void doFileOperations ( ) { if ( fileCopyMap . size ( ) > 0 ) { log ( "Moving " + fileCopyMap . size ( ) + " files to " + destDir . getAbsolutePath ( ) ) ; Enumeration e = fileCopyMap . keys ( ) ; while ( e . hasMoreElements ( ) ) { String fromFile = ( String ) e . nextElement ( ) ; String toFile = ( String ) fileCopyMap . get ( fromFile ) ; if ( fromFile . equals ( toFile ) ) { log ( "Skipping self-move of " + fromFile , verbosity ) ; continue ; } boolean moved = false ; File f = new File ( fromFile ) ; File d = new File ( toFile ) ; try { log ( "Attempting to rename: " + fromFile + " to " + toFile , verbosity ) ; moved = renameFile ( f , d , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Failed to rename " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } if ( ! moved ) { try { log ( "Moving " + fromFile + " to " + toFile , verbosity ) ; FilterSetCollection executionFilters = new FilterSetCollection ( ) ; if ( filtering ) { executionFilters . addFilterSet ( project . getGlobalFilterSet ( ) ) ; } for ( Enumeration filterEnum = getFilterSets ( ) . elements ( ) ; filterEnum . hasMoreElements ( ) ; ) { executionFilters . addFilterSet ( ( FilterSet ) filterEnum . nextElement ( ) ) ; } getFileUtils ( ) . copyFile ( f , d , executionFilters , forceOverwrite ) ; f = new File ( fromFile ) ; if ( ! f . delete ( ) ) { throw new BuildException ( "Unable to delete file " + f . getAbsolutePath ( ) ) ; } } catch ( IOException ioe ) { String msg = "Failed to copy " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } } } } if ( includeEmpty ) { Enumeration e = dirCopyMap . elements ( ) ; int count = 0 ; while ( e . hasMoreElements ( ) ) { File d = new File ( ( String ) e . nextElement ( ) ) ; if ( ! d . exists ( ) ) { if ( ! d . mkdirs ( ) ) { log ( "Unable to create directory " + d . getAbsolutePath ( ) , Project . MSG_ERR ) ; } else { count ++ ; } } } if ( count > 0 ) { log ( "Moved " + count + " empty directories to " + destDir . getAbsolutePath ( ) ) ; } } if ( filesets . size ( ) > 0 ) { Enumeration e = filesets . elements ( ) ; while ( e . hasMoreElements ( ) ) { FileSet fs = ( FileSet ) e . nextElement ( ) ; File dir = fs . getDir ( project ) ; if ( okToDelete ( dir ) ) { deleteDir ( dir ) ; } } } } protected boolean okToDelete ( File d ) { String [ ] list = d . list ( ) ; if ( list == null ) return false ; for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( d , s ) ; if ( f . isDirectory ( ) ) { if ( ! okToDelete ( f ) ) return false ; } else { return false ; } } return true ; } protected void deleteDir ( File d ) { String [ ] list = d . list ( ) ; if ( list == null ) return ; for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( d , s ) ; if ( f . isDirectory ( ) ) { deleteDir ( f ) ; } else { throw new BuildException ( "UNEXPECTED ERROR - The file " + f . getAbsolutePath ( ) + " should not exist!" ) ; } } log ( "Deleting directory " + d . getAbsolutePath ( ) , verbosity ) ; if ( ! d . delete ( ) ) { throw new BuildException ( "Unable to delete directory " + d . getAbsolutePath ( ) ) ; } } protected boolean renameFile ( File sourceFile , File destFile , boolean filtering , boolean overwrite ) throws IOException , BuildException { boolean renamed = true ; if ( ! filtering ) { String parentPath = destFile . getParent ( ) ; if ( parentPath != null ) { File parent = new File ( parentPath ) ; if ( ! parent . exists ( ) ) { parent . mkdirs ( ) ; } } if ( destFile . exists ( ) ) { if ( ! destFile . delete ( ) ) { throw new BuildException ( "Unable to remove existing file " + destFile ) ; } } renamed = sourceFile . renameTo ( destFile ) ; } else { renamed = false ; } return renamed ; } } 	1	['5', '4', '0', '10', '42', '10', '0', '10', '1', '2', '481', '0', '0', '0.952380952', '0.6', '4', '6', '95.2', '15', '5.2', '1']
package org . apache . tools . ant . types ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; public class Reference { private String refid ; public Reference ( ) { super ( ) ; } public Reference ( String id ) { this ( ) ; setRefId ( id ) ; } public void setRefId ( String id ) { refid = id ; } public String getRefId ( ) { return refid ; } public Object getReferencedObject ( Project project ) throws BuildException { if ( refid == null ) { throw new BuildException ( "No reference specified" ) ; } Object o = project . getReferences ( ) . get ( refid ) ; if ( o == null ) { throw new BuildException ( "Reference " + refid + " not found." ) ; } return o ; } } 	0	['5', '1', '0', '19', '12', '4', '17', '2', '5', '0.25', '55', '1', '0', '0', '0.533333333', '0', '0', '9.8', '1', '0.6', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; public class CompilerAdapterFactory { private CompilerAdapterFactory ( ) { } public static CompilerAdapter getCompiler ( String compilerType , Task task ) throws BuildException { if ( compilerType . equalsIgnoreCase ( "jikes" ) ) { return new Jikes ( ) ; } if ( compilerType . equalsIgnoreCase ( "extJavac" ) ) { return new JavacExternal ( ) ; } if ( compilerType . equalsIgnoreCase ( "classic" ) || compilerType . equalsIgnoreCase ( "javac1.1" ) || compilerType . equalsIgnoreCase ( "javac1.2" ) ) { return new Javac12 ( ) ; } if ( compilerType . equalsIgnoreCase ( "modern" ) || compilerType . equalsIgnoreCase ( "javac1.3" ) || compilerType . equalsIgnoreCase ( "javac1.4" ) ) { try { Class . forName ( "com.sun.tools.javac.Main" ) ; } catch ( ClassNotFoundException cnfe ) { task . log ( "Modern compiler is not available - using " + "classic compiler" , Project . MSG_WARN ) ; return new Javac12 ( ) ; } return new Javac13 ( ) ; } if ( compilerType . equalsIgnoreCase ( "jvc" ) || compilerType . equalsIgnoreCase ( "microsoft" ) ) { return new Jvc ( ) ; } if ( compilerType . equalsIgnoreCase ( "kjc" ) ) { return new Kjc ( ) ; } if ( compilerType . equalsIgnoreCase ( "gcj" ) ) { return new Gcj ( ) ; } if ( compilerType . equalsIgnoreCase ( "sj" ) || compilerType . equalsIgnoreCase ( "symantec" ) ) { return new Sj ( ) ; } return resolveClassName ( compilerType ) ; } private static CompilerAdapter resolveClassName ( String className ) throws BuildException { try { Class c = Class . forName ( className ) ; Object o = c . newInstance ( ) ; return ( CompilerAdapter ) o ; } catch ( ClassNotFoundException cnfe ) { throw new BuildException ( className + " can\'t be found." , cnfe ) ; } catch ( ClassCastException cce ) { throw new BuildException ( className + " isn\'t the classname of " + "a compiler adapter." , cce ) ; } catch ( Throwable t ) { throw new BuildException ( className + " caused an interesting " + "exception." , t ) ; } } } 	1	['3', '1', '0', '12', '20', '3', '1', '11', '1', '2', '165', '0', '0', '0', '0.444444444', '0', '0', '54', '1', '0.6667', '1']
package org . apache . tools . mail ; import java . io . * ; import java . net . * ; import java . util . * ; public class MailMessage { String host ; String from ; Vector to , cc ; Hashtable headers ; MailPrintStream out ; SmtpResponseReader in ; Socket socket ; public MailMessage ( ) throws IOException { this ( "localhost" ) ; } public MailMessage ( String host ) throws IOException { this . host = host ; to = new Vector ( ) ; cc = new Vector ( ) ; headers = new Hashtable ( ) ; setHeader ( "X-Mailer" , "org.apache.tools.mail.MailMessage (jakarta.apache.org)" ) ; connect ( ) ; sendHelo ( ) ; } public void from ( String from ) throws IOException { sendFrom ( from ) ; this . from = from ; } public void to ( String to ) throws IOException { sendRcpt ( to ) ; this . to . addElement ( to ) ; } public void cc ( String cc ) throws IOException { sendRcpt ( cc ) ; this . cc . addElement ( cc ) ; } public void bcc ( String bcc ) throws IOException { sendRcpt ( bcc ) ; } public void setSubject ( String subj ) { headers . put ( "Subject" , subj ) ; } public void setHeader ( String name , String value ) { headers . put ( name , value ) ; } public PrintStream getPrintStream ( ) throws IOException { setFromHeader ( ) ; setToHeader ( ) ; setCcHeader ( ) ; sendData ( ) ; flushHeaders ( ) ; return out ; } void setFromHeader ( ) { setHeader ( "From" , from ) ; } void setToHeader ( ) { setHeader ( "To" , vectorToList ( to ) ) ; } void setCcHeader ( ) { setHeader ( "Cc" , vectorToList ( cc ) ) ; } String vectorToList ( Vector v ) { StringBuffer buf = new StringBuffer ( ) ; Enumeration e = v . elements ( ) ; while ( e . hasMoreElements ( ) ) { buf . append ( e . nextElement ( ) ) ; if ( e . hasMoreElements ( ) ) { buf . append ( ", " ) ; } } return buf . toString ( ) ; } void flushHeaders ( ) throws IOException { Enumeration e = headers . keys ( ) ; while ( e . hasMoreElements ( ) ) { String name = ( String ) e . nextElement ( ) ; String value = ( String ) headers . get ( name ) ; out . println ( name + ": " + value ) ; } out . println ( ) ; out . flush ( ) ; } public void sendAndClose ( ) throws IOException { sendDot ( ) ; sendQuit ( ) ; disconnect ( ) ; } static String sanitizeAddress ( String s ) { int paramDepth = 0 ; int start = 0 ; int end = 0 ; int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = s . charAt ( i ) ; if ( c == '(' ) { paramDepth ++ ; if ( start == 0 ) { end = i ; } } else if ( c == ')' ) { paramDepth -- ; if ( end == 0 ) { start = i + 1 ; } } else if ( paramDepth == 0 && c == '<' ) { start = i + 1 ; } else if ( paramDepth == 0 && c == '>' ) { end = i ; } } if ( end == 0 ) { end = len ; } return s . substring ( start , end ) ; } void connect ( ) throws IOException { socket = new Socket ( host , 25 ) ; out = new MailPrintStream ( new BufferedOutputStream ( socket . getOutputStream ( ) ) ) ; in = new SmtpResponseReader ( socket . getInputStream ( ) ) ; getReady ( ) ; } void getReady ( ) throws IOException { String response = in . getResponse ( ) ; int [ ] ok = { 220 } ; if ( ! isResponseOK ( response , ok ) ) { throw new IOException ( "Didn't get introduction from server: " + response ) ; } } void sendHelo ( ) throws IOException { String local = InetAddress . getLocalHost ( ) . getHostName ( ) ; int [ ] ok = { 250 } ; send ( "HELO " + local , ok ) ; } void sendFrom ( String from ) throws IOException { int [ ] ok = { 250 } ; send ( "MAIL FROM: " + "<" + sanitizeAddress ( from ) + ">" , ok ) ; } void sendRcpt ( String rcpt ) throws IOException { int [ ] ok = { 250 , 251 } ; send ( "RCPT TO: " + "<" + sanitizeAddress ( rcpt ) + ">" , ok ) ; } void sendData ( ) throws IOException { int [ ] ok = { 354 } ; send ( "DATA" , ok ) ; } void sendDot ( ) throws IOException { int [ ] ok = { 250 } ; send ( "\r\n." , ok ) ; } void sendQuit ( ) throws IOException { int [ ] ok = { 221 } ; send ( "QUIT" , ok ) ; } void send ( String msg , int [ ] ok ) throws IOException { out . rawPrint ( msg + "\r\n" ) ; String response = in . getResponse ( ) ; if ( ! isResponseOK ( response , ok ) ) { throw new IOException ( "Unexpected reply to command: " + msg + ": " + response ) ; } } boolean isResponseOK ( String response , int [ ] ok ) { for ( int i = 0 ; i < ok . length ; i ++ ) { if ( response . startsWith ( "" + ok [ i ] ) ) { return true ; } } return false ; } void disconnect ( ) throws IOException { if ( out != null ) out . close ( ) ; if ( in != null ) in . close ( ) ; if ( socket != null ) socket . close ( ) ; } } class MailPrintStream extends PrintStream { int lastChar ; public MailPrintStream ( OutputStream out ) { super ( out , true ) ; } public void write ( int b ) { if ( b == '\n' && lastChar != '\r' ) { rawWrite ( '\r' ) ; rawWrite ( b ) ; } else if ( b == '.' && lastChar == '\n' ) { rawWrite ( '.' ) ; rawWrite ( b ) ; } else { rawWrite ( b ) ; } lastChar = b ; } public void write ( byte buf [ ] , int off , int len ) { for ( int i = 0 ; i < len ; i ++ ) { write ( buf [ off + i ] ) ; } } void rawWrite ( int b ) { super . write ( b ) ; } void rawPrint ( String s ) { int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { rawWrite ( s . charAt ( i ) ) ; } } } 	0	['27', '1', '0', '3', '63', '297', '1', '2', '10', '0.778846154', '527', '0', '2', '0', '0.37962963', '0', '0', '18.22222222', '11', '1.4444', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . taskdefs . condition . ConditionBase ; public class ConditionTask extends ConditionBase { private String property ; private String value = "true" ; public void setProperty ( String p ) { property = p ; } public void setValue ( String v ) { value = v ; } public void execute ( ) throws BuildException { if ( countConditions ( ) > 1 ) { throw new BuildException ( "You must not nest more than one condition into <condition>" ) ; } if ( countConditions ( ) < 1 ) { throw new BuildException ( "You must nest a condition into <condition>" ) ; } Condition c = ( Condition ) getConditions ( ) . nextElement ( ) ; if ( c . eval ( ) ) { getProject ( ) . setProperty ( property , value ) ; } } } 	1	['4', '3', '0', '4', '12', '0', '0', '4', '4', '0.5', '54', '1', '0', '0.914285714', '0.75', '0', '0', '12', '1', '0.75', '1']
package org . apache . tools . ant ; import java . util . EventListener ; public interface BuildListener extends EventListener { public void buildStarted ( BuildEvent event ) ; public void buildFinished ( BuildEvent event ) ; public void targetStarted ( BuildEvent event ) ; public void targetFinished ( BuildEvent event ) ; public void taskStarted ( BuildEvent event ) ; public void taskFinished ( BuildEvent event ) ; public void messageLogged ( BuildEvent event ) ; } 	0	['7', '1', '0', '11', '7', '21', '10', '1', '7', '2', '7', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; import java . util . zip . * ; public class Expand extends MatchingTask { private File dest ; private File source ; private boolean overwrite = true ; public void execute ( ) throws BuildException { if ( "expand" . equals ( taskType ) ) { log ( "!! expand is deprecated. Use unzip instead. !!" ) ; } Touch touch = ( Touch ) project . createTask ( "touch" ) ; touch . setOwningTarget ( target ) ; touch . setTaskName ( getTaskName ( ) ) ; touch . setLocation ( getLocation ( ) ) ; if ( source == null ) { throw new BuildException ( "Source attribute must be specified" ) ; } if ( dest == null ) { throw new BuildException ( "Dest attribute must be specified" ) ; } if ( source . isDirectory ( ) ) { DirectoryScanner ds = super . getDirectoryScanner ( source ) ; String [ ] files = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; ++ i ) { File file = new File ( source , files [ i ] ) ; expandFile ( touch , file , dest ) ; } } else { expandFile ( touch , source , dest ) ; } } private void expandFile ( Touch touch , File srcF , File dir ) { ZipInputStream zis = null ; try { log ( "Expanding: " + srcF + " into " + dir , Project . MSG_INFO ) ; zis = new ZipInputStream ( new FileInputStream ( srcF ) ) ; ZipEntry ze = null ; while ( ( ze = zis . getNextEntry ( ) ) != null ) { File f = new File ( dir , project . translatePath ( ze . getName ( ) ) ) ; try { if ( ! overwrite && f . exists ( ) && f . lastModified ( ) >= ze . getTime ( ) ) { log ( "Skipping " + f + " as it is up-to-date" , Project . MSG_DEBUG ) ; continue ; } log ( "expanding " + ze . getName ( ) + " to " + f , Project . MSG_VERBOSE ) ; File dirF = new File ( f . getParent ( ) ) ; dirF . mkdirs ( ) ; if ( ze . isDirectory ( ) ) { f . mkdirs ( ) ; } else { byte [ ] buffer = new byte [ 1024 ] ; int length = 0 ; FileOutputStream fos = new FileOutputStream ( f ) ; while ( ( length = zis . read ( buffer ) ) >= 0 ) { fos . write ( buffer , 0 , length ) ; } fos . close ( ) ; } if ( project . getJavaVersion ( ) != Project . JAVA_1_1 ) { touch . setFile ( f ) ; touch . setMillis ( ze . getTime ( ) ) ; touch . touch ( ) ; } } catch ( FileNotFoundException ex ) { log ( "Unable to expand to file " + f . getPath ( ) , Project . MSG_WARN ) ; } } log ( "expand complete" , Project . MSG_VERBOSE ) ; } catch ( IOException ioe ) { throw new BuildException ( "Error while expanding " + srcF . getPath ( ) , ioe ) ; } finally { if ( zis != null ) { try { zis . close ( ) ; } catch ( IOException e ) { } } } } public void setDest ( File d ) { this . dest = d ; } public void setSrc ( File s ) { this . source = s ; } public void setOverwrite ( boolean b ) { overwrite = b ; } } 	1	['6', '4', '0', '9', '48', '5', '0', '9', '5', '0.666666667', '300', '1', '0', '0.939759036', '0.458333333', '4', '5', '48.5', '10', '2.3333', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . ZipFileSet ; import org . apache . tools . zip . * ; import java . io . * ; import java . util . Vector ; public class Ear extends Jar { private File deploymentDescriptor ; private boolean descriptorAdded ; public Ear ( ) { super ( ) ; archiveType = "ear" ; emptyBehavior = "create" ; } public void setEarfile ( File earFile ) { super . setZipfile ( earFile ) ; } public void setAppxml ( File descr ) { deploymentDescriptor = descr ; if ( ! deploymentDescriptor . exists ( ) ) throw new BuildException ( "Deployment descriptor: " + deploymentDescriptor + " does not exist." ) ; ZipFileSet fs = new ZipFileSet ( ) ; fs . setDir ( new File ( deploymentDescriptor . getParent ( ) ) ) ; fs . setIncludes ( deploymentDescriptor . getName ( ) ) ; fs . setFullpath ( "META-INF/application.xml" ) ; super . addFileset ( fs ) ; } public void addArchives ( ZipFileSet fs ) { log ( "addArchives called" , Project . MSG_DEBUG ) ; fs . setPrefix ( "/" ) ; super . addFileset ( fs ) ; } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( deploymentDescriptor == null ) { throw new BuildException ( "appxml attribute is required" , location ) ; } super . initZipOutputStream ( zOut ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath ) throws IOException { if ( vPath . equalsIgnoreCase ( "META-INF/aplication.xml" ) ) { if ( deploymentDescriptor == null || ! deploymentDescriptor . equals ( file ) || descriptorAdded ) { log ( "Warning: selected " + archiveType + " files include a META-INF/application.xml which will be ignored " + "(please use appxml attribute to " + archiveType + " task)" , Project . MSG_WARN ) ; } else { super . zipFile ( file , zOut , vPath ) ; descriptorAdded = true ; } } else { super . zipFile ( file , zOut , vPath ) ; } } protected void cleanUp ( ) { descriptorAdded = false ; super . cleanUp ( ) ; } } 	0	['7', '6', '0', '8', '31', '13', '0', '8', '4', '0.75', '151', '1', '0', '0.9625', '0.4', '4', '9', '20.28571429', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import java . io . * ; import java . util . * ; public class Property extends Task { protected String name ; protected String value ; protected File file ; protected String resource ; protected Path classpath ; protected String env ; protected Reference ref = null ; protected boolean userProperty = false ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setLocation ( File location ) { setValue ( location . getAbsolutePath ( ) ) ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } public void setFile ( File file ) { this . file = file ; } public File getFile ( ) { return file ; } public void setRefid ( Reference ref ) { this . ref = ref ; } public Reference getRefid ( ) { return ref ; } public void setResource ( String resource ) { this . resource = resource ; } public String getResource ( ) { return resource ; } public void setEnvironment ( String env ) { this . env = env ; } public String getEnvironment ( ) { return env ; } public void setClasspath ( Path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( project ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setUserProperty ( boolean userProperty ) { this . userProperty = userProperty ; } public String toString ( ) { return value == null ? "" : value ; } public void execute ( ) throws BuildException { if ( name != null ) { if ( value == null && ref == null ) { throw new BuildException ( "You must specify value, location or refid with the name attribute" , location ) ; } } else { if ( file == null && resource == null && env == null ) { throw new BuildException ( "You must specify file, resource or environment when not using the name attribute" , location ) ; } } if ( ( name != null ) && ( value != null ) ) { addProperty ( name , value ) ; } if ( file != null ) loadFile ( file ) ; if ( resource != null ) loadResource ( resource ) ; if ( env != null ) loadEnvironment ( env ) ; if ( ( name != null ) && ( ref != null ) ) { Object obj = ref . getReferencedObject ( getProject ( ) ) ; if ( obj != null ) { addProperty ( name , obj . toString ( ) ) ; } } } protected void loadFile ( File file ) throws BuildException { Properties props = new Properties ( ) ; log ( "Loading " + file . getAbsolutePath ( ) , Project . MSG_VERBOSE ) ; try { if ( file . exists ( ) ) { FileInputStream fis = new FileInputStream ( file ) ; try { props . load ( fis ) ; } finally { if ( fis != null ) { fis . close ( ) ; } } addProperties ( props ) ; } else { log ( "Unable to find property file: " + file . getAbsolutePath ( ) , Project . MSG_VERBOSE ) ; } } catch ( IOException ex ) { throw new BuildException ( ex , location ) ; } } protected void loadResource ( String name ) { Properties props = new Properties ( ) ; log ( "Resource Loading " + name , Project . MSG_VERBOSE ) ; try { ClassLoader cL = null ; InputStream is = null ; if ( classpath != null ) { cL = new AntClassLoader ( project , classpath ) ; } else { cL = this . getClass ( ) . getClassLoader ( ) ; } if ( cL == null ) { is = ClassLoader . getSystemResourceAsStream ( name ) ; } else { is = cL . getResourceAsStream ( name ) ; } if ( is != null ) { props . load ( is ) ; addProperties ( props ) ; } else { log ( "Unable to find resource " + name , Project . MSG_WARN ) ; } } catch ( IOException ex ) { throw new BuildException ( ex , location ) ; } } protected void loadEnvironment ( String prefix ) { Properties props = new Properties ( ) ; if ( ! prefix . endsWith ( "." ) ) prefix += "." ; log ( "Loading Environment " + prefix , Project . MSG_VERBOSE ) ; Vector osEnv = Execute . getProcEnvironment ( ) ; for ( Enumeration e = osEnv . elements ( ) ; e . hasMoreElements ( ) ; ) { String entry = ( String ) e . nextElement ( ) ; int pos = entry . indexOf ( '=' ) ; if ( pos == - 1 ) { log ( "Ignoring: " + entry , Project . MSG_WARN ) ; } else { props . put ( prefix + entry . substring ( 0 , pos ) , entry . substring ( pos + 1 ) ) ; } } addProperties ( props ) ; } protected void addProperties ( Properties props ) { resolveAllProperties ( props ) ; Enumeration e = props . keys ( ) ; while ( e . hasMoreElements ( ) ) { String name = ( String ) e . nextElement ( ) ; String value = ( String ) props . getProperty ( name ) ; String v = ProjectHelper . replaceProperties ( project , value , project . getProperties ( ) ) ; addProperty ( name , v ) ; } } protected void addProperty ( String n , String v ) { if ( userProperty ) { if ( project . getUserProperty ( n ) == null ) { project . setUserProperty ( n , v ) ; } else { log ( "Override ignored for " + n , Project . MSG_VERBOSE ) ; } } else { if ( project . getProperty ( n ) == null ) { project . setProperty ( n , v ) ; } else { log ( "Override ignored for " + n , Project . MSG_VERBOSE ) ; } } } private void resolveAllProperties ( Properties props ) throws BuildException { for ( Enumeration e = props . keys ( ) ; e . hasMoreElements ( ) ; ) { String name = ( String ) e . nextElement ( ) ; String value = props . getProperty ( name ) ; boolean resolved = false ; while ( ! resolved ) { Vector fragments = new Vector ( ) ; Vector propertyRefs = new Vector ( ) ; ProjectHelper . parsePropertyString ( value , fragments , propertyRefs ) ; resolved = true ; if ( propertyRefs . size ( ) != 0 ) { StringBuffer sb = new StringBuffer ( ) ; Enumeration i = fragments . elements ( ) ; Enumeration j = propertyRefs . elements ( ) ; while ( i . hasMoreElements ( ) ) { String fragment = ( String ) i . nextElement ( ) ; if ( fragment == null ) { String propertyName = ( String ) j . nextElement ( ) ; if ( propertyName . equals ( name ) ) { throw new BuildException ( "Property " + name + " was circularly defined." ) ; } fragment = getProject ( ) . getProperty ( propertyName ) ; if ( fragment == null ) { if ( props . containsKey ( propertyName ) ) { fragment = props . getProperty ( propertyName ) ; resolved = false ; } else { fragment = "${" + propertyName + "}" ; } } } sb . append ( fragment ) ; } value = sb . toString ( ) ; props . put ( name , value ) ; } } } } } 	1	['26', '3', '0', '12', '74', '265', '2', '10', '20', '0.885', '643', '1', '2', '0.596774194', '0.230769231', '0', '0', '23.42307692', '4', '1.4615', '1']
package org . apache . tools . ant . util . regexp ; import org . apache . tools . ant . BuildException ; import java . util . Vector ; public interface RegexpMatcher { public void setPattern ( String pattern ) throws BuildException ; public String getPattern ( ) ; public boolean matches ( String argument ) ; public Vector getGroups ( String argument ) ; } 	0	['4', '1', '0', '5', '4', '6', '4', '1', '4', '2', '4', '0', '0', '0', '0.875', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; public class Os implements Condition { private String family ; public void setFamily ( String f ) { family = f . toLowerCase ( ) ; } public boolean eval ( ) throws BuildException { String osName = System . getProperty ( "os.name" ) . toLowerCase ( ) ; String pathSep = System . getProperty ( "path.separator" ) ; if ( family != null ) { if ( family . equals ( "windows" ) ) { return osName . indexOf ( "windows" ) > - 1 ; } else if ( family . equals ( "dos" ) ) { return pathSep . equals ( ";" ) ; } else if ( family . equals ( "mac" ) ) { return osName . indexOf ( "mac" ) > - 1 ; } else if ( family . equals ( "unix" ) ) { return pathSep . equals ( ":" ) && ( ! osName . startsWith ( "mac" ) || osName . endsWith ( "x" ) ) ; } throw new BuildException ( "Don\'t know how to detect os family \"" + family + "\"" ) ; } return false ; } } 	1	['3', '1', '0', '3', '14', '1', '1', '2', '3', '0.5', '97', '1', '0', '0', '0.666666667', '0', '0', '31', '1', '0.6667', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . PatternSet ; import java . util . * ; public class CompileTask extends Javac { protected Vector taskList = new Vector ( ) ; public Taskdef createTaskdef ( ) { Taskdef task = new Taskdef ( ) ; taskList . addElement ( task ) ; return task ; } public void init ( ) { log ( "!! CompileTask is deprecated. !!" ) ; log ( "Use <taskdef> elements nested into <target>s instead" ) ; for ( Enumeration e = taskList . elements ( ) ; e . hasMoreElements ( ) ; ) { Taskdef task = ( Taskdef ) e . nextElement ( ) ; String source = task . getClassname ( ) . replace ( '.' , '/' ) + ".java" ; PatternSet . NameEntry include = super . createInclude ( ) ; include . setName ( "**/" + source ) ; } super . init ( ) ; super . execute ( ) ; for ( Enumeration e = taskList . elements ( ) ; e . hasMoreElements ( ) ; ) { Taskdef task = ( Taskdef ) e . nextElement ( ) ; task . init ( ) ; } } public void execute ( ) { } } 	0	['4', '5', '0', '6', '21', '0', '0', '6', '4', '0.333333333', '87', '1', '0', '0.98089172', '1', '1', '1', '20.5', '3', '1.25', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import java . util . * ; import org . apache . tools . mail . MailMessage ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; public class SendEmail extends Task { private String from ; private String mailhost = "localhost" ; private String message ; private String toList ; private String subject ; private Vector files = new Vector ( ) ; public SendEmail ( ) { } public void setToList ( String toList ) { this . toList = toList ; } public void setFrom ( String from ) { this . from = from ; } public void setMailhost ( String mailhost ) { this . mailhost = mailhost ; } public void setMessage ( String message ) { this . message = message ; } public void setSubject ( String subject ) { this . subject = subject ; } public void setFiles ( String filenames ) { StringTokenizer t = new StringTokenizer ( filenames , ", " ) ; while ( t . hasMoreTokens ( ) ) { files . addElement ( project . resolveFile ( t . nextToken ( ) ) ) ; } } public void execute ( ) { try { MailMessage mailMessage = new MailMessage ( mailhost ) ; if ( from != null ) { mailMessage . from ( from ) ; } else { throw new BuildException ( "Attribute \"from\" is required." ) ; } if ( toList != null ) { StringTokenizer t = new StringTokenizer ( toList , ", " , false ) ; while ( t . hasMoreTokens ( ) ) { mailMessage . to ( t . nextToken ( ) ) ; } } else { throw new BuildException ( "Attribute \"toList\" is required." ) ; } if ( subject != null ) { mailMessage . setSubject ( subject ) ; } if ( ! files . isEmpty ( ) ) { PrintStream out = mailMessage . getPrintStream ( ) ; for ( Enumeration e = files . elements ( ) ; e . hasMoreElements ( ) ; ) { File file = ( File ) e . nextElement ( ) ; if ( file . exists ( ) && file . canRead ( ) ) { int bufsize = 1024 ; int length ; byte [ ] buf = new byte [ bufsize ] ; BufferedInputStream in = null ; try { in = new BufferedInputStream ( new FileInputStream ( file ) , bufsize ) ; while ( ( length = in . read ( buf , 0 , bufsize ) ) != - 1 ) { out . write ( buf , 0 , length ) ; } } finally { if ( in != null ) { in . close ( ) ; } } } else { throw new BuildException ( "File \"" + file . getName ( ) + "\" does not exist or is not readable." ) ; } } } else if ( message != null ) { PrintStream out = mailMessage . getPrintStream ( ) ; out . print ( message ) ; } else { throw new BuildException ( "Attribute \"file\" or \"message\" is required." ) ; } log ( "Sending email" ) ; mailMessage . sendAndClose ( ) ; } catch ( IOException ioe ) { throw new BuildException ( "IO error sending mail: " + ioe . getMessage ( ) ) ; } } } 	1	['8', '3', '0', '5', '41', '10', '0', '5', '8', '0.80952381', '236', '1', '0', '0.840909091', '0.875', '1', '1', '27.75', '14', '2.625', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . rmic . * ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . * ; import java . io . File ; import java . io . IOException ; import java . rmi . Remote ; import java . util . Vector ; public class Rmic extends MatchingTask { private static final String FAIL_MSG = "Rmic failed, messages should have been provided." ; private File baseDir ; private String classname ; private File sourceBase ; private String stubVersion ; private Path compileClasspath ; private Path extdirs ; private boolean verify = false ; private boolean filtering = false ; private boolean iiop = false ; private String iiopopts ; private boolean idl = false ; private String idlopts ; private boolean debug = false ; private boolean includeAntRuntime = true ; private boolean includeJavaRuntime = false ; private Vector compileList = new Vector ( ) ; private ClassLoader loader = null ; public void setBase ( File base ) { this . baseDir = base ; } public File getBase ( ) { return this . baseDir ; } public void setClassname ( String classname ) { this . classname = classname ; } public String getClassname ( ) { return classname ; } public void setSourceBase ( File sourceBase ) { this . sourceBase = sourceBase ; } public File getSourceBase ( ) { return sourceBase ; } public void setStubVersion ( String stubVersion ) { this . stubVersion = stubVersion ; } public String getStubVersion ( ) { return stubVersion ; } public void setFiltering ( boolean filter ) { filtering = filter ; } public boolean getFiltering ( ) { return filtering ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public boolean getDebug ( ) { return debug ; } public void setClasspath ( Path classpath ) { if ( compileClasspath == null ) { compileClasspath = classpath ; } else { compileClasspath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( compileClasspath == null ) { compileClasspath = new Path ( project ) ; } return compileClasspath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public Path getClasspath ( ) { return compileClasspath ; } public void setVerify ( boolean verify ) { this . verify = verify ; } public boolean getVerify ( ) { return verify ; } public void setIiop ( boolean iiop ) { this . iiop = iiop ; } public boolean getIiop ( ) { return iiop ; } public void setIiopopts ( String iiopopts ) { this . iiopopts = iiopopts ; } public String getIiopopts ( ) { return iiopopts ; } public void setIdl ( boolean idl ) { this . idl = idl ; } public boolean getIdl ( ) { return idl ; } public void setIdlopts ( String idlopts ) { this . idlopts = idlopts ; } public String getIdlopts ( ) { return idlopts ; } public Vector getFileList ( ) { return compileList ; } public void setIncludeantruntime ( boolean include ) { includeAntRuntime = include ; } public boolean getIncludeantruntime ( ) { return includeAntRuntime ; } public void setIncludejavaruntime ( boolean include ) { includeJavaRuntime = include ; } public boolean getIncludejavaruntime ( ) { return includeJavaRuntime ; } public void setExtdirs ( Path extdirs ) { if ( this . extdirs == null ) { this . extdirs = extdirs ; } else { this . extdirs . append ( extdirs ) ; } } public Path createExtdirs ( ) { if ( extdirs == null ) { extdirs = new Path ( project ) ; } return extdirs . createPath ( ) ; } public Path getExtdirs ( ) { return extdirs ; } public Vector getCompileList ( ) { return compileList ; } public void execute ( ) throws BuildException { if ( baseDir == null ) { throw new BuildException ( "base attribute must be set!" , location ) ; } if ( ! baseDir . exists ( ) ) { throw new BuildException ( "base does not exist!" , location ) ; } if ( verify ) { log ( "Verify has been turned on." , Project . MSG_INFO ) ; } String compiler = project . getProperty ( "build.rmic" ) ; RmicAdapter adapter = RmicAdapterFactory . getRmic ( compiler , this ) ; adapter . setRmic ( this ) ; Path classpath = adapter . getClasspath ( ) ; loader = new AntClassLoader ( project , classpath ) ; if ( classname == null ) { DirectoryScanner ds = this . getDirectoryScanner ( baseDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( baseDir , files , adapter . getMapper ( ) ) ; } else { scanDir ( baseDir , new String [ ] { classname . replace ( '.' , File . separatorChar ) + ".class" } , adapter . getMapper ( ) ) ; } int fileCount = compileList . size ( ) ; if ( fileCount > 0 ) { log ( "RMI Compiling " + fileCount + " class" + ( fileCount > 1 ? "es" : "" ) + " to " + baseDir , Project . MSG_INFO ) ; if ( ! adapter . execute ( ) ) { throw new BuildException ( FAIL_MSG , location ) ; } } if ( null != sourceBase && ! baseDir . equals ( sourceBase ) ) { if ( idl ) { log ( "Cannot determine sourcefiles in idl mode, " , Project . MSG_WARN ) ; log ( "sourcebase attribute will be ignored." , Project . MSG_WARN ) ; } else { for ( int j = 0 ; j < fileCount ; j ++ ) { moveGeneratedFile ( baseDir , sourceBase , ( String ) compileList . elementAt ( j ) , adapter ) ; } } } compileList . removeAllElements ( ) ; } private void moveGeneratedFile ( File baseDir , File sourceBaseFile , String classname , RmicAdapter adapter ) throws BuildException { String classFileName = classname . replace ( '.' , File . separatorChar ) + ".class" ; String [ ] generatedFiles = adapter . getMapper ( ) . mapFileName ( classFileName ) ; for ( int i = 0 ; i < generatedFiles . length ; i ++ ) { String sourceFileName = classFileName . substring ( 0 , classFileName . length ( ) - 6 ) + ".java" ; File oldFile = new File ( baseDir , sourceFileName ) ; File newFile = new File ( sourceBaseFile , sourceFileName ) ; try { project . copyFile ( oldFile , newFile , filtering ) ; oldFile . delete ( ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + oldFile + " to " + newFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } } } protected void scanDir ( File baseDir , String files [ ] , FileNameMapper mapper ) { String [ ] newFiles = files ; if ( idl ) { log ( "will leave uptodate test to rmic implementation in idl mode." , Project . MSG_VERBOSE ) ; } else if ( iiop && iiopopts != null && iiopopts . indexOf ( "-always" ) > - 1 ) { log ( "no uptodate test as -always option has been specified" , Project . MSG_VERBOSE ) ; } else { SourceFileScanner sfs = new SourceFileScanner ( this ) ; newFiles = sfs . restrict ( files , baseDir , baseDir , mapper ) ; } for ( int i = 0 ; i < newFiles . length ; i ++ ) { String classname = newFiles [ i ] . replace ( File . separatorChar , '.' ) ; classname = classname . substring ( 0 , classname . lastIndexOf ( ".class" ) ) ; compileList . addElement ( classname ) ; } } public boolean isValidRmiRemote ( String classname ) { try { Class testClass = loader . loadClass ( classname ) ; if ( testClass . isInterface ( ) && ! iiop && ! idl ) { return false ; } return isValidRmiRemote ( testClass ) ; } catch ( ClassNotFoundException e ) { log ( "Unable to verify class " + classname + ". It could not be found." , Project . MSG_WARN ) ; } catch ( NoClassDefFoundError e ) { log ( "Unable to verify class " + classname + ". It is not defined." , Project . MSG_WARN ) ; } catch ( Throwable t ) { log ( "Unable to verify class " + classname + ". Loading caused Exception: " + t . getMessage ( ) , Project . MSG_WARN ) ; } return false ; } public Class getRemoteInterface ( Class testClass ) { if ( Remote . class . isAssignableFrom ( testClass ) ) { Class [ ] interfaces = testClass . getInterfaces ( ) ; if ( interfaces != null ) { for ( int i = 0 ; i < interfaces . length ; i ++ ) { if ( Remote . class . isAssignableFrom ( interfaces [ i ] ) ) { return interfaces [ i ] ; } } } } return null ; } private boolean isValidRmiRemote ( Class testClass ) { return getRemoteInterface ( testClass ) != null ; } public ClassLoader getLoader ( ) { return loader ; } } 	0	['44', '4', '0', '19', '91', '802', '6', '14', '40', '0.94369645', '724', '0.947368421', '2', '0.644628099', '0.156818182', '3', '3', '15.02272727', '7', '1.4091', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . * ; import org . apache . tools . ant . taskdefs . * ; import org . apache . tools . ant . types . * ; import java . io . * ; import java . util . Random ; public abstract class DefaultCompilerAdapter implements CompilerAdapter { protected Path src ; protected File destDir ; protected String encoding ; protected boolean debug = false ; protected boolean optimize = false ; protected boolean deprecation = false ; protected boolean depend = false ; protected boolean verbose = false ; protected String target ; protected Path bootclasspath ; protected Path extdirs ; protected Path compileClasspath ; protected Project project ; protected Location location ; protected boolean includeAntRuntime ; protected boolean includeJavaRuntime ; protected String memoryInitialSize ; protected String memoryMaximumSize ; protected File [ ] compileList ; protected static String lSep = System . getProperty ( "line.separator" ) ; protected Javac attributes ; public void setJavac ( Javac attributes ) { this . attributes = attributes ; src = attributes . getSrcdir ( ) ; destDir = attributes . getDestdir ( ) ; encoding = attributes . getEncoding ( ) ; debug = attributes . getDebug ( ) ; optimize = attributes . getOptimize ( ) ; deprecation = attributes . getDeprecation ( ) ; depend = attributes . getDepend ( ) ; verbose = attributes . getVerbose ( ) ; target = attributes . getTarget ( ) ; bootclasspath = attributes . getBootclasspath ( ) ; extdirs = attributes . getExtdirs ( ) ; compileList = attributes . getFileList ( ) ; compileClasspath = attributes . getClasspath ( ) ; project = attributes . getProject ( ) ; location = attributes . getLocation ( ) ; includeAntRuntime = attributes . getIncludeantruntime ( ) ; includeJavaRuntime = attributes . getIncludejavaruntime ( ) ; memoryInitialSize = attributes . getMemoryInitialSize ( ) ; memoryMaximumSize = attributes . getMemoryMaximumSize ( ) ; } public Javac getJavac ( ) { return attributes ; } protected Path getCompileClasspath ( ) { Path classpath = new Path ( project ) ; if ( destDir != null ) { classpath . setLocation ( destDir ) ; } if ( compileClasspath == null ) { if ( includeAntRuntime ) { classpath . addExisting ( Path . systemClasspath ) ; } } else { if ( includeAntRuntime ) { classpath . addExisting ( compileClasspath . concatSystemClasspath ( "last" ) ) ; } else { classpath . addExisting ( compileClasspath . concatSystemClasspath ( "ignore" ) ) ; } } if ( includeJavaRuntime ) { if ( System . getProperty ( "java.vendor" ) . toLowerCase ( ) . indexOf ( "microsoft" ) >= 0 ) { FileSet msZipFiles = new FileSet ( ) ; msZipFiles . setDir ( new File ( System . getProperty ( "java.home" ) + File . separator + "Packages" ) ) ; msZipFiles . setIncludes ( "*.ZIP" ) ; classpath . addFileset ( msZipFiles ) ; } else if ( Project . getJavaVersion ( ) == Project . JAVA_1_1 ) { classpath . addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + "classes.zip" ) ) ; } else { classpath . addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + "rt.jar" ) ) ; classpath . addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "jre" + File . separator + "lib" + File . separator + "rt.jar" ) ) ; classpath . addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + ".." + File . separator + "Classes" + File . separator + "classes.jar" ) ) ; classpath . addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + ".." + File . separator + "Classes" + File . separator + "ui.jar" ) ) ; } } return classpath ; } protected Commandline setupJavacCommandlineSwitches ( Commandline cmd ) { Path classpath = getCompileClasspath ( ) ; boolean usingJava1_1 = Project . getJavaVersion ( ) . equals ( Project . JAVA_1_1 ) ; String memoryParameterPrefix = usingJava1_1 ? "-J-" : "-J-X" ; if ( memoryInitialSize != null ) { cmd . createArgument ( ) . setValue ( memoryParameterPrefix + "ms" + memoryInitialSize ) ; } if ( memoryMaximumSize != null ) { cmd . createArgument ( ) . setValue ( memoryParameterPrefix + "mx" + memoryMaximumSize ) ; } if ( attributes . getNowarn ( ) ) { cmd . createArgument ( ) . setValue ( "-nowarn" ) ; } if ( deprecation == true ) { cmd . createArgument ( ) . setValue ( "-deprecation" ) ; } if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "-classpath" ) ; if ( Project . getJavaVersion ( ) . startsWith ( "1.1" ) ) { Path cp = new Path ( project ) ; if ( bootclasspath != null ) { cp . append ( bootclasspath ) ; } if ( extdirs != null ) { addExtdirsToClasspath ( cp ) ; } cp . append ( classpath ) ; cp . append ( src ) ; cmd . createArgument ( ) . setPath ( cp ) ; } else { cmd . createArgument ( ) . setPath ( classpath ) ; cmd . createArgument ( ) . setValue ( "-sourcepath" ) ; cmd . createArgument ( ) . setPath ( src ) ; if ( target != null ) { cmd . createArgument ( ) . setValue ( "-target" ) ; cmd . createArgument ( ) . setValue ( target ) ; } if ( bootclasspath != null ) { cmd . createArgument ( ) . setValue ( "-bootclasspath" ) ; cmd . createArgument ( ) . setPath ( bootclasspath ) ; } if ( extdirs != null ) { cmd . createArgument ( ) . setValue ( "-extdirs" ) ; cmd . createArgument ( ) . setPath ( extdirs ) ; } } if ( encoding != null ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( encoding ) ; } if ( debug ) { cmd . createArgument ( ) . setValue ( "-g" ) ; } else if ( Project . getJavaVersion ( ) != Project . JAVA_1_0 && Project . getJavaVersion ( ) != Project . JAVA_1_1 ) { cmd . createArgument ( ) . setValue ( "-g:none" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O" ) ; } if ( depend ) { if ( Project . getJavaVersion ( ) . startsWith ( "1.1" ) ) { cmd . createArgument ( ) . setValue ( "-depend" ) ; } else if ( Project . getJavaVersion ( ) . startsWith ( "1.2" ) ) { cmd . createArgument ( ) . setValue ( "-Xdepend" ) ; } else { attributes . log ( "depend attribute is not supported by the modern compiler" , Project . MSG_WARN ) ; } } if ( verbose ) { cmd . createArgument ( ) . setValue ( "-verbose" ) ; } return cmd ; } protected Commandline setupJavacCommand ( ) { Commandline cmd = new Commandline ( ) ; setupJavacCommandlineSwitches ( cmd ) ; logAndAddFilesToCompile ( cmd ) ; return cmd ; } protected void logAndAddFilesToCompile ( Commandline cmd ) { attributes . log ( "Compilation args: " + cmd . toString ( ) , Project . MSG_VERBOSE ) ; StringBuffer niceSourceList = new StringBuffer ( "File" ) ; if ( compileList . length != 1 ) { niceSourceList . append ( "s" ) ; } niceSourceList . append ( " to be compiled:" ) ; niceSourceList . append ( lSep ) ; for ( int i = 0 ; i < compileList . length ; i ++ ) { String arg = compileList [ i ] . getAbsolutePath ( ) ; cmd . createArgument ( ) . setValue ( arg ) ; niceSourceList . append ( "    " + arg + lSep ) ; } attributes . log ( niceSourceList . toString ( ) , Project . MSG_VERBOSE ) ; } protected int executeExternalCompile ( String [ ] args , int firstFileName ) { String [ ] commandArray = null ; File tmpFile = null ; try { if ( Commandline . toString ( args ) . length ( ) > 4096 ) { PrintWriter out = null ; try { tmpFile = new File ( "jikes" + ( new Random ( System . currentTimeMillis ( ) ) ) . nextLong ( ) ) ; out = new PrintWriter ( new FileWriter ( tmpFile ) ) ; for ( int i = firstFileName ; i < args . length ; i ++ ) { out . println ( args [ i ] ) ; } out . flush ( ) ; commandArray = new String [ firstFileName + 1 ] ; System . arraycopy ( args , 0 , commandArray , 0 , firstFileName ) ; commandArray [ firstFileName ] = "@" + tmpFile . getAbsolutePath ( ) ; } catch ( IOException e ) { throw new BuildException ( "Error creating temporary file" , e , location ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( Throwable t ) { } } } } else { commandArray = args ; } try { Execute exe = new Execute ( new LogStreamHandler ( attributes , Project . MSG_INFO , Project . MSG_WARN ) ) ; exe . setAntRun ( project ) ; exe . setWorkingDirectory ( project . getBaseDir ( ) ) ; exe . setCommandline ( commandArray ) ; exe . execute ( ) ; return exe . getExitValue ( ) ; } catch ( IOException e ) { throw new BuildException ( "Error running " + args [ 0 ] + " compiler" , e , location ) ; } } finally { if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } protected void addExtdirsToClasspath ( Path classpath ) { if ( extdirs == null ) { String extProp = System . getProperty ( "java.ext.dirs" ) ; if ( extProp != null ) { extdirs = new Path ( project , extProp ) ; } else { return ; } } String [ ] dirs = extdirs . list ( ) ; for ( int i = 0 ; i < dirs . length ; i ++ ) { if ( ! dirs [ i ] . endsWith ( File . separator ) ) { dirs [ i ] += File . separator ; } File dir = project . resolveFile ( dirs [ i ] ) ; FileSet fs = new FileSet ( ) ; fs . setDir ( dir ) ; fs . setIncludes ( "*" ) ; classpath . addFileset ( fs ) ; } } } 	1	['11', '1', '8', '22', '86', '15', '8', '14', '4', '0.728571429', '887', '1', '7', '0', '0.266666667', '0', '0', '77.72727273', '22', '4.6364', '1']
