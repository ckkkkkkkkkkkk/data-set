package org . apache . velocity . runtime . parser . node ; import java . io . IOException ; import java . io . Writer ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; public class ASTIfStatement extends SimpleNode { public ASTIfStatement ( int id ) { super ( id ) ; } public ASTIfStatement ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException , ResourceNotFoundException , ParseErrorException { if ( jjtGetChild ( 0 ) . evaluate ( context ) ) { jjtGetChild ( 1 ) . render ( context , writer ) ; return true ; } int totalNodes = jjtGetNumChildren ( ) ; for ( int i = 2 ; i < totalNodes ; i ++ ) { if ( jjtGetChild ( i ) . evaluate ( context ) ) { jjtGetChild ( i ) . render ( context , writer ) ; return true ; } } return true ; } public void process ( InternalContextAdapter context , ParserVisitor visitor ) { } } 	0	['5', '2', '0', '10', '12', '10', '4', '8', '5', '2', '62', '0', '0', '0.903225806', '0.4', '1', '2', '11.4', '1', '0.6', '0']
package org . apache . velocity . runtime . log ; import java . util . logging . Level ; import java . util . logging . Logger ; import org . apache . velocity . runtime . RuntimeServices ; public class JdkLogChute implements LogChute { public static final String RUNTIME_LOG_JDK_LOGGER = "runtime.log.logsystem.jdk.logger" ; public static final String DEFAULT_LOG_NAME = "org.apache.velocity" ; protected Logger logger = null ; public void init ( RuntimeServices rs ) { String name = ( String ) rs . getProperty ( RUNTIME_LOG_JDK_LOGGER ) ; if ( name == null ) { name = DEFAULT_LOG_NAME ; } logger = Logger . getLogger ( name ) ; log ( LogChute . DEBUG_ID , "JdkLogChute will use logger '" + name + '\'' ) ; } protected Level getJdkLevel ( int level ) { switch ( level ) { case LogChute . WARN_ID : return Level . WARNING ; case LogChute . INFO_ID : return Level . INFO ; case LogChute . DEBUG_ID : return Level . FINE ; case LogChute . TRACE_ID : return Level . FINEST ; case LogChute . ERROR_ID : return Level . SEVERE ; default : return Level . FINER ; } } public void log ( int level , String message ) { log ( level , message , null ) ; } public void log ( int level , String message , Throwable t ) { Level jdkLevel = getJdkLevel ( level ) ; if ( t == null ) { logger . log ( jdkLevel , message ) ; } else { logger . log ( jdkLevel , message , t ) ; } } public boolean isLevelEnabled ( int level ) { Level jdkLevel = getJdkLevel ( level ) ; return logger . isLoggable ( jdkLevel ) ; } } 	1	['6', '1', '0', '2', '16', '3', '0', '2', '5', '0.866666667', '90', '0.333333333', '0', '0', '0.466666667', '0', '0', '13.5', '2', '1.3333', '3']
package org . apache . velocity . anakia ; import org . jdom . Element ; import org . jdom . Namespace ; import org . jdom . output . XMLOutputter ; import java . util . List ; public class AnakiaElement extends Element { private static final long serialVersionUID = 8429597252274491314L ; private static final XMLOutputter DEFAULT_OUTPUTTER = new XMLOutputter ( ) ; static { DEFAULT_OUTPUTTER . getFormat ( ) . setLineSeparator ( System . getProperty ( "line.separator" ) ) ; } public AnakiaElement ( String name , Namespace namespace ) { super ( name , namespace ) ; } public AnakiaElement ( String name ) { super ( name ) ; } public AnakiaElement ( String name , String uri ) { super ( name , uri ) ; } public AnakiaElement ( String name , String prefix , String uri ) { super ( name , prefix , uri ) ; } public NodeList selectNodes ( String xpathExpression ) { return new NodeList ( XPathCache . getXPath ( xpathExpression ) . applyTo ( this ) , false ) ; } public String toString ( ) { return DEFAULT_OUTPUTTER . outputString ( this ) ; } public List getContent ( ) { return new NodeList ( super . getContent ( ) , false ) ; } public List getChildren ( ) { return new NodeList ( super . getChildren ( ) , false ) ; } public List getChildren ( String name ) { return new NodeList ( super . getChildren ( name ) ) ; } public List getChildren ( String name , Namespace ns ) { return new NodeList ( super . getChildren ( name , ns ) ) ; } public List getAttributes ( ) { return new NodeList ( super . getAttributes ( ) ) ; } } 	0	['12', '3', '0', '8', '30', '64', '1', '7', '11', '1', '93', '1', '0', '0.920454545', '0.606060606', '1', '2', '6.583333333', '1', '0.5833', '0']
package org . apache . velocity . util . introspection ; import java . lang . reflect . Method ; import org . apache . velocity . runtime . log . Log ; public abstract class IntrospectorBase implements IntrospectorCacheListener { protected final Log log ; private final IntrospectorCache introspectorCache ; protected IntrospectorBase ( final Log log ) { this . log = log ; introspectorCache = new IntrospectorCacheImpl ( log ) ; introspectorCache . addListener ( this ) ; } public Method getMethod ( final Class c , final String name , final Object [ ] params ) throws IllegalArgumentException , MethodMap . AmbiguousException { if ( c == null ) { throw new IllegalArgumentException ( "class object is null!" ) ; } if ( params == null ) { throw new IllegalArgumentException ( "params object is null!" ) ; } ClassMap classMap = null ; IntrospectorCache ic = getIntrospectorCache ( ) ; synchronized ( ic ) { classMap = ic . get ( c ) ; if ( classMap == null ) { classMap = ic . put ( c ) ; } } return classMap . findMethod ( name , params ) ; } protected IntrospectorCache getIntrospectorCache ( ) { return introspectorCache ; } protected void clearCache ( ) { getIntrospectorCache ( ) . clear ( ) ; } protected ClassMap createClassMap ( final Class c ) { return getIntrospectorCache ( ) . put ( c ) ; } protected ClassMap lookupClassMap ( final Class c ) { return getIntrospectorCache ( ) . get ( c ) ; } public void triggerClear ( ) { } public void triggerGet ( Class c , ClassMap classMap ) { } public void triggerPut ( Class c , ClassMap classMap ) { } } 	1	['9', '1', '1', '7', '17', '34', '1', '6', '4', '0.6875', '93', '1', '2', '0', '0.351851852', '0', '0', '9.111111111', '1', '0.8889', '3']
package org . apache . velocity . runtime . resource . loader ; import java . io . InputStream ; import org . apache . commons . collections . ExtendedProperties ; import org . apache . commons . lang . StringUtils ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . runtime . resource . Resource ; import org . apache . velocity . util . ClassUtils ; import org . apache . velocity . util . ExceptionUtils ; public class ClasspathResourceLoader extends ResourceLoader { public void init ( ExtendedProperties configuration ) { if ( log . isTraceEnabled ( ) ) { log . trace ( "ClasspathResourceLoader : initialization complete." ) ; } } public InputStream getResourceStream ( String name ) throws ResourceNotFoundException { InputStream result = null ; if ( StringUtils . isEmpty ( name ) ) { throw new ResourceNotFoundException ( "No template name provided" ) ; } try { result = ClassUtils . getResourceAsStream ( getClass ( ) , name ) ; } catch ( Exception fnfe ) { throw ( ResourceNotFoundException ) ExceptionUtils . createWithCause ( ResourceNotFoundException . class , "problem with template: " + name , fnfe ) ; } if ( result == null ) { String msg = "ClasspathResourceLoader Error: cannot find resource " + name ; throw new ResourceNotFoundException ( msg ) ; } return result ; } public boolean isSourceModified ( Resource resource ) { return false ; } public long getLastModified ( Resource resource ) { return 0 ; } } 	0	['6', '2', '0', '8', '20', '15', '0', '8', '5', '1', '88', '0', '0', '0.6875', '0.416666667', '1', '1', '13.5', '2', '1', '0']
package org . apache . velocity . runtime . directive ; import java . io . IOException ; import java . io . Writer ; import org . apache . velocity . app . event . EventHandlerUtil ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . parser . ParserTreeConstants ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . runtime . resource . Resource ; public class Include extends InputBase { private String outputMsgStart = "" ; private String outputMsgEnd = "" ; public String getName ( ) { return "include" ; } public int getType ( ) { return LINE ; } public void init ( RuntimeServices rs , InternalContextAdapter context , Node node ) throws TemplateInitException { super . init ( rs , context , node ) ; outputMsgStart = rsvc . getString ( RuntimeConstants . ERRORMSG_START ) ; outputMsgStart = outputMsgStart + " " ; outputMsgEnd = rsvc . getString ( RuntimeConstants . ERRORMSG_END ) ; outputMsgEnd = " " + outputMsgEnd ; } public boolean render ( InternalContextAdapter context , Writer writer , Node node ) throws IOException , MethodInvocationException , ResourceNotFoundException { int argCount = node . jjtGetNumChildren ( ) ; for ( int i = 0 ; i < argCount ; i ++ ) { Node n = node . jjtGetChild ( i ) ; if ( n . getType ( ) == ParserTreeConstants . JJTSTRINGLITERAL || n . getType ( ) == ParserTreeConstants . JJTREFERENCE ) { if ( ! renderOutput ( n , context , writer ) ) outputErrorToStream ( writer , "error with arg " + i + " please see log." ) ; } else { rsvc . getLog ( ) . error ( "#include() invalid argument type: " + n . toString ( ) ) ; outputErrorToStream ( writer , "error with arg " + i + " please see log." ) ; } } return true ; } private boolean renderOutput ( Node node , InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException , ResourceNotFoundException { if ( node == null ) { rsvc . getLog ( ) . error ( "#include() null argument" ) ; return false ; } Object value = node . value ( context ) ; if ( value == null ) { rsvc . getLog ( ) . error ( "#include()  null argument" ) ; return false ; } String sourcearg = value . toString ( ) ; String arg = EventHandlerUtil . includeEvent ( rsvc , context , sourcearg , context . getCurrentTemplateName ( ) , getName ( ) ) ; boolean blockinput = false ; if ( arg == null ) blockinput = true ; Resource resource = null ; try { if ( ! blockinput ) resource = rsvc . getContent ( arg , getInputEncoding ( context ) ) ; } catch ( ResourceNotFoundException rnfe ) { rsvc . getLog ( ) . error ( "#include(): cannot find resource '" + arg + "', called from template " + context . getCurrentTemplateName ( ) + " at (" + getLine ( ) + ", " + getColumn ( ) + ")" ) ; throw rnfe ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { rsvc . getLog ( ) . error ( "#include(): arg = '" + arg + "', called from template " + context . getCurrentTemplateName ( ) + " at (" + getLine ( ) + ", " + getColumn ( ) + ')' , e ) ; } if ( blockinput ) return true ; else if ( resource == null ) return false ; writer . write ( ( String ) resource . getData ( ) ) ; return true ; } private void outputErrorToStream ( Writer writer , String msg ) throws IOException { if ( outputMsgStart != null && outputMsgEnd != null ) { writer . write ( outputMsgStart ) ; writer . write ( msg ) ; writer . write ( outputMsgEnd ) ; } } } 	1	['7', '3', '0', '11', '31', '9', '0', '11', '5', '0.5', '285', '1', '0', '0.571428571', '0.428571429', '0', '0', '39.42857143', '1', '0.8571', '2']
package org . apache . velocity . anakia ; public class Escape { public static final String LINE_SEPARATOR = System . getProperty ( "line.separator" ) ; public Escape ( ) { } public static final String getText ( String st ) { StringBuffer buff = new StringBuffer ( ) ; char [ ] block = st . toCharArray ( ) ; String stEntity = null ; int i , last ; for ( i = 0 , last = 0 ; i < block . length ; i ++ ) { switch ( block [ i ] ) { case '<' : stEntity = "&lt;" ; break ; case '>' : stEntity = "&gt;" ; break ; case '&' : stEntity = "&amp;" ; break ; case '"' : stEntity = "&quot;" ; break ; case '\n' : stEntity = LINE_SEPARATOR ; break ; default : break ; } if ( stEntity != null ) { buff . append ( block , last , i - last ) ; buff . append ( stEntity ) ; stEntity = null ; last = i + 1 ; } } if ( last < block . length ) { buff . append ( block , last , i - last ) ; } return buff . toString ( ) ; } } 	0	['3', '1', '0', '1', '10', '1', '1', '0', '2', '0.5', '84', '0', '0', '0', '0.5', '0', '0', '26.66666667', '10', '3.3333', '0']
package org . apache . velocity . app . event . implement ; import java . util . ArrayList ; import java . util . List ; import org . apache . velocity . app . event . InvalidReferenceEventHandler ; import org . apache . velocity . context . Context ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . util . RuntimeServicesAware ; import org . apache . velocity . util . introspection . Info ; public class ReportInvalidReferences implements InvalidReferenceEventHandler , RuntimeServicesAware { public static final String EVENTHANDLER_INVALIDREFERENCE_EXCEPTION = "eventhandler.invalidreference.exception" ; List invalidReferences = new ArrayList ( ) ; private boolean stopOnFirstInvalidReference = false ; public Object invalidGetMethod ( Context context , String reference , Object object , String property , Info info ) { reportInvalidReference ( reference , info ) ; return null ; } public Object invalidMethod ( Context context , String reference , Object object , String method , Info info ) { if ( reference == null ) { reportInvalidReference ( object . getClass ( ) . getName ( ) + "." + method , info ) ; } else { reportInvalidReference ( reference , info ) ; } return null ; } public boolean invalidSetMethod ( Context context , String leftreference , String rightreference , Info info ) { reportInvalidReference ( leftreference , info ) ; return false ; } private void reportInvalidReference ( String reference , Info info ) { InvalidReferenceInfo invalidReferenceInfo = new InvalidReferenceInfo ( reference , info ) ; invalidReferences . add ( invalidReferenceInfo ) ; if ( stopOnFirstInvalidReference ) { throw new ParseErrorException ( "Error in page - invalid reference.  " , info , invalidReferenceInfo . getInvalidReference ( ) ) ; } } public List getInvalidReferences ( ) { return invalidReferences ; } public void setRuntimeServices ( RuntimeServices rs ) { stopOnFirstInvalidReference = rs . getConfiguration ( ) . getBoolean ( EVENTHANDLER_INVALIDREFERENCE_EXCEPTION , false ) ; } } 	1	['7', '1', '0', '8', '20', '11', '0', '8', '6', '0.5', '91', '0.333333333', '0', '0', '0.5', '0', '0', '11.57142857', '2', '1.1429', '1']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; public class ASTFalse extends SimpleNode { private static Boolean value = Boolean . FALSE ; public ASTFalse ( int id ) { super ( id ) ; } public ASTFalse ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) { return false ; } public Object value ( InternalContextAdapter context ) { return value ; } } 	0	['6', '2', '0', '6', '9', '13', '4', '4', '5', '0.8', '28', '1', '0', '0.903225806', '0.4', '0', '0', '3.5', '1', '0.5', '0']
package org . apache . velocity . runtime . parser . node ; import java . math . BigDecimal ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; public class ASTFloatingPointLiteral extends SimpleNode { private Number value = null ; public ASTFloatingPointLiteral ( int id ) { super ( id ) ; } public ASTFloatingPointLiteral ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object init ( InternalContextAdapter context , Object data ) throws TemplateInitException { super . init ( context , data ) ; String str = getFirstToken ( ) . image ; try { value = new Double ( str ) ; } catch ( NumberFormatException E1 ) { value = new BigDecimal ( str ) ; } return data ; } public Object value ( InternalContextAdapter context ) { return value ; } } 	1	['5', '2', '0', '8', '12', '0', '4', '6', '5', '0.25', '54', '1', '0', '0.903225806', '0.433333333', '0', '0', '9.6', '1', '0.6', '1']
package org . apache . velocity . runtime . log ; import org . apache . log4j . Category ; import org . apache . log4j . Level ; import org . apache . log4j . PatternLayout ; import org . apache . log4j . RollingFileAppender ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeServices ; public class SimpleLog4JLogSystem implements LogSystem { private RuntimeServices rsvc = null ; private RollingFileAppender appender = null ; protected Category logger = null ; public SimpleLog4JLogSystem ( ) { } public void init ( RuntimeServices rs ) { rsvc = rs ; String categoryname = ( String ) rsvc . getProperty ( "runtime.log.logsystem.log4j.category" ) ; if ( categoryname != null ) { logger = Category . getInstance ( categoryname ) ; logVelocityMessage ( 0 , "SimpleLog4JLogSystem using category '" + categoryname + "'" ) ; return ; } String logfile = rsvc . getString ( RuntimeConstants . RUNTIME_LOG ) ; try { internalInit ( logfile ) ; logVelocityMessage ( 0 , "SimpleLog4JLogSystem initialized using logfile '" + logfile + "'" ) ; } catch ( Exception e ) { System . err . println ( "PANIC : error configuring SimpleLog4JLogSystem : " + e ) ; } } private void internalInit ( String logfile ) throws Exception { logger = Category . getInstance ( this . getClass ( ) . getName ( ) ) ; logger . setAdditivity ( false ) ; logger . setLevel ( Level . DEBUG ) ; appender = new RollingFileAppender ( new PatternLayout ( "%d - %m%n" ) , logfile , true ) ; appender . setMaxBackupIndex ( 1 ) ; appender . setMaximumFileSize ( 100000 ) ; logger . addAppender ( appender ) ; } public void logVelocityMessage ( int level , String message ) { switch ( level ) { case LogSystem . WARN_ID : logger . warn ( message ) ; break ; case LogSystem . INFO_ID : logger . info ( message ) ; break ; case LogSystem . DEBUG_ID : logger . debug ( message ) ; break ; case LogSystem . ERROR_ID : logger . error ( message ) ; break ; default : logger . debug ( message ) ; break ; } } protected void finalize ( ) throws Throwable { shutdown ( ) ; } public void shutdown ( ) { if ( appender != null ) { logger . removeAppender ( appender ) ; appender . close ( ) ; appender = null ; } } } 	0	['6', '1', '0', '8', '30', '0', '0', '8', '4', '0.333333333', '168', '1', '1', '0', '0.416666667', '0', '0', '26.5', '2', '1.3333', '0']
package org . apache . velocity . runtime . resource ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . resource . loader . ResourceLoader ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . ParseErrorException ; public abstract class Resource { protected RuntimeServices rsvc = null ; protected ResourceLoader resourceLoader ; protected static final long MILLIS_PER_SECOND = 1000 ; protected long modificationCheckInterval = 0 ; protected long lastModified = 0 ; protected long nextCheck = 0 ; protected String name ; protected String encoding = RuntimeConstants . ENCODING_DEFAULT ; protected Object data = null ; public Resource ( ) { } public void setRuntimeServices ( RuntimeServices rs ) { rsvc = rs ; } public abstract boolean process ( ) throws ResourceNotFoundException , ParseErrorException , Exception ; public boolean isSourceModified ( ) { return resourceLoader . isSourceModified ( this ) ; } public void setModificationCheckInterval ( long modificationCheckInterval ) { this . modificationCheckInterval = modificationCheckInterval ; } public boolean requiresChecking ( ) { if ( modificationCheckInterval <= 0 ) { return false ; } return ( System . currentTimeMillis ( ) >= nextCheck ) ; } public void touch ( ) { nextCheck = System . currentTimeMillis ( ) + ( MILLIS_PER_SECOND * modificationCheckInterval ) ; } public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String getEncoding ( ) { return encoding ; } public long getLastModified ( ) { return lastModified ; } public void setLastModified ( long lastModified ) { this . lastModified = lastModified ; } public ResourceLoader getResourceLoader ( ) { return resourceLoader ; } public void setResourceLoader ( ResourceLoader resourceLoader ) { this . resourceLoader = resourceLoader ; } public void setData ( Object data ) { this . data = data ; } public Object getData ( ) { return data ; } } 	1	['17', '1', '2', '26', '20', '96', '23', '4', '17', '0.902777778', '120', '1', '2', '0', '0.235294118', '0', '0', '5.529411765', '3', '1.0588', '2']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; import org . apache . velocity . exception . MethodInvocationException ; public class ASTExpression extends SimpleNode { public ASTExpression ( int id ) { super ( id ) ; } public ASTExpression ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { return jjtGetChild ( 0 ) . evaluate ( context ) ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { return jjtGetChild ( 0 ) . value ( context ) ; } } 	0	['5', '2', '0', '9', '11', '10', '5', '6', '5', '2', '31', '0', '0', '0.903225806', '0.4', '1', '2', '5.2', '1', '0.6', '0']
package org . apache . velocity . app . event . implement ; import java . io . PrintWriter ; import java . io . StringWriter ; import org . apache . velocity . app . event . MethodExceptionEventHandler ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . util . RuntimeServicesAware ; public class PrintExceptions implements MethodExceptionEventHandler , RuntimeServicesAware { private static String SHOW_MESSAGE = "eventhandler.methodexception.message" ; private static String SHOW_STACK_TRACE = "eventhandler.methodexception.stacktrace" ; private RuntimeServices rs = null ; public Object methodException ( Class claz , String method , Exception e ) throws Exception { boolean showMessage = rs . getBoolean ( SHOW_MESSAGE , false ) ; boolean showStackTrace = rs . getBoolean ( SHOW_STACK_TRACE , false ) ; StringBuffer st ; if ( showMessage && showStackTrace ) { st = new StringBuffer ( 200 ) ; st . append ( e . getClass ( ) . getName ( ) ) . append ( "\n" ) ; st . append ( e . getMessage ( ) ) . append ( "\n" ) ; st . append ( getStackTrace ( e ) ) ; } else if ( showMessage ) { st = new StringBuffer ( 50 ) ; st . append ( e . getClass ( ) . getName ( ) ) . append ( "\n" ) ; st . append ( e . getMessage ( ) ) . append ( "\n" ) ; } else if ( showStackTrace ) { st = new StringBuffer ( 200 ) ; st . append ( e . getClass ( ) . getName ( ) ) . append ( "\n" ) ; st . append ( getStackTrace ( e ) ) ; } else { st = new StringBuffer ( 15 ) ; st . append ( e . getClass ( ) . getName ( ) ) . append ( "\n" ) ; } return st . toString ( ) ; } private static String getStackTrace ( Throwable throwable ) { PrintWriter printWriter = null ; try { StringWriter stackTraceWriter = new StringWriter ( ) ; printWriter = new PrintWriter ( stackTraceWriter ) ; throwable . printStackTrace ( printWriter ) ; printWriter . flush ( ) ; return stackTraceWriter . toString ( ) ; } finally { if ( printWriter != null ) { printWriter . close ( ) ; } } } public void setRuntimeServices ( RuntimeServices rs ) { this . rs = rs ; } } 	1	['5', '1', '0', '3', '19', '2', '0', '3', '3', '0.666666667', '157', '1', '1', '0', '0.333333333', '0', '0', '29.8', '3', '1', '1']
package org . apache . velocity . context ; import org . apache . velocity . app . event . EventCartridge ; public interface InternalEventContext { public EventCartridge attachEventCartridge ( EventCartridge ec ) ; public EventCartridge getEventCartridge ( ) ; } 	0	['2', '1', '0', '5', '2', '1', '5', '1', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . velocity . app . event . implement ; import org . apache . commons . lang . StringEscapeUtils ; public class EscapeXmlReference extends EscapeReference { protected String escape ( Object text ) { return StringEscapeUtils . escapeXml ( text . toString ( ) ) ; } protected String getMatchAttribute ( ) { return "eventhandler.escape.xml.match" ; } } 	1	['3', '2', '0', '2', '6', '3', '0', '2', '1', '2', '12', '0', '0', '0.714285714', '0.666666667', '1', '2', '3', '1', '0.6667', '1']
package org . apache . velocity . io ; import java . io . IOException ; import java . io . Writer ; public final class VelocityWriter extends Writer { public static final int NO_BUFFER = 0 ; public static final int DEFAULT_BUFFER = - 1 ; public static final int UNBOUNDED_BUFFER = - 2 ; private int bufferSize ; private boolean autoFlush ; private Writer writer ; private char cb [ ] ; private int nextChar ; private static int defaultCharBufferSize = 8 * 1024 ; public VelocityWriter ( Writer writer ) { this ( writer , defaultCharBufferSize , true ) ; } private VelocityWriter ( int bufferSize , boolean autoFlush ) { this . bufferSize = bufferSize ; this . autoFlush = autoFlush ; } public int getBufferSize ( ) { return bufferSize ; } public boolean isAutoFlush ( ) { return autoFlush ; } public VelocityWriter ( Writer writer , int sz , boolean autoFlush ) { this ( sz , autoFlush ) ; if ( sz < 0 ) throw new IllegalArgumentException ( "Buffer size <= 0" ) ; this . writer = writer ; cb = sz == 0 ? null : new char [ sz ] ; nextChar = 0 ; } private final void flushBuffer ( ) throws IOException { if ( bufferSize == 0 ) return ; if ( nextChar == 0 ) return ; writer . write ( cb , 0 , nextChar ) ; nextChar = 0 ; } public final void clear ( ) { nextChar = 0 ; } private final void bufferOverflow ( ) throws IOException { throw new IOException ( "overflow" ) ; } public final void flush ( ) throws IOException { flushBuffer ( ) ; if ( writer != null ) { writer . flush ( ) ; } } public final void close ( ) throws IOException { if ( writer == null ) return ; flush ( ) ; } public final int getRemaining ( ) { return bufferSize - nextChar ; } public final void write ( int c ) throws IOException { if ( bufferSize == 0 ) { writer . write ( c ) ; } else { if ( nextChar >= bufferSize ) if ( autoFlush ) flushBuffer ( ) ; else bufferOverflow ( ) ; cb [ nextChar ++ ] = ( char ) c ; } } private final int min ( int a , int b ) { return ( a < b ? a : b ) ; } public final void write ( char cbuf [ ] , int off , int len ) throws IOException { if ( bufferSize == 0 ) { writer . write ( cbuf , off , len ) ; return ; } if ( len == 0 ) { return ; } if ( len >= bufferSize ) { if ( autoFlush ) flushBuffer ( ) ; else bufferOverflow ( ) ; writer . write ( cbuf , off , len ) ; return ; } int b = off , t = off + len ; while ( b < t ) { int d = min ( bufferSize - nextChar , t - b ) ; System . arraycopy ( cbuf , b , cb , nextChar , d ) ; b += d ; nextChar += d ; if ( nextChar >= bufferSize ) if ( autoFlush ) flushBuffer ( ) ; else bufferOverflow ( ) ; } } public final void write ( char buf [ ] ) throws IOException { write ( buf , 0 , buf . length ) ; } public final void write ( String s , int off , int len ) throws IOException { if ( bufferSize == 0 ) { writer . write ( s , off , len ) ; return ; } int b = off , t = off + len ; while ( b < t ) { int d = min ( bufferSize - nextChar , t - b ) ; s . getChars ( b , b + d , cb , nextChar ) ; b += d ; nextChar += d ; if ( nextChar >= bufferSize ) if ( autoFlush ) flushBuffer ( ) ; else bufferOverflow ( ) ; } } public final void write ( String s ) throws IOException { if ( s != null ) { write ( s , 0 , s . length ( ) ) ; } } public final void recycle ( Writer writer ) { this . writer = writer ; clear ( ) ; } } 	0	['19', '2', '0', '1', '29', '61', '1', '0', '14', '0.709876543', '342', '0.666666667', '0', '0.464285714', '0.305555556', '1', '2', '16.52631579', '2', '0.8421', '0']
package org . apache . velocity . runtime ; public interface RuntimeConstants { String RUNTIME_LOG = "runtime.log" ; String RUNTIME_LOG_LOGSYSTEM = "runtime.log.logsystem" ; String RUNTIME_LOG_LOGSYSTEM_CLASS = "runtime.log.logsystem.class" ; String RUNTIME_LOG_ERROR_STACKTRACE = "runtime.log.error.stacktrace" ; String RUNTIME_LOG_WARN_STACKTRACE = "runtime.log.warn.stacktrace" ; String RUNTIME_LOG_INFO_STACKTRACE = "runtime.log.info.stacktrace" ; String RUNTIME_LOG_REFERENCE_LOG_INVALID = "runtime.log.invalid.references" ; String TRACE_PREFIX = " [trace] " ; String DEBUG_PREFIX = " [debug] " ; String INFO_PREFIX = "  [info] " ; String WARN_PREFIX = "  [warn] " ; String ERROR_PREFIX = " [error] " ; String UNKNOWN_PREFIX = " [unknown] " ; String COUNTER_NAME = "directive.foreach.counter.name" ; String COUNTER_INITIAL_VALUE = "directive.foreach.counter.initial.value" ; String MAX_NUMBER_LOOPS = "directive.foreach.maxloops" ; String SET_NULL_ALLOWED = "directive.set.null.allowed" ; String ERRORMSG_START = "directive.include.output.errormsg.start" ; String ERRORMSG_END = "directive.include.output.errormsg.end" ; String PARSE_DIRECTIVE_MAXDEPTH = "directive.parse.max.depth" ; String RESOURCE_MANAGER_CLASS = "resource.manager.class" ; String RESOURCE_MANAGER_CACHE_CLASS = "resource.manager.cache.class" ; String RESOURCE_MANAGER_DEFAULTCACHE_SIZE = "resource.manager.defaultcache.size" ; String RESOURCE_MANAGER_LOGWHENFOUND = "resource.manager.logwhenfound" ; String RESOURCE_LOADER = "resource.loader" ; String FILE_RESOURCE_LOADER_PATH = "file.resource.loader.path" ; String FILE_RESOURCE_LOADER_CACHE = "file.resource.loader.cache" ; String EVENTHANDLER_REFERENCEINSERTION = "eventhandler.referenceinsertion.class" ; String EVENTHANDLER_NULLSET = "eventhandler.nullset.class" ; String EVENTHANDLER_METHODEXCEPTION = "eventhandler.methodexception.class" ; String EVENTHANDLER_INCLUDE = "eventhandler.include.class" ; String EVENTHANDLER_INVALIDREFERENCES = "eventhandler.invalidreferences.class" ; String VM_LIBRARY = "velocimacro.library" ; String VM_LIBRARY_DEFAULT = "VM_global_library.vm" ; String VM_LIBRARY_AUTORELOAD = "velocimacro.library.autoreload" ; String VM_PERM_ALLOW_INLINE = "velocimacro.permissions.allow.inline" ; String VM_PERM_ALLOW_INLINE_REPLACE_GLOBAL = "velocimacro.permissions.allow.inline.to.replace.global" ; String VM_PERM_INLINE_LOCAL = "velocimacro.permissions.allow.inline.local.scope" ; String VM_MESSAGES_ON = "velocimacro.messages.on" ; String VM_CONTEXT_LOCALSCOPE = "velocimacro.context.localscope" ; String VM_ARGUMENTS_STRICT = "velocimacro.arguments.strict" ; String INTERPOLATE_STRINGLITERALS = "runtime.interpolate.string.literals" ; String INPUT_ENCODING = "input.encoding" ; String OUTPUT_ENCODING = "output.encoding" ; String ENCODING_DEFAULT = "ISO-8859-1" ; String UBERSPECT_CLASSNAME = "runtime.introspector.uberspect" ; String INTROSPECTOR_RESTRICT_PACKAGES = "introspector.restrict.packages" ; String INTROSPECTOR_RESTRICT_CLASSES = "introspector.restrict.classes" ; String PARSER_POOL_CLASS = "parser.pool.class" ; String PARSER_POOL_SIZE = "parser.pool.size" ; String DEFAULT_RUNTIME_PROPERTIES = "org/apache/velocity/runtime/defaults/velocity.properties" ; String DEFAULT_RUNTIME_DIRECTIVES = "org/apache/velocity/runtime/defaults/directive.properties" ; int NUMBER_OF_PARSERS = 20 ; } 	1	['0', '1', '0', '5', '0', '0', '5', '0', '0', '2', '53', '0', '0', '0', '0', '0', '0', '0', '0', '0', '7']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; public class ASTprocess extends SimpleNode { public ASTprocess ( int id ) { super ( id ) ; } public ASTprocess ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } } 	0	['3', '2', '0', '5', '6', '3', '4', '3', '3', '2', '17', '0', '0', '0.965517241', '0.533333333', '0', '0', '4.666666667', '1', '0.3333', '0']
package org . apache . velocity . runtime ; import java . util . HashMap ; import java . util . Map ; import java . util . Vector ; import org . apache . commons . lang . StringUtils ; import org . apache . velocity . Template ; import org . apache . velocity . runtime . directive . Directive ; import org . apache . velocity . runtime . directive . Macro ; import org . apache . velocity . runtime . directive . VelocimacroProxy ; import org . apache . velocity . runtime . log . LogDisplayWrapper ; public class VelocimacroFactory { private final RuntimeServices rsvc ; private final LogDisplayWrapper log ; private VelocimacroManager vmManager = null ; private boolean replaceAllowed = false ; private boolean addNewAllowed = true ; private boolean templateLocal = false ; private boolean autoReloadLibrary = false ; private Vector macroLibVec = null ; private Map libModMap ; public VelocimacroFactory ( final RuntimeServices rsvc ) { this . rsvc = rsvc ; this . log = new LogDisplayWrapper ( rsvc . getLog ( ) , "Velocimacro : " , rsvc . getBoolean ( RuntimeConstants . VM_MESSAGES_ON , true ) ) ; libModMap = new HashMap ( ) ; vmManager = new VelocimacroManager ( rsvc ) ; } public void initVelocimacro ( ) { synchronized ( this ) { log . trace ( "initialization starting." ) ; setReplacementPermission ( true ) ; vmManager . setNamespaceUsage ( false ) ; Object libfiles = rsvc . getProperty ( RuntimeConstants . VM_LIBRARY ) ; if ( libfiles == null ) { log . debug ( "\"" + RuntimeConstants . VM_LIBRARY + "\" is not set.  Trying default library: " + RuntimeConstants . VM_LIBRARY_DEFAULT ) ; if ( rsvc . getLoaderNameForResource ( RuntimeConstants . VM_LIBRARY_DEFAULT ) != null ) { libfiles = RuntimeConstants . VM_LIBRARY_DEFAULT ; } else { log . debug ( "Default library not found." ) ; } } if ( libfiles != null ) { if ( libfiles instanceof Vector ) { macroLibVec = ( Vector ) libfiles ; } else if ( libfiles instanceof String ) { macroLibVec = new Vector ( ) ; macroLibVec . addElement ( libfiles ) ; } for ( int i = 0 ; i < macroLibVec . size ( ) ; i ++ ) { String lib = ( String ) macroLibVec . elementAt ( i ) ; if ( StringUtils . isNotEmpty ( lib ) ) { vmManager . setRegisterFromLib ( true ) ; log . debug ( "adding VMs from VM library : " + lib ) ; try { Template template = rsvc . getTemplate ( lib ) ; Twonk twonk = new Twonk ( ) ; twonk . template = template ; twonk . modificationTime = template . getLastModified ( ) ; libModMap . put ( lib , twonk ) ; } catch ( Exception e ) { log . error ( true , "Velocimacro : Error using VM library : " + lib , e ) ; } log . trace ( "VM library registration complete." ) ; vmManager . setRegisterFromLib ( false ) ; } } } setAddMacroPermission ( true ) ; if ( ! rsvc . getBoolean ( RuntimeConstants . VM_PERM_ALLOW_INLINE , true ) ) { setAddMacroPermission ( false ) ; log . info ( "allowInline = false : VMs can NOT be defined inline in templates" ) ; } else { log . debug ( "allowInline = true : VMs can be defined inline in templates" ) ; } setReplacementPermission ( false ) ; if ( rsvc . getBoolean ( RuntimeConstants . VM_PERM_ALLOW_INLINE_REPLACE_GLOBAL , false ) ) { setReplacementPermission ( true ) ; log . info ( "allowInlineToOverride = true : VMs " + "defined inline may replace previous VM definitions" ) ; } else { log . debug ( "allowInlineToOverride = false : VMs " + "defined inline may NOT replace previous VM definitions" ) ; } vmManager . setNamespaceUsage ( true ) ; setTemplateLocalInline ( rsvc . getBoolean ( RuntimeConstants . VM_PERM_INLINE_LOCAL , false ) ) ; if ( getTemplateLocalInline ( ) ) { log . info ( "allowInlineLocal = true : VMs " + "defined inline will be local to their defining template only." ) ; } else { log . debug ( "allowInlineLocal = false : VMs " + "defined inline will be global in scope if allowed." ) ; } vmManager . setTemplateLocalInlineVM ( getTemplateLocalInline ( ) ) ; setAutoload ( rsvc . getBoolean ( RuntimeConstants . VM_LIBRARY_AUTORELOAD , false ) ) ; if ( getAutoload ( ) ) { log . info ( "autoload on : VM system " + "will automatically reload global library macros" ) ; } else { log . debug ( "autoload off : VM system " + "will not automatically reload global library macros" ) ; } log . trace ( "Velocimacro : initialization complete." ) ; } } public boolean addVelocimacro ( String name , String macroBody , String argArray [ ] , String sourceTemplate ) { if ( name == null || macroBody == null || argArray == null || sourceTemplate == null ) { log . warn ( "VM addition rejected : programmer error : arg null" ) ; return false ; } if ( ! canAddVelocimacro ( name , sourceTemplate ) ) { return false ; } synchronized ( this ) { vmManager . addVM ( name , macroBody , argArray , sourceTemplate ) ; } StringBuffer msg = new StringBuffer ( "added " ) ; Macro . macroToString ( msg , argArray ) ; msg . append ( " : source = " ) . append ( sourceTemplate ) ; log . info ( msg . toString ( ) ) ; return true ; } private synchronized boolean canAddVelocimacro ( String name , String sourceTemplate ) { if ( getAutoload ( ) && ( macroLibVec != null ) ) { for ( int i = 0 ; i < macroLibVec . size ( ) ; i ++ ) { String lib = ( String ) macroLibVec . elementAt ( i ) ; if ( lib . equals ( sourceTemplate ) ) { return true ; } } } if ( ! addNewAllowed ) { log . warn ( "VM addition rejected : " + name + " : inline VMs not allowed." ) ; return false ; } if ( ! templateLocal ) { if ( isVelocimacro ( name , sourceTemplate ) && ! replaceAllowed ) { log . warn ( "VM addition rejected : " + name + " : inline not allowed to replace existing VM" ) ; return false ; } } return true ; } public boolean isVelocimacro ( String vm , String sourceTemplate ) { synchronized ( this ) { if ( vmManager . get ( vm , sourceTemplate ) != null ) return true ; } return false ; } public Directive getVelocimacro ( String vmName , String sourceTemplate ) { VelocimacroProxy vp = null ; synchronized ( this ) { vp = vmManager . get ( vmName , sourceTemplate ) ; if ( vp != null && getAutoload ( ) ) { String lib = vmManager . getLibraryName ( vmName , sourceTemplate ) ; if ( lib != null ) { try { Twonk tw = ( Twonk ) libModMap . get ( lib ) ; if ( tw != null ) { Template template = tw . template ; long tt = tw . modificationTime ; long ft = template . getResourceLoader ( ) . getLastModified ( template ) ; if ( ft > tt ) { log . debug ( "auto-reloading VMs from VM library : " + lib ) ; tw . modificationTime = ft ; template = rsvc . getTemplate ( lib ) ; tw . template = template ; tw . modificationTime = template . getLastModified ( ) ; } } } catch ( Exception e ) { log . error ( true , "Velocimacro : Error using VM library : " + lib , e ) ; } vp = vmManager . get ( vmName , sourceTemplate ) ; } } } return vp ; } public boolean dumpVMNamespace ( String namespace ) { return vmManager . dumpNamespace ( namespace ) ; } private void setTemplateLocalInline ( boolean b ) { templateLocal = b ; } private boolean getTemplateLocalInline ( ) { return templateLocal ; } private boolean setAddMacroPermission ( final boolean addNewAllowed ) { boolean b = this . addNewAllowed ; this . addNewAllowed = addNewAllowed ; return b ; } private boolean setReplacementPermission ( boolean arg ) { boolean b = replaceAllowed ; replaceAllowed = arg ; return b ; } private void setAutoload ( boolean b ) { autoReloadLibrary = b ; } private boolean getAutoload ( ) { return autoReloadLibrary ; } private static class Twonk { public Template template ; public long modificationTime ; } } 	1	['13', '1', '0', '14', '51', '16', '1', '13', '6', '0.675925926', '615', '1', '3', '0', '0.369230769', '0', '0', '45.61538462', '12', '3.0769', '7']
package org . apache . velocity . runtime . resource ; import java . util . Iterator ; import org . apache . velocity . runtime . RuntimeServices ; public interface ResourceCache { public void initialize ( RuntimeServices rs ) ; public Resource get ( Object resourceKey ) ; public Resource put ( Object resourceKey , Resource resource ) ; public Resource remove ( Object resourceKey ) ; public Iterator enumerateKeys ( ) ; } 	0	['5', '1', '0', '4', '5', '10', '2', '2', '5', '2', '5', '0', '0', '0', '0.5', '0', '0', '0', '1', '1', '0']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . util . TemplateNumber ; public class ASTAddNode extends SimpleNode { public ASTAddNode ( int id ) { super ( id ) ; } public ASTAddNode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { Object left = jjtGetChild ( 0 ) . value ( context ) ; Object right = jjtGetChild ( 1 ) . value ( context ) ; if ( left == null || right == null ) { log . error ( ( left == null ? "Left" : "Right" ) + " side (" + jjtGetChild ( ( left == null ? 0 : 1 ) ) . literal ( ) + ") of addition operation has null value." + " Operation not possible. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return null ; } if ( left instanceof TemplateNumber ) { left = ( ( TemplateNumber ) left ) . getAsNumber ( ) ; } if ( right instanceof TemplateNumber ) { right = ( ( TemplateNumber ) right ) . getAsNumber ( ) ; } if ( left instanceof Number && right instanceof Number ) { return MathUtils . add ( ( Number ) left , ( Number ) right ) ; } if ( left instanceof String || right instanceof String ) { return left . toString ( ) . concat ( right . toString ( ) ) ; } log . error ( ( ! ( left instanceof Number || left instanceof String ) ? "Left" : "Right" ) + " side of addition operation is not a valid type. " + "Currently only Strings, numbers (1,2,3...) and Number type are supported. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return null ; } } 	1	['4', '2', '0', '11', '22', '6', '4', '9', '4', '2', '155', '0', '0', '0.933333333', '0.416666667', '1', '1', '37.75', '1', '0.5', '1']
package org . apache . velocity . runtime . parser ; public class TokenMgrError extends Error { static final int LEXICAL_ERROR = 0 ; static final int STATIC_LEXER_ERROR = 1 ; static final int INVALID_LEXICAL_STATE = 2 ; static final int LOOP_DETECTED = 3 ; int errorCode ; protected static final String addEscapes ( String str ) { StringBuffer retval = new StringBuffer ( ) ; char ch ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { switch ( str . charAt ( i ) ) { case 0 : continue ; case '\b' : retval . append ( "\\b" ) ; continue ; case '\t' : retval . append ( "\\t" ) ; continue ; case '\n' : retval . append ( "\\n" ) ; continue ; case '\f' : retval . append ( "\\f" ) ; continue ; case '\r' : retval . append ( "\\r" ) ; continue ; case '\"' : retval . append ( "\\\"" ) ; continue ; case '\'' : retval . append ( "\\\'" ) ; continue ; case '\\' : retval . append ( "\\\\" ) ; continue ; default : if ( ( ch = str . charAt ( i ) ) < 0x20 || ch > 0x7e ) { String s = "0000" + Integer . toString ( ch , 16 ) ; retval . append ( "\\u" + s . substring ( s . length ( ) - 4 , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . toString ( ) ; } protected static String LexicalError ( boolean EOFSeen , int lexState , int errorLine , int errorColumn , String errorAfter , char curChar ) { return ( "Lexical error at line " + errorLine + ", column " + errorColumn + ".  Encountered: " + ( EOFSeen ? "<EOF> " : ( "\"" + addEscapes ( String . valueOf ( curChar ) ) + "\"" ) + " (" + ( int ) curChar + "), " ) + "after : \"" + addEscapes ( errorAfter ) + "\"" ) ; } public String getMessage ( ) { return super . getMessage ( ) ; } public TokenMgrError ( ) { } public TokenMgrError ( String message , int reason ) { super ( message ) ; errorCode = reason ; } public TokenMgrError ( boolean EOFSeen , int lexState , int errorLine , int errorColumn , String errorAfter , char curChar , int reason ) { this ( LexicalError ( EOFSeen , lexState , errorLine , errorColumn , errorAfter , curChar ) , reason ) ; } } 	0	['6', '3', '0', '2', '19', '15', '2', '0', '4', '1.12', '184', '0', '0', '0.8125', '0.5', '1', '1', '28.83333333', '14', '2.8333', '0']
package org . apache . velocity . runtime . directive ; import java . io . Writer ; import java . io . IOException ; import java . util . List ; import java . util . ArrayList ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . runtime . parser . node . NodeUtils ; import org . apache . velocity . runtime . parser . Token ; import org . apache . velocity . runtime . parser . ParseException ; import org . apache . velocity . runtime . parser . ParserTreeConstants ; import org . apache . velocity . runtime . RuntimeServices ; public class Macro extends Directive { private static boolean debugMode = false ; public String getName ( ) { return "macro" ; } public int getType ( ) { return BLOCK ; } public boolean render ( InternalContextAdapter context , Writer writer , Node node ) throws IOException { return true ; } public void init ( RuntimeServices rs , InternalContextAdapter context , Node node ) throws TemplateInitException { super . init ( rs , context , node ) ; } public static void processAndRegister ( RuntimeServices rs , Token t , Node node , String sourceTemplate ) throws IOException , ParseException { int numArgs = node . jjtGetNumChildren ( ) ; if ( numArgs < 2 ) { rs . getLog ( ) . error ( "#macro error : Velocimacro must have name as 1st " + "argument to #macro(). #args = " + numArgs ) ; throw new MacroParseException ( "First argument to #macro() must be " + " macro name." , sourceTemplate , t ) ; } int firstType = node . jjtGetChild ( 0 ) . getType ( ) ; if ( firstType != ParserTreeConstants . JJTWORD ) { throw new MacroParseException ( "First argument to #macro() must be a" + " token without surrounding \' or \", which specifies" + " the macro name.  Currently it is a " + ParserTreeConstants . jjtNodeName [ firstType ] , sourceTemplate , t ) ; } String argArray [ ] = getArgArray ( node , rs ) ; List macroArray = getASTAsStringArray ( node . jjtGetChild ( numArgs - 1 ) ) ; StringBuffer macroBody = new StringBuffer ( ) ; for ( int i = 0 ; i < macroArray . size ( ) ; i ++ ) { macroBody . append ( macroArray . get ( i ) ) ; } boolean macroAdded = rs . addVelocimacro ( argArray [ 0 ] , macroBody . toString ( ) , argArray , sourceTemplate ) ; if ( ! macroAdded && rs . getLog ( ) . isWarnEnabled ( ) ) { StringBuffer msg = new StringBuffer ( "Failed to add macro: " ) ; macroToString ( msg , argArray ) ; msg . append ( " : source = " ) . append ( sourceTemplate ) ; rs . getLog ( ) . warn ( msg ) ; } } private static String [ ] getArgArray ( Node node , RuntimeServices rsvc ) { int numArgs = node . jjtGetNumChildren ( ) ; numArgs -- ; String argArray [ ] = new String [ numArgs ] ; int i = 0 ; while ( i < numArgs ) { argArray [ i ] = node . jjtGetChild ( i ) . getFirstToken ( ) . image ; if ( i > 0 ) { if ( argArray [ i ] . startsWith ( "$" ) ) { argArray [ i ] = argArray [ i ] . substring ( 1 , argArray [ i ] . length ( ) ) ; } } i ++ ; } if ( debugMode ) { StringBuffer msg = new StringBuffer ( "Macro.getArgArray() : nbrArgs=" ) ; msg . append ( numArgs ) . append ( " : " ) ; macroToString ( msg , argArray ) ; rsvc . getLog ( ) . debug ( msg ) ; } return argArray ; } private static List getASTAsStringArray ( Node rootNode ) { Token t = rootNode . getFirstToken ( ) ; Token tLast = rootNode . getLastToken ( ) ; List list = new ArrayList ( ) ; while ( t != tLast ) { list . add ( NodeUtils . tokenLiteral ( t ) ) ; t = t . next ; } list . add ( NodeUtils . tokenLiteral ( t ) ) ; return list ; } public static final StringBuffer macroToString ( final StringBuffer buf , final String [ ] argArray ) { StringBuffer ret = ( buf == null ) ? new StringBuffer ( ) : buf ; ret . append ( '#' ) . append ( argArray [ 0 ] ) . append ( "( " ) ; for ( int i = 1 ; i < argArray . length ; i ++ ) { ret . append ( ' ' ) . append ( argArray [ i ] ) ; } ret . append ( " )" ) ; return ret ; } } 	1	['10', '2', '0', '13', '39', '43', '2', '11', '7', '0.777777778', '276', '1', '0', '0.466666667', '0.24691358', '0', '0', '26.5', '5', '1.5', '3']
package org . apache . velocity . anakia ; import java . io . IOException ; import java . io . StringWriter ; import java . io . Writer ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Iterator ; import java . util . List ; import java . util . ListIterator ; import org . jdom . Attribute ; import org . jdom . CDATA ; import org . jdom . Comment ; import org . jdom . DocType ; import org . jdom . Document ; import org . jdom . Element ; import org . jdom . EntityRef ; import org . jdom . ProcessingInstruction ; import org . jdom . Text ; import org . jdom . output . XMLOutputter ; public class NodeList implements List , Cloneable { private static final AttributeXMLOutputter DEFAULT_OUTPUTTER = new AttributeXMLOutputter ( ) ; private List nodes ; public NodeList ( ) { nodes = new ArrayList ( ) ; } public NodeList ( Document document ) { this ( ( Object ) document ) ; } public NodeList ( Element element ) { this ( ( Object ) element ) ; } private NodeList ( Object object ) { if ( object == null ) { throw new IllegalArgumentException ( "Cannot construct NodeList with null." ) ; } nodes = new ArrayList ( 1 ) ; nodes . add ( object ) ; } public NodeList ( List nodes ) { this ( nodes , true ) ; } public NodeList ( List nodes , boolean copy ) { if ( nodes == null ) { throw new IllegalArgumentException ( "Cannot initialize NodeList with null list" ) ; } this . nodes = copy ? new ArrayList ( nodes ) : nodes ; } public List getList ( ) { return nodes ; } public String toString ( ) { if ( nodes . isEmpty ( ) ) { return "" ; } StringWriter sw = new StringWriter ( nodes . size ( ) * 128 ) ; try { for ( Iterator i = nodes . iterator ( ) ; i . hasNext ( ) ; ) { Object node = i . next ( ) ; if ( node instanceof Element ) { DEFAULT_OUTPUTTER . output ( ( Element ) node , sw ) ; } else if ( node instanceof Attribute ) { DEFAULT_OUTPUTTER . output ( ( Attribute ) node , sw ) ; } else if ( node instanceof Text ) { DEFAULT_OUTPUTTER . output ( ( Text ) node , sw ) ; } else if ( node instanceof Document ) { DEFAULT_OUTPUTTER . output ( ( Document ) node , sw ) ; } else if ( node instanceof ProcessingInstruction ) { DEFAULT_OUTPUTTER . output ( ( ProcessingInstruction ) node , sw ) ; } else if ( node instanceof Comment ) { DEFAULT_OUTPUTTER . output ( ( Comment ) node , sw ) ; } else if ( node instanceof CDATA ) { DEFAULT_OUTPUTTER . output ( ( CDATA ) node , sw ) ; } else if ( node instanceof DocType ) { DEFAULT_OUTPUTTER . output ( ( DocType ) node , sw ) ; } else if ( node instanceof EntityRef ) { DEFAULT_OUTPUTTER . output ( ( EntityRef ) node , sw ) ; } else { throw new IllegalArgumentException ( "Cannot process a " + ( node == null ? "null node" : "node of class " + node . getClass ( ) . getName ( ) ) ) ; } } } catch ( IOException e ) { throw new Error ( ) ; } return sw . toString ( ) ; } public Object clone ( ) throws CloneNotSupportedException { NodeList clonedList = ( NodeList ) super . clone ( ) ; clonedList . cloneNodes ( ) ; return clonedList ; } private void cloneNodes ( ) throws CloneNotSupportedException { Class listClass = nodes . getClass ( ) ; try { List clonedNodes = ( List ) listClass . newInstance ( ) ; clonedNodes . addAll ( nodes ) ; nodes = clonedNodes ; } catch ( IllegalAccessException e ) { throw new CloneNotSupportedException ( "Cannot clone NodeList since" + " there is no accessible no-arg constructor on class " + listClass . getName ( ) ) ; } catch ( InstantiationException e ) { throw new Error ( ) ; } } public int hashCode ( ) { return nodes . hashCode ( ) ; } public boolean equals ( Object o ) { return o instanceof NodeList ? ( ( NodeList ) o ) . nodes . equals ( nodes ) : false ; } public NodeList selectNodes ( String xpathString ) { return new NodeList ( XPathCache . getXPath ( xpathString ) . applyTo ( nodes ) , false ) ; } public boolean add ( Object o ) { return nodes . add ( o ) ; } public void add ( int index , Object o ) { nodes . add ( index , o ) ; } public boolean addAll ( Collection c ) { return nodes . addAll ( c ) ; } public boolean addAll ( int index , Collection c ) { return nodes . addAll ( index , c ) ; } public void clear ( ) { nodes . clear ( ) ; } public boolean contains ( Object o ) { return nodes . contains ( o ) ; } public boolean containsAll ( Collection c ) { return nodes . containsAll ( c ) ; } public Object get ( int index ) { return nodes . get ( index ) ; } public int indexOf ( Object o ) { return nodes . indexOf ( o ) ; } public boolean isEmpty ( ) { return nodes . isEmpty ( ) ; } public Iterator iterator ( ) { return nodes . iterator ( ) ; } public int lastIndexOf ( Object o ) { return nodes . lastIndexOf ( o ) ; } public ListIterator listIterator ( ) { return nodes . listIterator ( ) ; } public ListIterator listIterator ( int index ) { return nodes . listIterator ( index ) ; } public Object remove ( int index ) { return nodes . remove ( index ) ; } public boolean remove ( Object o ) { return nodes . remove ( o ) ; } public boolean removeAll ( Collection c ) { return nodes . removeAll ( c ) ; } public boolean retainAll ( Collection c ) { return nodes . retainAll ( c ) ; } public Object set ( int index , Object o ) { return nodes . set ( index , o ) ; } public int size ( ) { return nodes . size ( ) ; } public List subList ( int fromIndex , int toIndex ) { return new NodeList ( nodes . subList ( fromIndex , toIndex ) ) ; } public Object [ ] toArray ( ) { return nodes . toArray ( ) ; } public Object [ ] toArray ( Object [ ] a ) { return nodes . toArray ( a ) ; } private static final class AttributeXMLOutputter extends XMLOutputter { public void output ( Attribute attribute , Writer out ) throws IOException { out . write ( " " ) ; out . write ( attribute . getQualifiedName ( ) ) ; out . write ( "=" ) ; out . write ( "\"" ) ; out . write ( escapeAttributeEntities ( attribute . getValue ( ) ) ) ; out . write ( "\"" ) ; } } } 	0	['37', '1', '0', '16', '92', '0', '3', '13', '34', '0.5', '438', '1', '1', '0', '0.177777778', '1', '1', '10.78378378', '12', '1.1351', '0']
package org . apache . velocity . app . event . implement ; import org . apache . velocity . util . introspection . Info ; public class InvalidReferenceInfo extends Info { private String invalidReference ; public InvalidReferenceInfo ( String invalidReference , Info info ) { super ( info . getTemplateName ( ) , info . getLine ( ) , info . getColumn ( ) ) ; this . invalidReference = invalidReference ; } public String getInvalidReference ( ) { return invalidReference ; } public String toString ( ) { return getTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]: " + invalidReference ; } } 	1	['3', '2', '0', '2', '14', '0', '1', '1', '3', '0', '42', '1', '0', '0.666666667', '0.555555556', '0', '0', '12.66666667', '1', '0.6667', '1']
package org . apache . velocity . util . introspection ; import java . util . Iterator ; public interface Uberspect { public void init ( ) throws Exception ; public Iterator getIterator ( Object obj , Info info ) throws Exception ; public VelMethod getMethod ( Object obj , String method , Object [ ] args , Info info ) throws Exception ; public VelPropertyGet getPropertyGet ( Object obj , String identifier , Info info ) throws Exception ; public VelPropertySet getPropertySet ( Object obj , String identifier , Object arg , Info info ) throws Exception ; } 	0	['5', '1', '0', '12', '5', '10', '8', '4', '5', '2', '5', '0', '0', '0', '0.68', '0', '0', '0', '1', '1', '0']
package org . apache . velocity . util ; import org . apache . velocity . context . Context ; public interface ContextAware { public void setContext ( Context context ) ; } 	1	['1', '1', '0', '5', '1', '0', '4', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . velocity . runtime . log ; import java . util . Date ; import org . apache . log . format . PatternFormatter ; public class VelocityFormatter extends PatternFormatter { public VelocityFormatter ( String format ) { super ( format ) ; } protected String getTime ( final long time , final String format ) { return new Date ( ) . toString ( ) ; } } 	0	['2', '2', '0', '2', '5', '1', '1', '1', '1', '2', '11', '0', '0', '0.941176471', '0.833333333', '1', '2', '4.5', '1', '0.5', '0']
package org . apache . velocity . util . introspection ; import java . lang . reflect . Method ; import org . apache . velocity . runtime . log . Log ; public class SecureIntrospectorImpl extends Introspector implements SecureIntrospectorControl { private String [ ] badClasses ; private String [ ] badPackages ; public SecureIntrospectorImpl ( String [ ] badClasses , String [ ] badPackages , Log log ) { super ( log ) ; this . badClasses = badClasses ; this . badPackages = badPackages ; } public Method getMethod ( Class clazz , String methodName , Object [ ] params ) throws IllegalArgumentException { if ( ! checkObjectExecutePermission ( clazz , methodName ) ) { log . warn ( "Cannot retrieve method " + methodName + " from object of class " + clazz . getName ( ) + " due to security restrictions." ) ; return null ; } else { return super . getMethod ( clazz , methodName , params ) ; } } public boolean checkObjectExecutePermission ( Class clazz , String methodName ) { if ( ( methodName != null ) && ( methodName . equals ( "wait" ) || methodName . equals ( "notify" ) ) ) { return false ; } else if ( java . lang . Number . class . isAssignableFrom ( clazz ) ) { return true ; } else if ( java . lang . Boolean . class . isAssignableFrom ( clazz ) ) { return true ; } else if ( java . lang . String . class . isAssignableFrom ( clazz ) ) { return true ; } else if ( java . lang . Class . class . isAssignableFrom ( clazz ) && ( methodName != null ) && methodName . equals ( "getName" ) ) { return true ; } String className = clazz . getName ( ) ; if ( className . startsWith ( "[L" ) && className . endsWith ( ";" ) ) { className = className . substring ( 2 , className . length ( ) - 1 ) ; } String packageName ; int dotPos = className . lastIndexOf ( '.' ) ; packageName = ( dotPos == - 1 ) ? "" : className . substring ( 0 , dotPos ) ; int sz = badPackages . length ; for ( int i = 0 ; i < sz ; i ++ ) { if ( packageName . equals ( badPackages [ i ] ) ) { return false ; } } sz = badClasses . length ; for ( int i = 0 ; i < sz ; i ++ ) { if ( className . equals ( badClasses [ i ] ) ) { return false ; } } return true ; } } 	1	['4', '3', '0', '4', '21', '4', '1', '3', '3', '0.555555556', '206', '0.333333333', '0', '0.769230769', '0.458333333', '1', '1', '49', '21', '5.75', '2']
package org . apache . velocity . util . introspection ; public interface VelPropertySet { public Object invoke ( Object o , Object arg ) throws Exception ; public boolean isCacheable ( ) ; public String getMethodName ( ) ; } 	0	['3', '1', '0', '4', '3', '3', '4', '0', '3', '2', '3', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . velocity . runtime . resource . util ; public interface StringResourceRepository { StringResource getStringResource ( String name ) ; void putStringResource ( String name , String body ) ; void removeStringResource ( String name ) ; void setEncoding ( String encoding ) ; String getEncoding ( ) ; } 	1	['5', '1', '0', '4', '5', '10', '3', '1', '5', '2', '5', '0', '0', '0', '0.9', '0', '0', '0', '1', '1', '2']
package org . apache . velocity . anakia ; import java . io . IOException ; import java . io . StringWriter ; import org . jdom . Element ; import org . jdom . output . XMLOutputter ; import org . jdom . output . Format ; public class OutputWrapper extends XMLOutputter { public OutputWrapper ( ) { } public OutputWrapper ( Format f ) { super ( f ) ; } public String outputString ( Element element , boolean strip ) { StringWriter buff = new StringWriter ( ) ; try { outputElementContent ( element , buff ) ; } catch ( IOException e ) { } return buff . toString ( ) ; } } 	0	['3', '2', '0', '4', '8', '3', '1', '3', '3', '2', '23', '0', '0', '0.984615385', '0.5', '1', '1', '6.666666667', '1', '0.3333', '0']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; import org . apache . velocity . util . TemplateNumber ; public class ASTModNode extends SimpleNode { public ASTModNode ( int id ) { super ( id ) ; } public ASTModNode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { Object left = jjtGetChild ( 0 ) . value ( context ) ; Object right = jjtGetChild ( 1 ) . value ( context ) ; if ( left == null || right == null ) { log . error ( ( left == null ? "Left" : "Right" ) + " side (" + jjtGetChild ( ( left == null ? 0 : 1 ) ) . literal ( ) + ") of modulus operation has null value." + " Operation not possible. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return null ; } if ( left instanceof TemplateNumber ) { left = ( ( TemplateNumber ) left ) . getAsNumber ( ) ; } if ( right instanceof TemplateNumber ) { right = ( ( TemplateNumber ) right ) . getAsNumber ( ) ; } if ( ! ( left instanceof Number ) || ! ( right instanceof Number ) ) { log . error ( ( ! ( left instanceof Number ) ? "Left" : "Right" ) + " side " + " of modulus operation is not a Number. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return null ; } if ( MathUtils . isZero ( ( Number ) right ) ) { log . error ( "Right side of modulus operation is zero. Must be non-zero. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return null ; } return MathUtils . modulo ( ( Number ) left , ( Number ) right ) ; } } 	1	['4', '2', '0', '11', '21', '6', '4', '9', '4', '2', '170', '0', '0', '0.933333333', '0.416666667', '1', '1', '41.5', '1', '0.5', '1']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; import org . apache . velocity . exception . MethodInvocationException ; public class ASTAndNode extends SimpleNode { public ASTAndNode ( int id ) { super ( id ) ; } public ASTAndNode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { return new Boolean ( evaluate ( context ) ) ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { Node left = jjtGetChild ( 0 ) ; Node right = jjtGetChild ( 1 ) ; if ( left == null || right == null ) { log . error ( ( left == null ? "Left" : "Right" ) + " side of '&&' operation is null." + " Operation not possible. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return false ; } if ( left . evaluate ( context ) ) { if ( right . evaluate ( context ) ) { return true ; } } return false ; } } 	0	['5', '2', '0', '9', '19', '10', '4', '7', '5', '2', '84', '0', '0', '0.903225806', '0.4', '1', '1', '15.8', '1', '0.6', '0']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . util . TemplateNumber ; public class ASTLTNode extends SimpleNode { public ASTLTNode ( int id ) { super ( id ) ; } public ASTLTNode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { Object left = jjtGetChild ( 0 ) . value ( context ) ; Object right = jjtGetChild ( 1 ) . value ( context ) ; if ( left == null || right == null ) { log . error ( ( left == null ? "Left" : "Right" ) + " side (" + jjtGetChild ( ( left == null ? 0 : 1 ) ) . literal ( ) + ") of '<' operation has null value." + " Operation not possible. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return false ; } if ( left instanceof TemplateNumber ) { left = ( ( TemplateNumber ) left ) . getAsNumber ( ) ; } if ( right instanceof TemplateNumber ) { right = ( ( TemplateNumber ) right ) . getAsNumber ( ) ; } if ( ! ( left instanceof Number ) || ! ( right instanceof Number ) ) { log . error ( ( ! ( left instanceof Number ) ? "Left" : "Right" ) + " side of '>=' operation is not a valid Number. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return false ; } return MathUtils . compare ( ( Number ) left , ( Number ) right ) == - 1 ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { boolean val = evaluate ( context ) ; return val ? Boolean . TRUE : Boolean . FALSE ; } } 	1	['5', '2', '0', '11', '21', '10', '4', '9', '5', '2', '154', '0', '0', '0.903225806', '0.4', '1', '1', '29.8', '1', '0.6', '1']
package org . apache . velocity . runtime . parser ; import org . apache . velocity . runtime . parser . node . ASTAddNode ; import org . apache . velocity . runtime . parser . node . ASTAndNode ; import org . apache . velocity . runtime . parser . node . ASTAssignment ; import org . apache . velocity . runtime . parser . node . ASTBlock ; import org . apache . velocity . runtime . parser . node . ASTComment ; import org . apache . velocity . runtime . parser . node . ASTDirective ; import org . apache . velocity . runtime . parser . node . ASTDivNode ; import org . apache . velocity . runtime . parser . node . ASTEQNode ; import org . apache . velocity . runtime . parser . node . ASTElseIfStatement ; import org . apache . velocity . runtime . parser . node . ASTElseStatement ; import org . apache . velocity . runtime . parser . node . ASTEscape ; import org . apache . velocity . runtime . parser . node . ASTEscapedDirective ; import org . apache . velocity . runtime . parser . node . ASTExpression ; import org . apache . velocity . runtime . parser . node . ASTFalse ; import org . apache . velocity . runtime . parser . node . ASTFloatingPointLiteral ; import org . apache . velocity . runtime . parser . node . ASTGENode ; import org . apache . velocity . runtime . parser . node . ASTGTNode ; import org . apache . velocity . runtime . parser . node . ASTIdentifier ; import org . apache . velocity . runtime . parser . node . ASTIfStatement ; import org . apache . velocity . runtime . parser . node . ASTIntegerLiteral ; import org . apache . velocity . runtime . parser . node . ASTIntegerRange ; import org . apache . velocity . runtime . parser . node . ASTLENode ; import org . apache . velocity . runtime . parser . node . ASTLTNode ; import org . apache . velocity . runtime . parser . node . ASTMap ; import org . apache . velocity . runtime . parser . node . ASTMethod ; import org . apache . velocity . runtime . parser . node . ASTModNode ; import org . apache . velocity . runtime . parser . node . ASTMulNode ; import org . apache . velocity . runtime . parser . node . ASTNENode ; import org . apache . velocity . runtime . parser . node . ASTNotNode ; import org . apache . velocity . runtime . parser . node . ASTObjectArray ; import org . apache . velocity . runtime . parser . node . ASTOrNode ; import org . apache . velocity . runtime . parser . node . ASTReference ; import org . apache . velocity . runtime . parser . node . ASTSetDirective ; import org . apache . velocity . runtime . parser . node . ASTStop ; import org . apache . velocity . runtime . parser . node . ASTStringLiteral ; import org . apache . velocity . runtime . parser . node . ASTSubtractNode ; import org . apache . velocity . runtime . parser . node . ASTText ; import org . apache . velocity . runtime . parser . node . ASTTrue ; import org . apache . velocity . runtime . parser . node . ASTWord ; import org . apache . velocity . runtime . parser . node . ASTprocess ; import org . apache . velocity . runtime . parser . node . SimpleNode ; public interface ParserVisitor { public Object visit ( SimpleNode node , Object data ) ; public Object visit ( ASTprocess node , Object data ) ; public Object visit ( ASTEscapedDirective node , Object data ) ; public Object visit ( ASTEscape node , Object data ) ; public Object visit ( ASTComment node , Object data ) ; public Object visit ( ASTFloatingPointLiteral node , Object data ) ; public Object visit ( ASTIntegerLiteral node , Object data ) ; public Object visit ( ASTStringLiteral node , Object data ) ; public Object visit ( ASTIdentifier node , Object data ) ; public Object visit ( ASTWord node , Object data ) ; public Object visit ( ASTDirective node , Object data ) ; public Object visit ( ASTBlock node , Object data ) ; public Object visit ( ASTMap node , Object data ) ; public Object visit ( ASTObjectArray node , Object data ) ; public Object visit ( ASTIntegerRange node , Object data ) ; public Object visit ( ASTMethod node , Object data ) ; public Object visit ( ASTReference node , Object data ) ; public Object visit ( ASTTrue node , Object data ) ; public Object visit ( ASTFalse node , Object data ) ; public Object visit ( ASTText node , Object data ) ; public Object visit ( ASTIfStatement node , Object data ) ; public Object visit ( ASTElseStatement node , Object data ) ; public Object visit ( ASTElseIfStatement node , Object data ) ; public Object visit ( ASTSetDirective node , Object data ) ; public Object visit ( ASTStop node , Object data ) ; public Object visit ( ASTExpression node , Object data ) ; public Object visit ( ASTAssignment node , Object data ) ; public Object visit ( ASTOrNode node , Object data ) ; public Object visit ( ASTAndNode node , Object data ) ; public Object visit ( ASTEQNode node , Object data ) ; public Object visit ( ASTNENode node , Object data ) ; public Object visit ( ASTLTNode node , Object data ) ; public Object visit ( ASTGTNode node , Object data ) ; public Object visit ( ASTLENode node , Object data ) ; public Object visit ( ASTGENode node , Object data ) ; public Object visit ( ASTAddNode node , Object data ) ; public Object visit ( ASTSubtractNode node , Object data ) ; public Object visit ( ASTMulNode node , Object data ) ; public Object visit ( ASTDivNode node , Object data ) ; public Object visit ( ASTModNode node , Object data ) ; public Object visit ( ASTNotNode node , Object data ) ; } 	0	['41', '1', '0', '49', '41', '820', '49', '41', '41', '2', '41', '0', '0', '0', '0.069767442', '0', '0', '0', '1', '1', '0']
package org . apache . velocity . app . event . implement ; import org . apache . commons . lang . StringEscapeUtils ; public class EscapeSqlReference extends EscapeReference { protected String escape ( Object text ) { return StringEscapeUtils . escapeSql ( text . toString ( ) ) ; } protected String getMatchAttribute ( ) { return "eventhandler.escape.sql.match" ; } } 	1	['3', '2', '0', '2', '6', '3', '0', '2', '1', '2', '12', '0', '0', '0.714285714', '0.666666667', '1', '2', '3', '1', '0.6667', '1']
package org . apache . velocity . context ; public interface Context { Object put ( String key , Object value ) ; Object get ( String key ) ; boolean containsKey ( Object key ) ; Object [ ] getKeys ( ) ; Object remove ( Object key ) ; } 	0	['5', '1', '0', '30', '5', '10', '30', '0', '5', '2', '5', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . velocity . runtime . parser . node ; import java . io . IOException ; import java . io . Writer ; import org . apache . commons . lang . builder . ToStringBuilder ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; import org . apache . velocity . runtime . parser . Token ; public class SimpleNode implements Node { protected RuntimeServices rsvc = null ; protected Log log = null ; protected Node parent ; protected Node [ ] children ; protected int id ; protected Parser parser ; protected int info ; public boolean state ; protected boolean invalid = false ; protected Token first ; protected Token last ; public SimpleNode ( int i ) { id = i ; } public SimpleNode ( Parser p , int i ) { this ( i ) ; parser = p ; } public void jjtOpen ( ) { first = parser . getToken ( 1 ) ; } public void jjtClose ( ) { last = parser . getToken ( 0 ) ; } public void setFirstToken ( Token t ) { this . first = t ; } public Token getFirstToken ( ) { return first ; } public Token getLastToken ( ) { return last ; } public void jjtSetParent ( Node n ) { parent = n ; } public Node jjtGetParent ( ) { return parent ; } public void jjtAddChild ( Node n , int i ) { if ( children == null ) { children = new Node [ i + 1 ] ; } else if ( i >= children . length ) { Node c [ ] = new Node [ i + 1 ] ; System . arraycopy ( children , 0 , c , 0 , children . length ) ; children = c ; } children [ i ] = n ; } public Node jjtGetChild ( int i ) { return children [ i ] ; } public int jjtGetNumChildren ( ) { return ( children == null ) ? 0 : children . length ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object childrenAccept ( ParserVisitor visitor , Object data ) { if ( children != null ) { for ( int i = 0 ; i < children . length ; ++ i ) { children [ i ] . jjtAccept ( visitor , data ) ; } } return data ; } public String toString ( String prefix ) { return prefix + toString ( ) ; } public void dump ( String prefix ) { System . out . println ( toString ( prefix ) ) ; if ( children != null ) { for ( int i = 0 ; i < children . length ; ++ i ) { SimpleNode n = ( SimpleNode ) children [ i ] ; if ( n != null ) { n . dump ( prefix + " " ) ; } } } } public String literal ( ) { Token t = first ; StringBuffer sb = new StringBuffer ( t . image ) ; while ( t != last ) { t = t . next ; sb . append ( t . image ) ; } return sb . toString ( ) ; } public Object init ( InternalContextAdapter context , Object data ) throws TemplateInitException { rsvc = ( RuntimeServices ) data ; log = rsvc . getLog ( ) ; int i , k = jjtGetNumChildren ( ) ; for ( i = 0 ; i < k ; i ++ ) { jjtGetChild ( i ) . init ( context , data ) ; } return data ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { return false ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { return null ; } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException , ParseErrorException , ResourceNotFoundException { int i , k = jjtGetNumChildren ( ) ; for ( i = 0 ; i < k ; i ++ ) jjtGetChild ( i ) . render ( context , writer ) ; return true ; } public Object execute ( Object o , InternalContextAdapter context ) throws MethodInvocationException { return null ; } public int getType ( ) { return id ; } public void setInfo ( int info ) { this . info = info ; } public int getInfo ( ) { return info ; } public void setInvalid ( ) { invalid = true ; } public boolean isInvalid ( ) { return invalid ; } public int getLine ( ) { return first . beginLine ; } public int getColumn ( ) { return first . beginColumn ; } public String toString ( ) { StringBuffer tokens = new StringBuffer ( ) ; for ( Token t = getFirstToken ( ) ; t != null ; ) { tokens . append ( "[" ) . append ( t . image ) . append ( "]" ) ; if ( t . next != null ) { if ( t . equals ( getLastToken ( ) ) ) { break ; } else { tokens . append ( ", " ) ; } } t = t . next ; } return new ToStringBuilder ( this ) . append ( "id" , getType ( ) ) . append ( "info" , getInfo ( ) ) . append ( "invalid" , isInvalid ( ) ) . append ( "children" , jjtGetNumChildren ( ) ) . append ( "tokens" , tokens ) . toString ( ) ; } } 	1	['30', '1', '43', '68', '49', '359', '59', '12', '30', '0.902821317', '382', '0.909090909', '7', '0', '0.176666667', '1', '1', '11.36666667', '4', '1.3333', '5']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; public class ASTVariable extends SimpleNode { public ASTVariable ( int id ) { super ( id ) ; } public ASTVariable ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } } 	0	['3', '2', '0', '3', '6', '3', '0', '3', '3', '2', '17', '0', '0', '0.965517241', '0.533333333', '0', '0', '4.666666667', '1', '0.3333', '0']
package org . apache . velocity . util ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; public class ExceptionUtils { private static boolean causesAllowed = true ; public static RuntimeException createRuntimeException ( String message , Throwable cause ) { return ( RuntimeException ) createWithCause ( RuntimeException . class , message , cause ) ; } public static Throwable createWithCause ( Class clazz , String message , Throwable cause ) { Throwable re = null ; if ( causesAllowed ) { try { Constructor constructor = clazz . getConstructor ( new Class [ ] { String . class , Throwable . class } ) ; re = ( Throwable ) constructor . newInstance ( new Object [ ] { message , cause } ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { causesAllowed = false ; } } if ( re == null ) { try { Constructor constructor = clazz . getConstructor ( new Class [ ] { String . class } ) ; re = ( Throwable ) constructor . newInstance ( new Object [ ] { message + " caused by " + cause } ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { throw new RuntimeException ( "Error caused " + e ) ; } } return re ; } public static void setCause ( Throwable onObject , Throwable cause ) { if ( causesAllowed ) { try { Method method = onObject . getClass ( ) . getMethod ( "initCause" , new Class [ ] { Throwable . class } ) ; method . invoke ( onObject , new Object [ ] { cause } ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { causesAllowed = false ; } } } } 	1	['6', '1', '0', '7', '20', '9', '7', '0', '4', '0.7', '185', '0.25', '0', '0', '0.4', '0', '0', '29.16666667', '6', '2', '1']
package org . apache . velocity . texen ; import java . io . File ; import java . io . InputStream ; import java . io . FileInputStream ; import java . io . BufferedInputStream ; import java . io . Writer ; import java . io . FileWriter ; import java . io . IOException ; import java . io . StringWriter ; import java . io . OutputStreamWriter ; import java . io . BufferedWriter ; import java . io . FileOutputStream ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . Properties ; import org . apache . velocity . Template ; import org . apache . velocity . context . Context ; import org . apache . velocity . VelocityContext ; import org . apache . velocity . app . VelocityEngine ; import org . apache . velocity . util . ClassUtils ; public class Generator { public static final String OUTPUT_PATH = "output.path" ; public static final String TEMPLATE_PATH = "template.path" ; private static final String DEFAULT_TEXEN_PROPERTIES = "org/apache/velocity/texen/defaults/texen.properties" ; private Properties props = new Properties ( ) ; private Context controlContext ; private Hashtable writers = new Hashtable ( ) ; private static Generator instance = new Generator ( ) ; protected String outputEncoding ; protected String inputEncoding ; protected VelocityEngine ve ; private Generator ( ) { setDefaultProps ( ) ; } public static Generator getInstance ( ) { return instance ; } public void setVelocityEngine ( VelocityEngine ve ) { this . ve = ve ; } public Generator ( String propFile ) { try { BufferedInputStream bi = null ; try { bi = new BufferedInputStream ( new FileInputStream ( propFile ) ) ; props . load ( bi ) ; } finally { if ( bi != null ) { bi . close ( ) ; } } } catch ( IOException e ) { System . err . println ( "Could not load " + propFile + ", falling back to defaults. (" + e . getMessage ( ) + ")" ) ; setDefaultProps ( ) ; } } public Generator ( Properties props ) { this . props = ( Properties ) props . clone ( ) ; } protected void setDefaultProps ( ) { ClassLoader classLoader = VelocityEngine . class . getClassLoader ( ) ; try { InputStream inputStream = null ; try { inputStream = classLoader . getResourceAsStream ( DEFAULT_TEXEN_PROPERTIES ) ; props . load ( inputStream ) ; } finally { if ( inputStream != null ) { inputStream . close ( ) ; } } } catch ( IOException ioe ) { System . err . println ( "Cannot get default properties: " + ioe . getMessage ( ) ) ; } } public void setTemplatePath ( String templatePath ) { props . put ( TEMPLATE_PATH , templatePath ) ; } public String getTemplatePath ( ) { return props . getProperty ( TEMPLATE_PATH ) ; } public void setOutputPath ( String outputPath ) { props . put ( OUTPUT_PATH , outputPath ) ; } public String getOutputPath ( ) { return props . getProperty ( OUTPUT_PATH ) ; } public void setOutputEncoding ( String outputEncoding ) { this . outputEncoding = outputEncoding ; } public void setInputEncoding ( String inputEncoding ) { this . inputEncoding = inputEncoding ; } public Writer getWriter ( String path , String encoding ) throws Exception { Writer writer ; if ( encoding == null || encoding . length ( ) == 0 || encoding . equals ( "8859-1" ) || encoding . equals ( "8859_1" ) ) { writer = new FileWriter ( path ) ; } else { writer = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( path ) , encoding ) ) ; } return writer ; } public Template getTemplate ( String templateName , String encoding ) throws Exception { Template template ; if ( encoding == null || encoding . length ( ) == 0 || encoding . equals ( "8859-1" ) || encoding . equals ( "8859_1" ) ) { template = ve . getTemplate ( templateName ) ; } else { template = ve . getTemplate ( templateName , encoding ) ; } return template ; } public String parse ( String inputTemplate , String outputFile ) throws Exception { return parse ( inputTemplate , outputFile , null , null ) ; } public String parse ( String inputTemplate , String outputFile , String objectID , Object object ) throws Exception { return parse ( inputTemplate , null , outputFile , null , objectID , object ) ; } public String parse ( String inputTemplate , String inputEncoding , String outputFile , String outputEncoding , String objectID , Object object ) throws Exception { if ( objectID != null && object != null ) { controlContext . put ( objectID , object ) ; } Template template = getTemplate ( inputTemplate , inputEncoding != null ? inputEncoding : this . inputEncoding ) ; if ( outputFile == null || outputFile . equals ( "" ) ) { StringWriter sw = new StringWriter ( ) ; template . merge ( controlContext , sw ) ; return sw . toString ( ) ; } else { Writer writer = null ; if ( writers . get ( outputFile ) == null ) { writer = getWriter ( getOutputPath ( ) + File . separator + outputFile , outputEncoding != null ? outputEncoding : this . outputEncoding ) ; writers . put ( outputFile , writer ) ; } else { writer = ( Writer ) writers . get ( outputFile ) ; } VelocityContext vc = new VelocityContext ( controlContext ) ; template . merge ( vc , writer ) ; return "" ; } } public String parse ( String controlTemplate , Context controlContext ) throws Exception { this . controlContext = controlContext ; fillContextDefaults ( this . controlContext ) ; fillContextProperties ( this . controlContext ) ; Template template = getTemplate ( controlTemplate , inputEncoding ) ; StringWriter sw = new StringWriter ( ) ; template . merge ( controlContext , sw ) ; return sw . toString ( ) ; } protected Context getContext ( Hashtable objs ) { fillContextHash ( controlContext , objs ) ; return controlContext ; } protected void fillContextHash ( Context context , Hashtable objs ) { Enumeration enumeration = objs . keys ( ) ; while ( enumeration . hasMoreElements ( ) ) { String key = enumeration . nextElement ( ) . toString ( ) ; context . put ( key , objs . get ( key ) ) ; } } protected void fillContextDefaults ( Context context ) { context . put ( "generator" , instance ) ; context . put ( "outputDirectory" , getOutputPath ( ) ) ; } protected void fillContextProperties ( Context context ) { Enumeration enumeration = props . propertyNames ( ) ; while ( enumeration . hasMoreElements ( ) ) { String nm = ( String ) enumeration . nextElement ( ) ; if ( nm . startsWith ( "context.objects." ) ) { String contextObj = props . getProperty ( nm ) ; int colon = nm . lastIndexOf ( '.' ) ; String contextName = nm . substring ( colon + 1 ) ; try { Object o = ClassUtils . getNewInstance ( contextObj ) ; context . put ( contextName , o ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } public void shutdown ( ) { Iterator iterator = writers . values ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Writer writer = ( Writer ) iterator . next ( ) ; try { writer . flush ( ) ; } catch ( IOException e ) { } try { writer . close ( ) ; } catch ( IOException e ) { } } writers . clear ( ) ; } } 	0	['25', '1', '0', '7', '78', '194', '2', '5', '17', '0.878787879', '530', '0.727272727', '3', '0', '0.261904762', '0', '0', '19.76', '3', '1.04', '0']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . util . TemplateNumber ; public class ASTLENode extends SimpleNode { public ASTLENode ( int id ) { super ( id ) ; } public ASTLENode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { Object left = jjtGetChild ( 0 ) . value ( context ) ; Object right = jjtGetChild ( 1 ) . value ( context ) ; if ( left == null || right == null ) { log . error ( ( left == null ? "Left" : "Right" ) + " side (" + jjtGetChild ( ( left == null ? 0 : 1 ) ) . literal ( ) + ") of '<=' operation has null value." + " Operation not possible. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return false ; } if ( left instanceof TemplateNumber ) { left = ( ( TemplateNumber ) left ) . getAsNumber ( ) ; } if ( right instanceof TemplateNumber ) { right = ( ( TemplateNumber ) right ) . getAsNumber ( ) ; } if ( ! ( left instanceof Number ) || ! ( right instanceof Number ) ) { log . error ( ( ! ( left instanceof Number ) ? "Left" : "Right" ) + " side of '>=' operation is not a Number. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return false ; } return MathUtils . compare ( ( Number ) left , ( Number ) right ) <= 0 ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { boolean val = evaluate ( context ) ; return val ? Boolean . TRUE : Boolean . FALSE ; } } 	1	['5', '2', '0', '11', '21', '10', '4', '9', '5', '2', '153', '0', '0', '0.903225806', '0.4', '1', '1', '29.6', '1', '0.6', '1']
package org . apache . velocity . util ; import java . util . Iterator ; import java . util . NoSuchElementException ; import java . lang . reflect . Array ; public class ArrayIterator implements Iterator { private Object array ; private int pos ; private int size ; public ArrayIterator ( Object array ) { if ( ! array . getClass ( ) . isArray ( ) ) { throw new IllegalArgumentException ( "Programmer error : internal ArrayIterator invoked w/o array" ) ; } this . array = array ; pos = 0 ; size = Array . getLength ( this . array ) ; } public Object next ( ) { if ( pos < size ) return Array . get ( array , pos ++ ) ; throw new NoSuchElementException ( "No more elements: " + pos + " / " + size ) ; } public boolean hasNext ( ) { return ( pos < size ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } 	0	['4', '1', '0', '1', '16', '0', '1', '0', '4', '0.444444444', '77', '1', '0', '0', '0.625', '0', '0', '17.5', '2', '1.25', '0']
package org . apache . velocity . runtime . resource . loader ; import java . io . BufferedInputStream ; import java . io . InputStream ; import java . sql . Connection ; import java . sql . PreparedStatement ; import java . sql . ResultSet ; import java . sql . SQLException ; import java . sql . Timestamp ; import javax . naming . InitialContext ; import javax . naming . NamingException ; import javax . sql . DataSource ; import org . apache . commons . collections . ExtendedProperties ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . runtime . resource . Resource ; import org . apache . velocity . util . ExceptionUtils ; import org . apache . velocity . util . StringUtils ; public class DataSourceResourceLoader extends ResourceLoader { private String dataSourceName ; private String tableName ; private String keyColumn ; private String templateColumn ; private String timestampColumn ; private InitialContext ctx ; private DataSource dataSource ; public void init ( ExtendedProperties configuration ) { dataSourceName = StringUtils . nullTrim ( configuration . getString ( "resource.datasource" ) ) ; tableName = StringUtils . nullTrim ( configuration . getString ( "resource.table" ) ) ; keyColumn = StringUtils . nullTrim ( configuration . getString ( "resource.keycolumn" ) ) ; templateColumn = StringUtils . nullTrim ( configuration . getString ( "resource.templatecolumn" ) ) ; timestampColumn = StringUtils . nullTrim ( configuration . getString ( "resource.timestampcolumn" ) ) ; if ( dataSource != null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "DataSourceResourceLoader: using dataSource instance with table \"" + tableName + "\"" ) ; log . debug ( "DataSourceResourceLoader: using columns \"" + keyColumn + "\", \"" + templateColumn + "\" and \"" + timestampColumn + "\"" ) ; } log . trace ( "DataSourceResourceLoader initialized." ) ; } else if ( dataSourceName != null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "DataSourceResourceLoader: using \"" + dataSourceName + "\" datasource with table \"" + tableName + "\"" ) ; log . debug ( "DataSourceResourceLoader: using columns \"" + keyColumn + "\", \"" + templateColumn + "\" and \"" + timestampColumn + "\"" ) ; } log . trace ( "DataSourceResourceLoader initialized." ) ; } else { log . warn ( "DataSourceResourceLoader not properly initialized. No DataSource was identified." ) ; } } public void setDataSource ( final DataSource dataSource ) { this . dataSource = dataSource ; } public boolean isSourceModified ( final Resource resource ) { return ( resource . getLastModified ( ) != readLastModified ( resource , "checking timestamp" ) ) ; } public long getLastModified ( final Resource resource ) { return readLastModified ( resource , "getting timestamp" ) ; } public synchronized InputStream getResourceStream ( final String name ) throws ResourceNotFoundException { if ( org . apache . commons . lang . StringUtils . isEmpty ( name ) ) { throw new ResourceNotFoundException ( "DataSourceResourceLoader: " + "Template name was empty or null" ) ; } Connection conn = null ; ResultSet rs = null ; try { conn = openDbConnection ( ) ; rs = readData ( conn , templateColumn , name ) ; if ( rs . next ( ) ) { InputStream ascStream = rs . getAsciiStream ( templateColumn ) ; if ( ascStream == null ) { throw new ResourceNotFoundException ( "DataSourceResourceLoader: " + "template column for '" + name + "' is null" ) ; } return new BufferedInputStream ( ascStream ) ; } else { throw new ResourceNotFoundException ( "DataSourceResourceLoader: " + "could not find resource '" + name + "'" ) ; } } catch ( SQLException sqle ) { String msg = "DataSourceResourceLoader: database problem while getting resource '" + name + "': " ; log . error ( msg , sqle ) ; throw new ResourceNotFoundException ( msg ) ; } catch ( NamingException ne ) { String msg = "DataSourceResourceLoader: database problem while getting resource '" + name + "': " ; log . error ( msg , ne ) ; throw new ResourceNotFoundException ( msg ) ; } finally { closeResultSet ( rs ) ; closeDbConnection ( conn ) ; } } private long readLastModified ( final Resource resource , final String operation ) { long timeStamp = 0 ; String name = resource . getName ( ) ; if ( name == null || name . length ( ) == 0 ) { log . error ( "DataSourceResourceLoader: " + "Template name was empty or null" ) ; } else { Connection conn = null ; ResultSet rs = null ; try { conn = openDbConnection ( ) ; rs = readData ( conn , timestampColumn , name ) ; if ( rs . next ( ) ) { Timestamp ts = rs . getTimestamp ( timestampColumn ) ; timeStamp = ts != null ? ts . getTime ( ) : 0 ; } else { log . error ( "DataSourceResourceLoader: could not find resource " + name + " while " + operation ) ; } } catch ( SQLException sqle ) { String msg = "DataSourceResourceLoader: database problem while " + operation + " of '" + name + "': " ; log . error ( msg , sqle ) ; throw ExceptionUtils . createRuntimeException ( msg , sqle ) ; } catch ( NamingException ne ) { String msg = "DataSourceResourceLoader: database problem while " + operation + " of '" + name + "': " ; log . error ( msg , ne ) ; throw ExceptionUtils . createRuntimeException ( msg , ne ) ; } finally { closeResultSet ( rs ) ; closeDbConnection ( conn ) ; } } return timeStamp ; } private Connection openDbConnection ( ) throws NamingException , SQLException { if ( dataSource != null ) { return dataSource . getConnection ( ) ; } if ( ctx == null ) { ctx = new InitialContext ( ) ; } dataSource = ( DataSource ) ctx . lookup ( dataSourceName ) ; return dataSource . getConnection ( ) ; } private void closeDbConnection ( final Connection conn ) { if ( conn != null ) { try { conn . close ( ) ; } catch ( RuntimeException re ) { throw re ; } catch ( Exception e ) { log . warn ( "DataSourceResourceLoader: problem when closing connection" , e ) ; } } } private void closeResultSet ( final ResultSet rs ) { if ( rs != null ) { try { rs . close ( ) ; } catch ( RuntimeException re ) { throw re ; } catch ( Exception e ) { log . warn ( "DataSourceResourceLoader: problem when closing result set: " , e ) ; } } } private ResultSet readData ( final Connection conn , final String columnNames , final String templateName ) throws SQLException { PreparedStatement ps = conn . prepareStatement ( "SELECT " + columnNames + " FROM " + tableName + " WHERE " + keyColumn + " = ?" ) ; ps . setString ( 1 , templateName ) ; return ps . executeQuery ( ) ; } } 	1	['11', '2', '0', '8', '43', '27', '0', '8', '6', '0.728571429', '523', '1', '0', '0.523809524', '0.285714286', '0', '0', '45.90909091', '5', '1.9091', '2']
package org . apache . velocity . anakia ; import org . jdom . Element ; import org . jdom . Namespace ; import org . jdom . DefaultJDOMFactory ; public class AnakiaJDOMFactory extends DefaultJDOMFactory { public AnakiaJDOMFactory ( ) { } public Element element ( String name , Namespace namespace ) { return new AnakiaElement ( name , namespace ) ; } public Element element ( String name ) { return new AnakiaElement ( name ) ; } public Element element ( String name , String uri ) { return new AnakiaElement ( name , uri ) ; } public Element element ( String name , String prefix , String uri ) { return new AnakiaElement ( name , prefix , uri ) ; } } 	0	['5', '2', '0', '5', '10', '10', '1', '4', '5', '2', '32', '0', '0', '0.862068966', '0.666666667', '0', '0', '5.4', '1', '0.8', '0']
package org . apache . velocity . runtime . resource . loader ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . util . ClassUtils ; import org . apache . velocity . util . StringUtils ; public class ResourceLoaderFactory { public static ResourceLoader getLoader ( RuntimeServices rs , String loaderClassName ) throws Exception { ResourceLoader loader = null ; try { loader = ( ResourceLoader ) ClassUtils . getNewInstance ( loaderClassName ) ; rs . getLog ( ) . debug ( "ResourceLoader instantiated: " + loader . getClass ( ) . getName ( ) ) ; return loader ; } catch ( Exception e ) { rs . getLog ( ) . error ( "Problem instantiating the template loader.\n" + "Look at your properties file and make sure the\n" + "name of the template loader is correct. Here is the\n" + "error:" , e ) ; throw new Exception ( "Problem initializing template loader: " + loaderClassName + "\nError is: " + StringUtils . stackTrace ( e ) ) ; } } } 	1	['2', '1', '0', '6', '14', '1', '1', '5', '2', '2', '49', '0', '0', '0', '0.5', '0', '0', '23.5', '1', '0.5', '1']
package org . apache . velocity . app . tools ; import java . lang . reflect . Array ; import java . text . DateFormat ; import java . util . Date ; import java . util . List ; import org . apache . velocity . context . Context ; public class VelocityFormatter { Context context = null ; public VelocityFormatter ( Context context ) { this . context = context ; } public String formatShortDate ( Date date ) { return DateFormat . getDateInstance ( DateFormat . SHORT ) . format ( date ) ; } public String formatLongDate ( Date date ) { return DateFormat . getDateInstance ( DateFormat . LONG ) . format ( date ) ; } public String formatShortDateTime ( Date date ) { return DateFormat . getDateTimeInstance ( DateFormat . SHORT , DateFormat . SHORT ) . format ( date ) ; } public String formatLongDateTime ( Date date ) { return DateFormat . getDateTimeInstance ( DateFormat . LONG , DateFormat . LONG ) . format ( date ) ; } public String formatArray ( Object array ) { return formatArray ( array , ", " , " and " ) ; } public String formatArray ( Object array , String delim ) { return formatArray ( array , delim , delim ) ; } public String formatArray ( Object array , String delim , String finaldelim ) { StringBuffer sb = new StringBuffer ( ) ; int arrayLen = Array . getLength ( array ) ; for ( int i = 0 ; i < arrayLen ; i ++ ) { sb . append ( Array . get ( array , i ) . toString ( ) ) ; if ( i < arrayLen - 2 ) { sb . append ( delim ) ; } else if ( i < arrayLen - 1 ) { sb . append ( finaldelim ) ; } } return sb . toString ( ) ; } public String formatVector ( List list ) { return formatVector ( list , ", " , " and " ) ; } public String formatVector ( List list , String delim ) { return formatVector ( list , delim , delim ) ; } public String formatVector ( List list , String delim , String finaldelim ) { StringBuffer sb = new StringBuffer ( ) ; int size = list . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { sb . append ( list . get ( i ) ) ; if ( i < size - 2 ) { sb . append ( delim ) ; } else if ( i < size - 1 ) { sb . append ( finaldelim ) ; } } return sb . toString ( ) ; } public String limitLen ( int maxlen , String string ) { return limitLen ( maxlen , string , "..." ) ; } public String limitLen ( int maxlen , String string , String suffix ) { String ret = string ; if ( string . length ( ) > maxlen ) { ret = string . substring ( 0 , maxlen - suffix . length ( ) ) + suffix ; } return ret ; } public class VelocityAlternator { protected String [ ] alternates = null ; protected int current = 0 ; public VelocityAlternator ( String [ ] alternates ) { this . alternates = alternates ; } public String alternate ( ) { current ++ ; current %= alternates . length ; return "" ; } public String toString ( ) { return alternates [ current ] ; } } public class VelocityAutoAlternator extends VelocityAlternator { public VelocityAutoAlternator ( String [ ] alternates ) { super ( alternates ) ; } public final String toString ( ) { String s = alternates [ current ] ; alternate ( ) ; return s ; } } public String makeAlternator ( String name , String alt1 , String alt2 ) { String [ ] alternates = { alt1 , alt2 } ; context . put ( name , new VelocityAlternator ( alternates ) ) ; return "" ; } public String makeAlternator ( String name , String alt1 , String alt2 , String alt3 ) { String [ ] alternates = { alt1 , alt2 , alt3 } ; context . put ( name , new VelocityAlternator ( alternates ) ) ; return "" ; } public String makeAlternator ( String name , String alt1 , String alt2 , String alt3 , String alt4 ) { String [ ] alternates = { alt1 , alt2 , alt3 , alt4 } ; context . put ( name , new VelocityAlternator ( alternates ) ) ; return "" ; } public String makeAutoAlternator ( String name , String alt1 , String alt2 ) { String [ ] alternates = { alt1 , alt2 } ; context . put ( name , new VelocityAutoAlternator ( alternates ) ) ; return "" ; } public Object isNull ( Object o , Object dflt ) { if ( o == null ) { return dflt ; } else { return o ; } } } 	0	['18', '1', '0', '3', '36', '133', '2', '3', '18', '0.764705882', '298', '0', '1', '0', '0.333333333', '0', '0', '15.5', '4', '1.3889', '0']
package org . apache . velocity . runtime . resource . loader ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . apache . commons . collections . ExtendedProperties ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . io . UnicodeInputStream ; import org . apache . velocity . runtime . resource . Resource ; import org . apache . velocity . util . StringUtils ; public class FileResourceLoader extends ResourceLoader { private List paths = new ArrayList ( ) ; private Map templatePaths = Collections . synchronizedMap ( new HashMap ( ) ) ; private boolean unicode = false ; public void init ( ExtendedProperties configuration ) { if ( log . isTraceEnabled ( ) ) { log . trace ( "FileResourceLoader : initialization starting." ) ; } paths . addAll ( configuration . getVector ( "path" ) ) ; unicode = configuration . getBoolean ( "unicode" , false ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Do unicode file recognition:  " + unicode ) ; } StringUtils . trimStrings ( paths ) ; if ( log . isInfoEnabled ( ) ) { int sz = paths . size ( ) ; for ( int i = 0 ; i < sz ; i ++ ) { log . info ( "FileResourceLoader : adding path '" + ( String ) paths . get ( i ) + "'" ) ; } log . trace ( "FileResourceLoader : initialization complete." ) ; } } public InputStream getResourceStream ( String templateName ) throws ResourceNotFoundException { if ( org . apache . commons . lang . StringUtils . isEmpty ( templateName ) ) { throw new ResourceNotFoundException ( "Need to specify a file name or file path!" ) ; } String template = StringUtils . normalizePath ( templateName ) ; if ( template == null || template . length ( ) == 0 ) { String msg = "File resource error : argument " + template + " contains .. and may be trying to access " + "content outside of template root.  Rejected." ; log . error ( "FileResourceLoader : " + msg ) ; throw new ResourceNotFoundException ( msg ) ; } int size = paths . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { String path = ( String ) paths . get ( i ) ; InputStream inputStream = null ; try { inputStream = findTemplate ( path , template ) ; } catch ( IOException ioe ) { log . error ( "While loading Template " + template + ": " , ioe ) ; } if ( inputStream != null ) { templatePaths . put ( templateName , path ) ; return inputStream ; } } throw new ResourceNotFoundException ( "FileResourceLoader : cannot find " + template ) ; } private InputStream findTemplate ( final String path , final String template ) throws IOException { try { File file = getFile ( path , template ) ; if ( file . canRead ( ) ) { FileInputStream fis = null ; try { fis = new FileInputStream ( file . getAbsolutePath ( ) ) ; if ( unicode ) { UnicodeInputStream uis = null ; try { uis = new UnicodeInputStream ( fis , true ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "File Encoding for " + file + " is: " + uis . getEncodingFromStream ( ) ) ; } return new BufferedInputStream ( uis ) ; } catch ( IOException e ) { closeQuiet ( uis ) ; throw e ; } } else { return new BufferedInputStream ( fis ) ; } } catch ( IOException e ) { closeQuiet ( fis ) ; throw e ; } } else { return null ; } } catch ( FileNotFoundException fnfe ) { return null ; } } private void closeQuiet ( final InputStream is ) { if ( is != null ) { try { is . close ( ) ; } catch ( IOException ioe ) { } } } public boolean isSourceModified ( Resource resource ) { boolean modified = true ; String fileName = resource . getName ( ) ; String path = ( String ) templatePaths . get ( fileName ) ; File currentFile = null ; for ( int i = 0 ; currentFile == null && i < paths . size ( ) ; i ++ ) { String testPath = ( String ) paths . get ( i ) ; File testFile = getFile ( testPath , fileName ) ; if ( testFile . canRead ( ) ) { currentFile = testFile ; } } File file = getFile ( path , fileName ) ; if ( currentFile == null || ! file . exists ( ) ) { } else if ( currentFile . equals ( file ) && file . canRead ( ) ) { modified = ( file . lastModified ( ) != resource . getLastModified ( ) ) ; } return modified ; } public long getLastModified ( Resource resource ) { String path = ( String ) templatePaths . get ( resource . getName ( ) ) ; File file = getFile ( path , resource . getName ( ) ) ; if ( file . canRead ( ) ) { return file . lastModified ( ) ; } else { return 0 ; } } private File getFile ( String path , String template ) { File file = null ; if ( "" . equals ( path ) ) { file = new File ( template ) ; } else { if ( template . startsWith ( "/" ) ) { template = template . substring ( 1 ) ; } file = new File ( path , template ) ; } return file ; } } 	1	['8', '2', '0', '8', '54', '4', '0', '8', '5', '0.571428571', '413', '1', '0', '0.611111111', '0.375', '1', '1', '50.25', '9', '2.875', '2']
package org . apache . velocity . anakia ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStreamWriter ; import java . io . Writer ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import java . util . StringTokenizer ; import org . apache . commons . collections . ExtendedProperties ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . MatchingTask ; import org . apache . velocity . Template ; import org . apache . velocity . VelocityContext ; import org . apache . velocity . app . VelocityEngine ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . util . StringUtils ; import org . jdom . Document ; import org . jdom . JDOMException ; import org . jdom . input . SAXBuilder ; import org . jdom . output . Format ; import org . xml . sax . SAXParseException ; public class AnakiaTask extends MatchingTask { SAXBuilder builder ; private File destDir = null ; File baseDir = null ; private String style = null ; private long styleSheetLastModified = 0 ; private String projectAttribute = null ; private File projectFile = null ; private long projectFileLastModified = 0 ; private boolean lastModifiedCheck = true ; private String extension = ".html" ; private String templatePath = null ; private File velocityPropertiesFile = null ; private VelocityEngine ve = new VelocityEngine ( ) ; private List contexts = new LinkedList ( ) ; public AnakiaTask ( ) { builder = new SAXBuilder ( ) ; builder . setFactory ( new AnakiaJDOMFactory ( ) ) ; } public void setBasedir ( File dir ) { baseDir = dir ; } public void setDestdir ( File dir ) { destDir = dir ; } public void setExtension ( String extension ) { this . extension = extension ; } public void setStyle ( String style ) { this . style = style ; } public void setProjectFile ( String projectAttribute ) { this . projectAttribute = projectAttribute ; } public void setTemplatePath ( File templatePath ) { try { this . templatePath = templatePath . getCanonicalPath ( ) ; } catch ( java . io . IOException ioe ) { throw new BuildException ( ioe ) ; } } public void setVelocityPropertiesFile ( File velocityPropertiesFile ) { this . velocityPropertiesFile = velocityPropertiesFile ; } public void setLastModifiedCheck ( String lastmod ) { if ( lastmod . equalsIgnoreCase ( "false" ) || lastmod . equalsIgnoreCase ( "no" ) || lastmod . equalsIgnoreCase ( "off" ) ) { this . lastModifiedCheck = false ; } } public void execute ( ) throws BuildException { DirectoryScanner scanner ; String [ ] list ; if ( baseDir == null ) { baseDir = project . resolveFile ( "." ) ; } if ( destDir == null ) { String msg = "destdir attribute must be set!" ; throw new BuildException ( msg ) ; } if ( style == null ) { throw new BuildException ( "style attribute must be set!" ) ; } if ( velocityPropertiesFile == null ) { velocityPropertiesFile = new File ( "velocity.properties" ) ; } if ( ! velocityPropertiesFile . exists ( ) && templatePath == null ) { throw new BuildException ( "No template path and could not " + "locate velocity.properties file: " + velocityPropertiesFile . getAbsolutePath ( ) ) ; } log ( "Transforming into: " + destDir . getAbsolutePath ( ) , Project . MSG_INFO ) ; if ( projectAttribute != null && projectAttribute . length ( ) > 0 ) { projectFile = new File ( baseDir , projectAttribute ) ; if ( projectFile . exists ( ) ) { projectFileLastModified = projectFile . lastModified ( ) ; } else { log ( "Project file is defined, but could not be located: " + projectFile . getAbsolutePath ( ) , Project . MSG_INFO ) ; projectFile = null ; } } Document projectDocument = null ; try { if ( velocityPropertiesFile . exists ( ) ) { String file = velocityPropertiesFile . getAbsolutePath ( ) ; ExtendedProperties config = new ExtendedProperties ( file ) ; ve . setExtendedProperties ( config ) ; } if ( templatePath != null && templatePath . length ( ) > 0 ) { ve . setProperty ( RuntimeConstants . FILE_RESOURCE_LOADER_PATH , templatePath ) ; } ve . init ( ) ; styleSheetLastModified = ve . getTemplate ( style ) . getLastModified ( ) ; if ( projectFile != null ) { projectDocument = builder . build ( projectFile ) ; } } catch ( Exception e ) { log ( "Error: " + e . toString ( ) , Project . MSG_INFO ) ; throw new BuildException ( e ) ; } scanner = getDirectoryScanner ( baseDir ) ; list = scanner . getIncludedFiles ( ) ; for ( int i = 0 ; i < list . length ; ++ i ) { process ( list [ i ] , projectDocument ) ; } } private void process ( String xmlFile , Document projectDocument ) throws BuildException { File outFile = null ; File inFile = null ; Writer writer = null ; try { inFile = new File ( baseDir , xmlFile ) ; outFile = new File ( destDir , xmlFile . substring ( 0 , xmlFile . lastIndexOf ( '.' ) ) + extension ) ; if ( lastModifiedCheck == false || ( inFile . lastModified ( ) > outFile . lastModified ( ) || styleSheetLastModified > outFile . lastModified ( ) || projectFileLastModified > outFile . lastModified ( ) || userContextsModifed ( outFile . lastModified ( ) ) ) ) { ensureDirectoryFor ( outFile ) ; log ( "Input:  " + xmlFile , Project . MSG_INFO ) ; Document root = builder . build ( inFile ) ; VelocityContext context = new VelocityContext ( ) ; String encoding = ( String ) ve . getProperty ( RuntimeConstants . OUTPUT_ENCODING ) ; if ( encoding == null || encoding . length ( ) == 0 || encoding . equals ( "8859-1" ) || encoding . equals ( "8859_1" ) ) { encoding = "ISO-8859-1" ; } Format f = Format . getRawFormat ( ) ; f . setEncoding ( encoding ) ; OutputWrapper ow = new OutputWrapper ( f ) ; context . put ( "root" , root . getRootElement ( ) ) ; context . put ( "xmlout" , ow ) ; context . put ( "relativePath" , getRelativePath ( xmlFile ) ) ; context . put ( "treeWalk" , new TreeWalker ( ) ) ; context . put ( "xpath" , new XPathTool ( ) ) ; context . put ( "escape" , new Escape ( ) ) ; context . put ( "date" , new java . util . Date ( ) ) ; if ( projectDocument != null ) { context . put ( "project" , projectDocument . getRootElement ( ) ) ; } for ( Iterator iter = contexts . iterator ( ) ; iter . hasNext ( ) ; ) { Context subContext = ( Context ) iter . next ( ) ; if ( subContext == null ) { throw new BuildException ( "Found an undefined SubContext!" ) ; } if ( subContext . getContextDocument ( ) == null ) { throw new BuildException ( "Could not build a subContext for " + subContext . getName ( ) ) ; } context . put ( subContext . getName ( ) , subContext . getContextDocument ( ) . getRootElement ( ) ) ; } writer = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( outFile ) , encoding ) ) ; Template template = ve . getTemplate ( style ) ; template . merge ( context , writer ) ; log ( "Output: " + outFile , Project . MSG_INFO ) ; } } catch ( JDOMException e ) { outFile . delete ( ) ; if ( e . getCause ( ) != null ) { Throwable rootCause = e . getCause ( ) ; if ( rootCause instanceof SAXParseException ) { System . out . println ( "" ) ; System . out . println ( "Error: " + rootCause . getMessage ( ) ) ; System . out . println ( "       Line: " + ( ( SAXParseException ) rootCause ) . getLineNumber ( ) + " Column: " + ( ( SAXParseException ) rootCause ) . getColumnNumber ( ) ) ; System . out . println ( "" ) ; } else { rootCause . printStackTrace ( ) ; } } else { e . printStackTrace ( ) ; } } catch ( Throwable e ) { if ( outFile != null ) { outFile . delete ( ) ; } e . printStackTrace ( ) ; } finally { if ( writer != null ) { try { writer . flush ( ) ; } catch ( IOException e ) { } try { writer . close ( ) ; } catch ( IOException e ) { } } } } private String getRelativePath ( String file ) { if ( file == null || file . length ( ) == 0 ) return "" ; StringTokenizer st = new StringTokenizer ( file , "/\\" ) ; int slashCount = st . countTokens ( ) - 1 ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < slashCount ; i ++ ) { sb . append ( "../" ) ; } if ( sb . toString ( ) . length ( ) > 0 ) { return StringUtils . chop ( sb . toString ( ) , 1 ) ; } return "." ; } private void ensureDirectoryFor ( File targetFile ) throws BuildException { File directory = new File ( targetFile . getParent ( ) ) ; if ( ! directory . exists ( ) ) { if ( ! directory . mkdirs ( ) ) { throw new BuildException ( "Unable to create directory: " + directory . getAbsolutePath ( ) ) ; } } } private boolean userContextsModifed ( long lastModified ) { for ( Iterator iter = contexts . iterator ( ) ; iter . hasNext ( ) ; ) { AnakiaTask . Context ctx = ( AnakiaTask . Context ) iter . next ( ) ; if ( ctx . getLastModified ( ) > lastModified ) { return true ; } } return false ; } public Context createContext ( ) { Context context = new Context ( ) ; contexts . add ( context ) ; return context ; } public class Context { private String name ; private Document contextDoc = null ; private String file ; public Context ( ) { } public String getName ( ) { return name ; } public void setName ( String name ) { if ( name . equals ( "relativePath" ) || name . equals ( "treeWalk" ) || name . equals ( "xpath" ) || name . equals ( "escape" ) || name . equals ( "date" ) || name . equals ( "project" ) ) { throw new IllegalArgumentException ( "Context name '" + name + "' is reserved by Anakia" ) ; } this . name = name ; } public void setFile ( String file ) { this . file = file ; } public long getLastModified ( ) { return new File ( baseDir , file ) . lastModified ( ) ; } public Document getContextDocument ( ) { if ( contextDoc == null ) { File contextFile = new File ( baseDir , file ) ; try { contextDoc = builder . build ( contextFile ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } return contextDoc ; } } } 	0	['15', '4', '0', '22', '89', '51', '1', '22', '11', '0.826530612', '776', '0.857142857', '1', '0.847826087', '0.373333333', '2', '2', '49.8', '5', '1.4667', '0']
package org . apache . velocity . app . event . implement ; import org . apache . commons . lang . StringEscapeUtils ; public class EscapeJavaScriptReference extends EscapeReference { protected String escape ( Object text ) { return StringEscapeUtils . escapeJavaScript ( text . toString ( ) ) ; } protected String getMatchAttribute ( ) { return "eventhandler.escape.javascript.match" ; } } 	1	['3', '2', '0', '2', '6', '3', '0', '2', '1', '2', '12', '0', '0', '0.714285714', '0.666666667', '1', '2', '3', '1', '0.6667', '1']
package org . apache . velocity . context ; public interface InternalContextAdapter extends InternalHousekeepingContext , Context , InternalWrapperContext , InternalEventContext { } 	0	['0', '1', '0', '61', '0', '0', '58', '4', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . velocity . runtime . parser . node ; import java . io . IOException ; import java . io . Writer ; import org . apache . commons . lang . builder . ToStringBuilder ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . runtime . directive . Directive ; import org . apache . velocity . runtime . parser . ParseException ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; import org . apache . velocity . util . ExceptionUtils ; public class ASTDirective extends SimpleNode { private Directive directive = null ; private String directiveName = "" ; private boolean isDirective ; public ASTDirective ( int id ) { super ( id ) ; } public ASTDirective ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object init ( InternalContextAdapter context , Object data ) throws TemplateInitException { super . init ( context , data ) ; if ( parser . isDirective ( directiveName ) ) { isDirective = true ; try { directive = ( Directive ) parser . getDirective ( directiveName ) . getClass ( ) . newInstance ( ) ; } catch ( InstantiationException e ) { throw ExceptionUtils . createRuntimeException ( "Couldn't initialize " + "directive of class " + parser . getDirective ( directiveName ) . getClass ( ) . getName ( ) , e ) ; } catch ( IllegalAccessException e ) { throw ExceptionUtils . createRuntimeException ( "Couldn't initialize " + "directive of class " + parser . getDirective ( directiveName ) . getClass ( ) . getName ( ) , e ) ; } directive . init ( rsvc , context , this ) ; directive . setLocation ( getLine ( ) , getColumn ( ) ) ; } else if ( rsvc . isVelocimacro ( directiveName , context . getCurrentTemplateName ( ) ) ) { isDirective = true ; directive = rsvc . getVelocimacro ( directiveName , context . getCurrentTemplateName ( ) ) ; try { directive . init ( rsvc , context , this ) ; } catch ( TemplateInitException die ) { throw new TemplateInitException ( die . getMessage ( ) , ( ParseException ) die . getWrappedThrowable ( ) , die . getTemplateName ( ) , die . getColumnNumber ( ) + getColumn ( ) , die . getLineNumber ( ) + getLine ( ) ) ; } directive . setLocation ( getLine ( ) , getColumn ( ) ) ; } else { isDirective = false ; } return data ; } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException , ResourceNotFoundException , ParseErrorException { if ( isDirective ) { directive . render ( context , writer , this ) ; } else { if ( context . getAllowRendering ( ) ) { writer . write ( "#" ) ; writer . write ( directiveName ) ; } } return true ; } public void setDirectiveName ( String str ) { directiveName = str ; } public String getDirectiveName ( ) { return directiveName ; } public String toString ( ) { return new ToStringBuilder ( this ) . appendSuper ( super . toString ( ) ) . append ( "directiveName" , getDirectiveName ( ) ) . toString ( ) ; } } 	1	['8', '2', '0', '17', '42', '0', '5', '14', '8', '0.523809524', '219', '1', '1', '0.823529412', '0.28125', '1', '1', '26', '1', '0.75', '6']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; public class ASTWord extends SimpleNode { public ASTWord ( int id ) { super ( id ) ; } public ASTWord ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } } 	0	['3', '2', '0', '5', '6', '3', '4', '3', '3', '2', '17', '0', '0', '0.965517241', '0.533333333', '0', '0', '4.666666667', '1', '0.3333', '0']
package org . apache . velocity . app . event ; import java . util . Iterator ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . util . ExceptionUtils ; import org . apache . velocity . util . introspection . Info ; public class EventHandlerUtil { public static Object referenceInsert ( RuntimeServices rsvc , InternalContextAdapter context , String reference , Object value ) { EventCartridge ev1 = rsvc . getApplicationEventCartridge ( ) ; Iterator applicationEventHandlerIterator = ( ev1 == null ) ? null : ev1 . getReferenceInsertionEventHandlers ( ) ; EventCartridge ev2 = context . getEventCartridge ( ) ; initializeEventCartridge ( rsvc , ev2 ) ; Iterator contextEventHandlerIterator = ( ev2 == null ) ? null : ev2 . getReferenceInsertionEventHandlers ( ) ; try { EventHandlerMethodExecutor methodExecutor = new ReferenceInsertionEventHandler . referenceInsertExecutor ( context , reference , value ) ; callEventHandlers ( applicationEventHandlerIterator , contextEventHandlerIterator , methodExecutor ) ; return methodExecutor . getReturnValue ( ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { throw ExceptionUtils . createRuntimeException ( "Exception in event handler." , e ) ; } } public static boolean shouldLogOnNullSet ( RuntimeServices rsvc , InternalContextAdapter context , String lhs , String rhs ) { EventCartridge ev1 = rsvc . getApplicationEventCartridge ( ) ; Iterator applicationEventHandlerIterator = ( ev1 == null ) ? null : ev1 . getNullSetEventHandlers ( ) ; EventCartridge ev2 = context . getEventCartridge ( ) ; initializeEventCartridge ( rsvc , ev2 ) ; Iterator contextEventHandlerIterator = ( ev2 == null ) ? null : ev2 . getNullSetEventHandlers ( ) ; try { EventHandlerMethodExecutor methodExecutor = new NullSetEventHandler . ShouldLogOnNullSetExecutor ( context , lhs , rhs ) ; callEventHandlers ( applicationEventHandlerIterator , contextEventHandlerIterator , methodExecutor ) ; return ( ( Boolean ) methodExecutor . getReturnValue ( ) ) . booleanValue ( ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { throw ExceptionUtils . createRuntimeException ( "Exception in event handler." , e ) ; } } public static Object methodException ( RuntimeServices rsvc , InternalContextAdapter context , Class claz , String method , Exception e ) throws Exception { EventCartridge ev1 = rsvc . getApplicationEventCartridge ( ) ; Iterator applicationEventHandlerIterator = ( ev1 == null ) ? null : ev1 . getMethodExceptionEventHandlers ( ) ; EventCartridge ev2 = context . getEventCartridge ( ) ; initializeEventCartridge ( rsvc , ev2 ) ; Iterator contextEventHandlerIterator = ( ev2 == null ) ? null : ev2 . getMethodExceptionEventHandlers ( ) ; EventHandlerMethodExecutor methodExecutor = new MethodExceptionEventHandler . MethodExceptionExecutor ( context , claz , method , e ) ; if ( ( ( applicationEventHandlerIterator == null ) || ! applicationEventHandlerIterator . hasNext ( ) ) && ( ( contextEventHandlerIterator == null ) || ! contextEventHandlerIterator . hasNext ( ) ) ) { throw e ; } callEventHandlers ( applicationEventHandlerIterator , contextEventHandlerIterator , methodExecutor ) ; return methodExecutor . getReturnValue ( ) ; } public static String includeEvent ( RuntimeServices rsvc , InternalContextAdapter context , String includeResourcePath , String currentResourcePath , String directiveName ) { EventCartridge ev1 = rsvc . getApplicationEventCartridge ( ) ; Iterator applicationEventHandlerIterator = ( ev1 == null ) ? null : ev1 . getIncludeEventHandlers ( ) ; EventCartridge ev2 = context . getEventCartridge ( ) ; initializeEventCartridge ( rsvc , ev2 ) ; Iterator contextEventHandlerIterator = ( ev2 == null ) ? null : ev2 . getIncludeEventHandlers ( ) ; try { EventHandlerMethodExecutor methodExecutor = new IncludeEventHandler . IncludeEventExecutor ( context , includeResourcePath , currentResourcePath , directiveName ) ; callEventHandlers ( applicationEventHandlerIterator , contextEventHandlerIterator , methodExecutor ) ; return ( String ) methodExecutor . getReturnValue ( ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { throw ExceptionUtils . createRuntimeException ( "Exception in event handler." , e ) ; } } public static Object invalidGetMethod ( RuntimeServices rsvc , InternalContextAdapter context , String reference , Object object , String property , Info info ) { return invalidReferenceHandlerCall ( new InvalidReferenceEventHandler . InvalidGetMethodExecutor ( context , reference , object , property , info ) , rsvc , context ) ; } public static void invalidSetMethod ( RuntimeServices rsvc , InternalContextAdapter context , String leftreference , String rightreference , Info info ) { invalidReferenceHandlerCall ( new InvalidReferenceEventHandler . InvalidSetMethodExecutor ( context , leftreference , rightreference , info ) , rsvc , context ) ; } public static Object invalidMethod ( RuntimeServices rsvc , InternalContextAdapter context , String reference , Object object , String method , Info info ) { return invalidReferenceHandlerCall ( new InvalidReferenceEventHandler . InvalidMethodExecutor ( context , reference , object , method , info ) , rsvc , context ) ; } public static Object invalidReferenceHandlerCall ( EventHandlerMethodExecutor methodExecutor , RuntimeServices rsvc , InternalContextAdapter context ) { EventCartridge ev1 = rsvc . getApplicationEventCartridge ( ) ; Iterator applicationEventHandlerIterator = ( ev1 == null ) ? null : ev1 . getInvalidReferenceEventHandlers ( ) ; EventCartridge ev2 = context . getEventCartridge ( ) ; initializeEventCartridge ( rsvc , ev2 ) ; Iterator contextEventHandlerIterator = ( ev2 == null ) ? null : ev2 . getInvalidReferenceEventHandlers ( ) ; try { callEventHandlers ( applicationEventHandlerIterator , contextEventHandlerIterator , methodExecutor ) ; return methodExecutor . getReturnValue ( ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { throw ExceptionUtils . createRuntimeException ( "Exception in event handler." , e ) ; } } private static void initializeEventCartridge ( RuntimeServices rsvc , EventCartridge eventCartridge ) { if ( eventCartridge != null ) { try { eventCartridge . initialize ( rsvc ) ; } catch ( Exception e ) { throw ExceptionUtils . createRuntimeException ( "Couldn't initialize event cartridge : " , e ) ; } } } private static void callEventHandlers ( Iterator applicationEventHandlerIterator , Iterator contextEventHandlerIterator , EventHandlerMethodExecutor eventExecutor ) throws Exception { iterateOverEventHandlers ( applicationEventHandlerIterator , eventExecutor ) ; iterateOverEventHandlers ( contextEventHandlerIterator , eventExecutor ) ; } private static void iterateOverEventHandlers ( Iterator handlerIterator , EventHandlerMethodExecutor eventExecutor ) throws Exception { if ( handlerIterator != null ) { for ( Iterator i = handlerIterator ; i . hasNext ( ) ; ) { EventHandler eventHandler = ( EventHandler ) i . next ( ) ; if ( ! eventExecutor . isDone ( ) ) { eventExecutor . execute ( eventHandler ) ; } } } } } 	1	['12', '1', '0', '21', '35', '66', '6', '15', '9', '2', '316', '0', '0', '0', '0.295454545', '0', '0', '25.33333333', '3', '1.6667', '2']
package org . apache . velocity . runtime . parser . node ; import java . io . Writer ; import java . io . IOException ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; import org . apache . velocity . runtime . parser . Token ; public class ASTText extends SimpleNode { private char [ ] ctext ; public ASTText ( int id ) { super ( id ) ; } public ASTText ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object init ( InternalContextAdapter context , Object data ) throws TemplateInitException { Token t = getFirstToken ( ) ; String text = NodeUtils . tokenLiteral ( t ) ; ctext = text . toCharArray ( ) ; return data ; } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException { if ( context . getAllowRendering ( ) ) { writer . write ( ctext ) ; } return true ; } } 	0	['5', '2', '0', '9', '13', '8', '4', '7', '5', '0.75', '41', '1', '0', '0.903225806', '0.4', '0', '0', '7', '1', '0.6', '0']
package org . apache . velocity . context ; public abstract class AbstractContext extends InternalContextBase implements Context { private Context innerContext = null ; public abstract Object internalGet ( String key ) ; public abstract Object internalPut ( String key , Object value ) ; public abstract boolean internalContainsKey ( Object key ) ; public abstract Object [ ] internalGetKeys ( ) ; public abstract Object internalRemove ( Object key ) ; public AbstractContext ( ) { } public AbstractContext ( Context inner ) { innerContext = inner ; if ( innerContext instanceof InternalEventContext ) { attachEventCartridge ( ( ( InternalEventContext ) innerContext ) . getEventCartridge ( ) ) ; } } public Object put ( String key , Object value ) { if ( key == null ) { return null ; } else if ( value == null ) { return null ; } return internalPut ( key , value ) ; } public Object get ( String key ) { if ( key == null ) { return null ; } Object o = internalGet ( key ) ; if ( o == null && innerContext != null ) { o = innerContext . get ( key ) ; } return o ; } public boolean containsKey ( Object key ) { if ( key == null ) { return false ; } return internalContainsKey ( key ) ; } public Object [ ] getKeys ( ) { return internalGetKeys ( ) ; } public Object remove ( Object key ) { if ( key == null ) { return null ; } return internalRemove ( key ) ; } public Context getChainedContext ( ) { return innerContext ; } } 	1	['13', '2', '1', '5', '17', '66', '1', '4', '13', '0.75', '95', '1', '1', '0.52173913', '0.461538462', '0', '0', '6.230769231', '4', '1.3846', '1']
package org . apache . velocity . runtime . resource ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . ParseErrorException ; public interface ResourceManager { public static final int RESOURCE_TEMPLATE = 1 ; public static final int RESOURCE_CONTENT = 2 ; public void initialize ( RuntimeServices rs ) throws Exception ; public Resource getResource ( String resourceName , int resourceType , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception ; public String getLoaderNameForResource ( String resourceName ) ; } 	0	['3', '1', '0', '6', '3', '3', '2', '4', '3', '1.5', '5', '0', '0', '0', '0.583333333', '0', '0', '0', '1', '1', '0']
package org . apache . velocity . runtime . parser . node ; import java . util . Map ; import org . apache . velocity . runtime . log . Log ; public class MapGetExecutor extends AbstractExecutor { private final String property ; public MapGetExecutor ( final Log log , final Class clazz , final String property ) { this . log = log ; this . property = property ; discover ( clazz ) ; } protected void discover ( final Class clazz ) { Class [ ] interfaces = clazz . getInterfaces ( ) ; for ( int i = 0 ; i < interfaces . length ; i ++ ) { if ( interfaces [ i ] . equals ( Map . class ) ) { try { if ( property != null ) { setMethod ( Map . class . getMethod ( "get" , new Class [ ] { Object . class } ) ) ; } } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { log . error ( "While looking for get('" + property + "') method:" , e ) ; } break ; } } } public Object execute ( final Object o ) { return ( ( Map ) o ) . get ( property ) ; } } 	1	['4', '2', '0', '3', '17', '0', '1', '2', '2', '0.555555556', '109', '0.333333333', '0', '0.571428571', '0.45', '0', '0', '25.5', '6', '2', '2']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; public class ASTNotNode extends SimpleNode { public ASTNotNode ( int id ) { super ( id ) ; } public ASTNotNode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { if ( jjtGetChild ( 0 ) . evaluate ( context ) ) return false ; else return true ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { return ( jjtGetChild ( 0 ) . evaluate ( context ) ? Boolean . FALSE : Boolean . TRUE ) ; } } 	0	['5', '2', '0', '8', '10', '10', '4', '6', '5', '2', '39', '0', '0', '0.903225806', '0.4', '1', '2', '6.8', '1', '0.6', '0']
package org . apache . velocity . runtime . log ; import java . io . IOException ; import java . lang . reflect . Field ; import org . apache . log4j . Level ; import org . apache . log4j . Logger ; import org . apache . log4j . PatternLayout ; import org . apache . log4j . RollingFileAppender ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . util . ExceptionUtils ; public class Log4JLogChute implements LogChute { public static final String RUNTIME_LOG_LOG4J_LOGGER = "runtime.log.logsystem.log4j.logger" ; private RuntimeServices rsvc = null ; private boolean hasTrace = false ; private RollingFileAppender appender = null ; protected Logger logger = null ; public void init ( RuntimeServices rs ) throws Exception { rsvc = rs ; String name = ( String ) rsvc . getProperty ( RUNTIME_LOG_LOG4J_LOGGER ) ; if ( name != null ) { logger = Logger . getLogger ( name ) ; log ( DEBUG_ID , "Log4JLogChute using logger '" + name + '\'' ) ; } else { logger = Logger . getLogger ( this . getClass ( ) . getName ( ) ) ; String file = rsvc . getString ( RuntimeConstants . RUNTIME_LOG ) ; if ( file != null && file . length ( ) > 0 ) { initAppender ( file ) ; } } try { Field traceLevel = Level . class . getField ( "TRACE" ) ; hasTrace = true ; } catch ( NoSuchFieldException e ) { log ( DEBUG_ID , "The version of log4j being used does not support the \"trace\" level." ) ; } } private void initAppender ( String file ) throws Exception { try { PatternLayout layout = new PatternLayout ( "%d - %m%n" ) ; this . appender = new RollingFileAppender ( layout , file , true ) ; appender . setMaxBackupIndex ( 1 ) ; appender . setMaximumFileSize ( 100000 ) ; logger . setAdditivity ( false ) ; logger . setLevel ( Level . DEBUG ) ; logger . addAppender ( appender ) ; log ( DEBUG_ID , "Log4JLogChute initialized using file '" + file + '\'' ) ; } catch ( IOException ioe ) { rsvc . getLog ( ) . warn ( "Could not create file appender '" + file + '\'' , ioe ) ; throw ExceptionUtils . createRuntimeException ( "Error configuring Log4JLogChute : " , ioe ) ; } } public void log ( int level , String message ) { switch ( level ) { case LogChute . WARN_ID : logger . warn ( message ) ; break ; case LogChute . INFO_ID : logger . info ( message ) ; break ; case LogChute . DEBUG_ID : logger . debug ( message ) ; break ; case LogChute . TRACE_ID : if ( hasTrace ) { logger . trace ( message ) ; } else { logger . debug ( message ) ; } break ; case LogChute . ERROR_ID : logger . error ( message ) ; break ; default : logger . debug ( message ) ; break ; } } public void log ( int level , String message , Throwable t ) { switch ( level ) { case LogChute . WARN_ID : logger . warn ( message , t ) ; break ; case LogChute . INFO_ID : logger . info ( message , t ) ; break ; case LogChute . DEBUG_ID : logger . debug ( message , t ) ; break ; case LogChute . TRACE_ID : if ( hasTrace ) { logger . trace ( message , t ) ; } else { logger . debug ( message , t ) ; } break ; case LogChute . ERROR_ID : logger . error ( message , t ) ; break ; default : logger . debug ( message , t ) ; break ; } } public boolean isLevelEnabled ( int level ) { switch ( level ) { case LogChute . DEBUG_ID : return logger . isDebugEnabled ( ) ; case LogChute . INFO_ID : return logger . isInfoEnabled ( ) ; case LogChute . TRACE_ID : if ( hasTrace ) { return logger . isTraceEnabled ( ) ; } else { return logger . isDebugEnabled ( ) ; } case LogChute . WARN_ID : return logger . isEnabledFor ( Level . WARN ) ; case LogChute . ERROR_ID : return logger . isEnabledFor ( Level . ERROR ) ; default : return true ; } } protected void finalize ( ) throws Throwable { shutdown ( ) ; } public void shutdown ( ) { if ( appender != null ) { logger . removeAppender ( appender ) ; appender . close ( ) ; appender = null ; } } } 	1	['9', '1', '1', '12', '50', '0', '1', '11', '6', '0.645833333', '316', '0.666666667', '1', '0', '0.377777778', '0', '0', '33.44444444', '3', '1.6667', '3']
package org . apache . velocity . anakia ; import com . werken . xpath . XPath ; import java . util . Map ; import java . util . WeakHashMap ; class XPathCache { private static final Map XPATH_CACHE = new WeakHashMap ( ) ; private XPathCache ( ) { } static XPath getXPath ( String xpathString ) { XPath xpath = null ; synchronized ( XPATH_CACHE ) { xpath = ( XPath ) XPATH_CACHE . get ( xpathString ) ; if ( xpath == null ) { xpath = new XPath ( xpathString ) ; XPATH_CACHE . put ( xpathString , xpath ) ; } } return xpath ; } } 	0	['3', '1', '0', '4', '8', '1', '3', '1', '0', '0.5', '45', '1', '0', '0', '0.5', '0', '0', '13.66666667', '2', '0.6667', '0']
package org . apache . velocity . util ; public interface TemplateNumber { public Number getAsNumber ( ) ; } 	1	['1', '1', '0', '11', '1', '0', '11', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . velocity . runtime . log ; public class Log4JLogSystem extends Log4JLogChute implements LogSystem { public void logVelocityMessage ( int level , String message ) { log ( level , message ) ; } } 	0	['2', '2', '0', '2', '4', '1', '0', '2', '2', '2', '10', '0', '0', '0.888888889', '0.666666667', '0', '0', '4', '1', '0.5', '0']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . util . TemplateNumber ; public class ASTGENode extends SimpleNode { public ASTGENode ( int id ) { super ( id ) ; } public ASTGENode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { Object left = jjtGetChild ( 0 ) . value ( context ) ; Object right = jjtGetChild ( 1 ) . value ( context ) ; if ( left == null || right == null ) { log . error ( ( left == null ? "Left" : "Right" ) + " side (" + jjtGetChild ( ( left == null ? 0 : 1 ) ) . literal ( ) + ") of '>=' operation has null value." + " Operation not possible. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return false ; } if ( left instanceof TemplateNumber ) { left = ( ( TemplateNumber ) left ) . getAsNumber ( ) ; } if ( right instanceof TemplateNumber ) { right = ( ( TemplateNumber ) right ) . getAsNumber ( ) ; } if ( ! ( left instanceof Number ) || ! ( right instanceof Number ) ) { log . error ( ( ! ( left instanceof Number ) ? "Left" : "Right" ) + " side of '>=' operation is not a Number. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return false ; } return MathUtils . compare ( ( Number ) left , ( Number ) right ) >= 0 ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { boolean val = evaluate ( context ) ; return val ? Boolean . TRUE : Boolean . FALSE ; } } 	1	['5', '2', '0', '11', '21', '10', '4', '9', '5', '2', '153', '0', '0', '0.903225806', '0.4', '1', '1', '29.6', '1', '0.6', '1']
package org . apache . velocity . util . introspection ; public interface VelMethod { public Object invoke ( Object o , Object [ ] params ) throws Exception ; public boolean isCacheable ( ) ; public String getMethodName ( ) ; public Class getReturnType ( ) ; } 	0	['4', '1', '0', '4', '4', '6', '4', '0', '4', '2', '4', '0', '0', '0', '0.5', '0', '0', '0', '1', '1', '0']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . util . TemplateNumber ; public class ASTNENode extends SimpleNode { public ASTNENode ( int id ) { super ( id ) ; } public ASTNENode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { Object left = jjtGetChild ( 0 ) . value ( context ) ; Object right = jjtGetChild ( 1 ) . value ( context ) ; if ( left == null || right == null ) { log . error ( ( left == null ? "Left" : "Right" ) + " side (" + jjtGetChild ( ( left == null ? 0 : 1 ) ) . literal ( ) + ") of '!=' operation has null value." + " Operation not possible. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return false ; } if ( left instanceof TemplateNumber ) { left = ( ( TemplateNumber ) left ) . getAsNumber ( ) ; } if ( right instanceof TemplateNumber ) { right = ( ( TemplateNumber ) right ) . getAsNumber ( ) ; } if ( left instanceof Number && right instanceof Number ) { return MathUtils . compare ( ( Number ) left , ( Number ) right ) != 0 ; } if ( left . getClass ( ) . isAssignableFrom ( right . getClass ( ) ) || right . getClass ( ) . isAssignableFrom ( left . getClass ( ) ) ) { return ! left . equals ( right ) ; } else { if ( ( left . toString ( ) == null ) || ( right . toString ( ) == null ) ) { boolean culprit = ( left . toString ( ) == null ) ; log . error ( ( culprit ? "Left" : "Right" ) + " string side " + "String representation (" + jjtGetChild ( ( culprit ? 0 : 1 ) ) . literal ( ) + ") of '!=' operation has null value." + " Operation not possible. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return false ; } else { return ! left . toString ( ) . equals ( right . toString ( ) ) ; } } } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { boolean val = evaluate ( context ) ; return val ? Boolean . TRUE : Boolean . FALSE ; } } 	1	['5', '2', '0', '11', '26', '10', '4', '9', '5', '2', '210', '0', '0', '0.903225806', '0.4', '2', '2', '41', '1', '0.6', '2']
package org . apache . velocity . convert ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import org . apache . oro . text . perl . Perl5Util ; import org . apache . velocity . util . StringUtils ; import org . apache . tools . ant . DirectoryScanner ; public class WebMacro { protected static final String VM_EXT = ".vm" ; protected static final String WM_EXT = ".wm" ; protected static String [ ] perLineREs = { "#if\\s*[(]\\s*(.*\\S)\\s*[)]\\s*(#begin|{)[ \\t]?" , "#if( $1 )" , "[ \\t]?(#end|})[ \\t]*\n(\\s*)#else\\s*(#begin|{)[ \\t]?(\\w)" , "$2#else#**#$4" , "[ \\t]?(#end|})[ \\t]*\n(\\s*)#else\\s*(#begin|{)[ \\t]?" , "$2#else" , "(#end|})(\\s*#else)\\s*(#begin|{)[ \\t]?" , "$1\n$2" , "#foreach\\s+(\\$\\w+)\\s+in\\s+(\\$[^\\s#]+)\\s*(#begin|{)[ \\t]?" , "#foreach( $1 in $2 )" , "#set\\s+(\\$[^\\s=]+)\\s*=\\s*([\\S \\t]+)" , "#set( $1 = $2 )" , "(##[# \\t\\w]*)\\)" , ")$1" , "#parse\\s+([^\\s#]+)[ \\t]?" , "#parse( $1 )" , "#include\\s+([^\\s#]+)[ \\t]?" , "#include( $1 )" , "\\$\\(([^\\)]+)\\)" , "${$1}" , "\\${([^}\\(]+)\\(([^}]+)}\\)" , "${$1($2)}" , "\\$_" , "$l_" , "\\${(_[^}]+)}" , "${l$1}" , "(#set\\s*\\([^;]+);(\\s*\\))" , "$1$2" , "(^|[^\\\\])\\$(\\w[^=\n;'\"]*);" , "$1${$2}" , "\\.wm" , ".vm" } ; public void convert ( String target ) { File file = new File ( target ) ; if ( ! file . exists ( ) ) { throw new RuntimeException ( "The specified template or directory does not exist" ) ; } if ( file . isDirectory ( ) ) { String basedir = file . getAbsolutePath ( ) ; String newBasedir = basedir + VM_EXT ; DirectoryScanner ds = new DirectoryScanner ( ) ; ds . setBasedir ( basedir ) ; ds . addDefaultExcludes ( ) ; ds . scan ( ) ; String [ ] files = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { writeTemplate ( files [ i ] , basedir , newBasedir ) ; } } else { writeTemplate ( file . getAbsolutePath ( ) , "" , "" ) ; } } private boolean writeTemplate ( String file , String basedir , String newBasedir ) { if ( file . indexOf ( WM_EXT ) < 0 ) { return false ; } System . out . println ( "Converting " + file + "..." ) ; String template = file ; String newTemplate = convertName ( file ) ; if ( basedir . length ( ) > 0 ) { String templateDir = newBasedir + extractPath ( file ) ; File outputDirectory = new File ( templateDir ) ; template = basedir + File . separator + file ; if ( ! outputDirectory . exists ( ) ) { outputDirectory . mkdirs ( ) ; } newTemplate = newBasedir + File . separator + convertName ( file ) ; } String convertedTemplate = convertTemplate ( template ) ; FileWriter fw = null ; try { fw = new FileWriter ( newTemplate ) ; fw . write ( convertedTemplate ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( fw != null ) { try { fw . close ( ) ; } catch ( IOException io ) { } } } return true ; } private final String extractPath ( String file ) { int lastSepPos = file . lastIndexOf ( File . separator ) ; return ( lastSepPos == - 1 ? "" : File . separator + file . substring ( 0 , lastSepPos ) ) ; } private String convertName ( String name ) { return ( name . indexOf ( WM_EXT ) < 0 ) ? name : name . substring ( 0 , name . indexOf ( WM_EXT ) ) + VM_EXT ; } private static final void usage ( ) { System . err . println ( "Usage: convert-wm <template.wm | directory>" ) ; } public String convertTemplate ( String template ) { String contents = StringUtils . fileContentsToString ( template ) ; if ( ! contents . endsWith ( "\n" ) ) { contents += "\n" ; } Perl5Util perl = new Perl5Util ( ) ; for ( int i = 0 ; i < perLineREs . length ; i += 2 ) { contents = perl . substitute ( makeSubstRE ( i ) , contents ) ; } if ( perl . match ( "m/javascript/i" , contents ) ) { contents = perl . substitute ( "s/\n}/\n#end/g" , contents ) ; } else { contents = perl . substitute ( "s/(\n\\s*)}/$1#end/g" , contents ) ; contents = perl . substitute ( "s/#end\\s*\n\\s*#else/#else/g" , contents ) ; } return contents ; } private final String makeSubstRE ( int i ) { return ( "s/" + perLineREs [ i ] + '/' + perLineREs [ i + 1 ] + "/g" ) ; } public static void main ( String [ ] args ) { if ( args . length > 0 ) { for ( int x = 0 ; x < args . length ; x ++ ) { WebMacro converter = new WebMacro ( ) ; converter . convert ( args [ x ] ) ; } } else { usage ( ) ; } } } 	0	['10', '1', '0', '3', '40', '39', '0', '3', '4', '0.962962963', '470', '1', '0', '0', '0.388888889', '0', '0', '45.7', '8', '2.3', '0']
package org . apache . velocity . runtime . parser ; import java . io . * ; import java . util . * ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . parser . node . * ; import org . apache . velocity . runtime . directive . Directive ; import org . apache . velocity . runtime . directive . Macro ; import org . apache . velocity . runtime . directive . MacroParseException ; import org . apache . velocity . util . StringUtils ; public class Parser implements ParserTreeConstants , ParserConstants { protected JJTParserState jjtree = new JJTParserState ( ) ; private Hashtable directives = new Hashtable ( 0 ) ; String currentTemplateName = "" ; VelocityCharStream velcharstream = null ; private RuntimeServices rsvc = null ; public Parser ( RuntimeServices rs ) { this ( new VelocityCharStream ( new ByteArrayInputStream ( "\n" . getBytes ( ) ) , 1 , 1 ) ) ; velcharstream = new VelocityCharStream ( new ByteArrayInputStream ( "\n" . getBytes ( ) ) , 1 , 1 ) ; rsvc = rs ; } public SimpleNode parse ( Reader reader , String templateName ) throws ParseException { SimpleNode sn = null ; currentTemplateName = templateName ; try { token_source . clearStateVars ( ) ; velcharstream . ReInit ( reader , 1 , 1 ) ; ReInit ( velcharstream ) ; sn = process ( ) ; } catch ( MacroParseException mee ) { rsvc . getLog ( ) . error ( "Parser Error: #macro() : " + templateName , mee ) ; throw mee ; } catch ( ParseException pe ) { rsvc . getLog ( ) . error ( "Parser Exception: " + templateName , pe ) ; throw new TemplateParseException ( pe . currentToken , pe . expectedTokenSequences , pe . tokenImage , currentTemplateName ) ; } catch ( TokenMgrError tme ) { throw new ParseException ( "Lexical error: " + tme . toString ( ) ) ; } catch ( Exception e ) { rsvc . getLog ( ) . error ( "Parser Error: " + templateName , e ) ; } currentTemplateName = "" ; return sn ; } public void setDirectives ( Hashtable directives ) { this . directives = directives ; } public Directive getDirective ( String directive ) { return ( Directive ) directives . get ( directive ) ; } public boolean isDirective ( String directive ) { return directives . containsKey ( directive ) ; } private String escapedDirective ( String strImage ) { int iLast = strImage . lastIndexOf ( "\\" ) ; String strDirective = strImage . substring ( iLast + 1 ) ; boolean bRecognizedDirective = false ; if ( isDirective ( strDirective . substring ( 1 ) ) ) { bRecognizedDirective = true ; } else if ( rsvc . isVelocimacro ( strDirective . substring ( 1 ) , currentTemplateName ) ) { bRecognizedDirective = true ; } else { if ( strDirective . substring ( 1 ) . equals ( "if" ) || strDirective . substring ( 1 ) . equals ( "end" ) || strDirective . substring ( 1 ) . equals ( "set" ) || strDirective . substring ( 1 ) . equals ( "else" ) || strDirective . substring ( 1 ) . equals ( "elseif" ) || strDirective . substring ( 1 ) . equals ( "stop" ) ) { bRecognizedDirective = true ; } } if ( bRecognizedDirective ) return ( strImage . substring ( 0 , iLast / 2 ) + strDirective ) ; else return ( strImage ) ; } final public SimpleNode process ( ) throws ParseException { ASTprocess jjtn000 = new ASTprocess ( this , JJTPROCESS ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { label_1 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LPAREN : case RPAREN : case ESCAPE_DIRECTIVE : case SET_DIRECTIVE : case SINGLE_LINE_COMMENT_START : case DOUBLE_ESCAPE : case ESCAPE : case TEXT : case FORMAL_COMMENT : case MULTI_LINE_COMMENT : case STRING_LITERAL : case IF_DIRECTIVE : case STOP_DIRECTIVE : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case WORD : case BRACKETED_WORD : case IDENTIFIER : case DOT : case LCURLY : case RCURLY : ; break ; default : jj_la1 [ 0 ] = jj_gen ; break label_1 ; } Statement ( ) ; } jj_consume_token ( 0 ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; { if ( true ) return jjtn000 ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } throw new Error ( "Missing return statement in function" ) ; } final public void Statement ( ) throws ParseException { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IF_DIRECTIVE : IfStatement ( ) ; break ; case STOP_DIRECTIVE : StopStatement ( ) ; break ; default : jj_la1 [ 1 ] = jj_gen ; if ( jj_2_1 ( 2 ) ) { Reference ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case SINGLE_LINE_COMMENT_START : case FORMAL_COMMENT : case MULTI_LINE_COMMENT : Comment ( ) ; break ; case SET_DIRECTIVE : SetDirective ( ) ; break ; case ESCAPE_DIRECTIVE : EscapedDirective ( ) ; break ; case DOUBLE_ESCAPE : Escape ( ) ; break ; case WORD : case BRACKETED_WORD : Directive ( ) ; break ; case LPAREN : case RPAREN : case ESCAPE : case TEXT : case STRING_LITERAL : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case DOT : case LCURLY : case RCURLY : Text ( ) ; break ; default : jj_la1 [ 2 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } } final public void EscapedDirective ( ) throws ParseException { ASTEscapedDirective jjtn000 = new ASTEscapedDirective ( this , JJTESCAPEDDIRECTIVE ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { Token t = null ; t = jj_consume_token ( ESCAPE_DIRECTIVE ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; t . image = escapedDirective ( t . image ) ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void Escape ( ) throws ParseException { ASTEscape jjtn000 = new ASTEscape ( this , JJTESCAPE ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { Token t = null ; int count = 0 ; boolean control = false ; label_2 : while ( true ) { t = jj_consume_token ( DOUBLE_ESCAPE ) ; count ++ ; if ( jj_2_2 ( 2 ) ) { ; } else { break label_2 ; } } jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; switch ( t . next . kind ) { case IF_DIRECTIVE : case ELSE_DIRECTIVE : case ELSEIF_DIRECTIVE : case END : case STOP_DIRECTIVE : control = true ; break ; } if ( isDirective ( t . next . image . substring ( 1 ) ) ) control = true ; else if ( rsvc . isVelocimacro ( t . next . image . substring ( 1 ) , currentTemplateName ) ) control = true ; jjtn000 . val = "" ; for ( int i = 0 ; i < count ; i ++ ) jjtn000 . val += ( control ? "\\" : "\\\\" ) ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void Comment ( ) throws ParseException { ASTComment jjtn000 = new ASTComment ( this , JJTCOMMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case SINGLE_LINE_COMMENT_START : jj_consume_token ( SINGLE_LINE_COMMENT_START ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case SINGLE_LINE_COMMENT : jj_consume_token ( SINGLE_LINE_COMMENT ) ; break ; default : jj_la1 [ 3 ] = jj_gen ; ; } break ; case MULTI_LINE_COMMENT : jj_consume_token ( MULTI_LINE_COMMENT ) ; break ; case FORMAL_COMMENT : jj_consume_token ( FORMAL_COMMENT ) ; break ; default : jj_la1 [ 4 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void FloatingPointLiteral ( ) throws ParseException { ASTFloatingPointLiteral jjtn000 = new ASTFloatingPointLiteral ( this , JJTFLOATINGPOINTLITERAL ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( FLOATING_POINT_LITERAL ) ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void IntegerLiteral ( ) throws ParseException { ASTIntegerLiteral jjtn000 = new ASTIntegerLiteral ( this , JJTINTEGERLITERAL ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( INTEGER_LITERAL ) ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void StringLiteral ( ) throws ParseException { ASTStringLiteral jjtn000 = new ASTStringLiteral ( this , JJTSTRINGLITERAL ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( STRING_LITERAL ) ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void Identifier ( ) throws ParseException { ASTIdentifier jjtn000 = new ASTIdentifier ( this , JJTIDENTIFIER ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( IDENTIFIER ) ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void Word ( ) throws ParseException { ASTWord jjtn000 = new ASTWord ( this , JJTWORD ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( WORD ) ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public int DirectiveArg ( ) throws ParseException { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : case LCURLY : Reference ( ) ; { if ( true ) return ParserTreeConstants . JJTREFERENCE ; } break ; case WORD : Word ( ) ; { if ( true ) return ParserTreeConstants . JJTWORD ; } break ; case STRING_LITERAL : StringLiteral ( ) ; { if ( true ) return ParserTreeConstants . JJTSTRINGLITERAL ; } break ; case INTEGER_LITERAL : IntegerLiteral ( ) ; { if ( true ) return ParserTreeConstants . JJTINTEGERLITERAL ; } break ; default : jj_la1 [ 5 ] = jj_gen ; if ( jj_2_3 ( 2147483647 ) ) { IntegerRange ( ) ; { if ( true ) return ParserTreeConstants . JJTINTEGERRANGE ; } } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case FLOATING_POINT_LITERAL : FloatingPointLiteral ( ) ; { if ( true ) return ParserTreeConstants . JJTFLOATINGPOINTLITERAL ; } break ; case LEFT_CURLEY : Map ( ) ; { if ( true ) return ParserTreeConstants . JJTMAP ; } break ; case LBRACKET : ObjectArray ( ) ; { if ( true ) return ParserTreeConstants . JJTOBJECTARRAY ; } break ; case TRUE : True ( ) ; { if ( true ) return ParserTreeConstants . JJTTRUE ; } break ; case FALSE : False ( ) ; { if ( true ) return ParserTreeConstants . JJTFALSE ; } break ; default : jj_la1 [ 6 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } throw new Error ( "Missing return statement in function" ) ; } final public SimpleNode Directive ( ) throws ParseException { ASTDirective jjtn000 = new ASTDirective ( this , JJTDIRECTIVE ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; Token t = null ; int argType ; int argPos = 0 ; Directive d ; int directiveType ; boolean isVM = false ; boolean doItNow = false ; try { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WORD : t = jj_consume_token ( WORD ) ; break ; case BRACKETED_WORD : t = jj_consume_token ( BRACKETED_WORD ) ; break ; default : jj_la1 [ 7 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } String directiveName ; if ( t . kind == ParserConstants . BRACKETED_WORD ) { directiveName = t . image . substring ( 2 , t . image . length ( ) - 1 ) ; } else { directiveName = t . image . substring ( 1 ) ; } d = ( Directive ) directives . get ( directiveName ) ; if ( directiveName . equals ( "macro" ) ) { doItNow = true ; } jjtn000 . setDirectiveName ( directiveName ) ; if ( d == null ) { isVM = rsvc . isVelocimacro ( directiveName , currentTemplateName ) ; if ( ! isVM ) { token_source . stateStackPop ( ) ; token_source . inDirective = false ; { if ( true ) return jjtn000 ; } } directiveType = Directive . LINE ; } else { directiveType = d . getType ( ) ; } token_source . SwitchTo ( DIRECTIVE ) ; argPos = 0 ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 8 ] = jj_gen ; ; } jj_consume_token ( LPAREN ) ; label_3 : while ( true ) { if ( jj_2_4 ( 2 ) ) { ; } else { break label_3 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 9 ] = jj_gen ; ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case COMMA : jj_consume_token ( COMMA ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 10 ] = jj_gen ; ; } break ; default : jj_la1 [ 11 ] = jj_gen ; ; } argType = DirectiveArg ( ) ; if ( argType == ParserTreeConstants . JJTWORD ) { if ( doItNow && argPos == 0 ) { ; } else if ( ( t . image . equals ( "#foreach" ) || t . image . equals ( "#{foreach}" ) ) && argPos == 1 ) { ; } else { { if ( true ) throw new MacroParseException ( "Invalid arg #" + argPos + " in " + ( isVM ? "VM " : "directive " ) + t . image , currentTemplateName , t ) ; } } } else { if ( doItNow && argPos == 0 ) { { if ( true ) throw new MacroParseException ( "Invalid first arg" + " in #macro() directive - must be a" + " word token (no \' or \" surrounding)" , currentTemplateName , t ) ; } } } argPos ++ ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 12 ] = jj_gen ; ; } jj_consume_token ( RPAREN ) ; if ( directiveType == Directive . LINE ) { { if ( true ) return jjtn000 ; } } ASTBlock jjtn001 = new ASTBlock ( this , JJTBLOCK ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; try { label_4 : while ( true ) { Statement ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LPAREN : case RPAREN : case ESCAPE_DIRECTIVE : case SET_DIRECTIVE : case SINGLE_LINE_COMMENT_START : case DOUBLE_ESCAPE : case ESCAPE : case TEXT : case FORMAL_COMMENT : case MULTI_LINE_COMMENT : case STRING_LITERAL : case IF_DIRECTIVE : case STOP_DIRECTIVE : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case WORD : case BRACKETED_WORD : case IDENTIFIER : case DOT : case LCURLY : case RCURLY : ; break ; default : jj_la1 [ 13 ] = jj_gen ; break label_4 ; } } } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , true ) ; } } jj_consume_token ( END ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; if ( doItNow ) { Macro . processAndRegister ( rsvc , t , jjtn000 , currentTemplateName ) ; } { if ( true ) return jjtn000 ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } throw new Error ( "Missing return statement in function" ) ; } final public void Map ( ) throws ParseException { ASTMap jjtn000 = new ASTMap ( this , JJTMAP ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( LEFT_CURLEY ) ; if ( jj_2_5 ( 2 ) ) { Parameter ( ) ; jj_consume_token ( COLON ) ; Parameter ( ) ; label_5 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case COMMA : ; break ; default : jj_la1 [ 14 ] = jj_gen ; break label_5 ; } jj_consume_token ( COMMA ) ; Parameter ( ) ; jj_consume_token ( COLON ) ; Parameter ( ) ; } } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 15 ] = jj_gen ; ; } } jj_consume_token ( RIGHT_CURLEY ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void ObjectArray ( ) throws ParseException { ASTObjectArray jjtn000 = new ASTObjectArray ( this , JJTOBJECTARRAY ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( LBRACKET ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACKET : case LEFT_CURLEY : case WHITESPACE : case STRING_LITERAL : case TRUE : case FALSE : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case IDENTIFIER : case LCURLY : Parameter ( ) ; label_6 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case COMMA : ; break ; default : jj_la1 [ 16 ] = jj_gen ; break label_6 ; } jj_consume_token ( COMMA ) ; Parameter ( ) ; } break ; default : jj_la1 [ 17 ] = jj_gen ; ; } jj_consume_token ( RBRACKET ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void IntegerRange ( ) throws ParseException { ASTIntegerRange jjtn000 = new ASTIntegerRange ( this , JJTINTEGERRANGE ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( LBRACKET ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 18 ] = jj_gen ; ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : case LCURLY : Reference ( ) ; break ; case INTEGER_LITERAL : IntegerLiteral ( ) ; break ; default : jj_la1 [ 19 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 20 ] = jj_gen ; ; } jj_consume_token ( DOUBLEDOT ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 21 ] = jj_gen ; ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : case LCURLY : Reference ( ) ; break ; case INTEGER_LITERAL : IntegerLiteral ( ) ; break ; default : jj_la1 [ 22 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 23 ] = jj_gen ; ; } jj_consume_token ( RBRACKET ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void Parameter ( ) throws ParseException { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 24 ] = jj_gen ; ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case STRING_LITERAL : StringLiteral ( ) ; break ; case INTEGER_LITERAL : IntegerLiteral ( ) ; break ; default : jj_la1 [ 25 ] = jj_gen ; if ( jj_2_6 ( 2147483647 ) ) { IntegerRange ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LEFT_CURLEY : Map ( ) ; break ; case LBRACKET : ObjectArray ( ) ; break ; case TRUE : True ( ) ; break ; case FALSE : False ( ) ; break ; case IDENTIFIER : case LCURLY : Reference ( ) ; break ; case FLOATING_POINT_LITERAL : FloatingPointLiteral ( ) ; break ; default : jj_la1 [ 26 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 27 ] = jj_gen ; ; } } final public void Method ( ) throws ParseException { ASTMethod jjtn000 = new ASTMethod ( this , JJTMETHOD ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { Identifier ( ) ; jj_consume_token ( LPAREN ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACKET : case LEFT_CURLEY : case WHITESPACE : case STRING_LITERAL : case TRUE : case FALSE : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case IDENTIFIER : case LCURLY : Parameter ( ) ; label_7 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case COMMA : ; break ; default : jj_la1 [ 28 ] = jj_gen ; break label_7 ; } jj_consume_token ( COMMA ) ; Parameter ( ) ; } break ; default : jj_la1 [ 29 ] = jj_gen ; ; } jj_consume_token ( REFMOD2_RPAREN ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void Reference ( ) throws ParseException { ASTReference jjtn000 = new ASTReference ( this , JJTREFERENCE ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : jj_consume_token ( IDENTIFIER ) ; label_8 : while ( true ) { if ( jj_2_7 ( 2 ) ) { ; } else { break label_8 ; } jj_consume_token ( DOT ) ; if ( jj_2_8 ( 3 ) ) { Method ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : Identifier ( ) ; break ; default : jj_la1 [ 30 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } break ; case LCURLY : jj_consume_token ( LCURLY ) ; jj_consume_token ( IDENTIFIER ) ; label_9 : while ( true ) { if ( jj_2_9 ( 2 ) ) { ; } else { break label_9 ; } jj_consume_token ( DOT ) ; if ( jj_2_10 ( 3 ) ) { Method ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : Identifier ( ) ; break ; default : jj_la1 [ 31 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } jj_consume_token ( RCURLY ) ; break ; default : jj_la1 [ 32 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void True ( ) throws ParseException { ASTTrue jjtn000 = new ASTTrue ( this , JJTTRUE ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( TRUE ) ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void False ( ) throws ParseException { ASTFalse jjtn000 = new ASTFalse ( this , JJTFALSE ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( FALSE ) ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void Text ( ) throws ParseException { ASTText jjtn000 = new ASTText ( this , JJTTEXT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case TEXT : jj_consume_token ( TEXT ) ; break ; case DOT : jj_consume_token ( DOT ) ; break ; case RPAREN : jj_consume_token ( RPAREN ) ; break ; case LPAREN : jj_consume_token ( LPAREN ) ; break ; case INTEGER_LITERAL : jj_consume_token ( INTEGER_LITERAL ) ; break ; case FLOATING_POINT_LITERAL : jj_consume_token ( FLOATING_POINT_LITERAL ) ; break ; case STRING_LITERAL : jj_consume_token ( STRING_LITERAL ) ; break ; case ESCAPE : jj_consume_token ( ESCAPE ) ; break ; case LCURLY : jj_consume_token ( LCURLY ) ; break ; case RCURLY : jj_consume_token ( RCURLY ) ; break ; default : jj_la1 [ 33 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void IfStatement ( ) throws ParseException { ASTIfStatement jjtn000 = new ASTIfStatement ( this , JJTIFSTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( IF_DIRECTIVE ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 34 ] = jj_gen ; ; } jj_consume_token ( LPAREN ) ; Expression ( ) ; jj_consume_token ( RPAREN ) ; ASTBlock jjtn001 = new ASTBlock ( this , JJTBLOCK ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; try { label_10 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LPAREN : case RPAREN : case ESCAPE_DIRECTIVE : case SET_DIRECTIVE : case SINGLE_LINE_COMMENT_START : case DOUBLE_ESCAPE : case ESCAPE : case TEXT : case FORMAL_COMMENT : case MULTI_LINE_COMMENT : case STRING_LITERAL : case IF_DIRECTIVE : case STOP_DIRECTIVE : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case WORD : case BRACKETED_WORD : case IDENTIFIER : case DOT : case LCURLY : case RCURLY : ; break ; default : jj_la1 [ 35 ] = jj_gen ; break label_10 ; } Statement ( ) ; } } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , true ) ; } } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case ELSEIF_DIRECTIVE : label_11 : while ( true ) { ElseIfStatement ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case ELSEIF_DIRECTIVE : ; break ; default : jj_la1 [ 36 ] = jj_gen ; break label_11 ; } } break ; default : jj_la1 [ 37 ] = jj_gen ; ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case ELSE_DIRECTIVE : ElseStatement ( ) ; break ; default : jj_la1 [ 38 ] = jj_gen ; ; } jj_consume_token ( END ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void ElseStatement ( ) throws ParseException { ASTElseStatement jjtn000 = new ASTElseStatement ( this , JJTELSESTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( ELSE_DIRECTIVE ) ; ASTBlock jjtn001 = new ASTBlock ( this , JJTBLOCK ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; try { label_12 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LPAREN : case RPAREN : case ESCAPE_DIRECTIVE : case SET_DIRECTIVE : case SINGLE_LINE_COMMENT_START : case DOUBLE_ESCAPE : case ESCAPE : case TEXT : case FORMAL_COMMENT : case MULTI_LINE_COMMENT : case STRING_LITERAL : case IF_DIRECTIVE : case STOP_DIRECTIVE : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case WORD : case BRACKETED_WORD : case IDENTIFIER : case DOT : case LCURLY : case RCURLY : ; break ; default : jj_la1 [ 39 ] = jj_gen ; break label_12 ; } Statement ( ) ; } } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , true ) ; } } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void ElseIfStatement ( ) throws ParseException { ASTElseIfStatement jjtn000 = new ASTElseIfStatement ( this , JJTELSEIFSTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( ELSEIF_DIRECTIVE ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 40 ] = jj_gen ; ; } jj_consume_token ( LPAREN ) ; Expression ( ) ; jj_consume_token ( RPAREN ) ; ASTBlock jjtn001 = new ASTBlock ( this , JJTBLOCK ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; try { label_13 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LPAREN : case RPAREN : case ESCAPE_DIRECTIVE : case SET_DIRECTIVE : case SINGLE_LINE_COMMENT_START : case DOUBLE_ESCAPE : case ESCAPE : case TEXT : case FORMAL_COMMENT : case MULTI_LINE_COMMENT : case STRING_LITERAL : case IF_DIRECTIVE : case STOP_DIRECTIVE : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case WORD : case BRACKETED_WORD : case IDENTIFIER : case DOT : case LCURLY : case RCURLY : ; break ; default : jj_la1 [ 41 ] = jj_gen ; break label_13 ; } Statement ( ) ; } } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , true ) ; } } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void SetDirective ( ) throws ParseException { ASTSetDirective jjtn000 = new ASTSetDirective ( this , JJTSETDIRECTIVE ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( SET_DIRECTIVE ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 42 ] = jj_gen ; ; } Reference ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 43 ] = jj_gen ; ; } jj_consume_token ( EQUALS ) ; Expression ( ) ; jj_consume_token ( RPAREN ) ; token_source . inSet = false ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case NEWLINE : jj_consume_token ( NEWLINE ) ; break ; default : jj_la1 [ 44 ] = jj_gen ; ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void StopStatement ( ) throws ParseException { ASTStop jjtn000 = new ASTStop ( this , JJTSTOP ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( STOP_DIRECTIVE ) ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , 0 ) ; } } } final public void Expression ( ) throws ParseException { ASTExpression jjtn000 = new ASTExpression ( this , JJTEXPRESSION ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { ConditionalOrExpression ( ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void Assignment ( ) throws ParseException { ASTAssignment jjtn000 = new ASTAssignment ( this , JJTASSIGNMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { PrimaryExpression ( ) ; jj_consume_token ( EQUALS ) ; Expression ( ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , 2 ) ; } } } final public void ConditionalOrExpression ( ) throws ParseException { ConditionalAndExpression ( ) ; label_14 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LOGICAL_OR : ; break ; default : jj_la1 [ 45 ] = jj_gen ; break label_14 ; } jj_consume_token ( LOGICAL_OR ) ; ASTOrNode jjtn001 = new ASTOrNode ( this , JJTORNODE ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; try { ConditionalAndExpression ( ) ; } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; } } } } final public void ConditionalAndExpression ( ) throws ParseException { EqualityExpression ( ) ; label_15 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LOGICAL_AND : ; break ; default : jj_la1 [ 46 ] = jj_gen ; break label_15 ; } jj_consume_token ( LOGICAL_AND ) ; ASTAndNode jjtn001 = new ASTAndNode ( this , JJTANDNODE ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; try { EqualityExpression ( ) ; } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; } } } } final public void EqualityExpression ( ) throws ParseException { RelationalExpression ( ) ; label_16 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LOGICAL_EQUALS : case LOGICAL_NOT_EQUALS : ; break ; default : jj_la1 [ 47 ] = jj_gen ; break label_16 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LOGICAL_EQUALS : jj_consume_token ( LOGICAL_EQUALS ) ; ASTEQNode jjtn001 = new ASTEQNode ( this , JJTEQNODE ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; try { RelationalExpression ( ) ; } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; } } break ; case LOGICAL_NOT_EQUALS : jj_consume_token ( LOGICAL_NOT_EQUALS ) ; ASTNENode jjtn002 = new ASTNENode ( this , JJTNENODE ) ; boolean jjtc002 = true ; jjtree . openNodeScope ( jjtn002 ) ; try { RelationalExpression ( ) ; } catch ( Throwable jjte002 ) { if ( jjtc002 ) { jjtree . clearNodeScope ( jjtn002 ) ; jjtc002 = false ; } else { jjtree . popNode ( ) ; } if ( jjte002 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte002 ; } } if ( jjte002 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte002 ; } } { if ( true ) throw ( Error ) jjte002 ; } } finally { if ( jjtc002 ) { jjtree . closeNodeScope ( jjtn002 , 2 ) ; } } break ; default : jj_la1 [ 48 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void RelationalExpression ( ) throws ParseException { AdditiveExpression ( ) ; label_17 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LOGICAL_LT : case LOGICAL_LE : case LOGICAL_GT : case LOGICAL_GE : ; break ; default : jj_la1 [ 49 ] = jj_gen ; break label_17 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LOGICAL_LT : jj_consume_token ( LOGICAL_LT ) ; ASTLTNode jjtn001 = new ASTLTNode ( this , JJTLTNODE ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; try { AdditiveExpression ( ) ; } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; } } break ; case LOGICAL_GT : jj_consume_token ( LOGICAL_GT ) ; ASTGTNode jjtn002 = new ASTGTNode ( this , JJTGTNODE ) ; boolean jjtc002 = true ; jjtree . openNodeScope ( jjtn002 ) ; try { AdditiveExpression ( ) ; } catch ( Throwable jjte002 ) { if ( jjtc002 ) { jjtree . clearNodeScope ( jjtn002 ) ; jjtc002 = false ; } else { jjtree . popNode ( ) ; } if ( jjte002 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte002 ; } } if ( jjte002 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte002 ; } } { if ( true ) throw ( Error ) jjte002 ; } } finally { if ( jjtc002 ) { jjtree . closeNodeScope ( jjtn002 , 2 ) ; } } break ; case LOGICAL_LE : jj_consume_token ( LOGICAL_LE ) ; ASTLENode jjtn003 = new ASTLENode ( this , JJTLENODE ) ; boolean jjtc003 = true ; jjtree . openNodeScope ( jjtn003 ) ; try { AdditiveExpression ( ) ; } catch ( Throwable jjte003 ) { if ( jjtc003 ) { jjtree . clearNodeScope ( jjtn003 ) ; jjtc003 = false ; } else { jjtree . popNode ( ) ; } if ( jjte003 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte003 ; } } if ( jjte003 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte003 ; } } { if ( true ) throw ( Error ) jjte003 ; } } finally { if ( jjtc003 ) { jjtree . closeNodeScope ( jjtn003 , 2 ) ; } } break ; case LOGICAL_GE : jj_consume_token ( LOGICAL_GE ) ; ASTGENode jjtn004 = new ASTGENode ( this , JJTGENODE ) ; boolean jjtc004 = true ; jjtree . openNodeScope ( jjtn004 ) ; try { AdditiveExpression ( ) ; } catch ( Throwable jjte004 ) { if ( jjtc004 ) { jjtree . clearNodeScope ( jjtn004 ) ; jjtc004 = false ; } else { jjtree . popNode ( ) ; } if ( jjte004 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte004 ; } } if ( jjte004 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte004 ; } } { if ( true ) throw ( Error ) jjte004 ; } } finally { if ( jjtc004 ) { jjtree . closeNodeScope ( jjtn004 , 2 ) ; } } break ; default : jj_la1 [ 50 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void AdditiveExpression ( ) throws ParseException { MultiplicativeExpression ( ) ; label_18 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case MINUS : case PLUS : ; break ; default : jj_la1 [ 51 ] = jj_gen ; break label_18 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case PLUS : jj_consume_token ( PLUS ) ; ASTAddNode jjtn001 = new ASTAddNode ( this , JJTADDNODE ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; try { MultiplicativeExpression ( ) ; } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; } } break ; case MINUS : jj_consume_token ( MINUS ) ; ASTSubtractNode jjtn002 = new ASTSubtractNode ( this , JJTSUBTRACTNODE ) ; boolean jjtc002 = true ; jjtree . openNodeScope ( jjtn002 ) ; try { MultiplicativeExpression ( ) ; } catch ( Throwable jjte002 ) { if ( jjtc002 ) { jjtree . clearNodeScope ( jjtn002 ) ; jjtc002 = false ; } else { jjtree . popNode ( ) ; } if ( jjte002 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte002 ; } } if ( jjte002 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte002 ; } } { if ( true ) throw ( Error ) jjte002 ; } } finally { if ( jjtc002 ) { jjtree . closeNodeScope ( jjtn002 , 2 ) ; } } break ; default : jj_la1 [ 52 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void MultiplicativeExpression ( ) throws ParseException { UnaryExpression ( ) ; label_19 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case MULTIPLY : case DIVIDE : case MODULUS : ; break ; default : jj_la1 [ 53 ] = jj_gen ; break label_19 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case MULTIPLY : jj_consume_token ( MULTIPLY ) ; ASTMulNode jjtn001 = new ASTMulNode ( this , JJTMULNODE ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; try { UnaryExpression ( ) ; } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; } } break ; case DIVIDE : jj_consume_token ( DIVIDE ) ; ASTDivNode jjtn002 = new ASTDivNode ( this , JJTDIVNODE ) ; boolean jjtc002 = true ; jjtree . openNodeScope ( jjtn002 ) ; try { UnaryExpression ( ) ; } catch ( Throwable jjte002 ) { if ( jjtc002 ) { jjtree . clearNodeScope ( jjtn002 ) ; jjtc002 = false ; } else { jjtree . popNode ( ) ; } if ( jjte002 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte002 ; } } if ( jjte002 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte002 ; } } { if ( true ) throw ( Error ) jjte002 ; } } finally { if ( jjtc002 ) { jjtree . closeNodeScope ( jjtn002 , 2 ) ; } } break ; case MODULUS : jj_consume_token ( MODULUS ) ; ASTModNode jjtn003 = new ASTModNode ( this , JJTMODNODE ) ; boolean jjtc003 = true ; jjtree . openNodeScope ( jjtn003 ) ; try { UnaryExpression ( ) ; } catch ( Throwable jjte003 ) { if ( jjtc003 ) { jjtree . clearNodeScope ( jjtn003 ) ; jjtc003 = false ; } else { jjtree . popNode ( ) ; } if ( jjte003 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte003 ; } } if ( jjte003 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte003 ; } } { if ( true ) throw ( Error ) jjte003 ; } } finally { if ( jjtc003 ) { jjtree . closeNodeScope ( jjtn003 , 2 ) ; } } break ; default : jj_la1 [ 54 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void UnaryExpression ( ) throws ParseException { if ( jj_2_11 ( 2 ) ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 55 ] = jj_gen ; ; } jj_consume_token ( LOGICAL_NOT ) ; ASTNotNode jjtn001 = new ASTNotNode ( this , JJTNOTNODE ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; try { UnaryExpression ( ) ; } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 1 ) ; } } } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACKET : case LEFT_CURLEY : case LPAREN : case WHITESPACE : case STRING_LITERAL : case TRUE : case FALSE : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case IDENTIFIER : case LCURLY : PrimaryExpression ( ) ; break ; default : jj_la1 [ 56 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void PrimaryExpression ( ) throws ParseException { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 57 ] = jj_gen ; ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case STRING_LITERAL : StringLiteral ( ) ; break ; case IDENTIFIER : case LCURLY : Reference ( ) ; break ; case INTEGER_LITERAL : IntegerLiteral ( ) ; break ; default : jj_la1 [ 58 ] = jj_gen ; if ( jj_2_12 ( 2147483647 ) ) { IntegerRange ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case FLOATING_POINT_LITERAL : FloatingPointLiteral ( ) ; break ; case LEFT_CURLEY : Map ( ) ; break ; case LBRACKET : ObjectArray ( ) ; break ; case TRUE : True ( ) ; break ; case FALSE : False ( ) ; break ; case LPAREN : jj_consume_token ( LPAREN ) ; Expression ( ) ; jj_consume_token ( RPAREN ) ; break ; default : jj_la1 [ 59 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 60 ] = jj_gen ; ; } } final private boolean jj_2_1 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; try { return ! jj_3_1 ( ) ; } catch ( LookaheadSuccess ls ) { return true ; } finally { jj_save ( 0 , xla ) ; } } final private boolean jj_2_2 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; try { return ! jj_3_2 ( ) ; } catch ( LookaheadSuccess ls ) { return true ; } finally { jj_save ( 1 , xla ) ; } } final private boolean jj_2_3 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; try { return ! jj_3_3 ( ) ; } catch ( LookaheadSuccess ls ) { return true ; } finally { jj_save ( 2 , xla ) ; } } final private boolean jj_2_4 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; try { return ! jj_3_4 ( ) ; } catch ( LookaheadSuccess ls ) { return true ; } finally { jj_save ( 3 , xla ) ; } } final private boolean jj_2_5 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; try { return ! jj_3_5 ( ) ; } catch ( LookaheadSuccess ls ) { return true ; } finally { jj_save ( 4 , xla ) ; } } final private boolean jj_2_6 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; try { return ! jj_3_6 ( ) ; } catch ( LookaheadSuccess ls ) { return true ; } finally { jj_save ( 5 , xla ) ; } } final private boolean jj_2_7 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; try { return ! jj_3_7 ( ) ; } catch ( LookaheadSuccess ls ) { return true ; } finally { jj_save ( 6 , xla ) ; } } final private boolean jj_2_8 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; try { return ! jj_3_8 ( ) ; } catch ( LookaheadSuccess ls ) { return true ; } finally { jj_save ( 7 , xla ) ; } } final private boolean jj_2_9 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; try { return ! jj_3_9 ( ) ; } catch ( LookaheadSuccess ls ) { return true ; } finally { jj_save ( 8 , xla ) ; } } final private boolean jj_2_10 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; try { return ! jj_3_10 ( ) ; } catch ( LookaheadSuccess ls ) { return true ; } finally { jj_save ( 9 , xla ) ; } } final private boolean jj_2_11 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; try { return ! jj_3_11 ( ) ; } catch ( LookaheadSuccess ls ) { return true ; } finally { jj_save ( 10 , xla ) ; } } final private boolean jj_2_12 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; try { return ! jj_3_12 ( ) ; } catch ( LookaheadSuccess ls ) { return true ; } finally { jj_save ( 11 , xla ) ; } } final private boolean jj_3R_82 ( ) { if ( jj_scan_token ( COMMA ) ) return true ; if ( jj_3R_25 ( ) ) return true ; return false ; } final private boolean jj_3_8 ( ) { if ( jj_3R_29 ( ) ) return true ; return false ; } final private boolean jj_3R_26 ( ) { if ( jj_3R_20 ( ) ) return true ; return false ; } final private boolean jj_3R_66 ( ) { if ( jj_scan_token ( FALSE ) ) return true ; return false ; } final private boolean jj_3R_65 ( ) { if ( jj_scan_token ( TRUE ) ) return true ; return false ; } final private boolean jj_3_9 ( ) { if ( jj_scan_token ( DOT ) ) return true ; Token xsp ; xsp = jj_scanpos ; if ( jj_3_10 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_30 ( ) ) return true ; } return false ; } final private boolean jj_3R_57 ( ) { if ( jj_3R_25 ( ) ) return true ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_82 ( ) ) { jj_scanpos = xsp ; break ; } } return false ; } final private boolean jj_3_7 ( ) { if ( jj_scan_token ( DOT ) ) return true ; Token xsp ; xsp = jj_scanpos ; if ( jj_3_8 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_28 ( ) ) return true ; } return false ; } final private boolean jj_3_2 ( ) { if ( jj_scan_token ( DOUBLE_ESCAPE ) ) return true ; return false ; } final private boolean jj_3R_35 ( ) { if ( jj_scan_token ( LCURLY ) ) return true ; if ( jj_scan_token ( IDENTIFIER ) ) return true ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3_9 ( ) ) { jj_scanpos = xsp ; break ; } } if ( jj_scan_token ( RCURLY ) ) return true ; return false ; } final private boolean jj_3_12 ( ) { if ( jj_scan_token ( LBRACKET ) ) return true ; Token xsp ; xsp = jj_scanpos ; if ( jj_scan_token ( 26 ) ) jj_scanpos = xsp ; xsp = jj_scanpos ; if ( jj_3R_32 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_33 ( ) ) return true ; } xsp = jj_scanpos ; if ( jj_scan_token ( 26 ) ) jj_scanpos = xsp ; if ( jj_scan_token ( DOUBLEDOT ) ) return true ; return false ; } final private boolean jj_3R_34 ( ) { if ( jj_scan_token ( IDENTIFIER ) ) return true ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3_7 ( ) ) { jj_scanpos = xsp ; break ; } } return false ; } final private boolean jj_3R_81 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; return false ; } final private boolean jj_3R_80 ( ) { if ( jj_3R_66 ( ) ) return true ; return false ; } final private boolean jj_3R_79 ( ) { if ( jj_3R_65 ( ) ) return true ; return false ; } final private boolean jj_3R_20 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_34 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_35 ( ) ) return true ; } return false ; } final private boolean jj_3R_78 ( ) { if ( jj_3R_64 ( ) ) return true ; return false ; } final private boolean jj_3R_77 ( ) { if ( jj_3R_63 ( ) ) return true ; return false ; } final private boolean jj_3R_76 ( ) { if ( jj_3R_62 ( ) ) return true ; return false ; } final private boolean jj_3R_75 ( ) { if ( jj_3R_61 ( ) ) return true ; return false ; } final private boolean jj_3R_74 ( ) { if ( jj_3R_36 ( ) ) return true ; return false ; } final private boolean jj_3R_73 ( ) { if ( jj_3R_20 ( ) ) return true ; return false ; } final private boolean jj_3_6 ( ) { if ( jj_scan_token ( LBRACKET ) ) return true ; Token xsp ; xsp = jj_scanpos ; if ( jj_scan_token ( 26 ) ) jj_scanpos = xsp ; xsp = jj_scanpos ; if ( jj_3R_26 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_27 ( ) ) return true ; } xsp = jj_scanpos ; if ( jj_scan_token ( 26 ) ) jj_scanpos = xsp ; if ( jj_scan_token ( DOUBLEDOT ) ) return true ; return false ; } final private boolean jj_3R_29 ( ) { if ( jj_3R_56 ( ) ) return true ; if ( jj_scan_token ( LPAREN ) ) return true ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_57 ( ) ) jj_scanpos = xsp ; if ( jj_scan_token ( REFMOD2_RPAREN ) ) return true ; return false ; } final private boolean jj_3R_72 ( ) { if ( jj_3R_60 ( ) ) return true ; return false ; } final private boolean jj_3R_67 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_scan_token ( 26 ) ) jj_scanpos = xsp ; xsp = jj_scanpos ; if ( jj_3R_72 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_73 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_74 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_75 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_76 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_77 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_78 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_79 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_80 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_81 ( ) ) return true ; } } } } } } } } } return false ; } final private boolean jj_3R_55 ( ) { if ( jj_3R_62 ( ) ) return true ; return false ; } final private boolean jj_3R_54 ( ) { if ( jj_3R_20 ( ) ) return true ; return false ; } final private boolean jj_3R_53 ( ) { if ( jj_3R_66 ( ) ) return true ; return false ; } final private boolean jj_3R_85 ( ) { if ( jj_scan_token ( COMMA ) ) return true ; if ( jj_3R_25 ( ) ) return true ; if ( jj_scan_token ( COLON ) ) return true ; if ( jj_3R_25 ( ) ) return true ; return false ; } final private boolean jj_3R_52 ( ) { if ( jj_3R_65 ( ) ) return true ; return false ; } final private boolean jj_3R_31 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3_11 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_58 ( ) ) return true ; } return false ; } final private boolean jj_3_11 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_scan_token ( 26 ) ) jj_scanpos = xsp ; if ( jj_scan_token ( LOGICAL_NOT ) ) return true ; if ( jj_3R_31 ( ) ) return true ; return false ; } final private boolean jj_3R_58 ( ) { if ( jj_3R_67 ( ) ) return true ; return false ; } final private boolean jj_3R_51 ( ) { if ( jj_3R_64 ( ) ) return true ; return false ; } final private boolean jj_3R_50 ( ) { if ( jj_3R_63 ( ) ) return true ; return false ; } final private boolean jj_3R_49 ( ) { if ( jj_3R_61 ( ) ) return true ; return false ; } final private boolean jj_3R_48 ( ) { if ( jj_3R_36 ( ) ) return true ; return false ; } final private boolean jj_3R_47 ( ) { if ( jj_3R_60 ( ) ) return true ; return false ; } final private boolean jj_3R_22 ( ) { if ( jj_3R_36 ( ) ) return true ; return false ; } final private boolean jj_3R_84 ( ) { if ( jj_3R_36 ( ) ) return true ; return false ; } final private boolean jj_3R_69 ( ) { if ( jj_3R_36 ( ) ) return true ; return false ; } final private boolean jj_3R_86 ( ) { if ( jj_scan_token ( COMMA ) ) return true ; if ( jj_3R_25 ( ) ) return true ; return false ; } final private boolean jj_3R_25 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_scan_token ( 26 ) ) jj_scanpos = xsp ; xsp = jj_scanpos ; if ( jj_3R_47 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_48 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_49 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_50 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_51 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_52 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_53 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_54 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_55 ( ) ) return true ; } } } } } } } } xsp = jj_scanpos ; if ( jj_scan_token ( 26 ) ) jj_scanpos = xsp ; return false ; } final private boolean jj_3_1 ( ) { if ( jj_3R_20 ( ) ) return true ; return false ; } final private boolean jj_3R_21 ( ) { if ( jj_3R_20 ( ) ) return true ; return false ; } final private boolean jj_3R_83 ( ) { if ( jj_3R_20 ( ) ) return true ; return false ; } final private boolean jj_3R_68 ( ) { if ( jj_3R_20 ( ) ) return true ; return false ; } final private boolean jj_3R_71 ( ) { if ( jj_3R_25 ( ) ) return true ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_86 ( ) ) { jj_scanpos = xsp ; break ; } } return false ; } final private boolean jj_3R_61 ( ) { if ( jj_scan_token ( LBRACKET ) ) return true ; Token xsp ; xsp = jj_scanpos ; if ( jj_scan_token ( 26 ) ) jj_scanpos = xsp ; xsp = jj_scanpos ; if ( jj_3R_68 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_69 ( ) ) return true ; } xsp = jj_scanpos ; if ( jj_scan_token ( 26 ) ) jj_scanpos = xsp ; if ( jj_scan_token ( DOUBLEDOT ) ) return true ; xsp = jj_scanpos ; if ( jj_scan_token ( 26 ) ) jj_scanpos = xsp ; xsp = jj_scanpos ; if ( jj_3R_83 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_84 ( ) ) return true ; } xsp = jj_scanpos ; if ( jj_scan_token ( 26 ) ) jj_scanpos = xsp ; if ( jj_scan_token ( RBRACKET ) ) return true ; return false ; } final private boolean jj_3R_64 ( ) { if ( jj_scan_token ( LBRACKET ) ) return true ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_71 ( ) ) jj_scanpos = xsp ; if ( jj_scan_token ( RBRACKET ) ) return true ; return false ; } final private boolean jj_3R_46 ( ) { if ( jj_3R_66 ( ) ) return true ; return false ; } final private boolean jj_3R_70 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_scan_token ( 26 ) ) jj_scanpos = xsp ; return false ; } final private boolean jj_3_5 ( ) { if ( jj_3R_25 ( ) ) return true ; if ( jj_scan_token ( COLON ) ) return true ; if ( jj_3R_25 ( ) ) return true ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_85 ( ) ) { jj_scanpos = xsp ; break ; } } return false ; } final private boolean jj_3R_45 ( ) { if ( jj_3R_65 ( ) ) return true ; return false ; } final private boolean jj_3R_63 ( ) { if ( jj_scan_token ( LEFT_CURLEY ) ) return true ; Token xsp ; xsp = jj_scanpos ; if ( jj_3_5 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_70 ( ) ) return true ; } if ( jj_scan_token ( RIGHT_CURLEY ) ) return true ; return false ; } final private boolean jj_3_3 ( ) { if ( jj_scan_token ( LBRACKET ) ) return true ; Token xsp ; xsp = jj_scanpos ; if ( jj_scan_token ( 26 ) ) jj_scanpos = xsp ; xsp = jj_scanpos ; if ( jj_3R_21 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_22 ( ) ) return true ; } xsp = jj_scanpos ; if ( jj_scan_token ( 26 ) ) jj_scanpos = xsp ; if ( jj_scan_token ( DOUBLEDOT ) ) return true ; return false ; } final private boolean jj_3R_44 ( ) { if ( jj_3R_64 ( ) ) return true ; return false ; } final private boolean jj_3R_43 ( ) { if ( jj_3R_63 ( ) ) return true ; return false ; } final private boolean jj_3R_42 ( ) { if ( jj_3R_62 ( ) ) return true ; return false ; } final private boolean jj_3R_41 ( ) { if ( jj_3R_61 ( ) ) return true ; return false ; } final private boolean jj_3R_40 ( ) { if ( jj_3R_36 ( ) ) return true ; return false ; } final private boolean jj_3R_39 ( ) { if ( jj_3R_60 ( ) ) return true ; return false ; } final private boolean jj_3R_23 ( ) { if ( jj_scan_token ( COMMA ) ) return true ; Token xsp ; xsp = jj_scanpos ; if ( jj_scan_token ( 26 ) ) jj_scanpos = xsp ; return false ; } final private boolean jj_3R_38 ( ) { if ( jj_3R_59 ( ) ) return true ; return false ; } final private boolean jj_3R_37 ( ) { if ( jj_3R_20 ( ) ) return true ; return false ; } final private boolean jj_3R_24 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_37 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_38 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_39 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_40 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_41 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_42 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_43 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_44 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_45 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_46 ( ) ) return true ; } } } } } } } } } return false ; } final private boolean jj_3R_59 ( ) { if ( jj_scan_token ( WORD ) ) return true ; return false ; } final private boolean jj_3R_56 ( ) { if ( jj_scan_token ( IDENTIFIER ) ) return true ; return false ; } final private boolean jj_3_4 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_scan_token ( 26 ) ) jj_scanpos = xsp ; xsp = jj_scanpos ; if ( jj_3R_23 ( ) ) jj_scanpos = xsp ; if ( jj_3R_24 ( ) ) return true ; return false ; } final private boolean jj_3R_60 ( ) { if ( jj_scan_token ( STRING_LITERAL ) ) return true ; return false ; } final private boolean jj_3R_30 ( ) { if ( jj_3R_56 ( ) ) return true ; return false ; } final private boolean jj_3R_36 ( ) { if ( jj_scan_token ( INTEGER_LITERAL ) ) return true ; return false ; } final private boolean jj_3R_28 ( ) { if ( jj_3R_56 ( ) ) return true ; return false ; } final private boolean jj_3R_62 ( ) { if ( jj_scan_token ( FLOATING_POINT_LITERAL ) ) return true ; return false ; } final private boolean jj_3R_33 ( ) { if ( jj_3R_36 ( ) ) return true ; return false ; } final private boolean jj_3R_32 ( ) { if ( jj_3R_20 ( ) ) return true ; return false ; } final private boolean jj_3R_27 ( ) { if ( jj_3R_36 ( ) ) return true ; return false ; } final private boolean jj_3_10 ( ) { if ( jj_3R_29 ( ) ) return true ; return false ; } public ParserTokenManager token_source ; public Token token , jj_nt ; private int jj_ntk ; private Token jj_scanpos , jj_lastpos ; private int jj_la ; public boolean lookingAhead = false ; private boolean jj_semLA ; private int jj_gen ; final private int [ ] jj_la1 = new int [ 61 ] ; static private int [ ] jj_la1_0 ; static private int [ ] jj_la1_1 ; static private int [ ] jj_la1_2 ; static { jj_la1_0 ( ) ; jj_la1_1 ( ) ; jj_la1_2 ( ) ; } private static void jj_la1_0 ( ) { jj_la1_0 = new int [ ] { 0x9bc1b00 , 0x0 , 0x9bc1b00 , 0x400000 , 0x1840000 , 0x8000000 , 0x30000042 , 0x0 , 0x4000000 , 0x4000000 , 0x4000000 , 0x8 , 0x4000000 , 0x9bc1b00 , 0x8 , 0x4000000 , 0x8 , 0x3c000042 , 0x4000000 , 0x0 , 0x4000000 , 0x4000000 , 0x0 , 0x4000000 , 0x4000000 , 0x8000000 , 0x30000042 , 0x4000000 , 0x8 , 0x3c000042 , 0x0 , 0x0 , 0x0 , 0x8300300 , 0x4000000 , 0x9bc1b00 , 0x0 , 0x0 , 0x0 , 0x9bc1b00 , 0x4000000 , 0x9bc1b00 , 0x4000000 , 0x4000000 , 0x40000000 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x80000000 , 0x80000000 , 0x0 , 0x0 , 0x4000000 , 0x3c000142 , 0x4000000 , 0x8000000 , 0x30000142 , 0x4000000 , } ; } private static void jj_la1_1 ( ) { jj_la1_1 = new int [ ] { 0xc6348000 , 0x48000 , 0x86300000 , 0x0 , 0x0 , 0x42100000 , 0x200000 , 0x6000000 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0xc6348000 , 0x0 , 0x0 , 0x0 , 0x40300000 , 0x0 , 0x40100000 , 0x0 , 0x0 , 0x40100000 , 0x0 , 0x0 , 0x100000 , 0x40200000 , 0x0 , 0x0 , 0x40300000 , 0x40000000 , 0x40000000 , 0x40000000 , 0x80300000 , 0x0 , 0xc6348000 , 0x10000 , 0x10000 , 0x20000 , 0xc6348000 , 0x0 , 0xc6348000 , 0x0 , 0x0 , 0x0 , 0x20 , 0x10 , 0xc00 , 0xc00 , 0x3c0 , 0x3c0 , 0x1 , 0x1 , 0xe , 0xe , 0x0 , 0x40300000 , 0x0 , 0x40100000 , 0x200000 , 0x0 , } ; } private static void jj_la1_2 ( ) { jj_la1_2 = new int [ ] { 0x3 , 0x0 , 0x3 , 0x0 , 0x0 , 0x1 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x3 , 0x0 , 0x0 , 0x0 , 0x1 , 0x0 , 0x1 , 0x0 , 0x0 , 0x1 , 0x0 , 0x0 , 0x0 , 0x1 , 0x0 , 0x0 , 0x1 , 0x0 , 0x0 , 0x1 , 0x3 , 0x0 , 0x3 , 0x0 , 0x0 , 0x0 , 0x3 , 0x0 , 0x3 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x1 , 0x0 , 0x1 , 0x0 , 0x0 , } ; } final private JJCalls [ ] jj_2_rtns = new JJCalls [ 12 ] ; private boolean jj_rescan = false ; private int jj_gc = 0 ; public Parser ( CharStream stream ) { token_source = new ParserTokenManager ( stream ) ; token = new Token ( ) ; jj_ntk = - 1 ; jj_gen = 0 ; for ( int i = 0 ; i < 61 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; } public void ReInit ( CharStream stream ) { token_source . ReInit ( stream ) ; token = new Token ( ) ; jj_ntk = - 1 ; jjtree . reset ( ) ; jj_gen = 0 ; for ( int i = 0 ; i < 61 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; } public Parser ( ParserTokenManager tm ) { token_source = tm ; token = new Token ( ) ; jj_ntk = - 1 ; jj_gen = 0 ; for ( int i = 0 ; i < 61 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; } public void ReInit ( ParserTokenManager tm ) { token_source = tm ; token = new Token ( ) ; jj_ntk = - 1 ; jjtree . reset ( ) ; jj_gen = 0 ; for ( int i = 0 ; i < 61 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; } final private Token jj_consume_token ( int kind ) throws ParseException { Token oldToken ; if ( ( oldToken = token ) . next != null ) token = token . next ; else token = token . next = token_source . getNextToken ( ) ; jj_ntk = - 1 ; if ( token . kind == kind ) { jj_gen ++ ; if ( ++ jj_gc > 100 ) { jj_gc = 0 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) { JJCalls c = jj_2_rtns [ i ] ; while ( c != null ) { if ( c . gen < jj_gen ) c . first = null ; c = c . next ; } } } return token ; } token = oldToken ; jj_kind = kind ; throw generateParseException ( ) ; } static private final class LookaheadSuccess extends java . lang . Error { } final private LookaheadSuccess jj_ls = new LookaheadSuccess ( ) ; final private boolean jj_scan_token ( int kind ) { if ( jj_scanpos == jj_lastpos ) { jj_la -- ; if ( jj_scanpos . next == null ) { jj_lastpos = jj_scanpos = jj_scanpos . next = token_source . getNextToken ( ) ; } else { jj_lastpos = jj_scanpos = jj_scanpos . next ; } } else { jj_scanpos = jj_scanpos . next ; } if ( jj_rescan ) { int i = 0 ; Token tok = token ; while ( tok != null && tok != jj_scanpos ) { i ++ ; tok = tok . next ; } if ( tok != null ) jj_add_error_token ( kind , i ) ; } if ( jj_scanpos . kind != kind ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) throw jj_ls ; return false ; } final public Token getNextToken ( ) { if ( token . next != null ) token = token . next ; else token = token . next = token_source . getNextToken ( ) ; jj_ntk = - 1 ; jj_gen ++ ; return token ; } final public Token getToken ( int index ) { Token t = lookingAhead ? jj_scanpos : token ; for ( int i = 0 ; i < index ; i ++ ) { if ( t . next != null ) t = t . next ; else t = t . next = token_source . getNextToken ( ) ; } return t ; } final private int jj_ntk ( ) { if ( ( jj_nt = token . next ) == null ) return ( jj_ntk = ( token . next = token_source . getNextToken ( ) ) . kind ) ; else return ( jj_ntk = jj_nt . kind ) ; } private java . util . Vector jj_expentries = new java . util . Vector ( ) ; private int [ ] jj_expentry ; private int jj_kind = - 1 ; private int [ ] jj_lasttokens = new int [ 100 ] ; private int jj_endpos ; private void jj_add_error_token ( int kind , int pos ) { if ( pos >= 100 ) return ; if ( pos == jj_endpos + 1 ) { jj_lasttokens [ jj_endpos ++ ] = kind ; } else if ( jj_endpos != 0 ) { jj_expentry = new int [ jj_endpos ] ; for ( int i = 0 ; i < jj_endpos ; i ++ ) { jj_expentry [ i ] = jj_lasttokens [ i ] ; } boolean exists = false ; for ( java . util . Enumeration e = jj_expentries . elements ( ) ; e . hasMoreElements ( ) ; ) { int [ ] oldentry = ( int [ ] ) ( e . nextElement ( ) ) ; if ( oldentry . length == jj_expentry . length ) { exists = true ; for ( int i = 0 ; i < jj_expentry . length ; i ++ ) { if ( oldentry [ i ] != jj_expentry [ i ] ) { exists = false ; break ; } } if ( exists ) break ; } } if ( ! exists ) jj_expentries . addElement ( jj_expentry ) ; if ( pos != 0 ) jj_lasttokens [ ( jj_endpos = pos ) - 1 ] = kind ; } } public ParseException generateParseException ( ) { jj_expentries . removeAllElements ( ) ; boolean [ ] la1tokens = new boolean [ 68 ] ; for ( int i = 0 ; i < 68 ; i ++ ) { la1tokens [ i ] = false ; } if ( jj_kind >= 0 ) { la1tokens [ jj_kind ] = true ; jj_kind = - 1 ; } for ( int i = 0 ; i < 61 ; i ++ ) { if ( jj_la1 [ i ] == jj_gen ) { for ( int j = 0 ; j < 32 ; j ++ ) { if ( ( jj_la1_0 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ j ] = true ; } if ( ( jj_la1_1 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ 32 + j ] = true ; } if ( ( jj_la1_2 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ 64 + j ] = true ; } } } } for ( int i = 0 ; i < 68 ; i ++ ) { if ( la1tokens [ i ] ) { jj_expentry = new int [ 1 ] ; jj_expentry [ 0 ] = i ; jj_expentries . addElement ( jj_expentry ) ; } } jj_endpos = 0 ; jj_rescan_token ( ) ; jj_add_error_token ( 0 , 0 ) ; int [ ] [ ] exptokseq = new int [ jj_expentries . size ( ) ] [ ] ; for ( int i = 0 ; i < jj_expentries . size ( ) ; i ++ ) { exptokseq [ i ] = ( int [ ] ) jj_expentries . elementAt ( i ) ; } return new ParseException ( token , exptokseq , tokenImage ) ; } final public void enable_tracing ( ) { } final public void disable_tracing ( ) { } final private void jj_rescan_token ( ) { jj_rescan = true ; for ( int i = 0 ; i < 12 ; i ++ ) { try { JJCalls p = jj_2_rtns [ i ] ; do { if ( p . gen > jj_gen ) { jj_la = p . arg ; jj_lastpos = jj_scanpos = p . first ; switch ( i ) { case 0 : jj_3_1 ( ) ; break ; case 1 : jj_3_2 ( ) ; break ; case 2 : jj_3_3 ( ) ; break ; case 3 : jj_3_4 ( ) ; break ; case 4 : jj_3_5 ( ) ; break ; case 5 : jj_3_6 ( ) ; break ; case 6 : jj_3_7 ( ) ; break ; case 7 : jj_3_8 ( ) ; break ; case 8 : jj_3_9 ( ) ; break ; case 9 : jj_3_10 ( ) ; break ; case 10 : jj_3_11 ( ) ; break ; case 11 : jj_3_12 ( ) ; break ; } } p = p . next ; } while ( p != null ) ; } catch ( LookaheadSuccess ls ) { } } jj_rescan = false ; } final private void jj_save ( int index , int xla ) { JJCalls p = jj_2_rtns [ index ] ; while ( p . gen > jj_gen ) { if ( p . next == null ) { p = p . next = new JJCalls ( ) ; break ; } p = p . next ; } p . gen = jj_gen + xla - jj_la ; p . first = token ; p . arg = xla ; } static final class JJCalls { int gen ; Token first ; int arg ; JJCalls next ; } } 	1	['152', '1', '0', '66', '245', '7900', '48', '60', '50', '0.761589404', '8177', '0.785714286', '10', '0', '0.145695364', '0', '0', '52.61184211', '12', '2.6118', '10']
package org . apache . velocity . runtime . parser . node ; import java . io . Writer ; import java . io . IOException ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; public class ASTEscape extends SimpleNode { public String val ; private char [ ] ctext ; public ASTEscape ( int id ) { super ( id ) ; } public ASTEscape ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object init ( InternalContextAdapter context , Object data ) { ctext = val . toCharArray ( ) ; return data ; } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException { if ( context . getAllowRendering ( ) ) { writer . write ( ctext ) ; } return true ; } } 	0	['5', '2', '0', '6', '11', '8', '4', '4', '5', '0.875', '37', '0.5', '0', '0.903225806', '0.4', '0', '0', '6', '1', '0.6', '0']
package org . apache . velocity . runtime . log ; import org . apache . velocity . runtime . RuntimeServices ; public class SystemLogChute implements LogChute { public static final String RUNTIME_LOG_LEVEL_KEY = "runtime.log.logsystem.system.level" ; public static final String RUNTIME_LOG_SYSTEM_ERR_LEVEL_KEY = "runtime.log.logsystem.system.err.level" ; private int enabled = TRACE_ID ; private int errLevel = TRACE_ID ; public void init ( RuntimeServices rs ) throws Exception { String level = ( String ) rs . getProperty ( RUNTIME_LOG_LEVEL_KEY ) ; if ( level != null ) { setEnabledLevel ( toLevel ( level ) ) ; } String errLevel = ( String ) rs . getProperty ( RUNTIME_LOG_SYSTEM_ERR_LEVEL_KEY ) ; if ( errLevel != null ) { setSystemErrLevel ( toLevel ( errLevel ) ) ; } } protected int toLevel ( String level ) { if ( level . equalsIgnoreCase ( "debug" ) ) { return DEBUG_ID ; } else if ( level . equalsIgnoreCase ( "info" ) ) { return INFO_ID ; } else if ( level . equalsIgnoreCase ( "warn" ) ) { return WARN_ID ; } else if ( level . equalsIgnoreCase ( "error" ) ) { return ERROR_ID ; } else { return TRACE_ID ; } } protected String getPrefix ( int level ) { switch ( level ) { case WARN_ID : return WARN_PREFIX ; case INFO_ID : return INFO_PREFIX ; case DEBUG_ID : return DEBUG_PREFIX ; case TRACE_ID : return TRACE_PREFIX ; case ERROR_ID : return ERROR_PREFIX ; default : return INFO_PREFIX ; } } public void log ( int level , String message ) { log ( level , message , null ) ; } public void log ( int level , String message , Throwable t ) { if ( ! isLevelEnabled ( level ) ) { return ; } String prefix = getPrefix ( level ) ; if ( level >= this . errLevel ) { System . err . print ( prefix ) ; System . err . println ( message ) ; if ( t != null ) { System . err . println ( t . getMessage ( ) ) ; t . printStackTrace ( ) ; } } else { System . out . print ( prefix ) ; System . out . println ( message ) ; if ( t != null ) { System . out . println ( t . getMessage ( ) ) ; t . printStackTrace ( System . out ) ; } } } public void setEnabledLevel ( int level ) { this . enabled = level ; } public int getEnabledLevel ( ) { return this . enabled ; } public void setSystemErrLevel ( int level ) { this . errLevel = level ; } public int getSystemErrLevel ( ) { return this . errLevel ; } public boolean isLevelEnabled ( int level ) { return ( level >= this . enabled ) ; } } 	1	['11', '1', '0', '3', '19', '31', '1', '2', '9', '0.8', '161', '0.5', '0', '0', '0.4', '0', '0', '13.27272727', '5', '1.8182', '2']
package org . apache . velocity . util . introspection ; public interface VelPropertyGet { public Object invoke ( Object o ) throws Exception ; public boolean isCacheable ( ) ; public String getMethodName ( ) ; } 	0	['3', '1', '0', '4', '3', '3', '4', '0', '3', '2', '3', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . velocity . app ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import java . io . StringReader ; import java . io . UnsupportedEncodingException ; import java . io . Writer ; import java . util . Properties ; import org . apache . commons . collections . ExtendedProperties ; import org . apache . velocity . Template ; import org . apache . velocity . context . Context ; import org . apache . velocity . context . InternalContextAdapterImpl ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeInstance ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . parser . ParseException ; import org . apache . velocity . runtime . parser . node . SimpleNode ; public class VelocityEngine implements RuntimeConstants { private RuntimeInstance ri = new RuntimeInstance ( ) ; public VelocityEngine ( ) { } public VelocityEngine ( String propsFilename ) throws Exception { ri . init ( propsFilename ) ; } public VelocityEngine ( Properties p ) throws Exception { ri . init ( p ) ; } public void init ( ) throws Exception { ri . init ( ) ; } public void init ( String propsFilename ) throws Exception { ri . init ( propsFilename ) ; } public void init ( Properties p ) throws Exception { ri . init ( p ) ; } public void setProperty ( String key , Object value ) { ri . setProperty ( key , value ) ; } public void addProperty ( String key , Object value ) { ri . addProperty ( key , value ) ; } public void clearProperty ( String key ) { ri . clearProperty ( key ) ; } public void setExtendedProperties ( ExtendedProperties configuration ) { ri . setConfiguration ( configuration ) ; } public Object getProperty ( String key ) { return ri . getProperty ( key ) ; } public boolean evaluate ( Context context , Writer out , String logTag , String instring ) throws ParseErrorException , MethodInvocationException , ResourceNotFoundException , IOException { return evaluate ( context , out , logTag , new BufferedReader ( new StringReader ( instring ) ) ) ; } public boolean evaluate ( Context context , Writer writer , String logTag , InputStream instream ) throws ParseErrorException , MethodInvocationException , ResourceNotFoundException , IOException { BufferedReader br = null ; String encoding = null ; try { encoding = ri . getString ( INPUT_ENCODING , ENCODING_DEFAULT ) ; br = new BufferedReader ( new InputStreamReader ( instream , encoding ) ) ; } catch ( UnsupportedEncodingException uce ) { String msg = "Unsupported input encoding : " + encoding + " for template " + logTag ; throw new ParseErrorException ( msg ) ; } return evaluate ( context , writer , logTag , br ) ; } public boolean evaluate ( Context context , Writer writer , String logTag , Reader reader ) throws ParseErrorException , MethodInvocationException , ResourceNotFoundException , IOException { SimpleNode nodeTree = null ; try { nodeTree = ri . parse ( reader , logTag ) ; } catch ( ParseException pex ) { throw new ParseErrorException ( pex ) ; } catch ( TemplateInitException pex ) { throw new ParseErrorException ( pex ) ; } if ( nodeTree != null ) { InternalContextAdapterImpl ica = new InternalContextAdapterImpl ( context ) ; ica . pushCurrentTemplateName ( logTag ) ; try { try { nodeTree . init ( ica , ri ) ; } catch ( TemplateInitException pex ) { throw new ParseErrorException ( pex ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { getLog ( ) . error ( "Velocity.evaluate() : init exception for tag = " + logTag , e ) ; } nodeTree . render ( ica , writer ) ; } finally { ica . popCurrentTemplateName ( ) ; } return true ; } return false ; } public boolean invokeVelocimacro ( String vmName , String logTag , String params [ ] , Context context , Writer writer ) throws Exception { if ( vmName == null || params == null || context == null || writer == null || logTag == null ) { getLog ( ) . error ( "VelocityEngine.invokeVelocimacro() : invalid parameter" ) ; return false ; } if ( ! ri . isVelocimacro ( vmName , logTag ) ) { getLog ( ) . error ( "VelocityEngine.invokeVelocimacro() : VM '" + vmName + "' not registered." ) ; return false ; } StringBuffer construct = new StringBuffer ( "#" ) ; construct . append ( vmName ) ; construct . append ( "(" ) ; for ( int i = 0 ; i < params . length ; i ++ ) { construct . append ( " $" ) ; construct . append ( params [ i ] ) ; } construct . append ( " )" ) ; try { boolean retval = evaluate ( context , writer , logTag , construct . toString ( ) ) ; return retval ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { getLog ( ) . error ( "VelocityEngine.invokeVelocimacro() : error " , e ) ; throw e ; } } public boolean mergeTemplate ( String templateName , Context context , Writer writer ) throws ResourceNotFoundException , ParseErrorException , MethodInvocationException , Exception { return mergeTemplate ( templateName , ri . getString ( INPUT_ENCODING , ENCODING_DEFAULT ) , context , writer ) ; } public boolean mergeTemplate ( String templateName , String encoding , Context context , Writer writer ) throws ResourceNotFoundException , ParseErrorException , MethodInvocationException , Exception { Template template = ri . getTemplate ( templateName , encoding ) ; if ( template == null ) { getLog ( ) . error ( "Velocity.mergeTemplate() was unable to load template '" + templateName + "'" ) ; return false ; } else { template . merge ( context , writer ) ; return true ; } } public Template getTemplate ( String name ) throws ResourceNotFoundException , ParseErrorException , Exception { return ri . getTemplate ( name ) ; } public Template getTemplate ( String name , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception { return ri . getTemplate ( name , encoding ) ; } public boolean resourceExists ( String resourceName ) { return ( ri . getLoaderNameForResource ( resourceName ) != null ) ; } public boolean templateExists ( String resourceName ) { return resourceExists ( resourceName ) ; } public Log getLog ( ) { return ri . getLog ( ) ; } public void warn ( Object message ) { getLog ( ) . warn ( message ) ; } public void info ( Object message ) { getLog ( ) . info ( message ) ; } public void error ( Object message ) { getLog ( ) . error ( message ) ; } public void debug ( Object message ) { getLog ( ) . debug ( message ) ; } public void setApplicationAttribute ( Object key , Object value ) { ri . setApplicationAttribute ( key , value ) ; } public Object getApplicationAttribute ( Object key ) { return ri . getApplicationAttribute ( key ) ; } } 	1	['28', '1', '0', '18', '68', '0', '3', '15', '28', '0', '431', '1', '1', '0', '0.25', '0', '0', '14.35714286', '2', '0.9286', '3']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; public class ASTIncludeStatement extends SimpleNode { public ASTIncludeStatement ( int id ) { super ( id ) ; } public ASTIncludeStatement ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } } 	0	['3', '2', '0', '3', '6', '3', '0', '3', '3', '2', '17', '0', '0', '0.965517241', '0.533333333', '0', '0', '4.666666667', '1', '0.3333', '0']
package org . apache . velocity . util ; import java . io . InputStream ; public class ClassUtils { private ClassUtils ( ) { } public static Class getClass ( String clazz ) throws ClassNotFoundException { ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( loader != null ) { try { return Class . forName ( clazz , true , loader ) ; } catch ( ClassNotFoundException E ) { } } return Class . forName ( clazz ) ; } public static Object getNewInstance ( String clazz ) throws ClassNotFoundException , IllegalAccessException , InstantiationException { return getClass ( clazz ) . newInstance ( ) ; } public static InputStream getResourceAsStream ( Class claz , String name ) { InputStream result = null ; while ( name . startsWith ( "/" ) ) { name = name . substring ( 1 ) ; } ClassLoader classLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( classLoader == null ) { classLoader = claz . getClassLoader ( ) ; result = classLoader . getResourceAsStream ( name ) ; } else { result = classLoader . getResourceAsStream ( name ) ; if ( result == null ) { classLoader = claz . getClassLoader ( ) ; if ( classLoader != null ) result = classLoader . getResourceAsStream ( name ) ; } } return result ; } } 	1	['4', '1', '0', '8', '14', '6', '8', '0', '3', '2', '66', '0', '0', '0', '0.416666667', '0', '0', '15.5', '5', '1.75', '1']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; public class ASTAssignment extends SimpleNode { public ASTAssignment ( int id ) { super ( id ) ; } public ASTAssignment ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } } 	0	['3', '2', '0', '5', '6', '3', '4', '3', '3', '2', '17', '0', '0', '0.965517241', '0.533333333', '0', '0', '4.666666667', '1', '0.3333', '0']
package org . apache . velocity . runtime . parser . node ; import java . io . IOException ; import java . io . Writer ; import org . apache . velocity . app . event . EventHandlerUtil ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; import org . apache . velocity . util . introspection . Info ; public class ASTSetDirective extends SimpleNode { private String leftReference = "" ; private Node right = null ; private ASTReference left = null ; boolean logOnNull = false ; protected Info uberInfo ; public ASTSetDirective ( int id ) { super ( id ) ; } public ASTSetDirective ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object init ( InternalContextAdapter context , Object data ) throws TemplateInitException { super . init ( context , data ) ; uberInfo = new Info ( context . getCurrentTemplateName ( ) , getLine ( ) , getColumn ( ) ) ; right = getRightHandSide ( ) ; left = getLeftHandSide ( ) ; logOnNull = rsvc . getBoolean ( RuntimeConstants . RUNTIME_LOG_REFERENCE_LOG_INVALID , true ) ; leftReference = left . getFirstToken ( ) . image . substring ( 1 ) ; return data ; } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException { Object value = right . value ( context ) ; if ( ! rsvc . getBoolean ( RuntimeConstants . SET_NULL_ALLOWED , false ) ) { if ( value == null ) { if ( logOnNull ) { boolean doit = EventHandlerUtil . shouldLogOnNullSet ( rsvc , context , left . literal ( ) , right . literal ( ) ) ; if ( doit && log . isInfoEnabled ( ) ) { log . info ( "RHS of #set statement is null. Context will not be modified. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; } } String rightReference = null ; if ( right instanceof ASTExpression ) { rightReference = ( ( ASTExpression ) right ) . getLastToken ( ) . image ; } EventHandlerUtil . invalidSetMethod ( rsvc , context , leftReference , rightReference , uberInfo ) ; return false ; } } if ( value == null ) { String rightReference = null ; if ( right instanceof ASTExpression ) { rightReference = ( ( ASTExpression ) right ) . getLastToken ( ) . image ; } EventHandlerUtil . invalidSetMethod ( rsvc , context , leftReference , rightReference , uberInfo ) ; context . remove ( leftReference ) ; return false ; } else { if ( left . jjtGetNumChildren ( ) == 0 ) { context . put ( leftReference , value ) ; } else { left . setValue ( context , value ) ; } } return true ; } private ASTReference getLeftHandSide ( ) { return ( ASTReference ) jjtGetChild ( 0 ) ; } private Node getRightHandSide ( ) { return jjtGetChild ( 1 ) ; } } 	1	['7', '2', '0', '16', '35', '9', '4', '14', '5', '0.566666667', '229', '0.8', '3', '0.848484848', '0.326530612', '1', '1', '31', '1', '0.7143', '5']
package org . apache . velocity . runtime . parser . node ; import java . io . Writer ; import java . io . IOException ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; public class ASTBlock extends SimpleNode { public ASTBlock ( int id ) { super ( id ) ; } public ASTBlock ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException , ResourceNotFoundException , ParseErrorException { int i , k = jjtGetNumChildren ( ) ; for ( i = 0 ; i < k ; i ++ ) jjtGetChild ( i ) . render ( context , writer ) ; return true ; } } 	0	['4', '2', '0', '10', '10', '6', '4', '8', '4', '2', '37', '0', '0', '0.933333333', '0.392857143', '1', '1', '8.25', '1', '0.5', '0']
package org . apache . velocity . app . event . implement ; import org . apache . commons . lang . StringEscapeUtils ; public class EscapeHtmlReference extends EscapeReference { protected String escape ( Object text ) { return StringEscapeUtils . escapeHtml ( text . toString ( ) ) ; } protected String getMatchAttribute ( ) { return "eventhandler.escape.html.match" ; } } 	1	['3', '2', '0', '2', '6', '3', '0', '2', '1', '2', '12', '0', '0', '0.714285714', '0.666666667', '1', '2', '3', '1', '0.6667', '1']
package org . apache . velocity . runtime . parser . node ; import java . io . IOException ; import java . io . Writer ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; public class ASTElseIfStatement extends SimpleNode { public ASTElseIfStatement ( int id ) { super ( id ) ; } public ASTElseIfStatement ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { return jjtGetChild ( 0 ) . evaluate ( context ) ; } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException , ResourceNotFoundException , ParseErrorException { return jjtGetChild ( 1 ) . render ( context , writer ) ; } } 	0	['5', '2', '0', '10', '11', '10', '4', '8', '5', '2', '32', '0', '0', '0.903225806', '0.371428571', '1', '2', '5.4', '1', '0.6', '0']
package org . apache . velocity . runtime . parser ; import org . apache . velocity . runtime . parser . node . Node ; class JJTParserState { private java . util . Stack nodes ; private java . util . Stack marks ; private int sp ; private int mk ; private boolean node_created ; JJTParserState ( ) { nodes = new java . util . Stack ( ) ; marks = new java . util . Stack ( ) ; sp = 0 ; mk = 0 ; } boolean nodeCreated ( ) { return node_created ; } void reset ( ) { nodes . removeAllElements ( ) ; marks . removeAllElements ( ) ; sp = 0 ; mk = 0 ; } Node rootNode ( ) { return ( Node ) nodes . elementAt ( 0 ) ; } void pushNode ( Node n ) { nodes . push ( n ) ; ++ sp ; } Node popNode ( ) { if ( -- sp < mk ) { mk = ( ( Integer ) marks . pop ( ) ) . intValue ( ) ; } return ( Node ) nodes . pop ( ) ; } Node peekNode ( ) { return ( Node ) nodes . peek ( ) ; } int nodeArity ( ) { return sp - mk ; } void clearNodeScope ( Node n ) { while ( sp > mk ) { popNode ( ) ; } mk = ( ( Integer ) marks . pop ( ) ) . intValue ( ) ; } void openNodeScope ( Node n ) { marks . push ( new Integer ( mk ) ) ; mk = sp ; n . jjtOpen ( ) ; } void closeNodeScope ( Node n , int num ) { mk = ( ( Integer ) marks . pop ( ) ) . intValue ( ) ; while ( num -- > 0 ) { Node c = popNode ( ) ; c . jjtSetParent ( n ) ; n . jjtAddChild ( c , num ) ; } n . jjtClose ( ) ; pushNode ( n ) ; node_created = true ; } void closeNodeScope ( Node n , boolean condition ) { if ( condition ) { int a = nodeArity ( ) ; mk = ( ( Integer ) marks . pop ( ) ) . intValue ( ) ; while ( a -- > 0 ) { Node c = popNode ( ) ; c . jjtSetParent ( n ) ; n . jjtAddChild ( c , a ) ; } n . jjtClose ( ) ; pushNode ( n ) ; node_created = true ; } else { mk = ( ( Integer ) marks . pop ( ) ) . intValue ( ) ; node_created = false ; } } } 	1	['12', '1', '0', '2', '25', '0', '1', '1', '0', '0.436363636', '218', '1', '0', '0', '0.395833333', '0', '0', '16.75', '3', '1.3333', '1']
package org . apache . velocity . runtime . log ; public class AvalonLogSystem extends AvalonLogChute implements LogSystem { public void logVelocityMessage ( int level , String message ) { log ( level , message ) ; } } 	0	['2', '2', '0', '2', '4', '1', '0', '2', '2', '2', '10', '0', '0', '0.888888889', '0.666666667', '0', '0', '4', '1', '0.5', '0']
package org . apache . velocity . exception ; import org . apache . velocity . util . ExceptionUtils ; public class VelocityException extends RuntimeException { private static final long serialVersionUID = 1251243065134956045L ; private final Throwable wrapped ; public VelocityException ( final String exceptionMessage ) { super ( exceptionMessage ) ; wrapped = null ; } public VelocityException ( final String exceptionMessage , final Throwable wrapped ) { super ( exceptionMessage ) ; this . wrapped = wrapped ; ExceptionUtils . setCause ( this , wrapped ) ; } public VelocityException ( final Throwable wrapped ) { super ( ) ; this . wrapped = wrapped ; ExceptionUtils . setCause ( this , wrapped ) ; } public Throwable getWrappedThrowable ( ) { return wrapped ; } } 	1	['4', '4', '4', '10', '7', '0', '9', '1', '4', '0.666666667', '35', '1', '0', '0.928571429', '0.666666667', '0', '0', '7.25', '1', '0.25', '1']
package org . apache . velocity . runtime . log ; import org . apache . velocity . runtime . RuntimeServices ; public interface LogSystem { public final static boolean DEBUG_ON = true ; public final static int DEBUG_ID = 0 ; public final static int INFO_ID = 1 ; public final static int WARN_ID = 2 ; public final static int ERROR_ID = 3 ; public void init ( RuntimeServices rs ) throws Exception ; public void logVelocityMessage ( int level , String message ) ; } 	0	['2', '1', '0', '8', '2', '1', '7', '1', '2', '2', '7', '0', '0', '0', '0.625', '0', '0', '0', '1', '1', '0']
package org . apache . velocity . runtime . resource ; import java . util . Collections ; import java . util . Hashtable ; import java . util . Map ; import java . util . Iterator ; import org . apache . commons . collections . map . LRUMap ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeServices ; public class ResourceCacheImpl implements ResourceCache { protected Map cache = new Hashtable ( ) ; protected RuntimeServices rsvc = null ; public void initialize ( RuntimeServices rs ) { rsvc = rs ; int maxSize = rsvc . getInt ( RuntimeConstants . RESOURCE_MANAGER_DEFAULTCACHE_SIZE , 89 ) ; if ( maxSize > 0 ) { Map lruCache = Collections . synchronizedMap ( new LRUMap ( maxSize ) ) ; lruCache . putAll ( cache ) ; cache = lruCache ; } rsvc . getLog ( ) . debug ( "ResourceCache: initialized (" + this . getClass ( ) + ')' ) ; } public Resource get ( Object key ) { return ( Resource ) cache . get ( key ) ; } public Resource put ( Object key , Resource value ) { return ( Resource ) cache . put ( key , value ) ; } public Resource remove ( Object key ) { return ( Resource ) cache . remove ( key ) ; } public Iterator enumerateKeys ( ) { return cache . keySet ( ) . iterator ( ) ; } } 	1	['6', '1', '0', '6', '25', '0', '1', '5', '6', '0.4', '83', '1', '1', '0', '0.458333333', '0', '0', '12.5', '2', '1', '1']
package org . apache . velocity . texen . util ; import java . io . File ; public class FileUtil { static public String mkdir ( String s ) { try { if ( ( new File ( s ) ) . mkdirs ( ) ) return "Created dir: " + s ; else return "Failed to create dir or dir already exists: " + s ; } catch ( Exception e ) { return e . toString ( ) ; } } public static File file ( String s ) { File f = new File ( s ) ; return f ; } public static File file ( String base , String s ) { File f = new File ( base , s ) ; return f ; } } 	0	['4', '1', '0', '0', '12', '6', '0', '0', '4', '2', '50', '0', '0', '0', '0.5', '0', '0', '11.5', '2', '1', '0']
package org . apache . velocity . runtime . resource . loader ; import java . io . ByteArrayInputStream ; import java . io . InputStream ; import java . io . UnsupportedEncodingException ; import org . apache . commons . collections . ExtendedProperties ; import org . apache . commons . lang . StringUtils ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . resource . Resource ; import org . apache . velocity . runtime . resource . util . StringResource ; import org . apache . velocity . runtime . resource . util . StringResourceRepository ; import org . apache . velocity . runtime . resource . util . StringResourceRepositoryImpl ; import org . apache . velocity . util . ClassUtils ; public class StringResourceLoader extends ResourceLoader { public static final String REPOSITORY_CLASS = "repository.class" ; public static final String REPOSITORY_CLASS_DEFAULT = StringResourceRepositoryImpl . class . getName ( ) ; public static final String REPOSITORY_ENCODING = "repository.encoding" ; public static final String REPOSITORY_ENCODING_DEFAULT = "UTF-8" ; public static StringResourceRepository getRepository ( ) { return RepositoryFactory . getRepository ( ) ; } public void init ( final ExtendedProperties configuration ) { log . info ( "StringResourceLoader : initialization starting." ) ; String repositoryClass = configuration . getString ( REPOSITORY_CLASS , REPOSITORY_CLASS_DEFAULT ) ; String encoding = configuration . getString ( REPOSITORY_ENCODING , REPOSITORY_ENCODING_DEFAULT ) ; RepositoryFactory . setRepositoryClass ( repositoryClass ) ; RepositoryFactory . setEncoding ( encoding ) ; RepositoryFactory . init ( log ) ; log . info ( "StringResourceLoader : initialization complete." ) ; } public InputStream getResourceStream ( final String name ) throws ResourceNotFoundException { if ( StringUtils . isEmpty ( name ) ) { throw new ResourceNotFoundException ( "No template name provided" ) ; } StringResource resource = getRepository ( ) . getStringResource ( name ) ; if ( resource == null ) { throw new ResourceNotFoundException ( "Could not locate resource '" + name + "'" ) ; } byte [ ] byteArray = null ; try { byteArray = resource . getBody ( ) . getBytes ( resource . getEncoding ( ) ) ; return new ByteArrayInputStream ( byteArray ) ; } catch ( UnsupportedEncodingException ue ) { throw new VelocityException ( "Could not convert String using encoding " + resource . getEncoding ( ) , ue ) ; } } public boolean isSourceModified ( final Resource resource ) { StringResource original = null ; boolean result = true ; original = getRepository ( ) . getStringResource ( resource . getName ( ) ) ; if ( original != null ) { result = original . getLastModified ( ) != resource . getLastModified ( ) ; } return result ; } public long getLastModified ( final Resource resource ) { StringResource original = null ; original = getRepository ( ) . getStringResource ( resource . getName ( ) ) ; return ( original != null ) ? original . getLastModified ( ) : 0 ; } private static final class RepositoryFactory { private static boolean isInitialized = false ; private static StringResourceRepository repository = null ; public static void setRepositoryClass ( final String className ) { if ( isInitialized ) { throw new IllegalStateException ( "The RepositoryFactory has already been initialized!" ) ; } try { repository = ( StringResourceRepository ) ClassUtils . getNewInstance ( className ) ; } catch ( ClassNotFoundException cnfe ) { throw new VelocityException ( "Could not find '" + className + "'" , cnfe ) ; } catch ( IllegalAccessException iae ) { throw new VelocityException ( "Could not access '" + className + "'" , iae ) ; } catch ( InstantiationException ie ) { throw new VelocityException ( "Could not instantiante '" + className + "'" , ie ) ; } } public static void setEncoding ( final String encoding ) { if ( repository == null ) { throw new IllegalStateException ( "The Repository class has not yet been set!" ) ; } repository . setEncoding ( encoding ) ; } public static synchronized void init ( final Log log ) throws VelocityException { if ( isInitialized ) { throw new IllegalStateException ( "Attempted to re-initialize Factory!" ) ; } if ( log . isInfoEnabled ( ) ) { log . info ( "Using " + repository . getClass ( ) . getName ( ) + " as repository implementation" ) ; log . info ( "Current repository encoding is " + repository . getEncoding ( ) ) ; } isInitialized = true ; } public static StringResourceRepository getRepository ( ) { if ( ! isInitialized ) { throw new IllegalStateException ( "RepositoryFactory was not properly set up" ) ; } return repository ; } } } 	1	['8', '2', '0', '10', '33', '26', '0', '10', '6', '1.057142857', '158', '0', '0', '0.647058824', '0.357142857', '1', '1', '18.125', '3', '1.125', '5']
package org . apache . velocity . texen . util ; import java . io . FileInputStream ; import java . io . InputStream ; import java . util . Properties ; import java . util . StringTokenizer ; import org . apache . velocity . texen . Generator ; public class PropertiesUtil { public Properties load ( final String propertiesFile ) { Properties properties = null ; String templatePath = Generator . getInstance ( ) . getTemplatePath ( ) ; try { if ( templatePath != null ) { properties = loadFromTemplatePath ( propertiesFile ) ; } else { properties = loadFromClassPath ( propertiesFile ) ; } } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { throw new RuntimeException ( "Could not load properties: " + e . getMessage ( ) ) ; } return properties ; } protected Properties loadFromTemplatePath ( final String propertiesFile ) throws Exception { Properties properties = new Properties ( ) ; String templatePath = Generator . getInstance ( ) . getTemplatePath ( ) ; StringTokenizer st = new StringTokenizer ( templatePath , "," ) ; while ( st . hasMoreTokens ( ) ) { String templateDir = st . nextToken ( ) ; InputStream stream = null ; try { String fullPath = propertiesFile ; if ( ! fullPath . startsWith ( templateDir ) ) { fullPath = templateDir + "/" + propertiesFile ; } stream = new FileInputStream ( fullPath ) ; properties . load ( stream ) ; break ; } finally { if ( stream != null ) { stream . close ( ) ; } } } return properties ; } protected Properties loadFromClassPath ( final String propertiesName ) throws Exception { Properties properties = new Properties ( ) ; ClassLoader classLoader = this . getClass ( ) . getClassLoader ( ) ; InputStream inputStream = null ; try { String propertiesFile = propertiesName . startsWith ( "$generator" ) ? propertiesName . substring ( "$generator.templatePath/" . length ( ) ) : propertiesName ; inputStream = classLoader . getResourceAsStream ( propertiesFile ) ; properties . load ( inputStream ) ; } finally { if ( inputStream != null ) { inputStream . close ( ) ; } } return properties ; } } 	0	['4', '1', '0', '1', '25', '6', '0', '1', '2', '2', '145', '0', '0', '0', '0.875', '0', '0', '35.25', '2', '1', '0']
package org . apache . velocity . exception ; import org . apache . velocity . runtime . parser . ParseException ; public class TemplateInitException extends VelocityException implements ExtendedParseException { private final String templateName ; private final int col ; private final int line ; private static final long serialVersionUID = - 4985224672336070621L ; public TemplateInitException ( final String msg , final String templateName , final int col , final int line ) { super ( msg ) ; this . templateName = templateName ; this . col = col ; this . line = line ; } public TemplateInitException ( final String msg , ParseException parseException , final String templateName , final int col , final int line ) { super ( msg , parseException ) ; this . templateName = templateName ; this . col = col ; this . line = line ; } public String getTemplateName ( ) { return templateName ; } public int getLineNumber ( ) { return line ; } public int getColumnNumber ( ) { return col ; } } 	1	['5', '5', '0', '23', '7', '0', '20', '3', '5', '0.6875', '45', '1', '0', '0.823529412', '0.5', '0', '0', '7.2', '1', '0.6', '1']
package org . apache . velocity . runtime . parser . node ; import java . io . Writer ; import java . io . IOException ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; public class ASTEscapedDirective extends SimpleNode { public ASTEscapedDirective ( int id ) { super ( id ) ; } public ASTEscapedDirective ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException { if ( context . getAllowRendering ( ) ) { writer . write ( getFirstToken ( ) . image ) ; } return true ; } } 	0	['4', '2', '0', '7', '10', '6', '4', '5', '4', '2', '28', '0', '0', '0.933333333', '0.392857143', '0', '0', '6', '1', '0.5', '0']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; import org . apache . velocity . util . TemplateNumber ; public class ASTMulNode extends SimpleNode { public ASTMulNode ( int id ) { super ( id ) ; } public ASTMulNode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { Object left = jjtGetChild ( 0 ) . value ( context ) ; Object right = jjtGetChild ( 1 ) . value ( context ) ; if ( left == null || right == null ) { log . error ( ( left == null ? "Left" : "Right" ) + " side (" + jjtGetChild ( ( left == null ? 0 : 1 ) ) . literal ( ) + ") of multiplication operation has null value." + " Operation not possible. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return null ; } if ( left instanceof TemplateNumber ) { left = ( ( TemplateNumber ) left ) . getAsNumber ( ) ; } if ( right instanceof TemplateNumber ) { right = ( ( TemplateNumber ) right ) . getAsNumber ( ) ; } if ( ! ( left instanceof Number ) || ! ( right instanceof Number ) ) { log . error ( ( ! ( left instanceof Number ) ? "Left" : "Right" ) + " side of multiplication operation is not a Number. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return null ; } return MathUtils . multiply ( ( Number ) left , ( Number ) right ) ; } } 	1	['4', '2', '0', '11', '20', '6', '4', '9', '4', '2', '138', '0', '0', '0.933333333', '0.416666667', '1', '1', '33.5', '1', '0.5', '1']
package org . apache . velocity ; import java . util . HashMap ; import java . util . Map ; import org . apache . velocity . context . AbstractContext ; import org . apache . velocity . context . Context ; public class VelocityContext extends AbstractContext implements Cloneable { private static final long serialVersionUID = 9033846851064645037L ; private Map context = null ; public VelocityContext ( ) { this ( null , null ) ; } public VelocityContext ( Map context ) { this ( context , null ) ; } public VelocityContext ( Context innerContext ) { this ( null , innerContext ) ; } public VelocityContext ( Map context , Context innerContext ) { super ( innerContext ) ; this . context = ( context == null ? new HashMap ( ) : context ) ; } public Object internalGet ( String key ) { return context . get ( key ) ; } public Object internalPut ( String key , Object value ) { return context . put ( key , value ) ; } public boolean internalContainsKey ( Object key ) { return context . containsKey ( key ) ; } public Object [ ] internalGetKeys ( ) { return context . keySet ( ) . toArray ( ) ; } public Object internalRemove ( Object key ) { return context . remove ( key ) ; } public Object clone ( ) { VelocityContext clone = null ; try { clone = ( VelocityContext ) super . clone ( ) ; clone . context = new HashMap ( context ) ; } catch ( CloneNotSupportedException ignored ) { } return clone ; } } 	0	['10', '3', '0', '8', '20', '3', '6', '2', '10', '0.555555556', '86', '1', '0', '0.793103448', '0.38', '1', '4', '7.4', '1', '0.6', '0']
package org . apache . velocity . util . introspection ; import java . lang . reflect . Method ; import org . apache . velocity . runtime . RuntimeLogger ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . log . RuntimeLoggerLog ; public class Introspector extends IntrospectorBase { public final static String CACHEDUMP_MSG = "Introspector: detected classloader change. Dumping cache." ; public Introspector ( final Log log ) { super ( log ) ; } public Introspector ( final RuntimeLogger logger ) { this ( new RuntimeLoggerLog ( logger ) ) ; } public Method getMethod ( final Class c , final String name , final Object [ ] params ) throws IllegalArgumentException { try { return super . getMethod ( c , name , params ) ; } catch ( MethodMap . AmbiguousException ae ) { StringBuffer msg = new StringBuffer ( "Introspection Error : Ambiguous method invocation " ) . append ( name ) . append ( "(" ) ; for ( int i = 0 ; i < params . length ; i ++ ) { if ( i > 0 ) { msg . append ( ", " ) ; } if ( params [ i ] == null ) { msg . append ( "null" ) ; } else { msg . append ( params [ i ] . getClass ( ) . getName ( ) ) ; } } msg . append ( ") for class " ) . append ( c ) ; log . error ( msg . toString ( ) ) ; } return null ; } public void triggerClear ( ) { super . triggerClear ( ) ; log . info ( CACHEDUMP_MSG ) ; } } 	1	['4', '2', '1', '16', '16', '4', '11', '5', '4', '1.333333333', '83', '0', '0', '0.8', '0.375', '0', '0', '19.5', '1', '0.5', '3']
package org . apache . velocity . texen . ant ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . Writer ; import java . util . Date ; import java . util . Iterator ; import java . util . StringTokenizer ; import org . apache . commons . collections . ExtendedProperties ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . velocity . VelocityContext ; import org . apache . velocity . app . VelocityEngine ; import org . apache . velocity . context . Context ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . texen . Generator ; import org . apache . velocity . util . StringUtils ; public class TexenTask extends Task { private final static String ERR_MSG_FRAGMENT = ". For more information consult the velocity log, or invoke ant " + "with the -debug flag." ; protected String controlTemplate ; protected String templatePath ; protected String outputDirectory ; protected String outputFile ; protected String outputEncoding ; protected String inputEncoding ; protected ExtendedProperties contextProperties ; protected boolean useClasspath ; protected String logFile ; protected String useResourceLoaderCache = "false" ; protected String resourceLoaderModificationCheckInterval = "2" ; public void setControlTemplate ( String controlTemplate ) { this . controlTemplate = controlTemplate ; } public String getControlTemplate ( ) { return controlTemplate ; } public void setTemplatePath ( String templatePath ) throws Exception { StringBuffer resolvedPath = new StringBuffer ( ) ; StringTokenizer st = new StringTokenizer ( templatePath , "," ) ; while ( st . hasMoreTokens ( ) ) { File fullPath = project . resolveFile ( st . nextToken ( ) ) ; resolvedPath . append ( fullPath . getCanonicalPath ( ) ) ; if ( st . hasMoreTokens ( ) ) { resolvedPath . append ( "," ) ; } } this . templatePath = resolvedPath . toString ( ) ; System . out . println ( templatePath ) ; } public String getTemplatePath ( ) { return templatePath ; } public void setOutputDirectory ( File outputDirectory ) { try { this . outputDirectory = outputDirectory . getCanonicalPath ( ) ; } catch ( java . io . IOException ioe ) { throw new BuildException ( ioe ) ; } } public String getOutputDirectory ( ) { return outputDirectory ; } public void setOutputFile ( String outputFile ) { this . outputFile = outputFile ; } public void setOutputEncoding ( String outputEncoding ) { this . outputEncoding = outputEncoding ; } public void setInputEncoding ( String inputEncoding ) { this . inputEncoding = inputEncoding ; } public String getOutputFile ( ) { return outputFile ; } public void setLogFile ( String log ) { this . logFile = log ; } public String getLogFile ( ) { return this . logFile ; } public void setContextProperties ( String file ) { String [ ] sources = StringUtils . split ( file , "," ) ; contextProperties = new ExtendedProperties ( ) ; for ( int i = 0 ; i < sources . length ; i ++ ) { ExtendedProperties source = new ExtendedProperties ( ) ; try { File fullPath = project . resolveFile ( sources [ i ] ) ; log ( "Using contextProperties file: " + fullPath ) ; source . load ( new FileInputStream ( fullPath ) ) ; } catch ( IOException e ) { ClassLoader classLoader = this . getClass ( ) . getClassLoader ( ) ; try { InputStream inputStream = classLoader . getResourceAsStream ( sources [ i ] ) ; if ( inputStream == null ) { throw new BuildException ( "Context properties file " + sources [ i ] + " could not be found in the file system or on the classpath!" ) ; } else { source . load ( inputStream ) ; } } catch ( IOException ioe ) { source = null ; } } if ( source != null ) { for ( Iterator j = source . getKeys ( ) ; j . hasNext ( ) ; ) { String name = ( String ) j . next ( ) ; String value = StringUtils . nullTrim ( source . getString ( name ) ) ; contextProperties . setProperty ( name , value ) ; } } } } public ExtendedProperties getContextProperties ( ) { return contextProperties ; } public void setUseClasspath ( boolean useClasspath ) { this . useClasspath = useClasspath ; } public void setUseResourceLoaderCache ( String useResourceLoaderCache ) { this . useResourceLoaderCache = useResourceLoaderCache ; } public void setResourceLoaderModificationCheckInterval ( String resourceLoaderModificationCheckInterval ) { this . resourceLoaderModificationCheckInterval = resourceLoaderModificationCheckInterval ; } public Context initControlContext ( ) throws Exception { return new VelocityContext ( ) ; } public void execute ( ) throws BuildException { if ( templatePath == null && useClasspath == false ) { throw new BuildException ( "The template path needs to be defined if you are not using " + "the classpath for locating templates!" ) ; } if ( controlTemplate == null ) { throw new BuildException ( "The control template needs to be defined!" ) ; } if ( outputDirectory == null ) { throw new BuildException ( "The output directory needs to be defined!" ) ; } if ( outputFile == null ) { throw new BuildException ( "The output file needs to be defined!" ) ; } VelocityEngine ve = new VelocityEngine ( ) ; try { if ( templatePath != null ) { log ( "Using templatePath: " + templatePath , Project . MSG_VERBOSE ) ; ve . setProperty ( RuntimeConstants . FILE_RESOURCE_LOADER_PATH , templatePath ) ; } if ( useClasspath ) { log ( "Using classpath" ) ; ve . addProperty ( VelocityEngine . RESOURCE_LOADER , "classpath" ) ; ve . setProperty ( "classpath." + VelocityEngine . RESOURCE_LOADER + ".class" , "org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader" ) ; ve . setProperty ( "classpath." + VelocityEngine . RESOURCE_LOADER + ".cache" , useResourceLoaderCache ) ; ve . setProperty ( "classpath." + VelocityEngine . RESOURCE_LOADER + ".modificationCheckInterval" , resourceLoaderModificationCheckInterval ) ; } if ( this . logFile != null ) { ve . setProperty ( RuntimeConstants . RUNTIME_LOG , this . logFile ) ; } ve . init ( ) ; Generator generator = Generator . getInstance ( ) ; generator . setVelocityEngine ( ve ) ; generator . setOutputPath ( outputDirectory ) ; generator . setInputEncoding ( inputEncoding ) ; generator . setOutputEncoding ( outputEncoding ) ; if ( templatePath != null ) { generator . setTemplatePath ( templatePath ) ; } File file = new File ( outputDirectory ) ; if ( ! file . exists ( ) ) { file . mkdirs ( ) ; } String path = outputDirectory + File . separator + outputFile ; log ( "Generating to file " + path , Project . MSG_INFO ) ; Writer writer = generator . getWriter ( path , outputEncoding ) ; Context c = initControlContext ( ) ; populateInitialContext ( c ) ; if ( contextProperties != null ) { Iterator i = contextProperties . getKeys ( ) ; while ( i . hasNext ( ) ) { String property = ( String ) i . next ( ) ; String value = StringUtils . nullTrim ( contextProperties . getString ( property ) ) ; try { c . put ( property , new Integer ( value ) ) ; } catch ( NumberFormatException nfe ) { String booleanString = contextProperties . testBoolean ( value ) ; if ( booleanString != null ) { c . put ( property , Boolean . valueOf ( booleanString ) ) ; } else { if ( property . endsWith ( "file.contents" ) ) { value = StringUtils . fileContentsToString ( project . resolveFile ( value ) . getCanonicalPath ( ) ) ; property = property . substring ( 0 , property . indexOf ( "file.contents" ) - 1 ) ; } c . put ( property , value ) ; } } } } writer . write ( generator . parse ( controlTemplate , c ) ) ; writer . flush ( ) ; writer . close ( ) ; generator . shutdown ( ) ; cleanup ( ) ; } catch ( BuildException e ) { throw e ; } catch ( MethodInvocationException e ) { throw new BuildException ( "Exception thrown by '" + e . getReferenceName ( ) + "." + e . getMethodName ( ) + "'" + ERR_MSG_FRAGMENT , e . getWrappedThrowable ( ) ) ; } catch ( ParseErrorException e ) { throw new BuildException ( "Velocity syntax error" + ERR_MSG_FRAGMENT , e ) ; } catch ( ResourceNotFoundException e ) { throw new BuildException ( "Resource not found" + ERR_MSG_FRAGMENT , e ) ; } catch ( Exception e ) { throw new BuildException ( "Generation failed" + ERR_MSG_FRAGMENT , e ) ; } } protected void populateInitialContext ( Context context ) throws Exception { context . put ( "now" , new Date ( ) . toString ( ) ) ; } protected void cleanup ( ) throws Exception { } } 	0	['22', '3', '0', '12', '84', '177', '0', '12', '20', '0.928571429', '565', '1', '0', '0.637931034', '0.309090909', '1', '1', '24.13636364', '5', '1.1364', '0']
package org . apache . velocity . context ; import org . apache . velocity . util . introspection . IntrospectionCacheData ; import org . apache . velocity . runtime . resource . Resource ; interface InternalHousekeepingContext { void pushCurrentTemplateName ( String s ) ; void popCurrentTemplateName ( ) ; String getCurrentTemplateName ( ) ; Object [ ] getTemplateNameStack ( ) ; IntrospectionCacheData icacheGet ( Object key ) ; void icachePut ( Object key , IntrospectionCacheData o ) ; Resource getCurrentResource ( ) ; void setCurrentResource ( Resource r ) ; boolean getAllowRendering ( ) ; void setAllowRendering ( boolean v ) ; } 	1	['10', '1', '0', '5', '10', '45', '3', '2', '10', '2', '10', '0', '0', '0', '0.266666667', '0', '0', '0', '1', '1', '2']
package org . apache . velocity . runtime . log ; public class PrimordialLogSystem extends HoldingLogChute implements LogSystem { public void logVelocityMessage ( int level , String message ) { log ( level , message ) ; } public void dumpLogMessages ( LogSystem newLogger ) { transferTo ( new LogChuteSystem ( newLogger ) ) ; } } 	0	['3', '2', '0', '4', '7', '3', '0', '4', '3', '2', '18', '0', '0', '0.714285714', '0.5', '0', '0', '5', '1', '0.6667', '0']
package org . apache . velocity . runtime . parser . node ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . StringReader ; import java . io . StringWriter ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . parser . ParseException ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; public class ASTStringLiteral extends SimpleNode { private boolean interpolate = true ; private SimpleNode nodeTree = null ; private String image = "" ; private String interpolateimage = "" ; private boolean containsLineComment ; public ASTStringLiteral ( int id ) { super ( id ) ; } public ASTStringLiteral ( Parser p , int id ) { super ( p , id ) ; } public Object init ( InternalContextAdapter context , Object data ) throws TemplateInitException { super . init ( context , data ) ; interpolate = rsvc . getBoolean ( RuntimeConstants . INTERPOLATE_STRINGLITERALS , true ) && getFirstToken ( ) . image . startsWith ( "\"" ) && ( ( getFirstToken ( ) . image . indexOf ( '$' ) != - 1 ) || ( getFirstToken ( ) . image . indexOf ( '#' ) != - 1 ) ) ; image = getFirstToken ( ) . image . substring ( 1 , getFirstToken ( ) . image . length ( ) - 1 ) ; containsLineComment = ( image . indexOf ( "##" ) != - 1 ) ; if ( ! containsLineComment ) { interpolateimage = image + " " ; } else { interpolateimage = image ; } if ( interpolate ) { BufferedReader br = new BufferedReader ( new StringReader ( interpolateimage ) ) ; try { nodeTree = rsvc . parse ( br , ( context != null ) ? context . getCurrentTemplateName ( ) : "StringLiteral" , false ) ; } catch ( ParseException e ) { throw new TemplateInitException ( "Problem parsing String literal." , e , ( context != null ) ? context . getCurrentTemplateName ( ) : "StringLiteral" , getColumn ( ) , getLine ( ) ) ; } nodeTree . init ( context , rsvc ) ; } return data ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object value ( InternalContextAdapter context ) { if ( interpolate ) { try { StringWriter writer = new StringWriter ( ) ; nodeTree . render ( context , writer ) ; String ret = writer . toString ( ) ; if ( ! containsLineComment && ret . length ( ) > 0 ) { return ret . substring ( 0 , ret . length ( ) - 1 ) ; } else { return ret ; } } catch ( ParseErrorException e ) { log . error ( "Error in interpolating string literal" , e ) ; } catch ( MethodInvocationException e ) { log . error ( "Error in interpolating string literal" , e ) ; } catch ( ResourceNotFoundException e ) { log . error ( "Error in interpolating string literal" , e ) ; } catch ( RuntimeException e ) { throw e ; } catch ( IOException e ) { log . error ( "Error in interpolating string literal" , e ) ; } } return image ; } } 	1	['5', '2', '0', '14', '30', '0', '4', '12', '5', '0.4', '244', '1', '1', '0.903225806', '0.433333333', '1', '1', '46.8', '4', '1.2', '7']
package org . apache . velocity . util . introspection ; import org . apache . velocity . runtime . RuntimeLogger ; import org . apache . velocity . runtime . log . Log ; public interface UberspectLoggable { public void setLog ( Log log ) ; public void setRuntimeLogger ( RuntimeLogger logger ) ; } 	0	['2', '1', '0', '4', '2', '1', '2', '2', '2', '2', '2', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . velocity . util . introspection ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; import org . apache . velocity . runtime . log . Log ; public final class IntrospectorCacheImpl implements IntrospectorCache { private final Log log ; private final Map classMapCache = new HashMap ( ) ; private final Set classNameCache = new HashSet ( ) ; private final Set listeners = new HashSet ( ) ; public IntrospectorCacheImpl ( final Log log ) { this . log = log ; } public synchronized void clear ( ) { classMapCache . clear ( ) ; classNameCache . clear ( ) ; for ( Iterator it = listeners . iterator ( ) ; it . hasNext ( ) ; ) { ( ( IntrospectorCacheListener ) it . next ( ) ) . triggerClear ( ) ; } } public synchronized ClassMap get ( final Class c ) { if ( c == null ) { throw new IllegalArgumentException ( "class is null!" ) ; } ClassMap classMap = ( ClassMap ) classMapCache . get ( c ) ; if ( classMap == null ) { if ( classNameCache . contains ( c . getName ( ) ) ) { clear ( ) ; } } for ( Iterator it = listeners . iterator ( ) ; it . hasNext ( ) ; ) { ( ( IntrospectorCacheListener ) it . next ( ) ) . triggerGet ( c , classMap ) ; } return classMap ; } public synchronized ClassMap put ( final Class c ) { ClassMap classMap = new ClassMap ( c , log ) ; classMapCache . put ( c , classMap ) ; classNameCache . add ( c . getName ( ) ) ; for ( Iterator it = listeners . iterator ( ) ; it . hasNext ( ) ; ) { ( ( IntrospectorCacheListener ) it . next ( ) ) . triggerPut ( c , classMap ) ; } return classMap ; } public void addListener ( final IntrospectorCacheListener listener ) { listeners . add ( listener ) ; } public void removeListener ( final IntrospectorCacheListener listener ) { listeners . remove ( listener ) ; } } 	1	['6', '1', '0', '5', '25', '0', '1', '4', '6', '0.4', '136', '1', '1', '0', '0.458333333', '0', '0', '21', '5', '1.8333', '2']
package org . apache . velocity . runtime . directive ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . resource . Resource ; public abstract class InputBase extends Directive { protected String getInputEncoding ( InternalContextAdapter context ) { Resource current = context . getCurrentResource ( ) ; if ( current != null ) { return current . getEncoding ( ) ; } else { return ( String ) rsvc . getProperty ( RuntimeConstants . INPUT_ENCODING ) ; } } } 	0	['2', '2', '2', '6', '6', '1', '2', '4', '1', '2', '19', '0', '0', '0.875', '0.75', '0', '0', '8.5', '2', '1', '0']
package org . apache . velocity . runtime . parser . node ; import java . io . IOException ; import java . io . Writer ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . runtime . parser . ParserVisitor ; import org . apache . velocity . runtime . parser . Token ; public interface Node { public void jjtOpen ( ) ; public void jjtClose ( ) ; public void jjtSetParent ( Node n ) ; public Node jjtGetParent ( ) ; public void jjtAddChild ( Node n , int i ) ; public Node jjtGetChild ( int i ) ; public int jjtGetNumChildren ( ) ; public Object jjtAccept ( ParserVisitor visitor , Object data ) ; public Object childrenAccept ( ParserVisitor visitor , Object data ) ; public Token getFirstToken ( ) ; public Token getLastToken ( ) ; public int getType ( ) ; public Object init ( InternalContextAdapter context , Object data ) throws TemplateInitException ; public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException ; public Object value ( InternalContextAdapter context ) throws MethodInvocationException ; public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException , ParseErrorException , ResourceNotFoundException ; public Object execute ( Object o , InternalContextAdapter context ) throws MethodInvocationException ; public void setInfo ( int info ) ; public int getInfo ( ) ; public String literal ( ) ; public void setInvalid ( ) ; public boolean isInvalid ( ) ; public int getLine ( ) ; public int getColumn ( ) ; } 	1	['24', '1', '0', '44', '24', '276', '37', '7', '24', '2', '24', '0', '0', '0', '0.244047619', '0', '0', '0', '1', '1', '2']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; public class ASTElseStatement extends SimpleNode { public ASTElseStatement ( int id ) { super ( id ) ; } public ASTElseStatement ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) { return true ; } } 	0	['4', '2', '0', '6', '7', '6', '4', '4', '4', '2', '20', '0', '0', '0.933333333', '0.416666667', '0', '0', '4', '1', '0.5', '0']
package org . apache . velocity . runtime . resource . util ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; import org . apache . velocity . runtime . resource . loader . StringResourceLoader ; public class StringResourceRepositoryImpl implements StringResourceRepository { protected Map resources = Collections . synchronizedMap ( new HashMap ( ) ) ; private String encoding = StringResourceLoader . REPOSITORY_ENCODING_DEFAULT ; public StringResource getStringResource ( final String name ) { return ( StringResource ) resources . get ( name ) ; } public void putStringResource ( final String name , final String body ) { resources . put ( name , new StringResource ( body , getEncoding ( ) ) ) ; } public void removeStringResource ( final String name ) { resources . remove ( name ) ; } public String getEncoding ( ) { return encoding ; } public void setEncoding ( final String encoding ) { this . encoding = encoding ; } } 	1	['6', '1', '0', '2', '13', '0', '0', '2', '6', '0.4', '51', '1', '0', '0', '0.833333333', '0', '0', '7.166666667', '1', '0.8333', '2']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; public class ASTTrue extends SimpleNode { private static Boolean value = Boolean . TRUE ; public ASTTrue ( int id ) { super ( id ) ; } public ASTTrue ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) { return true ; } public Object value ( InternalContextAdapter context ) { return value ; } } 	0	['6', '2', '0', '6', '9', '13', '4', '4', '5', '0.8', '28', '1', '0', '0.903225806', '0.4', '0', '0', '3.5', '1', '0.5', '0']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; import org . apache . velocity . exception . MethodInvocationException ; import java . util . HashMap ; import java . util . Map ; public class ASTMap extends SimpleNode { public ASTMap ( int id ) { super ( id ) ; } public ASTMap ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { int size = jjtGetNumChildren ( ) ; Map objectMap = new HashMap ( ) ; for ( int i = 0 ; i < size ; i += 2 ) { SimpleNode keyNode = ( SimpleNode ) jjtGetChild ( i ) ; SimpleNode valueNode = ( SimpleNode ) jjtGetChild ( i + 1 ) ; Object key = ( keyNode == null ? null : keyNode . value ( context ) ) ; Object value = ( valueNode == null ? null : valueNode . value ( context ) ) ; objectMap . put ( key , value ) ; } return objectMap ; } } 	1	['4', '2', '0', '8', '12', '6', '4', '6', '4', '2', '67', '0', '0', '0.933333333', '0.416666667', '1', '1', '15.75', '1', '0.5', '1']
package org . apache . velocity . runtime . parser ; public interface CharStream { char readChar ( ) throws java . io . IOException ; int getColumn ( ) ; int getLine ( ) ; int getEndColumn ( ) ; int getEndLine ( ) ; int getBeginColumn ( ) ; int getBeginLine ( ) ; void backup ( int amount ) ; char BeginToken ( ) throws java . io . IOException ; String GetImage ( ) ; char [ ] GetSuffix ( int len ) ; void Done ( ) ; } 	0	['12', '1', '0', '3', '12', '66', '3', '0', '12', '2', '12', '0', '0', '0', '0.583333333', '0', '0', '0', '1', '1', '0']
package org . apache . velocity . app . event ; import org . apache . velocity . context . Context ; import org . apache . velocity . util . introspection . Info ; public interface InvalidReferenceEventHandler extends EventHandler { public Object invalidGetMethod ( Context context , String reference , Object object , String property , Info info ) ; public boolean invalidSetMethod ( Context context , String leftreference , String rightreference , Info info ) ; public Object invalidMethod ( Context context , String reference , Object object , String method , Info info ) ; static class InvalidGetMethodExecutor implements EventHandlerMethodExecutor { private Context context ; private String reference ; private Object object ; private String property ; private Info info ; private Object result ; InvalidGetMethodExecutor ( Context context , String reference , Object object , String property , Info info ) { this . context = context ; this . reference = reference ; this . object = object ; this . property = property ; this . info = info ; } public void execute ( EventHandler handler ) { result = ( ( InvalidReferenceEventHandler ) handler ) . invalidGetMethod ( context , reference , object , property , info ) ; } public Object getReturnValue ( ) { return result ; } public boolean isDone ( ) { return ( result != null ) ; } } static class InvalidSetMethodExecutor implements EventHandlerMethodExecutor { private Context context ; private String leftreference ; private String rightreference ; private Info info ; private boolean result ; InvalidSetMethodExecutor ( Context context , String leftreference , String rightreference , Info info ) { this . context = context ; this . leftreference = leftreference ; this . rightreference = rightreference ; this . info = info ; } public void execute ( EventHandler handler ) { result = ( ( InvalidReferenceEventHandler ) handler ) . invalidSetMethod ( context , leftreference , rightreference , info ) ; } public Object getReturnValue ( ) { return null ; } public boolean isDone ( ) { return result ; } } static class InvalidMethodExecutor implements EventHandlerMethodExecutor { private Context context ; private String reference ; private Object object ; private String method ; private Info info ; private Object result ; private boolean executed = false ; InvalidMethodExecutor ( Context context , String reference , Object object , String method , Info info ) { this . context = context ; this . reference = reference ; this . object = object ; this . method = method ; this . info = info ; } public void execute ( EventHandler handler ) { executed = true ; result = ( ( InvalidReferenceEventHandler ) handler ) . invalidMethod ( context , reference , object , method , info ) ; } public Object getReturnValue ( ) { return result ; } public boolean isDone ( ) { return executed && ( result != null ) ; } } } 	1	['3', '1', '0', '9', '3', '3', '6', '3', '3', '2', '3', '0', '0', '0', '0.933333333', '0', '0', '0', '1', '1', '1']
package org . apache . velocity . runtime . parser ; public class Token { public int kind ; public int beginLine , beginColumn , endLine , endColumn ; public String image ; public Token next ; public Token specialToken ; public String toString ( ) { return image ; } public static final Token newToken ( int ofKind ) { switch ( ofKind ) { default : return new Token ( ) ; } } } 	0	['3', '1', '0', '24', '4', '3', '24', '0', '3', '1.4375', '23', '0', '2', '0', '0.5', '0', '0', '4', '2', '1', '0']
package org . apache . velocity . runtime . parser . node ; import java . lang . reflect . InvocationTargetException ; import org . apache . commons . lang . StringUtils ; import org . apache . velocity . runtime . RuntimeLogger ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . log . RuntimeLoggerLog ; import org . apache . velocity . util . introspection . Introspector ; public class PropertyExecutor extends AbstractExecutor { private final Introspector introspector ; public PropertyExecutor ( final Log log , final Introspector introspector , final Class clazz , final String property ) { this . log = log ; this . introspector = introspector ; if ( StringUtils . isNotEmpty ( property ) ) { discover ( clazz , property ) ; } } public PropertyExecutor ( final RuntimeLogger r , final Introspector introspector , final Class clazz , final String property ) { this ( new RuntimeLoggerLog ( r ) , introspector , clazz , property ) ; } protected Introspector getIntrospector ( ) { return this . introspector ; } protected void discover ( final Class clazz , final String property ) { try { Object [ ] params = { } ; StringBuffer sb = new StringBuffer ( "get" ) ; sb . append ( property ) ; setMethod ( introspector . getMethod ( clazz , sb . toString ( ) , params ) ) ; if ( ! isAlive ( ) ) { char c = sb . charAt ( 3 ) ; if ( Character . isLowerCase ( c ) ) { sb . setCharAt ( 3 , Character . toUpperCase ( c ) ) ; } else { sb . setCharAt ( 3 , Character . toLowerCase ( c ) ) ; } setMethod ( introspector . getMethod ( clazz , sb . toString ( ) , params ) ) ; } } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { log . error ( "While looking for property getter for '" + property + "':" , e ) ; } } public Object execute ( Object o ) throws IllegalAccessException , InvocationTargetException { return isAlive ( ) ? getMethod ( ) . invoke ( o , ( ( Object [ ] ) null ) ) : null ; } } 	1	['5', '2', '1', '8', '23', '4', '2', '6', '3', '0.25', '118', '1', '1', '0.571428571', '0.457142857', '0', '0', '22.4', '2', '0.8', '2']
package org . apache . velocity . app . event ; public interface EventHandler { } 	0	['0', '1', '0', '16', '0', '0', '16', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . runtime . RuntimeLogger ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . log . RuntimeLoggerLog ; import org . apache . velocity . util . introspection . Introspector ; public class BooleanPropertyExecutor extends PropertyExecutor { public BooleanPropertyExecutor ( final Log log , final Introspector introspector , final Class clazz , final String property ) { super ( log , introspector , clazz , property ) ; } public BooleanPropertyExecutor ( final RuntimeLogger rlog , final Introspector introspector , final Class clazz , final String property ) { super ( new RuntimeLoggerLog ( rlog ) , introspector , clazz , property ) ; } protected void discover ( final Class clazz , final String property ) { try { Object [ ] params = { } ; StringBuffer sb = new StringBuffer ( "is" ) ; sb . append ( property ) ; setMethod ( getIntrospector ( ) . getMethod ( clazz , sb . toString ( ) , params ) ) ; if ( ! isAlive ( ) ) { char c = sb . charAt ( 2 ) ; if ( Character . isLowerCase ( c ) ) { sb . setCharAt ( 2 , Character . toUpperCase ( c ) ) ; } else { sb . setCharAt ( 2 , Character . toLowerCase ( c ) ) ; } setMethod ( getIntrospector ( ) . getMethod ( clazz , sb . toString ( ) , params ) ) ; } if ( isAlive ( ) ) { if ( getMethod ( ) . getReturnType ( ) != Boolean . TYPE ) { setMethod ( null ) ; } } } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { log . error ( "While looking for boolean property getter for '" + property + "':" , e ) ; } } } 	1	['3', '3', '0', '6', '21', '3', '1', '5', '2', '2', '102', '0', '0', '0.875', '0.722222222', '2', '2', '33', '3', '1', '3']
package org . apache . velocity . runtime ; public interface RuntimeLogger { public void warn ( Object message ) ; public void info ( Object message ) ; public void error ( Object message ) ; public void debug ( Object message ) ; } 	0	['4', '1', '0', '8', '4', '6', '8', '0', '4', '2', '4', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . velocity . util . introspection ; public interface IntrospectorCache { void clear ( ) ; ClassMap get ( Class c ) ; ClassMap put ( Class c ) ; void addListener ( IntrospectorCacheListener listener ) ; void removeListener ( IntrospectorCacheListener listener ) ; } 	1	['5', '1', '0', '4', '5', '10', '2', '2', '5', '2', '5', '0', '0', '0', '0.6', '0', '0', '0', '1', '1', '2']
package org . apache . velocity . servlet ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . StringWriter ; import java . io . UnsupportedEncodingException ; import java . util . Properties ; import javax . servlet . ServletConfig ; import javax . servlet . ServletContext ; import javax . servlet . ServletException ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServlet ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . apache . velocity . Template ; import org . apache . velocity . VelocityContext ; import org . apache . velocity . app . Velocity ; import org . apache . velocity . context . Context ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . io . VelocityWriter ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeSingleton ; import org . apache . velocity . util . SimplePool ; public abstract class VelocityServlet extends HttpServlet { public static final String REQUEST = "req" ; public static final String RESPONSE = "res" ; public static final String CONTENT_TYPE = "default.contentType" ; public static final String DEFAULT_CONTENT_TYPE = "text/html" ; public static final String DEFAULT_OUTPUT_ENCODING = "ISO-8859-1" ; private static String defaultContentType ; protected static final String INIT_PROPS_KEY = "org.apache.velocity.properties" ; private static final String OLD_INIT_PROPS_KEY = "properties" ; private static SimplePool writerPool = new SimplePool ( 40 ) ; public void init ( ServletConfig config ) throws ServletException { super . init ( config ) ; initVelocity ( config ) ; VelocityServlet . defaultContentType = RuntimeSingleton . getString ( CONTENT_TYPE , DEFAULT_CONTENT_TYPE ) ; } protected void initVelocity ( ServletConfig config ) throws ServletException { try { Properties props = loadConfiguration ( config ) ; Velocity . init ( props ) ; } catch ( Exception e ) { throw new ServletException ( "Error initializing Velocity: " + e , e ) ; } } protected Properties loadConfiguration ( ServletConfig config ) throws IOException , FileNotFoundException { String propsFile = config . getInitParameter ( INIT_PROPS_KEY ) ; if ( propsFile == null || propsFile . length ( ) == 0 ) { ServletContext sc = config . getServletContext ( ) ; propsFile = config . getInitParameter ( OLD_INIT_PROPS_KEY ) ; if ( propsFile == null || propsFile . length ( ) == 0 ) { propsFile = sc . getInitParameter ( INIT_PROPS_KEY ) ; if ( propsFile == null || propsFile . length ( ) == 0 ) { propsFile = sc . getInitParameter ( OLD_INIT_PROPS_KEY ) ; if ( propsFile != null && propsFile . length ( ) > 0 ) { sc . log ( "Use of the properties initialization " + "parameter '" + OLD_INIT_PROPS_KEY + "' has " + "been deprecated by '" + INIT_PROPS_KEY + '\'' ) ; } } } else { sc . log ( "Use of the properties initialization parameter '" + OLD_INIT_PROPS_KEY + "' has been deprecated by '" + INIT_PROPS_KEY + '\'' ) ; } } Properties p = new Properties ( ) ; if ( propsFile != null ) { p . load ( getServletContext ( ) . getResourceAsStream ( propsFile ) ) ; } return p ; } public void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { doRequest ( request , response ) ; } public void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { doRequest ( request , response ) ; } protected void doRequest ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { Context context = null ; try { context = createContext ( request , response ) ; setContentType ( request , response ) ; Template template = handleRequest ( request , response , context ) ; if ( template == null ) { return ; } mergeTemplate ( template , context , response ) ; } catch ( Exception e ) { error ( request , response , e ) ; } finally { requestCleanup ( request , response , context ) ; } } protected void requestCleanup ( HttpServletRequest request , HttpServletResponse response , Context context ) { } protected void mergeTemplate ( Template template , Context context , HttpServletResponse response ) throws ResourceNotFoundException , ParseErrorException , MethodInvocationException , IOException , UnsupportedEncodingException , Exception { ServletOutputStream output = response . getOutputStream ( ) ; VelocityWriter vw = null ; String encoding = response . getCharacterEncoding ( ) ; try { vw = ( VelocityWriter ) writerPool . get ( ) ; if ( vw == null ) { vw = new VelocityWriter ( new OutputStreamWriter ( output , encoding ) , 4 * 1024 , true ) ; } else { vw . recycle ( new OutputStreamWriter ( output , encoding ) ) ; } template . merge ( context , vw ) ; } finally { if ( vw != null ) { try { vw . flush ( ) ; } catch ( IOException e ) { } vw . recycle ( null ) ; writerPool . put ( vw ) ; } } } protected void setContentType ( HttpServletRequest request , HttpServletResponse response ) { String contentType = VelocityServlet . defaultContentType ; int index = contentType . lastIndexOf ( ';' ) + 1 ; if ( index <= 0 || ( index < contentType . length ( ) && contentType . indexOf ( "charset" , index ) == - 1 ) ) { String encoding = chooseCharacterEncoding ( request ) ; if ( ! DEFAULT_OUTPUT_ENCODING . equalsIgnoreCase ( encoding ) ) { contentType += "; charset=" + encoding ; } } response . setContentType ( contentType ) ; } protected String chooseCharacterEncoding ( HttpServletRequest request ) { return RuntimeSingleton . getString ( RuntimeConstants . OUTPUT_ENCODING , DEFAULT_OUTPUT_ENCODING ) ; } protected Context createContext ( HttpServletRequest request , HttpServletResponse response ) { VelocityContext context = new VelocityContext ( ) ; context . put ( REQUEST , request ) ; context . put ( RESPONSE , response ) ; return context ; } public Template getTemplate ( String name ) throws ResourceNotFoundException , ParseErrorException , Exception { return RuntimeSingleton . getTemplate ( name ) ; } public Template getTemplate ( String name , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception { return RuntimeSingleton . getTemplate ( name , encoding ) ; } protected Template handleRequest ( HttpServletRequest request , HttpServletResponse response , Context ctx ) throws Exception { Template t = handleRequest ( ctx ) ; if ( t == null ) { throw new Exception ( "handleRequest(Context) returned null - no template selected!" ) ; } return t ; } protected Template handleRequest ( Context ctx ) throws Exception { throw new Exception ( "You must override VelocityServlet.handleRequest( Context) " + " or VelocityServlet.handleRequest( HttpServletRequest, " + " HttpServletResponse, Context)" ) ; } protected void error ( HttpServletRequest request , HttpServletResponse response , Exception cause ) throws ServletException , IOException { StringBuffer html = new StringBuffer ( ) ; html . append ( "<html>" ) ; html . append ( "<title>Error</title>" ) ; html . append ( "<body bgcolor=\"#ffffff\">" ) ; html . append ( "<h2>VelocityServlet: Error processing the template</h2>" ) ; html . append ( "<pre>" ) ; String why = cause . getMessage ( ) ; if ( why != null && why . trim ( ) . length ( ) > 0 ) { html . append ( why ) ; html . append ( "<br>" ) ; } StringWriter sw = new StringWriter ( ) ; cause . printStackTrace ( new PrintWriter ( sw ) ) ; html . append ( sw . toString ( ) ) ; html . append ( "</pre>" ) ; html . append ( "</body>" ) ; html . append ( "</html>" ) ; response . getOutputStream ( ) . print ( html . toString ( ) ) ; } } 	0	['18', '3', '0', '10', '62', '149', '0', '10', '6', '1.019607843', '417', '0.444444444', '1', '0.6', '0.338235294', '1', '2', '21.66666667', '5', '1.1111', '0']
package org . apache . velocity . runtime . visitor ; import java . util . Map ; import org . apache . velocity . runtime . parser . node . ASTReference ; public class VMReferenceMungeVisitor extends BaseVisitor { private Map argmap = null ; public VMReferenceMungeVisitor ( Map map ) { argmap = map ; } public Object visit ( ASTReference node , Object data ) { String override = ( String ) argmap . get ( node . literal ( ) . substring ( 1 ) ) ; if ( override != null ) { node . setLiteral ( override ) ; } data = node . childrenAccept ( this , data ) ; return data ; } } 	1	['2', '2', '0', '4', '8', '0', '1', '3', '2', '0', '33', '1', '0', '0.977272727', '0.625', '0', '0', '15', '2', '1', '2']
package org . apache . velocity . runtime . log ; public class NullLogSystem extends NullLogChute implements LogSystem { public void logVelocityMessage ( int level , String message ) { } } 	0	['2', '2', '0', '2', '3', '1', '0', '2', '2', '2', '6', '0', '0', '0.8', '0.666666667', '0', '0', '2', '1', '0.5', '0']
package org . apache . velocity . runtime . parser . node ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . util . HashMap ; import java . util . Map ; import java . util . List ; import java . util . ArrayList ; public abstract class MathUtils { protected static final BigDecimal DECIMAL_ZERO = new BigDecimal ( BigInteger . ZERO ) ; protected static final int BASE_LONG = 0 ; protected static final int BASE_FLOAT = 1 ; protected static final int BASE_DOUBLE = 2 ; protected static final int BASE_BIGINTEGER = 3 ; protected static final int BASE_BIGDECIMAL = 4 ; protected static final Map ints = new HashMap ( ) ; static { ints . put ( Byte . class , BigDecimal . valueOf ( Byte . MAX_VALUE ) ) ; ints . put ( Short . class , BigDecimal . valueOf ( Short . MAX_VALUE ) ) ; ints . put ( Integer . class , BigDecimal . valueOf ( Integer . MAX_VALUE ) ) ; ints . put ( Long . class , BigDecimal . valueOf ( Long . MAX_VALUE ) ) ; ints . put ( BigInteger . class , BigDecimal . valueOf ( - 1 ) ) ; } protected static final List typesBySize = new ArrayList ( ) ; static { typesBySize . add ( Byte . class ) ; typesBySize . add ( Short . class ) ; typesBySize . add ( Integer . class ) ; typesBySize . add ( Long . class ) ; typesBySize . add ( Float . class ) ; typesBySize . add ( Double . class ) ; } public static BigDecimal toBigDecimal ( Number n ) { if ( n instanceof BigDecimal ) { return ( BigDecimal ) n ; } if ( n instanceof BigInteger ) { return new BigDecimal ( ( BigInteger ) n ) ; } return new BigDecimal ( n . doubleValue ( ) ) ; } public static BigInteger toBigInteger ( Number n ) { if ( n instanceof BigInteger ) { return ( BigInteger ) n ; } return BigInteger . valueOf ( n . longValue ( ) ) ; } public static boolean isZero ( Number n ) { if ( isInteger ( n ) ) { if ( n instanceof BigInteger ) { return ( ( BigInteger ) n ) . compareTo ( BigInteger . ZERO ) == 0 ; } return n . doubleValue ( ) == 0 ; } if ( n instanceof Float ) { return n . floatValue ( ) == 0f ; } if ( n instanceof Double ) { return n . doubleValue ( ) == 0d ; } return toBigDecimal ( n ) . compareTo ( DECIMAL_ZERO ) == 0 ; } public static boolean isInteger ( Number n ) { return ints . containsKey ( n . getClass ( ) ) ; } public static Number wrapPrimitive ( long value , Class type ) { if ( type == Byte . class ) { if ( value > Byte . MAX_VALUE || value < Byte . MIN_VALUE ) { type = Short . class ; } else { return new Byte ( ( byte ) value ) ; } } if ( type == Short . class ) { if ( value > Short . MAX_VALUE || value < Short . MIN_VALUE ) { type = Integer . class ; } else { return new Short ( ( short ) value ) ; } } if ( type == Integer . class ) { if ( value > Integer . MAX_VALUE || value < Integer . MIN_VALUE ) { type = Long . class ; } else { return new Integer ( ( int ) value ) ; } } if ( type == Long . class ) { return new Long ( value ) ; } return BigInteger . valueOf ( value ) ; } private static Number wrapPrimitive ( long value , Number op1 , Number op2 ) { if ( typesBySize . indexOf ( op1 . getClass ( ) ) > typesBySize . indexOf ( op2 . getClass ( ) ) ) { return wrapPrimitive ( value , op1 . getClass ( ) ) ; } return wrapPrimitive ( value , op2 . getClass ( ) ) ; } private static int findCalculationBase ( Number op1 , Number op2 ) { boolean op1Int = isInteger ( op1 ) ; boolean op2Int = isInteger ( op2 ) ; if ( ( op1 instanceof BigDecimal || op2 instanceof BigDecimal ) || ( ( ! op1Int || ! op2Int ) && ( op1 instanceof BigInteger || op2 instanceof BigInteger ) ) ) { return BASE_BIGDECIMAL ; } if ( op1Int && op2Int ) { if ( op1 instanceof BigInteger || op2 instanceof BigInteger ) { return BASE_BIGINTEGER ; } return BASE_LONG ; } if ( ( op1 instanceof Double ) || ( op2 instanceof Double ) ) { return BASE_DOUBLE ; } return BASE_FLOAT ; } public static Number add ( Number op1 , Number op2 ) { int calcBase = findCalculationBase ( op1 , op2 ) ; switch ( calcBase ) { case BASE_BIGINTEGER : return toBigInteger ( op1 ) . add ( toBigInteger ( op2 ) ) ; case BASE_LONG : long l1 = op1 . longValue ( ) ; long l2 = op2 . longValue ( ) ; long result = l1 + l2 ; if ( ( result ^ l1 ) < 0 && ( result ^ l2 ) < 0 ) { return toBigInteger ( op1 ) . add ( toBigInteger ( op2 ) ) ; } return wrapPrimitive ( result , op1 , op2 ) ; case BASE_FLOAT : return new Float ( op1 . floatValue ( ) + op2 . floatValue ( ) ) ; case BASE_DOUBLE : return new Double ( op1 . doubleValue ( ) + op2 . doubleValue ( ) ) ; default : return toBigDecimal ( op1 ) . add ( toBigDecimal ( op2 ) ) ; } } public static Number subtract ( Number op1 , Number op2 ) { int calcBase = findCalculationBase ( op1 , op2 ) ; switch ( calcBase ) { case BASE_BIGINTEGER : return toBigInteger ( op1 ) . subtract ( toBigInteger ( op2 ) ) ; case BASE_LONG : long l1 = op1 . longValue ( ) ; long l2 = op2 . longValue ( ) ; long result = l1 - l2 ; if ( ( result ^ l1 ) < 0 && ( result ^ ~ l2 ) < 0 ) { return toBigInteger ( op1 ) . subtract ( toBigInteger ( op2 ) ) ; } return wrapPrimitive ( result , op1 , op2 ) ; case BASE_FLOAT : return new Float ( op1 . floatValue ( ) - op2 . floatValue ( ) ) ; case BASE_DOUBLE : return new Double ( op1 . doubleValue ( ) - op2 . doubleValue ( ) ) ; default : return toBigDecimal ( op1 ) . subtract ( toBigDecimal ( op2 ) ) ; } } public static Number multiply ( Number op1 , Number op2 ) { int calcBase = findCalculationBase ( op1 , op2 ) ; switch ( calcBase ) { case BASE_BIGINTEGER : return toBigInteger ( op1 ) . multiply ( toBigInteger ( op2 ) ) ; case BASE_LONG : long l1 = op1 . longValue ( ) ; long l2 = op2 . longValue ( ) ; long result = l1 * l2 ; if ( ( l2 != 0 ) && ( result / l2 != l1 ) ) { return toBigInteger ( op1 ) . multiply ( toBigInteger ( op2 ) ) ; } return wrapPrimitive ( result , op1 , op2 ) ; case BASE_FLOAT : return new Float ( op1 . floatValue ( ) * op2 . floatValue ( ) ) ; case BASE_DOUBLE : return new Double ( op1 . doubleValue ( ) * op2 . doubleValue ( ) ) ; default : return toBigDecimal ( op1 ) . multiply ( toBigDecimal ( op2 ) ) ; } } public static Number divide ( Number op1 , Number op2 ) { int calcBase = findCalculationBase ( op1 , op2 ) ; switch ( calcBase ) { case BASE_BIGINTEGER : BigInteger b1 = toBigInteger ( op1 ) ; BigInteger b2 = toBigInteger ( op2 ) ; return b1 . divide ( b2 ) ; case BASE_LONG : long l1 = op1 . longValue ( ) ; long l2 = op2 . longValue ( ) ; return wrapPrimitive ( l1 / l2 , op1 , op2 ) ; case BASE_FLOAT : return new Float ( op1 . floatValue ( ) / op2 . floatValue ( ) ) ; case BASE_DOUBLE : return new Double ( op1 . doubleValue ( ) / op2 . doubleValue ( ) ) ; default : return toBigDecimal ( op1 ) . divide ( toBigDecimal ( op2 ) , BigDecimal . ROUND_HALF_DOWN ) ; } } public static Number modulo ( Number op1 , Number op2 ) throws ArithmeticException { int calcBase = findCalculationBase ( op1 , op2 ) ; switch ( calcBase ) { case BASE_BIGINTEGER : return toBigInteger ( op1 ) . mod ( toBigInteger ( op2 ) ) ; case BASE_LONG : return wrapPrimitive ( op1 . longValue ( ) % op2 . longValue ( ) , op1 , op2 ) ; case BASE_FLOAT : return new Float ( op1 . floatValue ( ) % op2 . floatValue ( ) ) ; case BASE_DOUBLE : return new Double ( op1 . doubleValue ( ) % op2 . doubleValue ( ) ) ; default : throw new ArithmeticException ( "Cannot calculate the modulo of BigDecimals." ) ; } } public static int compare ( Number op1 , Number op2 ) { int calcBase = findCalculationBase ( op1 , op2 ) ; switch ( calcBase ) { case BASE_BIGINTEGER : return toBigInteger ( op1 ) . compareTo ( toBigInteger ( op2 ) ) ; case BASE_LONG : long l1 = op1 . longValue ( ) ; long l2 = op2 . longValue ( ) ; if ( l1 < l2 ) { return - 1 ; } if ( l1 > l2 ) { return 1 ; } return 0 ; case BASE_FLOAT : float f1 = op1 . floatValue ( ) ; float f2 = op2 . floatValue ( ) ; if ( f1 < f2 ) { return - 1 ; } if ( f1 > f2 ) { return 1 ; } return 0 ; case BASE_DOUBLE : double d1 = op1 . doubleValue ( ) ; double d2 = op2 . doubleValue ( ) ; if ( d1 < d2 ) { return - 1 ; } if ( d1 > d2 ) { return 1 ; } return 0 ; default : return toBigDecimal ( op1 ) . compareTo ( toBigDecimal ( op2 ) ) ; } } } 	1	['16', '1', '0', '11', '52', '112', '11', '0', '12', '0.826666667', '854', '0.533333333', '0', '0', '0.226666667', '0', '0', '51.4375', '18', '4.5625', '1']
package org . apache . velocity . runtime . directive ; import java . io . IOException ; import java . io . Writer ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . parser . node . Node ; public class Literal extends Directive { String literalText ; public String getName ( ) { return "literal" ; } public int getType ( ) { return BLOCK ; } public void init ( RuntimeServices rs , InternalContextAdapter context , Node node ) throws TemplateInitException { super . init ( rs , context , node ) ; literalText = node . jjtGetChild ( 0 ) . literal ( ) ; } public boolean render ( InternalContextAdapter context , Writer writer , Node node ) throws IOException { writer . write ( literalText ) ; return true ; } } 	0	['5', '2', '0', '5', '10', '8', '0', '5', '5', '0.75', '31', '0', '0', '0.636363636', '0.44', '0', '0', '5', '1', '0.8', '0']
package org . apache . velocity . runtime . visitor ; import org . apache . velocity . runtime . parser . Token ; import org . apache . velocity . runtime . parser . node . ASTAddNode ; import org . apache . velocity . runtime . parser . node . ASTAndNode ; import org . apache . velocity . runtime . parser . node . ASTAssignment ; import org . apache . velocity . runtime . parser . node . ASTBlock ; import org . apache . velocity . runtime . parser . node . ASTDirective ; import org . apache . velocity . runtime . parser . node . ASTDivNode ; import org . apache . velocity . runtime . parser . node . ASTEQNode ; import org . apache . velocity . runtime . parser . node . ASTElseIfStatement ; import org . apache . velocity . runtime . parser . node . ASTElseStatement ; import org . apache . velocity . runtime . parser . node . ASTEscape ; import org . apache . velocity . runtime . parser . node . ASTEscapedDirective ; import org . apache . velocity . runtime . parser . node . ASTExpression ; import org . apache . velocity . runtime . parser . node . ASTFalse ; import org . apache . velocity . runtime . parser . node . ASTFloatingPointLiteral ; import org . apache . velocity . runtime . parser . node . ASTGENode ; import org . apache . velocity . runtime . parser . node . ASTGTNode ; import org . apache . velocity . runtime . parser . node . ASTIdentifier ; import org . apache . velocity . runtime . parser . node . ASTIfStatement ; import org . apache . velocity . runtime . parser . node . ASTIntegerLiteral ; import org . apache . velocity . runtime . parser . node . ASTIntegerRange ; import org . apache . velocity . runtime . parser . node . ASTLENode ; import org . apache . velocity . runtime . parser . node . ASTLTNode ; import org . apache . velocity . runtime . parser . node . ASTMap ; import org . apache . velocity . runtime . parser . node . ASTMethod ; import org . apache . velocity . runtime . parser . node . ASTModNode ; import org . apache . velocity . runtime . parser . node . ASTMulNode ; import org . apache . velocity . runtime . parser . node . ASTNENode ; import org . apache . velocity . runtime . parser . node . ASTNotNode ; import org . apache . velocity . runtime . parser . node . ASTObjectArray ; import org . apache . velocity . runtime . parser . node . ASTOrNode ; import org . apache . velocity . runtime . parser . node . ASTReference ; import org . apache . velocity . runtime . parser . node . ASTSetDirective ; import org . apache . velocity . runtime . parser . node . ASTStop ; import org . apache . velocity . runtime . parser . node . ASTStringLiteral ; import org . apache . velocity . runtime . parser . node . ASTSubtractNode ; import org . apache . velocity . runtime . parser . node . ASTText ; import org . apache . velocity . runtime . parser . node . ASTTrue ; import org . apache . velocity . runtime . parser . node . ASTWord ; import org . apache . velocity . runtime . parser . node . ASTprocess ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . runtime . parser . node . SimpleNode ; public class NodeViewMode extends BaseVisitor { private int indent = 0 ; private boolean showTokens = true ; private String indentString ( ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < indent ; ++ i ) { sb . append ( "  " ) ; } return sb . toString ( ) ; } private Object showNode ( Node node , Object data ) { String tokens = "" ; String special = "" ; Token t ; if ( showTokens ) { t = node . getFirstToken ( ) ; if ( t . specialToken != null && ! t . specialToken . image . startsWith ( "##" ) ) special = t . specialToken . image ; tokens = " -> " + special + t . image ; } System . out . println ( indentString ( ) + node + tokens ) ; ++ indent ; data = node . childrenAccept ( this , data ) ; -- indent ; return data ; } public Object visit ( SimpleNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTprocess node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTExpression node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTAssignment node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTOrNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTAndNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTEQNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTNENode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTLTNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTGTNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTLENode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTGENode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTAddNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTSubtractNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTMulNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTDivNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTModNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTNotNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTFloatingPointLiteral node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTIntegerLiteral node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTStringLiteral node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTIdentifier node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTMethod node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTReference node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTTrue node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTFalse node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTBlock node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTText node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTIfStatement node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTElseStatement node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTElseIfStatement node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTObjectArray node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTDirective node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTWord node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTSetDirective node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTEscapedDirective node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTEscape node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTMap node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTIntegerRange node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTStop node , Object data ) { return showNode ( node , data ) ; } } 	1	['43', '2', '0', '44', '52', '897', '0', '44', '41', '0.011904762', '340', '1', '0', '0.505882353', '0.06760411', '0', '0', '6.860465116', '4', '1.0698', '1']
package org . apache . velocity . util ; public final class SimplePool { private Object pool [ ] ; private int max ; private int current = - 1 ; public SimplePool ( int max ) { this . max = max ; pool = new Object [ max ] ; } public void put ( Object o ) { int idx = - 1 ; synchronized ( this ) { if ( current < max - 1 ) { idx = ++ current ; } if ( idx >= 0 ) { pool [ idx ] = o ; } } } public Object get ( ) { synchronized ( this ) { if ( current >= 0 ) { Object o = pool [ current ] ; pool [ current ] = null ; current -- ; return o ; } } return null ; } public int getMax ( ) { return max ; } Object [ ] getPool ( ) { return pool ; } } 	0	['5', '1', '0', '2', '6', '0', '2', '0', '4', '0.416666667', '103', '1', '0', '0', '0.466666667', '0', '0', '19', '3', '1.4', '0']
package org . apache . velocity . util ; import org . apache . velocity . runtime . RuntimeServices ; public interface RuntimeServicesAware { public void setRuntimeServices ( RuntimeServices rs ) ; } 	1	['1', '1', '0', '8', '1', '0', '7', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . velocity . anakia ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Iterator ; import org . jdom . Element ; public class TreeWalker { public TreeWalker ( ) { } public NodeList allElements ( Element e ) { ArrayList theElements = new ArrayList ( ) ; treeWalk ( e , theElements ) ; return new NodeList ( theElements , false ) ; } private final void treeWalk ( Element e , Collection theElements ) { for ( Iterator i = e . getChildren ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Element child = ( Element ) i . next ( ) ; theElements . add ( child ) ; treeWalk ( child , theElements ) ; } } } 	0	['3', '1', '0', '3', '11', '3', '1', '2', '2', '2', '41', '0', '0', '0', '0.666666667', '0', '0', '12.66666667', '2', '1', '0']
package org . apache . velocity . runtime . parser . node ; import java . util . ArrayList ; import java . util . List ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; public class ASTIntegerRange extends SimpleNode { public ASTIntegerRange ( int id ) { super ( id ) ; } public ASTIntegerRange ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { Object left = jjtGetChild ( 0 ) . value ( context ) ; Object right = jjtGetChild ( 1 ) . value ( context ) ; if ( left == null || right == null ) { log . error ( ( left == null ? "Left" : "Right" ) + " side of range operator [n..m] has null value." + " Operation not possible. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return null ; } if ( ! ( left instanceof Integer ) || ! ( right instanceof Integer ) ) { log . error ( ( ! ( left instanceof Integer ) ? "Left" : "Right" ) + " side of range operator is not a valid type. " + "Currently only integers (1,2,3...) and Integer type is supported. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return null ; } int l = ( ( Integer ) left ) . intValue ( ) ; int r = ( ( Integer ) right ) . intValue ( ) ; int nbrElements = Math . abs ( l - r ) ; nbrElements += 1 ; int delta = ( l >= r ) ? - 1 : 1 ; List elements = new ArrayList ( nbrElements ) ; int value = l ; for ( int i = 0 ; i < nbrElements ; i ++ ) { elements . add ( new Integer ( value ) ) ; value += delta ; } return elements ; } } 	1	['4', '2', '0', '9', '22', '6', '4', '7', '4', '2', '157', '0', '0', '0.933333333', '0.416666667', '1', '1', '38.25', '1', '0.5', '1']
package org . apache . velocity . anakia ; import java . util . List ; import org . jdom . Document ; import org . jdom . Element ; public class XPathTool { public XPathTool ( ) { } public NodeList applyTo ( String xpathSpec , Document doc ) { return new NodeList ( XPathCache . getXPath ( xpathSpec ) . applyTo ( doc ) , false ) ; } public NodeList applyTo ( String xpathSpec , Element elem ) { return new NodeList ( XPathCache . getXPath ( xpathSpec ) . applyTo ( elem ) , false ) ; } public NodeList applyTo ( String xpathSpec , List nodeSet ) { return new NodeList ( XPathCache . getXPath ( xpathSpec ) . applyTo ( nodeSet ) , false ) ; } } 	0	['4', '1', '0', '6', '10', '6', '1', '5', '4', '2', '34', '0', '0', '0', '0.5', '0', '0', '7.5', '1', '0.75', '0']
package org . apache . velocity . runtime . directive ; import java . io . BufferedReader ; import java . io . StringReader ; import java . io . StringWriter ; import org . apache . velocity . VelocityContext ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . context . InternalContextAdapterImpl ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . parser . ParserTreeConstants ; import org . apache . velocity . runtime . parser . node . ASTReference ; import org . apache . velocity . runtime . parser . node . SimpleNode ; public class VMProxyArg { private static final int GENERALSTATIC = - 1 ; private int type = 0 ; private SimpleNode nodeTree = null ; private Object staticObject = null ; private int numTreeChildren = 0 ; private String contextReference = null ; private String callerReference = null ; private String singleLevelRef = null ; private boolean constant = false ; private RuntimeServices rsvc = null ; private Log log = null ; public VMProxyArg ( RuntimeServices rs , String contextRef , String callerRef , int t ) { rsvc = rs ; log = rsvc . getLog ( ) ; contextReference = contextRef ; callerReference = callerRef ; type = t ; setup ( ) ; if ( nodeTree != null ) { numTreeChildren = nodeTree . jjtGetNumChildren ( ) ; } if ( type == ParserTreeConstants . JJTREFERENCE ) { if ( numTreeChildren == 0 ) { singleLevelRef = ( ( ASTReference ) nodeTree ) . getRootString ( ) ; } } } public boolean isConstant ( ) { return constant ; } public Object setObject ( InternalContextAdapter context , Object o ) { if ( type == ParserTreeConstants . JJTREFERENCE ) { if ( numTreeChildren > 0 ) { try { ( ( ASTReference ) nodeTree ) . setValue ( context , o ) ; } catch ( MethodInvocationException mie ) { log . error ( "VMProxyArg.getObject() : method invocation error setting value" , mie ) ; } } else { context . put ( singleLevelRef , o ) ; } } else { type = GENERALSTATIC ; staticObject = o ; log . error ( "VMProxyArg.setObject() : Programmer error : I am a constant!  No setting! : " + contextReference + " / " + callerReference ) ; } return null ; } public Object getObject ( InternalContextAdapter context ) throws MethodInvocationException { try { Object retObject = null ; if ( type == ParserTreeConstants . JJTREFERENCE ) { if ( numTreeChildren == 0 ) { retObject = context . get ( singleLevelRef ) ; } else { retObject = nodeTree . execute ( null , context ) ; } } else if ( type == ParserTreeConstants . JJTMAP ) { retObject = nodeTree . value ( context ) ; } else if ( type == ParserTreeConstants . JJTOBJECTARRAY ) { retObject = nodeTree . value ( context ) ; } else if ( type == ParserTreeConstants . JJTINTEGERRANGE ) { retObject = nodeTree . value ( context ) ; } else if ( type == ParserTreeConstants . JJTTRUE ) { retObject = staticObject ; } else if ( type == ParserTreeConstants . JJTFALSE ) { retObject = staticObject ; } else if ( type == ParserTreeConstants . JJTSTRINGLITERAL ) { retObject = nodeTree . value ( context ) ; } else if ( type == ParserTreeConstants . JJTINTEGERLITERAL ) { retObject = staticObject ; } else if ( type == ParserTreeConstants . JJTFLOATINGPOINTLITERAL ) { retObject = staticObject ; } else if ( type == ParserTreeConstants . JJTTEXT ) { try { StringWriter writer = new StringWriter ( ) ; nodeTree . render ( context , writer ) ; retObject = writer ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { log . error ( "VMProxyArg.getObject() : error rendering reference" , e ) ; } } else if ( type == GENERALSTATIC ) { retObject = staticObject ; } else { log . error ( "Unsupported VM arg type : VM arg = " + callerReference + " type = " + type + "( VMProxyArg.getObject() )" ) ; } return retObject ; } catch ( MethodInvocationException mie ) { log . error ( "VMProxyArg.getObject() : method invocation error getting value" , mie ) ; throw mie ; } } private void setup ( ) { switch ( type ) { case ParserTreeConstants . JJTINTEGERRANGE : case ParserTreeConstants . JJTREFERENCE : case ParserTreeConstants . JJTOBJECTARRAY : case ParserTreeConstants . JJTMAP : case ParserTreeConstants . JJTSTRINGLITERAL : case ParserTreeConstants . JJTTEXT : { constant = false ; try { String buff = "#include(" + callerReference + " ) " ; BufferedReader br = new BufferedReader ( new StringReader ( buff ) ) ; nodeTree = rsvc . parse ( br , "VMProxyArg:" + callerReference , true ) ; nodeTree = ( SimpleNode ) nodeTree . jjtGetChild ( 0 ) . jjtGetChild ( 0 ) ; if ( nodeTree != null ) { if ( nodeTree . getType ( ) != type ) { log . error ( "VMProxyArg.setup() : programmer error : type doesn't match node type." ) ; } InternalContextAdapter ica = new InternalContextAdapterImpl ( new VelocityContext ( ) ) ; ica . pushCurrentTemplateName ( "VMProxyArg : " + ParserTreeConstants . jjtNodeName [ type ] ) ; nodeTree . init ( ica , rsvc ) ; } } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { log . error ( "VMProxyArg.setup() : exception " + callerReference , e ) ; } break ; } case ParserTreeConstants . JJTTRUE : { constant = true ; staticObject = Boolean . TRUE ; break ; } case ParserTreeConstants . JJTFALSE : { constant = true ; staticObject = Boolean . FALSE ; break ; } case ParserTreeConstants . JJTINTEGERLITERAL : { constant = true ; staticObject = new Integer ( callerReference ) ; break ; } case ParserTreeConstants . JJTFLOATINGPOINTLITERAL : { constant = true ; staticObject = new Double ( callerReference ) ; break ; } case ParserTreeConstants . JJTWORD : { log . error ( "Unsupported arg type : " + callerReference + " You most likely intended to call a VM with a string literal, so enclose with ' or \" characters. (VMProxyArg.setup())" ) ; constant = true ; staticObject = callerReference ; break ; } default : { log . error ( "VMProxyArg.setup() : unsupported type : " + callerReference ) ; } } } public VMProxyArg ( VMProxyArg model , InternalContextAdapter c ) { contextReference = model . getContextReference ( ) ; callerReference = model . getCallerReference ( ) ; nodeTree = model . getNodeTree ( ) ; staticObject = model . getStaticObject ( ) ; type = model . getType ( ) ; if ( nodeTree != null ) numTreeChildren = nodeTree . jjtGetNumChildren ( ) ; if ( type == ParserTreeConstants . JJTREFERENCE ) { if ( numTreeChildren == 0 ) { singleLevelRef = ( ( ASTReference ) nodeTree ) . getRootString ( ) ; } } } public String getCallerReference ( ) { return callerReference ; } public String getContextReference ( ) { return contextReference ; } public SimpleNode getNodeTree ( ) { return nodeTree ; } public Object getStaticObject ( ) { return staticObject ; } public int getType ( ) { return type ; } } 	1	['11', '1', '0', '13', '40', '0', '2', '11', '10', '0.663636364', '580', '1', '3', '0', '0.246753247', '0', '0', '50.72727273', '3', '1.1818', '2']
package org . apache . velocity . util ; import java . util . Iterator ; import java . util . Enumeration ; public class EnumerationIterator implements Iterator { private Enumeration enumeration = null ; public EnumerationIterator ( Enumeration enumeration ) { this . enumeration = enumeration ; } public Object next ( ) { return enumeration . nextElement ( ) ; } public boolean hasNext ( ) { return enumeration . hasMoreElements ( ) ; } public void remove ( ) { } } 	0	['4', '1', '0', '1', '7', '0', '1', '0', '4', '0.333333333', '23', '1', '0', '0', '0.625', '0', '0', '4.5', '1', '0.75', '0']
package org . apache . velocity . app . event ; public interface EventHandlerMethodExecutor { public void execute ( EventHandler handler ) throws Exception ; public boolean isDone ( ) ; public Object getReturnValue ( ) ; } 	1	['3', '1', '0', '9', '3', '3', '8', '1', '3', '2', '3', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '1']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; public class ASTOrNode extends SimpleNode { public ASTOrNode ( int id ) { super ( id ) ; } public ASTOrNode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { return new Boolean ( evaluate ( context ) ) ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { Node left = jjtGetChild ( 0 ) ; Node right = jjtGetChild ( 1 ) ; if ( left != null && left . evaluate ( context ) ) return true ; if ( right != null && right . evaluate ( context ) ) return true ; return false ; } } 	0	['5', '2', '0', '8', '11', '10', '4', '6', '5', '2', '52', '0', '0', '0.903225806', '0.4', '1', '1', '9.4', '1', '0.6', '0']
package org . apache . velocity . runtime . parser . node ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import org . apache . velocity . runtime . log . Log ; public abstract class SetExecutor { protected Log log = null ; private Method method = null ; public abstract Object execute ( Object o , Object value ) throws IllegalAccessException , InvocationTargetException ; public boolean isAlive ( ) { return ( method != null ) ; } public Method getMethod ( ) { return method ; } protected void setMethod ( final Method method ) { this . method = method ; } } 	1	['5', '1', '3', '6', '6', '0', '5', '1', '4', '0.625', '30', '1', '1', '0', '0.466666667', '0', '0', '4.6', '2', '1', '1']
package org . apache . velocity . runtime . directive ; public interface DirectiveConstants { public static final int BLOCK = 1 ; public static final int LINE = 2 ; } 	0	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . velocity . runtime . log ; import org . apache . velocity . runtime . RuntimeLogger ; public class RuntimeLoggerLog extends Log { private RuntimeLogger rlog ; public RuntimeLoggerLog ( RuntimeLogger rlog ) { if ( rlog == null ) { throw new NullPointerException ( "RuntimeLogger cannot be null!" ) ; } this . rlog = rlog ; } protected void setLogChute ( LogChute newLogChute ) { throw new UnsupportedOperationException ( "RuntimeLoggerLog does not support this method." ) ; } protected LogChute getLogChute ( ) { throw new UnsupportedOperationException ( "RuntimeLoggerLog does not support this method." ) ; } protected void setShowStackTraces ( boolean showStacks ) { throw new UnsupportedOperationException ( "RuntimeLoggerLog does not support this method." ) ; } public boolean getShowStackTraces ( ) { throw new UnsupportedOperationException ( "RuntimeLoggerLog does not support this method." ) ; } public boolean isTraceEnabled ( ) { return true ; } public void trace ( Object message ) { debug ( message ) ; } public void trace ( Object message , Throwable t ) { debug ( message , t ) ; } public boolean isDebugEnabled ( ) { return true ; } public void debug ( Object message ) { rlog . debug ( message ) ; } public void debug ( Object message , Throwable t ) { rlog . debug ( message ) ; rlog . debug ( t ) ; } public boolean isInfoEnabled ( ) { return true ; } public void info ( Object message ) { rlog . info ( message ) ; } public void info ( Object message , Throwable t ) { rlog . info ( message ) ; rlog . info ( t ) ; } public boolean isWarnEnabled ( ) { return true ; } public void warn ( Object message ) { rlog . warn ( message ) ; } public void warn ( Object message , Throwable t ) { rlog . warn ( message ) ; rlog . warn ( t ) ; } public boolean isErrorEnabled ( ) { return true ; } public void error ( Object message ) { rlog . error ( message ) ; } public void error ( Object message , Throwable t ) { rlog . error ( message ) ; rlog . error ( t ) ; } } 	1	['20', '2', '0', '8', '27', '118', '5', '3', '17', '0.473684211', '129', '1', '1', '0.5', '0.316666667', '1', '3', '5.4', '1', '0.95', '1']
package org . apache . velocity . runtime . parser ; public class ParseException extends Exception { private static final long serialVersionUID = - 309603325673449381L ; public ParseException ( Token currentTokenVal , int [ ] [ ] expectedTokenSequencesVal , String [ ] tokenImageVal ) { super ( "" ) ; specialConstructor = true ; currentToken = currentTokenVal ; expectedTokenSequences = expectedTokenSequencesVal ; tokenImage = tokenImageVal ; } public ParseException ( ) { super ( ) ; specialConstructor = false ; } public ParseException ( String message ) { super ( message ) ; specialConstructor = false ; } protected boolean specialConstructor ; public Token currentToken ; public int [ ] [ ] expectedTokenSequences ; public String [ ] tokenImage ; public String getMessage ( ) { if ( ! specialConstructor ) { return super . getMessage ( ) ; } String expected = "" ; int maxSize = 0 ; for ( int i = 0 ; i < expectedTokenSequences . length ; i ++ ) { if ( maxSize < expectedTokenSequences [ i ] . length ) { maxSize = expectedTokenSequences [ i ] . length ; } for ( int j = 0 ; j < expectedTokenSequences [ i ] . length ; j ++ ) { expected += tokenImage [ expectedTokenSequences [ i ] [ j ] ] + " " ; } if ( expectedTokenSequences [ i ] [ expectedTokenSequences [ i ] . length - 1 ] != 0 ) { expected += "..." ; } expected += eol + "    " ; } String retval = "Encountered \"" ; Token tok = currentToken . next ; for ( int i = 0 ; i < maxSize ; i ++ ) { if ( i != 0 ) retval += " " ; if ( tok . kind == 0 ) { retval += tokenImage [ 0 ] ; break ; } retval += add_escapes ( tok . image ) ; tok = tok . next ; } retval += "\" at line " + currentToken . next . beginLine + ", column " + currentToken . next . beginColumn ; retval += "." + eol ; if ( expectedTokenSequences . length == 1 ) { retval += "Was expecting:" + eol + "    " ; } else { retval += "Was expecting one of:" + eol + "    " ; } retval += expected ; return retval ; } protected String eol = System . getProperty ( "line.separator" , "\n" ) ; protected String add_escapes ( String str ) { StringBuffer retval = new StringBuffer ( ) ; char ch ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { switch ( str . charAt ( i ) ) { case 0 : continue ; case '\b' : retval . append ( "\\b" ) ; continue ; case '\t' : retval . append ( "\\t" ) ; continue ; case '\n' : retval . append ( "\\n" ) ; continue ; case '\f' : retval . append ( "\\f" ) ; continue ; case '\r' : retval . append ( "\\r" ) ; continue ; case '\"' : retval . append ( "\\\"" ) ; continue ; case '\'' : retval . append ( "\\\'" ) ; continue ; case '\\' : retval . append ( "\\\\" ) ; continue ; default : if ( ( ch = str . charAt ( i ) ) < 0x20 || ch > 0x7e ) { String s = "0000" + Integer . toString ( ch , 16 ) ; retval . append ( "\\u" + s . substring ( s . length ( ) - 4 , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . toString ( ) ; } } 	0	['5', '3', '2', '16', '18', '0', '15', '1', '4', '0.666666667', '388', '0.5', '1', '0.866666667', '0.4', '1', '1', '75.4', '14', '4.8', '0']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; import org . apache . velocity . util . TemplateNumber ; public class ASTEQNode extends SimpleNode { public ASTEQNode ( int id ) { super ( id ) ; } public ASTEQNode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { Object left = jjtGetChild ( 0 ) . value ( context ) ; Object right = jjtGetChild ( 1 ) . value ( context ) ; if ( left == null || right == null ) { log . error ( ( left == null ? "Left" : "Right" ) + " side (" + jjtGetChild ( ( left == null ? 0 : 1 ) ) . literal ( ) + ") of '==' operation " + "has null value. " + "If a reference, it may not be in the context." + " Operation not possible. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return false ; } if ( left instanceof TemplateNumber ) { left = ( ( TemplateNumber ) left ) . getAsNumber ( ) ; } if ( right instanceof TemplateNumber ) { right = ( ( TemplateNumber ) right ) . getAsNumber ( ) ; } if ( left instanceof Number && right instanceof Number ) { return MathUtils . compare ( ( Number ) left , ( Number ) right ) == 0 ; } if ( left . getClass ( ) . isAssignableFrom ( right . getClass ( ) ) || right . getClass ( ) . isAssignableFrom ( left . getClass ( ) ) ) { return left . equals ( right ) ; } else { if ( ( left . toString ( ) == null ) || ( right . toString ( ) == null ) ) { boolean culprit = ( left . toString ( ) == null ) ; log . error ( ( culprit ? "Left" : "Right" ) + " string side " + "String representation (" + jjtGetChild ( ( culprit ? 0 : 1 ) ) . literal ( ) + ") of '!=' operation has null value." + " Operation not possible. " + context . getCurrentTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]" ) ; return false ; } else { return left . toString ( ) . equals ( right . toString ( ) ) ; } } } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { return evaluate ( context ) ? Boolean . TRUE : Boolean . FALSE ; } } 	1	['5', '2', '0', '11', '26', '10', '4', '9', '5', '2', '204', '0', '0', '0.903225806', '0.4', '2', '2', '39.8', '1', '0.6', '2']
package org . apache . velocity . runtime . resource ; import org . apache . velocity . Template ; public class ResourceFactory { public static Resource getResource ( String resourceName , int resourceType ) { Resource resource = null ; switch ( resourceType ) { case ResourceManager . RESOURCE_TEMPLATE : resource = new Template ( ) ; break ; case ResourceManager . RESOURCE_CONTENT : resource = new ContentResource ( ) ; break ; } return resource ; } } 	0	['2', '1', '0', '4', '5', '1', '1', '3', '2', '2', '20', '0', '0', '0', '0.5', '0', '0', '9', '4', '2', '0']
package org . apache . velocity . runtime ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . util . SimplePool ; public class ParserPoolImpl implements ParserPool { RuntimeServices rsvc = null ; SimplePool pool = null ; int max = RuntimeConstants . NUMBER_OF_PARSERS ; public void initialize ( RuntimeServices rsvc ) { this . rsvc = rsvc ; max = rsvc . getInt ( RuntimeConstants . PARSER_POOL_SIZE , RuntimeConstants . NUMBER_OF_PARSERS ) ; pool = new SimplePool ( max ) ; for ( int i = 0 ; i < max ; i ++ ) { pool . put ( rsvc . createNewParser ( ) ) ; } if ( rsvc . getLog ( ) . isDebugEnabled ( ) ) { rsvc . getLog ( ) . debug ( "Created '" + max + "' parsers." ) ; } } public Parser get ( ) { Parser parser = ( Parser ) pool . get ( ) ; if ( parser == null ) { rsvc . getLog ( ) . debug ( "Created new " + "parser (pool exhausted).  Consider " + "increasing pool size." ) ; parser = rsvc . createNewParser ( ) ; } return parser ; } public void put ( Parser parser ) { pool . put ( parser ) ; } } 	1	['4', '1', '0', '5', '17', '0', '0', '5', '4', '0.333333333', '90', '0', '2', '0', '0.5', '0', '0', '20.75', '3', '1.5', '2']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; public class ASTParameters extends SimpleNode { public ASTParameters ( int id ) { super ( id ) ; } public ASTParameters ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } } 	0	['3', '2', '0', '3', '6', '3', '0', '3', '3', '2', '17', '0', '0', '0.965517241', '0.533333333', '0', '0', '4.666666667', '1', '0.3333', '0']
package org . apache . velocity . app . event . implement ; import org . apache . velocity . app . event . IncludeEventHandler ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . util . RuntimeServicesAware ; import org . apache . velocity . util . StringUtils ; public class IncludeNotFound implements IncludeEventHandler , RuntimeServicesAware { private static final String DEFAULT_NOT_FOUND = "notfound.vm" ; private static final String PROPERTY_NOT_FOUND = "eventhandler.include.notfound" ; private RuntimeServices rs = null ; String notfound ; public String includeEvent ( String includeResourcePath , String currentResourcePath , String directiveName ) { boolean exists = ( rs . getLoaderNameForResource ( includeResourcePath ) != null ) ; if ( ! exists ) { if ( rs . getLoaderNameForResource ( notfound ) == null ) { return notfound ; } else { rs . getLog ( ) . error ( "Can't find include not found page: " + notfound ) ; return null ; } } else return includeResourcePath ; } public void setRuntimeServices ( RuntimeServices rs ) { this . rs = rs ; notfound = StringUtils . nullTrim ( rs . getString ( PROPERTY_NOT_FOUND , DEFAULT_NOT_FOUND ) ) ; } } 	1	['3', '1', '0', '5', '12', '0', '0', '5', '3', '0.875', '61', '0.75', '1', '0', '0.555555556', '0', '0', '18', '4', '1.6667', '2']
package org . apache . velocity . context ; public interface InternalWrapperContext { Context getInternalUserContext ( ) ; InternalContextAdapter getBaseContext ( ) ; Object localPut ( final String key , final Object value ) ; } 	0	['3', '1', '0', '2', '3', '3', '1', '2', '3', '2', '3', '0', '0', '0', '0.555555556', '0', '0', '0', '1', '1', '0']
package org . apache . velocity . util . introspection ; public interface SecureIntrospectorControl { public boolean checkObjectExecutePermission ( Class clazz , String method ) ; } 	1	['1', '1', '0', '2', '1', '0', '2', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . velocity . util . introspection ; public class IntrospectionCacheData { public Object thingy ; public Class contextData ; } 	0	['1', '1', '0', '7', '2', '0', '7', '0', '1', '2', '6', '0', '0', '0', '1', '0', '0', '3', '0', '0', '0']
package org . apache . velocity . runtime . directive ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . StringReader ; import java . io . Writer ; import java . util . HashMap ; import org . apache . commons . lang . StringUtils ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . context . VMContext ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . parser . ParserTreeConstants ; import org . apache . velocity . runtime . parser . Token ; import org . apache . velocity . runtime . parser . node . ASTDirective ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . runtime . parser . node . SimpleNode ; import org . apache . velocity . runtime . visitor . VMReferenceMungeVisitor ; public class VelocimacroProxy extends Directive { private String macroName = "" ; private String macroBody = "" ; private String [ ] argArray = null ; private SimpleNode nodeTree = null ; private int numMacroArgs = 0 ; private String namespace = "" ; private boolean init = false ; private String [ ] callingArgs ; private int [ ] callingArgTypes ; private HashMap proxyArgHash = new HashMap ( ) ; private boolean strictArguments ; public String getName ( ) { return macroName ; } public int getType ( ) { return LINE ; } public void setName ( String name ) { macroName = name ; } public void setArgArray ( String [ ] arr ) { argArray = arr ; numMacroArgs = argArray . length - 1 ; } public void setNodeTree ( SimpleNode tree ) { nodeTree = tree ; } public int getNumArgs ( ) { return numMacroArgs ; } public void setMacrobody ( String mb ) { macroBody = mb ; } public void setNamespace ( String ns ) { this . namespace = ns ; } public boolean render ( InternalContextAdapter context , Writer writer , Node node ) throws IOException , MethodInvocationException { try { if ( nodeTree != null ) { if ( ! init ) { nodeTree . init ( context , rsvc ) ; init = true ; } VMContext vmc = new VMContext ( context , rsvc ) ; for ( int i = 1 ; i < argArray . length ; i ++ ) { VMProxyArg arg = ( VMProxyArg ) proxyArgHash . get ( argArray [ i ] ) ; vmc . addVMProxyArg ( arg ) ; } nodeTree . render ( vmc , writer ) ; } else { rsvc . getLog ( ) . error ( "VM error " + macroName + ". Null AST" ) ; } } catch ( MethodInvocationException e ) { throw e ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { rsvc . getLog ( ) . error ( "VelocimacroProxy.render() : exception VM = #" + macroName + "()" , e ) ; } return true ; } public void init ( RuntimeServices rs , InternalContextAdapter context , Node node ) throws TemplateInitException { super . init ( rs , context , node ) ; strictArguments = rs . getConfiguration ( ) . getBoolean ( RuntimeConstants . VM_ARGUMENTS_STRICT , false ) ; int i = node . jjtGetNumChildren ( ) ; if ( getNumArgs ( ) != i ) { for ( Node parent = node . jjtGetParent ( ) ; parent != null ; ) { if ( ( parent instanceof ASTDirective ) && StringUtils . equals ( ( ( ASTDirective ) parent ) . getDirectiveName ( ) , "macro" ) ) { return ; } parent = parent . jjtGetParent ( ) ; } String errormsg = "VM #" + macroName + ": error : too " + ( ( getNumArgs ( ) > i ) ? "few" : "many" ) + " arguments to macro. Wanted " + getNumArgs ( ) + " got " + i ; if ( strictArguments ) { throw new TemplateInitException ( errormsg , context . getCurrentTemplateName ( ) , 0 , 0 ) ; } else { rsvc . getLog ( ) . error ( errormsg ) ; return ; } } callingArgs = getArgArray ( node ) ; setupMacro ( callingArgs , callingArgTypes ) ; } public boolean setupMacro ( String [ ] callArgs , int [ ] callArgTypes ) { setupProxyArgs ( callArgs , callArgTypes ) ; parseTree ( callArgs ) ; return true ; } private void parseTree ( String [ ] callArgs ) { try { BufferedReader br = new BufferedReader ( new StringReader ( macroBody ) ) ; nodeTree = rsvc . parse ( br , namespace , false ) ; HashMap hm = new HashMap ( ) ; for ( int i = 1 ; i < argArray . length ; i ++ ) { String arg = callArgs [ i - 1 ] ; if ( arg . charAt ( 0 ) == '$' ) { hm . put ( argArray [ i ] , arg ) ; } } VMReferenceMungeVisitor v = new VMReferenceMungeVisitor ( hm ) ; nodeTree . jjtAccept ( v , null ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { rsvc . getLog ( ) . error ( "VelocimacroManager.parseTree() : exception " + macroName , e ) ; } } private void setupProxyArgs ( String [ ] callArgs , int [ ] callArgTypes ) { for ( int i = 1 ; i < argArray . length ; i ++ ) { VMProxyArg arg = new VMProxyArg ( rsvc , argArray [ i ] , callArgs [ i - 1 ] , callArgTypes [ i - 1 ] ) ; proxyArgHash . put ( argArray [ i ] , arg ) ; } } private String [ ] getArgArray ( Node node ) { int numArgs = node . jjtGetNumChildren ( ) ; String args [ ] = new String [ numArgs ] ; callingArgTypes = new int [ numArgs ] ; int i = 0 ; Token t = null ; Token tLast = null ; while ( i < numArgs ) { args [ i ] = "" ; callingArgTypes [ i ] = node . jjtGetChild ( i ) . getType ( ) ; if ( false && node . jjtGetChild ( i ) . getType ( ) == ParserTreeConstants . JJTSTRINGLITERAL ) { args [ i ] += node . jjtGetChild ( i ) . getFirstToken ( ) . image . substring ( 1 , node . jjtGetChild ( i ) . getFirstToken ( ) . image . length ( ) - 1 ) ; } else { t = node . jjtGetChild ( i ) . getFirstToken ( ) ; tLast = node . jjtGetChild ( i ) . getLastToken ( ) ; while ( t != tLast ) { args [ i ] += t . image ; t = t . next ; } args [ i ] += t . image ; } i ++ ; } return args ; } } 	1	['15', '2', '0', '19', '50', '39', '3', '16', '12', '0.811688312', '487', '1', '1', '0.333333333', '0.237037037', '0', '0', '30.73333333', '3', '1.2667', '8']
package org . apache . velocity . runtime . parser . node ; import java . io . IOException ; import java . io . Writer ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . ParserVisitor ; import org . apache . velocity . runtime . parser . Token ; public class ASTComment extends SimpleNode { private static final char [ ] ZILCH = "" . toCharArray ( ) ; private char [ ] carr ; public ASTComment ( int id ) { super ( id ) ; } public ASTComment ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object init ( InternalContextAdapter context , Object data ) { Token t = getFirstToken ( ) ; int loc1 = t . image . indexOf ( "##" ) ; int loc2 = t . image . indexOf ( "#*" ) ; if ( loc1 == - 1 && loc2 == - 1 ) { carr = ZILCH ; } else { carr = t . image . substring ( 0 , ( loc1 == - 1 ) ? loc2 : loc1 ) . toCharArray ( ) ; } return data ; } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException , ParseErrorException , ResourceNotFoundException { if ( context . getAllowRendering ( ) ) { writer . write ( carr ) ; } return true ; } } 	0	['6', '2', '0', '9', '15', '11', '3', '8', '5', '0.8', '73', '1', '0', '0.903225806', '0.4', '0', '0', '10.83333333', '4', '1', '0']
package org . apache . velocity . app . event ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . Set ; import org . apache . velocity . context . Context ; import org . apache . velocity . context . InternalEventContext ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . util . RuntimeServicesAware ; public class EventCartridge { private List referenceHandlers = new ArrayList ( ) ; private List nullSetHandlers = new ArrayList ( ) ; private List methodExceptionHandlers = new ArrayList ( ) ; private List includeHandlers = new ArrayList ( ) ; private List invalidReferenceHandlers = new ArrayList ( ) ; Set initializedHandlers = new HashSet ( ) ; public boolean addEventHandler ( EventHandler ev ) { if ( ev == null ) { return false ; } boolean found = false ; if ( ev instanceof ReferenceInsertionEventHandler ) { addReferenceInsertionEventHandler ( ( ReferenceInsertionEventHandler ) ev ) ; found = true ; } if ( ev instanceof NullSetEventHandler ) { addNullSetEventHandler ( ( NullSetEventHandler ) ev ) ; found = true ; } if ( ev instanceof MethodExceptionEventHandler ) { addMethodExceptionHandler ( ( MethodExceptionEventHandler ) ev ) ; found = true ; } if ( ev instanceof IncludeEventHandler ) { addIncludeEventHandler ( ( IncludeEventHandler ) ev ) ; found = true ; } if ( ev instanceof InvalidReferenceEventHandler ) { addInvalidReferenceEventHandler ( ( InvalidReferenceEventHandler ) ev ) ; found = true ; } return found ; } public void addReferenceInsertionEventHandler ( ReferenceInsertionEventHandler ev ) { referenceHandlers . add ( ev ) ; } public void addNullSetEventHandler ( NullSetEventHandler ev ) { nullSetHandlers . add ( ev ) ; } public void addMethodExceptionHandler ( MethodExceptionEventHandler ev ) { methodExceptionHandlers . add ( ev ) ; } public void addIncludeEventHandler ( IncludeEventHandler ev ) { includeHandlers . add ( ev ) ; } public void addInvalidReferenceEventHandler ( InvalidReferenceEventHandler ev ) { invalidReferenceHandlers . add ( ev ) ; } public boolean removeEventHandler ( EventHandler ev ) { if ( ev == null ) { return false ; } boolean found = false ; if ( ev instanceof ReferenceInsertionEventHandler ) return referenceHandlers . remove ( ev ) ; if ( ev instanceof NullSetEventHandler ) return nullSetHandlers . remove ( ev ) ; if ( ev instanceof MethodExceptionEventHandler ) return methodExceptionHandlers . remove ( ev ) ; if ( ev instanceof IncludeEventHandler ) return includeHandlers . remove ( ev ) ; if ( ev instanceof InvalidReferenceEventHandler ) return invalidReferenceHandlers . remove ( ev ) ; return found ; } public Iterator getReferenceInsertionEventHandlers ( ) { return referenceHandlers . iterator ( ) ; } public Iterator getNullSetEventHandlers ( ) { return nullSetHandlers . iterator ( ) ; } public Iterator getMethodExceptionEventHandlers ( ) { return methodExceptionHandlers . iterator ( ) ; } public Iterator getIncludeEventHandlers ( ) { return includeHandlers . iterator ( ) ; } public Iterator getInvalidReferenceEventHandlers ( ) { return invalidReferenceHandlers . iterator ( ) ; } public final boolean attachToContext ( Context context ) { if ( context instanceof InternalEventContext ) { InternalEventContext iec = ( InternalEventContext ) context ; iec . attachEventCartridge ( this ) ; return true ; } else { return false ; } } public void initialize ( RuntimeServices rs ) throws Exception { for ( Iterator i = referenceHandlers . iterator ( ) ; i . hasNext ( ) ; ) { EventHandler eh = ( EventHandler ) i . next ( ) ; if ( ( eh instanceof RuntimeServicesAware ) && ! initializedHandlers . contains ( eh ) ) { ( ( RuntimeServicesAware ) eh ) . setRuntimeServices ( rs ) ; initializedHandlers . add ( eh ) ; } } for ( Iterator i = nullSetHandlers . iterator ( ) ; i . hasNext ( ) ; ) { EventHandler eh = ( EventHandler ) i . next ( ) ; if ( ( eh instanceof RuntimeServicesAware ) && ! initializedHandlers . contains ( eh ) ) { ( ( RuntimeServicesAware ) eh ) . setRuntimeServices ( rs ) ; initializedHandlers . add ( eh ) ; } } for ( Iterator i = methodExceptionHandlers . iterator ( ) ; i . hasNext ( ) ; ) { EventHandler eh = ( EventHandler ) i . next ( ) ; if ( ( eh instanceof RuntimeServicesAware ) && ! initializedHandlers . contains ( eh ) ) { ( ( RuntimeServicesAware ) eh ) . setRuntimeServices ( rs ) ; initializedHandlers . add ( eh ) ; } } for ( Iterator i = includeHandlers . iterator ( ) ; i . hasNext ( ) ; ) { EventHandler eh = ( EventHandler ) i . next ( ) ; if ( ( eh instanceof RuntimeServicesAware ) && ! initializedHandlers . contains ( eh ) ) { ( ( RuntimeServicesAware ) eh ) . setRuntimeServices ( rs ) ; initializedHandlers . add ( eh ) ; } } for ( Iterator i = invalidReferenceHandlers . iterator ( ) ; i . hasNext ( ) ; ) { EventHandler eh = ( EventHandler ) i . next ( ) ; if ( ( eh instanceof RuntimeServicesAware ) && ! initializedHandlers . contains ( eh ) ) { ( ( RuntimeServicesAware ) eh ) . setRuntimeServices ( rs ) ; initializedHandlers . add ( eh ) ; } } } } 	1	['15', '1', '0', '18', '27', '29', '10', '10', '15', '0.69047619', '365', '0.833333333', '0', '0', '0.177777778', '0', '0', '22.93333333', '7', '1.8', '2']
