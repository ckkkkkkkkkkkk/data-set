package org . apache . log4j . net ; import java . net . DatagramSocket ; import java . net . InetAddress ; import java . net . DatagramPacket ; import java . net . UnknownHostException ; import java . net . SocketException ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . AppenderSkeleton ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . Layout ; import org . apache . log4j . helpers . SyslogWriter ; import org . apache . log4j . helpers . SyslogQuietWriter ; import org . apache . log4j . net . SyslogTracerPrintWriter ; public class SyslogAppender extends AppenderSkeleton { final static public int LOG_KERN = 0 ; final static public int LOG_USER = 1 << 3 ; final static public int LOG_MAIL = 2 << 3 ; final static public int LOG_DAEMON = 3 << 3 ; final static public int LOG_AUTH = 4 << 3 ; final static public int LOG_SYSLOG = 5 << 3 ; final static public int LOG_LPR = 6 << 3 ; final static public int LOG_NEWS = 7 << 3 ; final static public int LOG_UUCP = 8 << 3 ; final static public int LOG_CRON = 9 << 3 ; final static public int LOG_AUTHPRIV = 10 << 3 ; final static public int LOG_FTP = 11 << 3 ; final static public int LOG_LOCAL0 = 16 << 3 ; final static public int LOG_LOCAL1 = 17 << 3 ; final static public int LOG_LOCAL2 = 18 << 3 ; final static public int LOG_LOCAL3 = 19 << 3 ; final static public int LOG_LOCAL4 = 20 << 3 ; final static public int LOG_LOCAL5 = 21 << 3 ; final static public int LOG_LOCAL6 = 22 << 3 ; final static public int LOG_LOCAL7 = 23 << 3 ; public static final String SYSLOG_HOST_OPTION = "SyslogHost" ; public static final String FACILITY_OPTION = "Facility" ; public static final String FACILITY_PRINTING_OPTION = "FacilityPrinting" ; protected static final int SYSLOG_HOST_OI = 0 ; protected static final int FACILITY_OI = 1 ; int syslogFacility = LOG_USER ; String facilityStr ; boolean facilityPrinting = false ; SyslogTracerPrintWriter stp ; SyslogQuietWriter sqw ; String syslogHost ; public SyslogAppender ( ) { this . initSyslogFacilityStr ( this . syslogFacility ) ; } public SyslogAppender ( Layout layout , int syslogFacility ) { this . layout = layout ; this . syslogFacility = syslogFacility ; this . initSyslogFacilityStr ( syslogFacility ) ; } public SyslogAppender ( Layout layout , String syslogHost , int syslogFacility ) { this ( layout , syslogFacility ) ; setSyslogHost ( syslogHost ) ; } public void close ( ) { closed = true ; sqw = null ; stp = null ; } private void initSyslogFacilityStr ( int syslogFacility ) { switch ( syslogFacility ) { case LOG_KERN : facilityStr = "kern:" ; break ; case LOG_USER : facilityStr = "user:" ; break ; case LOG_MAIL : facilityStr = "mail:" ; break ; case LOG_DAEMON : facilityStr = "daemon:" ; break ; case LOG_AUTH : facilityStr = "auth:" ; ; break ; case LOG_SYSLOG : facilityStr = "syslog:" ; break ; case LOG_LPR : facilityStr = "lpr:" ; break ; case LOG_NEWS : facilityStr = "news:" ; break ; case LOG_UUCP : facilityStr = "uucp:" ; break ; case LOG_CRON : facilityStr = "cron:" ; break ; case LOG_AUTHPRIV : facilityStr = "authpriv:" ; break ; case LOG_FTP : facilityStr = "ftp:" ; break ; case LOG_LOCAL0 : facilityStr = "local0:" ; break ; case LOG_LOCAL1 : facilityStr = "local1:" ; break ; case LOG_LOCAL2 : facilityStr = "local2:" ; break ; case LOG_LOCAL3 : facilityStr = "local3:" ; break ; case LOG_LOCAL4 : facilityStr = "local4:" ; break ; case LOG_LOCAL5 : facilityStr = "local5:" ; break ; case LOG_LOCAL6 : facilityStr = "local6:" ; break ; case LOG_LOCAL7 : facilityStr = "local7:" ; break ; default : System . err . println ( "\"" + syslogFacility + "\" is an unknown syslog facility. Defaulting to \"USER\"." ) ; this . syslogFacility = LOG_USER ; facilityStr = "user:" ; } } public void append ( LoggingEvent event ) { if ( ! isAsSevereAsThreshold ( event . priority ) ) return ; if ( sqw == null ) { errorHandler . error ( "No syslog host is set for SyslogAppedender named \"" + this . name + "\"." ) ; return ; } String buffer = ( facilityPrinting ? facilityStr : "" ) + layout . format ( event ) ; sqw . setPriority ( event . priority . getSyslogEquivalent ( ) ) ; sqw . write ( buffer ) ; if ( event . throwable != null ) event . throwable . printStackTrace ( stp ) ; else if ( event . throwableInformation != null ) { sqw . write ( event . throwableInformation ) ; } } public void activateOptions ( ) { } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { SYSLOG_HOST_OPTION , FACILITY_OPTION , FACILITY_PRINTING_OPTION } ) ; } public boolean requiresLayout ( ) { return true ; } public void setFacility ( String facilityName ) { if ( facilityName == null ) return ; if ( "KERN" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_KERN ; else if ( "USER" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_USER ; else if ( "MAIL" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_MAIL ; else if ( "DAEMON" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_DAEMON ; else if ( "AUTH" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_AUTH ; else if ( "SYSLOG" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_SYSLOG ; else if ( "LPR" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_LPR ; else if ( "NEWS" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_NEWS ; else if ( "UUCP" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_UUCP ; else if ( "CRON" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_CRON ; else if ( "AUTHPRIV" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_AUTHPRIV ; else if ( "FTP" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_FTP ; else if ( "LOCAL0" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_LOCAL0 ; else if ( "LOCAL1" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_LOCAL1 ; else if ( "LOCAL2" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_LOCAL2 ; else if ( "LOCAL3" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_LOCAL3 ; else if ( "LOCAL4" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_LOCAL4 ; else if ( "LOCAL5" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_LOCAL5 ; else if ( "LOCAL6" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_LOCAL6 ; else if ( "LOCAL7" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_LOCAL7 ; else { System . err . println ( facilityName + " is an unknown syslog facility. Defaulting to \"USER\"." ) ; this . syslogFacility = LOG_USER ; } this . initSyslogFacilityStr ( this . syslogFacility ) ; if ( sqw != null ) { sqw . setSyslogFacility ( this . syslogFacility ) ; } } public void setOption ( String option , String value ) { if ( value == null ) return ; super . setOption ( option , value ) ; if ( option . equals ( SYSLOG_HOST_OPTION ) ) this . setSyslogHost ( value ) ; else if ( option . equals ( FACILITY_PRINTING_OPTION ) ) facilityPrinting = OptionConverter . toBoolean ( value , facilityPrinting ) ; else if ( option . equals ( FACILITY_OPTION ) ) { this . setFacility ( value ) ; } } public void setSyslogHost ( String syslogHost ) { this . sqw = new SyslogQuietWriter ( new SyslogWriter ( syslogHost ) , syslogFacility , errorHandler ) ; this . stp = new SyslogTracerPrintWriter ( sqw ) ; this . syslogHost = syslogHost ; } } 	1	['12', '2', '0', '10', '35', '24', '0', '10', '11', '0.994134897', '531', '0.064516129', '2', '0.666666667', '0.366666667', '2', '4', '40.66666667', '23', '5.0833', '2']
package org . apache . log4j . helpers ; import org . apache . log4j . spi . ErrorHandler ; public class OnlyOnceErrorHandler implements ErrorHandler { final String WARN_PREFIX = "log4j warning: " ; final String ERROR_PREFIX = "log4j error: " ; boolean firstTime = true ; public void activateOptions ( ) { } public void error ( String message , Exception e , int errorCode ) { if ( firstTime ) { LogLog . error ( message , e ) ; firstTime = false ; } } public String [ ] getOptionStrings ( ) { return null ; } public void setOption ( String key , String value ) { } public void error ( String message ) { if ( firstTime ) { LogLog . error ( message ) ; firstTime = false ; } } } 	1	['6', '1', '0', '3', '9', '9', '1', '2', '6', '0.866666667', '44', '0', '0', '0', '0.458333333', '0', '0', '5.833333333', '2', '1.1667', '1']
package org . apache . log4j ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . or . ObjectRenderer ; import org . apache . log4j . or . RendererMap ; import java . util . Enumeration ; public class BasicConfigurator { public static final String DISABLE_OVERRIDE_KEY = "log4j.disableOverride" ; public static final String INHERITED = "inherited" ; static { String override = null ; String propertyName = DISABLE_OVERRIDE_KEY ; try { override = System . getProperty ( propertyName , override ) ; } catch ( SecurityException e ) { LogLog . debug ( "Could not read system property \"" + propertyName + "\"." , e ) ; } if ( override != null ) { if ( OptionConverter . toBoolean ( override , true ) ) { LogLog . debug ( "Overriding disable. Non-null system property " + DISABLE_OVERRIDE_KEY + "=[" + override + "]." ) ; Category . disable = Category . DISABLE_OVERRIDE ; } } } protected BasicConfigurator ( ) { } protected void addRenderer ( String renderedClassName , String renderingClassName ) { LogLog . debug ( "Rendering class: [" + renderingClassName + "], Rendered class: [" + renderedClassName + "]." ) ; ObjectRenderer renderer = ( ObjectRenderer ) OptionConverter . instantiateByClassName ( renderingClassName , ObjectRenderer . class , null ) ; if ( renderer == null ) { LogLog . error ( "Could not isntantiate renderer [" + renderingClassName + "]." ) ; return ; } else { try { Class renderedClass = Class . forName ( renderedClassName ) ; Category . defaultHierarchy . rendererMap . put ( renderedClass , renderer ) ; } catch ( ClassNotFoundException e ) { LogLog . error ( "Could not find class [" + renderedClassName + "]." , e ) ; } } } static public void configure ( ) { Category root = Category . getRoot ( ) ; root . addAppender ( new FileAppender ( new PatternLayout ( PatternLayout . TTCC_CONVERSION_PATTERN ) , System . out ) ) ; } static public void configure ( Appender appender ) { Category root = Category . getRoot ( ) ; root . addAppender ( appender ) ; } static public void disable ( Priority p ) { if ( Category . disable != Category . DISABLE_OVERRIDE ) { Category . disable = p . level ; } } static public void disableAll ( ) { disable ( Priority . FATAL ) ; } static public void disableDebug ( ) { disable ( Priority . DEBUG ) ; } static public void disableInfo ( ) { disable ( Priority . INFO ) ; } static public void enableAll ( ) { Category . disable = Category . DISABLE_OFF ; } public static void flagAsShippedCode ( ) { disableInfo ( ) ; } protected static void overrideAsNeeded ( String override ) { if ( override != null ) { LogLog . debug ( "Handling non-null disable override directive: \"" + override + "\"." ) ; if ( OptionConverter . toBoolean ( override , true ) ) { LogLog . debug ( "Overriding all disable methods." ) ; Category . disable = Category . DISABLE_OVERRIDE ; } } } public static void resetConfiguration ( ) { Category . defaultHierarchy . getRoot ( ) . setPriority ( Priority . DEBUG ) ; Category . defaultHierarchy . root . setResourceBundle ( null ) ; Category . disable = Category . DISABLE_OFF ; synchronized ( Category . defaultHierarchy . ht ) { Category . defaultHierarchy . shutdown ( ) ; Enumeration cats = Category . getCurrentCategories ( ) ; while ( cats . hasMoreElements ( ) ) { Category c = ( Category ) cats . nextElement ( ) ; c . setPriority ( null ) ; c . setAdditivity ( true ) ; c . setResourceBundle ( null ) ; } } Category . defaultHierarchy . rendererMap . clear ( ) ; } } 	1	['14', '1', '2', '20', '42', '91', '9', '11', '9', '1.051282051', '247', '0', '0', '0', '0.134615385', '0', '0', '16.42857143', '3', '1.2857', '1']
package org . apache . log4j ; import java . io . IOException ; import java . io . Writer ; import java . io . FileWriter ; import java . io . File ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . QuietWriter ; import org . apache . log4j . helpers . CountingQuietWriter ; import org . apache . log4j . spi . LoggingEvent ; public class RollingFileAppender extends FileAppender { static final public String MAX_FILE_SIZE_OPTION = "MaxFileSize" ; static final public String MAX_BACKUP_INDEX_OPTION = "MaxBackupIndex" ; protected long maxFileSize = 10 * 1024 * 1024 ; protected int maxBackupIndex = 1 ; public RollingFileAppender ( ) { super ( ) ; } public RollingFileAppender ( Layout layout , OutputStream os ) { super ( layout , os ) ; } public RollingFileAppender ( Layout layout , Writer writer ) { super ( layout , writer ) ; } public RollingFileAppender ( Layout layout , String filename , boolean append ) throws IOException { super ( layout , filename , append ) ; } public RollingFileAppender ( Layout layout , String filename ) throws IOException { super ( layout , filename ) ; } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { MAX_FILE_SIZE_OPTION , MAX_BACKUP_INDEX_OPTION } ) ; } public synchronized void setFile ( String fileName , boolean append ) throws IOException { super . setFile ( fileName , append ) ; if ( append ) { File f = new File ( fileName ) ; ( ( CountingQuietWriter ) qw ) . setCount ( f . length ( ) ) ; } } public synchronized void rollOver ( ) { File target ; File file ; if ( maxBackupIndex > 0 ) { file = new File ( fileName + '.' + maxBackupIndex ) ; if ( file . exists ( ) ) file . delete ( ) ; for ( int i = maxBackupIndex - 1 ; i >= 1 ; i -- ) { file = new File ( fileName + "." + i ) ; if ( file . exists ( ) ) { target = new File ( fileName + '.' + ( i + 1 ) ) ; file . renameTo ( target ) ; } } target = new File ( fileName + "." + 1 ) ; this . closeWriterIfOurs ( ) ; file = new File ( fileName ) ; file . renameTo ( target ) ; } try { this . setFile ( fileName , false ) ; } catch ( IOException e ) { System . err . println ( "setFile(" + fileName + ", false) call failed." ) ; e . printStackTrace ( ) ; } } public void setMaxBackupIndex ( int maxBackups ) { this . maxBackupIndex = maxBackups ; } public void setMaxFileSize ( long maxFileSize ) { this . maxFileSize = maxFileSize ; } public void setOption ( String key , String value ) { super . setOption ( key , value ) ; if ( key . equalsIgnoreCase ( MAX_FILE_SIZE_OPTION ) ) { maxFileSize = OptionConverter . toFileSize ( value , maxFileSize + 1 ) ; } else if ( key . equalsIgnoreCase ( MAX_BACKUP_INDEX_OPTION ) ) { maxBackupIndex = OptionConverter . toInt ( value , maxBackupIndex ) ; } } protected void setQWForFiles ( Writer writer ) { this . qw = new CountingQuietWriter ( writer , errorHandler ) ; } protected void subAppend ( LoggingEvent event ) { super . subAppend ( event ) ; if ( ( fileName != null ) && ( ( CountingQuietWriter ) qw ) . getCount ( ) >= maxFileSize ) this . rollOver ( ) ; } } 	1	['13', '3', '1', '10', '42', '0', '2', '8', '11', '0.729166667', '289', '0.5', '0', '0.804878049', '0.247863248', '1', '10', '20.92307692', '5', '1.2308', '1']
package org . apache . log4j ; import java . util . Hashtable ; import java . util . Stack ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . log4j . helpers . LogLog ; public class NDC { static Hashtable ht = new Hashtable ( ) ; static int pushCounter = 0 ; static final int REAP_THRESHOLD = 5 ; private NDC ( ) { } public static void clear ( ) { Stack stack = ( Stack ) ht . get ( Thread . currentThread ( ) ) ; if ( stack != null ) stack . setSize ( 0 ) ; } public static Stack cloneStack ( ) { Object o = ht . get ( Thread . currentThread ( ) ) ; if ( o == null ) return null ; else { Stack stack = ( Stack ) o ; return ( Stack ) stack . clone ( ) ; } } public static void inherit ( Stack stack ) { if ( stack != null ) ht . put ( Thread . currentThread ( ) , stack ) ; } static public String get ( ) { Stack s = ( Stack ) ht . get ( Thread . currentThread ( ) ) ; if ( s != null && ! s . isEmpty ( ) ) return ( ( DiagnosticContext ) s . peek ( ) ) . fullMessage ; else return null ; } public static int getDepth ( ) { Stack stack = ( Stack ) ht . get ( Thread . currentThread ( ) ) ; if ( stack == null ) return 0 ; else return stack . size ( ) ; } private static void lazyRemove ( ) { Vector v ; synchronized ( ht ) { if ( ++ pushCounter >= REAP_THRESHOLD ) { return ; } else { pushCounter = 0 ; } int misses = 0 ; v = new Vector ( ) ; Enumeration enum = ht . keys ( ) ; while ( enum . hasMoreElements ( ) && ( misses <= 4 ) ) { Thread t = ( Thread ) enum . nextElement ( ) ; if ( t . isAlive ( ) ) { misses ++ ; } else { misses = 0 ; v . addElement ( t ) ; } } } int size = v . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { Thread t = ( Thread ) v . elementAt ( i ) ; LogLog . debug ( "Lazy NDC removal for thread [" + t . getName ( ) + "] (" + ht . size ( ) + ")." ) ; ht . remove ( t ) ; } } public static String pop ( ) { Thread key = Thread . currentThread ( ) ; Stack stack = ( Stack ) ht . get ( key ) ; if ( stack != null && ! stack . isEmpty ( ) ) return ( ( DiagnosticContext ) stack . pop ( ) ) . message ; else return "" ; } public static void push ( String message ) { Thread key = Thread . currentThread ( ) ; Stack stack = ( Stack ) ht . get ( key ) ; if ( stack == null ) { DiagnosticContext dc = new DiagnosticContext ( message , null ) ; stack = new Stack ( ) ; ht . put ( key , stack ) ; stack . push ( dc ) ; } else if ( stack . isEmpty ( ) ) { DiagnosticContext dc = new DiagnosticContext ( message , null ) ; stack . push ( dc ) ; } else { DiagnosticContext parent = ( DiagnosticContext ) stack . peek ( ) ; stack . push ( new DiagnosticContext ( message , parent ) ) ; } } static public void remove ( ) { ht . remove ( Thread . currentThread ( ) ) ; lazyRemove ( ) ; } static public void setMaxDepth ( int maxDepth ) { Stack stack = ( Stack ) ht . get ( Thread . currentThread ( ) ) ; if ( stack != null && maxDepth < stack . size ( ) ) stack . setSize ( maxDepth ) ; } private static class DiagnosticContext { String fullMessage ; String message ; DiagnosticContext ( String message , DiagnosticContext parent ) { this . message = message ; if ( parent != null ) { fullMessage = parent . fullMessage + ' ' + message ; } else { fullMessage = message ; } } } } 	1	['12', '1', '0', '12', '41', '0', '10', '2', '9', '0.666666667', '275', '0', '0', '0', '0.090909091', '0', '0', '21.66666667', '6', '2.25', '1']
package org . apache . log4j ; public class Priority { int level ; String levelStr ; int syslogEquivalent ; final static int FATAL_INT = 50000 ; final static int ERROR_INT = 40000 ; final static int WARN_INT = 30000 ; final static int INFO_INT = 20000 ; final static int DEBUG_INT = 10000 ; final static public Priority FATAL = new Priority ( FATAL_INT , "FATAL" , 0 ) ; final static public Priority ERROR = new Priority ( ERROR_INT , "ERROR" , 3 ) ; final static public Priority WARN = new Priority ( WARN_INT , "WARN" , 4 ) ; final static public Priority INFO = new Priority ( INFO_INT , "INFO" , 5 ) ; final static public Priority DEBUG = new Priority ( DEBUG_INT , "DEBUG" , 6 ) ; protected Priority ( int level , String levelStr , int syslogEquivalent ) { this . level = level ; this . levelStr = levelStr ; this . syslogEquivalent = syslogEquivalent ; } public final int getSyslogEquivalent ( ) { return syslogEquivalent ; } final public String toString ( ) { return levelStr ; } public final int toInt ( ) { return level ; } public boolean isGreaterOrEqual ( Priority r ) { return level >= r . level ; } public static Priority [ ] getAllPossiblePriorities ( ) { return new Priority [ ] { Priority . FATAL , Priority . ERROR , Priority . WARN , Priority . INFO , Priority . DEBUG } ; } public static Priority toPriority ( String sArg ) { return toPriority ( sArg , Priority . DEBUG ) ; } public static Priority toPriority ( int val ) { switch ( val ) { case DEBUG_INT : return DEBUG ; case INFO_INT : return INFO ; case WARN_INT : return WARN ; case ERROR_INT : return ERROR ; case FATAL_INT : return FATAL ; default : return DEBUG ; } } public static Priority toPriority ( String sArg , Priority defaultPriority ) { if ( sArg == null ) return defaultPriority ; String s = sArg . toUpperCase ( ) ; if ( s . equals ( "DEBUG" ) ) return Priority . DEBUG ; if ( s . equals ( "INFO" ) ) return Priority . INFO ; if ( s . equals ( "WARN" ) ) return Priority . WARN ; if ( s . equals ( "ERROR" ) ) return Priority . ERROR ; if ( s . equals ( "FATAL" ) ) return Priority . FATAL ; return defaultPriority ; } } 	1	['10', '1', '2', '40', '13', '15', '40', '0', '8', '0.811965812', '169', '0', '5', '0', '0.333333333', '0', '0', '14.6', '7', '2.1', '1']
package org . apache . log4j . spi ; import java . io . StringWriter ; import java . io . PrintWriter ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . Layout ; ; public class LocationInfo implements java . io . Serializable { transient String lineNumber ; transient String fileName ; transient String className ; transient String methodName ; public String fullInfo ; private static StringWriter sw = new StringWriter ( ) ; private static PrintWriter pw = new PrintWriter ( sw ) ; public final static String NA = "?" ; static final long serialVersionUID = - 1325822038990805636L ; static boolean inVisualAge = false ; { try { Class dummy = Class . forName ( "com.ibm.uvm.tools.DebugSupport" ) ; inVisualAge = true ; LogLog . debug ( "Detected IBM VisualAge environment." ) ; } catch ( Throwable e ) { } } public LocationInfo ( Throwable t , String fqnOfCallingClass ) { if ( t == null ) return ; String s ; synchronized ( sw ) { t . printStackTrace ( pw ) ; s = sw . toString ( ) ; sw . getBuffer ( ) . setLength ( 0 ) ; } int ibegin , iend ; ibegin = s . lastIndexOf ( fqnOfCallingClass ) ; if ( ibegin == - 1 ) return ; ibegin = s . indexOf ( Layout . LINE_SEP , ibegin ) ; if ( ibegin == - 1 ) return ; ibegin += Layout . LINE_SEP_LEN ; iend = s . indexOf ( Layout . LINE_SEP , ibegin ) ; if ( iend == - 1 ) return ; if ( ! inVisualAge ) { ibegin = s . lastIndexOf ( "at " , iend ) ; if ( ibegin == - 1 ) return ; ibegin += 3 ; } this . fullInfo = s . substring ( ibegin , iend ) ; } public String getClassName ( ) { if ( fullInfo == null ) return NA ; if ( className == null ) { int iend = fullInfo . lastIndexOf ( '(' ) ; if ( iend == - 1 ) className = NA ; else { iend = fullInfo . lastIndexOf ( '.' , iend ) ; if ( iend == - 1 ) className = NA ; else className = this . fullInfo . substring ( 0 , iend ) ; } } return className ; } public String getFileName ( ) { if ( fullInfo == null ) return NA ; if ( fileName == null ) { int iend = fullInfo . lastIndexOf ( ':' ) ; if ( iend == - 1 ) fileName = NA ; else { int ibegin = fullInfo . lastIndexOf ( '(' , iend - 1 ) ; fileName = this . fullInfo . substring ( ibegin + 1 , iend ) ; } } return fileName ; } public String getLineNumber ( ) { if ( fullInfo == null ) return NA ; if ( lineNumber == null ) { int iend = fullInfo . lastIndexOf ( ')' ) ; int ibegin = fullInfo . lastIndexOf ( ':' , iend - 1 ) ; if ( ibegin == - 1 ) lineNumber = NA ; else lineNumber = this . fullInfo . substring ( ibegin + 1 , iend ) ; } return lineNumber ; } public String getMethodName ( ) { if ( fullInfo == null ) return NA ; if ( methodName == null ) { int iend = fullInfo . lastIndexOf ( '(' ) ; int ibegin = fullInfo . lastIndexOf ( '.' , iend ) ; if ( ibegin == - 1 ) methodName = NA ; else methodName = this . fullInfo . substring ( ibegin + 1 , iend ) ; } return methodName ; } } 	1	['6', '1', '0', '7', '21', '0', '5', '2', '5', '0.9', '274', '0.2', '0', '0', '0.466666667', '0', '0', '43', '5', '2.8333', '1']
package org . apache . log4j . helpers ; public class LogLog { public static final String CONFIG_DEBUG_KEY = "log4j.configDebug" ; protected static boolean configDebugEnabled = false ; private static final String PREFIX = "log4j: " ; private static final String ERR_PREFIX = "log4j:ERROR " ; static { try { String key = System . getProperty ( CONFIG_DEBUG_KEY ) ; if ( key != null ) configDebugEnabled = OptionConverter . toBoolean ( key , true ) ; } catch ( SecurityException e ) { System . err . println ( PREFIX + "Could not read system property \"" + CONFIG_DEBUG_KEY + "\"." ) ; } } static public void setInternalDebugging ( boolean enabled ) { configDebugEnabled = enabled ; } public static void debug ( String msg ) { if ( configDebugEnabled ) { System . out . println ( PREFIX + msg ) ; } } public static void debug ( String msg , Throwable t ) { if ( configDebugEnabled ) { System . out . println ( PREFIX + msg ) ; if ( t != null ) t . printStackTrace ( System . out ) ; } } public static void error ( String msg ) { System . err . println ( ERR_PREFIX + msg ) ; } public static void error ( String msg , Throwable t ) { System . err . println ( ERR_PREFIX + msg ) ; if ( t != null ) { t . printStackTrace ( ) ; } } } 	1	['7', '1', '0', '28', '16', '9', '28', '1', '6', '1', '91', '0.75', '0', '0', '0.333333333', '0', '0', '11.42857143', '3', '1.2857', '2']
package org . apache . log4j . spi ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; import org . apache . log4j . helpers . LogLog ; import java . io . StringWriter ; import java . io . PrintWriter ; import java . io . ObjectOutputStream ; import java . io . ObjectInputStream ; public class LoggingEvent implements java . io . Serializable { private static long startTime = System . currentTimeMillis ( ) ; transient public String fqnOfCategoryClass ; public String categoryName ; transient public Priority priority ; public String ndc ; public boolean ndcLookupRequired = true ; public String message ; public String threadName ; transient public Throwable throwable ; public String throwableInformation ; public long timeStamp ; public LocationInfo locationInfo ; static final long serialVersionUID = - 868428216207166145L ; public LoggingEvent ( String fqnOfCategoryClass , Category category , Priority priority , String message , Throwable throwable ) { this . fqnOfCategoryClass = fqnOfCategoryClass ; this . categoryName = category . getName ( ) ; this . priority = priority ; this . message = message ; this . throwable = throwable ; timeStamp = System . currentTimeMillis ( ) ; } public static long getStartTime ( ) { return startTime ; } public String getNDC ( ) { if ( ndcLookupRequired ) { ndcLookupRequired = false ; ndc = NDC . get ( ) ; } return ndc ; } public String getThreadName ( ) { if ( threadName == null ) threadName = ( Thread . currentThread ( ) ) . getName ( ) ; return threadName ; } public String getThrowableInformation ( ) { if ( throwable == null ) { return null ; } if ( throwableInformation == null ) { StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; throwable . printStackTrace ( pw ) ; throwableInformation = sw . toString ( ) ; } return throwableInformation ; } private void writeObject ( ObjectOutputStream oos ) throws java . io . IOException { this . getThreadName ( ) ; this . getNDC ( ) ; this . getThrowableInformation ( ) ; oos . defaultWriteObject ( ) ; oos . writeInt ( priority . toInt ( ) ) ; } private void readObject ( ObjectInputStream ois ) throws java . io . IOException , ClassNotFoundException { ois . defaultReadObject ( ) ; priority = Priority . toPriority ( ois . readInt ( ) ) ; if ( locationInfo == null ) locationInfo = new LocationInfo ( null , null ) ; } public void setLocationInformation ( ) { if ( locationInfo == null ) { locationInfo = new LocationInfo ( new Throwable ( ) , fqnOfCategoryClass ) ; } } } 	1	['9', '1', '0', '53', '27', '20', '50', '4', '6', '0.894230769', '151', '0.076923077', '2', '0', '0.232142857', '0', '0', '14.33333333', '3', '1.3333', '2']
package org . apache . log4j . helpers ; import java . net . URL ; import java . awt . Image ; import java . awt . Toolkit ; public class Loader extends java . lang . Object { public static Image getGIF_Image ( String path ) { Image img = null ; try { URL url = ClassLoader . getSystemResource ( path ) ; System . out . println ( url ) ; img = ( Image ) ( Toolkit . getDefaultToolkit ( ) ) . getImage ( url ) ; } catch ( Exception e ) { System . out . println ( "Exception occured: " + e . getMessage ( ) + " - " + e ) ; } return ( img ) ; } public static Image getGIF_Image ( URL url ) { Image img = null ; try { System . out . println ( url ) ; img = ( Image ) ( Toolkit . getDefaultToolkit ( ) ) . getImage ( url ) ; } catch ( Exception e ) { System . out . println ( "Exception occured: " + e . getMessage ( ) + " - " + e ) ; } return ( img ) ; } public static URL getHTML_Page ( String path ) { URL url = null ; return ( url = ClassLoader . getSystemResource ( path ) ) ; } } 	1	['4', '1', '0', '0', '15', '6', '0', '0', '4', '2', '73', '0', '0', '0', '0.333333333', '0', '0', '17.25', '1', '0.75', '3']
package org . apache . log4j . xml ; import org . apache . log4j . Layout ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . DateLayout ; public class XMLLayout extends Layout { private final int DEFAULT_SIZE = 256 ; private final int UPPER_LIMIT = 2048 ; private StringBuffer buf = new StringBuffer ( DEFAULT_SIZE ) ; private boolean locationInfo = false ; public static final String LOCATION_INFO_OPTION = "LocationInfo" ; public void activateOptions ( ) { } public String format ( LoggingEvent event ) { if ( buf . capacity ( ) > UPPER_LIMIT ) { buf = new StringBuffer ( DEFAULT_SIZE ) ; } else { buf . setLength ( 0 ) ; } buf . append ( "<log4j:event category=\"" ) ; buf . append ( event . categoryName ) ; buf . append ( "\" timestamp=\"" ) ; buf . append ( event . timeStamp ) ; buf . append ( "\" priority=\"" ) ; buf . append ( event . priority ) ; buf . append ( "\" thread=\"" ) ; buf . append ( event . getThreadName ( ) ) ; buf . append ( "\">\r\n" ) ; buf . append ( "<log4j:message>" ) ; buf . append ( event . message ) ; buf . append ( "</log4j:message>\r\n" ) ; String ndc = event . getNDC ( ) ; if ( ndc != null ) { buf . append ( "<log4j:NDC>" ) ; buf . append ( ndc ) ; buf . append ( "</log4j:NDC>\r\n" ) ; } String t = event . getThrowableInformation ( ) ; if ( t != null ) { buf . append ( "<log4j:throwable>" ) ; buf . append ( t ) ; buf . append ( "</log4j:throwable>\r\n" ) ; } if ( locationInfo ) { event . setLocationInformation ( ) ; buf . append ( "<log4j:locationInfo class=\"" ) ; buf . append ( event . locationInfo . getClassName ( ) ) ; buf . append ( "\" method=\"" ) ; buf . append ( event . locationInfo . getMethodName ( ) ) ; buf . append ( "\" file=\"" ) ; buf . append ( event . locationInfo . getFileName ( ) ) ; buf . append ( "\" line=\"" ) ; buf . append ( event . locationInfo . getLineNumber ( ) ) ; buf . append ( "\"/>\r\n" ) ; } buf . append ( "</log4j:event>\r\n\r\n" ) ; return buf . toString ( ) ; } public String [ ] getOptionStrings ( ) { return new String [ ] { LOCATION_INFO_OPTION } ; } public boolean ignoresThrowable ( ) { return false ; } public void setOption ( String key , String value ) { if ( value == null ) return ; if ( key . equals ( LOCATION_INFO_OPTION ) ) { locationInfo = OptionConverter . toBoolean ( value , locationInfo ) ; } } } 	1	['6', '2', '0', '5', '24', '9', '0', '5', '6', '0.92', '241', '0.8', '0', '0.615384615', '0.444444444', '1', '1', '38.33333333', '5', '1.8333', '1']
package org . apache . log4j . test ; import java . net . Socket ; import java . net . ServerSocket ; import java . io . IOException ; import org . apache . log4j . Category ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . net . SocketNode ; import org . apache . log4j . net . SocketServer ; public class ShortSocketServer { static Category cat = Category . getInstance ( ShortSocketServer . class . getName ( ) ) ; static int port ; static int delay ; static void delay ( int amount ) { try { Thread . currentThread ( ) . sleep ( amount ) ; } catch ( Exception e ) { } } public static void main ( String argv [ ] ) { if ( argv . length == 3 ) init ( argv [ 0 ] , argv [ 1 ] , argv [ 2 ] ) ; else usage ( "Wrong number of arguments." ) ; try { LogLog . debug ( "Listening on port " + port ) ; ServerSocket serverSocket = new ServerSocket ( port ) ; LogLog . debug ( "Waiting to accept a new client." ) ; Socket socket = serverSocket . accept ( ) ; LogLog . debug ( "Connected to client at " + socket . getInetAddress ( ) ) ; LogLog . debug ( "Starting new socket node." ) ; SocketNode sn = new SocketNode ( socket , Category . getDefaultHierarchy ( ) ) ; Thread t = new Thread ( sn ) ; t . start ( ) ; t . join ( ) ; } catch ( Exception e ) { cat . error ( "Error while in main." , e ) ; } } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + ShortSocketServer . class . getName ( ) + " port configFile delay" ) ; System . exit ( 1 ) ; } static void init ( String portStr , String configFile , String delayStr ) { try { port = Integer . parseInt ( portStr ) ; } catch ( java . lang . NumberFormatException e ) { e . printStackTrace ( ) ; usage ( "Could not interpret port number [" + portStr + "]." ) ; } try { delay = Integer . parseInt ( delayStr ) ; } catch ( java . lang . NumberFormatException e ) { e . printStackTrace ( ) ; usage ( "Could not interpret delay number [" + delayStr + "]." ) ; } PropertyConfigurator . configure ( configFile ) ; } } 	1	['7', '1', '0', '5', '35', '15', '0', '5', '2', '0.75', '179', '0', '1', '0', '0.25', '0', '0', '24', '2', '1', '1']
package org . apache . log4j ; import java . io . IOException ; import java . io . Writer ; import java . io . FileWriter ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . ErrorCode ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . QuietWriter ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . TracerPrintWriter ; public class FileAppender extends AppenderSkeleton { public static final String FILE_OPTION = "File" ; public static final String IMMEDIATE_FLUSH_OPTION = "ImmediateFlush" ; public static final String APPEND_OPTION = "Append" ; protected boolean fileAppend = true ; protected boolean immediateFlush = true ; protected QuietWriter qw ; protected TracerPrintWriter tp ; protected String fileName = null ; protected boolean qwIsOurs = false ; public FileAppender ( ) { } public FileAppender ( Layout layout , OutputStream os ) { this ( layout , new OutputStreamWriter ( os ) ) ; } public FileAppender ( Layout layout , Writer writer ) { this . layout = layout ; this . setWriter ( writer ) ; } public FileAppender ( Layout layout , String filename , boolean append ) throws IOException { this . layout = layout ; this . setFile ( filename , append ) ; } public FileAppender ( Layout layout , String filename ) throws IOException { this ( layout , filename , true ) ; } public void activateOptions ( ) { if ( fileName != null ) { try { setFile ( fileName , fileAppend ) ; } catch ( java . io . IOException e ) { errorHandler . error ( "setFile(" + fileName + "," + fileAppend + ") call failed." , e , ErrorCode . FILE_OPEN_FAILURE ) ; } } } public void append ( LoggingEvent event ) { if ( ! checkEntryConditions ( ) ) { return ; } subAppend ( event ) ; } protected boolean checkEntryConditions ( ) { if ( this . qw == null ) { errorHandler . error ( "No output target set for appender named \"" + name + "\"." ) ; return false ; } if ( this . layout == null ) { errorHandler . error ( "No layout set for appender named \"" + name + "\"." ) ; return false ; } return true ; } public void close ( ) { this . closed = true ; reset ( ) ; } protected void closeWriterIfOurs ( ) { if ( this . qwIsOurs && this . qw != null ) { try { this . qw . close ( ) ; } catch ( java . io . IOException e ) { LogLog . error ( "Could not close output stream " + qw , e ) ; } } } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { FILE_OPTION , APPEND_OPTION , IMMEDIATE_FLUSH_OPTION } ) ; } public synchronized void setErrorHandler ( ErrorHandler eh ) { this . errorHandler = eh ; if ( this . qwIsOurs && this . qw != null ) { this . qw . setErrorHandler ( eh ) ; } } public synchronized void setFile ( String fileName , boolean append ) throws IOException { reset ( ) ; this . setQWForFiles ( new FileWriter ( fileName , append ) ) ; this . tp = new TracerPrintWriter ( qw ) ; this . fileName = fileName ; this . qwIsOurs = true ; } public void setFile ( String fileName ) throws IOException { this . setFile ( fileName , fileAppend ) ; } public void setOption ( String key , String value ) { if ( value == null ) return ; super . setOption ( key , value ) ; if ( key . equalsIgnoreCase ( FILE_OPTION ) ) { value = value . trim ( ) ; if ( value . equalsIgnoreCase ( "System.out" ) ) setWriter ( new OutputStreamWriter ( System . out ) ) ; else if ( value . equalsIgnoreCase ( "System.err" ) ) setWriter ( new OutputStreamWriter ( System . err ) ) ; else { fileName = value ; } } else if ( key . equalsIgnoreCase ( APPEND_OPTION ) ) { fileAppend = OptionConverter . toBoolean ( value , fileAppend ) ; } else if ( key . equalsIgnoreCase ( IMMEDIATE_FLUSH_OPTION ) ) { immediateFlush = OptionConverter . toBoolean ( value , immediateFlush ) ; } } public synchronized void setWriter ( Writer writer ) { reset ( ) ; this . qw = new QuietWriter ( writer , errorHandler ) ; this . tp = new TracerPrintWriter ( qw ) ; this . qwIsOurs = false ; } protected void setQWForFiles ( Writer writer ) { this . qw = new QuietWriter ( writer , errorHandler ) ; } protected void subAppend ( LoggingEvent event ) { this . qw . write ( this . layout . format ( event ) ) ; if ( layout . ignoresThrowable ( ) ) { if ( event . throwable != null ) { event . throwable . printStackTrace ( this . tp ) ; } else if ( event . throwableInformation != null ) { this . qw . write ( event . throwableInformation ) ; } } if ( this . immediateFlush ) { this . qw . flush ( ) ; } } public boolean requiresLayout ( ) { return true ; } protected void reset ( ) { closeWriterIfOurs ( ) ; this . fileName = null ; this . qw = null ; this . tp = null ; } } 	1	['20', '2', '2', '17', '46', '58', '9', '8', '15', '0.649122807', '413', '0.666666667', '2', '0.545454545', '0.2375', '1', '3', '19.2', '7', '1.65', '1']
package org . apache . log4j ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . OptionConverter ; import java . io . StringWriter ; import java . io . PrintWriter ; import java . io . Writer ; public class HTMLLayout extends Layout { protected final int BUF_SIZE = 256 ; protected final int MAX_CAPACITY = 1024 ; private StringBuffer sbuf = new StringBuffer ( BUF_SIZE ) ; public static final String LOCATION_INFO_OPTION = "LocationInfo" ; boolean locationInfo = false ; public void activateOptions ( ) { } public String format ( LoggingEvent event ) { if ( sbuf . capacity ( ) > MAX_CAPACITY ) { sbuf = new StringBuffer ( BUF_SIZE ) ; } else { sbuf . setLength ( 0 ) ; } sbuf . append ( "\r\n\r\n<tr>" ) ; sbuf . append ( "<td>" ) ; sbuf . append ( event . timeStamp - event . getStartTime ( ) ) ; sbuf . append ( "</td>\r\n" ) ; sbuf . append ( "<td>" ) ; sbuf . append ( event . getThreadName ( ) ) ; sbuf . append ( "</td>\r\n" ) ; sbuf . append ( "<td>" ) ; if ( event . priority . isGreaterOrEqual ( Priority . WARN ) ) { sbuf . append ( "<font color=\"#FF0000\">" ) ; sbuf . append ( event . priority ) ; sbuf . append ( "</font>" ) ; } else { sbuf . append ( event . priority ) ; } sbuf . append ( "</td>\r\n" ) ; sbuf . append ( "<td>" ) ; sbuf . append ( event . categoryName ) ; sbuf . append ( "</td>\r\n" ) ; sbuf . append ( "<td>" ) ; sbuf . append ( event . getNDC ( ) ) ; sbuf . append ( "</td>\r\n" ) ; if ( locationInfo ) { event . setLocationInformation ( ) ; sbuf . append ( "<td>" ) ; sbuf . append ( event . locationInfo . getFileName ( ) ) ; sbuf . append ( ':' ) ; sbuf . append ( event . locationInfo . getLineNumber ( ) ) ; sbuf . append ( "</td>\r\n" ) ; } sbuf . append ( "<td>" ) ; sbuf . append ( event . message ) ; sbuf . append ( "</td>\r\n" ) ; sbuf . append ( "</tr>" ) ; if ( event . throwable != null ) { sbuf . append ( "\r\n<tr><td colspan=\"7\">" ) ; sbuf . append ( getThrowableAsHTML ( event . throwable ) ) ; sbuf . append ( "</td></tr>" ) ; } return sbuf . toString ( ) ; } public String getContentType ( ) { return "text/html" ; } public String getHeader ( ) { StringBuffer sbuf = new StringBuffer ( ) ; sbuf . append ( "<html><body>\r\n" ) ; sbuf . append ( "<table border=\"1\" cellpadding=\"2\">\r\n<tr>\r\n" ) ; sbuf . append ( "<th>Time</th><th>Thread</th><th>Priority</th><th>Category</th>" ) ; sbuf . append ( "<th>NDC</th>" ) ; if ( locationInfo ) { sbuf . append ( "<th>File:Line</th>" ) ; } sbuf . append ( "<th>Message</th></tr>" ) ; return sbuf . toString ( ) ; } public String getFooter ( ) { return "</table></body></html>" ; } public String [ ] getOptionStrings ( ) { return new String [ ] { LOCATION_INFO_OPTION } ; } String getThrowableAsHTML ( Throwable throwable ) { if ( throwable == null ) return null ; StringWriter sw = new StringWriter ( ) ; HTMLPrintWriter hpw = new HTMLPrintWriter ( sw ) ; throwable . printStackTrace ( hpw ) ; return sw . toString ( ) ; } public boolean ignoresThrowable ( ) { return false ; } public void setOption ( String key , String value ) { if ( value == null ) return ; if ( key . equals ( LOCATION_INFO_OPTION ) ) { locationInfo = OptionConverter . toBoolean ( value , locationInfo ) ; } } static class HTMLPrintWriter extends PrintWriter { static String TRACE_PREFIX = "<br>&nbsp;&nbsp;&nbsp;&nbsp;" ; public HTMLPrintWriter ( Writer writer ) { super ( writer ) ; } public void println ( char [ ] c ) { write ( TRACE_PREFIX ) ; this . write ( c ) ; } public void println ( String s ) { write ( TRACE_PREFIX ) ; this . write ( s ) ; } } } 	1	['10', '2', '0', '6', '33', '33', '0', '6', '9', '0.933333333', '321', '0.6', '0', '0.470588235', '0.325', '1', '1', '30.6', '5', '1.7', '2']
package org . apache . log4j ; import org . apache . log4j . Priority ; import org . apache . log4j . spi . RootCategory ; import org . apache . log4j . spi . AppenderAttachable ; import org . apache . log4j . spi . CategoryFactory ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . NullEnumeration ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . AppenderAttachableImpl ; import org . apache . log4j . or . RendererMap ; import org . apache . log4j . or . ObjectRenderer ; import java . util . Enumeration ; import java . util . Vector ; import java . util . MissingResourceException ; import java . text . MessageFormat ; import java . util . ResourceBundle ; import java . net . URL ; import java . net . MalformedURLException ; public class Category implements AppenderAttachable { static final int DISABLE_OFF = - 1 ; static final int DISABLE_OVERRIDE = - 21 ; private static String DEFAULT_FQN = "org.apache.log4j.Category" ; protected static String instanceFQN ; protected static int disable = Category . DISABLE_OFF ; static boolean emittedNoAppenderWarning = false ; static boolean emittedNoResourceBundleWarning = false ; static public final Hierarchy defaultHierarchy = new Hierarchy ( new RootCategory ( Priority . DEBUG ) ) ; protected ResourceBundle resourceBundle ; protected Hierarchy myContext ; static public final String DEFAULT_CONFIGURATION_FILE = "log4j.properties" ; static final public String DEFAULT_CONFIGURATION_KEY = "log4j.configuration" ; public static final String DEFAULT_INIT_OVERRIDE_KEY = "log4j.defaultInitOverride" ; static { String override = null ; try { override = System . getProperty ( DEFAULT_INIT_OVERRIDE_KEY , override ) ; } catch ( SecurityException e ) { LogLog . debug ( "Could not read system property \"" + DEFAULT_INIT_OVERRIDE_KEY + "\"." , e ) ; } if ( override == null || "false" . equalsIgnoreCase ( override ) ) { String resource = System . getProperty ( DEFAULT_CONFIGURATION_KEY , DEFAULT_CONFIGURATION_FILE ) ; URL url = null ; try { url = new URL ( resource ) ; } catch ( MalformedURLException ex ) { url = Category . class . getResource ( resource ) ; if ( url == null ) { ClassLoader loader = Category . class . getClassLoader ( ) ; if ( loader != null ) { url = loader . getResource ( resource ) ; } } } if ( url != null ) { OptionConverter . selectAndConfigure ( url ) ; } else { LogLog . debug ( "Could not find resource: [" + resource + "]." ) ; } } } protected String name ; protected Priority priority ; protected Category parent ; AppenderAttachableImpl aai ; protected boolean additive = true ; protected Category ( String name ) { this . name = name ; this . instanceFQN = DEFAULT_FQN ; } synchronized public void addAppender ( Appender newAppender ) { if ( aai == null ) { aai = new AppenderAttachableImpl ( ) ; } aai . addAppender ( newAppender ) ; } public void assert ( boolean assertion , String msg ) { if ( ! assertion ) this . error ( msg ) ; } public void callAppenders ( LoggingEvent event ) { int writes = 0 ; for ( Category c = this ; c != null ; c = c . parent ) { synchronized ( c ) { if ( c . aai != null ) { writes += c . aai . appendLoopOnAppenders ( event ) ; } if ( ! c . additive ) { break ; } } } if ( ! Category . emittedNoAppenderWarning && writes == 0 ) { LogLog . error ( "No appenders could be found for category (" + this . getName ( ) + ")." ) ; LogLog . error ( "Please initialize the log4j system properly." ) ; emittedNoAppenderWarning = true ; } } synchronized void closeNestedAppenders ( ) { Enumeration enum = this . getAllAppenders ( ) ; if ( enum != null ) { while ( enum . hasMoreElements ( ) ) { Appender a = ( Appender ) enum . nextElement ( ) ; if ( a instanceof AppenderAttachable ) { a . close ( ) ; } } } } public void debug ( Object message ) { if ( disable >= Priority . DEBUG_INT ) return ; if ( Priority . DEBUG . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) { forcedLog ( instanceFQN , Priority . DEBUG , message , null ) ; } } public void debug ( Object message , Throwable t ) { if ( disable >= Priority . DEBUG_INT ) return ; if ( Priority . DEBUG . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) forcedLog ( instanceFQN , Priority . DEBUG , message , t ) ; } public void error ( Object message ) { if ( disable >= Priority . ERROR_INT ) return ; if ( this . isEnabledFor ( Priority . ERROR ) ) forcedLog ( instanceFQN , Priority . ERROR , message , null ) ; } public void error ( Object message , Throwable t ) { if ( disable >= Priority . ERROR_INT ) return ; if ( this . isEnabledFor ( Priority . ERROR ) ) forcedLog ( instanceFQN , Priority . ERROR , message , t ) ; } public static Category exists ( String name ) { return defaultHierarchy . exists ( name ) ; } public void fatal ( Object message ) { if ( disable >= Priority . FATAL_INT ) return ; if ( Priority . FATAL . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) forcedLog ( instanceFQN , Priority . FATAL , message , null ) ; } public void fatal ( Object message , Throwable t ) { if ( disable >= Priority . FATAL_INT ) return ; if ( Priority . FATAL . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) forcedLog ( instanceFQN , Priority . FATAL , message , t ) ; } protected void forcedLog ( String fqn , Priority priority , Object message , Throwable t ) { String s ; if ( message instanceof String ) { s = ( String ) message ; } else { s = myContext . rendererMap . findAndRender ( message ) ; } callAppenders ( new LoggingEvent ( fqn , this , priority , s , t ) ) ; } public boolean getAdditivity ( ) { return additive ; } public Enumeration getAllAppenders ( ) { if ( aai == null ) return NullEnumeration . getInstance ( ) ; else return aai . getAllAppenders ( ) ; } public Appender getAppender ( String name ) { if ( aai == null || name == null ) return null ; return aai . getAppender ( name ) ; } public Priority getChainedPriority ( ) { for ( Category c = this ; c != null ; c = c . parent ) { if ( c . priority != null ) return c . priority ; } return null ; } public static Enumeration getCurrentCategories ( ) { Vector v = new Vector ( defaultHierarchy . ht . size ( ) ) ; Enumeration elems = defaultHierarchy . ht . elements ( ) ; while ( elems . hasMoreElements ( ) ) { Object o = elems . nextElement ( ) ; if ( o instanceof Category ) { v . addElement ( o ) ; } } return v . elements ( ) ; } public static Hierarchy getDefaultHierarchy ( ) { return defaultHierarchy ; } public static Category getInstance ( String name ) { return defaultHierarchy . getInstance ( name ) ; } public static Category getInstance ( Class clazz ) { return getInstance ( clazz . getName ( ) ) ; } public static Category getInstance ( String name , CategoryFactory factory ) { return defaultHierarchy . getInstance ( name , factory ) ; } public final String getName ( ) { return name ; } final public Priority getPriority ( ) { return this . priority ; } final public static Category getRoot ( ) { return defaultHierarchy . getRoot ( ) ; } public ResourceBundle getResourceBundle ( ) { for ( Category c = this ; c != null ; c = c . parent ) { if ( c . resourceBundle != null ) return c . resourceBundle ; } return null ; } protected String getResourceBundleString ( String key ) { ResourceBundle rb = getResourceBundle ( ) ; if ( rb == null ) { if ( ! emittedNoResourceBundleWarning ) { error ( "No resource bundle has been set for category " + name ) ; emittedNoResourceBundleWarning = true ; } return null ; } else { try { return rb . getString ( key ) ; } catch ( MissingResourceException mre ) { error ( "No resource is associated with key \"" + key + "\"." ) ; return null ; } } } public void info ( Object message ) { if ( disable >= Priority . INFO_INT ) return ; if ( Priority . INFO . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) forcedLog ( instanceFQN , Priority . INFO , message , null ) ; } public void info ( Object message , Throwable t ) { if ( disable >= Priority . INFO_INT ) return ; if ( Priority . INFO . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) forcedLog ( instanceFQN , Priority . INFO , message , t ) ; } public boolean isDebugEnabled ( ) { if ( disable >= Priority . DEBUG_INT ) return false ; return Priority . DEBUG . isGreaterOrEqual ( this . getChainedPriority ( ) ) ; } public boolean isEnabledFor ( Priority priority ) { if ( disable >= priority . level ) { return false ; } return priority . isGreaterOrEqual ( this . getChainedPriority ( ) ) ; } public boolean isInfoEnabled ( ) { if ( disable >= Priority . INFO_INT ) return false ; return Priority . INFO . isGreaterOrEqual ( this . getChainedPriority ( ) ) ; } public void l7dlog ( Priority priority , String key , Throwable t ) { if ( disable >= priority . level ) { return ; } if ( priority . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) { String msg = getResourceBundleString ( key ) ; if ( msg == null ) { msg = key ; } callAppenders ( new LoggingEvent ( instanceFQN , this , priority , msg , t ) ) ; } } public void l7dlog ( Priority priority , String key , Object [ ] params , Throwable t ) { if ( disable >= priority . level ) { return ; } if ( priority . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) { String pattern = getResourceBundleString ( key ) ; String msg ; if ( pattern == null ) msg = key ; else msg = java . text . MessageFormat . format ( pattern , params ) ; callAppenders ( new LoggingEvent ( instanceFQN , this , priority , msg , t ) ) ; } } public void log ( Priority priority , Object message , Throwable t ) { if ( disable >= priority . level ) { return ; } if ( priority . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) forcedLog ( instanceFQN , priority , message , t ) ; } public void log ( Priority priority , Object message ) { if ( disable >= priority . level ) { return ; } if ( priority . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) forcedLog ( instanceFQN , priority , message , null ) ; } public void log ( String callerFQN , Priority priority , Object message , Throwable t ) { if ( disable >= priority . level ) { return ; } if ( priority . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) { forcedLog ( callerFQN , priority , message , t ) ; } } synchronized public void removeAllAppenders ( ) { if ( aai != null ) { aai . removeAllAppenders ( ) ; aai = null ; } } synchronized public void removeAppender ( Appender appender ) { if ( appender == null || aai == null ) return ; aai . removeAppender ( appender ) ; } synchronized public void removeAppender ( String name ) { if ( name == null || aai == null ) return ; aai . removeAppender ( name ) ; } public void setAdditivity ( boolean additive ) { this . additive = additive ; } final void setHierarchy ( Hierarchy hierarchy ) { this . myContext = hierarchy ; } public void setPriority ( Priority priority ) { this . priority = priority ; } public void setResourceBundle ( ResourceBundle bundle ) { resourceBundle = bundle ; } public static void shutdown ( ) { defaultHierarchy . shutdown ( ) ; } public void warn ( Object message ) { if ( this . isEnabledFor ( Priority . WARN ) ) forcedLog ( instanceFQN , Priority . WARN , message , null ) ; } public void warn ( Object message , Throwable t ) { if ( this . isEnabledFor ( Priority . WARN ) ) forcedLog ( instanceFQN , Priority . WARN , message , t ) ; } } 	1	['49', '1', '3', '60', '96', '688', '53', '12', '42', '0.828947368', '800', '0.473684211', '5', '0', '0.150641026', '0', '0', '14.93877551', '6', '2.1429', '9']
package org . apache . log4j ; import org . apache . log4j . spi . Filter ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . LoggingEvent ; public interface Appender { void addFilter ( Filter newFilter ) ; public void clearFilters ( ) ; public void close ( ) ; public void doAppend ( LoggingEvent event ) ; public String getName ( ) ; public void setErrorHandler ( ErrorHandler errorHandler ) ; public void setLayout ( Layout layout ) ; public void setName ( String name ) ; public boolean requiresLayout ( ) ; } 	1	['9', '1', '0', '22', '9', '36', '18', '4', '9', '2', '9', '0', '0', '0', '0.259259259', '0', '0', '0', '1', '1', '1']
package org . apache . log4j . nt ; import org . apache . log4j . * ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Priority ; import java . io . * ; public class NTEventLogAppender extends AppenderSkeleton { private int _handle = 0 ; private static final int FATAL = Priority . FATAL . toInt ( ) ; private static final int ERROR = Priority . ERROR . toInt ( ) ; private static final int WARN = Priority . WARN . toInt ( ) ; private static final int INFO = Priority . INFO . toInt ( ) ; private static final int DEBUG = Priority . DEBUG . toInt ( ) ; public NTEventLogAppender ( ) { this ( null , null , null ) ; } public NTEventLogAppender ( String source ) { this ( null , source , null ) ; } public NTEventLogAppender ( String server , String source ) { this ( server , source , null ) ; } public NTEventLogAppender ( Layout layout ) { this ( null , null , layout ) ; } public NTEventLogAppender ( String source , Layout layout ) { this ( null , source , layout ) ; } public NTEventLogAppender ( String server , String source , Layout layout ) { if ( source == null ) { source = "Log4j" ; } if ( layout == null ) { this . layout = new TTCCLayout ( ) ; } else { this . layout = layout ; } try { _handle = registerEventSource ( server , source ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; _handle = 0 ; } } public void close ( ) { } public void append ( LoggingEvent event ) { StringWriter sw_writer = new StringWriter ( ) ; PrintWriter pw_writer = new PrintWriter ( sw_writer ) ; pw_writer . print ( layout . format ( event ) ) ; if ( event . throwable != null ) event . throwable . printStackTrace ( pw_writer ) ; pw_writer . close ( ) ; int nt_category = event . priority . toInt ( ) ; if ( nt_category < FATAL || nt_category > DEBUG ) { nt_category = INFO ; } reportEvent ( _handle , sw_writer . toString ( ) , nt_category ) ; } public void finalize ( ) { deregisterEventSource ( _handle ) ; _handle = 0 ; } public boolean requiresLayout ( ) { return true ; } native private int registerEventSource ( String server , String source ) ; native private void reportEvent ( int handle , String message , int priority ) ; native private void deregisterEventSource ( int handle ) ; static { System . loadLibrary ( "NTEventLogAppender" ) ; } } 	1	['14', '2', '0', '6', '26', '83', '1', '5', '10', '0.871794872', '157', '1', '0', '0.72', '0.384615385', '1', '1', '9.785714286', '4', '0.7143', '1']
package org . apache . log4j . net ; import org . apache . log4j . AppenderSkeleton ; import org . apache . log4j . Layout ; import org . apache . log4j . Priority ; import org . apache . log4j . helpers . CyclicBuffer ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . spi . ErrorCode ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . TriggeringEventEvaluator ; import java . util . Properties ; import java . util . Date ; import javax . mail . Session ; import javax . mail . Transport ; import javax . mail . Message ; import javax . mail . MessagingException ; import javax . mail . internet . MimeMessage ; import javax . mail . Multipart ; import javax . mail . internet . MimeMultipart ; import javax . mail . internet . MimeBodyPart ; import javax . mail . internet . InternetAddress ; import javax . mail . internet . AddressException ; import javax . mail . internet . MimeUtility ; public class SMTPAppender extends AppenderSkeleton { public static final String TO_OPTION = "To" ; public static final String FROM_OPTION = "From" ; public static final String SUBJECT_OPTION = "Subject" ; public static final String SMTP_HOST_OPTION = "SMTPHost" ; public static final String BUFFER_SIZE_OPTION = "BufferSize" ; public static final String EVALUATOR_CLASS_OPTION = "EvaluatorClass" ; public static final String LOCATION_INFO_OPTION = "LocationInfo" ; String to ; String from ; String subject ; String smtpHost ; int bufferSize = 512 ; CyclicBuffer cb = new CyclicBuffer ( bufferSize ) ; Session session ; Message msg ; boolean locationInfo = false ; TriggeringEventEvaluator evaluator ; public SMTPAppender ( ) { this ( new DefaultEvaluator ( ) ) ; } public SMTPAppender ( TriggeringEventEvaluator evaluator ) { this . evaluator = evaluator ; } public void activateOptions ( ) { Properties props = System . getProperties ( ) ; if ( smtpHost != null ) props . put ( "mail.smtp.host" , smtpHost ) ; session = Session . getDefaultInstance ( props , null ) ; msg = new MimeMessage ( session ) ; try { if ( from != null ) msg . setFrom ( getAddress ( from ) ) ; else msg . setFrom ( ) ; msg . setRecipients ( Message . RecipientType . TO , parseAddress ( to ) ) ; if ( subject != null ) msg . setSubject ( subject ) ; } catch ( MessagingException e ) { LogLog . error ( "Could not activate SMTPAppender options." , e ) ; } } public void append ( LoggingEvent event ) { if ( ! checkEntryConditions ( ) ) { return ; } event . getThreadName ( ) ; event . getNDC ( ) ; if ( locationInfo ) { event . setLocationInformation ( ) ; } cb . add ( event ) ; if ( evaluator . isTriggeringEvent ( event ) ) { sendBuffer ( ) ; } } protected boolean checkEntryConditions ( ) { if ( this . msg == null ) { errorHandler . error ( "Message object not configured." ) ; return false ; } if ( this . evaluator == null ) { errorHandler . error ( "No TriggeringEventEvaluator is set for appender [" + name + "]." ) ; return false ; } if ( this . layout == null ) { errorHandler . error ( "No layout set for appender named [" + name + "]." ) ; return false ; } return true ; } public void close ( ) { this . closed = true ; } InternetAddress getAddress ( String addressStr ) { try { return new InternetAddress ( addressStr ) ; } catch ( AddressException e ) { errorHandler . error ( "Could not parse address [" + addressStr + "]." , e , ErrorCode . ADDRESS_PARSE_FAILURE ) ; return null ; } } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { TO_OPTION , FROM_OPTION , SUBJECT_OPTION , SMTP_HOST_OPTION , BUFFER_SIZE_OPTION , LOCATION_INFO_OPTION } ) ; } InternetAddress [ ] parseAddress ( String addressStr ) { try { return InternetAddress . parse ( addressStr , true ) ; } catch ( AddressException e ) { errorHandler . error ( "Could not parse address [" + addressStr + "]." , e , ErrorCode . ADDRESS_PARSE_FAILURE ) ; return null ; } } public boolean requiresLayout ( ) { return true ; } protected void sendBuffer ( ) { try { MimeBodyPart part = new MimeBodyPart ( ) ; StringBuffer sbuf = new StringBuffer ( ) ; String t = layout . getHeader ( ) ; if ( t != null ) sbuf . append ( t ) ; int len = cb . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { sbuf . append ( layout . format ( cb . get ( ) ) ) ; } t = layout . getFooter ( ) ; if ( t != null ) sbuf . append ( t ) ; part . setContent ( sbuf . toString ( ) , layout . getContentType ( ) ) ; Multipart mp = new MimeMultipart ( ) ; mp . addBodyPart ( part ) ; msg . setContent ( mp ) ; msg . setSentDate ( new Date ( ) ) ; Transport . send ( msg ) ; } catch ( Exception e ) { LogLog . error ( "Error occured while sending e-mail notification." , e ) ; } } public void setOption ( String option , String value ) { if ( value == null ) return ; super . setOption ( option , value ) ; if ( option . equals ( TO_OPTION ) ) to = value ; else if ( option . equals ( FROM_OPTION ) ) from = value ; else if ( option . equals ( SMTP_HOST_OPTION ) ) smtpHost = value ; else if ( option . equals ( SUBJECT_OPTION ) ) subject = value ; else if ( option . equals ( EVALUATOR_CLASS_OPTION ) ) { evaluator = ( TriggeringEventEvaluator ) OptionConverter . instantiateByClassName ( value , TriggeringEventEvaluator . class , evaluator ) ; } else if ( option . equals ( BUFFER_SIZE_OPTION ) ) { bufferSize = OptionConverter . toInt ( value , bufferSize ) ; cb . resize ( bufferSize ) ; } else if ( option . equals ( LOCATION_INFO_OPTION ) ) locationInfo = OptionConverter . toBoolean ( value , locationInfo ) ; } } class DefaultEvaluator implements TriggeringEventEvaluator { public boolean isTriggeringEvent ( LoggingEvent event ) { return event . priority . isGreaterOrEqual ( Priority . ERROR ) ; } } 	1	['13', '2', '0', '9', '62', '52', '0', '9', '8', '0.939814815', '449', '0', '2', '0.620689655', '0.346153846', '2', '3', '32.15384615', '10', '2.3846', '3']
package org . apache . log4j ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . DefaultCategoryFactory ; import org . apache . log4j . spi . OptionHandler ; import org . apache . log4j . spi . Configurator ; import org . apache . log4j . spi . CategoryFactory ; import org . apache . log4j . or . ObjectRenderer ; import org . apache . log4j . or . RendererMap ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . FileWatchdog ; import java . util . NoSuchElementException ; import java . util . Enumeration ; import java . util . Properties ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . StringTokenizer ; import java . util . Hashtable ; public class PropertyConfigurator extends BasicConfigurator implements Configurator { protected Hashtable registry = new Hashtable ( 11 ) ; protected CategoryFactory categoryFactory = new DefaultCategoryFactory ( ) ; static final String CATEGORY_PREFIX = "log4j.category." ; static final String ADDITIVITY_PREFIX = "log4j.additivity." ; static final String ROOT_CATEGORY_PREFIX = "log4j.rootCategory" ; static final String APPENDER_PREFIX = "log4j.appender." ; static final String RENDERER_PREFIX = "log4j.renderer." ; static final String CATEGORY_FACTORY_KEY = "log4j.categoryFactory" ; static final private String INTERNAL_ROOT_NAME = "root" ; public void doConfigure ( String configFileName , Hierarchy hierarchy ) { Properties props = new Properties ( ) ; try { FileInputStream istream = new FileInputStream ( configFileName ) ; props . load ( istream ) ; istream . close ( ) ; } catch ( IOException e ) { LogLog . error ( "Could not read configuration file [" + configFileName + "]." , e ) ; LogLog . error ( "Ignoring configuration file [" + configFileName + "]." ) ; return ; } doConfigure ( props , hierarchy ) ; } static public void configure ( String configFilename ) { new PropertyConfigurator ( ) . doConfigure ( configFilename , Category . defaultHierarchy ) ; } public static void configure ( java . net . URL configURL ) { new PropertyConfigurator ( ) . doConfigure ( configURL , Category . defaultHierarchy ) ; } static public void configure ( Properties properties ) { new PropertyConfigurator ( ) . doConfigure ( properties , Category . defaultHierarchy ) ; } static public void configureAndWatch ( String configFilename ) { configureAndWatch ( configFilename , FileWatchdog . DEFAULT_DELAY ) ; } static public void configureAndWatch ( String configFilename , long delay ) { PropertyWatchdog pdog = new PropertyWatchdog ( configFilename ) ; pdog . setDelay ( delay ) ; pdog . start ( ) ; } public void doConfigure ( Properties properties , Hierarchy hierarchy ) { String value = properties . getProperty ( LogLog . CONFIG_DEBUG_KEY ) ; if ( value != null ) { LogLog . setInternalDebugging ( OptionConverter . toBoolean ( value , true ) ) ; } String override = properties . getProperty ( BasicConfigurator . DISABLE_OVERRIDE_KEY ) ; BasicConfigurator . overrideAsNeeded ( override ) ; configureRootCategory ( properties , hierarchy ) ; configureCategoryFactory ( properties ) ; parseCatsAndRenderers ( properties , hierarchy ) ; LogLog . debug ( "Finished configuring." ) ; registry . clear ( ) ; } public void doConfigure ( java . net . URL configURL , Hierarchy hierarchy ) { Properties props = new Properties ( ) ; LogLog . debug ( "Reading configuration from URL " + configURL ) ; try { props . load ( configURL . openStream ( ) ) ; } catch ( java . io . IOException e ) { LogLog . error ( "Could not read configuration file from URL [" + configURL + "]." , e ) ; LogLog . error ( "Ignoring configuration file [" + configURL + "]." ) ; return ; } doConfigure ( props , hierarchy ) ; } void configureCategoryFactory ( Properties props ) { String factoryClassName = OptionConverter . findAndSubst ( CATEGORY_FACTORY_KEY , props ) ; if ( factoryClassName != null ) { LogLog . debug ( "Setting category factory to [" + factoryClassName + "]." ) ; categoryFactory = ( CategoryFactory ) OptionConverter . instantiateByClassName ( factoryClassName , CategoryFactory . class , categoryFactory ) ; } } void configureOptionHandler ( OptionHandler oh , String prefix , Properties props ) { String [ ] options = oh . getOptionStrings ( ) ; if ( options == null ) return ; String value ; for ( int i = 0 ; i < options . length ; i ++ ) { value = OptionConverter . findAndSubst ( prefix + options [ i ] , props ) ; LogLog . debug ( "Option " + options [ i ] + "=[" + ( value == null ? "null" : value ) + "]." ) ; if ( value != null ) { oh . setOption ( options [ i ] , value ) ; } } oh . activateOptions ( ) ; } void configureRootCategory ( Properties props , Hierarchy hierarchy ) { String value = OptionConverter . findAndSubst ( ROOT_CATEGORY_PREFIX , props ) ; if ( value == null ) LogLog . debug ( "Could not find root category information. Is this OK?" ) ; else { Category root = hierarchy . getRoot ( ) ; synchronized ( root ) { parseCategory ( props , root , ROOT_CATEGORY_PREFIX , INTERNAL_ROOT_NAME , value ) ; } } } protected void parseCatsAndRenderers ( Properties props , Hierarchy hierarchy ) { Enumeration enum = props . propertyNames ( ) ; while ( enum . hasMoreElements ( ) ) { String key = ( String ) enum . nextElement ( ) ; if ( key . startsWith ( CATEGORY_PREFIX ) ) { String categoryName = key . substring ( CATEGORY_PREFIX . length ( ) ) ; String value = OptionConverter . findAndSubst ( key , props ) ; Category cat = hierarchy . getInstance ( categoryName , categoryFactory ) ; synchronized ( cat ) { parseCategory ( props , cat , key , categoryName , value ) ; parseAdditivityForCategory ( props , cat , categoryName ) ; } } else if ( key . startsWith ( RENDERER_PREFIX ) ) { String renderedClass = key . substring ( RENDERER_PREFIX . length ( ) ) ; String renderingClass = OptionConverter . findAndSubst ( key , props ) ; addRenderer ( renderedClass , renderingClass ) ; } } } void parseAdditivityForCategory ( Properties props , Category cat , String categoryName ) { String value = OptionConverter . findAndSubst ( ADDITIVITY_PREFIX + categoryName , props ) ; LogLog . debug ( "Handling " + ADDITIVITY_PREFIX + categoryName + "=[" + value + "]" ) ; if ( ( value != null ) && ( ! value . equals ( "" ) ) ) { boolean additivity = OptionConverter . toBoolean ( value , true ) ; LogLog . debug ( "Setting additivity for \"" + categoryName + "\" to " + additivity ) ; cat . setAdditivity ( additivity ) ; } } void parseCategory ( Properties props , Category cat , String optionKey , String catName , String value ) { LogLog . debug ( "Parsing for [" + catName + "] with value=[" + value + "]." ) ; StringTokenizer st = new StringTokenizer ( value , "," ) ; if ( ! ( value . startsWith ( "," ) || value . equals ( "" ) ) ) { if ( ! st . hasMoreTokens ( ) ) return ; String priorityStr = st . nextToken ( ) ; LogLog . debug ( "Priority token is [" + priorityStr + "]." ) ; if ( priorityStr . equalsIgnoreCase ( BasicConfigurator . INHERITED ) && ! catName . equals ( INTERNAL_ROOT_NAME ) ) cat . setPriority ( null ) ; else cat . setPriority ( Priority . toPriority ( priorityStr ) ) ; LogLog . debug ( "Category " + catName + " set to " + cat . getPriority ( ) ) ; } cat . removeAllAppenders ( ) ; Appender appender ; String appenderName ; while ( st . hasMoreTokens ( ) ) { appenderName = st . nextToken ( ) . trim ( ) ; if ( appenderName == null || appenderName . equals ( "," ) ) continue ; LogLog . debug ( "Parsing appender named \"" + appenderName + "\"." ) ; appender = parseAppender ( props , appenderName ) ; if ( appender != null ) { cat . addAppender ( appender ) ; } } } Appender parseAppender ( Properties props , String appenderName ) { Appender appender = registryGet ( appenderName ) ; if ( ( appender != null ) ) { LogLog . debug ( "Appender \"" + appenderName + "\" was already parsed." ) ; return appender ; } String prefix = APPENDER_PREFIX + appenderName ; String layoutPrefix = prefix + ".layout" ; appender = ( Appender ) OptionConverter . instantiateByKey ( props , prefix , org . apache . log4j . Appender . class , null ) ; if ( appender == null ) { LogLog . error ( "Could not instantiate appender named \"" + appenderName + "\"." ) ; return null ; } appender . setName ( appenderName ) ; if ( appender instanceof OptionHandler ) { configureOptionHandler ( ( OptionHandler ) appender , prefix + "." , props ) ; LogLog . debug ( "Parsed \"" + appenderName + "\" options." ) ; if ( appender . requiresLayout ( ) ) { Layout layout = ( Layout ) OptionConverter . instantiateByKey ( props , layoutPrefix , Layout . class , null ) ; if ( layout != null ) { appender . setLayout ( layout ) ; LogLog . debug ( "Parsing layout options for \"" + appenderName + "\"." ) ; configureOptionHandler ( layout , layoutPrefix + "." , props ) ; LogLog . debug ( "End of parsing for \"" + appenderName + "\"." ) ; } } } registryPut ( appender ) ; return appender ; } void registryPut ( Appender appender ) { registry . put ( appender . getName ( ) , appender ) ; } Appender registryGet ( String name ) { return ( Appender ) registry . get ( name ) ; } } class PropertyWatchdog extends FileWatchdog { PropertyWatchdog ( String filename ) { super ( filename ) ; } public void doOnChange ( ) { new PropertyConfigurator ( ) . doConfigure ( filename , Category . defaultHierarchy ) ; } } 	1	['19', '2', '0', '28', '79', '153', '16', '14', '9', '0.939814815', '754', '0.25', '1', '0.4', '0.257309942', '1', '1', '38.05263158', '10', '2.4211', '2']
package org . apache . log4j . xml . examples ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . spi . OptionHandler ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . spi . CategoryFactory ; import org . apache . log4j . xml . examples . XPriority ; public class XCategory extends Category implements OptionHandler { private static XFactory factory = new XFactory ( ) ; static String instanceFQCN = XCategory . class . getName ( ) ; public static final String SUFFIX_OPTION = "Suffix" ; String suffix ; public XCategory ( String name ) { super ( name ) ; } public void activateOptions ( ) { } public void debug ( String message ) { log ( instanceFQCN , Priority . DEBUG , message + suffix , null ) ; } public void fatal ( String message ) { if ( disable <= XPriority . FATAL_INT ) return ; if ( XPriority . FATAL . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) callAppenders ( new LoggingEvent ( instanceFQCN , this , XPriority . FATAL , message , null ) ) ; } public static Category getInstance ( String name ) { return Category . getInstance ( name , factory ) ; } public String [ ] getOptionStrings ( ) { return ( new String [ ] { SUFFIX_OPTION } ) ; } public void setOption ( String option , String value ) { System . out . println ( option + "=" + value ) ; if ( option == null ) { return ; } if ( option . equalsIgnoreCase ( SUFFIX_OPTION ) ) { this . suffix = value ; System . out . println ( "Setting suffix to" + suffix ) ; } } public void trace ( String message ) { if ( disable <= XPriority . TRACE_INT ) return ; if ( XPriority . TRACE . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) callAppenders ( new LoggingEvent ( instanceFQCN , this , XPriority . TRACE , message , null ) ) ; } private static class XFactory implements CategoryFactory { XFactory ( ) { } public Category makeNewCategoryInstance ( String name ) { return new XCategory ( name ) ; } } } 	1	['10', '2', '0', '7', '27', '29', '1', '7', '8', '0.911111111', '145', '0.2', '1', '0.854545455', '0.777777778', '1', '4', '13', '3', '1.4', '1']
package org . apache . log4j . xml ; import java . util . * ; import java . net . URL ; import org . w3c . dom . * ; import java . lang . reflect . Method ; import org . apache . log4j . Category ; import org . apache . log4j . spi . OptionHandler ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . AppenderAttachable ; import org . apache . log4j . spi . Configurator ; import org . apache . log4j . Appender ; import org . apache . log4j . Layout ; import org . apache . log4j . Priority ; import org . apache . log4j . Hierarchy ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . spi . Filter ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . FileWatchdog ; import org . xml . sax . InputSource ; import java . io . FileInputStream ; import java . io . InputStream ; import java . io . IOException ; import java . net . URL ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . FactoryConfigurationError ; public class DOMConfigurator extends BasicConfigurator implements Configurator { static final String CONFIGURATION_TAG = "configuration" ; static final String RENDERER_TAG = "renderer" ; static final String APPENDER_TAG = "appender" ; static final String APPENDER_REF_TAG = "appender-ref" ; static final String PARAM_TAG = "param" ; static final String LAYOUT_TAG = "layout" ; static final String CATEGORY = "category" ; static final String NAME_ATTR = "name" ; static final String CLASS_ATTR = "class" ; static final String VALUE_ATTR = "value" ; static final String ROOT_TAG = "root" ; static final String PRIORITY_TAG = "priority" ; static final String FILTER_TAG = "filter" ; static final String ERROR_HANDLER_TAG = "errorHandler" ; static final String REF_ATTR = "ref" ; static final String ADDITIVITY_ATTR = "additivity" ; static final String SCFO_ATTR = "disableOverride" ; static final String CONFIG_DEBUG_ATTR = "configDebug" ; static final String RENDERING_CLASS_ATTR = "renderingClass" ; static final String RENDERED_CLASS_ATTR = "renderedClass" ; static final String EMPTY_STR = "" ; static final Class [ ] ONE_STRING_PARAM = new Class [ ] { String . class } ; final static String dbfKey = "javax.xml.parsers.DocumentBuilderFactory" ; Hashtable appenderBag ; public DOMConfigurator ( ) { appenderBag = new Hashtable ( ) ; } protected Appender findAppenderByReference ( Element appenderRef ) { String appenderName = appenderRef . getAttribute ( REF_ATTR ) ; Appender appender = ( Appender ) appenderBag . get ( appenderName ) ; if ( appender != null ) { return appender ; } else { Document doc = appenderRef . getOwnerDocument ( ) ; Element element = null ; NodeList list = doc . getElementsByTagName ( "appender" ) ; for ( int t = 0 ; t < list . getLength ( ) ; t ++ ) { Node node = list . item ( t ) ; NamedNodeMap map = node . getAttributes ( ) ; Node attrNode = map . getNamedItem ( "name" ) ; if ( appenderName . equals ( attrNode . getNodeValue ( ) ) ) { element = ( Element ) node ; break ; } } if ( element == null ) { LogLog . error ( "No appender named [" + appenderName + "] could be found." ) ; return null ; } else { appender = parseAppender ( element ) ; appenderBag . put ( appenderName , appender ) ; return appender ; } } } protected Appender parseAppender ( Element appenderElement ) { String className = appenderElement . getAttribute ( CLASS_ATTR ) ; LogLog . debug ( "Class name: [" + className + ']' ) ; try { Object instance = Class . forName ( className ) . newInstance ( ) ; Appender appender = ( Appender ) instance ; appender . setName ( appenderElement . getAttribute ( NAME_ATTR ) ) ; NodeList children = appenderElement . getChildNodes ( ) ; final int length = children . getLength ( ) ; for ( int loop = 0 ; loop < length ; loop ++ ) { Node currentNode = children . item ( loop ) ; if ( currentNode . getNodeType ( ) == Node . ELEMENT_NODE ) { Element currentElement = ( Element ) currentNode ; if ( currentElement . getTagName ( ) . equals ( PARAM_TAG ) ) { if ( appender instanceof OptionHandler ) { parseParameters ( currentElement , ( OptionHandler ) appender ) ; } } else if ( currentElement . getTagName ( ) . equals ( LAYOUT_TAG ) ) { appender . setLayout ( parseLayout ( currentElement ) ) ; } else if ( currentElement . getTagName ( ) . equals ( FILTER_TAG ) ) { parseFilters ( currentElement , appender ) ; } else if ( currentElement . getTagName ( ) . equals ( ERROR_HANDLER_TAG ) ) { parseErrorHandler ( currentElement , appender ) ; } else if ( currentElement . getTagName ( ) . equals ( APPENDER_REF_TAG ) ) { String refName = currentElement . getAttribute ( REF_ATTR ) ; if ( appender instanceof AppenderAttachable ) { AppenderAttachable aa = ( AppenderAttachable ) appender ; LogLog . debug ( "Attaching appender named [" + refName + "] to appender named [" + appender . getName ( ) + "]." ) ; aa . addAppender ( findAppenderByReference ( currentElement ) ) ; } else { LogLog . error ( "Requesting attachment of appender named [" + refName + "] to appender named [" + appender . getName ( ) + "] which does not implement org.apache.log4j.spi.AppenderAttachable." ) ; } } } } if ( appender instanceof OptionHandler ) { ( ( OptionHandler ) appender ) . activateOptions ( ) ; } return appender ; } catch ( Exception oops ) { LogLog . error ( "Could not create an Appender. Reported error follows." , oops ) ; return null ; } } protected void parseErrorHandler ( Element element , Appender appender ) { ErrorHandler eh = ( ErrorHandler ) OptionConverter . instantiateByClassName ( element . getAttribute ( CLASS_ATTR ) , org . apache . log4j . spi . ErrorHandler . class , null ) ; if ( eh != null ) { NodeList children = element . getChildNodes ( ) ; final int length = children . getLength ( ) ; for ( int loop = 0 ; loop < length ; loop ++ ) { Node currentNode = children . item ( loop ) ; if ( currentNode . getNodeType ( ) == Node . ELEMENT_NODE ) { Element currentElement = ( Element ) currentNode ; String tagName = currentElement . getTagName ( ) ; if ( tagName . equals ( PARAM_TAG ) ) { parseParameters ( currentElement , eh ) ; } } } appender . setErrorHandler ( eh ) ; } } protected void parseParameters ( Element elem , OptionHandler oh ) { String name = elem . getAttribute ( NAME_ATTR ) ; String value = elem . getAttribute ( VALUE_ATTR ) ; LogLog . debug ( "Handling parameter \"" + name + "=" + value + '\"' ) ; if ( oh instanceof OptionHandler && value != null ) { oh . setOption ( name , OptionConverter . convertSpecialChars ( value ) ) ; } } protected void parseFilters ( Element element , Appender appender ) { String clazz = element . getAttribute ( CLASS_ATTR ) ; Filter filter = ( Filter ) OptionConverter . instantiateByClassName ( clazz , org . apache . log4j . spi . Filter . class , null ) ; if ( filter != null ) { NodeList children = element . getChildNodes ( ) ; final int length = children . getLength ( ) ; for ( int loop = 0 ; loop < length ; loop ++ ) { Node currentNode = children . item ( loop ) ; if ( currentNode . getNodeType ( ) == Node . ELEMENT_NODE ) { Element currentElement = ( Element ) currentNode ; String tagName = currentElement . getTagName ( ) ; if ( tagName . equals ( PARAM_TAG ) ) { parseParameters ( currentElement , filter ) ; } } } appender . addFilter ( filter ) ; } } protected void parseCategory ( Element categoryElement , Hierarchy hierarchy ) { String catName = categoryElement . getAttribute ( NAME_ATTR ) ; Category cat ; String className = categoryElement . getAttribute ( CLASS_ATTR ) ; if ( EMPTY_STR . equals ( className ) ) { LogLog . debug ( "Retreiving an instance of org.apache.log4j.Category." ) ; cat = hierarchy . getInstance ( catName ) ; } else { LogLog . debug ( "Desired category sub-class: [" + className + ']' ) ; try { Class clazz = Class . forName ( className ) ; Method getInstanceMethod = clazz . getMethod ( "getInstance" , ONE_STRING_PARAM ) ; cat = ( Category ) getInstanceMethod . invoke ( null , new Object [ ] { catName } ) ; } catch ( Exception oops ) { LogLog . error ( "Could not retrieve category [" + catName + "]. Reported error follows." , oops ) ; return ; } } synchronized ( cat ) { cat . setAdditivity ( OptionConverter . toBoolean ( categoryElement . getAttribute ( ADDITIVITY_ATTR ) , true ) ) ; parseChildrenOfCategoryElement ( categoryElement , cat , false ) ; } } protected void parseRoot ( Element rootElement , Hierarchy hierarchy ) { Category root = hierarchy . getRoot ( ) ; synchronized ( root ) { parseChildrenOfCategoryElement ( rootElement , root , true ) ; } } protected void parseChildrenOfCategoryElement ( Element catElement , Category cat , boolean isRoot ) { cat . removeAllAppenders ( ) ; NodeList children = catElement . getChildNodes ( ) ; final int length = children . getLength ( ) ; for ( int loop = 0 ; loop < length ; loop ++ ) { Node currentNode = children . item ( loop ) ; if ( currentNode . getNodeType ( ) == Node . ELEMENT_NODE ) { Element currentElement = ( Element ) currentNode ; String tagName = currentElement . getTagName ( ) ; if ( tagName . equals ( APPENDER_REF_TAG ) ) { Element appenderRef = ( Element ) currentNode ; Appender appender = findAppenderByReference ( appenderRef ) ; String refName = appenderRef . getAttribute ( REF_ATTR ) ; if ( appender != null ) LogLog . debug ( "Adding appender named [" + refName + "] to category [" + cat . getName ( ) + "]." ) ; else LogLog . debug ( "Appender named [" + refName + "] not found." ) ; cat . addAppender ( appender ) ; } else if ( tagName . equals ( PRIORITY_TAG ) ) { parsePriority ( currentElement , cat , isRoot ) ; } else if ( tagName . equals ( PARAM_TAG ) ) { if ( cat instanceof OptionHandler ) { OptionHandler oh = ( OptionHandler ) cat ; parseParameters ( currentElement , oh ) ; oh . activateOptions ( ) ; } } } } } protected Layout parseLayout ( Element layout_element ) { String className = layout_element . getAttribute ( CLASS_ATTR ) ; LogLog . debug ( "Parsing layout of class: \"" + className + "\"" ) ; try { Object instance = Class . forName ( className ) . newInstance ( ) ; Layout layout = ( Layout ) instance ; NodeList params = layout_element . getChildNodes ( ) ; final int length = params . getLength ( ) ; for ( int loop = 0 ; loop < length ; loop ++ ) { Node currentNode = ( Node ) params . item ( loop ) ; if ( currentNode . getNodeType ( ) == Node . ELEMENT_NODE ) { Element currentElement = ( Element ) currentNode ; String tagName = currentElement . getTagName ( ) ; if ( tagName . equals ( PARAM_TAG ) ) { parseParameters ( currentElement , layout ) ; } } } layout . activateOptions ( ) ; return layout ; } catch ( Exception oops ) { LogLog . error ( "Could not create the Layout. Reported error follows." , oops ) ; return null ; } } protected void parserRenderer ( Element element ) { String renderingClass = element . getAttribute ( RENDERING_CLASS_ATTR ) ; String renderedClass = element . getAttribute ( RENDERED_CLASS_ATTR ) ; addRenderer ( renderedClass , renderingClass ) ; } protected void parsePriority ( Element element , Category cat , boolean isRoot ) { String catName = cat . getName ( ) ; if ( isRoot ) { catName = "root" ; } String priStr = element . getAttribute ( VALUE_ATTR ) ; LogLog . debug ( "Priority value for " + catName + " is  [" + priStr + "]." ) ; if ( BasicConfigurator . INHERITED . equals ( priStr ) ) { if ( isRoot ) { LogLog . error ( "Root priority cannot be inherited. Ignoring directive." ) ; } else { cat . setPriority ( null ) ; } } else { String className = element . getAttribute ( CLASS_ATTR ) ; if ( EMPTY_STR . equals ( className ) ) { cat . setPriority ( Priority . toPriority ( priStr ) ) ; } else { LogLog . debug ( "Desired Priority sub-class: [" + className + ']' ) ; try { Class clazz = Class . forName ( className ) ; Method toPriorityMethod = clazz . getMethod ( "toPriority" , ONE_STRING_PARAM ) ; Priority pri = ( Priority ) toPriorityMethod . invoke ( null , new Object [ ] { priStr } ) ; cat . setPriority ( pri ) ; } catch ( Exception oops ) { LogLog . error ( "Could not create priority [" + priStr + "]. Reported error follows." , oops ) ; return ; } } } LogLog . debug ( catName + " priority set to " + cat . getPriority ( ) ) ; } static public void configure ( Element element ) { DOMConfigurator configurator = new DOMConfigurator ( ) ; configurator . parse ( element , Category . getDefaultHierarchy ( ) ) ; } static public void configureAndWatch ( String configFilename ) { configureAndWatch ( configFilename , FileWatchdog . DEFAULT_DELAY ) ; } static public void configureAndWatch ( String configFilename , long delay ) { XMLWatchdog xdog = new XMLWatchdog ( configFilename ) ; xdog . setDelay ( delay ) ; xdog . start ( ) ; } public void doConfigure ( String filename , Hierarchy hierarchy ) { try { doConfigure ( new FileInputStream ( filename ) , hierarchy ) ; } catch ( IOException e ) { LogLog . error ( "Could not open [" + filename + "]." , e ) ; } } public void doConfigure ( URL url , Hierarchy hierarchy ) { try { doConfigure ( url . openStream ( ) , hierarchy ) ; } catch ( IOException e ) { LogLog . error ( "Could not open [" + url + "]." , e ) ; } } public void doConfigure ( InputStream input , Hierarchy hierarchy ) throws FactoryConfigurationError { DocumentBuilderFactory dbf = null ; try { LogLog . debug ( "System property is :" + System . getProperty ( dbfKey ) ) ; dbf = DocumentBuilderFactory . newInstance ( ) ; LogLog . debug ( "Standard DocumentBuilderFactory search succeded." ) ; LogLog . debug ( "DocumentBuilderFactory is: " + dbf . getClass ( ) . getName ( ) ) ; } catch ( FactoryConfigurationError fce ) { Exception e = fce . getException ( ) ; LogLog . debug ( "Could not instantiate a DocumentBuilderFactory." , e ) ; throw fce ; } try { dbf . setValidating ( true ) ; DocumentBuilder docBuilder = dbf . newDocumentBuilder ( ) ; InputSource inputSource = new InputSource ( input ) ; URL dtdURL = DOMConfigurator . class . getResource ( "log4j.dtd" ) ; if ( dtdURL == null ) { LogLog . error ( "Could not find log4j.dtd." ) ; } else { LogLog . debug ( "URL to log4j.dtd is [" + dtdURL . toString ( ) + "]." ) ; inputSource . setSystemId ( dtdURL . toString ( ) ) ; } Document doc = docBuilder . parse ( inputSource ) ; parse ( doc . getDocumentElement ( ) , hierarchy ) ; } catch ( Exception e ) { LogLog . error ( "Could not parse input stream [" + input + "]." , e ) ; } } static public void configure ( String filename ) throws FactoryConfigurationError { new DOMConfigurator ( ) . doConfigure ( filename , Category . getDefaultHierarchy ( ) ) ; } protected void parse ( Element element , Hierarchy hierarchy ) { if ( ! element . getTagName ( ) . equals ( CONFIGURATION_TAG ) ) { LogLog . error ( "DOM element is not a <configuration> element" ) ; return ; } String confDebug = element . getAttribute ( CONFIG_DEBUG_ATTR ) ; LogLog . debug ( "configDebug attribute= \"" + confDebug + "\"." ) ; if ( ! confDebug . equals ( "" ) && ! confDebug . equals ( "null" ) ) { LogLog . setInternalDebugging ( OptionConverter . toBoolean ( confDebug , true ) ) ; } else LogLog . debug ( "Ignoring " + CONFIG_DEBUG_ATTR + " attribute." ) ; String override = element . getAttribute ( SCFO_ATTR ) ; LogLog . debug ( "Disable override=\"" + override + "\"." ) ; if ( ! override . equals ( "" ) && ! override . equals ( "null" ) ) { overrideAsNeeded ( override ) ; } else LogLog . debug ( "Ignoring " + SCFO_ATTR + " attribute." ) ; NodeList children = element . getChildNodes ( ) ; final int length = children . getLength ( ) ; for ( int loop = 0 ; loop < length ; loop ++ ) { Node currentNode = children . item ( loop ) ; if ( currentNode . getNodeType ( ) == Node . ELEMENT_NODE ) { Element currentElement = ( Element ) currentNode ; String tagName = currentElement . getTagName ( ) ; if ( tagName . equals ( CATEGORY ) ) { parseCategory ( currentElement , hierarchy ) ; } else if ( tagName . equals ( ROOT_TAG ) ) { parseRoot ( currentElement , hierarchy ) ; } else if ( tagName . equals ( RENDERER_TAG ) ) { parserRenderer ( currentElement ) ; } } } } } class XMLWatchdog extends FileWatchdog { XMLWatchdog ( String filename ) { super ( filename ) ; } public void doOnChange ( ) { new DOMConfigurator ( ) . doConfigure ( filename , Category . getDefaultHierarchy ( ) ) ; } } 	1	['22', '2', '0', '19', '95', '223', '6', '15', '8', '1.013605442', '1176', '0', '0', '0.375', '0.216450216', '1', '1', '51.18181818', '11', '3.2273', '3']
package org . apache . log4j . spi ; import org . apache . log4j . spi . LoggingEvent ; public abstract class Filter implements OptionHandler { public Filter next ; public static final int DENY = - 1 ; public static final int NEUTRAL = 0 ; public static final int ACCEPT = 1 ; public void activateOptions ( ) { } abstract public int decide ( LoggingEvent event ) ; } 	1	['5', '1', '3', '8', '6', '10', '6', '2', '5', '1.25', '13', '0', '1', '0', '0.466666667', '0', '0', '0.8', '1', '0.8', '1']
package org . apache . log4j . net ; import java . net . InetAddress ; import java . net . Socket ; import java . io . OutputStream ; import java . io . IOException ; import java . io . ObjectOutputStream ; import java . io . ObjectOutputStream ; import java . io . OutputStreamWriter ; import java . io . StringWriter ; import java . io . PrintWriter ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . AppenderSkeleton ; public class SocketAppender extends AppenderSkeleton { InetAddress address ; int port = 4560 ; String hostName ; ObjectOutputStream oos ; int reconnectionDelay = 30000 ; boolean locationInfo = false ; private Connector connector ; int counter = 0 ; private static final int RESET_FREQUENCY = 1 ; public static final String REMOTE_HOST_OPTION = "RemoteHost" ; public static final String PORT_OPTION = "Port" ; public static final String LOCATION_INFO_OPTION = "LocationInfo" ; public static final String RECONNECTION_DELAY_OPTION = "ReconnectionDelay" ; public SocketAppender ( ) { } public SocketAppender ( InetAddress address , int port ) { this . address = address ; this . port = port ; this . hostName = address . getHostName ( ) ; connect ( address , port ) ; } public SocketAppender ( String host , int port ) { this . port = port ; this . hostName = host ; this . address = getAddressByName ( host ) ; connect ( address , port ) ; } public void activateOptions ( ) { connect ( address , port ) ; } public void close ( ) { this . closed = true ; cleanUp ( ) ; } public void cleanUp ( ) { if ( oos != null ) { try { oos . close ( ) ; } catch ( IOException e ) { LogLog . error ( "Could not close oos." , e ) ; } oos = null ; } if ( connector != null ) { connector . interrupt ( ) ; connector = null ; } } void connect ( InetAddress address , int port ) { if ( this . address == null ) return ; try { cleanUp ( ) ; oos = new ObjectOutputStream ( new Socket ( address , port ) . getOutputStream ( ) ) ; } catch ( IOException e ) { LogLog . error ( "Could not connect to remote log4j server at [" + address . getHostName ( ) + "]. We will try again later." , e ) ; fireConnector ( ) ; } } public void append ( LoggingEvent event ) { if ( address == null ) { errorHandler . error ( "No remote host is set for SocketAppedender named \"" + this . name + "\"." ) ; return ; } if ( oos != null ) { try { if ( locationInfo ) { event . setLocationInformation ( ) ; } oos . writeObject ( event ) ; oos . flush ( ) ; if ( ++ counter >= RESET_FREQUENCY ) { counter = 0 ; oos . reset ( ) ; } } catch ( IOException e ) { oos = null ; LogLog . debug ( "Detected problem with connection: " + e ) ; fireConnector ( ) ; } } } void fireConnector ( ) { if ( connector == null ) { LogLog . debug ( "Starting a new connector thread." ) ; connector = new Connector ( ) ; connector . setDaemon ( true ) ; connector . setPriority ( Thread . MIN_PRIORITY ) ; connector . start ( ) ; } } InetAddress getAddressByName ( String host ) { try { return InetAddress . getByName ( host ) ; } catch ( Exception e ) { LogLog . error ( "Could not find address of [" + host + "]." , e ) ; return null ; } } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { REMOTE_HOST_OPTION , PORT_OPTION , LOCATION_INFO_OPTION , RECONNECTION_DELAY_OPTION } ) ; } public boolean requiresLayout ( ) { return false ; } public void setOption ( String option , String value ) { if ( value == null ) return ; super . setOption ( option , value ) ; if ( option . equals ( REMOTE_HOST_OPTION ) ) address = getAddressByName ( value ) ; else if ( option . equals ( PORT_OPTION ) ) port = OptionConverter . toInt ( value , port ) ; else if ( option . equals ( LOCATION_INFO_OPTION ) ) locationInfo = OptionConverter . toBoolean ( value , locationInfo ) ; else if ( option . equals ( RECONNECTION_DELAY_OPTION ) ) reconnectionDelay = OptionConverter . toInt ( value , reconnectionDelay ) ; } class Connector extends Thread { public void run ( ) { Socket socket ; while ( ! isInterrupted ( ) ) { try { sleep ( reconnectionDelay ) ; LogLog . debug ( "Attempting connection to " + address . getHostName ( ) ) ; socket = new Socket ( address , port ) ; synchronized ( this ) { oos = new ObjectOutputStream ( socket . getOutputStream ( ) ) ; connector = null ; break ; } } catch ( InterruptedException e ) { LogLog . debug ( "Connector interrupted. Leaving loop." ) ; return ; } catch ( java . net . ConnectException e ) { LogLog . debug ( "Remote host " + address . getHostName ( ) + " refused connection." ) ; } catch ( IOException e ) { LogLog . debug ( "Could not connect to " + address . getHostName ( ) + ". Exception is " + e ) ; } } } } } 	1	['14', '2', '0', '8', '43', '41', '3', '6', '10', '0.846153846', '359', '0.153846154', '1', '0.620689655', '0.244897959', '2', '3', '23.71428571', '6', '1.6429', '1']
package org . apache . log4j . net ; import java . net . Socket ; import java . net . ServerSocket ; import java . net . InetAddress ; import java . net . MalformedURLException ; import java . io . IOException ; import java . io . File ; import java . util . Hashtable ; import org . apache . log4j . Category ; import org . apache . log4j . Hierarchy ; import org . apache . log4j . Priority ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . spi . RootCategory ; public class SocketServer { static String GENERIC = "generic" ; static String CONFIG_FILE_EXT = ".lcf" ; static Category cat = Category . getInstance ( SocketServer . class ) ; static SocketServer server ; static int port ; Hashtable hierarchyMap ; Hierarchy genericHierarchy ; File dir ; public static void main ( String argv [ ] ) { if ( argv . length == 3 ) init ( argv [ 0 ] , argv [ 1 ] , argv [ 2 ] ) ; else usage ( "Wrong number of arguments." ) ; try { cat . info ( "Listening on port " + port ) ; ServerSocket serverSocket = new ServerSocket ( port ) ; while ( true ) { cat . info ( "Waiting to accept a new client." ) ; Socket socket = serverSocket . accept ( ) ; InetAddress inetAddress = socket . getInetAddress ( ) ; cat . info ( "Connected to client at " + inetAddress ) ; Hierarchy h = ( Hierarchy ) server . hierarchyMap . get ( inetAddress ) ; if ( h == null ) { h = server . configureHierarchy ( inetAddress ) ; } cat . info ( "Starting new socket node." ) ; new Thread ( new SocketNode ( socket , h ) ) . start ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + SocketServer . class . getName ( ) + " port configFile directory" ) ; System . exit ( 1 ) ; } static void init ( String portStr , String configFile , String dirStr ) { try { port = Integer . parseInt ( portStr ) ; } catch ( java . lang . NumberFormatException e ) { e . printStackTrace ( ) ; usage ( "Could not interpret port number [" + portStr + "]." ) ; } PropertyConfigurator . configure ( configFile ) ; File dir = new File ( dirStr ) ; if ( ! dir . isDirectory ( ) ) { usage ( "[" + dirStr + "] is not a directory." ) ; } server = new SocketServer ( dir ) ; } public SocketServer ( File directory ) { this . dir = directory ; hierarchyMap = new Hashtable ( 11 ) ; } Hierarchy configureHierarchy ( InetAddress inetAddress ) { cat . info ( "Locating configuration file for " + inetAddress ) ; String s = inetAddress . toString ( ) ; int i = s . indexOf ( "/" ) ; if ( i == - 1 ) { cat . warn ( "Could not parse the inetAddress [" + inetAddress + "]. Using default hierarchy." ) ; return genericHierarchy ( ) ; } else { String key = s . substring ( 0 , i ) ; File configFile = new File ( dir , key + CONFIG_FILE_EXT ) ; if ( configFile . exists ( ) ) { Hierarchy h = new Hierarchy ( new RootCategory ( Priority . DEBUG ) ) ; hierarchyMap . put ( inetAddress , h ) ; try { new PropertyConfigurator ( ) . doConfigure ( configFile . toURL ( ) , h ) ; } catch ( MalformedURLException e ) { cat . error ( "Could not convert" + configFile + " to a URL." , e ) ; } return h ; } else { cat . warn ( "Could not find config file [" + configFile + "]." ) ; return genericHierarchy ( ) ; } } } Hierarchy genericHierarchy ( ) { if ( genericHierarchy == null ) { File f = new File ( dir , GENERIC + CONFIG_FILE_EXT ) ; if ( f . exists ( ) ) { genericHierarchy = new Hierarchy ( new RootCategory ( Priority . DEBUG ) ) ; try { new PropertyConfigurator ( ) . doConfigure ( f . toURL ( ) , genericHierarchy ) ; } catch ( MalformedURLException e ) { cat . error ( "Could not convert" + f + " to a URL. Reverting to default hierarchy" , e ) ; genericHierarchy = Category . getDefaultHierarchy ( ) ; } } else { cat . warn ( "Could not find config file [" + f + "]. Will use the default hierarchy." ) ; genericHierarchy = Category . getDefaultHierarchy ( ) ; } } return genericHierarchy ; } } 	1	['8', '1', '0', '6', '49', '6', '0', '6', '2', '0.666666667', '389', '0', '3', '0', '0.257142857', '0', '0', '46.5', '3', '1.75', '1']
package org . apache . log4j . helpers ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . AbsoluteTimeDateFormat ; import org . apache . log4j . Layout ; import org . apache . log4j . NDC ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . or . ObjectRenderer ; import org . apache . log4j . or . RendererMap ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; public class PatternParser { private static final char ESCAPE_CHAR = '%' ; private static final int LITERAL_STATE = 0 ; private static final int CONVERTER_STATE = 1 ; private static final int MINUS_STATE = 2 ; private static final int DOT_STATE = 3 ; private static final int MIN_STATE = 4 ; private static final int MAX_STATE = 5 ; static final int FULL_LOCATION_CONVERTER = 1000 ; static final int METHOD_LOCATION_CONVERTER = 1001 ; static final int CLASS_LOCATION_CONVERTER = 1002 ; static final int LINE_LOCATION_CONVERTER = 1003 ; static final int FILE_LOCATION_CONVERTER = 1004 ; static final int RELATIVE_TIME_CONVERTER = 2000 ; static final int THREAD_CONVERTER = 2001 ; static final int PRIORITY_CONVERTER = 2002 ; static final int NDC_CONVERTER = 2003 ; static final int MESSAGE_CONVERTER = 2004 ; int state ; protected StringBuffer currentLiteral = new StringBuffer ( 32 ) ; protected int patternLength ; protected int i ; PatternConverter head ; PatternConverter tail ; protected FormattingInfo formattingInfo = new FormattingInfo ( ) ; protected String pattern ; public PatternParser ( String pattern ) { this . pattern = pattern ; patternLength = pattern . length ( ) ; state = LITERAL_STATE ; } private void addToList ( PatternConverter pc ) { if ( head == null ) { head = tail = pc ; } else { tail . next = pc ; tail = pc ; } } private String extractOption ( ) { if ( ( i < patternLength ) && ( pattern . charAt ( i ) == '{' ) ) { int end = pattern . indexOf ( '}' , i ) ; if ( end > i ) { String r = pattern . substring ( i + 1 , end ) ; i = end + 1 ; return r ; } } return null ; } private int extractPrecisionOption ( ) { String opt = extractOption ( ) ; int r = 0 ; if ( opt != null ) { try { r = Integer . parseInt ( opt ) ; if ( r <= 0 ) { LogLog . error ( "Precision option (" + opt + ") isn't a positive integer." ) ; r = 0 ; } } catch ( NumberFormatException e ) { LogLog . error ( "Category option \"" + opt + "\" not a decimal integer." , e ) ; } } return r ; } public PatternConverter parse ( ) { char c ; i = 0 ; while ( i < patternLength ) { c = pattern . charAt ( i ++ ) ; switch ( state ) { case LITERAL_STATE : if ( i == patternLength ) { currentLiteral . append ( c ) ; continue ; } if ( c == ESCAPE_CHAR ) { switch ( pattern . charAt ( i ) ) { case ESCAPE_CHAR : currentLiteral . append ( c ) ; i ++ ; break ; case 'n' : currentLiteral . append ( Layout . LINE_SEP ) ; i ++ ; break ; default : if ( currentLiteral . length ( ) != 0 ) { addToList ( new LiteralPatternConverter ( currentLiteral . toString ( ) ) ) ; } currentLiteral . setLength ( 0 ) ; currentLiteral . append ( c ) ; state = CONVERTER_STATE ; formattingInfo . reset ( ) ; } } else { currentLiteral . append ( c ) ; } break ; case CONVERTER_STATE : currentLiteral . append ( c ) ; switch ( c ) { case '-' : formattingInfo . leftAlign = true ; break ; case '.' : state = DOT_STATE ; break ; default : if ( c >= '0' && c <= '9' ) { formattingInfo . min = c - '0' ; state = MIN_STATE ; } else finalizeConverter ( c ) ; } break ; case MIN_STATE : currentLiteral . append ( c ) ; if ( c >= '0' && c <= '9' ) formattingInfo . min = formattingInfo . min * 10 + ( c - '0' ) ; else if ( c == '.' ) state = DOT_STATE ; else { finalizeConverter ( c ) ; } break ; case DOT_STATE : currentLiteral . append ( c ) ; if ( c >= '0' && c <= '9' ) { formattingInfo . max = c - '0' ; state = MAX_STATE ; } else { LogLog . error ( "Error occured in position " + i + ".\n Was expecting digit, instead got char \"" + c + "\"." ) ; state = LITERAL_STATE ; } break ; case MAX_STATE : currentLiteral . append ( c ) ; if ( c >= '0' && c <= '9' ) formattingInfo . max = formattingInfo . max * 10 + ( c - '0' ) ; else { finalizeConverter ( c ) ; state = LITERAL_STATE ; } break ; } } if ( currentLiteral . length ( ) != 0 ) { addToList ( new LiteralPatternConverter ( currentLiteral . toString ( ) ) ) ; } return head ; } protected void finalizeConverter ( char c ) { PatternConverter pc = null ; switch ( c ) { case 'c' : pc = new CategoryPatternConverter ( formattingInfo , extractPrecisionOption ( ) ) ; currentLiteral . setLength ( 0 ) ; break ; case 'C' : pc = new ClassNamePatternConverter ( formattingInfo , extractPrecisionOption ( ) ) ; currentLiteral . setLength ( 0 ) ; break ; case 'd' : String dateFormatStr = AbsoluteTimeDateFormat . ISO8601_DATE_FORMAT ; DateFormat df ; String dOpt = extractOption ( ) ; if ( dOpt != null ) dateFormatStr = dOpt ; if ( dateFormatStr . equalsIgnoreCase ( AbsoluteTimeDateFormat . ISO8601_DATE_FORMAT ) ) df = new ISO8601DateFormat ( ) ; else if ( dateFormatStr . equalsIgnoreCase ( AbsoluteTimeDateFormat . ABS_TIME_DATE_FORMAT ) ) df = new AbsoluteTimeDateFormat ( ) ; else if ( dateFormatStr . equalsIgnoreCase ( AbsoluteTimeDateFormat . DATE_AND_TIME_DATE_FORMAT ) ) df = new DateTimeDateFormat ( ) ; else { try { df = new SimpleDateFormat ( dateFormatStr ) ; } catch ( IllegalArgumentException e ) { LogLog . error ( "Could not instantiate SimpleDateFormat with " + dateFormatStr , e ) ; df = ( DateFormat ) OptionConverter . instantiateByClassName ( "org.apache.log4j.helpers.ISO8601DateFormat" , DateFormat . class , null ) ; } } pc = new DatePatternConverter ( formattingInfo , df ) ; currentLiteral . setLength ( 0 ) ; break ; case 'F' : pc = new LocationPatternConverter ( formattingInfo , FILE_LOCATION_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'l' : pc = new LocationPatternConverter ( formattingInfo , FULL_LOCATION_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'L' : pc = new LocationPatternConverter ( formattingInfo , LINE_LOCATION_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'm' : pc = new BasicPatternConverter ( formattingInfo , MESSAGE_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'M' : pc = new LocationPatternConverter ( formattingInfo , METHOD_LOCATION_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'p' : pc = new BasicPatternConverter ( formattingInfo , PRIORITY_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'r' : pc = new BasicPatternConverter ( formattingInfo , RELATIVE_TIME_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 't' : pc = new BasicPatternConverter ( formattingInfo , THREAD_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'x' : pc = new BasicPatternConverter ( formattingInfo , NDC_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; default : LogLog . error ( "Unexpected char " + c + " at position " + i ) ; pc = new LiteralPatternConverter ( currentLiteral . toString ( ) ) ; currentLiteral . setLength ( 0 ) ; } addConverter ( pc ) ; } protected void addConverter ( PatternConverter pc ) { currentLiteral . setLength ( 0 ) ; addToList ( pc ) ; state = LITERAL_STATE ; formattingInfo . reset ( ) ; } private static class BasicPatternConverter extends PatternConverter { int type ; BasicPatternConverter ( FormattingInfo formattingInfo , int type ) { super ( formattingInfo ) ; this . type = type ; } public String convert ( LoggingEvent event ) { switch ( type ) { case RELATIVE_TIME_CONVERTER : return ( Long . toString ( event . timeStamp - LoggingEvent . getStartTime ( ) ) ) ; case THREAD_CONVERTER : return event . getThreadName ( ) ; case PRIORITY_CONVERTER : return event . priority . toString ( ) ; case NDC_CONVERTER : return event . getNDC ( ) ; case MESSAGE_CONVERTER : { return event . message ; } default : return null ; } } } private static class LiteralPatternConverter extends PatternConverter { private String literal ; LiteralPatternConverter ( String value ) { literal = value ; } public final void format ( StringBuffer sbuf , LoggingEvent event ) { sbuf . append ( literal ) ; } public String convert ( LoggingEvent event ) { return literal ; } } private static class DatePatternConverter extends PatternConverter { private DateFormat df ; private Date date ; DatePatternConverter ( FormattingInfo formattingInfo , DateFormat df ) { super ( formattingInfo ) ; date = new Date ( ) ; this . df = df ; } public String convert ( LoggingEvent event ) { date . setTime ( System . currentTimeMillis ( ) ) ; return df . format ( date ) ; } } private class LocationPatternConverter extends PatternConverter { int type ; LocationPatternConverter ( FormattingInfo formattingInfo , int type ) { super ( formattingInfo ) ; this . type = type ; } public String convert ( LoggingEvent event ) { event . setLocationInformation ( ) ; switch ( type ) { case FULL_LOCATION_CONVERTER : return event . locationInfo . fullInfo ; case METHOD_LOCATION_CONVERTER : return event . locationInfo . getMethodName ( ) ; case LINE_LOCATION_CONVERTER : return event . locationInfo . getLineNumber ( ) ; case FILE_LOCATION_CONVERTER : return event . locationInfo . getFileName ( ) ; default : return null ; } } } private static abstract class NamedPatternConverter extends PatternConverter { int precision ; NamedPatternConverter ( FormattingInfo formattingInfo , int precision ) { super ( formattingInfo ) ; this . precision = precision ; } abstract String getFullyQualifiedName ( LoggingEvent event ) ; public String convert ( LoggingEvent event ) { String n = getFullyQualifiedName ( event ) ; if ( precision <= 0 ) return n ; else { int len = n . length ( ) ; int end = len - 1 ; for ( int i = precision ; i > 0 ; i -- ) { end = n . lastIndexOf ( '.' , end - 1 ) ; if ( end == - 1 ) return n ; } return n . substring ( end + 1 , len ) ; } } } private class ClassNamePatternConverter extends NamedPatternConverter { ClassNamePatternConverter ( FormattingInfo formattingInfo , int precision ) { super ( formattingInfo , precision ) ; } String getFullyQualifiedName ( LoggingEvent event ) { event . setLocationInformation ( ) ; return event . locationInfo . getClassName ( ) ; } } private class CategoryPatternConverter extends NamedPatternConverter { CategoryPatternConverter ( FormattingInfo formattingInfo , int precision ) { super ( formattingInfo , precision ) ; } String getFullyQualifiedName ( LoggingEvent event ) { return event . categoryName ; } } } 	1	['8', '1', '0', '15', '41', '8', '4', '14', '2', '0.956043956', '691', '0.461538462', '3', '0', '0.375', '0', '0', '82.125', '21', '6.25', '1']
package org . apache . log4j . performance ; import org . apache . log4j . Category ; import org . apache . log4j . Layout ; import org . apache . log4j . xml . DOMConfigurator ; import org . apache . log4j . Appender ; import org . apache . log4j . net . SyslogAppender ; import org . apache . log4j . net . SocketAppender ; import org . apache . log4j . FileAppender ; import org . apache . log4j . Priority ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . NDC ; import org . apache . log4j . performance . NOPWriter ; import java . util . Enumeration ; public class Logging { static int runLength ; static int delay = - 1 ; static int burstLen = 100 ; static int DELAY_MULT = 1000 / burstLen ; static Category cat = Category . getInstance ( "A0123456789.B0123456789.C0123456789" ) ; static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java org.apache.log4j.test.Logging confFile runLength delay burstLen\n" + "        confFile is a configuration file and\n" + "        runLength (integer) is the length of test loop.\n" + "        delay is the time in millisecs to wait every bustLen log requests." ) ; System . exit ( 1 ) ; } public static void main ( String argv [ ] ) { if ( argv . length == 2 ) init ( argv [ 0 ] , argv [ 1 ] , null , null ) ; else if ( argv . length == 4 ) init ( argv [ 0 ] , argv [ 1 ] , argv [ 2 ] , argv [ 3 ] ) ; else Usage ( "Wrong number of arguments." ) ; NDC . push ( "some context" ) ; double delta ; String msg = "ABCDEGHIJKLMNOPQRSTUVWXYZabcdeghijklmnopqrstuvwxyz1234567890" ; if ( delay <= 0 ) delta = NoDelayLoop ( cat , msg ) ; else delta = DelayedLoop ( cat , msg ) ; System . out . print ( ( int ) delta ) ; Category . getRoot ( ) . removeAllAppenders ( ) ; System . gc ( ) ; System . gc ( ) ; } static void init ( String configFile , String runLengthStr , String delayStr , String burstLenStr ) { try { runLength = Integer . parseInt ( runLengthStr ) ; if ( delayStr != null ) { delay = Integer . parseInt ( delayStr ) ; } if ( delayStr != null ) { burstLen = Integer . parseInt ( burstLenStr ) ; DELAY_MULT = 1000 / burstLen ; } } catch ( java . lang . NumberFormatException e ) { e . printStackTrace ( ) ; } DOMConfigurator . configure ( configFile ) ; } static double NoDelayLoop ( Category category , String msg ) { long before = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { category . info ( msg ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / runLength ; } static double DelayedLoop ( Category category , String msg ) { long before = System . currentTimeMillis ( ) ; int j = 0 ; Thread currentThread = Thread . currentThread ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { category . info ( msg ) ; if ( j ++ == burstLen ) { j = 0 ; try { currentThread . sleep ( delay ) ; } catch ( Exception e ) { } } } double actualTime = ( ( System . currentTimeMillis ( ) - before ) * 1000.0 / runLength ) ; System . out . println ( "actual time: " + actualTime ) ; return ( actualTime - delay * DELAY_MULT ) ; } } 	1	['7', '1', '0', '3', '27', '5', '0', '3', '2', '0.566666667', '196', '0', '1', '0', '0.333333333', '0', '0', '26.28571429', '4', '1.7143', '1']
package org . apache . log4j . helpers ; import java . util . Properties ; import java . net . URL ; import org . apache . log4j . Category ; import org . apache . log4j . spi . Configurator ; import org . apache . log4j . xml . DOMConfigurator ; import org . apache . log4j . PropertyConfigurator ; public class OptionConverter { static String DELIM_START = "${" ; static char DELIM_STOP = '}' ; static int DELIM_START_LEN = 2 ; static int DELIM_STOP_LEN = 1 ; static StringBuffer sbuf = new StringBuffer ( ) ; private OptionConverter ( ) { } public static String [ ] concatanateArrays ( String [ ] l , String [ ] r ) { int len = l . length + r . length ; String [ ] a = new String [ len ] ; System . arraycopy ( l , 0 , a , 0 , l . length ) ; System . arraycopy ( r , 0 , a , l . length , r . length ) ; return a ; } public static String convertSpecialChars ( String s ) { char c ; int len = s . length ( ) ; StringBuffer sbuf = new StringBuffer ( len ) ; int i = 0 ; while ( i < len ) { c = s . charAt ( i ++ ) ; if ( c == '\\' ) { c = s . charAt ( i ++ ) ; if ( c == 'n' ) c = '\n' ; else if ( c == 'r' ) c = '\r' ; else if ( c == 't' ) c = '\t' ; else if ( c == 'f' ) c = '\f' ; else if ( c == '\b' ) c = '\b' ; else if ( c == '\"' ) c = '\"' ; else if ( c == '\'' ) c = '\'' ; else if ( c == '\\' ) c = '\\' ; } sbuf . append ( c ) ; } return sbuf . toString ( ) ; } public static Object instantiateByKey ( Properties props , String key , Class superClass , Object defaultValue ) { String className = props . getProperty ( key ) ; if ( className == null ) { LogLog . error ( "Could not find value for key " + key ) ; return defaultValue ; } return OptionConverter . instantiateByClassName ( className . trim ( ) , superClass , defaultValue ) ; } public static boolean toBoolean ( String value , boolean dEfault ) { if ( value == null ) return dEfault ; String trimmedVal = value . trim ( ) ; if ( "true" . equalsIgnoreCase ( trimmedVal ) ) return true ; if ( "false" . equalsIgnoreCase ( trimmedVal ) ) return false ; return dEfault ; } public static int toInt ( String value , int dEfault ) { if ( value != null ) { String s = value . trim ( ) ; try { return Integer . valueOf ( s ) . intValue ( ) ; } catch ( NumberFormatException e ) { LogLog . error ( "[" + s + "] is not in proper int form." ) ; e . printStackTrace ( ) ; } } return dEfault ; } public static long toFileSize ( String value , long dEfault ) { if ( value == null ) return dEfault ; String s = value . trim ( ) . toUpperCase ( ) ; long multiplier = 1 ; int index ; if ( ( index = s . indexOf ( "KB" ) ) != - 1 ) { multiplier = 1024 ; s = s . substring ( 0 , index ) ; } else if ( ( index = s . indexOf ( "MB" ) ) != - 1 ) { multiplier = 1024 * 1024 ; s = s . substring ( 0 , index ) ; } else if ( ( index = s . indexOf ( "GB" ) ) != - 1 ) { multiplier = 1024 * 1024 * 1024 ; s = s . substring ( 0 , index ) ; } if ( s != null ) { try { return Long . valueOf ( s ) . longValue ( ) * multiplier ; } catch ( NumberFormatException e ) { LogLog . error ( "[" + s + "] is not in proper int form." ) ; LogLog . error ( "[" + value + "] not in expected format." , e ) ; } } return dEfault ; } public static String findAndSubst ( String key , Properties props ) { String value = props . getProperty ( key ) ; if ( value == null ) return null ; try { return substVars ( value , props ) ; } catch ( IllegalArgumentException e ) { LogLog . error ( "Bad option value [" + value + "]." , e ) ; return value ; } } public static Object instantiateByClassName ( String className , Class superClass , Object defaultValue ) { if ( className != null ) { try { Class classObj = Class . forName ( className ) ; if ( ! superClass . isAssignableFrom ( classObj ) ) LogLog . error ( "A \"" + className + "\" object is not assignable to a \"" + superClass . getName ( ) + "\" object." ) ; return classObj . newInstance ( ) ; } catch ( Exception e ) { LogLog . error ( "Could not instantiate class [" + className + "]." , e ) ; } } return defaultValue ; } public static String substVars ( String val , Properties props ) throws IllegalArgumentException { sbuf . setLength ( 0 ) ; int i = 0 ; int j , k ; while ( true ) { j = val . indexOf ( DELIM_START , i ) ; if ( j == - 1 ) { if ( i == 0 ) return val ; else { sbuf . append ( val . substring ( i , val . length ( ) ) ) ; return sbuf . toString ( ) ; } } else { sbuf . append ( val . substring ( i , j ) ) ; k = val . indexOf ( DELIM_STOP , j ) ; if ( k == - 1 ) { throw new IllegalArgumentException ( '"' + val + "\" has no closing brace. Opening brace at position " + j + '.' ) ; } else { j += DELIM_START_LEN ; String key = val . substring ( j , k ) ; String replacement = System . getProperty ( key ) ; if ( replacement == null && props != null ) { replacement = props . getProperty ( key ) ; } if ( replacement != null ) sbuf . append ( replacement ) ; i = k + DELIM_STOP_LEN ; } } } } static public void selectAndConfigure ( URL url ) { String clazz = url . getRef ( ) ; Configurator configurator = null ; if ( clazz != null ) { LogLog . debug ( "Preferred configurator class: " + clazz ) ; configurator = ( Configurator ) instantiateByClassName ( clazz , Configurator . class , null ) ; if ( configurator == null ) { LogLog . error ( "Could not instantiate configurator [" + clazz + "]." ) ; return ; } } else { String filename = url . getFile ( ) ; if ( filename != null && filename . endsWith ( ".xml" ) ) { configurator = new DOMConfigurator ( ) ; } else { configurator = new PropertyConfigurator ( ) ; } } configurator . doConfigure ( url , Category . defaultHierarchy ) ; } } 	1	['13', '1', '0', '22', '54', '76', '20', '6', '10', '0.861111111', '537', '0', '0', '0', '0.183333333', '0', '0', '39.84615385', '11', '3', '3']
package org . apache . log4j . helpers ; import org . apache . log4j . spi . LoggingEvent ; public class CyclicBuffer { LoggingEvent [ ] ea ; int first ; int last ; int numElems ; int maxSize ; public CyclicBuffer ( int maxSize ) throws IllegalArgumentException { if ( maxSize < 1 ) { throw new IllegalArgumentException ( "The maxSize argument (" + maxSize + ") is not a positive integer." ) ; } this . maxSize = maxSize ; ea = new LoggingEvent [ maxSize ] ; first = 0 ; last = 0 ; numElems = 0 ; } public void add ( LoggingEvent event ) { ea [ last ] = event ; if ( ++ last == maxSize ) last = 0 ; if ( numElems < maxSize ) numElems ++ ; else if ( ++ first == maxSize ) first = 0 ; } public LoggingEvent get ( int i ) { if ( i < 0 || i >= numElems ) return null ; return ea [ ( first + i ) % maxSize ] ; } public int getMaxSize ( ) { return maxSize ; } public LoggingEvent get ( ) { LoggingEvent r = null ; if ( numElems > 0 ) { numElems -- ; r = ea [ first ] ; ea [ first ] = null ; if ( ++ first == maxSize ) first = 0 ; } return r ; } public int length ( ) { return numElems ; } public void resize ( int newSize ) { if ( newSize < 0 ) { throw new IllegalArgumentException ( "Negative array size [" + newSize + "] not allowed." ) ; } if ( newSize == numElems ) return ; LoggingEvent [ ] temp = new LoggingEvent [ newSize ] ; int loopLen = newSize < numElems ? newSize : numElems ; for ( int i = 0 ; i < loopLen ; i ++ ) { temp [ i ] = ea [ first ] ; ea [ first ] = null ; if ( ++ first == numElems ) first = 0 ; } ea = temp ; first = 0 ; numElems = loopLen ; maxSize = newSize ; } } 	1	['7', '1', '0', '4', '13', '0', '3', '1', '7', '0.366666667', '236', '0', '1', '0', '0.523809524', '0', '0', '32', '6', '2.5714', '1']
package org . apache . log4j ; import org . apache . log4j . Category ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . BoundedFIFO ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . spi . AppenderAttachable ; import org . apache . log4j . helpers . AppenderAttachableImpl ; import org . apache . log4j . helpers . LogLog ; import java . util . Enumeration ; public class AsyncAppender extends AppenderSkeleton implements AppenderAttachable { public static final String LOCATION_INFO_OPTION = "LocationInfo" ; static final int BUFFER_SIZE = 128 ; BoundedFIFO bf = new BoundedFIFO ( BUFFER_SIZE ) ; AppenderAttachableImpl aai ; Dispatcher dispatcher ; boolean locationInfo = false ; public AsyncAppender ( ) { aai = new AppenderAttachableImpl ( ) ; dispatcher = new Dispatcher ( bf , aai ) ; dispatcher . start ( ) ; } synchronized public void addAppender ( Appender newAppender ) { aai . addAppender ( newAppender ) ; } public void append ( LoggingEvent event ) { event . getNDC ( ) ; event . getThreadName ( ) ; if ( locationInfo ) { event . setLocationInformation ( ) ; } synchronized ( bf ) { if ( bf . isFull ( ) ) { try { bf . wait ( ) ; } catch ( InterruptedException e ) { LogLog . error ( "AsyncAppender cannot be interrupted." , e ) ; } } bf . put ( event ) ; if ( bf . wasEmpty ( ) ) { bf . notify ( ) ; } } } public void close ( ) { closed = true ; dispatcher . interrupt ( ) ; try { dispatcher . join ( ) ; } catch ( InterruptedException e ) { LogLog . error ( "Got an InterruptedException while waiting for the " + "dispatcher to finish." , e ) ; } dispatcher = null ; bf = null ; } public Enumeration getAllAppenders ( ) { return aai . getAllAppenders ( ) ; } public Appender getAppender ( String name ) { return aai . getAppender ( name ) ; } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { LOCATION_INFO_OPTION } ) ; } public boolean requiresLayout ( ) { return false ; } synchronized public void removeAllAppenders ( ) { aai . removeAllAppenders ( ) ; } synchronized public void removeAppender ( Appender appender ) { aai . removeAppender ( appender ) ; } synchronized public void removeAppender ( String name ) { aai . removeAppender ( name ) ; } public void setOption ( String option , String value ) { if ( value == null ) return ; super . setOption ( option , value ) ; if ( option . equals ( LOCATION_INFO_OPTION ) ) locationInfo = OptionConverter . toBoolean ( value , locationInfo ) ; } } class Dispatcher extends Thread { BoundedFIFO bf ; AppenderAttachableImpl aai ; Dispatcher ( BoundedFIFO bf , AppenderAttachableImpl aai ) { this . bf = bf ; this . aai = aai ; this . setPriority ( Thread . MIN_PRIORITY ) ; } public void run ( ) { LoggingEvent event ; while ( true ) { synchronized ( bf ) { if ( bf . length ( ) == 0 ) { if ( interrupted ( ) ) { return ; } try { bf . wait ( ) ; } catch ( InterruptedException e ) { break ; } } event = bf . get ( ) ; if ( bf . wasFull ( ) ) { bf . notify ( ) ; } } if ( aai != null ) aai . appendLoopOnAppenders ( event ) ; } } } 	1	['12', '2', '0', '9', '39', '14', '0', '9', '12', '0.863636364', '174', '0', '3', '0.620689655', '0.375', '2', '3', '13', '4', '1.3333', '5']
package org . apache . log4j . varia ; import org . apache . log4j . Priority ; import org . apache . log4j . spi . Filter ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . OptionConverter ; public class PriorityMatchFilter extends Filter { public static final String PRIORITY_TO_MATCH_OPTION = "PriorityToMatch" ; public static final String ACCEPT_ON_MATCH_OPTION = "AcceptOnMatch" ; boolean acceptOnMatch = true ; Priority priorityToMatch ; public int decide ( LoggingEvent event ) { if ( this . priorityToMatch == null ) { return Filter . NEUTRAL ; } boolean matchOccured = false ; if ( this . priorityToMatch == event . priority ) { matchOccured = true ; } if ( this . acceptOnMatch ^ matchOccured ) { return Filter . DENY ; } else { return Filter . ACCEPT ; } } public String [ ] getOptionStrings ( ) { return new String [ ] { PRIORITY_TO_MATCH_OPTION , ACCEPT_ON_MATCH_OPTION } ; } public void setOption ( String key , String value ) { if ( key . equalsIgnoreCase ( PRIORITY_TO_MATCH_OPTION ) ) { priorityToMatch = Priority . toPriority ( value , null ) ; } else if ( key . equalsIgnoreCase ( ACCEPT_ON_MATCH_OPTION ) ) { acceptOnMatch = OptionConverter . toBoolean ( value , acceptOnMatch ) ; } } } 	1	['4', '2', '0', '4', '8', '0', '0', '4', '4', '0.916666667', '69', '0', '1', '0.571428571', '0.5', '0', '0', '15.25', '4', '2', '1']
package org . apache . log4j ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . Layout ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . NDC ; import org . apache . log4j . helpers . PatternParser ; import org . apache . log4j . helpers . PatternConverter ; import org . apache . log4j . helpers . OptionConverter ; import java . io . PrintWriter ; import java . io . StringWriter ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . TimeZone ; import java . util . Vector ; import java . text . FieldPosition ; public class PatternLayout extends Layout { final static public String CONVERSION_PATTERN_OPTION = "ConversionPattern" ; public final static String DEFAULT_CONVERSION_PATTERN = "%m\n" ; public final static String TTCC_CONVERSION_PATTERN = "%r [%t] %p %c %x - %m%n" ; protected final int BUF_SIZE = 256 ; protected final int MAX_CAPACITY = 1024 ; private StringBuffer sbuf = new StringBuffer ( BUF_SIZE ) ; private PatternConverter head ; private String timezone ; public PatternLayout ( ) { this ( DEFAULT_CONVERSION_PATTERN ) ; } public PatternLayout ( String pattern ) { head = createPatternParser ( ( pattern == null ) ? DEFAULT_CONVERSION_PATTERN : pattern ) . parse ( ) ; } public void activateOptions ( ) { } protected PatternParser createPatternParser ( String pattern ) { return new PatternParser ( pattern ) ; } public String format ( LoggingEvent event ) { if ( sbuf . capacity ( ) > MAX_CAPACITY ) { sbuf = new StringBuffer ( BUF_SIZE ) ; } else { sbuf . setLength ( 0 ) ; } PatternConverter c = head ; while ( c != null ) { c . format ( sbuf , event ) ; c = c . next ; } return sbuf . toString ( ) ; } public String [ ] getOptionStrings ( ) { return new String [ ] { CONVERSION_PATTERN_OPTION } ; } public boolean ignoresThrowable ( ) { return true ; } public void setConversionPattern ( String conversionPattern ) { setOption ( CONVERSION_PATTERN_OPTION , conversionPattern ) ; } public void setOption ( String option , String value ) { if ( value == null ) return ; if ( option . equalsIgnoreCase ( CONVERSION_PATTERN_OPTION ) ) { head = createPatternParser ( value ) . parse ( ) ; } } } 	1	['9', '2', '0', '13', '18', '30', '9', '4', '8', '0.9375', '114', '0.625', '1', '0.533333333', '0.518518519', '0', '0', '10.77777778', '3', '1.2222', '1']
package org . apache . log4j . helpers ; import java . io . File ; import org . apache . log4j . helpers . LogLog ; public abstract class FileWatchdog extends Thread { static final public long DEFAULT_DELAY = 60000 ; protected String filename ; protected long delay = DEFAULT_DELAY ; File file ; long lastModif = 0 ; boolean warnedAlready = false ; protected FileWatchdog ( String filename ) { this . filename = filename ; file = new File ( filename ) ; setDaemon ( true ) ; checkAndConfigure ( ) ; } public void setDelay ( long delay ) { this . delay = delay ; } abstract protected void doOnChange ( ) ; protected void checkAndConfigure ( ) { if ( file . exists ( ) ) { long l = file . lastModified ( ) ; if ( l > lastModif ) { lastModif = l ; doOnChange ( ) ; warnedAlready = false ; } } else { if ( ! warnedAlready ) { LogLog . debug ( "[" + filename + "] does not exist." ) ; warnedAlready = true ; } } } public void run ( ) { while ( ! interrupted ( ) ) { try { Thread . currentThread ( ) . sleep ( delay ) ; } catch ( InterruptedException e ) { } checkAndConfigure ( ) ; } } } 	1	['5', '2', '2', '5', '17', '2', '4', '1', '2', '0.625', '95', '0.333333333', '0', '0.938461538', '0.466666667', '1', '1', '16.8', '3', '1.4', '2']
package org . apache . log4j ; import java . util . Hashtable ; import java . util . Enumeration ; import org . apache . log4j . spi . RootCategory ; import org . apache . log4j . spi . CategoryFactory ; import org . apache . log4j . or . RendererMap ; import org . apache . log4j . or . ObjectRenderer ; public class Hierarchy { static private CategoryFactory defaultFactory = new DefaultCategoryFactory ( ) ; Hashtable ht ; Category root ; RendererMap rendererMap ; public Hierarchy ( Category root ) { ht = new Hashtable ( ) ; this . root = root ; this . root . myContext = this ; rendererMap = new RendererMap ( ) ; } public void addRenderer ( Class classToRender , ObjectRenderer or ) { rendererMap . put ( classToRender , or ) ; } public void clear ( ) { ht . clear ( ) ; } public Category exists ( String name ) { Object o = ht . get ( new CategoryKey ( name ) ) ; if ( o instanceof Category ) { return ( Category ) o ; } else { return null ; } } public Category getInstance ( String name ) { return getInstance ( name , defaultFactory ) ; } public Category getInstance ( String name , CategoryFactory factory ) { CategoryKey key = new CategoryKey ( name ) ; Category category ; synchronized ( ht ) { Object o = ht . get ( key ) ; if ( o == null ) { category = factory . makeNewCategoryInstance ( name ) ; category . setHierarchy ( this ) ; ht . put ( key , category ) ; updateParents ( category ) ; return category ; } else if ( o instanceof Category ) { return ( Category ) o ; } else if ( o instanceof ProvisionNode ) { category = factory . makeNewCategoryInstance ( name ) ; ht . put ( key , category ) ; updateChildren ( ( ProvisionNode ) o , category ) ; updateParents ( category ) ; return category ; } else { return null ; } } } public RendererMap getRendererMap ( ) { return rendererMap ; } public Category getRoot ( ) { return root ; } final private void updateParents ( Category cat ) { String name = cat . name ; int length = name . length ( ) ; boolean parentFound = false ; for ( int i = name . lastIndexOf ( '.' , length - 1 ) ; i >= 0 ; i = name . lastIndexOf ( '.' , i - 1 ) ) { String substr = name . substring ( 0 , i ) ; CategoryKey key = new CategoryKey ( substr ) ; Object o = ht . get ( key ) ; if ( o == null ) { ProvisionNode pn = new ProvisionNode ( cat ) ; ht . put ( key , pn ) ; } else if ( o instanceof Category ) { parentFound = true ; cat . parent = ( Category ) o ; break ; } else if ( o instanceof ProvisionNode ) { ( ( ProvisionNode ) o ) . addElement ( cat ) ; } else { Exception e = new IllegalStateException ( "unexpected object type " + o . getClass ( ) + " in ht." ) ; e . printStackTrace ( ) ; } } if ( ! parentFound ) cat . parent = root ; } final private void updateChildren ( ProvisionNode pn , Category cat ) { final int last = pn . size ( ) ; childLoop : for ( int i = 0 ; i < last ; i ++ ) { Category c = ( Category ) pn . elementAt ( i ) ; if ( c . parent != null && c . parent . name . startsWith ( cat . name ) ) { continue childLoop ; } while ( c . parent != null && c . parent . name . startsWith ( cat . name ) ) { c = c . parent ; } cat . parent = c . parent ; c . parent = cat ; } } public void shutdown ( ) { Category root = getRoot ( ) ; root . closeNestedAppenders ( ) ; synchronized ( ht ) { Enumeration cats = Category . getCurrentCategories ( ) ; while ( cats . hasMoreElements ( ) ) { Category c = ( Category ) cats . nextElement ( ) ; c . closeNestedAppenders ( ) ; } root . removeAllAppenders ( ) ; cats = Category . getCurrentCategories ( ) ; while ( cats . hasMoreElements ( ) ) { Category c = ( Category ) cats . nextElement ( ) ; c . removeAllAppenders ( ) ; } } } } 	1	['12', '1', '0', '21', '43', '24', '15', '7', '9', '0.704545455', '346', '0.25', '3', '0', '0.272727273', '0', '0', '27.5', '6', '2.1667', '2']
package org . apache . log4j . test ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . Category ; import org . apache . log4j . NDC ; import org . apache . log4j . Priority ; import java . io . IOException ; import java . util . Enumeration ; public class Shallow { static Category cat = Category . getInstance ( Shallow . class ) ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) init ( argv [ 0 ] ) ; else usage ( "Wrong number of arguments." ) ; test ( ) ; } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + Shallow . class . getName ( ) + "configFile" ) ; System . exit ( 1 ) ; } static void init ( String configFile ) { PropertyConfigurator . configure ( configFile ) ; } static void test ( ) { int i = - 1 ; NDC . push ( "NDC" ) ; Category root = Category . getRoot ( ) ; cat . debug ( "Message " + ++ i ) ; root . debug ( "Message " + i ) ; cat . info ( "Message " + ++ i ) ; root . info ( "Message " + i ) ; cat . warn ( "Message " + ++ i ) ; root . warn ( "Message " + i ) ; cat . error ( "Message " + ++ i ) ; root . error ( "Message " + i ) ; cat . log ( Priority . FATAL , "Message " + ++ i ) ; root . log ( Priority . FATAL , "Message " + i ) ; Exception e = new Exception ( "Just testing" ) ; cat . debug ( "Message " + ++ i , e ) ; root . debug ( "Message " + i , e ) ; cat . info ( "Message " + ++ i , e ) ; root . info ( "Message " + i , e ) ; cat . warn ( "Message " + ++ i , e ) ; root . warn ( "Message " + i , e ) ; cat . error ( "Message " + ++ i , e ) ; root . error ( "Message " + i , e ) ; cat . log ( Priority . FATAL , "Message " + ++ i , e ) ; root . log ( Priority . FATAL , "Message " + i , e ) ; Category . shutdown ( ) ; System . gc ( ) ; } static void delay ( int amount ) { try { Thread . currentThread ( ) . sleep ( amount ) ; } catch ( Exception e ) { } } } 	1	['8', '1', '0', '4', '38', '24', '0', '4', '2', '0.714285714', '322', '0', '1', '0', '0.214285714', '0', '0', '39', '2', '1', '1']
