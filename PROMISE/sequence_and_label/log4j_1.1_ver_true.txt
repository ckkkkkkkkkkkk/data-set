package org . apache . log4j . net . test ; import org . apache . log4j . Category ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . Appender ; import org . apache . log4j . net . SocketAppender ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; import java . io . IOException ; import java . io . InputStreamReader ; public class SocketMin { static Category cat = Category . getInstance ( SyslogMin . class . getName ( ) ) ; static SocketAppender s ; public static void main ( String argv [ ] ) { if ( argv . length == 3 ) init ( argv [ 0 ] , argv [ 1 ] ) ; else usage ( "Wrong number of arguments." ) ; NDC . push ( "some context" ) ; if ( argv [ 2 ] . equals ( "true" ) ) loop ( ) ; else test ( ) ; s . close ( ) ; } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + SocketMin . class + " host port true|false" ) ; System . exit ( 1 ) ; } static void init ( String host , String portStr ) { Category root = Category . getRoot ( ) ; BasicConfigurator . configure ( ) ; try { int port = Integer . parseInt ( portStr ) ; cat . info ( "Creating socket appender (" + host + "," + port + ")." ) ; s = new SocketAppender ( host , port ) ; s . setName ( "S" ) ; root . addAppender ( s ) ; } catch ( java . lang . NumberFormatException e ) { e . printStackTrace ( ) ; usage ( "Could not interpret port number [" + portStr + "]." ) ; } catch ( Exception e ) { System . err . println ( "Could not start!" ) ; e . printStackTrace ( ) ; System . exit ( 1 ) ; } } static void loop ( ) { Category root = Category . getRoot ( ) ; InputStreamReader in = new InputStreamReader ( System . in ) ; System . out . println ( "Type 'q' to quit" ) ; int i ; int k = 0 ; while ( true ) { cat . debug ( "Message " + k ++ ) ; cat . info ( "Message " + k ++ ) ; cat . warn ( "Message " + k ++ ) ; cat . error ( "Message " + k ++ , new Exception ( "Just testing" ) ) ; try { i = in . read ( ) ; } catch ( Exception e ) { return ; } if ( i == - 1 ) break ; if ( i == 'q' ) break ; if ( i == 'r' ) { System . out . println ( "Removing appender S" ) ; root . removeAppender ( "S" ) ; } } } static void test ( ) { int i = 0 ; cat . debug ( "Message " + i ++ ) ; cat . info ( "Message " + i ++ ) ; cat . warn ( "Message " + i ++ ) ; cat . error ( "Message " + i ++ ) ; cat . log ( Priority . FATAL , "Message " + i ++ ) ; cat . debug ( "Message " + i ++ , new Exception ( "Just testing." ) ) ; } } 	0	['8', '1', '0', '7', '42', '14', '0', '7', '2', '0.75', '308', '0', '2', '0', '0.238095238', '0', '0', '37', '4', '1.5', '0']
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . SimpleLayout ; import org . apache . log4j . FileAppender ; public class DefaultInit { static Category cat = Category . getInstance ( DefaultInit . class . getName ( ) ) ; public static void main ( String [ ] argv ) { cat . debug ( "Hello world" ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java org.apache.log4j.test.DefaultInit " ) ; System . exit ( 1 ) ; } } 	0	['5', '1', '0', '1', '14', '8', '0', '1', '2', '0.875', '45', '0', '1', '0', '0.333333333', '0', '0', '7.6', '1', '0.6', '0']
package org . apache . log4j . spi ; import org . apache . log4j . spi . LoggingEvent ; public abstract class Filter implements OptionHandler { public Filter next ; public static final int DENY = - 1 ; public static final int NEUTRAL = 0 ; public static final int ACCEPT = 1 ; public void activateOptions ( ) { } abstract public int decide ( LoggingEvent event ) ; } 	0	['5', '1', '0', '4', '6', '10', '2', '2', '5', '1.25', '13', '0', '1', '0', '0.466666667', '0', '0', '0.8', '1', '0.8', '0']
package org . apache . log4j . helpers ; public class FormattingInfo { int min = - 1 ; int max = 0x7FFFFFFF ; boolean leftAlign = false ; void reset ( ) { min = - 1 ; max = 0x7FFFFFFF ; leftAlign = false ; } void dump ( ) { LogLog . debug ( "min=" + min + ", max=" + max + ", leftAlign=" + leftAlign ) ; } } 	0	['3', '1', '0', '9', '10', '0', '8', '1', '1', '0', '49', '0', '0', '0', '1', '0', '0', '14.33333333', '1', '0.6667', '0']
package org . apache . log4j . or ; class DefaultRenderer implements ObjectRenderer { DefaultRenderer ( ) { } public String doRender ( Object o ) { return o . toString ( ) ; } } 	0	['2', '1', '0', '2', '4', '1', '1', '1', '1', '2', '8', '0', '0', '0', '0.75', '0', '0', '3', '1', '0.5', '0']
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . FileAppender ; import org . apache . log4j . SimpleLayout ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; import java . util . Random ; import java . util . Stack ; public class StressNDC extends Thread { static Category root = Category . getRoot ( ) ; static Random random = new Random ( 101 ) ; static final int LOOP_LENGTH = 24 ; static final int PUSH_MISS = LOOP_LENGTH / 2 ; static final int POP_MISS = PUSH_MISS * 2 ; static final int BRANCHING_FACTOR = 4 + 1 ; static int maxThreads ; static int msgCounter = 0 ; static int threadCounter = 0 ; static double LOG_2 = Math . log ( 2 ) ; static Object lock = new Object ( ) ; public static void main ( String args [ ] ) { root . setPriority ( Priority . DEBUG ) ; BasicConfigurator . configure ( ) ; if ( args . length != 1 ) { usage ( ) ; } try { maxThreads = Integer . parseInt ( args [ 0 ] ) ; } catch ( java . lang . NumberFormatException e ) { System . err . println ( e ) ; usage ( ) ; } root . debug ( "push(IP=127.0.0.1)" ) ; NDC . push ( "IP=127.0.0.1" ) ; while ( true ) { synchronized ( lock ) { createChildren ( randomInt ( BRANCHING_FACTOR ) + 1 ) ; try { root . debug ( "About to wait for notification." ) ; lock . wait ( ) ; root . debug ( "Got a notification." ) ; } catch ( InterruptedException e ) { root . warn ( "Unpextected InterruptedException received." , e ) ; } } } } static void usage ( ) { System . err . println ( "Usage: java org.apache.log4j.test.StressNDC " + "MAX_THREADS" ) ; System . exit ( 1 ) ; } Stack parentDC ; public StressNDC ( Stack parentDC ) { this . setName ( randomID ( ) ) ; this . parentDC = parentDC ; } public void run ( ) { NDC . inherit ( parentDC ) ; int loopLength = StressNDC . randomInt ( LOOP_LENGTH ) ; root . debug ( "In run loop.debug( loopLength = " + loopLength ) ; int createIndex = loopLength / 2 ; for ( int i = 0 ; i <= loopLength ; i ++ ) { if ( i == createIndex ) createChildren ( randomInt ( BRANCHING_FACTOR ) ) ; if ( randomInt ( PUSH_MISS ) == 0 ) { String id = randomID ( ) ; root . debug ( "push(" + id + ")" ) ; NDC . push ( id ) ; } root . debug ( "Message number " + StressNDC . msgCounter ++ ) ; if ( randomInt ( POP_MISS ) == 0 ) { root . debug ( "pop()" ) ; NDC . pop ( ) ; } } synchronized ( lock ) { StressNDC . threadCounter -- ; root . debug ( "Exiting run loop. " + threadCounter ) ; if ( StressNDC . threadCounter <= 0 ) { root . debug ( "Notifying [main] thread." ) ; lock . notify ( ) ; } } if ( ( loopLength % 2 ) == 0 ) { root . debug ( "Removing NDC for this thread." ) ; NDC . remove ( ) ; } } public static void createChildren ( int n ) { if ( n <= 0 ) return ; synchronized ( lock ) { n = maxThreadsConstained ( n ) ; root . debug ( "Creating " + n + " child StressNDC threads." ) ; for ( int i = 0 ; i < n ; i ++ ) { root . debug ( "New StressNDC, threadCounter = " + ( ++ threadCounter ) ) ; new StressNDC ( NDC . cloneStack ( ) ) . start ( ) ; } } } static public int maxThreadsConstained ( int a ) { int maxAllowed = StressNDC . maxThreads - StressNDC . threadCounter ; return a <= maxAllowed ? a : maxAllowed ; } public static int randomInt ( int n ) { int r = random . nextInt ( ) % n ; return r >= 0 ? r : - r ; } public static String randomID ( ) { return Integer . toHexString ( random . nextInt ( ) & 0xFFFFFF ) ; } } 	0	['9', '2', '0', '4', '37', '8', '0', '4', '7', '0.822916667', '314', '0', '1', '0.897058824', '0.21875', '0', '0', '32.55555556', '7', '2', '0']
package org . apache . log4j ; class CategoryKey { String name ; int hashCache ; CategoryKey ( String name ) { this . name = name . intern ( ) ; hashCache = name . hashCode ( ) ; } final public int hashCode ( ) { return hashCache ; } final public boolean equals ( Object rArg ) { if ( this == rArg ) return true ; if ( rArg != null && CategoryKey . class == rArg . getClass ( ) ) return name == ( ( CategoryKey ) rArg ) . name ; else return false ; } } 	0	['4', '1', '0', '1', '11', '2', '1', '0', '2', '0.777777778', '61', '0', '0', '0', '0.5', '1', '1', '13.5', '6', '2', '0']
package org . apache . log4j . performance ; import org . apache . log4j . Layout ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . AppenderSkeleton ; public class NullAppender extends AppenderSkeleton { public static String s ; public String t ; public NullAppender ( ) { } public NullAppender ( Layout layout ) { this . layout = layout ; } public void close ( ) { } public void doAppend ( LoggingEvent event ) { if ( layout != null ) { t = layout . format ( event ) ; s = t ; } } public void append ( LoggingEvent event ) { } public boolean requiresLayout ( ) { return true ; } } 	0	['6', '2', '0', '3', '8', '15', '0', '3', '6', '1', '34', '0', '0', '0.818181818', '0.5', '1', '1', '4.333333333', '2', '0.8333', '0']
package org . apache . log4j . test ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import java . io . IOException ; public class ROFile { static Category cat = Category . getInstance ( ROFile . class . getName ( ) ) ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) init ( argv [ 0 ] ) ; else Usage ( "Wrong number of arguments." ) ; test ( ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + ROFile . class . getName ( ) + "configFile" ) ; System . exit ( 1 ) ; } static void init ( String configFile ) { PropertyConfigurator . configure ( configFile ) ; } static void test ( ) { int i = - 1 ; cat . debug ( "Message " + ++ i ) ; } } 	0	['7', '1', '0', '2', '21', '17', '0', '2', '2', '0.666666667', '90', '0', '1', '0', '0.277777778', '0', '0', '11.57142857', '2', '1', '0']
package org . apache . log4j ; import java . util . Vector ; class ProvisionNode extends Vector { ProvisionNode ( Category cat ) { super ( ) ; this . addElement ( cat ) ; } } 	0	['1', '4', '0', '2', '3', '0', '1', '1', '0', '2', '7', '0', '0', '1', '1', '0', '0', '6', '0', '0', '0']
package org . apache . log4j . test ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . Category ; import org . apache . log4j . NDC ; public class ConfigurationFileParsing { public static void main ( String argv [ ] ) { if ( argv . length == 1 ) { NDC . push ( "testing" ) ; PropertyConfigurator . configure ( argv [ 0 ] ) ; Category root = Category . getRoot ( ) ; root . debug ( "Message 1" ) ; root . debug ( "Message 2" ) ; NDC . pop ( ) ; Category . shutdown ( ) ; } else { Usage ( "Wrong number of arguments." ) ; } } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + ConfigurationFileParsing . class . getName ( ) + " fileName" ) ; System . exit ( 1 ) ; } } 	0	['4', '1', '0', '3', '20', '6', '0', '3', '2', '0.666666667', '69', '0', '0', '0', '0.333333333', '0', '0', '16', '2', '1.25', '0']
package org . apache . log4j . spi ; import org . apache . log4j . Appender ; public interface ErrorHandler extends OptionHandler { void error ( String message , Exception e , int errorCode ) ; void error ( String message ) ; } 	0	['2', '1', '0', '14', '2', '1', '13', '1', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . log4j . spi ; import java . io . StringWriter ; import java . io . PrintWriter ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . Layout ; public class LocationInfo implements java . io . Serializable { transient String lineNumber ; transient String fileName ; transient String className ; transient String methodName ; public String fullInfo ; private static StringWriter sw = new StringWriter ( ) ; private static PrintWriter pw = new PrintWriter ( sw ) ; public final static String NA = "?" ; static final long serialVersionUID = - 1325822038990805636L ; static boolean inVisualAge = false ; static { try { Class dummy = Class . forName ( "com.ibm.uvm.tools.DebugSupport" ) ; inVisualAge = true ; LogLog . debug ( "Detected IBM VisualAge environment." ) ; } catch ( Throwable e ) { } } public LocationInfo ( Throwable t , String fqnOfCallingClass ) { if ( t == null ) return ; String s ; synchronized ( sw ) { t . printStackTrace ( pw ) ; s = sw . toString ( ) ; sw . getBuffer ( ) . setLength ( 0 ) ; } int ibegin , iend ; ibegin = s . lastIndexOf ( fqnOfCallingClass ) ; if ( ibegin == - 1 ) return ; ibegin = s . indexOf ( Layout . LINE_SEP , ibegin ) ; if ( ibegin == - 1 ) return ; ibegin += Layout . LINE_SEP_LEN ; iend = s . indexOf ( Layout . LINE_SEP , ibegin ) ; if ( iend == - 1 ) return ; if ( ! inVisualAge ) { ibegin = s . lastIndexOf ( "at " , iend ) ; if ( ibegin == - 1 ) return ; ibegin += 3 ; } this . fullInfo = s . substring ( ibegin , iend ) ; } public String getClassName ( ) { if ( fullInfo == null ) return NA ; if ( className == null ) { int iend = fullInfo . lastIndexOf ( '(' ) ; if ( iend == - 1 ) className = NA ; else { iend = fullInfo . lastIndexOf ( '.' , iend ) ; int ibegin = 0 ; if ( inVisualAge ) { ibegin = fullInfo . lastIndexOf ( ' ' , iend ) + 1 ; } if ( iend == - 1 ) className = NA ; else className = this . fullInfo . substring ( ibegin , iend ) ; } } return className ; } public String getFileName ( ) { if ( fullInfo == null ) return NA ; if ( fileName == null ) { int iend = fullInfo . lastIndexOf ( ':' ) ; if ( iend == - 1 ) fileName = NA ; else { int ibegin = fullInfo . lastIndexOf ( '(' , iend - 1 ) ; fileName = this . fullInfo . substring ( ibegin + 1 , iend ) ; } } return fileName ; } public String getLineNumber ( ) { if ( fullInfo == null ) return NA ; if ( lineNumber == null ) { int iend = fullInfo . lastIndexOf ( ')' ) ; int ibegin = fullInfo . lastIndexOf ( ':' , iend - 1 ) ; if ( ibegin == - 1 ) lineNumber = NA ; else lineNumber = this . fullInfo . substring ( ibegin + 1 , iend ) ; } return lineNumber ; } public String getMethodName ( ) { if ( fullInfo == null ) return NA ; if ( methodName == null ) { int iend = fullInfo . lastIndexOf ( '(' ) ; int ibegin = fullInfo . lastIndexOf ( '.' , iend ) ; if ( ibegin == - 1 ) methodName = NA ; else methodName = this . fullInfo . substring ( ibegin + 1 , iend ) ; } return methodName ; } } 	0	['6', '1', '0', '9', '21', '0', '7', '2', '5', '0.88', '286', '0.2', '0', '0', '0.466666667', '0', '0', '45', '6', '3', '0']
package org . apache . log4j . helpers ; import org . apache . log4j . spi . LoggingEvent ; public class BoundedFIFO { LoggingEvent [ ] buf ; int numElements = 0 ; int first = 0 ; int next = 0 ; int maxSize ; public BoundedFIFO ( int maxSize ) { if ( maxSize < 1 ) { throw new IllegalArgumentException ( "The maxSize argument (" + maxSize + ") is not a positive integer." ) ; } this . maxSize = maxSize ; buf = new LoggingEvent [ maxSize ] ; } public LoggingEvent get ( ) { if ( numElements == 0 ) return null ; LoggingEvent r = buf [ first ] ; if ( ++ first == maxSize ) { first = 0 ; } numElements -- ; return r ; } public void put ( LoggingEvent o ) { if ( numElements != maxSize ) { buf [ next ] = o ; if ( ++ next == maxSize ) { next = 0 ; } numElements ++ ; } } public int getMaxSize ( ) { return maxSize ; } public boolean isFull ( ) { return numElements == maxSize ; } public int length ( ) { return numElements ; } int min ( int a , int b ) { return a < b ? a : b ; } synchronized public void resize ( int newSize ) { if ( newSize == maxSize ) return ; LoggingEvent [ ] tmp = new LoggingEvent [ newSize ] ; int len1 = maxSize - first ; len1 = min ( len1 , newSize ) ; len1 = min ( len1 , numElements ) ; System . arraycopy ( buf , first , tmp , 0 , len1 ) ; int len2 = 0 ; if ( ( len1 < numElements ) && ( len1 < newSize ) ) { len2 = numElements - len1 ; len2 = min ( len2 , newSize - len1 ) ; System . arraycopy ( buf , 0 , tmp , len1 , len2 ) ; } this . buf = tmp ; this . maxSize = newSize ; this . first = 0 ; this . numElements = len1 + len2 ; this . next = this . numElements ; if ( this . next == this . maxSize ) this . next = 0 ; } public boolean wasEmpty ( ) { return numElements == 1 ; } public boolean wasFull ( ) { return ( numElements + 1 == maxSize ) ; } } 	0	['10', '1', '0', '3', '17', '0', '2', '1', '9', '0.555555556', '243', '0', '1', '0', '0.466666667', '0', '0', '22.8', '5', '2.1', '0']
package org . apache . log4j . config ; import java . io . * ; import java . util . * ; import org . apache . log4j . * ; public class PropertyPrinter implements PropertyGetter . PropertyCallback { protected int numAppenders = 0 ; protected Hashtable appenderNames = new Hashtable ( ) ; protected Hashtable layoutNames = new Hashtable ( ) ; protected PrintWriter out ; protected boolean doCapitalize ; public PropertyPrinter ( PrintWriter out ) { this ( out , false ) ; } public PropertyPrinter ( PrintWriter out , boolean doCapitalize ) { this . out = out ; this . doCapitalize = doCapitalize ; print ( out ) ; out . flush ( ) ; } protected String genAppName ( ) { return "A" + numAppenders ++ ; } protected boolean isGenAppName ( String name ) { if ( name . length ( ) < 2 || name . charAt ( 0 ) != 'A' ) return false ; for ( int i = 0 ; i < name . length ( ) ; i ++ ) { if ( name . charAt ( i ) < '0' || name . charAt ( i ) > '9' ) return false ; } return true ; } public void print ( PrintWriter out ) { printOptions ( out , Category . getRoot ( ) ) ; Enumeration cats = Category . getCurrentCategories ( ) ; while ( cats . hasMoreElements ( ) ) { printOptions ( out , ( Category ) cats . nextElement ( ) ) ; } } protected void printOptions ( PrintWriter out , Category cat ) { Enumeration appenders = cat . getAllAppenders ( ) ; Priority prio = cat . getPriority ( ) ; String appenderString = ( prio == null ? "" : prio . toString ( ) ) ; while ( appenders . hasMoreElements ( ) ) { Appender app = ( Appender ) appenders . nextElement ( ) ; String name ; if ( ( name = ( String ) appenderNames . get ( app ) ) == null ) { if ( ( name = app . getName ( ) ) == null || isGenAppName ( name ) ) { name = genAppName ( ) ; } appenderNames . put ( app , name ) ; printOptions ( out , app , "log4j.appender." + name ) ; if ( app . getLayout ( ) != null ) { printOptions ( out , app . getLayout ( ) , "log4j.appender." + name + ".layout" ) ; } } appenderString += ", " + name ; } String catKey = ( cat == Category . getRoot ( ) ) ? "log4j.rootCategory" : "log4j.category." + cat . getName ( ) ; if ( appenderString != "" ) { out . println ( catKey + "=" + appenderString ) ; } } protected void printOptions ( PrintWriter out , Object obj , String fullname ) { out . println ( fullname + "=" + obj . getClass ( ) . getName ( ) ) ; PropertyGetter . getProperties ( obj , this , fullname + "." ) ; } public void foundProperty ( Object obj , String prefix , String name , Object value ) { if ( obj instanceof Appender && "name" . equals ( name ) ) { return ; } if ( doCapitalize ) { name = capitalize ( name ) ; } out . println ( prefix + name + "=" + value . toString ( ) ) ; } public static String capitalize ( String name ) { if ( Character . isLowerCase ( name . charAt ( 0 ) ) ) { if ( name . length ( ) == 1 || Character . isLowerCase ( name . charAt ( 1 ) ) ) { StringBuffer newname = new StringBuffer ( name ) ; newname . setCharAt ( 0 , Character . toUpperCase ( name . charAt ( 0 ) ) ) ; return newname . toString ( ) ; } } return name ; } public static void main ( String [ ] args ) { new PropertyPrinter ( new PrintWriter ( System . out ) ) ; } } 	0	['10', '1', '0', '7', '42', '39', '1', '6', '6', '0.644444444', '328', '1', '0', '0', '0.314285714', '0', '0', '31.3', '9', '2.8', '0']
package org . apache . log4j . test ; public class SpacePad { static String [ ] SPACES = { " " , "  " , "    " , "        " , "                " , "                                " } ; static public void main ( String [ ] args ) { StringBuffer sbuf = new StringBuffer ( ) ; for ( int i = 0 ; i < 35 ; i ++ ) { sbuf . setLength ( 0 ) ; sbuf . append ( "\"" ) ; spacePad ( sbuf , i ) ; sbuf . append ( "\"" ) ; System . out . println ( sbuf . toString ( ) ) ; } sbuf . setLength ( 0 ) ; sbuf . append ( "\"" ) ; spacePad ( sbuf , 67 ) ; sbuf . append ( "\"" ) ; System . out . println ( sbuf . toString ( ) ) ; } static public void spacePad ( StringBuffer sbuf , int length ) { while ( length >= 32 ) { sbuf . append ( SPACES [ 5 ] ) ; length -= 32 ; } for ( int i = 4 ; i >= 0 ; i -- ) { if ( ( length & ( 1 << i ) ) != 0 ) { sbuf . append ( SPACES [ i ] ) ; } } } } 	0	['4', '1', '0', '0', '10', '4', '0', '0', '3', '0.333333333', '114', '0', '0', '0', '0.333333333', '0', '0', '27.25', '4', '1.5', '0']
package org . apache . log4j . or ; import java . util . Hashtable ; public class RendererMap { Hashtable map ; static ObjectRenderer defaultRenderer = new DefaultRenderer ( ) ; public RendererMap ( ) { map = new Hashtable ( ) ; } public String findAndRender ( Object o ) { if ( o == null ) return null ; else return get ( o . getClass ( ) ) . doRender ( o ) ; } public ObjectRenderer get ( Object o ) { if ( o == null ) return null ; else return get ( o . getClass ( ) ) ; } public ObjectRenderer get ( Class clazz ) { ObjectRenderer r = null ; for ( Class c = clazz ; c != null ; c = c . getSuperclass ( ) ) { r = ( ObjectRenderer ) map . get ( c ) ; if ( r != null ) { return r ; } r = searchInterfaces ( c ) ; if ( r != null ) return r ; } return defaultRenderer ; } ObjectRenderer searchInterfaces ( Class c ) { ObjectRenderer r = ( ObjectRenderer ) map . get ( c ) ; if ( r != null ) { return r ; } else { Class [ ] ia = c . getInterfaces ( ) ; for ( int i = 0 ; i < ia . length ; i ++ ) { r = searchInterfaces ( ia [ i ] ) ; if ( r != null ) return r ; } } return null ; } public ObjectRenderer getDefaultRenderer ( ) { return defaultRenderer ; } public void clear ( ) { map . clear ( ) ; } public void put ( Class clazz , ObjectRenderer or ) { map . put ( clazz , or ) ; } } 	0	['9', '1', '0', '5', '19', '10', '3', '2', '7', '0.375', '120', '0', '1', '0', '0.4375', '0', '0', '12.11111111', '4', '1.6667', '0']
package org . apache . log4j . helpers ; import org . apache . log4j . spi . LoggingEvent ; public class CyclicBuffer { LoggingEvent [ ] ea ; int first ; int last ; int numElems ; int maxSize ; public CyclicBuffer ( int maxSize ) throws IllegalArgumentException { if ( maxSize < 1 ) { throw new IllegalArgumentException ( "The maxSize argument (" + maxSize + ") is not a positive integer." ) ; } this . maxSize = maxSize ; ea = new LoggingEvent [ maxSize ] ; first = 0 ; last = 0 ; numElems = 0 ; } public void add ( LoggingEvent event ) { ea [ last ] = event ; if ( ++ last == maxSize ) last = 0 ; if ( numElems < maxSize ) numElems ++ ; else if ( ++ first == maxSize ) first = 0 ; } public LoggingEvent get ( int i ) { if ( i < 0 || i >= numElems ) return null ; return ea [ ( first + i ) % maxSize ] ; } public int getMaxSize ( ) { return maxSize ; } public LoggingEvent get ( ) { LoggingEvent r = null ; if ( numElems > 0 ) { numElems -- ; r = ea [ first ] ; ea [ first ] = null ; if ( ++ first == maxSize ) first = 0 ; } return r ; } public int length ( ) { return numElems ; } public void resize ( int newSize ) { if ( newSize < 0 ) { throw new IllegalArgumentException ( "Negative array size [" + newSize + "] not allowed." ) ; } if ( newSize == numElems ) return ; LoggingEvent [ ] temp = new LoggingEvent [ newSize ] ; int loopLen = newSize < numElems ? newSize : numElems ; for ( int i = 0 ; i < loopLen ; i ++ ) { temp [ i ] = ea [ first ] ; ea [ first ] = null ; if ( ++ first == numElems ) first = 0 ; } ea = temp ; first = 0 ; numElems = loopLen ; maxSize = newSize ; if ( loopLen == newSize ) { last = 0 ; } else { last = loopLen ; } } } 	0	['7', '1', '0', '2', '13', '0', '1', '1', '7', '0.333333333', '246', '0', '1', '0', '0.523809524', '0', '0', '33.42857143', '7', '2.7143', '0']
package org . apache . log4j ; import org . apache . log4j . spi . CategoryFactory ; class DefaultCategoryFactory implements CategoryFactory { DefaultCategoryFactory ( ) { } public Category makeNewCategoryInstance ( String name ) { return new Category ( name ) ; } } 	0	['2', '1', '0', '4', '4', '1', '2', '2', '1', '2', '10', '0', '0', '0', '0.75', '0', '0', '4', '1', '0.5', '0']
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . FileAppender ; import org . apache . log4j . SimpleLayout ; import org . apache . log4j . xml . DOMConfigurator ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; import java . util . Random ; import java . util . Stack ; public class StressAsyncAppender extends Thread { static Category root = Category . getRoot ( ) ; static Random random = new Random ( 101 ) ; static final int LOOP_LENGTH = 24 ; static final int BRANCHING_FACTOR = 4 ; static int maxThreads ; static long msgCounter = 0 ; static int threadCounter = 0 ; static double LOG_2 = Math . log ( 2 ) ; static Object lock = new Object ( ) ; public static void main ( String args [ ] ) { if ( args . length != 1 ) { usage ( ) ; } DOMConfigurator . configure ( "xml/stressAsyncAppender.xml" ) ; try { maxThreads = Integer . parseInt ( args [ 0 ] ) ; } catch ( java . lang . NumberFormatException e ) { System . err . println ( e ) ; usage ( ) ; } while ( true ) { synchronized ( lock ) { createChildren ( randomInt ( BRANCHING_FACTOR ) + 1 ) ; try { root . debug ( "About to wait for notification." ) ; lock . wait ( ) ; root . debug ( "Got a notification." ) ; } catch ( InterruptedException e ) { root . warn ( "Unpextected InterruptedException received." , e ) ; } } } } static void usage ( ) { System . err . println ( "Usage: java " + StressAsyncAppender . class . getName ( ) + " MAX_THREADS" ) ; System . exit ( 1 ) ; } public StressAsyncAppender ( ) { } public void run ( ) { int loopLength = StressAsyncAppender . randomInt ( LOOP_LENGTH ) ; root . debug ( "In run loop, loopLength = " + loopLength ) ; int createIndex = loopLength / 2 ; for ( int i = 0 ; i <= loopLength ; i ++ ) { if ( i == createIndex ) createChildren ( randomInt ( BRANCHING_FACTOR ) ) ; synchronized ( lock ) { root . debug ( "Message number " + msgCounter ++ ) ; } } synchronized ( lock ) { StressAsyncAppender . threadCounter -- ; root . debug ( "Exiting run loop. " + threadCounter ) ; if ( StressAsyncAppender . threadCounter <= 0 ) { root . debug ( "Notifying [main] thread." ) ; lock . notify ( ) ; } } } public static void createChildren ( int n ) { if ( n <= 0 ) return ; synchronized ( lock ) { n = maxThreadsConstrained ( n ) ; root . debug ( "Creating " + n + " child StressAsyncAppender threads." ) ; for ( int i = 0 ; i < n ; i ++ ) { root . debug ( "New StressAsyncAppender, threadCounter = " + ( ++ threadCounter ) ) ; new StressAsyncAppender ( ) . start ( ) ; } } } static public int maxThreadsConstrained ( int a ) { int maxAllowed = StressAsyncAppender . maxThreads - StressAsyncAppender . threadCounter ; return a <= maxAllowed ? a : maxAllowed ; } public static int randomInt ( int n ) { int r = random . nextInt ( ) % n ; return r >= 0 ? r : - r ; } public void delay ( long millis ) { try { Thread . currentThread ( ) . sleep ( millis ) ; } catch ( Exception e ) { } } } 	0	['10', '2', '0', '2', '37', '23', '0', '2', '7', '0.833333333', '301', '0', '1', '0.884057971', '0.2', '0', '0', '28.1', '4', '1.7', '0']
package org . apache . log4j . helpers ; import java . util . Calendar ; import java . util . TimeZone ; import java . util . Date ; import java . text . FieldPosition ; import java . text . ParsePosition ; import java . text . DateFormat ; import java . text . DateFormatSymbols ; public class DateTimeDateFormat extends AbsoluteTimeDateFormat { String [ ] shortMonths ; public DateTimeDateFormat ( ) { super ( ) ; shortMonths = new DateFormatSymbols ( ) . getShortMonths ( ) ; } public DateTimeDateFormat ( TimeZone timeZone ) { this ( ) ; setCalendar ( Calendar . getInstance ( timeZone ) ) ; } public StringBuffer format ( Date date , StringBuffer sbuf , FieldPosition fieldPosition ) { calendar . setTime ( date ) ; int day = calendar . get ( Calendar . DAY_OF_MONTH ) ; if ( day < 10 ) sbuf . append ( '0' ) ; sbuf . append ( day ) ; sbuf . append ( ' ' ) ; sbuf . append ( shortMonths [ calendar . get ( Calendar . MONTH ) ] ) ; sbuf . append ( ' ' ) ; int year = calendar . get ( Calendar . YEAR ) ; sbuf . append ( year ) ; sbuf . append ( ' ' ) ; return super . format ( date , sbuf , fieldPosition ) ; } public Date parse ( java . lang . String s , ParsePosition pos ) { return null ; } } 	0	['4', '4', '0', '3', '15', '4', '2', '1', '4', '0.333333333', '80', '0', '0', '0.953488372', '0.357142857', '1', '3', '18.75', '2', '0.75', '0']
package org . apache . log4j . net . test ; import org . apache . log4j . * ; import org . apache . log4j . net . SocketAppender ; public class Loop { public static void main ( String [ ] args ) { Category root = Category . getRoot ( ) ; Category cat = Category . getInstance ( Loop . class . getName ( ) ) ; if ( args . length != 2 ) usage ( "Wrong number of arguments." ) ; String host = args [ 0 ] ; int port = 0 ; try { port = Integer . valueOf ( args [ 1 ] ) . intValue ( ) ; } catch ( NumberFormatException e ) { usage ( "Argument [" + args [ 1 ] + "] is not in proper int form." ) ; } SocketAppender sa = new SocketAppender ( host , port ) ; Layout layout = new PatternLayout ( "%5p [%t] %x %c - %m\n" ) ; Appender so = new ConsoleAppender ( layout , "System.out" ) ; root . addAppender ( sa ) ; root . addAppender ( so ) ; int i = 0 ; while ( true ) { NDC . push ( "" + ( i ++ ) ) ; cat . debug ( "Debug message." ) ; root . info ( "Info message." ) ; NDC . pop ( ) ; } } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + Loop . class . getName ( ) + " host port" ) ; System . exit ( 1 ) ; } } 	0	['4', '1', '0', '7', '27', '4', '0', '7', '2', '0.666666667', '134', '0', '0', '0', '0.333333333', '0', '0', '32.25', '3', '1.5', '0']
package org . apache . log4j . or ; import org . apache . log4j . Layout ; public class ThreadGroupRenderer implements ObjectRenderer { public ThreadGroupRenderer ( ) { } public String doRender ( Object o ) { if ( o instanceof ThreadGroup ) { StringBuffer sbuf = new StringBuffer ( ) ; ThreadGroup tg = ( ThreadGroup ) o ; sbuf . append ( "java.lang.ThreadGroup[name=" ) ; sbuf . append ( tg . getName ( ) ) ; sbuf . append ( ", maxpri=" ) ; sbuf . append ( tg . getMaxPriority ( ) ) ; sbuf . append ( "]" ) ; Thread [ ] t = new Thread [ tg . activeCount ( ) ] ; tg . enumerate ( t ) ; for ( int i = 0 ; i < t . length ; i ++ ) { sbuf . append ( Layout . LINE_SEP ) ; sbuf . append ( "   Thread=[" ) ; sbuf . append ( t [ i ] . getName ( ) ) ; sbuf . append ( "," ) ; sbuf . append ( t [ i ] . getPriority ( ) ) ; sbuf . append ( "," ) ; sbuf . append ( t [ i ] . isDaemon ( ) ) ; sbuf . append ( "]" ) ; } return sbuf . toString ( ) ; } else { return o . toString ( ) ; } } } 	0	['2', '1', '0', '2', '16', '1', '0', '2', '2', '2', '100', '0', '0', '0', '0.75', '0', '0', '49', '3', '1.5', '0']
package org . apache . log4j . net . test ; import org . apache . log4j . Category ; import org . apache . log4j . Layout ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . Appender ; import org . apache . log4j . net . SocketAppender ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; import java . io . IOException ; public class SyslogMin { static Category CAT = Category . getInstance ( SyslogMin . class . getName ( ) ) ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) { ProgramInit ( argv [ 0 ] ) ; } else { Usage ( "Wrong number of arguments." ) ; } test ( "someHost" ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + SyslogMin . class + " configFile" ) ; System . exit ( 1 ) ; } static void ProgramInit ( String configFile ) { int port = 0 ; PropertyConfigurator . configure ( configFile ) ; } static void test ( String host ) { NDC . push ( host ) ; int i = 0 ; CAT . debug ( "Message " + i ++ ) ; CAT . info ( "Message " + i ++ ) ; CAT . warn ( "Message " + i ++ ) ; CAT . error ( "Message " + i ++ ) ; CAT . log ( Priority . FATAL , "Message " + i ++ ) ; CAT . debug ( "Message " + i ++ , new Exception ( "Just testing." ) ) ; } } 	0	['7', '1', '0', '4', '29', '17', '0', '4', '2', '0.666666667', '154', '0', '1', '0', '0.333333333', '0', '0', '20.71428571', '2', '1', '0']
package org . apache . log4j . spi ; public interface ErrorCode { public final int GENERIC_FAILURE = 0 ; public final int WRITE_FAILURE = 1 ; public final int FLUSH_FAILURE = 2 ; public final int CLOSE_FAILURE = 3 ; public final int FILE_OPEN_FAILURE = 4 ; public final int MISSING_LAYOUT = 5 ; public final int ADDRESS_PARSE_FAILURE = 6 ; } 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '7', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . log4j . helpers ; import java . util . Date ; import java . text . FieldPosition ; import java . text . ParsePosition ; import java . text . DateFormat ; public class RelativeTimeDateFormat extends DateFormat { protected final long startTime ; public RelativeTimeDateFormat ( ) { this . startTime = System . currentTimeMillis ( ) ; } public StringBuffer format ( Date date , StringBuffer sbuf , FieldPosition fieldPosition ) { return sbuf . append ( ( date . getTime ( ) - startTime ) ) ; } public Date parse ( java . lang . String s , ParsePosition pos ) { return null ; } } 	0	['3', '3', '0', '1', '7', '1', '1', '0', '3', '0.5', '20', '1', '0', '0.951219512', '0.444444444', '1', '3', '5.333333333', '1', '0.6667', '0']
package org . apache . log4j ; import java . beans . * ; import org . apache . log4j . helpers . LogLog ; import java . lang . reflect . Method ; public class RollingFileAppenderBeanInfo extends SimpleBeanInfo { private PropertyDescriptor [ ] props ; public RollingFileAppenderBeanInfo ( ) { Class clazz = RollingFileAppender . class ; try { BeanInfo bi = Introspector . getBeanInfo ( clazz , Introspector . IGNORE_ALL_BEANINFO ) ; props = bi . getPropertyDescriptors ( ) ; if ( props != null ) { for ( int i = 0 ; i < props . length ; i ++ ) { if ( props [ i ] . getName ( ) . equals ( "maxFileSize" ) ) { Method m = clazz . getMethod ( "setMaxFileSize" , new Class [ ] { String . class } ) ; props [ i ] = new PropertyDescriptor ( "maxFileSize" , null , m ) ; } } } Introspector . flushFromCaches ( RollingFileAppender . class ) ; } catch ( IntrospectionException e ) { LogLog . error ( "Could not inspect RollingFileAppender." , e ) ; } catch ( NoSuchMethodException e ) { LogLog . error ( "Could not find setter method for RollingFileAppender." , e ) ; } } public PropertyDescriptor [ ] getPropertyDescriptors ( ) { return props ; } } 	0	['3', '2', '0', '1', '15', '1', '0', '1', '2', '0.833333333', '105', '0.333333333', '0', '0.818181818', '0.5', '0', '0', '33', '1', '0.6667', '0']
package org . apache . log4j . helpers ; import java . util . Date ; import java . util . Calendar ; import java . util . TimeZone ; import java . text . FieldPosition ; import java . text . ParsePosition ; import java . text . DateFormat ; public class AbsoluteTimeDateFormat extends DateFormat { public final static String ABS_TIME_DATE_FORMAT = "ABSOLUTE" ; public final static String DATE_AND_TIME_DATE_FORMAT = "DATE" ; public final static String ISO8601_DATE_FORMAT = "ISO8601" ; public AbsoluteTimeDateFormat ( ) { setCalendar ( Calendar . getInstance ( ) ) ; } public AbsoluteTimeDateFormat ( TimeZone timeZone ) { setCalendar ( Calendar . getInstance ( timeZone ) ) ; } public StringBuffer format ( Date date , StringBuffer sbuf , FieldPosition fieldPosition ) { calendar . setTime ( date ) ; int hour = calendar . get ( Calendar . HOUR_OF_DAY ) ; if ( hour < 10 ) { sbuf . append ( '0' ) ; } sbuf . append ( hour ) ; sbuf . append ( ':' ) ; int mins = calendar . get ( Calendar . MINUTE ) ; if ( mins < 10 ) { sbuf . append ( '0' ) ; } sbuf . append ( mins ) ; sbuf . append ( ':' ) ; int secs = calendar . get ( Calendar . SECOND ) ; if ( secs < 10 ) { sbuf . append ( '0' ) ; } sbuf . append ( secs ) ; sbuf . append ( ',' ) ; int millis = calendar . get ( Calendar . MILLISECOND ) ; if ( millis < 100 ) sbuf . append ( '0' ) ; if ( millis < 10 ) sbuf . append ( '0' ) ; sbuf . append ( millis ) ; return sbuf ; } public Date parse ( String s , ParsePosition pos ) { return null ; } } 	0	['4', '3', '2', '4', '12', '6', '4', '0', '4', '1.333333333', '111', '0', '0', '0.951219512', '0.357142857', '1', '3', '26', '6', '1.75', '0']
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . xml . DOMConfigurator ; public class DelayedLoop { static Category cat = Category . getInstance ( DelayedLoop . class ) ; static int loopLength ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) init ( argv [ 0 ] ) ; else usage ( "Wrong number of arguments." ) ; test ( ) ; } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + DelayedLoop . class . getName ( ) + "configFile" ) ; System . exit ( 1 ) ; } static void init ( String configFile ) { if ( configFile . endsWith ( "xml" ) ) { DOMConfigurator . configureAndWatch ( configFile , 3000 ) ; } else { PropertyConfigurator . configureAndWatch ( configFile , 3000 ) ; } } static void test ( ) { int i = 0 ; while ( true ) { cat . debug ( "MSG " + i ++ ) ; try { Thread . currentThread ( ) . sleep ( 1000 ) ; } catch ( Exception e ) { } } } } 	0	['7', '1', '0', '3', '25', '17', '0', '3', '2', '0.833333333', '105', '0', '1', '0', '0.277777778', '0', '0', '13.57142857', '2', '1.1429', '0']
package org . apache . log4j . or ; public interface ObjectRenderer { public String doRender ( Object o ) ; } 	0	['1', '1', '0', '7', '1', '0', '7', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . log4j . performance ; import java . util . Vector ; public class ListVsVector { static int RUN_LENGTH = 1000000 ; static Vector v = new Vector ( ) ; static Chain head ; static String tmp ; static public void main ( String [ ] args ) { v . addElement ( "aaa" ) ; v . addElement ( "bbb" ) ; v . addElement ( "ccc" ) ; v . addElement ( "ddd" ) ; v . addElement ( "eee" ) ; Chain c = new Chain ( "aaa" ) ; head = c ; c . next = new Chain ( "bbb" ) ; c = c . next ; c . next = new Chain ( "ccc" ) ; c = c . next ; c . next = new Chain ( "ddd" ) ; c = c . next ; c . next = new Chain ( "eee" ) ; double t ; t = loopChain ( ) ; System . out . println ( "Looping thourgh the chain took " + t ) ; t = loopVector ( ) ; System . out . println ( "Looping thourgh the vector took " + t ) ; } static double loopChain ( ) { long before = System . currentTimeMillis ( ) ; Chain c ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { c = head ; while ( c != null ) { tmp = c . s ; c = c . next ; } } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } static double loopVector ( ) { long before = System . currentTimeMillis ( ) ; int size = v . size ( ) ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { for ( int j = 0 ; j < size ; j ++ ) tmp = ( String ) v . elementAt ( j ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } static class Chain { public String s ; public Chain next ; Chain ( String s ) { this . s = s ; } void setNext ( Chain c ) { next = c ; } } } 	0	['5', '1', '0', '1', '17', '0', '0', '1', '2', '0.5', '163', '0', '1', '0', '0.25', '0', '0', '30.8', '3', '1.4', '0']
package org . apache . log4j . test ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Enumeration ; public class Finalize { static Category CAT = Category . getInstance ( Finalize . class . getName ( ) ) ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) init ( argv [ 0 ] ) ; else Usage ( "Wrong number of arguments." ) ; test ( ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + Finalize . class . getName ( ) + " configFile" ) ; System . exit ( 1 ) ; } static void init ( String configFile ) { PropertyConfigurator . configure ( configFile ) ; } static void test ( ) { int i = - 1 ; InputStreamReader in = new InputStreamReader ( System . in ) ; Category root = Category . getRoot ( ) ; System . out . println ( "Type 'q' to quit" ) ; int j = 0 ; while ( true ) { System . gc ( ) ; try { i = in . read ( ) ; } catch ( Exception e ) { return ; } System . gc ( ) ; System . out . println ( "Read [" + i + "]." ) ; if ( i == - 1 ) break ; else if ( i == 'q' ) break ; else root . debug ( "Hello " + ( ++ j ) ) ; } root . removeAllAppenders ( ) ; System . gc ( ) ; delay ( 3000 ) ; System . gc ( ) ; delay ( 3000 ) ; System . gc ( ) ; delay ( 3000 ) ; System . gc ( ) ; } static void foo ( Category cat ) { Enumeration enum = cat . getAllAppenders ( ) ; while ( enum != null && enum . hasMoreElements ( ) ) { ( ( org . apache . log4j . Appender ) enum . nextElement ( ) ) . close ( ) ; } } static void delay ( int amount ) { try { Thread . currentThread ( ) . sleep ( amount ) ; } catch ( Exception e ) { } } } 	0	['9', '1', '0', '3', '34', '34', '0', '3', '2', '0.875', '167', '0', '1', '0', '0.175', '0', '0', '17.33333333', '3', '1.4444', '0']
package org . apache . log4j . test ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . Category ; import org . apache . log4j . Appender ; import java . util . Enumeration ; import java . util . Vector ; public class MultipleAppenders { public static void main ( String argv [ ] ) { PropertyConfigurator . configure ( argv [ 0 ] ) ; Category root = Category . getRoot ( ) ; Enumeration e1 = root . getAllAppenders ( ) ; Vector v = new Vector ( 1 ) ; while ( e1 . hasMoreElements ( ) ) { Appender a = ( Appender ) e1 . nextElement ( ) ; v . addElement ( a ) ; String appenderName = a . getName ( ) ; if ( a != root . getAppender ( appenderName ) ) { System . out . println ( appenderName + " lookup failed. Exiting." ) ; System . exit ( 1 ) ; } root . addAppender ( a ) ; } root . addAppender ( null ) ; Enumeration e2 = root . getAllAppenders ( ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( v . elementAt ( i ) != e2 . nextElement ( ) ) { } } if ( e2 . hasMoreElements ( ) ) { System . out . println ( "Failure, e2 has remaining elements. Exiting." ) ; System . exit ( 1 ) ; } System . out . println ( "OK" ) ; } } 	0	['2', '1', '0', '3', '20', '1', '0', '3', '2', '2', '85', '0', '0', '0', '0.5', '0', '0', '41.5', '6', '3', '0']
package org . apache . log4j . spi ; import org . apache . log4j . Category ; public interface CategoryFactory { public Category makeNewCategoryInstance ( String name ) ; } 	0	['1', '1', '0', '6', '1', '0', '6', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . log4j . helpers ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . AbsoluteTimeDateFormat ; import org . apache . log4j . Layout ; import org . apache . log4j . NDC ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . spi . LocationInfo ; import org . apache . log4j . or . ObjectRenderer ; import org . apache . log4j . or . RendererMap ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; public class PatternParser { private static final char ESCAPE_CHAR = '%' ; private static final int LITERAL_STATE = 0 ; private static final int CONVERTER_STATE = 1 ; private static final int MINUS_STATE = 2 ; private static final int DOT_STATE = 3 ; private static final int MIN_STATE = 4 ; private static final int MAX_STATE = 5 ; static final int FULL_LOCATION_CONVERTER = 1000 ; static final int METHOD_LOCATION_CONVERTER = 1001 ; static final int CLASS_LOCATION_CONVERTER = 1002 ; static final int LINE_LOCATION_CONVERTER = 1003 ; static final int FILE_LOCATION_CONVERTER = 1004 ; static final int RELATIVE_TIME_CONVERTER = 2000 ; static final int THREAD_CONVERTER = 2001 ; static final int PRIORITY_CONVERTER = 2002 ; static final int NDC_CONVERTER = 2003 ; static final int MESSAGE_CONVERTER = 2004 ; int state ; protected StringBuffer currentLiteral = new StringBuffer ( 32 ) ; protected int patternLength ; protected int i ; PatternConverter head ; PatternConverter tail ; protected FormattingInfo formattingInfo = new FormattingInfo ( ) ; protected String pattern ; public PatternParser ( String pattern ) { this . pattern = pattern ; patternLength = pattern . length ( ) ; state = LITERAL_STATE ; } private void addToList ( PatternConverter pc ) { if ( head == null ) { head = tail = pc ; } else { tail . next = pc ; tail = pc ; } } private String extractOption ( ) { if ( ( i < patternLength ) && ( pattern . charAt ( i ) == '{' ) ) { int end = pattern . indexOf ( '}' , i ) ; if ( end > i ) { String r = pattern . substring ( i + 1 , end ) ; i = end + 1 ; return r ; } } return null ; } private int extractPrecisionOption ( ) { String opt = extractOption ( ) ; int r = 0 ; if ( opt != null ) { try { r = Integer . parseInt ( opt ) ; if ( r <= 0 ) { LogLog . error ( "Precision option (" + opt + ") isn't a positive integer." ) ; r = 0 ; } } catch ( NumberFormatException e ) { LogLog . error ( "Category option \"" + opt + "\" not a decimal integer." , e ) ; } } return r ; } public PatternConverter parse ( ) { char c ; i = 0 ; while ( i < patternLength ) { c = pattern . charAt ( i ++ ) ; switch ( state ) { case LITERAL_STATE : if ( i == patternLength ) { currentLiteral . append ( c ) ; continue ; } if ( c == ESCAPE_CHAR ) { switch ( pattern . charAt ( i ) ) { case ESCAPE_CHAR : currentLiteral . append ( c ) ; i ++ ; break ; case 'n' : currentLiteral . append ( Layout . LINE_SEP ) ; i ++ ; break ; default : if ( currentLiteral . length ( ) != 0 ) { addToList ( new LiteralPatternConverter ( currentLiteral . toString ( ) ) ) ; } currentLiteral . setLength ( 0 ) ; currentLiteral . append ( c ) ; state = CONVERTER_STATE ; formattingInfo . reset ( ) ; } } else { currentLiteral . append ( c ) ; } break ; case CONVERTER_STATE : currentLiteral . append ( c ) ; switch ( c ) { case '-' : formattingInfo . leftAlign = true ; break ; case '.' : state = DOT_STATE ; break ; default : if ( c >= '0' && c <= '9' ) { formattingInfo . min = c - '0' ; state = MIN_STATE ; } else finalizeConverter ( c ) ; } break ; case MIN_STATE : currentLiteral . append ( c ) ; if ( c >= '0' && c <= '9' ) formattingInfo . min = formattingInfo . min * 10 + ( c - '0' ) ; else if ( c == '.' ) state = DOT_STATE ; else { finalizeConverter ( c ) ; } break ; case DOT_STATE : currentLiteral . append ( c ) ; if ( c >= '0' && c <= '9' ) { formattingInfo . max = c - '0' ; state = MAX_STATE ; } else { LogLog . error ( "Error occured in position " + i + ".\n Was expecting digit, instead got char \"" + c + "\"." ) ; state = LITERAL_STATE ; } break ; case MAX_STATE : currentLiteral . append ( c ) ; if ( c >= '0' && c <= '9' ) formattingInfo . max = formattingInfo . max * 10 + ( c - '0' ) ; else { finalizeConverter ( c ) ; state = LITERAL_STATE ; } break ; } } if ( currentLiteral . length ( ) != 0 ) { addToList ( new LiteralPatternConverter ( currentLiteral . toString ( ) ) ) ; } return head ; } protected void finalizeConverter ( char c ) { PatternConverter pc = null ; switch ( c ) { case 'c' : pc = new CategoryPatternConverter ( formattingInfo , extractPrecisionOption ( ) ) ; currentLiteral . setLength ( 0 ) ; break ; case 'C' : pc = new ClassNamePatternConverter ( formattingInfo , extractPrecisionOption ( ) ) ; currentLiteral . setLength ( 0 ) ; break ; case 'd' : String dateFormatStr = AbsoluteTimeDateFormat . ISO8601_DATE_FORMAT ; DateFormat df ; String dOpt = extractOption ( ) ; if ( dOpt != null ) dateFormatStr = dOpt ; if ( dateFormatStr . equalsIgnoreCase ( AbsoluteTimeDateFormat . ISO8601_DATE_FORMAT ) ) df = new ISO8601DateFormat ( ) ; else if ( dateFormatStr . equalsIgnoreCase ( AbsoluteTimeDateFormat . ABS_TIME_DATE_FORMAT ) ) df = new AbsoluteTimeDateFormat ( ) ; else if ( dateFormatStr . equalsIgnoreCase ( AbsoluteTimeDateFormat . DATE_AND_TIME_DATE_FORMAT ) ) df = new DateTimeDateFormat ( ) ; else { try { df = new SimpleDateFormat ( dateFormatStr ) ; } catch ( IllegalArgumentException e ) { LogLog . error ( "Could not instantiate SimpleDateFormat with " + dateFormatStr , e ) ; df = ( DateFormat ) OptionConverter . instantiateByClassName ( "org.apache.log4j.helpers.ISO8601DateFormat" , DateFormat . class , null ) ; } } pc = new DatePatternConverter ( formattingInfo , df ) ; currentLiteral . setLength ( 0 ) ; break ; case 'F' : pc = new LocationPatternConverter ( formattingInfo , FILE_LOCATION_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'l' : pc = new LocationPatternConverter ( formattingInfo , FULL_LOCATION_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'L' : pc = new LocationPatternConverter ( formattingInfo , LINE_LOCATION_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'm' : pc = new BasicPatternConverter ( formattingInfo , MESSAGE_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'M' : pc = new LocationPatternConverter ( formattingInfo , METHOD_LOCATION_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'p' : pc = new BasicPatternConverter ( formattingInfo , PRIORITY_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'r' : pc = new BasicPatternConverter ( formattingInfo , RELATIVE_TIME_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 't' : pc = new BasicPatternConverter ( formattingInfo , THREAD_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'x' : pc = new BasicPatternConverter ( formattingInfo , NDC_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; default : LogLog . error ( "Unexpected char [" + c + "] at position " + i + " in conversion patterrn." ) ; pc = new LiteralPatternConverter ( currentLiteral . toString ( ) ) ; currentLiteral . setLength ( 0 ) ; } addConverter ( pc ) ; } protected void addConverter ( PatternConverter pc ) { currentLiteral . setLength ( 0 ) ; addToList ( pc ) ; state = LITERAL_STATE ; formattingInfo . reset ( ) ; } private static class BasicPatternConverter extends PatternConverter { int type ; BasicPatternConverter ( FormattingInfo formattingInfo , int type ) { super ( formattingInfo ) ; this . type = type ; } public String convert ( LoggingEvent event ) { switch ( type ) { case RELATIVE_TIME_CONVERTER : return ( Long . toString ( event . timeStamp - LoggingEvent . getStartTime ( ) ) ) ; case THREAD_CONVERTER : return event . getThreadName ( ) ; case PRIORITY_CONVERTER : return event . priority . toString ( ) ; case NDC_CONVERTER : return event . getNDC ( ) ; case MESSAGE_CONVERTER : { return event . getRenderedMessage ( ) ; } default : return null ; } } } private static class LiteralPatternConverter extends PatternConverter { private String literal ; LiteralPatternConverter ( String value ) { literal = value ; } public final void format ( StringBuffer sbuf , LoggingEvent event ) { sbuf . append ( literal ) ; } public String convert ( LoggingEvent event ) { return literal ; } } private static class DatePatternConverter extends PatternConverter { private DateFormat df ; private Date date ; DatePatternConverter ( FormattingInfo formattingInfo , DateFormat df ) { super ( formattingInfo ) ; date = new Date ( ) ; this . df = df ; } public String convert ( LoggingEvent event ) { date . setTime ( event . timeStamp ) ; String converted = null ; try { converted = df . format ( date ) ; } catch ( Exception ex ) { LogLog . error ( "Error occured while converting date." , ex ) ; } return converted ; } } private class LocationPatternConverter extends PatternConverter { int type ; LocationPatternConverter ( FormattingInfo formattingInfo , int type ) { super ( formattingInfo ) ; this . type = type ; } public String convert ( LoggingEvent event ) { LocationInfo locationInfo = event . getLocationInformation ( ) ; switch ( type ) { case FULL_LOCATION_CONVERTER : return locationInfo . fullInfo ; case METHOD_LOCATION_CONVERTER : return locationInfo . getMethodName ( ) ; case LINE_LOCATION_CONVERTER : return locationInfo . getLineNumber ( ) ; case FILE_LOCATION_CONVERTER : return locationInfo . getFileName ( ) ; default : return null ; } } } private static abstract class NamedPatternConverter extends PatternConverter { int precision ; NamedPatternConverter ( FormattingInfo formattingInfo , int precision ) { super ( formattingInfo ) ; this . precision = precision ; } abstract String getFullyQualifiedName ( LoggingEvent event ) ; public String convert ( LoggingEvent event ) { String n = getFullyQualifiedName ( event ) ; if ( precision <= 0 ) return n ; else { int len = n . length ( ) ; int end = len - 1 ; for ( int i = precision ; i > 0 ; i -- ) { end = n . lastIndexOf ( '.' , end - 1 ) ; if ( end == - 1 ) return n ; } return n . substring ( end + 1 , len ) ; } } } private class ClassNamePatternConverter extends NamedPatternConverter { ClassNamePatternConverter ( FormattingInfo formattingInfo , int precision ) { super ( formattingInfo , precision ) ; } String getFullyQualifiedName ( LoggingEvent event ) { return event . getLocationInformation ( ) . getClassName ( ) ; } } private class CategoryPatternConverter extends NamedPatternConverter { CategoryPatternConverter ( FormattingInfo formattingInfo , int precision ) { super ( formattingInfo , precision ) ; } String getFullyQualifiedName ( LoggingEvent event ) { return event . categoryName ; } } } 	0	['8', '1', '0', '15', '41', '8', '4', '14', '2', '0.956043956', '693', '0.461538462', '3', '0', '0.375', '0', '0', '82.375', '21', '6.25', '0']
package org . apache . log4j . helpers ; import java . util . Calendar ; import java . util . TimeZone ; import java . util . Date ; import java . text . FieldPosition ; import java . text . ParsePosition ; import java . text . DateFormat ; import java . text . DateFormatSymbols ; public class ISO8601DateFormat extends AbsoluteTimeDateFormat { public ISO8601DateFormat ( ) { } public ISO8601DateFormat ( TimeZone timeZone ) { super ( timeZone ) ; } public StringBuffer format ( Date date , StringBuffer sbuf , FieldPosition fieldPosition ) { calendar . setTime ( date ) ; int year = calendar . get ( Calendar . YEAR ) ; sbuf . append ( year ) ; String month ; switch ( calendar . get ( Calendar . MONTH ) ) { case Calendar . JANUARY : month = "-01-" ; break ; case Calendar . FEBRUARY : month = "-02-" ; break ; case Calendar . MARCH : month = "-03-" ; break ; case Calendar . APRIL : month = "-04-" ; break ; case Calendar . MAY : month = "-05-" ; break ; case Calendar . JUNE : month = "-06-" ; break ; case Calendar . JULY : month = "-07-" ; break ; case Calendar . AUGUST : month = "-08-" ; break ; case Calendar . SEPTEMBER : month = "-09-" ; break ; case Calendar . OCTOBER : month = "-10-" ; break ; case Calendar . NOVEMBER : month = "-11-" ; break ; case Calendar . DECEMBER : month = "-12-" ; break ; default : month = "-NA-" ; break ; } sbuf . append ( month ) ; int day = calendar . get ( Calendar . DAY_OF_MONTH ) ; if ( day < 10 ) sbuf . append ( '0' ) ; sbuf . append ( day ) ; sbuf . append ( ' ' ) ; return super . format ( date , sbuf , fieldPosition ) ; } public Date parse ( java . lang . String s , ParsePosition pos ) { return null ; } } 	0	['4', '4', '0', '3', '12', '6', '2', '1', '4', '2', '99', '0', '0', '0.953488372', '0.357142857', '1', '3', '23.75', '3', '1', '0']
package org . apache . log4j . helpers ; import org . apache . log4j . spi . AppenderAttachable ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Appender ; import java . util . Vector ; import java . util . Enumeration ; public class AppenderAttachableImpl implements AppenderAttachable { protected Vector appenderList ; public void addAppender ( Appender newAppender ) { if ( newAppender == null ) return ; if ( appenderList == null ) { appenderList = new Vector ( 1 ) ; } if ( ! appenderList . contains ( newAppender ) ) appenderList . addElement ( newAppender ) ; } public int appendLoopOnAppenders ( LoggingEvent event ) { int size = 0 ; Appender appender ; if ( appenderList != null ) { size = appenderList . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { appender = ( Appender ) appenderList . elementAt ( i ) ; appender . doAppend ( event ) ; } } return size ; } public Enumeration getAllAppenders ( ) { if ( appenderList == null ) return null ; else return appenderList . elements ( ) ; } public Appender getAppender ( String name ) { if ( appenderList == null || name == null ) return null ; int size = appenderList . size ( ) ; Appender appender ; for ( int i = 0 ; i < size ; i ++ ) { appender = ( Appender ) appenderList . elementAt ( i ) ; if ( name . equals ( appender . getName ( ) ) ) return appender ; } return null ; } public void removeAllAppenders ( ) { if ( appenderList != null ) { int len = appenderList . size ( ) ; for ( int i = 0 ; i < len ; i ++ ) { Appender a = ( Appender ) appenderList . elementAt ( i ) ; a . close ( ) ; } appenderList . removeAllElements ( ) ; appenderList = null ; } } public void removeAppender ( Appender appender ) { if ( appender == null || appenderList == null ) return ; appenderList . removeElement ( appender ) ; } public void removeAppender ( String name ) { if ( name == null || appenderList == null ) return ; int size = appenderList . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( name . equals ( ( ( Appender ) appenderList . elementAt ( i ) ) . getName ( ) ) ) { appenderList . removeElementAt ( i ) ; break ; } } } } 	0	['8', '1', '0', '6', '22', '0', '3', '3', '8', '0.142857143', '176', '1', '0', '0', '0.40625', '0', '0', '20.875', '5', '3.125', '0']
package org . apache . log4j ; import org . apache . log4j . spi . OptionHandler ; import org . apache . log4j . spi . LoggingEvent ; public abstract class Layout implements OptionHandler { public final static String LINE_SEP = System . getProperty ( "line.separator" ) ; public final static int LINE_SEP_LEN = LINE_SEP . length ( ) ; abstract public String format ( LoggingEvent event ) ; public String getContentType ( ) { return "text/plain" ; } public String getHeader ( ) { return null ; } public String getFooter ( ) { return null ; } abstract public boolean ignoresThrowable ( ) ; } 	0	['10', '1', '4', '26', '13', '45', '24', '2', '9', '1', '28', '0', '0', '0', '0.407407407', '0', '0', '1.6', '1', '0.8', '0']
package org . apache . log4j . test ; class Base64 { final static int MAX_LINE = 76 ; static byte [ ] asciiEncoding = { 65 , 66 , 67 , 68 , 69 , 70 , 71 , 72 , 73 , 74 , 75 , 76 , 77 , 78 , 79 , 80 , 81 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 89 , 90 , 97 , 98 , 99 , 100 , 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 , 119 , 120 , 121 , 122 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 43 , 47 } ; static char [ ] charEnc = new char [ 64 ] ; static { for ( int i = 0 ; i < 26 ; i ++ ) { charEnc [ i ] = ( char ) ( 'A' + i ) ; charEnc [ i + 26 ] = ( char ) ( 'a' + i ) ; } for ( int i = 0 ; i < 10 ; i ++ ) { charEnc [ i + 52 ] = ( char ) ( '0' + i ) ; } charEnc [ 62 ] = '+' ; charEnc [ 63 ] = '/' ; } static String toString ( byte [ ] inbuf ) { return toString ( inbuf , 0 , inbuf . length ) ; } static String toString ( byte [ ] inbuf , int offset , int length ) { StringBuffer output = new StringBuffer ( ( length ) * 4 / 3 + 1 ) ; int in ; char [ ] out = new char [ 4 ] ; int i = offset ; boolean ended = false ; int last = offset + length ; int j ; int bitsRead ; while ( ! ended ) { in = 0 ; bitsRead = 0 ; for ( j = 0 ; j < 3 ; j ++ ) { if ( i == last ) { ended = true ; break ; } in = ( in << 8 ) | ( inbuf [ i ++ ] & 0xFF ) ; bitsRead += 8 ; } while ( bitsRead >= 6 ) { bitsRead -= 6 ; output . append ( charEnc [ ( in > > > bitsRead ) & 0x3F ] ) ; } if ( bitsRead == 4 ) { output . append ( charEnc [ ( in & 0x0F ) << 2 ] ) ; output . append ( "=" ) ; } else if ( bitsRead == 2 ) { output . append ( charEnc [ ( in & 0x03 ) << 4 ] ) ; output . append ( "==" ) ; } } return output . toString ( ) ; } public static void main ( String [ ] args ) { byte [ ] inbuf = new byte [ MAX_LINE ] ; while ( true ) { try { int read = System . in . read ( inbuf , 0 , MAX_LINE ) ; if ( read == - 1 ) break ; System . out . println ( "Read " + read + " chars." ) ; System . out . println ( Base64 . toString ( inbuf , 0 , read ) ) ; } catch ( Exception e ) { System . out . println ( "Exception " + e ) ; } } } } 	0	['5', '1', '0', '0', '15', '8', '0', '0', '1', '0.833333333', '479', '0', '0', '0', '0.3125', '0', '0', '94.2', '7', '2', '0']
package org . apache . log4j ; import org . apache . log4j . spi . LoggingEvent ; public class SimpleLayout extends Layout { StringBuffer sbuf = new StringBuffer ( 128 ) ; public SimpleLayout ( ) { } public String [ ] getOptionStrings ( ) { return new String [ 0 ] ; } public void setOption ( String option , String value ) { } public void activateOptions ( ) { } public String format ( LoggingEvent event ) { sbuf . setLength ( 0 ) ; sbuf . append ( event . priority . toString ( ) ) ; sbuf . append ( " - " ) ; sbuf . append ( event . getRenderedMessage ( ) ) ; sbuf . append ( LINE_SEP ) ; return sbuf . toString ( ) ; } public boolean ignoresThrowable ( ) { return true ; } } 	0	['6', '2', '0', '6', '13', '13', '3', '3', '6', '0.8', '54', '0', '0', '0.615384615', '0.444444444', '0', '0', '7.833333333', '1', '0.8333', '0']
package org . apache . log4j . performance ; import java . util . Date ; public class ConcatVsArray { static void Usage ( ) { System . err . println ( "Usage: java org.apache.log4j.performance.ConcatVsArray " + "string1 string2 runLength\n" + "       where runLength is an integer." ) ; System . exit ( 1 ) ; } public static void main ( String args [ ] ) { if ( args . length != 3 ) { Usage ( ) ; } String s1 = args [ 0 ] ; String s2 = args [ 1 ] ; int runLength = 0 ; try { runLength = Integer . parseInt ( args [ 2 ] ) ; } catch ( java . lang . NumberFormatException e ) { System . err . println ( e ) ; Usage ( ) ; } double micros ; String [ ] sa ; long before = new Date ( ) . getTime ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { sa = new String [ ] { s1 , s2 } ; } micros = ( new Date ( ) . getTime ( ) - before ) * 1000.0 / runLength ; System . out . println ( "The anonymous array loop took around " + micros + " microseconds." ) ; String s ; before = new Date ( ) . getTime ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { s = s1 + s2 ; } micros = ( new Date ( ) . getTime ( ) - before ) * 1000.0 / runLength ; System . out . println ( "The append loop took around " + micros + " microseconds." ) ; } } 	0	['3', '1', '0', '0', '14', '3', '0', '0', '2', '2', '133', '0', '0', '0', '0.333333333', '0', '0', '43.33333333', '4', '1.6667', '0']
package org . apache . log4j . nt . test ; import org . apache . log4j . Category ; import org . apache . log4j . Layout ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . Appender ; import org . apache . log4j . nt . NTEventLogAppender ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; import java . io . IOException ; public class NTMin { static Category cat = Category . getInstance ( NTMin . class . getName ( ) ) ; public static void main ( String argv [ ] ) { init ( ) ; test ( "someHost" ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + NTMin . class + "" ) ; System . exit ( 1 ) ; } static void init ( ) { BasicConfigurator . configure ( new NTEventLogAppender ( ) ) ; } static void test ( String host ) { NDC . push ( host ) ; int i = 0 ; cat . debug ( "Message " + i ++ ) ; cat . info ( "Message " + i ++ ) ; cat . warn ( "Message " + i ++ ) ; cat . error ( "Message " + i ++ ) ; cat . log ( Priority . FATAL , "Message " + i ++ ) ; cat . debug ( "Message " + i ++ , new Exception ( "Just testing." ) ) ; } } 	0	['7', '1', '0', '6', '30', '17', '0', '6', '2', '0.75', '144', '0', '1', '0', '0.277777778', '0', '0', '19.28571429', '2', '0.8571', '0']
package org . apache . log4j . helpers ; import java . io . Writer ; import java . io . FilterWriter ; import java . io . IOException ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . ErrorCode ; public class QuietWriter extends FilterWriter { protected ErrorHandler errorHandler ; public QuietWriter ( Writer writer , ErrorHandler errorHandler ) { super ( writer ) ; setErrorHandler ( errorHandler ) ; } public void write ( String string ) { try { out . write ( string ) ; } catch ( IOException e ) { errorHandler . error ( "Failed to write [" + string + "]." , e , ErrorCode . WRITE_FAILURE ) ; } } public void flush ( ) { try { out . flush ( ) ; } catch ( IOException e ) { errorHandler . error ( "Failed to flush writer," , e , ErrorCode . FLUSH_FAILURE ) ; } } public void setErrorHandler ( ErrorHandler eh ) { if ( eh == null ) { throw new IllegalArgumentException ( "Attempted to set null ErrorHandler." ) ; } else { this . errorHandler = eh ; } } } 	0	['4', '3', '2', '6', '12', '0', '5', '1', '4', '0', '57', '1', '1', '0.857142857', '0.5', '2', '2', '13', '2', '1', '0']
package org . apache . log4j . helpers ; import java . io . File ; import org . apache . log4j . helpers . LogLog ; public abstract class FileWatchdog extends Thread { static final public long DEFAULT_DELAY = 60000 ; protected String filename ; protected long delay = DEFAULT_DELAY ; File file ; long lastModif = 0 ; boolean warnedAlready = false ; boolean interrupted = false ; protected FileWatchdog ( String filename ) { this . filename = filename ; file = new File ( filename ) ; setDaemon ( true ) ; checkAndConfigure ( ) ; } public void setDelay ( long delay ) { this . delay = delay ; } abstract protected void doOnChange ( ) ; protected void checkAndConfigure ( ) { boolean fileExists ; try { fileExists = file . exists ( ) ; } catch ( SecurityException e ) { LogLog . warn ( "Was not allowed to read check file existance, file:[" + filename + "]." ) ; interrupted = true ; return ; } if ( fileExists ) { long l = file . lastModified ( ) ; if ( l > lastModif ) { lastModif = l ; doOnChange ( ) ; warnedAlready = false ; } } else { if ( ! warnedAlready ) { LogLog . debug ( "[" + filename + "] does not exist." ) ; warnedAlready = true ; } } } public void run ( ) { while ( ! interrupted ) { try { Thread . currentThread ( ) . sleep ( delay ) ; } catch ( InterruptedException e ) { } checkAndConfigure ( ) ; } } } 	0	['5', '2', '0', '2', '17', '0', '1', '1', '2', '0.607142857', '120', '0.285714286', '0', '0.938461538', '0.466666667', '1', '1', '21.6', '3', '1.4', '0']
package org . apache . log4j . net . test ; import org . apache . log4j . * ; import java . io . IOException ; import java . io . InputStreamReader ; public class SMTPMin { static Category cat = Category . getInstance ( SMTPMin . class ) ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) init ( argv [ 0 ] ) ; else usage ( "Wrong number of arguments." ) ; NDC . push ( "some context" ) ; test ( ) ; } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + SMTPMin . class . getName ( ) + " configFile" ) ; System . exit ( 1 ) ; } static void init ( String configFile ) { PropertyConfigurator . configure ( configFile ) ; } static void test ( ) { int i = 0 ; cat . debug ( "Message " + i ++ ) ; cat . debug ( "Message " + i ++ , new Exception ( "Just testing." ) ) ; cat . info ( "Message " + i ++ ) ; cat . warn ( "Message " + i ++ ) ; cat . error ( "Message " + i ++ ) ; cat . log ( Priority . FATAL , "Message " + i ++ ) ; Category . shutdown ( ) ; Thread . currentThread ( ) . getThreadGroup ( ) . list ( ) ; } } 	0	['7', '1', '0', '4', '32', '17', '0', '4', '2', '0.666666667', '155', '0', '1', '0', '0.277777778', '0', '0', '20.85714286', '2', '1', '0']
package org . apache . log4j . performance ; public class NewVsSetLen { static String s ; static int BIGBUF_LEN = 1048576 ; static int SBUF_LEN = 256 ; static int RUN_LENGTH = BIGBUF_LEN / 4 ; static char [ ] sbuf = new char [ SBUF_LEN ] ; static char [ ] bigbuf = new char [ BIGBUF_LEN ] ; { for ( int i = 0 ; i < SBUF_LEN ; i ++ ) { sbuf [ i ] = ( char ) ( i ) ; } for ( int i = 0 ; i < BIGBUF_LEN ; i ++ ) { bigbuf [ i ] = ( char ) ( i ) ; } } static public void main ( String [ ] args ) { int t ; for ( int len = SBUF_LEN ; len <= BIGBUF_LEN ; len *= 4 , RUN_LENGTH /= 4 ) { System . out . println ( "<td>" + len + "\n" ) ; for ( int second = 0 ; second < 16 ; ) { System . out . println ( "SECOND loop=" + second + ", RUN_LENGTH=" + RUN_LENGTH + ", len=" + len ) ; t = ( int ) newBuffer ( len , second ) ; ; System . out . print ( "<td>" + t ) ; t = ( int ) setLen ( len , second ) ; System . out . println ( " <td>" + t + " \n" ) ; if ( second == 0 ) { second = 1 ; } else { second *= 2 ; } } } } static double newBuffer ( int size , int second ) { long before = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { StringBuffer buf = new StringBuffer ( SBUF_LEN ) ; buf . append ( sbuf , 0 , sbuf . length ) ; buf . append ( bigbuf , 0 , size ) ; s = buf . toString ( ) ; } for ( int x = 0 ; x < second ; x ++ ) { StringBuffer buf = new StringBuffer ( SBUF_LEN ) ; buf . append ( sbuf , 0 , SBUF_LEN ) ; s = buf . toString ( ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } static double setLen ( int size , int second ) { long before = System . currentTimeMillis ( ) ; StringBuffer buf = new StringBuffer ( SBUF_LEN ) ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { buf . append ( sbuf , 0 , sbuf . length ) ; buf . append ( bigbuf , 0 , size ) ; s = buf . toString ( ) ; buf . setLength ( 0 ) ; } for ( int x = 0 ; x < second ; x ++ ) { buf . append ( sbuf , 0 , SBUF_LEN ) ; s = buf . toString ( ) ; buf . setLength ( 0 ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } } 	0	['5', '1', '0', '0', '16', '0', '0', '0', '2', '0.208333333', '268', '0', '0', '0', '0.333333333', '0', '0', '51.4', '4', '2', '0']
package org . apache . log4j . helpers ; import org . apache . log4j . spi . LoggingEvent ; public abstract class PatternConverter { public PatternConverter next ; int min = - 1 ; int max = 0x7FFFFFFF ; boolean leftAlign = false ; protected PatternConverter ( ) { } protected PatternConverter ( FormattingInfo fi ) { min = fi . min ; max = fi . max ; leftAlign = fi . leftAlign ; } abstract protected String convert ( LoggingEvent event ) ; public void format ( StringBuffer sbuf , LoggingEvent e ) { String s = convert ( e ) ; if ( s == null ) { if ( 0 < min ) spacePad ( sbuf , min ) ; return ; } int len = s . length ( ) ; if ( len > max ) sbuf . append ( s . substring ( len - max ) ) ; else if ( len < min ) { if ( leftAlign ) { sbuf . append ( s ) ; spacePad ( sbuf , min - len ) ; } else { spacePad ( sbuf , min - len ) ; sbuf . append ( s ) ; } } else sbuf . append ( s ) ; } static String [ ] SPACES = { " " , "  " , "    " , "        " , "                " , "                                " } ; public void spacePad ( StringBuffer sbuf , int length ) { while ( length >= 32 ) { sbuf . append ( SPACES [ 5 ] ) ; length -= 32 ; } for ( int i = 4 ; i >= 0 ; i -- ) { if ( ( length & ( 1 << i ) ) != 0 ) { sbuf . append ( SPACES [ i ] ) ; } } } } 	0	['6', '1', '5', '9', '10', '7', '7', '2', '2', '0.72', '174', '0', '1', '0', '0.44', '0', '0', '27.16666667', '6', '1.8333', '0']
package org . apache . log4j . test ; import java . io . * ; import org . apache . log4j . config . PropertyPrinter ; public class PrintProperties { public static void main ( String [ ] args ) { new PropertyPrinter ( new PrintWriter ( System . out ) , true ) ; } } 	0	['2', '1', '0', '1', '5', '1', '0', '1', '2', '2', '15', '0', '0', '0', '0.5', '0', '0', '6.5', '1', '0.5', '0']
package org . apache . log4j . spi ; import org . apache . log4j . Appender ; import java . util . Enumeration ; public interface AppenderAttachable { public void addAppender ( Appender newAppender ) ; public Enumeration getAllAppenders ( ) ; public Appender getAppender ( String name ) ; void removeAllAppenders ( ) ; void removeAppender ( Appender appender ) ; void removeAppender ( String name ) ; } 	0	['6', '1', '0', '4', '6', '15', '3', '1', '6', '2', '6', '0', '0', '0', '0.555555556', '0', '0', '0', '1', '1', '0']
package org . apache . log4j . helpers ; public class LogLog { public static final String DEBUG_KEY = "log4j.debug" ; public static final String CONFIG_DEBUG_KEY = "log4j.configDebug" ; protected static boolean debugEnabled = false ; private static boolean quietMode = false ; private static final String PREFIX = "log4j: " ; private static final String ERR_PREFIX = "log4j:ERROR " ; private static final String WARN_PREFIX = "log4j:WARN " ; static { String key = OptionConverter . getSystemProperty ( DEBUG_KEY , null ) ; if ( key == null ) { key = OptionConverter . getSystemProperty ( CONFIG_DEBUG_KEY , null ) ; } if ( key != null ) { debugEnabled = OptionConverter . toBoolean ( key , true ) ; } } static public void setInternalDebugging ( boolean enabled ) { debugEnabled = enabled ; } public static void debug ( String msg ) { if ( debugEnabled && ! quietMode ) { System . out . println ( PREFIX + msg ) ; } } public static void debug ( String msg , Throwable t ) { if ( debugEnabled && ! quietMode ) { System . out . println ( PREFIX + msg ) ; if ( t != null ) t . printStackTrace ( System . out ) ; } } public static void error ( String msg ) { if ( quietMode ) return ; System . err . println ( ERR_PREFIX + msg ) ; } public static void error ( String msg , Throwable t ) { if ( quietMode ) return ; System . err . println ( ERR_PREFIX + msg ) ; if ( t != null ) { t . printStackTrace ( ) ; } } public static void setQuietMode ( boolean quietMode ) { LogLog . quietMode = quietMode ; } public static void warn ( String msg ) { if ( quietMode ) return ; System . err . println ( WARN_PREFIX + msg ) ; } public static void warn ( String msg , Throwable t ) { if ( quietMode ) return ; System . err . println ( WARN_PREFIX + msg ) ; if ( t != null ) { t . printStackTrace ( ) ; } } } 	0	['10', '1', '0', '34', '19', '0', '34', '1', '9', '0.920634921', '146', '0.714285714', '0', '0', '0.333333333', '0', '0', '12.9', '4', '1.9', '0']
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . Layout ; import org . apache . log4j . Appender ; import org . apache . log4j . ConsoleAppender ; import org . apache . log4j . net . SyslogAppender ; import org . apache . log4j . SimpleLayout ; import org . apache . log4j . TTCCLayout ; import org . apache . log4j . Priority ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . helpers . AbsoluteTimeDateFormat ; import java . io . IOException ; public class Min { public static void main ( String argv [ ] ) { if ( argv . length == 1 ) { ProgramInit ( argv [ 0 ] ) ; } else { Usage ( "Wrong number of arguments." ) ; } test1 ( ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java org.apache.log4j.test.Min " + "simple|ttcc" ) ; System . exit ( 1 ) ; } static void ProgramInit ( String layoutType ) { Appender appender = null ; Layout layout = null ; if ( layoutType . equals ( "simple" ) ) layout = new SimpleLayout ( ) ; else if ( layoutType . equals ( "ttcc" ) ) { layout = new TTCCLayout ( AbsoluteTimeDateFormat . DATE_AND_TIME_DATE_FORMAT ) ; } else Usage ( "Wrong layoutType [" + layoutType + "]." ) ; appender = new ConsoleAppender ( layout , "System.out" ) ; BasicConfigurator . configure ( appender ) ; } static void test1 ( ) { int i = 0 ; Category ERR = Category . getInstance ( "ERR" ) ; ERR . setPriority ( Priority . ERROR ) ; Category INF = Category . getInstance ( "INF" ) ; INF . setPriority ( Priority . INFO ) ; Category INF_ERR = Category . getInstance ( "INF.ERR" ) ; INF_ERR . setPriority ( Priority . ERROR ) ; Category DEB = Category . getInstance ( "DEB" ) ; DEB . setPriority ( Priority . DEBUG ) ; Category INF_UNDEF = Category . getInstance ( "INF.UNDEF" ) ; Category INF_ERR_UNDEF = Category . getInstance ( "INF.ERR.UNDEF" ) ; Category UNDEF = Category . getInstance ( "UNDEF" ) ; ERR . log ( Priority . FATAL , "Message " + i ) ; i ++ ; ERR . error ( "Message " + i ) ; i ++ ; INF . log ( Priority . FATAL , "Message " + i ) ; i ++ ; INF . error ( "Message " + i ) ; i ++ ; INF . warn ( "Message " + i ) ; i ++ ; INF . info ( "Message " + i ) ; i ++ ; INF_UNDEF . log ( Priority . FATAL , "Message " + i ) ; i ++ ; INF_UNDEF . error ( "Message " + i ) ; i ++ ; INF_UNDEF . warn ( "Message " + i ) ; i ++ ; INF_UNDEF . info ( "Message " + i ) ; i ++ ; INF_ERR . log ( Priority . FATAL , "Message " + i ) ; i ++ ; INF_ERR . error ( "Message " + i ) ; i ++ ; INF_ERR_UNDEF . log ( Priority . FATAL , "Message " + i ) ; i ++ ; INF_ERR_UNDEF . error ( "Message " + i ) ; i ++ ; DEB . log ( Priority . FATAL , "Message " + i ) ; i ++ ; DEB . error ( "Message " + i ) ; i ++ ; DEB . warn ( "Message " + i ) ; i ++ ; DEB . info ( "Message " + i ) ; i ++ ; DEB . debug ( "Message " + i ) ; i ++ ; UNDEF . log ( Priority . FATAL , "Message " + i ) ; i ++ ; UNDEF . error ( "Message " + i ) ; i ++ ; UNDEF . warn ( "Message " + i ) ; i ++ ; UNDEF . info ( "Message " + i ) ; i ++ ; UNDEF . debug ( "Message " + i , new Exception ( "Just testing." ) ) ; i ++ ; ERR . warn ( "Message " + i ) ; i ++ ; ERR . info ( "Message " + i ) ; i ++ ; ERR . debug ( "Message " + i ) ; i ++ ; INF . debug ( "Message " + i ) ; i ++ ; INF_UNDEF . debug ( "Message " + i ) ; i ++ ; INF_ERR . warn ( "Message " + i ) ; i ++ ; INF_ERR . info ( "Message " + i ) ; i ++ ; INF_ERR . debug ( "Message " + i ) ; i ++ ; INF_ERR_UNDEF . warn ( "Message " + i ) ; i ++ ; INF_ERR_UNDEF . info ( "Message " + i ) ; i ++ ; INF_ERR_UNDEF . debug ( "Message " + i ) ; i ++ ; INF . info ( "Messages should bear numbers 0 through 23." ) ; } } 	0	['5', '1', '0', '8', '26', '10', '0', '8', '2', '2', '508', '0', '0', '0', '0.266666667', '0', '0', '100.6', '3', '1.4', '0']
package org . apache . log4j . spi ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . helpers . LogLog ; final public class RootCategory extends Category { public RootCategory ( Priority priority ) { super ( "root" ) ; setPriority ( priority ) ; } final public Priority getChainedPriority ( ) { return priority ; } final public void setPriority ( Priority priority ) { if ( priority == null ) { LogLog . error ( "You have tried to set a null priority to root." , new Throwable ( ) ) ; } else { this . priority = priority ; } } } 	0	['3', '2', '0', '4', '6', '3', '2', '3', '3', '2', '25', '0', '0', '0.959183673', '0.833333333', '1', '5', '7.333333333', '2', '1', '0']
package org . apache . log4j . test ; import java . net . Socket ; import java . net . ServerSocket ; import java . io . IOException ; import org . apache . log4j . Category ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . net . SocketNode ; import org . apache . log4j . net . SocketServer ; public class ShortSocketServer { static Category cat = Category . getInstance ( ShortSocketServer . class . getName ( ) ) ; static int port ; public static void main ( String argv [ ] ) { if ( argv . length == 2 ) { init ( argv [ 0 ] , argv [ 1 ] ) ; } else { usage ( "Wrong number of arguments." ) ; } try { LogLog . debug ( "Listening on port " + port ) ; ServerSocket serverSocket = new ServerSocket ( port ) ; LogLog . debug ( "Waiting to accept a new client." ) ; Socket socket = serverSocket . accept ( ) ; LogLog . debug ( "Connected to client at " + socket . getInetAddress ( ) ) ; LogLog . debug ( "Starting new socket node." ) ; SocketNode sn = new SocketNode ( socket , Category . getDefaultHierarchy ( ) ) ; Thread t = new Thread ( sn ) ; t . start ( ) ; t . join ( ) ; } catch ( Exception e ) { cat . error ( "Error while in main." , e ) ; } } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + ShortSocketServer . class . getName ( ) + " port configFile" ) ; System . exit ( 1 ) ; } static void init ( String portStr , String configFile ) { try { port = Integer . parseInt ( portStr ) ; } catch ( java . lang . NumberFormatException e ) { e . printStackTrace ( ) ; usage ( "Could not interpret port number [" + portStr + "]." ) ; } PropertyConfigurator . configure ( configFile ) ; } } 	0	['6', '1', '0', '5', '32', '9', '0', '5', '2', '0.666666667', '148', '0', '1', '0', '0.333333333', '0', '0', '23.16666667', '2', '1', '0']
package org . apache . log4j . helpers ; import java . io . Writer ; import java . io . FilterWriter ; import java . io . IOException ; import org . apache . log4j . spi . ErrorHandler ; public class SyslogQuietWriter extends QuietWriter { int syslogFacility ; int priority ; public SyslogQuietWriter ( Writer writer , int syslogFacility , ErrorHandler eh ) { super ( writer , eh ) ; this . syslogFacility = syslogFacility ; } public void setPriority ( int priority ) { this . priority = priority ; } public void setSyslogFacility ( int syslogFacility ) { this . syslogFacility = syslogFacility ; } public void write ( String string ) { super . write ( "<" + ( syslogFacility | priority ) + ">" + string ) ; } } 	0	['4', '4', '0', '3', '10', '0', '1', '2', '4', '0.5', '41', '0', '0', '0.875', '0.5', '2', '2', '8.75', '1', '0.75', '0']
package org . apache . log4j . performance ; public class SystemTime { static int RUN_LENGTH = 1000000 ; static public void main ( String [ ] args ) { double t = systemCurrentTimeLoop ( ) ; System . out . println ( "Average System.currentTimeMillis() call took " + t ) ; t = currentThreadNameloop ( ) ; System . out . println ( "Average Thread.currentThread().getName() call took " + t ) ; } static double systemCurrentTimeLoop ( ) { long before = System . currentTimeMillis ( ) ; long l ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { l = System . currentTimeMillis ( ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } static double currentThreadNameloop ( ) { long before = System . currentTimeMillis ( ) ; String t ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { t = Thread . currentThread ( ) . getName ( ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } } 	0	['5', '1', '0', '0', '14', '4', '0', '0', '2', '0.25', '80', '0', '0', '0', '0.25', '0', '0', '14.8', '2', '1', '0']
package org . apache . log4j . or ; import org . apache . log4j . Layout ; import org . apache . log4j . helpers . LogLog ; import javax . jms . Message ; import javax . jms . JMSException ; import javax . jms . DeliveryMode ; import java . util . Enumeration ; public class MessageRenderer implements ObjectRenderer { public MessageRenderer ( ) { } public String doRender ( Object o ) { if ( o instanceof Message ) { StringBuffer sbuf = new StringBuffer ( ) ; Message m = ( Message ) o ; try { sbuf . append ( "DeliveryMode=" ) ; switch ( m . getJMSDeliveryMode ( ) ) { case DeliveryMode . NON_PERSISTENT : sbuf . append ( "NON_PERSISTENT" ) ; break ; case DeliveryMode . PERSISTENT : sbuf . append ( "PERSISTENT" ) ; break ; default : sbuf . append ( "UNKNOWN" ) ; } sbuf . append ( ", CorrelationID=" ) ; sbuf . append ( m . getJMSCorrelationID ( ) ) ; sbuf . append ( ", Destination=" ) ; sbuf . append ( m . getJMSDestination ( ) ) ; sbuf . append ( ", Expiration=" ) ; sbuf . append ( m . getJMSExpiration ( ) ) ; sbuf . append ( ", MessageID=" ) ; sbuf . append ( m . getJMSMessageID ( ) ) ; sbuf . append ( ", Priority=" ) ; sbuf . append ( m . getJMSPriority ( ) ) ; sbuf . append ( ", Redelivered=" ) ; sbuf . append ( m . getJMSRedelivered ( ) ) ; sbuf . append ( ", ReplyTo=" ) ; sbuf . append ( m . getJMSReplyTo ( ) ) ; sbuf . append ( ", Timestamp=" ) ; sbuf . append ( m . getJMSTimestamp ( ) ) ; sbuf . append ( ", Type=" ) ; sbuf . append ( m . getJMSType ( ) ) ; } catch ( JMSException e ) { LogLog . error ( "Could not parse Message." , e ) ; } return sbuf . toString ( ) ; } else { return o . toString ( ) ; } } } 	0	['2', '1', '0', '3', '22', '1', '1', '2', '2', '2', '128', '0', '0', '0', '0.75', '0', '0', '63', '5', '2.5', '0']
package org . apache . log4j . helpers ; import java . io . Writer ; import java . net . DatagramSocket ; import java . net . InetAddress ; import java . net . DatagramPacket ; import java . net . UnknownHostException ; import java . net . SocketException ; import java . io . IOException ; public class SyslogWriter extends Writer { final int SYSLOG_PORT = 514 ; static String syslogHost ; private InetAddress address ; private DatagramSocket ds ; public SyslogWriter ( String syslogHost ) { this . syslogHost = syslogHost ; try { this . address = InetAddress . getByName ( syslogHost ) ; } catch ( UnknownHostException e ) { LogLog . error ( "Could not find " + syslogHost + ". All logging will FAIL." , e ) ; } try { this . ds = new DatagramSocket ( ) ; } catch ( SocketException e ) { e . printStackTrace ( ) ; LogLog . error ( "Could not instantiate DatagramSocket to " + syslogHost + ". All logging will FAIL." , e ) ; } } public void write ( char [ ] buf , int off , int len ) throws IOException { this . write ( new String ( buf , off , len ) ) ; } public void write ( String string ) throws IOException { DatagramPacket packet = new DatagramPacket ( string . getBytes ( ) , string . length ( ) , address , SYSLOG_PORT ) ; if ( this . ds != null ) ds . send ( packet ) ; } public void flush ( ) { } public void close ( ) { } } 	0	['5', '2', '0', '2', '18', '8', '1', '1', '5', '0.75', '88', '0.5', '0', '0.764705882', '0.45', '1', '2', '15.8', '1', '0.8', '0']
package org . apache . log4j . performance ; import java . io . Writer ; import java . io . IOException ; public class NOPWriter extends Writer { public void write ( char [ ] cbuf ) throws IOException { } public void write ( char [ ] cbuf , int off , int len ) throws IOException { } public void write ( int b ) throws IOException { } public void write ( String s ) throws IOException { } public void write ( String s , int off , int len ) throws IOException { } public void flush ( ) throws IOException { } public void close ( ) throws IOException { System . err . println ( "Close called." ) ; } } 	0	['8', '2', '0', '0', '10', '28', '0', '0', '8', '2', '21', '0', '0', '0.65', '0.46875', '1', '2', '1.625', '1', '0.875', '0']
package org . apache . log4j ; import org . apache . log4j . spi . Filter ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . LoggingEvent ; public interface Appender { void addFilter ( Filter newFilter ) ; public Filter getFilter ( ) ; public void clearFilters ( ) ; public void close ( ) ; public void doAppend ( LoggingEvent event ) ; public String getName ( ) ; public void setErrorHandler ( ErrorHandler errorHandler ) ; public ErrorHandler getErrorHandler ( ) ; public void setLayout ( Layout layout ) ; public Layout getLayout ( ) ; public void setName ( String name ) ; public boolean requiresLayout ( ) ; } 	0	['12', '1', '0', '21', '12', '66', '17', '4', '12', '2', '12', '0', '0', '0', '0.236111111', '0', '0', '0', '1', '1', '0']
package org . apache . log4j . test ; import org . apache . log4j . * ; public class CategoryWrapper { Category c ; static String FQCN = CategoryWrapper . class . getName ( ) ; CategoryWrapper ( String name ) { c = Category . getInstance ( name ) ; } public static void main ( String argv [ ] ) { Layout layout = new PatternLayout ( "%p [%t] %C %F - %m\n" ) ; Appender out = new ConsoleAppender ( layout , ConsoleAppender . SYSTEM_OUT ) ; CategoryWrapper w1 = new CategoryWrapper ( "c1" ) ; w1 . addAppender ( out ) ; w1 . print ( "hello" ) ; } public void addAppender ( Appender appender ) { c . addAppender ( appender ) ; } public void print ( String msg ) { c . log ( FQCN + ".print" , Priority . DEBUG , msg , null ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + CategoryWrapper . class . getName ( ) + " fileName" ) ; System . exit ( 1 ) ; } } 	0	['7', '1', '0', '6', '22', '11', '0', '6', '3', '0.666666667', '107', '0', '1', '0', '0.375', '0', '0', '13.85714286', '2', '0.8571', '0']
package org . apache . log4j . helpers ; import org . apache . log4j . spi . ErrorHandler ; public class OnlyOnceErrorHandler implements ErrorHandler { final String WARN_PREFIX = "log4j warning: " ; final String ERROR_PREFIX = "log4j error: " ; boolean firstTime = true ; public String [ ] getOptionStrings ( ) { return null ; } public void setOption ( String key , String value ) { } public void activateOptions ( ) { } public void error ( String message , Exception e , int errorCode ) { if ( firstTime ) { LogLog . error ( message , e ) ; firstTime = false ; } } public void error ( String message ) { if ( firstTime ) { LogLog . error ( message ) ; firstTime = false ; } } } 	0	['6', '1', '0', '3', '9', '9', '1', '2', '6', '0.866666667', '44', '0', '0', '0', '0.458333333', '0', '0', '5.833333333', '2', '1.1667', '0']
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . BasicConfigurator ; public class Hello { static Category cat = Category . getInstance ( Hello . class ) ; public static void main ( String argv [ ] ) { BasicConfigurator . configure ( ) ; cat . debug ( "Hello world." ) ; cat . info ( "What a beatiful day." ) ; } } 	0	['4', '1', '0', '2', '12', '4', '0', '2', '2', '0.833333333', '38', '0', '1', '0', '0.333333333', '0', '0', '8', '1', '0.5', '0']
package org . apache . log4j . helpers ; import java . io . File ; import java . io . Writer ; import java . io . FileWriter ; import java . io . FilterWriter ; import java . io . IOException ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . ErrorCode ; public class CountingQuietWriter extends QuietWriter { protected long count ; public CountingQuietWriter ( Writer writer , ErrorHandler eh ) { super ( writer , eh ) ; } public void write ( String string ) { try { out . write ( string ) ; count += string . length ( ) ; } catch ( IOException e ) { errorHandler . error ( "Write failure." , e , ErrorCode . WRITE_FAILURE ) ; } } public long getCount ( ) { return count ; } public void setCount ( long count ) { this . count = count ; } } 	0	['4', '4', '0', '3', '8', '0', '1', '2', '4', '0.333333333', '38', '1', '0', '0.875', '0.4', '2', '2', '8.25', '1', '0.75', '0']
package org . apache . log4j . test ; import org . apache . log4j . * ; import java . util . * ; import java . text . * ; public class L7D { static ResourceBundle [ ] bundles ; public static void main ( String args [ ] ) { if ( args . length == 3 ) init ( args [ 0 ] , args [ 1 ] , args [ 2 ] ) ; else Usage ( "Wrong number of arguments." ) ; test ( ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + L7D . class . getName ( ) + "configFile ISO639LanguageCode ISO2166CountryCode" ) ; System . exit ( 1 ) ; } static void init ( String configFile , String lanCode , String countryCode ) { PropertyConfigurator . configure ( configFile ) ; bundles = new ResourceBundle [ 3 ] ; try { bundles [ 0 ] = ResourceBundle . getBundle ( "L7D" , new Locale ( "en" , "US" ) ) ; bundles [ 1 ] = ResourceBundle . getBundle ( "L7D" , new Locale ( "fr" , "FR" ) ) ; bundles [ 2 ] = ResourceBundle . getBundle ( "L7D" , new Locale ( "fr" , "CH" ) ) ; } catch ( MissingResourceException e ) { e . printStackTrace ( ) ; } } static void test ( ) { Category root = Category . getRoot ( ) ; for ( int i = 0 ; i < bundles . length ; i ++ ) { root . setResourceBundle ( bundles [ i ] ) ; root . l7dlog ( Priority . DEBUG , "bogus1" , null ) ; root . l7dlog ( Priority . INFO , "test" , null ) ; root . l7dlog ( Priority . WARN , "hello_world" , null ) ; root . l7dlog ( Priority . DEBUG , "msg1" , new Object [ ] { new Integer ( i + 1 ) , "log4j" } , null ) ; root . l7dlog ( Priority . ERROR , "bogusMsg" , new Object [ ] { new Integer ( i + 1 ) , "log4j" } , null ) ; root . l7dlog ( Priority . ERROR , "msg1" , new Object [ ] { new Integer ( i + 1 ) , "log4j" } , null ) ; root . l7dlog ( Priority . INFO , "bogus2" , null ) ; } } } 	0	['6', '1', '0', '3', '25', '13', '0', '3', '2', '0.7', '202', '0', '0', '0', '0.277777778', '0', '0', '32.33333333', '2', '1.3333', '0']
package org . apache . log4j . spi ; public interface TriggeringEventEvaluator { public boolean isTriggeringEvent ( LoggingEvent event ) ; } 	0	['1', '1', '0', '3', '1', '0', '2', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . log4j . config ; public class PropertySetterException extends Exception { protected Throwable rootCause ; public PropertySetterException ( String msg ) { super ( msg ) ; } public PropertySetterException ( Throwable rootCause ) { super ( ) ; this . rootCause = rootCause ; } public String getMessage ( ) { String msg = super . getMessage ( ) ; if ( msg == null && rootCause != null ) { msg = rootCause . getMessage ( ) ; } return msg ; } } 	0	['3', '3', '0', '1', '6', '1', '1', '0', '3', '0.5', '28', '1', '0', '0.944444444', '0.555555556', '1', '1', '8', '3', '1', '0']
package org . apache . log4j . helpers ; import java . util . Enumeration ; import java . util . NoSuchElementException ; public class NullEnumeration implements Enumeration { private static final NullEnumeration instance = new NullEnumeration ( ) ; private NullEnumeration ( ) { } public static NullEnumeration getInstance ( ) { return instance ; } public boolean hasMoreElements ( ) { return false ; } public Object nextElement ( ) { throw new NoSuchElementException ( ) ; } } 	0	['5', '1', '0', '1', '7', '8', '1', '0', '3', '0.75', '22', '1', '1', '0', '0.75', '0', '0', '3.2', '1', '0.6', '0']
