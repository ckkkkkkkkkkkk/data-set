package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; public class ASTMulNode extends ASTMathNode { public ASTMulNode ( int id ) { super ( id ) ; } public ASTMulNode ( Parser p , int id ) { super ( p , id ) ; } public Number perform ( Number left , Number right , InternalContextAdapter context ) { return MathUtils . multiply ( left , right ) ; } } 	0	['3', '3', '0', '7', '6', '3', '4', '4', '3', '2', '16', '0', '0', '0.972222222', '0.533333333', '1', '1', '4.333333333', '1', '0.3333', '0']
package org . apache . velocity . runtime . resource . loader ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; import java . io . ByteArrayInputStream ; import java . io . InputStream ; import java . io . UnsupportedEncodingException ; import org . apache . commons . collections . ExtendedProperties ; import org . apache . commons . lang . StringUtils ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . runtime . resource . Resource ; import org . apache . velocity . runtime . resource . util . StringResource ; import org . apache . velocity . runtime . resource . util . StringResourceRepository ; import org . apache . velocity . runtime . resource . util . StringResourceRepositoryImpl ; import org . apache . velocity . util . ClassUtils ; public class StringResourceLoader extends ResourceLoader { public static final String REPOSITORY_STATIC = "repository.static" ; public static final boolean REPOSITORY_STATIC_DEFAULT = true ; public static final String REPOSITORY_CLASS = "repository.class" ; public static final String REPOSITORY_CLASS_DEFAULT = StringResourceRepositoryImpl . class . getName ( ) ; public static final String REPOSITORY_NAME = "repository.name" ; public static final String REPOSITORY_NAME_DEFAULT = StringResourceRepository . class . getName ( ) ; public static final String REPOSITORY_ENCODING = "repository.encoding" ; public static final String REPOSITORY_ENCODING_DEFAULT = "UTF-8" ; protected static final Map STATIC_REPOSITORIES = Collections . synchronizedMap ( new HashMap ( ) ) ; public static StringResourceRepository getRepository ( ) { return getRepository ( REPOSITORY_NAME_DEFAULT ) ; } public static StringResourceRepository getRepository ( String name ) { return ( StringResourceRepository ) STATIC_REPOSITORIES . get ( name ) ; } public static void setRepository ( String name , StringResourceRepository repo ) { STATIC_REPOSITORIES . put ( name , repo ) ; } public static StringResourceRepository removeRepository ( String name ) { return ( StringResourceRepository ) STATIC_REPOSITORIES . remove ( name ) ; } public static void clearRepositories ( ) { STATIC_REPOSITORIES . clear ( ) ; } protected StringResourceRepository repository ; public void init ( final ExtendedProperties configuration ) { log . trace ( "StringResourceLoader : initialization starting." ) ; String repoClass = configuration . getString ( REPOSITORY_CLASS , REPOSITORY_CLASS_DEFAULT ) ; String repoName = configuration . getString ( REPOSITORY_NAME , REPOSITORY_NAME_DEFAULT ) ; boolean isStatic = configuration . getBoolean ( REPOSITORY_STATIC , REPOSITORY_STATIC_DEFAULT ) ; String encoding = configuration . getString ( REPOSITORY_ENCODING ) ; if ( isStatic ) { this . repository = getRepository ( repoName ) ; if ( repository != null && log . isDebugEnabled ( ) ) { log . debug ( "Loaded repository '" + repoName + "' from static repo store" ) ; } } else { this . repository = ( StringResourceRepository ) rsvc . getApplicationAttribute ( repoName ) ; if ( repository != null && log . isDebugEnabled ( ) ) { log . debug ( "Loaded repository '" + repoName + "' from application attributes" ) ; } } if ( this . repository == null ) { this . repository = createRepository ( repoClass , encoding ) ; if ( isStatic ) { setRepository ( repoName , this . repository ) ; } else { rsvc . setApplicationAttribute ( repoName , this . repository ) ; } } else { if ( ! this . repository . getClass ( ) . getName ( ) . equals ( repoClass ) ) { log . debug ( "Cannot change class of string repository '" + repoName + "' from " + this . repository . getClass ( ) . getName ( ) + " to " + repoClass + ". The change will be ignored." ) ; } if ( encoding != null && ! this . repository . getEncoding ( ) . equals ( encoding ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Changing the default encoding of string repository '" + repoName + "' from " + this . repository . getEncoding ( ) + " to " + encoding ) ; } this . repository . setEncoding ( encoding ) ; } } log . trace ( "StringResourceLoader : initialization complete." ) ; } public StringResourceRepository createRepository ( final String className , final String encoding ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Creating string repository using class " + className + "..." ) ; } StringResourceRepository repo ; try { repo = ( StringResourceRepository ) ClassUtils . getNewInstance ( className ) ; } catch ( ClassNotFoundException cnfe ) { throw new VelocityException ( "Could not find '" + className + "'" , cnfe ) ; } catch ( IllegalAccessException iae ) { throw new VelocityException ( "Could not access '" + className + "'" , iae ) ; } catch ( InstantiationException ie ) { throw new VelocityException ( "Could not instantiate '" + className + "'" , ie ) ; } if ( encoding != null ) { repo . setEncoding ( encoding ) ; } else { repo . setEncoding ( REPOSITORY_ENCODING_DEFAULT ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Default repository encoding is " + repo . getEncoding ( ) ) ; } return repo ; } public boolean resourceExists ( final String name ) { if ( name == null ) { return false ; } return ( this . repository . getStringResource ( name ) != null ) ; } public InputStream getResourceStream ( final String name ) throws ResourceNotFoundException { if ( StringUtils . isEmpty ( name ) ) { throw new ResourceNotFoundException ( "No template name provided" ) ; } StringResource resource = this . repository . getStringResource ( name ) ; if ( resource == null ) { throw new ResourceNotFoundException ( "Could not locate resource '" + name + "'" ) ; } byte [ ] byteArray = null ; try { byteArray = resource . getBody ( ) . getBytes ( resource . getEncoding ( ) ) ; return new ByteArrayInputStream ( byteArray ) ; } catch ( UnsupportedEncodingException ue ) { throw new VelocityException ( "Could not convert String using encoding " + resource . getEncoding ( ) , ue ) ; } } public boolean isSourceModified ( final Resource resource ) { StringResource original = null ; boolean result = true ; original = this . repository . getStringResource ( resource . getName ( ) ) ; if ( original != null ) { result = original . getLastModified ( ) != resource . getLastModified ( ) ; } return result ; } public long getLastModified ( final Resource resource ) { StringResource original = null ; original = this . repository . getStringResource ( resource . getName ( ) ) ; return ( original != null ) ? original . getLastModified ( ) : 0 ; } } 	1	['14', '2', '0', '11', '52', '43', '0', '11', '12', '0.955128205', '467', '0.166666667', '1', '0.5', '0.276923077', '2', '3', '31.5', '12', '2.2143', '1']
package org . apache . velocity . texen ; import java . io . File ; import java . io . InputStream ; import java . io . FileInputStream ; import java . io . BufferedInputStream ; import java . io . Writer ; import java . io . FileWriter ; import java . io . IOException ; import java . io . StringWriter ; import java . io . OutputStreamWriter ; import java . io . BufferedWriter ; import java . io . FileOutputStream ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . Properties ; import org . apache . velocity . Template ; import org . apache . velocity . context . Context ; import org . apache . velocity . VelocityContext ; import org . apache . velocity . app . VelocityEngine ; import org . apache . velocity . util . ClassUtils ; public class Generator { public static final String OUTPUT_PATH = "output.path" ; public static final String TEMPLATE_PATH = "template.path" ; private static final String DEFAULT_TEXEN_PROPERTIES = "org/apache/velocity/texen/defaults/texen.properties" ; private Properties props = new Properties ( ) ; private Context controlContext ; private Hashtable writers = new Hashtable ( ) ; private static Generator instance = new Generator ( ) ; protected String outputEncoding ; protected String inputEncoding ; protected VelocityEngine ve ; private Generator ( ) { setDefaultProps ( ) ; } public static Generator getInstance ( ) { return instance ; } public void setVelocityEngine ( VelocityEngine ve ) { this . ve = ve ; } public Generator ( String propFile ) { try { BufferedInputStream bi = null ; try { bi = new BufferedInputStream ( new FileInputStream ( propFile ) ) ; props . load ( bi ) ; } finally { if ( bi != null ) { bi . close ( ) ; } } } catch ( IOException e ) { System . err . println ( "Could not load " + propFile + ", falling back to defaults. (" + e . getMessage ( ) + ")" ) ; setDefaultProps ( ) ; } } public Generator ( Properties props ) { this . props = ( Properties ) props . clone ( ) ; } protected void setDefaultProps ( ) { ClassLoader classLoader = VelocityEngine . class . getClassLoader ( ) ; try { InputStream inputStream = null ; try { inputStream = classLoader . getResourceAsStream ( DEFAULT_TEXEN_PROPERTIES ) ; props . load ( inputStream ) ; } finally { if ( inputStream != null ) { inputStream . close ( ) ; } } } catch ( IOException ioe ) { System . err . println ( "Cannot get default properties: " + ioe . getMessage ( ) ) ; } } public void setTemplatePath ( String templatePath ) { props . put ( TEMPLATE_PATH , templatePath ) ; } public String getTemplatePath ( ) { return props . getProperty ( TEMPLATE_PATH ) ; } public void setOutputPath ( String outputPath ) { props . put ( OUTPUT_PATH , outputPath ) ; } public String getOutputPath ( ) { return props . getProperty ( OUTPUT_PATH ) ; } public void setOutputEncoding ( String outputEncoding ) { this . outputEncoding = outputEncoding ; } public void setInputEncoding ( String inputEncoding ) { this . inputEncoding = inputEncoding ; } public Writer getWriter ( String path , String encoding ) throws Exception { Writer writer ; if ( encoding == null || encoding . length ( ) == 0 || encoding . equals ( "8859-1" ) || encoding . equals ( "8859_1" ) ) { writer = new FileWriter ( path ) ; } else { writer = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( path ) , encoding ) ) ; } return writer ; } public Template getTemplate ( String templateName , String encoding ) throws Exception { Template template ; if ( encoding == null || encoding . length ( ) == 0 || encoding . equals ( "8859-1" ) || encoding . equals ( "8859_1" ) ) { template = ve . getTemplate ( templateName ) ; } else { template = ve . getTemplate ( templateName , encoding ) ; } return template ; } public String parse ( String inputTemplate , String outputFile ) throws Exception { return parse ( inputTemplate , outputFile , null , null ) ; } public String parse ( String inputTemplate , String outputFile , String objectID , Object object ) throws Exception { return parse ( inputTemplate , null , outputFile , null , objectID , object ) ; } public String parse ( String inputTemplate , String inputEncoding , String outputFile , String outputEncoding , String objectID , Object object ) throws Exception { if ( objectID != null && object != null ) { controlContext . put ( objectID , object ) ; } Template template = getTemplate ( inputTemplate , inputEncoding != null ? inputEncoding : this . inputEncoding ) ; if ( outputFile == null || outputFile . equals ( "" ) ) { StringWriter sw = new StringWriter ( ) ; template . merge ( controlContext , sw ) ; return sw . toString ( ) ; } else { Writer writer = null ; if ( writers . get ( outputFile ) == null ) { writer = getWriter ( getOutputPath ( ) + File . separator + outputFile , outputEncoding != null ? outputEncoding : this . outputEncoding ) ; writers . put ( outputFile , writer ) ; } else { writer = ( Writer ) writers . get ( outputFile ) ; } VelocityContext vc = new VelocityContext ( controlContext ) ; template . merge ( vc , writer ) ; return "" ; } } public String parse ( String controlTemplate , Context controlContext ) throws Exception { this . controlContext = controlContext ; fillContextDefaults ( this . controlContext ) ; fillContextProperties ( this . controlContext ) ; Template template = getTemplate ( controlTemplate , inputEncoding ) ; StringWriter sw = new StringWriter ( ) ; template . merge ( controlContext , sw ) ; return sw . toString ( ) ; } protected Context getContext ( Hashtable objs ) { fillContextHash ( controlContext , objs ) ; return controlContext ; } protected void fillContextHash ( Context context , Hashtable objs ) { Enumeration enumeration = objs . keys ( ) ; while ( enumeration . hasMoreElements ( ) ) { String key = enumeration . nextElement ( ) . toString ( ) ; context . put ( key , objs . get ( key ) ) ; } } protected void fillContextDefaults ( Context context ) { context . put ( "generator" , instance ) ; context . put ( "outputDirectory" , getOutputPath ( ) ) ; } protected void fillContextProperties ( Context context ) { Enumeration enumeration = props . propertyNames ( ) ; while ( enumeration . hasMoreElements ( ) ) { String nm = ( String ) enumeration . nextElement ( ) ; if ( nm . startsWith ( "context.objects." ) ) { String contextObj = props . getProperty ( nm ) ; int colon = nm . lastIndexOf ( '.' ) ; String contextName = nm . substring ( colon + 1 ) ; try { Object o = ClassUtils . getNewInstance ( contextObj ) ; context . put ( contextName , o ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } public void shutdown ( ) { Iterator iterator = writers . values ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Writer writer = ( Writer ) iterator . next ( ) ; try { writer . flush ( ) ; } catch ( IOException e ) { } try { writer . close ( ) ; } catch ( IOException e ) { } } writers . clear ( ) ; } } 	0	['25', '1', '0', '7', '78', '194', '2', '5', '17', '0.878787879', '530', '0.727272727', '3', '0', '0.261904762', '0', '0', '19.76', '3', '1.04', '0']
package org . apache . velocity . context ; import java . util . HashSet ; import java . util . Set ; import java . util . List ; import org . apache . velocity . VelocityContext ; import org . apache . velocity . app . event . EventCartridge ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . resource . Resource ; import org . apache . velocity . util . ClassUtils ; import org . apache . velocity . util . introspection . IntrospectionCacheData ; public class EvaluateContext extends ChainedInternalContextAdapter { Context localContext ; boolean allowRendering = true ; public EvaluateContext ( InternalContextAdapter inner , RuntimeServices rsvc ) { super ( inner ) ; initContext ( rsvc ) ; } private void initContext ( RuntimeServices rsvc ) { String contextClass = rsvc . getString ( RuntimeConstants . EVALUATE_CONTEXT_CLASS ) ; if ( contextClass != null && contextClass . length ( ) > 0 ) { Object o = null ; try { o = ClassUtils . getNewInstance ( contextClass ) ; } catch ( ClassNotFoundException cnfe ) { String err = "The specified class for #evaluate() context (" + contextClass + ") does not exist or is not accessible to the current classloader." ; rsvc . getLog ( ) . error ( err ) ; throw new RuntimeException ( err , cnfe ) ; } catch ( Exception e ) { String err = "The specified class for #evaluate() context (" + contextClass + ") can not be loaded." ; rsvc . getLog ( ) . error ( err , e ) ; throw new RuntimeException ( err ) ; } if ( ! ( o instanceof Context ) ) { String err = "The specified class for #evaluate() context (" + contextClass + ") does not implement " + Context . class . getName ( ) + "." ; rsvc . getLog ( ) . error ( err ) ; throw new RuntimeException ( err ) ; } localContext = ( Context ) o ; } else { String err = "No class specified for #evaluate() context." ; rsvc . getLog ( ) . error ( err ) ; throw new RuntimeException ( err ) ; } } public Object put ( String key , Object value ) { return localContext . put ( key , value ) ; } public Object get ( String key ) { Object o = localContext . get ( key ) ; if ( o == null ) { o = super . get ( key ) ; } return o ; } public boolean containsKey ( Object key ) { return localContext . containsKey ( key ) || super . containsKey ( key ) ; } public Object [ ] getKeys ( ) { Set keys = new HashSet ( ) ; Object [ ] localKeys = localContext . getKeys ( ) ; for ( int i = 0 ; i < localKeys . length ; i ++ ) { keys . add ( localKeys [ i ] ) ; } Object [ ] innerKeys = super . getKeys ( ) ; for ( int i = 0 ; i < innerKeys . length ; i ++ ) { keys . add ( innerKeys [ i ] ) ; } return keys . toArray ( ) ; } public Object remove ( Object key ) { return localContext . remove ( key ) ; } public Object localPut ( final String key , final Object value ) { return localContext . put ( key , value ) ; } public boolean getAllowRendering ( ) { return allowRendering && innerContext . getAllowRendering ( ) ; } public void setAllowRendering ( boolean v ) { allowRendering = false ; } } 	1	['11', '2', '0', '7', '39', '7', '1', '6', '9', '0.666666667', '245', '0', '1', '0.72972973', '0.333333333', '0', '0', '21', '5', '1.9091', '2']
package org . apache . velocity . servlet ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . StringWriter ; import java . io . UnsupportedEncodingException ; import java . util . Properties ; import javax . servlet . ServletConfig ; import javax . servlet . ServletContext ; import javax . servlet . ServletException ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServlet ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . apache . velocity . Template ; import org . apache . velocity . VelocityContext ; import org . apache . velocity . app . Velocity ; import org . apache . velocity . context . Context ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . io . VelocityWriter ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeSingleton ; import org . apache . velocity . util . SimplePool ; public abstract class VelocityServlet extends HttpServlet { public static final String REQUEST = "req" ; public static final String RESPONSE = "res" ; public static final String CONTENT_TYPE = "default.contentType" ; public static final String DEFAULT_CONTENT_TYPE = "text/html" ; public static final String DEFAULT_OUTPUT_ENCODING = "ISO-8859-1" ; private static String defaultContentType ; protected static final String INIT_PROPS_KEY = "org.apache.velocity.properties" ; private static final String OLD_INIT_PROPS_KEY = "properties" ; private static SimplePool writerPool = new SimplePool ( 40 ) ; public void init ( ServletConfig config ) throws ServletException { super . init ( config ) ; initVelocity ( config ) ; VelocityServlet . defaultContentType = RuntimeSingleton . getString ( CONTENT_TYPE , DEFAULT_CONTENT_TYPE ) ; } protected void initVelocity ( ServletConfig config ) throws ServletException { try { Properties props = loadConfiguration ( config ) ; Velocity . init ( props ) ; } catch ( Exception e ) { throw new ServletException ( "Error initializing Velocity: " + e , e ) ; } } protected Properties loadConfiguration ( ServletConfig config ) throws IOException , FileNotFoundException { String propsFile = config . getInitParameter ( INIT_PROPS_KEY ) ; if ( propsFile == null || propsFile . length ( ) == 0 ) { ServletContext sc = config . getServletContext ( ) ; propsFile = config . getInitParameter ( OLD_INIT_PROPS_KEY ) ; if ( propsFile == null || propsFile . length ( ) == 0 ) { propsFile = sc . getInitParameter ( INIT_PROPS_KEY ) ; if ( propsFile == null || propsFile . length ( ) == 0 ) { propsFile = sc . getInitParameter ( OLD_INIT_PROPS_KEY ) ; if ( propsFile != null && propsFile . length ( ) > 0 ) { sc . log ( "Use of the properties initialization " + "parameter '" + OLD_INIT_PROPS_KEY + "' has " + "been deprecated by '" + INIT_PROPS_KEY + '\'' ) ; } } } else { sc . log ( "Use of the properties initialization parameter '" + OLD_INIT_PROPS_KEY + "' has been deprecated by '" + INIT_PROPS_KEY + '\'' ) ; } } Properties p = new Properties ( ) ; if ( propsFile != null ) { p . load ( getServletContext ( ) . getResourceAsStream ( propsFile ) ) ; } return p ; } public void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { doRequest ( request , response ) ; } public void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { doRequest ( request , response ) ; } protected void doRequest ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { Context context = null ; try { context = createContext ( request , response ) ; setContentType ( request , response ) ; Template template = handleRequest ( request , response , context ) ; if ( template == null ) { return ; } mergeTemplate ( template , context , response ) ; } catch ( Exception e ) { error ( request , response , e ) ; } finally { requestCleanup ( request , response , context ) ; } } protected void requestCleanup ( HttpServletRequest request , HttpServletResponse response , Context context ) { } protected void mergeTemplate ( Template template , Context context , HttpServletResponse response ) throws ResourceNotFoundException , ParseErrorException , MethodInvocationException , IOException , UnsupportedEncodingException , Exception { ServletOutputStream output = response . getOutputStream ( ) ; VelocityWriter vw = null ; String encoding = response . getCharacterEncoding ( ) ; try { vw = ( VelocityWriter ) writerPool . get ( ) ; if ( vw == null ) { vw = new VelocityWriter ( new OutputStreamWriter ( output , encoding ) , 4 * 1024 , true ) ; } else { vw . recycle ( new OutputStreamWriter ( output , encoding ) ) ; } template . merge ( context , vw ) ; } finally { if ( vw != null ) { try { vw . flush ( ) ; } catch ( IOException e ) { } vw . recycle ( null ) ; writerPool . put ( vw ) ; } } } protected void setContentType ( HttpServletRequest request , HttpServletResponse response ) { String contentType = VelocityServlet . defaultContentType ; int index = contentType . lastIndexOf ( ';' ) + 1 ; if ( index <= 0 || ( index < contentType . length ( ) && contentType . indexOf ( "charset" , index ) == - 1 ) ) { String encoding = chooseCharacterEncoding ( request ) ; if ( ! DEFAULT_OUTPUT_ENCODING . equalsIgnoreCase ( encoding ) ) { contentType += "; charset=" + encoding ; } } response . setContentType ( contentType ) ; } protected String chooseCharacterEncoding ( HttpServletRequest request ) { return RuntimeSingleton . getString ( RuntimeConstants . OUTPUT_ENCODING , DEFAULT_OUTPUT_ENCODING ) ; } protected Context createContext ( HttpServletRequest request , HttpServletResponse response ) { VelocityContext context = new VelocityContext ( ) ; context . put ( REQUEST , request ) ; context . put ( RESPONSE , response ) ; return context ; } public Template getTemplate ( String name ) throws ResourceNotFoundException , ParseErrorException , Exception { return RuntimeSingleton . getTemplate ( name ) ; } public Template getTemplate ( String name , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception { return RuntimeSingleton . getTemplate ( name , encoding ) ; } protected Template handleRequest ( HttpServletRequest request , HttpServletResponse response , Context ctx ) throws Exception { Template t = handleRequest ( ctx ) ; if ( t == null ) { throw new Exception ( "handleRequest(Context) returned null - no template selected!" ) ; } return t ; } protected Template handleRequest ( Context ctx ) throws Exception { throw new Exception ( "You must override VelocityServlet.handleRequest( Context) " + " or VelocityServlet.handleRequest( HttpServletRequest, " + " HttpServletResponse, Context)" ) ; } protected void error ( HttpServletRequest request , HttpServletResponse response , Exception cause ) throws ServletException , IOException { StringBuffer html = new StringBuffer ( ) ; html . append ( "<html>" ) ; html . append ( "<title>Error</title>" ) ; html . append ( "<body bgcolor=\"#ffffff\">" ) ; html . append ( "<h2>VelocityServlet: Error processing the template</h2>" ) ; html . append ( "<pre>" ) ; String why = cause . getMessage ( ) ; if ( why != null && why . trim ( ) . length ( ) > 0 ) { html . append ( why ) ; html . append ( "<br>" ) ; } StringWriter sw = new StringWriter ( ) ; cause . printStackTrace ( new PrintWriter ( sw ) ) ; html . append ( sw . toString ( ) ) ; html . append ( "</pre>" ) ; html . append ( "</body>" ) ; html . append ( "</html>" ) ; response . getOutputStream ( ) . print ( html . toString ( ) ) ; } } 	0	['18', '3', '0', '10', '62', '149', '0', '10', '6', '1.019607843', '417', '0.444444444', '1', '0.6', '0.338235294', '1', '2', '21.66666667', '5', '1.1111', '0']
package org . apache . velocity . runtime . parser . node ; import java . io . IOException ; import java . io . Writer ; import org . apache . commons . lang . builder . ToStringBuilder ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . runtime . directive . Directive ; import org . apache . velocity . runtime . directive . RuntimeMacro ; import org . apache . velocity . runtime . parser . ParseException ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . util . ExceptionUtils ; public class ASTDirective extends SimpleNode { private Directive directive = null ; private String directiveName = "" ; private boolean isDirective ; private boolean isInitialized ; public ASTDirective ( int id ) { super ( id ) ; } public ASTDirective ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public synchronized Object init ( InternalContextAdapter context , Object data ) throws TemplateInitException { if ( ! isInitialized ) { super . init ( context , data ) ; if ( parser . isDirective ( directiveName ) ) { isDirective = true ; try { directive = ( Directive ) parser . getDirective ( directiveName ) . getClass ( ) . newInstance ( ) ; } catch ( InstantiationException e ) { throw ExceptionUtils . createRuntimeException ( "Couldn't initialize " + "directive of class " + parser . getDirective ( directiveName ) . getClass ( ) . getName ( ) , e ) ; } catch ( IllegalAccessException e ) { throw ExceptionUtils . createRuntimeException ( "Couldn't initialize " + "directive of class " + parser . getDirective ( directiveName ) . getClass ( ) . getName ( ) , e ) ; } directive . setLocation ( getLine ( ) , getColumn ( ) ) ; directive . init ( rsvc , context , this ) ; } else { directive = new RuntimeMacro ( directiveName , getTemplateName ( ) ) ; directive . setLocation ( getLine ( ) , getColumn ( ) ) ; try { directive . init ( rsvc , context , this ) ; } catch ( TemplateInitException die ) { throw new TemplateInitException ( die . getMessage ( ) , ( ParseException ) die . getWrappedThrowable ( ) , die . getTemplateName ( ) , die . getColumnNumber ( ) + getColumn ( ) , die . getLineNumber ( ) + getLine ( ) ) ; } isDirective = true ; } isInitialized = true ; } return data ; } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException , ResourceNotFoundException , ParseErrorException { if ( isDirective ) { directive . render ( context , writer , this ) ; } else { if ( context . getAllowRendering ( ) ) { writer . write ( "#" ) ; writer . write ( directiveName ) ; } } return true ; } public void setDirectiveName ( String str ) { directiveName = str ; } public String getDirectiveName ( ) { return directiveName ; } public String toString ( ) { return new ToStringBuilder ( this ) . appendSuper ( super . toString ( ) ) . append ( "directiveName" , getDirectiveName ( ) ) . toString ( ) ; } } 	1	['8', '2', '0', '18', '41', '0', '5', '15', '8', '0.642857143', '218', '1', '1', '0.833333333', '0.28125', '1', '1', '25.75', '1', '0.75', '3']
package org . apache . velocity . runtime . log ; public class LogDisplayWrapper extends Log { private final String prefix ; private final boolean outputMessages ; private final Log log ; public LogDisplayWrapper ( final Log log , final String prefix , final boolean outputMessages ) { super ( log . getLogChute ( ) ) ; this . log = log ; this . prefix = prefix ; this . outputMessages = outputMessages ; } protected LogChute getLogChute ( ) { return log . getLogChute ( ) ; } protected void log ( final int level , final Object message ) { log ( outputMessages , level , message ) ; } protected void log ( final boolean doLogging , final int level , final Object message ) { if ( doLogging ) { getLogChute ( ) . log ( level , prefix + String . valueOf ( message ) ) ; } } protected void log ( final int level , final Object message , final Throwable t ) { log ( outputMessages , level , message ) ; } protected void log ( final boolean doLogging , final int level , final Object message , final Throwable t ) { if ( doLogging ) { getLogChute ( ) . log ( level , prefix + String . valueOf ( message ) , t ) ; } } public void trace ( final boolean doLogging , final Object message ) { log ( doLogging , LogChute . TRACE_ID , message ) ; } public void trace ( final boolean doLogging , final Object message , final Throwable t ) { log ( doLogging , LogChute . TRACE_ID , message , t ) ; } public void debug ( final boolean doLogging , final Object message ) { log ( doLogging , LogChute . DEBUG_ID , message ) ; } public void debug ( final boolean doLogging , final Object message , final Throwable t ) { log ( doLogging , LogChute . DEBUG_ID , message , t ) ; } public void info ( final boolean doLogging , final Object message ) { log ( doLogging , LogChute . INFO_ID , message ) ; } public void info ( final boolean doLogging , final Object message , final Throwable t ) { log ( doLogging , LogChute . INFO_ID , message , t ) ; } public void warn ( final boolean doLogging , final Object message ) { log ( doLogging , LogChute . WARN_ID , message ) ; } public void warn ( final boolean doLogging , final Object message , final Throwable t ) { log ( doLogging , LogChute . WARN_ID , message , t ) ; } public void error ( final boolean doLogging , final Object message ) { log ( doLogging , LogChute . ERROR_ID , message ) ; } public void error ( final boolean doLogging , final Object message , final Throwable t ) { log ( doLogging , LogChute . ERROR_ID , message , t ) ; } } 	0	['16', '2', '0', '3', '24', '106', '1', '2', '11', '0.333333333', '151', '1', '1', '0.605263158', '0.5', '1', '6', '8.25', '2', '1.0625', '0']
package org . apache . velocity . runtime . parser . node ; import java . util . Map ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . runtime . log . Log ; public class MapGetExecutor extends AbstractExecutor { private final String property ; public MapGetExecutor ( final Log log , final Class clazz , final String property ) { this . log = log ; this . property = property ; discover ( clazz ) ; } protected void discover ( final Class clazz ) { Class [ ] interfaces = clazz . getInterfaces ( ) ; for ( int i = 0 ; i < interfaces . length ; i ++ ) { if ( interfaces [ i ] . equals ( Map . class ) ) { try { if ( property != null ) { setMethod ( Map . class . getMethod ( "get" , new Class [ ] { Object . class } ) ) ; } } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { String msg = "Exception while looking for get('" + property + "') method" ; log . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } break ; } } } public Object execute ( final Object o ) { return ( ( Map ) o ) . get ( property ) ; } } 	1	['4', '2', '0', '4', '18', '0', '1', '3', '2', '0.555555556', '116', '0.333333333', '0', '0.571428571', '0.45', '0', '0', '27.25', '6', '2', '1']
package org . apache . velocity . runtime . parser . node ; import java . io . IOException ; import java . io . StringReader ; import java . io . StringWriter ; import org . apache . commons . lang . text . StrBuilder ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . parser . ParseException ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . Token ; import org . apache . velocity . runtime . visitor . BaseVisitor ; public class ASTStringLiteral extends SimpleNode { private boolean interpolate = true ; private SimpleNode nodeTree = null ; private String image = "" ; private String interpolateimage = "" ; private boolean containsLineComment ; public ASTStringLiteral ( int id ) { super ( id ) ; } public ASTStringLiteral ( Parser p , int id ) { super ( p , id ) ; } public Object init ( InternalContextAdapter context , Object data ) throws TemplateInitException { super . init ( context , data ) ; interpolate = rsvc . getBoolean ( RuntimeConstants . INTERPOLATE_STRINGLITERALS , true ) && getFirstToken ( ) . image . startsWith ( "\"" ) && ( ( getFirstToken ( ) . image . indexOf ( '$' ) != - 1 ) || ( getFirstToken ( ) . image . indexOf ( '#' ) != - 1 ) ) ; image = getFirstToken ( ) . image . substring ( 1 , getFirstToken ( ) . image . length ( ) - 1 ) ; if ( getFirstToken ( ) . image . startsWith ( "\"" ) ) { image = unescape ( image ) ; } containsLineComment = ( image . indexOf ( "##" ) != - 1 ) ; if ( ! containsLineComment ) { interpolateimage = image + " " ; } else { interpolateimage = image ; } if ( interpolate ) { StringReader br = new StringReader ( interpolateimage ) ; String templateName = ( context != null ) ? context . getCurrentTemplateName ( ) : "StringLiteral" ; try { nodeTree = rsvc . parse ( br , templateName , false ) ; } catch ( ParseException e ) { String msg = "Failed to parse String literal at " + Log . formatFileString ( templateName , getLine ( ) , getColumn ( ) ) ; throw new TemplateInitException ( msg , e , templateName , getColumn ( ) , getLine ( ) ) ; } adjTokenLineNums ( nodeTree ) ; nodeTree . init ( context , rsvc ) ; } return data ; } public void adjTokenLineNums ( Node node ) { Token tok = node . getFirstToken ( ) ; while ( tok != null && tok != node . getLastToken ( ) ) { if ( tok . beginLine == 1 ) tok . beginColumn += getColumn ( ) ; if ( tok . endLine == 1 ) tok . endColumn += getColumn ( ) ; tok . beginLine += getLine ( ) - 1 ; tok . endLine += getLine ( ) - 1 ; tok = tok . next ; } } public static String unescape ( final String string ) { int u = string . indexOf ( "\\u" ) ; if ( u < 0 ) return string ; StrBuilder result = new StrBuilder ( ) ; int lastCopied = 0 ; for ( ; ; ) { result . append ( string . substring ( lastCopied , u ) ) ; char c = ( char ) Integer . parseInt ( string . substring ( u + 2 , u + 6 ) , 16 ) ; result . append ( c ) ; lastCopied = u + 6 ; u = string . indexOf ( "\\u" , lastCopied ) ; if ( u < 0 ) { result . append ( string . substring ( lastCopied ) ) ; return result . toString ( ) ; } } } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean isConstant ( ) { return ! interpolate ; } public Object value ( InternalContextAdapter context ) { if ( interpolate ) { try { StringWriter writer = new StringWriter ( ) ; nodeTree . render ( context , writer ) ; String ret = writer . toString ( ) ; if ( ! containsLineComment && ret . length ( ) > 0 ) { return ret . substring ( 0 , ret . length ( ) - 1 ) ; } else { return ret ; } } catch ( RuntimeException e ) { throw e ; } catch ( IOException e ) { String msg = "Error in interpolating string literal" ; log . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } } return image ; } } 	0	['8', '2', '0', '14', '43', '8', '4', '12', '8', '0.628571429', '376', '1', '1', '0.833333333', '0.265625', '1', '2', '45.375', '5', '1.875', '0']
package org . apache . velocity . runtime . log ; import java . io . IOException ; import java . lang . reflect . Field ; import org . apache . log4j . Level ; import org . apache . log4j . Logger ; import org . apache . log4j . PatternLayout ; import org . apache . log4j . RollingFileAppender ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . util . ExceptionUtils ; public class Log4JLogChute implements LogChute { public static final String RUNTIME_LOG_LOG4J_LOGGER = "runtime.log.logsystem.log4j.logger" ; public static final String RUNTIME_LOG_LOG4J_LOGGER_LEVEL = "runtime.log.logsystem.log4j.logger.level" ; private RuntimeServices rsvc = null ; private boolean hasTrace = false ; private RollingFileAppender appender = null ; protected Logger logger = null ; public void init ( RuntimeServices rs ) throws Exception { rsvc = rs ; String name = ( String ) rsvc . getProperty ( RUNTIME_LOG_LOG4J_LOGGER ) ; if ( name != null ) { logger = Logger . getLogger ( name ) ; log ( DEBUG_ID , "Log4JLogChute using logger '" + name + '\'' ) ; } else { logger = Logger . getLogger ( this . getClass ( ) . getName ( ) ) ; String file = rsvc . getString ( RuntimeConstants . RUNTIME_LOG ) ; if ( file != null && file . length ( ) > 0 ) { initAppender ( file ) ; } } String lvl = rsvc . getString ( RUNTIME_LOG_LOG4J_LOGGER_LEVEL ) ; if ( lvl != null ) { Level level = Level . toLevel ( lvl ) ; logger . setLevel ( level ) ; } try { Field traceLevel = Level . class . getField ( "TRACE" ) ; hasTrace = true ; } catch ( NoSuchFieldException e ) { log ( DEBUG_ID , "The version of log4j being used does not support the \"trace\" level." ) ; } } private void initAppender ( String file ) throws Exception { try { PatternLayout layout = new PatternLayout ( "%d - %m%n" ) ; this . appender = new RollingFileAppender ( layout , file , true ) ; appender . setMaxBackupIndex ( 1 ) ; appender . setMaximumFileSize ( 100000 ) ; logger . setAdditivity ( false ) ; logger . addAppender ( appender ) ; log ( DEBUG_ID , "Log4JLogChute initialized using file '" + file + '\'' ) ; } catch ( IOException ioe ) { rsvc . getLog ( ) . error ( "Could not create file appender '" + file + '\'' , ioe ) ; throw ExceptionUtils . createRuntimeException ( "Error configuring Log4JLogChute : " , ioe ) ; } } public void log ( int level , String message ) { switch ( level ) { case LogChute . WARN_ID : logger . warn ( message ) ; break ; case LogChute . INFO_ID : logger . info ( message ) ; break ; case LogChute . TRACE_ID : if ( hasTrace ) { logger . trace ( message ) ; } else { logger . debug ( message ) ; } break ; case LogChute . ERROR_ID : logger . error ( message ) ; break ; case LogChute . DEBUG_ID : default : logger . debug ( message ) ; break ; } } public void log ( int level , String message , Throwable t ) { switch ( level ) { case LogChute . WARN_ID : logger . warn ( message , t ) ; break ; case LogChute . INFO_ID : logger . info ( message , t ) ; break ; case LogChute . TRACE_ID : if ( hasTrace ) { logger . trace ( message , t ) ; } else { logger . debug ( message , t ) ; } break ; case LogChute . ERROR_ID : logger . error ( message , t ) ; break ; case LogChute . DEBUG_ID : default : logger . debug ( message , t ) ; break ; } } public boolean isLevelEnabled ( int level ) { switch ( level ) { case LogChute . DEBUG_ID : return logger . isDebugEnabled ( ) ; case LogChute . INFO_ID : return logger . isInfoEnabled ( ) ; case LogChute . TRACE_ID : if ( hasTrace ) { return logger . isTraceEnabled ( ) ; } else { return logger . isDebugEnabled ( ) ; } case LogChute . WARN_ID : return logger . isEnabledFor ( Level . WARN ) ; case LogChute . ERROR_ID : return logger . isEnabledFor ( Level . ERROR ) ; default : return true ; } } protected void finalize ( ) throws Throwable { shutdown ( ) ; } public void shutdown ( ) { if ( appender != null ) { logger . removeAppender ( appender ) ; appender . close ( ) ; appender = null ; } } } 	1	['9', '1', '1', '12', '51', '0', '1', '11', '6', '0.714285714', '316', '0.571428571', '1', '0', '0.377777778', '0', '0', '33.33333333', '3', '1.6667', '2']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . runtime . parser . Parser ; public class ASTWord extends SimpleNode { public ASTWord ( int id ) { super ( id ) ; } public ASTWord ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } } 	0	['3', '2', '0', '5', '6', '3', '4', '3', '3', '2', '17', '0', '0', '0.967741935', '0.533333333', '0', '0', '4.666666667', '1', '0.3333', '0']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . util . TemplateNumber ; public class ASTGENode extends SimpleNode { public ASTGENode ( int id ) { super ( id ) ; } public ASTGENode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { Object left = jjtGetChild ( 0 ) . value ( context ) ; Object right = jjtGetChild ( 1 ) . value ( context ) ; if ( left == null || right == null ) { log . error ( ( left == null ? "Left" : "Right" ) + " side (" + jjtGetChild ( ( left == null ? 0 : 1 ) ) . literal ( ) + ") of '>=' operation has null value." + " Operation not possible. " + Log . formatFileString ( this ) ) ; return false ; } if ( left instanceof TemplateNumber ) { left = ( ( TemplateNumber ) left ) . getAsNumber ( ) ; } if ( right instanceof TemplateNumber ) { right = ( ( TemplateNumber ) right ) . getAsNumber ( ) ; } if ( ! ( left instanceof Number ) || ! ( right instanceof Number ) ) { log . error ( ( ! ( left instanceof Number ) ? "Left" : "Right" ) + " side of '>=' operation is not a Number. " + Log . formatFileString ( this ) ) ; return false ; } return MathUtils . compare ( ( Number ) left , ( Number ) right ) >= 0 ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { boolean val = evaluate ( context ) ; return val ? Boolean . TRUE : Boolean . FALSE ; } } 	1	['5', '2', '0', '11', '18', '10', '4', '9', '5', '2', '129', '0', '0', '0.909090909', '0.4', '1', '1', '24.8', '1', '0.6', '1']
package org . apache . velocity . util . introspection ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; import org . apache . velocity . runtime . log . Log ; public final class IntrospectorCacheImpl implements IntrospectorCache { public final static String CACHEDUMP_MSG = "IntrospectorCache detected classloader change. Dumping cache." ; private final Log log ; private final Map classMapCache = new HashMap ( ) ; private final Set classNameCache = new HashSet ( ) ; public IntrospectorCacheImpl ( final Log log ) { this . log = log ; } public void clear ( ) { synchronized ( classMapCache ) { classMapCache . clear ( ) ; classNameCache . clear ( ) ; log . debug ( CACHEDUMP_MSG ) ; } } public ClassMap get ( final Class c ) { if ( c == null ) { throw new IllegalArgumentException ( "class is null!" ) ; } ClassMap classMap = ( ClassMap ) classMapCache . get ( c ) ; if ( classMap == null ) { synchronized ( classMapCache ) { if ( classNameCache . contains ( c . getName ( ) ) ) { clear ( ) ; } } } return classMap ; } public ClassMap put ( final Class c ) { final ClassMap classMap = new ClassMap ( c , log ) ; synchronized ( classMapCache ) { classMapCache . put ( c , classMap ) ; classNameCache . add ( c . getName ( ) ) ; } return classMap ; } } 	0	['4', '1', '0', '4', '17', '0', '1', '3', '4', '0.333333333', '120', '0.75', '1', '0', '0.583333333', '0', '0', '28', '4', '1.5', '0']
package org . apache . velocity . runtime . parser ; import java . io . * ; import java . util . * ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . parser . node . * ; import org . apache . velocity . runtime . directive . Directive ; import org . apache . velocity . runtime . directive . Macro ; import org . apache . velocity . runtime . directive . MacroParseException ; import org . apache . velocity . util . StringUtils ; public class Parser implements ParserTreeConstants , ParserConstants { protected JJTParserState jjtree = new JJTParserState ( ) ; private Hashtable directives = new Hashtable ( 0 ) ; public String currentTemplateName = "" ; VelocityCharStream velcharstream = null ; private RuntimeServices rsvc = null ; public Parser ( RuntimeServices rs ) { this ( new VelocityCharStream ( new ByteArrayInputStream ( "\n" . getBytes ( ) ) , 1 , 1 ) ) ; velcharstream = new VelocityCharStream ( new ByteArrayInputStream ( "\n" . getBytes ( ) ) , 1 , 1 ) ; rsvc = rs ; } public SimpleNode parse ( Reader reader , String templateName ) throws ParseException { SimpleNode sn = null ; currentTemplateName = templateName ; try { token_source . clearStateVars ( ) ; velcharstream . ReInit ( reader , 1 , 1 ) ; ReInit ( velcharstream ) ; sn = process ( ) ; } catch ( MacroParseException mee ) { rsvc . getLog ( ) . error ( "Parser Error: " + templateName , mee ) ; throw mee ; } catch ( ParseException pe ) { rsvc . getLog ( ) . error ( "Parser Exception: " + templateName , pe ) ; throw new TemplateParseException ( pe . currentToken , pe . expectedTokenSequences , pe . tokenImage , currentTemplateName ) ; } catch ( TokenMgrError tme ) { throw new ParseException ( "Lexical error: " + tme . toString ( ) ) ; } catch ( Exception e ) { String msg = "Parser Error: " + templateName ; rsvc . getLog ( ) . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } currentTemplateName = "" ; return sn ; } public void setDirectives ( Hashtable directives ) { this . directives = directives ; } public Directive getDirective ( String directive ) { return ( Directive ) directives . get ( directive ) ; } public boolean isDirective ( String directive ) { return directives . containsKey ( directive ) ; } private String escapedDirective ( String strImage ) { int iLast = strImage . lastIndexOf ( "\\" ) ; String strDirective = strImage . substring ( iLast + 1 ) ; boolean bRecognizedDirective = false ; String dirTag = strDirective . substring ( 1 ) ; if ( dirTag . charAt ( 0 ) == '{' ) { dirTag = dirTag . substring ( 1 , dirTag . length ( ) - 1 ) ; } if ( isDirective ( dirTag ) ) { bRecognizedDirective = true ; } else if ( rsvc . isVelocimacro ( dirTag , currentTemplateName ) ) { bRecognizedDirective = true ; } else { if ( dirTag . equals ( "if" ) || dirTag . equals ( "end" ) || dirTag . equals ( "set" ) || dirTag . equals ( "else" ) || dirTag . equals ( "elseif" ) || dirTag . equals ( "stop" ) ) { bRecognizedDirective = true ; } } if ( bRecognizedDirective ) return ( strImage . substring ( 0 , iLast / 2 ) + strDirective ) ; else return ( strImage ) ; } private boolean isLeftParenthesis ( ) { char c ; int no = 0 ; try { while ( true ) { c = velcharstream . readChar ( ) ; no ++ ; if ( c == '(' ) { return true ; } else if ( c != ' ' && c != '\n' && c != '\r' && c != '\t' ) { return false ; } } } catch ( IOException e ) { } finally { velcharstream . backup ( no ) ; } return false ; } final public SimpleNode process ( ) throws ParseException { ASTprocess jjtn000 = new ASTprocess ( this , JJTPROCESS ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { label_1 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LPAREN : case RPAREN : case ESCAPE_DIRECTIVE : case SET_DIRECTIVE : case SINGLE_LINE_COMMENT_START : case DOUBLE_ESCAPE : case ESCAPE : case TEXT : case FORMAL_COMMENT : case MULTI_LINE_COMMENT : case STRING_LITERAL : case IF_DIRECTIVE : case STOP_DIRECTIVE : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case WORD : case BRACKETED_WORD : case IDENTIFIER : case DOT : case LCURLY : case RCURLY : ; break ; default : jj_la1 [ 0 ] = jj_gen ; break label_1 ; } Statement ( ) ; } jj_consume_token ( 0 ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; { if ( true ) return jjtn000 ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } throw new Error ( "Missing return statement in function" ) ; } final public void Statement ( ) throws ParseException { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IF_DIRECTIVE : IfStatement ( ) ; break ; case STOP_DIRECTIVE : StopStatement ( ) ; break ; default : jj_la1 [ 1 ] = jj_gen ; if ( jj_2_1 ( 2 ) ) { Reference ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case SINGLE_LINE_COMMENT_START : case FORMAL_COMMENT : case MULTI_LINE_COMMENT : Comment ( ) ; break ; case SET_DIRECTIVE : SetDirective ( ) ; break ; case ESCAPE_DIRECTIVE : EscapedDirective ( ) ; break ; case DOUBLE_ESCAPE : Escape ( ) ; break ; case WORD : case BRACKETED_WORD : Directive ( ) ; break ; case LPAREN : case RPAREN : case ESCAPE : case TEXT : case STRING_LITERAL : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case DOT : case LCURLY : case RCURLY : Text ( ) ; break ; default : jj_la1 [ 2 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } } final public void EscapedDirective ( ) throws ParseException { ASTEscapedDirective jjtn000 = new ASTEscapedDirective ( this , JJTESCAPEDDIRECTIVE ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { Token t = null ; t = jj_consume_token ( ESCAPE_DIRECTIVE ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; t . image = escapedDirective ( t . image ) ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void Escape ( ) throws ParseException { ASTEscape jjtn000 = new ASTEscape ( this , JJTESCAPE ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { Token t = null ; int count = 0 ; boolean control = false ; label_2 : while ( true ) { t = jj_consume_token ( DOUBLE_ESCAPE ) ; count ++ ; if ( jj_2_2 ( 2 ) ) { ; } else { break label_2 ; } } jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; switch ( t . next . kind ) { case IF_DIRECTIVE : case ELSE_DIRECTIVE : case ELSEIF_DIRECTIVE : case END : case STOP_DIRECTIVE : control = true ; break ; } String nTag = t . next . image . substring ( 1 ) ; if ( isDirective ( nTag ) ) control = true ; else if ( rsvc . isVelocimacro ( nTag , currentTemplateName ) ) control = true ; jjtn000 . val = "" ; for ( int i = 0 ; i < count ; i ++ ) jjtn000 . val += ( control ? "\\" : "\\\\" ) ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void Comment ( ) throws ParseException { ASTComment jjtn000 = new ASTComment ( this , JJTCOMMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case SINGLE_LINE_COMMENT_START : jj_consume_token ( SINGLE_LINE_COMMENT_START ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case SINGLE_LINE_COMMENT : jj_consume_token ( SINGLE_LINE_COMMENT ) ; break ; default : jj_la1 [ 3 ] = jj_gen ; ; } break ; case MULTI_LINE_COMMENT : jj_consume_token ( MULTI_LINE_COMMENT ) ; break ; case FORMAL_COMMENT : jj_consume_token ( FORMAL_COMMENT ) ; break ; default : jj_la1 [ 4 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void FloatingPointLiteral ( ) throws ParseException { ASTFloatingPointLiteral jjtn000 = new ASTFloatingPointLiteral ( this , JJTFLOATINGPOINTLITERAL ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( FLOATING_POINT_LITERAL ) ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void IntegerLiteral ( ) throws ParseException { ASTIntegerLiteral jjtn000 = new ASTIntegerLiteral ( this , JJTINTEGERLITERAL ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( INTEGER_LITERAL ) ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void StringLiteral ( ) throws ParseException { ASTStringLiteral jjtn000 = new ASTStringLiteral ( this , JJTSTRINGLITERAL ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( STRING_LITERAL ) ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void Identifier ( ) throws ParseException { ASTIdentifier jjtn000 = new ASTIdentifier ( this , JJTIDENTIFIER ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( IDENTIFIER ) ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void Word ( ) throws ParseException { ASTWord jjtn000 = new ASTWord ( this , JJTWORD ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( WORD ) ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public int DirectiveArg ( ) throws ParseException { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : case LCURLY : Reference ( ) ; { if ( true ) return ParserTreeConstants . JJTREFERENCE ; } break ; case WORD : Word ( ) ; { if ( true ) return ParserTreeConstants . JJTWORD ; } break ; case STRING_LITERAL : StringLiteral ( ) ; { if ( true ) return ParserTreeConstants . JJTSTRINGLITERAL ; } break ; case INTEGER_LITERAL : IntegerLiteral ( ) ; { if ( true ) return ParserTreeConstants . JJTINTEGERLITERAL ; } break ; default : jj_la1 [ 5 ] = jj_gen ; if ( jj_2_3 ( 2147483647 ) ) { IntegerRange ( ) ; { if ( true ) return ParserTreeConstants . JJTINTEGERRANGE ; } } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case FLOATING_POINT_LITERAL : FloatingPointLiteral ( ) ; { if ( true ) return ParserTreeConstants . JJTFLOATINGPOINTLITERAL ; } break ; case LEFT_CURLEY : Map ( ) ; { if ( true ) return ParserTreeConstants . JJTMAP ; } break ; case LBRACKET : ObjectArray ( ) ; { if ( true ) return ParserTreeConstants . JJTOBJECTARRAY ; } break ; case TRUE : True ( ) ; { if ( true ) return ParserTreeConstants . JJTTRUE ; } break ; case FALSE : False ( ) ; { if ( true ) return ParserTreeConstants . JJTFALSE ; } break ; default : jj_la1 [ 6 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } throw new Error ( "Missing return statement in function" ) ; } final public SimpleNode Directive ( ) throws ParseException { ASTDirective jjtn000 = new ASTDirective ( this , JJTDIRECTIVE ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; Token t = null ; int argType ; int argPos = 0 ; Directive d ; int directiveType ; boolean isVM = false ; boolean doItNow = false ; try { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WORD : t = jj_consume_token ( WORD ) ; break ; case BRACKETED_WORD : t = jj_consume_token ( BRACKETED_WORD ) ; break ; default : jj_la1 [ 7 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } String directiveName ; if ( t . kind == ParserConstants . BRACKETED_WORD ) { directiveName = t . image . substring ( 2 , t . image . length ( ) - 1 ) ; } else { directiveName = t . image . substring ( 1 ) ; } d = ( Directive ) directives . get ( directiveName ) ; if ( directiveName . equals ( "macro" ) ) { doItNow = true ; } jjtn000 . setDirectiveName ( directiveName ) ; if ( d == null ) { isVM = rsvc . isVelocimacro ( directiveName , currentTemplateName ) ; directiveType = Directive . LINE ; } else { directiveType = d . getType ( ) ; } token_source . SwitchTo ( DIRECTIVE ) ; argPos = 0 ; if ( isLeftParenthesis ( ) ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 8 ] = jj_gen ; ; } jj_consume_token ( LPAREN ) ; label_3 : while ( true ) { if ( jj_2_4 ( 2 ) ) { ; } else { break label_3 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 9 ] = jj_gen ; ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case COMMA : jj_consume_token ( COMMA ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 10 ] = jj_gen ; ; } break ; default : jj_la1 [ 11 ] = jj_gen ; ; } argType = DirectiveArg ( ) ; if ( argType == ParserTreeConstants . JJTWORD ) { if ( doItNow && argPos == 0 ) { } else if ( isVM ) { { if ( true ) throw new MacroParseException ( "Invalid arg #" + argPos + " in VM " + t . image , currentTemplateName , t ) ; } } else if ( d != null && ( ! directiveName . equals ( "foreach" ) || argPos != 1 ) ) { { if ( true ) throw new MacroParseException ( "Invalid arg #" + argPos + " in directive " + t . image , currentTemplateName , t ) ; } } else { } } else { if ( doItNow && argPos == 0 ) { { if ( true ) throw new MacroParseException ( "Invalid first arg" + " in #macro() directive - must be a" + " word token (no \' or \" surrounding)" , currentTemplateName , t ) ; } } } argPos ++ ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 12 ] = jj_gen ; ; } jj_consume_token ( RPAREN ) ; if ( directiveType == Directive . LINE ) { { if ( true ) return jjtn000 ; } } } else { token_source . stateStackPop ( ) ; token_source . inDirective = false ; { if ( true ) return jjtn000 ; } } ASTBlock jjtn001 = new ASTBlock ( this , JJTBLOCK ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; try { label_4 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LPAREN : case RPAREN : case ESCAPE_DIRECTIVE : case SET_DIRECTIVE : case SINGLE_LINE_COMMENT_START : case DOUBLE_ESCAPE : case ESCAPE : case TEXT : case FORMAL_COMMENT : case MULTI_LINE_COMMENT : case STRING_LITERAL : case IF_DIRECTIVE : case STOP_DIRECTIVE : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case WORD : case BRACKETED_WORD : case IDENTIFIER : case DOT : case LCURLY : case RCURLY : ; break ; default : jj_la1 [ 13 ] = jj_gen ; break label_4 ; } Statement ( ) ; } } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , true ) ; } } jj_consume_token ( END ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; if ( doItNow ) { Macro . processAndRegister ( rsvc , t , jjtn000 , currentTemplateName ) ; } { if ( true ) return jjtn000 ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } throw new Error ( "Missing return statement in function" ) ; } final public void Map ( ) throws ParseException { ASTMap jjtn000 = new ASTMap ( this , JJTMAP ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( LEFT_CURLEY ) ; if ( jj_2_5 ( 2 ) ) { Parameter ( ) ; jj_consume_token ( COLON ) ; Parameter ( ) ; label_5 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case COMMA : ; break ; default : jj_la1 [ 14 ] = jj_gen ; break label_5 ; } jj_consume_token ( COMMA ) ; Parameter ( ) ; jj_consume_token ( COLON ) ; Parameter ( ) ; } } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 15 ] = jj_gen ; ; } } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case RIGHT_CURLEY : jj_consume_token ( RIGHT_CURLEY ) ; break ; case RCURLY : jj_consume_token ( RCURLY ) ; break ; default : jj_la1 [ 16 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void ObjectArray ( ) throws ParseException { ASTObjectArray jjtn000 = new ASTObjectArray ( this , JJTOBJECTARRAY ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( LBRACKET ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACKET : case LEFT_CURLEY : case WHITESPACE : case STRING_LITERAL : case TRUE : case FALSE : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case IDENTIFIER : case LCURLY : Parameter ( ) ; label_6 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case COMMA : ; break ; default : jj_la1 [ 17 ] = jj_gen ; break label_6 ; } jj_consume_token ( COMMA ) ; Parameter ( ) ; } break ; default : jj_la1 [ 18 ] = jj_gen ; ; } jj_consume_token ( RBRACKET ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void IntegerRange ( ) throws ParseException { ASTIntegerRange jjtn000 = new ASTIntegerRange ( this , JJTINTEGERRANGE ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( LBRACKET ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 19 ] = jj_gen ; ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : case LCURLY : Reference ( ) ; break ; case INTEGER_LITERAL : IntegerLiteral ( ) ; break ; default : jj_la1 [ 20 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 21 ] = jj_gen ; ; } jj_consume_token ( DOUBLEDOT ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 22 ] = jj_gen ; ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : case LCURLY : Reference ( ) ; break ; case INTEGER_LITERAL : IntegerLiteral ( ) ; break ; default : jj_la1 [ 23 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 24 ] = jj_gen ; ; } jj_consume_token ( RBRACKET ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void Parameter ( ) throws ParseException { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 25 ] = jj_gen ; ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case STRING_LITERAL : StringLiteral ( ) ; break ; case INTEGER_LITERAL : IntegerLiteral ( ) ; break ; default : jj_la1 [ 26 ] = jj_gen ; if ( jj_2_6 ( 2147483647 ) ) { IntegerRange ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LEFT_CURLEY : Map ( ) ; break ; case LBRACKET : ObjectArray ( ) ; break ; case TRUE : True ( ) ; break ; case FALSE : False ( ) ; break ; case IDENTIFIER : case LCURLY : Reference ( ) ; break ; case FLOATING_POINT_LITERAL : FloatingPointLiteral ( ) ; break ; default : jj_la1 [ 27 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 28 ] = jj_gen ; ; } } final public void Method ( ) throws ParseException { ASTMethod jjtn000 = new ASTMethod ( this , JJTMETHOD ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { Identifier ( ) ; jj_consume_token ( LPAREN ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACKET : case LEFT_CURLEY : case WHITESPACE : case STRING_LITERAL : case TRUE : case FALSE : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case IDENTIFIER : case LCURLY : Parameter ( ) ; label_7 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case COMMA : ; break ; default : jj_la1 [ 29 ] = jj_gen ; break label_7 ; } jj_consume_token ( COMMA ) ; Parameter ( ) ; } break ; default : jj_la1 [ 30 ] = jj_gen ; ; } jj_consume_token ( REFMOD2_RPAREN ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void Reference ( ) throws ParseException { ASTReference jjtn000 = new ASTReference ( this , JJTREFERENCE ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : jj_consume_token ( IDENTIFIER ) ; label_8 : while ( true ) { if ( jj_2_7 ( 2 ) ) { ; } else { break label_8 ; } jj_consume_token ( DOT ) ; if ( jj_2_8 ( 3 ) ) { Method ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : Identifier ( ) ; break ; default : jj_la1 [ 31 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } break ; case LCURLY : jj_consume_token ( LCURLY ) ; jj_consume_token ( IDENTIFIER ) ; label_9 : while ( true ) { if ( jj_2_9 ( 2 ) ) { ; } else { break label_9 ; } jj_consume_token ( DOT ) ; if ( jj_2_10 ( 3 ) ) { Method ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : Identifier ( ) ; break ; default : jj_la1 [ 32 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } jj_consume_token ( RCURLY ) ; break ; default : jj_la1 [ 33 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void True ( ) throws ParseException { ASTTrue jjtn000 = new ASTTrue ( this , JJTTRUE ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( TRUE ) ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void False ( ) throws ParseException { ASTFalse jjtn000 = new ASTFalse ( this , JJTFALSE ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( FALSE ) ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void Text ( ) throws ParseException { ASTText jjtn000 = new ASTText ( this , JJTTEXT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case TEXT : jj_consume_token ( TEXT ) ; break ; case DOT : jj_consume_token ( DOT ) ; break ; case RPAREN : jj_consume_token ( RPAREN ) ; break ; case LPAREN : jj_consume_token ( LPAREN ) ; break ; case INTEGER_LITERAL : jj_consume_token ( INTEGER_LITERAL ) ; break ; case FLOATING_POINT_LITERAL : jj_consume_token ( FLOATING_POINT_LITERAL ) ; break ; case STRING_LITERAL : jj_consume_token ( STRING_LITERAL ) ; break ; case ESCAPE : jj_consume_token ( ESCAPE ) ; break ; case LCURLY : jj_consume_token ( LCURLY ) ; break ; case RCURLY : jj_consume_token ( RCURLY ) ; break ; default : jj_la1 [ 34 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void IfStatement ( ) throws ParseException { ASTIfStatement jjtn000 = new ASTIfStatement ( this , JJTIFSTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( IF_DIRECTIVE ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 35 ] = jj_gen ; ; } jj_consume_token ( LPAREN ) ; Expression ( ) ; jj_consume_token ( RPAREN ) ; ASTBlock jjtn001 = new ASTBlock ( this , JJTBLOCK ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; try { label_10 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LPAREN : case RPAREN : case ESCAPE_DIRECTIVE : case SET_DIRECTIVE : case SINGLE_LINE_COMMENT_START : case DOUBLE_ESCAPE : case ESCAPE : case TEXT : case FORMAL_COMMENT : case MULTI_LINE_COMMENT : case STRING_LITERAL : case IF_DIRECTIVE : case STOP_DIRECTIVE : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case WORD : case BRACKETED_WORD : case IDENTIFIER : case DOT : case LCURLY : case RCURLY : ; break ; default : jj_la1 [ 36 ] = jj_gen ; break label_10 ; } Statement ( ) ; } } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , true ) ; } } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case ELSEIF_DIRECTIVE : label_11 : while ( true ) { ElseIfStatement ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case ELSEIF_DIRECTIVE : ; break ; default : jj_la1 [ 37 ] = jj_gen ; break label_11 ; } } break ; default : jj_la1 [ 38 ] = jj_gen ; ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case ELSE_DIRECTIVE : ElseStatement ( ) ; break ; default : jj_la1 [ 39 ] = jj_gen ; ; } jj_consume_token ( END ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void ElseStatement ( ) throws ParseException { ASTElseStatement jjtn000 = new ASTElseStatement ( this , JJTELSESTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( ELSE_DIRECTIVE ) ; ASTBlock jjtn001 = new ASTBlock ( this , JJTBLOCK ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; try { label_12 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LPAREN : case RPAREN : case ESCAPE_DIRECTIVE : case SET_DIRECTIVE : case SINGLE_LINE_COMMENT_START : case DOUBLE_ESCAPE : case ESCAPE : case TEXT : case FORMAL_COMMENT : case MULTI_LINE_COMMENT : case STRING_LITERAL : case IF_DIRECTIVE : case STOP_DIRECTIVE : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case WORD : case BRACKETED_WORD : case IDENTIFIER : case DOT : case LCURLY : case RCURLY : ; break ; default : jj_la1 [ 40 ] = jj_gen ; break label_12 ; } Statement ( ) ; } } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , true ) ; } } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void ElseIfStatement ( ) throws ParseException { ASTElseIfStatement jjtn000 = new ASTElseIfStatement ( this , JJTELSEIFSTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( ELSEIF_DIRECTIVE ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 41 ] = jj_gen ; ; } jj_consume_token ( LPAREN ) ; Expression ( ) ; jj_consume_token ( RPAREN ) ; ASTBlock jjtn001 = new ASTBlock ( this , JJTBLOCK ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; try { label_13 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LPAREN : case RPAREN : case ESCAPE_DIRECTIVE : case SET_DIRECTIVE : case SINGLE_LINE_COMMENT_START : case DOUBLE_ESCAPE : case ESCAPE : case TEXT : case FORMAL_COMMENT : case MULTI_LINE_COMMENT : case STRING_LITERAL : case IF_DIRECTIVE : case STOP_DIRECTIVE : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case WORD : case BRACKETED_WORD : case IDENTIFIER : case DOT : case LCURLY : case RCURLY : ; break ; default : jj_la1 [ 42 ] = jj_gen ; break label_13 ; } Statement ( ) ; } } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , true ) ; } } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void SetDirective ( ) throws ParseException { ASTSetDirective jjtn000 = new ASTSetDirective ( this , JJTSETDIRECTIVE ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( SET_DIRECTIVE ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 43 ] = jj_gen ; ; } Reference ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 44 ] = jj_gen ; ; } jj_consume_token ( EQUALS ) ; Expression ( ) ; jj_consume_token ( RPAREN ) ; token_source . inSet = false ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case NEWLINE : jj_consume_token ( NEWLINE ) ; break ; default : jj_la1 [ 45 ] = jj_gen ; ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void StopStatement ( ) throws ParseException { ASTStop jjtn000 = new ASTStop ( this , JJTSTOP ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( STOP_DIRECTIVE ) ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , 0 ) ; } } } final public void Expression ( ) throws ParseException { ASTExpression jjtn000 = new ASTExpression ( this , JJTEXPRESSION ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { ConditionalOrExpression ( ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void Assignment ( ) throws ParseException { ASTAssignment jjtn000 = new ASTAssignment ( this , JJTASSIGNMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { PrimaryExpression ( ) ; jj_consume_token ( EQUALS ) ; Expression ( ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , 2 ) ; } } } final public void ConditionalOrExpression ( ) throws ParseException { ConditionalAndExpression ( ) ; label_14 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LOGICAL_OR : ; break ; default : jj_la1 [ 46 ] = jj_gen ; break label_14 ; } jj_consume_token ( LOGICAL_OR ) ; ASTOrNode jjtn001 = new ASTOrNode ( this , JJTORNODE ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; try { ConditionalAndExpression ( ) ; } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; } } } } final public void ConditionalAndExpression ( ) throws ParseException { EqualityExpression ( ) ; label_15 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LOGICAL_AND : ; break ; default : jj_la1 [ 47 ] = jj_gen ; break label_15 ; } jj_consume_token ( LOGICAL_AND ) ; ASTAndNode jjtn001 = new ASTAndNode ( this , JJTANDNODE ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; try { EqualityExpression ( ) ; } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; } } } } final public void EqualityExpression ( ) throws ParseException { RelationalExpression ( ) ; label_16 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LOGICAL_EQUALS : case LOGICAL_NOT_EQUALS : ; break ; default : jj_la1 [ 48 ] = jj_gen ; break label_16 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LOGICAL_EQUALS : jj_consume_token ( LOGICAL_EQUALS ) ; ASTEQNode jjtn001 = new ASTEQNode ( this , JJTEQNODE ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; try { RelationalExpression ( ) ; } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; } } break ; case LOGICAL_NOT_EQUALS : jj_consume_token ( LOGICAL_NOT_EQUALS ) ; ASTNENode jjtn002 = new ASTNENode ( this , JJTNENODE ) ; boolean jjtc002 = true ; jjtree . openNodeScope ( jjtn002 ) ; try { RelationalExpression ( ) ; } catch ( Throwable jjte002 ) { if ( jjtc002 ) { jjtree . clearNodeScope ( jjtn002 ) ; jjtc002 = false ; } else { jjtree . popNode ( ) ; } if ( jjte002 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte002 ; } } if ( jjte002 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte002 ; } } { if ( true ) throw ( Error ) jjte002 ; } } finally { if ( jjtc002 ) { jjtree . closeNodeScope ( jjtn002 , 2 ) ; } } break ; default : jj_la1 [ 49 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void RelationalExpression ( ) throws ParseException { AdditiveExpression ( ) ; label_17 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LOGICAL_LT : case LOGICAL_LE : case LOGICAL_GT : case LOGICAL_GE : ; break ; default : jj_la1 [ 50 ] = jj_gen ; break label_17 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LOGICAL_LT : jj_consume_token ( LOGICAL_LT ) ; ASTLTNode jjtn001 = new ASTLTNode ( this , JJTLTNODE ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; try { AdditiveExpression ( ) ; } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; } } break ; case LOGICAL_GT : jj_consume_token ( LOGICAL_GT ) ; ASTGTNode jjtn002 = new ASTGTNode ( this , JJTGTNODE ) ; boolean jjtc002 = true ; jjtree . openNodeScope ( jjtn002 ) ; try { AdditiveExpression ( ) ; } catch ( Throwable jjte002 ) { if ( jjtc002 ) { jjtree . clearNodeScope ( jjtn002 ) ; jjtc002 = false ; } else { jjtree . popNode ( ) ; } if ( jjte002 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte002 ; } } if ( jjte002 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte002 ; } } { if ( true ) throw ( Error ) jjte002 ; } } finally { if ( jjtc002 ) { jjtree . closeNodeScope ( jjtn002 , 2 ) ; } } break ; case LOGICAL_LE : jj_consume_token ( LOGICAL_LE ) ; ASTLENode jjtn003 = new ASTLENode ( this , JJTLENODE ) ; boolean jjtc003 = true ; jjtree . openNodeScope ( jjtn003 ) ; try { AdditiveExpression ( ) ; } catch ( Throwable jjte003 ) { if ( jjtc003 ) { jjtree . clearNodeScope ( jjtn003 ) ; jjtc003 = false ; } else { jjtree . popNode ( ) ; } if ( jjte003 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte003 ; } } if ( jjte003 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte003 ; } } { if ( true ) throw ( Error ) jjte003 ; } } finally { if ( jjtc003 ) { jjtree . closeNodeScope ( jjtn003 , 2 ) ; } } break ; case LOGICAL_GE : jj_consume_token ( LOGICAL_GE ) ; ASTGENode jjtn004 = new ASTGENode ( this , JJTGENODE ) ; boolean jjtc004 = true ; jjtree . openNodeScope ( jjtn004 ) ; try { AdditiveExpression ( ) ; } catch ( Throwable jjte004 ) { if ( jjtc004 ) { jjtree . clearNodeScope ( jjtn004 ) ; jjtc004 = false ; } else { jjtree . popNode ( ) ; } if ( jjte004 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte004 ; } } if ( jjte004 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte004 ; } } { if ( true ) throw ( Error ) jjte004 ; } } finally { if ( jjtc004 ) { jjtree . closeNodeScope ( jjtn004 , 2 ) ; } } break ; default : jj_la1 [ 51 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void AdditiveExpression ( ) throws ParseException { MultiplicativeExpression ( ) ; label_18 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case MINUS : case PLUS : ; break ; default : jj_la1 [ 52 ] = jj_gen ; break label_18 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case PLUS : jj_consume_token ( PLUS ) ; ASTAddNode jjtn001 = new ASTAddNode ( this , JJTADDNODE ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; try { MultiplicativeExpression ( ) ; } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; } } break ; case MINUS : jj_consume_token ( MINUS ) ; ASTSubtractNode jjtn002 = new ASTSubtractNode ( this , JJTSUBTRACTNODE ) ; boolean jjtc002 = true ; jjtree . openNodeScope ( jjtn002 ) ; try { MultiplicativeExpression ( ) ; } catch ( Throwable jjte002 ) { if ( jjtc002 ) { jjtree . clearNodeScope ( jjtn002 ) ; jjtc002 = false ; } else { jjtree . popNode ( ) ; } if ( jjte002 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte002 ; } } if ( jjte002 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte002 ; } } { if ( true ) throw ( Error ) jjte002 ; } } finally { if ( jjtc002 ) { jjtree . closeNodeScope ( jjtn002 , 2 ) ; } } break ; default : jj_la1 [ 53 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void MultiplicativeExpression ( ) throws ParseException { UnaryExpression ( ) ; label_19 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case MULTIPLY : case DIVIDE : case MODULUS : ; break ; default : jj_la1 [ 54 ] = jj_gen ; break label_19 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case MULTIPLY : jj_consume_token ( MULTIPLY ) ; ASTMulNode jjtn001 = new ASTMulNode ( this , JJTMULNODE ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; try { UnaryExpression ( ) ; } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; } } break ; case DIVIDE : jj_consume_token ( DIVIDE ) ; ASTDivNode jjtn002 = new ASTDivNode ( this , JJTDIVNODE ) ; boolean jjtc002 = true ; jjtree . openNodeScope ( jjtn002 ) ; try { UnaryExpression ( ) ; } catch ( Throwable jjte002 ) { if ( jjtc002 ) { jjtree . clearNodeScope ( jjtn002 ) ; jjtc002 = false ; } else { jjtree . popNode ( ) ; } if ( jjte002 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte002 ; } } if ( jjte002 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte002 ; } } { if ( true ) throw ( Error ) jjte002 ; } } finally { if ( jjtc002 ) { jjtree . closeNodeScope ( jjtn002 , 2 ) ; } } break ; case MODULUS : jj_consume_token ( MODULUS ) ; ASTModNode jjtn003 = new ASTModNode ( this , JJTMODNODE ) ; boolean jjtc003 = true ; jjtree . openNodeScope ( jjtn003 ) ; try { UnaryExpression ( ) ; } catch ( Throwable jjte003 ) { if ( jjtc003 ) { jjtree . clearNodeScope ( jjtn003 ) ; jjtc003 = false ; } else { jjtree . popNode ( ) ; } if ( jjte003 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte003 ; } } if ( jjte003 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte003 ; } } { if ( true ) throw ( Error ) jjte003 ; } } finally { if ( jjtc003 ) { jjtree . closeNodeScope ( jjtn003 , 2 ) ; } } break ; default : jj_la1 [ 55 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void UnaryExpression ( ) throws ParseException { if ( jj_2_11 ( 2 ) ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 56 ] = jj_gen ; ; } jj_consume_token ( LOGICAL_NOT ) ; ASTNotNode jjtn001 = new ASTNotNode ( this , JJTNOTNODE ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; try { UnaryExpression ( ) ; } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 1 ) ; } } } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACKET : case LEFT_CURLEY : case LPAREN : case WHITESPACE : case STRING_LITERAL : case TRUE : case FALSE : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case IDENTIFIER : case LCURLY : PrimaryExpression ( ) ; break ; default : jj_la1 [ 57 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void PrimaryExpression ( ) throws ParseException { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 58 ] = jj_gen ; ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case STRING_LITERAL : StringLiteral ( ) ; break ; case IDENTIFIER : case LCURLY : Reference ( ) ; break ; case INTEGER_LITERAL : IntegerLiteral ( ) ; break ; default : jj_la1 [ 59 ] = jj_gen ; if ( jj_2_12 ( 2147483647 ) ) { IntegerRange ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case FLOATING_POINT_LITERAL : FloatingPointLiteral ( ) ; break ; case LEFT_CURLEY : Map ( ) ; break ; case LBRACKET : ObjectArray ( ) ; break ; case TRUE : True ( ) ; break ; case FALSE : False ( ) ; break ; case LPAREN : jj_consume_token ( LPAREN ) ; Expression ( ) ; jj_consume_token ( RPAREN ) ; break ; default : jj_la1 [ 60 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 61 ] = jj_gen ; ; } } private boolean jj_2_1 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; try { return ! jj_3_1 ( ) ; } catch ( LookaheadSuccess ls ) { return true ; } finally { jj_save ( 0 , xla ) ; } } private boolean jj_2_2 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; try { return ! jj_3_2 ( ) ; } catch ( LookaheadSuccess ls ) { return true ; } finally { jj_save ( 1 , xla ) ; } } private boolean jj_2_3 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; try { return ! jj_3_3 ( ) ; } catch ( LookaheadSuccess ls ) { return true ; } finally { jj_save ( 2 , xla ) ; } } private boolean jj_2_4 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; try { return ! jj_3_4 ( ) ; } catch ( LookaheadSuccess ls ) { return true ; } finally { jj_save ( 3 , xla ) ; } } private boolean jj_2_5 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; try { return ! jj_3_5 ( ) ; } catch ( LookaheadSuccess ls ) { return true ; } finally { jj_save ( 4 , xla ) ; } } private boolean jj_2_6 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; try { return ! jj_3_6 ( ) ; } catch ( LookaheadSuccess ls ) { return true ; } finally { jj_save ( 5 , xla ) ; } } private boolean jj_2_7 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; try { return ! jj_3_7 ( ) ; } catch ( LookaheadSuccess ls ) { return true ; } finally { jj_save ( 6 , xla ) ; } } private boolean jj_2_8 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; try { return ! jj_3_8 ( ) ; } catch ( LookaheadSuccess ls ) { return true ; } finally { jj_save ( 7 , xla ) ; } } private boolean jj_2_9 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; try { return ! jj_3_9 ( ) ; } catch ( LookaheadSuccess ls ) { return true ; } finally { jj_save ( 8 , xla ) ; } } private boolean jj_2_10 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; try { return ! jj_3_10 ( ) ; } catch ( LookaheadSuccess ls ) { return true ; } finally { jj_save ( 9 , xla ) ; } } private boolean jj_2_11 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; try { return ! jj_3_11 ( ) ; } catch ( LookaheadSuccess ls ) { return true ; } finally { jj_save ( 10 , xla ) ; } } private boolean jj_2_12 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; try { return ! jj_3_12 ( ) ; } catch ( LookaheadSuccess ls ) { return true ; } finally { jj_save ( 11 , xla ) ; } } private boolean jj_3R_45 ( ) { if ( jj_3R_65 ( ) ) return true ; return false ; } private boolean jj_3_3 ( ) { if ( jj_scan_token ( LBRACKET ) ) return true ; Token xsp ; xsp = jj_scanpos ; if ( jj_scan_token ( 26 ) ) jj_scanpos = xsp ; xsp = jj_scanpos ; if ( jj_3R_21 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_22 ( ) ) return true ; } xsp = jj_scanpos ; if ( jj_scan_token ( 26 ) ) jj_scanpos = xsp ; if ( jj_scan_token ( DOUBLEDOT ) ) return true ; return false ; } private boolean jj_3R_44 ( ) { if ( jj_3R_64 ( ) ) return true ; return false ; } private boolean jj_3R_43 ( ) { if ( jj_3R_63 ( ) ) return true ; return false ; } private boolean jj_3R_42 ( ) { if ( jj_3R_62 ( ) ) return true ; return false ; } private boolean jj_3R_41 ( ) { if ( jj_3R_61 ( ) ) return true ; return false ; } private boolean jj_3R_40 ( ) { if ( jj_3R_36 ( ) ) return true ; return false ; } private boolean jj_3R_39 ( ) { if ( jj_3R_60 ( ) ) return true ; return false ; } private boolean jj_3R_38 ( ) { if ( jj_3R_59 ( ) ) return true ; return false ; } private boolean jj_3R_23 ( ) { if ( jj_scan_token ( COMMA ) ) return true ; Token xsp ; xsp = jj_scanpos ; if ( jj_scan_token ( 26 ) ) jj_scanpos = xsp ; return false ; } private boolean jj_3R_37 ( ) { if ( jj_3R_20 ( ) ) return true ; return false ; } private boolean jj_3R_24 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_37 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_38 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_39 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_40 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_41 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_42 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_43 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_44 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_45 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_46 ( ) ) return true ; } } } } } } } } } return false ; } private boolean jj_3R_59 ( ) { if ( jj_scan_token ( WORD ) ) return true ; return false ; } private boolean jj_3R_56 ( ) { if ( jj_scan_token ( IDENTIFIER ) ) return true ; return false ; } private boolean jj_3R_30 ( ) { if ( jj_3R_56 ( ) ) return true ; return false ; } private boolean jj_3_4 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_scan_token ( 26 ) ) jj_scanpos = xsp ; xsp = jj_scanpos ; if ( jj_3R_23 ( ) ) jj_scanpos = xsp ; if ( jj_3R_24 ( ) ) return true ; return false ; } private boolean jj_3R_60 ( ) { if ( jj_scan_token ( STRING_LITERAL ) ) return true ; return false ; } private boolean jj_3R_28 ( ) { if ( jj_3R_56 ( ) ) return true ; return false ; } private boolean jj_3R_33 ( ) { if ( jj_3R_36 ( ) ) return true ; return false ; } private boolean jj_3R_36 ( ) { if ( jj_scan_token ( INTEGER_LITERAL ) ) return true ; return false ; } private boolean jj_3R_62 ( ) { if ( jj_scan_token ( FLOATING_POINT_LITERAL ) ) return true ; return false ; } private boolean jj_3R_32 ( ) { if ( jj_3R_20 ( ) ) return true ; return false ; } private boolean jj_3R_27 ( ) { if ( jj_3R_36 ( ) ) return true ; return false ; } private boolean jj_3_10 ( ) { if ( jj_3R_29 ( ) ) return true ; return false ; } private boolean jj_3R_82 ( ) { if ( jj_scan_token ( COMMA ) ) return true ; if ( jj_3R_25 ( ) ) return true ; return false ; } private boolean jj_3_8 ( ) { if ( jj_3R_29 ( ) ) return true ; return false ; } private boolean jj_3R_26 ( ) { if ( jj_3R_20 ( ) ) return true ; return false ; } private boolean jj_3R_66 ( ) { if ( jj_scan_token ( FALSE ) ) return true ; return false ; } private boolean jj_3R_65 ( ) { if ( jj_scan_token ( TRUE ) ) return true ; return false ; } private boolean jj_3_9 ( ) { if ( jj_scan_token ( DOT ) ) return true ; Token xsp ; xsp = jj_scanpos ; if ( jj_3_10 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_30 ( ) ) return true ; } return false ; } private boolean jj_3R_57 ( ) { if ( jj_3R_25 ( ) ) return true ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_82 ( ) ) { jj_scanpos = xsp ; break ; } } return false ; } private boolean jj_3_7 ( ) { if ( jj_scan_token ( DOT ) ) return true ; Token xsp ; xsp = jj_scanpos ; if ( jj_3_8 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_28 ( ) ) return true ; } return false ; } private boolean jj_3R_35 ( ) { if ( jj_scan_token ( LCURLY ) ) return true ; if ( jj_scan_token ( IDENTIFIER ) ) return true ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3_9 ( ) ) { jj_scanpos = xsp ; break ; } } if ( jj_scan_token ( RCURLY ) ) return true ; return false ; } private boolean jj_3_12 ( ) { if ( jj_scan_token ( LBRACKET ) ) return true ; Token xsp ; xsp = jj_scanpos ; if ( jj_scan_token ( 26 ) ) jj_scanpos = xsp ; xsp = jj_scanpos ; if ( jj_3R_32 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_33 ( ) ) return true ; } xsp = jj_scanpos ; if ( jj_scan_token ( 26 ) ) jj_scanpos = xsp ; if ( jj_scan_token ( DOUBLEDOT ) ) return true ; return false ; } private boolean jj_3R_34 ( ) { if ( jj_scan_token ( IDENTIFIER ) ) return true ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3_7 ( ) ) { jj_scanpos = xsp ; break ; } } return false ; } private boolean jj_3R_81 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; return false ; } private boolean jj_3R_80 ( ) { if ( jj_3R_66 ( ) ) return true ; return false ; } private boolean jj_3R_79 ( ) { if ( jj_3R_65 ( ) ) return true ; return false ; } private boolean jj_3_2 ( ) { if ( jj_scan_token ( DOUBLE_ESCAPE ) ) return true ; return false ; } private boolean jj_3R_20 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_34 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_35 ( ) ) return true ; } return false ; } private boolean jj_3R_78 ( ) { if ( jj_3R_64 ( ) ) return true ; return false ; } private boolean jj_3R_77 ( ) { if ( jj_3R_63 ( ) ) return true ; return false ; } private boolean jj_3R_76 ( ) { if ( jj_3R_62 ( ) ) return true ; return false ; } private boolean jj_3R_75 ( ) { if ( jj_3R_61 ( ) ) return true ; return false ; } private boolean jj_3R_74 ( ) { if ( jj_3R_36 ( ) ) return true ; return false ; } private boolean jj_3R_73 ( ) { if ( jj_3R_20 ( ) ) return true ; return false ; } private boolean jj_3_6 ( ) { if ( jj_scan_token ( LBRACKET ) ) return true ; Token xsp ; xsp = jj_scanpos ; if ( jj_scan_token ( 26 ) ) jj_scanpos = xsp ; xsp = jj_scanpos ; if ( jj_3R_26 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_27 ( ) ) return true ; } xsp = jj_scanpos ; if ( jj_scan_token ( 26 ) ) jj_scanpos = xsp ; if ( jj_scan_token ( DOUBLEDOT ) ) return true ; return false ; } private boolean jj_3R_29 ( ) { if ( jj_3R_56 ( ) ) return true ; if ( jj_scan_token ( LPAREN ) ) return true ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_57 ( ) ) jj_scanpos = xsp ; if ( jj_scan_token ( REFMOD2_RPAREN ) ) return true ; return false ; } private boolean jj_3R_72 ( ) { if ( jj_3R_60 ( ) ) return true ; return false ; } private boolean jj_3R_67 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_scan_token ( 26 ) ) jj_scanpos = xsp ; xsp = jj_scanpos ; if ( jj_3R_72 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_73 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_74 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_75 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_76 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_77 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_78 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_79 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_80 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_81 ( ) ) return true ; } } } } } } } } } return false ; } private boolean jj_3R_55 ( ) { if ( jj_3R_62 ( ) ) return true ; return false ; } private boolean jj_3R_54 ( ) { if ( jj_3R_20 ( ) ) return true ; return false ; } private boolean jj_3R_53 ( ) { if ( jj_3R_66 ( ) ) return true ; return false ; } private boolean jj_3R_52 ( ) { if ( jj_3R_65 ( ) ) return true ; return false ; } private boolean jj_3R_31 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3_11 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_58 ( ) ) return true ; } return false ; } private boolean jj_3_11 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_scan_token ( 26 ) ) jj_scanpos = xsp ; if ( jj_scan_token ( LOGICAL_NOT ) ) return true ; if ( jj_3R_31 ( ) ) return true ; return false ; } private boolean jj_3R_58 ( ) { if ( jj_3R_67 ( ) ) return true ; return false ; } private boolean jj_3R_51 ( ) { if ( jj_3R_64 ( ) ) return true ; return false ; } private boolean jj_3R_85 ( ) { if ( jj_scan_token ( COMMA ) ) return true ; if ( jj_3R_25 ( ) ) return true ; if ( jj_scan_token ( COLON ) ) return true ; if ( jj_3R_25 ( ) ) return true ; return false ; } private boolean jj_3R_50 ( ) { if ( jj_3R_63 ( ) ) return true ; return false ; } private boolean jj_3R_49 ( ) { if ( jj_3R_61 ( ) ) return true ; return false ; } private boolean jj_3R_48 ( ) { if ( jj_3R_36 ( ) ) return true ; return false ; } private boolean jj_3R_47 ( ) { if ( jj_3R_60 ( ) ) return true ; return false ; } private boolean jj_3R_84 ( ) { if ( jj_3R_36 ( ) ) return true ; return false ; } private boolean jj_3R_69 ( ) { if ( jj_3R_36 ( ) ) return true ; return false ; } private boolean jj_3R_86 ( ) { if ( jj_scan_token ( COMMA ) ) return true ; if ( jj_3R_25 ( ) ) return true ; return false ; } private boolean jj_3R_25 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_scan_token ( 26 ) ) jj_scanpos = xsp ; xsp = jj_scanpos ; if ( jj_3R_47 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_48 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_49 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_50 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_51 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_52 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_53 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_54 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_55 ( ) ) return true ; } } } } } } } } xsp = jj_scanpos ; if ( jj_scan_token ( 26 ) ) jj_scanpos = xsp ; return false ; } private boolean jj_3R_22 ( ) { if ( jj_3R_36 ( ) ) return true ; return false ; } private boolean jj_3R_83 ( ) { if ( jj_3R_20 ( ) ) return true ; return false ; } private boolean jj_3R_68 ( ) { if ( jj_3R_20 ( ) ) return true ; return false ; } private boolean jj_3R_71 ( ) { if ( jj_3R_25 ( ) ) return true ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_86 ( ) ) { jj_scanpos = xsp ; break ; } } return false ; } private boolean jj_3R_61 ( ) { if ( jj_scan_token ( LBRACKET ) ) return true ; Token xsp ; xsp = jj_scanpos ; if ( jj_scan_token ( 26 ) ) jj_scanpos = xsp ; xsp = jj_scanpos ; if ( jj_3R_68 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_69 ( ) ) return true ; } xsp = jj_scanpos ; if ( jj_scan_token ( 26 ) ) jj_scanpos = xsp ; if ( jj_scan_token ( DOUBLEDOT ) ) return true ; xsp = jj_scanpos ; if ( jj_scan_token ( 26 ) ) jj_scanpos = xsp ; xsp = jj_scanpos ; if ( jj_3R_83 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_84 ( ) ) return true ; } xsp = jj_scanpos ; if ( jj_scan_token ( 26 ) ) jj_scanpos = xsp ; if ( jj_scan_token ( RBRACKET ) ) return true ; return false ; } private boolean jj_3_1 ( ) { if ( jj_3R_20 ( ) ) return true ; return false ; } private boolean jj_3R_21 ( ) { if ( jj_3R_20 ( ) ) return true ; return false ; } private boolean jj_3R_64 ( ) { if ( jj_scan_token ( LBRACKET ) ) return true ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_71 ( ) ) jj_scanpos = xsp ; if ( jj_scan_token ( RBRACKET ) ) return true ; return false ; } private boolean jj_3R_70 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_scan_token ( 26 ) ) jj_scanpos = xsp ; return false ; } private boolean jj_3_5 ( ) { if ( jj_3R_25 ( ) ) return true ; if ( jj_scan_token ( COLON ) ) return true ; if ( jj_3R_25 ( ) ) return true ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_85 ( ) ) { jj_scanpos = xsp ; break ; } } return false ; } private boolean jj_3R_46 ( ) { if ( jj_3R_66 ( ) ) return true ; return false ; } private boolean jj_3R_63 ( ) { if ( jj_scan_token ( LEFT_CURLEY ) ) return true ; Token xsp ; xsp = jj_scanpos ; if ( jj_3_5 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_70 ( ) ) return true ; } xsp = jj_scanpos ; if ( jj_scan_token ( 7 ) ) { jj_scanpos = xsp ; if ( jj_scan_token ( 65 ) ) return true ; } return false ; } public ParserTokenManager token_source ; public Token token ; public Token jj_nt ; private int jj_ntk ; private Token jj_scanpos , jj_lastpos ; private int jj_la ; private int jj_gen ; final private int [ ] jj_la1 = new int [ 62 ] ; static private int [ ] jj_la1_0 ; static private int [ ] jj_la1_1 ; static private int [ ] jj_la1_2 ; static { jj_la1_init_0 ( ) ; jj_la1_init_1 ( ) ; jj_la1_init_2 ( ) ; } private static void jj_la1_init_0 ( ) { jj_la1_0 = new int [ ] { 0x9bc1b00 , 0x0 , 0x9bc1b00 , 0x400000 , 0x1840000 , 0x8000000 , 0x30000042 , 0x0 , 0x4000000 , 0x4000000 , 0x4000000 , 0x8 , 0x4000000 , 0x9bc1b00 , 0x8 , 0x4000000 , 0x80 , 0x8 , 0x3c000042 , 0x4000000 , 0x0 , 0x4000000 , 0x4000000 , 0x0 , 0x4000000 , 0x4000000 , 0x8000000 , 0x30000042 , 0x4000000 , 0x8 , 0x3c000042 , 0x0 , 0x0 , 0x0 , 0x8300300 , 0x4000000 , 0x9bc1b00 , 0x0 , 0x0 , 0x0 , 0x9bc1b00 , 0x4000000 , 0x9bc1b00 , 0x4000000 , 0x4000000 , 0x40000000 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x80000000 , 0x80000000 , 0x0 , 0x0 , 0x4000000 , 0x3c000142 , 0x4000000 , 0x8000000 , 0x30000142 , 0x4000000 , } ; } private static void jj_la1_init_1 ( ) { jj_la1_1 = new int [ ] { 0xc6348000 , 0x48000 , 0x86300000 , 0x0 , 0x0 , 0x42100000 , 0x200000 , 0x6000000 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0xc6348000 , 0x0 , 0x0 , 0x0 , 0x0 , 0x40300000 , 0x0 , 0x40100000 , 0x0 , 0x0 , 0x40100000 , 0x0 , 0x0 , 0x100000 , 0x40200000 , 0x0 , 0x0 , 0x40300000 , 0x40000000 , 0x40000000 , 0x40000000 , 0x80300000 , 0x0 , 0xc6348000 , 0x10000 , 0x10000 , 0x20000 , 0xc6348000 , 0x0 , 0xc6348000 , 0x0 , 0x0 , 0x0 , 0x20 , 0x10 , 0xc00 , 0xc00 , 0x3c0 , 0x3c0 , 0x1 , 0x1 , 0xe , 0xe , 0x0 , 0x40300000 , 0x0 , 0x40100000 , 0x200000 , 0x0 , } ; } private static void jj_la1_init_2 ( ) { jj_la1_2 = new int [ ] { 0x3 , 0x0 , 0x3 , 0x0 , 0x0 , 0x1 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x3 , 0x0 , 0x0 , 0x2 , 0x0 , 0x1 , 0x0 , 0x1 , 0x0 , 0x0 , 0x1 , 0x0 , 0x0 , 0x0 , 0x1 , 0x0 , 0x0 , 0x1 , 0x0 , 0x0 , 0x1 , 0x3 , 0x0 , 0x3 , 0x0 , 0x0 , 0x0 , 0x3 , 0x0 , 0x3 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x1 , 0x0 , 0x1 , 0x0 , 0x0 , } ; } final private JJCalls [ ] jj_2_rtns = new JJCalls [ 12 ] ; private boolean jj_rescan = false ; private int jj_gc = 0 ; public Parser ( CharStream stream ) { token_source = new ParserTokenManager ( stream ) ; token = new Token ( ) ; jj_ntk = - 1 ; jj_gen = 0 ; for ( int i = 0 ; i < 62 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; } public void ReInit ( CharStream stream ) { token_source . ReInit ( stream ) ; token = new Token ( ) ; jj_ntk = - 1 ; jjtree . reset ( ) ; jj_gen = 0 ; for ( int i = 0 ; i < 62 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; } public Parser ( ParserTokenManager tm ) { token_source = tm ; token = new Token ( ) ; jj_ntk = - 1 ; jj_gen = 0 ; for ( int i = 0 ; i < 62 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; } public void ReInit ( ParserTokenManager tm ) { token_source = tm ; token = new Token ( ) ; jj_ntk = - 1 ; jjtree . reset ( ) ; jj_gen = 0 ; for ( int i = 0 ; i < 62 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; } private Token jj_consume_token ( int kind ) throws ParseException { Token oldToken ; if ( ( oldToken = token ) . next != null ) token = token . next ; else token = token . next = token_source . getNextToken ( ) ; jj_ntk = - 1 ; if ( token . kind == kind ) { jj_gen ++ ; if ( ++ jj_gc > 100 ) { jj_gc = 0 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) { JJCalls c = jj_2_rtns [ i ] ; while ( c != null ) { if ( c . gen < jj_gen ) c . first = null ; c = c . next ; } } } return token ; } token = oldToken ; jj_kind = kind ; throw generateParseException ( ) ; } static private final class LookaheadSuccess extends java . lang . Error { } final private LookaheadSuccess jj_ls = new LookaheadSuccess ( ) ; private boolean jj_scan_token ( int kind ) { if ( jj_scanpos == jj_lastpos ) { jj_la -- ; if ( jj_scanpos . next == null ) { jj_lastpos = jj_scanpos = jj_scanpos . next = token_source . getNextToken ( ) ; } else { jj_lastpos = jj_scanpos = jj_scanpos . next ; } } else { jj_scanpos = jj_scanpos . next ; } if ( jj_rescan ) { int i = 0 ; Token tok = token ; while ( tok != null && tok != jj_scanpos ) { i ++ ; tok = tok . next ; } if ( tok != null ) jj_add_error_token ( kind , i ) ; } if ( jj_scanpos . kind != kind ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) throw jj_ls ; return false ; } final public Token getNextToken ( ) { if ( token . next != null ) token = token . next ; else token = token . next = token_source . getNextToken ( ) ; jj_ntk = - 1 ; jj_gen ++ ; return token ; } final public Token getToken ( int index ) { Token t = token ; for ( int i = 0 ; i < index ; i ++ ) { if ( t . next != null ) t = t . next ; else t = t . next = token_source . getNextToken ( ) ; } return t ; } private int jj_ntk ( ) { if ( ( jj_nt = token . next ) == null ) return ( jj_ntk = ( token . next = token_source . getNextToken ( ) ) . kind ) ; else return ( jj_ntk = jj_nt . kind ) ; } private java . util . List jj_expentries = new java . util . ArrayList ( ) ; private int [ ] jj_expentry ; private int jj_kind = - 1 ; private int [ ] jj_lasttokens = new int [ 100 ] ; private int jj_endpos ; private void jj_add_error_token ( int kind , int pos ) { if ( pos >= 100 ) return ; if ( pos == jj_endpos + 1 ) { jj_lasttokens [ jj_endpos ++ ] = kind ; } else if ( jj_endpos != 0 ) { jj_expentry = new int [ jj_endpos ] ; for ( int i = 0 ; i < jj_endpos ; i ++ ) { jj_expentry [ i ] = jj_lasttokens [ i ] ; } jj_entries_loop : for ( java . util . Iterator it = jj_expentries . iterator ( ) ; it . hasNext ( ) ; ) { int [ ] oldentry = ( int [ ] ) ( it . next ( ) ) ; if ( oldentry . length == jj_expentry . length ) { for ( int i = 0 ; i < jj_expentry . length ; i ++ ) { if ( oldentry [ i ] != jj_expentry [ i ] ) { continue jj_entries_loop ; } } jj_expentries . add ( jj_expentry ) ; break jj_entries_loop ; } } if ( pos != 0 ) jj_lasttokens [ ( jj_endpos = pos ) - 1 ] = kind ; } } public ParseException generateParseException ( ) { jj_expentries . clear ( ) ; boolean [ ] la1tokens = new boolean [ 68 ] ; if ( jj_kind >= 0 ) { la1tokens [ jj_kind ] = true ; jj_kind = - 1 ; } for ( int i = 0 ; i < 62 ; i ++ ) { if ( jj_la1 [ i ] == jj_gen ) { for ( int j = 0 ; j < 32 ; j ++ ) { if ( ( jj_la1_0 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ j ] = true ; } if ( ( jj_la1_1 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ 32 + j ] = true ; } if ( ( jj_la1_2 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ 64 + j ] = true ; } } } } for ( int i = 0 ; i < 68 ; i ++ ) { if ( la1tokens [ i ] ) { jj_expentry = new int [ 1 ] ; jj_expentry [ 0 ] = i ; jj_expentries . add ( jj_expentry ) ; } } jj_endpos = 0 ; jj_rescan_token ( ) ; jj_add_error_token ( 0 , 0 ) ; int [ ] [ ] exptokseq = new int [ jj_expentries . size ( ) ] [ ] ; for ( int i = 0 ; i < jj_expentries . size ( ) ; i ++ ) { exptokseq [ i ] = ( int [ ] ) jj_expentries . get ( i ) ; } return new ParseException ( token , exptokseq , tokenImage ) ; } final public void enable_tracing ( ) { } final public void disable_tracing ( ) { } private void jj_rescan_token ( ) { jj_rescan = true ; for ( int i = 0 ; i < 12 ; i ++ ) { try { JJCalls p = jj_2_rtns [ i ] ; do { if ( p . gen > jj_gen ) { jj_la = p . arg ; jj_lastpos = jj_scanpos = p . first ; switch ( i ) { case 0 : jj_3_1 ( ) ; break ; case 1 : jj_3_2 ( ) ; break ; case 2 : jj_3_3 ( ) ; break ; case 3 : jj_3_4 ( ) ; break ; case 4 : jj_3_5 ( ) ; break ; case 5 : jj_3_6 ( ) ; break ; case 6 : jj_3_7 ( ) ; break ; case 7 : jj_3_8 ( ) ; break ; case 8 : jj_3_9 ( ) ; break ; case 9 : jj_3_10 ( ) ; break ; case 10 : jj_3_11 ( ) ; break ; case 11 : jj_3_12 ( ) ; break ; } } p = p . next ; } while ( p != null ) ; } catch ( LookaheadSuccess ls ) { } } jj_rescan = false ; } private void jj_save ( int index , int xla ) { JJCalls p = jj_2_rtns [ index ] ; while ( p . gen > jj_gen ) { if ( p . next == null ) { p = p . next = new JJCalls ( ) ; break ; } p = p . next ; } p . gen = jj_gen + xla - jj_la ; p . first = token ; p . arg = xla ; } static final class JJCalls { int gen ; Token first ; int arg ; JJCalls next ; } } 	1	['153', '1', '0', '68', '250', '8092', '49', '61', '50', '0.743421053', '8270', '0.807692308', '10', '0', '0.145559211', '0', '0', '52.88235294', '12', '2.6275', '11']
package org . apache . velocity . app . event . implement ; import org . apache . commons . lang . StringEscapeUtils ; public class EscapeJavaScriptReference extends EscapeReference { protected String escape ( Object text ) { return StringEscapeUtils . escapeJavaScript ( text . toString ( ) ) ; } protected String getMatchAttribute ( ) { return "eventhandler.escape.javascript.match" ; } } 	0	['3', '2', '0', '2', '6', '3', '0', '2', '1', '2', '12', '0', '0', '0.714285714', '0.666666667', '1', '2', '3', '1', '0.6667', '0']
package org . apache . velocity . runtime . log ; import java . io . PrintStream ; import org . apache . velocity . runtime . RuntimeServices ; public class SystemLogChute implements LogChute { public static final String RUNTIME_LOG_LEVEL_KEY = "runtime.log.logsystem.system.level" ; public static final String RUNTIME_LOG_SYSTEM_ERR_LEVEL_KEY = "runtime.log.logsystem.system.err.level" ; private int enabled = WARN_ID ; private int errLevel = TRACE_ID ; public void init ( RuntimeServices rs ) throws Exception { String level = ( String ) rs . getProperty ( RUNTIME_LOG_LEVEL_KEY ) ; if ( level != null ) { setEnabledLevel ( toLevel ( level ) ) ; } String errLevel = ( String ) rs . getProperty ( RUNTIME_LOG_SYSTEM_ERR_LEVEL_KEY ) ; if ( errLevel != null ) { setSystemErrLevel ( toLevel ( errLevel ) ) ; } } protected int toLevel ( String level ) { if ( level . equalsIgnoreCase ( "debug" ) ) { return DEBUG_ID ; } else if ( level . equalsIgnoreCase ( "info" ) ) { return INFO_ID ; } else if ( level . equalsIgnoreCase ( "warn" ) ) { return WARN_ID ; } else if ( level . equalsIgnoreCase ( "error" ) ) { return ERROR_ID ; } else { return TRACE_ID ; } } protected String getPrefix ( int level ) { switch ( level ) { case WARN_ID : return WARN_PREFIX ; case DEBUG_ID : return DEBUG_PREFIX ; case TRACE_ID : return TRACE_PREFIX ; case ERROR_ID : return ERROR_PREFIX ; case INFO_ID : default : return INFO_PREFIX ; } } public void log ( int level , String message ) { log ( level , message , null ) ; } public void log ( int level , String message , Throwable t ) { if ( ! isLevelEnabled ( level ) ) { return ; } String prefix = getPrefix ( level ) ; if ( level >= this . errLevel ) { write ( System . err , prefix , message , t ) ; } else { write ( System . out , prefix , message , t ) ; } } protected void write ( PrintStream stream , String prefix , String message , Throwable t ) { stream . print ( prefix ) ; stream . println ( message ) ; if ( t != null ) { stream . println ( t . getMessage ( ) ) ; t . printStackTrace ( stream ) ; } } public void setEnabledLevel ( int level ) { this . enabled = level ; } public int getEnabledLevel ( ) { return this . enabled ; } public void setSystemErrLevel ( int level ) { this . errLevel = level ; } public int getSystemErrLevel ( ) { return this . errLevel ; } public boolean isLevelEnabled ( int level ) { return ( level >= this . enabled ) ; } } 	1	['12', '1', '0', '3', '19', '42', '1', '2', '9', '0.818181818', '159', '0.5', '0', '0', '0.361111111', '0', '0', '11.91666667', '5', '1.6667', '2']
package org . apache . velocity . app . event ; import java . util . Iterator ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . util . ExceptionUtils ; import org . apache . velocity . util . introspection . Info ; public class EventHandlerUtil { public static Object referenceInsert ( RuntimeServices rsvc , InternalContextAdapter context , String reference , Object value ) { EventCartridge ev1 = rsvc . getApplicationEventCartridge ( ) ; Iterator applicationEventHandlerIterator = ( ev1 == null ) ? null : ev1 . getReferenceInsertionEventHandlers ( ) ; EventCartridge ev2 = context . getEventCartridge ( ) ; initializeEventCartridge ( rsvc , ev2 ) ; Iterator contextEventHandlerIterator = ( ev2 == null ) ? null : ev2 . getReferenceInsertionEventHandlers ( ) ; try { EventHandlerMethodExecutor methodExecutor = null ; if ( applicationEventHandlerIterator != null ) { methodExecutor = new ReferenceInsertionEventHandler . referenceInsertExecutor ( context , reference , value ) ; iterateOverEventHandlers ( applicationEventHandlerIterator , methodExecutor ) ; } if ( contextEventHandlerIterator != null ) { if ( methodExecutor == null ) methodExecutor = new ReferenceInsertionEventHandler . referenceInsertExecutor ( context , reference , value ) ; iterateOverEventHandlers ( contextEventHandlerIterator , methodExecutor ) ; } return methodExecutor != null ? methodExecutor . getReturnValue ( ) : value ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { throw ExceptionUtils . createRuntimeException ( "Exception in event handler." , e ) ; } } public static boolean shouldLogOnNullSet ( RuntimeServices rsvc , InternalContextAdapter context , String lhs , String rhs ) { EventCartridge ev1 = rsvc . getApplicationEventCartridge ( ) ; Iterator applicationEventHandlerIterator = ( ev1 == null ) ? null : ev1 . getNullSetEventHandlers ( ) ; EventCartridge ev2 = context . getEventCartridge ( ) ; initializeEventCartridge ( rsvc , ev2 ) ; Iterator contextEventHandlerIterator = ( ev2 == null ) ? null : ev2 . getNullSetEventHandlers ( ) ; try { EventHandlerMethodExecutor methodExecutor = new NullSetEventHandler . ShouldLogOnNullSetExecutor ( context , lhs , rhs ) ; callEventHandlers ( applicationEventHandlerIterator , contextEventHandlerIterator , methodExecutor ) ; return ( ( Boolean ) methodExecutor . getReturnValue ( ) ) . booleanValue ( ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { throw ExceptionUtils . createRuntimeException ( "Exception in event handler." , e ) ; } } public static Object methodException ( RuntimeServices rsvc , InternalContextAdapter context , Class claz , String method , Exception e ) throws Exception { EventCartridge ev1 = rsvc . getApplicationEventCartridge ( ) ; Iterator applicationEventHandlerIterator = ( ev1 == null ) ? null : ev1 . getMethodExceptionEventHandlers ( ) ; EventCartridge ev2 = context . getEventCartridge ( ) ; initializeEventCartridge ( rsvc , ev2 ) ; Iterator contextEventHandlerIterator = ( ev2 == null ) ? null : ev2 . getMethodExceptionEventHandlers ( ) ; EventHandlerMethodExecutor methodExecutor = new MethodExceptionEventHandler . MethodExceptionExecutor ( context , claz , method , e ) ; if ( ( ( applicationEventHandlerIterator == null ) || ! applicationEventHandlerIterator . hasNext ( ) ) && ( ( contextEventHandlerIterator == null ) || ! contextEventHandlerIterator . hasNext ( ) ) ) { throw e ; } callEventHandlers ( applicationEventHandlerIterator , contextEventHandlerIterator , methodExecutor ) ; return methodExecutor . getReturnValue ( ) ; } public static String includeEvent ( RuntimeServices rsvc , InternalContextAdapter context , String includeResourcePath , String currentResourcePath , String directiveName ) { EventCartridge ev1 = rsvc . getApplicationEventCartridge ( ) ; Iterator applicationEventHandlerIterator = ( ev1 == null ) ? null : ev1 . getIncludeEventHandlers ( ) ; EventCartridge ev2 = context . getEventCartridge ( ) ; initializeEventCartridge ( rsvc , ev2 ) ; Iterator contextEventHandlerIterator = ( ev2 == null ) ? null : ev2 . getIncludeEventHandlers ( ) ; try { EventHandlerMethodExecutor methodExecutor = new IncludeEventHandler . IncludeEventExecutor ( context , includeResourcePath , currentResourcePath , directiveName ) ; callEventHandlers ( applicationEventHandlerIterator , contextEventHandlerIterator , methodExecutor ) ; return ( String ) methodExecutor . getReturnValue ( ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { throw ExceptionUtils . createRuntimeException ( "Exception in event handler." , e ) ; } } public static Object invalidGetMethod ( RuntimeServices rsvc , InternalContextAdapter context , String reference , Object object , String property , Info info ) { return invalidReferenceHandlerCall ( new InvalidReferenceEventHandler . InvalidGetMethodExecutor ( context , reference , object , property , info ) , rsvc , context ) ; } public static void invalidSetMethod ( RuntimeServices rsvc , InternalContextAdapter context , String leftreference , String rightreference , Info info ) { invalidReferenceHandlerCall ( new InvalidReferenceEventHandler . InvalidSetMethodExecutor ( context , leftreference , rightreference , info ) , rsvc , context ) ; } public static Object invalidMethod ( RuntimeServices rsvc , InternalContextAdapter context , String reference , Object object , String method , Info info ) { return invalidReferenceHandlerCall ( new InvalidReferenceEventHandler . InvalidMethodExecutor ( context , reference , object , method , info ) , rsvc , context ) ; } public static Object invalidReferenceHandlerCall ( EventHandlerMethodExecutor methodExecutor , RuntimeServices rsvc , InternalContextAdapter context ) { EventCartridge ev1 = rsvc . getApplicationEventCartridge ( ) ; Iterator applicationEventHandlerIterator = ( ev1 == null ) ? null : ev1 . getInvalidReferenceEventHandlers ( ) ; EventCartridge ev2 = context . getEventCartridge ( ) ; initializeEventCartridge ( rsvc , ev2 ) ; Iterator contextEventHandlerIterator = ( ev2 == null ) ? null : ev2 . getInvalidReferenceEventHandlers ( ) ; try { callEventHandlers ( applicationEventHandlerIterator , contextEventHandlerIterator , methodExecutor ) ; return methodExecutor . getReturnValue ( ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { throw ExceptionUtils . createRuntimeException ( "Exception in event handler." , e ) ; } } private static void initializeEventCartridge ( RuntimeServices rsvc , EventCartridge eventCartridge ) { if ( eventCartridge != null ) { try { eventCartridge . initialize ( rsvc ) ; } catch ( Exception e ) { throw ExceptionUtils . createRuntimeException ( "Couldn't initialize event cartridge : " , e ) ; } } } private static void callEventHandlers ( Iterator applicationEventHandlerIterator , Iterator contextEventHandlerIterator , EventHandlerMethodExecutor eventExecutor ) throws Exception { iterateOverEventHandlers ( applicationEventHandlerIterator , eventExecutor ) ; iterateOverEventHandlers ( contextEventHandlerIterator , eventExecutor ) ; } private static void iterateOverEventHandlers ( Iterator handlerIterator , EventHandlerMethodExecutor eventExecutor ) throws Exception { if ( handlerIterator != null ) { for ( Iterator i = handlerIterator ; i . hasNext ( ) ; ) { EventHandler eventHandler = ( EventHandler ) i . next ( ) ; if ( ! eventExecutor . isDone ( ) ) { eventExecutor . execute ( eventHandler ) ; } } } } } 	0	['12', '1', '0', '21', '35', '66', '6', '15', '9', '2', '337', '0', '0', '0', '0.295454545', '0', '0', '27.08333333', '7', '2', '0']
package org . apache . velocity . runtime . directive ; import java . io . IOException ; import java . io . Writer ; import java . util . Iterator ; import java . util . List ; import org . apache . velocity . app . event . EventCartridge ; import org . apache . velocity . context . Context ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . parser . node . ASTReference ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . runtime . parser . node . SimpleNode ; import org . apache . velocity . runtime . resource . Resource ; import org . apache . velocity . util . introspection . Info ; import org . apache . velocity . util . introspection . IntrospectionCacheData ; public class Break extends Directive { public String getName ( ) { return "break" ; } public int getType ( ) { return LINE ; } public void init ( RuntimeServices rs , InternalContextAdapter context , Node node ) throws TemplateInitException { super . init ( rs , context , node ) ; } public boolean render ( InternalContextAdapter context , Writer writer , Node node ) throws IOException , MethodInvocationException , ResourceNotFoundException , ParseErrorException { throw new BreakException ( ) ; } public static class BreakException extends RuntimeException { } } 	1	['5', '2', '0', '9', '8', '10', '0', '9', '5', '2', '22', '0', '0', '0.692307692', '0.44', '0', '0', '3.4', '1', '0.8', '5']
package org . apache . velocity . context ; public abstract class AbstractContext extends InternalContextBase implements Context { private Context innerContext = null ; public abstract Object internalGet ( String key ) ; public abstract Object internalPut ( String key , Object value ) ; public abstract boolean internalContainsKey ( Object key ) ; public abstract Object [ ] internalGetKeys ( ) ; public abstract Object internalRemove ( Object key ) ; public AbstractContext ( ) { } public AbstractContext ( Context inner ) { innerContext = inner ; if ( innerContext instanceof InternalEventContext ) { attachEventCartridge ( ( ( InternalEventContext ) innerContext ) . getEventCartridge ( ) ) ; } } public Object put ( String key , Object value ) { if ( key == null ) { return null ; } return internalPut ( key , value ) ; } public Object get ( String key ) { if ( key == null ) { return null ; } Object o = internalGet ( key ) ; if ( o == null && innerContext != null ) { o = innerContext . get ( key ) ; } return o ; } public boolean containsKey ( Object key ) { if ( key == null ) { return false ; } boolean exists = internalContainsKey ( key ) ; if ( ! exists && innerContext != null ) { exists = innerContext . containsKey ( key ) ; } return exists ; } public Object [ ] getKeys ( ) { return internalGetKeys ( ) ; } public Object remove ( Object key ) { if ( key == null ) { return null ; } return internalRemove ( key ) ; } public Context getChainedContext ( ) { return innerContext ; } } 	0	['13', '2', '1', '5', '18', '58', '1', '4', '13', '0.666666667', '103', '1', '1', '0.633333333', '0.461538462', '0', '0', '6.846153846', '4', '1.4615', '0']
package org . apache . velocity . runtime . parser . node ; import java . io . IOException ; import java . io . Writer ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; public class ASTEscapedDirective extends SimpleNode { public ASTEscapedDirective ( int id ) { super ( id ) ; } public ASTEscapedDirective ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException { if ( context . getAllowRendering ( ) ) { writer . write ( getFirstToken ( ) . image ) ; } return true ; } } 	1	['4', '2', '0', '7', '10', '6', '4', '5', '4', '2', '28', '0', '0', '0.9375', '0.392857143', '0', '0', '6', '1', '0.5', '1']
package org . apache . velocity . runtime . parser ; public class TokenMgrError extends Error { static final int LEXICAL_ERROR = 0 ; static final int STATIC_LEXER_ERROR = 1 ; static final int INVALID_LEXICAL_STATE = 2 ; static final int LOOP_DETECTED = 3 ; int errorCode ; protected static final String addEscapes ( String str ) { StringBuffer retval = new StringBuffer ( ) ; char ch ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { switch ( str . charAt ( i ) ) { case 0 : continue ; case '\b' : retval . append ( "\\b" ) ; continue ; case '\t' : retval . append ( "\\t" ) ; continue ; case '\n' : retval . append ( "\\n" ) ; continue ; case '\f' : retval . append ( "\\f" ) ; continue ; case '\r' : retval . append ( "\\r" ) ; continue ; case '\"' : retval . append ( "\\\"" ) ; continue ; case '\'' : retval . append ( "\\\'" ) ; continue ; case '\\' : retval . append ( "\\\\" ) ; continue ; default : if ( ( ch = str . charAt ( i ) ) < 0x20 || ch > 0x7e ) { String s = "0000" + Integer . toString ( ch , 16 ) ; retval . append ( "\\u" + s . substring ( s . length ( ) - 4 , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . toString ( ) ; } protected static String LexicalError ( boolean EOFSeen , int lexState , int errorLine , int errorColumn , String errorAfter , char curChar ) { return ( "Lexical error at line " + errorLine + ", column " + errorColumn + ".  Encountered: " + ( EOFSeen ? "<EOF> " : ( "\"" + addEscapes ( String . valueOf ( curChar ) ) + "\"" ) + " (" + ( int ) curChar + "), " ) + "after : \"" + addEscapes ( errorAfter ) + "\"" ) ; } public String getMessage ( ) { return super . getMessage ( ) ; } public TokenMgrError ( ) { } public TokenMgrError ( String message , int reason ) { super ( message ) ; errorCode = reason ; } public TokenMgrError ( boolean EOFSeen , int lexState , int errorLine , int errorColumn , String errorAfter , char curChar , int reason ) { this ( LexicalError ( EOFSeen , lexState , errorLine , errorColumn , errorAfter , curChar ) , reason ) ; } } 	0	['6', '3', '0', '2', '19', '15', '2', '0', '4', '1.12', '184', '0', '0', '0.8125', '0.5', '1', '1', '28.83333333', '14', '2.8333', '0']
package org . apache . velocity . runtime . parser ; import java . io . * ; import java . util . * ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . parser . node . * ; import org . apache . velocity . runtime . directive . Directive ; import org . apache . velocity . runtime . directive . Macro ; import org . apache . velocity . runtime . directive . MacroParseException ; import org . apache . velocity . util . StringUtils ; public class ParserTokenManager implements ParserConstants { private int fileDepth = 0 ; private int lparen = 0 ; private int rparen = 0 ; Stack stateStack = new Stack ( ) ; public boolean debugPrint = false ; private boolean inReference ; public boolean inDirective ; private boolean inComment ; public boolean inSet ; public boolean stateStackPop ( ) { Hashtable h ; try { h = ( Hashtable ) stateStack . pop ( ) ; } catch ( EmptyStackException e ) { lparen = 0 ; SwitchTo ( DEFAULT ) ; return false ; } if ( debugPrint ) System . out . println ( " stack pop (" + stateStack . size ( ) + ") : lparen=" + ( ( Integer ) h . get ( "lparen" ) ) . intValue ( ) + " newstate=" + ( ( Integer ) h . get ( "lexstate" ) ) . intValue ( ) ) ; lparen = ( ( Integer ) h . get ( "lparen" ) ) . intValue ( ) ; rparen = ( ( Integer ) h . get ( "rparen" ) ) . intValue ( ) ; SwitchTo ( ( ( Integer ) h . get ( "lexstate" ) ) . intValue ( ) ) ; return true ; } public boolean stateStackPush ( ) { if ( debugPrint ) System . out . println ( " (" + stateStack . size ( ) + ") pushing cur state : " + curLexState ) ; Hashtable h = new Hashtable ( ) ; h . put ( "lexstate" , new Integer ( curLexState ) ) ; h . put ( "lparen" , new Integer ( lparen ) ) ; h . put ( "rparen" , new Integer ( rparen ) ) ; lparen = 0 ; stateStack . push ( h ) ; return true ; } public void clearStateVars ( ) { stateStack . clear ( ) ; lparen = 0 ; rparen = 0 ; inReference = false ; inDirective = false ; inComment = false ; inSet = false ; return ; } private void RPARENHandler ( ) { boolean closed = false ; if ( inComment ) closed = true ; while ( ! closed ) { if ( lparen > 0 ) { if ( lparen == rparen + 1 ) { stateStackPop ( ) ; } else { rparen ++ ; } closed = true ; } else { if ( ! stateStackPop ( ) ) break ; } } } public java . io . PrintStream debugStream = System . out ; public void setDebugStream ( java . io . PrintStream ds ) { debugStream = ds ; } private final int jjStopStringLiteralDfa_0 ( int pos , long active0 ) { switch ( pos ) { case 0 : if ( ( active0 & 0x10L ) != 0L ) return 58 ; if ( ( active0 & 0x80000000L ) != 0L ) return 101 ; if ( ( active0 & 0x40L ) != 0L ) return 65 ; if ( ( active0 & 0x30000000L ) != 0L ) { jjmatchedKind = 57 ; return 63 ; } if ( ( active0 & 0x200000000000L ) != 0L ) return 50 ; if ( ( active0 & 0x70000L ) != 0L ) return 7 ; return - 1 ; case 1 : if ( ( active0 & 0x10000L ) != 0L ) return 5 ; if ( ( active0 & 0x30000000L ) != 0L ) { jjmatchedKind = 57 ; jjmatchedPos = 1 ; return 63 ; } return - 1 ; case 2 : if ( ( active0 & 0x30000000L ) != 0L ) { jjmatchedKind = 57 ; jjmatchedPos = 2 ; return 63 ; } return - 1 ; case 3 : if ( ( active0 & 0x10000000L ) != 0L ) return 63 ; if ( ( active0 & 0x20000000L ) != 0L ) { jjmatchedKind = 57 ; jjmatchedPos = 3 ; return 63 ; } return - 1 ; default : return - 1 ; } } private final int jjStartNfa_0 ( int pos , long active0 ) { return jjMoveNfa_0 ( jjStopStringLiteralDfa_0 ( pos , active0 ) , pos + 1 ) ; } private int jjStopAtPos ( int pos , int kind ) { jjmatchedKind = kind ; jjmatchedPos = pos ; return pos + 1 ; } private int jjMoveStringLiteralDfa0_0 ( ) { switch ( curChar ) { case 35 : jjmatchedKind = 17 ; return jjMoveStringLiteralDfa1_0 ( 0x50000L ) ; case 37 : return jjStopAtPos ( 0 , 35 ) ; case 40 : return jjStopAtPos ( 0 , 8 ) ; case 42 : return jjStopAtPos ( 0 , 33 ) ; case 43 : return jjStopAtPos ( 0 , 32 ) ; case 44 : return jjStopAtPos ( 0 , 3 ) ; case 45 : return jjStartNfaWithStates_0 ( 0 , 31 , 101 ) ; case 46 : return jjMoveStringLiteralDfa1_0 ( 0x10L ) ; case 47 : return jjStopAtPos ( 0 , 34 ) ; case 58 : return jjStopAtPos ( 0 , 5 ) ; case 61 : return jjStartNfaWithStates_0 ( 0 , 45 , 50 ) ; case 91 : return jjStopAtPos ( 0 , 1 ) ; case 93 : return jjStopAtPos ( 0 , 2 ) ; case 102 : return jjMoveStringLiteralDfa1_0 ( 0x20000000L ) ; case 116 : return jjMoveStringLiteralDfa1_0 ( 0x10000000L ) ; case 123 : return jjStartNfaWithStates_0 ( 0 , 6 , 65 ) ; case 125 : return jjStopAtPos ( 0 , 7 ) ; default : return jjMoveNfa_0 ( 0 , 0 ) ; } } private int jjMoveStringLiteralDfa1_0 ( long active0 ) { try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 0 , active0 ) ; return 1 ; } switch ( curChar ) { case 35 : if ( ( active0 & 0x40000L ) != 0L ) return jjStopAtPos ( 1 , 18 ) ; break ; case 42 : if ( ( active0 & 0x10000L ) != 0L ) return jjStartNfaWithStates_0 ( 1 , 16 , 5 ) ; break ; case 46 : if ( ( active0 & 0x10L ) != 0L ) return jjStopAtPos ( 1 , 4 ) ; break ; case 97 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x20000000L ) ; case 114 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x10000000L ) ; default : break ; } return jjStartNfa_0 ( 0 , active0 ) ; } private int jjMoveStringLiteralDfa2_0 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0L ) return jjStartNfa_0 ( 0 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 1 , active0 ) ; return 2 ; } switch ( curChar ) { case 108 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x20000000L ) ; case 117 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x10000000L ) ; default : break ; } return jjStartNfa_0 ( 1 , active0 ) ; } private int jjMoveStringLiteralDfa3_0 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0L ) return jjStartNfa_0 ( 1 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 2 , active0 ) ; return 3 ; } switch ( curChar ) { case 101 : if ( ( active0 & 0x10000000L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 28 , 63 ) ; break ; case 115 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x20000000L ) ; default : break ; } return jjStartNfa_0 ( 2 , active0 ) ; } private int jjMoveStringLiteralDfa4_0 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0L ) return jjStartNfa_0 ( 2 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 3 , active0 ) ; return 4 ; } switch ( curChar ) { case 101 : if ( ( active0 & 0x20000000L ) != 0L ) return jjStartNfaWithStates_0 ( 4 , 29 , 63 ) ; break ; default : break ; } return jjStartNfa_0 ( 3 , active0 ) ; } private int jjStartNfaWithStates_0 ( int pos , int kind , int state ) { jjmatchedKind = kind ; jjmatchedPos = pos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return pos + 1 ; } return jjMoveNfa_0 ( state , pos + 1 ) ; } static final long [ ] jjbitVec0 = { 0xfffffffffffffffeL , 0xffffffffffffffffL , 0xffffffffffffffffL , 0xffffffffffffffffL } ; static final long [ ] jjbitVec2 = { 0x0L , 0x0L , 0xffffffffffffffffL , 0xffffffffffffffffL } ; private int jjMoveNfa_0 ( int startState , int curPos ) { int startsAt = 0 ; jjnewStateCnt = 101 ; int i = 1 ; jjstateSet [ 0 ] = startState ; int kind = 0x7fffffff ; for ( ; ; ) { if ( ++ jjround == 0x7fffffff ) ReInitRounds ( ) ; if ( curChar < 64 ) { long l = 1L << curChar ; do { switch ( jjstateSet [ -- i ] ) { case 0 : if ( ( 0x3ff000000000000L & l ) != 0L ) { if ( kind > 52 ) kind = 52 ; jjCheckNAddStates ( 0 , 5 ) ; } else if ( ( 0x100002600L & l ) != 0L ) { if ( kind > 26 ) kind = 26 ; jjCheckNAdd ( 9 ) ; } else if ( curChar == 45 ) jjCheckNAddStates ( 6 , 9 ) ; else if ( curChar == 36 ) { if ( kind > 13 ) kind = 13 ; jjCheckNAddTwoStates ( 73 , 74 ) ; } else if ( curChar == 46 ) jjCheckNAdd ( 58 ) ; else if ( curChar == 33 ) { if ( kind > 44 ) kind = 44 ; } else if ( curChar == 61 ) jjstateSet [ jjnewStateCnt ++ ] = 50 ; else if ( curChar == 62 ) jjstateSet [ jjnewStateCnt ++ ] = 48 ; else if ( curChar == 60 ) jjstateSet [ jjnewStateCnt ++ ] = 45 ; else if ( curChar == 38 ) jjstateSet [ jjnewStateCnt ++ ] = 35 ; else if ( curChar == 39 ) jjCheckNAddStates ( 10 , 12 ) ; else if ( curChar == 34 ) jjCheckNAddStates ( 13 , 15 ) ; else if ( curChar == 35 ) jjstateSet [ jjnewStateCnt ++ ] = 7 ; else if ( curChar == 41 ) { if ( kind > 9 ) kind = 9 ; jjCheckNAddStates ( 16 , 18 ) ; } if ( ( 0x2400L & l ) != 0L ) { if ( kind > 30 ) kind = 30 ; } else if ( curChar == 33 ) jjstateSet [ jjnewStateCnt ++ ] = 54 ; else if ( curChar == 62 ) { if ( kind > 40 ) kind = 40 ; } else if ( curChar == 60 ) { if ( kind > 38 ) kind = 38 ; } if ( curChar == 13 ) jjstateSet [ jjnewStateCnt ++ ] = 33 ; break ; case 101 : if ( ( 0x3ff000000000000L & l ) != 0L ) jjCheckNAddTwoStates ( 96 , 97 ) ; else if ( curChar == 46 ) jjCheckNAdd ( 58 ) ; if ( ( 0x3ff000000000000L & l ) != 0L ) jjCheckNAddTwoStates ( 90 , 91 ) ; if ( ( 0x3ff000000000000L & l ) != 0L ) { if ( kind > 52 ) kind = 52 ; jjCheckNAddTwoStates ( 87 , 89 ) ; } break ; case 1 : if ( ( 0x100000200L & l ) != 0L ) jjCheckNAddStates ( 16 , 18 ) ; break ; case 2 : if ( ( 0x2400L & l ) != 0L && kind > 9 ) kind = 9 ; break ; case 3 : if ( curChar == 10 && kind > 9 ) kind = 9 ; break ; case 4 : if ( curChar == 13 ) jjstateSet [ jjnewStateCnt ++ ] = 3 ; break ; case 5 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 6 ; break ; case 6 : if ( ( 0xfffffff7ffffffffL & l ) != 0L && kind > 15 ) kind = 15 ; break ; case 7 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 5 ; break ; case 8 : if ( curChar == 35 ) jjstateSet [ jjnewStateCnt ++ ] = 7 ; break ; case 9 : if ( ( 0x100002600L & l ) == 0L ) break ; if ( kind > 26 ) kind = 26 ; jjCheckNAdd ( 9 ) ; break ; case 10 : if ( curChar == 34 ) jjCheckNAddStates ( 13 , 15 ) ; break ; case 11 : if ( ( 0xfffffffbffffffffL & l ) != 0L ) jjCheckNAddStates ( 13 , 15 ) ; break ; case 12 : if ( curChar == 34 && kind > 27 ) kind = 27 ; break ; case 14 : if ( ( 0x8400000000L & l ) != 0L ) jjCheckNAddStates ( 13 , 15 ) ; break ; case 15 : if ( ( 0xff000000000000L & l ) != 0L ) jjCheckNAddStates ( 19 , 22 ) ; break ; case 16 : if ( ( 0xff000000000000L & l ) != 0L ) jjCheckNAddStates ( 13 , 15 ) ; break ; case 17 : if ( ( 0xf000000000000L & l ) != 0L ) jjstateSet [ jjnewStateCnt ++ ] = 18 ; break ; case 18 : if ( ( 0xff000000000000L & l ) != 0L ) jjCheckNAdd ( 16 ) ; break ; case 20 : if ( ( 0x3ff000000000000L & l ) != 0L ) jjstateSet [ jjnewStateCnt ++ ] = 21 ; break ; case 21 : if ( ( 0x3ff000000000000L & l ) != 0L ) jjstateSet [ jjnewStateCnt ++ ] = 22 ; break ; case 22 : if ( ( 0x3ff000000000000L & l ) != 0L ) jjstateSet [ jjnewStateCnt ++ ] = 23 ; break ; case 23 : if ( ( 0x3ff000000000000L & l ) != 0L ) jjCheckNAddStates ( 13 , 15 ) ; break ; case 24 : if ( curChar == 32 ) jjAddStates ( 23 , 24 ) ; break ; case 25 : if ( curChar == 10 ) jjCheckNAddStates ( 13 , 15 ) ; break ; case 26 : if ( curChar == 39 ) jjCheckNAddStates ( 10 , 12 ) ; break ; case 27 : if ( ( 0xffffff7fffffffffL & l ) != 0L ) jjCheckNAddStates ( 10 , 12 ) ; break ; case 29 : if ( curChar == 32 ) jjAddStates ( 25 , 26 ) ; break ; case 30 : if ( curChar == 10 ) jjCheckNAddStates ( 10 , 12 ) ; break ; case 31 : if ( curChar == 39 && kind > 27 ) kind = 27 ; break ; case 32 : if ( ( 0x2400L & l ) != 0L && kind > 30 ) kind = 30 ; break ; case 33 : if ( curChar == 10 && kind > 30 ) kind = 30 ; break ; case 34 : if ( curChar == 13 ) jjstateSet [ jjnewStateCnt ++ ] = 33 ; break ; case 35 : if ( curChar == 38 && kind > 36 ) kind = 36 ; break ; case 36 : if ( curChar == 38 ) jjstateSet [ jjnewStateCnt ++ ] = 35 ; break ; case 44 : if ( curChar == 60 && kind > 38 ) kind = 38 ; break ; case 45 : if ( curChar == 61 && kind > 39 ) kind = 39 ; break ; case 46 : if ( curChar == 60 ) jjstateSet [ jjnewStateCnt ++ ] = 45 ; break ; case 47 : if ( curChar == 62 && kind > 40 ) kind = 40 ; break ; case 48 : if ( curChar == 61 && kind > 41 ) kind = 41 ; break ; case 49 : if ( curChar == 62 ) jjstateSet [ jjnewStateCnt ++ ] = 48 ; break ; case 50 : if ( curChar == 61 && kind > 42 ) kind = 42 ; break ; case 51 : if ( curChar == 61 ) jjstateSet [ jjnewStateCnt ++ ] = 50 ; break ; case 54 : if ( curChar == 61 && kind > 43 ) kind = 43 ; break ; case 55 : if ( curChar == 33 ) jjstateSet [ jjnewStateCnt ++ ] = 54 ; break ; case 56 : if ( curChar == 33 && kind > 44 ) kind = 44 ; break ; case 57 : if ( curChar == 46 ) jjCheckNAdd ( 58 ) ; break ; case 58 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 53 ) kind = 53 ; jjCheckNAddTwoStates ( 58 , 59 ) ; break ; case 60 : if ( ( 0x280000000000L & l ) != 0L ) jjCheckNAdd ( 61 ) ; break ; case 61 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 53 ) kind = 53 ; jjCheckNAdd ( 61 ) ; break ; case 63 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 57 ) kind = 57 ; jjstateSet [ jjnewStateCnt ++ ] = 63 ; break ; case 66 : if ( ( 0x3ff000000000000L & l ) != 0L ) jjAddStates ( 27 , 28 ) ; break ; case 70 : if ( curChar == 36 && kind > 13 ) kind = 13 ; break ; case 72 : if ( curChar == 36 ) jjCheckNAddTwoStates ( 73 , 74 ) ; break ; case 74 : if ( curChar == 33 && kind > 14 ) kind = 14 ; break ; case 75 : if ( curChar != 36 ) break ; if ( kind > 13 ) kind = 13 ; jjCheckNAddTwoStates ( 73 , 74 ) ; break ; case 86 : if ( curChar == 45 ) jjCheckNAddStates ( 6 , 9 ) ; break ; case 87 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 52 ) kind = 52 ; jjCheckNAddTwoStates ( 87 , 89 ) ; break ; case 88 : if ( curChar == 46 && kind > 52 ) kind = 52 ; break ; case 89 : if ( curChar == 46 ) jjstateSet [ jjnewStateCnt ++ ] = 88 ; break ; case 90 : if ( ( 0x3ff000000000000L & l ) != 0L ) jjCheckNAddTwoStates ( 90 , 91 ) ; break ; case 91 : if ( curChar != 46 ) break ; if ( kind > 53 ) kind = 53 ; jjCheckNAddTwoStates ( 92 , 93 ) ; break ; case 92 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 53 ) kind = 53 ; jjCheckNAddTwoStates ( 92 , 93 ) ; break ; case 94 : if ( ( 0x280000000000L & l ) != 0L ) jjCheckNAdd ( 95 ) ; break ; case 95 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 53 ) kind = 53 ; jjCheckNAdd ( 95 ) ; break ; case 96 : if ( ( 0x3ff000000000000L & l ) != 0L ) jjCheckNAddTwoStates ( 96 , 97 ) ; break ; case 98 : if ( ( 0x280000000000L & l ) != 0L ) jjCheckNAdd ( 99 ) ; break ; case 99 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 53 ) kind = 53 ; jjCheckNAdd ( 99 ) ; break ; case 100 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 52 ) kind = 52 ; jjCheckNAddStates ( 0 , 5 ) ; break ; default : break ; } } while ( i != startsAt ) ; } else if ( curChar < 128 ) { long l = 1L << ( curChar & 077 ) ; do { switch ( jjstateSet [ -- i ] ) { case 0 : if ( ( 0x7fffffe87fffffeL & l ) != 0L ) { if ( kind > 57 ) kind = 57 ; jjCheckNAdd ( 63 ) ; } else if ( curChar == 92 ) jjCheckNAddStates ( 29 , 32 ) ; else if ( curChar == 123 ) jjstateSet [ jjnewStateCnt ++ ] = 65 ; else if ( curChar == 124 ) jjstateSet [ jjnewStateCnt ++ ] = 40 ; if ( curChar == 110 ) jjAddStates ( 33 , 34 ) ; else if ( curChar == 103 ) jjAddStates ( 35 , 36 ) ; else if ( curChar == 108 ) jjAddStates ( 37 , 38 ) ; else if ( curChar == 101 ) jjstateSet [ jjnewStateCnt ++ ] = 52 ; else if ( curChar == 111 ) jjstateSet [ jjnewStateCnt ++ ] = 42 ; else if ( curChar == 97 ) jjstateSet [ jjnewStateCnt ++ ] = 38 ; break ; case 6 : if ( kind > 15 ) kind = 15 ; break ; case 11 : jjCheckNAddStates ( 13 , 15 ) ; break ; case 13 : if ( curChar == 92 ) jjAddStates ( 39 , 44 ) ; break ; case 14 : if ( ( 0x14404410000000L & l ) != 0L ) jjCheckNAddStates ( 13 , 15 ) ; break ; case 19 : if ( curChar == 117 ) jjstateSet [ jjnewStateCnt ++ ] = 20 ; break ; case 20 : if ( ( 0x7e0000007eL & l ) != 0L ) jjstateSet [ jjnewStateCnt ++ ] = 21 ; break ; case 21 : if ( ( 0x7e0000007eL & l ) != 0L ) jjstateSet [ jjnewStateCnt ++ ] = 22 ; break ; case 22 : if ( ( 0x7e0000007eL & l ) != 0L ) jjstateSet [ jjnewStateCnt ++ ] = 23 ; break ; case 23 : if ( ( 0x7e0000007eL & l ) != 0L ) jjCheckNAddStates ( 13 , 15 ) ; break ; case 27 : jjAddStates ( 10 , 12 ) ; break ; case 28 : if ( curChar == 92 ) jjAddStates ( 25 , 26 ) ; break ; case 37 : if ( curChar == 100 && kind > 36 ) kind = 36 ; break ; case 38 : if ( curChar == 110 ) jjstateSet [ jjnewStateCnt ++ ] = 37 ; break ; case 39 : if ( curChar == 97 ) jjstateSet [ jjnewStateCnt ++ ] = 38 ; break ; case 40 : if ( curChar == 124 && kind > 37 ) kind = 37 ; break ; case 41 : if ( curChar == 124 ) jjstateSet [ jjnewStateCnt ++ ] = 40 ; break ; case 42 : if ( curChar == 114 && kind > 37 ) kind = 37 ; break ; case 43 : if ( curChar == 111 ) jjstateSet [ jjnewStateCnt ++ ] = 42 ; break ; case 52 : if ( curChar == 113 && kind > 42 ) kind = 42 ; break ; case 53 : if ( curChar == 101 ) jjstateSet [ jjnewStateCnt ++ ] = 52 ; break ; case 59 : if ( ( 0x2000000020L & l ) != 0L ) jjAddStates ( 45 , 46 ) ; break ; case 62 : case 63 : if ( ( 0x7fffffe87fffffeL & l ) == 0L ) break ; if ( kind > 57 ) kind = 57 ; jjCheckNAdd ( 63 ) ; break ; case 64 : if ( curChar == 123 ) jjstateSet [ jjnewStateCnt ++ ] = 65 ; break ; case 65 : case 66 : if ( ( 0x7fffffe87fffffeL & l ) != 0L ) jjCheckNAddTwoStates ( 66 , 67 ) ; break ; case 67 : if ( curChar == 125 && kind > 58 ) kind = 58 ; break ; case 68 : if ( curChar == 92 ) jjCheckNAddStates ( 29 , 32 ) ; break ; case 69 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 69 , 70 ) ; break ; case 71 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 71 , 72 ) ; break ; case 73 : if ( curChar == 92 ) jjAddStates ( 47 , 48 ) ; break ; case 76 : if ( curChar == 108 ) jjAddStates ( 37 , 38 ) ; break ; case 77 : if ( curChar == 116 && kind > 38 ) kind = 38 ; break ; case 78 : if ( curChar == 101 && kind > 39 ) kind = 39 ; break ; case 79 : if ( curChar == 103 ) jjAddStates ( 35 , 36 ) ; break ; case 80 : if ( curChar == 116 && kind > 40 ) kind = 40 ; break ; case 81 : if ( curChar == 101 && kind > 41 ) kind = 41 ; break ; case 82 : if ( curChar == 110 ) jjAddStates ( 33 , 34 ) ; break ; case 83 : if ( curChar == 101 && kind > 43 ) kind = 43 ; break ; case 84 : if ( curChar == 116 && kind > 44 ) kind = 44 ; break ; case 85 : if ( curChar == 111 ) jjstateSet [ jjnewStateCnt ++ ] = 84 ; break ; case 93 : if ( ( 0x2000000020L & l ) != 0L ) jjAddStates ( 49 , 50 ) ; break ; case 97 : if ( ( 0x2000000020L & l ) != 0L ) jjAddStates ( 51 , 52 ) ; break ; default : break ; } } while ( i != startsAt ) ; } else { int hiByte = ( int ) ( curChar > > 8 ) ; int i1 = hiByte > > 6 ; long l1 = 1L << ( hiByte & 077 ) ; int i2 = ( curChar & 0xff ) > > 6 ; long l2 = 1L << ( curChar & 077 ) ; do { switch ( jjstateSet [ -- i ] ) { case 6 : if ( jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) && kind > 15 ) kind = 15 ; break ; case 11 : if ( jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) ) jjAddStates ( 13 , 15 ) ; break ; case 27 : if ( jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) ) jjAddStates ( 10 , 12 ) ; break ; default : break ; } } while ( i != startsAt ) ; } if ( kind != 0x7fffffff ) { jjmatchedKind = kind ; jjmatchedPos = curPos ; kind = 0x7fffffff ; } ++ curPos ; if ( ( i = jjnewStateCnt ) == ( startsAt = 101 - ( jjnewStateCnt = startsAt ) ) ) return curPos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return curPos ; } } } private final int jjStopStringLiteralDfa_6 ( int pos , long active0 ) { switch ( pos ) { case 0 : if ( ( active0 & 0x70000L ) != 0L ) return 2 ; return - 1 ; default : return - 1 ; } } private final int jjStartNfa_6 ( int pos , long active0 ) { return jjMoveNfa_6 ( jjStopStringLiteralDfa_6 ( pos , active0 ) , pos + 1 ) ; } private int jjMoveStringLiteralDfa0_6 ( ) { switch ( curChar ) { case 35 : jjmatchedKind = 17 ; return jjMoveStringLiteralDfa1_6 ( 0x50000L ) ; case 42 : return jjMoveStringLiteralDfa1_6 ( 0x1000000L ) ; default : return jjMoveNfa_6 ( 3 , 0 ) ; } } private int jjMoveStringLiteralDfa1_6 ( long active0 ) { try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_6 ( 0 , active0 ) ; return 1 ; } switch ( curChar ) { case 35 : if ( ( active0 & 0x40000L ) != 0L ) return jjStopAtPos ( 1 , 18 ) ; else if ( ( active0 & 0x1000000L ) != 0L ) return jjStopAtPos ( 1 , 24 ) ; break ; case 42 : if ( ( active0 & 0x10000L ) != 0L ) return jjStartNfaWithStates_6 ( 1 , 16 , 0 ) ; break ; default : break ; } return jjStartNfa_6 ( 0 , active0 ) ; } private int jjStartNfaWithStates_6 ( int pos , int kind , int state ) { jjmatchedKind = kind ; jjmatchedPos = pos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return pos + 1 ; } return jjMoveNfa_6 ( state , pos + 1 ) ; } private int jjMoveNfa_6 ( int startState , int curPos ) { int startsAt = 0 ; jjnewStateCnt = 12 ; int i = 1 ; jjstateSet [ 0 ] = startState ; int kind = 0x7fffffff ; for ( ; ; ) { if ( ++ jjround == 0x7fffffff ) ReInitRounds ( ) ; if ( curChar < 64 ) { long l = 1L << curChar ; do { switch ( jjstateSet [ -- i ] ) { case 3 : if ( curChar == 36 ) { if ( kind > 13 ) kind = 13 ; jjCheckNAddTwoStates ( 9 , 10 ) ; } else if ( curChar == 35 ) jjstateSet [ jjnewStateCnt ++ ] = 2 ; break ; case 0 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 1 ; break ; case 1 : if ( ( 0xfffffff7ffffffffL & l ) != 0L && kind > 15 ) kind = 15 ; break ; case 2 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 0 ; break ; case 6 : if ( curChar == 36 && kind > 13 ) kind = 13 ; break ; case 8 : if ( curChar == 36 ) jjCheckNAddTwoStates ( 9 , 10 ) ; break ; case 10 : if ( curChar == 33 && kind > 14 ) kind = 14 ; break ; case 11 : if ( curChar != 36 ) break ; if ( kind > 13 ) kind = 13 ; jjCheckNAddTwoStates ( 9 , 10 ) ; break ; default : break ; } } while ( i != startsAt ) ; } else if ( curChar < 128 ) { long l = 1L << ( curChar & 077 ) ; do { switch ( jjstateSet [ -- i ] ) { case 3 : if ( curChar == 92 ) jjCheckNAddStates ( 53 , 56 ) ; break ; case 1 : if ( kind > 15 ) kind = 15 ; break ; case 5 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 5 , 6 ) ; break ; case 7 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 7 , 8 ) ; break ; case 9 : if ( curChar == 92 ) jjAddStates ( 57 , 58 ) ; break ; default : break ; } } while ( i != startsAt ) ; } else { int hiByte = ( int ) ( curChar > > 8 ) ; int i1 = hiByte > > 6 ; long l1 = 1L << ( hiByte & 077 ) ; int i2 = ( curChar & 0xff ) > > 6 ; long l2 = 1L << ( curChar & 077 ) ; do { switch ( jjstateSet [ -- i ] ) { case 1 : if ( jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) && kind > 15 ) kind = 15 ; break ; default : break ; } } while ( i != startsAt ) ; } if ( kind != 0x7fffffff ) { jjmatchedKind = kind ; jjmatchedPos = curPos ; kind = 0x7fffffff ; } ++ curPos ; if ( ( i = jjnewStateCnt ) == ( startsAt = 12 - ( jjnewStateCnt = startsAt ) ) ) return curPos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return curPos ; } } } private final int jjStopStringLiteralDfa_5 ( int pos , long active0 ) { switch ( pos ) { case 0 : if ( ( active0 & 0x70000L ) != 0L ) return 2 ; return - 1 ; default : return - 1 ; } } private final int jjStartNfa_5 ( int pos , long active0 ) { return jjMoveNfa_5 ( jjStopStringLiteralDfa_5 ( pos , active0 ) , pos + 1 ) ; } private int jjMoveStringLiteralDfa0_5 ( ) { switch ( curChar ) { case 35 : jjmatchedKind = 17 ; return jjMoveStringLiteralDfa1_5 ( 0x50000L ) ; default : return jjMoveNfa_5 ( 3 , 0 ) ; } } private int jjMoveStringLiteralDfa1_5 ( long active0 ) { try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_5 ( 0 , active0 ) ; return 1 ; } switch ( curChar ) { case 35 : if ( ( active0 & 0x40000L ) != 0L ) return jjStopAtPos ( 1 , 18 ) ; break ; case 42 : if ( ( active0 & 0x10000L ) != 0L ) return jjStartNfaWithStates_5 ( 1 , 16 , 0 ) ; break ; default : break ; } return jjStartNfa_5 ( 0 , active0 ) ; } private int jjStartNfaWithStates_5 ( int pos , int kind , int state ) { jjmatchedKind = kind ; jjmatchedPos = pos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return pos + 1 ; } return jjMoveNfa_5 ( state , pos + 1 ) ; } private int jjMoveNfa_5 ( int startState , int curPos ) { int startsAt = 0 ; jjnewStateCnt = 92 ; int i = 1 ; jjstateSet [ 0 ] = startState ; int kind = 0x7fffffff ; for ( ; ; ) { if ( ++ jjround == 0x7fffffff ) ReInitRounds ( ) ; if ( curChar < 64 ) { long l = 1L << curChar ; do { switch ( jjstateSet [ -- i ] ) { case 3 : if ( ( 0x3ff000000000000L & l ) != 0L ) { if ( kind > 52 ) kind = 52 ; jjCheckNAddStates ( 59 , 64 ) ; } else if ( curChar == 45 ) jjCheckNAddStates ( 65 , 68 ) ; else if ( curChar == 36 ) { if ( kind > 13 ) kind = 13 ; jjCheckNAddTwoStates ( 26 , 27 ) ; } else if ( curChar == 46 ) jjCheckNAdd ( 11 ) ; else if ( curChar == 35 ) jjstateSet [ jjnewStateCnt ++ ] = 2 ; break ; case 0 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 1 ; break ; case 1 : if ( ( 0xfffffff7ffffffffL & l ) != 0L && kind > 15 ) kind = 15 ; break ; case 2 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 0 ; break ; case 10 : if ( curChar == 46 ) jjCheckNAdd ( 11 ) ; break ; case 11 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 53 ) kind = 53 ; jjCheckNAddTwoStates ( 11 , 12 ) ; break ; case 13 : if ( ( 0x280000000000L & l ) != 0L ) jjCheckNAdd ( 14 ) ; break ; case 14 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 53 ) kind = 53 ; jjCheckNAdd ( 14 ) ; break ; case 16 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 57 ) kind = 57 ; jjstateSet [ jjnewStateCnt ++ ] = 16 ; break ; case 19 : if ( ( 0x3ff000000000000L & l ) != 0L ) jjAddStates ( 69 , 70 ) ; break ; case 23 : if ( curChar == 36 && kind > 13 ) kind = 13 ; break ; case 25 : if ( curChar == 36 ) jjCheckNAddTwoStates ( 26 , 27 ) ; break ; case 27 : if ( curChar == 33 && kind > 14 ) kind = 14 ; break ; case 28 : if ( curChar != 36 ) break ; if ( kind > 13 ) kind = 13 ; jjCheckNAddTwoStates ( 26 , 27 ) ; break ; case 31 : if ( ( 0x100000200L & l ) != 0L ) jjCheckNAddStates ( 71 , 73 ) ; break ; case 32 : if ( ( 0x2400L & l ) != 0L && kind > 46 ) kind = 46 ; break ; case 33 : if ( curChar == 10 && kind > 46 ) kind = 46 ; break ; case 34 : case 51 : if ( curChar == 13 ) jjCheckNAdd ( 33 ) ; break ; case 42 : if ( ( 0x100000200L & l ) != 0L ) jjCheckNAddStates ( 74 , 76 ) ; break ; case 43 : if ( ( 0x2400L & l ) != 0L && kind > 49 ) kind = 49 ; break ; case 44 : if ( curChar == 10 && kind > 49 ) kind = 49 ; break ; case 45 : case 67 : if ( curChar == 13 ) jjCheckNAdd ( 44 ) ; break ; case 50 : if ( ( 0x100000200L & l ) != 0L ) jjCheckNAddStates ( 77 , 79 ) ; break ; case 66 : if ( ( 0x100000200L & l ) != 0L ) jjCheckNAddStates ( 80 , 82 ) ; break ; case 77 : if ( curChar == 45 ) jjCheckNAddStates ( 65 , 68 ) ; break ; case 78 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 52 ) kind = 52 ; jjCheckNAddTwoStates ( 78 , 80 ) ; break ; case 79 : if ( curChar == 46 && kind > 52 ) kind = 52 ; break ; case 80 : if ( curChar == 46 ) jjstateSet [ jjnewStateCnt ++ ] = 79 ; break ; case 81 : if ( ( 0x3ff000000000000L & l ) != 0L ) jjCheckNAddTwoStates ( 81 , 82 ) ; break ; case 82 : if ( curChar != 46 ) break ; if ( kind > 53 ) kind = 53 ; jjCheckNAddTwoStates ( 83 , 84 ) ; break ; case 83 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 53 ) kind = 53 ; jjCheckNAddTwoStates ( 83 , 84 ) ; break ; case 85 : if ( ( 0x280000000000L & l ) != 0L ) jjCheckNAdd ( 86 ) ; break ; case 86 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 53 ) kind = 53 ; jjCheckNAdd ( 86 ) ; break ; case 87 : if ( ( 0x3ff000000000000L & l ) != 0L ) jjCheckNAddTwoStates ( 87 , 88 ) ; break ; case 89 : if ( ( 0x280000000000L & l ) != 0L ) jjCheckNAdd ( 90 ) ; break ; case 90 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 53 ) kind = 53 ; jjCheckNAdd ( 90 ) ; break ; case 91 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 52 ) kind = 52 ; jjCheckNAddStates ( 59 , 64 ) ; break ; default : break ; } } while ( i != startsAt ) ; } else if ( curChar < 128 ) { long l = 1L << ( curChar & 077 ) ; do { switch ( jjstateSet [ -- i ] ) { case 3 : if ( ( 0x7fffffe87fffffeL & l ) != 0L ) { if ( kind > 57 ) kind = 57 ; jjCheckNAdd ( 16 ) ; } else if ( curChar == 123 ) jjAddStates ( 83 , 87 ) ; else if ( curChar == 92 ) jjCheckNAddStates ( 88 , 91 ) ; if ( curChar == 101 ) jjAddStates ( 92 , 94 ) ; else if ( curChar == 123 ) jjstateSet [ jjnewStateCnt ++ ] = 18 ; else if ( curChar == 115 ) jjstateSet [ jjnewStateCnt ++ ] = 8 ; else if ( curChar == 105 ) jjstateSet [ jjnewStateCnt ++ ] = 4 ; break ; case 1 : if ( kind > 15 ) kind = 15 ; break ; case 4 : if ( curChar == 102 && kind > 47 ) kind = 47 ; break ; case 5 : if ( curChar == 105 ) jjstateSet [ jjnewStateCnt ++ ] = 4 ; break ; case 6 : if ( curChar == 112 && kind > 50 ) kind = 50 ; break ; case 7 : if ( curChar == 111 ) jjstateSet [ jjnewStateCnt ++ ] = 6 ; break ; case 8 : if ( curChar == 116 ) jjstateSet [ jjnewStateCnt ++ ] = 7 ; break ; case 9 : if ( curChar == 115 ) jjstateSet [ jjnewStateCnt ++ ] = 8 ; break ; case 12 : if ( ( 0x2000000020L & l ) != 0L ) jjAddStates ( 95 , 96 ) ; break ; case 15 : case 16 : if ( ( 0x7fffffe87fffffeL & l ) == 0L ) break ; if ( kind > 57 ) kind = 57 ; jjCheckNAdd ( 16 ) ; break ; case 17 : if ( curChar == 123 ) jjstateSet [ jjnewStateCnt ++ ] = 18 ; break ; case 18 : case 19 : if ( ( 0x7fffffe87fffffeL & l ) != 0L ) jjCheckNAddTwoStates ( 19 , 20 ) ; break ; case 20 : if ( curChar == 125 && kind > 58 ) kind = 58 ; break ; case 21 : if ( curChar == 92 ) jjCheckNAddStates ( 88 , 91 ) ; break ; case 22 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 22 , 23 ) ; break ; case 24 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 24 , 25 ) ; break ; case 26 : if ( curChar == 92 ) jjAddStates ( 97 , 98 ) ; break ; case 29 : if ( curChar == 101 ) jjAddStates ( 92 , 94 ) ; break ; case 30 : if ( curChar != 100 ) break ; if ( kind > 46 ) kind = 46 ; jjCheckNAddStates ( 71 , 73 ) ; break ; case 35 : if ( curChar == 110 ) jjstateSet [ jjnewStateCnt ++ ] = 30 ; break ; case 36 : if ( curChar == 102 && kind > 48 ) kind = 48 ; break ; case 37 : if ( curChar == 105 ) jjstateSet [ jjnewStateCnt ++ ] = 36 ; break ; case 38 : if ( curChar == 101 ) jjstateSet [ jjnewStateCnt ++ ] = 37 ; break ; case 39 : if ( curChar == 115 ) jjstateSet [ jjnewStateCnt ++ ] = 38 ; break ; case 40 : if ( curChar == 108 ) jjstateSet [ jjnewStateCnt ++ ] = 39 ; break ; case 41 : if ( curChar != 101 ) break ; if ( kind > 49 ) kind = 49 ; jjCheckNAddStates ( 74 , 76 ) ; break ; case 46 : if ( curChar == 115 ) jjstateSet [ jjnewStateCnt ++ ] = 41 ; break ; case 47 : if ( curChar == 108 ) jjstateSet [ jjnewStateCnt ++ ] = 46 ; break ; case 48 : if ( curChar == 123 ) jjAddStates ( 83 , 87 ) ; break ; case 49 : if ( curChar != 125 ) break ; if ( kind > 46 ) kind = 46 ; jjCheckNAddStates ( 77 , 79 ) ; break ; case 52 : if ( curChar == 100 ) jjstateSet [ jjnewStateCnt ++ ] = 49 ; break ; case 53 : if ( curChar == 110 ) jjstateSet [ jjnewStateCnt ++ ] = 52 ; break ; case 54 : if ( curChar == 101 ) jjstateSet [ jjnewStateCnt ++ ] = 53 ; break ; case 55 : if ( curChar == 125 && kind > 47 ) kind = 47 ; break ; case 56 : if ( curChar == 102 ) jjstateSet [ jjnewStateCnt ++ ] = 55 ; break ; case 57 : if ( curChar == 105 ) jjstateSet [ jjnewStateCnt ++ ] = 56 ; break ; case 58 : if ( curChar == 125 && kind > 48 ) kind = 48 ; break ; case 59 : if ( curChar == 102 ) jjstateSet [ jjnewStateCnt ++ ] = 58 ; break ; case 60 : if ( curChar == 105 ) jjstateSet [ jjnewStateCnt ++ ] = 59 ; break ; case 61 : if ( curChar == 101 ) jjstateSet [ jjnewStateCnt ++ ] = 60 ; break ; case 62 : if ( curChar == 115 ) jjstateSet [ jjnewStateCnt ++ ] = 61 ; break ; case 63 : if ( curChar == 108 ) jjstateSet [ jjnewStateCnt ++ ] = 62 ; break ; case 64 : if ( curChar == 101 ) jjstateSet [ jjnewStateCnt ++ ] = 63 ; break ; case 65 : if ( curChar != 125 ) break ; if ( kind > 49 ) kind = 49 ; jjCheckNAddStates ( 80 , 82 ) ; break ; case 68 : if ( curChar == 101 ) jjstateSet [ jjnewStateCnt ++ ] = 65 ; break ; case 69 : if ( curChar == 115 ) jjstateSet [ jjnewStateCnt ++ ] = 68 ; break ; case 70 : if ( curChar == 108 ) jjstateSet [ jjnewStateCnt ++ ] = 69 ; break ; case 71 : if ( curChar == 101 ) jjstateSet [ jjnewStateCnt ++ ] = 70 ; break ; case 72 : if ( curChar == 125 && kind > 50 ) kind = 50 ; break ; case 73 : if ( curChar == 112 ) jjstateSet [ jjnewStateCnt ++ ] = 72 ; break ; case 74 : if ( curChar == 111 ) jjstateSet [ jjnewStateCnt ++ ] = 73 ; break ; case 75 : if ( curChar == 116 ) jjstateSet [ jjnewStateCnt ++ ] = 74 ; break ; case 76 : if ( curChar == 115 ) jjstateSet [ jjnewStateCnt ++ ] = 75 ; break ; case 84 : if ( ( 0x2000000020L & l ) != 0L ) jjAddStates ( 99 , 100 ) ; break ; case 88 : if ( ( 0x2000000020L & l ) != 0L ) jjAddStates ( 101 , 102 ) ; break ; default : break ; } } while ( i != startsAt ) ; } else { int hiByte = ( int ) ( curChar > > 8 ) ; int i1 = hiByte > > 6 ; long l1 = 1L << ( hiByte & 077 ) ; int i2 = ( curChar & 0xff ) > > 6 ; long l2 = 1L << ( curChar & 077 ) ; do { switch ( jjstateSet [ -- i ] ) { case 1 : if ( jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) && kind > 15 ) kind = 15 ; break ; default : break ; } } while ( i != startsAt ) ; } if ( kind != 0x7fffffff ) { jjmatchedKind = kind ; jjmatchedPos = curPos ; kind = 0x7fffffff ; } ++ curPos ; if ( ( i = jjnewStateCnt ) == ( startsAt = 92 - ( jjnewStateCnt = startsAt ) ) ) return curPos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return curPos ; } } } private final int jjStopStringLiteralDfa_3 ( int pos , long active0 ) { switch ( pos ) { case 0 : if ( ( active0 & 0x180000L ) != 0L ) return 14 ; if ( ( active0 & 0x70000L ) != 0L ) return 33 ; return - 1 ; default : return - 1 ; } } private final int jjStartNfa_3 ( int pos , long active0 ) { return jjMoveNfa_3 ( jjStopStringLiteralDfa_3 ( pos , active0 ) , pos + 1 ) ; } private int jjMoveStringLiteralDfa0_3 ( ) { switch ( curChar ) { case 35 : jjmatchedKind = 17 ; return jjMoveStringLiteralDfa1_3 ( 0x50000L ) ; case 92 : jjmatchedKind = 20 ; return jjMoveStringLiteralDfa1_3 ( 0x80000L ) ; default : return jjMoveNfa_3 ( 22 , 0 ) ; } } private int jjMoveStringLiteralDfa1_3 ( long active0 ) { try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_3 ( 0 , active0 ) ; return 1 ; } switch ( curChar ) { case 35 : if ( ( active0 & 0x40000L ) != 0L ) return jjStopAtPos ( 1 , 18 ) ; break ; case 42 : if ( ( active0 & 0x10000L ) != 0L ) return jjStartNfaWithStates_3 ( 1 , 16 , 31 ) ; break ; case 92 : if ( ( active0 & 0x80000L ) != 0L ) return jjStartNfaWithStates_3 ( 1 , 19 , 34 ) ; break ; default : break ; } return jjStartNfa_3 ( 0 , active0 ) ; } private int jjStartNfaWithStates_3 ( int pos , int kind , int state ) { jjmatchedKind = kind ; jjmatchedPos = pos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return pos + 1 ; } return jjMoveNfa_3 ( state , pos + 1 ) ; } private int jjMoveNfa_3 ( int startState , int curPos ) { int startsAt = 0 ; jjnewStateCnt = 34 ; int i = 1 ; jjstateSet [ 0 ] = startState ; int kind = 0x7fffffff ; for ( ; ; ) { if ( ++ jjround == 0x7fffffff ) ReInitRounds ( ) ; if ( curChar < 64 ) { long l = 1L << curChar ; do { switch ( jjstateSet [ -- i ] ) { case 22 : if ( ( 0xffffffe7ffffffffL & l ) != 0L ) { if ( kind > 21 ) kind = 21 ; jjCheckNAdd ( 12 ) ; } else if ( curChar == 35 ) jjCheckNAddStates ( 103 , 105 ) ; else if ( curChar == 36 ) { if ( kind > 13 ) kind = 13 ; jjCheckNAddTwoStates ( 27 , 28 ) ; } if ( ( 0x100000200L & l ) != 0L ) jjCheckNAddTwoStates ( 0 , 1 ) ; break ; case 14 : if ( curChar == 36 ) jjCheckNAddTwoStates ( 27 , 28 ) ; else if ( curChar == 35 ) jjAddStates ( 106 , 107 ) ; if ( curChar == 36 ) { if ( kind > 13 ) kind = 13 ; } break ; case 34 : if ( curChar == 36 ) jjCheckNAddTwoStates ( 27 , 28 ) ; if ( curChar == 36 ) { if ( kind > 13 ) kind = 13 ; } break ; case 33 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 31 ; break ; case 0 : if ( ( 0x100000200L & l ) != 0L ) jjCheckNAddTwoStates ( 0 , 1 ) ; break ; case 1 : if ( curChar == 35 ) jjCheckNAddTwoStates ( 6 , 11 ) ; break ; case 3 : if ( curChar == 32 ) jjAddStates ( 108 , 109 ) ; break ; case 4 : if ( curChar == 40 && kind > 12 ) kind = 12 ; break ; case 12 : if ( ( 0xffffffe7ffffffffL & l ) == 0L ) break ; if ( kind > 21 ) kind = 21 ; jjCheckNAdd ( 12 ) ; break ; case 15 : if ( curChar == 35 ) jjAddStates ( 106 , 107 ) ; break ; case 17 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 11 ) kind = 11 ; jjstateSet [ jjnewStateCnt ++ ] = 17 ; break ; case 20 : if ( ( 0x3ff000000000000L & l ) != 0L ) jjAddStates ( 110 , 111 ) ; break ; case 24 : if ( curChar == 36 && kind > 13 ) kind = 13 ; break ; case 26 : if ( curChar == 36 ) jjCheckNAddTwoStates ( 27 , 28 ) ; break ; case 28 : if ( curChar == 33 && kind > 14 ) kind = 14 ; break ; case 29 : if ( curChar != 36 ) break ; if ( kind > 13 ) kind = 13 ; jjCheckNAddTwoStates ( 27 , 28 ) ; break ; case 30 : if ( curChar == 35 ) jjCheckNAddStates ( 103 , 105 ) ; break ; case 31 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 32 ; break ; case 32 : if ( ( 0xfffffff7ffffffffL & l ) != 0L && kind > 15 ) kind = 15 ; break ; default : break ; } } while ( i != startsAt ) ; } else if ( curChar < 128 ) { long l = 1L << ( curChar & 077 ) ; do { switch ( jjstateSet [ -- i ] ) { case 22 : if ( ( 0xffffffffefffffffL & l ) != 0L ) { if ( kind > 21 ) kind = 21 ; jjCheckNAdd ( 12 ) ; } else if ( curChar == 92 ) jjCheckNAddStates ( 112 , 115 ) ; if ( curChar == 92 ) jjAddStates ( 116 , 117 ) ; break ; case 14 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 25 , 26 ) ; if ( curChar == 92 ) jjCheckNAddTwoStates ( 23 , 24 ) ; if ( curChar == 92 ) jjstateSet [ jjnewStateCnt ++ ] = 13 ; break ; case 34 : if ( curChar == 92 ) jjAddStates ( 116 , 117 ) ; if ( curChar == 92 ) jjCheckNAddTwoStates ( 25 , 26 ) ; if ( curChar == 92 ) jjCheckNAddTwoStates ( 23 , 24 ) ; break ; case 33 : if ( curChar == 123 ) jjstateSet [ jjnewStateCnt ++ ] = 10 ; else if ( curChar == 115 ) jjstateSet [ jjnewStateCnt ++ ] = 5 ; break ; case 2 : if ( curChar == 116 ) jjCheckNAddTwoStates ( 3 , 4 ) ; break ; case 5 : if ( curChar == 101 ) jjstateSet [ jjnewStateCnt ++ ] = 2 ; break ; case 6 : if ( curChar == 115 ) jjstateSet [ jjnewStateCnt ++ ] = 5 ; break ; case 7 : if ( curChar == 125 ) jjCheckNAddTwoStates ( 3 , 4 ) ; break ; case 8 : if ( curChar == 116 ) jjstateSet [ jjnewStateCnt ++ ] = 7 ; break ; case 9 : if ( curChar == 101 ) jjstateSet [ jjnewStateCnt ++ ] = 8 ; break ; case 10 : if ( curChar == 115 ) jjstateSet [ jjnewStateCnt ++ ] = 9 ; break ; case 11 : if ( curChar == 123 ) jjstateSet [ jjnewStateCnt ++ ] = 10 ; break ; case 12 : if ( ( 0xffffffffefffffffL & l ) == 0L ) break ; if ( kind > 21 ) kind = 21 ; jjCheckNAdd ( 12 ) ; break ; case 13 : if ( curChar == 92 ) jjAddStates ( 116 , 117 ) ; break ; case 16 : case 17 : if ( ( 0x7fffffe87fffffeL & l ) == 0L ) break ; if ( kind > 11 ) kind = 11 ; jjCheckNAdd ( 17 ) ; break ; case 18 : if ( curChar == 123 ) jjstateSet [ jjnewStateCnt ++ ] = 19 ; break ; case 19 : case 20 : if ( ( 0x7fffffe87fffffeL & l ) != 0L ) jjCheckNAddTwoStates ( 20 , 21 ) ; break ; case 21 : if ( curChar == 125 && kind > 11 ) kind = 11 ; break ; case 23 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 23 , 24 ) ; break ; case 25 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 25 , 26 ) ; break ; case 27 : if ( curChar == 92 ) jjAddStates ( 118 , 119 ) ; break ; case 32 : if ( kind > 15 ) kind = 15 ; break ; default : break ; } } while ( i != startsAt ) ; } else { int hiByte = ( int ) ( curChar > > 8 ) ; int i1 = hiByte > > 6 ; long l1 = 1L << ( hiByte & 077 ) ; int i2 = ( curChar & 0xff ) > > 6 ; long l2 = 1L << ( curChar & 077 ) ; do { switch ( jjstateSet [ -- i ] ) { case 22 : case 12 : if ( ! jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) ) break ; if ( kind > 21 ) kind = 21 ; jjCheckNAdd ( 12 ) ; break ; case 32 : if ( jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) && kind > 15 ) kind = 15 ; break ; default : break ; } } while ( i != startsAt ) ; } if ( kind != 0x7fffffff ) { jjmatchedKind = kind ; jjmatchedPos = curPos ; kind = 0x7fffffff ; } ++ curPos ; if ( ( i = jjnewStateCnt ) == ( startsAt = 34 - ( jjnewStateCnt = startsAt ) ) ) return curPos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return curPos ; } } } private final int jjStopStringLiteralDfa_7 ( int pos , long active0 ) { switch ( pos ) { case 0 : if ( ( active0 & 0x70000L ) != 0L ) return 2 ; return - 1 ; default : return - 1 ; } } private final int jjStartNfa_7 ( int pos , long active0 ) { return jjMoveNfa_7 ( jjStopStringLiteralDfa_7 ( pos , active0 ) , pos + 1 ) ; } private int jjMoveStringLiteralDfa0_7 ( ) { switch ( curChar ) { case 35 : jjmatchedKind = 17 ; return jjMoveStringLiteralDfa1_7 ( 0x50000L ) ; case 42 : return jjMoveStringLiteralDfa1_7 ( 0x800000L ) ; default : return jjMoveNfa_7 ( 3 , 0 ) ; } } private int jjMoveStringLiteralDfa1_7 ( long active0 ) { try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_7 ( 0 , active0 ) ; return 1 ; } switch ( curChar ) { case 35 : if ( ( active0 & 0x40000L ) != 0L ) return jjStopAtPos ( 1 , 18 ) ; else if ( ( active0 & 0x800000L ) != 0L ) return jjStopAtPos ( 1 , 23 ) ; break ; case 42 : if ( ( active0 & 0x10000L ) != 0L ) return jjStartNfaWithStates_7 ( 1 , 16 , 0 ) ; break ; default : break ; } return jjStartNfa_7 ( 0 , active0 ) ; } private int jjStartNfaWithStates_7 ( int pos , int kind , int state ) { jjmatchedKind = kind ; jjmatchedPos = pos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return pos + 1 ; } return jjMoveNfa_7 ( state , pos + 1 ) ; } private int jjMoveNfa_7 ( int startState , int curPos ) { int startsAt = 0 ; jjnewStateCnt = 12 ; int i = 1 ; jjstateSet [ 0 ] = startState ; int kind = 0x7fffffff ; for ( ; ; ) { if ( ++ jjround == 0x7fffffff ) ReInitRounds ( ) ; if ( curChar < 64 ) { long l = 1L << curChar ; do { switch ( jjstateSet [ -- i ] ) { case 3 : if ( curChar == 36 ) { if ( kind > 13 ) kind = 13 ; jjCheckNAddTwoStates ( 9 , 10 ) ; } else if ( curChar == 35 ) jjstateSet [ jjnewStateCnt ++ ] = 2 ; break ; case 0 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 1 ; break ; case 1 : if ( ( 0xfffffff7ffffffffL & l ) != 0L && kind > 15 ) kind = 15 ; break ; case 2 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 0 ; break ; case 6 : if ( curChar == 36 && kind > 13 ) kind = 13 ; break ; case 8 : if ( curChar == 36 ) jjCheckNAddTwoStates ( 9 , 10 ) ; break ; case 10 : if ( curChar == 33 && kind > 14 ) kind = 14 ; break ; case 11 : if ( curChar != 36 ) break ; if ( kind > 13 ) kind = 13 ; jjCheckNAddTwoStates ( 9 , 10 ) ; break ; default : break ; } } while ( i != startsAt ) ; } else if ( curChar < 128 ) { long l = 1L << ( curChar & 077 ) ; do { switch ( jjstateSet [ -- i ] ) { case 3 : if ( curChar == 92 ) jjCheckNAddStates ( 53 , 56 ) ; break ; case 1 : if ( kind > 15 ) kind = 15 ; break ; case 5 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 5 , 6 ) ; break ; case 7 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 7 , 8 ) ; break ; case 9 : if ( curChar == 92 ) jjAddStates ( 57 , 58 ) ; break ; default : break ; } } while ( i != startsAt ) ; } else { int hiByte = ( int ) ( curChar > > 8 ) ; int i1 = hiByte > > 6 ; long l1 = 1L << ( hiByte & 077 ) ; int i2 = ( curChar & 0xff ) > > 6 ; long l2 = 1L << ( curChar & 077 ) ; do { switch ( jjstateSet [ -- i ] ) { case 1 : if ( jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) && kind > 15 ) kind = 15 ; break ; default : break ; } } while ( i != startsAt ) ; } if ( kind != 0x7fffffff ) { jjmatchedKind = kind ; jjmatchedPos = curPos ; kind = 0x7fffffff ; } ++ curPos ; if ( ( i = jjnewStateCnt ) == ( startsAt = 12 - ( jjnewStateCnt = startsAt ) ) ) return curPos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return curPos ; } } } private final int jjStopStringLiteralDfa_8 ( int pos , long active0 ) { switch ( pos ) { case 0 : if ( ( active0 & 0x70000L ) != 0L ) return 2 ; return - 1 ; default : return - 1 ; } } private final int jjStartNfa_8 ( int pos , long active0 ) { return jjMoveNfa_8 ( jjStopStringLiteralDfa_8 ( pos , active0 ) , pos + 1 ) ; } private int jjMoveStringLiteralDfa0_8 ( ) { switch ( curChar ) { case 35 : jjmatchedKind = 17 ; return jjMoveStringLiteralDfa1_8 ( 0x50000L ) ; default : return jjMoveNfa_8 ( 3 , 0 ) ; } } private int jjMoveStringLiteralDfa1_8 ( long active0 ) { try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_8 ( 0 , active0 ) ; return 1 ; } switch ( curChar ) { case 35 : if ( ( active0 & 0x40000L ) != 0L ) return jjStopAtPos ( 1 , 18 ) ; break ; case 42 : if ( ( active0 & 0x10000L ) != 0L ) return jjStartNfaWithStates_8 ( 1 , 16 , 0 ) ; break ; default : break ; } return jjStartNfa_8 ( 0 , active0 ) ; } private int jjStartNfaWithStates_8 ( int pos , int kind , int state ) { jjmatchedKind = kind ; jjmatchedPos = pos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return pos + 1 ; } return jjMoveNfa_8 ( state , pos + 1 ) ; } private int jjMoveNfa_8 ( int startState , int curPos ) { int startsAt = 0 ; jjnewStateCnt = 15 ; int i = 1 ; jjstateSet [ 0 ] = startState ; int kind = 0x7fffffff ; for ( ; ; ) { if ( ++ jjround == 0x7fffffff ) ReInitRounds ( ) ; if ( curChar < 64 ) { long l = 1L << curChar ; do { switch ( jjstateSet [ -- i ] ) { case 3 : if ( ( 0x2400L & l ) != 0L ) { if ( kind > 22 ) kind = 22 ; } else if ( curChar == 36 ) { if ( kind > 13 ) kind = 13 ; jjCheckNAddTwoStates ( 12 , 13 ) ; } else if ( curChar == 35 ) jjstateSet [ jjnewStateCnt ++ ] = 2 ; if ( curChar == 13 ) jjstateSet [ jjnewStateCnt ++ ] = 5 ; break ; case 0 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 1 ; break ; case 1 : if ( ( 0xfffffff7ffffffffL & l ) != 0L && kind > 15 ) kind = 15 ; break ; case 2 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 0 ; break ; case 4 : if ( ( 0x2400L & l ) != 0L && kind > 22 ) kind = 22 ; break ; case 5 : if ( curChar == 10 && kind > 22 ) kind = 22 ; break ; case 6 : if ( curChar == 13 ) jjstateSet [ jjnewStateCnt ++ ] = 5 ; break ; case 9 : if ( curChar == 36 && kind > 13 ) kind = 13 ; break ; case 11 : if ( curChar == 36 ) jjCheckNAddTwoStates ( 12 , 13 ) ; break ; case 13 : if ( curChar == 33 && kind > 14 ) kind = 14 ; break ; case 14 : if ( curChar != 36 ) break ; if ( kind > 13 ) kind = 13 ; jjCheckNAddTwoStates ( 12 , 13 ) ; break ; default : break ; } } while ( i != startsAt ) ; } else if ( curChar < 128 ) { long l = 1L << ( curChar & 077 ) ; do { switch ( jjstateSet [ -- i ] ) { case 3 : if ( curChar == 92 ) jjCheckNAddStates ( 120 , 123 ) ; break ; case 1 : if ( kind > 15 ) kind = 15 ; break ; case 8 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 8 , 9 ) ; break ; case 10 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 10 , 11 ) ; break ; case 12 : if ( curChar == 92 ) jjAddStates ( 124 , 125 ) ; break ; default : break ; } } while ( i != startsAt ) ; } else { int hiByte = ( int ) ( curChar > > 8 ) ; int i1 = hiByte > > 6 ; long l1 = 1L << ( hiByte & 077 ) ; int i2 = ( curChar & 0xff ) > > 6 ; long l2 = 1L << ( curChar & 077 ) ; do { switch ( jjstateSet [ -- i ] ) { case 1 : if ( jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) && kind > 15 ) kind = 15 ; break ; default : break ; } } while ( i != startsAt ) ; } if ( kind != 0x7fffffff ) { jjmatchedKind = kind ; jjmatchedPos = curPos ; kind = 0x7fffffff ; } ++ curPos ; if ( ( i = jjnewStateCnt ) == ( startsAt = 15 - ( jjnewStateCnt = startsAt ) ) ) return curPos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return curPos ; } } } private final int jjStopStringLiteralDfa_4 ( int pos , long active0 , long active1 ) { switch ( pos ) { case 0 : if ( ( active0 & 0x70000L ) != 0L ) return 27 ; if ( ( active0 & 0x30000000L ) != 0L ) { jjmatchedKind = 62 ; return 13 ; } return - 1 ; case 1 : if ( ( active0 & 0x30000000L ) != 0L ) { jjmatchedKind = 62 ; jjmatchedPos = 1 ; return 13 ; } if ( ( active0 & 0x10000L ) != 0L ) return 25 ; return - 1 ; case 2 : if ( ( active0 & 0x30000000L ) != 0L ) { jjmatchedKind = 62 ; jjmatchedPos = 2 ; return 13 ; } return - 1 ; case 3 : if ( ( active0 & 0x10000000L ) != 0L ) return 13 ; if ( ( active0 & 0x20000000L ) != 0L ) { jjmatchedKind = 62 ; jjmatchedPos = 3 ; return 13 ; } return - 1 ; default : return - 1 ; } } private final int jjStartNfa_4 ( int pos , long active0 , long active1 ) { return jjMoveNfa_4 ( jjStopStringLiteralDfa_4 ( pos , active0 , active1 ) , pos + 1 ) ; } private int jjMoveStringLiteralDfa0_4 ( ) { switch ( curChar ) { case 35 : jjmatchedKind = 17 ; return jjMoveStringLiteralDfa1_4 ( 0x50000L ) ; case 102 : return jjMoveStringLiteralDfa1_4 ( 0x20000000L ) ; case 116 : return jjMoveStringLiteralDfa1_4 ( 0x10000000L ) ; case 123 : return jjStopAtPos ( 0 , 64 ) ; case 125 : return jjStopAtPos ( 0 , 65 ) ; default : return jjMoveNfa_4 ( 12 , 0 ) ; } } private int jjMoveStringLiteralDfa1_4 ( long active0 ) { try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_4 ( 0 , active0 , 0L ) ; return 1 ; } switch ( curChar ) { case 35 : if ( ( active0 & 0x40000L ) != 0L ) return jjStopAtPos ( 1 , 18 ) ; break ; case 42 : if ( ( active0 & 0x10000L ) != 0L ) return jjStartNfaWithStates_4 ( 1 , 16 , 25 ) ; break ; case 97 : return jjMoveStringLiteralDfa2_4 ( active0 , 0x20000000L ) ; case 114 : return jjMoveStringLiteralDfa2_4 ( active0 , 0x10000000L ) ; default : break ; } return jjStartNfa_4 ( 0 , active0 , 0L ) ; } private int jjMoveStringLiteralDfa2_4 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0L ) return jjStartNfa_4 ( 0 , old0 , 0L ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_4 ( 1 , active0 , 0L ) ; return 2 ; } switch ( curChar ) { case 108 : return jjMoveStringLiteralDfa3_4 ( active0 , 0x20000000L ) ; case 117 : return jjMoveStringLiteralDfa3_4 ( active0 , 0x10000000L ) ; default : break ; } return jjStartNfa_4 ( 1 , active0 , 0L ) ; } private int jjMoveStringLiteralDfa3_4 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0L ) return jjStartNfa_4 ( 1 , old0 , 0L ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_4 ( 2 , active0 , 0L ) ; return 3 ; } switch ( curChar ) { case 101 : if ( ( active0 & 0x10000000L ) != 0L ) return jjStartNfaWithStates_4 ( 3 , 28 , 13 ) ; break ; case 115 : return jjMoveStringLiteralDfa4_4 ( active0 , 0x20000000L ) ; default : break ; } return jjStartNfa_4 ( 2 , active0 , 0L ) ; } private int jjMoveStringLiteralDfa4_4 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0L ) return jjStartNfa_4 ( 2 , old0 , 0L ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_4 ( 3 , active0 , 0L ) ; return 4 ; } switch ( curChar ) { case 101 : if ( ( active0 & 0x20000000L ) != 0L ) return jjStartNfaWithStates_4 ( 4 , 29 , 13 ) ; break ; default : break ; } return jjStartNfa_4 ( 3 , active0 , 0L ) ; } private int jjStartNfaWithStates_4 ( int pos , int kind , int state ) { jjmatchedKind = kind ; jjmatchedPos = pos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return pos + 1 ; } return jjMoveNfa_4 ( state , pos + 1 ) ; } private int jjMoveNfa_4 ( int startState , int curPos ) { int startsAt = 0 ; jjnewStateCnt = 28 ; int i = 1 ; jjstateSet [ 0 ] = startState ; int kind = 0x7fffffff ; for ( ; ; ) { if ( ++ jjround == 0x7fffffff ) ReInitRounds ( ) ; if ( curChar < 64 ) { long l = 1L << curChar ; do { switch ( jjstateSet [ -- i ] ) { case 12 : if ( ( 0x100000200L & l ) != 0L ) jjCheckNAddTwoStates ( 0 , 1 ) ; else if ( curChar == 35 ) jjCheckNAddStates ( 126 , 128 ) ; else if ( curChar == 36 ) { if ( kind > 13 ) kind = 13 ; jjCheckNAddTwoStates ( 21 , 22 ) ; } else if ( curChar == 46 ) jjstateSet [ jjnewStateCnt ++ ] = 15 ; break ; case 27 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 25 ; break ; case 0 : if ( ( 0x100000200L & l ) != 0L ) jjCheckNAddTwoStates ( 0 , 1 ) ; break ; case 1 : if ( curChar == 35 ) jjCheckNAddTwoStates ( 6 , 11 ) ; break ; case 3 : if ( curChar == 32 ) jjAddStates ( 108 , 109 ) ; break ; case 4 : if ( curChar == 40 && kind > 12 ) kind = 12 ; break ; case 13 : if ( ( 0x3ff200000000000L & l ) == 0L ) break ; if ( kind > 62 ) kind = 62 ; jjstateSet [ jjnewStateCnt ++ ] = 13 ; break ; case 14 : if ( curChar == 46 ) jjstateSet [ jjnewStateCnt ++ ] = 15 ; break ; case 18 : if ( curChar == 36 && kind > 13 ) kind = 13 ; break ; case 20 : if ( curChar == 36 ) jjCheckNAddTwoStates ( 21 , 22 ) ; break ; case 22 : if ( curChar == 33 && kind > 14 ) kind = 14 ; break ; case 23 : if ( curChar != 36 ) break ; if ( kind > 13 ) kind = 13 ; jjCheckNAddTwoStates ( 21 , 22 ) ; break ; case 24 : if ( curChar == 35 ) jjCheckNAddStates ( 126 , 128 ) ; break ; case 25 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 26 ; break ; case 26 : if ( ( 0xfffffff7ffffffffL & l ) != 0L && kind > 15 ) kind = 15 ; break ; default : break ; } } while ( i != startsAt ) ; } else if ( curChar < 128 ) { long l = 1L << ( curChar & 077 ) ; do { switch ( jjstateSet [ -- i ] ) { case 12 : if ( ( 0x7fffffe87fffffeL & l ) != 0L ) { if ( kind > 62 ) kind = 62 ; jjCheckNAdd ( 13 ) ; } else if ( curChar == 92 ) jjCheckNAddStates ( 129 , 132 ) ; break ; case 27 : if ( curChar == 123 ) jjstateSet [ jjnewStateCnt ++ ] = 10 ; else if ( curChar == 115 ) jjstateSet [ jjnewStateCnt ++ ] = 5 ; break ; case 2 : if ( curChar == 116 ) jjCheckNAddTwoStates ( 3 , 4 ) ; break ; case 5 : if ( curChar == 101 ) jjstateSet [ jjnewStateCnt ++ ] = 2 ; break ; case 6 : if ( curChar == 115 ) jjstateSet [ jjnewStateCnt ++ ] = 5 ; break ; case 7 : if ( curChar == 125 ) jjCheckNAddTwoStates ( 3 , 4 ) ; break ; case 8 : if ( curChar == 116 ) jjstateSet [ jjnewStateCnt ++ ] = 7 ; break ; case 9 : if ( curChar == 101 ) jjstateSet [ jjnewStateCnt ++ ] = 8 ; break ; case 10 : if ( curChar == 115 ) jjstateSet [ jjnewStateCnt ++ ] = 9 ; break ; case 11 : if ( curChar == 123 ) jjstateSet [ jjnewStateCnt ++ ] = 10 ; break ; case 13 : if ( ( 0x7fffffe87fffffeL & l ) == 0L ) break ; if ( kind > 62 ) kind = 62 ; jjCheckNAdd ( 13 ) ; break ; case 15 : if ( ( 0x7fffffe07fffffeL & l ) != 0L && kind > 63 ) kind = 63 ; break ; case 16 : if ( curChar == 92 ) jjCheckNAddStates ( 129 , 132 ) ; break ; case 17 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 17 , 18 ) ; break ; case 19 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 19 , 20 ) ; break ; case 21 : if ( curChar == 92 ) jjAddStates ( 133 , 134 ) ; break ; case 26 : if ( kind > 15 ) kind = 15 ; break ; default : break ; } } while ( i != startsAt ) ; } else { int hiByte = ( int ) ( curChar > > 8 ) ; int i1 = hiByte > > 6 ; long l1 = 1L << ( hiByte & 077 ) ; int i2 = ( curChar & 0xff ) > > 6 ; long l2 = 1L << ( curChar & 077 ) ; do { switch ( jjstateSet [ -- i ] ) { case 26 : if ( jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) && kind > 15 ) kind = 15 ; break ; default : break ; } } while ( i != startsAt ) ; } if ( kind != 0x7fffffff ) { jjmatchedKind = kind ; jjmatchedPos = curPos ; kind = 0x7fffffff ; } ++ curPos ; if ( ( i = jjnewStateCnt ) == ( startsAt = 28 - ( jjnewStateCnt = startsAt ) ) ) return curPos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return curPos ; } } } private final int jjStopStringLiteralDfa_1 ( int pos , long active0 ) { switch ( pos ) { case 0 : if ( ( active0 & 0x70000L ) != 0L ) return 48 ; if ( ( active0 & 0x30000000L ) != 0L ) { jjmatchedKind = 62 ; return 36 ; } if ( ( active0 & 0x10L ) != 0L ) return 70 ; return - 1 ; case 1 : if ( ( active0 & 0x10000L ) != 0L ) return 46 ; if ( ( active0 & 0x30000000L ) != 0L ) { jjmatchedKind = 62 ; jjmatchedPos = 1 ; return 36 ; } return - 1 ; case 2 : if ( ( active0 & 0x30000000L ) != 0L ) { jjmatchedKind = 62 ; jjmatchedPos = 2 ; return 36 ; } return - 1 ; case 3 : if ( ( active0 & 0x10000000L ) != 0L ) return 36 ; if ( ( active0 & 0x20000000L ) != 0L ) { jjmatchedKind = 62 ; jjmatchedPos = 3 ; return 36 ; } return - 1 ; default : return - 1 ; } } private final int jjStartNfa_1 ( int pos , long active0 ) { return jjMoveNfa_1 ( jjStopStringLiteralDfa_1 ( pos , active0 ) , pos + 1 ) ; } private int jjMoveStringLiteralDfa0_1 ( ) { switch ( curChar ) { case 35 : jjmatchedKind = 17 ; return jjMoveStringLiteralDfa1_1 ( 0x50000L ) ; case 41 : return jjStopAtPos ( 0 , 10 ) ; case 44 : return jjStopAtPos ( 0 , 3 ) ; case 46 : return jjMoveStringLiteralDfa1_1 ( 0x10L ) ; case 58 : return jjStopAtPos ( 0 , 5 ) ; case 91 : return jjStopAtPos ( 0 , 1 ) ; case 93 : return jjStopAtPos ( 0 , 2 ) ; case 102 : return jjMoveStringLiteralDfa1_1 ( 0x20000000L ) ; case 116 : return jjMoveStringLiteralDfa1_1 ( 0x10000000L ) ; case 123 : return jjStopAtPos ( 0 , 6 ) ; case 125 : return jjStopAtPos ( 0 , 7 ) ; default : return jjMoveNfa_1 ( 13 , 0 ) ; } } private int jjMoveStringLiteralDfa1_1 ( long active0 ) { try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_1 ( 0 , active0 ) ; return 1 ; } switch ( curChar ) { case 35 : if ( ( active0 & 0x40000L ) != 0L ) return jjStopAtPos ( 1 , 18 ) ; break ; case 42 : if ( ( active0 & 0x10000L ) != 0L ) return jjStartNfaWithStates_1 ( 1 , 16 , 46 ) ; break ; case 46 : if ( ( active0 & 0x10L ) != 0L ) return jjStopAtPos ( 1 , 4 ) ; break ; case 97 : return jjMoveStringLiteralDfa2_1 ( active0 , 0x20000000L ) ; case 114 : return jjMoveStringLiteralDfa2_1 ( active0 , 0x10000000L ) ; default : break ; } return jjStartNfa_1 ( 0 , active0 ) ; } private int jjMoveStringLiteralDfa2_1 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0L ) return jjStartNfa_1 ( 0 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_1 ( 1 , active0 ) ; return 2 ; } switch ( curChar ) { case 108 : return jjMoveStringLiteralDfa3_1 ( active0 , 0x20000000L ) ; case 117 : return jjMoveStringLiteralDfa3_1 ( active0 , 0x10000000L ) ; default : break ; } return jjStartNfa_1 ( 1 , active0 ) ; } private int jjMoveStringLiteralDfa3_1 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0L ) return jjStartNfa_1 ( 1 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_1 ( 2 , active0 ) ; return 3 ; } switch ( curChar ) { case 101 : if ( ( active0 & 0x10000000L ) != 0L ) return jjStartNfaWithStates_1 ( 3 , 28 , 36 ) ; break ; case 115 : return jjMoveStringLiteralDfa4_1 ( active0 , 0x20000000L ) ; default : break ; } return jjStartNfa_1 ( 2 , active0 ) ; } private int jjMoveStringLiteralDfa4_1 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0L ) return jjStartNfa_1 ( 2 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_1 ( 3 , active0 ) ; return 4 ; } switch ( curChar ) { case 101 : if ( ( active0 & 0x20000000L ) != 0L ) return jjStartNfaWithStates_1 ( 4 , 29 , 36 ) ; break ; default : break ; } return jjStartNfa_1 ( 3 , active0 ) ; } private int jjStartNfaWithStates_1 ( int pos , int kind , int state ) { jjmatchedKind = kind ; jjmatchedPos = pos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return pos + 1 ; } return jjMoveNfa_1 ( state , pos + 1 ) ; } private int jjMoveNfa_1 ( int startState , int curPos ) { int startsAt = 0 ; jjnewStateCnt = 71 ; int i = 1 ; jjstateSet [ 0 ] = startState ; int kind = 0x7fffffff ; for ( ; ; ) { if ( ++ jjround == 0x7fffffff ) ReInitRounds ( ) ; if ( curChar < 64 ) { long l = 1L << curChar ; do { switch ( jjstateSet [ -- i ] ) { case 13 : if ( ( 0x3ff000000000000L & l ) != 0L ) { if ( kind > 52 ) kind = 52 ; jjCheckNAddStates ( 135 , 140 ) ; } else if ( ( 0x100002600L & l ) != 0L ) { if ( kind > 26 ) kind = 26 ; jjCheckNAdd ( 12 ) ; } else if ( curChar == 46 ) jjCheckNAddTwoStates ( 60 , 70 ) ; else if ( curChar == 45 ) jjCheckNAddStates ( 141 , 144 ) ; else if ( curChar == 35 ) jjCheckNAddStates ( 145 , 147 ) ; else if ( curChar == 36 ) { if ( kind > 13 ) kind = 13 ; jjCheckNAddTwoStates ( 42 , 43 ) ; } else if ( curChar == 39 ) jjCheckNAddStates ( 148 , 150 ) ; else if ( curChar == 34 ) jjCheckNAddStates ( 151 , 153 ) ; if ( ( 0x100000200L & l ) != 0L ) jjCheckNAddTwoStates ( 0 , 1 ) ; break ; case 70 : case 60 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 53 ) kind = 53 ; jjCheckNAddTwoStates ( 60 , 61 ) ; break ; case 48 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 46 ; break ; case 0 : if ( ( 0x100000200L & l ) != 0L ) jjCheckNAddTwoStates ( 0 , 1 ) ; break ; case 1 : if ( curChar == 35 ) jjCheckNAddTwoStates ( 6 , 11 ) ; break ; case 3 : if ( curChar == 32 ) jjAddStates ( 108 , 109 ) ; break ; case 4 : if ( curChar == 40 && kind > 12 ) kind = 12 ; break ; case 12 : if ( ( 0x100002600L & l ) == 0L ) break ; if ( kind > 26 ) kind = 26 ; jjCheckNAdd ( 12 ) ; break ; case 14 : if ( ( 0xfffffffbffffffffL & l ) != 0L ) jjCheckNAddStates ( 151 , 153 ) ; break ; case 15 : if ( curChar == 34 && kind > 27 ) kind = 27 ; break ; case 17 : if ( ( 0x8400000000L & l ) != 0L ) jjCheckNAddStates ( 151 , 153 ) ; break ; case 18 : if ( ( 0xff000000000000L & l ) != 0L ) jjCheckNAddStates ( 154 , 157 ) ; break ; case 19 : if ( ( 0xff000000000000L & l ) != 0L ) jjCheckNAddStates ( 151 , 153 ) ; break ; case 20 : if ( ( 0xf000000000000L & l ) != 0L ) jjstateSet [ jjnewStateCnt ++ ] = 21 ; break ; case 21 : if ( ( 0xff000000000000L & l ) != 0L ) jjCheckNAdd ( 19 ) ; break ; case 23 : if ( ( 0x3ff000000000000L & l ) != 0L ) jjstateSet [ jjnewStateCnt ++ ] = 24 ; break ; case 24 : if ( ( 0x3ff000000000000L & l ) != 0L ) jjstateSet [ jjnewStateCnt ++ ] = 25 ; break ; case 25 : if ( ( 0x3ff000000000000L & l ) != 0L ) jjstateSet [ jjnewStateCnt ++ ] = 26 ; break ; case 26 : if ( ( 0x3ff000000000000L & l ) != 0L ) jjCheckNAddStates ( 151 , 153 ) ; break ; case 27 : if ( curChar == 32 ) jjAddStates ( 118 , 119 ) ; break ; case 28 : if ( curChar == 10 ) jjCheckNAddStates ( 151 , 153 ) ; break ; case 29 : if ( curChar == 39 ) jjCheckNAddStates ( 148 , 150 ) ; break ; case 30 : if ( ( 0xffffff7fffffffffL & l ) != 0L ) jjCheckNAddStates ( 148 , 150 ) ; break ; case 32 : if ( curChar == 32 ) jjAddStates ( 158 , 159 ) ; break ; case 33 : if ( curChar == 10 ) jjCheckNAddStates ( 148 , 150 ) ; break ; case 34 : if ( curChar == 39 && kind > 27 ) kind = 27 ; break ; case 36 : if ( ( 0x3ff200000000000L & l ) == 0L ) break ; if ( kind > 62 ) kind = 62 ; jjstateSet [ jjnewStateCnt ++ ] = 36 ; break ; case 39 : if ( curChar == 36 && kind > 13 ) kind = 13 ; break ; case 41 : if ( curChar == 36 ) jjCheckNAddTwoStates ( 42 , 43 ) ; break ; case 43 : if ( curChar == 33 && kind > 14 ) kind = 14 ; break ; case 44 : if ( curChar != 36 ) break ; if ( kind > 13 ) kind = 13 ; jjCheckNAddTwoStates ( 42 , 43 ) ; break ; case 45 : if ( curChar == 35 ) jjCheckNAddStates ( 145 , 147 ) ; break ; case 46 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 47 ; break ; case 47 : if ( ( 0xfffffff7ffffffffL & l ) != 0L && kind > 15 ) kind = 15 ; break ; case 49 : if ( curChar == 45 ) jjCheckNAddStates ( 141 , 144 ) ; break ; case 50 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 52 ) kind = 52 ; jjCheckNAddTwoStates ( 50 , 52 ) ; break ; case 51 : if ( curChar == 46 && kind > 52 ) kind = 52 ; break ; case 52 : if ( curChar == 46 ) jjstateSet [ jjnewStateCnt ++ ] = 51 ; break ; case 53 : if ( ( 0x3ff000000000000L & l ) != 0L ) jjCheckNAddTwoStates ( 53 , 54 ) ; break ; case 54 : if ( curChar != 46 ) break ; if ( kind > 53 ) kind = 53 ; jjCheckNAddTwoStates ( 55 , 56 ) ; break ; case 55 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 53 ) kind = 53 ; jjCheckNAddTwoStates ( 55 , 56 ) ; break ; case 57 : if ( ( 0x280000000000L & l ) != 0L ) jjCheckNAdd ( 58 ) ; break ; case 58 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 53 ) kind = 53 ; jjCheckNAdd ( 58 ) ; break ; case 59 : if ( curChar == 46 ) jjCheckNAdd ( 60 ) ; break ; case 62 : if ( ( 0x280000000000L & l ) != 0L ) jjCheckNAdd ( 63 ) ; break ; case 63 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 53 ) kind = 53 ; jjCheckNAdd ( 63 ) ; break ; case 64 : if ( ( 0x3ff000000000000L & l ) != 0L ) jjCheckNAddTwoStates ( 64 , 65 ) ; break ; case 66 : if ( ( 0x280000000000L & l ) != 0L ) jjCheckNAdd ( 67 ) ; break ; case 67 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 53 ) kind = 53 ; jjCheckNAdd ( 67 ) ; break ; case 68 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 52 ) kind = 52 ; jjCheckNAddStates ( 135 , 140 ) ; break ; case 69 : if ( curChar == 46 ) jjCheckNAddTwoStates ( 60 , 70 ) ; break ; default : break ; } } while ( i != startsAt ) ; } else if ( curChar < 128 ) { long l = 1L << ( curChar & 077 ) ; do { switch ( jjstateSet [ -- i ] ) { case 13 : if ( ( 0x7fffffe87fffffeL & l ) != 0L ) { if ( kind > 62 ) kind = 62 ; jjCheckNAdd ( 36 ) ; } else if ( curChar == 92 ) jjCheckNAddStates ( 160 , 163 ) ; break ; case 70 : if ( ( 0x7fffffe07fffffeL & l ) != 0L && kind > 63 ) kind = 63 ; break ; case 48 : if ( curChar == 123 ) jjstateSet [ jjnewStateCnt ++ ] = 10 ; else if ( curChar == 115 ) jjstateSet [ jjnewStateCnt ++ ] = 5 ; break ; case 2 : if ( curChar == 116 ) jjCheckNAddTwoStates ( 3 , 4 ) ; break ; case 5 : if ( curChar == 101 ) jjstateSet [ jjnewStateCnt ++ ] = 2 ; break ; case 6 : if ( curChar == 115 ) jjstateSet [ jjnewStateCnt ++ ] = 5 ; break ; case 7 : if ( curChar == 125 ) jjCheckNAddTwoStates ( 3 , 4 ) ; break ; case 8 : if ( curChar == 116 ) jjstateSet [ jjnewStateCnt ++ ] = 7 ; break ; case 9 : if ( curChar == 101 ) jjstateSet [ jjnewStateCnt ++ ] = 8 ; break ; case 10 : if ( curChar == 115 ) jjstateSet [ jjnewStateCnt ++ ] = 9 ; break ; case 11 : if ( curChar == 123 ) jjstateSet [ jjnewStateCnt ++ ] = 10 ; break ; case 14 : jjCheckNAddStates ( 151 , 153 ) ; break ; case 16 : if ( curChar == 92 ) jjAddStates ( 164 , 169 ) ; break ; case 17 : if ( ( 0x14404410000000L & l ) != 0L ) jjCheckNAddStates ( 151 , 153 ) ; break ; case 22 : if ( curChar == 117 ) jjstateSet [ jjnewStateCnt ++ ] = 23 ; break ; case 23 : if ( ( 0x7e0000007eL & l ) != 0L ) jjstateSet [ jjnewStateCnt ++ ] = 24 ; break ; case 24 : if ( ( 0x7e0000007eL & l ) != 0L ) jjstateSet [ jjnewStateCnt ++ ] = 25 ; break ; case 25 : if ( ( 0x7e0000007eL & l ) != 0L ) jjstateSet [ jjnewStateCnt ++ ] = 26 ; break ; case 26 : if ( ( 0x7e0000007eL & l ) != 0L ) jjCheckNAddStates ( 151 , 153 ) ; break ; case 30 : jjAddStates ( 148 , 150 ) ; break ; case 31 : if ( curChar == 92 ) jjAddStates ( 158 , 159 ) ; break ; case 35 : case 36 : if ( ( 0x7fffffe87fffffeL & l ) == 0L ) break ; if ( kind > 62 ) kind = 62 ; jjCheckNAdd ( 36 ) ; break ; case 37 : if ( curChar == 92 ) jjCheckNAddStates ( 160 , 163 ) ; break ; case 38 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 38 , 39 ) ; break ; case 40 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 40 , 41 ) ; break ; case 42 : if ( curChar == 92 ) jjAddStates ( 170 , 171 ) ; break ; case 47 : if ( kind > 15 ) kind = 15 ; break ; case 56 : if ( ( 0x2000000020L & l ) != 0L ) jjAddStates ( 172 , 173 ) ; break ; case 61 : if ( ( 0x2000000020L & l ) != 0L ) jjAddStates ( 174 , 175 ) ; break ; case 65 : if ( ( 0x2000000020L & l ) != 0L ) jjAddStates ( 27 , 28 ) ; break ; default : break ; } } while ( i != startsAt ) ; } else { int hiByte = ( int ) ( curChar > > 8 ) ; int i1 = hiByte > > 6 ; long l1 = 1L << ( hiByte & 077 ) ; int i2 = ( curChar & 0xff ) > > 6 ; long l2 = 1L << ( curChar & 077 ) ; do { switch ( jjstateSet [ -- i ] ) { case 14 : if ( jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) ) jjAddStates ( 151 , 153 ) ; break ; case 30 : if ( jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) ) jjAddStates ( 148 , 150 ) ; break ; case 47 : if ( jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) && kind > 15 ) kind = 15 ; break ; default : break ; } } while ( i != startsAt ) ; } if ( kind != 0x7fffffff ) { jjmatchedKind = kind ; jjmatchedPos = curPos ; kind = 0x7fffffff ; } ++ curPos ; if ( ( i = jjnewStateCnt ) == ( startsAt = 71 - ( jjnewStateCnt = startsAt ) ) ) return curPos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return curPos ; } } } private final int jjStopStringLiteralDfa_2 ( int pos , long active0 , long active1 ) { switch ( pos ) { case 0 : if ( ( active0 & 0x70000L ) != 0L ) return 27 ; if ( ( active0 & 0x30000000L ) != 0L ) { jjmatchedKind = 62 ; return 13 ; } return - 1 ; case 1 : if ( ( active0 & 0x30000000L ) != 0L ) { jjmatchedKind = 62 ; jjmatchedPos = 1 ; return 13 ; } if ( ( active0 & 0x10000L ) != 0L ) return 25 ; return - 1 ; case 2 : if ( ( active0 & 0x30000000L ) != 0L ) { jjmatchedKind = 62 ; jjmatchedPos = 2 ; return 13 ; } return - 1 ; case 3 : if ( ( active0 & 0x10000000L ) != 0L ) return 13 ; if ( ( active0 & 0x20000000L ) != 0L ) { jjmatchedKind = 62 ; jjmatchedPos = 3 ; return 13 ; } return - 1 ; default : return - 1 ; } } private final int jjStartNfa_2 ( int pos , long active0 , long active1 ) { return jjMoveNfa_2 ( jjStopStringLiteralDfa_2 ( pos , active0 , active1 ) , pos + 1 ) ; } private int jjMoveStringLiteralDfa0_2 ( ) { switch ( curChar ) { case 35 : jjmatchedKind = 17 ; return jjMoveStringLiteralDfa1_2 ( 0x50000L ) ; case 40 : return jjStopAtPos ( 0 , 8 ) ; case 102 : return jjMoveStringLiteralDfa1_2 ( 0x20000000L ) ; case 116 : return jjMoveStringLiteralDfa1_2 ( 0x10000000L ) ; case 123 : return jjStopAtPos ( 0 , 64 ) ; case 125 : return jjStopAtPos ( 0 , 65 ) ; default : return jjMoveNfa_2 ( 12 , 0 ) ; } } private int jjMoveStringLiteralDfa1_2 ( long active0 ) { try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_2 ( 0 , active0 , 0L ) ; return 1 ; } switch ( curChar ) { case 35 : if ( ( active0 & 0x40000L ) != 0L ) return jjStopAtPos ( 1 , 18 ) ; break ; case 42 : if ( ( active0 & 0x10000L ) != 0L ) return jjStartNfaWithStates_2 ( 1 , 16 , 25 ) ; break ; case 97 : return jjMoveStringLiteralDfa2_2 ( active0 , 0x20000000L ) ; case 114 : return jjMoveStringLiteralDfa2_2 ( active0 , 0x10000000L ) ; default : break ; } return jjStartNfa_2 ( 0 , active0 , 0L ) ; } private int jjMoveStringLiteralDfa2_2 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0L ) return jjStartNfa_2 ( 0 , old0 , 0L ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_2 ( 1 , active0 , 0L ) ; return 2 ; } switch ( curChar ) { case 108 : return jjMoveStringLiteralDfa3_2 ( active0 , 0x20000000L ) ; case 117 : return jjMoveStringLiteralDfa3_2 ( active0 , 0x10000000L ) ; default : break ; } return jjStartNfa_2 ( 1 , active0 , 0L ) ; } private int jjMoveStringLiteralDfa3_2 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0L ) return jjStartNfa_2 ( 1 , old0 , 0L ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_2 ( 2 , active0 , 0L ) ; return 3 ; } switch ( curChar ) { case 101 : if ( ( active0 & 0x10000000L ) != 0L ) return jjStartNfaWithStates_2 ( 3 , 28 , 13 ) ; break ; case 115 : return jjMoveStringLiteralDfa4_2 ( active0 , 0x20000000L ) ; default : break ; } return jjStartNfa_2 ( 2 , active0 , 0L ) ; } private int jjMoveStringLiteralDfa4_2 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0L ) return jjStartNfa_2 ( 2 , old0 , 0L ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_2 ( 3 , active0 , 0L ) ; return 4 ; } switch ( curChar ) { case 101 : if ( ( active0 & 0x20000000L ) != 0L ) return jjStartNfaWithStates_2 ( 4 , 29 , 13 ) ; break ; default : break ; } return jjStartNfa_2 ( 3 , active0 , 0L ) ; } private int jjStartNfaWithStates_2 ( int pos , int kind , int state ) { jjmatchedKind = kind ; jjmatchedPos = pos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return pos + 1 ; } return jjMoveNfa_2 ( state , pos + 1 ) ; } private int jjMoveNfa_2 ( int startState , int curPos ) { int startsAt = 0 ; jjnewStateCnt = 28 ; int i = 1 ; jjstateSet [ 0 ] = startState ; int kind = 0x7fffffff ; for ( ; ; ) { if ( ++ jjround == 0x7fffffff ) ReInitRounds ( ) ; if ( curChar < 64 ) { long l = 1L << curChar ; do { switch ( jjstateSet [ -- i ] ) { case 12 : if ( ( 0x100000200L & l ) != 0L ) jjCheckNAddTwoStates ( 0 , 1 ) ; else if ( curChar == 35 ) jjCheckNAddStates ( 126 , 128 ) ; else if ( curChar == 36 ) { if ( kind > 13 ) kind = 13 ; jjCheckNAddTwoStates ( 21 , 22 ) ; } else if ( curChar == 46 ) jjstateSet [ jjnewStateCnt ++ ] = 15 ; break ; case 27 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 25 ; break ; case 0 : if ( ( 0x100000200L & l ) != 0L ) jjCheckNAddTwoStates ( 0 , 1 ) ; break ; case 1 : if ( curChar == 35 ) jjCheckNAddTwoStates ( 6 , 11 ) ; break ; case 3 : if ( curChar == 32 ) jjAddStates ( 108 , 109 ) ; break ; case 4 : if ( curChar == 40 && kind > 12 ) kind = 12 ; break ; case 13 : if ( ( 0x3ff200000000000L & l ) == 0L ) break ; if ( kind > 62 ) kind = 62 ; jjstateSet [ jjnewStateCnt ++ ] = 13 ; break ; case 14 : if ( curChar == 46 ) jjstateSet [ jjnewStateCnt ++ ] = 15 ; break ; case 18 : if ( curChar == 36 && kind > 13 ) kind = 13 ; break ; case 20 : if ( curChar == 36 ) jjCheckNAddTwoStates ( 21 , 22 ) ; break ; case 22 : if ( curChar == 33 && kind > 14 ) kind = 14 ; break ; case 23 : if ( curChar != 36 ) break ; if ( kind > 13 ) kind = 13 ; jjCheckNAddTwoStates ( 21 , 22 ) ; break ; case 24 : if ( curChar == 35 ) jjCheckNAddStates ( 126 , 128 ) ; break ; case 25 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 26 ; break ; case 26 : if ( ( 0xfffffff7ffffffffL & l ) != 0L && kind > 15 ) kind = 15 ; break ; default : break ; } } while ( i != startsAt ) ; } else if ( curChar < 128 ) { long l = 1L << ( curChar & 077 ) ; do { switch ( jjstateSet [ -- i ] ) { case 12 : if ( ( 0x7fffffe87fffffeL & l ) != 0L ) { if ( kind > 62 ) kind = 62 ; jjCheckNAdd ( 13 ) ; } else if ( curChar == 92 ) jjCheckNAddStates ( 129 , 132 ) ; break ; case 27 : if ( curChar == 123 ) jjstateSet [ jjnewStateCnt ++ ] = 10 ; else if ( curChar == 115 ) jjstateSet [ jjnewStateCnt ++ ] = 5 ; break ; case 2 : if ( curChar == 116 ) jjCheckNAddTwoStates ( 3 , 4 ) ; break ; case 5 : if ( curChar == 101 ) jjstateSet [ jjnewStateCnt ++ ] = 2 ; break ; case 6 : if ( curChar == 115 ) jjstateSet [ jjnewStateCnt ++ ] = 5 ; break ; case 7 : if ( curChar == 125 ) jjCheckNAddTwoStates ( 3 , 4 ) ; break ; case 8 : if ( curChar == 116 ) jjstateSet [ jjnewStateCnt ++ ] = 7 ; break ; case 9 : if ( curChar == 101 ) jjstateSet [ jjnewStateCnt ++ ] = 8 ; break ; case 10 : if ( curChar == 115 ) jjstateSet [ jjnewStateCnt ++ ] = 9 ; break ; case 11 : if ( curChar == 123 ) jjstateSet [ jjnewStateCnt ++ ] = 10 ; break ; case 13 : if ( ( 0x7fffffe87fffffeL & l ) == 0L ) break ; if ( kind > 62 ) kind = 62 ; jjCheckNAdd ( 13 ) ; break ; case 15 : if ( ( 0x7fffffe07fffffeL & l ) != 0L && kind > 63 ) kind = 63 ; break ; case 16 : if ( curChar == 92 ) jjCheckNAddStates ( 129 , 132 ) ; break ; case 17 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 17 , 18 ) ; break ; case 19 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 19 , 20 ) ; break ; case 21 : if ( curChar == 92 ) jjAddStates ( 133 , 134 ) ; break ; case 26 : if ( kind > 15 ) kind = 15 ; break ; default : break ; } } while ( i != startsAt ) ; } else { int hiByte = ( int ) ( curChar > > 8 ) ; int i1 = hiByte > > 6 ; long l1 = 1L << ( hiByte & 077 ) ; int i2 = ( curChar & 0xff ) > > 6 ; long l2 = 1L << ( curChar & 077 ) ; do { switch ( jjstateSet [ -- i ] ) { case 26 : if ( jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) && kind > 15 ) kind = 15 ; break ; default : break ; } } while ( i != startsAt ) ; } if ( kind != 0x7fffffff ) { jjmatchedKind = kind ; jjmatchedPos = curPos ; kind = 0x7fffffff ; } ++ curPos ; if ( ( i = jjnewStateCnt ) == ( startsAt = 28 - ( jjnewStateCnt = startsAt ) ) ) return curPos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return curPos ; } } } static final int [ ] jjnextStates = { 87 , 89 , 90 , 91 , 96 , 97 , 87 , 90 , 57 , 96 , 27 , 28 , 31 , 11 , 12 , 13 , 1 , 2 , 4 , 11 , 16 , 12 , 13 , 24 , 25 , 29 , 30 , 66 , 67 , 69 , 70 , 71 , 72 , 83 , 85 , 80 , 81 , 77 , 78 , 14 , 15 , 17 , 19 , 24 , 25 , 60 , 61 , 73 , 74 , 94 , 95 , 98 , 99 , 5 , 6 , 7 , 8 , 9 , 10 , 78 , 80 , 81 , 82 , 87 , 88 , 78 , 81 , 10 , 87 , 19 , 20 , 31 , 32 , 34 , 42 , 43 , 45 , 50 , 32 , 51 , 66 , 43 , 67 , 54 , 57 , 64 , 71 , 76 , 22 , 23 , 24 , 25 , 35 , 40 , 47 , 13 , 14 , 26 , 27 , 85 , 86 , 89 , 90 , 6 , 11 , 33 , 16 , 18 , 3 , 4 , 20 , 21 , 23 , 24 , 25 , 26 , 14 , 15 , 27 , 28 , 8 , 9 , 10 , 11 , 12 , 13 , 6 , 11 , 27 , 17 , 18 , 19 , 20 , 21 , 22 , 50 , 52 , 53 , 54 , 64 , 65 , 50 , 53 , 59 , 64 , 6 , 11 , 48 , 30 , 31 , 34 , 14 , 15 , 16 , 14 , 19 , 15 , 16 , 32 , 33 , 38 , 39 , 40 , 41 , 17 , 18 , 20 , 22 , 27 , 28 , 42 , 43 , 57 , 58 , 62 , 63 , } ; private static final boolean jjCanMove_0 ( int hiByte , int i1 , int i2 , long l1 , long l2 ) { switch ( hiByte ) { case 0 : return ( ( jjbitVec2 [ i2 ] & l2 ) != 0L ) ; default : if ( ( jjbitVec0 [ i1 ] & l1 ) != 0L ) return true ; return false ; } } public static final String [ ] jjstrLiteralImages = { null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , } ; public static final String [ ] lexStateNames = { "DIRECTIVE" , "REFMOD2" , "REFMODIFIER" , "DEFAULT" , "REFERENCE" , "PRE_DIRECTIVE" , "IN_MULTI_LINE_COMMENT" , "IN_FORMAL_COMMENT" , "IN_SINGLE_LINE_COMMENT" , } ; public static final int [ ] jjnewLexState = { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , } ; static final long [ ] jjtoToken = { 0xc637fffffdfc1fffL , 0x3L , } ; static final long [ ] jjtoSkip = { 0x2000000L , 0xcL , } ; static final long [ ] jjtoSpecial = { 0x0L , 0xcL , } ; static final long [ ] jjtoMore = { 0x3e000L , 0x0L , } ; protected CharStream input_stream ; private final int [ ] jjrounds = new int [ 101 ] ; private final int [ ] jjstateSet = new int [ 202 ] ; private final StringBuffer jjimage = new StringBuffer ( ) ; private StringBuffer image = jjimage ; private int jjimageLen ; private int lengthOfMatch ; protected char curChar ; public ParserTokenManager ( CharStream stream ) { input_stream = stream ; } public ParserTokenManager ( CharStream stream , int lexState ) { this ( stream ) ; SwitchTo ( lexState ) ; } public void ReInit ( CharStream stream ) { jjmatchedPos = jjnewStateCnt = 0 ; curLexState = defaultLexState ; input_stream = stream ; ReInitRounds ( ) ; } private void ReInitRounds ( ) { int i ; jjround = 0x80000001 ; for ( i = 101 ; i -- > 0 ; ) jjrounds [ i ] = 0x80000000 ; } public void ReInit ( CharStream stream , int lexState ) { ReInit ( stream ) ; SwitchTo ( lexState ) ; } public void SwitchTo ( int lexState ) { if ( lexState >= 9 || lexState < 0 ) throw new TokenMgrError ( "Error: Ignoring invalid lexical state : " + lexState + ". State unchanged." , TokenMgrError . INVALID_LEXICAL_STATE ) ; else curLexState = lexState ; } protected Token jjFillToken ( ) { final Token t ; final String curTokenImage ; final int beginLine ; final int endLine ; final int beginColumn ; final int endColumn ; String im = jjstrLiteralImages [ jjmatchedKind ] ; curTokenImage = ( im == null ) ? input_stream . GetImage ( ) : im ; beginLine = input_stream . getBeginLine ( ) ; beginColumn = input_stream . getBeginColumn ( ) ; endLine = input_stream . getEndLine ( ) ; endColumn = input_stream . getEndColumn ( ) ; t = Token . newToken ( jjmatchedKind ) ; t . kind = jjmatchedKind ; t . image = curTokenImage ; t . beginLine = beginLine ; t . endLine = endLine ; t . beginColumn = beginColumn ; t . endColumn = endColumn ; return t ; } int curLexState = 3 ; int defaultLexState = 3 ; int jjnewStateCnt ; int jjround ; int jjmatchedPos ; int jjmatchedKind ; public Token getNextToken ( ) { Token specialToken = null ; Token matchedToken ; int curPos = 0 ; EOFLoop : for ( ; ; ) { try { curChar = input_stream . BeginToken ( ) ; } catch ( java . io . IOException e ) { jjmatchedKind = 0 ; matchedToken = jjFillToken ( ) ; matchedToken . specialToken = specialToken ; return matchedToken ; } image = jjimage ; image . setLength ( 0 ) ; jjimageLen = 0 ; for ( ; ; ) { switch ( curLexState ) { case 0 : jjmatchedKind = 0x7fffffff ; jjmatchedPos = 0 ; curPos = jjMoveStringLiteralDfa0_0 ( ) ; break ; case 1 : jjmatchedKind = 0x7fffffff ; jjmatchedPos = 0 ; curPos = jjMoveStringLiteralDfa0_1 ( ) ; if ( jjmatchedPos == 0 && jjmatchedKind > 66 ) { jjmatchedKind = 66 ; } break ; case 2 : jjmatchedKind = 0x7fffffff ; jjmatchedPos = 0 ; curPos = jjMoveStringLiteralDfa0_2 ( ) ; if ( jjmatchedPos == 0 && jjmatchedKind > 66 ) { jjmatchedKind = 66 ; } break ; case 3 : jjmatchedKind = 0x7fffffff ; jjmatchedPos = 0 ; curPos = jjMoveStringLiteralDfa0_3 ( ) ; break ; case 4 : jjmatchedKind = 0x7fffffff ; jjmatchedPos = 0 ; curPos = jjMoveStringLiteralDfa0_4 ( ) ; if ( jjmatchedPos == 0 && jjmatchedKind > 66 ) { jjmatchedKind = 66 ; } break ; case 5 : jjmatchedKind = 0x7fffffff ; jjmatchedPos = 0 ; curPos = jjMoveStringLiteralDfa0_5 ( ) ; if ( jjmatchedPos == 0 && jjmatchedKind > 67 ) { jjmatchedKind = 67 ; } break ; case 6 : jjmatchedKind = 0x7fffffff ; jjmatchedPos = 0 ; curPos = jjMoveStringLiteralDfa0_6 ( ) ; if ( jjmatchedPos == 0 && jjmatchedKind > 25 ) { jjmatchedKind = 25 ; } break ; case 7 : jjmatchedKind = 0x7fffffff ; jjmatchedPos = 0 ; curPos = jjMoveStringLiteralDfa0_7 ( ) ; if ( jjmatchedPos == 0 && jjmatchedKind > 25 ) { jjmatchedKind = 25 ; } break ; case 8 : jjmatchedKind = 0x7fffffff ; jjmatchedPos = 0 ; curPos = jjMoveStringLiteralDfa0_8 ( ) ; if ( jjmatchedPos == 0 && jjmatchedKind > 25 ) { jjmatchedKind = 25 ; } break ; } if ( jjmatchedKind != 0x7fffffff ) { if ( jjmatchedPos + 1 < curPos ) input_stream . backup ( curPos - jjmatchedPos - 1 ) ; if ( ( jjtoToken [ jjmatchedKind > > 6 ] & ( 1L << ( jjmatchedKind & 077 ) ) ) != 0L ) { matchedToken = jjFillToken ( ) ; matchedToken . specialToken = specialToken ; TokenLexicalActions ( matchedToken ) ; if ( jjnewLexState [ jjmatchedKind ] != - 1 ) curLexState = jjnewLexState [ jjmatchedKind ] ; return matchedToken ; } else if ( ( jjtoSkip [ jjmatchedKind > > 6 ] & ( 1L << ( jjmatchedKind & 077 ) ) ) != 0L ) { if ( ( jjtoSpecial [ jjmatchedKind > > 6 ] & ( 1L << ( jjmatchedKind & 077 ) ) ) != 0L ) { matchedToken = jjFillToken ( ) ; if ( specialToken == null ) specialToken = matchedToken ; else { matchedToken . specialToken = specialToken ; specialToken = ( specialToken . next = matchedToken ) ; } SkipLexicalActions ( matchedToken ) ; } else SkipLexicalActions ( null ) ; if ( jjnewLexState [ jjmatchedKind ] != - 1 ) curLexState = jjnewLexState [ jjmatchedKind ] ; continue EOFLoop ; } MoreLexicalActions ( ) ; if ( jjnewLexState [ jjmatchedKind ] != - 1 ) curLexState = jjnewLexState [ jjmatchedKind ] ; curPos = 0 ; jjmatchedKind = 0x7fffffff ; try { curChar = input_stream . readChar ( ) ; continue ; } catch ( java . io . IOException e1 ) { } } int error_line = input_stream . getEndLine ( ) ; int error_column = input_stream . getEndColumn ( ) ; String error_after = null ; boolean EOFSeen = false ; try { input_stream . readChar ( ) ; input_stream . backup ( 1 ) ; } catch ( java . io . IOException e1 ) { EOFSeen = true ; error_after = curPos <= 1 ? "" : input_stream . GetImage ( ) ; if ( curChar == '\n' || curChar == '\r' ) { error_line ++ ; error_column = 0 ; } else error_column ++ ; } if ( ! EOFSeen ) { input_stream . backup ( 1 ) ; error_after = curPos <= 1 ? "" : input_stream . GetImage ( ) ; } throw new TokenMgrError ( EOFSeen , curLexState , error_line , error_column , error_after , curChar , TokenMgrError . LEXICAL_ERROR ) ; } } } void SkipLexicalActions ( Token matchedToken ) { switch ( jjmatchedKind ) { case 66 : image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; input_stream . backup ( 1 ) ; inReference = false ; if ( debugPrint ) System . out . print ( "REF_TERM :" ) ; stateStackPop ( ) ; break ; case 67 : image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; if ( debugPrint ) System . out . print ( "DIRECTIVE_TERM :" ) ; input_stream . backup ( 1 ) ; inDirective = false ; stateStackPop ( ) ; break ; default : break ; } } void MoreLexicalActions ( ) { jjimageLen += ( lengthOfMatch = jjmatchedPos + 1 ) ; switch ( jjmatchedKind ) { case 13 : image . append ( input_stream . GetSuffix ( jjimageLen ) ) ; jjimageLen = 0 ; if ( ! inComment ) { if ( curLexState == REFERENCE ) { inReference = false ; stateStackPop ( ) ; } inReference = true ; if ( debugPrint ) System . out . print ( "$  : going to " + REFERENCE ) ; stateStackPush ( ) ; SwitchTo ( REFERENCE ) ; } break ; case 14 : image . append ( input_stream . GetSuffix ( jjimageLen ) ) ; jjimageLen = 0 ; if ( ! inComment ) { if ( curLexState == REFERENCE ) { inReference = false ; stateStackPop ( ) ; } inReference = true ; if ( debugPrint ) System . out . print ( "$!  : going to " + REFERENCE ) ; stateStackPush ( ) ; SwitchTo ( REFERENCE ) ; } break ; case 15 : image . append ( input_stream . GetSuffix ( jjimageLen ) ) ; jjimageLen = 0 ; if ( ! inComment ) { input_stream . backup ( 1 ) ; inComment = true ; stateStackPush ( ) ; SwitchTo ( IN_FORMAL_COMMENT ) ; } break ; case 16 : image . append ( input_stream . GetSuffix ( jjimageLen ) ) ; jjimageLen = 0 ; if ( ! inComment ) { inComment = true ; stateStackPush ( ) ; SwitchTo ( IN_MULTI_LINE_COMMENT ) ; } break ; case 17 : image . append ( input_stream . GetSuffix ( jjimageLen ) ) ; jjimageLen = 0 ; if ( ! inComment ) { if ( curLexState == REFERENCE || curLexState == REFMODIFIER ) { inReference = false ; stateStackPop ( ) ; } inDirective = true ; if ( debugPrint ) System . out . print ( "# :  going to " + DIRECTIVE ) ; stateStackPush ( ) ; SwitchTo ( PRE_DIRECTIVE ) ; } break ; default : break ; } } void TokenLexicalActions ( Token matchedToken ) { switch ( jjmatchedKind ) { case 8 : image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; if ( ! inComment ) lparen ++ ; if ( curLexState == REFMODIFIER ) SwitchTo ( REFMOD2 ) ; break ; case 9 : image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; RPARENHandler ( ) ; break ; case 10 : image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; SwitchTo ( REFERENCE ) ; break ; case 12 : image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; if ( ! inComment ) { inDirective = true ; if ( debugPrint ) System . out . print ( "#set :  going to " + DIRECTIVE ) ; stateStackPush ( ) ; inSet = true ; SwitchTo ( DIRECTIVE ) ; } if ( ! inComment ) { lparen ++ ; if ( curLexState == REFMODIFIER ) SwitchTo ( REFMOD2 ) ; } break ; case 18 : image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; if ( ! inComment ) { if ( curLexState == REFERENCE ) { inReference = false ; stateStackPop ( ) ; } inComment = true ; stateStackPush ( ) ; SwitchTo ( IN_SINGLE_LINE_COMMENT ) ; } break ; case 22 : image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; inComment = false ; stateStackPop ( ) ; break ; case 23 : image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; inComment = false ; stateStackPop ( ) ; break ; case 24 : image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; inComment = false ; stateStackPop ( ) ; break ; case 27 : image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; if ( curLexState == DIRECTIVE && ! inSet && lparen == 0 ) stateStackPop ( ) ; break ; case 30 : image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; if ( debugPrint ) System . out . println ( " NEWLINE :" ) ; stateStackPop ( ) ; if ( inSet ) inSet = false ; if ( inDirective ) inDirective = false ; break ; case 46 : image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; inDirective = false ; stateStackPop ( ) ; break ; case 47 : image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; SwitchTo ( DIRECTIVE ) ; break ; case 48 : image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; SwitchTo ( DIRECTIVE ) ; break ; case 49 : image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; inDirective = false ; stateStackPop ( ) ; break ; case 50 : image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; inDirective = false ; stateStackPop ( ) ; break ; case 52 : image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; if ( matchedToken . image . endsWith ( ".." ) ) { input_stream . backup ( 2 ) ; matchedToken . image = matchedToken . image . substring ( 0 , matchedToken . image . length ( ) - 2 ) ; } if ( lparen == 0 && ! inSet && curLexState != REFMOD2 ) { stateStackPop ( ) ; } break ; case 53 : image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; if ( lparen == 0 && ! inSet && curLexState != REFMOD2 ) { stateStackPop ( ) ; } break ; case 63 : image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; input_stream . backup ( 1 ) ; matchedToken . image = "." ; if ( debugPrint ) System . out . print ( "DOT : switching to " + REFMODIFIER ) ; SwitchTo ( REFMODIFIER ) ; break ; case 65 : image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; stateStackPop ( ) ; break ; default : break ; } } private void jjCheckNAdd ( int state ) { if ( jjrounds [ state ] != jjround ) { jjstateSet [ jjnewStateCnt ++ ] = state ; jjrounds [ state ] = jjround ; } } private void jjAddStates ( int start , int end ) { do { jjstateSet [ jjnewStateCnt ++ ] = jjnextStates [ start ] ; } while ( start ++ != end ) ; } private void jjCheckNAddTwoStates ( int state1 , int state2 ) { jjCheckNAdd ( state1 ) ; jjCheckNAdd ( state2 ) ; } private void jjCheckNAddStates ( int start , int end ) { do { jjCheckNAdd ( jjnextStates [ start ] ) ; } while ( start ++ != end ) ; } } 	1	['89', '1', '0', '5', '123', '492', '1', '4', '10', '0.80815508', '13175', '0.382352941', '1', '0', '0.339015152', '0', '0', '146.6516854', '209', '13.4831', '9']
package org . apache . velocity . anakia ; import java . io . IOException ; import java . io . StringWriter ; import java . io . Writer ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Iterator ; import java . util . List ; import java . util . ListIterator ; import org . jdom . Attribute ; import org . jdom . CDATA ; import org . jdom . Comment ; import org . jdom . DocType ; import org . jdom . Document ; import org . jdom . Element ; import org . jdom . EntityRef ; import org . jdom . ProcessingInstruction ; import org . jdom . Text ; import org . jdom . output . XMLOutputter ; public class NodeList implements List , Cloneable { private static final AttributeXMLOutputter DEFAULT_OUTPUTTER = new AttributeXMLOutputter ( ) ; private List nodes ; public NodeList ( ) { nodes = new ArrayList ( ) ; } public NodeList ( Document document ) { this ( ( Object ) document ) ; } public NodeList ( Element element ) { this ( ( Object ) element ) ; } private NodeList ( Object object ) { if ( object == null ) { throw new IllegalArgumentException ( "Cannot construct NodeList with null." ) ; } nodes = new ArrayList ( 1 ) ; nodes . add ( object ) ; } public NodeList ( List nodes ) { this ( nodes , true ) ; } public NodeList ( List nodes , boolean copy ) { if ( nodes == null ) { throw new IllegalArgumentException ( "Cannot initialize NodeList with null list" ) ; } this . nodes = copy ? new ArrayList ( nodes ) : nodes ; } public List getList ( ) { return nodes ; } public String toString ( ) { if ( nodes . isEmpty ( ) ) { return "" ; } StringWriter sw = new StringWriter ( nodes . size ( ) * 128 ) ; try { for ( Iterator i = nodes . iterator ( ) ; i . hasNext ( ) ; ) { Object node = i . next ( ) ; if ( node instanceof Element ) { DEFAULT_OUTPUTTER . output ( ( Element ) node , sw ) ; } else if ( node instanceof Attribute ) { DEFAULT_OUTPUTTER . output ( ( Attribute ) node , sw ) ; } else if ( node instanceof Text ) { DEFAULT_OUTPUTTER . output ( ( Text ) node , sw ) ; } else if ( node instanceof Document ) { DEFAULT_OUTPUTTER . output ( ( Document ) node , sw ) ; } else if ( node instanceof ProcessingInstruction ) { DEFAULT_OUTPUTTER . output ( ( ProcessingInstruction ) node , sw ) ; } else if ( node instanceof Comment ) { DEFAULT_OUTPUTTER . output ( ( Comment ) node , sw ) ; } else if ( node instanceof CDATA ) { DEFAULT_OUTPUTTER . output ( ( CDATA ) node , sw ) ; } else if ( node instanceof DocType ) { DEFAULT_OUTPUTTER . output ( ( DocType ) node , sw ) ; } else if ( node instanceof EntityRef ) { DEFAULT_OUTPUTTER . output ( ( EntityRef ) node , sw ) ; } else { throw new IllegalArgumentException ( "Cannot process a " + ( node == null ? "null node" : "node of class " + node . getClass ( ) . getName ( ) ) ) ; } } } catch ( IOException e ) { throw new Error ( ) ; } return sw . toString ( ) ; } public Object clone ( ) throws CloneNotSupportedException { NodeList clonedList = ( NodeList ) super . clone ( ) ; clonedList . cloneNodes ( ) ; return clonedList ; } private void cloneNodes ( ) throws CloneNotSupportedException { Class listClass = nodes . getClass ( ) ; try { List clonedNodes = ( List ) listClass . newInstance ( ) ; clonedNodes . addAll ( nodes ) ; nodes = clonedNodes ; } catch ( IllegalAccessException e ) { throw new CloneNotSupportedException ( "Cannot clone NodeList since" + " there is no accessible no-arg constructor on class " + listClass . getName ( ) ) ; } catch ( InstantiationException e ) { throw new Error ( ) ; } } public int hashCode ( ) { return nodes . hashCode ( ) ; } public boolean equals ( Object o ) { return o instanceof NodeList ? ( ( NodeList ) o ) . nodes . equals ( nodes ) : false ; } public NodeList selectNodes ( String xpathString ) { return new NodeList ( XPathCache . getXPath ( xpathString ) . applyTo ( nodes ) , false ) ; } public boolean add ( Object o ) { return nodes . add ( o ) ; } public void add ( int index , Object o ) { nodes . add ( index , o ) ; } public boolean addAll ( Collection c ) { return nodes . addAll ( c ) ; } public boolean addAll ( int index , Collection c ) { return nodes . addAll ( index , c ) ; } public void clear ( ) { nodes . clear ( ) ; } public boolean contains ( Object o ) { return nodes . contains ( o ) ; } public boolean containsAll ( Collection c ) { return nodes . containsAll ( c ) ; } public Object get ( int index ) { return nodes . get ( index ) ; } public int indexOf ( Object o ) { return nodes . indexOf ( o ) ; } public boolean isEmpty ( ) { return nodes . isEmpty ( ) ; } public Iterator iterator ( ) { return nodes . iterator ( ) ; } public int lastIndexOf ( Object o ) { return nodes . lastIndexOf ( o ) ; } public ListIterator listIterator ( ) { return nodes . listIterator ( ) ; } public ListIterator listIterator ( int index ) { return nodes . listIterator ( index ) ; } public Object remove ( int index ) { return nodes . remove ( index ) ; } public boolean remove ( Object o ) { return nodes . remove ( o ) ; } public boolean removeAll ( Collection c ) { return nodes . removeAll ( c ) ; } public boolean retainAll ( Collection c ) { return nodes . retainAll ( c ) ; } public Object set ( int index , Object o ) { return nodes . set ( index , o ) ; } public int size ( ) { return nodes . size ( ) ; } public List subList ( int fromIndex , int toIndex ) { return new NodeList ( nodes . subList ( fromIndex , toIndex ) ) ; } public Object [ ] toArray ( ) { return nodes . toArray ( ) ; } public Object [ ] toArray ( Object [ ] a ) { return nodes . toArray ( a ) ; } private static final class AttributeXMLOutputter extends XMLOutputter { public void output ( Attribute attribute , Writer out ) throws IOException { out . write ( " " ) ; out . write ( attribute . getQualifiedName ( ) ) ; out . write ( "=" ) ; out . write ( "\"" ) ; out . write ( escapeAttributeEntities ( attribute . getValue ( ) ) ) ; out . write ( "\"" ) ; } } } 	0	['37', '1', '0', '16', '92', '0', '3', '13', '34', '0.5', '438', '1', '1', '0', '0.177777778', '1', '1', '10.78378378', '12', '1.1351', '0']
package org . apache . velocity . runtime . log ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . util . StringUtils ; public class LogChuteSystem implements LogChute { private LogSystem logSystem ; protected LogChuteSystem ( LogSystem wrapMe ) { this . logSystem = wrapMe ; } public void init ( RuntimeServices rs ) throws Exception { logSystem . init ( rs ) ; } public void log ( int level , String message ) { logSystem . logVelocityMessage ( level , message ) ; } public void log ( int level , String message , Throwable t ) { logSystem . logVelocityMessage ( level , message ) ; logSystem . logVelocityMessage ( level , StringUtils . stackTrace ( t ) ) ; } public boolean isLevelEnabled ( int level ) { return true ; } } 	1	['5', '1', '0', '6', '9', '0', '2', '4', '4', '0.25', '37', '1', '1', '0', '0.433333333', '0', '0', '6.2', '1', '0.8', '2']
package org . apache . velocity . util ; public interface TemplateNumber { public Number getAsNumber ( ) ; } 	0	['1', '1', '0', '7', '1', '0', '7', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . velocity . runtime . parser . node ; import java . lang . reflect . InvocationTargetException ; import org . apache . commons . lang . ArrayUtils ; import org . apache . commons . lang . StringUtils ; import org . apache . velocity . app . event . EventHandlerUtil ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . util . introspection . Info ; import org . apache . velocity . util . introspection . IntrospectionCacheData ; import org . apache . velocity . util . introspection . VelMethod ; public class ASTMethod extends SimpleNode { private String methodName = "" ; private int paramCount = 0 ; protected Info uberInfo ; protected boolean strictRef = false ; public ASTMethod ( int id ) { super ( id ) ; } public ASTMethod ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object init ( InternalContextAdapter context , Object data ) throws TemplateInitException { super . init ( context , data ) ; uberInfo = new Info ( getTemplateName ( ) , getLine ( ) , getColumn ( ) ) ; methodName = getFirstToken ( ) . image ; paramCount = jjtGetNumChildren ( ) - 1 ; strictRef = rsvc . getBoolean ( RuntimeConstants . RUNTIME_REFERENCES_STRICT , false ) ; return data ; } public Object execute ( Object o , InternalContextAdapter context ) throws MethodInvocationException { VelMethod method = null ; Object [ ] params = new Object [ paramCount ] ; try { final Class [ ] paramClasses = paramCount > 0 ? new Class [ paramCount ] : ArrayUtils . EMPTY_CLASS_ARRAY ; for ( int j = 0 ; j < paramCount ; j ++ ) { params [ j ] = jjtGetChild ( j + 1 ) . value ( context ) ; if ( params [ j ] != null ) { paramClasses [ j ] = params [ j ] . getClass ( ) ; } } MethodCacheKey mck = new MethodCacheKey ( methodName , paramClasses ) ; IntrospectionCacheData icd = context . icacheGet ( mck ) ; if ( icd != null && ( o != null && icd . contextData == o . getClass ( ) ) ) { method = ( VelMethod ) icd . thingy ; } else { method = rsvc . getUberspect ( ) . getMethod ( o , methodName , params , new Info ( getTemplateName ( ) , getLine ( ) , getColumn ( ) ) ) ; if ( ( method != null ) && ( o != null ) ) { icd = new IntrospectionCacheData ( ) ; icd . contextData = o . getClass ( ) ; icd . thingy = method ; context . icachePut ( mck , icd ) ; } } if ( method == null ) { if ( strictRef ) { StringBuffer plist = new StringBuffer ( ) ; for ( int i = 0 ; i < params . length ; i ++ ) { Class param = paramClasses [ i ] ; plist . append ( param == null ? "null" : param . getName ( ) ) ; if ( i < params . length - 1 ) plist . append ( ", " ) ; } throw new MethodInvocationException ( "Object '" + o . getClass ( ) . getName ( ) + "' does not contain method " + methodName + "(" + plist + ")" , null , methodName , uberInfo . getTemplateName ( ) , uberInfo . getLine ( ) , uberInfo . getColumn ( ) ) ; } else { return null ; } } } catch ( MethodInvocationException mie ) { throw mie ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { String msg = "ASTMethod.execute() : exception from introspection" ; log . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } try { Object obj = method . invoke ( o , params ) ; if ( obj == null ) { if ( method . getReturnType ( ) == Void . TYPE ) { return "" ; } } return obj ; } catch ( InvocationTargetException ite ) { return handleInvocationException ( o , context , ite . getTargetException ( ) ) ; } catch ( IllegalArgumentException t ) { return handleInvocationException ( o , context , t ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { String msg = "ASTMethod.execute() : exception invoking method '" + methodName + "' in " + o . getClass ( ) ; log . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } } private Object handleInvocationException ( Object o , InternalContextAdapter context , Throwable t ) { if ( t instanceof Exception ) { try { return EventHandlerUtil . methodException ( rsvc , context , o . getClass ( ) , methodName , ( Exception ) t ) ; } catch ( Exception e ) { throw new MethodInvocationException ( "Invocation of method '" + methodName + "' in  " + o . getClass ( ) + " threw exception " + e . toString ( ) , e , methodName , getTemplateName ( ) , this . getLine ( ) , this . getColumn ( ) ) ; } } else { throw new MethodInvocationException ( "Invocation of method '" + methodName + "' in  " + o . getClass ( ) + " threw exception " + t . toString ( ) , t , methodName , getTemplateName ( ) , this . getLine ( ) , this . getColumn ( ) ) ; } } public static class MethodCacheKey { private final String methodName ; private final Class [ ] params ; public MethodCacheKey ( String methodName , Class [ ] params ) { this . methodName = ( methodName != null ) ? methodName : StringUtils . EMPTY ; this . params = ( params != null ) ? params : ArrayUtils . EMPTY_CLASS_ARRAY ; } public boolean equals ( Object o ) { if ( o instanceof MethodCacheKey ) { final MethodCacheKey other = ( MethodCacheKey ) o ; if ( params . length == other . params . length && methodName . equals ( other . methodName ) ) { for ( int i = 0 ; i < params . length ; ++ i ) { if ( params [ i ] == null ) { if ( params [ i ] != other . params [ i ] ) { return false ; } } else if ( ! params [ i ] . equals ( other . params [ i ] ) ) { return false ; } } return true ; } } return false ; } public int hashCode ( ) { int result = 17 ; for ( int i = 0 ; i < params . length ; ++ i ) { final Class param = params [ i ] ; if ( param != null ) { result = result * 37 + param . hashCode ( ) ; } } result = result * 37 + methodName . hashCode ( ) ; return result ; } } public String getMethodName ( ) { return methodName ; } } 	1	['7', '2', '0', '21', '44', '0', '5', '18', '6', '0.5', '427', '1', '1', '0.857142857', '0.387755102', '1', '2', '59.42857143', '2', '0.8571', '3']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . util . TemplateNumber ; public class ASTNENode extends SimpleNode { public ASTNENode ( int id ) { super ( id ) ; } public ASTNENode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { Object left = jjtGetChild ( 0 ) . value ( context ) ; Object right = jjtGetChild ( 1 ) . value ( context ) ; if ( left instanceof TemplateNumber ) { left = ( ( TemplateNumber ) left ) . getAsNumber ( ) ; } if ( right instanceof TemplateNumber ) { right = ( ( TemplateNumber ) right ) . getAsNumber ( ) ; } if ( left instanceof Number && right instanceof Number ) { return MathUtils . compare ( ( Number ) left , ( Number ) right ) != 0 ; } if ( left != null && right != null && ( left . getClass ( ) . isAssignableFrom ( right . getClass ( ) ) || right . getClass ( ) . isAssignableFrom ( left . getClass ( ) ) ) ) { return ! left . equals ( right ) ; } left = ( left == null ) ? null : left . toString ( ) ; right = ( right == null ) ? null : right . toString ( ) ; if ( left == null && right == null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Both right (" + getLiteral ( false ) + " and left " + getLiteral ( true ) + " sides of '!=' operation returned null." + "If references, they may not be in the context." + getLocation ( context ) ) ; } return false ; } else if ( left == null || right == null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( ( left == null ? "Left" : "Right" ) + " side (" + getLiteral ( left == null ) + ") of '!=' operation has null value. If it is a " + "reference, it may not be in the context or its " + "toString() returned null. " + getLocation ( context ) ) ; } return true ; } else { return ! left . equals ( right ) ; } } private String getLiteral ( boolean left ) { return jjtGetChild ( left ? 0 : 1 ) . literal ( ) ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { boolean val = evaluate ( context ) ; return val ? Boolean . TRUE : Boolean . FALSE ; } } 	0	['6', '2', '0', '11', '24', '15', '4', '9', '5', '2', '207', '0', '0', '0.882352941', '0.333333333', '2', '2', '33.5', '2', '0.8333', '0']
package org . apache . velocity . util . introspection ; import java . util . Iterator ; public abstract class AbstractChainableUberspector extends UberspectImpl implements ChainableUberspector { protected Uberspect inner ; public void wrap ( Uberspect inner ) { this . inner = inner ; } public void init ( ) throws Exception { if ( this . inner != null ) { this . inner . init ( ) ; } } public Iterator getIterator ( Object obj , Info i ) throws Exception { return ( this . inner != null ) ? this . inner . getIterator ( obj , i ) : null ; } public VelMethod getMethod ( Object obj , String methodName , Object [ ] args , Info i ) throws Exception { return ( this . inner != null ) ? this . inner . getMethod ( obj , methodName , args , i ) : null ; } public VelPropertyGet getPropertyGet ( Object obj , String identifier , Info i ) throws Exception { return ( this . inner != null ) ? this . inner . getPropertyGet ( obj , identifier , i ) : null ; } public VelPropertySet getPropertySet ( Object obj , String identifier , Object arg , Info i ) throws Exception { return ( this . inner != null ) ? this . inner . getPropertySet ( obj , identifier , arg , i ) : null ; } } 	1	['7', '2', '1', '8', '13', '0', '1', '7', '7', '0.166666667', '71', '1', '1', '0.571428571', '0.476190476', '0', '0', '9', '1', '0.8571', '2']
package org . apache . velocity . runtime . parser ; import org . apache . velocity . exception . ExtendedParseException ; import org . apache . velocity . runtime . log . Log ; public class TemplateParseException extends ParseException implements ExtendedParseException { private static final long serialVersionUID = - 3146323135623083918L ; private final String templateName ; public TemplateParseException ( Token currentTokenVal , int [ ] [ ] expectedTokenSequencesVal , String [ ] tokenImageVal , String templateNameVal ) { super ( currentTokenVal , expectedTokenSequencesVal , tokenImageVal ) ; this . templateName = templateNameVal ; } public TemplateParseException ( Token currentTokenVal , int [ ] [ ] expectedTokenSequencesVal , String [ ] tokenImageVal ) { super ( currentTokenVal , expectedTokenSequencesVal , tokenImageVal ) ; templateName = "*unset*" ; } public TemplateParseException ( ) { super ( ) ; templateName = "*unset*" ; } public TemplateParseException ( String message ) { super ( message ) ; templateName = "*unset*" ; } public String getTemplateName ( ) { return templateName ; } public int getLineNumber ( ) { if ( ( currentToken != null ) && ( currentToken . next != null ) ) { return currentToken . next . beginLine ; } else { return - 1 ; } } public int getColumnNumber ( ) { if ( ( currentToken != null ) && ( currentToken . next != null ) ) { return currentToken . next . beginColumn ; } else { return - 1 ; } } public String getMessage ( ) { if ( ! specialConstructor ) { StringBuffer sb = new StringBuffer ( super . getMessage ( ) ) ; appendTemplateInfo ( sb ) ; return sb . toString ( ) ; } int maxSize = 0 ; StringBuffer expected = new StringBuffer ( ) ; for ( int i = 0 ; i < expectedTokenSequences . length ; i ++ ) { if ( maxSize < expectedTokenSequences [ i ] . length ) { maxSize = expectedTokenSequences [ i ] . length ; } for ( int j = 0 ; j < expectedTokenSequences [ i ] . length ; j ++ ) { expected . append ( tokenImage [ expectedTokenSequences [ i ] [ j ] ] ) . append ( " " ) ; } if ( expectedTokenSequences [ i ] [ expectedTokenSequences [ i ] . length - 1 ] != 0 ) { expected . append ( "..." ) ; } expected . append ( eol ) . append ( "    " ) ; } StringBuffer retval = new StringBuffer ( "Encountered \"" ) ; Token tok = currentToken . next ; for ( int i = 0 ; i < maxSize ; i ++ ) { if ( i != 0 ) { retval . append ( " " ) ; } if ( tok . kind == 0 ) { retval . append ( tokenImage [ 0 ] ) ; break ; } retval . append ( add_escapes ( tok . image ) ) ; tok = tok . next ; } retval . append ( "\" at " ) ; appendTemplateInfo ( retval ) ; if ( expectedTokenSequences . length == 1 ) { retval . append ( "Was expecting:" ) . append ( eol ) . append ( "    " ) ; } else { retval . append ( "Was expecting one of:" ) . append ( eol ) . append ( "    " ) ; } retval . append ( expected . toString ( ) ) ; return retval . toString ( ) ; } protected void appendTemplateInfo ( final StringBuffer sb ) { sb . append ( Log . formatFileString ( getTemplateName ( ) , getLineNumber ( ) , getColumnNumber ( ) ) ) ; sb . append ( eol ) ; } } 	0	['9', '4', '0', '5', '19', '8', '1', '4', '8', '0.75', '263', '1', '0', '0.75', '0.333333333', '1', '2', '28', '10', '2', '0']
package org . apache . velocity . runtime . resource . loader ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . util . ClassUtils ; import org . apache . velocity . util . StringUtils ; public class ResourceLoaderFactory { public static ResourceLoader getLoader ( RuntimeServices rs , String loaderClassName ) throws Exception { ResourceLoader loader = null ; try { loader = ( ResourceLoader ) ClassUtils . getNewInstance ( loaderClassName ) ; rs . getLog ( ) . debug ( "ResourceLoader instantiated: " + loader . getClass ( ) . getName ( ) ) ; return loader ; } catch ( Exception e ) { String msg = "Problem instantiating the template loader: " + loaderClassName + ".\n" + "Look at your properties file and make sure the\n" + "name of the template loader is correct." ; rs . getLog ( ) . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } } } 	1	['2', '1', '0', '6', '13', '1', '1', '5', '2', '2', '53', '0', '0', '0', '0.5', '0', '0', '25.5', '1', '0.5', '1']
package org . apache . velocity . exception ; import org . apache . velocity . util . ExceptionUtils ; public class VelocityException extends RuntimeException { private static final long serialVersionUID = 1251243065134956045L ; private final Throwable wrapped ; public VelocityException ( final String exceptionMessage ) { super ( exceptionMessage ) ; wrapped = null ; } public VelocityException ( final String exceptionMessage , final Throwable wrapped ) { super ( exceptionMessage ) ; this . wrapped = wrapped ; ExceptionUtils . setCause ( this , wrapped ) ; } public VelocityException ( final Throwable wrapped ) { super ( ) ; this . wrapped = wrapped ; ExceptionUtils . setCause ( this , wrapped ) ; } public Throwable getWrappedThrowable ( ) { return wrapped ; } } 	0	['4', '4', '6', '38', '7', '0', '37', '1', '4', '0.666666667', '35', '1', '0', '0.928571429', '0.666666667', '0', '0', '7.25', '1', '0.25', '0']
package org . apache . velocity . runtime . resource . loader ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . apache . commons . collections . ExtendedProperties ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . io . UnicodeInputStream ; import org . apache . velocity . runtime . resource . Resource ; import org . apache . velocity . util . StringUtils ; public class FileResourceLoader extends ResourceLoader { private List paths = new ArrayList ( ) ; private Map templatePaths = Collections . synchronizedMap ( new HashMap ( ) ) ; private boolean unicode = false ; public void init ( ExtendedProperties configuration ) { if ( log . isTraceEnabled ( ) ) { log . trace ( "FileResourceLoader : initialization starting." ) ; } paths . addAll ( configuration . getVector ( "path" ) ) ; unicode = configuration . getBoolean ( "unicode" , false ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Do unicode file recognition:  " + unicode ) ; } if ( log . isDebugEnabled ( ) ) { StringUtils . trimStrings ( paths ) ; int sz = paths . size ( ) ; for ( int i = 0 ; i < sz ; i ++ ) { log . debug ( "FileResourceLoader : adding path '" + ( String ) paths . get ( i ) + "'" ) ; } log . trace ( "FileResourceLoader : initialization complete." ) ; } } public InputStream getResourceStream ( String templateName ) throws ResourceNotFoundException { if ( org . apache . commons . lang . StringUtils . isEmpty ( templateName ) ) { throw new ResourceNotFoundException ( "Need to specify a file name or file path!" ) ; } String template = StringUtils . normalizePath ( templateName ) ; if ( template == null || template . length ( ) == 0 ) { String msg = "File resource error : argument " + template + " contains .. and may be trying to access " + "content outside of template root.  Rejected." ; log . error ( "FileResourceLoader : " + msg ) ; throw new ResourceNotFoundException ( msg ) ; } int size = paths . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { String path = ( String ) paths . get ( i ) ; InputStream inputStream = null ; try { inputStream = findTemplate ( path , template ) ; } catch ( IOException ioe ) { String msg = "Exception while loading Template " + template ; log . error ( msg , ioe ) ; throw new VelocityException ( msg , ioe ) ; } if ( inputStream != null ) { templatePaths . put ( templateName , path ) ; return inputStream ; } } throw new ResourceNotFoundException ( "FileResourceLoader : cannot find " + template ) ; } public boolean resourceExists ( String name ) { if ( name == null ) { return false ; } name = StringUtils . normalizePath ( name ) ; if ( name == null || name . length ( ) == 0 ) { return false ; } int size = paths . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { String path = ( String ) paths . get ( i ) ; try { File file = getFile ( path , name ) ; return file . canRead ( ) ; } catch ( Exception ioe ) { String msg = "Exception while checking for template " + name ; log . debug ( msg , ioe ) ; } } return false ; } private InputStream findTemplate ( final String path , final String template ) throws IOException { try { File file = getFile ( path , template ) ; if ( file . canRead ( ) ) { FileInputStream fis = null ; try { fis = new FileInputStream ( file . getAbsolutePath ( ) ) ; if ( unicode ) { UnicodeInputStream uis = null ; try { uis = new UnicodeInputStream ( fis , true ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "File Encoding for " + file + " is: " + uis . getEncodingFromStream ( ) ) ; } return new BufferedInputStream ( uis ) ; } catch ( IOException e ) { closeQuiet ( uis ) ; throw e ; } } else { return new BufferedInputStream ( fis ) ; } } catch ( IOException e ) { closeQuiet ( fis ) ; throw e ; } } else { return null ; } } catch ( FileNotFoundException fnfe ) { return null ; } } private void closeQuiet ( final InputStream is ) { if ( is != null ) { try { is . close ( ) ; } catch ( IOException ioe ) { } } } public boolean isSourceModified ( Resource resource ) { boolean modified = true ; String fileName = resource . getName ( ) ; String path = ( String ) templatePaths . get ( fileName ) ; File currentFile = null ; for ( int i = 0 ; currentFile == null && i < paths . size ( ) ; i ++ ) { String testPath = ( String ) paths . get ( i ) ; File testFile = getFile ( testPath , fileName ) ; if ( testFile . canRead ( ) ) { currentFile = testFile ; } } File file = getFile ( path , fileName ) ; if ( currentFile == null || ! file . exists ( ) ) { } else if ( currentFile . equals ( file ) && file . canRead ( ) ) { modified = ( file . lastModified ( ) != resource . getLastModified ( ) ) ; } return modified ; } public long getLastModified ( Resource resource ) { String path = ( String ) templatePaths . get ( resource . getName ( ) ) ; File file = getFile ( path , resource . getName ( ) ) ; if ( file . canRead ( ) ) { return file . lastModified ( ) ; } else { return 0 ; } } private File getFile ( String path , String template ) { File file = null ; if ( "" . equals ( path ) ) { file = new File ( template ) ; } else { if ( template . startsWith ( "/" ) ) { template = template . substring ( 1 ) ; } file = new File ( path , template ) ; } return file ; } } 	1	['9', '2', '0', '9', '55', '2', '0', '9', '6', '0.583333333', '476', '1', '0', '0.6', '0.377777778', '2', '2', '51.55555556', '9', '3.1111', '1']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MathException ; import org . apache . velocity . runtime . parser . Parser ; public class ASTDivNode extends ASTMathNode { public ASTDivNode ( int id ) { super ( id ) ; } public ASTDivNode ( Parser p , int id ) { super ( p , id ) ; } public Number perform ( Number left , Number right , InternalContextAdapter context ) { if ( MathUtils . isZero ( right ) ) { String msg = "Right side of division operation is zero. Must be non-zero. " + getLocation ( context ) ; if ( strictMode ) { log . error ( msg ) ; throw new MathException ( msg ) ; } else { log . debug ( msg ) ; return null ; } } return MathUtils . divide ( left , right ) ; } } 	0	['3', '3', '0', '9', '14', '3', '4', '6', '3', '2', '48', '0', '0', '0.972222222', '0.533333333', '2', '2', '15', '3', '1', '0']
package org . apache . velocity . runtime . visitor ; import org . apache . velocity . runtime . parser . Token ; import org . apache . velocity . runtime . parser . node . ASTAddNode ; import org . apache . velocity . runtime . parser . node . ASTAndNode ; import org . apache . velocity . runtime . parser . node . ASTAssignment ; import org . apache . velocity . runtime . parser . node . ASTBlock ; import org . apache . velocity . runtime . parser . node . ASTDirective ; import org . apache . velocity . runtime . parser . node . ASTDivNode ; import org . apache . velocity . runtime . parser . node . ASTEQNode ; import org . apache . velocity . runtime . parser . node . ASTElseIfStatement ; import org . apache . velocity . runtime . parser . node . ASTElseStatement ; import org . apache . velocity . runtime . parser . node . ASTEscape ; import org . apache . velocity . runtime . parser . node . ASTEscapedDirective ; import org . apache . velocity . runtime . parser . node . ASTExpression ; import org . apache . velocity . runtime . parser . node . ASTFalse ; import org . apache . velocity . runtime . parser . node . ASTFloatingPointLiteral ; import org . apache . velocity . runtime . parser . node . ASTGENode ; import org . apache . velocity . runtime . parser . node . ASTGTNode ; import org . apache . velocity . runtime . parser . node . ASTIdentifier ; import org . apache . velocity . runtime . parser . node . ASTIfStatement ; import org . apache . velocity . runtime . parser . node . ASTIntegerLiteral ; import org . apache . velocity . runtime . parser . node . ASTIntegerRange ; import org . apache . velocity . runtime . parser . node . ASTLENode ; import org . apache . velocity . runtime . parser . node . ASTLTNode ; import org . apache . velocity . runtime . parser . node . ASTMap ; import org . apache . velocity . runtime . parser . node . ASTMethod ; import org . apache . velocity . runtime . parser . node . ASTModNode ; import org . apache . velocity . runtime . parser . node . ASTMulNode ; import org . apache . velocity . runtime . parser . node . ASTNENode ; import org . apache . velocity . runtime . parser . node . ASTNotNode ; import org . apache . velocity . runtime . parser . node . ASTObjectArray ; import org . apache . velocity . runtime . parser . node . ASTOrNode ; import org . apache . velocity . runtime . parser . node . ASTReference ; import org . apache . velocity . runtime . parser . node . ASTSetDirective ; import org . apache . velocity . runtime . parser . node . ASTStop ; import org . apache . velocity . runtime . parser . node . ASTStringLiteral ; import org . apache . velocity . runtime . parser . node . ASTSubtractNode ; import org . apache . velocity . runtime . parser . node . ASTText ; import org . apache . velocity . runtime . parser . node . ASTTrue ; import org . apache . velocity . runtime . parser . node . ASTWord ; import org . apache . velocity . runtime . parser . node . ASTprocess ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . runtime . parser . node . SimpleNode ; public class NodeViewMode extends BaseVisitor { private int indent = 0 ; private boolean showTokens = true ; private String indentString ( ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < indent ; ++ i ) { sb . append ( "  " ) ; } return sb . toString ( ) ; } private Object showNode ( Node node , Object data ) { String tokens = "" ; String special = "" ; Token t ; if ( showTokens ) { t = node . getFirstToken ( ) ; if ( t . specialToken != null && ! t . specialToken . image . startsWith ( "##" ) ) special = t . specialToken . image ; tokens = " -> " + special + t . image ; } System . out . println ( indentString ( ) + node + tokens ) ; ++ indent ; data = node . childrenAccept ( this , data ) ; -- indent ; return data ; } public Object visit ( SimpleNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTprocess node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTExpression node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTAssignment node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTOrNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTAndNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTEQNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTNENode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTLTNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTGTNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTLENode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTGENode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTAddNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTSubtractNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTMulNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTDivNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTModNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTNotNode node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTFloatingPointLiteral node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTIntegerLiteral node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTStringLiteral node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTIdentifier node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTMethod node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTReference node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTTrue node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTFalse node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTBlock node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTText node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTIfStatement node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTElseStatement node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTElseIfStatement node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTObjectArray node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTDirective node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTWord node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTSetDirective node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTEscapedDirective node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTEscape node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTMap node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTIntegerRange node , Object data ) { return showNode ( node , data ) ; } public Object visit ( ASTStop node , Object data ) { return showNode ( node , data ) ; } } 	1	['43', '2', '0', '44', '52', '897', '0', '44', '41', '0.011904762', '340', '1', '0', '0.505882353', '0.06760411', '0', '0', '6.860465116', '4', '1.0698', '1']
package org . apache . velocity . io ; import java . io . IOException ; import java . io . Writer ; public final class VelocityWriter extends Writer { public static final int NO_BUFFER = 0 ; public static final int DEFAULT_BUFFER = - 1 ; public static final int UNBOUNDED_BUFFER = - 2 ; private int bufferSize ; private boolean autoFlush ; private Writer writer ; private char cb [ ] ; private int nextChar ; private static int defaultCharBufferSize = 8 * 1024 ; public VelocityWriter ( Writer writer ) { this ( writer , defaultCharBufferSize , true ) ; } private VelocityWriter ( int bufferSize , boolean autoFlush ) { this . bufferSize = bufferSize ; this . autoFlush = autoFlush ; } public int getBufferSize ( ) { return bufferSize ; } public boolean isAutoFlush ( ) { return autoFlush ; } public VelocityWriter ( Writer writer , int sz , boolean autoFlush ) { this ( sz , autoFlush ) ; if ( sz < 0 ) throw new IllegalArgumentException ( "Buffer size <= 0" ) ; this . writer = writer ; cb = sz == 0 ? null : new char [ sz ] ; nextChar = 0 ; } private final void flushBuffer ( ) throws IOException { if ( bufferSize == 0 ) return ; if ( nextChar == 0 ) return ; writer . write ( cb , 0 , nextChar ) ; nextChar = 0 ; } public final void clear ( ) { nextChar = 0 ; } private final void bufferOverflow ( ) throws IOException { throw new IOException ( "overflow" ) ; } public final void flush ( ) throws IOException { flushBuffer ( ) ; if ( writer != null ) { writer . flush ( ) ; } } public final void close ( ) throws IOException { if ( writer == null ) return ; flush ( ) ; } public final int getRemaining ( ) { return bufferSize - nextChar ; } public final void write ( int c ) throws IOException { if ( bufferSize == 0 ) { writer . write ( c ) ; } else { if ( nextChar >= bufferSize ) if ( autoFlush ) flushBuffer ( ) ; else bufferOverflow ( ) ; cb [ nextChar ++ ] = ( char ) c ; } } private final int min ( int a , int b ) { return ( a < b ? a : b ) ; } public final void write ( char cbuf [ ] , int off , int len ) throws IOException { if ( bufferSize == 0 ) { writer . write ( cbuf , off , len ) ; return ; } if ( len == 0 ) { return ; } if ( len >= bufferSize ) { if ( autoFlush ) flushBuffer ( ) ; else bufferOverflow ( ) ; writer . write ( cbuf , off , len ) ; return ; } int b = off , t = off + len ; while ( b < t ) { int d = min ( bufferSize - nextChar , t - b ) ; System . arraycopy ( cbuf , b , cb , nextChar , d ) ; b += d ; nextChar += d ; if ( nextChar >= bufferSize ) if ( autoFlush ) flushBuffer ( ) ; else bufferOverflow ( ) ; } } public final void write ( char buf [ ] ) throws IOException { write ( buf , 0 , buf . length ) ; } public final void write ( String s , int off , int len ) throws IOException { if ( bufferSize == 0 ) { writer . write ( s , off , len ) ; return ; } int b = off , t = off + len ; while ( b < t ) { int d = min ( bufferSize - nextChar , t - b ) ; s . getChars ( b , b + d , cb , nextChar ) ; b += d ; nextChar += d ; if ( nextChar >= bufferSize ) if ( autoFlush ) flushBuffer ( ) ; else bufferOverflow ( ) ; } } public final void write ( String s ) throws IOException { if ( s != null ) { write ( s , 0 , s . length ( ) ) ; } } public final void recycle ( Writer writer ) { this . writer = writer ; clear ( ) ; } } 	0	['19', '2', '0', '1', '29', '61', '1', '0', '14', '0.709876543', '342', '0.666666667', '0', '0.464285714', '0.305555556', '1', '2', '16.52631579', '2', '0.8421', '0']
package org . apache . velocity . context ; import java . io . StringWriter ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . apache . velocity . app . event . EventCartridge ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . parser . ParserTreeConstants ; import org . apache . velocity . runtime . parser . node . ASTReference ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . runtime . resource . Resource ; import org . apache . velocity . util . introspection . IntrospectionCacheData ; public class ProxyVMContext extends ChainedInternalContextAdapter { Map vmproxyhash = new HashMap ( 8 , 0.8f ) ; Map localcontext = new HashMap ( 8 , 0.8f ) ; ; InternalContextAdapter wrappedContext ; private boolean localContextScope ; private RuntimeServices rsvc ; public ProxyVMContext ( InternalContextAdapter inner , RuntimeServices rsvc , boolean localContextScope ) { super ( inner ) ; this . localContextScope = localContextScope ; this . rsvc = rsvc ; wrappedContext = inner ; } public void addVMProxyArg ( InternalContextAdapter context , String macroArgumentName , String literalMacroArgumentName , Node argumentValue ) throws MethodInvocationException { if ( isConstant ( argumentValue ) ) { localcontext . put ( macroArgumentName , argumentValue . value ( context ) ) ; } else { vmproxyhash . put ( macroArgumentName , argumentValue ) ; localcontext . put ( literalMacroArgumentName , argumentValue ) ; } } private boolean isConstant ( Node node ) { switch ( node . getType ( ) ) { case ParserTreeConstants . JJTINTEGERRANGE : case ParserTreeConstants . JJTREFERENCE : case ParserTreeConstants . JJTOBJECTARRAY : case ParserTreeConstants . JJTMAP : case ParserTreeConstants . JJTSTRINGLITERAL : case ParserTreeConstants . JJTTEXT : return ( false ) ; default : return ( true ) ; } } public Object put ( final String key , final Object value ) { return put ( key , value , localContextScope ) ; } public Object localPut ( final String key , final Object value ) { return put ( key , value , true ) ; } protected Object put ( final String key , final Object value , final boolean forceLocal ) { Node astNode = ( Node ) vmproxyhash . get ( key ) ; if ( astNode != null ) { if ( astNode . getType ( ) == ParserTreeConstants . JJTREFERENCE ) { ASTReference ref = ( ASTReference ) astNode ; if ( ref . jjtGetNumChildren ( ) > 0 ) ref . setValue ( wrappedContext , value ) ; else wrappedContext . put ( ref . getRootString ( ) , value ) ; } else { rsvc . getLog ( ) . error ( "ProxyVMContext.put() : New value cannot be assigned to a constant: " + key + " / " + get ( "$" + key + ".literal" ) ) ; } return null ; } else { if ( forceLocal ) { return localcontext . put ( key , value ) ; } else { if ( localcontext . containsKey ( key ) ) { return localcontext . put ( key , value ) ; } else { return super . put ( key , value ) ; } } } } public Object get ( String key ) { Object o = null ; Node astNode = ( Node ) vmproxyhash . get ( key ) ; if ( astNode != null ) { int type = astNode . getType ( ) ; if ( type == ParserTreeConstants . JJTREFERENCE ) { ASTReference ref = ( ASTReference ) astNode ; if ( ref . jjtGetNumChildren ( ) > 0 ) { return ref . execute ( null , wrappedContext ) ; } else { Object obj = wrappedContext . get ( ref . getRootString ( ) ) ; if ( obj == null && ref . strictRef ) { if ( ! wrappedContext . containsKey ( ref . getRootString ( ) ) ) { throw new MethodInvocationException ( "Parameter '" + ref . getRootString ( ) + "' not defined" , null , key , ref . getTemplateName ( ) , ref . getLine ( ) , ref . getColumn ( ) ) ; } } return obj ; } } else if ( type == ParserTreeConstants . JJTTEXT ) { try { StringWriter writer = new StringWriter ( ) ; astNode . render ( wrappedContext , writer ) ; return writer . toString ( ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { String msg = "ProxyVMContext.get() : error rendering reference" ; rsvc . getLog ( ) . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } } else { return astNode . value ( wrappedContext ) ; } } else { o = localcontext . get ( key ) ; if ( o == null ) { o = super . get ( key ) ; } } return o ; } public boolean containsKey ( Object key ) { return vmproxyhash . containsKey ( key ) || localcontext . containsKey ( key ) || super . containsKey ( key ) ; } public Object [ ] getKeys ( ) { return vmproxyhash . keySet ( ) . toArray ( ) ; } public Object remove ( Object key ) { if ( vmproxyhash . containsKey ( key ) ) { return vmproxyhash . remove ( key ) ; } else { if ( localContextScope ) { return localcontext . remove ( key ) ; } Object oldValue = localcontext . remove ( key ) ; if ( oldValue == null ) { oldValue = super . remove ( key ) ; } return oldValue ; } } } 	1	['10', '2', '0', '9', '46', '0', '1', '8', '8', '0.555555556', '296', '0.5', '1', '0.75', '0.385714286', '0', '0', '28.2', '9', '2.6', '3']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . runtime . parser . Parser ; public class ASTprocess extends SimpleNode { public ASTprocess ( int id ) { super ( id ) ; } public ASTprocess ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } } 	0	['3', '2', '0', '5', '6', '3', '4', '3', '3', '2', '17', '0', '0', '0.967741935', '0.533333333', '0', '0', '4.666666667', '1', '0.3333', '0']
package org . apache . velocity . runtime . log ; import java . io . StringWriter ; import java . io . PrintWriter ; import javax . servlet . ServletContext ; import org . apache . velocity . runtime . RuntimeServices ; public class ServletLogChute implements LogChute { public static final String RUNTIME_LOG_LEVEL_KEY = "runtime.log.logsystem.servlet.level" ; private int enabled = TRACE_ID ; protected ServletContext servletContext = null ; public static final String PREFIX = " Velocity " ; public ServletLogChute ( ) { } public void init ( RuntimeServices rs ) throws Exception { Object obj = rs . getApplicationAttribute ( ServletContext . class . getName ( ) ) ; if ( obj == null ) { throw new UnsupportedOperationException ( "Could not retrieve ServletContext from application attributes" ) ; } servletContext = ( ServletContext ) obj ; String level = ( String ) rs . getProperty ( RUNTIME_LOG_LEVEL_KEY ) ; if ( level != null ) { setEnabledLevel ( toLevel ( level ) ) ; } } protected int toLevel ( String level ) { if ( level . equalsIgnoreCase ( "debug" ) ) { return DEBUG_ID ; } else if ( level . equalsIgnoreCase ( "info" ) ) { return INFO_ID ; } else if ( level . equalsIgnoreCase ( "warn" ) ) { return WARN_ID ; } else if ( level . equalsIgnoreCase ( "error" ) ) { return ERROR_ID ; } else { return TRACE_ID ; } } public void setEnabledLevel ( int level ) { this . enabled = level ; } public int getEnabledLevel ( ) { return this . enabled ; } public boolean isLevelEnabled ( int level ) { return ( level >= this . enabled ) ; } public void log ( int level , String message ) { if ( ! isLevelEnabled ( level ) ) { return ; } switch ( level ) { case WARN_ID : servletContext . log ( PREFIX + WARN_PREFIX + message ) ; break ; case INFO_ID : servletContext . log ( PREFIX + INFO_PREFIX + message ) ; break ; case DEBUG_ID : servletContext . log ( PREFIX + DEBUG_PREFIX + message ) ; break ; case TRACE_ID : servletContext . log ( PREFIX + TRACE_PREFIX + message ) ; break ; case ERROR_ID : servletContext . log ( PREFIX + ERROR_PREFIX + message ) ; break ; default : servletContext . log ( PREFIX + " : " + message ) ; break ; } } public void log ( int level , String message , Throwable t ) { if ( ! isLevelEnabled ( level ) ) { return ; } message += " - " + t . toString ( ) ; if ( level >= ERROR_ID ) { StringWriter sw = new StringWriter ( ) ; t . printStackTrace ( new PrintWriter ( sw ) ) ; message += "\n" + sw . toString ( ) ; } log ( level , message ) ; } } 	1	['9', '1', '0', '2', '27', '18', '0', '2', '7', '0.825', '236', '0.4', '0', '0', '0.4', '0', '0', '24.66666667', '5', '1.8889', '2']
package org . apache . velocity . runtime . resource ; import java . util . Iterator ; import org . apache . velocity . runtime . RuntimeServices ; public interface ResourceCache { public void initialize ( RuntimeServices rs ) ; public Resource get ( Object resourceKey ) ; public Resource put ( Object resourceKey , Resource resource ) ; public Resource remove ( Object resourceKey ) ; public Iterator enumerateKeys ( ) ; } 	0	['5', '1', '0', '4', '5', '10', '2', '2', '5', '2', '5', '0', '0', '0', '0.5', '0', '0', '0', '1', '1', '0']
package org . apache . velocity . app ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import java . io . UnsupportedEncodingException ; import java . io . Writer ; import java . util . Properties ; import org . apache . commons . collections . ExtendedProperties ; import org . apache . velocity . Template ; import org . apache . velocity . context . Context ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeInstance ; import org . apache . velocity . runtime . log . Log ; public class VelocityEngine implements RuntimeConstants { private RuntimeInstance ri = new RuntimeInstance ( ) ; public VelocityEngine ( ) { } public VelocityEngine ( String propsFilename ) throws Exception { ri . init ( propsFilename ) ; } public VelocityEngine ( Properties p ) throws Exception { ri . init ( p ) ; } public void init ( ) throws Exception { ri . init ( ) ; } public void init ( String propsFilename ) throws Exception { ri . init ( propsFilename ) ; } public void init ( Properties p ) throws Exception { ri . init ( p ) ; } public void setProperty ( String key , Object value ) { ri . setProperty ( key , value ) ; } public void addProperty ( String key , Object value ) { ri . addProperty ( key , value ) ; } public void clearProperty ( String key ) { ri . clearProperty ( key ) ; } public void setExtendedProperties ( ExtendedProperties configuration ) { ri . setConfiguration ( configuration ) ; } public Object getProperty ( String key ) { return ri . getProperty ( key ) ; } public boolean evaluate ( Context context , Writer out , String logTag , String instring ) throws ParseErrorException , MethodInvocationException , ResourceNotFoundException , IOException { return ri . evaluate ( context , out , logTag , instring ) ; } public boolean evaluate ( Context context , Writer writer , String logTag , InputStream instream ) throws ParseErrorException , MethodInvocationException , ResourceNotFoundException , IOException { BufferedReader br = null ; String encoding = null ; try { encoding = ri . getString ( INPUT_ENCODING , ENCODING_DEFAULT ) ; br = new BufferedReader ( new InputStreamReader ( instream , encoding ) ) ; } catch ( UnsupportedEncodingException uce ) { String msg = "Unsupported input encoding : " + encoding + " for template " + logTag ; throw new ParseErrorException ( msg ) ; } return evaluate ( context , writer , logTag , br ) ; } public boolean evaluate ( Context context , Writer writer , String logTag , Reader reader ) throws ParseErrorException , MethodInvocationException , ResourceNotFoundException , IOException { return ri . evaluate ( context , writer , logTag , reader ) ; } public boolean invokeVelocimacro ( String vmName , String logTag , String params [ ] , Context context , Writer writer ) throws Exception { return ri . invokeVelocimacro ( vmName , logTag , params , context , writer ) ; } public boolean mergeTemplate ( String templateName , Context context , Writer writer ) throws ResourceNotFoundException , ParseErrorException , MethodInvocationException , Exception { return mergeTemplate ( templateName , ri . getString ( INPUT_ENCODING , ENCODING_DEFAULT ) , context , writer ) ; } public boolean mergeTemplate ( String templateName , String encoding , Context context , Writer writer ) throws ResourceNotFoundException , ParseErrorException , MethodInvocationException , Exception { Template template = ri . getTemplate ( templateName , encoding ) ; if ( template == null ) { String msg = "VelocityEngine.mergeTemplate() was unable to load template '" + templateName + "'" ; getLog ( ) . error ( msg ) ; throw new ResourceNotFoundException ( msg ) ; } else { template . merge ( context , writer ) ; return true ; } } public Template getTemplate ( String name ) throws ResourceNotFoundException , ParseErrorException , Exception { return ri . getTemplate ( name ) ; } public Template getTemplate ( String name , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception { return ri . getTemplate ( name , encoding ) ; } public boolean resourceExists ( String resourceName ) { return ( ri . getLoaderNameForResource ( resourceName ) != null ) ; } public boolean templateExists ( String resourceName ) { return resourceExists ( resourceName ) ; } public Log getLog ( ) { return ri . getLog ( ) ; } public void warn ( Object message ) { getLog ( ) . warn ( message ) ; } public void info ( Object message ) { getLog ( ) . info ( message ) ; } public void error ( Object message ) { getLog ( ) . error ( message ) ; } public void debug ( Object message ) { getLog ( ) . debug ( message ) ; } public void setApplicationAttribute ( Object key , Object value ) { ri . setApplicationAttribute ( key , value ) ; } public Object getApplicationAttribute ( Object key ) { return ri . getApplicationAttribute ( key ) ; } } 	1	['28', '1', '0', '12', '60', '0', '3', '9', '28', '0', '278', '1', '1', '0', '0.25', '0', '0', '8.892857143', '2', '0.9286', '2']
package org . apache . velocity . util ; import org . apache . velocity . runtime . RuntimeServices ; public interface RuntimeServicesAware { public void setRuntimeServices ( RuntimeServices rs ) ; } 	0	['1', '1', '0', '8', '1', '0', '7', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . velocity . runtime . log ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . log . LogChute ; public class CommonsLogLogChute implements LogChute { public static final String LOGCHUTE_COMMONS_LOG_NAME = "runtime.log.logsystem.commons.logging.name" ; public static final String DEFAULT_LOG_NAME = "org.apache.velocity" ; protected Log log ; public void init ( RuntimeServices rs ) throws Exception { String name = ( String ) rs . getProperty ( LOGCHUTE_COMMONS_LOG_NAME ) ; if ( name == null ) { name = DEFAULT_LOG_NAME ; } log = LogFactory . getLog ( name ) ; log ( LogChute . DEBUG_ID , "CommonsLogLogChute name is '" + name + "'" ) ; } public void log ( int level , String message ) { switch ( level ) { case LogChute . WARN_ID : log . warn ( message ) ; break ; case LogChute . INFO_ID : log . info ( message ) ; break ; case LogChute . TRACE_ID : log . trace ( message ) ; break ; case LogChute . ERROR_ID : log . error ( message ) ; break ; case LogChute . DEBUG_ID : default : log . debug ( message ) ; break ; } } public void log ( int level , String message , Throwable t ) { switch ( level ) { case LogChute . WARN_ID : log . warn ( message , t ) ; break ; case LogChute . INFO_ID : log . info ( message , t ) ; break ; case LogChute . TRACE_ID : log . trace ( message , t ) ; break ; case LogChute . ERROR_ID : log . error ( message , t ) ; break ; case LogChute . DEBUG_ID : default : log . debug ( message , t ) ; break ; } } public boolean isLevelEnabled ( int level ) { switch ( level ) { case LogChute . DEBUG_ID : return log . isDebugEnabled ( ) ; case LogChute . INFO_ID : return log . isInfoEnabled ( ) ; case LogChute . TRACE_ID : return log . isTraceEnabled ( ) ; case LogChute . WARN_ID : return log . isWarnEnabled ( ) ; case LogChute . ERROR_ID : return log . isErrorEnabled ( ) ; default : return true ; } } } 	1	['5', '1', '0', '4', '26', '0', '0', '4', '5', '0.916666667', '121', '0.333333333', '0', '0', '0.48', '0', '0', '22.6', '2', '1.4', '2']
package org . apache . velocity . runtime . parser . node ; import java . util . ArrayList ; import java . util . List ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . parser . Parser ; public class ASTIntegerRange extends SimpleNode { public ASTIntegerRange ( int id ) { super ( id ) ; } public ASTIntegerRange ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { Object left = jjtGetChild ( 0 ) . value ( context ) ; Object right = jjtGetChild ( 1 ) . value ( context ) ; if ( left == null || right == null ) { log . error ( ( left == null ? "Left" : "Right" ) + " side of range operator [n..m] has null value." + " Operation not possible. " + Log . formatFileString ( this ) ) ; return null ; } if ( ! ( left instanceof Number ) || ! ( right instanceof Number ) ) { log . error ( ( ! ( left instanceof Number ) ? "Left" : "Right" ) + " side of range operator is not a valid type. " + "Currently only integers (1,2,3...) and the Number type are supported. " + Log . formatFileString ( this ) ) ; return null ; } int l = ( ( Number ) left ) . intValue ( ) ; int r = ( ( Number ) right ) . intValue ( ) ; int nbrElements = Math . abs ( l - r ) ; nbrElements += 1 ; int delta = ( l >= r ) ? - 1 : 1 ; List elements = new ArrayList ( nbrElements ) ; int value = l ; for ( int i = 0 ; i < nbrElements ; i ++ ) { elements . add ( new Integer ( value ) ) ; value += delta ; } return elements ; } } 	0	['4', '2', '0', '9', '19', '6', '4', '7', '4', '2', '133', '0', '0', '0.9375', '0.416666667', '1', '1', '32.25', '1', '0.5', '0']
package org . apache . velocity . util . introspection ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . HashMap ; import java . util . Map ; import org . apache . commons . lang . text . StrBuilder ; import org . apache . velocity . runtime . log . Log ; public class ClassMap { private static final boolean debugReflection = false ; private final Log log ; private final Class clazz ; private final MethodCache methodCache ; public ClassMap ( final Class clazz , final Log log ) { this . clazz = clazz ; this . log = log ; if ( debugReflection && log . isDebugEnabled ( ) ) { log . debug ( "=================================================================" ) ; log . debug ( "== Class: " + clazz ) ; } methodCache = createMethodCache ( ) ; if ( debugReflection && log . isDebugEnabled ( ) ) { log . debug ( "=================================================================" ) ; } } public Class getCachedClass ( ) { return clazz ; } public Method findMethod ( final String name , final Object [ ] params ) throws MethodMap . AmbiguousException { return methodCache . get ( name , params ) ; } private MethodCache createMethodCache ( ) { MethodCache methodCache = new MethodCache ( log ) ; for ( Class classToReflect = getCachedClass ( ) ; classToReflect != null ; classToReflect = classToReflect . getSuperclass ( ) ) { if ( Modifier . isPublic ( classToReflect . getModifiers ( ) ) ) { populateMethodCacheWith ( methodCache , classToReflect ) ; } Class [ ] interfaces = classToReflect . getInterfaces ( ) ; for ( int i = 0 ; i < interfaces . length ; i ++ ) { if ( Modifier . isPublic ( interfaces [ i ] . getModifiers ( ) ) ) { populateMethodCacheWith ( methodCache , interfaces [ i ] ) ; } } } return methodCache ; } private void populateMethodCacheWith ( MethodCache methodCache , Class classToReflect ) { if ( debugReflection && log . isDebugEnabled ( ) ) { log . debug ( "Reflecting " + classToReflect ) ; } try { Method [ ] methods = classToReflect . getDeclaredMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { int modifiers = methods [ i ] . getModifiers ( ) ; if ( Modifier . isPublic ( modifiers ) ) { if ( classToReflect . isInterface ( ) || ! Modifier . isAbstract ( modifiers ) ) { methodCache . put ( methods [ i ] ) ; } } } } catch ( SecurityException se ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "While accessing methods of " + classToReflect + ": " , se ) ; } } } private static final class MethodCache { private static final Object CACHE_MISS = new Object ( ) ; private static final String NULL_ARG = Object . class . getName ( ) ; private static final Map convertPrimitives = new HashMap ( ) ; static { convertPrimitives . put ( Boolean . TYPE , Boolean . class . getName ( ) ) ; convertPrimitives . put ( Byte . TYPE , Byte . class . getName ( ) ) ; convertPrimitives . put ( Character . TYPE , Character . class . getName ( ) ) ; convertPrimitives . put ( Double . TYPE , Double . class . getName ( ) ) ; convertPrimitives . put ( Float . TYPE , Float . class . getName ( ) ) ; convertPrimitives . put ( Integer . TYPE , Integer . class . getName ( ) ) ; convertPrimitives . put ( Long . TYPE , Long . class . getName ( ) ) ; convertPrimitives . put ( Short . TYPE , Short . class . getName ( ) ) ; } private final Log log ; private final Map cache = new HashMap ( ) ; private final MethodMap methodMap = new MethodMap ( ) ; private MethodCache ( Log log ) { this . log = log ; } public Method get ( final String name , final Object [ ] params ) throws MethodMap . AmbiguousException { String methodKey = makeMethodKey ( name , params ) ; Object cacheEntry = cache . get ( methodKey ) ; if ( cacheEntry == CACHE_MISS ) { return null ; } if ( cacheEntry == null ) { try { cacheEntry = methodMap . find ( name , params ) ; } catch ( MethodMap . AmbiguousException ae ) { cache . put ( methodKey , CACHE_MISS ) ; throw ae ; } cache . put ( methodKey , ( cacheEntry != null ) ? cacheEntry : CACHE_MISS ) ; } return ( Method ) cacheEntry ; } private void put ( Method method ) { String methodKey = makeMethodKey ( method ) ; if ( cache . get ( methodKey ) == null ) { cache . put ( methodKey , method ) ; methodMap . add ( method ) ; if ( debugReflection && log . isDebugEnabled ( ) ) { log . debug ( "Adding " + method ) ; } } } private String makeMethodKey ( final Method method ) { Class [ ] parameterTypes = method . getParameterTypes ( ) ; int args = parameterTypes . length ; if ( args == 0 ) { return method . getName ( ) ; } StrBuilder methodKey = new StrBuilder ( ( args + 1 ) * 16 ) . append ( method . getName ( ) ) ; for ( int j = 0 ; j < args ; j ++ ) { if ( parameterTypes [ j ] . isPrimitive ( ) ) { methodKey . append ( ( String ) convertPrimitives . get ( parameterTypes [ j ] ) ) ; } else { methodKey . append ( parameterTypes [ j ] . getName ( ) ) ; } } return methodKey . toString ( ) ; } private String makeMethodKey ( String method , Object [ ] params ) { int args = params . length ; if ( args == 0 ) { return method ; } StrBuilder methodKey = new StrBuilder ( ( args + 1 ) * 16 ) . append ( method ) ; for ( int j = 0 ; j < args ; j ++ ) { Object arg = params [ j ] ; if ( arg == null ) { methodKey . append ( NULL_ARG ) ; } else { methodKey . append ( arg . getClass ( ) . getName ( ) ) ; } } return methodKey . toString ( ) ; } } } 	1	['6', '1', '0', '7', '27', '5', '4', '4', '3', '1.076923077', '151', '0.307692308', '2', '0', '0.333333333', '0', '0', '22', '5', '2.1667', '3']
package org . apache . velocity . runtime . parser ; public class ParseException extends Exception { private static final long serialVersionUID = - 309603325673449381L ; public ParseException ( Token currentTokenVal , int [ ] [ ] expectedTokenSequencesVal , String [ ] tokenImageVal ) { super ( "" ) ; specialConstructor = true ; currentToken = currentTokenVal ; expectedTokenSequences = expectedTokenSequencesVal ; tokenImage = tokenImageVal ; } public ParseException ( ) { super ( ) ; specialConstructor = false ; } public ParseException ( String message ) { super ( message ) ; specialConstructor = false ; } protected boolean specialConstructor ; public Token currentToken ; public int [ ] [ ] expectedTokenSequences ; public String [ ] tokenImage ; public String getMessage ( ) { if ( ! specialConstructor ) { return super . getMessage ( ) ; } String expected = "" ; int maxSize = 0 ; for ( int i = 0 ; i < expectedTokenSequences . length ; i ++ ) { if ( maxSize < expectedTokenSequences [ i ] . length ) { maxSize = expectedTokenSequences [ i ] . length ; } for ( int j = 0 ; j < expectedTokenSequences [ i ] . length ; j ++ ) { expected += tokenImage [ expectedTokenSequences [ i ] [ j ] ] + " " ; } if ( expectedTokenSequences [ i ] [ expectedTokenSequences [ i ] . length - 1 ] != 0 ) { expected += "..." ; } expected += eol + "    " ; } String retval = "Encountered \"" ; Token tok = currentToken . next ; for ( int i = 0 ; i < maxSize ; i ++ ) { if ( i != 0 ) retval += " " ; if ( tok . kind == 0 ) { retval += tokenImage [ 0 ] ; break ; } retval += add_escapes ( tok . image ) ; tok = tok . next ; } retval += "\" at line " + currentToken . next . beginLine + ", column " + currentToken . next . beginColumn ; retval += "." + eol ; if ( expectedTokenSequences . length == 1 ) { retval += "Was expecting:" + eol + "    " ; } else { retval += "Was expecting one of:" + eol + "    " ; } retval += expected ; return retval ; } protected String eol = System . getProperty ( "line.separator" , "\n" ) ; protected String add_escapes ( String str ) { StringBuffer retval = new StringBuffer ( ) ; char ch ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { switch ( str . charAt ( i ) ) { case 0 : continue ; case '\b' : retval . append ( "\\b" ) ; continue ; case '\t' : retval . append ( "\\t" ) ; continue ; case '\n' : retval . append ( "\\n" ) ; continue ; case '\f' : retval . append ( "\\f" ) ; continue ; case '\r' : retval . append ( "\\r" ) ; continue ; case '\"' : retval . append ( "\\\"" ) ; continue ; case '\'' : retval . append ( "\\\'" ) ; continue ; case '\\' : retval . append ( "\\\\" ) ; continue ; default : if ( ( ch = str . charAt ( i ) ) < 0x20 || ch > 0x7e ) { String s = "0000" + Integer . toString ( ch , 16 ) ; retval . append ( "\\u" + s . substring ( s . length ( ) - 4 , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . toString ( ) ; } } 	0	['5', '3', '2', '16', '18', '0', '15', '1', '4', '0.666666667', '388', '0.5', '1', '0.866666667', '0.4', '1', '1', '75.4', '14', '4.8', '0']
package org . apache . velocity . runtime . parser . node ; import java . io . IOException ; import java . io . Writer ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . runtime . parser . Parser ; public class ASTStop extends SimpleNode { public ASTStop ( int id ) { super ( id ) ; } public ASTStop ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException , ParseErrorException , ResourceNotFoundException { context . setAllowRendering ( false ) ; return true ; } } 	1	['4', '2', '0', '9', '8', '6', '4', '7', '4', '2', '23', '0', '0', '0.9375', '0.392857143', '0', '0', '4.75', '1', '0.5', '2']
package org . apache . velocity . runtime . parser . node ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import org . apache . velocity . runtime . log . Log ; public abstract class AbstractExecutor { protected Log log = null ; private Method method = null ; public abstract Object execute ( Object o ) throws IllegalAccessException , InvocationTargetException ; public boolean isAlive ( ) { return ( method != null ) ; } public Method getMethod ( ) { return method ; } protected void setMethod ( final Method method ) { this . method = method ; } } 	0	['5', '1', '3', '6', '6', '0', '5', '1', '4', '0.625', '30', '1', '1', '0', '0.466666667', '0', '0', '4.6', '2', '1', '0']
package org . apache . velocity . runtime . directive ; import java . io . IOException ; import java . io . Writer ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . parser . ParseException ; import org . apache . velocity . runtime . parser . ParserTreeConstants ; import org . apache . velocity . runtime . parser . Token ; import org . apache . velocity . runtime . parser . node . Node ; public class Macro extends Directive { private static boolean debugMode = false ; public String getName ( ) { return "macro" ; } public int getType ( ) { return BLOCK ; } public boolean render ( InternalContextAdapter context , Writer writer , Node node ) throws IOException { return true ; } public void init ( RuntimeServices rs , InternalContextAdapter context , Node node ) throws TemplateInitException { super . init ( rs , context , node ) ; } public static void processAndRegister ( RuntimeServices rs , Token t , Node node , String sourceTemplate ) throws IOException , ParseException { int numArgs = node . jjtGetNumChildren ( ) ; if ( numArgs < 2 ) { rs . getLog ( ) . error ( "#macro error : Velocimacro must have name as 1st " + "argument to #macro(). #args = " + numArgs ) ; throw new MacroParseException ( "First argument to #macro() must be " + " macro name." , sourceTemplate , t ) ; } int firstType = node . jjtGetChild ( 0 ) . getType ( ) ; if ( firstType != ParserTreeConstants . JJTWORD ) { throw new MacroParseException ( "First argument to #macro() must be a" + " token without surrounding \' or \", which specifies" + " the macro name.  Currently it is a " + ParserTreeConstants . jjtNodeName [ firstType ] , sourceTemplate , t ) ; } String argArray [ ] = getArgArray ( node , rs ) ; rs . addVelocimacro ( argArray [ 0 ] , node . jjtGetChild ( numArgs - 1 ) , argArray , sourceTemplate ) ; } private static String [ ] getArgArray ( Node node , RuntimeServices rsvc ) { int numArgs = node . jjtGetNumChildren ( ) ; numArgs -- ; String argArray [ ] = new String [ numArgs ] ; int i = 0 ; while ( i < numArgs ) { argArray [ i ] = node . jjtGetChild ( i ) . getFirstToken ( ) . image ; if ( i > 0 ) { if ( argArray [ i ] . startsWith ( "$" ) ) { argArray [ i ] = argArray [ i ] . substring ( 1 , argArray [ i ] . length ( ) ) ; } } i ++ ; } if ( debugMode ) { StringBuffer msg = new StringBuffer ( "Macro.getArgArray() : nbrArgs=" ) ; msg . append ( numArgs ) . append ( " : " ) ; macroToString ( msg , argArray ) ; rsvc . getLog ( ) . debug ( msg ) ; } return argArray ; } public static final StringBuffer macroToString ( final StringBuffer buf , final String [ ] argArray ) { StringBuffer ret = ( buf == null ) ? new StringBuffer ( ) : buf ; ret . append ( '#' ) . append ( argArray [ 0 ] ) . append ( "( " ) ; for ( int i = 1 ; i < argArray . length ; i ++ ) { ret . append ( ' ' ) . append ( argArray [ i ] ) ; } ret . append ( " )" ) ; return ret ; } } 	1	['9', '2', '0', '12', '29', '34', '2', '10', '7', '0.75', '199', '1', '0', '0.5625', '0.263888889', '0', '0', '21', '5', '1.4444', '2']
package org . apache . velocity . runtime . parser . node ; import java . lang . reflect . InvocationTargetException ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . util . introspection . Introspector ; public class PutExecutor extends SetExecutor { private final Introspector introspector ; private final String property ; public PutExecutor ( final Log log , final Introspector introspector , final Class clazz , final Object arg , final String property ) { this . log = log ; this . introspector = introspector ; this . property = property ; discover ( clazz , arg ) ; } protected void discover ( final Class clazz , final Object arg ) { Object [ ] params ; if ( property == null ) { params = new Object [ ] { arg } ; } else { params = new Object [ ] { property , arg } ; } try { setMethod ( introspector . getMethod ( clazz , "put" , params ) ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { String msg = "Exception while looking for put('" + params [ 0 ] + "') method" ; log . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } } public Object execute ( final Object o , final Object value ) throws IllegalAccessException , InvocationTargetException { Object [ ] params ; if ( isAlive ( ) ) { if ( property == null ) { params = new Object [ ] { value } ; } else { params = new Object [ ] { property , value } ; } return getMethod ( ) . invoke ( o , params ) ; } return null ; } } 	0	['3', '2', '0', '5', '15', '0', '1', '4', '2', '0.25', '116', '1', '1', '0.666666667', '0.611111111', '0', '0', '37', '2', '1', '0']
package org . apache . velocity . runtime . parser . node ; public interface ParserVisitor { public Object visit ( SimpleNode node , Object data ) ; public Object visit ( ASTprocess node , Object data ) ; public Object visit ( ASTEscapedDirective node , Object data ) ; public Object visit ( ASTEscape node , Object data ) ; public Object visit ( ASTComment node , Object data ) ; public Object visit ( ASTFloatingPointLiteral node , Object data ) ; public Object visit ( ASTIntegerLiteral node , Object data ) ; public Object visit ( ASTStringLiteral node , Object data ) ; public Object visit ( ASTIdentifier node , Object data ) ; public Object visit ( ASTWord node , Object data ) ; public Object visit ( ASTDirective node , Object data ) ; public Object visit ( ASTBlock node , Object data ) ; public Object visit ( ASTMap node , Object data ) ; public Object visit ( ASTObjectArray node , Object data ) ; public Object visit ( ASTIntegerRange node , Object data ) ; public Object visit ( ASTMethod node , Object data ) ; public Object visit ( ASTReference node , Object data ) ; public Object visit ( ASTTrue node , Object data ) ; public Object visit ( ASTFalse node , Object data ) ; public Object visit ( ASTText node , Object data ) ; public Object visit ( ASTIfStatement node , Object data ) ; public Object visit ( ASTElseStatement node , Object data ) ; public Object visit ( ASTElseIfStatement node , Object data ) ; public Object visit ( ASTSetDirective node , Object data ) ; public Object visit ( ASTStop node , Object data ) ; public Object visit ( ASTExpression node , Object data ) ; public Object visit ( ASTAssignment node , Object data ) ; public Object visit ( ASTOrNode node , Object data ) ; public Object visit ( ASTAndNode node , Object data ) ; public Object visit ( ASTEQNode node , Object data ) ; public Object visit ( ASTNENode node , Object data ) ; public Object visit ( ASTLTNode node , Object data ) ; public Object visit ( ASTGTNode node , Object data ) ; public Object visit ( ASTLENode node , Object data ) ; public Object visit ( ASTGENode node , Object data ) ; public Object visit ( ASTAddNode node , Object data ) ; public Object visit ( ASTSubtractNode node , Object data ) ; public Object visit ( ASTMulNode node , Object data ) ; public Object visit ( ASTDivNode node , Object data ) ; public Object visit ( ASTModNode node , Object data ) ; public Object visit ( ASTNotNode node , Object data ) ; } 	1	['41', '1', '0', '48', '41', '820', '43', '41', '41', '2', '41', '0', '0', '0', '0.069767442', '0', '0', '0', '1', '1', '1']
package org . apache . velocity . runtime . log ; import org . apache . velocity . runtime . RuntimeLogger ; public class RuntimeLoggerLog extends Log { private RuntimeLogger rlog ; public RuntimeLoggerLog ( RuntimeLogger rlog ) { if ( rlog == null ) { throw new NullPointerException ( "RuntimeLogger cannot be null!" ) ; } this . rlog = rlog ; } protected void setLogChute ( LogChute newLogChute ) { throw new UnsupportedOperationException ( "RuntimeLoggerLog does not support this method." ) ; } protected LogChute getLogChute ( ) { throw new UnsupportedOperationException ( "RuntimeLoggerLog does not support this method." ) ; } protected void setShowStackTraces ( boolean showStacks ) { throw new UnsupportedOperationException ( "RuntimeLoggerLog does not support this method." ) ; } public boolean getShowStackTraces ( ) { throw new UnsupportedOperationException ( "RuntimeLoggerLog does not support this method." ) ; } public boolean isTraceEnabled ( ) { return true ; } public void trace ( Object message ) { debug ( message ) ; } public void trace ( Object message , Throwable t ) { debug ( message , t ) ; } public boolean isDebugEnabled ( ) { return true ; } public void debug ( Object message ) { rlog . debug ( message ) ; } public void debug ( Object message , Throwable t ) { rlog . debug ( message ) ; rlog . debug ( t ) ; } public boolean isInfoEnabled ( ) { return true ; } public void info ( Object message ) { rlog . info ( message ) ; } public void info ( Object message , Throwable t ) { rlog . info ( message ) ; rlog . info ( t ) ; } public boolean isWarnEnabled ( ) { return true ; } public void warn ( Object message ) { rlog . warn ( message ) ; } public void warn ( Object message , Throwable t ) { rlog . warn ( message ) ; rlog . warn ( t ) ; } public boolean isErrorEnabled ( ) { return true ; } public void error ( Object message ) { rlog . error ( message ) ; } public void error ( Object message , Throwable t ) { rlog . error ( message ) ; rlog . error ( t ) ; } } 	0	['20', '2', '0', '8', '27', '118', '5', '3', '17', '0.473684211', '129', '1', '1', '0.547619048', '0.316666667', '1', '3', '5.4', '1', '0.95', '0']
package org . apache . velocity . runtime . parser . node ; import java . io . IOException ; import java . io . Writer ; import org . apache . commons . lang . builder . ToStringBuilder ; import org . apache . commons . lang . text . StrBuilder ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . Token ; public class SimpleNode implements Node { protected RuntimeServices rsvc = null ; protected Log log = null ; protected Node parent ; protected Node [ ] children ; protected int id ; protected Parser parser ; protected int info ; public boolean state ; protected boolean invalid = false ; protected Token first ; protected Token last ; protected String templateName ; public SimpleNode ( int i ) { id = i ; } public SimpleNode ( Parser p , int i ) { this ( i ) ; parser = p ; templateName = parser . currentTemplateName ; } public void jjtOpen ( ) { first = parser . getToken ( 1 ) ; } public void jjtClose ( ) { last = parser . getToken ( 0 ) ; } public void setFirstToken ( Token t ) { this . first = t ; } public Token getFirstToken ( ) { return first ; } public Token getLastToken ( ) { return last ; } public void jjtSetParent ( Node n ) { parent = n ; } public Node jjtGetParent ( ) { return parent ; } public void jjtAddChild ( Node n , int i ) { if ( children == null ) { children = new Node [ i + 1 ] ; } else if ( i >= children . length ) { Node c [ ] = new Node [ i + 1 ] ; System . arraycopy ( children , 0 , c , 0 , children . length ) ; children = c ; } children [ i ] = n ; } public Node jjtGetChild ( int i ) { return children [ i ] ; } public int jjtGetNumChildren ( ) { return ( children == null ) ? 0 : children . length ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object childrenAccept ( ParserVisitor visitor , Object data ) { if ( children != null ) { for ( int i = 0 ; i < children . length ; ++ i ) { children [ i ] . jjtAccept ( visitor , data ) ; } } return data ; } public String toString ( String prefix ) { return prefix + toString ( ) ; } public void dump ( String prefix ) { System . out . println ( toString ( prefix ) ) ; if ( children != null ) { for ( int i = 0 ; i < children . length ; ++ i ) { SimpleNode n = ( SimpleNode ) children [ i ] ; if ( n != null ) { n . dump ( prefix + " " ) ; } } } } protected String getLocation ( InternalContextAdapter context ) { return Log . formatFileString ( this ) ; } public String literal ( ) { if ( first == last ) { return NodeUtils . tokenLiteral ( first ) ; } Token t = first ; StrBuilder sb = new StrBuilder ( NodeUtils . tokenLiteral ( t ) ) ; while ( t != last ) { t = t . next ; sb . append ( NodeUtils . tokenLiteral ( t ) ) ; } return sb . toString ( ) ; } public Object init ( InternalContextAdapter context , Object data ) throws TemplateInitException { rsvc = ( RuntimeServices ) data ; log = rsvc . getLog ( ) ; int i , k = jjtGetNumChildren ( ) ; for ( i = 0 ; i < k ; i ++ ) { jjtGetChild ( i ) . init ( context , data ) ; } return data ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { return false ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { return null ; } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException , ParseErrorException , ResourceNotFoundException { int i , k = jjtGetNumChildren ( ) ; for ( i = 0 ; i < k ; i ++ ) jjtGetChild ( i ) . render ( context , writer ) ; return true ; } public Object execute ( Object o , InternalContextAdapter context ) throws MethodInvocationException { return null ; } public int getType ( ) { return id ; } public void setInfo ( int info ) { this . info = info ; } public int getInfo ( ) { return info ; } public void setInvalid ( ) { invalid = true ; } public boolean isInvalid ( ) { return invalid ; } public int getLine ( ) { return first . beginLine ; } public int getColumn ( ) { return first . beginColumn ; } public String toString ( ) { StrBuilder tokens = new StrBuilder ( ) ; for ( Token t = getFirstToken ( ) ; t != null ; ) { tokens . append ( "[" ) . append ( t . image ) . append ( "]" ) ; if ( t . next != null ) { if ( t . equals ( getLastToken ( ) ) ) { break ; } else { tokens . append ( ", " ) ; } } t = t . next ; } return new ToStringBuilder ( this ) . append ( "id" , getType ( ) ) . append ( "info" , getInfo ( ) ) . append ( "invalid" , isInvalid ( ) ) . append ( "children" , jjtGetNumChildren ( ) ) . append ( "tokens" , tokens ) . toString ( ) ; } public String getTemplateName ( ) { return templateName ; } } 	1	['32', '1', '39', '65', '56', '418', '54', '14', '31', '0.913978495', '405', '0.916666667', '7', '0', '0.175', '1', '1', '11.28125', '4', '1.3438', '1']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . util . TemplateNumber ; public class ASTEQNode extends SimpleNode { public ASTEQNode ( int id ) { super ( id ) ; } public ASTEQNode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { Object left = jjtGetChild ( 0 ) . value ( context ) ; Object right = jjtGetChild ( 1 ) . value ( context ) ; if ( left instanceof TemplateNumber ) { left = ( ( TemplateNumber ) left ) . getAsNumber ( ) ; } if ( right instanceof TemplateNumber ) { right = ( ( TemplateNumber ) right ) . getAsNumber ( ) ; } if ( left instanceof Number && right instanceof Number ) { return MathUtils . compare ( ( Number ) left , ( Number ) right ) == 0 ; } if ( left != null && right != null && ( left . getClass ( ) . isAssignableFrom ( right . getClass ( ) ) || right . getClass ( ) . isAssignableFrom ( left . getClass ( ) ) ) ) { return left . equals ( right ) ; } left = ( left == null ) ? null : left . toString ( ) ; right = ( right == null ) ? null : right . toString ( ) ; if ( left == null && right == null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Both right (" + getLiteral ( false ) + " and left " + getLiteral ( true ) + " sides of '==' operation returned null." + "If references, they may not be in the context." + getLocation ( context ) ) ; } return true ; } else if ( left == null || right == null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( ( left == null ? "Left" : "Right" ) + " side (" + getLiteral ( left == null ) + ") of '==' operation has null value. If it is a " + "reference, it may not be in the context or its " + "toString() returned null. " + getLocation ( context ) ) ; } return false ; } else { return left . equals ( right ) ; } } private String getLiteral ( boolean left ) { return jjtGetChild ( left ? 0 : 1 ) . literal ( ) ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { return evaluate ( context ) ? Boolean . TRUE : Boolean . FALSE ; } } 	0	['6', '2', '0', '11', '24', '15', '4', '9', '5', '2', '197', '0', '0', '0.882352941', '0.333333333', '2', '2', '31.83333333', '2', '0.8333', '0']
package org . apache . velocity . runtime . parser . node ; import java . io . IOException ; import java . io . Writer ; import java . lang . reflect . InvocationTargetException ; import org . apache . velocity . app . event . EventHandlerUtil ; import org . apache . velocity . context . Context ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . Renderable ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . Token ; import org . apache . velocity . util . introspection . Info ; import org . apache . velocity . util . introspection . VelPropertySet ; public class ASTReference extends SimpleNode { private static final int NORMAL_REFERENCE = 1 ; private static final int FORMAL_REFERENCE = 2 ; private static final int QUIET_REFERENCE = 3 ; private static final int RUNT = 4 ; private int referenceType ; private String nullString ; private String rootString ; private boolean escaped = false ; private boolean computableReference = true ; private boolean logOnNull = true ; private String escPrefix = "" ; private String morePrefix = "" ; private String identifier = "" ; private String literal = null ; public boolean strictRef = false ; private int numChildren = 0 ; protected Info uberInfo ; public ASTReference ( int id ) { super ( id ) ; } public ASTReference ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object init ( InternalContextAdapter context , Object data ) throws TemplateInitException { super . init ( context , data ) ; rootString = getRoot ( ) ; numChildren = jjtGetNumChildren ( ) ; if ( numChildren > 0 ) { identifier = jjtGetChild ( numChildren - 1 ) . getFirstToken ( ) . image ; } uberInfo = new Info ( getTemplateName ( ) , getLine ( ) , getColumn ( ) ) ; logOnNull = rsvc . getBoolean ( RuntimeConstants . RUNTIME_LOG_REFERENCE_LOG_INVALID , true ) ; strictRef = rsvc . getBoolean ( RuntimeConstants . RUNTIME_REFERENCES_STRICT , false ) ; if ( strictRef && numChildren == 0 ) { logOnNull = false ; Node node = this . jjtGetParent ( ) ; if ( node instanceof ASTNotNode || node instanceof ASTExpression || node instanceof ASTOrNode || node instanceof ASTAndNode ) { while ( node != null ) { if ( node instanceof ASTIfStatement ) { strictRef = false ; break ; } node = node . jjtGetParent ( ) ; } } } return data ; } public String getRootString ( ) { return rootString ; } public Object execute ( Object o , InternalContextAdapter context ) throws MethodInvocationException { if ( referenceType == RUNT ) return null ; Object result = getVariableValue ( context , rootString ) ; if ( result == null && ! strictRef ) { return EventHandlerUtil . invalidGetMethod ( rsvc , context , "$" + rootString , null , null , uberInfo ) ; } try { Object previousResult = result ; int failedChild = - 1 ; for ( int i = 0 ; i < numChildren ; i ++ ) { if ( strictRef && result == null ) { String name = jjtGetChild ( i ) . getFirstToken ( ) . image ; throw new VelocityException ( "Attempted to access '" + name + "' on a null value at " + Log . formatFileString ( uberInfo . getTemplateName ( ) , + jjtGetChild ( i ) . getLine ( ) , jjtGetChild ( i ) . getColumn ( ) ) ) ; } previousResult = result ; result = jjtGetChild ( i ) . execute ( result , context ) ; if ( result == null && ! strictRef ) { failedChild = i ; break ; } } if ( result == null ) { if ( failedChild == - 1 ) { result = EventHandlerUtil . invalidGetMethod ( rsvc , context , "$" + rootString , previousResult , null , uberInfo ) ; } else { StringBuffer name = new StringBuffer ( "$" ) . append ( rootString ) ; for ( int i = 0 ; i <= failedChild ; i ++ ) { Node node = jjtGetChild ( i ) ; if ( node instanceof ASTMethod ) { name . append ( "." ) . append ( ( ( ASTMethod ) node ) . getMethodName ( ) ) . append ( "()" ) ; } else { name . append ( "." ) . append ( node . getFirstToken ( ) . image ) ; } } if ( jjtGetChild ( failedChild ) instanceof ASTMethod ) { String methodName = ( ( ASTMethod ) jjtGetChild ( failedChild ) ) . getMethodName ( ) ; result = EventHandlerUtil . invalidMethod ( rsvc , context , name . toString ( ) , previousResult , methodName , uberInfo ) ; } else { String property = jjtGetChild ( failedChild ) . getFirstToken ( ) . image ; result = EventHandlerUtil . invalidGetMethod ( rsvc , context , name . toString ( ) , previousResult , property , uberInfo ) ; } } } return result ; } catch ( MethodInvocationException mie ) { log . error ( "Method " + mie . getMethodName ( ) + " threw exception for reference $" + rootString + " in " + Log . formatFileString ( this ) ) ; mie . setReferenceName ( rootString ) ; throw mie ; } } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException { if ( referenceType == RUNT ) { if ( context . getAllowRendering ( ) ) { writer . write ( rootString ) ; } return true ; } Object value = execute ( null , context ) ; String localNullString = null ; if ( escaped ) { localNullString = getNullString ( context ) ; if ( value == null ) { if ( context . getAllowRendering ( ) ) { writer . write ( escPrefix ) ; writer . write ( "\\" ) ; writer . write ( localNullString ) ; } } else { if ( context . getAllowRendering ( ) ) { writer . write ( escPrefix ) ; writer . write ( localNullString ) ; } } return true ; } value = EventHandlerUtil . referenceInsert ( rsvc , context , literal ( ) , value ) ; String toString = null ; if ( value != null ) { if ( value instanceof Renderable && ( ( Renderable ) value ) . render ( context , writer ) ) { return true ; } toString = value . toString ( ) ; } if ( value == null || toString == null ) { if ( context . getAllowRendering ( ) ) { localNullString = getNullString ( context ) ; writer . write ( escPrefix ) ; writer . write ( escPrefix ) ; writer . write ( morePrefix ) ; writer . write ( localNullString ) ; } if ( logOnNull && referenceType != QUIET_REFERENCE && log . isDebugEnabled ( ) ) { log . debug ( "Null reference [template '" + getTemplateName ( ) + "', line " + this . getLine ( ) + ", column " + this . getColumn ( ) + "] : " + this . literal ( ) + " cannot be resolved." ) ; } return true ; } else { if ( context . getAllowRendering ( ) ) { writer . write ( escPrefix ) ; writer . write ( morePrefix ) ; writer . write ( toString ) ; } return true ; } } private String getNullString ( InternalContextAdapter context ) { Object callingArgument = context . get ( ".literal." + nullString ) ; if ( callingArgument != null ) return ( ( Node ) callingArgument ) . literal ( ) ; else return nullString ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { Object value = execute ( null , context ) ; if ( value == null ) { return false ; } else if ( value instanceof Boolean ) { if ( ( ( Boolean ) value ) . booleanValue ( ) ) return true ; else return false ; } else if ( value . toString ( ) == null ) { return false ; } else return true ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { return ( computableReference ? execute ( null , context ) : null ) ; } public boolean setValue ( InternalContextAdapter context , Object value ) throws MethodInvocationException { if ( jjtGetNumChildren ( ) == 0 ) { context . put ( rootString , value ) ; return true ; } Object result = getVariableValue ( context , rootString ) ; if ( result == null ) { String msg = "reference set is not a valid reference at " + Log . formatFileString ( uberInfo ) ; log . error ( msg ) ; return false ; } for ( int i = 0 ; i < numChildren - 1 ; i ++ ) { result = jjtGetChild ( i ) . execute ( result , context ) ; if ( result == null ) { if ( strictRef ) { String name = jjtGetChild ( i + 1 ) . getFirstToken ( ) . image ; throw new MethodInvocationException ( "Attempted to access '" + name + "' on a null value" , null , name , uberInfo . getTemplateName ( ) , jjtGetChild ( i + 1 ) . getLine ( ) , jjtGetChild ( i + 1 ) . getColumn ( ) ) ; } String msg = "reference set is not a valid reference at " + Log . formatFileString ( uberInfo ) ; log . error ( msg ) ; return false ; } } try { VelPropertySet vs = rsvc . getUberspect ( ) . getPropertySet ( result , identifier , value , uberInfo ) ; if ( vs == null ) { if ( strictRef ) { throw new MethodInvocationException ( "Object '" + result . getClass ( ) . getName ( ) + "' does not contain property '" + identifier + "'" , null , identifier , uberInfo . getTemplateName ( ) , uberInfo . getLine ( ) , uberInfo . getColumn ( ) ) ; } else { return false ; } } vs . invoke ( result , value ) ; } catch ( InvocationTargetException ite ) { throw new MethodInvocationException ( "ASTReference : Invocation of method '" + identifier + "' in  " + result . getClass ( ) + " threw exception " + ite . getTargetException ( ) . toString ( ) , ite . getTargetException ( ) , identifier , getTemplateName ( ) , this . getLine ( ) , this . getColumn ( ) ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { String msg = "ASTReference setValue() : exception : " + e + " template at " + Log . formatFileString ( uberInfo ) ; log . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } return true ; } private String getRoot ( ) { Token t = getFirstToken ( ) ; int slashbang = t . image . indexOf ( "\\!" ) ; if ( slashbang != - 1 ) { int i = 0 ; int len = t . image . length ( ) ; i = t . image . indexOf ( '$' ) ; if ( i == - 1 ) { log . error ( "ASTReference.getRoot() : internal error : " + "no $ found for slashbang." ) ; computableReference = false ; nullString = t . image ; return nullString ; } while ( i < len && t . image . charAt ( i ) != '\\' ) { i ++ ; } int start = i ; int count = 0 ; while ( i < len && t . image . charAt ( i ++ ) == '\\' ) { count ++ ; } nullString = t . image . substring ( 0 , start ) ; nullString += t . image . substring ( start , start + count - 1 ) ; nullString += t . image . substring ( start + count ) ; computableReference = false ; return nullString ; } escaped = false ; if ( t . image . startsWith ( "\\" ) ) { int i = 0 ; int len = t . image . length ( ) ; while ( i < len && t . image . charAt ( i ) == '\\' ) { i ++ ; } if ( ( i % 2 ) != 0 ) escaped = true ; if ( i > 0 ) escPrefix = t . image . substring ( 0 , i / 2 ) ; t . image = t . image . substring ( i ) ; } int loc1 = t . image . lastIndexOf ( '$' ) ; if ( loc1 > 0 ) { morePrefix = morePrefix + t . image . substring ( 0 , loc1 ) ; t . image = t . image . substring ( loc1 ) ; } nullString = literal ( ) ; if ( t . image . startsWith ( "$!" ) ) { referenceType = QUIET_REFERENCE ; if ( ! escaped ) nullString = "" ; if ( t . image . startsWith ( "$!{" ) ) { return t . next . image ; } else { return t . image . substring ( 2 ) ; } } else if ( t . image . equals ( "${" ) ) { referenceType = FORMAL_REFERENCE ; return t . next . image ; } else if ( t . image . startsWith ( "$" ) ) { referenceType = NORMAL_REFERENCE ; return t . image . substring ( 1 ) ; } else { referenceType = RUNT ; return t . image ; } } public Object getVariableValue ( Context context , String variable ) throws MethodInvocationException { Object obj = null ; try { obj = context . get ( variable ) ; } catch ( RuntimeException e ) { log . error ( "Exception calling reference $" + variable + " at " + Log . formatFileString ( uberInfo ) ) ; throw e ; } if ( strictRef && obj == null ) { if ( ! context . containsKey ( variable ) ) { log . error ( "Variable $" + variable + " has not been set at " + Log . formatFileString ( uberInfo ) ) ; throw new MethodInvocationException ( "Variable $" + variable + " has not been set" , null , identifier , uberInfo . getTemplateName ( ) , uberInfo . getLine ( ) , uberInfo . getColumn ( ) ) ; } } return obj ; } public void setLiteral ( String literal ) { if ( this . literal == null ) this . literal = literal ; } public String literal ( ) { if ( literal != null ) return literal ; return super . literal ( ) ; } } 	1	['15', '2', '0', '28', '83', '25', '7', '23', '13', '0.735294118', '1221', '0.941176471', '1', '0.697674419', '0.251851852', '1', '2', '79.26666667', '18', '2.2', '12']
package org . apache . velocity . runtime . log ; import java . util . logging . Level ; import java . util . logging . Logger ; import org . apache . velocity . runtime . RuntimeServices ; public class JdkLogChute implements LogChute { public static final String RUNTIME_LOG_JDK_LOGGER = "runtime.log.logsystem.jdk.logger" ; public static final String RUNTIME_LOG_JDK_LOGGER_LEVEL = "runtime.log.logsystem.jdk.logger.level" ; public static final String DEFAULT_LOG_NAME = "org.apache.velocity" ; protected Logger logger = null ; public void init ( RuntimeServices rs ) { String name = ( String ) rs . getProperty ( RUNTIME_LOG_JDK_LOGGER ) ; if ( name == null ) { name = DEFAULT_LOG_NAME ; } logger = Logger . getLogger ( name ) ; String lvl = rs . getString ( RUNTIME_LOG_JDK_LOGGER_LEVEL ) ; if ( lvl != null ) { Level level = Level . parse ( lvl ) ; logger . setLevel ( level ) ; log ( LogChute . DEBUG_ID , "JdkLogChute will use logger '" + name + '\'' + " at level '" + level + '\'' ) ; } } protected Level getJdkLevel ( int level ) { switch ( level ) { case LogChute . WARN_ID : return Level . WARNING ; case LogChute . INFO_ID : return Level . INFO ; case LogChute . DEBUG_ID : return Level . FINE ; case LogChute . TRACE_ID : return Level . FINEST ; case LogChute . ERROR_ID : return Level . SEVERE ; default : return Level . FINER ; } } public void log ( int level , String message ) { log ( level , message , null ) ; } public void log ( int level , String message , Throwable t ) { Level jdkLevel = getJdkLevel ( level ) ; if ( t == null ) { logger . log ( jdkLevel , message ) ; } else { logger . log ( jdkLevel , message , t ) ; } } public boolean isLevelEnabled ( int level ) { Level jdkLevel = getJdkLevel ( level ) ; return logger . isLoggable ( jdkLevel ) ; } } 	0	['6', '1', '0', '2', '20', '3', '0', '2', '5', '0.95', '110', '0.25', '0', '0', '0.466666667', '0', '0', '16.66666667', '3', '1.5', '0']
package org . apache . velocity . runtime . directive ; import org . apache . velocity . exception . ExtendedParseException ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . parser . ParseException ; import org . apache . velocity . runtime . parser . Token ; public class MacroParseException extends ParseException implements ExtendedParseException { private final String templateName ; private static final long serialVersionUID = - 4985224672336070689L ; public MacroParseException ( final String msg , final String templateName , final Token currentToken ) { super ( msg ) ; this . currentToken = currentToken ; this . templateName = templateName ; } public String getTemplateName ( ) { return templateName ; } public int getLineNumber ( ) { if ( ( currentToken != null ) && ( currentToken . next != null ) ) { return currentToken . next . beginLine ; } else { return - 1 ; } } public int getColumnNumber ( ) { if ( ( currentToken != null ) && ( currentToken . next != null ) ) { return currentToken . next . beginColumn ; } else { return - 1 ; } } public String getMessage ( ) { if ( ! specialConstructor ) { StringBuffer sb = new StringBuffer ( super . getMessage ( ) ) ; appendTemplateInfo ( sb ) ; return sb . toString ( ) ; } int maxSize = 0 ; StringBuffer expected = new StringBuffer ( ) ; for ( int i = 0 ; i < expectedTokenSequences . length ; i ++ ) { if ( maxSize < expectedTokenSequences [ i ] . length ) { maxSize = expectedTokenSequences [ i ] . length ; } for ( int j = 0 ; j < expectedTokenSequences [ i ] . length ; j ++ ) { expected . append ( tokenImage [ expectedTokenSequences [ i ] [ j ] ] ) . append ( " " ) ; } if ( expectedTokenSequences [ i ] [ expectedTokenSequences [ i ] . length - 1 ] != 0 ) { expected . append ( "..." ) ; } expected . append ( eol ) . append ( "    " ) ; } StringBuffer retval = new StringBuffer ( "Encountered \"" ) ; Token tok = currentToken . next ; for ( int i = 0 ; i < maxSize ; i ++ ) { if ( i != 0 ) { retval . append ( " " ) ; } if ( tok . kind == 0 ) { retval . append ( tokenImage [ 0 ] ) ; break ; } retval . append ( add_escapes ( tok . image ) ) ; tok = tok . next ; } retval . append ( "\"" ) ; appendTemplateInfo ( retval ) ; if ( expectedTokenSequences . length == 1 ) { retval . append ( "Was expecting:" ) . append ( eol ) . append ( "    " ) ; } else { retval . append ( "Was expecting one of:" ) . append ( eol ) . append ( "    " ) ; } retval . append ( expected . toString ( ) ) ; return retval . toString ( ) ; } protected void appendTemplateInfo ( final StringBuffer sb ) { sb . append ( Log . formatFileString ( getTemplateName ( ) , getLineNumber ( ) , getColumnNumber ( ) ) ) ; sb . append ( eol ) ; } } 	1	['6', '4', '0', '6', '14', '0', '2', '4', '5', '0.9', '239', '1', '0', '0.75', '0.375', '1', '3', '38.5', '10', '3', '1']
package org . apache . velocity . util . introspection ; import java . lang . reflect . Method ; import org . apache . velocity . runtime . log . Log ; public abstract class IntrospectorBase { protected final Log log ; private final IntrospectorCache introspectorCache ; protected IntrospectorBase ( final Log log ) { this . log = log ; introspectorCache = new IntrospectorCacheImpl ( log ) ; } public Method getMethod ( final Class c , final String name , final Object [ ] params ) throws IllegalArgumentException , MethodMap . AmbiguousException { if ( c == null ) { throw new IllegalArgumentException ( "class object is null!" ) ; } if ( params == null ) { throw new IllegalArgumentException ( "params object is null!" ) ; } IntrospectorCache ic = getIntrospectorCache ( ) ; ClassMap classMap = ic . get ( c ) ; if ( classMap == null ) { classMap = ic . put ( c ) ; } return classMap . findMethod ( name , params ) ; } protected IntrospectorCache getIntrospectorCache ( ) { return introspectorCache ; } } 	0	['3', '1', '1', '6', '9', '1', '1', '5', '1', '0.5', '52', '1', '2', '0', '0.466666667', '0', '0', '15.66666667', '1', '0.6667', '0']
package org . apache . velocity . runtime . log ; import org . apache . velocity . runtime . RuntimeServices ; public class NullLogChute implements LogChute { public void init ( RuntimeServices rs ) throws Exception { } public void log ( int level , String message ) { } public void log ( int level , String message , Throwable t ) { } public boolean isLevelEnabled ( int level ) { return false ; } } 	1	['5', '1', '1', '3', '6', '10', '1', '2', '5', '2', '13', '0', '0', '0', '0.48', '0', '0', '1.6', '1', '0.8', '2']
package org . apache . velocity . runtime . parser . node ; import java . io . IOException ; import java . io . Writer ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . runtime . parser . Parser ; public class ASTIfStatement extends SimpleNode { public ASTIfStatement ( int id ) { super ( id ) ; } public ASTIfStatement ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException , ResourceNotFoundException , ParseErrorException { if ( jjtGetChild ( 0 ) . evaluate ( context ) ) { jjtGetChild ( 1 ) . render ( context , writer ) ; return true ; } int totalNodes = jjtGetNumChildren ( ) ; for ( int i = 2 ; i < totalNodes ; i ++ ) { if ( jjtGetChild ( i ) . evaluate ( context ) ) { jjtGetChild ( i ) . render ( context , writer ) ; return true ; } } return true ; } public void process ( InternalContextAdapter context , ParserVisitor visitor ) { } } 	0	['5', '2', '0', '11', '12', '10', '5', '8', '5', '2', '62', '0', '0', '0.909090909', '0.4', '1', '2', '11.4', '1', '0.6', '0']
package org . apache . velocity . runtime . directive ; import java . io . IOException ; import java . io . Writer ; import org . apache . velocity . context . EvaluateContext ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . context . InternalContextAdapterImpl ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . parser . ParseException ; import org . apache . velocity . runtime . parser . ParserTreeConstants ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . runtime . parser . node . SimpleNode ; import org . apache . velocity . util . introspection . Info ; public class Evaluate extends Directive { public String getName ( ) { return "evaluate" ; } public int getType ( ) { return LINE ; } public void init ( RuntimeServices rs , InternalContextAdapter context , Node node ) throws TemplateInitException { super . init ( rs , context , node ) ; int argCount = node . jjtGetNumChildren ( ) ; if ( argCount == 0 ) { throw new TemplateInitException ( "#" + getName ( ) + "() requires exactly one argument" , context . getCurrentTemplateName ( ) , node . getColumn ( ) , node . getLine ( ) ) ; } if ( argCount > 1 ) { throw new TemplateInitException ( "#" + getName ( ) + "() requires exactly one argument" , context . getCurrentTemplateName ( ) , node . jjtGetChild ( 1 ) . getColumn ( ) , node . jjtGetChild ( 1 ) . getLine ( ) ) ; } Node childNode = node . jjtGetChild ( 0 ) ; if ( childNode . getType ( ) != ParserTreeConstants . JJTSTRINGLITERAL && childNode . getType ( ) != ParserTreeConstants . JJTREFERENCE ) { throw new TemplateInitException ( "#" + getName ( ) + "()  argument must be a string literal or reference" , context . getCurrentTemplateName ( ) , childNode . getColumn ( ) , childNode . getLine ( ) ) ; } } public boolean render ( InternalContextAdapter context , Writer writer , Node node ) throws IOException , ResourceNotFoundException , ParseErrorException , MethodInvocationException { Object value = node . jjtGetChild ( 0 ) . value ( context ) ; String sourceText ; if ( value != null ) { sourceText = value . toString ( ) ; } else { sourceText = "" ; } String templateName = context . getCurrentTemplateName ( ) ; SimpleNode nodeTree = null ; try { nodeTree = rsvc . parse ( sourceText , templateName ) ; } catch ( ParseException pex ) { Info info = new Info ( templateName , node . getLine ( ) , node . getColumn ( ) ) ; throw new ParseErrorException ( pex . getMessage ( ) , info ) ; } catch ( TemplateInitException pex ) { Info info = new Info ( templateName , node . getLine ( ) , node . getColumn ( ) ) ; throw new ParseErrorException ( pex . getMessage ( ) , info ) ; } if ( nodeTree != null ) { InternalContextAdapterImpl ica = new InternalContextAdapterImpl ( new EvaluateContext ( context , rsvc ) ) ; ica . pushCurrentTemplateName ( templateName ) ; try { try { nodeTree . init ( ica , rsvc ) ; } catch ( TemplateInitException pex ) { Info info = new Info ( templateName , node . getLine ( ) , node . getColumn ( ) ) ; throw new ParseErrorException ( pex . getMessage ( ) , info ) ; } try { nodeTree . render ( ica , writer ) ; } catch ( ParseErrorException pex ) { Info info = new Info ( templateName , node . getLine ( ) , node . getColumn ( ) ) ; throw new ParseErrorException ( pex . getMessage ( ) , info ) ; } } finally { ica . popCurrentTemplateName ( ) ; } return true ; } return false ; } } 	1	['5', '2', '0', '14', '31', '10', '0', '14', '5', '2', '239', '0', '0', '0.692307692', '0.44', '0', '0', '46.8', '1', '0.8', '4']
package org . apache . velocity . exception ; import org . apache . commons . lang . StringUtils ; import org . apache . velocity . runtime . log . Log ; public class MethodInvocationException extends VelocityException implements ExtendedParseException { private static final long serialVersionUID = 7305685093478106342L ; private String referenceName = "" ; private final String methodName ; private final int lineNumber ; private final int columnNumber ; private final String templateName ; public MethodInvocationException ( final String message , final Throwable e , final String methodName , final String templateName , final int lineNumber , final int columnNumber ) { super ( message , e ) ; this . methodName = methodName ; this . templateName = templateName ; this . lineNumber = lineNumber ; this . columnNumber = columnNumber ; } public String getMethodName ( ) { return methodName ; } public void setReferenceName ( String ref ) { referenceName = ref ; } public String getReferenceName ( ) { return referenceName ; } public int getColumnNumber ( ) { return columnNumber ; } public int getLineNumber ( ) { return lineNumber ; } public String getTemplateName ( ) { return templateName ; } public String getMessage ( ) { StringBuffer message = new StringBuffer ( ) ; message . append ( super . getMessage ( ) ) ; message . append ( " at " ) ; message . append ( Log . formatFileString ( templateName , lineNumber , columnNumber ) ) ; return message . toString ( ) ; } } 	0	['8', '5', '0', '46', '14', '6', '43', '3', '8', '0.80952381', '79', '1', '0', '0.666666667', '0.375', '1', '1', '8.125', '1', '0.875', '0']
package org . apache . velocity . runtime ; import java . io . Reader ; import java . util . Properties ; import org . apache . commons . collections . ExtendedProperties ; import org . apache . velocity . Template ; import org . apache . velocity . app . event . EventCartridge ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . runtime . directive . Directive ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . parser . ParseException ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . runtime . parser . node . SimpleNode ; import org . apache . velocity . runtime . resource . ContentResource ; import org . apache . velocity . util . introspection . Introspector ; import org . apache . velocity . util . introspection . Uberspect ; public class RuntimeSingleton implements RuntimeConstants { private static RuntimeInstance ri = new RuntimeInstance ( ) ; public synchronized static void init ( ) throws Exception { ri . init ( ) ; } public static boolean isInitialized ( ) { return ri . isInitialized ( ) ; } public static RuntimeServices getRuntimeServices ( ) { return ri ; } public static void setProperty ( String key , Object value ) { ri . setProperty ( key , value ) ; } public static void setConfiguration ( ExtendedProperties configuration ) { ri . setConfiguration ( configuration ) ; } public static void addProperty ( String key , Object value ) { ri . addProperty ( key , value ) ; } public static void clearProperty ( String key ) { ri . clearProperty ( key ) ; } public static Object getProperty ( String key ) { return ri . getProperty ( key ) ; } public static void init ( Properties p ) throws Exception { ri . init ( p ) ; } public static void init ( String configurationFile ) throws Exception { ri . init ( configurationFile ) ; } public static SimpleNode parse ( Reader reader , String templateName ) throws ParseException { return ri . parse ( reader , templateName ) ; } public static SimpleNode parse ( Reader reader , String templateName , boolean dumpNamespace ) throws ParseException { return ri . parse ( reader , templateName , dumpNamespace ) ; } public static Template getTemplate ( String name ) throws ResourceNotFoundException , ParseErrorException , Exception { return ri . getTemplate ( name ) ; } public static Template getTemplate ( String name , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception { return ri . getTemplate ( name , encoding ) ; } public static ContentResource getContent ( String name ) throws ResourceNotFoundException , ParseErrorException , Exception { return ri . getContent ( name ) ; } public static ContentResource getContent ( String name , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception { return ri . getContent ( name , encoding ) ; } public static String getLoaderNameForResource ( String resourceName ) { return ri . getLoaderNameForResource ( resourceName ) ; } public static Log getLog ( ) { return ri . getLog ( ) ; } public static void warn ( Object message ) { getLog ( ) . warn ( message ) ; } public static void info ( Object message ) { getLog ( ) . info ( message ) ; } public static void error ( Object message ) { getLog ( ) . error ( message ) ; } public static void debug ( Object message ) { getLog ( ) . debug ( message ) ; } public static String getString ( String key , String defaultValue ) { return ri . getString ( key , defaultValue ) ; } public static Directive getVelocimacro ( String vmName , String templateName ) { return ri . getVelocimacro ( vmName , templateName ) ; } public static boolean addVelocimacro ( String name , Node macro , String argArray [ ] , String sourceTemplate ) { return ri . addVelocimacro ( name , macro , argArray , sourceTemplate ) ; } public static boolean addVelocimacro ( String name , String macro , String argArray [ ] , String sourceTemplate ) { return ri . addVelocimacro ( name , macro , argArray , sourceTemplate ) ; } public static boolean isVelocimacro ( String vmName , String templateName ) { return ri . isVelocimacro ( vmName , templateName ) ; } public static boolean dumpVMNamespace ( String namespace ) { return ri . dumpVMNamespace ( namespace ) ; } public static String getString ( String key ) { return ri . getString ( key ) ; } public static int getInt ( String key ) { return ri . getInt ( key ) ; } public static int getInt ( String key , int defaultValue ) { return ri . getInt ( key , defaultValue ) ; } public static boolean getBoolean ( String key , boolean def ) { return ri . getBoolean ( key , def ) ; } public static ExtendedProperties getConfiguration ( ) { return ri . getConfiguration ( ) ; } public static Introspector getIntrospector ( ) { return ri . getIntrospector ( ) ; } public EventCartridge getEventCartridge ( ) { return ri . getApplicationEventCartridge ( ) ; } public static Object getApplicationAttribute ( Object key ) { return ri . getApplicationAttribute ( key ) ; } public static Uberspect getUberspect ( ) { return ri . getUberspect ( ) ; } public static RuntimeInstance getRuntimeInstance ( ) { return ri ; } } 	1	['40', '1', '0', '19', '78', '0', '3', '16', '39', '0.025641026', '208', '1', '1', '0', '0.105128205', '0', '0', '4.175', '1', '0.95', '1']
package org . apache . velocity . app . event ; import org . apache . velocity . context . Context ; import org . apache . velocity . util . ContextAware ; public interface NullSetEventHandler extends EventHandler { public boolean shouldLogOnNullSet ( String lhs , String rhs ) ; static class ShouldLogOnNullSetExecutor implements EventHandlerMethodExecutor { private Context context ; private String lhs ; private String rhs ; private boolean result = true ; private boolean executed = false ; ShouldLogOnNullSetExecutor ( Context context , String lhs , String rhs ) { this . context = context ; this . lhs = lhs ; this . rhs = rhs ; } public void execute ( EventHandler handler ) { NullSetEventHandler eh = ( NullSetEventHandler ) handler ; if ( eh instanceof ContextAware ) ( ( ContextAware ) eh ) . setContext ( context ) ; executed = true ; result = ( ( NullSetEventHandler ) handler ) . shouldLogOnNullSet ( lhs , rhs ) ; } public Object getReturnValue ( ) { return result ? Boolean . TRUE : Boolean . FALSE ; } public boolean isDone ( ) { return executed && ! result ; } } } 	0	['1', '1', '0', '4', '1', '0', '3', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . velocity . runtime . parser . node ; import java . io . IOException ; import java . io . Writer ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; public class ASTEscape extends SimpleNode { public String val ; private char [ ] ctext ; public ASTEscape ( int id ) { super ( id ) ; } public ASTEscape ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object init ( InternalContextAdapter context , Object data ) { ctext = val . toCharArray ( ) ; return data ; } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException { if ( context . getAllowRendering ( ) ) { writer . write ( ctext ) ; } return true ; } } 	1	['5', '2', '0', '6', '11', '8', '4', '4', '5', '0.875', '37', '0.5', '0', '0.909090909', '0.4', '0', '0', '6', '1', '0.6', '1']
package org . apache . velocity . runtime . log ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . util . introspection . Info ; public class Log { private LogChute chute ; public Log ( ) { setLogChute ( new HoldingLogChute ( ) ) ; } public Log ( final LogChute chute ) { setLogChute ( chute ) ; } protected void setLogChute ( final LogChute chute ) { if ( chute == null ) { throw new NullPointerException ( "The LogChute cannot be set to null!" ) ; } this . chute = chute ; } protected LogChute getLogChute ( ) { return this . chute ; } protected void log ( int level , Object message ) { getLogChute ( ) . log ( level , String . valueOf ( message ) ) ; } protected void log ( int level , Object message , Throwable t ) { getLogChute ( ) . log ( level , String . valueOf ( message ) , t ) ; } public boolean isTraceEnabled ( ) { return getLogChute ( ) . isLevelEnabled ( LogChute . TRACE_ID ) ; } public void trace ( Object message ) { log ( LogChute . TRACE_ID , message ) ; } public void trace ( Object message , Throwable t ) { log ( LogChute . TRACE_ID , message , t ) ; } public boolean isDebugEnabled ( ) { return getLogChute ( ) . isLevelEnabled ( LogChute . DEBUG_ID ) ; } public void debug ( Object message ) { log ( LogChute . DEBUG_ID , message ) ; } public void debug ( Object message , Throwable t ) { log ( LogChute . DEBUG_ID , message , t ) ; } public boolean isInfoEnabled ( ) { return getLogChute ( ) . isLevelEnabled ( LogChute . INFO_ID ) ; } public void info ( Object message ) { log ( LogChute . INFO_ID , message ) ; } public void info ( Object message , Throwable t ) { log ( LogChute . INFO_ID , message , t ) ; } public boolean isWarnEnabled ( ) { return getLogChute ( ) . isLevelEnabled ( LogChute . WARN_ID ) ; } public void warn ( Object message ) { log ( LogChute . WARN_ID , message ) ; } public void warn ( Object message , Throwable t ) { log ( LogChute . WARN_ID , message , t ) ; } public boolean isErrorEnabled ( ) { return getLogChute ( ) . isLevelEnabled ( LogChute . ERROR_ID ) ; } public void error ( Object message ) { log ( LogChute . ERROR_ID , message ) ; } public void error ( Object message , Throwable t ) { log ( LogChute . ERROR_ID , message , t ) ; } public static final String formatFileString ( Node node ) { return formatFileString ( node . getTemplateName ( ) , node . getLine ( ) , node . getColumn ( ) ) ; } public static final String formatFileString ( Info info ) { return formatFileString ( info . getTemplateName ( ) , info . getLine ( ) , info . getColumn ( ) ) ; } public static final String formatFileString ( String template , int linenum , int colnum ) { if ( template == null || template . equals ( "" ) ) { template = "<unknown template>" ; } return template + "[line " + linenum + ", column " + colnum + "]" ; } } 	0	['25', '1', '2', '80', '46', '298', '76', '5', '21', '0.166666667', '198', '1', '1', '0', '0.213333333', '0', '0', '6.88', '3', '1.04', '0']
package org . apache . velocity . util . introspection ; import java . util . Iterator ; public interface Uberspect { public void init ( ) throws Exception ; public Iterator getIterator ( Object obj , Info info ) throws Exception ; public VelMethod getMethod ( Object obj , String method , Object [ ] args , Info info ) throws Exception ; public VelPropertyGet getPropertyGet ( Object obj , String identifier , Info info ) throws Exception ; public VelPropertySet getPropertySet ( Object obj , String identifier , Object arg , Info info ) throws Exception ; } 	1	['5', '1', '0', '15', '5', '10', '11', '4', '5', '2', '5', '0', '0', '0', '0.68', '0', '0', '0', '1', '1', '2']
package org . apache . velocity . util ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileReader ; import java . io . PrintWriter ; import java . util . ArrayList ; import java . util . Hashtable ; import java . util . List ; import java . util . Map ; import java . util . StringTokenizer ; public class StringUtils { private static final String EOL = System . getProperty ( "line.separator" ) ; public String concat ( List list ) { StringBuffer sb = new StringBuffer ( ) ; int size = list . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { sb . append ( list . get ( i ) . toString ( ) ) ; } return sb . toString ( ) ; } static public String getPackageAsPath ( String pckge ) { return pckge . replace ( '.' , File . separator . charAt ( 0 ) ) + File . separator ; } static public String removeUnderScores ( String data ) { String temp = null ; StringBuffer out = new StringBuffer ( ) ; temp = data ; StringTokenizer st = new StringTokenizer ( temp , "_" ) ; while ( st . hasMoreTokens ( ) ) { String element = ( String ) st . nextElement ( ) ; out . append ( firstLetterCaps ( element ) ) ; } return out . toString ( ) ; } static public String removeAndHump ( String data ) { return removeAndHump ( data , "_" ) ; } static public String removeAndHump ( String data , String replaceThis ) { String temp = null ; StringBuffer out = new StringBuffer ( ) ; temp = data ; StringTokenizer st = new StringTokenizer ( temp , replaceThis ) ; while ( st . hasMoreTokens ( ) ) { String element = ( String ) st . nextElement ( ) ; out . append ( capitalizeFirstLetter ( element ) ) ; } return out . toString ( ) ; } static public String firstLetterCaps ( String data ) { String firstLetter = data . substring ( 0 , 1 ) . toUpperCase ( ) ; String restLetters = data . substring ( 1 ) . toLowerCase ( ) ; return firstLetter + restLetters ; } static public String capitalizeFirstLetter ( String data ) { String firstLetter = data . substring ( 0 , 1 ) . toUpperCase ( ) ; String restLetters = data . substring ( 1 ) ; return firstLetter + restLetters ; } public static String [ ] split ( String line , String delim ) { List list = new ArrayList ( ) ; StringTokenizer t = new StringTokenizer ( line , delim ) ; while ( t . hasMoreTokens ( ) ) { list . add ( t . nextToken ( ) ) ; } return ( String [ ] ) list . toArray ( new String [ list . size ( ) ] ) ; } public static String chop ( String s , int i ) { return chop ( s , i , EOL ) ; } public static String chop ( String s , int i , String eol ) { if ( i == 0 || s == null || eol == null ) { return s ; } int length = s . length ( ) ; if ( eol . length ( ) == 2 && s . endsWith ( eol ) ) { length -= 2 ; i -= 1 ; } if ( i > 0 ) { length -= i ; } if ( length < 0 ) { length = 0 ; } return s . substring ( 0 , length ) ; } public static StringBuffer stringSubstitution ( String argStr , Hashtable vars ) { return stringSubstitution ( argStr , ( Map ) vars ) ; } public static StringBuffer stringSubstitution ( String argStr , Map vars ) { StringBuffer argBuf = new StringBuffer ( ) ; for ( int cIdx = 0 ; cIdx < argStr . length ( ) ; ) { char ch = argStr . charAt ( cIdx ) ; switch ( ch ) { case '$' : StringBuffer nameBuf = new StringBuffer ( ) ; for ( ++ cIdx ; cIdx < argStr . length ( ) ; ++ cIdx ) { ch = argStr . charAt ( cIdx ) ; if ( ch == '_' || Character . isLetterOrDigit ( ch ) ) nameBuf . append ( ch ) ; else break ; } if ( nameBuf . length ( ) > 0 ) { String value = ( String ) vars . get ( nameBuf . toString ( ) ) ; if ( value != null ) { argBuf . append ( value ) ; } } break ; default : argBuf . append ( ch ) ; ++ cIdx ; break ; } } return argBuf ; } public static String fileContentsToString ( String file ) { String contents = "" ; File f = null ; try { f = new File ( file ) ; if ( f . exists ( ) ) { FileReader fr = null ; try { fr = new FileReader ( f ) ; char [ ] template = new char [ ( int ) f . length ( ) ] ; fr . read ( template ) ; contents = new String ( template ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( fr != null ) { fr . close ( ) ; } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } return contents ; } public static String collapseNewlines ( String argStr ) { char last = argStr . charAt ( 0 ) ; StringBuffer argBuf = new StringBuffer ( ) ; for ( int cIdx = 0 ; cIdx < argStr . length ( ) ; cIdx ++ ) { char ch = argStr . charAt ( cIdx ) ; if ( ch != '\n' || last != '\n' ) { argBuf . append ( ch ) ; last = ch ; } } return argBuf . toString ( ) ; } public static String collapseSpaces ( String argStr ) { char last = argStr . charAt ( 0 ) ; StringBuffer argBuf = new StringBuffer ( ) ; for ( int cIdx = 0 ; cIdx < argStr . length ( ) ; cIdx ++ ) { char ch = argStr . charAt ( cIdx ) ; if ( ch != ' ' || last != ' ' ) { argBuf . append ( ch ) ; last = ch ; } } return argBuf . toString ( ) ; } public static final String sub ( String line , String oldString , String newString ) { int i = 0 ; if ( ( i = line . indexOf ( oldString , i ) ) >= 0 ) { char [ ] line2 = line . toCharArray ( ) ; char [ ] newString2 = newString . toCharArray ( ) ; int oLength = oldString . length ( ) ; StringBuffer buf = new StringBuffer ( line2 . length ) ; buf . append ( line2 , 0 , i ) . append ( newString2 ) ; i += oLength ; int j = i ; while ( ( i = line . indexOf ( oldString , i ) ) > 0 ) { buf . append ( line2 , j , i - j ) . append ( newString2 ) ; i += oLength ; j = i ; } buf . append ( line2 , j , line2 . length - j ) ; return buf . toString ( ) ; } return line ; } public static final String stackTrace ( Throwable e ) { String foo = null ; try { ByteArrayOutputStream ostr = new ByteArrayOutputStream ( ) ; e . printStackTrace ( new PrintWriter ( ostr , true ) ) ; foo = ostr . toString ( ) ; } catch ( Exception f ) { } return foo ; } public static final String normalizePath ( String path ) { String normalized = path ; if ( normalized . indexOf ( '\\' ) >= 0 ) { normalized = normalized . replace ( '\\' , '/' ) ; } if ( ! normalized . startsWith ( "/" ) ) { normalized = "/" + normalized ; } while ( true ) { int index = normalized . indexOf ( "//" ) ; if ( index < 0 ) break ; normalized = normalized . substring ( 0 , index ) + normalized . substring ( index + 1 ) ; } while ( true ) { int index = normalized . indexOf ( "%20" ) ; if ( index < 0 ) break ; normalized = normalized . substring ( 0 , index ) + " " + normalized . substring ( index + 3 ) ; } while ( true ) { int index = normalized . indexOf ( "/./" ) ; if ( index < 0 ) break ; normalized = normalized . substring ( 0 , index ) + normalized . substring ( index + 2 ) ; } while ( true ) { int index = normalized . indexOf ( "/../" ) ; if ( index < 0 ) break ; if ( index == 0 ) return ( null ) ; int index2 = normalized . lastIndexOf ( '/' , index - 1 ) ; normalized = normalized . substring ( 0 , index2 ) + normalized . substring ( index + 3 ) ; } return ( normalized ) ; } public String select ( boolean state , String trueString , String falseString ) { if ( state ) { return trueString ; } else { return falseString ; } } public boolean allEmpty ( List list ) { int size = list . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( list . get ( i ) != null && list . get ( i ) . toString ( ) . length ( ) > 0 ) { return false ; } } return true ; } public static List trimStrings ( List list ) { if ( list == null ) return null ; int sz = list . size ( ) ; for ( int i = 0 ; i < sz ; i ++ ) list . set ( i , nullTrim ( ( String ) list . get ( i ) ) ) ; return list ; } public static String nullTrim ( String s ) { if ( s == null ) { return null ; } else { return s . trim ( ) ; } } } 	0	['24', '1', '0', '11', '74', '274', '11', '0', '23', '0.956521739', '731', '1', '0', '0', '0.168478261', '0', '0', '29.41666667', '8', '2.5833', '0']
package org . apache . velocity . util ; import java . io . InputStream ; public class ClassUtils { private ClassUtils ( ) { } public static Class getClass ( String clazz ) throws ClassNotFoundException { ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( loader != null ) { try { return Class . forName ( clazz , true , loader ) ; } catch ( ClassNotFoundException E ) { } } return Class . forName ( clazz ) ; } public static Object getNewInstance ( String clazz ) throws ClassNotFoundException , IllegalAccessException , InstantiationException { return getClass ( clazz ) . newInstance ( ) ; } public static InputStream getResourceAsStream ( Class claz , String name ) { InputStream result = null ; while ( name . startsWith ( "/" ) ) { name = name . substring ( 1 ) ; } ClassLoader classLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( classLoader == null ) { classLoader = claz . getClassLoader ( ) ; result = classLoader . getResourceAsStream ( name ) ; } else { result = classLoader . getResourceAsStream ( name ) ; if ( result == null ) { classLoader = claz . getClassLoader ( ) ; if ( classLoader != null ) result = classLoader . getResourceAsStream ( name ) ; } } return result ; } } 	1	['4', '1', '0', '9', '14', '6', '9', '0', '3', '2', '66', '0', '0', '0', '0.416666667', '0', '0', '15.5', '5', '1.75', '2']
package org . apache . velocity . runtime . parser . node ; import java . io . IOException ; import java . io . Writer ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . runtime . parser . Parser ; public class ASTBlock extends SimpleNode { public ASTBlock ( int id ) { super ( id ) ; } public ASTBlock ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException , ResourceNotFoundException , ParseErrorException { int i , k = jjtGetNumChildren ( ) ; for ( i = 0 ; i < k ; i ++ ) jjtGetChild ( i ) . render ( context , writer ) ; return true ; } } 	0	['4', '2', '0', '10', '10', '6', '4', '8', '4', '2', '37', '0', '0', '0.9375', '0.392857143', '1', '1', '8.25', '1', '0.5', '0']
package org . apache . velocity . runtime ; import java . util . Collections ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; import org . apache . velocity . runtime . directive . VelocimacroProxy ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . runtime . parser . node . SimpleNode ; import org . apache . velocity . util . MapFactory ; public class VelocimacroManager { private static String GLOBAL_NAMESPACE = "" ; private boolean registerFromLib = false ; private final Map namespaceHash = MapFactory . create ( 17 , 0.5f , 20 , false ) ; private final Map globalNamespace ; private final Set libraries = Collections . synchronizedSet ( new HashSet ( ) ) ; private boolean namespacesOn = true ; private boolean inlineLocalMode = false ; private boolean inlineReplacesGlobal = false ; VelocimacroManager ( RuntimeServices rsvc ) { globalNamespace = addNamespace ( GLOBAL_NAMESPACE ) ; } public boolean addVM ( final String vmName , final Node macroBody , final String argArray [ ] , final String namespace , boolean canReplaceGlobalMacro ) { if ( macroBody == null ) { throw new RuntimeException ( "Null AST for " + vmName + " in " + namespace ) ; } MacroEntry me = new MacroEntry ( vmName , macroBody , argArray , namespace ) ; me . setFromLibrary ( registerFromLib ) ; boolean isLib = true ; MacroEntry exist = ( MacroEntry ) globalNamespace . get ( vmName ) ; if ( registerFromLib ) { libraries . add ( namespace ) ; } else { isLib = libraries . contains ( namespace ) ; } if ( ! isLib && usingNamespaces ( namespace ) ) { Map local = getNamespace ( namespace , true ) ; local . put ( vmName , me ) ; return true ; } else { if ( exist != null ) { me . setFromLibrary ( exist . getFromLibrary ( ) ) ; } globalNamespace . put ( vmName , me ) ; return true ; } } public VelocimacroProxy get ( final String vmName , final String namespace ) { return ( get ( vmName , namespace , null ) ) ; } public VelocimacroProxy get ( final String vmName , final String namespace , final String renderingTemplate ) { if ( inlineReplacesGlobal && renderingTemplate != null ) { Map local = getNamespace ( renderingTemplate , false ) ; if ( local != null ) { MacroEntry me = ( MacroEntry ) local . get ( vmName ) ; if ( me != null ) { return me . getProxy ( namespace ) ; } } } if ( usingNamespaces ( namespace ) ) { Map local = getNamespace ( namespace , false ) ; if ( local != null ) { MacroEntry me = ( MacroEntry ) local . get ( vmName ) ; if ( me != null ) { return me . getProxy ( namespace ) ; } } } MacroEntry me = ( MacroEntry ) globalNamespace . get ( vmName ) ; if ( me != null ) { return me . getProxy ( namespace ) ; } return null ; } public boolean dumpNamespace ( final String namespace ) { synchronized ( this ) { if ( usingNamespaces ( namespace ) ) { Map h = ( Map ) namespaceHash . remove ( namespace ) ; if ( h == null ) { return false ; } h . clear ( ) ; return true ; } return false ; } } public void setNamespaceUsage ( final boolean namespaceOn ) { this . namespacesOn = namespaceOn ; } public void setRegisterFromLib ( final boolean registerFromLib ) { this . registerFromLib = registerFromLib ; } public void setTemplateLocalInlineVM ( final boolean inlineLocalMode ) { this . inlineLocalMode = inlineLocalMode ; } private Map getNamespace ( final String namespace , final boolean addIfNew ) { Map h = ( Map ) namespaceHash . get ( namespace ) ; if ( h == null && addIfNew ) { h = addNamespace ( namespace ) ; } return h ; } private Map addNamespace ( final String namespace ) { Map h = MapFactory . create ( 17 , 0.5f , 20 , false ) ; Object oh ; if ( ( oh = namespaceHash . put ( namespace , h ) ) != null ) { namespaceHash . put ( namespace , oh ) ; return null ; } return h ; } private boolean usingNamespaces ( final String namespace ) { if ( ! namespacesOn ) { return false ; } if ( inlineLocalMode ) { return true ; } return false ; } public String getLibraryName ( final String vmName , final String namespace ) { if ( usingNamespaces ( namespace ) ) { Map local = getNamespace ( namespace , false ) ; if ( local != null ) { MacroEntry me = ( MacroEntry ) local . get ( vmName ) ; if ( me != null ) { return null ; } } } MacroEntry me = ( MacroEntry ) globalNamespace . get ( vmName ) ; if ( me != null ) { return me . getSourceTemplate ( ) ; } return null ; } public void setInlineReplacesGlobal ( boolean is ) { inlineReplacesGlobal = is ; } private static class MacroEntry { private final String vmName ; private final String [ ] argArray ; private final String sourceTemplate ; private SimpleNode nodeTree = null ; private boolean fromLibrary = false ; private VelocimacroProxy vp ; private MacroEntry ( final String vmName , final Node macro , final String argArray [ ] , final String sourceTemplate ) { this . vmName = vmName ; this . argArray = argArray ; this . nodeTree = ( SimpleNode ) macro ; this . sourceTemplate = sourceTemplate ; vp = new VelocimacroProxy ( ) ; vp . setName ( this . vmName ) ; vp . setArgArray ( this . argArray ) ; vp . setNodeTree ( this . nodeTree ) ; } public void setFromLibrary ( final boolean fromLibrary ) { this . fromLibrary = fromLibrary ; } public boolean getFromLibrary ( ) { return fromLibrary ; } public SimpleNode getNodeTree ( ) { return nodeTree ; } public String getSourceTemplate ( ) { return sourceTemplate ; } VelocimacroProxy getProxy ( final String namespace ) { return vp ; } } } 	1	['14', '1', '0', '7', '33', '47', '1', '6', '9', '0.721153846', '344', '1', '0', '0', '0.384615385', '0', '0', '23', '9', '2.5714', '1']
package org . apache . velocity . runtime . parser . node ; import java . io . IOException ; import java . io . Writer ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . runtime . parser . Parser ; public class ASTElseIfStatement extends SimpleNode { public ASTElseIfStatement ( int id ) { super ( id ) ; } public ASTElseIfStatement ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { return jjtGetChild ( 0 ) . evaluate ( context ) ; } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException , ResourceNotFoundException , ParseErrorException { return jjtGetChild ( 1 ) . render ( context , writer ) ; } } 	0	['5', '2', '0', '10', '11', '10', '4', '8', '5', '2', '32', '0', '0', '0.909090909', '0.371428571', '1', '2', '5.4', '1', '0.6', '0']
package org . apache . velocity . runtime . directive ; import java . io . Writer ; import java . io . IOException ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . TemplateInitException ; public abstract class Directive implements DirectiveConstants , Cloneable { private int line = 0 ; private int column = 0 ; protected RuntimeServices rsvc = null ; public abstract String getName ( ) ; public abstract int getType ( ) ; public void setLocation ( int line , int column ) { this . line = line ; this . column = column ; } public int getLine ( ) { return line ; } public int getColumn ( ) { return column ; } public void init ( RuntimeServices rs , InternalContextAdapter context , Node node ) throws TemplateInitException { rsvc = rs ; } public abstract boolean render ( InternalContextAdapter context , Writer writer , Node node ) throws IOException , ResourceNotFoundException , ParseErrorException , MethodInvocationException ; } 	1	['10', '1', '9', '26', '11', '31', '19', '8', '10', '0.777777778', '54', '1', '1', '0', '0.271428571', '0', '0', '4', '1', '0.9', '3']
package org . apache . velocity . runtime . parser . node ; import org . apache . commons . lang . text . StrBuilder ; import org . apache . velocity . context . Context ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . runtime . parser . ParserConstants ; import org . apache . velocity . runtime . parser . Token ; public class NodeUtils { public static String specialText ( Token t ) { if ( t . specialToken == null || t . specialToken . image . startsWith ( "##" ) ) { return "" ; } return getSpecialText ( t ) . toString ( ) ; } public static StrBuilder getSpecialText ( Token t ) { StrBuilder sb = new StrBuilder ( ) ; Token tmp_t = t . specialToken ; while ( tmp_t . specialToken != null ) { tmp_t = tmp_t . specialToken ; } while ( tmp_t != null ) { String st = tmp_t . image ; for ( int i = 0 , is = st . length ( ) ; i < is ; i ++ ) { char c = st . charAt ( i ) ; if ( c == '#' || c == '$' ) { sb . append ( c ) ; } if ( c == '\\' ) { boolean ok = true ; boolean term = false ; int j = i ; for ( ok = true ; ok && j < is ; j ++ ) { char cc = st . charAt ( j ) ; if ( cc == '\\' ) { continue ; } else if ( cc == '$' ) { term = true ; ok = false ; } else { ok = false ; } } if ( term ) { String foo = st . substring ( i , j ) ; sb . append ( foo ) ; i = j ; } } } tmp_t = tmp_t . next ; } return sb ; } public static String tokenLiteral ( Token t ) { if ( t . kind == ParserConstants . MULTI_LINE_COMMENT ) { return "" ; } else if ( t . specialToken == null || t . specialToken . image . startsWith ( "##" ) ) { return t . image ; } else { StrBuilder special = getSpecialText ( t ) ; if ( special . length ( ) > 0 ) { return special . append ( t . image ) . toString ( ) ; } return t . image ; } } public static String interpolate ( String argStr , Context vars ) throws MethodInvocationException { if ( argStr . indexOf ( '$' ) == - 1 ) return argStr ; StrBuilder argBuf = new StrBuilder ( ) ; for ( int cIdx = 0 , is = argStr . length ( ) ; cIdx < is ; ) { char ch = argStr . charAt ( cIdx ) ; if ( ch == '$' ) { StrBuilder nameBuf = new StrBuilder ( ) ; for ( ++ cIdx ; cIdx < is ; ++ cIdx ) { ch = argStr . charAt ( cIdx ) ; if ( ch == '_' || ch == '-' || Character . isLetterOrDigit ( ch ) ) nameBuf . append ( ch ) ; else if ( ch == '{' || ch == '}' ) continue ; else break ; } if ( nameBuf . length ( ) > 0 ) { Object value = vars . get ( nameBuf . toString ( ) ) ; if ( value == null ) argBuf . append ( "$" ) . append ( nameBuf . toString ( ) ) ; else argBuf . append ( value . toString ( ) ) ; } } else { argBuf . append ( ch ) ; ++ cIdx ; } } return argBuf . toString ( ) ; } } 	0	['5', '1', '0', '6', '19', '10', '2', '4', '5', '2', '247', '0', '0', '0', '0.3', '0', '0', '48.4', '12', '4.2', '0']
package org . apache . velocity . runtime . directive ; import java . io . IOException ; import java . io . Writer ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . parser . node . Node ; public class Literal extends Directive { String literalText ; public String getName ( ) { return "literal" ; } public int getType ( ) { return BLOCK ; } public void init ( RuntimeServices rs , InternalContextAdapter context , Node node ) throws TemplateInitException { super . init ( rs , context , node ) ; literalText = node . jjtGetChild ( 0 ) . literal ( ) ; } public boolean render ( InternalContextAdapter context , Writer writer , Node node ) throws IOException { writer . write ( literalText ) ; return true ; } } 	1	['5', '2', '0', '5', '10', '8', '0', '5', '5', '0.75', '31', '0', '0', '0.692307692', '0.44', '0', '0', '5', '1', '0.8', '2']
package org . apache . velocity . anakia ; public class Escape { public static final String LINE_SEPARATOR = System . getProperty ( "line.separator" ) ; public Escape ( ) { } public static final String getText ( String st ) { StringBuffer buff = new StringBuffer ( ) ; char [ ] block = st . toCharArray ( ) ; String stEntity = null ; int i , last ; for ( i = 0 , last = 0 ; i < block . length ; i ++ ) { switch ( block [ i ] ) { case '<' : stEntity = "&lt;" ; break ; case '>' : stEntity = "&gt;" ; break ; case '&' : stEntity = "&amp;" ; break ; case '"' : stEntity = "&quot;" ; break ; case '\n' : stEntity = LINE_SEPARATOR ; break ; default : break ; } if ( stEntity != null ) { buff . append ( block , last , i - last ) ; buff . append ( stEntity ) ; stEntity = null ; last = i + 1 ; } } if ( last < block . length ) { buff . append ( block , last , i - last ) ; } return buff . toString ( ) ; } } 	0	['3', '1', '0', '1', '10', '1', '1', '0', '2', '0.5', '84', '0', '0', '0', '0.5', '0', '0', '26.66666667', '10', '3.3333', '0']
package org . apache . velocity . runtime . parser . node ; import java . util . Map ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . runtime . log . Log ; public class MapSetExecutor extends SetExecutor { private final String property ; public MapSetExecutor ( final Log log , final Class clazz , final String property ) { this . log = log ; this . property = property ; discover ( clazz ) ; } protected void discover ( final Class clazz ) { Class [ ] interfaces = clazz . getInterfaces ( ) ; for ( int i = 0 ; i < interfaces . length ; i ++ ) { if ( interfaces [ i ] . equals ( Map . class ) ) { try { if ( property != null ) { setMethod ( Map . class . getMethod ( "put" , new Class [ ] { Object . class , Object . class } ) ) ; } } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { String msg = "Exception while looking for put('" + property + "') method" ; log . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } break ; } } } public Object execute ( final Object o , final Object arg ) { return ( ( Map ) o ) . put ( property , arg ) ; } } 	1	['4', '2', '0', '4', '18', '0', '1', '3', '2', '0.555555556', '128', '0.333333333', '0', '0.571428571', '0.45', '0', '0', '30.25', '7', '2.25', '1']
package org . apache . velocity . runtime ; import java . io . StringReader ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Vector ; import java . util . ArrayList ; import org . apache . commons . lang . StringUtils ; import org . apache . velocity . Template ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . runtime . directive . Directive ; import org . apache . velocity . runtime . directive . Macro ; import org . apache . velocity . runtime . directive . VelocimacroProxy ; import org . apache . velocity . runtime . log . LogDisplayWrapper ; import org . apache . velocity . runtime . parser . ParseException ; import org . apache . velocity . runtime . parser . node . Node ; public class VelocimacroFactory { private final RuntimeServices rsvc ; private final LogDisplayWrapper log ; private VelocimacroManager vmManager = null ; private boolean replaceAllowed = false ; private boolean addNewAllowed = true ; private boolean templateLocal = false ; private boolean autoReloadLibrary = false ; private List macroLibVec = null ; private Map libModMap ; public VelocimacroFactory ( final RuntimeServices rsvc ) { this . rsvc = rsvc ; this . log = new LogDisplayWrapper ( rsvc . getLog ( ) , "Velocimacro : " , rsvc . getBoolean ( RuntimeConstants . VM_MESSAGES_ON , true ) ) ; libModMap = new HashMap ( ) ; vmManager = new VelocimacroManager ( rsvc ) ; } public void initVelocimacro ( ) { synchronized ( this ) { log . trace ( "initialization starting." ) ; setReplacementPermission ( true ) ; vmManager . setNamespaceUsage ( false ) ; Object libfiles = rsvc . getProperty ( RuntimeConstants . VM_LIBRARY ) ; if ( libfiles == null ) { log . debug ( "\"" + RuntimeConstants . VM_LIBRARY + "\" is not set.  Trying default library: " + RuntimeConstants . VM_LIBRARY_DEFAULT ) ; if ( rsvc . getLoaderNameForResource ( RuntimeConstants . VM_LIBRARY_DEFAULT ) != null ) { libfiles = RuntimeConstants . VM_LIBRARY_DEFAULT ; } else { log . debug ( "Default library not found." ) ; } } if ( libfiles != null ) { macroLibVec = new ArrayList ( ) ; if ( libfiles instanceof Vector ) { macroLibVec . addAll ( ( Vector ) libfiles ) ; } else if ( libfiles instanceof String ) { macroLibVec . add ( libfiles ) ; } for ( int i = 0 , is = macroLibVec . size ( ) ; i < is ; i ++ ) { String lib = ( String ) macroLibVec . get ( i ) ; if ( StringUtils . isNotEmpty ( lib ) ) { vmManager . setRegisterFromLib ( true ) ; log . debug ( "adding VMs from VM library : " + lib ) ; try { Template template = rsvc . getTemplate ( lib ) ; Twonk twonk = new Twonk ( ) ; twonk . template = template ; twonk . modificationTime = template . getLastModified ( ) ; libModMap . put ( lib , twonk ) ; } catch ( Exception e ) { String msg = "Velocimacro : Error using VM library : " + lib ; log . error ( true , msg , e ) ; throw new VelocityException ( msg , e ) ; } log . trace ( "VM library registration complete." ) ; vmManager . setRegisterFromLib ( false ) ; } } } setAddMacroPermission ( true ) ; if ( ! rsvc . getBoolean ( RuntimeConstants . VM_PERM_ALLOW_INLINE , true ) ) { setAddMacroPermission ( false ) ; log . debug ( "allowInline = false : VMs can NOT be defined inline in templates" ) ; } else { log . debug ( "allowInline = true : VMs can be defined inline in templates" ) ; } setReplacementPermission ( false ) ; if ( rsvc . getBoolean ( RuntimeConstants . VM_PERM_ALLOW_INLINE_REPLACE_GLOBAL , false ) ) { setReplacementPermission ( true ) ; log . debug ( "allowInlineToOverride = true : VMs " + "defined inline may replace previous VM definitions" ) ; } else { log . debug ( "allowInlineToOverride = false : VMs " + "defined inline may NOT replace previous VM definitions" ) ; } vmManager . setNamespaceUsage ( true ) ; setTemplateLocalInline ( rsvc . getBoolean ( RuntimeConstants . VM_PERM_INLINE_LOCAL , false ) ) ; if ( getTemplateLocalInline ( ) ) { log . debug ( "allowInlineLocal = true : VMs " + "defined inline will be local to their defining template only." ) ; } else { log . debug ( "allowInlineLocal = false : VMs " + "defined inline will be global in scope if allowed." ) ; } vmManager . setTemplateLocalInlineVM ( getTemplateLocalInline ( ) ) ; setAutoload ( rsvc . getBoolean ( RuntimeConstants . VM_LIBRARY_AUTORELOAD , false ) ) ; if ( getAutoload ( ) ) { log . debug ( "autoload on : VM system " + "will automatically reload global library macros" ) ; } else { log . debug ( "autoload off : VM system " + "will not automatically reload global library macros" ) ; } log . trace ( "Velocimacro : initialization complete." ) ; } } public boolean addVelocimacro ( String name , String macroBody , String argArray [ ] , String sourceTemplate ) { if ( name == null || macroBody == null || argArray == null || sourceTemplate == null ) { String msg = "VM '" + name + "' addition rejected : " ; if ( name == null ) { msg += "name" ; } else if ( macroBody == null ) { msg += "macroBody" ; } else if ( argArray == null ) { msg += "argArray" ; } else { msg += "sourceTemplate" ; } msg += " argument was null" ; log . error ( msg ) ; throw new NullPointerException ( msg ) ; } if ( ! canAddVelocimacro ( name , sourceTemplate ) ) { return false ; } synchronized ( this ) { try { Node macroRootNode = rsvc . parse ( new StringReader ( macroBody ) , sourceTemplate ) ; vmManager . addVM ( name , macroRootNode , argArray , sourceTemplate , replaceAllowed ) ; } catch ( ParseException ex ) { throw new RuntimeException ( ex . toString ( ) ) ; } } if ( log . isDebugEnabled ( ) ) { StringBuffer msg = new StringBuffer ( "added " ) ; Macro . macroToString ( msg , argArray ) ; msg . append ( " : source = " ) . append ( sourceTemplate ) ; log . debug ( msg . toString ( ) ) ; } return true ; } public boolean addVelocimacro ( String name , Node macroBody , String argArray [ ] , String sourceTemplate ) { if ( name == null || macroBody == null || argArray == null || sourceTemplate == null ) { String msg = "VM '" + name + "' addition rejected : " ; if ( name == null ) { msg += "name" ; } else if ( macroBody == null ) { msg += "macroBody" ; } else if ( argArray == null ) { msg += "argArray" ; } else { msg += "sourceTemplate" ; } msg += " argument was null" ; log . error ( msg ) ; throw new NullPointerException ( msg ) ; } if ( ! canAddVelocimacro ( name , sourceTemplate ) ) { return false ; } synchronized ( this ) { vmManager . addVM ( name , macroBody , argArray , sourceTemplate , replaceAllowed ) ; } return ( true ) ; } private synchronized boolean canAddVelocimacro ( String name , String sourceTemplate ) { if ( autoReloadLibrary && ( macroLibVec != null ) ) { if ( macroLibVec . contains ( sourceTemplate ) ) return true ; } if ( ! addNewAllowed ) { log . warn ( "VM addition rejected : " + name + " : inline VMs not allowed." ) ; return false ; } if ( ! templateLocal ) { if ( ! replaceAllowed && isVelocimacro ( name , sourceTemplate ) ) { if ( log . isDebugEnabled ( ) ) log . debug ( "VM addition rejected : " + name + " : inline not allowed to replace existing VM" ) ; return false ; } } return true ; } public boolean isVelocimacro ( String vm , String sourceTemplate ) { return ( vmManager . get ( vm , sourceTemplate ) != null ) ; } public Directive getVelocimacro ( String vmName , String sourceTemplate ) { return ( getVelocimacro ( vmName , sourceTemplate , null ) ) ; } public Directive getVelocimacro ( String vmName , String sourceTemplate , String renderingTemplate ) { VelocimacroProxy vp = null ; vp = vmManager . get ( vmName , sourceTemplate , renderingTemplate ) ; if ( vp != null && autoReloadLibrary ) { synchronized ( this ) { String lib = vmManager . getLibraryName ( vmName , sourceTemplate ) ; if ( lib != null ) { try { Twonk tw = ( Twonk ) libModMap . get ( lib ) ; if ( tw != null ) { Template template = tw . template ; long tt = tw . modificationTime ; long ft = template . getResourceLoader ( ) . getLastModified ( template ) ; if ( ft > tt ) { log . debug ( "auto-reloading VMs from VM library : " + lib ) ; tw . modificationTime = ft ; template = rsvc . getTemplate ( lib ) ; tw . template = template ; tw . modificationTime = template . getLastModified ( ) ; } } } catch ( Exception e ) { String msg = "Velocimacro : Error using VM library : " + lib ; log . error ( true , msg , e ) ; throw new VelocityException ( msg , e ) ; } vp = vmManager . get ( vmName , sourceTemplate , renderingTemplate ) ; } } } return vp ; } public boolean dumpVMNamespace ( String namespace ) { return vmManager . dumpNamespace ( namespace ) ; } private void setTemplateLocalInline ( boolean b ) { templateLocal = b ; } private boolean getTemplateLocalInline ( ) { return templateLocal ; } private boolean setAddMacroPermission ( final boolean addNewAllowed ) { boolean b = this . addNewAllowed ; this . addNewAllowed = addNewAllowed ; return b ; } private boolean setReplacementPermission ( boolean arg ) { boolean b = replaceAllowed ; replaceAllowed = arg ; vmManager . setInlineReplacesGlobal ( arg ) ; return b ; } private void setAutoload ( boolean b ) { autoReloadLibrary = b ; } private boolean getAutoload ( ) { return autoReloadLibrary ; } private static class Twonk { public Template template ; public long modificationTime ; } } 	0	['15', '1', '0', '18', '63', '9', '1', '17', '8', '0.603174603', '830', '1', '3', '0', '0.333333333', '0', '0', '53.73333333', '12', '3.6', '0']
package org . apache . velocity . runtime . directive ; import org . apache . commons . lang . text . StrBuilder ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . runtime . parser . Token ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . util . introspection . Info ; import java . io . Writer ; import java . io . IOException ; import java . util . List ; public class RuntimeMacro extends Directive { private String macroName ; private String sourceTemplate ; private String literal = null ; private Node node = null ; protected boolean strictRef = false ; public RuntimeMacro ( String macroName , String sourceTemplate ) { if ( macroName == null || sourceTemplate == null ) { throw new IllegalArgumentException ( "Null arguments" ) ; } this . macroName = macroName ; this . sourceTemplate = sourceTemplate ; } public String getName ( ) { return macroName ; } public int getType ( ) { return LINE ; } public void init ( RuntimeServices rs , InternalContextAdapter context , Node node ) { super . init ( rs , context , node ) ; rsvc = rs ; this . node = node ; Token t = node . getLastToken ( ) ; if ( t . image . charAt ( 0 ) == ')' ) { strictRef = rsvc . getBoolean ( RuntimeConstants . RUNTIME_REFERENCES_STRICT , false ) ; } } private String getLiteral ( ) { if ( literal == null ) { StrBuilder buffer = new StrBuilder ( ) ; Token t = node . getFirstToken ( ) ; while ( t != null && t != node . getLastToken ( ) ) { buffer . append ( t . image ) ; t = t . next ; } if ( t != null ) { buffer . append ( t . image ) ; } literal = buffer . toString ( ) ; } return literal ; } public boolean render ( InternalContextAdapter context , Writer writer , Node node ) throws IOException , ResourceNotFoundException , ParseErrorException , MethodInvocationException { VelocimacroProxy vmProxy = null ; String renderingTemplate = context . getCurrentTemplateName ( ) ; Object o = rsvc . getVelocimacro ( macroName , sourceTemplate , renderingTemplate ) ; if ( o != null ) { vmProxy = ( VelocimacroProxy ) o ; } if ( vmProxy == null ) { List macroLibraries = context . getMacroLibraries ( ) ; if ( macroLibraries != null ) { for ( int i = macroLibraries . size ( ) - 1 ; i >= 0 ; i -- ) { o = rsvc . getVelocimacro ( macroName , ( String ) macroLibraries . get ( i ) , renderingTemplate ) ; if ( o != null ) { vmProxy = ( VelocimacroProxy ) o ; break ; } } } } if ( vmProxy != null ) { try { vmProxy . init ( rsvc , context , node ) ; } catch ( TemplateInitException die ) { Info info = new Info ( sourceTemplate , node . getLine ( ) , node . getColumn ( ) ) ; throw new ParseErrorException ( die . getMessage ( ) + " at " + Log . formatFileString ( info ) , info ) ; } try { return vmProxy . render ( context , writer , node ) ; } catch ( RuntimeException e ) { rsvc . getLog ( ) . error ( "Exception in macro #" + macroName + " at " + Log . formatFileString ( sourceTemplate , getLine ( ) , getColumn ( ) ) ) ; throw e ; } catch ( IOException e ) { rsvc . getLog ( ) . error ( "Exception in macro #" + macroName + " at " + Log . formatFileString ( sourceTemplate , getLine ( ) , getColumn ( ) ) ) ; throw e ; } } else if ( strictRef ) { Info info = new Info ( sourceTemplate , node . getLine ( ) , node . getColumn ( ) ) ; throw new ParseErrorException ( "Macro '#" + macroName + "' is not defined at " + Log . formatFileString ( info ) , info ) ; } writer . write ( getLiteral ( ) ) ; return true ; } } 	1	['6', '2', '0', '14', '38', '1', '1', '13', '5', '0.6', '297', '1', '1', '0.642857143', '0.361111111', '0', '0', '47.66666667', '5', '1.6667', '6']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; public class ASTAddNode extends ASTMathNode { public ASTAddNode ( int id ) { super ( id ) ; } public ASTAddNode ( Parser p , int id ) { super ( p , id ) ; } protected Object handleSpecial ( Object left , Object right , InternalContextAdapter context ) { if ( left instanceof String || right instanceof String ) { if ( left == null ) { left = jjtGetChild ( 0 ) . literal ( ) ; } else if ( right == null ) { right = jjtGetChild ( 1 ) . literal ( ) ; } return left . toString ( ) . concat ( right . toString ( ) ) ; } return null ; } public Number perform ( Number left , Number right , InternalContextAdapter context ) { return MathUtils . add ( left , right ) ; } } 	0	['4', '3', '0', '8', '11', '6', '4', '5', '3', '2', '46', '0', '0', '0.945945946', '0.458333333', '2', '3', '10.5', '5', '1.5', '0']
package org . apache . velocity . context ; import java . util . HashMap ; import java . util . Stack ; import java . util . List ; import org . apache . velocity . app . event . EventCartridge ; import org . apache . velocity . runtime . resource . Resource ; import org . apache . velocity . util . introspection . IntrospectionCacheData ; class InternalContextBase implements InternalHousekeepingContext , InternalEventContext { private static final long serialVersionUID = - 245905472770843470L ; private HashMap introspectionCache = new HashMap ( 33 ) ; private Stack templateNameStack = new Stack ( ) ; private Stack macroNameStack = new Stack ( ) ; private EventCartridge eventCartridge = null ; private Resource currentResource = null ; private boolean allowRendering = true ; private List macroLibraries = null ; public void pushCurrentTemplateName ( String s ) { templateNameStack . push ( s ) ; } public void popCurrentTemplateName ( ) { templateNameStack . pop ( ) ; } public String getCurrentTemplateName ( ) { if ( templateNameStack . empty ( ) ) return "<undef>" ; else return ( String ) templateNameStack . peek ( ) ; } public Object [ ] getTemplateNameStack ( ) { return templateNameStack . toArray ( ) ; } public void pushCurrentMacroName ( String s ) { macroNameStack . push ( s ) ; } public void popCurrentMacroName ( ) { macroNameStack . pop ( ) ; } public String getCurrentMacroName ( ) { if ( macroNameStack . empty ( ) ) { return "<undef>" ; } else { return ( String ) macroNameStack . peek ( ) ; } } public int getCurrentMacroCallDepth ( ) { return macroNameStack . size ( ) ; } public Object [ ] getMacroNameStack ( ) { return macroNameStack . toArray ( ) ; } public IntrospectionCacheData icacheGet ( Object key ) { return ( IntrospectionCacheData ) introspectionCache . get ( key ) ; } public void icachePut ( Object key , IntrospectionCacheData o ) { introspectionCache . put ( key , o ) ; } public void setCurrentResource ( Resource r ) { currentResource = r ; } public Resource getCurrentResource ( ) { return currentResource ; } public boolean getAllowRendering ( ) { return allowRendering ; } public void setAllowRendering ( boolean v ) { allowRendering = v ; } public void setMacroLibraries ( List macroLibraries ) { this . macroLibraries = macroLibraries ; } public List getMacroLibraries ( ) { return macroLibraries ; } public EventCartridge attachEventCartridge ( EventCartridge ec ) { EventCartridge temp = eventCartridge ; eventCartridge = ec ; return temp ; } public EventCartridge getEventCartridge ( ) { return eventCartridge ; } } 	1	['20', '1', '1', '7', '31', '110', '2', '5', '19', '0.881578947', '160', '1', '2', '0', '0.18125', '0', '0', '6.6', '2', '1.05', '1']
package org . apache . velocity . app ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . HashMap ; import org . apache . velocity . util . ClassUtils ; public class FieldMethodizer { private HashMap fieldHash = new HashMap ( ) ; public FieldMethodizer ( ) { } public FieldMethodizer ( String s ) { try { addObject ( s ) ; } catch ( Exception e ) { System . err . println ( "Could not add " + s + " for field methodizing: " + e . getMessage ( ) ) ; } } public FieldMethodizer ( Object o ) { try { addObject ( o ) ; } catch ( Exception e ) { System . err . println ( "Could not add " + o + " for field methodizing: " + e . getMessage ( ) ) ; } } public void addObject ( String s ) throws Exception { inspect ( ClassUtils . getClass ( s ) ) ; } public void addObject ( Object o ) throws Exception { inspect ( o . getClass ( ) ) ; } public Object get ( String fieldName ) { Object value = null ; try { Field f = ( Field ) fieldHash . get ( fieldName ) ; if ( f != null ) { value = f . get ( null ) ; } } catch ( IllegalAccessException e ) { System . err . println ( "IllegalAccessException while trying to access " + fieldName + ": " + e . getMessage ( ) ) ; } return value ; } private void inspect ( Class clas ) { Field [ ] fields = clas . getFields ( ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { int mod = fields [ i ] . getModifiers ( ) ; if ( Modifier . isStatic ( mod ) && Modifier . isPublic ( mod ) ) { fieldHash . put ( fields [ i ] . getName ( ) , fields [ i ] ) ; } } } } 	0	['7', '1', '0', '1', '26', '1', '0', '1', '6', '0', '149', '1', '0', '0', '0.464285714', '0', '0', '20.14285714', '4', '1', '0']
package org . apache . velocity . runtime . visitor ; import java . io . Writer ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . node . ASTAddNode ; import org . apache . velocity . runtime . parser . node . ASTAndNode ; import org . apache . velocity . runtime . parser . node . ASTAssignment ; import org . apache . velocity . runtime . parser . node . ASTBlock ; import org . apache . velocity . runtime . parser . node . ASTComment ; import org . apache . velocity . runtime . parser . node . ASTDirective ; import org . apache . velocity . runtime . parser . node . ASTDivNode ; import org . apache . velocity . runtime . parser . node . ASTEQNode ; import org . apache . velocity . runtime . parser . node . ASTElseIfStatement ; import org . apache . velocity . runtime . parser . node . ASTElseStatement ; import org . apache . velocity . runtime . parser . node . ASTEscape ; import org . apache . velocity . runtime . parser . node . ASTEscapedDirective ; import org . apache . velocity . runtime . parser . node . ASTExpression ; import org . apache . velocity . runtime . parser . node . ASTFalse ; import org . apache . velocity . runtime . parser . node . ASTFloatingPointLiteral ; import org . apache . velocity . runtime . parser . node . ASTGENode ; import org . apache . velocity . runtime . parser . node . ASTGTNode ; import org . apache . velocity . runtime . parser . node . ASTIdentifier ; import org . apache . velocity . runtime . parser . node . ASTIfStatement ; import org . apache . velocity . runtime . parser . node . ASTIntegerLiteral ; import org . apache . velocity . runtime . parser . node . ASTIntegerRange ; import org . apache . velocity . runtime . parser . node . ASTLENode ; import org . apache . velocity . runtime . parser . node . ASTLTNode ; import org . apache . velocity . runtime . parser . node . ASTMap ; import org . apache . velocity . runtime . parser . node . ASTMethod ; import org . apache . velocity . runtime . parser . node . ASTModNode ; import org . apache . velocity . runtime . parser . node . ASTMulNode ; import org . apache . velocity . runtime . parser . node . ASTNENode ; import org . apache . velocity . runtime . parser . node . ASTNotNode ; import org . apache . velocity . runtime . parser . node . ASTObjectArray ; import org . apache . velocity . runtime . parser . node . ASTOrNode ; import org . apache . velocity . runtime . parser . node . ASTReference ; import org . apache . velocity . runtime . parser . node . ASTSetDirective ; import org . apache . velocity . runtime . parser . node . ASTStop ; import org . apache . velocity . runtime . parser . node . ASTStringLiteral ; import org . apache . velocity . runtime . parser . node . ASTSubtractNode ; import org . apache . velocity . runtime . parser . node . ASTText ; import org . apache . velocity . runtime . parser . node . ASTTrue ; import org . apache . velocity . runtime . parser . node . ASTWord ; import org . apache . velocity . runtime . parser . node . ASTprocess ; import org . apache . velocity . runtime . parser . node . ParserVisitor ; import org . apache . velocity . runtime . parser . node . SimpleNode ; public abstract class BaseVisitor implements ParserVisitor { protected InternalContextAdapter context ; protected Writer writer ; public void setWriter ( Writer writer ) { this . writer = writer ; } public void setContext ( InternalContextAdapter context ) { this . context = context ; } public Object visit ( SimpleNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTprocess node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTExpression node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTAssignment node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTOrNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTAndNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTEQNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTNENode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTLTNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTGTNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTLENode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTGENode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTAddNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTSubtractNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTMulNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTDivNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTModNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTNotNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTIntegerLiteral node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTFloatingPointLiteral node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTStringLiteral node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTIdentifier node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTMethod node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTReference node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTTrue node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTFalse node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTBlock node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTText node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTIfStatement node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTElseStatement node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTElseIfStatement node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTComment node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTObjectArray node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTWord node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTSetDirective node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTDirective node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTEscapedDirective node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTEscape node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTMap node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTIntegerRange node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTStop node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } } 	1	['44', '1', '1', '44', '86', '946', '1', '43', '44', '1', '344', '1', '1', '0', '0.064646465', '0', '0', '6.772727273', '1', '0.9773', '1']
package org . apache . velocity . exception ; public class MathException extends VelocityException { public MathException ( final String exceptionMessage ) { super ( exceptionMessage ) ; } } 	0	['1', '5', '0', '4', '2', '0', '3', '1', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . apache . velocity . runtime . resource . loader ; import java . io . InputStream ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . resource . Resource ; import org . apache . velocity . runtime . resource . ResourceCacheImpl ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . VelocityException ; import org . apache . commons . collections . ExtendedProperties ; public abstract class ResourceLoader { protected boolean isCachingOn = false ; protected long modificationCheckInterval = 2 ; protected String className = null ; protected RuntimeServices rsvc = null ; protected Log log = null ; public void commonInit ( RuntimeServices rs , ExtendedProperties configuration ) { this . rsvc = rs ; this . log = rsvc . getLog ( ) ; try { isCachingOn = configuration . getBoolean ( "cache" , false ) ; } catch ( Exception e ) { isCachingOn = false ; String msg = "Exception parsing cache setting: " + configuration . getString ( "cache" ) ; log . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } try { modificationCheckInterval = configuration . getLong ( "modificationCheckInterval" , 0 ) ; } catch ( Exception e ) { modificationCheckInterval = 0 ; String msg = "Exception parsing modificationCheckInterval setting: " + configuration . getString ( "modificationCheckInterval" ) ; log . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } className = ResourceCacheImpl . class . getName ( ) ; try { className = configuration . getString ( "class" , className ) ; } catch ( Exception e ) { String msg = "Exception retrieving resource cache class name" ; log . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } } public abstract void init ( ExtendedProperties configuration ) ; public abstract InputStream getResourceStream ( String source ) throws ResourceNotFoundException ; public abstract boolean isSourceModified ( Resource resource ) ; public abstract long getLastModified ( Resource resource ) ; public String getClassName ( ) { return className ; } public void setCachingOn ( boolean value ) { isCachingOn = value ; } public boolean isCachingOn ( ) { return isCachingOn ; } public void setModificationCheckInterval ( long modificationCheckInterval ) { this . modificationCheckInterval = modificationCheckInterval ; } public long getModificationCheckInterval ( ) { return modificationCheckInterval ; } public boolean resourceExists ( final String resourceName ) { InputStream is = null ; try { is = getResourceStream ( resourceName ) ; } catch ( ResourceNotFoundException e ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Could not load resource '" + resourceName + "' from ResourceLoader " + this . getClass ( ) . getName ( ) + ": " , e ) ; } } finally { try { if ( is != null ) { is . close ( ) ; } } catch ( Exception e ) { if ( log . isErrorEnabled ( ) ) { String msg = "While closing InputStream for resource '" + resourceName + "' from ResourceLoader " + this . getClass ( ) . getName ( ) ; log . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } } } return ( is != null ) ; } } 	1	['13', '1', '6', '17', '33', '48', '12', '6', '12', '0.847222222', '255', '0.833333333', '2', '0', '0.241758242', '0', '0', '18.15384615', '7', '1.4615', '1']
package org . apache . velocity . util . introspection ; import java . lang . reflect . Method ; import org . apache . velocity . runtime . log . Log ; public class SecureIntrospectorImpl extends Introspector implements SecureIntrospectorControl { private String [ ] badClasses ; private String [ ] badPackages ; public SecureIntrospectorImpl ( String [ ] badClasses , String [ ] badPackages , Log log ) { super ( log ) ; this . badClasses = badClasses ; this . badPackages = badPackages ; } public Method getMethod ( Class clazz , String methodName , Object [ ] params ) throws IllegalArgumentException { if ( ! checkObjectExecutePermission ( clazz , methodName ) ) { log . warn ( "Cannot retrieve method " + methodName + " from object of class " + clazz . getName ( ) + " due to security restrictions." ) ; return null ; } else { return super . getMethod ( clazz , methodName , params ) ; } } public boolean checkObjectExecutePermission ( Class clazz , String methodName ) { if ( methodName != null && ( methodName . equals ( "wait" ) || methodName . equals ( "notify" ) ) ) { return false ; } else if ( Number . class . isAssignableFrom ( clazz ) ) { return true ; } else if ( Boolean . class . isAssignableFrom ( clazz ) ) { return true ; } else if ( String . class . isAssignableFrom ( clazz ) ) { return true ; } else if ( Class . class . isAssignableFrom ( clazz ) && ( methodName != null ) && methodName . equals ( "getName" ) ) { return true ; } String className = clazz . getName ( ) ; if ( className . startsWith ( "[L" ) && className . endsWith ( ";" ) ) { className = className . substring ( 2 , className . length ( ) - 1 ) ; } int dotPos = className . lastIndexOf ( '.' ) ; String packageName = ( dotPos == - 1 ) ? "" : className . substring ( 0 , dotPos ) ; for ( int i = 0 , size = badPackages . length ; i < size ; i ++ ) { if ( packageName . equals ( badPackages [ i ] ) ) { return false ; } } for ( int i = 0 , size = badClasses . length ; i < size ; i ++ ) { if ( className . equals ( badClasses [ i ] ) ) { return false ; } } return true ; } } 	0	['4', '3', '0', '4', '21', '4', '1', '3', '3', '0.555555556', '206', '0.333333333', '0', '0.5', '0.458333333', '1', '1', '49', '21', '5.75', '0']
package org . apache . velocity . runtime . log ; import java . io . File ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import org . apache . commons . lang . StringUtils ; import org . apache . log . Hierarchy ; import org . apache . log . LogTarget ; import org . apache . log . Logger ; import org . apache . log . Priority ; import org . apache . log . output . io . FileTarget ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeServices ; public class AvalonLogChute implements LogChute { public static final String AVALON_LOGGER = "runtime.log.logsystem.avalon.logger" ; public static final String AVALON_LOGGER_FORMAT = "runtime.log.logsystem.avalon.format" ; public static final String AVALON_LOGGER_LEVEL = "runtime.log.logsystem.avalon.level" ; private Logger logger = null ; private RuntimeServices rsvc = null ; private static final Map logLevels = new HashMap ( ) ; static { logLevels . put ( "trace" , Priority . DEBUG ) ; logLevels . put ( "debug" , Priority . DEBUG ) ; logLevels . put ( "info" , Priority . INFO ) ; logLevels . put ( "warn" , Priority . WARN ) ; logLevels . put ( "error" , Priority . ERROR ) ; } public void init ( RuntimeServices rs ) throws Exception { this . rsvc = rs ; String name = ( String ) rsvc . getProperty ( AVALON_LOGGER ) ; if ( name != null ) { this . logger = Hierarchy . getDefaultHierarchy ( ) . getLoggerFor ( name ) ; } else { logger = Hierarchy . getDefaultHierarchy ( ) . getLoggerFor ( rsvc . toString ( ) ) ; String file = ( String ) rsvc . getProperty ( RuntimeConstants . RUNTIME_LOG ) ; if ( StringUtils . isNotEmpty ( file ) ) { initTarget ( file , rsvc ) ; } } } private void initTarget ( final String file , final RuntimeServices rsvc ) throws Exception { try { String format = null ; Priority level = null ; if ( rsvc != null ) { format = rsvc . getString ( AVALON_LOGGER_FORMAT , "%{time} %{message}\\n%{throwable}" ) ; level = ( Priority ) logLevels . get ( rsvc . getString ( AVALON_LOGGER_LEVEL , "warn" ) ) ; } VelocityFormatter vf = new VelocityFormatter ( format ) ; FileTarget target = new FileTarget ( new File ( file ) , false , vf ) ; logger . setPriority ( level ) ; logger . setLogTargets ( new LogTarget [ ] { target } ) ; log ( DEBUG_ID , "AvalonLogChute initialized using file '" + file + '\'' ) ; } catch ( IOException ioe ) { rsvc . getLog ( ) . error ( "Unable to create log file for AvalonLogChute" , ioe ) ; throw new Exception ( "Error configuring AvalonLogChute : " + ioe ) ; } } public void init ( String file ) throws Exception { logger = Hierarchy . getDefaultHierarchy ( ) . getLoggerFor ( rsvc . toString ( ) ) ; initTarget ( file , null ) ; log ( DEBUG_ID , "You shouldn't be using the init(String file) method!" ) ; } public void log ( int level , String message ) { switch ( level ) { case WARN_ID : logger . warn ( WARN_PREFIX + message ) ; break ; case INFO_ID : logger . info ( INFO_PREFIX + message ) ; break ; case DEBUG_ID : logger . debug ( DEBUG_PREFIX + message ) ; break ; case TRACE_ID : logger . debug ( TRACE_PREFIX + message ) ; break ; case ERROR_ID : logger . error ( ERROR_PREFIX + message ) ; break ; default : logger . info ( message ) ; break ; } } public void log ( int level , String message , Throwable t ) { switch ( level ) { case WARN_ID : logger . warn ( WARN_PREFIX + message , t ) ; break ; case INFO_ID : logger . info ( INFO_PREFIX + message , t ) ; break ; case DEBUG_ID : logger . debug ( DEBUG_PREFIX + message , t ) ; break ; case TRACE_ID : logger . debug ( TRACE_PREFIX + message , t ) ; break ; case ERROR_ID : logger . error ( ERROR_PREFIX + message , t ) ; break ; default : logger . info ( message , t ) ; break ; } } public boolean isLevelEnabled ( int level ) { switch ( level ) { case TRACE_ID : case DEBUG_ID : return logger . isDebugEnabled ( ) ; case INFO_ID : return logger . isInfoEnabled ( ) ; case WARN_ID : return logger . isWarnEnabled ( ) ; case ERROR_ID : return logger . isErrorEnabled ( ) ; default : return true ; } } protected void finalize ( ) throws Throwable { shutdown ( ) ; } public void shutdown ( ) { logger . unsetLogTargets ( ) ; } } 	1	['10', '1', '1', '12', '46', '0', '1', '11', '7', '0.814814815', '357', '0.5', '1', '0', '0.422222222', '0', '0', '34.1', '2', '1.1', '2']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; public class ASTFalse extends SimpleNode { private static Boolean value = Boolean . FALSE ; public ASTFalse ( int id ) { super ( id ) ; } public ASTFalse ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) { return false ; } public Object value ( InternalContextAdapter context ) { return value ; } } 	0	['6', '2', '0', '6', '9', '13', '4', '4', '5', '0.8', '28', '1', '0', '0.909090909', '0.4', '0', '0', '3.5', '1', '0.5', '0']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . util . TemplateNumber ; public class ASTGTNode extends SimpleNode { public ASTGTNode ( int id ) { super ( id ) ; } public ASTGTNode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { Object left = jjtGetChild ( 0 ) . value ( context ) ; Object right = jjtGetChild ( 1 ) . value ( context ) ; if ( left == null || right == null ) { log . error ( ( left == null ? "Left" : "Right" ) + " side (" + jjtGetChild ( ( left == null ? 0 : 1 ) ) . literal ( ) + ") of '>' operation has null value." + " Operation not possible. " + Log . formatFileString ( this ) ) ; return false ; } if ( left instanceof TemplateNumber ) { left = ( ( TemplateNumber ) left ) . getAsNumber ( ) ; } if ( right instanceof TemplateNumber ) { right = ( ( TemplateNumber ) right ) . getAsNumber ( ) ; } if ( ! ( left instanceof Number ) || ! ( right instanceof Number ) ) { log . error ( ( ! ( left instanceof Number ) ? "Left" : "Right" ) + " side of '>=' operation is not a Numbere. " + Log . formatFileString ( this ) ) ; return false ; } return MathUtils . compare ( ( Number ) left , ( Number ) right ) == 1 ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { boolean val = evaluate ( context ) ; return val ? Boolean . TRUE : Boolean . FALSE ; } } 	1	['5', '2', '0', '11', '18', '10', '4', '9', '5', '2', '130', '0', '0', '0.909090909', '0.4', '1', '1', '25', '1', '0.6', '1']
package org . apache . velocity . runtime . resource . util ; public interface StringResourceRepository { StringResource getStringResource ( String name ) ; void putStringResource ( String name , String body ) ; void putStringResource ( String name , String body , String encoding ) ; void removeStringResource ( String name ) ; void setEncoding ( String encoding ) ; String getEncoding ( ) ; } 	0	['6', '1', '0', '3', '6', '15', '2', '1', '6', '2', '6', '0', '0', '0', '0.916666667', '0', '0', '0', '1', '1', '0']
package org . apache . velocity . runtime . log ; import java . util . Vector ; import java . util . Iterator ; import org . apache . velocity . runtime . RuntimeServices ; class HoldingLogChute implements LogChute { private Vector pendingMessages = new Vector ( ) ; private volatile boolean transferring = false ; public void init ( RuntimeServices rs ) throws Exception { } public synchronized void log ( int level , String message ) { if ( ! transferring ) { Object [ ] data = new Object [ 2 ] ; data [ 0 ] = new Integer ( level ) ; data [ 1 ] = message ; pendingMessages . addElement ( data ) ; } } public synchronized void log ( int level , String message , Throwable t ) { if ( ! transferring ) { Object [ ] data = new Object [ 3 ] ; data [ 0 ] = new Integer ( level ) ; data [ 1 ] = message ; data [ 2 ] = t ; pendingMessages . addElement ( data ) ; } } public boolean isLevelEnabled ( int level ) { return true ; } public synchronized void transferTo ( LogChute newChute ) { if ( ! transferring && ! pendingMessages . isEmpty ( ) ) { transferring = true ; for ( Iterator i = pendingMessages . iterator ( ) ; i . hasNext ( ) ; ) { Object [ ] data = ( Object [ ] ) i . next ( ) ; int level = ( ( Integer ) data [ 0 ] ) . intValue ( ) ; String message = ( String ) data [ 1 ] ; if ( data . length == 2 ) { newChute . log ( level , message ) ; } else { newChute . log ( level , message , ( Throwable ) data [ 2 ] ) ; } } } } } 	1	['6', '1', '1', '5', '17', '3', '3', '2', '5', '0.4', '121', '1', '0', '0', '0.388888889', '0', '0', '18.83333333', '5', '1.8333', '2']
package org . apache . velocity . runtime . resource . loader ; import java . io . InputStream ; import java . util . Hashtable ; import java . util . Vector ; import java . util . Map ; import java . util . HashMap ; import org . apache . velocity . util . StringUtils ; import org . apache . velocity . runtime . resource . Resource ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . commons . collections . ExtendedProperties ; public class JarResourceLoader extends ResourceLoader { private Map entryDirectory = new HashMap ( 559 ) ; private Map jarfiles = new HashMap ( 89 ) ; public void init ( ExtendedProperties configuration ) { log . trace ( "JarResourceLoader : initialization starting." ) ; Vector paths = configuration . getVector ( "path" ) ; StringUtils . trimStrings ( paths ) ; if ( paths == null || paths . size ( ) == 0 ) { paths = configuration . getVector ( "resource.path" ) ; StringUtils . trimStrings ( paths ) ; if ( paths != null && paths . size ( ) > 0 ) { log . debug ( "JarResourceLoader : you are using a deprecated configuration" + " property for the JarResourceLoader -> '<name>.resource.loader.resource.path'." + " Please change to the conventional '<name>.resource.loader.path'." ) ; } } if ( paths != null ) { log . debug ( "JarResourceLoader # of paths : " + paths . size ( ) ) ; for ( int i = 0 ; i < paths . size ( ) ; i ++ ) { loadJar ( ( String ) paths . get ( i ) ) ; } } log . trace ( "JarResourceLoader : initialization complete." ) ; } private void loadJar ( String path ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "JarResourceLoader : trying to load \"" + path + "\"" ) ; } if ( path == null ) { String msg = "JarResourceLoader : can not load JAR - JAR path is null" ; log . error ( msg ) ; throw new RuntimeException ( msg ) ; } if ( ! path . startsWith ( "jar:" ) ) { String msg = "JarResourceLoader : JAR path must start with jar: -> see java.net.JarURLConnection for information" ; log . error ( msg ) ; throw new RuntimeException ( msg ) ; } if ( path . indexOf ( "!/" ) < 0 ) { path += "!/" ; } closeJar ( path ) ; JarHolder temp = new JarHolder ( rsvc , path ) ; addEntries ( temp . getEntries ( ) ) ; jarfiles . put ( temp . getUrlPath ( ) , temp ) ; } private void closeJar ( String path ) { if ( jarfiles . containsKey ( path ) ) { JarHolder theJar = ( JarHolder ) jarfiles . get ( path ) ; theJar . close ( ) ; } } private void addEntries ( Hashtable entries ) { entryDirectory . putAll ( entries ) ; } public InputStream getResourceStream ( String source ) throws ResourceNotFoundException { InputStream results = null ; if ( org . apache . commons . lang . StringUtils . isEmpty ( source ) ) { throw new ResourceNotFoundException ( "Need to have a resource!" ) ; } String normalizedPath = StringUtils . normalizePath ( source ) ; if ( normalizedPath == null || normalizedPath . length ( ) == 0 ) { String msg = "JAR resource error : argument " + normalizedPath + " contains .. and may be trying to access " + "content outside of template root.  Rejected." ; log . error ( "JarResourceLoader : " + msg ) ; throw new ResourceNotFoundException ( msg ) ; } if ( normalizedPath . startsWith ( "/" ) ) { normalizedPath = normalizedPath . substring ( 1 ) ; } if ( entryDirectory . containsKey ( normalizedPath ) ) { String jarurl = ( String ) entryDirectory . get ( normalizedPath ) ; if ( jarfiles . containsKey ( jarurl ) ) { JarHolder holder = ( JarHolder ) jarfiles . get ( jarurl ) ; results = holder . getResource ( normalizedPath ) ; return results ; } } throw new ResourceNotFoundException ( "JarResourceLoader Error: cannot find resource " + source ) ; } public boolean isSourceModified ( Resource resource ) { return true ; } public long getLastModified ( Resource resource ) { return 0 ; } } 	0	['8', '2', '0', '9', '39', '8', '0', '9', '5', '0.5', '288', '1', '0', '0.631578947', '0.375', '1', '1', '34.75', '7', '2.25', '0']
package org . apache . velocity . runtime . directive ; import java . io . IOException ; import java . io . Writer ; import java . util . Iterator ; import java . util . List ; import org . apache . velocity . app . event . EventCartridge ; import org . apache . velocity . context . ChainedInternalContextAdapter ; import org . apache . velocity . context . Context ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . parser . node . ASTReference ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . runtime . parser . node . SimpleNode ; import org . apache . velocity . runtime . resource . Resource ; import org . apache . velocity . util . introspection . Info ; import org . apache . velocity . util . introspection . IntrospectionCacheData ; public class Foreach extends Directive { protected static class NullHolderContext extends ChainedInternalContextAdapter { private String loopVariableKey = "" ; private boolean active = true ; private NullHolderContext ( String key , InternalContextAdapter context ) { super ( context ) ; if ( key != null ) loopVariableKey = key ; } public Object get ( String key ) throws MethodInvocationException { return ( active && loopVariableKey . equals ( key ) ) ? null : super . get ( key ) ; } public Object put ( String key , Object value ) { if ( loopVariableKey . equals ( key ) && ( value == null ) ) { active = true ; } return super . put ( key , value ) ; } public Object localPut ( final String key , final Object value ) { return put ( key , value ) ; } public Object remove ( Object key ) { if ( loopVariableKey . equals ( key ) ) { active = false ; } return super . remove ( key ) ; } } public String getName ( ) { return "foreach" ; } public int getType ( ) { return BLOCK ; } private String counterName ; private String hasNextName ; private int counterInitialValue ; private int maxNbrLoops ; private boolean skipInvalidIterator ; private String elementKey ; protected Info uberInfo ; public void init ( RuntimeServices rs , InternalContextAdapter context , Node node ) throws TemplateInitException { super . init ( rs , context , node ) ; counterName = rsvc . getString ( RuntimeConstants . COUNTER_NAME ) ; hasNextName = rsvc . getString ( RuntimeConstants . HAS_NEXT_NAME ) ; counterInitialValue = rsvc . getInt ( RuntimeConstants . COUNTER_INITIAL_VALUE ) ; maxNbrLoops = rsvc . getInt ( RuntimeConstants . MAX_NUMBER_LOOPS , Integer . MAX_VALUE ) ; if ( maxNbrLoops < 1 ) { maxNbrLoops = Integer . MAX_VALUE ; } skipInvalidIterator = rsvc . getBoolean ( RuntimeConstants . SKIP_INVALID_ITERATOR , true ) ; SimpleNode sn = ( SimpleNode ) node . jjtGetChild ( 0 ) ; if ( sn instanceof ASTReference ) { elementKey = ( ( ASTReference ) sn ) . getRootString ( ) ; } else { elementKey = sn . getFirstToken ( ) . image . substring ( 1 ) ; } uberInfo = new Info ( context . getCurrentTemplateName ( ) , getLine ( ) , getColumn ( ) ) ; } protected void put ( InternalContextAdapter context , String key , Object value ) { context . put ( key , value ) ; } public boolean render ( InternalContextAdapter context , Writer writer , Node node ) throws IOException , MethodInvocationException , ResourceNotFoundException , ParseErrorException { Object listObject = node . jjtGetChild ( 2 ) . value ( context ) ; if ( listObject == null ) return false ; Iterator i = null ; try { i = rsvc . getUberspect ( ) . getIterator ( listObject , uberInfo ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception ee ) { String msg = "Error getting iterator for #foreach at " + uberInfo ; rsvc . getLog ( ) . error ( msg , ee ) ; throw new VelocityException ( msg , ee ) ; } if ( i == null ) { if ( skipInvalidIterator ) { return false ; } else { Node pnode = node . jjtGetChild ( 2 ) ; String msg = "#foreach parameter " + pnode . literal ( ) + " at " + rsvc . getLog ( ) . formatFileString ( uberInfo . getTemplateName ( ) , pnode . getLine ( ) , pnode . getColumn ( ) ) + " is of type " + listObject . getClass ( ) . getName ( ) + " and is either of wrong type or cannot be iterated." ; rsvc . getLog ( ) . error ( msg ) ; throw new VelocityException ( msg ) ; } } int counter = counterInitialValue ; boolean maxNbrLoopsExceeded = false ; Object o = context . get ( elementKey ) ; Object savedCounter = context . get ( counterName ) ; NullHolderContext nullHolderContext = null ; while ( ! maxNbrLoopsExceeded && i . hasNext ( ) ) { put ( context , counterName , new Integer ( counter ) ) ; put ( context , hasNextName , Boolean . valueOf ( i . hasNext ( ) ) ) ; Object value = i . next ( ) ; put ( context , elementKey , value ) ; try { if ( value == null ) { if ( nullHolderContext == null ) { nullHolderContext = new NullHolderContext ( elementKey , context ) ; } node . jjtGetChild ( 3 ) . render ( nullHolderContext , writer ) ; } else { node . jjtGetChild ( 3 ) . render ( context , writer ) ; } } catch ( Break . BreakException ex ) { break ; } counter ++ ; maxNbrLoopsExceeded = ( counter - counterInitialValue ) >= maxNbrLoops ; } if ( savedCounter != null ) { context . put ( counterName , savedCounter ) ; } else { context . remove ( counterName ) ; } if ( o != null ) { context . put ( elementKey , o ) ; } else { context . remove ( elementKey ) ; } return true ; } } 	1	['6', '2', '0', '18', '48', '13', '0', '18', '5', '0.8', '325', '1', '1', '0.642857143', '0.357142857', '0', '0', '52', '1', '0.8333', '3']
package org . apache . velocity . texen . util ; import java . io . File ; public class FileUtil { static public String mkdir ( String s ) { try { if ( ( new File ( s ) ) . mkdirs ( ) ) return "Created dir: " + s ; else return "Failed to create dir or dir already exists: " + s ; } catch ( Exception e ) { return e . toString ( ) ; } } public static File file ( String s ) { File f = new File ( s ) ; return f ; } public static File file ( String base , String s ) { File f = new File ( base , s ) ; return f ; } } 	0	['4', '1', '0', '0', '12', '6', '0', '0', '4', '2', '50', '0', '0', '0', '0.5', '0', '0', '11.5', '2', '1', '0']
package org . apache . velocity . util . introspection ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; public class MethodMap { private static final int MORE_SPECIFIC = 0 ; private static final int LESS_SPECIFIC = 1 ; private static final int INCOMPARABLE = 2 ; Map methodByNameMap = new HashMap ( ) ; public void add ( Method method ) { String methodName = method . getName ( ) ; List l = get ( methodName ) ; if ( l == null ) { l = new ArrayList ( ) ; methodByNameMap . put ( methodName , l ) ; } l . add ( method ) ; } public List get ( String key ) { return ( List ) methodByNameMap . get ( key ) ; } public Method find ( String methodName , Object [ ] args ) throws AmbiguousException { List methodList = get ( methodName ) ; if ( methodList == null ) { return null ; } int l = args . length ; Class [ ] classes = new Class [ l ] ; for ( int i = 0 ; i < l ; ++ i ) { Object arg = args [ i ] ; classes [ i ] = arg == null ? null : arg . getClass ( ) ; } return getBestMatch ( methodList , classes ) ; } private static Method getBestMatch ( List methods , Class [ ] args ) { List equivalentMatches = null ; Method bestMatch = null ; Class [ ] bestMatchTypes = null ; for ( Iterator i = methods . iterator ( ) ; i . hasNext ( ) ; ) { Method method = ( Method ) i . next ( ) ; if ( isApplicable ( method , args ) ) { if ( bestMatch == null ) { bestMatch = method ; bestMatchTypes = method . getParameterTypes ( ) ; } else { Class [ ] methodTypes = method . getParameterTypes ( ) ; switch ( compare ( methodTypes , bestMatchTypes ) ) { case MORE_SPECIFIC : if ( equivalentMatches == null ) { bestMatch = method ; bestMatchTypes = methodTypes ; } else { int ambiguities = equivalentMatches . size ( ) ; for ( int a = 0 ; a < ambiguities ; a ++ ) { Method other = ( Method ) equivalentMatches . get ( a ) ; switch ( compare ( methodTypes , other . getParameterTypes ( ) ) ) { case MORE_SPECIFIC : bestMatch = method ; bestMatchTypes = methodTypes ; equivalentMatches = null ; ambiguities = 0 ; break ; case INCOMPARABLE : equivalentMatches . add ( method ) ; break ; case LESS_SPECIFIC : break ; } } } break ; case INCOMPARABLE : if ( equivalentMatches == null ) { equivalentMatches = new ArrayList ( bestMatchTypes . length ) ; } equivalentMatches . add ( method ) ; break ; case LESS_SPECIFIC : break ; } } } } if ( equivalentMatches != null ) { throw new AmbiguousException ( ) ; } return bestMatch ; } public static class AmbiguousException extends RuntimeException { private static final long serialVersionUID = - 2314636505414551663L ; } private static int compare ( Class [ ] c1 , Class [ ] c2 ) { boolean c1MoreSpecific = false ; boolean c2MoreSpecific = false ; if ( c1 . length > c2 . length ) { return MORE_SPECIFIC ; } if ( c2 . length > c1 . length ) { return LESS_SPECIFIC ; } for ( int i = 0 ; i < c1 . length ; ++ i ) { if ( c1 [ i ] != c2 [ i ] ) { boolean last = ( i == c1 . length - 1 ) ; c1MoreSpecific = c1MoreSpecific || isStrictConvertible ( c2 [ i ] , c1 [ i ] , last ) ; c2MoreSpecific = c2MoreSpecific || isStrictConvertible ( c1 [ i ] , c2 [ i ] , last ) ; } } if ( c1MoreSpecific ) { if ( c2MoreSpecific ) { boolean last1Array = c1 [ c1 . length - 1 ] . isArray ( ) ; boolean last2Array = c2 [ c2 . length - 1 ] . isArray ( ) ; if ( last1Array && ! last2Array ) { return LESS_SPECIFIC ; } if ( ! last1Array && last2Array ) { return MORE_SPECIFIC ; } return INCOMPARABLE ; } return MORE_SPECIFIC ; } if ( c2MoreSpecific ) { return LESS_SPECIFIC ; } return INCOMPARABLE ; } private static boolean isApplicable ( Method method , Class [ ] classes ) { Class [ ] methodArgs = method . getParameterTypes ( ) ; if ( methodArgs . length > classes . length ) { if ( methodArgs . length == classes . length + 1 && methodArgs [ methodArgs . length - 1 ] . isArray ( ) ) { return true ; } else { return false ; } } else if ( methodArgs . length == classes . length ) { for ( int i = 0 ; i < classes . length ; ++ i ) { if ( ! isConvertible ( methodArgs [ i ] , classes [ i ] , false ) ) { if ( i == classes . length - 1 && methodArgs [ i ] . isArray ( ) ) { return isConvertible ( methodArgs [ i ] , classes [ i ] , true ) ; } return false ; } } } else if ( methodArgs . length > 0 ) { Class lastarg = methodArgs [ methodArgs . length - 1 ] ; if ( ! lastarg . isArray ( ) ) { return false ; } for ( int i = 0 ; i < methodArgs . length - 1 ; ++ i ) { if ( ! isConvertible ( methodArgs [ i ] , classes [ i ] , false ) ) { return false ; } } Class vararg = lastarg . getComponentType ( ) ; for ( int i = methodArgs . length - 1 ; i < classes . length ; ++ i ) { if ( ! isConvertible ( vararg , classes [ i ] , false ) ) { return false ; } } } return true ; } private static boolean isConvertible ( Class formal , Class actual , boolean possibleVarArg ) { return IntrospectionUtils . isMethodInvocationConvertible ( formal , actual , possibleVarArg ) ; } private static boolean isStrictConvertible ( Class formal , Class actual , boolean possibleVarArg ) { return IntrospectionUtils . isStrictMethodInvocationConvertible ( formal , actual , possibleVarArg ) ; } } 	1	['9', '1', '0', '3', '29', '30', '1', '2', '4', '1', '465', '0.75', '0', '0', '0.236111111', '0', '0', '50.22222222', '17', '5.1111', '1']
package org . apache . velocity . app . event . implement ; import org . apache . commons . lang . StringEscapeUtils ; public class EscapeSqlReference extends EscapeReference { protected String escape ( Object text ) { return StringEscapeUtils . escapeSql ( text . toString ( ) ) ; } protected String getMatchAttribute ( ) { return "eventhandler.escape.sql.match" ; } } 	0	['3', '2', '0', '2', '6', '3', '0', '2', '1', '2', '12', '0', '0', '0.714285714', '0.666666667', '1', '2', '3', '1', '0.6667', '0']
package org . apache . velocity . util . introspection ; import java . lang . reflect . Array ; import java . lang . reflect . Method ; import java . util . Collection ; import java . util . Enumeration ; import java . util . Iterator ; import java . util . Map ; import org . apache . velocity . runtime . RuntimeLogger ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . log . RuntimeLoggerLog ; import org . apache . velocity . runtime . parser . node . AbstractExecutor ; import org . apache . velocity . runtime . parser . node . BooleanPropertyExecutor ; import org . apache . velocity . runtime . parser . node . GetExecutor ; import org . apache . velocity . runtime . parser . node . MapGetExecutor ; import org . apache . velocity . runtime . parser . node . MapSetExecutor ; import org . apache . velocity . runtime . parser . node . PropertyExecutor ; import org . apache . velocity . runtime . parser . node . PutExecutor ; import org . apache . velocity . runtime . parser . node . SetExecutor ; import org . apache . velocity . runtime . parser . node . SetPropertyExecutor ; import org . apache . velocity . util . ArrayIterator ; import org . apache . velocity . util . ArrayListWrapper ; import org . apache . velocity . util . EnumerationIterator ; public class UberspectImpl implements Uberspect , UberspectLoggable { protected Log log ; protected Introspector introspector ; public void init ( ) throws Exception { introspector = new Introspector ( log ) ; } public void setLog ( Log log ) { this . log = log ; } public void setRuntimeLogger ( RuntimeLogger runtimeLogger ) { setLog ( new RuntimeLoggerLog ( runtimeLogger ) ) ; } public Iterator getIterator ( Object obj , Info i ) throws Exception { if ( obj . getClass ( ) . isArray ( ) ) { return new ArrayIterator ( obj ) ; } else if ( obj instanceof Collection ) { return ( ( Collection ) obj ) . iterator ( ) ; } else if ( obj instanceof Map ) { return ( ( Map ) obj ) . values ( ) . iterator ( ) ; } else if ( obj instanceof Iterator ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "The iterative object in the #foreach() loop at " + i + " is of type java.util.Iterator.  Because " + "it is not resettable, if used in more than once it " + "may lead to unexpected results." ) ; } return ( ( Iterator ) obj ) ; } else if ( obj instanceof Enumeration ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "The iterative object in the #foreach() loop at " + i + " is of type java.util.Enumeration.  Because " + "it is not resettable, if used in more than once it " + "may lead to unexpected results." ) ; } return new EnumerationIterator ( ( Enumeration ) obj ) ; } else { Class type = obj . getClass ( ) ; try { Method iter = type . getMethod ( "iterator" , null ) ; Class returns = iter . getReturnType ( ) ; if ( Iterator . class . isAssignableFrom ( returns ) ) { return ( Iterator ) iter . invoke ( obj , null ) ; } else { log . debug ( "iterator() method of reference in #foreach loop at " + i + " does not return a true Iterator." ) ; } } catch ( NoSuchMethodException nsme ) { } } log . debug ( "Could not determine type of iterator in #foreach loop at " + i ) ; return null ; } public VelMethod getMethod ( Object obj , String methodName , Object [ ] args , Info i ) throws Exception { if ( obj == null ) { return null ; } Method m = introspector . getMethod ( obj . getClass ( ) , methodName , args ) ; if ( m != null ) { return new VelMethodImpl ( m ) ; } Class cls = obj . getClass ( ) ; if ( cls . isArray ( ) ) { m = introspector . getMethod ( ArrayListWrapper . class , methodName , args ) ; if ( m != null ) { return new VelMethodImpl ( m , true ) ; } } else if ( cls == Class . class ) { m = introspector . getMethod ( ( Class ) obj , methodName , args ) ; if ( m != null ) { return new VelMethodImpl ( m ) ; } } return null ; } public VelPropertyGet getPropertyGet ( Object obj , String identifier , Info i ) throws Exception { if ( obj == null ) { return null ; } Class claz = obj . getClass ( ) ; AbstractExecutor executor = new PropertyExecutor ( log , introspector , claz , identifier ) ; if ( ! executor . isAlive ( ) ) { executor = new MapGetExecutor ( log , claz , identifier ) ; } if ( ! executor . isAlive ( ) ) { executor = new GetExecutor ( log , introspector , claz , identifier ) ; } if ( ! executor . isAlive ( ) ) { executor = new BooleanPropertyExecutor ( log , introspector , claz , identifier ) ; } return ( executor . isAlive ( ) ) ? new VelGetterImpl ( executor ) : null ; } public VelPropertySet getPropertySet ( Object obj , String identifier , Object arg , Info i ) throws Exception { if ( obj == null ) { return null ; } Class claz = obj . getClass ( ) ; SetExecutor executor = new SetPropertyExecutor ( log , introspector , claz , identifier , arg ) ; if ( ! executor . isAlive ( ) ) { executor = new MapSetExecutor ( log , claz , identifier ) ; } if ( ! executor . isAlive ( ) ) { executor = new PutExecutor ( log , introspector , claz , arg , identifier ) ; } return ( executor . isAlive ( ) ) ? new VelSetterImpl ( executor ) : null ; } public static class VelMethodImpl implements VelMethod { final Method method ; Boolean isVarArg ; boolean wrapArray ; public VelMethodImpl ( Method m ) { this ( m , false ) ; } public VelMethodImpl ( Method method , boolean wrapArray ) { this . method = method ; this . wrapArray = wrapArray ; } private VelMethodImpl ( ) { method = null ; } public Object invoke ( Object o , Object [ ] actual ) throws Exception { if ( wrapArray ) { o = new ArrayListWrapper ( o ) ; } if ( isVarArg ( ) ) { Class [ ] formal = method . getParameterTypes ( ) ; int index = formal . length - 1 ; if ( actual . length >= index ) { Class type = formal [ index ] . getComponentType ( ) ; actual = handleVarArg ( type , index , actual ) ; } } return doInvoke ( o , actual ) ; } protected Object doInvoke ( Object o , Object [ ] actual ) throws Exception { return method . invoke ( o , actual ) ; } public boolean isVarArg ( ) { if ( isVarArg == null ) { Class [ ] formal = method . getParameterTypes ( ) ; if ( formal == null || formal . length == 0 ) { this . isVarArg = Boolean . FALSE ; } else { Class last = formal [ formal . length - 1 ] ; this . isVarArg = Boolean . valueOf ( last . isArray ( ) ) ; } } return isVarArg . booleanValue ( ) ; } private Object [ ] handleVarArg ( final Class type , final int index , Object [ ] actual ) { if ( actual . length == index ) { actual = new Object [ ] { Array . newInstance ( type , 0 ) } ; } else if ( actual . length == index + 1 && actual [ index ] != null ) { Class argClass = actual [ index ] . getClass ( ) ; if ( ! argClass . isArray ( ) && IntrospectionUtils . isMethodInvocationConvertible ( type , argClass , false ) ) { Object lastActual = Array . newInstance ( type , 1 ) ; Array . set ( lastActual , 0 , actual [ index ] ) ; actual [ index ] = lastActual ; } } else if ( actual . length > index + 1 ) { int size = actual . length - index ; Object lastActual = Array . newInstance ( type , size ) ; for ( int i = 0 ; i < size ; i ++ ) { Array . set ( lastActual , i , actual [ index + i ] ) ; } Object [ ] newActual = new Object [ index + 1 ] ; for ( int i = 0 ; i < index ; i ++ ) { newActual [ i ] = actual [ i ] ; } newActual [ index ] = lastActual ; actual = newActual ; } return actual ; } public boolean isCacheable ( ) { return true ; } public String getMethodName ( ) { return method . getName ( ) ; } public Class getReturnType ( ) { return method . getReturnType ( ) ; } } public static class VelGetterImpl implements VelPropertyGet { final AbstractExecutor getExecutor ; public VelGetterImpl ( AbstractExecutor exec ) { getExecutor = exec ; } private VelGetterImpl ( ) { getExecutor = null ; } public Object invoke ( Object o ) throws Exception { return getExecutor . execute ( o ) ; } public boolean isCacheable ( ) { return true ; } public String getMethodName ( ) { return getExecutor . isAlive ( ) ? getExecutor . getMethod ( ) . getName ( ) : null ; } } public static class VelSetterImpl implements VelPropertySet { private final SetExecutor setExecutor ; public VelSetterImpl ( final SetExecutor setExecutor ) { this . setExecutor = setExecutor ; } private VelSetterImpl ( ) { setExecutor = null ; } public Object invoke ( final Object o , final Object value ) throws Exception { return setExecutor . execute ( o , value ) ; } public boolean isCacheable ( ) { return true ; } public String getMethodName ( ) { return setExecutor . isAlive ( ) ? setExecutor . getMethod ( ) . getName ( ) : null ; } } } 	1	['9', '1', '2', '26', '45', '10', '2', '24', '8', '0.8', '374', '0.4', '2', '0', '0.365079365', '0', '0', '40', '1', '0.8889', '2']
package org . apache . velocity . runtime . log ; import org . apache . log4j . Category ; import org . apache . log4j . Level ; import org . apache . log4j . PatternLayout ; import org . apache . log4j . RollingFileAppender ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeServices ; public class SimpleLog4JLogSystem implements LogSystem { private RuntimeServices rsvc = null ; private RollingFileAppender appender = null ; protected Category logger = null ; public SimpleLog4JLogSystem ( ) { } public void init ( RuntimeServices rs ) { rsvc = rs ; String categoryname = ( String ) rsvc . getProperty ( "runtime.log.logsystem.log4j.category" ) ; if ( categoryname != null ) { logger = Category . getInstance ( categoryname ) ; logVelocityMessage ( 0 , "SimpleLog4JLogSystem using category '" + categoryname + "'" ) ; return ; } String logfile = rsvc . getString ( RuntimeConstants . RUNTIME_LOG ) ; try { internalInit ( logfile ) ; logVelocityMessage ( 0 , "SimpleLog4JLogSystem initialized using logfile '" + logfile + "'" ) ; } catch ( Exception e ) { System . err . println ( "PANIC : error configuring SimpleLog4JLogSystem : " + e ) ; } } private void internalInit ( String logfile ) throws Exception { logger = Category . getInstance ( this . getClass ( ) . getName ( ) ) ; logger . setAdditivity ( false ) ; logger . setLevel ( Level . DEBUG ) ; appender = new RollingFileAppender ( new PatternLayout ( "%d - %m%n" ) , logfile , true ) ; appender . setMaxBackupIndex ( 1 ) ; appender . setMaximumFileSize ( 100000 ) ; logger . addAppender ( appender ) ; } public void logVelocityMessage ( int level , String message ) { switch ( level ) { case LogSystem . WARN_ID : logger . warn ( message ) ; break ; case LogSystem . INFO_ID : logger . info ( message ) ; break ; case LogSystem . ERROR_ID : logger . error ( message ) ; break ; case LogSystem . DEBUG_ID : default : logger . debug ( message ) ; break ; } } protected void finalize ( ) throws Throwable { shutdown ( ) ; } public void shutdown ( ) { if ( appender != null ) { logger . removeAppender ( appender ) ; appender . close ( ) ; appender = null ; } } } 	0	['6', '1', '0', '8', '30', '0', '0', '8', '4', '0.333333333', '163', '1', '1', '0', '0.416666667', '0', '0', '25.66666667', '2', '1.3333', '0']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . util . TemplateNumber ; public class ASTLENode extends SimpleNode { public ASTLENode ( int id ) { super ( id ) ; } public ASTLENode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { Object left = jjtGetChild ( 0 ) . value ( context ) ; Object right = jjtGetChild ( 1 ) . value ( context ) ; if ( left == null || right == null ) { log . error ( ( left == null ? "Left" : "Right" ) + " side (" + jjtGetChild ( ( left == null ? 0 : 1 ) ) . literal ( ) + ") of '<=' operation has null value." + " Operation not possible. " + Log . formatFileString ( this ) ) ; return false ; } if ( left instanceof TemplateNumber ) { left = ( ( TemplateNumber ) left ) . getAsNumber ( ) ; } if ( right instanceof TemplateNumber ) { right = ( ( TemplateNumber ) right ) . getAsNumber ( ) ; } if ( ! ( left instanceof Number ) || ! ( right instanceof Number ) ) { log . error ( ( ! ( left instanceof Number ) ? "Left" : "Right" ) + " side of '>=' operation is not a Number. " + Log . formatFileString ( this ) ) ; return false ; } return MathUtils . compare ( ( Number ) left , ( Number ) right ) <= 0 ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { boolean val = evaluate ( context ) ; return val ? Boolean . TRUE : Boolean . FALSE ; } } 	1	['5', '2', '0', '11', '18', '10', '4', '9', '5', '2', '129', '0', '0', '0.909090909', '0.4', '1', '1', '24.8', '1', '0.6', '1']
package org . apache . velocity . app . event ; import org . apache . velocity . context . Context ; import org . apache . velocity . util . ContextAware ; public interface MethodExceptionEventHandler extends EventHandler { public Object methodException ( Class claz , String method , Exception e ) throws Exception ; static class MethodExceptionExecutor implements EventHandlerMethodExecutor { private Context context ; private Class claz ; private String method ; private Exception e ; private Object result ; private boolean executed = false ; MethodExceptionExecutor ( Context context , Class claz , String method , Exception e ) { this . context = context ; this . claz = claz ; this . method = method ; this . e = e ; } public void execute ( EventHandler handler ) throws Exception { MethodExceptionEventHandler eh = ( MethodExceptionEventHandler ) handler ; if ( eh instanceof ContextAware ) ( ( ContextAware ) eh ) . setContext ( context ) ; executed = true ; result = ( ( MethodExceptionEventHandler ) handler ) . methodException ( claz , method , e ) ; } public Object getReturnValue ( ) { return result ; } public boolean isDone ( ) { return executed ; } } } 	0	['1', '1', '0', '5', '1', '0', '4', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . velocity ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . UnsupportedEncodingException ; import java . io . Writer ; import java . util . List ; import org . apache . velocity . context . Context ; import org . apache . velocity . context . InternalContextAdapterImpl ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . runtime . parser . ParseException ; import org . apache . velocity . runtime . parser . node . SimpleNode ; import org . apache . velocity . runtime . resource . Resource ; import org . apache . velocity . runtime . resource . ResourceManager ; public class Template extends Resource { private VelocityException errorCondition = null ; public Template ( ) { super ( ) ; setType ( ResourceManager . RESOURCE_TEMPLATE ) ; } public boolean process ( ) throws ResourceNotFoundException , ParseErrorException , IOException { data = null ; InputStream is = null ; errorCondition = null ; try { is = resourceLoader . getResourceStream ( name ) ; } catch ( ResourceNotFoundException rnfe ) { errorCondition = rnfe ; throw rnfe ; } if ( is != null ) { try { BufferedReader br = new BufferedReader ( new InputStreamReader ( is , encoding ) ) ; data = rsvc . parse ( br , name ) ; initDocument ( ) ; return true ; } catch ( UnsupportedEncodingException uce ) { String msg = "Template.process : Unsupported input encoding : " + encoding + " for template " + name ; errorCondition = new ParseErrorException ( msg ) ; throw errorCondition ; } catch ( ParseException pex ) { errorCondition = new ParseErrorException ( pex ) ; throw errorCondition ; } catch ( TemplateInitException pex ) { errorCondition = new ParseErrorException ( pex ) ; throw errorCondition ; } catch ( RuntimeException e ) { throw new RuntimeException ( "Exception thrown processing Template " + getName ( ) , e ) ; } finally { is . close ( ) ; } } else { errorCondition = new ResourceNotFoundException ( "Unknown resource error for resource " + name ) ; throw errorCondition ; } } public void initDocument ( ) throws TemplateInitException { InternalContextAdapterImpl ica = new InternalContextAdapterImpl ( new VelocityContext ( ) ) ; try { ica . pushCurrentTemplateName ( name ) ; ica . setCurrentResource ( this ) ; ( ( SimpleNode ) data ) . init ( ica , rsvc ) ; } finally { ica . popCurrentTemplateName ( ) ; ica . setCurrentResource ( null ) ; } } public void merge ( Context context , Writer writer ) throws ResourceNotFoundException , ParseErrorException , MethodInvocationException , IOException { merge ( context , writer , null ) ; } public void merge ( Context context , Writer writer , List macroLibraries ) throws ResourceNotFoundException , ParseErrorException , MethodInvocationException , IOException { if ( errorCondition != null ) { throw errorCondition ; } if ( data != null ) { InternalContextAdapterImpl ica = new InternalContextAdapterImpl ( context ) ; ica . setMacroLibraries ( macroLibraries ) ; if ( macroLibraries != null ) { for ( int i = 0 ; i < macroLibraries . size ( ) ; i ++ ) { try { rsvc . getTemplate ( ( String ) macroLibraries . get ( i ) ) ; } catch ( ResourceNotFoundException re ) { rsvc . getLog ( ) . error ( "template.merge(): " + "cannot find template " + ( String ) macroLibraries . get ( i ) ) ; throw re ; } catch ( ParseErrorException pe ) { rsvc . getLog ( ) . error ( "template.merge(): " + "syntax error in template " + ( String ) macroLibraries . get ( i ) + "." ) ; throw pe ; } catch ( Exception e ) { throw new RuntimeException ( "Template.merge(): parse failed in template  " + ( String ) macroLibraries . get ( i ) + "." , e ) ; } } } try { ica . pushCurrentTemplateName ( name ) ; ica . setCurrentResource ( this ) ; ( ( SimpleNode ) data ) . render ( ica , writer ) ; } finally { ica . popCurrentTemplateName ( ) ; ica . setCurrentResource ( null ) ; } } else { String msg = "Template.merge() failure. The document is null, " + "most likely due to parsing error." ; throw new RuntimeException ( msg ) ; } } } 	1	['5', '2', '0', '27', '35', '0', '13', '15', '5', '0.25', '319', '1', '1', '0.818181818', '0.5', '1', '1', '62.6', '1', '0.8', '5']
package org . apache . velocity . runtime . parser . node ; import java . lang . reflect . InvocationTargetException ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . runtime . RuntimeLogger ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . log . RuntimeLoggerLog ; import org . apache . velocity . util . introspection . Introspector ; public class GetExecutor extends AbstractExecutor { private final Introspector introspector ; private Object [ ] params = { } ; public GetExecutor ( final Log log , final Introspector introspector , final Class clazz , final String property ) { this . log = log ; this . introspector = introspector ; if ( property != null ) { this . params = new Object [ ] { property } ; } discover ( clazz ) ; } public GetExecutor ( final RuntimeLogger rlog , final Introspector introspector , final Class clazz , final String property ) { this ( new RuntimeLoggerLog ( rlog ) , introspector , clazz , property ) ; } protected void discover ( final Class clazz ) { try { setMethod ( introspector . getMethod ( clazz , "get" , params ) ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { String msg = "Exception while looking for get('" + params [ 0 ] + "') method" ; log . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } } public Object execute ( final Object o ) throws IllegalAccessException , InvocationTargetException { return isAlive ( ) ? getMethod ( ) . invoke ( o , params ) : null ; } } 	0	['4', '2', '0', '7', '17', '0', '1', '6', '3', '0.166666667', '94', '1', '1', '0.666666667', '0.5', '0', '0', '22', '1', '0.5', '0']
package org . apache . velocity . util . introspection ; import java . util . Iterator ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . util . RuntimeServicesAware ; public class SecureUberspector extends UberspectImpl implements RuntimeServicesAware { RuntimeServices runtimeServices ; public SecureUberspector ( ) { super ( ) ; } public void init ( ) { String [ ] badPackages = runtimeServices . getConfiguration ( ) . getStringArray ( RuntimeConstants . INTROSPECTOR_RESTRICT_PACKAGES ) ; String [ ] badClasses = runtimeServices . getConfiguration ( ) . getStringArray ( RuntimeConstants . INTROSPECTOR_RESTRICT_CLASSES ) ; introspector = new SecureIntrospectorImpl ( badClasses , badPackages , log ) ; } public Iterator getIterator ( Object obj , Info i ) throws Exception { if ( obj != null ) { SecureIntrospectorControl sic = ( SecureIntrospectorControl ) introspector ; if ( sic . checkObjectExecutePermission ( obj . getClass ( ) , null ) ) { return super . getIterator ( obj , i ) ; } else { log . warn ( "Cannot retrieve iterator from " + obj . getClass ( ) + " due to security restrictions." ) ; } } return null ; } public void setRuntimeServices ( RuntimeServices rs ) { this . runtimeServices = rs ; } } 	1	['4', '2', '0', '9', '16', '2', '0', '9', '4', '0.666666667', '67', '0', '1', '0.727272727', '0.4375', '1', '1', '15.5', '1', '0.75', '2']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . runtime . parser . Parser ; public class ASTOrNode extends SimpleNode { public ASTOrNode ( int id ) { super ( id ) ; } public ASTOrNode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { return evaluate ( context ) ? Boolean . TRUE : Boolean . FALSE ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { Node left = jjtGetChild ( 0 ) ; Node right = jjtGetChild ( 1 ) ; if ( left != null && left . evaluate ( context ) ) return true ; if ( right != null && right . evaluate ( context ) ) return true ; return false ; } } 	0	['5', '2', '0', '9', '10', '10', '5', '6', '5', '2', '53', '0', '0', '0.909090909', '0.4', '1', '1', '9.6', '1', '0.6', '0']
package org . apache . velocity . runtime . resource ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Vector ; import org . apache . commons . collections . ExtendedProperties ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . resource . loader . ResourceLoader ; import org . apache . velocity . runtime . resource . loader . ResourceLoaderFactory ; import org . apache . velocity . util . ClassUtils ; import org . apache . velocity . util . StringUtils ; public class ResourceManagerImpl implements ResourceManager { public static final int RESOURCE_TEMPLATE = 1 ; public static final int RESOURCE_CONTENT = 2 ; private static final String RESOURCE_LOADER_IDENTIFIER = "_RESOURCE_LOADER_IDENTIFIER_" ; protected ResourceCache globalCache = null ; protected final List resourceLoaders = new ArrayList ( ) ; private final List sourceInitializerList = new ArrayList ( ) ; private boolean isInit = false ; private boolean logWhenFound = true ; protected RuntimeServices rsvc = null ; protected Log log = null ; public synchronized void initialize ( final RuntimeServices rsvc ) throws Exception { if ( isInit ) { log . debug ( "Re-initialization of ResourceLoader attempted and ignored." ) ; return ; } ResourceLoader resourceLoader = null ; this . rsvc = rsvc ; log = rsvc . getLog ( ) ; log . trace ( "Default ResourceManager initializing. (" + this . getClass ( ) + ")" ) ; assembleResourceLoaderInitializers ( ) ; for ( Iterator it = sourceInitializerList . iterator ( ) ; it . hasNext ( ) ; ) { ExtendedProperties configuration = ( ExtendedProperties ) it . next ( ) ; String loaderClass = StringUtils . nullTrim ( configuration . getString ( "class" ) ) ; ResourceLoader loaderInstance = ( ResourceLoader ) configuration . get ( "instance" ) ; if ( loaderInstance != null ) { resourceLoader = loaderInstance ; } else if ( loaderClass != null ) { resourceLoader = ResourceLoaderFactory . getLoader ( rsvc , loaderClass ) ; } else { String msg = "Unable to find '" + configuration . getString ( RESOURCE_LOADER_IDENTIFIER ) + ".resource.loader.class' specification in configuration." + " This is a critical value.  Please adjust configuration." ; log . error ( msg ) ; throw new Exception ( msg ) ; } resourceLoader . commonInit ( rsvc , configuration ) ; resourceLoader . init ( configuration ) ; resourceLoaders . add ( resourceLoader ) ; } logWhenFound = rsvc . getBoolean ( RuntimeConstants . RESOURCE_MANAGER_LOGWHENFOUND , true ) ; String cacheClassName = rsvc . getString ( RuntimeConstants . RESOURCE_MANAGER_CACHE_CLASS ) ; Object cacheObject = null ; if ( org . apache . commons . lang . StringUtils . isNotEmpty ( cacheClassName ) ) { try { cacheObject = ClassUtils . getNewInstance ( cacheClassName ) ; } catch ( ClassNotFoundException cnfe ) { String msg = "The specified class for ResourceCache (" + cacheClassName + ") does not exist or is not accessible to the current classloader." ; log . error ( msg , cnfe ) ; throw cnfe ; } if ( ! ( cacheObject instanceof ResourceCache ) ) { String msg = "The specified resource cache class (" + cacheClassName + ") must implement " + ResourceCache . class . getName ( ) ; log . error ( msg ) ; throw new RuntimeException ( msg ) ; } } if ( cacheObject == null ) { cacheObject = new ResourceCacheImpl ( ) ; } globalCache = ( ResourceCache ) cacheObject ; globalCache . initialize ( rsvc ) ; log . trace ( "Default ResourceManager initialization complete." ) ; } private void assembleResourceLoaderInitializers ( ) { Vector resourceLoaderNames = rsvc . getConfiguration ( ) . getVector ( RuntimeConstants . RESOURCE_LOADER ) ; StringUtils . trimStrings ( resourceLoaderNames ) ; for ( Iterator it = resourceLoaderNames . iterator ( ) ; it . hasNext ( ) ; ) { String loaderName = ( String ) it . next ( ) ; StringBuffer loaderID = new StringBuffer ( loaderName ) ; loaderID . append ( "." ) . append ( RuntimeConstants . RESOURCE_LOADER ) ; ExtendedProperties loaderConfiguration = rsvc . getConfiguration ( ) . subset ( loaderID . toString ( ) ) ; if ( loaderConfiguration == null ) { log . debug ( "ResourceManager : No configuration information found " + "for resource loader named '" + loaderName + "' (id is " + loaderID + "). Skipping it..." ) ; continue ; } loaderConfiguration . setProperty ( RESOURCE_LOADER_IDENTIFIER , loaderName ) ; sourceInitializerList . add ( loaderConfiguration ) ; } } public Resource getResource ( final String resourceName , final int resourceType , final String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception { String resourceKey = resourceType + resourceName ; Resource resource = globalCache . get ( resourceKey ) ; if ( resource != null ) { try { if ( resource . requiresChecking ( ) ) { resource = refreshResource ( resource , encoding ) ; } } catch ( ResourceNotFoundException rnfe ) { globalCache . remove ( resourceKey ) ; return getResource ( resourceName , resourceType , encoding ) ; } catch ( ParseErrorException pee ) { log . error ( "ResourceManager.getResource() exception" , pee ) ; throw pee ; } catch ( RuntimeException re ) { log . error ( "ResourceManager.getResource() exception" , re ) ; throw re ; } catch ( Exception e ) { log . error ( "ResourceManager.getResource() exception" , e ) ; throw e ; } } else { try { resource = loadResource ( resourceName , resourceType , encoding ) ; if ( resource . getResourceLoader ( ) . isCachingOn ( ) ) { globalCache . put ( resourceKey , resource ) ; } } catch ( ResourceNotFoundException rnfe ) { log . error ( "ResourceManager : unable to find resource '" + resourceName + "' in any resource loader." ) ; throw rnfe ; } catch ( ParseErrorException pee ) { log . error ( "ResourceManager.getResource() parse exception" , pee ) ; throw pee ; } catch ( RuntimeException re ) { log . error ( "ResourceManager.getResource() load exception" , re ) ; throw re ; } catch ( Exception e ) { log . error ( "ResourceManager.getResource() exception new" , e ) ; throw e ; } } return resource ; } protected Resource createResource ( String resourceName , int resourceType ) { return ResourceFactory . getResource ( resourceName , resourceType ) ; } protected Resource loadResource ( String resourceName , int resourceType , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception { Resource resource = createResource ( resourceName , resourceType ) ; resource . setRuntimeServices ( rsvc ) ; resource . setName ( resourceName ) ; resource . setEncoding ( encoding ) ; long howOldItWas = 0 ; for ( Iterator it = resourceLoaders . iterator ( ) ; it . hasNext ( ) ; ) { ResourceLoader resourceLoader = ( ResourceLoader ) it . next ( ) ; resource . setResourceLoader ( resourceLoader ) ; try { if ( resource . process ( ) ) { if ( logWhenFound && log . isDebugEnabled ( ) ) { log . debug ( "ResourceManager : found " + resourceName + " with loader " + resourceLoader . getClassName ( ) ) ; } howOldItWas = resourceLoader . getLastModified ( resource ) ; break ; } } catch ( ResourceNotFoundException rnfe ) { } } if ( resource . getData ( ) == null ) { throw new ResourceNotFoundException ( "Unable to find resource '" + resourceName + "'" ) ; } resource . setLastModified ( howOldItWas ) ; resource . setModificationCheckInterval ( resource . getResourceLoader ( ) . getModificationCheckInterval ( ) ) ; resource . touch ( ) ; return resource ; } protected Resource refreshResource ( Resource resource , final String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception { resource . touch ( ) ; if ( resource . isSourceModified ( ) ) { if ( ! org . apache . commons . lang . StringUtils . equals ( resource . getEncoding ( ) , encoding ) ) { log . warn ( "Declared encoding for template '" + resource . getName ( ) + "' is different on reload. Old = '" + resource . getEncoding ( ) + "' New = '" + encoding ) ; resource . setEncoding ( encoding ) ; } long howOldItWas = resource . getResourceLoader ( ) . getLastModified ( resource ) ; String resourceKey = resource . getType ( ) + resource . getName ( ) ; Resource newResource = ResourceFactory . getResource ( resource . getName ( ) , resource . getType ( ) ) ; newResource . setRuntimeServices ( rsvc ) ; newResource . setName ( resource . getName ( ) ) ; newResource . setEncoding ( resource . getEncoding ( ) ) ; newResource . setResourceLoader ( resource . getResourceLoader ( ) ) ; newResource . setModificationCheckInterval ( resource . getResourceLoader ( ) . getModificationCheckInterval ( ) ) ; newResource . process ( ) ; newResource . setLastModified ( howOldItWas ) ; resource = newResource ; globalCache . put ( resourceKey , newResource ) ; } return resource ; } public Resource getResource ( String resourceName , int resourceType ) throws ResourceNotFoundException , ParseErrorException , Exception { return getResource ( resourceName , resourceType , RuntimeConstants . ENCODING_DEFAULT ) ; } public String getLoaderNameForResource ( String resourceName ) { for ( Iterator it = resourceLoaders . iterator ( ) ; it . hasNext ( ) ; ) { ResourceLoader resourceLoader = ( ResourceLoader ) it . next ( ) ; if ( resourceLoader . resourceExists ( resourceName ) ) { return resourceLoader . getClass ( ) . toString ( ) ; } } return null ; } } 	1	['10', '1', '0', '15', '81', '9', '0', '15', '5', '0.747474747', '659', '0.727272727', '3', '0', '0.44', '0', '0', '63.8', '3', '1.2', '2']
package org . apache . velocity . runtime . resource . util ; public final class StringResource { private String body ; private String encoding ; private long lastModified ; public StringResource ( final String body , final String encoding ) { setBody ( body ) ; setEncoding ( encoding ) ; } public String getBody ( ) { return body ; } public long getLastModified ( ) { return lastModified ; } public void setBody ( final String body ) { this . body = body ; this . lastModified = System . currentTimeMillis ( ) ; } public void setLastModified ( final long lastModified ) { this . lastModified = lastModified ; } public String getEncoding ( ) { return this . encoding ; } public void setEncoding ( final String encoding ) { this . encoding = encoding ; } } 	0	['7', '1', '0', '3', '9', '11', '3', '0', '7', '0.611111111', '43', '1', '0', '0', '0.523809524', '0', '0', '4.714285714', '1', '0.8571', '0']
package org . apache . velocity . app ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import java . io . UnsupportedEncodingException ; import java . io . Writer ; import java . util . Properties ; import org . apache . commons . collections . ExtendedProperties ; import org . apache . velocity . Template ; import org . apache . velocity . context . Context ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeSingleton ; import org . apache . velocity . runtime . log . Log ; public class Velocity implements RuntimeConstants { public static void init ( ) throws Exception { RuntimeSingleton . init ( ) ; } public static void init ( String propsFilename ) throws Exception { RuntimeSingleton . init ( propsFilename ) ; } public static void init ( Properties p ) throws Exception { RuntimeSingleton . init ( p ) ; } public static void setProperty ( String key , Object value ) { RuntimeSingleton . setProperty ( key , value ) ; } public static void addProperty ( String key , Object value ) { RuntimeSingleton . addProperty ( key , value ) ; } public static void clearProperty ( String key ) { RuntimeSingleton . clearProperty ( key ) ; } public static void setExtendedProperties ( ExtendedProperties configuration ) { RuntimeSingleton . setConfiguration ( configuration ) ; } public static Object getProperty ( String key ) { return RuntimeSingleton . getProperty ( key ) ; } public static boolean evaluate ( Context context , Writer out , String logTag , String instring ) throws ParseErrorException , MethodInvocationException , ResourceNotFoundException , IOException { return RuntimeSingleton . getRuntimeServices ( ) . evaluate ( context , out , logTag , instring ) ; } public static boolean evaluate ( Context context , Writer writer , String logTag , InputStream instream ) throws ParseErrorException , MethodInvocationException , ResourceNotFoundException , IOException { BufferedReader br = null ; String encoding = null ; try { encoding = RuntimeSingleton . getString ( INPUT_ENCODING , ENCODING_DEFAULT ) ; br = new BufferedReader ( new InputStreamReader ( instream , encoding ) ) ; } catch ( UnsupportedEncodingException uce ) { String msg = "Unsupported input encoding : " + encoding + " for template " + logTag ; throw new ParseErrorException ( msg ) ; } return evaluate ( context , writer , logTag , br ) ; } public static boolean evaluate ( Context context , Writer writer , String logTag , Reader reader ) throws ParseErrorException , MethodInvocationException , ResourceNotFoundException , IOException { return RuntimeSingleton . getRuntimeServices ( ) . evaluate ( context , writer , logTag , reader ) ; } public static boolean invokeVelocimacro ( String vmName , String logTag , String params [ ] , Context context , Writer writer ) { try { return RuntimeSingleton . getRuntimeServices ( ) . invokeVelocimacro ( vmName , logTag , params , context , writer ) ; } catch ( IOException ioe ) { String msg = "Velocity.invokeVelocimacro(" + vmName + ") failed" ; getLog ( ) . error ( msg , ioe ) ; throw new VelocityException ( msg , ioe ) ; } } public static boolean mergeTemplate ( String templateName , Context context , Writer writer ) throws ResourceNotFoundException , ParseErrorException , MethodInvocationException , Exception { return mergeTemplate ( templateName , RuntimeSingleton . getString ( INPUT_ENCODING , ENCODING_DEFAULT ) , context , writer ) ; } public static boolean mergeTemplate ( String templateName , String encoding , Context context , Writer writer ) throws ResourceNotFoundException , ParseErrorException , MethodInvocationException , Exception { Template template = RuntimeSingleton . getTemplate ( templateName , encoding ) ; if ( template == null ) { String msg = "Velocity.mergeTemplate() was unable to load template '" + templateName + "'" ; getLog ( ) . error ( msg ) ; throw new ResourceNotFoundException ( msg ) ; } else { template . merge ( context , writer ) ; return true ; } } public static Template getTemplate ( String name ) throws ResourceNotFoundException , ParseErrorException , Exception { return RuntimeSingleton . getTemplate ( name ) ; } public static Template getTemplate ( String name , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception { return RuntimeSingleton . getTemplate ( name , encoding ) ; } public static boolean resourceExists ( String resourceName ) { return ( RuntimeSingleton . getLoaderNameForResource ( resourceName ) != null ) ; } public static Log getLog ( ) { return RuntimeSingleton . getLog ( ) ; } public static void warn ( Object message ) { getLog ( ) . warn ( message ) ; } public static void info ( Object message ) { getLog ( ) . info ( message ) ; } public static void error ( Object message ) { getLog ( ) . error ( message ) ; } public static void debug ( Object message ) { getLog ( ) . debug ( message ) ; } public static void setApplicationAttribute ( Object key , Object value ) { RuntimeSingleton . getRuntimeInstance ( ) . setApplicationAttribute ( key , value ) ; } public static boolean templateExists ( String resourceName ) { return resourceExists ( resourceName ) ; } } 	1	['25', '1', '0', '13', '59', '300', '1', '12', '25', '2', '220', '0', '0', '0', '0.16', '0', '0', '7.8', '2', '1', '2']
package org . apache . velocity . runtime . log ; public class Log4JLogSystem extends Log4JLogChute implements LogSystem { public void logVelocityMessage ( int level , String message ) { log ( level , message ) ; } } 	0	['2', '2', '0', '2', '4', '1', '0', '2', '2', '2', '10', '0', '0', '0.888888889', '0.666666667', '0', '0', '4', '1', '0.5', '0']
package org . apache . velocity . runtime . directive ; import java . io . IOException ; import java . io . Writer ; import org . apache . commons . lang . StringUtils ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . context . ProxyVMContext ; import org . apache . velocity . exception . MacroOverflowException ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . parser . ParserTreeConstants ; import org . apache . velocity . runtime . parser . node . ASTDirective ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . runtime . parser . node . SimpleNode ; public class VelocimacroProxy extends Directive { private String macroName ; private String [ ] argArray = null ; private String [ ] literalArgArray = null ; private SimpleNode nodeTree = null ; private int numMacroArgs = 0 ; private boolean preInit = false ; private boolean strictArguments ; private boolean localContextScope = false ; private int maxCallDepth ; public String getName ( ) { return macroName ; } public int getType ( ) { return LINE ; } public void setName ( String name ) { macroName = name ; } public void setArgArray ( String [ ] arr ) { argArray = arr ; literalArgArray = new String [ arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { literalArgArray [ i ] = ".literal.$" + argArray [ i ] ; } numMacroArgs = argArray . length - 1 ; } public void setNodeTree ( SimpleNode tree ) { nodeTree = tree ; } public int getNumArgs ( ) { return numMacroArgs ; } public boolean render ( InternalContextAdapter context , Writer writer , Node node ) throws IOException , MethodInvocationException , MacroOverflowException { final ProxyVMContext vmc = new ProxyVMContext ( context , rsvc , localContextScope ) ; int callArguments = node . jjtGetNumChildren ( ) ; if ( callArguments > 0 ) { for ( int i = 1 ; i < argArray . length && i <= callArguments ; i ++ ) { Node macroCallArgument = node . jjtGetChild ( i - 1 ) ; vmc . addVMProxyArg ( context , argArray [ i ] , literalArgArray [ i ] , macroCallArgument ) ; } } if ( maxCallDepth > 0 && maxCallDepth == vmc . getCurrentMacroCallDepth ( ) ) { String templateName = vmc . getCurrentTemplateName ( ) ; Object [ ] stack = vmc . getMacroNameStack ( ) ; StringBuffer out = new StringBuffer ( 100 ) . append ( "Max calling depth of " ) . append ( maxCallDepth ) . append ( " was exceeded in Template:" ) . append ( templateName ) . append ( " and Macro:" ) . append ( macroName ) . append ( " with Call Stack:" ) ; for ( int i = 0 ; i < stack . length ; i ++ ) { if ( i != 0 ) { out . append ( "->" ) ; } out . append ( stack [ i ] ) ; } rsvc . getLog ( ) . error ( out . toString ( ) ) ; try { throw new MacroOverflowException ( out . toString ( ) ) ; } finally { while ( vmc . getCurrentMacroCallDepth ( ) > 0 ) { vmc . popCurrentMacroName ( ) ; } } } try { vmc . pushCurrentMacroName ( macroName ) ; nodeTree . render ( vmc , writer ) ; vmc . popCurrentMacroName ( ) ; return true ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { String msg = "VelocimacroProxy.render() : exception VM = #" + macroName + "()" ; rsvc . getLog ( ) . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } } public void init ( RuntimeServices rs , InternalContextAdapter context , Node node ) throws TemplateInitException { synchronized ( this ) { if ( ! preInit ) { super . init ( rs , context , node ) ; strictArguments = rs . getConfiguration ( ) . getBoolean ( RuntimeConstants . VM_ARGUMENTS_STRICT , false ) ; localContextScope = rsvc . getBoolean ( RuntimeConstants . VM_CONTEXT_LOCALSCOPE , false ) ; maxCallDepth = rsvc . getInt ( RuntimeConstants . VM_MAX_DEPTH ) ; nodeTree . init ( context , rs ) ; preInit = true ; } } int i = node . jjtGetNumChildren ( ) ; if ( getNumArgs ( ) != i ) { for ( Node parent = node . jjtGetParent ( ) ; parent != null ; ) { if ( ( parent instanceof ASTDirective ) && StringUtils . equals ( ( ( ASTDirective ) parent ) . getDirectiveName ( ) , "macro" ) ) { return ; } parent = parent . jjtGetParent ( ) ; } String msg = "VM #" + macroName + ": too " + ( ( getNumArgs ( ) > i ) ? "few" : "many" ) + " arguments to macro. Wanted " + getNumArgs ( ) + " got " + i ; if ( strictArguments ) { throw new TemplateInitException ( msg , context . getCurrentTemplateName ( ) , 0 , 0 ) ; } else { rsvc . getLog ( ) . debug ( msg ) ; return ; } } for ( int n = 0 ; n < i ; n ++ ) { Node child = node . jjtGetChild ( n ) ; if ( child . getType ( ) == ParserTreeConstants . JJTWORD ) { throw new TemplateInitException ( "Invalid arg #" + n + " in VM #" + macroName , context . getCurrentTemplateName ( ) , 0 , 0 ) ; } } } } 	1	['9', '2', '0', '18', '44', '6', '4', '14', '9', '0.763888889', '415', '1', '1', '0.529411765', '0.25', '0', '0', '44.11111111', '2', '1', '7']
package org . apache . velocity . runtime . parser . node ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . util . HashMap ; import java . util . Map ; import java . util . List ; import java . util . ArrayList ; public abstract class MathUtils { protected static final BigDecimal DECIMAL_ZERO = new BigDecimal ( BigInteger . ZERO ) ; protected static final int BASE_LONG = 0 ; protected static final int BASE_FLOAT = 1 ; protected static final int BASE_DOUBLE = 2 ; protected static final int BASE_BIGINTEGER = 3 ; protected static final int BASE_BIGDECIMAL = 4 ; protected static final Map ints = new HashMap ( ) ; static { ints . put ( Byte . class , BigDecimal . valueOf ( Byte . MAX_VALUE ) ) ; ints . put ( Short . class , BigDecimal . valueOf ( Short . MAX_VALUE ) ) ; ints . put ( Integer . class , BigDecimal . valueOf ( Integer . MAX_VALUE ) ) ; ints . put ( Long . class , BigDecimal . valueOf ( Long . MAX_VALUE ) ) ; ints . put ( BigInteger . class , BigDecimal . valueOf ( - 1 ) ) ; } protected static final List typesBySize = new ArrayList ( ) ; static { typesBySize . add ( Byte . class ) ; typesBySize . add ( Short . class ) ; typesBySize . add ( Integer . class ) ; typesBySize . add ( Long . class ) ; typesBySize . add ( Float . class ) ; typesBySize . add ( Double . class ) ; } public static BigDecimal toBigDecimal ( Number n ) { if ( n instanceof BigDecimal ) { return ( BigDecimal ) n ; } if ( n instanceof BigInteger ) { return new BigDecimal ( ( BigInteger ) n ) ; } return new BigDecimal ( n . doubleValue ( ) ) ; } public static BigInteger toBigInteger ( Number n ) { if ( n instanceof BigInteger ) { return ( BigInteger ) n ; } return BigInteger . valueOf ( n . longValue ( ) ) ; } public static boolean isZero ( Number n ) { if ( isInteger ( n ) ) { if ( n instanceof BigInteger ) { return ( ( BigInteger ) n ) . compareTo ( BigInteger . ZERO ) == 0 ; } return n . doubleValue ( ) == 0 ; } if ( n instanceof Float ) { return n . floatValue ( ) == 0f ; } if ( n instanceof Double ) { return n . doubleValue ( ) == 0d ; } return toBigDecimal ( n ) . compareTo ( DECIMAL_ZERO ) == 0 ; } public static boolean isInteger ( Number n ) { return ints . containsKey ( n . getClass ( ) ) ; } public static Number wrapPrimitive ( long value , Class type ) { if ( type == Byte . class ) { if ( value > Byte . MAX_VALUE || value < Byte . MIN_VALUE ) { type = Short . class ; } else { return new Byte ( ( byte ) value ) ; } } if ( type == Short . class ) { if ( value > Short . MAX_VALUE || value < Short . MIN_VALUE ) { type = Integer . class ; } else { return new Short ( ( short ) value ) ; } } if ( type == Integer . class ) { if ( value > Integer . MAX_VALUE || value < Integer . MIN_VALUE ) { type = Long . class ; } else { return new Integer ( ( int ) value ) ; } } if ( type == Long . class ) { return new Long ( value ) ; } return BigInteger . valueOf ( value ) ; } private static Number wrapPrimitive ( long value , Number op1 , Number op2 ) { if ( typesBySize . indexOf ( op1 . getClass ( ) ) > typesBySize . indexOf ( op2 . getClass ( ) ) ) { return wrapPrimitive ( value , op1 . getClass ( ) ) ; } return wrapPrimitive ( value , op2 . getClass ( ) ) ; } private static int findCalculationBase ( Number op1 , Number op2 ) { boolean op1Int = isInteger ( op1 ) ; boolean op2Int = isInteger ( op2 ) ; if ( ( op1 instanceof BigDecimal || op2 instanceof BigDecimal ) || ( ( ! op1Int || ! op2Int ) && ( op1 instanceof BigInteger || op2 instanceof BigInteger ) ) ) { return BASE_BIGDECIMAL ; } if ( op1Int && op2Int ) { if ( op1 instanceof BigInteger || op2 instanceof BigInteger ) { return BASE_BIGINTEGER ; } return BASE_LONG ; } if ( ( op1 instanceof Double ) || ( op2 instanceof Double ) ) { return BASE_DOUBLE ; } return BASE_FLOAT ; } public static Number add ( Number op1 , Number op2 ) { int calcBase = findCalculationBase ( op1 , op2 ) ; switch ( calcBase ) { case BASE_BIGINTEGER : return toBigInteger ( op1 ) . add ( toBigInteger ( op2 ) ) ; case BASE_LONG : long l1 = op1 . longValue ( ) ; long l2 = op2 . longValue ( ) ; long result = l1 + l2 ; if ( ( result ^ l1 ) < 0 && ( result ^ l2 ) < 0 ) { return toBigInteger ( op1 ) . add ( toBigInteger ( op2 ) ) ; } return wrapPrimitive ( result , op1 , op2 ) ; case BASE_FLOAT : return new Float ( op1 . floatValue ( ) + op2 . floatValue ( ) ) ; case BASE_DOUBLE : return new Double ( op1 . doubleValue ( ) + op2 . doubleValue ( ) ) ; default : return toBigDecimal ( op1 ) . add ( toBigDecimal ( op2 ) ) ; } } public static Number subtract ( Number op1 , Number op2 ) { int calcBase = findCalculationBase ( op1 , op2 ) ; switch ( calcBase ) { case BASE_BIGINTEGER : return toBigInteger ( op1 ) . subtract ( toBigInteger ( op2 ) ) ; case BASE_LONG : long l1 = op1 . longValue ( ) ; long l2 = op2 . longValue ( ) ; long result = l1 - l2 ; if ( ( result ^ l1 ) < 0 && ( result ^ ~ l2 ) < 0 ) { return toBigInteger ( op1 ) . subtract ( toBigInteger ( op2 ) ) ; } return wrapPrimitive ( result , op1 , op2 ) ; case BASE_FLOAT : return new Float ( op1 . floatValue ( ) - op2 . floatValue ( ) ) ; case BASE_DOUBLE : return new Double ( op1 . doubleValue ( ) - op2 . doubleValue ( ) ) ; default : return toBigDecimal ( op1 ) . subtract ( toBigDecimal ( op2 ) ) ; } } public static Number multiply ( Number op1 , Number op2 ) { int calcBase = findCalculationBase ( op1 , op2 ) ; switch ( calcBase ) { case BASE_BIGINTEGER : return toBigInteger ( op1 ) . multiply ( toBigInteger ( op2 ) ) ; case BASE_LONG : long l1 = op1 . longValue ( ) ; long l2 = op2 . longValue ( ) ; long result = l1 * l2 ; if ( ( l2 != 0 ) && ( result / l2 != l1 ) ) { return toBigInteger ( op1 ) . multiply ( toBigInteger ( op2 ) ) ; } return wrapPrimitive ( result , op1 , op2 ) ; case BASE_FLOAT : return new Float ( op1 . floatValue ( ) * op2 . floatValue ( ) ) ; case BASE_DOUBLE : return new Double ( op1 . doubleValue ( ) * op2 . doubleValue ( ) ) ; default : return toBigDecimal ( op1 ) . multiply ( toBigDecimal ( op2 ) ) ; } } public static Number divide ( Number op1 , Number op2 ) { int calcBase = findCalculationBase ( op1 , op2 ) ; switch ( calcBase ) { case BASE_BIGINTEGER : BigInteger b1 = toBigInteger ( op1 ) ; BigInteger b2 = toBigInteger ( op2 ) ; return b1 . divide ( b2 ) ; case BASE_LONG : long l1 = op1 . longValue ( ) ; long l2 = op2 . longValue ( ) ; return wrapPrimitive ( l1 / l2 , op1 , op2 ) ; case BASE_FLOAT : return new Float ( op1 . floatValue ( ) / op2 . floatValue ( ) ) ; case BASE_DOUBLE : return new Double ( op1 . doubleValue ( ) / op2 . doubleValue ( ) ) ; default : return toBigDecimal ( op1 ) . divide ( toBigDecimal ( op2 ) , BigDecimal . ROUND_HALF_DOWN ) ; } } public static Number modulo ( Number op1 , Number op2 ) throws ArithmeticException { int calcBase = findCalculationBase ( op1 , op2 ) ; switch ( calcBase ) { case BASE_BIGINTEGER : return toBigInteger ( op1 ) . mod ( toBigInteger ( op2 ) ) ; case BASE_LONG : return wrapPrimitive ( op1 . longValue ( ) % op2 . longValue ( ) , op1 , op2 ) ; case BASE_FLOAT : return new Float ( op1 . floatValue ( ) % op2 . floatValue ( ) ) ; case BASE_DOUBLE : return new Double ( op1 . doubleValue ( ) % op2 . doubleValue ( ) ) ; default : throw new ArithmeticException ( "Cannot calculate the modulo of BigDecimals." ) ; } } public static int compare ( Number op1 , Number op2 ) { int calcBase = findCalculationBase ( op1 , op2 ) ; switch ( calcBase ) { case BASE_BIGINTEGER : return toBigInteger ( op1 ) . compareTo ( toBigInteger ( op2 ) ) ; case BASE_LONG : long l1 = op1 . longValue ( ) ; long l2 = op2 . longValue ( ) ; if ( l1 < l2 ) { return - 1 ; } if ( l1 > l2 ) { return 1 ; } return 0 ; case BASE_FLOAT : float f1 = op1 . floatValue ( ) ; float f2 = op2 . floatValue ( ) ; if ( f1 < f2 ) { return - 1 ; } if ( f1 > f2 ) { return 1 ; } return 0 ; case BASE_DOUBLE : double d1 = op1 . doubleValue ( ) ; double d2 = op2 . doubleValue ( ) ; if ( d1 < d2 ) { return - 1 ; } if ( d1 > d2 ) { return 1 ; } return 0 ; default : return toBigDecimal ( op1 ) . compareTo ( toBigDecimal ( op2 ) ) ; } } } 	0	['16', '1', '0', '11', '52', '112', '11', '0', '12', '0.826666667', '854', '0.533333333', '0', '0', '0.226666667', '0', '0', '51.4375', '18', '4.5625', '0']
package org . apache . velocity . runtime . directive ; import java . io . IOException ; import java . io . Writer ; import org . apache . velocity . app . event . EventHandlerUtil ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . parser . ParserTreeConstants ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . runtime . resource . Resource ; public class Include extends InputBase { private String outputMsgStart = "" ; private String outputMsgEnd = "" ; public String getName ( ) { return "include" ; } public int getType ( ) { return LINE ; } public void init ( RuntimeServices rs , InternalContextAdapter context , Node node ) throws TemplateInitException { super . init ( rs , context , node ) ; outputMsgStart = rsvc . getString ( RuntimeConstants . ERRORMSG_START ) ; outputMsgStart = outputMsgStart + " " ; outputMsgEnd = rsvc . getString ( RuntimeConstants . ERRORMSG_END ) ; outputMsgEnd = " " + outputMsgEnd ; } public boolean render ( InternalContextAdapter context , Writer writer , Node node ) throws IOException , MethodInvocationException , ResourceNotFoundException { int argCount = node . jjtGetNumChildren ( ) ; for ( int i = 0 ; i < argCount ; i ++ ) { Node n = node . jjtGetChild ( i ) ; if ( n . getType ( ) == ParserTreeConstants . JJTSTRINGLITERAL || n . getType ( ) == ParserTreeConstants . JJTREFERENCE ) { if ( ! renderOutput ( n , context , writer ) ) outputErrorToStream ( writer , "error with arg " + i + " please see log." ) ; } else { String msg = "invalid #include() argument type [line " + getLine ( ) + ", column " + getColumn ( ) + ", template " + context . getCurrentTemplateName ( ) + "]: " + n . toString ( ) ; rsvc . getLog ( ) . error ( msg ) ; outputErrorToStream ( writer , "error with arg " + i + " please see log." ) ; throw new VelocityException ( msg ) ; } } return true ; } private boolean renderOutput ( Node node , InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException , ResourceNotFoundException { if ( node == null ) { rsvc . getLog ( ) . error ( "#include() null argument" ) ; return false ; } Object value = node . value ( context ) ; if ( value == null ) { rsvc . getLog ( ) . error ( "#include()  null argument" ) ; return false ; } String sourcearg = value . toString ( ) ; String arg = EventHandlerUtil . includeEvent ( rsvc , context , sourcearg , context . getCurrentTemplateName ( ) , getName ( ) ) ; boolean blockinput = false ; if ( arg == null ) blockinput = true ; Resource resource = null ; try { if ( ! blockinput ) resource = rsvc . getContent ( arg , getInputEncoding ( context ) ) ; } catch ( ResourceNotFoundException rnfe ) { rsvc . getLog ( ) . error ( "#include(): cannot find resource '" + arg + "', called from template " + context . getCurrentTemplateName ( ) + " at (" + getLine ( ) + ", " + getColumn ( ) + ")" ) ; throw rnfe ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { String msg = "#include(): arg = '" + arg + "', called from template " + context . getCurrentTemplateName ( ) + " at (" + getLine ( ) + ", " + getColumn ( ) + ')' ; rsvc . getLog ( ) . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } if ( blockinput ) return true ; else if ( resource == null ) return false ; writer . write ( ( String ) resource . getData ( ) ) ; return true ; } private void outputErrorToStream ( Writer writer , String msg ) throws IOException { if ( outputMsgStart != null && outputMsgEnd != null ) { writer . write ( outputMsgStart ) ; writer . write ( msg ) ; writer . write ( outputMsgEnd ) ; } } } 	1	['7', '3', '0', '13', '31', '9', '0', '13', '5', '0.5', '298', '1', '0', '0.625', '0.428571429', '0', '0', '41.28571429', '1', '0.8571', '1']
package org . apache . velocity . runtime . resource . loader ; import java . io . InputStream ; import java . io . IOException ; import java . lang . reflect . Method ; import java . net . URL ; import java . net . URLConnection ; import java . util . HashMap ; import org . apache . commons . collections . ExtendedProperties ; import org . apache . commons . lang . StringUtils ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . runtime . resource . Resource ; public class URLResourceLoader extends ResourceLoader { private String [ ] roots = null ; protected HashMap templateRoots = null ; private int timeout = - 1 ; private Method [ ] timeoutMethods ; public void init ( ExtendedProperties configuration ) { log . trace ( "URLResourceLoader : initialization starting." ) ; roots = configuration . getStringArray ( "root" ) ; if ( log . isDebugEnabled ( ) ) { for ( int i = 0 ; i < roots . length ; i ++ ) { log . debug ( "URLResourceLoader : adding root '" + roots [ i ] + "'" ) ; } } timeout = configuration . getInt ( "timeout" , - 1 ) ; if ( timeout > 0 ) { try { Class [ ] types = new Class [ ] { Integer . TYPE } ; Method conn = URLConnection . class . getMethod ( "setConnectTimeout" , types ) ; Method read = URLConnection . class . getMethod ( "setReadTimeout" , types ) ; timeoutMethods = new Method [ ] { conn , read } ; log . debug ( "URLResourceLoader : timeout set to " + timeout ) ; } catch ( NoSuchMethodException nsme ) { log . debug ( "URLResourceLoader : Java 1.5+ is required to customize timeout!" , nsme ) ; timeout = - 1 ; } } templateRoots = new HashMap ( ) ; log . trace ( "URLResourceLoader : initialization complete." ) ; } public synchronized InputStream getResourceStream ( String name ) throws ResourceNotFoundException { if ( StringUtils . isEmpty ( name ) ) { throw new ResourceNotFoundException ( "URLResourceLoader : No template name provided" ) ; } InputStream inputStream = null ; Exception exception = null ; for ( int i = 0 ; i < roots . length ; i ++ ) { try { URL u = new URL ( roots [ i ] + name ) ; URLConnection conn = u . openConnection ( ) ; tryToSetTimeout ( conn ) ; inputStream = conn . getInputStream ( ) ; if ( inputStream != null ) { if ( log . isDebugEnabled ( ) ) log . debug ( "URLResourceLoader: Found '" + name + "' at '" + roots [ i ] + "'" ) ; templateRoots . put ( name , roots [ i ] ) ; break ; } } catch ( IOException ioe ) { if ( log . isDebugEnabled ( ) ) log . debug ( "URLResourceLoader: Exception when looking for '" + name + "' at '" + roots [ i ] + "'" , ioe ) ; if ( exception == null ) { exception = ioe ; } } } if ( inputStream == null ) { String msg ; if ( exception == null ) { msg = "URLResourceLoader : Resource '" + name + "' not found." ; } else { msg = exception . getMessage ( ) ; } throw new ResourceNotFoundException ( msg ) ; } return inputStream ; } public boolean isSourceModified ( Resource resource ) { long fileLastModified = getLastModified ( resource ) ; if ( fileLastModified == 0 || fileLastModified != resource . getLastModified ( ) ) { return true ; } return false ; } public long getLastModified ( Resource resource ) { String name = resource . getName ( ) ; String root = ( String ) templateRoots . get ( name ) ; try { URL u = new URL ( root + name ) ; URLConnection conn = u . openConnection ( ) ; tryToSetTimeout ( conn ) ; return conn . getLastModified ( ) ; } catch ( IOException ioe ) { String msg = "URLResourceLoader: '" + name + "' is no longer reachable at '" + root + "'" ; log . error ( msg , ioe ) ; throw new ResourceNotFoundException ( msg , ioe ) ; } } public int getTimeout ( ) { return timeout ; } private void tryToSetTimeout ( URLConnection conn ) { if ( timeout > 0 ) { Object [ ] arg = new Object [ ] { new Integer ( timeout ) } ; try { timeoutMethods [ 0 ] . invoke ( conn , arg ) ; timeoutMethods [ 1 ] . invoke ( conn , arg ) ; } catch ( Exception e ) { String msg = "Unexpected exception while setting connection timeout for " + conn ; log . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } } } } 	0	['8', '2', '0', '7', '41', '2', '0', '7', '6', '0.6', '425', '0.8', '0', '0.631578947', '0.325', '1', '2', '51.5', '6', '1.875', '0']
package org . apache . velocity . runtime . resource ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . resource . loader . ResourceLoader ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . ParseErrorException ; public abstract class Resource { protected RuntimeServices rsvc = null ; protected ResourceLoader resourceLoader ; protected static final long MILLIS_PER_SECOND = 1000 ; protected long modificationCheckInterval = 0 ; protected long lastModified = 0 ; protected long nextCheck = 0 ; protected String name ; protected String encoding = RuntimeConstants . ENCODING_DEFAULT ; protected Object data = null ; protected int type ; public Resource ( ) { } public void setRuntimeServices ( RuntimeServices rs ) { rsvc = rs ; } public abstract boolean process ( ) throws ResourceNotFoundException , ParseErrorException , Exception ; public boolean isSourceModified ( ) { return resourceLoader . isSourceModified ( this ) ; } public void setModificationCheckInterval ( long modificationCheckInterval ) { this . modificationCheckInterval = modificationCheckInterval ; } public boolean requiresChecking ( ) { if ( modificationCheckInterval <= 0 ) { return false ; } return ( System . currentTimeMillis ( ) >= nextCheck ) ; } public void touch ( ) { nextCheck = System . currentTimeMillis ( ) + ( MILLIS_PER_SECOND * modificationCheckInterval ) ; } public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String getEncoding ( ) { return encoding ; } public long getLastModified ( ) { return lastModified ; } public void setLastModified ( long lastModified ) { this . lastModified = lastModified ; } public ResourceLoader getResourceLoader ( ) { return resourceLoader ; } public void setResourceLoader ( ResourceLoader resourceLoader ) { this . resourceLoader = resourceLoader ; } public void setData ( Object data ) { this . data = data ; } public Object getData ( ) { return data ; } public void setType ( int type ) { this . type = type ; } public int getType ( ) { return type ; } } 	1	['19', '1', '2', '25', '22', '129', '22', '4', '19', '0.916666667', '130', '1', '2', '0', '0.203007519', '0', '0', '5.315789474', '3', '1.0526', '1']
package org . apache . velocity . context ; public interface InternalWrapperContext { Context getInternalUserContext ( ) ; InternalContextAdapter getBaseContext ( ) ; Object localPut ( final String key , final Object value ) ; } 	0	['3', '1', '0', '2', '3', '3', '1', '2', '3', '2', '3', '0', '0', '0', '0.555555556', '0', '0', '0', '1', '1', '0']
package org . apache . velocity . runtime ; public interface RuntimeConstants { String RUNTIME_LOG = "runtime.log" ; String RUNTIME_LOG_LOGSYSTEM = "runtime.log.logsystem" ; String RUNTIME_LOG_LOGSYSTEM_CLASS = "runtime.log.logsystem.class" ; String RUNTIME_REFERENCES_STRICT = "runtime.references.strict" ; String RUNTIME_LOG_ERROR_STACKTRACE = "runtime.log.error.stacktrace" ; String RUNTIME_LOG_WARN_STACKTRACE = "runtime.log.warn.stacktrace" ; String RUNTIME_LOG_INFO_STACKTRACE = "runtime.log.info.stacktrace" ; String RUNTIME_LOG_REFERENCE_LOG_INVALID = "runtime.log.invalid.references" ; String TRACE_PREFIX = " [trace] " ; String DEBUG_PREFIX = " [debug] " ; String INFO_PREFIX = "  [info] " ; String WARN_PREFIX = "  [warn] " ; String ERROR_PREFIX = " [error] " ; String UNKNOWN_PREFIX = " [unknown] " ; String COUNTER_NAME = "directive.foreach.counter.name" ; String HAS_NEXT_NAME = "directive.foreach.iterator.name" ; String COUNTER_INITIAL_VALUE = "directive.foreach.counter.initial.value" ; String MAX_NUMBER_LOOPS = "directive.foreach.maxloops" ; String SKIP_INVALID_ITERATOR = "directive.foreach.skip.invalid" ; String SET_NULL_ALLOWED = "directive.set.null.allowed" ; String ERRORMSG_START = "directive.include.output.errormsg.start" ; String ERRORMSG_END = "directive.include.output.errormsg.end" ; String PARSE_DIRECTIVE_MAXDEPTH = "directive.parse.max.depth" ; String DEFINE_DIRECTIVE_MAXDEPTH = "directive.define.max.depth" ; String EVALUATE_CONTEXT_CLASS = "directive.evaluate.context.class" ; String RESOURCE_MANAGER_CLASS = "resource.manager.class" ; String RESOURCE_MANAGER_CACHE_CLASS = "resource.manager.cache.class" ; String RESOURCE_MANAGER_DEFAULTCACHE_SIZE = "resource.manager.defaultcache.size" ; String RESOURCE_MANAGER_LOGWHENFOUND = "resource.manager.logwhenfound" ; String RESOURCE_LOADER = "resource.loader" ; String FILE_RESOURCE_LOADER_PATH = "file.resource.loader.path" ; String FILE_RESOURCE_LOADER_CACHE = "file.resource.loader.cache" ; String EVENTHANDLER_REFERENCEINSERTION = "eventhandler.referenceinsertion.class" ; String EVENTHANDLER_NULLSET = "eventhandler.nullset.class" ; String EVENTHANDLER_METHODEXCEPTION = "eventhandler.methodexception.class" ; String EVENTHANDLER_INCLUDE = "eventhandler.include.class" ; String EVENTHANDLER_INVALIDREFERENCES = "eventhandler.invalidreferences.class" ; String VM_LIBRARY = "velocimacro.library" ; String VM_LIBRARY_DEFAULT = "VM_global_library.vm" ; String VM_LIBRARY_AUTORELOAD = "velocimacro.library.autoreload" ; String VM_PERM_ALLOW_INLINE = "velocimacro.permissions.allow.inline" ; String VM_PERM_ALLOW_INLINE_REPLACE_GLOBAL = "velocimacro.permissions.allow.inline.to.replace.global" ; String VM_PERM_INLINE_LOCAL = "velocimacro.permissions.allow.inline.local.scope" ; String VM_MESSAGES_ON = "velocimacro.messages.on" ; String VM_CONTEXT_LOCALSCOPE = "velocimacro.context.localscope" ; String VM_ARGUMENTS_STRICT = "velocimacro.arguments.strict" ; String VM_MAX_DEPTH = "velocimacro.max.depth" ; String INTERPOLATE_STRINGLITERALS = "runtime.interpolate.string.literals" ; String INPUT_ENCODING = "input.encoding" ; String OUTPUT_ENCODING = "output.encoding" ; String ENCODING_DEFAULT = "ISO-8859-1" ; String UBERSPECT_CLASSNAME = "runtime.introspector.uberspect" ; String INTROSPECTOR_RESTRICT_PACKAGES = "introspector.restrict.packages" ; String INTROSPECTOR_RESTRICT_CLASSES = "introspector.restrict.classes" ; String STRICT_MATH = "runtime.strict.math" ; String PARSER_POOL_CLASS = "parser.pool.class" ; String PARSER_POOL_SIZE = "parser.pool.size" ; String DEFAULT_RUNTIME_PROPERTIES = "org/apache/velocity/runtime/defaults/velocity.properties" ; String DEFAULT_RUNTIME_DIRECTIVES = "org/apache/velocity/runtime/defaults/directive.properties" ; int NUMBER_OF_PARSERS = 20 ; } 	1	['0', '1', '0', '5', '0', '0', '5', '0', '0', '2', '60', '0', '0', '0', '0', '0', '0', '0', '0', '0', '5']
package org . apache . velocity . util . introspection ; public interface SecureIntrospectorControl { public boolean checkObjectExecutePermission ( Class clazz , String method ) ; } 	0	['1', '1', '0', '2', '1', '0', '2', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . velocity . runtime . directive ; import java . io . IOException ; import java . io . Writer ; import java . util . List ; import java . util . ArrayList ; import org . apache . velocity . Template ; import org . apache . velocity . app . event . EventHandlerUtil ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . runtime . parser . node . SimpleNode ; public class Parse extends InputBase { private int maxDepth ; public String getName ( ) { return "parse" ; } public int getType ( ) { return LINE ; } public void init ( RuntimeServices rs , InternalContextAdapter context , Node node ) throws TemplateInitException { super . init ( rs , context , node ) ; this . maxDepth = rsvc . getInt ( RuntimeConstants . PARSE_DIRECTIVE_MAXDEPTH , 10 ) ; } public boolean render ( InternalContextAdapter context , Writer writer , Node node ) throws IOException , ResourceNotFoundException , ParseErrorException , MethodInvocationException { if ( ! context . getAllowRendering ( ) ) { return true ; } if ( node . jjtGetChild ( 0 ) == null ) { rsvc . getLog ( ) . error ( "#parse() null argument" ) ; return false ; } Object value = node . jjtGetChild ( 0 ) . value ( context ) ; if ( value == null ) { rsvc . getLog ( ) . error ( "#parse() null argument" ) ; return false ; } String sourcearg = value . toString ( ) ; String arg = EventHandlerUtil . includeEvent ( rsvc , context , sourcearg , context . getCurrentTemplateName ( ) , getName ( ) ) ; boolean blockinput = false ; if ( arg == null ) blockinput = true ; if ( maxDepth > 0 ) { Object [ ] templateStack = context . getTemplateNameStack ( ) ; if ( templateStack . length >= maxDepth ) { StringBuffer path = new StringBuffer ( ) ; for ( int i = 0 ; i < templateStack . length ; ++ i ) { path . append ( " > " + templateStack [ i ] ) ; } rsvc . getLog ( ) . error ( "Max recursion depth reached (" + templateStack . length + ')' + " File stack:" + path ) ; return false ; } } Template t = null ; try { if ( ! blockinput ) t = rsvc . getTemplate ( arg , getInputEncoding ( context ) ) ; } catch ( ResourceNotFoundException rnfe ) { rsvc . getLog ( ) . error ( "#parse(): cannot find template '" + arg + "', called from template " + context . getCurrentTemplateName ( ) + " at (" + getLine ( ) + ", " + getColumn ( ) + ")" ) ; throw rnfe ; } catch ( ParseErrorException pee ) { rsvc . getLog ( ) . error ( "#parse(): syntax error in #parse()-ed template '" + arg + "', called from template " + context . getCurrentTemplateName ( ) + " at (" + getLine ( ) + ", " + getColumn ( ) + ")" ) ; throw pee ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { String msg = "#parse() : arg = " + arg + '.' ; rsvc . getLog ( ) . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } List macroLibraries = context . getMacroLibraries ( ) ; if ( macroLibraries == null ) { macroLibraries = new ArrayList ( ) ; } context . setMacroLibraries ( macroLibraries ) ; macroLibraries . add ( arg ) ; try { if ( ! blockinput ) { context . pushCurrentTemplateName ( arg ) ; ( ( SimpleNode ) t . getData ( ) ) . render ( context , writer ) ; } } catch ( MethodInvocationException e ) { throw e ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { String msg = "Exception rendering #parse(" + arg + ')' ; rsvc . getLog ( ) . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } finally { if ( ! blockinput ) context . popCurrentTemplateName ( ) ; } return true ; } } 	1	['5', '3', '0', '14', '36', '8', '0', '14', '5', '0.75', '322', '1', '0', '0.714285714', '0.44', '1', '1', '63.2', '1', '0.8', '2']
package org . apache . velocity . util . introspection ; public interface VelPropertyGet { public Object invoke ( Object o ) throws Exception ; public boolean isCacheable ( ) ; public String getMethodName ( ) ; } 	0	['3', '1', '0', '6', '3', '3', '6', '0', '3', '2', '3', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . velocity . runtime . log ; import org . apache . velocity . runtime . RuntimeServices ; public interface LogChute { String TRACE_PREFIX = " [trace] " ; String DEBUG_PREFIX = " [debug] " ; String INFO_PREFIX = "  [info] " ; String WARN_PREFIX = "  [warn] " ; String ERROR_PREFIX = " [error] " ; int TRACE_ID = - 1 ; int DEBUG_ID = 0 ; int INFO_ID = 1 ; int WARN_ID = 2 ; int ERROR_ID = 3 ; void init ( RuntimeServices rs ) throws Exception ; void log ( int level , String message ) ; void log ( int level , String message , Throwable t ) ; boolean isLevelEnabled ( int level ) ; } 	1	['4', '1', '0', '15', '4', '6', '14', '1', '4', '1.333333333', '14', '0', '0', '0', '0.55', '0', '0', '0', '1', '1', '2']
package org . apache . velocity . runtime . log ; import java . util . Date ; import org . apache . log . format . PatternFormatter ; public class VelocityFormatter extends PatternFormatter { public VelocityFormatter ( String format ) { super ( format ) ; } protected String getTime ( final long time , final String format ) { return new Date ( ) . toString ( ) ; } } 	0	['2', '2', '0', '2', '5', '1', '1', '1', '1', '2', '11', '0', '0', '0.941176471', '0.833333333', '1', '2', '4.5', '1', '0.5', '0']
package org . apache . velocity . runtime . log ; import java . util . List ; import java . util . ArrayList ; import java . util . Iterator ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . util . ClassUtils ; public class LogManager { private static LogChute createLogChute ( RuntimeServices rsvc ) throws Exception { Log log = rsvc . getLog ( ) ; Object o = rsvc . getProperty ( RuntimeConstants . RUNTIME_LOG_LOGSYSTEM ) ; if ( o != null ) { if ( o instanceof LogChute ) { try { ( ( LogChute ) o ) . init ( rsvc ) ; return ( LogChute ) o ; } catch ( Exception e ) { String msg = "Could not init runtime.log.logsystem " + o ; log . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } } else if ( o instanceof LogSystem ) { log . debug ( "LogSystem has been deprecated. Please use a LogChute implementation." ) ; try { LogChute chute = new LogChuteSystem ( ( LogSystem ) o ) ; chute . init ( rsvc ) ; return chute ; } catch ( Exception e ) { String msg = "Could not init runtime.log.logsystem " + o ; log . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } } else { String msg = o . getClass ( ) . getName ( ) + " object set as runtime.log.logsystem is not a valid log implementation." ; log . error ( msg ) ; throw new VelocityException ( msg ) ; } } List classes = new ArrayList ( ) ; Object obj = rsvc . getProperty ( RuntimeConstants . RUNTIME_LOG_LOGSYSTEM_CLASS ) ; if ( obj instanceof List ) { classes = ( List ) obj ; } else if ( obj instanceof String ) { classes . add ( obj ) ; } for ( Iterator ii = classes . iterator ( ) ; ii . hasNext ( ) ; ) { String claz = ( String ) ii . next ( ) ; if ( claz != null && claz . length ( ) > 0 ) { log . debug ( "Trying to use logger class " + claz ) ; try { o = ClassUtils . getNewInstance ( claz ) ; if ( o instanceof LogChute ) { ( ( LogChute ) o ) . init ( rsvc ) ; log . debug ( "Using logger class " + claz ) ; return ( LogChute ) o ; } else if ( o instanceof LogSystem ) { log . debug ( "LogSystem has been deprecated. Please use a LogChute implementation." ) ; LogChute chute = new LogChuteSystem ( ( LogSystem ) o ) ; chute . init ( rsvc ) ; return chute ; } else { String msg = "The specified logger class " + claz + " does not implement the " + LogChute . class . getName ( ) + " interface." ; log . error ( msg ) ; if ( isProbablyProvidedLogChute ( claz ) ) { log . error ( "This appears to be a ClassLoader issue.  Check for multiple Velocity jars in your classpath." ) ; } throw new VelocityException ( msg ) ; } } catch ( NoClassDefFoundError ncdfe ) { if ( isProbablyProvidedLogChute ( claz ) ) { log . debug ( "Target log system for " + claz + " is not available (" + ncdfe . toString ( ) + ").  Falling back to next log system..." ) ; } else { log . debug ( "Couldn't find class " + claz + " or necessary supporting classes in classpath." , ncdfe ) ; } } catch ( Exception e ) { String msg = "Failed to initialize an instance of " + claz + " with the current runtime configuration." ; log . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } } } LogChute slc = new SystemLogChute ( ) ; slc . init ( rsvc ) ; log . debug ( "Using SystemLogChute." ) ; return slc ; } private static boolean isProbablyProvidedLogChute ( String claz ) { if ( claz == null ) { return false ; } else { return ( claz . startsWith ( "org.apache.velocity.runtime.log" ) && claz . endsWith ( "LogChute" ) ) ; } } public static void updateLog ( Log log , RuntimeServices rsvc ) throws Exception { LogChute newLogChute = createLogChute ( rsvc ) ; LogChute oldLogChute = log . getLogChute ( ) ; log . setLogChute ( newLogChute ) ; if ( oldLogChute instanceof HoldingLogChute ) { HoldingLogChute hlc = ( HoldingLogChute ) oldLogChute ; hlc . transferTo ( newLogChute ) ; } } } 	1	['5', '1', '0', '10', '39', '10', '1', '9', '2', '0.75', '344', '0', '0', '0', '0.3', '0', '0', '67.6', '4', '1.4', '2']
package org . apache . velocity . util . introspection ; public interface VelPropertySet { public Object invoke ( Object o , Object arg ) throws Exception ; public boolean isCacheable ( ) ; public String getMethodName ( ) ; } 	0	['3', '1', '0', '6', '3', '3', '6', '0', '3', '2', '3', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . velocity . runtime . parser ; public interface ParserConstants { int EOF = 0 ; int LBRACKET = 1 ; int RBRACKET = 2 ; int COMMA = 3 ; int DOUBLEDOT = 4 ; int COLON = 5 ; int LEFT_CURLEY = 6 ; int RIGHT_CURLEY = 7 ; int LPAREN = 8 ; int RPAREN = 9 ; int REFMOD2_RPAREN = 10 ; int ESCAPE_DIRECTIVE = 11 ; int SET_DIRECTIVE = 12 ; int DOLLAR = 13 ; int DOLLARBANG = 14 ; int HASH = 17 ; int SINGLE_LINE_COMMENT_START = 18 ; int DOUBLE_ESCAPE = 19 ; int ESCAPE = 20 ; int TEXT = 21 ; int SINGLE_LINE_COMMENT = 22 ; int FORMAL_COMMENT = 23 ; int MULTI_LINE_COMMENT = 24 ; int WHITESPACE = 26 ; int STRING_LITERAL = 27 ; int TRUE = 28 ; int FALSE = 29 ; int NEWLINE = 30 ; int MINUS = 31 ; int PLUS = 32 ; int MULTIPLY = 33 ; int DIVIDE = 34 ; int MODULUS = 35 ; int LOGICAL_AND = 36 ; int LOGICAL_OR = 37 ; int LOGICAL_LT = 38 ; int LOGICAL_LE = 39 ; int LOGICAL_GT = 40 ; int LOGICAL_GE = 41 ; int LOGICAL_EQUALS = 42 ; int LOGICAL_NOT_EQUALS = 43 ; int LOGICAL_NOT = 44 ; int EQUALS = 45 ; int END = 46 ; int IF_DIRECTIVE = 47 ; int ELSEIF_DIRECTIVE = 48 ; int ELSE_DIRECTIVE = 49 ; int STOP_DIRECTIVE = 50 ; int DIGIT = 51 ; int INTEGER_LITERAL = 52 ; int FLOATING_POINT_LITERAL = 53 ; int EXPONENT = 54 ; int LETTER = 55 ; int DIRECTIVE_CHAR = 56 ; int WORD = 57 ; int BRACKETED_WORD = 58 ; int ALPHA_CHAR = 59 ; int ALPHANUM_CHAR = 60 ; int IDENTIFIER_CHAR = 61 ; int IDENTIFIER = 62 ; int DOT = 63 ; int LCURLY = 64 ; int RCURLY = 65 ; int REFERENCE_TERMINATOR = 66 ; int DIRECTIVE_TERMINATOR = 67 ; int DIRECTIVE = 0 ; int REFMOD2 = 1 ; int REFMODIFIER = 2 ; int DEFAULT = 3 ; int REFERENCE = 4 ; int PRE_DIRECTIVE = 5 ; int IN_MULTI_LINE_COMMENT = 6 ; int IN_FORMAL_COMMENT = 7 ; int IN_SINGLE_LINE_COMMENT = 8 ; String [ ] tokenImage = { "<EOF>" , "\"[\"" , "\"]\"" , "\",\"" , "\"..\"" , "\":\"" , "\"{\"" , "\"}\"" , "\"(\"" , "<RPAREN>" , "\")\"" , "<ESCAPE_DIRECTIVE>" , "<SET_DIRECTIVE>" , "<DOLLAR>" , "<DOLLARBANG>" , "<token of kind 15>" , "\"#*\"" , "\"#\"" , "\"##\"" , "\"\\\\\\\\\"" , "\"\\\\\"" , "<TEXT>" , "<SINGLE_LINE_COMMENT>" , "\"*#\"" , "\"*#\"" , "<token of kind 25>" , "<WHITESPACE>" , "<STRING_LITERAL>" , "\"true\"" , "\"false\"" , "<NEWLINE>" , "\"-\"" , "\"+\"" , "\"*\"" , "\"/\"" , "\"%\"" , "<LOGICAL_AND>" , "<LOGICAL_OR>" , "<LOGICAL_LT>" , "<LOGICAL_LE>" , "<LOGICAL_GT>" , "<LOGICAL_GE>" , "<LOGICAL_EQUALS>" , "<LOGICAL_NOT_EQUALS>" , "<LOGICAL_NOT>" , "\"=\"" , "<END>" , "<IF_DIRECTIVE>" , "<ELSEIF_DIRECTIVE>" , "<ELSE_DIRECTIVE>" , "<STOP_DIRECTIVE>" , "<DIGIT>" , "<INTEGER_LITERAL>" , "<FLOATING_POINT_LITERAL>" , "<EXPONENT>" , "<LETTER>" , "<DIRECTIVE_CHAR>" , "<WORD>" , "<BRACKETED_WORD>" , "<ALPHA_CHAR>" , "<ALPHANUM_CHAR>" , "<IDENTIFIER_CHAR>" , "<IDENTIFIER>" , "<DOT>" , "\"{\"" , "\"}\"" , "<REFERENCE_TERMINATOR>" , "<DIRECTIVE_TERMINATOR>" , } ; } 	1	['1', '1', '0', '2', '1', '0', '2', '0', '0', '2', '352', '0', '0', '0', '0', '0', '0', '276', '0', '0', '6']
package org . apache . velocity . runtime . parser ; public interface CharStream { char readChar ( ) throws java . io . IOException ; int getColumn ( ) ; int getLine ( ) ; int getEndColumn ( ) ; int getEndLine ( ) ; int getBeginColumn ( ) ; int getBeginLine ( ) ; void backup ( int amount ) ; char BeginToken ( ) throws java . io . IOException ; String GetImage ( ) ; char [ ] GetSuffix ( int len ) ; void Done ( ) ; } 	0	['12', '1', '0', '4', '12', '66', '4', '0', '12', '2', '12', '0', '0', '0', '0.583333333', '0', '0', '0', '1', '1', '0']
package org . apache . velocity . runtime . log ; import org . apache . velocity . runtime . RuntimeServices ; public interface LogSystem { public final static boolean DEBUG_ON = true ; public final static int DEBUG_ID = 0 ; public final static int INFO_ID = 1 ; public final static int WARN_ID = 2 ; public final static int ERROR_ID = 3 ; public void init ( RuntimeServices rs ) throws Exception ; public void logVelocityMessage ( int level , String message ) ; } 	1	['2', '1', '0', '8', '2', '1', '7', '1', '2', '2', '7', '0', '0', '0', '0.625', '0', '0', '0', '1', '1', '2']
package org . apache . velocity . runtime . parser ; public class Token { public int kind ; public int beginLine , beginColumn , endLine , endColumn ; public String image ; public Token next ; public Token specialToken ; public String toString ( ) { return image ; } public static final Token newToken ( int ofKind ) { switch ( ofKind ) { default : return new Token ( ) ; } } } 	0	['3', '1', '0', '25', '4', '3', '25', '0', '3', '1.4375', '23', '0', '2', '0', '0.5', '0', '0', '4', '2', '1', '0']
package org . apache . velocity . runtime ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . Reader ; import java . io . StringReader ; import java . io . Writer ; import java . util . Enumeration ; import java . util . HashMap ; import java . util . Hashtable ; import java . util . Map ; import java . util . Properties ; import org . apache . commons . collections . ExtendedProperties ; import org . apache . commons . lang . text . StrBuilder ; import org . apache . velocity . Template ; import org . apache . velocity . app . event . EventCartridge ; import org . apache . velocity . app . event . EventHandler ; import org . apache . velocity . app . event . IncludeEventHandler ; import org . apache . velocity . app . event . InvalidReferenceEventHandler ; import org . apache . velocity . app . event . MethodExceptionEventHandler ; import org . apache . velocity . app . event . NullSetEventHandler ; import org . apache . velocity . app . event . ReferenceInsertionEventHandler ; import org . apache . velocity . context . Context ; import org . apache . velocity . context . InternalContextAdapterImpl ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . runtime . directive . Directive ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . log . LogManager ; import org . apache . velocity . runtime . parser . ParseException ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . runtime . parser . node . SimpleNode ; import org . apache . velocity . runtime . resource . ContentResource ; import org . apache . velocity . runtime . resource . ResourceManager ; import org . apache . velocity . util . ClassUtils ; import org . apache . velocity . util . RuntimeServicesAware ; import org . apache . velocity . util . StringUtils ; import org . apache . velocity . util . introspection . Introspector ; import org . apache . velocity . util . introspection . Uberspect ; import org . apache . velocity . util . introspection . UberspectLoggable ; import org . apache . velocity . util . introspection . ChainableUberspector ; import org . apache . velocity . util . introspection . LinkingUberspector ; public class RuntimeInstance implements RuntimeConstants , RuntimeServices { private VelocimacroFactory vmFactory = null ; private Log log = new Log ( ) ; private ParserPool parserPool ; private boolean initializing = false ; private boolean initialized = false ; private ExtendedProperties overridingProperties = null ; private Hashtable runtimeDirectives ; private ExtendedProperties configuration = new ExtendedProperties ( ) ; private ResourceManager resourceManager = null ; private EventCartridge eventCartridge = null ; private Introspector introspector = null ; private Map applicationAttributes = null ; private Uberspect uberSpect ; private String encoding ; public RuntimeInstance ( ) { vmFactory = new VelocimacroFactory ( this ) ; introspector = new Introspector ( getLog ( ) ) ; applicationAttributes = new HashMap ( ) ; } public synchronized void init ( ) throws Exception { if ( ! initialized && ! initializing ) { initializing = true ; log . trace ( "*******************************************************************" ) ; log . debug ( "Starting Apache Velocity v@build.version@ (compiled: @build.time@)" ) ; log . trace ( "RuntimeInstance initializing." ) ; initializeProperties ( ) ; initializeLog ( ) ; initializeResourceManager ( ) ; initializeDirectives ( ) ; initializeEventHandlers ( ) ; initializeParserPool ( ) ; initializeIntrospection ( ) ; vmFactory . initVelocimacro ( ) ; log . trace ( "RuntimeInstance successfully initialized." ) ; initialized = true ; initializing = false ; } } public boolean isInitialized ( ) { return initialized ; } private void requireInitialization ( ) { if ( ! initialized && ! initializing ) { log . debug ( "Velocity was not initialized! Calling init()..." ) ; try { init ( ) ; } catch ( Exception e ) { getLog ( ) . error ( "Could not auto-initialize Velocity" , e ) ; throw new RuntimeException ( "Velocity could not be initialized!" , e ) ; } } } private void initializeIntrospection ( ) throws Exception { String [ ] uberspectors = configuration . getStringArray ( RuntimeConstants . UBERSPECT_CLASSNAME ) ; for ( int i = 0 ; i < uberspectors . length ; i ++ ) { String rm = uberspectors [ i ] ; Object o = null ; try { o = ClassUtils . getNewInstance ( rm ) ; } catch ( ClassNotFoundException cnfe ) { String err = "The specified class for Uberspect (" + rm + ") does not exist or is not accessible to the current classloader." ; log . error ( err ) ; throw new Exception ( err ) ; } if ( ! ( o instanceof Uberspect ) ) { String err = "The specified class for Uberspect (" + rm + ") does not implement " + Uberspect . class . getName ( ) + "; Velocity is not initialized correctly." ; log . error ( err ) ; throw new Exception ( err ) ; } Uberspect u = ( Uberspect ) o ; if ( u instanceof UberspectLoggable ) { ( ( UberspectLoggable ) u ) . setLog ( getLog ( ) ) ; } if ( u instanceof RuntimeServicesAware ) { ( ( RuntimeServicesAware ) u ) . setRuntimeServices ( this ) ; } if ( uberSpect == null ) { uberSpect = u ; } else { if ( u instanceof ChainableUberspector ) { ( ( ChainableUberspector ) u ) . wrap ( uberSpect ) ; uberSpect = u ; } else { uberSpect = new LinkingUberspector ( uberSpect , u ) ; } } } if ( uberSpect != null ) { uberSpect . init ( ) ; } else { String err = "It appears that no class was specified as the" + " Uberspect.  Please ensure that all configuration" + " information is correct." ; log . error ( err ) ; throw new Exception ( err ) ; } } private void setDefaultProperties ( ) { InputStream inputStream = null ; try { inputStream = getClass ( ) . getResourceAsStream ( '/' + DEFAULT_RUNTIME_PROPERTIES ) ; configuration . load ( inputStream ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Default Properties File: " + new File ( DEFAULT_RUNTIME_PROPERTIES ) . getPath ( ) ) ; } } catch ( IOException ioe ) { String msg = "Cannot get Velocity Runtime default properties!" ; log . error ( msg , ioe ) ; throw new RuntimeException ( msg , ioe ) ; } finally { try { if ( inputStream != null ) { inputStream . close ( ) ; } } catch ( IOException ioe ) { String msg = "Cannot close Velocity Runtime default properties!" ; log . error ( msg , ioe ) ; throw new RuntimeException ( msg , ioe ) ; } } } public void setProperty ( String key , Object value ) { if ( overridingProperties == null ) { overridingProperties = new ExtendedProperties ( ) ; } overridingProperties . setProperty ( key , value ) ; } public void setConfiguration ( ExtendedProperties configuration ) { if ( overridingProperties == null ) { overridingProperties = configuration ; } else { if ( overridingProperties != configuration ) { overridingProperties . combine ( configuration ) ; } } } public void addProperty ( String key , Object value ) { if ( overridingProperties == null ) { overridingProperties = new ExtendedProperties ( ) ; } overridingProperties . addProperty ( key , value ) ; } public void clearProperty ( String key ) { if ( overridingProperties != null ) { overridingProperties . clearProperty ( key ) ; } } public Object getProperty ( String key ) { Object o = null ; if ( ! initialized && ! initializing && overridingProperties != null ) { o = overridingProperties . get ( key ) ; } if ( o == null ) { o = configuration . getProperty ( key ) ; } if ( o instanceof String ) { return StringUtils . nullTrim ( ( String ) o ) ; } else { return o ; } } private void initializeProperties ( ) { if ( configuration . isInitialized ( ) == false ) { setDefaultProperties ( ) ; } if ( overridingProperties != null ) { configuration . combine ( overridingProperties ) ; } } public void init ( Properties p ) throws Exception { setProperties ( ExtendedProperties . convertProperties ( p ) ) ; init ( ) ; } private void setProperties ( ExtendedProperties p ) { if ( overridingProperties == null ) { overridingProperties = p ; } else { overridingProperties . combine ( p ) ; } } public void init ( String configurationFile ) throws Exception { setProperties ( new ExtendedProperties ( configurationFile ) ) ; init ( ) ; } private void initializeResourceManager ( ) throws Exception { String rm = getString ( RuntimeConstants . RESOURCE_MANAGER_CLASS ) ; if ( rm != null && rm . length ( ) > 0 ) { Object o = null ; try { o = ClassUtils . getNewInstance ( rm ) ; } catch ( ClassNotFoundException cnfe ) { String err = "The specified class for ResourceManager (" + rm + ") does not exist or is not accessible to the current classloader." ; log . error ( err ) ; throw new Exception ( err ) ; } if ( ! ( o instanceof ResourceManager ) ) { String err = "The specified class for ResourceManager (" + rm + ") does not implement " + ResourceManager . class . getName ( ) + "; Velocity is not initialized correctly." ; log . error ( err ) ; throw new Exception ( err ) ; } resourceManager = ( ResourceManager ) o ; resourceManager . initialize ( this ) ; } else { String err = "It appears that no class was specified as the" + " ResourceManager.  Please ensure that all configuration" + " information is correct." ; log . error ( err ) ; throw new Exception ( err ) ; } } private void initializeEventHandlers ( ) throws Exception { eventCartridge = new EventCartridge ( ) ; String [ ] referenceinsertion = configuration . getStringArray ( RuntimeConstants . EVENTHANDLER_REFERENCEINSERTION ) ; if ( referenceinsertion != null ) { for ( int i = 0 ; i < referenceinsertion . length ; i ++ ) { EventHandler ev = initializeSpecificEventHandler ( referenceinsertion [ i ] , RuntimeConstants . EVENTHANDLER_REFERENCEINSERTION , ReferenceInsertionEventHandler . class ) ; if ( ev != null ) eventCartridge . addReferenceInsertionEventHandler ( ( ReferenceInsertionEventHandler ) ev ) ; } } String [ ] nullset = configuration . getStringArray ( RuntimeConstants . EVENTHANDLER_NULLSET ) ; if ( nullset != null ) { for ( int i = 0 ; i < nullset . length ; i ++ ) { EventHandler ev = initializeSpecificEventHandler ( nullset [ i ] , RuntimeConstants . EVENTHANDLER_NULLSET , NullSetEventHandler . class ) ; if ( ev != null ) eventCartridge . addNullSetEventHandler ( ( NullSetEventHandler ) ev ) ; } } String [ ] methodexception = configuration . getStringArray ( RuntimeConstants . EVENTHANDLER_METHODEXCEPTION ) ; if ( methodexception != null ) { for ( int i = 0 ; i < methodexception . length ; i ++ ) { EventHandler ev = initializeSpecificEventHandler ( methodexception [ i ] , RuntimeConstants . EVENTHANDLER_METHODEXCEPTION , MethodExceptionEventHandler . class ) ; if ( ev != null ) eventCartridge . addMethodExceptionHandler ( ( MethodExceptionEventHandler ) ev ) ; } } String [ ] includeHandler = configuration . getStringArray ( RuntimeConstants . EVENTHANDLER_INCLUDE ) ; if ( includeHandler != null ) { for ( int i = 0 ; i < includeHandler . length ; i ++ ) { EventHandler ev = initializeSpecificEventHandler ( includeHandler [ i ] , RuntimeConstants . EVENTHANDLER_INCLUDE , IncludeEventHandler . class ) ; if ( ev != null ) eventCartridge . addIncludeEventHandler ( ( IncludeEventHandler ) ev ) ; } } String [ ] invalidReferenceSet = configuration . getStringArray ( RuntimeConstants . EVENTHANDLER_INVALIDREFERENCES ) ; if ( invalidReferenceSet != null ) { for ( int i = 0 ; i < invalidReferenceSet . length ; i ++ ) { EventHandler ev = initializeSpecificEventHandler ( invalidReferenceSet [ i ] , RuntimeConstants . EVENTHANDLER_INVALIDREFERENCES , InvalidReferenceEventHandler . class ) ; if ( ev != null ) { eventCartridge . addInvalidReferenceEventHandler ( ( InvalidReferenceEventHandler ) ev ) ; } } } } private EventHandler initializeSpecificEventHandler ( String classname , String paramName , Class EventHandlerInterface ) throws Exception { if ( classname != null && classname . length ( ) > 0 ) { Object o = null ; try { o = ClassUtils . getNewInstance ( classname ) ; } catch ( ClassNotFoundException cnfe ) { String err = "The specified class for " + paramName + " (" + classname + ") does not exist or is not accessible to the current classloader." ; log . error ( err ) ; throw new Exception ( err ) ; } if ( ! EventHandlerInterface . isAssignableFrom ( EventHandlerInterface ) ) { String err = "The specified class for " + paramName + " (" + classname + ") does not implement " + EventHandlerInterface . getName ( ) + "; Velocity is not initialized correctly." ; log . error ( err ) ; throw new Exception ( err ) ; } EventHandler ev = ( EventHandler ) o ; if ( ev instanceof RuntimeServicesAware ) ( ( RuntimeServicesAware ) ev ) . setRuntimeServices ( this ) ; return ev ; } else return null ; } private void initializeLog ( ) throws Exception { LogManager . updateLog ( this . log , this ) ; } private void initializeDirectives ( ) throws Exception { runtimeDirectives = new Hashtable ( ) ; Properties directiveProperties = new Properties ( ) ; InputStream inputStream = null ; try { inputStream = getClass ( ) . getResourceAsStream ( '/' + DEFAULT_RUNTIME_DIRECTIVES ) ; if ( inputStream == null ) { throw new Exception ( "Error loading directive.properties! " + "Something is very wrong if these properties " + "aren't being located. Either your Velocity " + "distribution is incomplete or your Velocity " + "jar file is corrupted!" ) ; } directiveProperties . load ( inputStream ) ; } catch ( IOException ioe ) { String msg = "Error while loading directive properties!" ; log . error ( msg , ioe ) ; throw new RuntimeException ( msg , ioe ) ; } finally { try { if ( inputStream != null ) { inputStream . close ( ) ; } } catch ( IOException ioe ) { String msg = "Cannot close directive properties!" ; log . error ( msg , ioe ) ; throw new RuntimeException ( msg , ioe ) ; } } Enumeration directiveClasses = directiveProperties . elements ( ) ; while ( directiveClasses . hasMoreElements ( ) ) { String directiveClass = ( String ) directiveClasses . nextElement ( ) ; loadDirective ( directiveClass ) ; log . debug ( "Loaded System Directive: " + directiveClass ) ; } String [ ] userdirective = configuration . getStringArray ( "userdirective" ) ; for ( int i = 0 ; i < userdirective . length ; i ++ ) { loadDirective ( userdirective [ i ] ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Loaded User Directive: " + userdirective [ i ] ) ; } } } public void addDirective ( Directive directive ) { runtimeDirectives . put ( directive . getName ( ) , directive ) ; } public Directive getDirective ( String name ) { return ( Directive ) runtimeDirectives . get ( name ) ; } public void removeDirective ( String name ) { runtimeDirectives . remove ( name ) ; } private void loadDirective ( String directiveClass ) { try { Object o = ClassUtils . getNewInstance ( directiveClass ) ; if ( o instanceof Directive ) { Directive directive = ( Directive ) o ; addDirective ( directive ) ; } else { String msg = directiveClass + " does not implement " + Directive . class . getName ( ) + "; it cannot be loaded." ; log . error ( msg ) ; throw new VelocityException ( msg ) ; } } catch ( Exception e ) { String msg = "Failed to load Directive: " + directiveClass ; log . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } } private void initializeParserPool ( ) throws Exception { String pp = getString ( RuntimeConstants . PARSER_POOL_CLASS ) ; if ( pp != null && pp . length ( ) > 0 ) { Object o = null ; try { o = ClassUtils . getNewInstance ( pp ) ; } catch ( ClassNotFoundException cnfe ) { String err = "The specified class for ParserPool (" + pp + ") does not exist (or is not accessible to the current classloader." ; log . error ( err ) ; throw new Exception ( err ) ; } if ( ! ( o instanceof ParserPool ) ) { String err = "The specified class for ParserPool (" + pp + ") does not implement " + ParserPool . class + " Velocity not initialized correctly." ; log . error ( err ) ; throw new Exception ( err ) ; } parserPool = ( ParserPool ) o ; parserPool . initialize ( this ) ; } else { String err = "It appears that no class was specified as the" + " ParserPool.  Please ensure that all configuration" + " information is correct." ; log . error ( err ) ; throw new Exception ( err ) ; } } public Parser createNewParser ( ) { requireInitialization ( ) ; Parser parser = new Parser ( this ) ; parser . setDirectives ( runtimeDirectives ) ; return parser ; } public SimpleNode parse ( String string , String templateName ) throws ParseException { return parse ( new StringReader ( string ) , templateName ) ; } public SimpleNode parse ( Reader reader , String templateName ) throws ParseException { return parse ( reader , templateName , true ) ; } public SimpleNode parse ( Reader reader , String templateName , boolean dumpNamespace ) throws ParseException { requireInitialization ( ) ; Parser parser = ( Parser ) parserPool . get ( ) ; boolean keepParser = true ; if ( parser == null ) { if ( log . isInfoEnabled ( ) ) { log . info ( "Runtime : ran out of parsers. Creating a new one. " + " Please increment the parser.pool.size property." + " The current value is too small." ) ; } parser = createNewParser ( ) ; keepParser = false ; } try { if ( dumpNamespace ) { dumpVMNamespace ( templateName ) ; } return parser . parse ( reader , templateName ) ; } finally { if ( keepParser ) { parserPool . put ( parser ) ; } } } public boolean evaluate ( Context context , Writer out , String logTag , String instring ) throws IOException { return evaluate ( context , out , logTag , new StringReader ( instring ) ) ; } public boolean evaluate ( Context context , Writer writer , String logTag , Reader reader ) throws IOException { if ( logTag == null ) { throw new NullPointerException ( "logTag (i.e. template name) cannot be null, you must provide an identifier for the content being evaluated" ) ; } SimpleNode nodeTree = null ; try { nodeTree = parse ( reader , logTag ) ; } catch ( ParseException pex ) { throw new ParseErrorException ( pex ) ; } catch ( TemplateInitException pex ) { throw new ParseErrorException ( pex ) ; } if ( nodeTree == null ) { return false ; } else { return render ( context , writer , logTag , nodeTree ) ; } } public boolean render ( Context context , Writer writer , String logTag , SimpleNode nodeTree ) throws IOException { InternalContextAdapterImpl ica = new InternalContextAdapterImpl ( context ) ; ica . pushCurrentTemplateName ( logTag ) ; try { try { nodeTree . init ( ica , this ) ; } catch ( TemplateInitException pex ) { throw new ParseErrorException ( pex ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { String msg = "RuntimeInstance.render(): init exception for tag = " + logTag ; getLog ( ) . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } nodeTree . render ( ica , writer ) ; } finally { ica . popCurrentTemplateName ( ) ; } return true ; } public boolean invokeVelocimacro ( final String vmName , String logTag , String [ ] params , final Context context , final Writer writer ) throws IOException { if ( vmName == null || context == null || writer == null ) { String msg = "RuntimeInstance.invokeVelocimacro() : invalid call : vmName, context, and writer must not be null" ; getLog ( ) . error ( msg ) ; throw new NullPointerException ( msg ) ; } if ( logTag == null ) { logTag = vmName ; } if ( params == null ) { params = new String [ 0 ] ; } if ( ! isVelocimacro ( vmName , logTag ) ) { String msg = "RuntimeInstance.invokeVelocimacro() : VM '" + vmName + "' is not registered." ; getLog ( ) . error ( msg ) ; throw new VelocityException ( msg ) ; } StrBuilder template = new StrBuilder ( "#" ) ; template . append ( vmName ) ; template . append ( "(" ) ; for ( int i = 0 ; i < params . length ; i ++ ) { template . append ( " $" ) ; template . append ( params [ i ] ) ; } template . append ( " )" ) ; return evaluate ( context , writer , logTag , template . toString ( ) ) ; } private String getDefaultEncoding ( ) { if ( encoding == null ) { encoding = getString ( INPUT_ENCODING , ENCODING_DEFAULT ) ; } return encoding ; } public Template getTemplate ( String name ) throws ResourceNotFoundException , ParseErrorException , Exception { return getTemplate ( name , getDefaultEncoding ( ) ) ; } public Template getTemplate ( String name , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception { requireInitialization ( ) ; return ( Template ) resourceManager . getResource ( name , ResourceManager . RESOURCE_TEMPLATE , encoding ) ; } public ContentResource getContent ( String name ) throws ResourceNotFoundException , ParseErrorException , Exception { return getContent ( name , getDefaultEncoding ( ) ) ; } public ContentResource getContent ( String name , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception { requireInitialization ( ) ; return ( ContentResource ) resourceManager . getResource ( name , ResourceManager . RESOURCE_CONTENT , encoding ) ; } public String getLoaderNameForResource ( String resourceName ) { requireInitialization ( ) ; return resourceManager . getLoaderNameForResource ( resourceName ) ; } public Log getLog ( ) { return log ; } public void warn ( Object message ) { getLog ( ) . warn ( message ) ; } public void info ( Object message ) { getLog ( ) . info ( message ) ; } public void error ( Object message ) { getLog ( ) . error ( message ) ; } public void debug ( Object message ) { getLog ( ) . debug ( message ) ; } public String getString ( String key , String defaultValue ) { return configuration . getString ( key , defaultValue ) ; } public Directive getVelocimacro ( String vmName , String templateName ) { return vmFactory . getVelocimacro ( vmName , templateName ) ; } public Directive getVelocimacro ( String vmName , String templateName , String renderingTemplate ) { return vmFactory . getVelocimacro ( vmName , templateName , renderingTemplate ) ; } public boolean addVelocimacro ( String name , String macro , String argArray [ ] , String sourceTemplate ) { return vmFactory . addVelocimacro ( name , macro , argArray , sourceTemplate ) ; } public boolean addVelocimacro ( String name , Node macro , String argArray [ ] , String sourceTemplate ) { return vmFactory . addVelocimacro ( name , macro , argArray , sourceTemplate ) ; } public boolean isVelocimacro ( String vmName , String templateName ) { return vmFactory . isVelocimacro ( vmName , templateName ) ; } public boolean dumpVMNamespace ( String namespace ) { return vmFactory . dumpVMNamespace ( namespace ) ; } public String getString ( String key ) { return StringUtils . nullTrim ( configuration . getString ( key ) ) ; } public int getInt ( String key ) { return configuration . getInt ( key ) ; } public int getInt ( String key , int defaultValue ) { return configuration . getInt ( key , defaultValue ) ; } public boolean getBoolean ( String key , boolean def ) { return configuration . getBoolean ( key , def ) ; } public ExtendedProperties getConfiguration ( ) { return configuration ; } public Introspector getIntrospector ( ) { return introspector ; } public EventCartridge getApplicationEventCartridge ( ) { return eventCartridge ; } public Object getApplicationAttribute ( Object key ) { return applicationAttributes . get ( key ) ; } public Object setApplicationAttribute ( Object key , Object o ) { return applicationAttributes . put ( key , o ) ; } public Uberspect getUberspect ( ) { return uberSpect ; } } 	1	['62', '1', '0', '42', '165', '1423', '3', '39', '48', '0.827512473', '1691', '0.608695652', '7', '0', '0.135483871', '0', '0', '25.90322581', '6', '1.3226', '8']
package org . apache . velocity . app . event . implement ; import org . apache . commons . lang . StringEscapeUtils ; public class EscapeHtmlReference extends EscapeReference { protected String escape ( Object text ) { return StringEscapeUtils . escapeHtml ( text . toString ( ) ) ; } protected String getMatchAttribute ( ) { return "eventhandler.escape.html.match" ; } } 	0	['3', '2', '0', '2', '6', '3', '0', '2', '1', '2', '12', '0', '0', '0.714285714', '0.666666667', '1', '2', '3', '1', '0.6667', '0']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . util . TemplateNumber ; public class ASTLTNode extends SimpleNode { public ASTLTNode ( int id ) { super ( id ) ; } public ASTLTNode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { Object left = jjtGetChild ( 0 ) . value ( context ) ; Object right = jjtGetChild ( 1 ) . value ( context ) ; if ( left == null || right == null ) { log . error ( ( left == null ? "Left" : "Right" ) + " side (" + jjtGetChild ( ( left == null ? 0 : 1 ) ) . literal ( ) + ") of '<' operation has null value." + " Operation not possible. " + Log . formatFileString ( this ) ) ; return false ; } if ( left instanceof TemplateNumber ) { left = ( ( TemplateNumber ) left ) . getAsNumber ( ) ; } if ( right instanceof TemplateNumber ) { right = ( ( TemplateNumber ) right ) . getAsNumber ( ) ; } if ( ! ( left instanceof Number ) || ! ( right instanceof Number ) ) { log . error ( ( ! ( left instanceof Number ) ? "Left" : "Right" ) + " side of '>=' operation is not a valid Number. " + Log . formatFileString ( this ) ) ; return false ; } return MathUtils . compare ( ( Number ) left , ( Number ) right ) == - 1 ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { boolean val = evaluate ( context ) ; return val ? Boolean . TRUE : Boolean . FALSE ; } } 	1	['5', '2', '0', '11', '18', '10', '4', '9', '5', '2', '130', '0', '0', '0.909090909', '0.4', '1', '1', '25', '1', '0.6', '1']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . runtime . parser . Parser ; public class ASTAndNode extends SimpleNode { public ASTAndNode ( int id ) { super ( id ) ; } public ASTAndNode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { return evaluate ( context ) ? Boolean . TRUE : Boolean . FALSE ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { Node left = jjtGetChild ( 0 ) ; Node right = jjtGetChild ( 1 ) ; if ( left == null || right == null ) { return false ; } if ( left . evaluate ( context ) ) { if ( right . evaluate ( context ) ) { return true ; } } return false ; } } 	0	['5', '2', '0', '9', '10', '10', '5', '6', '5', '2', '53', '0', '0', '0.909090909', '0.4', '1', '1', '9.6', '1', '0.6', '0']
package org . apache . velocity . runtime . parser ; public interface ParserTreeConstants { public int JJTPROCESS = 0 ; public int JJTVOID = 1 ; public int JJTESCAPEDDIRECTIVE = 2 ; public int JJTESCAPE = 3 ; public int JJTCOMMENT = 4 ; public int JJTFLOATINGPOINTLITERAL = 5 ; public int JJTINTEGERLITERAL = 6 ; public int JJTSTRINGLITERAL = 7 ; public int JJTIDENTIFIER = 8 ; public int JJTWORD = 9 ; public int JJTDIRECTIVE = 10 ; public int JJTBLOCK = 11 ; public int JJTMAP = 12 ; public int JJTOBJECTARRAY = 13 ; public int JJTINTEGERRANGE = 14 ; public int JJTMETHOD = 15 ; public int JJTREFERENCE = 16 ; public int JJTTRUE = 17 ; public int JJTFALSE = 18 ; public int JJTTEXT = 19 ; public int JJTIFSTATEMENT = 20 ; public int JJTELSESTATEMENT = 21 ; public int JJTELSEIFSTATEMENT = 22 ; public int JJTSETDIRECTIVE = 23 ; public int JJTSTOP = 24 ; public int JJTEXPRESSION = 25 ; public int JJTASSIGNMENT = 26 ; public int JJTORNODE = 27 ; public int JJTANDNODE = 28 ; public int JJTEQNODE = 29 ; public int JJTNENODE = 30 ; public int JJTLTNODE = 31 ; public int JJTGTNODE = 32 ; public int JJTLENODE = 33 ; public int JJTGENODE = 34 ; public int JJTADDNODE = 35 ; public int JJTSUBTRACTNODE = 36 ; public int JJTMULNODE = 37 ; public int JJTDIVNODE = 38 ; public int JJTMODNODE = 39 ; public int JJTNOTNODE = 40 ; public String [ ] jjtNodeName = { "process" , "void" , "EscapedDirective" , "Escape" , "Comment" , "FloatingPointLiteral" , "IntegerLiteral" , "StringLiteral" , "Identifier" , "Word" , "Directive" , "Block" , "Map" , "ObjectArray" , "IntegerRange" , "Method" , "Reference" , "True" , "False" , "Text" , "IfStatement" , "ElseStatement" , "ElseIfStatement" , "SetDirective" , "Stop" , "Expression" , "Assignment" , "OrNode" , "AndNode" , "EQNode" , "NENode" , "LTNode" , "GTNode" , "LENode" , "GENode" , "AddNode" , "SubtractNode" , "MulNode" , "DivNode" , "ModNode" , "NotNode" , } ; } 	1	['1', '1', '0', '2', '1', '0', '2', '0', '0', '2', '211', '0', '0', '0', '0', '0', '0', '168', '0', '0', '6']
package org . apache . velocity . runtime . parser ; import org . apache . velocity . runtime . parser . node . Node ; public class JJTParserState { private java . util . List nodes ; private java . util . List marks ; private int sp ; private int mk ; private boolean node_created ; public JJTParserState ( ) { nodes = new java . util . ArrayList ( ) ; marks = new java . util . ArrayList ( ) ; sp = 0 ; mk = 0 ; } public boolean nodeCreated ( ) { return node_created ; } public void reset ( ) { nodes . clear ( ) ; marks . clear ( ) ; sp = 0 ; mk = 0 ; } public Node rootNode ( ) { return ( Node ) nodes . get ( 0 ) ; } public void pushNode ( Node n ) { nodes . add ( n ) ; ++ sp ; } public Node popNode ( ) { if ( -- sp < mk ) { mk = ( ( Integer ) marks . remove ( marks . size ( ) - 1 ) ) . intValue ( ) ; } return ( Node ) nodes . remove ( nodes . size ( ) - 1 ) ; } public Node peekNode ( ) { return ( Node ) nodes . get ( nodes . size ( ) - 1 ) ; } public int nodeArity ( ) { return sp - mk ; } public void clearNodeScope ( Node n ) { while ( sp > mk ) { popNode ( ) ; } mk = ( ( Integer ) marks . remove ( marks . size ( ) - 1 ) ) . intValue ( ) ; } public void openNodeScope ( Node n ) { marks . add ( new Integer ( mk ) ) ; mk = sp ; n . jjtOpen ( ) ; } public void closeNodeScope ( Node n , int num ) { mk = ( ( Integer ) marks . remove ( marks . size ( ) - 1 ) ) . intValue ( ) ; while ( num -- > 0 ) { Node c = popNode ( ) ; c . jjtSetParent ( n ) ; n . jjtAddChild ( c , num ) ; } n . jjtClose ( ) ; pushNode ( n ) ; node_created = true ; } public void closeNodeScope ( Node n , boolean condition ) { if ( condition ) { int a = nodeArity ( ) ; mk = ( ( Integer ) marks . remove ( marks . size ( ) - 1 ) ) . intValue ( ) ; while ( a -- > 0 ) { Node c = popNode ( ) ; c . jjtSetParent ( n ) ; n . jjtAddChild ( c , a ) ; } n . jjtClose ( ) ; pushNode ( n ) ; node_created = true ; } else { mk = ( ( Integer ) marks . remove ( marks . size ( ) - 1 ) ) . intValue ( ) ; node_created = false ; } } } 	0	['12', '1', '0', '2', '25', '0', '1', '1', '12', '0.436363636', '253', '1', '0', '0', '0.395833333', '0', '0', '19.66666667', '3', '1.3333', '0']
package org . apache . velocity . app . event ; import org . apache . velocity . context . Context ; import org . apache . velocity . util . introspection . Info ; public interface InvalidReferenceEventHandler extends EventHandler { public Object invalidGetMethod ( Context context , String reference , Object object , String property , Info info ) ; public boolean invalidSetMethod ( Context context , String leftreference , String rightreference , Info info ) ; public Object invalidMethod ( Context context , String reference , Object object , String method , Info info ) ; static class InvalidGetMethodExecutor implements EventHandlerMethodExecutor { private Context context ; private String reference ; private Object object ; private String property ; private Info info ; private Object result ; InvalidGetMethodExecutor ( Context context , String reference , Object object , String property , Info info ) { this . context = context ; this . reference = reference ; this . object = object ; this . property = property ; this . info = info ; } public void execute ( EventHandler handler ) { result = ( ( InvalidReferenceEventHandler ) handler ) . invalidGetMethod ( context , reference , object , property , info ) ; } public Object getReturnValue ( ) { return result ; } public boolean isDone ( ) { return ( result != null ) ; } } static class InvalidSetMethodExecutor implements EventHandlerMethodExecutor { private Context context ; private String leftreference ; private String rightreference ; private Info info ; private boolean result ; InvalidSetMethodExecutor ( Context context , String leftreference , String rightreference , Info info ) { this . context = context ; this . leftreference = leftreference ; this . rightreference = rightreference ; this . info = info ; } public void execute ( EventHandler handler ) { result = ( ( InvalidReferenceEventHandler ) handler ) . invalidSetMethod ( context , leftreference , rightreference , info ) ; } public Object getReturnValue ( ) { return null ; } public boolean isDone ( ) { return result ; } } static class InvalidMethodExecutor implements EventHandlerMethodExecutor { private Context context ; private String reference ; private Object object ; private String method ; private Info info ; private Object result ; private boolean executed = false ; InvalidMethodExecutor ( Context context , String reference , Object object , String method , Info info ) { this . context = context ; this . reference = reference ; this . object = object ; this . method = method ; this . info = info ; } public void execute ( EventHandler handler ) { executed = true ; result = ( ( InvalidReferenceEventHandler ) handler ) . invalidMethod ( context , reference , object , method , info ) ; } public Object getReturnValue ( ) { return result ; } public boolean isDone ( ) { return executed && ( result != null ) ; } } } 	1	['3', '1', '0', '9', '3', '3', '6', '3', '3', '2', '3', '0', '0', '0', '0.933333333', '0', '0', '0', '1', '1', '1']
package org . apache . velocity . runtime ; public interface RuntimeLogger { public void warn ( Object message ) ; public void info ( Object message ) ; public void error ( Object message ) ; public void debug ( Object message ) ; } 	0	['4', '1', '0', '8', '4', '6', '8', '0', '4', '2', '4', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . velocity . util ; import java . lang . reflect . Constructor ; import java . util . Collections ; import java . util . HashMap ; import java . util . Hashtable ; import java . util . Map ; public class MapFactory { private static Constructor concurrentHashMapConstructor ; static { try { concurrentHashMapConstructor = Class . forName ( "java.util.concurrent.ConcurrentHashMap" ) . getConstructor ( new Class [ ] { int . class , float . class , int . class } ) ; } catch ( Exception ex ) { } } public static Map create ( int size , float loadFactor , int concurrencyLevel , boolean allowNullKeys ) { Map map = null ; if ( concurrencyLevel <= 1 ) { map = new HashMap ( size , loadFactor ) ; } else { if ( concurrentHashMapConstructor != null ) { try { map = ( Map ) concurrentHashMapConstructor . newInstance ( new Object [ ] { new Integer ( size ) , new Float ( loadFactor ) , new Integer ( concurrencyLevel ) } ) ; } catch ( Exception ex ) { throw new RuntimeException ( "this should not happen" , ex ) ; } } else { if ( allowNullKeys ) { map = Collections . synchronizedMap ( new HashMap ( size , loadFactor ) ) ; } else { map = new Hashtable ( size , loadFactor ) ; } } } return map ; } } 	1	['3', '1', '0', '2', '13', '1', '2', '0', '2', '0.5', '95', '1', '0', '0', '0.5', '0', '0', '30.33333333', '4', '1.3333', '1']
package org . apache . velocity . runtime . resource . loader ; import java . io . IOException ; import java . io . InputStream ; import java . net . JarURLConnection ; import java . net . URL ; import java . util . Enumeration ; import java . util . jar . JarEntry ; import java . util . jar . JarFile ; import java . util . Hashtable ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . VelocityException ; public class JarHolder { private String urlpath = null ; private JarFile theJar = null ; private JarURLConnection conn = null ; private Log log = null ; public JarHolder ( RuntimeServices rs , String urlpath ) { this . log = rs . getLog ( ) ; this . urlpath = urlpath ; init ( ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "JarHolder: initialized JAR: " + urlpath ) ; } } public void init ( ) { try { if ( log . isDebugEnabled ( ) ) { log . debug ( "JarHolder: attempting to connect to " + urlpath ) ; } URL url = new URL ( urlpath ) ; conn = ( JarURLConnection ) url . openConnection ( ) ; conn . setAllowUserInteraction ( false ) ; conn . setDoInput ( true ) ; conn . setDoOutput ( false ) ; conn . connect ( ) ; theJar = conn . getJarFile ( ) ; } catch ( IOException ioe ) { String msg = "JarHolder: error establishing connection to JAR at \"" + urlpath + "\"" ; log . error ( msg , ioe ) ; throw new VelocityException ( msg , ioe ) ; } } public void close ( ) { try { theJar . close ( ) ; } catch ( Exception e ) { String msg = "JarHolder: error closing the JAR file" ; log . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } theJar = null ; conn = null ; log . trace ( "JarHolder: JAR file closed" ) ; } public InputStream getResource ( String theentry ) throws ResourceNotFoundException { InputStream data = null ; try { JarEntry entry = theJar . getJarEntry ( theentry ) ; if ( entry != null ) { data = theJar . getInputStream ( entry ) ; } } catch ( Exception fnfe ) { log . error ( "JarHolder: getResource() error" , fnfe ) ; throw new ResourceNotFoundException ( fnfe ) ; } return data ; } public Hashtable getEntries ( ) { Hashtable allEntries = new Hashtable ( 559 ) ; Enumeration all = theJar . entries ( ) ; while ( all . hasMoreElements ( ) ) { JarEntry je = ( JarEntry ) all . nextElement ( ) ; if ( ! je . isDirectory ( ) ) { allEntries . put ( je . getName ( ) , this . urlpath ) ; } } return allEntries ; } public String getUrlPath ( ) { return urlpath ; } } 	0	['6', '1', '0', '5', '34', '0', '1', '4', '6', '0.4', '211', '1', '1', '0', '0.5', '0', '0', '33.5', '2', '1.1667', '0']
package org . apache . velocity . context ; import org . apache . velocity . app . event . EventCartridge ; import org . apache . velocity . runtime . resource . Resource ; import org . apache . velocity . util . introspection . IntrospectionCacheData ; import java . util . List ; public final class InternalContextAdapterImpl implements InternalContextAdapter { Context context = null ; InternalHousekeepingContext icb = null ; InternalEventContext iec = null ; public InternalContextAdapterImpl ( Context c ) { context = c ; if ( ! ( c instanceof InternalHousekeepingContext ) ) { icb = new InternalContextBase ( ) ; } else { icb = ( InternalHousekeepingContext ) context ; } if ( c instanceof InternalEventContext ) { iec = ( InternalEventContext ) context ; } } public void pushCurrentTemplateName ( String s ) { icb . pushCurrentTemplateName ( s ) ; } public void popCurrentTemplateName ( ) { icb . popCurrentTemplateName ( ) ; } public String getCurrentTemplateName ( ) { return icb . getCurrentTemplateName ( ) ; } public Object [ ] getTemplateNameStack ( ) { return icb . getTemplateNameStack ( ) ; } public void pushCurrentMacroName ( String s ) { icb . pushCurrentMacroName ( s ) ; } public void popCurrentMacroName ( ) { icb . popCurrentMacroName ( ) ; } public String getCurrentMacroName ( ) { return icb . getCurrentMacroName ( ) ; } public int getCurrentMacroCallDepth ( ) { return icb . getCurrentMacroCallDepth ( ) ; } public Object [ ] getMacroNameStack ( ) { return icb . getMacroNameStack ( ) ; } public IntrospectionCacheData icacheGet ( Object key ) { return icb . icacheGet ( key ) ; } public void icachePut ( Object key , IntrospectionCacheData o ) { icb . icachePut ( key , o ) ; } public void setCurrentResource ( Resource r ) { icb . setCurrentResource ( r ) ; } public Resource getCurrentResource ( ) { return icb . getCurrentResource ( ) ; } public boolean getAllowRendering ( ) { return icb . getAllowRendering ( ) ; } public void setAllowRendering ( boolean v ) { icb . setAllowRendering ( v ) ; } public void setMacroLibraries ( List macroLibraries ) { icb . setMacroLibraries ( macroLibraries ) ; } public List getMacroLibraries ( ) { return icb . getMacroLibraries ( ) ; } public Object put ( String key , Object value ) { return context . put ( key , value ) ; } public Object localPut ( final String key , final Object value ) { return put ( key , value ) ; } public Object get ( String key ) { return context . get ( key ) ; } public boolean containsKey ( Object key ) { return context . containsKey ( key ) ; } public Object [ ] getKeys ( ) { return context . getKeys ( ) ; } public Object remove ( Object key ) { return context . remove ( key ) ; } public Context getInternalUserContext ( ) { return context ; } public InternalContextAdapter getBaseContext ( ) { return this ; } public EventCartridge attachEventCartridge ( EventCartridge ec ) { if ( iec != null ) { return iec . attachEventCartridge ( ec ) ; } return null ; } public EventCartridge getEventCartridge ( ) { if ( iec != null ) { return iec . getEventCartridge ( ) ; } return null ; } } 	1	['28', '1', '0', '11', '54', '24', '3', '8', '28', '0.679012346', '198', '0', '3', '0', '0.178571429', '0', '0', '5.964285714', '2', '1.0357', '1']
package org . apache . velocity . exception ; import org . apache . velocity . runtime . parser . ParseException ; public class TemplateInitException extends VelocityException implements ExtendedParseException { private final String templateName ; private final int col ; private final int line ; private static final long serialVersionUID = - 4985224672336070621L ; public TemplateInitException ( final String msg , final String templateName , final int col , final int line ) { super ( msg ) ; this . templateName = templateName ; this . col = col ; this . line = line ; } public TemplateInitException ( final String msg , ParseException parseException , final String templateName , final int col , final int line ) { super ( msg , parseException ) ; this . templateName = templateName ; this . col = col ; this . line = line ; } public String getTemplateName ( ) { return templateName ; } public int getLineNumber ( ) { return line ; } public int getColumnNumber ( ) { return col ; } } 	0	['5', '5', '0', '28', '7', '0', '25', '3', '5', '0.6875', '45', '1', '0', '0.823529412', '0.5', '0', '0', '7.2', '1', '0.6', '0']
package org . apache . velocity . app . event . implement ; import org . apache . velocity . app . event . IncludeEventHandler ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . util . RuntimeServicesAware ; import org . apache . velocity . util . StringUtils ; public class IncludeNotFound implements IncludeEventHandler , RuntimeServicesAware { private static final String DEFAULT_NOT_FOUND = "notfound.vm" ; private static final String PROPERTY_NOT_FOUND = "eventhandler.include.notfound" ; private RuntimeServices rs = null ; String notfound ; public String includeEvent ( String includeResourcePath , String currentResourcePath , String directiveName ) { boolean exists = ( rs . getLoaderNameForResource ( includeResourcePath ) != null ) ; if ( ! exists ) { if ( rs . getLoaderNameForResource ( notfound ) != null ) { return notfound ; } else { rs . getLog ( ) . error ( "Can't find include not found page: " + notfound ) ; return null ; } } else return includeResourcePath ; } public void setRuntimeServices ( RuntimeServices rs ) { this . rs = rs ; notfound = StringUtils . nullTrim ( rs . getString ( PROPERTY_NOT_FOUND , DEFAULT_NOT_FOUND ) ) ; } } 	1	['3', '1', '0', '5', '12', '0', '0', '5', '3', '0.875', '61', '0.75', '1', '0', '0.555555556', '0', '0', '18', '4', '1.6667', '1']
package org . apache . velocity . util . introspection ; import java . lang . reflect . Method ; import org . apache . velocity . runtime . RuntimeLogger ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . log . RuntimeLoggerLog ; public class Introspector extends IntrospectorBase { public Introspector ( final Log log ) { super ( log ) ; } public Introspector ( final RuntimeLogger logger ) { this ( new RuntimeLoggerLog ( logger ) ) ; } public Method getMethod ( final Class c , final String name , final Object [ ] params ) throws IllegalArgumentException { try { return super . getMethod ( c , name , params ) ; } catch ( MethodMap . AmbiguousException ae ) { StringBuffer msg = new StringBuffer ( "Introspection Error : Ambiguous method invocation " ) . append ( name ) . append ( "(" ) ; for ( int i = 0 ; i < params . length ; i ++ ) { if ( i > 0 ) { msg . append ( ", " ) ; } if ( params [ i ] == null ) { msg . append ( "null" ) ; } else { msg . append ( params [ i ] . getClass ( ) . getName ( ) ) ; } } msg . append ( ") for class " ) . append ( c ) ; log . debug ( msg . toString ( ) ) ; } return null ; } } 	0	['3', '2', '1', '16', '13', '3', '11', '5', '3', '2', '74', '0', '0', '0.666666667', '0.444444444', '0', '0', '23.66666667', '1', '0.3333', '0']
package org . apache . velocity . context ; import java . util . HashSet ; import java . util . Set ; import java . util . List ; import org . apache . velocity . VelocityContext ; import org . apache . velocity . app . event . EventCartridge ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . resource . Resource ; import org . apache . velocity . util . ClassUtils ; import org . apache . velocity . util . introspection . IntrospectionCacheData ; public abstract class ChainedInternalContextAdapter implements InternalContextAdapter { protected InternalContextAdapter innerContext = null ; public ChainedInternalContextAdapter ( InternalContextAdapter inner ) { innerContext = inner ; } public Context getInternalUserContext ( ) { return innerContext . getInternalUserContext ( ) ; } public InternalContextAdapter getBaseContext ( ) { return innerContext . getBaseContext ( ) ; } public Object get ( String key ) { return innerContext . get ( key ) ; } public Object put ( String key , Object value ) { return innerContext . put ( key , value ) ; } public boolean containsKey ( Object key ) { return innerContext . containsKey ( key ) ; } public Object [ ] getKeys ( ) { return innerContext . getKeys ( ) ; } public Object remove ( Object key ) { return innerContext . remove ( key ) ; } public void pushCurrentTemplateName ( String s ) { innerContext . pushCurrentTemplateName ( s ) ; } public void popCurrentTemplateName ( ) { innerContext . popCurrentTemplateName ( ) ; } public String getCurrentTemplateName ( ) { return innerContext . getCurrentTemplateName ( ) ; } public Object [ ] getTemplateNameStack ( ) { return innerContext . getTemplateNameStack ( ) ; } public void pushCurrentMacroName ( String s ) { innerContext . pushCurrentMacroName ( s ) ; } public void popCurrentMacroName ( ) { innerContext . popCurrentMacroName ( ) ; } public String getCurrentMacroName ( ) { return innerContext . getCurrentMacroName ( ) ; } public int getCurrentMacroCallDepth ( ) { return innerContext . getCurrentMacroCallDepth ( ) ; } public Object [ ] getMacroNameStack ( ) { return innerContext . getMacroNameStack ( ) ; } public IntrospectionCacheData icacheGet ( Object key ) { return innerContext . icacheGet ( key ) ; } public Object localPut ( final String key , final Object value ) { return innerContext . put ( key , value ) ; } public void icachePut ( Object key , IntrospectionCacheData o ) { innerContext . icachePut ( key , o ) ; } public boolean getAllowRendering ( ) { return innerContext . getAllowRendering ( ) ; } public void setAllowRendering ( boolean v ) { innerContext . setAllowRendering ( v ) ; } public void setMacroLibraries ( List macroLibraries ) { innerContext . setMacroLibraries ( macroLibraries ) ; } public List getMacroLibraries ( ) { return innerContext . getMacroLibraries ( ) ; } public EventCartridge attachEventCartridge ( EventCartridge ec ) { return innerContext . attachEventCartridge ( ec ) ; } public EventCartridge getEventCartridge ( ) { return innerContext . getEventCartridge ( ) ; } public void setCurrentResource ( Resource r ) { innerContext . setCurrentResource ( r ) ; } public Resource getCurrentResource ( ) { return innerContext . getCurrentResource ( ) ; } } 	1	['28', '1', '3', '8', '55', '0', '3', '5', '28', '0', '162', '1', '1', '0', '0.178571429', '0', '0', '4.75', '1', '0.9643', '1']
package org . apache . velocity . runtime . log ; public class NullLogSystem extends NullLogChute implements LogSystem { public void logVelocityMessage ( int level , String message ) { } } 	0	['2', '2', '0', '2', '3', '1', '0', '2', '2', '2', '6', '0', '0', '0.8', '0.666666667', '0', '0', '2', '1', '0.5', '0']
package org . apache . velocity . runtime . parser . node ; import java . io . IOException ; import java . io . Writer ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . Token ; public class ASTComment extends SimpleNode { private static final char [ ] ZILCH = "" . toCharArray ( ) ; private char [ ] carr ; public ASTComment ( int id ) { super ( id ) ; } public ASTComment ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object init ( InternalContextAdapter context , Object data ) { Token t = getFirstToken ( ) ; int loc1 = t . image . indexOf ( "##" ) ; int loc2 = t . image . indexOf ( "#*" ) ; if ( loc1 == - 1 && loc2 == - 1 ) { carr = ZILCH ; } else { carr = t . image . substring ( 0 , ( loc1 == - 1 ) ? loc2 : loc1 ) . toCharArray ( ) ; } return data ; } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException , ParseErrorException , ResourceNotFoundException { if ( context . getAllowRendering ( ) ) { writer . write ( carr ) ; } return true ; } } 	1	['6', '2', '0', '9', '15', '11', '3', '8', '5', '0.8', '73', '1', '0', '0.909090909', '0.4', '0', '0', '10.83333333', '4', '1', '1']
package org . apache . velocity . runtime ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import java . io . Writer ; import java . io . IOException ; public interface Renderable { public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException , ParseErrorException , ResourceNotFoundException ; } 	0	['1', '1', '0', '6', '1', '0', '2', '4', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . velocity . runtime . directive ; import java . io . Writer ; import java . io . IOException ; import java . io . StringWriter ; import org . apache . commons . lang . text . StrBuilder ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . runtime . Renderable ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . parser . node . Node ; public class Define extends Directive { private String key ; private Node block ; private Log log ; private int maxDepth ; private String definingTemplate ; public String getName ( ) { return "define" ; } public int getType ( ) { return BLOCK ; } public void init ( RuntimeServices rs , InternalContextAdapter context , Node node ) throws TemplateInitException { super . init ( rs , context , node ) ; log = rs . getLog ( ) ; maxDepth = rs . getInt ( RuntimeConstants . DEFINE_DIRECTIVE_MAXDEPTH , 2 ) ; key = node . jjtGetChild ( 0 ) . getFirstToken ( ) . image . substring ( 1 ) ; block = node . jjtGetChild ( 1 ) ; definingTemplate = context . getCurrentTemplateName ( ) ; } public boolean render ( InternalContextAdapter context , Writer writer , Node node ) { context . put ( key , new Block ( context , this ) ) ; return true ; } protected String id ( InternalContextAdapter context ) { StrBuilder str = new StrBuilder ( 100 ) . append ( "block $" ) . append ( key ) . append ( " (defined in " ) . append ( definingTemplate ) . append ( " [line " ) . append ( getLine ( ) ) . append ( ", column " ) . append ( getColumn ( ) ) . append ( "])" ) ; if ( ! context . getCurrentTemplateName ( ) . equals ( definingTemplate ) ) { str . append ( " used in " ) . append ( context . getCurrentTemplateName ( ) ) ; } return str . toString ( ) ; } public static class Block implements Renderable { private InternalContextAdapter context ; private Define parent ; private int depth ; public Block ( InternalContextAdapter context , Define parent ) { this . context = context ; this . parent = parent ; } public boolean render ( InternalContextAdapter context , Writer writer ) { try { depth ++ ; if ( depth > parent . maxDepth ) { parent . log . debug ( "Max recursion depth reached for " + parent . id ( context ) ) ; depth -- ; return false ; } else { parent . block . render ( context , writer ) ; depth -- ; return true ; } } catch ( IOException e ) { String msg = "Failed to render " + parent . id ( context ) + " to writer" ; parent . log . error ( msg , e ) ; throw new RuntimeException ( msg , e ) ; } catch ( VelocityException ve ) { String msg = "Failed to render " + parent . id ( context ) + " due to " + ve ; parent . log . error ( msg , ve ) ; throw ve ; } } public String toString ( ) { Writer stringwriter = new StringWriter ( ) ; if ( render ( context , stringwriter ) ) { return stringwriter . toString ( ) ; } else { return null ; } } } } 	1	['9', '2', '0', '9', '26', '24', '1', '9', '5', '0.85', '119', '1', '2', '0.529411765', '0.296296296', '0', '0', '11.66666667', '2', '1', '1']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; public class ASTSubtractNode extends ASTMathNode { public ASTSubtractNode ( int id ) { super ( id ) ; } public ASTSubtractNode ( Parser p , int id ) { super ( p , id ) ; } public Number perform ( Number left , Number right , InternalContextAdapter context ) { return MathUtils . subtract ( left , right ) ; } } 	0	['3', '3', '0', '7', '6', '3', '4', '4', '3', '2', '16', '0', '0', '0.972222222', '0.533333333', '1', '1', '4.333333333', '1', '0.3333', '0']
package org . apache . velocity . runtime ; import java . io . IOException ; import java . io . Reader ; import java . io . Writer ; import java . util . Properties ; import org . apache . commons . collections . ExtendedProperties ; import org . apache . velocity . Template ; import org . apache . velocity . app . event . EventCartridge ; import org . apache . velocity . context . Context ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . runtime . directive . Directive ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . parser . ParseException ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . runtime . parser . node . SimpleNode ; import org . apache . velocity . runtime . resource . ContentResource ; import org . apache . velocity . util . introspection . Introspector ; import org . apache . velocity . util . introspection . Uberspect ; public interface RuntimeServices extends RuntimeLogger { public void init ( ) throws Exception ; public void setProperty ( String key , Object value ) ; public void setConfiguration ( ExtendedProperties configuration ) ; public void addProperty ( String key , Object value ) ; public void clearProperty ( String key ) ; public Object getProperty ( String key ) ; public void init ( Properties p ) throws Exception ; public void init ( String configurationFile ) throws Exception ; public SimpleNode parse ( String string , String templateName ) throws ParseException ; public SimpleNode parse ( Reader reader , String templateName ) throws ParseException ; public SimpleNode parse ( Reader reader , String templateName , boolean dumpNamespace ) throws ParseException ; public boolean evaluate ( Context context , Writer out , String logTag , String instring ) throws IOException ; public boolean evaluate ( Context context , Writer writer , String logTag , Reader reader ) throws IOException ; public boolean invokeVelocimacro ( final String vmName , String logTag , String [ ] params , final Context context , final Writer writer ) throws IOException ; public Template getTemplate ( String name ) throws ResourceNotFoundException , ParseErrorException , Exception ; public Template getTemplate ( String name , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception ; public ContentResource getContent ( String name ) throws ResourceNotFoundException , ParseErrorException , Exception ; public ContentResource getContent ( String name , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception ; public String getLoaderNameForResource ( String resourceName ) ; public String getString ( String key , String defaultValue ) ; public Directive getVelocimacro ( String vmName , String templateName ) ; public Directive getVelocimacro ( String vmName , String templateName , String renderingTemplate ) ; public boolean addVelocimacro ( String name , String macro , String argArray [ ] , String sourceTemplate ) ; public boolean addVelocimacro ( String name , Node macro , String argArray [ ] , String sourceTemplate ) ; public boolean isVelocimacro ( String vmName , String templateName ) ; public boolean dumpVMNamespace ( String namespace ) ; public String getString ( String key ) ; public int getInt ( String key ) ; public int getInt ( String key , int defaultValue ) ; public boolean getBoolean ( String key , boolean def ) ; public ExtendedProperties getConfiguration ( ) ; public Object getApplicationAttribute ( Object key ) ; public Object setApplicationAttribute ( Object key , Object value ) ; public Uberspect getUberspect ( ) ; public Log getLog ( ) ; public EventCartridge getApplicationEventCartridge ( ) ; public Introspector getIntrospector ( ) ; public boolean isInitialized ( ) ; public Parser createNewParser ( ) ; public Directive getDirective ( String name ) ; } 	1	['40', '1', '0', '73', '40', '780', '63', '16', '40', '2', '40', '0', '0', '0', '0.1875', '0', '0', '0', '1', '1', '1']
package org . apache . velocity . util . introspection ; import org . apache . velocity . runtime . log . Log ; public class Info { private int line ; private int column ; private String templateName ; public Info ( String source , int line , int column ) { this . templateName = source ; this . line = line ; this . column = column ; } private Info ( ) { } public String getTemplateName ( ) { return templateName ; } public int getLine ( ) { return line ; } public int getColumn ( ) { return column ; } public String toString ( ) { return Log . formatFileString ( getTemplateName ( ) , getLine ( ) , getColumn ( ) ) ; } } 	0	['6', '1', '1', '21', '8', '9', '21', '1', '5', '0.6', '41', '1', '0', '0', '0.444444444', '0', '0', '5.333333333', '1', '0.6667', '0']
package org . apache . velocity . util . introspection ; import java . util . Iterator ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . util . RuntimeServicesAware ; public class LinkingUberspector extends AbstractChainableUberspector { private Uberspect leftUberspect ; private Uberspect rightUberspect ; public LinkingUberspector ( Uberspect left , Uberspect right ) { leftUberspect = left ; rightUberspect = right ; } public void init ( ) throws Exception { leftUberspect . init ( ) ; rightUberspect . init ( ) ; } public Iterator getIterator ( Object obj , Info i ) throws Exception { Iterator it = leftUberspect . getIterator ( obj , i ) ; return it != null ? it : rightUberspect . getIterator ( obj , i ) ; } public VelMethod getMethod ( Object obj , String methodName , Object [ ] args , Info i ) throws Exception { VelMethod method = leftUberspect . getMethod ( obj , methodName , args , i ) ; return method != null ? method : rightUberspect . getMethod ( obj , methodName , args , i ) ; } public VelPropertyGet getPropertyGet ( Object obj , String identifier , Info i ) throws Exception { VelPropertyGet getter = leftUberspect . getPropertyGet ( obj , identifier , i ) ; return getter != null ? getter : rightUberspect . getPropertyGet ( obj , identifier , i ) ; } public VelPropertySet getPropertySet ( Object obj , String identifier , Object arg , Info i ) throws Exception { VelPropertySet setter = leftUberspect . getPropertySet ( obj , identifier , arg , i ) ; return setter != null ? setter : rightUberspect . getPropertySet ( obj , identifier , arg , i ) ; } } 	1	['6', '3', '0', '7', '12', '0', '1', '6', '6', '0', '98', '1', '2', '0.736842105', '0.527777778', '0', '0', '15', '1', '0.8333', '2']
package org . apache . velocity . app . event ; import org . apache . velocity . context . Context ; import org . apache . velocity . util . ContextAware ; public interface IncludeEventHandler extends EventHandler { public String includeEvent ( String includeResourcePath , String currentResourcePath , String directiveName ) ; static class IncludeEventExecutor implements EventHandlerMethodExecutor { private Context context ; private String includeResourcePath ; private String currentResourcePath ; private String directiveName ; private boolean executed = false ; IncludeEventExecutor ( Context context , String includeResourcePath , String currentResourcePath , String directiveName ) { this . context = context ; this . includeResourcePath = includeResourcePath ; this . currentResourcePath = currentResourcePath ; this . directiveName = directiveName ; } public void execute ( EventHandler handler ) { IncludeEventHandler eh = ( IncludeEventHandler ) handler ; if ( eh instanceof ContextAware ) ( ( ContextAware ) eh ) . setContext ( context ) ; executed = true ; includeResourcePath = ( ( IncludeEventHandler ) handler ) . includeEvent ( includeResourcePath , currentResourcePath , directiveName ) ; } public Object getReturnValue ( ) { return includeResourcePath ; } public boolean isDone ( ) { return executed && ( includeResourcePath == null ) ; } } } 	0	['1', '1', '0', '6', '1', '0', '5', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . velocity . context ; import org . apache . velocity . util . introspection . IntrospectionCacheData ; import org . apache . velocity . runtime . resource . Resource ; import java . util . List ; interface InternalHousekeepingContext { void pushCurrentTemplateName ( String s ) ; void popCurrentTemplateName ( ) ; String getCurrentTemplateName ( ) ; Object [ ] getTemplateNameStack ( ) ; void pushCurrentMacroName ( String s ) ; void popCurrentMacroName ( ) ; String getCurrentMacroName ( ) ; int getCurrentMacroCallDepth ( ) ; Object [ ] getMacroNameStack ( ) ; IntrospectionCacheData icacheGet ( Object key ) ; void icachePut ( Object key , IntrospectionCacheData o ) ; Resource getCurrentResource ( ) ; void setCurrentResource ( Resource r ) ; boolean getAllowRendering ( ) ; void setAllowRendering ( boolean v ) ; void setMacroLibraries ( List macroLibraries ) ; List getMacroLibraries ( ) ; } 	1	['17', '1', '0', '5', '17', '136', '3', '2', '17', '2', '17', '0', '0', '0', '0.210084034', '0', '0', '0', '1', '1', '1']
package org . apache . velocity . runtime . resource ; import java . io . StringWriter ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . VelocityException ; public class ContentResource extends Resource { public ContentResource ( ) { super ( ) ; setType ( ResourceManager . RESOURCE_CONTENT ) ; } public boolean process ( ) throws ResourceNotFoundException { BufferedReader reader = null ; try { StringWriter sw = new StringWriter ( ) ; reader = new BufferedReader ( new InputStreamReader ( resourceLoader . getResourceStream ( name ) , encoding ) ) ; char buf [ ] = new char [ 1024 ] ; int len = 0 ; while ( ( len = reader . read ( buf , 0 , 1024 ) ) != - 1 ) sw . write ( buf , 0 , len ) ; setData ( sw . toString ( ) ) ; return true ; } catch ( ResourceNotFoundException e ) { throw e ; } catch ( Exception e ) { String msg = "Cannot process content resource" ; rsvc . getLog ( ) . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( Exception ignored ) { } } } } } 	0	['2', '2', '0', '11', '16', '1', '6', '6', '2', '2', '87', '0', '0', '0.947368421', '1', '1', '1', '42.5', '1', '0.5', '0']
package org . apache . velocity . runtime . parser . node ; import java . io . IOException ; import java . io . Writer ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . Token ; public class ASTText extends SimpleNode { private char [ ] ctext ; public ASTText ( int id ) { super ( id ) ; } public ASTText ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object init ( InternalContextAdapter context , Object data ) throws TemplateInitException { Token t = getFirstToken ( ) ; String text = NodeUtils . tokenLiteral ( t ) ; ctext = text . toCharArray ( ) ; return data ; } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException { if ( context . getAllowRendering ( ) ) { writer . write ( ctext ) ; } return true ; } } 	1	['5', '2', '0', '9', '13', '8', '4', '7', '5', '0.75', '41', '1', '0', '0.909090909', '0.4', '0', '0', '7', '1', '0.6', '4']
package org . apache . velocity . util ; import java . lang . reflect . Array ; import java . util . AbstractList ; public class ArrayListWrapper extends AbstractList { private Object array ; public ArrayListWrapper ( Object array ) { this . array = array ; } public Object get ( int index ) { return Array . get ( array , index ) ; } public Object set ( int index , Object element ) { Object old = get ( index ) ; Array . set ( array , index , element ) ; return old ; } public int size ( ) { return Array . getLength ( array ) ; } } 	0	['4', '3', '0', '1', '8', '0', '1', '0', '4', '0', '31', '1', '0', '0.918918919', '0.666666667', '2', '9', '6.5', '1', '0.75', '0']
package org . apache . velocity . runtime . parser . node ; import java . io . IOException ; import java . io . Writer ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . runtime . parser . Token ; public interface Node { public void jjtOpen ( ) ; public void jjtClose ( ) ; public void jjtSetParent ( Node n ) ; public Node jjtGetParent ( ) ; public void jjtAddChild ( Node n , int i ) ; public Node jjtGetChild ( int i ) ; public int jjtGetNumChildren ( ) ; public Object jjtAccept ( ParserVisitor visitor , Object data ) ; public Object childrenAccept ( ParserVisitor visitor , Object data ) ; public Token getFirstToken ( ) ; public Token getLastToken ( ) ; public int getType ( ) ; public Object init ( InternalContextAdapter context , Object data ) throws TemplateInitException ; public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException ; public Object value ( InternalContextAdapter context ) throws MethodInvocationException ; public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException , ParseErrorException , ResourceNotFoundException ; public Object execute ( Object o , InternalContextAdapter context ) throws MethodInvocationException ; public void setInfo ( int info ) ; public int getInfo ( ) ; public String literal ( ) ; public void setInvalid ( ) ; public boolean isInvalid ( ) ; public int getLine ( ) ; public int getColumn ( ) ; public String getTemplateName ( ) ; } 	1	['25', '1', '0', '54', '25', '300', '47', '7', '25', '2', '25', '0', '0', '0', '0.24', '0', '0', '0', '1', '1', '1']
package org . apache . velocity . anakia ; import org . jdom . Element ; import org . jdom . Namespace ; import org . jdom . DefaultJDOMFactory ; public class AnakiaJDOMFactory extends DefaultJDOMFactory { public AnakiaJDOMFactory ( ) { } public Element element ( String name , Namespace namespace ) { return new AnakiaElement ( name , namespace ) ; } public Element element ( String name ) { return new AnakiaElement ( name ) ; } public Element element ( String name , String uri ) { return new AnakiaElement ( name , uri ) ; } public Element element ( String name , String prefix , String uri ) { return new AnakiaElement ( name , prefix , uri ) ; } } 	0	['5', '2', '0', '5', '10', '10', '1', '4', '5', '2', '32', '0', '0', '0.862068966', '0.666666667', '0', '0', '5.4', '1', '0.8', '0']
package org . apache . velocity . runtime . resource ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . ParseErrorException ; public interface ResourceManager { public static final int RESOURCE_TEMPLATE = 1 ; public static final int RESOURCE_CONTENT = 2 ; public void initialize ( RuntimeServices rs ) throws Exception ; public Resource getResource ( String resourceName , int resourceType , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception ; public String getLoaderNameForResource ( String resourceName ) ; } 	1	['3', '1', '0', '6', '3', '3', '2', '4', '3', '1.5', '5', '0', '0', '0', '0.583333333', '0', '0', '0', '1', '1', '1']
