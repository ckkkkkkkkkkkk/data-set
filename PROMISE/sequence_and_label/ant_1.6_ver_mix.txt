package org . apache . tools . ant . input ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . Properties ; import org . apache . tools . ant . BuildException ; public class PropertyFileInputHandler implements InputHandler { private Properties props = null ; public static final String FILE_NAME_KEY = "ant.input.properties" ; public PropertyFileInputHandler ( ) { } public void handleInput ( InputRequest request ) throws BuildException { readProps ( ) ; Object o = props . get ( request . getPrompt ( ) ) ; if ( o == null ) { throw new BuildException ( "Unable to find input for \'" + request . getPrompt ( ) + "\'" ) ; } request . setInput ( o . toString ( ) ) ; if ( ! request . isInputValid ( ) ) { throw new BuildException ( "Found invalid input " + o + " for \'" + request . getPrompt ( ) + "\'" ) ; } } private synchronized void readProps ( ) throws BuildException { if ( props == null ) { String propsFile = System . getProperty ( FILE_NAME_KEY ) ; if ( propsFile == null ) { throw new BuildException ( "System property " + FILE_NAME_KEY + " for PropertyFileInputHandler not" + " set" ) ; } props = new Properties ( ) ; try { props . load ( new FileInputStream ( propsFile ) ) ; } catch ( IOException e ) { throw new BuildException ( "Couldn't load " + propsFile , e ) ; } } } } 	0	['3', '1', '0', '3', '19', '0', '0', '3', '2', '0.75', '104', '0.5', '0', '0', '0.666666667', '0', '0', '33', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . PrintStream ; import java . lang . reflect . Method ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import java . util . Set ; import java . util . HashSet ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . BuildListener ; import org . apache . tools . ant . DefaultLogger ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . Target ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . PropertySet ; import org . apache . tools . ant . util . FileUtils ; public class Ant extends Task { private File dir = null ; private String antFile = null ; private String target = null ; private String output = null ; private boolean inheritAll = true ; private boolean inheritRefs = false ; private Vector properties = new Vector ( ) ; private Vector references = new Vector ( ) ; private Project newProject ; private PrintStream out = null ; private Vector propertySets = new Vector ( ) ; public void setInheritAll ( boolean value ) { inheritAll = value ; } public void setInheritRefs ( boolean value ) { inheritRefs = value ; } public void init ( ) { newProject = new Project ( ) ; newProject . setDefaultInputStream ( getProject ( ) . getDefaultInputStream ( ) ) ; newProject . setJavaVersionProperty ( ) ; } private void reinit ( ) { init ( ) ; } private void initializeProject ( ) { newProject . setInputHandler ( getProject ( ) . getInputHandler ( ) ) ; Vector listeners = getProject ( ) . getBuildListeners ( ) ; final int count = listeners . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { newProject . addBuildListener ( ( BuildListener ) listeners . elementAt ( i ) ) ; } if ( output != null ) { File outfile = null ; if ( dir != null ) { outfile = FileUtils . newFileUtils ( ) . resolveFile ( dir , output ) ; } else { outfile = getProject ( ) . resolveFile ( output ) ; } try { out = new PrintStream ( new FileOutputStream ( outfile ) ) ; DefaultLogger logger = new DefaultLogger ( ) ; logger . setMessageOutputLevel ( Project . MSG_INFO ) ; logger . setOutputPrintStream ( out ) ; logger . setErrorPrintStream ( out ) ; newProject . addBuildListener ( logger ) ; } catch ( IOException ex ) { log ( "Ant: Can't set output to " + output ) ; } } getProject ( ) . initSubProject ( newProject ) ; getProject ( ) . copyUserProperties ( newProject ) ; if ( ! inheritAll ) { newProject . setSystemProperties ( ) ; } else { addAlmostAll ( getProject ( ) . getProperties ( ) ) ; } Enumeration e = propertySets . elements ( ) ; while ( e . hasMoreElements ( ) ) { PropertySet ps = ( PropertySet ) e . nextElement ( ) ; addAlmostAll ( ps . getProperties ( ) ) ; } } public void handleOutput ( String output ) { if ( newProject != null ) { newProject . demuxOutput ( output , false ) ; } else { super . handleOutput ( output ) ; } } public int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException { if ( newProject != null ) { return newProject . demuxInput ( buffer , offset , length ) ; } else { return super . handleInput ( buffer , offset , length ) ; } } public void handleFlush ( String output ) { if ( newProject != null ) { newProject . demuxFlush ( output , false ) ; } else { super . handleFlush ( output ) ; } } public void handleErrorOutput ( String output ) { if ( newProject != null ) { newProject . demuxOutput ( output , true ) ; } else { super . handleErrorOutput ( output ) ; } } public void handleErrorFlush ( String output ) { if ( newProject != null ) { newProject . demuxFlush ( output , true ) ; } else { super . handleErrorFlush ( output ) ; } } public void execute ( ) throws BuildException { File savedDir = dir ; String savedAntFile = antFile ; String savedTarget = target ; try { if ( newProject == null ) { reinit ( ) ; } if ( ( dir == null ) && ( inheritAll ) ) { dir = getProject ( ) . getBaseDir ( ) ; } initializeProject ( ) ; if ( dir != null ) { newProject . setBaseDir ( dir ) ; if ( savedDir != null ) { newProject . setInheritedProperty ( "basedir" , dir . getAbsolutePath ( ) ) ; } } else { dir = getProject ( ) . getBaseDir ( ) ; } overrideProperties ( ) ; if ( antFile == null ) { antFile = "build.xml" ; } File file = FileUtils . newFileUtils ( ) . resolveFile ( dir , antFile ) ; antFile = file . getAbsolutePath ( ) ; log ( "calling target " + ( target != null ? target : "[default]" ) + " in build file " + antFile , Project . MSG_VERBOSE ) ; newProject . setUserProperty ( "ant.file" , antFile ) ; if ( newProject . getProperty ( "ant.file" ) . equals ( getProject ( ) . getProperty ( "ant.file" ) ) && getOwningTarget ( ) != null ) { if ( getOwningTarget ( ) . getName ( ) . equals ( "" ) ) { if ( getTaskName ( ) . equals ( "antcall" ) ) { throw new BuildException ( "antcall must not be used at" + " the top level." ) ; } else { throw new BuildException ( getTaskName ( ) + " task at the" + " top level must not invoke" + " its own build file." ) ; } } } try { ProjectHelper . configureProject ( newProject , new File ( antFile ) ) ; } catch ( BuildException ex ) { throw ProjectHelper . addLocationToBuildException ( ex , getLocation ( ) ) ; } if ( target == null ) { target = newProject . getDefaultTarget ( ) ; } if ( newProject . getProperty ( "ant.file" ) . equals ( getProject ( ) . getProperty ( "ant.file" ) ) && getOwningTarget ( ) != null ) { String owningTargetName = getOwningTarget ( ) . getName ( ) ; if ( owningTargetName . equals ( target ) ) { throw new BuildException ( getTaskName ( ) + " task calling " + "its own parent target." ) ; } else { Target other = ( Target ) getProject ( ) . getTargets ( ) . get ( target ) ; if ( other != null && other . dependsOn ( owningTargetName ) ) { throw new BuildException ( getTaskName ( ) + " task calling a target" + " that depends on" + " its parent target \'" + owningTargetName + "\'." ) ; } } } addReferences ( ) ; if ( target != null && ! "" . equals ( target ) ) { try { log ( "Entering " + antFile + "..." , Project . MSG_VERBOSE ) ; newProject . executeTarget ( target ) ; } catch ( BuildException ex ) { throw ProjectHelper . addLocationToBuildException ( ex , getLocation ( ) ) ; } finally { log ( "Exiting " + antFile + "." , Project . MSG_VERBOSE ) ; } } } finally { newProject = null ; Enumeration e = properties . elements ( ) ; while ( e . hasMoreElements ( ) ) { Property p = ( Property ) e . nextElement ( ) ; p . setProject ( null ) ; } if ( output != null && out != null ) { try { out . close ( ) ; } catch ( final Exception ex ) { } } dir = savedDir ; antFile = savedAntFile ; target = savedTarget ; } } private void overrideProperties ( ) throws BuildException { Set set = new HashSet ( ) ; for ( int i = properties . size ( ) - 1 ; i >= 0 ; -- i ) { Property p = ( Property ) properties . get ( i ) ; if ( p . getName ( ) != null && ! p . getName ( ) . equals ( "" ) ) { if ( set . contains ( p . getName ( ) ) ) { properties . remove ( i ) ; } else { set . add ( p . getName ( ) ) ; } } } Enumeration e = properties . elements ( ) ; while ( e . hasMoreElements ( ) ) { Property p = ( Property ) e . nextElement ( ) ; p . setProject ( newProject ) ; p . execute ( ) ; } getProject ( ) . copyInheritedProperties ( newProject ) ; } private void addReferences ( ) throws BuildException { Hashtable thisReferences = ( Hashtable ) getProject ( ) . getReferences ( ) . clone ( ) ; Hashtable newReferences = newProject . getReferences ( ) ; Enumeration e ; if ( references . size ( ) > 0 ) { for ( e = references . elements ( ) ; e . hasMoreElements ( ) ; ) { Reference ref = ( Reference ) e . nextElement ( ) ; String refid = ref . getRefId ( ) ; if ( refid == null ) { throw new BuildException ( "the refid attribute is required" + " for reference elements" ) ; } if ( ! thisReferences . containsKey ( refid ) ) { log ( "Parent project doesn't contain any reference '" + refid + "'" , Project . MSG_WARN ) ; continue ; } thisReferences . remove ( refid ) ; String toRefid = ref . getToRefid ( ) ; if ( toRefid == null ) { toRefid = refid ; } copyReference ( refid , toRefid ) ; } } if ( inheritRefs ) { for ( e = thisReferences . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; if ( newReferences . containsKey ( key ) ) { continue ; } copyReference ( key , key ) ; } } } private void copyReference ( String oldKey , String newKey ) { Object orig = getProject ( ) . getReference ( oldKey ) ; if ( orig == null ) { log ( "No object referenced by " + oldKey + ". Can't copy to " + newKey , Project . MSG_WARN ) ; return ; } Class c = orig . getClass ( ) ; Object copy = orig ; try { Method cloneM = c . getMethod ( "clone" , new Class [ 0 ] ) ; if ( cloneM != null ) { copy = cloneM . invoke ( orig , new Object [ 0 ] ) ; log ( "Adding clone of reference " + oldKey , Project . MSG_DEBUG ) ; } } catch ( Exception e ) { } if ( copy instanceof ProjectComponent ) { ( ( ProjectComponent ) copy ) . setProject ( newProject ) ; } else { try { Method setProjectM = c . getMethod ( "setProject" , new Class [ ] { Project . class } ) ; if ( setProjectM != null ) { setProjectM . invoke ( copy , new Object [ ] { newProject } ) ; } } catch ( NoSuchMethodException e ) { } catch ( Exception e2 ) { String msg = "Error setting new project instance for " + "reference with id " + oldKey ; throw new BuildException ( msg , e2 , getLocation ( ) ) ; } } newProject . addReference ( newKey , copy ) ; } private void addAlmostAll ( Hashtable props ) { Enumeration e = props . keys ( ) ; while ( e . hasMoreElements ( ) ) { String key = e . nextElement ( ) . toString ( ) ; if ( "basedir" . equals ( key ) || "ant.file" . equals ( key ) ) { continue ; } String value = props . get ( key ) . toString ( ) ; if ( newProject . getProperty ( key ) == null ) { newProject . setNewProperty ( key , value ) ; } } } public void setDir ( File d ) { this . dir = d ; } public void setAntfile ( String s ) { this . antFile = s ; } public void setTarget ( String s ) { if ( s . equals ( "" ) ) { throw new BuildException ( "target attribute must not be empty" ) ; } this . target = s ; } public void setOutput ( String s ) { this . output = s ; } public Property createProperty ( ) { if ( newProject == null ) { reinit ( ) ; } Property p = new Property ( true , getProject ( ) ) ; p . setProject ( newProject ) ; p . setTaskName ( "property" ) ; properties . addElement ( p ) ; return p ; } public void addReference ( Reference r ) { references . addElement ( r ) ; } public void addPropertyset ( PropertySet ps ) { propertySets . addElement ( ps ) ; } public static class Reference extends org . apache . tools . ant . types . Reference { public Reference ( ) { super ( ) ; } private String targetid = null ; public void setToRefid ( String targetid ) { this . targetid = targetid ; } public String getToRefid ( ) { return targetid ; } } } 	1	['24', '3', '0', '17', '118', '72', '2', '15', '17', '0.851449275', '1066', '0.916666667', '1', '0.616666667', '0.185185185', '3', '4', '42.91666667', '6', '1.7083', '2']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . Enumeration ; public class OrSelector extends BaseSelectorContainer { public OrSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{orselect: " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; Enumeration e = selectorElements ( ) ; boolean result ; while ( e . hasMoreElements ( ) ) { result = ( ( FileSelector ) e . nextElement ( ) ) . isSelected ( basedir , filename , file ) ; if ( result ) { return true ; } } return false ; } } 	0	['3', '5', '0', '6', '14', '3', '5', '2', '3', '2', '52', '0', '0', '0.96875', '0.555555556', '1', '1', '16.33333333', '3', '1.6667', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import java . util . List ; import java . util . ArrayList ; import java . util . Iterator ; public class Assertions extends DataType { private Boolean enableSystemAssertions ; private ArrayList assertionList = new ArrayList ( ) ; public void addEnable ( EnabledAssertion assertion ) { checkChildrenAllowed ( ) ; assertionList . add ( assertion ) ; } public void addDisable ( DisabledAssertion assertion ) { checkChildrenAllowed ( ) ; assertionList . add ( assertion ) ; } public void setEnableSystemAssertions ( Boolean enableSystemAssertions ) { checkAttributesAllowed ( ) ; this . enableSystemAssertions = enableSystemAssertions ; } public void setRefid ( Reference ref ) { if ( assertionList . size ( ) > 0 || enableSystemAssertions != null ) { throw tooManyAttributes ( ) ; } super . setRefid ( ref ) ; } private Assertions getFinalReference ( ) { if ( getRefid ( ) == null ) { return this ; } else { Object o = getRefid ( ) . getReferencedObject ( getProject ( ) ) ; if ( ! ( o instanceof Assertions ) ) { throw new BuildException ( "reference is of wrong type" ) ; } return ( Assertions ) o ; } } public int size ( ) { Assertions clause = getFinalReference ( ) ; return clause . getFinalSize ( ) ; } private int getFinalSize ( ) { return assertionList . size ( ) + ( enableSystemAssertions != null ? 1 : 0 ) ; } public void applyAssertions ( List commandList ) { getProject ( ) . log ( "Applying assertions" , Project . MSG_DEBUG ) ; Assertions clause = getFinalReference ( ) ; if ( Boolean . TRUE . equals ( clause . enableSystemAssertions ) ) { getProject ( ) . log ( "Enabling system assertions" , Project . MSG_DEBUG ) ; commandList . add ( "-enablesystemassertions" ) ; } else if ( Boolean . FALSE . equals ( clause . enableSystemAssertions ) ) { getProject ( ) . log ( "disabling system assertions" , Project . MSG_DEBUG ) ; commandList . add ( "-disablesystemassertions" ) ; } Iterator it = clause . assertionList . iterator ( ) ; while ( it . hasNext ( ) ) { BaseAssertion assertion = ( BaseAssertion ) it . next ( ) ; String arg = assertion . toCommand ( ) ; getProject ( ) . log ( "adding assertion " + arg , Project . MSG_DEBUG ) ; commandList . add ( arg ) ; } } public void applyAssertions ( CommandlineJava command ) { Assertions clause = getFinalReference ( ) ; if ( Boolean . TRUE . equals ( clause . enableSystemAssertions ) ) { addVmArgument ( command , "-enablesystemassertions" ) ; } else if ( Boolean . FALSE . equals ( clause . enableSystemAssertions ) ) { addVmArgument ( command , "-disablesystemassertions" ) ; } Iterator it = clause . assertionList . iterator ( ) ; while ( it . hasNext ( ) ) { BaseAssertion assertion = ( BaseAssertion ) it . next ( ) ; String arg = assertion . toCommand ( ) ; addVmArgument ( command , arg ) ; } } private static void addVmArgument ( CommandlineJava command , String arg ) { Commandline . Argument argument ; argument = command . createVmArgument ( ) ; argument . setValue ( arg ) ; } protected Object clone ( ) throws CloneNotSupportedException { Assertions that = ( Assertions ) super . clone ( ) ; that . assertionList = ( ArrayList ) assertionList . clone ( ) ; return that ; } public abstract static class BaseAssertion { private String packageName ; private String className ; public void setClass ( String className ) { this . className = className ; } public void setPackage ( String packageName ) { this . packageName = packageName ; } protected String getClassName ( ) { return className ; } protected String getPackageName ( ) { return packageName ; } public abstract String getCommandPrefix ( ) ; public String toCommand ( ) { if ( getPackageName ( ) != null && getClassName ( ) != null ) { throw new BuildException ( "Both package and class have been set" ) ; } StringBuffer command = new StringBuffer ( getCommandPrefix ( ) ) ; if ( getPackageName ( ) != null ) { command . append ( ':' ) ; command . append ( getPackageName ( ) ) ; if ( ! command . toString ( ) . endsWith ( "..." ) ) { command . append ( "..." ) ; } } else if ( getClassName ( ) != null ) { command . append ( ':' ) ; command . append ( getClassName ( ) ) ; } return command . toString ( ) ; } } public static class EnabledAssertion extends BaseAssertion { public String getCommandPrefix ( ) { return "-ea" ; } } public static class DisabledAssertion extends BaseAssertion { public String getCommandPrefix ( ) { return "-da" ; } } } 	1	['12', '3', '0', '11', '38', '2', '2', '10', '8', '0.409090909', '224', '1', '0', '0.731707317', '0.197916667', '2', '3', '17.5', '4', '1.8333', '2']
package org . apache . tools . ant . filters . util ; import java . io . FilterReader ; import java . io . IOException ; import java . io . Reader ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . util . Vector ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . filters . BaseFilterReader ; import org . apache . tools . ant . filters . ChainableReader ; import org . apache . tools . ant . types . AntFilterReader ; import org . apache . tools . ant . types . FilterChain ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . types . Parameterizable ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileUtils ; public final class ChainReaderHelper { private static final int DEFAULT_BUFFER_SIZE = 8192 ; public Reader primaryReader ; public int bufferSize = DEFAULT_BUFFER_SIZE ; public Vector filterChains = new Vector ( ) ; private Project project = null ; public final void setPrimaryReader ( Reader rdr ) { primaryReader = rdr ; } public final void setProject ( final Project project ) { this . project = project ; } public final Project getProject ( ) { return project ; } public final void setBufferSize ( int size ) { bufferSize = size ; } public final void setFilterChains ( Vector fchain ) { filterChains = fchain ; } public final Reader getAssembledReader ( ) throws BuildException { if ( primaryReader == null ) { throw new BuildException ( "primaryReader must not be null." ) ; } Reader instream = primaryReader ; final int filterReadersCount = filterChains . size ( ) ; final Vector finalFilters = new Vector ( ) ; for ( int i = 0 ; i < filterReadersCount ; i ++ ) { final FilterChain filterchain = ( FilterChain ) filterChains . elementAt ( i ) ; final Vector filterReaders = filterchain . getFilterReaders ( ) ; final int readerCount = filterReaders . size ( ) ; for ( int j = 0 ; j < readerCount ; j ++ ) { finalFilters . addElement ( filterReaders . elementAt ( j ) ) ; } } final int filtersCount = finalFilters . size ( ) ; if ( filtersCount > 0 ) { for ( int i = 0 ; i < filtersCount ; i ++ ) { Object o = finalFilters . elementAt ( i ) ; if ( o instanceof AntFilterReader ) { final AntFilterReader filter = ( AntFilterReader ) finalFilters . elementAt ( i ) ; final String className = filter . getClassName ( ) ; final Path classpath = filter . getClasspath ( ) ; final Project project = filter . getProject ( ) ; if ( className != null ) { try { Class clazz = null ; if ( classpath == null ) { clazz = Class . forName ( className ) ; } else { AntClassLoader al = project . createClassLoader ( classpath ) ; clazz = Class . forName ( className , true , al ) ; } if ( clazz != null ) { if ( ! FilterReader . class . isAssignableFrom ( clazz ) ) { throw new BuildException ( className + " does not extend java.io.FilterReader" ) ; } final Constructor [ ] constructors = clazz . getConstructors ( ) ; int j = 0 ; boolean consPresent = false ; for ( ; j < constructors . length ; j ++ ) { Class [ ] types = constructors [ j ] . getParameterTypes ( ) ; if ( types . length == 1 && types [ 0 ] . isAssignableFrom ( Reader . class ) ) { consPresent = true ; break ; } } if ( ! consPresent ) { throw new BuildException ( className + " does not define a public constructor" + " that takes in a Reader as its " + "single argument." ) ; } final Reader [ ] rdr = { instream } ; instream = ( Reader ) constructors [ j ] . newInstance ( rdr ) ; setProjectOnObject ( instream ) ; if ( Parameterizable . class . isAssignableFrom ( clazz ) ) { final Parameter [ ] params = filter . getParams ( ) ; ( ( Parameterizable ) instream ) . setParameters ( params ) ; } } } catch ( final ClassNotFoundException cnfe ) { throw new BuildException ( cnfe ) ; } catch ( final InstantiationException ie ) { throw new BuildException ( ie ) ; } catch ( final IllegalAccessException iae ) { throw new BuildException ( iae ) ; } catch ( final InvocationTargetException ite ) { throw new BuildException ( ite ) ; } } } else if ( o instanceof ChainableReader ) { setProjectOnObject ( o ) ; instream = ( ( ChainableReader ) o ) . chain ( instream ) ; setProjectOnObject ( instream ) ; } } } return instream ; } private void setProjectOnObject ( Object obj ) { if ( project == null ) { return ; } if ( obj instanceof BaseFilterReader ) { ( ( BaseFilterReader ) obj ) . setProject ( project ) ; return ; } project . setProjectReference ( obj ) ; } public final String readFully ( Reader rdr ) throws IOException { return FileUtils . readFully ( rdr , bufferSize ) ; } } 	0	['10', '1', '0', '15', '39', '19', '4', '12', '8', '0.888888889', '344', '0.25', '1', '0', '0.228571429', '0', '0', '32.6', '3', '1.1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; import java . io . File ; import java . io . PrintStream ; import java . io . BufferedOutputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . Reader ; import java . io . BufferedReader ; import java . io . StringReader ; import java . io . FileReader ; import java . io . InputStreamReader ; import java . io . FileInputStream ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . util . Vector ; import java . sql . Connection ; import java . sql . Statement ; import java . sql . SQLException ; import java . sql . SQLWarning ; import java . sql . ResultSet ; import java . sql . ResultSetMetaData ; public class SQLExec extends JDBCTask { public static class DelimiterType extends EnumeratedAttribute { public static final String NORMAL = "normal" ; public static final String ROW = "row" ; public String [ ] getValues ( ) { return new String [ ] { NORMAL , ROW } ; } } private int goodSql = 0 ; private int totalSql = 0 ; private Connection conn = null ; private Vector filesets = new Vector ( ) ; private Statement statement = null ; private File srcFile = null ; private String sqlCommand = "" ; private Vector transactions = new Vector ( ) ; private String delimiter = ";" ; private String delimiterType = DelimiterType . NORMAL ; private boolean print = false ; private boolean showheaders = true ; private File output = null ; private String onError = "abort" ; private String encoding = null ; private boolean append = false ; private boolean keepformat = false ; private boolean escapeProcessing = true ; public void setSrc ( File srcFile ) { this . srcFile = srcFile ; } public void addText ( String sql ) { this . sqlCommand += sql ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public Transaction createTransaction ( ) { Transaction t = new Transaction ( ) ; transactions . addElement ( t ) ; return t ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public void setDelimiter ( String delimiter ) { this . delimiter = delimiter ; } public void setDelimiterType ( DelimiterType delimiterType ) { this . delimiterType = delimiterType . getValue ( ) ; } public void setPrint ( boolean print ) { this . print = print ; } public void setShowheaders ( boolean showheaders ) { this . showheaders = showheaders ; } public void setOutput ( File output ) { this . output = output ; } public void setAppend ( boolean append ) { this . append = append ; } public void setOnerror ( OnError action ) { this . onError = action . getValue ( ) ; } public void setKeepformat ( boolean keepformat ) { this . keepformat = keepformat ; } public void setEscapeProcessing ( boolean enable ) { escapeProcessing = enable ; } public void execute ( ) throws BuildException { Vector savedTransaction = ( Vector ) transactions . clone ( ) ; String savedSqlCommand = sqlCommand ; sqlCommand = sqlCommand . trim ( ) ; try { if ( srcFile == null && sqlCommand . length ( ) == 0 && filesets . isEmpty ( ) ) { if ( transactions . size ( ) == 0 ) { throw new BuildException ( "Source file or fileset, " + "transactions or sql statement " + "must be set!" , getLocation ( ) ) ; } } if ( srcFile != null && ! srcFile . exists ( ) ) { throw new BuildException ( "Source file does not exist!" , getLocation ( ) ) ; } for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; File srcDir = fs . getDir ( getProject ( ) ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; for ( int j = 0 ; j < srcFiles . length ; j ++ ) { Transaction t = createTransaction ( ) ; t . setSrc ( new File ( srcDir , srcFiles [ j ] ) ) ; } } Transaction t = createTransaction ( ) ; t . setSrc ( srcFile ) ; t . addText ( sqlCommand ) ; conn = getConnection ( ) ; if ( ! isValidRdbms ( conn ) ) { return ; } try { statement = conn . createStatement ( ) ; statement . setEscapeProcessing ( escapeProcessing ) ; PrintStream out = System . out ; try { if ( output != null ) { log ( "Opening PrintStream to output file " + output , Project . MSG_VERBOSE ) ; out = new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( output . getAbsolutePath ( ) , append ) ) ) ; } for ( Enumeration e = transactions . elements ( ) ; e . hasMoreElements ( ) ; ) { ( ( Transaction ) e . nextElement ( ) ) . runTransaction ( out ) ; if ( ! isAutocommit ( ) ) { log ( "Committing transaction" , Project . MSG_VERBOSE ) ; conn . commit ( ) ; } } } finally { if ( out != null && out != System . out ) { out . close ( ) ; } } } catch ( IOException e ) { if ( ! isAutocommit ( ) && conn != null && onError . equals ( "abort" ) ) { try { conn . rollback ( ) ; } catch ( SQLException ex ) { } } throw new BuildException ( e , getLocation ( ) ) ; } catch ( SQLException e ) { if ( ! isAutocommit ( ) && conn != null && onError . equals ( "abort" ) ) { try { conn . rollback ( ) ; } catch ( SQLException ex ) { } } throw new BuildException ( e , getLocation ( ) ) ; } finally { try { if ( statement != null ) { statement . close ( ) ; } if ( conn != null ) { conn . close ( ) ; } } catch ( SQLException ex ) { } } log ( goodSql + " of " + totalSql + " SQL statements executed successfully" ) ; } finally { transactions = savedTransaction ; sqlCommand = savedSqlCommand ; } } protected void runStatements ( Reader reader , PrintStream out ) throws SQLException , IOException { StringBuffer sql = new StringBuffer ( ) ; String line = "" ; BufferedReader in = new BufferedReader ( reader ) ; while ( ( line = in . readLine ( ) ) != null ) { if ( ! keepformat ) { line = line . trim ( ) ; } line = getProject ( ) . replaceProperties ( line ) ; if ( ! keepformat ) { if ( line . startsWith ( "//" ) ) { continue ; } if ( line . startsWith ( "--" ) ) { continue ; } StringTokenizer st = new StringTokenizer ( line ) ; if ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) ; if ( "REM" . equalsIgnoreCase ( token ) ) { continue ; } } } if ( ! keepformat ) { sql . append ( " " + line ) ; } else { sql . append ( "\n" + line ) ; } if ( ! keepformat ) { if ( line . indexOf ( "--" ) >= 0 ) { sql . append ( "\n" ) ; } } if ( ( delimiterType . equals ( DelimiterType . NORMAL ) && sql . toString ( ) . endsWith ( delimiter ) ) || ( delimiterType . equals ( DelimiterType . ROW ) && line . equals ( delimiter ) ) ) { execSQL ( sql . substring ( 0 , sql . length ( ) - delimiter . length ( ) ) , out ) ; sql . replace ( 0 , sql . length ( ) , "" ) ; } } if ( ! sql . equals ( "" ) ) { execSQL ( sql . toString ( ) , out ) ; } } protected void execSQL ( String sql , PrintStream out ) throws SQLException { if ( "" . equals ( sql . trim ( ) ) ) { return ; } try { totalSql ++ ; log ( "SQL: " + sql , Project . MSG_VERBOSE ) ; boolean ret ; int updateCount = 0 , updateCountTotal = 0 ; ResultSet resultSet = null ; ret = statement . execute ( sql ) ; updateCount = statement . getUpdateCount ( ) ; resultSet = statement . getResultSet ( ) ; do { if ( ! ret ) { if ( updateCount != - 1 ) { updateCountTotal += updateCount ; } } else { if ( print ) { printResults ( out ) ; } } ret = statement . getMoreResults ( ) ; updateCount = statement . getUpdateCount ( ) ; resultSet = statement . getResultSet ( ) ; } while ( ret ) ; log ( updateCountTotal + " rows affected" , Project . MSG_VERBOSE ) ; if ( print ) { StringBuffer line = new StringBuffer ( ) ; line . append ( updateCountTotal + " rows affected" ) ; out . println ( line ) ; } SQLWarning warning = conn . getWarnings ( ) ; while ( warning != null ) { log ( warning + " sql warning" , Project . MSG_VERBOSE ) ; warning = warning . getNextWarning ( ) ; } conn . clearWarnings ( ) ; goodSql ++ ; } catch ( SQLException e ) { log ( "Failed to execute: " + sql , Project . MSG_ERR ) ; if ( ! onError . equals ( "continue" ) ) { throw e ; } log ( e . toString ( ) , Project . MSG_ERR ) ; } } protected void printResults ( PrintStream out ) throws java . sql . SQLException { ResultSet rs = null ; rs = statement . getResultSet ( ) ; if ( rs != null ) { log ( "Processing new result set." , Project . MSG_VERBOSE ) ; ResultSetMetaData md = rs . getMetaData ( ) ; int columnCount = md . getColumnCount ( ) ; StringBuffer line = new StringBuffer ( ) ; if ( showheaders ) { for ( int col = 1 ; col < columnCount ; col ++ ) { line . append ( md . getColumnName ( col ) ) ; line . append ( "," ) ; } line . append ( md . getColumnName ( columnCount ) ) ; out . println ( line ) ; line = new StringBuffer ( ) ; } while ( rs . next ( ) ) { boolean first = true ; for ( int col = 1 ; col <= columnCount ; col ++ ) { String columnValue = rs . getString ( col ) ; if ( columnValue != null ) { columnValue = columnValue . trim ( ) ; } if ( first ) { first = false ; } else { line . append ( "," ) ; } line . append ( columnValue ) ; } out . println ( line ) ; line = new StringBuffer ( ) ; } } out . println ( ) ; } public static class OnError extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "continue" , "stop" , "abort" } ; } } public class Transaction { private File tSrcFile = null ; private String tSqlCommand = "" ; public void setSrc ( File src ) { this . tSrcFile = src ; } public void addText ( String sql ) { this . tSqlCommand += sql ; } private void runTransaction ( PrintStream out ) throws IOException , SQLException { if ( tSqlCommand . length ( ) != 0 ) { log ( "Executing commands" , Project . MSG_INFO ) ; runStatements ( new StringReader ( tSqlCommand ) , out ) ; } if ( tSrcFile != null ) { log ( "Executing file: " + tSrcFile . getAbsolutePath ( ) , Project . MSG_INFO ) ; Reader reader = ( encoding == null ) ? new FileReader ( tSrcFile ) : new InputStreamReader ( new FileInputStream ( tSrcFile ) , encoding ) ; try { runStatements ( reader , out ) ; } finally { reader . close ( ) ; } } } } } 	1	['20', '4', '0', '13', '97', '116', '1', '13', '16', '0.868421053', '895', '1', '0', '0.7625', '0.19', '4', '4', '42.85', '1', '0.95', '2']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStream ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class JikesOutputParser implements ExecuteStreamHandler { protected Task task ; protected boolean errorFlag = false ; protected int errors ; protected int warnings ; protected boolean error = false ; protected boolean emacsMode ; protected BufferedReader br ; public void setProcessInputStream ( OutputStream os ) { } public void setProcessErrorStream ( InputStream is ) { } public void setProcessOutputStream ( InputStream is ) throws IOException { br = new BufferedReader ( new InputStreamReader ( is ) ) ; } public void start ( ) throws IOException { parseOutput ( br ) ; } public void stop ( ) { } protected JikesOutputParser ( Task task , boolean emacsMode ) { super ( ) ; System . err . println ( "As of Ant 1.2 released in October 2000, the " + "JikesOutputParser class" ) ; System . err . println ( "is considered to be dead code by the Ant " + "developers and is unmaintained." ) ; System . err . println ( "Don\'t use it!" ) ; this . task = task ; this . emacsMode = emacsMode ; } protected void parseOutput ( BufferedReader reader ) throws IOException { if ( emacsMode ) { parseEmacsOutput ( reader ) ; } else { parseStandardOutput ( reader ) ; } } private void parseStandardOutput ( BufferedReader reader ) throws IOException { String line ; String lower ; while ( ( line = reader . readLine ( ) ) != null ) { lower = line . toLowerCase ( ) ; if ( line . trim ( ) . equals ( "" ) ) { continue ; } if ( lower . indexOf ( "error" ) != - 1 ) { setError ( true ) ; } else if ( lower . indexOf ( "warning" ) != - 1 ) { setError ( false ) ; } else { if ( emacsMode ) { setError ( true ) ; } } log ( line ) ; } } private void parseEmacsOutput ( BufferedReader reader ) throws IOException { parseStandardOutput ( reader ) ; } private void setError ( boolean err ) { error = err ; if ( error ) { errorFlag = true ; } } private void log ( String line ) { if ( ! emacsMode ) { task . log ( "" , ( error ? Project . MSG_ERR : Project . MSG_WARN ) ) ; } task . log ( line , ( error ? Project . MSG_ERR : Project . MSG_WARN ) ) ; } protected boolean getErrorFlag ( ) { return errorFlag ; } } 	0	['12', '1', '0', '3', '22', '44', '1', '2', '5', '0.805194805', '156', '1', '1', '0', '0.261904762', '0', '0', '11.41666667', '4', '1.25', '0']
package org . apache . tools . ant . types ; import java . io . File ; import java . util . StringTokenizer ; import java . util . Vector ; import java . util . ArrayList ; import java . util . List ; import java . util . ListIterator ; import java . util . LinkedList ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . util . StringUtils ; public class Commandline implements Cloneable { private Vector arguments = new Vector ( ) ; private String executable = null ; protected static final String DISCLAIMER = StringUtils . LINE_SEP + "The \' characters around the executable and arguments are" + StringUtils . LINE_SEP + "not part of the command." + StringUtils . LINE_SEP ; public Commandline ( String toProcess ) { super ( ) ; String [ ] tmp = translateCommandline ( toProcess ) ; if ( tmp != null && tmp . length > 0 ) { setExecutable ( tmp [ 0 ] ) ; for ( int i = 1 ; i < tmp . length ; i ++ ) { createArgument ( ) . setValue ( tmp [ i ] ) ; } } } public Commandline ( ) { super ( ) ; } public static class Argument extends ProjectComponent { private String [ ] parts ; public void setValue ( String value ) { parts = new String [ ] { value } ; } public void setLine ( String line ) { if ( line == null ) { return ; } parts = translateCommandline ( line ) ; } public void setPath ( Path value ) { parts = new String [ ] { value . toString ( ) } ; } public void setPathref ( Reference value ) { Path p = new Path ( getProject ( ) ) ; p . setRefid ( value ) ; parts = new String [ ] { p . toString ( ) } ; } public void setFile ( File value ) { parts = new String [ ] { value . getAbsolutePath ( ) } ; } public String [ ] getParts ( ) { return parts ; } } public class Marker { private int position ; private int realPos = - 1 ; Marker ( int position ) { this . position = position ; } public int getPosition ( ) { if ( realPos == - 1 ) { realPos = ( executable == null ? 0 : 1 ) ; for ( int i = 0 ; i < position ; i ++ ) { Argument arg = ( Argument ) arguments . elementAt ( i ) ; realPos += arg . getParts ( ) . length ; } } return realPos ; } } public Argument createArgument ( ) { return this . createArgument ( false ) ; } public Argument createArgument ( boolean insertAtStart ) { Argument argument = new Argument ( ) ; if ( insertAtStart ) { arguments . insertElementAt ( argument , 0 ) ; } else { arguments . addElement ( argument ) ; } return argument ; } public void setExecutable ( String executable ) { if ( executable == null || executable . length ( ) == 0 ) { return ; } this . executable = executable . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; } public String getExecutable ( ) { return executable ; } public void addArguments ( String [ ] line ) { for ( int i = 0 ; i < line . length ; i ++ ) { createArgument ( ) . setValue ( line [ i ] ) ; } } public String [ ] getCommandline ( ) { List commands = new LinkedList ( ) ; ListIterator list = commands . listIterator ( ) ; addCommandToList ( list ) ; final String [ ] result = new String [ commands . size ( ) ] ; return ( String [ ] ) commands . toArray ( result ) ; } public void addCommandToList ( ListIterator list ) { if ( executable != null ) { list . add ( executable ) ; } addArgumentsToList ( list ) ; } public String [ ] getArguments ( ) { List result = new ArrayList ( arguments . size ( ) * 2 ) ; addArgumentsToList ( result . listIterator ( ) ) ; String [ ] res = new String [ result . size ( ) ] ; return ( String [ ] ) result . toArray ( res ) ; } public void addArgumentsToList ( ListIterator list ) { for ( int i = 0 ; i < arguments . size ( ) ; i ++ ) { Argument arg = ( Argument ) arguments . elementAt ( i ) ; String [ ] s = arg . getParts ( ) ; if ( s != null ) { for ( int j = 0 ; j < s . length ; j ++ ) { list . add ( s [ j ] ) ; } } } } public String toString ( ) { return toString ( getCommandline ( ) ) ; } public static String quoteArgument ( String argument ) { if ( argument . indexOf ( "\"" ) > - 1 ) { if ( argument . indexOf ( "\'" ) > - 1 ) { throw new BuildException ( "Can\'t handle single and double" + " quotes in same argument" ) ; } else { return '\'' + argument + '\'' ; } } else if ( argument . indexOf ( "\'" ) > - 1 || argument . indexOf ( " " ) > - 1 ) { return '\"' + argument + '\"' ; } else { return argument ; } } public static String toString ( String [ ] line ) { if ( line == null || line . length == 0 ) { return "" ; } final StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < line . length ; i ++ ) { if ( i > 0 ) { result . append ( ' ' ) ; } result . append ( quoteArgument ( line [ i ] ) ) ; } return result . toString ( ) ; } public static String [ ] translateCommandline ( String toProcess ) { if ( toProcess == null || toProcess . length ( ) == 0 ) { return new String [ 0 ] ; } final int normal = 0 ; final int inQuote = 1 ; final int inDoubleQuote = 2 ; int state = normal ; StringTokenizer tok = new StringTokenizer ( toProcess , "\"\' " , true ) ; Vector v = new Vector ( ) ; StringBuffer current = new StringBuffer ( ) ; boolean lastTokenHasBeenQuoted = false ; while ( tok . hasMoreTokens ( ) ) { String nextTok = tok . nextToken ( ) ; switch ( state ) { case inQuote : if ( "\'" . equals ( nextTok ) ) { lastTokenHasBeenQuoted = true ; state = normal ; } else { current . append ( nextTok ) ; } break ; case inDoubleQuote : if ( "\"" . equals ( nextTok ) ) { lastTokenHasBeenQuoted = true ; state = normal ; } else { current . append ( nextTok ) ; } break ; default : if ( "\'" . equals ( nextTok ) ) { state = inQuote ; } else if ( "\"" . equals ( nextTok ) ) { state = inDoubleQuote ; } else if ( " " . equals ( nextTok ) ) { if ( lastTokenHasBeenQuoted || current . length ( ) != 0 ) { v . addElement ( current . toString ( ) ) ; current = new StringBuffer ( ) ; } } else { current . append ( nextTok ) ; } lastTokenHasBeenQuoted = false ; break ; } } if ( lastTokenHasBeenQuoted || current . length ( ) != 0 ) { v . addElement ( current . toString ( ) ) ; } if ( state == inQuote || state == inDoubleQuote ) { throw new BuildException ( "unbalanced quotes in " + toProcess ) ; } String [ ] args = new String [ v . size ( ) ] ; v . copyInto ( args ) ; return args ; } public int size ( ) { return getCommandline ( ) . length ; } public Object clone ( ) { try { Commandline c = ( Commandline ) super . clone ( ) ; c . arguments = ( Vector ) arguments . clone ( ) ; return c ; } catch ( CloneNotSupportedException e ) { throw new BuildException ( e ) ; } } public void clear ( ) { executable = null ; arguments . removeAllElements ( ) ; } public void clearArgs ( ) { arguments . removeAllElements ( ) ; } public Marker createMarker ( ) { return new Marker ( arguments . size ( ) ) ; } public String describeCommand ( ) { return describeCommand ( this ) ; } public String describeArguments ( ) { return describeArguments ( this ) ; } public static String describeCommand ( Commandline line ) { return describeCommand ( line . getCommandline ( ) ) ; } public static String describeArguments ( Commandline line ) { return describeArguments ( line . getArguments ( ) ) ; } public static String describeCommand ( String [ ] args ) { if ( args == null || args . length == 0 ) { return "" ; } StringBuffer buf = new StringBuffer ( "Executing \'" ) ; buf . append ( args [ 0 ] ) ; buf . append ( "\'" ) ; if ( args . length > 0 ) { buf . append ( " with " ) ; buf . append ( describeArguments ( args , 1 ) ) ; } else { buf . append ( DISCLAIMER ) ; } return buf . toString ( ) ; } public static String describeArguments ( String [ ] args ) { return describeArguments ( args , 0 ) ; } protected static String describeArguments ( String [ ] args , int offset ) { if ( args == null || args . length <= offset ) { return "" ; } StringBuffer buf = new StringBuffer ( "argument" ) ; if ( args . length > offset ) { buf . append ( "s" ) ; } buf . append ( ":" ) . append ( StringUtils . LINE_SEP ) ; for ( int i = offset ; i < args . length ; i ++ ) { buf . append ( "\'" ) . append ( args [ i ] ) . append ( "\'" ) . append ( StringUtils . LINE_SEP ) ; } buf . append ( DISCLAIMER ) ; return buf . toString ( ) ; } } 	1	['30', '1', '0', '31', '65', '303', '29', '4', '26', '0.689655172', '634', '1', '0', '0', '0.177339901', '0', '0', '20.03333333', '18', '2.2333', '1']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Vector ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . util . JavaEnvUtils ; public class SignJar extends Task { protected File jar ; protected String alias ; private String keystore ; protected String storepass ; protected String storetype ; protected String keypass ; protected String sigfile ; protected File signedjar ; protected boolean verbose ; protected boolean internalsf ; protected boolean sectionsonly ; private String maxMemory ; protected Vector filesets = new Vector ( ) ; protected boolean lazy ; public void setMaxmemory ( String max ) { maxMemory = max ; } public void setJar ( final File jar ) { this . jar = jar ; } public void setAlias ( final String alias ) { this . alias = alias ; } public void setKeystore ( final String keystore ) { this . keystore = keystore ; } public void setStorepass ( final String storepass ) { this . storepass = storepass ; } public void setStoretype ( final String storetype ) { this . storetype = storetype ; } public void setKeypass ( final String keypass ) { this . keypass = keypass ; } public void setSigfile ( final String sigfile ) { this . sigfile = sigfile ; } public void setSignedjar ( final File signedjar ) { this . signedjar = signedjar ; } public void setVerbose ( final boolean verbose ) { this . verbose = verbose ; } public void setInternalsf ( final boolean internalsf ) { this . internalsf = internalsf ; } public void setSectionsonly ( final boolean sectionsonly ) { this . sectionsonly = sectionsonly ; } public void setLazy ( final boolean lazy ) { this . lazy = lazy ; } public void addFileset ( final FileSet set ) { filesets . addElement ( set ) ; } public void execute ( ) throws BuildException { if ( null == jar && filesets . size ( ) == 0 ) { throw new BuildException ( "jar must be set through jar attribute " + "or nested filesets" ) ; } if ( null != jar ) { if ( filesets . size ( ) != 0 ) { log ( "nested filesets will be ignored if the jar attribute has" + " been specified." , Project . MSG_WARN ) ; } doOneJar ( jar , signedjar ) ; return ; } else { for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] jarFiles = ds . getIncludedFiles ( ) ; for ( int j = 0 ; j < jarFiles . length ; j ++ ) { doOneJar ( new File ( fs . getDir ( getProject ( ) ) , jarFiles [ j ] ) , null ) ; } } } } private void doOneJar ( File jarSource , File jarTarget ) throws BuildException { if ( null == alias ) { throw new BuildException ( "alias attribute must be set" ) ; } if ( null == storepass ) { throw new BuildException ( "storepass attribute must be set" ) ; } if ( isUpToDate ( jarSource , jarTarget ) ) { return ; } final ExecTask cmd = ( ExecTask ) getProject ( ) . createTask ( "exec" ) ; cmd . setExecutable ( JavaEnvUtils . getJdkExecutable ( "jarsigner" ) ) ; if ( maxMemory != null ) { cmd . createArg ( ) . setValue ( "-J-Xmx" + maxMemory ) ; } if ( null != keystore ) { File keystoreFile = getProject ( ) . resolveFile ( keystore ) ; if ( keystoreFile . exists ( ) ) { cmd . createArg ( ) . setValue ( "-keystore" ) ; cmd . createArg ( ) . setValue ( keystoreFile . getPath ( ) ) ; } else { cmd . createArg ( ) . setValue ( "-keystore" ) ; cmd . createArg ( ) . setValue ( keystore ) ; } } if ( null != storepass ) { cmd . createArg ( ) . setValue ( "-storepass" ) ; cmd . createArg ( ) . setValue ( storepass ) ; } if ( null != storetype ) { cmd . createArg ( ) . setValue ( "-storetype" ) ; cmd . createArg ( ) . setValue ( storetype ) ; } if ( null != keypass ) { cmd . createArg ( ) . setValue ( "-keypass" ) ; cmd . createArg ( ) . setValue ( keypass ) ; } if ( null != sigfile ) { cmd . createArg ( ) . setValue ( "-sigfile" ) ; cmd . createArg ( ) . setValue ( sigfile ) ; } if ( null != jarTarget ) { cmd . createArg ( ) . setValue ( "-signedjar" ) ; cmd . createArg ( ) . setValue ( jarTarget . toString ( ) ) ; } if ( verbose ) { cmd . createArg ( ) . setValue ( "-verbose" ) ; } if ( internalsf ) { cmd . createArg ( ) . setValue ( "-internalsf" ) ; } if ( sectionsonly ) { cmd . createArg ( ) . setValue ( "-sectionsonly" ) ; } cmd . createArg ( ) . setValue ( jarSource . toString ( ) ) ; cmd . createArg ( ) . setValue ( alias ) ; log ( "Signing Jar : " + jarSource . getAbsolutePath ( ) ) ; cmd . setFailonerror ( true ) ; cmd . setTaskName ( getTaskName ( ) ) ; cmd . execute ( ) ; } protected boolean isUpToDate ( File jarFile , File signedjarFile ) { if ( null == jarFile ) { return false ; } if ( null != signedjarFile ) { if ( ! jarFile . exists ( ) ) { return false ; } if ( ! signedjarFile . exists ( ) ) { return false ; } if ( jarFile . equals ( signedjarFile ) ) { return false ; } if ( signedjarFile . lastModified ( ) > jarFile . lastModified ( ) ) { return true ; } } else { if ( lazy ) { return isSigned ( jarFile ) ; } } return false ; } protected boolean isSigned ( File file ) { final String SIG_START = "META-INF/" ; final String SIG_END = ".SF" ; if ( ! file . exists ( ) ) { return false ; } ZipFile jarFile = null ; try { jarFile = new ZipFile ( file ) ; if ( null == alias ) { Enumeration entries = jarFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { String name = ( ( ZipEntry ) entries . nextElement ( ) ) . getName ( ) ; if ( name . startsWith ( SIG_START ) && name . endsWith ( SIG_END ) ) { return true ; } } return false ; } else { return jarFile . getEntry ( SIG_START + alias . toUpperCase ( ) + SIG_END ) != null ; } } catch ( IOException e ) { return false ; } finally { if ( jarFile != null ) { try { jarFile . close ( ) ; } catch ( IOException e ) { } } } } } 	0	['19', '3', '0', '10', '61', '135', '0', '10', '16', '0.888888889', '504', '1', '0', '0.672727273', '0.378947368', '1', '1', '24.78947368', '13', '1.9474', '0']
package org . apache . tools . ant . helper ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; import java . net . URL ; import java . util . Hashtable ; import java . util . Stack ; import org . xml . sax . Locator ; import org . xml . sax . InputSource ; import org . xml . sax . SAXParseException ; import org . xml . sax . SAXException ; import org . xml . sax . Attributes ; import org . xml . sax . helpers . DefaultHandler ; import org . apache . tools . ant . util . JAXPUtils ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Target ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . RuntimeConfigurable ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Location ; import org . apache . tools . ant . UnknownElement ; import org . xml . sax . XMLReader ; public class ProjectHelper2 extends ProjectHelper { private static AntHandler elementHandler = new ElementHandler ( ) ; private static AntHandler targetHandler = new TargetHandler ( ) ; private static AntHandler mainHandler = new MainHandler ( ) ; private static AntHandler projectHandler = new ProjectHandler ( ) ; private static FileUtils fu = FileUtils . newFileUtils ( ) ; public UnknownElement parseUnknownElement ( Project project , URL source ) throws BuildException { Target dummyTarget = new Target ( ) ; dummyTarget . setProject ( project ) ; AntXMLContext context = new AntXMLContext ( project ) ; context . addTarget ( dummyTarget ) ; context . setImplicitTarget ( dummyTarget ) ; parse ( context . getProject ( ) , source , new RootHandler ( context , elementHandler ) ) ; Task [ ] tasks = dummyTarget . getTasks ( ) ; if ( tasks . length != 1 ) { throw new BuildException ( "No tasks defined" ) ; } return ( UnknownElement ) tasks [ 0 ] ; } public void parse ( Project project , Object source ) throws BuildException { getImportStack ( ) . addElement ( source ) ; AntXMLContext context = null ; context = ( AntXMLContext ) project . getReference ( "ant.parsing.context" ) ; if ( context == null ) { context = new AntXMLContext ( project ) ; project . addReference ( "ant.parsing.context" , context ) ; project . addReference ( "ant.targets" , context . getTargets ( ) ) ; } if ( getImportStack ( ) . size ( ) > 1 ) { context . setIgnoreProjectTag ( true ) ; Target currentTarget = context . getCurrentTarget ( ) ; try { Target newCurrent = new Target ( ) ; newCurrent . setProject ( project ) ; newCurrent . setName ( "" ) ; context . setCurrentTarget ( newCurrent ) ; parse ( project , source , new RootHandler ( context , mainHandler ) ) ; newCurrent . execute ( ) ; } finally { context . setCurrentTarget ( currentTarget ) ; } } else { parse ( project , source , new RootHandler ( context , mainHandler ) ) ; context . getImplicitTarget ( ) . execute ( ) ; } } public void parse ( Project project , Object source , RootHandler handler ) throws BuildException { AntXMLContext context = handler . context ; File buildFile = null ; URL url = null ; String buildFileName = null ; if ( source instanceof File ) { buildFile = ( File ) source ; buildFile = new File ( buildFile . getAbsolutePath ( ) ) ; context . setBuildFile ( buildFile ) ; buildFileName = buildFile . toString ( ) ; } else if ( source instanceof URL ) { if ( handler . getCurrentAntHandler ( ) != elementHandler ) { throw new BuildException ( "Source " + source . getClass ( ) . getName ( ) + " not supported by this plugin for " + " non task xml" ) ; } url = ( URL ) source ; buildFileName = url . toString ( ) ; } else { throw new BuildException ( "Source " + source . getClass ( ) . getName ( ) + " not supported by this plugin" ) ; } InputStream inputStream = null ; InputSource inputSource = null ; try { XMLReader parser = JAXPUtils . getNamespaceXMLReader ( ) ; String uri = null ; if ( buildFile != null ) { uri = fu . toURI ( buildFile . getAbsolutePath ( ) ) ; inputStream = new FileInputStream ( buildFile ) ; } else { inputStream = url . openStream ( ) ; uri = url . toString ( ) ; } inputSource = new InputSource ( inputStream ) ; if ( uri != null ) { inputSource . setSystemId ( uri ) ; } project . log ( "parsing buildfile " + buildFileName + " with URI = " + uri , Project . MSG_VERBOSE ) ; DefaultHandler hb = handler ; parser . setContentHandler ( hb ) ; parser . setEntityResolver ( hb ) ; parser . setErrorHandler ( hb ) ; parser . setDTDHandler ( hb ) ; parser . parse ( inputSource ) ; } catch ( SAXParseException exc ) { Location location = new Location ( exc . getSystemId ( ) , exc . getLineNumber ( ) , exc . getColumnNumber ( ) ) ; Throwable t = exc . getException ( ) ; if ( t instanceof BuildException ) { BuildException be = ( BuildException ) t ; if ( be . getLocation ( ) == Location . UNKNOWN_LOCATION ) { be . setLocation ( location ) ; } throw be ; } throw new BuildException ( exc . getMessage ( ) , t , location ) ; } catch ( SAXException exc ) { Throwable t = exc . getException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( exc . getMessage ( ) , t ) ; } catch ( FileNotFoundException exc ) { throw new BuildException ( exc ) ; } catch ( UnsupportedEncodingException exc ) { throw new BuildException ( "Encoding of project file " + buildFileName + " is invalid." , exc ) ; } catch ( IOException exc ) { throw new BuildException ( "Error reading project file " + buildFileName + ": " + exc . getMessage ( ) , exc ) ; } finally { if ( inputStream != null ) { try { inputStream . close ( ) ; } catch ( IOException ioe ) { } } } } public static class AntHandler { public void onStartElement ( String uri , String tag , String qname , Attributes attrs , AntXMLContext context ) throws SAXParseException { } public AntHandler onStartChild ( String uri , String tag , String qname , Attributes attrs , AntXMLContext context ) throws SAXParseException { throw new SAXParseException ( "Unexpected element \"" + qname + " \"" , context . getLocator ( ) ) ; } public void onEndChild ( String uri , String tag , String qname , AntXMLContext context ) throws SAXParseException { } public void onEndElement ( String uri , String tag , AntXMLContext context ) { } public void characters ( char [ ] buf , int start , int count , AntXMLContext context ) throws SAXParseException { String s = new String ( buf , start , count ) . trim ( ) ; if ( s . length ( ) > 0 ) { throw new SAXParseException ( "Unexpected text \"" + s + "\"" , context . getLocator ( ) ) ; } } protected void checkNamespace ( String uri ) { } } public static class RootHandler extends DefaultHandler { private Stack antHandlers = new Stack ( ) ; private AntHandler currentHandler = null ; private AntXMLContext context ; public RootHandler ( AntXMLContext context , AntHandler rootHandler ) { currentHandler = rootHandler ; antHandlers . push ( currentHandler ) ; this . context = context ; } public AntHandler getCurrentAntHandler ( ) { return currentHandler ; } public InputSource resolveEntity ( String publicId , String systemId ) { context . getProject ( ) . log ( "resolving systemId: " + systemId , Project . MSG_VERBOSE ) ; if ( systemId . startsWith ( "file:" ) ) { String path = fu . fromURI ( systemId ) ; File file = new File ( path ) ; if ( ! file . isAbsolute ( ) ) { file = fu . resolveFile ( context . getBuildFileParent ( ) , path ) ; } try { InputSource inputSource = new InputSource ( new FileInputStream ( file ) ) ; inputSource . setSystemId ( fu . toURI ( file . getAbsolutePath ( ) ) ) ; return inputSource ; } catch ( FileNotFoundException fne ) { context . getProject ( ) . log ( file . getAbsolutePath ( ) + " could not be found" , Project . MSG_WARN ) ; } } return null ; } public void startElement ( String uri , String tag , String qname , Attributes attrs ) throws SAXParseException { AntHandler next = currentHandler . onStartChild ( uri , tag , qname , attrs , context ) ; antHandlers . push ( currentHandler ) ; currentHandler = next ; currentHandler . onStartElement ( uri , tag , qname , attrs , context ) ; } public void setDocumentLocator ( Locator locator ) { context . setLocator ( locator ) ; } public void endElement ( String uri , String name , String qName ) throws SAXException { currentHandler . onEndElement ( uri , name , context ) ; AntHandler prev = ( AntHandler ) antHandlers . pop ( ) ; currentHandler = prev ; if ( currentHandler != null ) { currentHandler . onEndChild ( uri , name , qName , context ) ; } } public void characters ( char [ ] buf , int start , int count ) throws SAXParseException { currentHandler . characters ( buf , start , count , context ) ; } public void startPrefixMapping ( String prefix , String uri ) { context . startPrefixMapping ( prefix , uri ) ; } public void endPrefixMapping ( String prefix ) { context . endPrefixMapping ( prefix ) ; } } public static class MainHandler extends AntHandler { public AntHandler onStartChild ( String uri , String name , String qname , Attributes attrs , AntXMLContext context ) throws SAXParseException { if ( name . equals ( "project" ) && ( uri . equals ( "" ) || uri . equals ( ANT_CORE_URI ) ) ) { return ProjectHelper2 . projectHandler ; } else { throw new SAXParseException ( "Unexpected element \"" + qname + "\" " + name , context . getLocator ( ) ) ; } } } public static class ProjectHandler extends AntHandler { public void onStartElement ( String uri , String tag , String qname , Attributes attrs , AntXMLContext context ) throws SAXParseException { String id = null ; String baseDir = null ; boolean nameAttributeSet = false ; Project project = context . getProject ( ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String attrUri = attrs . getURI ( i ) ; if ( attrUri != null && ! attrUri . equals ( "" ) && ! attrUri . equals ( uri ) ) { continue ; } String key = attrs . getLocalName ( i ) ; String value = attrs . getValue ( i ) ; if ( key . equals ( "default" ) ) { if ( value != null && ! value . equals ( "" ) ) { if ( ! context . isIgnoringProjectTag ( ) ) { project . setDefault ( value ) ; } } } else if ( key . equals ( "name" ) ) { if ( value != null ) { context . setCurrentProjectName ( value ) ; nameAttributeSet = true ; if ( ! context . isIgnoringProjectTag ( ) ) { project . setName ( value ) ; project . addReference ( value , project ) ; } } } else if ( key . equals ( "id" ) ) { if ( value != null ) { if ( ! context . isIgnoringProjectTag ( ) ) { project . addReference ( value , project ) ; } } } else if ( key . equals ( "basedir" ) ) { if ( ! context . isIgnoringProjectTag ( ) ) { baseDir = value ; } } else { throw new SAXParseException ( "Unexpected attribute \"" + attrs . getQName ( i ) + "\"" , context . getLocator ( ) ) ; } } String antFileProp = "ant.file." + context . getCurrentProjectName ( ) ; String dup = project . getProperty ( antFileProp ) ; if ( dup != null && nameAttributeSet ) { File dupFile = new File ( dup ) ; if ( context . isIgnoringProjectTag ( ) && ! dupFile . equals ( context . getBuildFile ( ) ) ) { project . log ( "Duplicated project name in import. Project " + context . getCurrentProjectName ( ) + " defined first in " + dup + " and again in " + context . getBuildFile ( ) , Project . MSG_WARN ) ; } } if ( context . getBuildFile ( ) != null ) { project . setUserProperty ( "ant.file." + context . getCurrentProjectName ( ) , context . getBuildFile ( ) . toString ( ) ) ; } if ( context . isIgnoringProjectTag ( ) ) { return ; } if ( project . getProperty ( "basedir" ) != null ) { project . setBasedir ( project . getProperty ( "basedir" ) ) ; } else { if ( baseDir == null ) { project . setBasedir ( context . getBuildFileParent ( ) . getAbsolutePath ( ) ) ; } else { if ( ( new File ( baseDir ) ) . isAbsolute ( ) ) { project . setBasedir ( baseDir ) ; } else { project . setBaseDir ( fu . resolveFile ( context . getBuildFileParent ( ) , baseDir ) ) ; } } } project . addTarget ( "" , context . getImplicitTarget ( ) ) ; context . setCurrentTarget ( context . getImplicitTarget ( ) ) ; } public AntHandler onStartChild ( String uri , String name , String qname , Attributes attrs , AntXMLContext context ) throws SAXParseException { if ( name . equals ( "target" ) && ( uri . equals ( "" ) || uri . equals ( ANT_CORE_URI ) ) ) { return ProjectHelper2 . targetHandler ; } else { return ProjectHelper2 . elementHandler ; } } } public static class TargetHandler extends AntHandler { public void onStartElement ( String uri , String tag , String qname , Attributes attrs , AntXMLContext context ) throws SAXParseException { String name = null ; String depends = "" ; Project project = context . getProject ( ) ; Target target = new Target ( ) ; target . setProject ( project ) ; context . addTarget ( target ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String attrUri = attrs . getURI ( i ) ; if ( attrUri != null && ! attrUri . equals ( "" ) && ! attrUri . equals ( uri ) ) { continue ; } String key = attrs . getLocalName ( i ) ; String value = attrs . getValue ( i ) ; if ( key . equals ( "name" ) ) { name = value ; if ( "" . equals ( name ) ) { throw new BuildException ( "name attribute must " + "not be empty" ) ; } } else if ( key . equals ( "depends" ) ) { depends = value ; } else if ( key . equals ( "if" ) ) { target . setIf ( value ) ; } else if ( key . equals ( "unless" ) ) { target . setUnless ( value ) ; } else if ( key . equals ( "id" ) ) { if ( value != null && ! value . equals ( "" ) ) { context . getProject ( ) . addReference ( value , target ) ; } } else if ( key . equals ( "description" ) ) { target . setDescription ( value ) ; } else { throw new SAXParseException ( "Unexpected attribute \"" + key + "\"" , context . getLocator ( ) ) ; } } if ( name == null ) { throw new SAXParseException ( "target element appears without " + "a name attribute" , context . getLocator ( ) ) ; } Hashtable currentTargets = project . getTargets ( ) ; if ( currentTargets . containsKey ( name ) ) { if ( context . getCurrentProjectName ( ) != null ) { String newName = context . getCurrentProjectName ( ) + "." + name ; project . log ( "Already defined in main or a previous import, " + "define " + name + " as " + newName , Project . MSG_VERBOSE ) ; name = newName ; } else { project . log ( "Already defined in main or a previous import, " + "ignore " + name , Project . MSG_VERBOSE ) ; name = null ; } } if ( name != null ) { target . setName ( name ) ; project . addOrReplaceTarget ( name , target ) ; } if ( depends . length ( ) > 0 ) { target . setDepends ( depends ) ; } } public AntHandler onStartChild ( String uri , String name , String qname , Attributes attrs , AntXMLContext context ) throws SAXParseException { return ProjectHelper2 . elementHandler ; } public void onEndElement ( String uri , String tag , AntXMLContext context ) { context . setCurrentTarget ( context . getImplicitTarget ( ) ) ; } } public static class ElementHandler extends AntHandler { public ElementHandler ( ) { } public void onStartElement ( String uri , String tag , String qname , Attributes attrs , AntXMLContext context ) throws SAXParseException { RuntimeConfigurable parentWrapper = context . currentWrapper ( ) ; Object parent = null ; if ( parentWrapper != null ) { parent = parentWrapper . getProxy ( ) ; } UnknownElement task = new UnknownElement ( tag ) ; task . setProject ( context . getProject ( ) ) ; task . setNamespace ( uri ) ; task . setQName ( qname ) ; task . setTaskType ( ProjectHelper . genComponentName ( task . getNamespace ( ) , tag ) ) ; task . setTaskName ( qname ) ; Location location = new Location ( context . getLocator ( ) . getSystemId ( ) , context . getLocator ( ) . getLineNumber ( ) , context . getLocator ( ) . getColumnNumber ( ) ) ; task . setLocation ( location ) ; task . setOwningTarget ( context . getCurrentTarget ( ) ) ; context . configureId ( task , attrs ) ; if ( parent != null ) { ( ( UnknownElement ) parent ) . addChild ( task ) ; } else { context . getCurrentTarget ( ) . addTask ( task ) ; } RuntimeConfigurable wrapper = new RuntimeConfigurable ( task , task . getTaskName ( ) ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String attrUri = attrs . getURI ( i ) ; if ( attrUri != null && ! attrUri . equals ( "" ) && ! attrUri . equals ( uri ) ) { continue ; } String name = attrs . getLocalName ( i ) ; String value = attrs . getValue ( i ) ; if ( name . equals ( "ant-type" ) ) { int index = value . indexOf ( ":" ) ; if ( index != - 1 ) { String prefix = value . substring ( 0 , index ) ; String mappedUri = context . getPrefixMapping ( prefix ) ; if ( mappedUri == null ) { throw new BuildException ( "Unable to find XML NS prefix " + prefix ) ; } value = ProjectHelper . genComponentName ( mappedUri , value . substring ( index + 1 ) ) ; } } wrapper . setAttribute ( name , value ) ; } if ( parentWrapper != null ) { parentWrapper . addChild ( wrapper ) ; } context . pushWrapper ( wrapper ) ; } public void characters ( char [ ] buf , int start , int count , AntXMLContext context ) throws SAXParseException { RuntimeConfigurable wrapper = context . currentWrapper ( ) ; wrapper . addText ( buf , start , count ) ; } public AntHandler onStartChild ( String uri , String tag , String qname , Attributes attrs , AntXMLContext context ) throws SAXParseException { return ProjectHelper2 . elementHandler ; } public void onEndElement ( String uri , String tag , AntXMLContext context ) { context . popWrapper ( ) ; } } } 	1	['9', '2', '0', '17', '73', '14', '7', '16', '4', '0.725', '432', '1', '5', '0.708333333', '0.275', '1', '1', '46.44444444', '1', '0.7778', '1']
package org . apache . tools . ant . taskdefs . condition ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; public class And extends ConditionBase implements Condition { public boolean eval ( ) throws BuildException { Enumeration e = getConditions ( ) ; while ( e . hasMoreElements ( ) ) { Condition c = ( Condition ) e . nextElement ( ) ; if ( ! c . eval ( ) ) { return false ; } } return true ; } } 	0	['2', '3', '0', '3', '7', '1', '1', '3', '2', '2', '23', '0', '0', '0.96969697', '1', '0', '0', '10.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class Gcj extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { Commandline cmd ; attributes . log ( "Using gcj compiler" , Project . MSG_VERBOSE ) ; cmd = setupGCJCommand ( ) ; int firstFileName = cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } protected Commandline setupGCJCommand ( ) { Commandline cmd = new Commandline ( ) ; Path classpath = new Path ( project ) ; if ( bootclasspath != null ) { classpath . append ( bootclasspath ) ; } classpath . addExtdirs ( extdirs ) ; if ( bootclasspath == null || bootclasspath . size ( ) == 0 ) { includeJavaRuntime = true ; } classpath . append ( getCompileClasspath ( ) ) ; if ( compileSourcepath != null ) { classpath . append ( compileSourcepath ) ; } else { classpath . append ( src ) ; } String exec = getJavac ( ) . getExecutable ( ) ; cmd . setExecutable ( exec == null ? "gcj" : exec ) ; if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; if ( destDir . mkdirs ( ) ) { throw new BuildException ( "Can't make output directories. " + "Maybe permission is wrong. " ) ; } ; } cmd . createArgument ( ) . setValue ( "-classpath" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; if ( encoding != null ) { cmd . createArgument ( ) . setValue ( "--encoding=" + encoding ) ; } if ( debug ) { cmd . createArgument ( ) . setValue ( "-g1" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O" ) ; } cmd . createArgument ( ) . setValue ( "-C" ) ; addCurrentCompilerArgs ( cmd ) ; return cmd ; } } 	1	['3', '2', '0', '9', '28', '3', '1', '8', '2', '2', '155', '0', '0', '0.92', '1', '1', '1', '50.66666667', '11', '4', '1']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; public class IsTrue extends ProjectComponent implements Condition { private Boolean value = null ; public void setValue ( boolean value ) { this . value = value ? Boolean . TRUE : Boolean . FALSE ; } public boolean eval ( ) throws BuildException { if ( value == null ) { throw new BuildException ( "Nothing to test for truth" ) ; } return value . booleanValue ( ) ; } } 	0	['3', '2', '0', '4', '6', '0', '1', '3', '3', '0', '30', '1', '0', '0.818181818', '0.666666667', '0', '0', '8.666666667', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import java . util . Enumeration ; import java . util . Locale ; import java . util . NoSuchElementException ; import java . util . Properties ; import org . apache . tools . ant . AntTypeDefinition ; import org . apache . tools . ant . ComponentHelper ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Location ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . types . EnumeratedAttribute ; public abstract class Definer extends DefBase { private String name ; private String classname ; private File file ; private String resource ; private int format = Format . PROPERTIES ; private boolean definerSet = false ; private int onError = OnError . FAIL ; private String adapter ; private String adaptTo ; private Class adapterClass ; private Class adaptToClass ; public static class OnError extends EnumeratedAttribute { public static final int FAIL = 0 , REPORT = 1 , IGNORE = 2 ; public OnError ( ) { super ( ) ; } public OnError ( String value ) { setValue ( value ) ; } public String [ ] getValues ( ) { return new String [ ] { "fail" , "report" , "ignore" } ; } } public static class Format extends EnumeratedAttribute { public static final int PROPERTIES = 0 , XML = 1 ; public String [ ] getValues ( ) { return new String [ ] { "properties" , "xml" } ; } } public void setOnError ( OnError onError ) { this . onError = onError . getIndex ( ) ; } public void setFormat ( Format format ) { this . format = format . getIndex ( ) ; } public String getName ( ) { return name ; } public File getFile ( ) { return file ; } public String getResource ( ) { return resource ; } public void execute ( ) throws BuildException { ClassLoader al = createLoader ( ) ; if ( ! definerSet ) { throw new BuildException ( "name, file or resource attribute of " + getTaskName ( ) + " is undefined" , getLocation ( ) ) ; } if ( name != null ) { if ( classname == null ) { throw new BuildException ( "classname attribute of " + getTaskName ( ) + " element " + "is undefined" , getLocation ( ) ) ; } addDefinition ( al , name , classname ) ; } else { if ( classname != null ) { String msg = "You must not specify classname " + "together with file or resource." ; throw new BuildException ( msg , getLocation ( ) ) ; } Enumeration urls = null ; if ( file != null ) { final URL url = fileToURL ( ) ; urls = new Enumeration ( ) { private boolean more = true ; public boolean hasMoreElements ( ) { return more ; } public Object nextElement ( ) throws NoSuchElementException { if ( more ) { more = false ; return url ; } else { throw new NoSuchElementException ( ) ; } } } ; } else { urls = resourceToURLs ( al ) ; } while ( urls . hasMoreElements ( ) ) { URL url = ( URL ) urls . nextElement ( ) ; int format = this . format ; if ( url . toString ( ) . toLowerCase ( Locale . US ) . endsWith ( ".xml" ) ) { format = Format . XML ; } if ( format == Format . PROPERTIES ) { loadProperties ( al , url ) ; break ; } else { loadAntlib ( al , url ) ; } } } } private URL fileToURL ( ) { if ( ! ( file . exists ( ) ) ) { log ( "File " + file + " does not exist" , Project . MSG_WARN ) ; return null ; } if ( ! ( file . isFile ( ) ) ) { log ( "File " + file + " is not a file" , Project . MSG_WARN ) ; return null ; } try { return file . toURL ( ) ; } catch ( Exception ex ) { log ( "File " + file + " cannot use as URL: " + ex . toString ( ) , Project . MSG_WARN ) ; return null ; } } private Enumeration resourceToURLs ( ClassLoader classLoader ) { Enumeration ret ; try { ret = classLoader . getResources ( resource ) ; } catch ( IOException e ) { throw new BuildException ( "Could not fetch resources named " + resource , e , getLocation ( ) ) ; } if ( ! ret . hasMoreElements ( ) ) { if ( onError != OnError . IGNORE ) { log ( "Could not load definitions from resource " + resource + ". It could not be found." , Project . MSG_WARN ) ; } } return ret ; } protected void loadProperties ( ClassLoader al , URL url ) { InputStream is = null ; try { is = url . openStream ( ) ; if ( is == null ) { log ( "Could not load definitions from " + url , Project . MSG_WARN ) ; return ; } Properties props = new Properties ( ) ; props . load ( is ) ; Enumeration keys = props . keys ( ) ; while ( keys . hasMoreElements ( ) ) { name = ( ( String ) keys . nextElement ( ) ) ; classname = props . getProperty ( name ) ; addDefinition ( al , name , classname ) ; } } catch ( IOException ex ) { throw new BuildException ( ex , getLocation ( ) ) ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( IOException e ) { } } } } private void loadAntlib ( ClassLoader classLoader , URL url ) { try { Antlib antlib = Antlib . createAntlib ( getProject ( ) , url , getURI ( ) ) ; antlib . setClassLoader ( classLoader ) ; antlib . setURI ( getURI ( ) ) ; antlib . perform ( ) ; } catch ( BuildException ex ) { throw ProjectHelper . addLocationToBuildException ( ex , getLocation ( ) ) ; } } public void setFile ( File file ) { if ( definerSet ) { tooManyDefinitions ( ) ; } definerSet = true ; this . file = file ; } public void setResource ( String res ) { if ( definerSet ) { tooManyDefinitions ( ) ; } definerSet = true ; this . resource = res ; } public void setName ( String name ) { if ( definerSet ) { tooManyDefinitions ( ) ; } definerSet = true ; this . name = name ; } public String getClassname ( ) { return classname ; } public void setClassname ( String classname ) { this . classname = classname ; } public void setAdapter ( String adapter ) { this . adapter = adapter ; } protected void setAdapterClass ( Class adapterClass ) { this . adapterClass = adapterClass ; } public void setAdaptTo ( String adaptTo ) { this . adaptTo = adaptTo ; } protected void setAdaptToClass ( Class adaptToClass ) { this . adaptToClass = adaptToClass ; } protected void addDefinition ( ClassLoader al , String name , String classname ) throws BuildException { Class cl = null ; try { try { name = ProjectHelper . genComponentName ( getURI ( ) , name ) ; if ( onError != OnError . IGNORE ) { cl = Class . forName ( classname , true , al ) ; } if ( adapter != null ) { adapterClass = Class . forName ( adapter , true , al ) ; } if ( adaptTo != null ) { adaptToClass = Class . forName ( adaptTo , true , al ) ; } AntTypeDefinition def = new AntTypeDefinition ( ) ; def . setName ( name ) ; def . setClassName ( classname ) ; def . setClass ( cl ) ; def . setAdapterClass ( adapterClass ) ; def . setAdaptToClass ( adaptToClass ) ; def . setClassLoader ( al ) ; if ( cl != null ) { def . checkClass ( getProject ( ) ) ; } ComponentHelper . getComponentHelper ( getProject ( ) ) . addDataTypeDefinition ( def ) ; } catch ( ClassNotFoundException cnfe ) { String msg = getTaskName ( ) + " class " + classname + " cannot be found" ; throw new BuildException ( msg , cnfe , getLocation ( ) ) ; } catch ( NoClassDefFoundError ncdfe ) { String msg = getTaskName ( ) + " A class needed by class " + classname + " cannot be found: " + ncdfe . getMessage ( ) ; throw new BuildException ( msg , ncdfe , getLocation ( ) ) ; } } catch ( BuildException ex ) { switch ( onError ) { case OnError . FAIL : throw ex ; case OnError . REPORT : log ( ex . getLocation ( ) + "Warning: " + ex . getMessage ( ) , Project . MSG_WARN ) ; break ; default : log ( ex . getLocation ( ) + ex . getMessage ( ) , Project . MSG_DEBUG ) ; } } } private void tooManyDefinitions ( ) { throw new BuildException ( "Only one of the attributes name,file,resource" + " can be set" , getLocation ( ) ) ; } } 	1	['22', '5', '1', '17', '73', '151', '4', '15', '14', '0.848484848', '618', '1', '0', '0.72', '0.221590909', '0', '0', '26.59090909', '7', '1.6364', '1']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . AbstractFileSet ; import org . apache . tools . ant . types . DirSet ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileList ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . SourceFileScanner ; public class ExecuteOn extends ExecTask { protected Vector filesets = new Vector ( ) ; private Vector filelists = new Vector ( ) ; private boolean relative = false ; private boolean parallel = false ; private boolean forwardSlash = false ; protected String type = "file" ; protected Commandline . Marker srcFilePos = null ; private boolean skipEmpty = false ; protected Commandline . Marker targetFilePos = null ; protected Mapper mapperElement = null ; protected FileNameMapper mapper = null ; protected File destDir = null ; private int maxParallel = - 1 ; private boolean addSourceFile = true ; private boolean verbose = false ; protected boolean srcIsFirst = true ; public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void addDirset ( DirSet set ) { filesets . addElement ( set ) ; } public void addFilelist ( FileList list ) { filelists . addElement ( list ) ; } public void setRelative ( boolean relative ) { this . relative = relative ; } public void setParallel ( boolean parallel ) { this . parallel = parallel ; } public void setType ( FileDirBoth type ) { this . type = type . getValue ( ) ; } public void setSkipEmptyFilesets ( boolean skip ) { skipEmpty = skip ; } public void setDest ( File destDir ) { this . destDir = destDir ; } public void setForwardslash ( boolean forwardSlash ) { this . forwardSlash = forwardSlash ; } public void setMaxParallel ( int max ) { maxParallel = max ; } public void setAddsourcefile ( boolean b ) { addSourceFile = b ; } public void setVerbose ( boolean b ) { verbose = b ; } public Commandline . Marker createSrcfile ( ) { if ( srcFilePos != null ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support multiple " + "srcfile elements." , getLocation ( ) ) ; } srcFilePos = cmdl . createMarker ( ) ; return srcFilePos ; } public Commandline . Marker createTargetfile ( ) { if ( targetFilePos != null ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support multiple " + "targetfile elements." , getLocation ( ) ) ; } targetFilePos = cmdl . createMarker ( ) ; srcIsFirst = ( srcFilePos != null ) ; return targetFilePos ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" , getLocation ( ) ) ; } mapperElement = new Mapper ( getProject ( ) ) ; return mapperElement ; } protected void checkConfiguration ( ) { if ( "execon" . equals ( getTaskName ( ) ) ) { log ( "!! execon is deprecated. Use apply instead. !!" ) ; } super . checkConfiguration ( ) ; if ( filesets . size ( ) == 0 && filelists . size ( ) == 0 ) { throw new BuildException ( "no filesets and no filelists specified" , getLocation ( ) ) ; } if ( targetFilePos != null || mapperElement != null || destDir != null ) { if ( mapperElement == null ) { throw new BuildException ( "no mapper specified" , getLocation ( ) ) ; } if ( destDir == null ) { throw new BuildException ( "no dest attribute specified" , getLocation ( ) ) ; } mapper = mapperElement . getImplementation ( ) ; } } protected void runExec ( Execute exe ) throws BuildException { int totalFiles = 0 ; int totalDirs = 0 ; boolean haveExecuted = false ; try { Vector fileNames = new Vector ( ) ; Vector baseDirs = new Vector ( ) ; for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { String currentType = type ; AbstractFileSet fs = ( AbstractFileSet ) filesets . elementAt ( i ) ; if ( fs instanceof DirSet ) { if ( ! "dir" . equals ( type ) ) { log ( "Found a nested dirset but type is " + type + ". " + "Temporarily switching to type=\"dir\" on the" + " assumption that you really did mean" + " <dirset> not <fileset>." , Project . MSG_DEBUG ) ; currentType = "dir" ; } } File base = fs . getDir ( getProject ( ) ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; if ( ! "dir" . equals ( currentType ) ) { String [ ] s = getFiles ( base , ds ) ; for ( int j = 0 ; j < s . length ; j ++ ) { totalFiles ++ ; fileNames . addElement ( s [ j ] ) ; baseDirs . addElement ( base ) ; } } if ( ! "file" . equals ( currentType ) ) { String [ ] s = getDirs ( base , ds ) ; for ( int j = 0 ; j < s . length ; j ++ ) { totalDirs ++ ; fileNames . addElement ( s [ j ] ) ; baseDirs . addElement ( base ) ; } } if ( fileNames . size ( ) == 0 && skipEmpty ) { log ( "Skipping fileset for directory " + base + ". It is empty." , Project . MSG_INFO ) ; continue ; } if ( ! parallel ) { String [ ] s = new String [ fileNames . size ( ) ] ; fileNames . copyInto ( s ) ; for ( int j = 0 ; j < s . length ; j ++ ) { String [ ] command = getCommandline ( s [ j ] , base ) ; log ( Commandline . describeCommand ( command ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( command ) ; if ( haveExecuted ) { exe . setStreamHandler ( createHandler ( ) ) ; } runExecute ( exe ) ; haveExecuted = true ; } fileNames . removeAllElements ( ) ; baseDirs . removeAllElements ( ) ; } } for ( int i = 0 ; i < filelists . size ( ) ; i ++ ) { FileList list = ( FileList ) filelists . elementAt ( i ) ; File base = list . getDir ( getProject ( ) ) ; String [ ] names = list . getFiles ( getProject ( ) ) ; for ( int j = 0 ; j < names . length ; j ++ ) { File f = new File ( base , names [ j ] ) ; if ( ( f . isFile ( ) && ! "dir" . equals ( type ) ) || ( f . isDirectory ( ) && ! "file" . equals ( type ) ) ) { if ( f . isFile ( ) ) { totalFiles ++ ; } else { totalDirs ++ ; } fileNames . addElement ( names [ j ] ) ; baseDirs . addElement ( base ) ; } } if ( fileNames . size ( ) == 0 && skipEmpty ) { log ( "Skipping filelist for directory " + base + ". It is empty." , Project . MSG_INFO ) ; continue ; } if ( ! parallel ) { String [ ] s = new String [ fileNames . size ( ) ] ; fileNames . copyInto ( s ) ; for ( int j = 0 ; j < s . length ; j ++ ) { String [ ] command = getCommandline ( s [ j ] , base ) ; log ( Commandline . describeCommand ( command ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( command ) ; if ( haveExecuted ) { exe . setStreamHandler ( createHandler ( ) ) ; } runExecute ( exe ) ; haveExecuted = true ; } fileNames . removeAllElements ( ) ; baseDirs . removeAllElements ( ) ; } } if ( parallel && ( fileNames . size ( ) > 0 || ! skipEmpty ) ) { runParallel ( exe , fileNames , baseDirs ) ; haveExecuted = true ; } if ( haveExecuted ) { log ( "Applied " + cmdl . getExecutable ( ) + " to " + totalFiles + " file" + ( totalFiles != 1 ? "s" : "" ) + " and " + totalDirs + " director" + ( totalDirs != 1 ? "ies" : "y" ) + "." , verbose ? Project . MSG_INFO : Project . MSG_VERBOSE ) ; } } catch ( IOException e ) { throw new BuildException ( "Execute failed: " + e , e , getLocation ( ) ) ; } finally { logFlush ( ) ; } } protected String [ ] getCommandline ( String [ ] srcFiles , File [ ] baseDirs ) { final char fileSeparator = File . separatorChar ; Vector targets = new Vector ( ) ; if ( targetFilePos != null ) { Hashtable addedFiles = new Hashtable ( ) ; for ( int i = 0 ; i < srcFiles . length ; i ++ ) { String [ ] subTargets = mapper . mapFileName ( srcFiles [ i ] ) ; if ( subTargets != null ) { for ( int j = 0 ; j < subTargets . length ; j ++ ) { String name = null ; if ( ! relative ) { name = ( new File ( destDir , subTargets [ j ] ) ) . getAbsolutePath ( ) ; } else { name = subTargets [ j ] ; } if ( forwardSlash && fileSeparator != '/' ) { name = name . replace ( fileSeparator , '/' ) ; } if ( ! addedFiles . contains ( name ) ) { targets . addElement ( name ) ; addedFiles . put ( name , name ) ; } } } } } String [ ] targetFiles = new String [ targets . size ( ) ] ; targets . copyInto ( targetFiles ) ; if ( ! addSourceFile ) { srcFiles = new String [ 0 ] ; } String [ ] orig = cmdl . getCommandline ( ) ; String [ ] result = new String [ orig . length + srcFiles . length + targetFiles . length ] ; int srcIndex = orig . length ; if ( srcFilePos != null ) { srcIndex = srcFilePos . getPosition ( ) ; } if ( targetFilePos != null ) { int targetIndex = targetFilePos . getPosition ( ) ; if ( srcIndex < targetIndex || ( srcIndex == targetIndex && srcIsFirst ) ) { System . arraycopy ( orig , 0 , result , 0 , srcIndex ) ; System . arraycopy ( orig , srcIndex , result , srcIndex + srcFiles . length , targetIndex - srcIndex ) ; System . arraycopy ( targetFiles , 0 , result , targetIndex + srcFiles . length , targetFiles . length ) ; System . arraycopy ( orig , targetIndex , result , targetIndex + srcFiles . length + targetFiles . length , orig . length - targetIndex ) ; } else { System . arraycopy ( orig , 0 , result , 0 , targetIndex ) ; System . arraycopy ( targetFiles , 0 , result , targetIndex , targetFiles . length ) ; System . arraycopy ( orig , targetIndex , result , targetIndex + targetFiles . length , srcIndex - targetIndex ) ; System . arraycopy ( orig , srcIndex , result , srcIndex + srcFiles . length + targetFiles . length , orig . length - srcIndex ) ; srcIndex += targetFiles . length ; } } else { System . arraycopy ( orig , 0 , result , 0 , srcIndex ) ; System . arraycopy ( orig , srcIndex , result , srcIndex + srcFiles . length , orig . length - srcIndex ) ; } for ( int i = 0 ; i < srcFiles . length ; i ++ ) { if ( ! relative ) { result [ srcIndex + i ] = ( new File ( baseDirs [ i ] , srcFiles [ i ] ) ) . getAbsolutePath ( ) ; } else { result [ srcIndex + i ] = srcFiles [ i ] ; } if ( forwardSlash && fileSeparator != '/' ) { result [ srcIndex + i ] = result [ srcIndex + i ] . replace ( fileSeparator , '/' ) ; } } return result ; } protected String [ ] getCommandline ( String srcFile , File baseDir ) { return getCommandline ( new String [ ] { srcFile } , new File [ ] { baseDir } ) ; } protected String [ ] getFiles ( File baseDir , DirectoryScanner ds ) { if ( mapper != null ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; return sfs . restrict ( ds . getIncludedFiles ( ) , baseDir , destDir , mapper ) ; } else { return ds . getIncludedFiles ( ) ; } } protected String [ ] getDirs ( File baseDir , DirectoryScanner ds ) { if ( mapper != null ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; return sfs . restrict ( ds . getIncludedDirectories ( ) , baseDir , destDir , mapper ) ; } else { return ds . getIncludedDirectories ( ) ; } } protected void runParallel ( Execute exe , Vector fileNames , Vector baseDirs ) throws IOException , BuildException { String [ ] s = new String [ fileNames . size ( ) ] ; fileNames . copyInto ( s ) ; File [ ] b = new File [ baseDirs . size ( ) ] ; baseDirs . copyInto ( b ) ; if ( maxParallel <= 0 || s . length == 0 ) { String [ ] command = getCommandline ( s , b ) ; log ( Commandline . describeCommand ( command ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( command ) ; runExecute ( exe ) ; } else { int stillToDo = fileNames . size ( ) ; int currentOffset = 0 ; while ( stillToDo > 0 ) { int currentAmount = Math . min ( stillToDo , maxParallel ) ; String [ ] cs = new String [ currentAmount ] ; System . arraycopy ( s , currentOffset , cs , 0 , currentAmount ) ; File [ ] cb = new File [ currentAmount ] ; System . arraycopy ( b , currentOffset , cb , 0 , currentAmount ) ; String [ ] command = getCommandline ( cs , cb ) ; log ( Commandline . describeCommand ( command ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( command ) ; if ( currentOffset > 0 ) { exe . setStreamHandler ( createHandler ( ) ) ; } runExecute ( exe ) ; stillToDo -= currentAmount ; currentOffset += currentAmount ; } } } public static class FileDirBoth extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "file" , "dir" , "both" } ; } } } 	0	['23', '4', '2', '22', '77', '149', '2', '20', '16', '0.826704545', '1164', '1', '4', '0.777777778', '0.142857143', '3', '7', '48.91304348', '19', '2.3043', '0']
package org . apache . tools . ant ; import java . io . BufferedReader ; import java . io . File ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . util . Hashtable ; import java . util . Locale ; import java . util . Vector ; import org . apache . tools . ant . helper . ProjectHelper2 ; import org . apache . tools . ant . util . LoaderUtils ; import org . xml . sax . AttributeList ; public class ProjectHelper { public static final String ANT_CORE_URI = "antlib:org.apache.tools.ant" ; public static final String ANT_CURRENT_URI = "ant:current" ; public static final String ANTLIB_URI = "antlib:" ; public static final String HELPER_PROPERTY = "org.apache.tools.ant.ProjectHelper" ; public static final String SERVICE_ID = "META-INF/services/org.apache.tools.ant.ProjectHelper" ; public static void configureProject ( Project project , File buildFile ) throws BuildException { ProjectHelper helper = ProjectHelper . getProjectHelper ( ) ; project . addReference ( "ant.projectHelper" , helper ) ; helper . parse ( project , buildFile ) ; } public ProjectHelper ( ) { } private Vector importStack = new Vector ( ) ; public Vector getImportStack ( ) { return importStack ; } public void parse ( Project project , Object source ) throws BuildException { throw new BuildException ( "ProjectHelper.parse() must be implemented " + "in a helper plugin " + this . getClass ( ) . getName ( ) ) ; } public static ProjectHelper getProjectHelper ( ) throws BuildException { ProjectHelper helper = null ; String helperClass = System . getProperty ( HELPER_PROPERTY ) ; try { if ( helperClass != null ) { helper = newHelper ( helperClass ) ; } } catch ( SecurityException e ) { System . out . println ( "Unable to load ProjectHelper class \"" + helperClass + " specified in system property " + HELPER_PROPERTY ) ; } if ( helper == null ) { try { ClassLoader classLoader = LoaderUtils . getContextClassLoader ( ) ; InputStream is = null ; if ( classLoader != null ) { is = classLoader . getResourceAsStream ( SERVICE_ID ) ; } if ( is == null ) { is = ClassLoader . getSystemResourceAsStream ( SERVICE_ID ) ; } if ( is != null ) { InputStreamReader isr ; try { isr = new InputStreamReader ( is , "UTF-8" ) ; } catch ( java . io . UnsupportedEncodingException e ) { isr = new InputStreamReader ( is ) ; } BufferedReader rd = new BufferedReader ( isr ) ; String helperClassName = rd . readLine ( ) ; rd . close ( ) ; if ( helperClassName != null && ! "" . equals ( helperClassName ) ) { helper = newHelper ( helperClassName ) ; } } } catch ( Exception ex ) { System . out . println ( "Unable to load ProjectHelper " + "from service \"" + SERVICE_ID ) ; } } if ( helper != null ) { return helper ; } else { try { return new ProjectHelper2 ( ) ; } catch ( Throwable e ) { String message = "Unable to load default ProjectHelper due to " + e . getClass ( ) . getName ( ) + ": " + e . getMessage ( ) ; throw new BuildException ( message , e ) ; } } } private static ProjectHelper newHelper ( String helperClass ) throws BuildException { ClassLoader classLoader = LoaderUtils . getContextClassLoader ( ) ; try { Class clazz = null ; if ( classLoader != null ) { try { clazz = classLoader . loadClass ( helperClass ) ; } catch ( ClassNotFoundException ex ) { } } if ( clazz == null ) { clazz = Class . forName ( helperClass ) ; } return ( ( ProjectHelper ) clazz . newInstance ( ) ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } public static ClassLoader getContextClassLoader ( ) { if ( ! LoaderUtils . isContextLoaderAvailable ( ) ) { return null ; } return LoaderUtils . getContextClassLoader ( ) ; } public static void configure ( Object target , AttributeList attrs , Project project ) throws BuildException { if ( target instanceof TypeAdapter ) { target = ( ( TypeAdapter ) target ) . getProxy ( ) ; } IntrospectionHelper ih = IntrospectionHelper . getHelper ( target . getClass ( ) ) ; project . addBuildListener ( ih ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String value = replaceProperties ( project , attrs . getValue ( i ) , project . getProperties ( ) ) ; try { ih . setAttribute ( project , target , attrs . getName ( i ) . toLowerCase ( Locale . US ) , value ) ; } catch ( BuildException be ) { if ( ! attrs . getName ( i ) . equals ( "id" ) ) { throw be ; } } } } public static void addText ( Project project , Object target , char [ ] buf , int start , int count ) throws BuildException { addText ( project , target , new String ( buf , start , count ) ) ; } public static void addText ( Project project , Object target , String text ) throws BuildException { if ( text == null ) { return ; } if ( target instanceof TypeAdapter ) { target = ( ( TypeAdapter ) target ) . getProxy ( ) ; } IntrospectionHelper . getHelper ( target . getClass ( ) ) . addText ( project , target , text ) ; } public static void storeChild ( Project project , Object parent , Object child , String tag ) { IntrospectionHelper ih = IntrospectionHelper . getHelper ( parent . getClass ( ) ) ; ih . storeElement ( project , parent , child , tag ) ; } public static String replaceProperties ( Project project , String value ) throws BuildException { return project . replaceProperties ( value ) ; } public static String replaceProperties ( Project project , String value , Hashtable keys ) throws BuildException { PropertyHelper ph = PropertyHelper . getPropertyHelper ( project ) ; return ph . replaceProperties ( null , value , keys ) ; } public static void parsePropertyString ( String value , Vector fragments , Vector propertyRefs ) throws BuildException { PropertyHelper . parsePropertyStringDefault ( value , fragments , propertyRefs ) ; } public static String genComponentName ( String uri , String name ) { if ( uri == null || uri . equals ( "" ) || uri . equals ( ANT_CORE_URI ) ) { return name ; } return uri + ":" + name ; } public static String extractUriFromComponentName ( String componentName ) { if ( componentName == null ) { return "" ; } int index = componentName . lastIndexOf ( ':' ) ; if ( index == - 1 ) { return "" ; } return componentName . substring ( 0 , index ) ; } public static String extractNameFromComponentName ( String componentName ) { int index = componentName . lastIndexOf ( ':' ) ; if ( index == - 1 ) { return componentName ; } return componentName . substring ( index + 1 ) ; } public static BuildException addLocationToBuildException ( BuildException ex , Location newLocation ) { if ( ex . getLocation ( ) == null || ex . getMessage ( ) == null ) { return ex ; } String errorMessage = "Following error occured while executing this line" + System . getProperty ( "line.separator" ) + ex . getLocation ( ) . toString ( ) + ex . getMessage ( ) ; if ( newLocation == null ) { return new BuildException ( errorMessage ) ; } else { return new BuildException ( errorMessage , newLocation ) ; } } } 	1	['18', '1', '2', '23', '68', '151', '16', '9', '17', '1.039215686', '413', '0.166666667', '0', '0', '0.152777778', '0', '0', '21.61111111', '4', '1.5', '1']
package org . apache . tools . bzip2 ; class CRC { public static int crc32Table [ ] = { 0x00000000 , 0x04c11db7 , 0x09823b6e , 0x0d4326d9 , 0x130476dc , 0x17c56b6b , 0x1a864db2 , 0x1e475005 , 0x2608edb8 , 0x22c9f00f , 0x2f8ad6d6 , 0x2b4bcb61 , 0x350c9b64 , 0x31cd86d3 , 0x3c8ea00a , 0x384fbdbd , 0x4c11db70 , 0x48d0c6c7 , 0x4593e01e , 0x4152fda9 , 0x5f15adac , 0x5bd4b01b , 0x569796c2 , 0x52568b75 , 0x6a1936c8 , 0x6ed82b7f , 0x639b0da6 , 0x675a1011 , 0x791d4014 , 0x7ddc5da3 , 0x709f7b7a , 0x745e66cd , 0x9823b6e0 , 0x9ce2ab57 , 0x91a18d8e , 0x95609039 , 0x8b27c03c , 0x8fe6dd8b , 0x82a5fb52 , 0x8664e6e5 , 0xbe2b5b58 , 0xbaea46ef , 0xb7a96036 , 0xb3687d81 , 0xad2f2d84 , 0xa9ee3033 , 0xa4ad16ea , 0xa06c0b5d , 0xd4326d90 , 0xd0f37027 , 0xddb056fe , 0xd9714b49 , 0xc7361b4c , 0xc3f706fb , 0xceb42022 , 0xca753d95 , 0xf23a8028 , 0xf6fb9d9f , 0xfbb8bb46 , 0xff79a6f1 , 0xe13ef6f4 , 0xe5ffeb43 , 0xe8bccd9a , 0xec7dd02d , 0x34867077 , 0x30476dc0 , 0x3d044b19 , 0x39c556ae , 0x278206ab , 0x23431b1c , 0x2e003dc5 , 0x2ac12072 , 0x128e9dcf , 0x164f8078 , 0x1b0ca6a1 , 0x1fcdbb16 , 0x018aeb13 , 0x054bf6a4 , 0x0808d07d , 0x0cc9cdca , 0x7897ab07 , 0x7c56b6b0 , 0x71159069 , 0x75d48dde , 0x6b93dddb , 0x6f52c06c , 0x6211e6b5 , 0x66d0fb02 , 0x5e9f46bf , 0x5a5e5b08 , 0x571d7dd1 , 0x53dc6066 , 0x4d9b3063 , 0x495a2dd4 , 0x44190b0d , 0x40d816ba , 0xaca5c697 , 0xa864db20 , 0xa527fdf9 , 0xa1e6e04e , 0xbfa1b04b , 0xbb60adfc , 0xb6238b25 , 0xb2e29692 , 0x8aad2b2f , 0x8e6c3698 , 0x832f1041 , 0x87ee0df6 , 0x99a95df3 , 0x9d684044 , 0x902b669d , 0x94ea7b2a , 0xe0b41de7 , 0xe4750050 , 0xe9362689 , 0xedf73b3e , 0xf3b06b3b , 0xf771768c , 0xfa325055 , 0xfef34de2 , 0xc6bcf05f , 0xc27dede8 , 0xcf3ecb31 , 0xcbffd686 , 0xd5b88683 , 0xd1799b34 , 0xdc3abded , 0xd8fba05a , 0x690ce0ee , 0x6dcdfd59 , 0x608edb80 , 0x644fc637 , 0x7a089632 , 0x7ec98b85 , 0x738aad5c , 0x774bb0eb , 0x4f040d56 , 0x4bc510e1 , 0x46863638 , 0x42472b8f , 0x5c007b8a , 0x58c1663d , 0x558240e4 , 0x51435d53 , 0x251d3b9e , 0x21dc2629 , 0x2c9f00f0 , 0x285e1d47 , 0x36194d42 , 0x32d850f5 , 0x3f9b762c , 0x3b5a6b9b , 0x0315d626 , 0x07d4cb91 , 0x0a97ed48 , 0x0e56f0ff , 0x1011a0fa , 0x14d0bd4d , 0x19939b94 , 0x1d528623 , 0xf12f560e , 0xf5ee4bb9 , 0xf8ad6d60 , 0xfc6c70d7 , 0xe22b20d2 , 0xe6ea3d65 , 0xeba91bbc , 0xef68060b , 0xd727bbb6 , 0xd3e6a601 , 0xdea580d8 , 0xda649d6f , 0xc423cd6a , 0xc0e2d0dd , 0xcda1f604 , 0xc960ebb3 , 0xbd3e8d7e , 0xb9ff90c9 , 0xb4bcb610 , 0xb07daba7 , 0xae3afba2 , 0xaafbe615 , 0xa7b8c0cc , 0xa379dd7b , 0x9b3660c6 , 0x9ff77d71 , 0x92b45ba8 , 0x9675461f , 0x8832161a , 0x8cf30bad , 0x81b02d74 , 0x857130c3 , 0x5d8a9099 , 0x594b8d2e , 0x5408abf7 , 0x50c9b640 , 0x4e8ee645 , 0x4a4ffbf2 , 0x470cdd2b , 0x43cdc09c , 0x7b827d21 , 0x7f436096 , 0x7200464f , 0x76c15bf8 , 0x68860bfd , 0x6c47164a , 0x61043093 , 0x65c52d24 , 0x119b4be9 , 0x155a565e , 0x18197087 , 0x1cd86d30 , 0x029f3d35 , 0x065e2082 , 0x0b1d065b , 0x0fdc1bec , 0x3793a651 , 0x3352bbe6 , 0x3e119d3f , 0x3ad08088 , 0x2497d08d , 0x2056cd3a , 0x2d15ebe3 , 0x29d4f654 , 0xc5a92679 , 0xc1683bce , 0xcc2b1d17 , 0xc8ea00a0 , 0xd6ad50a5 , 0xd26c4d12 , 0xdf2f6bcb , 0xdbee767c , 0xe3a1cbc1 , 0xe760d676 , 0xea23f0af , 0xeee2ed18 , 0xf0a5bd1d , 0xf464a0aa , 0xf9278673 , 0xfde69bc4 , 0x89b8fd09 , 0x8d79e0be , 0x803ac667 , 0x84fbdbd0 , 0x9abc8bd5 , 0x9e7d9662 , 0x933eb0bb , 0x97ffad0c , 0xafb010b1 , 0xab710d06 , 0xa6322bdf , 0xa2f33668 , 0xbcb4666d , 0xb8757bda , 0xb5365d03 , 0xb1f740b4 } ; public CRC ( ) { initialiseCRC ( ) ; } void initialiseCRC ( ) { globalCrc = 0xffffffff ; } int getFinalCRC ( ) { return ~ globalCrc ; } int getGlobalCRC ( ) { return globalCrc ; } void setGlobalCRC ( int newCrc ) { globalCrc = newCrc ; } void updateCRC ( int inCh ) { int temp = ( globalCrc > > 24 ) ^ inCh ; if ( temp < 0 ) { temp = 256 + temp ; } globalCrc = ( globalCrc << 8 ) ^ CRC . crc32Table [ temp ] ; } int globalCrc ; } 	0	['7', '1', '0', '2', '8', '0', '2', '0', '1', '0.5', '1082', '0', '0', '0', '0.666666667', '0', '0', '153.2857143', '2', '0.8571', '0']
package org . apache . tools . ant ; import java . util . Hashtable ; import java . util . Vector ; import java . util . Enumeration ; public class PropertyHelper { private Project project ; private PropertyHelper next ; private Hashtable properties = new Hashtable ( ) ; private Hashtable userProperties = new Hashtable ( ) ; private Hashtable inheritedProperties = new Hashtable ( ) ; protected PropertyHelper ( ) { } public void setProject ( Project p ) { this . project = p ; } public void setNext ( PropertyHelper next ) { this . next = next ; } public PropertyHelper getNext ( ) { return next ; } public static synchronized PropertyHelper getPropertyHelper ( Project project ) { PropertyHelper helper = ( PropertyHelper ) project . getReference ( "ant.PropertyHelper" ) ; if ( helper != null ) { return helper ; } helper = new PropertyHelper ( ) ; helper . setProject ( project ) ; project . addReference ( "ant.PropertyHelper" , helper ) ; return helper ; } public boolean setPropertyHook ( String ns , String name , Object value , boolean inherited , boolean user , boolean isNew ) { if ( getNext ( ) != null ) { boolean subst = getNext ( ) . setPropertyHook ( ns , name , value , inherited , user , isNew ) ; if ( subst ) { return true ; } } return false ; } public Object getPropertyHook ( String ns , String name , boolean user ) { if ( getNext ( ) != null ) { Object o = getNext ( ) . getPropertyHook ( ns , name , user ) ; if ( o != null ) { return o ; } } if ( name . startsWith ( "toString:" ) ) { name = name . substring ( "toString:" . length ( ) ) ; Object v = project . getReference ( name ) ; if ( v == null ) { return null ; } return v . toString ( ) ; } return null ; } public void parsePropertyString ( String value , Vector fragments , Vector propertyRefs ) throws BuildException { parsePropertyStringDefault ( value , fragments , propertyRefs ) ; } public String replaceProperties ( String ns , String value , Hashtable keys ) throws BuildException { if ( value == null ) { return null ; } Vector fragments = new Vector ( ) ; Vector propertyRefs = new Vector ( ) ; parsePropertyString ( value , fragments , propertyRefs ) ; StringBuffer sb = new StringBuffer ( ) ; Enumeration i = fragments . elements ( ) ; Enumeration j = propertyRefs . elements ( ) ; while ( i . hasMoreElements ( ) ) { String fragment = ( String ) i . nextElement ( ) ; if ( fragment == null ) { String propertyName = ( String ) j . nextElement ( ) ; Object replacement = null ; if ( keys != null ) { replacement = keys . get ( propertyName ) ; } if ( replacement == null ) { replacement = getProperty ( ns , propertyName ) ; } if ( replacement == null ) { project . log ( "Property ${" + propertyName + "} has not been set" , Project . MSG_VERBOSE ) ; } fragment = ( replacement != null ) ? replacement . toString ( ) : "${" + propertyName + "}" ; } sb . append ( fragment ) ; } return sb . toString ( ) ; } public synchronized boolean setProperty ( String ns , String name , Object value , boolean verbose ) { if ( null != userProperties . get ( name ) ) { if ( verbose ) { project . log ( "Override ignored for user property " + name , Project . MSG_VERBOSE ) ; } return false ; } boolean done = setPropertyHook ( ns , name , value , false , false , false ) ; if ( done ) { return true ; } if ( null != properties . get ( name ) && verbose ) { project . log ( "Overriding previous definition of property " + name , Project . MSG_VERBOSE ) ; } if ( verbose ) { project . log ( "Setting project property: " + name + " -> " + value , Project . MSG_DEBUG ) ; } properties . put ( name , value ) ; return true ; } public synchronized void setNewProperty ( String ns , String name , Object value ) { if ( null != properties . get ( name ) ) { project . log ( "Override ignored for property " + name , Project . MSG_VERBOSE ) ; return ; } boolean done = setPropertyHook ( ns , name , value , false , false , true ) ; if ( done ) { return ; } project . log ( "Setting project property: " + name + " -> " + value , Project . MSG_DEBUG ) ; if ( name != null && value != null ) { properties . put ( name , value ) ; } } public synchronized void setUserProperty ( String ns , String name , Object value ) { project . log ( "Setting ro project property: " + name + " -> " + value , Project . MSG_DEBUG ) ; userProperties . put ( name , value ) ; boolean done = setPropertyHook ( ns , name , value , false , true , false ) ; if ( done ) { return ; } properties . put ( name , value ) ; } public synchronized void setInheritedProperty ( String ns , String name , Object value ) { inheritedProperties . put ( name , value ) ; project . log ( "Setting ro project property: " + name + " -> " + value , Project . MSG_DEBUG ) ; userProperties . put ( name , value ) ; boolean done = setPropertyHook ( ns , name , value , true , false , false ) ; if ( done ) { return ; } properties . put ( name , value ) ; } public synchronized Object getProperty ( String ns , String name ) { if ( name == null ) { return null ; } Object o = getPropertyHook ( ns , name , false ) ; if ( o != null ) { return o ; } return properties . get ( name ) ; } public synchronized Object getUserProperty ( String ns , String name ) { if ( name == null ) { return null ; } Object o = getPropertyHook ( ns , name , true ) ; if ( o != null ) { return o ; } return userProperties . get ( name ) ; } public Hashtable getProperties ( ) { Hashtable propertiesCopy = new Hashtable ( ) ; Enumeration e = properties . keys ( ) ; while ( e . hasMoreElements ( ) ) { Object name = e . nextElement ( ) ; Object value = properties . get ( name ) ; propertiesCopy . put ( name , value ) ; } return propertiesCopy ; } public Hashtable getUserProperties ( ) { Hashtable propertiesCopy = new Hashtable ( ) ; Enumeration e = userProperties . keys ( ) ; while ( e . hasMoreElements ( ) ) { Object name = e . nextElement ( ) ; Object value = properties . get ( name ) ; propertiesCopy . put ( name , value ) ; } return propertiesCopy ; } public void copyInheritedProperties ( Project other ) { Enumeration e = inheritedProperties . keys ( ) ; while ( e . hasMoreElements ( ) ) { String arg = e . nextElement ( ) . toString ( ) ; if ( other . getUserProperty ( arg ) != null ) { continue ; } Object value = inheritedProperties . get ( arg ) ; other . setInheritedProperty ( arg , value . toString ( ) ) ; } } public void copyUserProperties ( Project other ) { Enumeration e = userProperties . keys ( ) ; while ( e . hasMoreElements ( ) ) { Object arg = e . nextElement ( ) ; if ( inheritedProperties . containsKey ( arg ) ) { continue ; } Object value = userProperties . get ( arg ) ; other . setUserProperty ( arg . toString ( ) , value . toString ( ) ) ; } } static void parsePropertyStringDefault ( String value , Vector fragments , Vector propertyRefs ) throws BuildException { int prev = 0 ; int pos ; while ( ( pos = value . indexOf ( "$" , prev ) ) >= 0 ) { if ( pos > 0 ) { fragments . addElement ( value . substring ( prev , pos ) ) ; } if ( pos == ( value . length ( ) - 1 ) ) { fragments . addElement ( "$" ) ; prev = pos + 1 ; } else if ( value . charAt ( pos + 1 ) != '{' ) { if ( value . charAt ( pos + 1 ) == '$' ) { fragments . addElement ( "$" ) ; prev = pos + 2 ; } else { fragments . addElement ( value . substring ( pos , pos + 2 ) ) ; prev = pos + 2 ; } } else { int endName = value . indexOf ( '}' , pos ) ; if ( endName < 0 ) { throw new BuildException ( "Syntax error in property: " + value ) ; } String propertyName = value . substring ( pos + 2 , endName ) ; fragments . addElement ( null ) ; propertyRefs . addElement ( propertyName ) ; prev = endName + 1 ; } } if ( prev < value . length ( ) ) { fragments . addElement ( value . substring ( prev ) ) ; } } } 	1	['20', '1', '0', '3', '50', '74', '2', '2', '18', '0.6', '721', '1', '2', '0', '0.28125', '0', '0', '34.8', '7', '2.4', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . TimeoutObserver ; import org . apache . tools . ant . util . Watchdog ; public class ExecuteWatchdog implements TimeoutObserver { private Process process ; private boolean watch = false ; private Exception caught = null ; private boolean killedProcess = false ; private Watchdog watchdog ; public ExecuteWatchdog ( long timeout ) { watchdog = new Watchdog ( timeout ) ; watchdog . addTimeoutObserver ( this ) ; } public ExecuteWatchdog ( int timeout ) { this ( ( long ) timeout ) ; } public synchronized void start ( Process process ) { if ( process == null ) { throw new NullPointerException ( "process is null." ) ; } if ( this . process != null ) { throw new IllegalStateException ( "Already running." ) ; } this . caught = null ; this . killedProcess = false ; this . watch = true ; this . process = process ; watchdog . start ( ) ; } public synchronized void stop ( ) { watchdog . stop ( ) ; watch = false ; process = null ; } public void timeoutOccured ( Watchdog w ) { try { try { process . exitValue ( ) ; } catch ( IllegalThreadStateException itse ) { if ( watch ) { killedProcess = true ; process . destroy ( ) ; } } } catch ( Exception e ) { caught = e ; } finally { cleanUp ( ) ; } } protected void cleanUp ( ) { watch = false ; process = null ; } public void checkException ( ) throws BuildException { if ( caught != null ) { throw new BuildException ( "Exception in ExecuteWatchdog.run: " + caught . getMessage ( ) , caught ) ; } } public boolean isWatching ( ) { return watch ; } public boolean killedProcess ( ) { return killedProcess ; } } 	0	['9', '1', '0', '8', '23', '0', '5', '3', '8', '0.5', '148', '1', '1', '0', '0.288888889', '0', '0', '14.88888889', '4', '1.3333', '0']
package org . apache . tools . ant . types ; import java . util . Enumeration ; import java . util . Properties ; import java . util . Vector ; import java . util . List ; import java . util . LinkedList ; import java . util . ListIterator ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . JavaEnvUtils ; public class CommandlineJava implements Cloneable { private Commandline vmCommand = new Commandline ( ) ; private Commandline javaCommand = new Commandline ( ) ; private SysProperties sysProperties = new SysProperties ( ) ; private Path classpath = null ; private Path bootclasspath = null ; private String vmVersion ; private String maxMemory = null ; private Assertions assertions = null ; private boolean executeJar = false ; public static class SysProperties extends Environment implements Cloneable { Properties sys = null ; private Vector propertySets = new Vector ( ) ; public String [ ] getVariables ( ) throws BuildException { List definitions = new LinkedList ( ) ; ListIterator list = definitions . listIterator ( ) ; addDefinitionsToList ( list ) ; if ( definitions . size ( ) == 0 ) { return null ; } else { return ( String [ ] ) definitions . toArray ( new String [ 0 ] ) ; } } public void addDefinitionsToList ( ListIterator listIt ) { String [ ] props = super . getVariables ( ) ; if ( props != null ) { for ( int i = 0 ; i < props . length ; i ++ ) { listIt . add ( "-D" + props [ i ] ) ; } } Properties propertySets = mergePropertySets ( ) ; for ( Enumeration e = propertySets . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; String value = propertySets . getProperty ( key ) ; listIt . add ( "-D" + key + "=" + value ) ; } } public int size ( ) { Properties p = mergePropertySets ( ) ; return variables . size ( ) + p . size ( ) ; } public void setSystem ( ) throws BuildException { try { sys = System . getProperties ( ) ; Properties p = new Properties ( ) ; for ( Enumeration e = sys . keys ( ) ; e . hasMoreElements ( ) ; ) { Object o = e . nextElement ( ) ; p . put ( o , sys . get ( o ) ) ; } p . putAll ( mergePropertySets ( ) ) ; for ( Enumeration e = variables . elements ( ) ; e . hasMoreElements ( ) ; ) { Environment . Variable v = ( Environment . Variable ) e . nextElement ( ) ; p . put ( v . getKey ( ) , v . getValue ( ) ) ; } System . setProperties ( p ) ; } catch ( SecurityException e ) { throw new BuildException ( "Cannot modify system properties" , e ) ; } } public void restoreSystem ( ) throws BuildException { if ( sys == null ) { throw new BuildException ( "Unbalanced nesting of SysProperties" ) ; } try { System . setProperties ( sys ) ; sys = null ; } catch ( SecurityException e ) { throw new BuildException ( "Cannot modify system properties" , e ) ; } } public Object clone ( ) { try { SysProperties c = ( SysProperties ) super . clone ( ) ; c . variables = ( Vector ) variables . clone ( ) ; c . propertySets = ( Vector ) propertySets . clone ( ) ; return c ; } catch ( CloneNotSupportedException e ) { return null ; } } public void addSyspropertyset ( PropertySet ps ) { propertySets . addElement ( ps ) ; } private Properties mergePropertySets ( ) { Properties p = new Properties ( ) ; for ( Enumeration e = propertySets . elements ( ) ; e . hasMoreElements ( ) ; ) { PropertySet ps = ( PropertySet ) e . nextElement ( ) ; p . putAll ( ps . getProperties ( ) ) ; } return p ; } } public CommandlineJava ( ) { setVm ( JavaEnvUtils . getJreExecutable ( "java" ) ) ; setVmversion ( JavaEnvUtils . getJavaVersion ( ) ) ; } public Commandline . Argument createArgument ( ) { return javaCommand . createArgument ( ) ; } public Commandline . Argument createVmArgument ( ) { return vmCommand . createArgument ( ) ; } public void addSysproperty ( Environment . Variable sysp ) { sysProperties . addVariable ( sysp ) ; } public void addSyspropertyset ( PropertySet sysp ) { sysProperties . addSyspropertyset ( sysp ) ; } public void setVm ( String vm ) { vmCommand . setExecutable ( vm ) ; } public void setVmversion ( String value ) { vmVersion = value ; } public Assertions getAssertions ( ) { return assertions ; } public void setAssertions ( Assertions assertions ) { this . assertions = assertions ; } public void setJar ( String jarpathname ) { javaCommand . setExecutable ( jarpathname ) ; executeJar = true ; } public String getJar ( ) { if ( executeJar ) { return javaCommand . getExecutable ( ) ; } return null ; } public void setClassname ( String classname ) { javaCommand . setExecutable ( classname ) ; executeJar = false ; } public String getClassname ( ) { if ( ! executeJar ) { return javaCommand . getExecutable ( ) ; } return null ; } public Path createClasspath ( Project p ) { if ( classpath == null ) { classpath = new Path ( p ) ; } return classpath ; } public Path createBootclasspath ( Project p ) { if ( bootclasspath == null ) { bootclasspath = new Path ( p ) ; } return bootclasspath ; } public String getVmversion ( ) { return vmVersion ; } public String [ ] getCommandline ( ) { List commands = new LinkedList ( ) ; final ListIterator listIterator = commands . listIterator ( ) ; addCommandsToList ( listIterator ) ; return ( String [ ] ) commands . toArray ( new String [ 0 ] ) ; } private void addCommandsToList ( final ListIterator listIterator ) { getActualVMCommand ( ) . addCommandToList ( listIterator ) ; sysProperties . addDefinitionsToList ( listIterator ) ; if ( haveBootclasspath ( true ) ) { listIterator . add ( "-Xbootclasspath:" + bootclasspath . toString ( ) ) ; } if ( haveClasspath ( ) ) { listIterator . add ( "-classpath" ) ; listIterator . add ( classpath . concatSystemClasspath ( "ignore" ) . toString ( ) ) ; } if ( getAssertions ( ) != null ) { getAssertions ( ) . applyAssertions ( this ) ; } if ( executeJar ) { listIterator . add ( "-jar" ) ; } javaCommand . addCommandToList ( listIterator ) ; } public void setMaxmemory ( String max ) { this . maxMemory = max ; } public String toString ( ) { return Commandline . toString ( getCommandline ( ) ) ; } public String describeCommand ( ) { return Commandline . describeCommand ( getCommandline ( ) ) ; } public String describeJavaCommand ( ) { return Commandline . describeCommand ( getJavaCommand ( ) ) ; } private Commandline getActualVMCommand ( ) { Commandline actualVMCommand = ( Commandline ) vmCommand . clone ( ) ; if ( maxMemory != null ) { if ( vmVersion . startsWith ( "1.1" ) ) { actualVMCommand . createArgument ( ) . setValue ( "-mx" + maxMemory ) ; } else { actualVMCommand . createArgument ( ) . setValue ( "-Xmx" + maxMemory ) ; } } return actualVMCommand ; } public int size ( ) { int size = getActualVMCommand ( ) . size ( ) + javaCommand . size ( ) + sysProperties . size ( ) ; if ( haveClasspath ( ) ) { size += 2 ; } if ( haveBootclasspath ( true ) ) { size ++ ; } if ( executeJar ) { size ++ ; } if ( getAssertions ( ) != null ) { size += getAssertions ( ) . size ( ) ; } return size ; } public Commandline getJavaCommand ( ) { return javaCommand ; } public Commandline getVmCommand ( ) { return getActualVMCommand ( ) ; } public Path getClasspath ( ) { return classpath ; } public Path getBootclasspath ( ) { return bootclasspath ; } public void setSystemProperties ( ) throws BuildException { sysProperties . setSystem ( ) ; } public void restoreSystemProperties ( ) throws BuildException { sysProperties . restoreSystem ( ) ; } public SysProperties getSystemProperties ( ) { return sysProperties ; } public Object clone ( ) { try { CommandlineJava c = ( CommandlineJava ) super . clone ( ) ; c . vmCommand = ( Commandline ) vmCommand . clone ( ) ; c . javaCommand = ( Commandline ) javaCommand . clone ( ) ; c . sysProperties = ( SysProperties ) sysProperties . clone ( ) ; if ( classpath != null ) { c . classpath = ( Path ) classpath . clone ( ) ; } if ( bootclasspath != null ) { c . bootclasspath = ( Path ) bootclasspath . clone ( ) ; } if ( assertions != null ) { c . assertions = ( Assertions ) assertions . clone ( ) ; } return c ; } catch ( CloneNotSupportedException e ) { throw new BuildException ( e ) ; } } public void clearJavaArgs ( ) { javaCommand . clearArgs ( ) ; } private boolean haveClasspath ( ) { Path fullClasspath = classpath != null ? classpath . concatSystemClasspath ( "ignore" ) : null ; return fullClasspath != null && fullClasspath . toString ( ) . trim ( ) . length ( ) > 0 ; } private boolean haveBootclasspath ( boolean log ) { if ( bootclasspath != null && bootclasspath . toString ( ) . trim ( ) . length ( ) > 0 ) { if ( ! bootclasspath . toString ( ) . equals ( bootclasspath . concatSystemClasspath ( "ignore" ) . toString ( ) ) ) { if ( log ) { System . out . println ( "Ignoring bootclasspath as " + "build.sysclasspath has been set." ) ; } } else if ( vmVersion . startsWith ( "1.1" ) ) { if ( log ) { System . out . println ( "Ignoring bootclasspath as " + "the target VM doesn't support it." ) ; } } else { return true ; } } return false ; } } 	1	['35', '1', '0', '12', '79', '333', '2', '11', '31', '0.751633987', '487', '1', '6', '0', '0.167857143', '0', '0', '12.65714286', '7', '1.7143', '3']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; public class IsSet extends ProjectComponent implements Condition { private String property ; public void setProperty ( String p ) { property = p ; } public boolean eval ( ) throws BuildException { if ( property == null ) { throw new BuildException ( "No property specified for isset " + "condition" ) ; } return getProject ( ) . getProperty ( property ) != null ; } } 	0	['3', '2', '0', '5', '7', '1', '1', '4', '3', '0.5', '29', '1', '0', '0.818181818', '0.666666667', '0', '0', '8.333333333', '1', '0.6667', '0']
package org . apache . tools . ant ; import java . io . File ; import java . io . IOException ; import java . util . Arrays ; import java . util . Enumeration ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Hashtable ; import java . util . Map ; import java . util . Set ; import java . util . Vector ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceFactory ; import org . apache . tools . ant . types . selectors . FileSelector ; import org . apache . tools . ant . types . selectors . SelectorScanner ; import org . apache . tools . ant . types . selectors . SelectorUtils ; import org . apache . tools . ant . util . FileUtils ; public class DirectoryScanner implements FileScanner , SelectorScanner , ResourceFactory { private static final boolean ON_VMS = Os . isFamily ( "openvms" ) ; protected static final String [ ] DEFAULTEXCLUDES = { "**/*~" , "**/#*#" , "**/.#*" , "**/%*%" , "**/._*" , "**/CVS" , "**/CVS/**" , "**/.cvsignore" , "**/SCCS" , "**/SCCS/**" , "**/vssver.scc" , "**/.svn" , "**/.svn/**" , "**/.DS_Store" } ; private static Vector defaultExcludes = new Vector ( ) ; static { resetDefaultExcludes ( ) ; } protected File basedir ; protected String [ ] includes ; protected String [ ] excludes ; protected FileSelector [ ] selectors = null ; protected Vector filesIncluded ; protected Vector filesNotIncluded ; protected Vector filesExcluded ; protected Vector dirsIncluded ; protected Vector dirsNotIncluded ; protected Vector dirsExcluded ; protected Vector filesDeselected ; protected Vector dirsDeselected ; protected boolean haveSlowResults = false ; protected boolean isCaseSensitive = true ; private boolean followSymlinks = true ; private static final FileUtils fileUtils = FileUtils . newFileUtils ( ) ; protected boolean everythingIncluded = true ; public DirectoryScanner ( ) { } protected static boolean matchPatternStart ( String pattern , String str ) { return SelectorUtils . matchPatternStart ( pattern , str ) ; } protected static boolean matchPatternStart ( String pattern , String str , boolean isCaseSensitive ) { return SelectorUtils . matchPatternStart ( pattern , str , isCaseSensitive ) ; } protected static boolean matchPath ( String pattern , String str ) { return SelectorUtils . matchPath ( pattern , str ) ; } protected static boolean matchPath ( String pattern , String str , boolean isCaseSensitive ) { return SelectorUtils . matchPath ( pattern , str , isCaseSensitive ) ; } public static boolean match ( String pattern , String str ) { return SelectorUtils . match ( pattern , str ) ; } protected static boolean match ( String pattern , String str , boolean isCaseSensitive ) { return SelectorUtils . match ( pattern , str , isCaseSensitive ) ; } public static String [ ] getDefaultExcludes ( ) { return ( String [ ] ) defaultExcludes . toArray ( new String [ defaultExcludes . size ( ) ] ) ; } public static boolean addDefaultExclude ( String s ) { if ( defaultExcludes . indexOf ( s ) == - 1 ) { defaultExcludes . add ( s ) ; return true ; } return false ; } public static boolean removeDefaultExclude ( String s ) { return defaultExcludes . remove ( s ) ; } public static void resetDefaultExcludes ( ) { defaultExcludes = new Vector ( ) ; for ( int i = 0 ; i < DEFAULTEXCLUDES . length ; i ++ ) { defaultExcludes . add ( DEFAULTEXCLUDES [ i ] ) ; } } public void setBasedir ( String basedir ) { setBasedir ( new File ( basedir . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ) ) ; } public void setBasedir ( File basedir ) { this . basedir = basedir ; } public File getBasedir ( ) { return basedir ; } public boolean isCaseSensitive ( ) { return isCaseSensitive ; } public void setCaseSensitive ( boolean isCaseSensitive ) { this . isCaseSensitive = isCaseSensitive ; } public boolean isFollowSymlinks ( ) { return followSymlinks ; } public void setFollowSymlinks ( boolean followSymlinks ) { this . followSymlinks = followSymlinks ; } public void setIncludes ( String [ ] includes ) { if ( includes == null ) { this . includes = null ; } else { this . includes = new String [ includes . length ] ; for ( int i = 0 ; i < includes . length ; i ++ ) { String pattern ; pattern = includes [ i ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( pattern . endsWith ( File . separator ) ) { pattern += "**" ; } this . includes [ i ] = pattern ; } } } public void setExcludes ( String [ ] excludes ) { if ( excludes == null ) { this . excludes = null ; } else { this . excludes = new String [ excludes . length ] ; for ( int i = 0 ; i < excludes . length ; i ++ ) { String pattern ; pattern = excludes [ i ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( pattern . endsWith ( File . separator ) ) { pattern += "**" ; } this . excludes [ i ] = pattern ; } } } public void setSelectors ( FileSelector [ ] selectors ) { this . selectors = selectors ; } public boolean isEverythingIncluded ( ) { return everythingIncluded ; } public void scan ( ) throws IllegalStateException { if ( basedir == null ) { throw new IllegalStateException ( "No basedir set" ) ; } if ( ! basedir . exists ( ) ) { throw new IllegalStateException ( "basedir " + basedir + " does not exist" ) ; } if ( ! basedir . isDirectory ( ) ) { throw new IllegalStateException ( "basedir " + basedir + " is not a directory" ) ; } if ( includes == null ) { includes = new String [ 1 ] ; includes [ 0 ] = "**" ; } if ( excludes == null ) { excludes = new String [ 0 ] ; } filesIncluded = new Vector ( ) ; filesNotIncluded = new Vector ( ) ; filesExcluded = new Vector ( ) ; filesDeselected = new Vector ( ) ; dirsIncluded = new Vector ( ) ; dirsNotIncluded = new Vector ( ) ; dirsExcluded = new Vector ( ) ; dirsDeselected = new Vector ( ) ; if ( isIncluded ( "" ) ) { if ( ! isExcluded ( "" ) ) { if ( isSelected ( "" , basedir ) ) { dirsIncluded . addElement ( "" ) ; } else { dirsDeselected . addElement ( "" ) ; } } else { dirsExcluded . addElement ( "" ) ; } } else { dirsNotIncluded . addElement ( "" ) ; } checkIncludePatterns ( ) ; clearCaches ( ) ; } private void checkIncludePatterns ( ) { Hashtable newroots = new Hashtable ( ) ; for ( int icounter = 0 ; icounter < includes . length ; icounter ++ ) { String newpattern = SelectorUtils . rtrimWildcardTokens ( includes [ icounter ] ) ; newroots . put ( newpattern , includes [ icounter ] ) ; } if ( newroots . containsKey ( "" ) ) { scandir ( basedir , "" , true ) ; } else { Enumeration enum2 = newroots . keys ( ) ; File canonBase = null ; try { canonBase = basedir . getCanonicalFile ( ) ; } catch ( IOException ex ) { throw new BuildException ( ex ) ; } while ( enum2 . hasMoreElements ( ) ) { String currentelement = ( String ) enum2 . nextElement ( ) ; String originalpattern = ( String ) newroots . get ( currentelement ) ; File myfile = new File ( basedir , currentelement ) ; if ( myfile . exists ( ) ) { try { File canonFile = myfile . getCanonicalFile ( ) ; String path = fileUtils . removeLeadingPath ( canonBase , canonFile ) ; if ( ! path . equals ( currentelement ) || ON_VMS ) { myfile = findFile ( basedir , currentelement ) ; if ( myfile != null ) { currentelement = fileUtils . removeLeadingPath ( basedir , myfile ) ; } } } catch ( IOException ex ) { throw new BuildException ( ex ) ; } } if ( ( myfile == null || ! myfile . exists ( ) ) && ! isCaseSensitive ) { File f = findFileCaseInsensitive ( basedir , currentelement ) ; if ( f . exists ( ) ) { currentelement = fileUtils . removeLeadingPath ( basedir , f ) ; myfile = f ; } } if ( myfile != null && myfile . exists ( ) ) { if ( ! followSymlinks && isSymlink ( basedir , currentelement ) ) { continue ; } if ( myfile . isDirectory ( ) ) { if ( isIncluded ( currentelement ) && currentelement . length ( ) > 0 ) { accountForIncludedDir ( currentelement , myfile , true ) ; } else { if ( currentelement . length ( ) > 0 ) { if ( currentelement . charAt ( currentelement . length ( ) - 1 ) != File . separatorChar ) { currentelement = currentelement + File . separatorChar ; } } scandir ( myfile , currentelement , true ) ; } } else { if ( isCaseSensitive && originalpattern . equals ( currentelement ) ) { accountForIncludedFile ( currentelement , myfile ) ; } else if ( ! isCaseSensitive && originalpattern . equalsIgnoreCase ( currentelement ) ) { accountForIncludedFile ( currentelement , myfile ) ; } } } } } } protected void slowScan ( ) { if ( haveSlowResults ) { return ; } String [ ] excl = new String [ dirsExcluded . size ( ) ] ; dirsExcluded . copyInto ( excl ) ; String [ ] notIncl = new String [ dirsNotIncluded . size ( ) ] ; dirsNotIncluded . copyInto ( notIncl ) ; for ( int i = 0 ; i < excl . length ; i ++ ) { if ( ! couldHoldIncluded ( excl [ i ] ) ) { scandir ( new File ( basedir , excl [ i ] ) , excl [ i ] + File . separator , false ) ; } } for ( int i = 0 ; i < notIncl . length ; i ++ ) { if ( ! couldHoldIncluded ( notIncl [ i ] ) ) { scandir ( new File ( basedir , notIncl [ i ] ) , notIncl [ i ] + File . separator , false ) ; } } haveSlowResults = true ; } protected void scandir ( File dir , String vpath , boolean fast ) { if ( fast && hasBeenScanned ( vpath ) ) { return ; } String [ ] newfiles = dir . list ( ) ; if ( newfiles == null ) { throw new BuildException ( "IO error scanning directory " + dir . getAbsolutePath ( ) ) ; } if ( ! followSymlinks ) { Vector noLinks = new Vector ( ) ; for ( int i = 0 ; i < newfiles . length ; i ++ ) { try { if ( fileUtils . isSymbolicLink ( dir , newfiles [ i ] ) ) { String name = vpath + newfiles [ i ] ; File file = new File ( dir , newfiles [ i ] ) ; if ( file . isDirectory ( ) ) { dirsExcluded . addElement ( name ) ; } else { filesExcluded . addElement ( name ) ; } } else { noLinks . addElement ( newfiles [ i ] ) ; } } catch ( IOException ioe ) { String msg = "IOException caught while checking " + "for links, couldn't get canonical path!" ; System . err . println ( msg ) ; noLinks . addElement ( newfiles [ i ] ) ; } } newfiles = new String [ noLinks . size ( ) ] ; noLinks . copyInto ( newfiles ) ; } for ( int i = 0 ; i < newfiles . length ; i ++ ) { String name = vpath + newfiles [ i ] ; File file = new File ( dir , newfiles [ i ] ) ; if ( file . isDirectory ( ) ) { if ( isIncluded ( name ) ) { accountForIncludedDir ( name , file , fast ) ; } else { everythingIncluded = false ; dirsNotIncluded . addElement ( name ) ; if ( fast && couldHoldIncluded ( name ) ) { scandir ( file , name + File . separator , fast ) ; } } if ( ! fast ) { scandir ( file , name + File . separator , fast ) ; } } else if ( file . isFile ( ) ) { if ( isIncluded ( name ) ) { accountForIncludedFile ( name , file ) ; } else { everythingIncluded = false ; filesNotIncluded . addElement ( name ) ; } } } } private void accountForIncludedFile ( String name , File file ) { if ( ! filesIncluded . contains ( name ) && ! filesExcluded . contains ( name ) && ! filesDeselected . contains ( name ) ) { if ( ! isExcluded ( name ) ) { if ( isSelected ( name , file ) ) { filesIncluded . addElement ( name ) ; } else { everythingIncluded = false ; filesDeselected . addElement ( name ) ; } } else { everythingIncluded = false ; filesExcluded . addElement ( name ) ; } } } private void accountForIncludedDir ( String name , File file , boolean fast ) { if ( ! dirsIncluded . contains ( name ) && ! dirsExcluded . contains ( name ) && ! dirsDeselected . contains ( name ) ) { if ( ! isExcluded ( name ) ) { if ( isSelected ( name , file ) ) { dirsIncluded . addElement ( name ) ; if ( fast ) { scandir ( file , name + File . separator , fast ) ; } } else { everythingIncluded = false ; dirsDeselected . addElement ( name ) ; if ( fast && couldHoldIncluded ( name ) ) { scandir ( file , name + File . separator , fast ) ; } } } else { everythingIncluded = false ; dirsExcluded . addElement ( name ) ; if ( fast && couldHoldIncluded ( name ) ) { scandir ( file , name + File . separator , fast ) ; } } } } protected boolean isIncluded ( String name ) { for ( int i = 0 ; i < includes . length ; i ++ ) { if ( matchPath ( includes [ i ] , name , isCaseSensitive ) ) { return true ; } } return false ; } protected boolean couldHoldIncluded ( String name ) { for ( int i = 0 ; i < includes . length ; i ++ ) { if ( matchPatternStart ( includes [ i ] , name , isCaseSensitive ) ) { if ( isMorePowerfulThanExcludes ( name , includes [ i ] ) ) { return true ; } } } return false ; } private boolean isMorePowerfulThanExcludes ( String name , String includepattern ) { String soughtexclude = name + File . separator + "**" ; for ( int counter = 0 ; counter < excludes . length ; counter ++ ) { if ( excludes [ counter ] . equals ( soughtexclude ) ) { return false ; } } return true ; } protected boolean isExcluded ( String name ) { for ( int i = 0 ; i < excludes . length ; i ++ ) { if ( matchPath ( excludes [ i ] , name , isCaseSensitive ) ) { return true ; } } return false ; } protected boolean isSelected ( String name , File file ) { if ( selectors != null ) { for ( int i = 0 ; i < selectors . length ; i ++ ) { if ( ! selectors [ i ] . isSelected ( basedir , name , file ) ) { return false ; } } } return true ; } public String [ ] getIncludedFiles ( ) { String [ ] files = new String [ filesIncluded . size ( ) ] ; filesIncluded . copyInto ( files ) ; Arrays . sort ( files ) ; return files ; } public String [ ] getNotIncludedFiles ( ) { slowScan ( ) ; String [ ] files = new String [ filesNotIncluded . size ( ) ] ; filesNotIncluded . copyInto ( files ) ; return files ; } public String [ ] getExcludedFiles ( ) { slowScan ( ) ; String [ ] files = new String [ filesExcluded . size ( ) ] ; filesExcluded . copyInto ( files ) ; return files ; } public String [ ] getDeselectedFiles ( ) { slowScan ( ) ; String [ ] files = new String [ filesDeselected . size ( ) ] ; filesDeselected . copyInto ( files ) ; return files ; } public String [ ] getIncludedDirectories ( ) { String [ ] directories = new String [ dirsIncluded . size ( ) ] ; dirsIncluded . copyInto ( directories ) ; Arrays . sort ( directories ) ; return directories ; } public String [ ] getNotIncludedDirectories ( ) { slowScan ( ) ; String [ ] directories = new String [ dirsNotIncluded . size ( ) ] ; dirsNotIncluded . copyInto ( directories ) ; return directories ; } public String [ ] getExcludedDirectories ( ) { slowScan ( ) ; String [ ] directories = new String [ dirsExcluded . size ( ) ] ; dirsExcluded . copyInto ( directories ) ; return directories ; } public String [ ] getDeselectedDirectories ( ) { slowScan ( ) ; String [ ] directories = new String [ dirsDeselected . size ( ) ] ; dirsDeselected . copyInto ( directories ) ; return directories ; } public void addDefaultExcludes ( ) { int excludesLength = excludes == null ? 0 : excludes . length ; String [ ] newExcludes ; newExcludes = new String [ excludesLength + defaultExcludes . size ( ) ] ; if ( excludesLength > 0 ) { System . arraycopy ( excludes , 0 , newExcludes , 0 , excludesLength ) ; } String [ ] defaultExcludesTemp = getDefaultExcludes ( ) ; for ( int i = 0 ; i < defaultExcludesTemp . length ; i ++ ) { newExcludes [ i + excludesLength ] = defaultExcludesTemp [ i ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; } excludes = newExcludes ; } public Resource getResource ( String name ) { File f = fileUtils . resolveFile ( basedir , name ) ; return new Resource ( name , f . exists ( ) , f . lastModified ( ) , f . isDirectory ( ) ) ; } private Map fileListMap = new HashMap ( ) ; private String [ ] list ( File file ) { String [ ] files = ( String [ ] ) fileListMap . get ( file ) ; if ( files == null ) { files = file . list ( ) ; if ( files != null ) { fileListMap . put ( file , files ) ; } } return files ; } private File findFileCaseInsensitive ( File base , String path ) { File f = findFileCaseInsensitive ( base , SelectorUtils . tokenizePath ( path ) ) ; return f == null ? new File ( base , path ) : f ; } private File findFileCaseInsensitive ( File base , Vector pathElements ) { if ( pathElements . size ( ) == 0 ) { return base ; } else { if ( ! base . isDirectory ( ) ) { return null ; } String [ ] files = list ( base ) ; if ( files == null ) { throw new BuildException ( "IO error scanning directory " + base . getAbsolutePath ( ) ) ; } String current = ( String ) pathElements . remove ( 0 ) ; for ( int i = 0 ; i < files . length ; i ++ ) { if ( files [ i ] . equals ( current ) ) { base = new File ( base , files [ i ] ) ; return findFileCaseInsensitive ( base , pathElements ) ; } } for ( int i = 0 ; i < files . length ; i ++ ) { if ( files [ i ] . equalsIgnoreCase ( current ) ) { base = new File ( base , files [ i ] ) ; return findFileCaseInsensitive ( base , pathElements ) ; } } } return null ; } private File findFile ( File base , String path ) { return findFile ( base , SelectorUtils . tokenizePath ( path ) ) ; } private File findFile ( File base , Vector pathElements ) { if ( pathElements . size ( ) == 0 ) { return base ; } else { if ( ! base . isDirectory ( ) ) { return null ; } String [ ] files = list ( base ) ; if ( files == null ) { throw new BuildException ( "IO error scanning directory " + base . getAbsolutePath ( ) ) ; } String current = ( String ) pathElements . remove ( 0 ) ; for ( int i = 0 ; i < files . length ; i ++ ) { if ( files [ i ] . equals ( current ) ) { base = new File ( base , files [ i ] ) ; return findFile ( base , pathElements ) ; } } } return null ; } private boolean isSymlink ( File base , String path ) { return isSymlink ( base , SelectorUtils . tokenizePath ( path ) ) ; } private boolean isSymlink ( File base , Vector pathElements ) { if ( pathElements . size ( ) > 0 ) { String current = ( String ) pathElements . remove ( 0 ) ; try { if ( fileUtils . isSymbolicLink ( base , current ) ) { return true ; } else { base = new File ( base , current ) ; return isSymlink ( base , pathElements ) ; } } catch ( IOException ioe ) { String msg = "IOException caught while checking " + "for links, couldn't get canonical path!" ; System . err . println ( msg ) ; return false ; } } return false ; } private Set scannedDirs = new HashSet ( ) ; private boolean hasBeenScanned ( String vpath ) { return ! scannedDirs . add ( vpath ) ; } private void clearCaches ( ) { fileListMap . clear ( ) ; scannedDirs . clear ( ) ; } } 	1	['53', '1', '1', '37', '119', '1112', '28', '9', '28', '0.842657343', '1739', '1', '2', '0', '0.244505495', '0', '0', '31.39622642', '23', '2.8113', '2']
package org . apache . tools . ant . types . selectors ; public class NotSelector extends NoneSelector { public NotSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{notselect: " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } public void verifySettings ( ) { if ( selectorCount ( ) != 1 ) { setError ( "One and only one selector is allowed within the " + "<not> tag" ) ; } } } 	0	['3', '6', '0', '7', '11', '3', '5', '3', '3', '2', '37', '0', '0', '0.96969697', '1', '2', '3', '11.33333333', '2', '1.3333', '0']
package org . apache . tools . ant . taskdefs ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public class PumpStreamHandler implements ExecuteStreamHandler { private Thread outputThread ; private Thread errorThread ; private Thread inputThread ; private OutputStream out ; private OutputStream err ; private InputStream input ; public PumpStreamHandler ( OutputStream out , OutputStream err , InputStream input ) { this . out = out ; this . err = err ; this . input = input ; } public PumpStreamHandler ( OutputStream out , OutputStream err ) { this ( out , err , null ) ; } public PumpStreamHandler ( OutputStream outAndErr ) { this ( outAndErr , outAndErr ) ; } public PumpStreamHandler ( ) { this ( System . out , System . err ) ; } public void setProcessOutputStream ( InputStream is ) { createProcessOutputPump ( is , out ) ; } public void setProcessErrorStream ( InputStream is ) { if ( err != null ) { createProcessErrorPump ( is , err ) ; } } public void setProcessInputStream ( OutputStream os ) { if ( input != null ) { inputThread = createPump ( input , os , true ) ; } else { try { os . close ( ) ; } catch ( IOException e ) { } } } public void start ( ) { outputThread . start ( ) ; errorThread . start ( ) ; if ( inputThread != null ) { inputThread . start ( ) ; } } public void stop ( ) { try { outputThread . join ( ) ; } catch ( InterruptedException e ) { } try { errorThread . join ( ) ; } catch ( InterruptedException e ) { } if ( inputThread != null ) { try { inputThread . join ( ) ; } catch ( InterruptedException e ) { } } try { err . flush ( ) ; } catch ( IOException e ) { } try { out . flush ( ) ; } catch ( IOException e ) { } } protected OutputStream getErr ( ) { return err ; } protected OutputStream getOut ( ) { return out ; } protected void createProcessOutputPump ( InputStream is , OutputStream os ) { outputThread = createPump ( is , os ) ; } protected void createProcessErrorPump ( InputStream is , OutputStream os ) { errorThread = createPump ( is , os ) ; } protected Thread createPump ( InputStream is , OutputStream os ) { return createPump ( is , os , false ) ; } protected Thread createPump ( InputStream is , OutputStream os , boolean closeWhenExhausted ) { final Thread result = new Thread ( new StreamPumper ( is , os , closeWhenExhausted ) ) ; result . setDaemon ( true ) ; return result ; } } 	1	['15', '1', '2', '8', '23', '67', '6', '2', '9', '0.714285714', '170', '1', '0', '0', '0.516666667', '0', '0', '9.933333333', '2', '1', '1']
package org . apache . tools . ant . types ; import java . lang . reflect . Method ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . Enumeration ; import java . util . Stack ; import java . util . Vector ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParserFactory ; import javax . xml . transform . Source ; import javax . xml . transform . TransformerException ; import javax . xml . transform . URIResolver ; import javax . xml . transform . sax . SAXSource ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JAXPUtils ; import org . xml . sax . EntityResolver ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; public class XMLCatalog extends DataType implements Cloneable , EntityResolver , URIResolver { private static FileUtils fileUtils = FileUtils . newFileUtils ( ) ; private Vector elements = new Vector ( ) ; private Path classpath ; private Path catalogPath ; public static final String APACHE_RESOLVER = "org.apache.tools.ant.types.resolver.ApacheCatalogResolver" ; public static final String CATALOG_RESOLVER = "org.apache.xml.resolver.tools.CatalogResolver" ; public XMLCatalog ( ) { setChecked ( false ) ; } private Vector getElements ( ) { return getRef ( ) . elements ; } private Path getClasspath ( ) { return getRef ( ) . classpath ; } private void setElements ( Vector aVector ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } elements = aVector ; } public Path createClasspath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } setChecked ( false ) ; return this . classpath . createPath ( ) ; } public void setClasspath ( Path classpath ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } setChecked ( false ) ; } public void setClasspathRef ( Reference r ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createClasspath ( ) . setRefid ( r ) ; setChecked ( false ) ; } public Path createCatalogPath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . catalogPath == null ) { this . catalogPath = new Path ( getProject ( ) ) ; } setChecked ( false ) ; return this . catalogPath . createPath ( ) ; } public void setCatalogPathRef ( Reference r ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createCatalogPath ( ) . setRefid ( r ) ; setChecked ( false ) ; } public Path getCatalogPath ( ) { return getRef ( ) . catalogPath ; } public void addDTD ( ResourceLocation dtd ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } getElements ( ) . addElement ( dtd ) ; setChecked ( false ) ; } public void addEntity ( ResourceLocation entity ) throws BuildException { addDTD ( entity ) ; } public void addConfiguredXMLCatalog ( XMLCatalog catalog ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } Vector newElements = catalog . getElements ( ) ; Vector ourElements = getElements ( ) ; Enumeration e = newElements . elements ( ) ; while ( e . hasMoreElements ( ) ) { ourElements . addElement ( e . nextElement ( ) ) ; } Path nestedClasspath = catalog . getClasspath ( ) ; createClasspath ( ) . append ( nestedClasspath ) ; Path nestedCatalogPath = catalog . getCatalogPath ( ) ; createCatalogPath ( ) . append ( nestedCatalogPath ) ; setChecked ( false ) ; } public void setRefid ( Reference r ) throws BuildException { if ( ! elements . isEmpty ( ) ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public InputSource resolveEntity ( String publicId , String systemId ) throws SAXException , IOException { if ( isReference ( ) ) { return getRef ( ) . resolveEntity ( publicId , systemId ) ; } if ( ! isChecked ( ) ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , getProject ( ) ) ; } log ( "resolveEntity: '" + publicId + "': '" + systemId + "'" , Project . MSG_DEBUG ) ; InputSource inputSource = getCatalogResolver ( ) . resolveEntity ( publicId , systemId ) ; if ( inputSource == null ) { log ( "No matching catalog entry found, parser will use: '" + systemId + "'" , Project . MSG_DEBUG ) ; } return inputSource ; } public Source resolve ( String href , String base ) throws TransformerException { if ( isReference ( ) ) { return getRef ( ) . resolve ( href , base ) ; } if ( ! isChecked ( ) ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , getProject ( ) ) ; } SAXSource source = null ; String uri = removeFragment ( href ) ; log ( "resolve: '" + uri + "' with base: '" + base + "'" , Project . MSG_DEBUG ) ; source = ( SAXSource ) getCatalogResolver ( ) . resolve ( uri , base ) ; if ( source == null ) { log ( "No matching catalog entry found, parser will use: '" + href + "'" , Project . MSG_DEBUG ) ; source = new SAXSource ( ) ; URL baseURL = null ; try { if ( base == null ) { baseURL = fileUtils . getFileURL ( getProject ( ) . getBaseDir ( ) ) ; } else { baseURL = new URL ( base ) ; } URL url = ( uri . length ( ) == 0 ? baseURL : new URL ( baseURL , uri ) ) ; source . setInputSource ( new InputSource ( url . toString ( ) ) ) ; } catch ( MalformedURLException ex ) { source . setInputSource ( new InputSource ( uri ) ) ; } } setEntityResolver ( source ) ; return source ; } private XMLCatalog getRef ( ) { if ( ! isReference ( ) ) { return this ; } return ( XMLCatalog ) getCheckedRef ( XMLCatalog . class , "xmlcatalog" ) ; } private CatalogResolver catalogResolver = null ; private CatalogResolver getCatalogResolver ( ) { if ( catalogResolver == null ) { AntClassLoader loader = null ; loader = getProject ( ) . createClassLoader ( Path . systemClasspath ) ; try { Class clazz = Class . forName ( APACHE_RESOLVER , true , loader ) ; ClassLoader apacheResolverLoader = clazz . getClassLoader ( ) ; Class baseResolverClass = Class . forName ( CATALOG_RESOLVER , true , apacheResolverLoader ) ; ClassLoader baseResolverLoader = baseResolverClass . getClassLoader ( ) ; clazz = Class . forName ( APACHE_RESOLVER , true , baseResolverLoader ) ; Object obj = clazz . newInstance ( ) ; catalogResolver = new ExternalResolver ( clazz , obj ) ; } catch ( Throwable ex ) { catalogResolver = new InternalResolver ( ) ; if ( getCatalogPath ( ) != null && getCatalogPath ( ) . list ( ) . length != 0 ) { log ( "Warning: catalogpath listing external catalogs" + " will be ignored" , Project . MSG_WARN ) ; } log ( "Failed to load Apache resolver: " + ex , Project . MSG_DEBUG ) ; } } return catalogResolver ; } private void setEntityResolver ( SAXSource source ) throws TransformerException { XMLReader reader = source . getXMLReader ( ) ; if ( reader == null ) { SAXParserFactory spFactory = SAXParserFactory . newInstance ( ) ; spFactory . setNamespaceAware ( true ) ; try { reader = spFactory . newSAXParser ( ) . getXMLReader ( ) ; } catch ( ParserConfigurationException ex ) { throw new TransformerException ( ex ) ; } catch ( SAXException ex ) { throw new TransformerException ( ex ) ; } } reader . setEntityResolver ( this ) ; source . setXMLReader ( reader ) ; } private ResourceLocation findMatchingEntry ( String publicId ) { Enumeration e = getElements ( ) . elements ( ) ; ResourceLocation element = null ; while ( e . hasMoreElements ( ) ) { Object o = e . nextElement ( ) ; if ( o instanceof ResourceLocation ) { element = ( ResourceLocation ) o ; if ( element . getPublicId ( ) . equals ( publicId ) ) { return element ; } } } return null ; } private String removeFragment ( String uri ) { String result = uri ; int hashPos = uri . indexOf ( "#" ) ; if ( hashPos >= 0 ) { result = uri . substring ( 0 , hashPos ) ; } return result ; } private InputSource filesystemLookup ( ResourceLocation matchingEntry ) { String uri = matchingEntry . getLocation ( ) ; uri = uri . replace ( File . separatorChar , '/' ) ; URL baseURL = null ; if ( matchingEntry . getBase ( ) != null ) { baseURL = matchingEntry . getBase ( ) ; } else { try { baseURL = fileUtils . getFileURL ( getProject ( ) . getBaseDir ( ) ) ; } catch ( MalformedURLException ex ) { throw new BuildException ( "Project basedir cannot be converted to a URL" ) ; } } InputSource source = null ; URL url = null ; try { url = new URL ( baseURL , uri ) ; } catch ( MalformedURLException ex ) { File testFile = new File ( uri ) ; if ( testFile . exists ( ) && testFile . canRead ( ) ) { log ( "uri : '" + uri + "' matches a readable file" , Project . MSG_DEBUG ) ; try { url = fileUtils . getFileURL ( testFile ) ; } catch ( MalformedURLException ex1 ) { throw new BuildException ( "could not find an URL for :" + testFile . getAbsolutePath ( ) ) ; } } else { log ( "uri : '" + uri + "' does not match a readable file" , Project . MSG_DEBUG ) ; } } if ( url != null ) { String fileName = url . getFile ( ) ; if ( fileName != null ) { log ( "fileName " + fileName , Project . MSG_DEBUG ) ; File resFile = new File ( fileName ) ; if ( resFile . exists ( ) && resFile . canRead ( ) ) { try { source = new InputSource ( new FileInputStream ( resFile ) ) ; String sysid = JAXPUtils . getSystemId ( resFile ) ; source . setSystemId ( sysid ) ; log ( "catalog entry matched a readable file: '" + sysid + "'" , Project . MSG_DEBUG ) ; } catch ( IOException ex ) { } } } } return source ; } private InputSource classpathLookup ( ResourceLocation matchingEntry ) { InputSource source = null ; AntClassLoader loader = null ; Path cp = classpath ; if ( cp != null ) { cp = classpath . concatSystemClasspath ( "ignore" ) ; } else { cp = ( new Path ( getProject ( ) ) ) . concatSystemClasspath ( "last" ) ; } loader = getProject ( ) . createClassLoader ( cp ) ; InputStream is = loader . getResourceAsStream ( matchingEntry . getLocation ( ) ) ; if ( is != null ) { source = new InputSource ( is ) ; URL entryURL = loader . getResource ( matchingEntry . getLocation ( ) ) ; String sysid = entryURL . toExternalForm ( ) ; source . setSystemId ( sysid ) ; log ( "catalog entry matched a resource in the classpath: '" + sysid + "'" , Project . MSG_DEBUG ) ; } return source ; } private InputSource urlLookup ( ResourceLocation matchingEntry ) { String uri = matchingEntry . getLocation ( ) ; URL baseURL = null ; if ( matchingEntry . getBase ( ) != null ) { baseURL = matchingEntry . getBase ( ) ; } else { try { baseURL = fileUtils . getFileURL ( getProject ( ) . getBaseDir ( ) ) ; } catch ( MalformedURLException ex ) { throw new BuildException ( "Project basedir cannot be converted to a URL" ) ; } } InputSource source = null ; URL url = null ; try { url = new URL ( baseURL , uri ) ; } catch ( MalformedURLException ex ) { } if ( url != null ) { try { InputStream is = url . openStream ( ) ; if ( is != null ) { source = new InputSource ( is ) ; String sysid = url . toExternalForm ( ) ; source . setSystemId ( sysid ) ; log ( "catalog entry matched as a URL: '" + sysid + "'" , Project . MSG_DEBUG ) ; } } catch ( IOException ex ) { } } return source ; } private interface CatalogResolver extends URIResolver , EntityResolver { InputSource resolveEntity ( String publicId , String systemId ) ; Source resolve ( String href , String base ) throws TransformerException ; } private class InternalResolver implements CatalogResolver { public InternalResolver ( ) { log ( "Apache resolver library not found, internal resolver will be used" , Project . MSG_VERBOSE ) ; } public InputSource resolveEntity ( String publicId , String systemId ) { InputSource result = null ; ResourceLocation matchingEntry = findMatchingEntry ( publicId ) ; if ( matchingEntry != null ) { log ( "Matching catalog entry found for publicId: '" + matchingEntry . getPublicId ( ) + "' location: '" + matchingEntry . getLocation ( ) + "'" , Project . MSG_DEBUG ) ; result = filesystemLookup ( matchingEntry ) ; if ( result == null ) { result = classpathLookup ( matchingEntry ) ; } if ( result == null ) { result = urlLookup ( matchingEntry ) ; } } return result ; } public Source resolve ( String href , String base ) throws TransformerException { SAXSource result = null ; InputSource source = null ; ResourceLocation matchingEntry = findMatchingEntry ( href ) ; if ( matchingEntry != null ) { log ( "Matching catalog entry found for uri: '" + matchingEntry . getPublicId ( ) + "' location: '" + matchingEntry . getLocation ( ) + "'" , Project . MSG_DEBUG ) ; ResourceLocation entryCopy = matchingEntry ; if ( base != null ) { try { URL baseURL = new URL ( base ) ; entryCopy = new ResourceLocation ( ) ; entryCopy . setBase ( baseURL ) ; } catch ( MalformedURLException ex ) { } } entryCopy . setPublicId ( matchingEntry . getPublicId ( ) ) ; entryCopy . setLocation ( matchingEntry . getLocation ( ) ) ; source = filesystemLookup ( entryCopy ) ; if ( source == null ) { source = classpathLookup ( entryCopy ) ; } if ( source == null ) { source = urlLookup ( entryCopy ) ; } if ( source != null ) { result = new SAXSource ( source ) ; } } return result ; } } private class ExternalResolver implements CatalogResolver { private Method setXMLCatalog = null ; private Method parseCatalog = null ; private Method resolveEntity = null ; private Method resolve = null ; private Object resolverImpl = null ; private boolean externalCatalogsProcessed = false ; public ExternalResolver ( Class resolverImplClass , Object resolverImpl ) { this . resolverImpl = resolverImpl ; try { setXMLCatalog = resolverImplClass . getMethod ( "setXMLCatalog" , new Class [ ] { XMLCatalog . class } ) ; parseCatalog = resolverImplClass . getMethod ( "parseCatalog" , new Class [ ] { String . class } ) ; resolveEntity = resolverImplClass . getMethod ( "resolveEntity" , new Class [ ] { String . class , String . class } ) ; resolve = resolverImplClass . getMethod ( "resolve" , new Class [ ] { String . class , String . class } ) ; } catch ( NoSuchMethodException ex ) { throw new BuildException ( ex ) ; } log ( "Apache resolver library found, xml-commons resolver will be used" , Project . MSG_VERBOSE ) ; } public InputSource resolveEntity ( String publicId , String systemId ) { InputSource result = null ; processExternalCatalogs ( ) ; ResourceLocation matchingEntry = findMatchingEntry ( publicId ) ; if ( matchingEntry != null ) { log ( "Matching catalog entry found for publicId: '" + matchingEntry . getPublicId ( ) + "' location: '" + matchingEntry . getLocation ( ) + "'" , Project . MSG_DEBUG ) ; result = filesystemLookup ( matchingEntry ) ; if ( result == null ) { result = classpathLookup ( matchingEntry ) ; } if ( result == null ) { try { result = ( InputSource ) resolveEntity . invoke ( resolverImpl , new Object [ ] { publicId , systemId } ) ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } } } else { try { result = ( InputSource ) resolveEntity . invoke ( resolverImpl , new Object [ ] { publicId , systemId } ) ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } } return result ; } public Source resolve ( String href , String base ) throws TransformerException { SAXSource result = null ; InputSource source = null ; processExternalCatalogs ( ) ; ResourceLocation matchingEntry = findMatchingEntry ( href ) ; if ( matchingEntry != null ) { log ( "Matching catalog entry found for uri: '" + matchingEntry . getPublicId ( ) + "' location: '" + matchingEntry . getLocation ( ) + "'" , Project . MSG_DEBUG ) ; ResourceLocation entryCopy = matchingEntry ; if ( base != null ) { try { URL baseURL = new URL ( base ) ; entryCopy = new ResourceLocation ( ) ; entryCopy . setBase ( baseURL ) ; } catch ( MalformedURLException ex ) { } } entryCopy . setPublicId ( matchingEntry . getPublicId ( ) ) ; entryCopy . setLocation ( matchingEntry . getLocation ( ) ) ; source = filesystemLookup ( entryCopy ) ; if ( source == null ) { source = classpathLookup ( entryCopy ) ; } if ( source != null ) { result = new SAXSource ( source ) ; } else { try { result = ( SAXSource ) resolve . invoke ( resolverImpl , new Object [ ] { href , base } ) ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } } } else { try { result = ( SAXSource ) resolve . invoke ( resolverImpl , new Object [ ] { href , base } ) ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } } return result ; } private void processExternalCatalogs ( ) { if ( ! externalCatalogsProcessed ) { try { setXMLCatalog . invoke ( resolverImpl , new Object [ ] { XMLCatalog . this } ) ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } Path catPath = getCatalogPath ( ) ; if ( catPath != null ) { log ( "Using catalogpath '" + getCatalogPath ( ) + "'" , Project . MSG_DEBUG ) ; String [ ] catPathList = getCatalogPath ( ) . list ( ) ; for ( int i = 0 ; i < catPathList . length ; i ++ ) { File catFile = new File ( catPathList [ i ] ) ; log ( "Parsing " + catFile , Project . MSG_DEBUG ) ; try { parseCatalog . invoke ( resolverImpl , new Object [ ] { catFile . getPath ( ) } ) ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } } } } externalCatalogsProcessed = true ; } } } 	0	['30', '3', '0', '15', '109', '395', '4', '13', '13', '0.869731801', '929', '0.555555556', '4', '0.517241379', '0.211206897', '1', '1', '29.66666667', '8', '1.9667', '0']
package org . apache . tools . ant . types ; import java . io . File ; import java . util . Stack ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . zip . UnixStat ; public class ZipFileSet extends FileSet { public static final int DEFAULT_DIR_MODE = UnixStat . DIR_FLAG | UnixStat . DEFAULT_DIR_PERM ; public static final int DEFAULT_FILE_MODE = UnixStat . FILE_FLAG | UnixStat . DEFAULT_FILE_PERM ; private File srcFile = null ; private String prefix = "" ; private String fullpath = "" ; private boolean hasDir = false ; private int fileMode = DEFAULT_FILE_MODE ; private int dirMode = DEFAULT_DIR_MODE ; private boolean fileModeHasBeenSet = false ; private boolean dirModeHasBeenSet = false ; public ZipFileSet ( ) { super ( ) ; } protected ZipFileSet ( FileSet fileset ) { super ( fileset ) ; } protected ZipFileSet ( ZipFileSet fileset ) { super ( fileset ) ; srcFile = fileset . srcFile ; prefix = fileset . prefix ; fullpath = fileset . fullpath ; hasDir = fileset . hasDir ; fileMode = fileset . fileMode ; dirMode = fileset . dirMode ; fileModeHasBeenSet = fileset . fileModeHasBeenSet ; dirModeHasBeenSet = fileset . dirModeHasBeenSet ; } public void setDir ( File dir ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( srcFile != null ) { throw new BuildException ( "Cannot set both dir and src attributes" ) ; } else { super . setDir ( dir ) ; hasDir = true ; } } public void setSrc ( File srcFile ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( hasDir ) { throw new BuildException ( "Cannot set both dir and src attributes" ) ; } this . srcFile = srcFile ; } public File getSrc ( Project p ) { if ( isReference ( ) ) { return ( ( ZipFileSet ) getRef ( p ) ) . getSrc ( p ) ; } return srcFile ; } public void setPrefix ( String prefix ) { if ( ! prefix . equals ( "" ) && ! fullpath . equals ( "" ) ) { throw new BuildException ( "Cannot set both fullpath and prefix attributes" ) ; } this . prefix = prefix ; } public String getPrefix ( Project p ) { if ( isReference ( ) ) { return ( ( ZipFileSet ) getRef ( p ) ) . getPrefix ( p ) ; } return prefix ; } public void setFullpath ( String fullpath ) { if ( ! prefix . equals ( "" ) && ! fullpath . equals ( "" ) ) { throw new BuildException ( "Cannot set both fullpath and prefix attributes" ) ; } this . fullpath = fullpath ; } public String getFullpath ( Project p ) { if ( isReference ( ) ) { return ( ( ZipFileSet ) getRef ( p ) ) . getFullpath ( p ) ; } return fullpath ; } public DirectoryScanner getDirectoryScanner ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getDirectoryScanner ( p ) ; } if ( srcFile != null ) { ZipScanner zs = new ZipScanner ( ) ; zs . setSrc ( srcFile ) ; super . setDir ( p . getBaseDir ( ) ) ; setupDirectoryScanner ( zs , p ) ; zs . init ( ) ; return zs ; } else { return super . getDirectoryScanner ( p ) ; } } public void setFileMode ( String octalString ) { fileModeHasBeenSet = true ; this . fileMode = UnixStat . FILE_FLAG | Integer . parseInt ( octalString , 8 ) ; } public int getFileMode ( Project p ) { if ( isReference ( ) ) { return ( ( ZipFileSet ) getRef ( p ) ) . getFileMode ( p ) ; } return fileMode ; } public boolean hasFileModeBeenSet ( ) { if ( isReference ( ) ) { return ( ( ZipFileSet ) getRef ( getProject ( ) ) ) . hasFileModeBeenSet ( ) ; } return fileModeHasBeenSet ; } public void setDirMode ( String octalString ) { dirModeHasBeenSet = true ; this . dirMode = UnixStat . DIR_FLAG | Integer . parseInt ( octalString , 8 ) ; } public int getDirMode ( Project p ) { if ( isReference ( ) ) { return ( ( ZipFileSet ) getRef ( p ) ) . getDirMode ( p ) ; } return dirMode ; } public boolean hasDirModeBeenSet ( ) { if ( isReference ( ) ) { return ( ( ZipFileSet ) getRef ( getProject ( ) ) ) . hasDirModeBeenSet ( ) ; } return dirModeHasBeenSet ; } protected AbstractFileSet getRef ( Project p ) { if ( ! isChecked ( ) ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , p ) ; } Object o = getRefid ( ) . getReferencedObject ( p ) ; if ( o instanceof ZipFileSet ) { return ( AbstractFileSet ) o ; } else if ( o instanceof FileSet ) { ZipFileSet zfs = new ZipFileSet ( ( FileSet ) o ) ; zfs . setPrefix ( prefix ) ; zfs . setFullpath ( fullpath ) ; zfs . fileModeHasBeenSet = fileModeHasBeenSet ; zfs . fileMode = fileMode ; zfs . dirModeHasBeenSet = dirModeHasBeenSet ; zfs . dirMode = dirMode ; return zfs ; } else { String msg = getRefid ( ) . getRefId ( ) + " doesn\'t denote a zipfileset or a fileset" ; throw new BuildException ( msg ) ; } } public Object clone ( ) { if ( isReference ( ) ) { return ( ( ZipFileSet ) getRef ( getProject ( ) ) ) . clone ( ) ; } else { return super . clone ( ) ; } } } 	1	['19', '5', '0', '14', '45', '25', '4', '10', '16', '0.488888889', '458', '0.8', '0', '0.85046729', '0.298245614', '4', '15', '22.57894737', '4', '1.8421', '3']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . util . Vector ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . types . RegularExpression ; import org . apache . tools . ant . util . regexp . Regexp ; public final class LineContainsRegExp extends BaseParamFilterReader implements ChainableReader { private static final String REGEXP_KEY = "regexp" ; private Vector regexps = new Vector ( ) ; private String line = null ; public LineContainsRegExp ( ) { super ( ) ; } public LineContainsRegExp ( final Reader in ) { super ( in ) ; } public final int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( line != null ) { ch = line . charAt ( 0 ) ; if ( line . length ( ) == 1 ) { line = null ; } else { line = line . substring ( 1 ) ; } } else { line = readLine ( ) ; final int regexpsSize = regexps . size ( ) ; while ( line != null ) { for ( int i = 0 ; i < regexpsSize ; i ++ ) { RegularExpression regexp = ( RegularExpression ) regexps . elementAt ( i ) ; Regexp re = regexp . getRegexp ( getProject ( ) ) ; boolean matches = re . matches ( line ) ; if ( ! matches ) { line = null ; break ; } } if ( line == null ) { line = readLine ( ) ; } else { break ; } } if ( line != null ) { return read ( ) ; } } return ch ; } public final void addConfiguredRegexp ( final RegularExpression regExp ) { this . regexps . addElement ( regExp ) ; } private void setRegexps ( final Vector regexps ) { this . regexps = regexps ; } private final Vector getRegexps ( ) { return regexps ; } public final Reader chain ( final Reader rdr ) { LineContainsRegExp newFilter = new LineContainsRegExp ( rdr ) ; newFilter . setRegexps ( getRegexps ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private final void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( REGEXP_KEY . equals ( params [ i ] . getType ( ) ) ) { String pattern = params [ i ] . getValue ( ) ; RegularExpression regexp = new RegularExpression ( ) ; regexp . setPattern ( pattern ) ; regexps . addElement ( regexp ) ; } } } } } 	0	['8', '5', '0', '9', '29', '0', '1', '8', '5', '0.571428571', '187', '1', '0', '0.823529412', '0.375', '2', '5', '22', '4', '1.125', '0']
package org . apache . tools . ant ; import org . apache . tools . ant . util . LoaderUtils ; import javax . xml . parsers . SAXParserFactory ; import javax . xml . parsers . SAXParser ; import java . io . File ; import java . io . FilenameFilter ; import java . io . PrintStream ; import java . io . InputStream ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Properties ; import java . lang . reflect . Method ; import java . lang . reflect . InvocationTargetException ; public final class Diagnostics { private static final String TEST_CLASS = "org.apache.tools.ant.taskdefs.optional.Test" ; private Diagnostics ( ) { } public static boolean isOptionalAvailable ( ) { try { Class . forName ( TEST_CLASS ) ; } catch ( ClassNotFoundException e ) { return false ; } return true ; } public static void validateVersion ( ) throws BuildException { try { Class optional = Class . forName ( "org.apache.tools.ant.taskdefs.optional.Test" ) ; String coreVersion = getImplementationVersion ( Main . class ) ; String optionalVersion = getImplementationVersion ( optional ) ; if ( coreVersion != null && ! coreVersion . equals ( optionalVersion ) ) { throw new BuildException ( "Invalid implementation version " + "between Ant core and Ant optional tasks.\n" + " core    : " + coreVersion + "\n" + " optional: " + optionalVersion ) ; } } catch ( ClassNotFoundException e ) { } } public static File [ ] listLibraries ( ) { String home = System . getProperty ( "ant.home" ) ; if ( home == null ) { return null ; } File libDir = new File ( home , "lib" ) ; FilenameFilter filter = new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { return name . endsWith ( ".jar" ) ; } } ; String [ ] filenames = libDir . list ( filter ) ; if ( filenames == null ) { return null ; } File [ ] files = new File [ filenames . length ] ; for ( int i = 0 ; i < filenames . length ; i ++ ) { files [ i ] = new File ( libDir , filenames [ i ] ) ; } return files ; } public static void main ( String [ ] args ) { doReport ( System . out ) ; } private static String getImplementationVersion ( Class clazz ) { try { Method method = Class . class . getMethod ( "getPackage" , new Class [ 0 ] ) ; Object pkg = method . invoke ( clazz , null ) ; if ( pkg != null ) { method = pkg . getClass ( ) . getMethod ( "getImplementationVersion" , new Class [ 0 ] ) ; Object version = method . invoke ( pkg , null ) ; return ( String ) version ; } } catch ( Exception e ) { return "?.?" ; } return null ; } private static String getXmlParserName ( ) { SAXParser saxParser = getSAXParser ( ) ; if ( saxParser == null ) { return "Could not create an XML Parser" ; } String saxParserName = saxParser . getClass ( ) . getName ( ) ; return saxParserName ; } private static SAXParser getSAXParser ( ) { SAXParserFactory saxParserFactory = SAXParserFactory . newInstance ( ) ; if ( saxParserFactory == null ) { return null ; } SAXParser saxParser = null ; try { saxParser = saxParserFactory . newSAXParser ( ) ; } catch ( Exception e ) { } return saxParser ; } private static String getXMLParserLocation ( ) { SAXParser saxParser = getSAXParser ( ) ; if ( saxParser == null ) { return null ; } String location = getClassLocation ( saxParser . getClass ( ) ) ; return location ; } private static String getClassLocation ( Class clazz ) { File f = LoaderUtils . getClassSource ( clazz ) ; return f == null ? null : f . getAbsolutePath ( ) ; } public static void doReport ( PrintStream out ) { out . println ( "------- Ant diagnostics report -------" ) ; out . println ( Main . getAntVersion ( ) ) ; out . println ( ) ; out . println ( "-------------------------------------------" ) ; out . println ( " Implementation Version (JDK1.2+ only)" ) ; out . println ( "-------------------------------------------" ) ; out . println ( "core tasks     : " + getImplementationVersion ( Main . class ) ) ; Class optional = null ; try { optional = Class . forName ( "org.apache.tools.ant.taskdefs.optional.Test" ) ; out . println ( "optional tasks : " + getImplementationVersion ( optional ) ) ; } catch ( ClassNotFoundException e ) { out . println ( "optional tasks : not available" ) ; } out . println ( ) ; out . println ( "-------------------------------------------" ) ; out . println ( " ANT_HOME/lib jar listing" ) ; out . println ( "-------------------------------------------" ) ; doReportLibraries ( out ) ; out . println ( ) ; out . println ( "-------------------------------------------" ) ; out . println ( " Tasks availability" ) ; out . println ( "-------------------------------------------" ) ; doReportTasksAvailability ( out ) ; out . println ( ) ; out . println ( "-------------------------------------------" ) ; out . println ( " org.apache.env.Which diagnostics" ) ; out . println ( "-------------------------------------------" ) ; doReportWhich ( out ) ; out . println ( ) ; out . println ( "-------------------------------------------" ) ; out . println ( " XML Parser information" ) ; out . println ( "-------------------------------------------" ) ; doReportParserInfo ( out ) ; out . println ( ) ; out . println ( "-------------------------------------------" ) ; out . println ( " System properties" ) ; out . println ( "-------------------------------------------" ) ; doReportSystemProperties ( out ) ; out . println ( ) ; } private static void doReportSystemProperties ( PrintStream out ) { for ( Enumeration keys = System . getProperties ( ) . keys ( ) ; keys . hasMoreElements ( ) ; ) { String key = ( String ) keys . nextElement ( ) ; out . println ( key + " : " + System . getProperty ( key ) ) ; } } private static void doReportLibraries ( PrintStream out ) { out . println ( "ant.home: " + System . getProperty ( "ant.home" ) ) ; File [ ] libs = listLibraries ( ) ; if ( libs == null ) { out . println ( "Unable to list libraries." ) ; return ; } for ( int i = 0 ; i < libs . length ; i ++ ) { out . println ( libs [ i ] . getName ( ) + " (" + libs [ i ] . length ( ) + " bytes)" ) ; } } private static void doReportWhich ( PrintStream out ) { Throwable error = null ; try { Class which = Class . forName ( "org.apache.env.Which" ) ; Method method = which . getMethod ( "main" , new Class [ ] { String [ ] . class } ) ; method . invoke ( null , new Object [ ] { new String [ ] { } } ) ; } catch ( ClassNotFoundException e ) { out . println ( "Not available." ) ; out . println ( "Download it at http://xml.apache.org/commons/" ) ; } catch ( InvocationTargetException e ) { error = e . getTargetException ( ) == null ? e : e . getTargetException ( ) ; } catch ( Throwable e ) { error = e ; } if ( error != null ) { out . println ( "Error while running org.apache.env.Which" ) ; error . printStackTrace ( ) ; } } private static void doReportTasksAvailability ( PrintStream out ) { InputStream is = Main . class . getResourceAsStream ( "/org/apache/tools/ant/taskdefs/defaults.properties" ) ; if ( is == null ) { out . println ( "None available" ) ; } else { Properties props = new Properties ( ) ; try { props . load ( is ) ; for ( Enumeration keys = props . keys ( ) ; keys . hasMoreElements ( ) ; ) { String key = ( String ) keys . nextElement ( ) ; String classname = props . getProperty ( key ) ; try { Class . forName ( classname ) ; props . remove ( key ) ; } catch ( ClassNotFoundException e ) { out . println ( key + " : Not Available" ) ; } catch ( NoClassDefFoundError e ) { String pkg = e . getMessage ( ) . replace ( '/' , '.' ) ; out . println ( key + " : Missing dependency " + pkg ) ; } catch ( Error e ) { out . println ( key + " : Initialization error" ) ; } } if ( props . size ( ) == 0 ) { out . println ( "All defined tasks are available" ) ; } } catch ( IOException e ) { out . println ( e . getMessage ( ) ) ; } } } private static void doReportParserInfo ( PrintStream out ) { String parserName = getXmlParserName ( ) ; String parserLocation = getXMLParserLocation ( ) ; if ( parserName == null ) { parserName = "unknown" ; } if ( parserLocation == null ) { parserLocation = "unknown" ; } out . println ( "XML Parser : " + parserName ) ; out . println ( "XML Parser Location: " + parserLocation ) ; } } 	1	['17', '1', '0', '4', '58', '130', '1', '4', '5', '0.921875', '630', '0.25', '0', '0', '0.129411765', '0', '0', '35.82352941', '4', '2.1176', '1']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Vector ; import java . util . Enumeration ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . DirSet ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . FileList ; import org . apache . tools . ant . types . PropertySet ; import org . apache . tools . ant . types . Reference ; public class SubAnt extends Task { private Path buildpath ; private String target = null ; private String antfile = "build.xml" ; private File genericantfile = null ; private boolean inheritAll = false ; private boolean inheritRefs = false ; private boolean failOnError = true ; private String output = null ; private Vector properties = new Vector ( ) ; private Vector references = new Vector ( ) ; private Vector propertySets = new Vector ( ) ; public void execute ( ) { if ( buildpath == null ) { throw new BuildException ( "No buildpath specified" ) ; } final String [ ] filenames = buildpath . list ( ) ; final int count = filenames . length ; if ( count < 1 ) { log ( "No sub-builds to iterate on" , Project . MSG_WARN ) ; return ; } BuildException buildException = null ; for ( int i = 0 ; i < count ; ++ i ) { File file = null ; Throwable thrownException = null ; try { File directory = null ; file = new File ( filenames [ i ] ) ; if ( file . isDirectory ( ) ) { if ( genericantfile != null ) { directory = file ; file = genericantfile ; } else { file = new File ( file , antfile ) ; } } execute ( file , directory ) ; } catch ( RuntimeException ex ) { if ( ! ( getProject ( ) . isKeepGoingMode ( ) ) ) { throw ex ; } thrownException = ex ; } catch ( Throwable ex ) { if ( ! ( getProject ( ) . isKeepGoingMode ( ) ) ) { throw new BuildException ( ex ) ; } thrownException = ex ; } if ( thrownException != null ) { if ( thrownException instanceof BuildException ) { log ( "File '" + file + "' failed with message '" + thrownException . getMessage ( ) + "'." , Project . MSG_ERR ) ; if ( buildException == null ) { buildException = ( BuildException ) thrownException ; } } else { log ( "Target '" + file + "' failed with message '" + thrownException . getMessage ( ) + "'." , Project . MSG_ERR ) ; thrownException . printStackTrace ( System . err ) ; if ( buildException == null ) { buildException = new BuildException ( thrownException ) ; } } } } if ( buildException != null ) { throw buildException ; } } private void execute ( File file , File directory ) throws BuildException { if ( ! file . exists ( ) || file . isDirectory ( ) || ! file . canRead ( ) ) { String msg = "Invalid file: " + file ; if ( failOnError ) { throw new BuildException ( msg ) ; } log ( msg , Project . MSG_WARN ) ; return ; } Ant ant = createAntTask ( directory ) ; String antfilename = null ; try { antfilename = file . getCanonicalPath ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } ant . setAntfile ( antfilename ) ; try { ant . execute ( ) ; } catch ( BuildException e ) { if ( failOnError ) { throw e ; } log ( "Failure for target '" + target + "' of: " + antfilename + "\n" + e . getMessage ( ) , Project . MSG_WARN ) ; } } public void setAntfile ( String antfile ) { this . antfile = antfile ; } public void setGenericAntfile ( File afile ) { this . genericantfile = afile ; } public void setFailonerror ( boolean failOnError ) { this . failOnError = failOnError ; } public void setTarget ( String target ) { this . target = target ; } public void setOutput ( String s ) { this . output = s ; } public void setInheritall ( boolean b ) { this . inheritAll = b ; } public void setInheritrefs ( boolean b ) { this . inheritRefs = b ; } public void addProperty ( Property p ) { properties . addElement ( p ) ; } public void addReference ( Ant . Reference r ) { references . addElement ( r ) ; } public void addPropertyset ( PropertySet ps ) { propertySets . addElement ( ps ) ; } public void addDirset ( DirSet set ) { getBuildpath ( ) . addDirset ( set ) ; } public void addFileset ( FileSet set ) { getBuildpath ( ) . addFileset ( set ) ; } public void addFilelist ( FileList list ) { getBuildpath ( ) . addFilelist ( list ) ; } public void setBuildpath ( Path s ) { getBuildpath ( ) . append ( s ) ; } public Path createBuildpath ( ) { return getBuildpath ( ) . createPath ( ) ; } public Path . PathElement createBuildpathElement ( ) { return getBuildpath ( ) . createPathElement ( ) ; } private Path getBuildpath ( ) { if ( buildpath == null ) { buildpath = new Path ( getProject ( ) ) ; } return buildpath ; } public void setBuildpathRef ( Reference r ) { createBuildpath ( ) . setRefid ( r ) ; } private Ant createAntTask ( File directory ) { Ant ant = ( Ant ) getProject ( ) . createTask ( "ant" ) ; ant . setOwningTarget ( getOwningTarget ( ) ) ; ant . setTaskName ( getTaskName ( ) ) ; ant . init ( ) ; if ( target != null && target . length ( ) > 0 ) { ant . setTarget ( target ) ; } if ( output != null ) { ant . setOutput ( output ) ; } if ( directory != null ) { ant . setDir ( directory ) ; } ant . setInheritAll ( inheritAll ) ; for ( Enumeration i = properties . elements ( ) ; i . hasMoreElements ( ) ; ) { copyProperty ( ant . createProperty ( ) , ( Property ) i . nextElement ( ) ) ; } for ( Enumeration i = propertySets . elements ( ) ; i . hasMoreElements ( ) ; ) { ant . addPropertyset ( ( PropertySet ) i . nextElement ( ) ) ; } ant . setInheritRefs ( inheritRefs ) ; for ( Enumeration i = references . elements ( ) ; i . hasMoreElements ( ) ; ) { ant . addReference ( ( Ant . Reference ) i . nextElement ( ) ) ; } return ant ; } private static void copyProperty ( Property to , Property from ) { to . setName ( from . getName ( ) ) ; if ( from . getValue ( ) != null ) { to . setValue ( from . getValue ( ) ) ; } if ( from . getFile ( ) != null ) { to . setFile ( from . getFile ( ) ) ; } if ( from . getResource ( ) != null ) { to . setResource ( from . getResource ( ) ) ; } if ( from . getPrefix ( ) != null ) { to . setPrefix ( from . getPrefix ( ) ) ; } if ( from . getRefid ( ) != null ) { to . setRefid ( from . getRefid ( ) ) ; } if ( from . getEnvironment ( ) != null ) { to . setEnvironment ( from . getEnvironment ( ) ) ; } if ( from . getClasspath ( ) != null ) { to . setClasspath ( from . getClasspath ( ) ) ; } } } 	0	['23', '3', '0', '15', '88', '201', '0', '15', '19', '0.847107438', '541', '1', '1', '0.627118644', '0.144927536', '2', '2', '22.04347826', '13', '2.1304', '0']
package org . apache . tools . ant . types ; import java . io . File ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Stack ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . FileScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . selectors . AndSelector ; import org . apache . tools . ant . types . selectors . ContainsSelector ; import org . apache . tools . ant . types . selectors . DateSelector ; import org . apache . tools . ant . types . selectors . DependSelector ; import org . apache . tools . ant . types . selectors . DepthSelector ; import org . apache . tools . ant . types . selectors . ExtendSelector ; import org . apache . tools . ant . types . selectors . FileSelector ; import org . apache . tools . ant . types . selectors . DifferentSelector ; import org . apache . tools . ant . types . selectors . FilenameSelector ; import org . apache . tools . ant . types . selectors . TypeSelector ; import org . apache . tools . ant . types . selectors . MajoritySelector ; import org . apache . tools . ant . types . selectors . NoneSelector ; import org . apache . tools . ant . types . selectors . NotSelector ; import org . apache . tools . ant . types . selectors . OrSelector ; import org . apache . tools . ant . types . selectors . PresentSelector ; import org . apache . tools . ant . types . selectors . ContainsRegexpSelector ; import org . apache . tools . ant . types . selectors . SelectSelector ; import org . apache . tools . ant . types . selectors . SelectorContainer ; import org . apache . tools . ant . types . selectors . SelectorScanner ; import org . apache . tools . ant . types . selectors . SizeSelector ; import org . apache . tools . ant . types . selectors . modifiedselector . ModifiedSelector ; public abstract class AbstractFileSet extends DataType implements Cloneable , SelectorContainer { private PatternSet defaultPatterns = new PatternSet ( ) ; private Vector additionalPatterns = new Vector ( ) ; private Vector selectors = new Vector ( ) ; private File dir ; private boolean useDefaultExcludes = true ; private boolean isCaseSensitive = true ; private boolean followSymlinks = true ; public AbstractFileSet ( ) { super ( ) ; } protected AbstractFileSet ( AbstractFileSet fileset ) { this . dir = fileset . dir ; this . defaultPatterns = fileset . defaultPatterns ; this . additionalPatterns = fileset . additionalPatterns ; this . selectors = fileset . selectors ; this . useDefaultExcludes = fileset . useDefaultExcludes ; this . isCaseSensitive = fileset . isCaseSensitive ; this . followSymlinks = fileset . followSymlinks ; setProject ( fileset . getProject ( ) ) ; } public void setRefid ( Reference r ) throws BuildException { if ( dir != null || defaultPatterns . hasPatterns ( getProject ( ) ) ) { throw tooManyAttributes ( ) ; } if ( ! additionalPatterns . isEmpty ( ) ) { throw noChildrenAllowed ( ) ; } if ( ! selectors . isEmpty ( ) ) { throw noChildrenAllowed ( ) ; } super . setRefid ( r ) ; } public void setDir ( File dir ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . dir = dir ; } public File getDir ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getDir ( p ) ; } return dir ; } public PatternSet createPatternSet ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } PatternSet patterns = new PatternSet ( ) ; additionalPatterns . addElement ( patterns ) ; return patterns ; } public PatternSet . NameEntry createInclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return defaultPatterns . createInclude ( ) ; } public PatternSet . NameEntry createIncludesFile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return defaultPatterns . createIncludesFile ( ) ; } public PatternSet . NameEntry createExclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return defaultPatterns . createExclude ( ) ; } public PatternSet . NameEntry createExcludesFile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return defaultPatterns . createExcludesFile ( ) ; } public void setFile ( File file ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } setDir ( file . getParentFile ( ) ) ; PatternSet . NameEntry include = createInclude ( ) ; include . setName ( file . getName ( ) ) ; } public void setIncludes ( String includes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } defaultPatterns . setIncludes ( includes ) ; } public void setExcludes ( String excludes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } defaultPatterns . setExcludes ( excludes ) ; } public void setIncludesfile ( File incl ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } defaultPatterns . setIncludesfile ( incl ) ; } public void setExcludesfile ( File excl ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } defaultPatterns . setExcludesfile ( excl ) ; } public void setDefaultexcludes ( boolean useDefaultExcludes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . useDefaultExcludes = useDefaultExcludes ; } public void setCaseSensitive ( boolean isCaseSensitive ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . isCaseSensitive = isCaseSensitive ; } public void setFollowSymlinks ( boolean followSymlinks ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . followSymlinks = followSymlinks ; } public boolean isFollowSymlinks ( ) { if ( isReference ( ) ) { return getRef ( getProject ( ) ) . isFollowSymlinks ( ) ; } else { return followSymlinks ; } } protected String getDataTypeName ( ) { Project project = getProject ( ) ; if ( project != null ) { Hashtable typedefs = project . getDataTypeDefinitions ( ) ; for ( Enumeration e = typedefs . keys ( ) ; e . hasMoreElements ( ) ; ) { String typeName = ( String ) e . nextElement ( ) ; Class typeClass = ( Class ) typedefs . get ( typeName ) ; if ( typeClass == getClass ( ) ) { return typeName ; } } } String classname = getClass ( ) . getName ( ) ; int dotIndex = classname . lastIndexOf ( "." ) ; if ( dotIndex == - 1 ) { return classname ; } return classname . substring ( dotIndex + 1 ) ; } public DirectoryScanner getDirectoryScanner ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getDirectoryScanner ( p ) ; } if ( dir == null ) { throw new BuildException ( "No directory specified for " + getDataTypeName ( ) + "." ) ; } if ( ! dir . exists ( ) ) { throw new BuildException ( dir . getAbsolutePath ( ) + " not found." ) ; } if ( ! dir . isDirectory ( ) ) { throw new BuildException ( dir . getAbsolutePath ( ) + " is not a directory." ) ; } DirectoryScanner ds = new DirectoryScanner ( ) ; setupDirectoryScanner ( ds , p ) ; ds . setFollowSymlinks ( followSymlinks ) ; ds . scan ( ) ; return ds ; } public void setupDirectoryScanner ( FileScanner ds , Project p ) { if ( isReference ( ) ) { getRef ( p ) . setupDirectoryScanner ( ds , p ) ; return ; } if ( ds == null ) { throw new IllegalArgumentException ( "ds cannot be null" ) ; } ds . setBasedir ( dir ) ; final int count = additionalPatterns . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { Object o = additionalPatterns . elementAt ( i ) ; defaultPatterns . append ( ( PatternSet ) o , p ) ; } p . log ( getDataTypeName ( ) + ": Setup scanner in dir " + dir + " with " + defaultPatterns , Project . MSG_DEBUG ) ; ds . setIncludes ( defaultPatterns . getIncludePatterns ( p ) ) ; ds . setExcludes ( defaultPatterns . getExcludePatterns ( p ) ) ; if ( ds instanceof SelectorScanner ) { SelectorScanner ss = ( SelectorScanner ) ds ; ss . setSelectors ( getSelectors ( p ) ) ; } if ( useDefaultExcludes ) { ds . addDefaultExcludes ( ) ; } ds . setCaseSensitive ( isCaseSensitive ) ; } protected AbstractFileSet getRef ( Project p ) { if ( ! isChecked ( ) ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , p ) ; } Object o = getRefid ( ) . getReferencedObject ( p ) ; if ( ! getClass ( ) . isAssignableFrom ( o . getClass ( ) ) ) { String msg = getRefid ( ) . getRefId ( ) + " doesn\'t denote a " + getDataTypeName ( ) ; throw new BuildException ( msg ) ; } else { return ( AbstractFileSet ) o ; } } public boolean hasSelectors ( ) { if ( isReference ( ) && getProject ( ) != null ) { return getRef ( getProject ( ) ) . hasSelectors ( ) ; } return ! ( selectors . isEmpty ( ) ) ; } public boolean hasPatterns ( ) { if ( isReference ( ) && getProject ( ) != null ) { return getRef ( getProject ( ) ) . hasPatterns ( ) ; } if ( defaultPatterns . hasPatterns ( getProject ( ) ) ) { return true ; } Enumeration e = additionalPatterns . elements ( ) ; while ( e . hasMoreElements ( ) ) { PatternSet ps = ( PatternSet ) e . nextElement ( ) ; if ( ps . hasPatterns ( getProject ( ) ) ) { return true ; } } return false ; } public int selectorCount ( ) { if ( isReference ( ) && getProject ( ) != null ) { return getRef ( getProject ( ) ) . selectorCount ( ) ; } return selectors . size ( ) ; } public FileSelector [ ] getSelectors ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getSelectors ( p ) ; } else { FileSelector [ ] result = new FileSelector [ selectors . size ( ) ] ; selectors . copyInto ( result ) ; return result ; } } public Enumeration selectorElements ( ) { if ( isReference ( ) && getProject ( ) != null ) { return getRef ( getProject ( ) ) . selectorElements ( ) ; } return selectors . elements ( ) ; } public void appendSelector ( FileSelector selector ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } selectors . addElement ( selector ) ; } public void addSelector ( SelectSelector selector ) { appendSelector ( selector ) ; } public void addAnd ( AndSelector selector ) { appendSelector ( selector ) ; } public void addOr ( OrSelector selector ) { appendSelector ( selector ) ; } public void addNot ( NotSelector selector ) { appendSelector ( selector ) ; } public void addNone ( NoneSelector selector ) { appendSelector ( selector ) ; } public void addMajority ( MajoritySelector selector ) { appendSelector ( selector ) ; } public void addDate ( DateSelector selector ) { appendSelector ( selector ) ; } public void addSize ( SizeSelector selector ) { appendSelector ( selector ) ; } public void addDifferent ( DifferentSelector selector ) { appendSelector ( selector ) ; } public void addFilename ( FilenameSelector selector ) { appendSelector ( selector ) ; } public void addType ( TypeSelector selector ) { appendSelector ( selector ) ; } public void addCustom ( ExtendSelector selector ) { appendSelector ( selector ) ; } public void addContains ( ContainsSelector selector ) { appendSelector ( selector ) ; } public void addPresent ( PresentSelector selector ) { appendSelector ( selector ) ; } public void addDepth ( DepthSelector selector ) { appendSelector ( selector ) ; } public void addDepend ( DependSelector selector ) { appendSelector ( selector ) ; } public void addContainsRegexp ( ContainsRegexpSelector selector ) { appendSelector ( selector ) ; } public void addModified ( ModifiedSelector selector ) { appendSelector ( selector ) ; } public void add ( FileSelector selector ) { appendSelector ( selector ) ; } public String toString ( ) { DirectoryScanner ds = getDirectoryScanner ( getProject ( ) ) ; String [ ] files = ds . getIncludedFiles ( ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { if ( i > 0 ) { sb . append ( ';' ) ; } sb . append ( files [ i ] ) ; } return sb . toString ( ) ; } public Object clone ( ) { if ( isReference ( ) ) { return ( getRef ( getProject ( ) ) ) . clone ( ) ; } else { try { AbstractFileSet fs = ( AbstractFileSet ) super . clone ( ) ; fs . defaultPatterns = ( PatternSet ) defaultPatterns . clone ( ) ; fs . additionalPatterns = new Vector ( additionalPatterns . size ( ) ) ; Enumeration e = additionalPatterns . elements ( ) ; while ( e . hasMoreElements ( ) ) { fs . additionalPatterns . addElement ( ( ( PatternSet ) e . nextElement ( ) ) . clone ( ) ) ; } fs . selectors = ( Vector ) fs . selectors . clone ( ) ; return fs ; } catch ( CloneNotSupportedException e ) { throw new BuildException ( e ) ; } } } } 	1	['50', '3', '2', '55', '123', '919', '25', '30', '47', '0.78425656', '918', '1', '1', '0.384615385', '0.064444444', '2', '5', '17.22', '6', '1.88', '2']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . BuildException ; public interface FileSelector { boolean isSelected ( File basedir , String filename , File file ) throws BuildException ; } 	0	['1', '1', '0', '16', '1', '0', '15', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . util . ArrayList ; import java . util . List ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; import java . util . HashSet ; import java . util . HashMap ; import java . util . Hashtable ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DynamicConfigurator ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . RuntimeConfigurable ; import org . apache . tools . ant . Target ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . UnknownElement ; public class MacroInstance extends Task implements DynamicConfigurator { private MacroDef macroDef ; private Map map = new HashMap ( ) ; private Map nsElements = null ; private Map presentElements = new HashMap ( ) ; private Hashtable localProperties = new Hashtable ( ) ; public void setMacroDef ( MacroDef macroDef ) { this . macroDef = macroDef ; } public void setDynamicAttribute ( String name , String value ) { map . put ( name , value ) ; } public Object createDynamicElement ( String name ) throws BuildException { if ( getNsElements ( ) . get ( name ) == null ) { throw new BuildException ( "unsupported element " + name ) ; } if ( presentElements . get ( name ) != null ) { throw new BuildException ( "Element " + name + " already present" ) ; } Element ret = new Element ( ) ; presentElements . put ( name , ret ) ; return ret ; } private Map getNsElements ( ) { if ( nsElements == null ) { nsElements = new HashMap ( ) ; for ( Iterator i = macroDef . getElements ( ) . entrySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) i . next ( ) ; nsElements . put ( ( String ) entry . getKey ( ) , entry . getValue ( ) ) ; } } return nsElements ; } public static class Element implements TaskContainer { private List unknownElements = new ArrayList ( ) ; public void addTask ( Task nestedTask ) { unknownElements . add ( nestedTask ) ; } public List getUnknownElements ( ) { return unknownElements ; } } private static final int STATE_NORMAL = 0 ; private static final int STATE_EXPECT_BRACKET = 1 ; private static final int STATE_EXPECT_NAME = 2 ; private static final int STATE_EXPECT_EXCAPE = 3 ; private String macroSubs ( String s , Map macroMapping ) { if ( s == null ) { return null ; } StringBuffer ret = new StringBuffer ( ) ; StringBuffer macroName = null ; boolean inMacro = false ; int state = STATE_NORMAL ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { char ch = s . charAt ( i ) ; switch ( state ) { case STATE_NORMAL : if ( ch == '@' ) { state = STATE_EXPECT_BRACKET ; } else { ret . append ( ch ) ; } break ; case STATE_EXPECT_BRACKET : if ( ch == '{' ) { state = STATE_EXPECT_NAME ; macroName = new StringBuffer ( ) ; } else if ( ch == '@' ) { state = STATE_EXPECT_EXCAPE ; } else { state = STATE_NORMAL ; ret . append ( '@' ) ; ret . append ( ch ) ; } break ; case STATE_EXPECT_NAME : if ( ch == '}' ) { state = STATE_NORMAL ; String name = macroName . toString ( ) ; String value = ( String ) macroMapping . get ( name ) ; if ( value == null ) { ret . append ( "@{" + name + "}" ) ; } else { ret . append ( value ) ; } macroName = null ; } else { macroName . append ( ch ) ; } break ; case STATE_EXPECT_EXCAPE : state = STATE_NORMAL ; if ( ch == '{' ) { ret . append ( "@" ) ; } else { ret . append ( "@@" ) ; } ret . append ( ch ) ; break ; default : break ; } } switch ( state ) { case STATE_NORMAL : break ; case STATE_EXPECT_BRACKET : ret . append ( '@' ) ; break ; case STATE_EXPECT_NAME : ret . append ( "@{" ) ; ret . append ( macroName . toString ( ) ) ; break ; case STATE_EXPECT_EXCAPE : ret . append ( "@@" ) ; break ; default : break ; } return ret . toString ( ) ; } private UnknownElement copy ( UnknownElement ue ) { UnknownElement ret = new UnknownElement ( ue . getTag ( ) ) ; ret . setNamespace ( ue . getNamespace ( ) ) ; ret . setProject ( getProject ( ) ) ; ret . setQName ( ue . getQName ( ) ) ; ret . setTaskName ( ue . getTaskName ( ) ) ; ret . setLocation ( ue . getLocation ( ) ) ; if ( getOwningTarget ( ) == null ) { Target t = new Target ( ) ; t . setProject ( getProject ( ) ) ; ret . setOwningTarget ( t ) ; } else { ret . setOwningTarget ( getOwningTarget ( ) ) ; } RuntimeConfigurable rc = new RuntimeConfigurable ( ret , ue . getTaskName ( ) ) ; rc . setPolyType ( ue . getWrapper ( ) . getPolyType ( ) ) ; Map map = ue . getWrapper ( ) . getAttributeMap ( ) ; for ( Iterator i = map . entrySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) i . next ( ) ; rc . setAttribute ( ( String ) entry . getKey ( ) , macroSubs ( ( String ) entry . getValue ( ) , localProperties ) ) ; } rc . addText ( macroSubs ( ue . getWrapper ( ) . getText ( ) . toString ( ) , localProperties ) ) ; Enumeration e = ue . getWrapper ( ) . getChildren ( ) ; while ( e . hasMoreElements ( ) ) { RuntimeConfigurable r = ( RuntimeConfigurable ) e . nextElement ( ) ; UnknownElement unknownElement = ( UnknownElement ) r . getProxy ( ) ; String tag = unknownElement . getTaskType ( ) ; MacroDef . TemplateElement templateElement = ( MacroDef . TemplateElement ) getNsElements ( ) . get ( tag ) ; if ( templateElement == null ) { UnknownElement child = copy ( unknownElement ) ; rc . addChild ( child . getWrapper ( ) ) ; ret . addChild ( child ) ; } else { Element element = ( Element ) presentElements . get ( tag ) ; if ( element == null ) { if ( ! templateElement . isOptional ( ) ) { throw new BuildException ( "Required nested element " + templateElement . getName ( ) + " missing" ) ; } continue ; } for ( Iterator i = element . getUnknownElements ( ) . iterator ( ) ; i . hasNext ( ) ; ) { UnknownElement child = ( UnknownElement ) i . next ( ) ; rc . addChild ( child . getWrapper ( ) ) ; ret . addChild ( child ) ; } } } return ret ; } public void execute ( ) { localProperties = new Hashtable ( ) ; Set copyKeys = new HashSet ( map . keySet ( ) ) ; for ( Iterator i = macroDef . getAttributes ( ) . iterator ( ) ; i . hasNext ( ) ; ) { MacroDef . Attribute attribute = ( MacroDef . Attribute ) i . next ( ) ; String value = ( String ) map . get ( attribute . getName ( ) ) ; if ( value == null ) { value = attribute . getDefault ( ) ; value = macroSubs ( value , localProperties ) ; } if ( value == null ) { throw new BuildException ( "required attribute " + attribute . getName ( ) + " not set" ) ; } localProperties . put ( attribute . getName ( ) , value ) ; copyKeys . remove ( attribute . getName ( ) ) ; } if ( copyKeys . contains ( "id" ) ) { copyKeys . remove ( "id" ) ; } if ( copyKeys . size ( ) != 0 ) { throw new BuildException ( "Unknown attribute" + ( copyKeys . size ( ) > 1 ? "s " : " " ) + copyKeys ) ; } UnknownElement c = copy ( macroDef . getNestedTask ( ) ) ; c . init ( ) ; try { c . perform ( ) ; } catch ( BuildException ex ) { throw ProjectHelper . addLocationToBuildException ( ex , getLocation ( ) ) ; } } } 	1	['8', '3', '0', '15', '77', '6', '1', '14', '5', '0.825396825', '585', '1', '1', '0.840909091', '0.35', '0', '0', '71', '10', '3.875', '2']
package org . apache . tools . ant . types ; import java . io . File ; import java . util . Enumeration ; import java . util . Locale ; import java . util . Stack ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . PathTokenizer ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . JavaEnvUtils ; public class Path extends DataType implements Cloneable { private Vector elements ; public static Path systemClasspath = new Path ( null , System . getProperty ( "java.class.path" ) ) ; public class PathElement { private String [ ] parts ; public void setLocation ( File loc ) { parts = new String [ ] { translateFile ( loc . getAbsolutePath ( ) ) } ; } public void setPath ( String path ) { parts = Path . translatePath ( getProject ( ) , path ) ; } public String [ ] getParts ( ) { return parts ; } } public Path ( Project p , String path ) { this ( p ) ; createPathElement ( ) . setPath ( path ) ; } public Path ( Project project ) { setProject ( project ) ; elements = new Vector ( ) ; } public void setLocation ( File location ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createPathElement ( ) . setLocation ( location ) ; } public void setPath ( String path ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createPathElement ( ) . setPath ( path ) ; } public void setRefid ( Reference r ) throws BuildException { if ( ! elements . isEmpty ( ) ) { throw tooManyAttributes ( ) ; } elements . addElement ( r ) ; super . setRefid ( r ) ; } public PathElement createPathElement ( ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } PathElement pe = new PathElement ( ) ; elements . addElement ( pe ) ; return pe ; } public void addFileset ( FileSet fs ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } elements . addElement ( fs ) ; setChecked ( false ) ; } public void addFilelist ( FileList fl ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } elements . addElement ( fl ) ; setChecked ( false ) ; } public void addDirset ( DirSet dset ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } elements . addElement ( dset ) ; setChecked ( false ) ; } public void add ( Path path ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } elements . addElement ( path ) ; setChecked ( false ) ; } public Path createPath ( ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } Path p = new Path ( getProject ( ) ) ; elements . addElement ( p ) ; setChecked ( false ) ; return p ; } public void append ( Path other ) { if ( other == null ) { return ; } String [ ] l = other . list ( ) ; for ( int i = 0 ; i < l . length ; i ++ ) { if ( elements . indexOf ( l [ i ] ) == - 1 ) { elements . addElement ( l [ i ] ) ; } } } public void addExisting ( Path source ) { addExisting ( source , false ) ; } public void addExisting ( Path source , boolean tryUserDir ) { String [ ] list = source . list ( ) ; File userDir = ( tryUserDir ) ? new File ( System . getProperty ( "user.dir" ) ) : null ; for ( int i = 0 ; i < list . length ; i ++ ) { File f = null ; if ( getProject ( ) != null ) { f = getProject ( ) . resolveFile ( list [ i ] ) ; } else { f = new File ( list [ i ] ) ; } if ( tryUserDir && ! f . exists ( ) ) { f = new File ( userDir , list [ i ] ) ; } if ( f . exists ( ) ) { setLocation ( f ) ; } else { log ( "dropping " + f + " from path as it doesn't exist" , Project . MSG_VERBOSE ) ; } } } public String [ ] list ( ) { if ( ! isChecked ( ) ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , getProject ( ) ) ; } Vector result = new Vector ( 2 * elements . size ( ) ) ; for ( int i = 0 ; i < elements . size ( ) ; i ++ ) { Object o = elements . elementAt ( i ) ; if ( o instanceof Reference ) { Reference r = ( Reference ) o ; o = r . getReferencedObject ( getProject ( ) ) ; if ( ! ( o instanceof Path ) ) { String msg = r . getRefId ( ) + " doesn\'t denote a path " + o ; throw new BuildException ( msg ) ; } } if ( o instanceof String ) { addUnlessPresent ( result , ( String ) o ) ; } else if ( o instanceof PathElement ) { String [ ] parts = ( ( PathElement ) o ) . getParts ( ) ; if ( parts == null ) { throw new BuildException ( "You must either set location or" + " path on <pathelement>" ) ; } for ( int j = 0 ; j < parts . length ; j ++ ) { addUnlessPresent ( result , parts [ j ] ) ; } } else if ( o instanceof Path ) { Path p = ( Path ) o ; if ( p . getProject ( ) == null ) { p . setProject ( getProject ( ) ) ; } String [ ] parts = p . list ( ) ; for ( int j = 0 ; j < parts . length ; j ++ ) { addUnlessPresent ( result , parts [ j ] ) ; } } else if ( o instanceof DirSet ) { DirSet dset = ( DirSet ) o ; DirectoryScanner ds = dset . getDirectoryScanner ( getProject ( ) ) ; String [ ] s = ds . getIncludedDirectories ( ) ; File dir = dset . getDir ( getProject ( ) ) ; addUnlessPresent ( result , dir , s ) ; } else if ( o instanceof FileSet ) { FileSet fs = ( FileSet ) o ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] s = ds . getIncludedFiles ( ) ; File dir = fs . getDir ( getProject ( ) ) ; addUnlessPresent ( result , dir , s ) ; } else if ( o instanceof FileList ) { FileList fl = ( FileList ) o ; String [ ] s = fl . getFiles ( getProject ( ) ) ; File dir = fl . getDir ( getProject ( ) ) ; addUnlessPresent ( result , dir , s ) ; } } String [ ] res = new String [ result . size ( ) ] ; result . copyInto ( res ) ; return res ; } public String toString ( ) { final String [ ] list = list ( ) ; if ( list . length == 0 ) { return "" ; } final StringBuffer result = new StringBuffer ( list [ 0 ] . toString ( ) ) ; for ( int i = 1 ; i < list . length ; i ++ ) { result . append ( File . pathSeparatorChar ) ; result . append ( list [ i ] ) ; } return result . toString ( ) ; } public static String [ ] translatePath ( Project project , String source ) { final Vector result = new Vector ( ) ; if ( source == null ) { return new String [ 0 ] ; } PathTokenizer tok = new PathTokenizer ( source ) ; StringBuffer element = new StringBuffer ( ) ; while ( tok . hasMoreTokens ( ) ) { String pathElement = tok . nextToken ( ) ; try { element . append ( resolveFile ( project , pathElement ) ) ; } catch ( BuildException e ) { project . log ( "Dropping path element " + pathElement + " as it is not valid relative to the project" , Project . MSG_VERBOSE ) ; } for ( int i = 0 ; i < element . length ( ) ; i ++ ) { translateFileSep ( element , i ) ; } result . addElement ( element . toString ( ) ) ; element = new StringBuffer ( ) ; } String [ ] res = new String [ result . size ( ) ] ; result . copyInto ( res ) ; return res ; } public static String translateFile ( String source ) { if ( source == null ) { return "" ; } final StringBuffer result = new StringBuffer ( source ) ; for ( int i = 0 ; i < result . length ( ) ; i ++ ) { translateFileSep ( result , i ) ; } return result . toString ( ) ; } protected static boolean translateFileSep ( StringBuffer buffer , int pos ) { if ( buffer . charAt ( pos ) == '/' || buffer . charAt ( pos ) == '\\' ) { buffer . setCharAt ( pos , File . separatorChar ) ; return true ; } return false ; } public int size ( ) { return list ( ) . length ; } public Object clone ( ) { try { Path p = ( Path ) super . clone ( ) ; p . elements = ( Vector ) elements . clone ( ) ; return p ; } catch ( CloneNotSupportedException e ) { throw new BuildException ( e ) ; } } protected void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( isChecked ( ) ) { return ; } Enumeration e = elements . elements ( ) ; while ( e . hasMoreElements ( ) ) { Object o = e . nextElement ( ) ; if ( o instanceof Reference ) { o = ( ( Reference ) o ) . getReferencedObject ( p ) ; } if ( o instanceof DataType ) { if ( stk . contains ( o ) ) { throw circularReference ( ) ; } else { stk . push ( o ) ; ( ( DataType ) o ) . dieOnCircularReference ( stk , p ) ; stk . pop ( ) ; } } } setChecked ( true ) ; } private static String resolveFile ( Project project , String relativeName ) { if ( project != null ) { File f = project . resolveFile ( relativeName ) ; return f . getAbsolutePath ( ) ; } return relativeName ; } private static void addUnlessPresent ( Vector v , String s ) { if ( v . indexOf ( s ) == - 1 ) { v . addElement ( s ) ; } } private static void addUnlessPresent ( Vector v , File dir , String [ ] s ) { for ( int j = 0 ; j < s . length ; j ++ ) { File d = new File ( dir , s [ j ] ) ; String absolutePath = d . getAbsolutePath ( ) ; addUnlessPresent ( v , translateFile ( absolutePath ) ) ; } } public Path concatSystemClasspath ( ) { return concatSystemClasspath ( "last" ) ; } public Path concatSystemClasspath ( String defValue ) { Path result = new Path ( getProject ( ) ) ; String order = defValue ; if ( getProject ( ) != null ) { String o = getProject ( ) . getProperty ( "build.sysclasspath" ) ; if ( o != null ) { order = o ; } } if ( order . equals ( "only" ) ) { result . addExisting ( Path . systemClasspath , true ) ; } else if ( order . equals ( "first" ) ) { result . addExisting ( Path . systemClasspath , true ) ; result . addExisting ( this ) ; } else if ( order . equals ( "ignore" ) ) { result . addExisting ( this ) ; } else { if ( ! order . equals ( "last" ) ) { log ( "invalid value for build.sysclasspath: " + order , Project . MSG_WARN ) ; } result . addExisting ( this ) ; result . addExisting ( Path . systemClasspath , true ) ; } return result ; } public void addJavaRuntime ( ) { if ( "Kaffe" . equals ( System . getProperty ( "java.vm.name" ) ) ) { File kaffeShare = new File ( System . getProperty ( "java.home" ) + File . separator + "share" + File . separator + "kaffe" ) ; if ( kaffeShare . isDirectory ( ) ) { FileSet kaffeJarFiles = new FileSet ( ) ; kaffeJarFiles . setDir ( kaffeShare ) ; kaffeJarFiles . setIncludes ( "*.jar" ) ; addFileset ( kaffeJarFiles ) ; } } if ( System . getProperty ( "java.vendor" ) . toLowerCase ( Locale . US ) . indexOf ( "microsoft" ) >= 0 ) { FileSet msZipFiles = new FileSet ( ) ; msZipFiles . setDir ( new File ( System . getProperty ( "java.home" ) + File . separator + "Packages" ) ) ; msZipFiles . setIncludes ( "*.ZIP" ) ; addFileset ( msZipFiles ) ; } else if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + "classes.zip" ) ) ; } else { addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + "rt.jar" ) ) ; addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "jre" + File . separator + "lib" + File . separator + "rt.jar" ) ) ; String [ ] secJars = { "jce" , "jsse" } ; for ( int i = 0 ; i < secJars . length ; i ++ ) { addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + secJars [ i ] + ".jar" ) ) ; addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + ".." + File . separator + "Classes" + File . separator + secJars [ i ] + ".jar" ) ) ; } String [ ] ibmJars = { "core" , "graphics" , "security" , "server" , "xml" } ; for ( int i = 0 ; i < ibmJars . length ; i ++ ) { addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + ibmJars [ i ] + ".jar" ) ) ; } addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + ".." + File . separator + "Classes" + File . separator + "classes.jar" ) ) ; addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + ".." + File . separator + "Classes" + File . separator + "ui.jar" ) ) ; } } public void addExtdirs ( Path extdirs ) { if ( extdirs == null ) { String extProp = System . getProperty ( "java.ext.dirs" ) ; if ( extProp != null ) { extdirs = new Path ( getProject ( ) , extProp ) ; } else { return ; } } String [ ] dirs = extdirs . list ( ) ; for ( int i = 0 ; i < dirs . length ; i ++ ) { File dir = getProject ( ) . resolveFile ( dirs [ i ] ) ; if ( dir . exists ( ) && dir . isDirectory ( ) ) { FileSet fs = new FileSet ( ) ; fs . setDir ( dir ) ; fs . setIncludes ( "*" ) ; addFileset ( fs ) ; } } } } 	0	['30', '3', '0', '51', '102', '301', '40', '13', '24', '0.603448276', '1238', '0.5', '1', '0.526315789', '0.12183908', '2', '6', '40.2', '15', '2.6333', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . FilterChain ; import org . apache . tools . ant . types . FilterSet ; import org . apache . tools . ant . types . FilterSetCollection ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . FlatFileNameMapper ; import org . apache . tools . ant . util . IdentityMapper ; import org . apache . tools . ant . util . SourceFileScanner ; public class Copy extends Task { protected File file = null ; protected File destFile = null ; protected File destDir = null ; protected Vector filesets = new Vector ( ) ; private boolean enableMultipleMappings = false ; protected boolean filtering = false ; protected boolean preserveLastModified = false ; protected boolean forceOverwrite = false ; protected boolean flatten = false ; protected int verbosity = Project . MSG_VERBOSE ; protected boolean includeEmpty = true ; private boolean failonerror = true ; protected Hashtable fileCopyMap = new Hashtable ( ) ; protected Hashtable dirCopyMap = new Hashtable ( ) ; protected Hashtable completeDirMap = new Hashtable ( ) ; protected Mapper mapperElement = null ; private Vector filterChains = new Vector ( ) ; private Vector filterSets = new Vector ( ) ; private FileUtils fileUtils ; private String inputEncoding = null ; private String outputEncoding = null ; public Copy ( ) { fileUtils = FileUtils . newFileUtils ( ) ; } protected FileUtils getFileUtils ( ) { return fileUtils ; } public void setFile ( File file ) { this . file = file ; } public void setTofile ( File destFile ) { this . destFile = destFile ; } public void setTodir ( File destDir ) { this . destDir = destDir ; } public FilterChain createFilterChain ( ) { FilterChain filterChain = new FilterChain ( ) ; filterChains . addElement ( filterChain ) ; return filterChain ; } public FilterSet createFilterSet ( ) { FilterSet filterSet = new FilterSet ( ) ; filterSets . addElement ( filterSet ) ; return filterSet ; } public void setPreserveLastModified ( String preserve ) { setPreserveLastModified ( Project . toBoolean ( preserve ) ) ; } public void setPreserveLastModified ( boolean preserve ) { preserveLastModified = preserve ; } public boolean getPreserveLastModified ( ) { return preserveLastModified ; } protected Vector getFilterSets ( ) { return filterSets ; } protected Vector getFilterChains ( ) { return filterChains ; } public void setFiltering ( boolean filtering ) { this . filtering = filtering ; } public void setOverwrite ( boolean overwrite ) { this . forceOverwrite = overwrite ; } public void setFlatten ( boolean flatten ) { this . flatten = flatten ; } public void setVerbose ( boolean verbose ) { if ( verbose ) { this . verbosity = Project . MSG_INFO ; } else { this . verbosity = Project . MSG_VERBOSE ; } } public void setIncludeEmptyDirs ( boolean includeEmpty ) { this . includeEmpty = includeEmpty ; } public void setEnableMultipleMappings ( boolean enableMultipleMappings ) { this . enableMultipleMappings = enableMultipleMappings ; } public boolean isEnableMultipleMapping ( ) { return enableMultipleMappings ; } public void setFailOnError ( boolean failonerror ) { this . failonerror = failonerror ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" , getLocation ( ) ) ; } mapperElement = new Mapper ( getProject ( ) ) ; return mapperElement ; } public void setEncoding ( String encoding ) { this . inputEncoding = encoding ; if ( outputEncoding == null ) { outputEncoding = encoding ; } } public String getEncoding ( ) { return inputEncoding ; } public void setOutputEncoding ( String encoding ) { this . outputEncoding = encoding ; } public String getOutputEncoding ( ) { return outputEncoding ; } public void execute ( ) throws BuildException { File savedFile = file ; File savedDestFile = destFile ; File savedDestDir = destDir ; FileSet savedFileSet = null ; if ( file == null && destFile != null && filesets . size ( ) == 1 ) { savedFileSet = ( FileSet ) filesets . elementAt ( 0 ) ; } validateAttributes ( ) ; try { if ( file != null ) { if ( file . exists ( ) ) { if ( destFile == null ) { destFile = new File ( destDir , file . getName ( ) ) ; } if ( forceOverwrite || ! destFile . exists ( ) || ( file . lastModified ( ) > destFile . lastModified ( ) ) ) { fileCopyMap . put ( file . getAbsolutePath ( ) , new String [ ] { destFile . getAbsolutePath ( ) } ) ; } else { log ( file + " omitted as " + destFile + " is up to date." , Project . MSG_VERBOSE ) ; } } else { String message = "Warning: Could not find file " + file . getAbsolutePath ( ) + " to copy." ; if ( ! failonerror ) { log ( message ) ; } else { throw new BuildException ( message ) ; } } } for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = null ; try { ds = fs . getDirectoryScanner ( getProject ( ) ) ; } catch ( BuildException e ) { if ( failonerror || ! e . getMessage ( ) . endsWith ( " not found." ) ) { throw e ; } else { log ( "Warning: " + e . getMessage ( ) ) ; continue ; } } File fromDir = fs . getDir ( getProject ( ) ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; String [ ] srcDirs = ds . getIncludedDirectories ( ) ; boolean isEverythingIncluded = ds . isEverythingIncluded ( ) && ( ! fs . hasSelectors ( ) && ! fs . hasPatterns ( ) ) ; if ( isEverythingIncluded && ! flatten && mapperElement == null ) { completeDirMap . put ( fromDir , destDir ) ; } scan ( fromDir , destDir , srcFiles , srcDirs ) ; } try { doFileOperations ( ) ; } catch ( BuildException e ) { if ( ! failonerror ) { log ( "Warning: " + e . getMessage ( ) , Project . MSG_ERR ) ; } else { throw e ; } } } finally { file = savedFile ; destFile = savedDestFile ; destDir = savedDestDir ; if ( savedFileSet != null ) { filesets . insertElementAt ( savedFileSet , 0 ) ; } fileCopyMap . clear ( ) ; dirCopyMap . clear ( ) ; completeDirMap . clear ( ) ; } } protected void validateAttributes ( ) throws BuildException { if ( file == null && filesets . size ( ) == 0 ) { throw new BuildException ( "Specify at least one source " + "- a file or a fileset." ) ; } if ( destFile != null && destDir != null ) { throw new BuildException ( "Only one of tofile and todir " + "may be set." ) ; } if ( destFile == null && destDir == null ) { throw new BuildException ( "One of tofile or todir must be set." ) ; } if ( file != null && file . exists ( ) && file . isDirectory ( ) ) { throw new BuildException ( "Use a fileset to copy directories." ) ; } if ( destFile != null && filesets . size ( ) > 0 ) { if ( filesets . size ( ) > 1 ) { throw new BuildException ( "Cannot concatenate multiple files into a single file." ) ; } else { FileSet fs = ( FileSet ) filesets . elementAt ( 0 ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; if ( srcFiles . length == 0 ) { throw new BuildException ( "Cannot perform operation from directory to file." ) ; } else if ( srcFiles . length == 1 ) { if ( file == null ) { file = new File ( ds . getBasedir ( ) , srcFiles [ 0 ] ) ; filesets . removeElementAt ( 0 ) ; } else { throw new BuildException ( "Cannot concatenate multiple " + "files into a single file." ) ; } } else { throw new BuildException ( "Cannot concatenate multiple " + "files into a single file." ) ; } } } if ( destFile != null ) { destDir = fileUtils . getParentFile ( destFile ) ; } } protected void scan ( File fromDir , File toDir , String [ ] files , String [ ] dirs ) { FileNameMapper mapper = null ; if ( mapperElement != null ) { mapper = mapperElement . getImplementation ( ) ; } else if ( flatten ) { mapper = new FlatFileNameMapper ( ) ; } else { mapper = new IdentityMapper ( ) ; } buildMap ( fromDir , toDir , files , mapper , fileCopyMap ) ; if ( includeEmpty ) { buildMap ( fromDir , toDir , dirs , mapper , dirCopyMap ) ; } } protected void buildMap ( File fromDir , File toDir , String [ ] names , FileNameMapper mapper , Hashtable map ) { String [ ] toCopy = null ; if ( forceOverwrite ) { Vector v = new Vector ( ) ; for ( int i = 0 ; i < names . length ; i ++ ) { if ( mapper . mapFileName ( names [ i ] ) != null ) { v . addElement ( names [ i ] ) ; } } toCopy = new String [ v . size ( ) ] ; v . copyInto ( toCopy ) ; } else { SourceFileScanner ds = new SourceFileScanner ( this ) ; toCopy = ds . restrict ( names , fromDir , toDir , mapper ) ; } for ( int i = 0 ; i < toCopy . length ; i ++ ) { File src = new File ( fromDir , toCopy [ i ] ) ; String [ ] mappedFiles = mapper . mapFileName ( toCopy [ i ] ) ; if ( ! enableMultipleMappings ) { map . put ( src . getAbsolutePath ( ) , new String [ ] { new File ( toDir , mappedFiles [ 0 ] ) . getAbsolutePath ( ) } ) ; } else { for ( int k = 0 ; k < mappedFiles . length ; k ++ ) { mappedFiles [ k ] = new File ( toDir , mappedFiles [ k ] ) . getAbsolutePath ( ) ; } map . put ( src . getAbsolutePath ( ) , mappedFiles ) ; } } } protected void doFileOperations ( ) { if ( fileCopyMap . size ( ) > 0 ) { log ( "Copying " + fileCopyMap . size ( ) + " file" + ( fileCopyMap . size ( ) == 1 ? "" : "s" ) + " to " + destDir . getAbsolutePath ( ) ) ; Enumeration e = fileCopyMap . keys ( ) ; while ( e . hasMoreElements ( ) ) { String fromFile = ( String ) e . nextElement ( ) ; String [ ] toFiles = ( String [ ] ) fileCopyMap . get ( fromFile ) ; for ( int i = 0 ; i < toFiles . length ; i ++ ) { String toFile = toFiles [ i ] ; if ( fromFile . equals ( toFile ) ) { log ( "Skipping self-copy of " + fromFile , verbosity ) ; continue ; } try { log ( "Copying " + fromFile + " to " + toFile , verbosity ) ; FilterSetCollection executionFilters = new FilterSetCollection ( ) ; if ( filtering ) { executionFilters . addFilterSet ( getProject ( ) . getGlobalFilterSet ( ) ) ; } for ( Enumeration filterEnum = filterSets . elements ( ) ; filterEnum . hasMoreElements ( ) ; ) { executionFilters . addFilterSet ( ( FilterSet ) filterEnum . nextElement ( ) ) ; } fileUtils . copyFile ( fromFile , toFile , executionFilters , filterChains , forceOverwrite , preserveLastModified , inputEncoding , outputEncoding , getProject ( ) ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; File targetFile = new File ( toFile ) ; if ( targetFile . exists ( ) && ! targetFile . delete ( ) ) { msg += " and I couldn't delete the corrupt " + toFile ; } throw new BuildException ( msg , ioe , getLocation ( ) ) ; } } } } if ( includeEmpty ) { Enumeration e = dirCopyMap . elements ( ) ; int createCount = 0 ; while ( e . hasMoreElements ( ) ) { String [ ] dirs = ( String [ ] ) e . nextElement ( ) ; for ( int i = 0 ; i < dirs . length ; i ++ ) { File d = new File ( dirs [ i ] ) ; if ( ! d . exists ( ) ) { if ( ! d . mkdirs ( ) ) { log ( "Unable to create directory " + d . getAbsolutePath ( ) , Project . MSG_ERR ) ; } else { createCount ++ ; } } } } if ( createCount > 0 ) { log ( "Copied " + dirCopyMap . size ( ) + " empty director" + ( dirCopyMap . size ( ) == 1 ? "y" : "ies" ) + " to " + createCount + " empty director" + ( createCount == 1 ? "y" : "ies" ) + " under " + destDir . getAbsolutePath ( ) ) ; } } } } 	1	['31', '3', '2', '20', '97', '307', '3', '17', '24', '0.884126984', '1137', '1', '2', '0.552238806', '0.209677419', '2', '2', '35', '18', '1.871', '4']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . util . Vector ; import org . apache . tools . ant . types . Parameter ; public final class StripLineComments extends BaseParamFilterReader implements ChainableReader { private static final String COMMENTS_KEY = "comment" ; private Vector comments = new Vector ( ) ; private String line = null ; public StripLineComments ( ) { super ( ) ; } public StripLineComments ( final Reader in ) { super ( in ) ; } public final int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( line != null ) { ch = line . charAt ( 0 ) ; if ( line . length ( ) == 1 ) { line = null ; } else { line = line . substring ( 1 ) ; } } else { line = readLine ( ) ; final int commentsSize = comments . size ( ) ; while ( line != null ) { for ( int i = 0 ; i < commentsSize ; i ++ ) { String comment = ( String ) comments . elementAt ( i ) ; if ( line . startsWith ( comment ) ) { line = null ; break ; } } if ( line == null ) { line = readLine ( ) ; } else { break ; } } if ( line != null ) { return read ( ) ; } } return ch ; } public final void addConfiguredComment ( final Comment comment ) { comments . addElement ( comment . getValue ( ) ) ; } private void setComments ( final Vector comments ) { this . comments = comments ; } private final Vector getComments ( ) { return comments ; } public final Reader chain ( final Reader rdr ) { StripLineComments newFilter = new StripLineComments ( rdr ) ; newFilter . setComments ( getComments ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private final void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( COMMENTS_KEY . equals ( params [ i ] . getType ( ) ) ) { comments . addElement ( params [ i ] . getValue ( ) ) ; } } } } public static class Comment { private String value ; public final void setValue ( String comment ) { value = comment ; } public final String getValue ( ) { return value ; } } } 	0	['8', '5', '0', '6', '26', '0', '1', '5', '5', '0.571428571', '172', '1', '0', '0.823529412', '0.375', '2', '5', '20.125', '4', '1.125', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class Jikes extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using jikes compiler" , Project . MSG_VERBOSE ) ; Path classpath = new Path ( project ) ; if ( bootclasspath != null ) { classpath . append ( bootclasspath ) ; } classpath . addExtdirs ( extdirs ) ; if ( bootclasspath == null || bootclasspath . size ( ) == 0 ) { includeJavaRuntime = true ; } else { } classpath . append ( getCompileClasspath ( ) ) ; if ( compileSourcepath != null ) { classpath . append ( compileSourcepath ) ; } else { classpath . append ( src ) ; } String jikesPath = System . getProperty ( "jikes.class.path" ) ; if ( jikesPath != null ) { classpath . append ( new Path ( project , jikesPath ) ) ; } Commandline cmd = new Commandline ( ) ; String exec = getJavac ( ) . getExecutable ( ) ; cmd . setExecutable ( exec == null ? "jikes" : exec ) ; if ( deprecation == true ) { cmd . createArgument ( ) . setValue ( "-deprecation" ) ; } if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "-classpath" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; if ( encoding != null ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( encoding ) ; } if ( debug ) { cmd . createArgument ( ) . setValue ( "-g" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O" ) ; } if ( verbose ) { cmd . createArgument ( ) . setValue ( "-verbose" ) ; } if ( depend ) { cmd . createArgument ( ) . setValue ( "-depend" ) ; } if ( target != null ) { cmd . createArgument ( ) . setValue ( "-target" ) ; cmd . createArgument ( ) . setValue ( target ) ; } String emacsProperty = project . getProperty ( "build.compiler.emacs" ) ; if ( emacsProperty != null && Project . toBoolean ( emacsProperty ) ) { cmd . createArgument ( ) . setValue ( "+E" ) ; } String warningsProperty = project . getProperty ( "build.compiler.warnings" ) ; if ( warningsProperty != null ) { attributes . log ( "!! the build.compiler.warnings property is " + "deprecated. !!" , Project . MSG_WARN ) ; attributes . log ( "!! Use the nowarn attribute instead. !!" , Project . MSG_WARN ) ; if ( ! Project . toBoolean ( warningsProperty ) ) { cmd . createArgument ( ) . setValue ( "-nowarn" ) ; } } if ( attributes . getNowarn ( ) ) { cmd . createArgument ( ) . setValue ( "-nowarn" ) ; } String pedanticProperty = project . getProperty ( "build.compiler.pedantic" ) ; if ( pedanticProperty != null && Project . toBoolean ( pedanticProperty ) ) { cmd . createArgument ( ) . setValue ( "+P" ) ; } String fullDependProperty = project . getProperty ( "build.compiler.fulldepend" ) ; if ( fullDependProperty != null && Project . toBoolean ( fullDependProperty ) ) { cmd . createArgument ( ) . setValue ( "+F" ) ; } if ( attributes . getSource ( ) != null ) { cmd . createArgument ( ) . setValue ( "-source" ) ; cmd . createArgument ( ) . setValue ( attributes . getSource ( ) ) ; } addCurrentCompilerArgs ( cmd ) ; int firstFileName = cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } } 	1	['2', '2', '0', '9', '28', '1', '1', '8', '2', '2', '268', '0', '0', '0.958333333', '1', '1', '1', '133', '1', '0.5', '1']
package org . apache . tools . ant . taskdefs ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskContainer ; public class Sequential extends Task implements TaskContainer { private Vector nestedTasks = new Vector ( ) ; public void addTask ( Task nestedTask ) { nestedTasks . addElement ( nestedTask ) ; } public void execute ( ) throws BuildException { for ( Enumeration e = nestedTasks . elements ( ) ; e . hasMoreElements ( ) ; ) { Task nestedTask = ( Task ) e . nextElement ( ) ; nestedTask . perform ( ) ; } } } 	0	['3', '3', '0', '3', '10', '0', '0', '3', '3', '0', '32', '1', '0', '0.948717949', '0.666666667', '0', '0', '9.333333333', '1', '0.6667', '0']
package org . apache . tools . ant ; import java . io . File ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . List ; import java . util . Locale ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . taskdefs . PreSetDef ; public final class IntrospectionHelper implements BuildListener { private Hashtable attributeTypes ; private Hashtable attributeSetters ; private Hashtable nestedTypes ; private Hashtable nestedCreators ; private List addTypeMethods ; private Method addText = null ; private Class bean ; private static Hashtable helpers = new Hashtable ( ) ; private static final Hashtable PRIMITIVE_TYPE_MAP = new Hashtable ( 8 ) ; static { Class [ ] primitives = { Boolean . TYPE , Byte . TYPE , Character . TYPE , Short . TYPE , Integer . TYPE , Long . TYPE , Float . TYPE , Double . TYPE } ; Class [ ] wrappers = { Boolean . class , Byte . class , Character . class , Short . class , Integer . class , Long . class , Float . class , Double . class } ; for ( int i = 0 ; i < primitives . length ; i ++ ) { PRIMITIVE_TYPE_MAP . put ( primitives [ i ] , wrappers [ i ] ) ; } } private IntrospectionHelper ( final Class bean ) { attributeTypes = new Hashtable ( ) ; attributeSetters = new Hashtable ( ) ; nestedTypes = new Hashtable ( ) ; nestedCreators = new Hashtable ( ) ; addTypeMethods = new ArrayList ( ) ; this . bean = bean ; Method [ ] methods = bean . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { final Method m = methods [ i ] ; final String name = m . getName ( ) ; Class returnType = m . getReturnType ( ) ; Class [ ] args = m . getParameterTypes ( ) ; if ( args . length == 1 && java . lang . Void . TYPE . equals ( returnType ) && ( name . equals ( "add" ) || name . equals ( "addConfigured" ) ) ) { insertAddTypeMethod ( m ) ; continue ; } if ( org . apache . tools . ant . Task . class . isAssignableFrom ( bean ) && args . length == 1 && isHiddenSetMethod ( name , args [ 0 ] ) ) { continue ; } if ( org . apache . tools . ant . TaskContainer . class . isAssignableFrom ( bean ) && args . length == 1 && "addTask" . equals ( name ) && org . apache . tools . ant . Task . class . equals ( args [ 0 ] ) ) { continue ; } if ( "addText" . equals ( name ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && java . lang . String . class . equals ( args [ 0 ] ) ) { addText = methods [ i ] ; } else if ( name . startsWith ( "set" ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && ! args [ 0 ] . isArray ( ) ) { String propName = getPropertyName ( name , "set" ) ; if ( attributeSetters . get ( propName ) != null ) { if ( java . lang . String . class . equals ( args [ 0 ] ) ) { continue ; } } AttributeSetter as = createAttributeSetter ( m , args [ 0 ] , propName ) ; if ( as != null ) { attributeTypes . put ( propName , args [ 0 ] ) ; attributeSetters . put ( propName , as ) ; } } else if ( name . startsWith ( "create" ) && ! returnType . isArray ( ) && ! returnType . isPrimitive ( ) && args . length == 0 ) { String propName = getPropertyName ( name , "create" ) ; if ( nestedCreators . get ( propName ) == null ) { nestedTypes . put ( propName , returnType ) ; nestedCreators . put ( propName , new NestedCreator ( ) { public boolean isPolyMorphic ( ) { return false ; } public Object getRealObject ( ) { return null ; } public Class getElementClass ( ) { return null ; } public Object create ( Project project , Object parent , Object ignore ) throws InvocationTargetException , IllegalAccessException { return m . invoke ( parent , new Object [ ] { } ) ; } public void store ( Object parent , Object child ) { } } ) ; } } else if ( name . startsWith ( "addConfigured" ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && ! java . lang . String . class . equals ( args [ 0 ] ) && ! args [ 0 ] . isArray ( ) && ! args [ 0 ] . isPrimitive ( ) ) { try { Constructor constructor = null ; try { constructor = args [ 0 ] . getConstructor ( new Class [ ] { } ) ; } catch ( NoSuchMethodException ex ) { constructor = args [ 0 ] . getConstructor ( new Class [ ] { Project . class } ) ; } final Constructor c = constructor ; String propName = getPropertyName ( name , "addConfigured" ) ; nestedTypes . put ( propName , args [ 0 ] ) ; nestedCreators . put ( propName , new NestedCreator ( ) { public boolean isPolyMorphic ( ) { return true ; } public Object getRealObject ( ) { return null ; } public Class getElementClass ( ) { return c . getDeclaringClass ( ) ; } public Object create ( Project project , Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException { if ( child != null ) { return child ; } else if ( c . getParameterTypes ( ) . length == 0 ) { return c . newInstance ( new Object [ ] { } ) ; } else { return c . newInstance ( new Object [ ] { project } ) ; } } public void store ( Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException { m . invoke ( parent , new Object [ ] { child } ) ; } } ) ; } catch ( NoSuchMethodException nse ) { } } else if ( name . startsWith ( "add" ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && ! java . lang . String . class . equals ( args [ 0 ] ) && ! args [ 0 ] . isArray ( ) && ! args [ 0 ] . isPrimitive ( ) ) { try { Constructor constructor = null ; try { constructor = args [ 0 ] . getConstructor ( new Class [ ] { } ) ; } catch ( NoSuchMethodException ex ) { constructor = args [ 0 ] . getConstructor ( new Class [ ] { Project . class } ) ; } final Constructor c = constructor ; String propName = getPropertyName ( name , "add" ) ; nestedTypes . put ( propName , args [ 0 ] ) ; nestedCreators . put ( propName , new NestedCreator ( ) { public boolean isPolyMorphic ( ) { return true ; } public Object getRealObject ( ) { return null ; } public Class getElementClass ( ) { return c . getDeclaringClass ( ) ; } public Object create ( Project project , Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException { if ( child != null ) { } else if ( c . getParameterTypes ( ) . length == 0 ) { child = c . newInstance ( new Object [ ] { } ) ; } else { child = c . newInstance ( new Object [ ] { project } ) ; } m . invoke ( parent , new Object [ ] { child } ) ; return child ; } public void store ( Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException { } } ) ; } catch ( NoSuchMethodException nse ) { } } } } private boolean isHiddenSetMethod ( String name , Class type ) { if ( "setLocation" . equals ( name ) && org . apache . tools . ant . Location . class . equals ( type ) ) { return true ; } if ( "setTaskType" . equals ( name ) && java . lang . String . class . equals ( type ) ) { return true ; } return false ; } public static synchronized IntrospectionHelper getHelper ( Class c ) { IntrospectionHelper ih = ( IntrospectionHelper ) helpers . get ( c ) ; if ( ih == null ) { ih = new IntrospectionHelper ( c ) ; helpers . put ( c , ih ) ; } return ih ; } public static synchronized IntrospectionHelper getHelper ( Project p , Class c ) { IntrospectionHelper ih = ( IntrospectionHelper ) helpers . get ( c ) ; if ( ih == null ) { ih = new IntrospectionHelper ( c ) ; helpers . put ( c , ih ) ; p . addBuildListener ( ih ) ; } return ih ; } public void setAttribute ( Project p , Object element , String attributeName , String value ) throws BuildException { AttributeSetter as = ( AttributeSetter ) attributeSetters . get ( attributeName ) ; if ( as == null ) { if ( element instanceof DynamicConfigurator ) { DynamicConfigurator dc = ( DynamicConfigurator ) element ; dc . setDynamicAttribute ( attributeName , value ) ; return ; } else { String msg = getElementName ( p , element ) + " doesn't support the \"" + attributeName + "\" attribute." ; throw new BuildException ( msg ) ; } } try { as . set ( p , element , value ) ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public void addText ( Project project , Object element , String text ) throws BuildException { if ( addText == null ) { if ( text . trim ( ) . length ( ) == 0 ) { return ; } else { String msg = project . getElementName ( element ) + " doesn't support nested text data." ; throw new BuildException ( msg ) ; } } try { addText . invoke ( element , new String [ ] { text } ) ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public void throwNotSupported ( Project project , Object parent , String elementName ) { String msg = project . getElementName ( parent ) + " doesn't support the nested \"" + elementName + "\" element." ; throw new BuildException ( msg ) ; } private NestedCreator getNestedCreator ( Project project , String parentUri , Object parent , String elementName ) throws BuildException { String uri = ProjectHelper . extractUriFromComponentName ( elementName ) ; String name = ProjectHelper . extractNameFromComponentName ( elementName ) ; NestedCreator nc = null ; if ( uri . equals ( parentUri ) ) { nc = ( NestedCreator ) nestedCreators . get ( name . toLowerCase ( Locale . US ) ) ; } if ( nc == null ) { nc = createAddTypeCreator ( project , parent , elementName ) ; } if ( nc == null && parent instanceof DynamicConfigurator ) { DynamicConfigurator dc = ( DynamicConfigurator ) parent ; final Object nestedElement = dc . createDynamicElement ( name . toLowerCase ( Locale . US ) ) ; if ( nestedElement != null ) { nc = new NestedCreator ( ) { public boolean isPolyMorphic ( ) { return false ; } public Class getElementClass ( ) { return null ; } public Object getRealObject ( ) { return null ; } public Object create ( Project project , Object parent , Object ignore ) { return nestedElement ; } public void store ( Object parent , Object child ) { } } ; } } if ( nc == null ) { throwNotSupported ( project , parent , elementName ) ; } return nc ; } public Object createElement ( Project project , Object parent , String elementName ) throws BuildException { NestedCreator nc = getNestedCreator ( project , "" , parent , elementName ) ; try { Object nestedElement = nc . create ( project , parent , null ) ; if ( project != null ) { project . setProjectReference ( nestedElement ) ; } return nestedElement ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InstantiationException ine ) { throw new BuildException ( ine ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public Creator getElementCreator ( Project project , String parentUri , Object parent , String elementName , UnknownElement ue ) { NestedCreator nc = getNestedCreator ( project , parentUri , parent , elementName ) ; return new Creator ( project , parent , nc ) ; } public boolean supportsNestedElement ( String elementName ) { return nestedCreators . containsKey ( elementName . toLowerCase ( Locale . US ) ) || DynamicConfigurator . class . isAssignableFrom ( bean ) || addTypeMethods . size ( ) != 0 ; } public boolean supportsNestedElement ( String parentUri , String elementName ) { String uri = ProjectHelper . extractUriFromComponentName ( elementName ) ; String name = ProjectHelper . extractNameFromComponentName ( elementName ) ; return ( nestedCreators . containsKey ( name . toLowerCase ( Locale . US ) ) && ( uri . equals ( parentUri ) ) ) || DynamicConfigurator . class . isAssignableFrom ( bean ) || addTypeMethods . size ( ) != 0 ; } public void storeElement ( Project project , Object parent , Object child , String elementName ) throws BuildException { if ( elementName == null ) { return ; } NestedCreator ns = ( NestedCreator ) nestedCreators . get ( elementName . toLowerCase ( Locale . US ) ) ; if ( ns == null ) { return ; } try { ns . store ( parent , child ) ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InstantiationException ine ) { throw new BuildException ( ine ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public Class getElementType ( String elementName ) throws BuildException { Class nt = ( Class ) nestedTypes . get ( elementName ) ; if ( nt == null ) { String msg = "Class " + bean . getName ( ) + " doesn't support the nested \"" + elementName + "\" element." ; throw new BuildException ( msg ) ; } return nt ; } public Class getAttributeType ( String attributeName ) throws BuildException { Class at = ( Class ) attributeTypes . get ( attributeName ) ; if ( at == null ) { String msg = "Class " + bean . getName ( ) + " doesn't support the \"" + attributeName + "\" attribute." ; throw new BuildException ( msg ) ; } return at ; } public boolean supportsCharacters ( ) { return addText != null ; } public Enumeration getAttributes ( ) { return attributeSetters . keys ( ) ; } public Enumeration getNestedElements ( ) { return nestedTypes . keys ( ) ; } private AttributeSetter createAttributeSetter ( final Method m , Class arg , final String attrName ) { final Class reflectedArg = PRIMITIVE_TYPE_MAP . containsKey ( arg ) ? ( Class ) PRIMITIVE_TYPE_MAP . get ( arg ) : arg ; if ( java . lang . String . class . equals ( reflectedArg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new String [ ] { value } ) ; } } ; } else if ( java . lang . Character . class . equals ( reflectedArg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { if ( value . length ( ) == 0 ) { throw new BuildException ( "The value \"\" is not a " + "legal value for attribute \"" + attrName + "\"" ) ; } m . invoke ( parent , new Character [ ] { new Character ( value . charAt ( 0 ) ) } ) ; } } ; } else if ( java . lang . Boolean . class . equals ( reflectedArg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Boolean [ ] { new Boolean ( Project . toBoolean ( value ) ) } ) ; } } ; } else if ( java . lang . Class . class . equals ( reflectedArg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException { try { m . invoke ( parent , new Class [ ] { Class . forName ( value ) } ) ; } catch ( ClassNotFoundException ce ) { throw new BuildException ( ce ) ; } } } ; } else if ( java . io . File . class . equals ( reflectedArg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new File [ ] { p . resolveFile ( value ) } ) ; } } ; } else if ( org . apache . tools . ant . types . Path . class . equals ( reflectedArg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Path [ ] { new Path ( p , value ) } ) ; } } ; } else if ( EnumeratedAttribute . class . isAssignableFrom ( reflectedArg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException { try { EnumeratedAttribute ea = ( EnumeratedAttribute ) reflectedArg . newInstance ( ) ; ea . setValue ( value ) ; m . invoke ( parent , new EnumeratedAttribute [ ] { ea } ) ; } catch ( InstantiationException ie ) { throw new BuildException ( ie ) ; } } } ; } else { try { final Constructor c = reflectedArg . getConstructor ( new Class [ ] { java . lang . String . class } ) ; return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException { try { Object attribute = c . newInstance ( new String [ ] { value } ) ; if ( p != null ) { p . setProjectReference ( attribute ) ; } m . invoke ( parent , new Object [ ] { attribute } ) ; } catch ( InstantiationException ie ) { throw new BuildException ( ie ) ; } } } ; } catch ( NoSuchMethodException nme ) { } } return null ; } protected String getElementName ( Project project , Object element ) { return project . getElementName ( element ) ; } private String getPropertyName ( String methodName , String prefix ) { int start = prefix . length ( ) ; return methodName . substring ( start ) . toLowerCase ( Locale . US ) ; } public static final class Creator { private NestedCreator nestedCreator ; private Object parent ; private Project project ; private Object nestedObject ; private String polyType ; private Creator ( Project project , Object parent , NestedCreator nestedCreator ) { this . project = project ; this . parent = parent ; this . nestedCreator = nestedCreator ; } public void setPolyType ( String polyType ) { this . polyType = polyType ; } public Object create ( ) { if ( polyType != null ) { if ( ! nestedCreator . isPolyMorphic ( ) ) { throw new BuildException ( "Not allowed to use the polymorphic form" + " for this element" ) ; } Class elementClass = nestedCreator . getElementClass ( ) ; ComponentHelper helper = ComponentHelper . getComponentHelper ( project ) ; nestedObject = ComponentHelper . getComponentHelper ( project ) . createComponent ( polyType ) ; if ( nestedObject == null ) { throw new BuildException ( "Unable to create object of type " + polyType ) ; } } try { nestedObject = nestedCreator . create ( project , parent , nestedObject ) ; if ( project != null ) { project . setProjectReference ( nestedObject ) ; } return nestedObject ; } catch ( IllegalAccessException ex ) { throw new BuildException ( ex ) ; } catch ( InstantiationException ex ) { throw new BuildException ( ex ) ; } catch ( IllegalArgumentException ex ) { if ( polyType != null ) { throw new BuildException ( "Invalid type used " + polyType ) ; } throw ex ; } catch ( InvocationTargetException ex ) { Throwable t = ex . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public Object getRealObject ( ) { return nestedCreator . getRealObject ( ) ; } public void store ( ) { try { nestedCreator . store ( parent , nestedObject ) ; } catch ( IllegalAccessException ex ) { throw new BuildException ( ex ) ; } catch ( InstantiationException ex ) { throw new BuildException ( ex ) ; } catch ( IllegalArgumentException ex ) { if ( polyType != null ) { throw new BuildException ( "Invalid type used " + polyType ) ; } throw ex ; } catch ( InvocationTargetException ex ) { Throwable t = ex . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } } private interface NestedCreator { boolean isPolyMorphic ( ) ; Class getElementClass ( ) ; Object getRealObject ( ) ; Object create ( Project project , Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException ; void store ( Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException ; } private interface AttributeSetter { void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException ; } public void buildFinished ( BuildEvent event ) { attributeTypes . clear ( ) ; attributeSetters . clear ( ) ; nestedTypes . clear ( ) ; nestedCreators . clear ( ) ; addText = null ; helpers . clear ( ) ; } public void buildStarted ( BuildEvent event ) { } public void targetStarted ( BuildEvent event ) { } public void targetFinished ( BuildEvent event ) { } public void taskStarted ( BuildEvent event ) { } public void taskFinished ( BuildEvent event ) { } public void messageLogged ( BuildEvent event ) { } private NestedCreator createAddTypeCreator ( Project project , Object parent , String elementName ) throws BuildException { if ( addTypeMethods . size ( ) == 0 ) { return null ; } ComponentHelper helper = ComponentHelper . getComponentHelper ( project ) ; Object addedObject = null ; Method addMethod = null ; Class clazz = helper . getComponentClass ( elementName ) ; if ( clazz == null ) { return null ; } addMethod = findMatchingMethod ( clazz , addTypeMethods ) ; if ( addMethod == null ) { return null ; } addedObject = helper . createComponent ( elementName ) ; if ( addedObject == null ) { return null ; } Object rObject = addedObject ; if ( addedObject instanceof PreSetDef . PreSetDefinition ) { rObject = ( ( PreSetDef . PreSetDefinition ) addedObject ) . createObject ( project ) ; } final Method method = addMethod ; final Object nestedObject = addedObject ; final Object realObject = rObject ; return new NestedCreator ( ) { public boolean isPolyMorphic ( ) { return false ; } public Class getElementClass ( ) { return null ; } public Object create ( Project project , Object parent , Object ignore ) throws InvocationTargetException , IllegalAccessException { if ( ! method . getName ( ) . endsWith ( "Configured" ) ) { method . invoke ( parent , new Object [ ] { realObject } ) ; } return nestedObject ; } public Object getRealObject ( ) { return realObject ; } public void store ( Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException { if ( method . getName ( ) . endsWith ( "Configured" ) ) { method . invoke ( parent , new Object [ ] { realObject } ) ; } } } ; } private void insertAddTypeMethod ( Method method ) { Class argClass = method . getParameterTypes ( ) [ 0 ] ; for ( int c = 0 ; c < addTypeMethods . size ( ) ; ++ c ) { Method current = ( Method ) addTypeMethods . get ( c ) ; if ( current . getParameterTypes ( ) [ 0 ] . equals ( argClass ) ) { return ; } if ( current . getParameterTypes ( ) [ 0 ] . isAssignableFrom ( argClass ) ) { addTypeMethods . add ( c , method ) ; return ; } } addTypeMethods . add ( method ) ; } private Method findMatchingMethod ( Class paramClass , List methods ) { Class matchedClass = null ; Method matchedMethod = null ; for ( int i = 0 ; i < methods . size ( ) ; ++ i ) { Method method = ( Method ) methods . get ( i ) ; Class methodClass = method . getParameterTypes ( ) [ 0 ] ; if ( methodClass . isAssignableFrom ( paramClass ) ) { if ( matchedClass == null ) { matchedClass = methodClass ; matchedMethod = method ; } else { if ( ! methodClass . isAssignableFrom ( matchedClass ) ) { throw new BuildException ( "ambiguous: types " + matchedClass . getName ( ) + " and " + methodClass . getName ( ) + " match " + paramClass . getName ( ) ) ; } } } } return matchedMethod ; } } 	1	['33', '1', '0', '29', '100', '420', '19', '25', '22', '0.902777778', '1585', '0.333333333', '0', '0', '0.28125', '0', '0', '46.21212121', '17', '2.1818', '3']
package org . apache . tools . ant . util ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public final class TaskLogger { private Task m_task ; public TaskLogger ( final Task task ) { this . m_task = task ; } public void info ( final String message ) { m_task . log ( message , Project . MSG_INFO ) ; } public void error ( final String message ) { m_task . log ( message , Project . MSG_ERR ) ; } public void warning ( final String message ) { m_task . log ( message , Project . MSG_WARN ) ; } public void verbose ( final String message ) { m_task . log ( message , Project . MSG_VERBOSE ) ; } public void debug ( final String message ) { m_task . log ( message , Project . MSG_DEBUG ) ; } } 	0	['6', '1', '0', '1', '8', '0', '0', '1', '6', '0', '43', '1', '1', '0', '0.666666667', '0', '0', '6', '1', '0.8333', '0']
package org . apache . tools . ant . types ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Stack ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . regexp . RegexpMatcher ; import org . apache . tools . ant . util . regexp . RegexpMatcherFactory ; public class PropertySet extends DataType { private boolean dynamic = true ; private Vector cachedNames ; private Vector ptyRefs = new Vector ( ) ; private Vector setRefs = new Vector ( ) ; private Mapper _mapper ; public static class PropertyRef { private int count ; private String name ; private String regex ; private String prefix ; private String builtin ; public void setName ( String name ) { assertValid ( "name" , name ) ; this . name = name ; } public void setRegex ( String regex ) { assertValid ( "regex" , regex ) ; this . regex = regex ; } public void setPrefix ( String prefix ) { assertValid ( "prefix" , prefix ) ; this . prefix = prefix ; } public void setBuiltin ( BuiltinPropertySetName b ) { String builtin = b . getValue ( ) ; assertValid ( "builtin" , builtin ) ; this . builtin = builtin ; } private void assertValid ( String attr , String value ) { if ( value == null || value . length ( ) < 1 ) { throw new BuildException ( "Invalid attribute: " + attr ) ; } if ( ++ count != 1 ) { throw new BuildException ( "Attributes name, regex, and " + "prefix are mutually exclusive" ) ; } } public String toString ( ) { return "name=" + name + ", regex=" + regex + ", prefix=" + prefix + ", builtin=" + builtin ; } } public void appendName ( String name ) { PropertyRef ref = new PropertyRef ( ) ; ref . setName ( name ) ; addPropertyref ( ref ) ; } public void appendRegex ( String regex ) { PropertyRef ref = new PropertyRef ( ) ; ref . setRegex ( regex ) ; addPropertyref ( ref ) ; } public void appendPrefix ( String prefix ) { PropertyRef ref = new PropertyRef ( ) ; ref . setPrefix ( prefix ) ; addPropertyref ( ref ) ; } public void appendBuiltin ( BuiltinPropertySetName b ) { PropertyRef ref = new PropertyRef ( ) ; ref . setBuiltin ( b ) ; addPropertyref ( ref ) ; } public void setMapper ( String type , String from , String to ) { Mapper mapper = createMapper ( ) ; Mapper . MapperType mapperType = new Mapper . MapperType ( ) ; mapperType . setValue ( type ) ; mapper . setFrom ( from ) ; mapper . setTo ( to ) ; } public void addPropertyref ( PropertyRef ref ) { assertNotReference ( ) ; ptyRefs . addElement ( ref ) ; } public void addPropertyset ( PropertySet ref ) { assertNotReference ( ) ; setRefs . addElement ( ref ) ; } public Mapper createMapper ( ) { assertNotReference ( ) ; if ( _mapper != null ) { throw new BuildException ( "Too many <mapper>s!" ) ; } _mapper = new Mapper ( getProject ( ) ) ; return _mapper ; } public void setDynamic ( boolean dynamic ) { assertNotReference ( ) ; this . dynamic = dynamic ; } public boolean getDynamic ( ) { return isReference ( ) ? getRef ( ) . dynamic : dynamic ; } public Mapper getMapper ( ) { return isReference ( ) ? getRef ( ) . _mapper : _mapper ; } public Properties getProperties ( ) { Vector names = null ; Project prj = getProject ( ) ; if ( getDynamic ( ) || cachedNames == null ) { names = new Vector ( ) ; if ( isReference ( ) ) { getRef ( ) . addPropertyNames ( names , prj . getProperties ( ) ) ; } else { addPropertyNames ( names , prj . getProperties ( ) ) ; } if ( ! getDynamic ( ) ) { cachedNames = names ; } } else { names = cachedNames ; } FileNameMapper mapper = null ; Mapper myMapper = getMapper ( ) ; if ( myMapper != null ) { mapper = myMapper . getImplementation ( ) ; } Properties properties = new Properties ( ) ; for ( Enumeration e = names . elements ( ) ; e . hasMoreElements ( ) ; ) { String name = ( String ) e . nextElement ( ) ; String value = prj . getProperty ( name ) ; if ( mapper != null ) { String [ ] newname = mapper . mapFileName ( name ) ; if ( newname != null ) { name = newname [ 0 ] ; } } properties . setProperty ( name , value ) ; } return properties ; } private void addPropertyNames ( Vector names , Hashtable properties ) { Project prj = getProject ( ) ; for ( Enumeration e = ptyRefs . elements ( ) ; e . hasMoreElements ( ) ; ) { PropertyRef ref = ( PropertyRef ) e . nextElement ( ) ; if ( ref . name != null ) { if ( prj . getProperty ( ref . name ) != null ) { names . addElement ( ref . name ) ; } } else if ( ref . prefix != null ) { for ( Enumeration p = properties . keys ( ) ; p . hasMoreElements ( ) ; ) { String name = ( String ) p . nextElement ( ) ; if ( name . startsWith ( ref . prefix ) ) { names . addElement ( name ) ; } } } else if ( ref . regex != null ) { RegexpMatcherFactory matchMaker = new RegexpMatcherFactory ( ) ; RegexpMatcher matcher = matchMaker . newRegexpMatcher ( ) ; matcher . setPattern ( ref . regex ) ; for ( Enumeration p = properties . keys ( ) ; p . hasMoreElements ( ) ; ) { String name = ( String ) p . nextElement ( ) ; if ( matcher . matches ( name ) ) { names . addElement ( name ) ; } } } else if ( ref . builtin != null ) { Enumeration e2 = null ; if ( ref . builtin . equals ( BuiltinPropertySetName . ALL ) ) { e2 = properties . keys ( ) ; } else if ( ref . builtin . equals ( BuiltinPropertySetName . SYSTEM ) ) { e2 = System . getProperties ( ) . keys ( ) ; } else if ( ref . builtin . equals ( BuiltinPropertySetName . COMMANDLINE ) ) { e2 = getProject ( ) . getUserProperties ( ) . keys ( ) ; } else { throw new BuildException ( "Impossible: Invalid builtin " + "attribute!" ) ; } while ( e2 . hasMoreElements ( ) ) { names . addElement ( e2 . nextElement ( ) ) ; } } else { throw new BuildException ( "Impossible: Invalid PropertyRef!" ) ; } } for ( Enumeration e = setRefs . elements ( ) ; e . hasMoreElements ( ) ; ) { PropertySet set = ( PropertySet ) e . nextElement ( ) ; set . addPropertyNames ( names , properties ) ; } } protected PropertySet getRef ( ) { if ( ! isChecked ( ) ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , getProject ( ) ) ; } Object o = getRefid ( ) . getReferencedObject ( getProject ( ) ) ; if ( ! ( o instanceof PropertySet ) ) { String msg = getRefid ( ) . getRefId ( ) + " doesn\'t denote a propertyset" ; throw new BuildException ( msg ) ; } else { return ( PropertySet ) o ; } } public final void setRefid ( Reference r ) { if ( ! noAttributeSet ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } protected final void assertNotReference ( ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } noAttributeSet = false ; } private boolean noAttributeSet = true ; public static class BuiltinPropertySetName extends EnumeratedAttribute { static final String ALL = "all" ; static final String SYSTEM = "system" ; static final String COMMANDLINE = "commandline" ; public String [ ] getValues ( ) { return new String [ ] { ALL , SYSTEM , COMMANDLINE } ; } } } 	1	['17', '3', '0', '19', '67', '112', '6', '13', '14', '0.770833333', '468', '1', '1', '0.652173913', '0.183006536', '1', '1', '26.17647059', '16', '2.7059', '2']
package org . apache . tools . ant . types . selectors ; import java . util . Enumeration ; import java . io . File ; import org . apache . tools . ant . Project ; public class SelectSelector extends BaseSelectorContainer { private String ifProperty ; private String unlessProperty ; public SelectSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{select" ) ; if ( ifProperty != null ) { buf . append ( " if: " ) ; buf . append ( ifProperty ) ; } if ( unlessProperty != null ) { buf . append ( " unless: " ) ; buf . append ( unlessProperty ) ; } buf . append ( " " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } private SelectSelector getRef ( ) { Object o = getCheckedRef ( this . getClass ( ) , "SelectSelector" ) ; return ( SelectSelector ) o ; } public boolean hasSelectors ( ) { if ( isReference ( ) ) { return getRef ( ) . hasSelectors ( ) ; } return super . hasSelectors ( ) ; } public int selectorCount ( ) { if ( isReference ( ) ) { return getRef ( ) . selectorCount ( ) ; } return super . selectorCount ( ) ; } public FileSelector [ ] getSelectors ( Project p ) { if ( isReference ( ) ) { return getRef ( ) . getSelectors ( p ) ; } return super . getSelectors ( p ) ; } public Enumeration selectorElements ( ) { if ( isReference ( ) ) { return getRef ( ) . selectorElements ( ) ; } return super . selectorElements ( ) ; } public void appendSelector ( FileSelector selector ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } super . appendSelector ( selector ) ; } public void verifySettings ( ) { int cnt = selectorCount ( ) ; if ( cnt < 0 || cnt > 1 ) { setError ( "Only one selector is allowed within the " + "<selector> tag" ) ; } } public boolean passesConditions ( ) { if ( ifProperty != null && getProject ( ) . getProperty ( ifProperty ) == null ) { return false ; } else if ( unlessProperty != null && getProject ( ) . getProperty ( unlessProperty ) != null ) { return false ; } return true ; } public void setIf ( String ifProperty ) { this . ifProperty = ifProperty ; } public void setUnless ( String unlessProperty ) { this . unlessProperty = unlessProperty ; } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; if ( ! ( passesConditions ( ) ) ) { return false ; } Enumeration e = selectorElements ( ) ; if ( ! ( e . hasMoreElements ( ) ) ) { return true ; } FileSelector f = ( FileSelector ) e . nextElement ( ) ; return f . isSelected ( basedir , filename , file ) ; } } 	0	['13', '5', '0', '11', '34', '68', '5', '7', '12', '0.75', '199', '1', '0', '0.837837838', '0.292307692', '2', '8', '14.15384615', '5', '2.1538', '0']
package org . apache . tools . ant ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . PrintStream ; import java . io . StringReader ; import org . apache . tools . ant . util . DateUtils ; import org . apache . tools . ant . util . StringUtils ; public class DefaultLogger implements BuildLogger { public static final int LEFT_COLUMN_SIZE = 12 ; protected PrintStream out ; protected PrintStream err ; protected int msgOutputLevel = Project . MSG_ERR ; private long startTime = System . currentTimeMillis ( ) ; protected static final String lSep = StringUtils . LINE_SEP ; protected boolean emacsMode = false ; public DefaultLogger ( ) { } public void setMessageOutputLevel ( int level ) { this . msgOutputLevel = level ; } public void setOutputPrintStream ( PrintStream output ) { this . out = new PrintStream ( output , true ) ; } public void setErrorPrintStream ( PrintStream err ) { this . err = new PrintStream ( err , true ) ; } public void setEmacsMode ( boolean emacsMode ) { this . emacsMode = emacsMode ; } public void buildStarted ( BuildEvent event ) { startTime = System . currentTimeMillis ( ) ; } public void buildFinished ( BuildEvent event ) { Throwable error = event . getException ( ) ; StringBuffer message = new StringBuffer ( ) ; if ( error == null ) { message . append ( StringUtils . LINE_SEP ) ; message . append ( "BUILD SUCCESSFUL" ) ; } else { message . append ( StringUtils . LINE_SEP ) ; message . append ( "BUILD FAILED" ) ; message . append ( StringUtils . LINE_SEP ) ; if ( Project . MSG_VERBOSE <= msgOutputLevel || ! ( error instanceof BuildException ) ) { message . append ( StringUtils . getStackTrace ( error ) ) ; } else { if ( error instanceof BuildException ) { message . append ( error . toString ( ) ) . append ( lSep ) ; } else { message . append ( error . getMessage ( ) ) . append ( lSep ) ; } } } message . append ( StringUtils . LINE_SEP ) ; message . append ( "Total time: " ) ; message . append ( formatTime ( System . currentTimeMillis ( ) - startTime ) ) ; String msg = message . toString ( ) ; if ( error == null ) { printMessage ( msg , out , Project . MSG_VERBOSE ) ; } else { printMessage ( msg , err , Project . MSG_ERR ) ; } log ( msg ) ; } public void targetStarted ( BuildEvent event ) { if ( Project . MSG_INFO <= msgOutputLevel && ! event . getTarget ( ) . getName ( ) . equals ( "" ) ) { String msg = StringUtils . LINE_SEP + event . getTarget ( ) . getName ( ) + ":" ; printMessage ( msg , out , event . getPriority ( ) ) ; log ( msg ) ; } } public void targetFinished ( BuildEvent event ) { } public void taskStarted ( BuildEvent event ) { } public void taskFinished ( BuildEvent event ) { } public void messageLogged ( BuildEvent event ) { int priority = event . getPriority ( ) ; if ( priority <= msgOutputLevel ) { StringBuffer message = new StringBuffer ( ) ; if ( event . getTask ( ) != null && ! emacsMode ) { String name = event . getTask ( ) . getTaskName ( ) ; String label = "[" + name + "] " ; int size = LEFT_COLUMN_SIZE - label . length ( ) ; StringBuffer tmp = new StringBuffer ( ) ; for ( int i = 0 ; i < size ; i ++ ) { tmp . append ( " " ) ; } tmp . append ( label ) ; label = tmp . toString ( ) ; try { BufferedReader r = new BufferedReader ( new StringReader ( event . getMessage ( ) ) ) ; String line = r . readLine ( ) ; boolean first = true ; while ( line != null ) { if ( ! first ) { message . append ( StringUtils . LINE_SEP ) ; } first = false ; message . append ( label ) . append ( line ) ; line = r . readLine ( ) ; } } catch ( IOException e ) { message . append ( label ) . append ( event . getMessage ( ) ) ; } } else { message . append ( event . getMessage ( ) ) ; } String msg = message . toString ( ) ; if ( priority != Project . MSG_ERR ) { printMessage ( msg , out , priority ) ; } else { printMessage ( msg , err , priority ) ; } log ( msg ) ; } } protected static String formatTime ( final long millis ) { return DateUtils . formatElapsedTime ( millis ) ; } protected void printMessage ( final String message , final PrintStream stream , final int priority ) { stream . println ( message ) ; } protected void log ( String message ) { } } 	1	['16', '1', '3', '13', '39', '80', '6', '7', '12', '0.876190476', '341', '0.857142857', '0', '0', '0.285714286', '0', '0', '19.875', '8', '1.75', '1']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Parameter ; public class FilenameSelector extends BaseExtendSelector { private String pattern = null ; private boolean casesensitive = true ; private boolean negated = false ; public static final String NAME_KEY = "name" ; public static final String CASE_KEY = "casesensitive" ; public static final String NEGATE_KEY = "negate" ; public FilenameSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{filenameselector name: " ) ; buf . append ( pattern ) ; buf . append ( " negate: " ) ; if ( negated ) { buf . append ( "true" ) ; } else { buf . append ( "false" ) ; } buf . append ( " casesensitive: " ) ; if ( casesensitive ) { buf . append ( "true" ) ; } else { buf . append ( "false" ) ; } buf . append ( "}" ) ; return buf . toString ( ) ; } public void setName ( String pattern ) { pattern = pattern . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( pattern . endsWith ( File . separator ) ) { pattern += "**" ; } this . pattern = pattern ; } public void setCasesensitive ( boolean casesensitive ) { this . casesensitive = casesensitive ; } public void setNegate ( boolean negated ) { this . negated = negated ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( NAME_KEY . equalsIgnoreCase ( paramname ) ) { setName ( parameters [ i ] . getValue ( ) ) ; } else if ( CASE_KEY . equalsIgnoreCase ( paramname ) ) { setCasesensitive ( Project . toBoolean ( parameters [ i ] . getValue ( ) ) ) ; } else if ( NEGATE_KEY . equalsIgnoreCase ( paramname ) ) { setNegate ( Project . toBoolean ( parameters [ i ] . getValue ( ) ) ) ; } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( pattern == null ) { setError ( "The name attribute is required" ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; return ( SelectorUtils . matchPath ( pattern , filename , casesensitive ) == ! ( negated ) ) ; } } 	0	['8', '5', '0', '10', '23', '0', '5', '5', '8', '0.761904762', '198', '0.5', '0', '0.844444444', '0.35', '1', '4', '23', '6', '2.25', '0']
package org . apache . tools . tar ; import java . io . FilterInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public class TarInputStream extends FilterInputStream { protected boolean debug ; protected boolean hasHitEOF ; protected int entrySize ; protected int entryOffset ; protected byte [ ] oneBuf ; protected byte [ ] readBuf ; protected TarBuffer buffer ; protected TarEntry currEntry ; private boolean v7Format ; public TarInputStream ( InputStream is ) { this ( is , TarBuffer . DEFAULT_BLKSIZE , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarInputStream ( InputStream is , int blockSize ) { this ( is , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarInputStream ( InputStream is , int blockSize , int recordSize ) { super ( is ) ; this . buffer = new TarBuffer ( is , blockSize , recordSize ) ; this . readBuf = null ; this . oneBuf = new byte [ 1 ] ; this . debug = false ; this . hasHitEOF = false ; this . v7Format = false ; } public void setDebug ( boolean debug ) { this . debug = debug ; this . buffer . setDebug ( debug ) ; } public void close ( ) throws IOException { this . buffer . close ( ) ; } public int getRecordSize ( ) { return this . buffer . getRecordSize ( ) ; } public int available ( ) throws IOException { return this . entrySize - this . entryOffset ; } public long skip ( long numToSkip ) throws IOException { byte [ ] skipBuf = new byte [ 8 * 1024 ] ; long skip = numToSkip ; while ( skip > 0 ) { int realSkip = ( int ) ( skip > skipBuf . length ? skipBuf . length : skip ) ; int numRead = this . read ( skipBuf , 0 , realSkip ) ; if ( numRead == - 1 ) { break ; } skip -= numRead ; } return ( numToSkip - skip ) ; } public boolean markSupported ( ) { return false ; } public void mark ( int markLimit ) { } public void reset ( ) { } public TarEntry getNextEntry ( ) throws IOException { if ( this . hasHitEOF ) { return null ; } if ( this . currEntry != null ) { int numToSkip = this . entrySize - this . entryOffset ; if ( this . debug ) { System . err . println ( "TarInputStream: SKIP currENTRY '" + this . currEntry . getName ( ) + "' SZ " + this . entrySize + " OFF " + this . entryOffset + "  skipping " + numToSkip + " bytes" ) ; } if ( numToSkip > 0 ) { this . skip ( numToSkip ) ; } this . readBuf = null ; } byte [ ] headerBuf = this . buffer . readRecord ( ) ; if ( headerBuf == null ) { if ( this . debug ) { System . err . println ( "READ NULL RECORD" ) ; } this . hasHitEOF = true ; } else if ( this . buffer . isEOFRecord ( headerBuf ) ) { if ( this . debug ) { System . err . println ( "READ EOF RECORD" ) ; } this . hasHitEOF = true ; } if ( this . hasHitEOF ) { this . currEntry = null ; } else { this . currEntry = new TarEntry ( headerBuf ) ; if ( ! ( headerBuf [ 257 ] == 'u' && headerBuf [ 258 ] == 's' && headerBuf [ 259 ] == 't' && headerBuf [ 260 ] == 'a' && headerBuf [ 261 ] == 'r' ) ) { this . v7Format = true ; } if ( this . debug ) { System . err . println ( "TarInputStream: SET CURRENTRY '" + this . currEntry . getName ( ) + "' size = " + this . currEntry . getSize ( ) ) ; } this . entryOffset = 0 ; this . entrySize = ( int ) this . currEntry . getSize ( ) ; } if ( this . currEntry != null && this . currEntry . isGNULongNameEntry ( ) ) { StringBuffer longName = new StringBuffer ( ) ; byte [ ] buffer = new byte [ 256 ] ; int length = 0 ; while ( ( length = read ( buffer ) ) >= 0 ) { longName . append ( new String ( buffer , 0 , length ) ) ; } getNextEntry ( ) ; if ( longName . length ( ) > 0 && longName . charAt ( longName . length ( ) - 1 ) == 0 ) { longName . deleteCharAt ( longName . length ( ) - 1 ) ; } this . currEntry . setName ( longName . toString ( ) ) ; } return this . currEntry ; } public int read ( ) throws IOException { int num = this . read ( this . oneBuf , 0 , 1 ) ; if ( num == - 1 ) { return num ; } else { return ( int ) this . oneBuf [ 0 ] ; } } public int read ( byte [ ] buf ) throws IOException { return this . read ( buf , 0 , buf . length ) ; } public int read ( byte [ ] buf , int offset , int numToRead ) throws IOException { int totalRead = 0 ; if ( this . entryOffset >= this . entrySize ) { return - 1 ; } if ( ( numToRead + this . entryOffset ) > this . entrySize ) { numToRead = ( this . entrySize - this . entryOffset ) ; } if ( this . readBuf != null ) { int sz = ( numToRead > this . readBuf . length ) ? this . readBuf . length : numToRead ; System . arraycopy ( this . readBuf , 0 , buf , offset , sz ) ; if ( sz >= this . readBuf . length ) { this . readBuf = null ; } else { int newLen = this . readBuf . length - sz ; byte [ ] newBuf = new byte [ newLen ] ; System . arraycopy ( this . readBuf , sz , newBuf , 0 , newLen ) ; this . readBuf = newBuf ; } totalRead += sz ; numToRead -= sz ; offset += sz ; } while ( numToRead > 0 ) { byte [ ] rec = this . buffer . readRecord ( ) ; if ( rec == null ) { throw new IOException ( "unexpected EOF with " + numToRead + " bytes unread" ) ; } int sz = numToRead ; int recLen = rec . length ; if ( recLen > sz ) { System . arraycopy ( rec , 0 , buf , offset , sz ) ; this . readBuf = new byte [ recLen - sz ] ; System . arraycopy ( rec , sz , this . readBuf , 0 , recLen - sz ) ; } else { sz = recLen ; System . arraycopy ( rec , 0 , buf , offset , recLen ) ; } totalRead += sz ; numToRead -= sz ; offset += sz ; } this . entryOffset += totalRead ; return totalRead ; } public void copyEntryContents ( OutputStream out ) throws IOException { byte [ ] buf = new byte [ 32 * 1024 ] ; while ( true ) { int numRead = this . read ( buf , 0 , buf . length ) ; if ( numRead == - 1 ) { break ; } out . write ( buf , 0 , numRead ) ; } } } 	1	['16', '3', '0', '3', '41', '84', '1', '2', '16', '0.674074074', '559', '1', '2', '0.580645161', '0.25', '2', '8', '33.375', '1', '0.8125', '3']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Parameter ; public class TypeSelector extends BaseExtendSelector { private String type = null ; public static final String TYPE_KEY = "type" ; public TypeSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{typeselector type: " ) ; buf . append ( type ) ; buf . append ( "}" ) ; return buf . toString ( ) ; } public void setType ( FileType fileTypes ) { this . type = fileTypes . getValue ( ) ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( TYPE_KEY . equalsIgnoreCase ( paramname ) ) { FileType type = new FileType ( ) ; type . setValue ( parameters [ i ] . getValue ( ) ) ; setType ( type ) ; } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( type == null ) { setError ( "The type attribute is required" ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; if ( file . isDirectory ( ) ) { return type . equals ( FileType . DIR ) ; } else { return type . equals ( FileType . FILE ) ; } } public static class FileType extends EnumeratedAttribute { public static final String FILE = "file" ; public static final String DIR = "dir" ; public String [ ] getValues ( ) { return new String [ ] { FILE , DIR } ; } } } 	0	['6', '5', '0', '9', '22', '0', '4', '5', '6', '0.6', '105', '0.5', '0', '0.88372093', '0.333333333', '2', '5', '16.16666667', '4', '1.6667', '0']
package org . apache . tools . ant . helper ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; import java . util . Locale ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . IntrospectionHelper ; import org . apache . tools . ant . Location ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . RuntimeConfigurable ; import org . apache . tools . ant . Target ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TypeAdapter ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . UnknownElement ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JAXPUtils ; import org . xml . sax . AttributeList ; import org . xml . sax . DocumentHandler ; import org . xml . sax . HandlerBase ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import org . xml . sax . helpers . XMLReaderAdapter ; public class ProjectHelperImpl extends ProjectHelper { private org . xml . sax . Parser parser ; private Project project ; private File buildFile ; private File buildFileParent ; private Locator locator ; private Target implicitTarget = new Target ( ) ; private static FileUtils fu = FileUtils . newFileUtils ( ) ; public ProjectHelperImpl ( ) { implicitTarget . setName ( "" ) ; } public void parse ( Project project , Object source ) throws BuildException { if ( ! ( source instanceof File ) ) { throw new BuildException ( "Only File source supported by " + "default plugin" ) ; } File buildFile = ( File ) source ; FileInputStream inputStream = null ; InputSource inputSource = null ; this . project = project ; this . buildFile = new File ( buildFile . getAbsolutePath ( ) ) ; buildFileParent = new File ( this . buildFile . getParent ( ) ) ; try { try { parser = JAXPUtils . getParser ( ) ; } catch ( BuildException e ) { parser = new XMLReaderAdapter ( JAXPUtils . getXMLReader ( ) ) ; } String uri = fu . toURI ( buildFile . getAbsolutePath ( ) ) ; inputStream = new FileInputStream ( buildFile ) ; inputSource = new InputSource ( inputStream ) ; inputSource . setSystemId ( uri ) ; project . log ( "parsing buildfile " + buildFile + " with URI = " + uri , Project . MSG_VERBOSE ) ; HandlerBase hb = new RootHandler ( this ) ; parser . setDocumentHandler ( hb ) ; parser . setEntityResolver ( hb ) ; parser . setErrorHandler ( hb ) ; parser . setDTDHandler ( hb ) ; parser . parse ( inputSource ) ; } catch ( SAXParseException exc ) { Location location = new Location ( exc . getSystemId ( ) , exc . getLineNumber ( ) , exc . getColumnNumber ( ) ) ; Throwable t = exc . getException ( ) ; if ( t instanceof BuildException ) { BuildException be = ( BuildException ) t ; if ( be . getLocation ( ) == Location . UNKNOWN_LOCATION ) { be . setLocation ( location ) ; } throw be ; } throw new BuildException ( exc . getMessage ( ) , t , location ) ; } catch ( SAXException exc ) { Throwable t = exc . getException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( exc . getMessage ( ) , t ) ; } catch ( FileNotFoundException exc ) { throw new BuildException ( exc ) ; } catch ( UnsupportedEncodingException exc ) { throw new BuildException ( "Encoding of project file is invalid." , exc ) ; } catch ( IOException exc ) { throw new BuildException ( "Error reading project file: " + exc . getMessage ( ) , exc ) ; } finally { if ( inputStream != null ) { try { inputStream . close ( ) ; } catch ( IOException ioe ) { } } } } static class AbstractHandler extends HandlerBase { protected DocumentHandler parentHandler ; ProjectHelperImpl helperImpl ; public AbstractHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler ) { this . parentHandler = parentHandler ; this . helperImpl = helperImpl ; helperImpl . parser . setDocumentHandler ( this ) ; } public void startElement ( String tag , AttributeList attrs ) throws SAXParseException { throw new SAXParseException ( "Unexpected element \"" + tag + "\"" , helperImpl . locator ) ; } public void characters ( char [ ] buf , int start , int count ) throws SAXParseException { String s = new String ( buf , start , count ) . trim ( ) ; if ( s . length ( ) > 0 ) { throw new SAXParseException ( "Unexpected text \"" + s + "\"" , helperImpl . locator ) ; } } public void endElement ( String name ) throws SAXException { helperImpl . parser . setDocumentHandler ( parentHandler ) ; } } static class RootHandler extends HandlerBase { ProjectHelperImpl helperImpl ; public RootHandler ( ProjectHelperImpl helperImpl ) { this . helperImpl = helperImpl ; } public InputSource resolveEntity ( String publicId , String systemId ) { helperImpl . project . log ( "resolving systemId: " + systemId , Project . MSG_VERBOSE ) ; if ( systemId . startsWith ( "file:" ) ) { String path = fu . fromURI ( systemId ) ; File file = new File ( path ) ; if ( ! file . isAbsolute ( ) ) { file = fu . resolveFile ( helperImpl . buildFileParent , path ) ; } try { InputSource inputSource = new InputSource ( new FileInputStream ( file ) ) ; inputSource . setSystemId ( fu . toURI ( file . getAbsolutePath ( ) ) ) ; return inputSource ; } catch ( FileNotFoundException fne ) { helperImpl . project . log ( file . getAbsolutePath ( ) + " could not be found" , Project . MSG_WARN ) ; } } return null ; } public void startElement ( String tag , AttributeList attrs ) throws SAXParseException { if ( tag . equals ( "project" ) ) { new ProjectHandler ( helperImpl , this ) . init ( tag , attrs ) ; } else { throw new SAXParseException ( "Config file is not of expected " + "XML type" , helperImpl . locator ) ; } } public void setDocumentLocator ( Locator locator ) { helperImpl . locator = locator ; } } static class ProjectHandler extends AbstractHandler { public ProjectHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler ) { super ( helperImpl , parentHandler ) ; } public void init ( String tag , AttributeList attrs ) throws SAXParseException { String def = null ; String name = null ; String id = null ; String baseDir = null ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String key = attrs . getName ( i ) ; String value = attrs . getValue ( i ) ; if ( key . equals ( "default" ) ) { def = value ; } else if ( key . equals ( "name" ) ) { name = value ; } else if ( key . equals ( "id" ) ) { id = value ; } else if ( key . equals ( "basedir" ) ) { baseDir = value ; } else { throw new SAXParseException ( "Unexpected attribute \"" + attrs . getName ( i ) + "\"" , helperImpl . locator ) ; } } if ( def != null && ! def . equals ( "" ) ) { helperImpl . project . setDefaultTarget ( def ) ; } else { throw new BuildException ( "The default attribute is required" ) ; } if ( name != null ) { helperImpl . project . setName ( name ) ; helperImpl . project . addReference ( name , helperImpl . project ) ; } if ( id != null ) { helperImpl . project . addReference ( id , helperImpl . project ) ; } if ( helperImpl . project . getProperty ( "basedir" ) != null ) { helperImpl . project . setBasedir ( helperImpl . project . getProperty ( "basedir" ) ) ; } else { if ( baseDir == null ) { helperImpl . project . setBasedir ( helperImpl . buildFileParent . getAbsolutePath ( ) ) ; } else { if ( ( new File ( baseDir ) ) . isAbsolute ( ) ) { helperImpl . project . setBasedir ( baseDir ) ; } else { File resolvedBaseDir = helperImpl . project . resolveFile ( baseDir , helperImpl . buildFileParent ) ; helperImpl . project . setBaseDir ( resolvedBaseDir ) ; } } } helperImpl . project . addTarget ( "" , helperImpl . implicitTarget ) ; } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { if ( name . equals ( "target" ) ) { handleTarget ( name , attrs ) ; } else { handleElement ( helperImpl , this , helperImpl . implicitTarget , name , attrs ) ; } } private void handleTarget ( String tag , AttributeList attrs ) throws SAXParseException { new TargetHandler ( helperImpl , this ) . init ( tag , attrs ) ; } } static class TargetHandler extends AbstractHandler { private Target target ; public TargetHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler ) { super ( helperImpl , parentHandler ) ; } public void init ( String tag , AttributeList attrs ) throws SAXParseException { String name = null ; String depends = "" ; String ifCond = null ; String unlessCond = null ; String id = null ; String description = null ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String key = attrs . getName ( i ) ; String value = attrs . getValue ( i ) ; if ( key . equals ( "name" ) ) { name = value ; if ( name . equals ( "" ) ) { throw new BuildException ( "name attribute must not" + " be empty" , new Location ( helperImpl . locator ) ) ; } } else if ( key . equals ( "depends" ) ) { depends = value ; } else if ( key . equals ( "if" ) ) { ifCond = value ; } else if ( key . equals ( "unless" ) ) { unlessCond = value ; } else if ( key . equals ( "id" ) ) { id = value ; } else if ( key . equals ( "description" ) ) { description = value ; } else { throw new SAXParseException ( "Unexpected attribute \"" + key + "\"" , helperImpl . locator ) ; } } if ( name == null ) { throw new SAXParseException ( "target element appears without a name attribute" , helperImpl . locator ) ; } target = new Target ( ) ; target . addDependency ( "" ) ; target . setName ( name ) ; target . setIf ( ifCond ) ; target . setUnless ( unlessCond ) ; target . setDescription ( description ) ; helperImpl . project . addTarget ( name , target ) ; if ( id != null && ! id . equals ( "" ) ) { helperImpl . project . addReference ( id , target ) ; } if ( depends . length ( ) > 0 ) { target . setDepends ( depends ) ; } } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { handleElement ( helperImpl , this , target , name , attrs ) ; } } private static void handleElement ( ProjectHelperImpl helperImpl , DocumentHandler parent , Target target , String elementName , AttributeList attrs ) throws SAXParseException { if ( elementName . equals ( "description" ) ) { new DescriptionHandler ( helperImpl , parent ) ; } else if ( helperImpl . project . getDataTypeDefinitions ( ) . get ( elementName ) != null ) { new DataTypeHandler ( helperImpl , parent , target ) . init ( elementName , attrs ) ; } else { new TaskHandler ( helperImpl , parent , target , null , target ) . init ( elementName , attrs ) ; } } static class DescriptionHandler extends AbstractHandler { public DescriptionHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler ) { super ( helperImpl , parentHandler ) ; } public void characters ( char [ ] buf , int start , int count ) { String text = new String ( buf , start , count ) ; String currentDescription = helperImpl . project . getDescription ( ) ; if ( currentDescription == null ) { helperImpl . project . setDescription ( text ) ; } else { helperImpl . project . setDescription ( currentDescription + text ) ; } } } static class TaskHandler extends AbstractHandler { private Target target ; private TaskContainer container ; private Task task ; private RuntimeConfigurable parentWrapper ; private RuntimeConfigurable wrapper = null ; public TaskHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler , TaskContainer container , RuntimeConfigurable parentWrapper , Target target ) { super ( helperImpl , parentHandler ) ; this . container = container ; this . parentWrapper = parentWrapper ; this . target = target ; } public void init ( String tag , AttributeList attrs ) throws SAXParseException { try { task = helperImpl . project . createTask ( tag ) ; } catch ( BuildException e ) { } if ( task == null ) { task = new UnknownElement ( tag ) ; task . setProject ( helperImpl . project ) ; task . setTaskName ( tag ) ; } task . setLocation ( new Location ( helperImpl . locator ) ) ; helperImpl . configureId ( task , attrs ) ; task . setOwningTarget ( target ) ; container . addTask ( task ) ; task . init ( ) ; wrapper = task . getRuntimeConfigurableWrapper ( ) ; wrapper . setAttributes ( attrs ) ; if ( parentWrapper != null ) { parentWrapper . addChild ( wrapper ) ; } } public void characters ( char [ ] buf , int start , int count ) { wrapper . addText ( buf , start , count ) ; } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { if ( task instanceof TaskContainer ) { new TaskHandler ( helperImpl , this , ( TaskContainer ) task , wrapper , target ) . init ( name , attrs ) ; } else { new NestedElementHandler ( helperImpl , this , task , wrapper , target ) . init ( name , attrs ) ; } } } static class NestedElementHandler extends AbstractHandler { private Object parent ; private Object child ; private RuntimeConfigurable parentWrapper ; private RuntimeConfigurable childWrapper = null ; private Target target ; public NestedElementHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler , Object parent , RuntimeConfigurable parentWrapper , Target target ) { super ( helperImpl , parentHandler ) ; if ( parent instanceof TypeAdapter ) { this . parent = ( ( TypeAdapter ) parent ) . getProxy ( ) ; } else { this . parent = parent ; } this . parentWrapper = parentWrapper ; this . target = target ; } public void init ( String propType , AttributeList attrs ) throws SAXParseException { Class parentClass = parent . getClass ( ) ; IntrospectionHelper ih = IntrospectionHelper . getHelper ( parentClass ) ; try { String elementName = propType . toLowerCase ( Locale . US ) ; if ( parent instanceof UnknownElement ) { UnknownElement uc = new UnknownElement ( elementName ) ; uc . setProject ( helperImpl . project ) ; ( ( UnknownElement ) parent ) . addChild ( uc ) ; child = uc ; } else { child = ih . createElement ( helperImpl . project , parent , elementName ) ; } helperImpl . configureId ( child , attrs ) ; childWrapper = new RuntimeConfigurable ( child , propType ) ; childWrapper . setAttributes ( attrs ) ; parentWrapper . addChild ( childWrapper ) ; } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , helperImpl . locator , exc ) ; } } public void characters ( char [ ] buf , int start , int count ) { childWrapper . addText ( buf , start , count ) ; } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { if ( child instanceof TaskContainer ) { new TaskHandler ( helperImpl , this , ( TaskContainer ) child , childWrapper , target ) . init ( name , attrs ) ; } else { new NestedElementHandler ( helperImpl , this , child , childWrapper , target ) . init ( name , attrs ) ; } } } static class DataTypeHandler extends AbstractHandler { private Target target ; private Object element ; private RuntimeConfigurable wrapper = null ; public DataTypeHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler , Target target ) { super ( helperImpl , parentHandler ) ; this . target = target ; } public void init ( String propType , AttributeList attrs ) throws SAXParseException { try { element = helperImpl . project . createDataType ( propType ) ; if ( element == null ) { throw new BuildException ( "Unknown data type " + propType ) ; } wrapper = new RuntimeConfigurable ( element , propType ) ; wrapper . setAttributes ( attrs ) ; target . addDataType ( wrapper ) ; } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , helperImpl . locator , exc ) ; } } public void characters ( char [ ] buf , int start , int count ) { wrapper . addText ( buf , start , count ) ; } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { new NestedElementHandler ( helperImpl , this , element , wrapper , target ) . init ( name , attrs ) ; } } private void configureId ( Object target , AttributeList attr ) { String id = attr . getValue ( "id" ) ; if ( id != null ) { project . addReference ( id , target ) ; } } } 	1	['14', '2', '0', '18', '63', '65', '9', '13', '2', '0.879120879', '322', '1', '3', '0.586206897', '0.230769231', '1', '1', '21.5', '2', '0.9286', '1']
package org . apache . tools . ant . taskdefs ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . zip . GZIPInputStream ; import org . apache . tools . ant . BuildException ; public class GUnzip extends Unpack { private static final String DEFAULT_EXTENSION = ".gz" ; protected String getDefaultExtension ( ) { return DEFAULT_EXTENSION ; } protected void extract ( ) { if ( source . lastModified ( ) > dest . lastModified ( ) ) { log ( "Expanding " + source . getAbsolutePath ( ) + " to " + dest . getAbsolutePath ( ) ) ; FileOutputStream out = null ; GZIPInputStream zIn = null ; FileInputStream fis = null ; try { out = new FileOutputStream ( dest ) ; fis = new FileInputStream ( source ) ; zIn = new GZIPInputStream ( fis ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { out . write ( buffer , 0 , count ) ; count = zIn . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } catch ( IOException ioe ) { String msg = "Problem expanding gzip " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } finally { if ( fis != null ) { try { fis . close ( ) ; } catch ( IOException ioex ) { } } if ( out != null ) { try { out . close ( ) ; } catch ( IOException ioex ) { } } if ( zIn != null ) { try { zIn . close ( ) ; } catch ( IOException ioex ) { } } } } } } 	0	['3', '4', '0', '4', '21', '3', '0', '4', '1', '1.5', '144', '1', '0', '0.960784314', '1', '2', '3', '46.66666667', '9', '3.3333', '0']
package org . apache . tools . ant . types . selectors . modifiedselector ; import java . util . Iterator ; import java . util . Vector ; import java . util . Enumeration ; import java . util . Properties ; import java . io . File ; import java . io . BufferedInputStream ; import java . io . FileInputStream ; import java . io . BufferedOutputStream ; import java . io . FileOutputStream ; public class PropertiesfileCache implements Cache { private File cachefile = null ; private Properties cache = new Properties ( ) ; private boolean cacheLoaded = false ; private boolean cacheDirty = true ; public PropertiesfileCache ( ) { } public PropertiesfileCache ( File cachefile ) { this . cachefile = cachefile ; } public void setCachefile ( File file ) { cachefile = file ; } public File getCachefile ( ) { return cachefile ; } public boolean isValid ( ) { return ( cachefile != null ) ; } public void load ( ) { if ( ( cachefile != null ) && cachefile . isFile ( ) && cachefile . canRead ( ) ) { try { BufferedInputStream bis = new BufferedInputStream ( new FileInputStream ( cachefile ) ) ; cache . load ( bis ) ; bis . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } cacheLoaded = true ; cacheDirty = false ; } public void save ( ) { if ( ! cacheDirty ) { return ; } if ( ( cachefile != null ) && cache . propertyNames ( ) . hasMoreElements ( ) ) { try { BufferedOutputStream bos = new BufferedOutputStream ( new FileOutputStream ( cachefile ) ) ; cache . store ( bos , null ) ; bos . flush ( ) ; bos . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } cacheDirty = false ; } public void delete ( ) { cache = new Properties ( ) ; cachefile . delete ( ) ; cacheLoaded = true ; cacheDirty = false ; } public Object get ( Object key ) { if ( ! cacheLoaded ) { load ( ) ; } try { return cache . getProperty ( String . valueOf ( key ) ) ; } catch ( ClassCastException e ) { return null ; } } public void put ( Object key , Object value ) { cache . put ( String . valueOf ( key ) , String . valueOf ( value ) ) ; cacheDirty = true ; } public Iterator iterator ( ) { Vector v = new java . util . Vector ( ) ; Enumeration en = cache . propertyNames ( ) ; while ( en . hasMoreElements ( ) ) { v . add ( en . nextElement ( ) ) ; } return v . iterator ( ) ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "<PropertiesfileCache:" ) ; buf . append ( "cachefile=" ) . append ( cachefile ) ; buf . append ( ";noOfEntries=" ) . append ( cache . size ( ) ) ; buf . append ( ">" ) ; return buf . toString ( ) ; } } 	1	['12', '1', '0', '2', '42', '0', '1', '1', '12', '0.386363636', '236', '1', '0', '0', '0.444444444', '0', '0', '18.33333333', '4', '1.5833', '1']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class Basename extends Task { private File file ; private String property ; private String suffix ; public void setFile ( File file ) { this . file = file ; } public void setProperty ( String property ) { this . property = property ; } public void setSuffix ( String suffix ) { this . suffix = suffix ; } public void execute ( ) throws BuildException { if ( property == null ) { throw new BuildException ( "property attribute required" , getLocation ( ) ) ; } if ( file == null ) { throw new BuildException ( "file attribute required" , getLocation ( ) ) ; } String value = file . getName ( ) ; if ( suffix != null && value . endsWith ( suffix ) ) { int pos = value . length ( ) - suffix . length ( ) ; if ( pos > 0 && suffix . charAt ( 0 ) != '.' && value . charAt ( pos - 1 ) == '.' ) { pos -- ; } value = value . substring ( 0 , pos ) ; } getProject ( ) . setNewProperty ( property , value ) ; } } 	0	['5', '3', '0', '5', '15', '4', '0', '5', '5', '0.75', '90', '1', '0', '0.902439024', '0.533333333', '0', '0', '16.4', '1', '0.8', '0']
package org . apache . tools . ant . taskdefs . rmic ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class RmicAdapterFactory { private RmicAdapterFactory ( ) { } public static RmicAdapter getRmic ( String rmicType , Task task ) throws BuildException { if ( rmicType . equalsIgnoreCase ( "sun" ) ) { return new SunRmic ( ) ; } else if ( rmicType . equalsIgnoreCase ( "kaffe" ) ) { return new KaffeRmic ( ) ; } else if ( rmicType . equalsIgnoreCase ( "weblogic" ) ) { return new WLRmic ( ) ; } return resolveClassName ( rmicType ) ; } private static RmicAdapter resolveClassName ( String className ) throws BuildException { try { Class c = Class . forName ( className ) ; Object o = c . newInstance ( ) ; return ( RmicAdapter ) o ; } catch ( ClassNotFoundException cnfe ) { throw new BuildException ( className + " can\'t be found." , cnfe ) ; } catch ( ClassCastException cce ) { throw new BuildException ( className + " isn\'t the classname of " + "a rmic adapter." , cce ) ; } catch ( Throwable t ) { throw new BuildException ( className + " caused an interesting " + "exception." , t ) ; } } } 	1	['3', '1', '0', '7', '14', '3', '1', '6', '1', '2', '88', '0', '0', '0', '0.444444444', '0', '0', '28.33333333', '1', '0.6667', '1']
package org . apache . tools . ant . types . selectors ; public interface SelectorScanner { void setSelectors ( FileSelector [ ] selectors ) ; String [ ] getDeselectedDirectories ( ) ; String [ ] getDeselectedFiles ( ) ; } 	0	['3', '1', '0', '3', '3', '3', '2', '1', '3', '2', '3', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . DynamicConfigurator ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . types . XMLCatalog ; import org . apache . tools . ant . util . FileUtils ; public class XSLTProcess extends MatchingTask implements XSLTLogger { private File destDir = null ; private File baseDir = null ; private String xslFile = null ; private String targetExtension = ".html" ; private Vector params = new Vector ( ) ; private File inFile = null ; private File outFile = null ; private String processor ; private Path classpath = null ; private XSLTLiaison liaison ; private boolean stylesheetLoaded = false ; private boolean force = false ; private FileUtils fileUtils ; private Vector outputProperties = new Vector ( ) ; private XMLCatalog xmlCatalog = new XMLCatalog ( ) ; private static final String TRAX_LIAISON_CLASS = "org.apache.tools.ant.taskdefs.optional.TraXLiaison" ; private static final String XSLP_LIAISON_CLASS = "org.apache.tools.ant.taskdefs.optional.XslpLiaison" ; private static final String XALAN_LIAISON_CLASS = "org.apache.tools.ant.taskdefs.optional.XalanLiaison" ; private boolean performDirectoryScan = true ; private Factory factory = null ; private boolean reuseLoadedStylesheet = true ; public XSLTProcess ( ) { fileUtils = FileUtils . newFileUtils ( ) ; } public void setScanIncludedDirectories ( boolean b ) { performDirectoryScan = b ; } public void setReloadStylesheet ( boolean b ) { reuseLoadedStylesheet = ! b ; } public void execute ( ) throws BuildException { File savedBaseDir = baseDir ; DirectoryScanner scanner ; String [ ] list ; String [ ] dirs ; if ( xslFile == null ) { throw new BuildException ( "no stylesheet specified" , getLocation ( ) ) ; } if ( inFile != null && ! inFile . exists ( ) ) { throw new BuildException ( "input file " + inFile . toString ( ) + " does not exist" , getLocation ( ) ) ; } try { if ( baseDir == null ) { baseDir = getProject ( ) . resolveFile ( "." ) ; } liaison = getLiaison ( ) ; if ( liaison instanceof XSLTLoggerAware ) { ( ( XSLTLoggerAware ) liaison ) . setLogger ( this ) ; } log ( "Using " + liaison . getClass ( ) . toString ( ) , Project . MSG_VERBOSE ) ; File stylesheet = getProject ( ) . resolveFile ( xslFile ) ; if ( ! stylesheet . exists ( ) ) { stylesheet = fileUtils . resolveFile ( baseDir , xslFile ) ; if ( stylesheet . exists ( ) ) { log ( "DEPRECATED - the style attribute should be relative " + "to the project\'s" ) ; log ( "             basedir, not the tasks\'s basedir." ) ; } } if ( inFile != null && outFile != null ) { process ( inFile , outFile , stylesheet ) ; return ; } if ( destDir == null ) { String msg = "destdir attributes must be set!" ; throw new BuildException ( msg ) ; } scanner = getDirectoryScanner ( baseDir ) ; log ( "Transforming into " + destDir , Project . MSG_INFO ) ; list = scanner . getIncludedFiles ( ) ; for ( int i = 0 ; i < list . length ; ++ i ) { process ( baseDir , list [ i ] , destDir , stylesheet ) ; } if ( performDirectoryScan ) { dirs = scanner . getIncludedDirectories ( ) ; for ( int j = 0 ; j < dirs . length ; ++ j ) { list = new File ( baseDir , dirs [ j ] ) . list ( ) ; for ( int i = 0 ; i < list . length ; ++ i ) { process ( baseDir , list [ i ] , destDir , stylesheet ) ; } } } } finally { liaison = null ; stylesheetLoaded = false ; baseDir = savedBaseDir ; } } public void setForce ( boolean force ) { this . force = force ; } public void setBasedir ( File dir ) { baseDir = dir ; } public void setDestdir ( File dir ) { destDir = dir ; } public void setExtension ( String name ) { targetExtension = name ; } public void setStyle ( String xslFile ) { this . xslFile = xslFile ; } public void setClasspath ( Path classpath ) { createClasspath ( ) . append ( classpath ) ; } public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( getProject ( ) ) ; } return classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setProcessor ( String processor ) { this . processor = processor ; } public void addConfiguredXMLCatalog ( XMLCatalog xmlCatalog ) { this . xmlCatalog . addConfiguredXMLCatalog ( xmlCatalog ) ; } private void resolveProcessor ( String proc ) throws Exception { if ( proc . equals ( "trax" ) ) { final Class clazz = loadClass ( TRAX_LIAISON_CLASS ) ; liaison = ( XSLTLiaison ) clazz . newInstance ( ) ; } else if ( proc . equals ( "xslp" ) ) { log ( "DEPRECATED - xslp processor is deprecated. Use trax " + "instead." ) ; final Class clazz = loadClass ( XSLP_LIAISON_CLASS ) ; liaison = ( XSLTLiaison ) clazz . newInstance ( ) ; } else if ( proc . equals ( "xalan" ) ) { log ( "DEPRECATED - xalan processor is deprecated. Use trax " + "instead." ) ; final Class clazz = loadClass ( XALAN_LIAISON_CLASS ) ; liaison = ( XSLTLiaison ) clazz . newInstance ( ) ; } else { liaison = ( XSLTLiaison ) loadClass ( proc ) . newInstance ( ) ; } } private Class loadClass ( String classname ) throws Exception { if ( classpath == null ) { return Class . forName ( classname ) ; } else { AntClassLoader al = getProject ( ) . createClassLoader ( classpath ) ; Class c = Class . forName ( classname , true , al ) ; return c ; } } public void setOut ( File outFile ) { this . outFile = outFile ; } public void setIn ( File inFile ) { this . inFile = inFile ; } private void process ( File baseDir , String xmlFile , File destDir , File stylesheet ) throws BuildException { String fileExt = targetExtension ; File outFile = null ; File inFile = null ; try { long styleSheetLastModified = stylesheet . lastModified ( ) ; inFile = new File ( baseDir , xmlFile ) ; if ( inFile . isDirectory ( ) ) { log ( "Skipping " + inFile + " it is a directory." , Project . MSG_VERBOSE ) ; return ; } int dotPos = xmlFile . lastIndexOf ( '.' ) ; if ( dotPos > 0 ) { outFile = new File ( destDir , xmlFile . substring ( 0 , xmlFile . lastIndexOf ( '.' ) ) + fileExt ) ; } else { outFile = new File ( destDir , xmlFile + fileExt ) ; } if ( force || inFile . lastModified ( ) > outFile . lastModified ( ) || styleSheetLastModified > outFile . lastModified ( ) ) { ensureDirectoryFor ( outFile ) ; log ( "Processing " + inFile + " to " + outFile ) ; configureLiaison ( stylesheet ) ; liaison . transform ( inFile , outFile ) ; } } catch ( Exception ex ) { log ( "Failed to process " + inFile , Project . MSG_INFO ) ; if ( outFile != null ) { outFile . delete ( ) ; } throw new BuildException ( ex ) ; } } private void process ( File inFile , File outFile , File stylesheet ) throws BuildException { try { long styleSheetLastModified = stylesheet . lastModified ( ) ; log ( "In file " + inFile + " time: " + inFile . lastModified ( ) , Project . MSG_DEBUG ) ; log ( "Out file " + outFile + " time: " + outFile . lastModified ( ) , Project . MSG_DEBUG ) ; log ( "Style file " + xslFile + " time: " + styleSheetLastModified , Project . MSG_DEBUG ) ; if ( force || inFile . lastModified ( ) >= outFile . lastModified ( ) || styleSheetLastModified >= outFile . lastModified ( ) ) { ensureDirectoryFor ( outFile ) ; log ( "Processing " + inFile + " to " + outFile , Project . MSG_INFO ) ; configureLiaison ( stylesheet ) ; liaison . transform ( inFile , outFile ) ; } else { log ( "Skipping input file " + inFile + " because it is older than output file " + outFile + " and so is the stylesheet " + stylesheet , Project . MSG_DEBUG ) ; } } catch ( Exception ex ) { log ( "Failed to process " + inFile , Project . MSG_INFO ) ; if ( outFile != null ) { outFile . delete ( ) ; } throw new BuildException ( ex ) ; } } private void ensureDirectoryFor ( File targetFile ) throws BuildException { File directory = fileUtils . getParentFile ( targetFile ) ; if ( ! directory . exists ( ) ) { if ( ! directory . mkdirs ( ) ) { throw new BuildException ( "Unable to create directory: " + directory . getAbsolutePath ( ) ) ; } } } public Factory getFactory ( ) { return factory ; } public XMLCatalog getXMLCatalog ( ) { return xmlCatalog ; } public Enumeration getOutputProperties ( ) { return outputProperties . elements ( ) ; } protected XSLTLiaison getLiaison ( ) { if ( liaison == null ) { if ( processor != null ) { try { resolveProcessor ( processor ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } else { try { resolveProcessor ( "trax" ) ; } catch ( Throwable e1 ) { try { resolveProcessor ( "xalan" ) ; } catch ( Throwable e2 ) { try { resolveProcessor ( "xslp" ) ; } catch ( Throwable e3 ) { e3 . printStackTrace ( ) ; e2 . printStackTrace ( ) ; throw new BuildException ( e1 ) ; } } } } } return liaison ; } public Param createParam ( ) { Param p = new Param ( ) ; params . addElement ( p ) ; return p ; } public static class Param { private String name = null ; private String expression = null ; private String ifProperty ; private String unlessProperty ; private Project project ; public void setProject ( Project project ) { this . project = project ; } public void setName ( String name ) { this . name = name ; } public void setExpression ( String expression ) { this . expression = expression ; } public String getName ( ) throws BuildException { if ( name == null ) { throw new BuildException ( "Name attribute is missing." ) ; } return name ; } public String getExpression ( ) throws BuildException { if ( expression == null ) { throw new BuildException ( "Expression attribute is missing." ) ; } return expression ; } public void setIf ( String ifProperty ) { this . ifProperty = ifProperty ; } public void setUnless ( String unlessProperty ) { this . unlessProperty = unlessProperty ; } public boolean shouldUse ( ) { if ( ifProperty != null && project . getProperty ( ifProperty ) == null ) { return false ; } else if ( unlessProperty != null && project . getProperty ( unlessProperty ) != null ) { return false ; } return true ; } } public OutputProperty createOutputProperty ( ) { OutputProperty p = new OutputProperty ( ) ; outputProperties . addElement ( p ) ; return p ; } public static class OutputProperty { private String name ; private String value ; public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } } public void init ( ) throws BuildException { super . init ( ) ; xmlCatalog . setProject ( getProject ( ) ) ; } protected void configureLiaison ( File stylesheet ) throws BuildException { if ( stylesheetLoaded && reuseLoadedStylesheet ) { return ; } stylesheetLoaded = true ; try { log ( "Loading stylesheet " + stylesheet , Project . MSG_INFO ) ; liaison . setStylesheet ( stylesheet ) ; for ( Enumeration e = params . elements ( ) ; e . hasMoreElements ( ) ; ) { Param p = ( Param ) e . nextElement ( ) ; if ( p . shouldUse ( ) ) { liaison . addParam ( p . getName ( ) , p . getExpression ( ) ) ; } } if ( liaison instanceof XSLTLiaison2 ) { ( ( XSLTLiaison2 ) liaison ) . configure ( this ) ; } } catch ( Exception ex ) { log ( "Failed to transform using stylesheet " + stylesheet , Project . MSG_INFO ) ; throw new BuildException ( ex ) ; } } public Factory createFactory ( ) throws BuildException { if ( factory != null ) { throw new BuildException ( "'factory' element must be unique" ) ; } factory = new Factory ( ) ; return factory ; } public static class Factory { private String name ; private Vector attributes = new Vector ( ) ; public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public void addAttribute ( Attribute attr ) { attributes . addElement ( attr ) ; } public Enumeration getAttributes ( ) { return attributes . elements ( ) ; } public static class Attribute implements DynamicConfigurator { private String name ; private Object value ; public String getName ( ) { return name ; } public Object getValue ( ) { return value ; } public Object createDynamicElement ( String name ) throws BuildException { return null ; } public void setDynamicAttribute ( String name , String value ) throws BuildException { if ( "name" . equalsIgnoreCase ( name ) ) { this . name = value ; } else if ( "value" . equalsIgnoreCase ( name ) ) { if ( "true" . equalsIgnoreCase ( value ) || "false" . equalsIgnoreCase ( value ) ) { this . value = new Boolean ( value ) ; } else { try { this . value = new Integer ( value ) ; } catch ( NumberFormatException e ) { this . value = value ; } } } else { throw new BuildException ( "Unsupported attribute: " + name ) ; } } } } } 	1	['30', '4', '0', '19', '93', '317', '1', '19', '23', '0.912972085', '949', '1', '5', '0.728971963', '0.238095238', '3', '4', '29.93333333', '3', '1.1', '3']
package org . apache . tools . ant . util ; import java . io . FilterOutputStream ; import java . io . IOException ; import java . io . OutputStream ; public class KeepAliveOutputStream extends FilterOutputStream { public KeepAliveOutputStream ( OutputStream out ) { super ( out ) ; } public void close ( ) throws IOException { } } 	0	['2', '3', '0', '0', '3', '1', '0', '0', '2', '2', '7', '0', '0', '0.909090909', '0.75', '1', '1', '2.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . io . Reader ; import java . io . StringWriter ; import java . io . UnsupportedEncodingException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . CollectionUtils ; public class Manifest { public static final String ATTRIBUTE_MANIFEST_VERSION = "Manifest-Version" ; public static final String ATTRIBUTE_SIGNATURE_VERSION = "Signature-Version" ; public static final String ATTRIBUTE_NAME = "Name" ; public static final String ATTRIBUTE_FROM = "From" ; public static final String ATTRIBUTE_CLASSPATH = "Class-Path" ; public static final String DEFAULT_MANIFEST_VERSION = "1.0" ; public static final int MAX_LINE_LENGTH = 72 ; public static final int MAX_SECTION_LENGTH = MAX_LINE_LENGTH - 2 ; public static final String EOL = "\r\n" ; public static class Attribute { private String name = null ; private Vector values = new Vector ( ) ; private int currentIndex = 0 ; public Attribute ( ) { } public Attribute ( String line ) throws ManifestException { parse ( line ) ; } public Attribute ( String name , String value ) { this . name = name ; setValue ( value ) ; } public int hashCode ( ) { int hashCode = 0 ; if ( name != null ) { hashCode += name . hashCode ( ) ; } hashCode += values . hashCode ( ) ; return hashCode ; } public boolean equals ( Object rhs ) { if ( rhs == null || rhs . getClass ( ) != getClass ( ) ) { return false ; } if ( rhs == this ) { return true ; } Attribute rhsAttribute = ( Attribute ) rhs ; String lhsKey = getKey ( ) ; String rhsKey = rhsAttribute . getKey ( ) ; if ( ( lhsKey == null && rhsKey != null ) || ( lhsKey != null && rhsKey == null ) || ! lhsKey . equals ( rhsKey ) ) { return false ; } return CollectionUtils . equals ( values , rhsAttribute . values ) ; } public void parse ( String line ) throws ManifestException { int index = line . indexOf ( ": " ) ; if ( index == - 1 ) { throw new ManifestException ( "Manifest line \"" + line + "\" is not valid as it does not " + "contain a name and a value separated by ': ' " ) ; } name = line . substring ( 0 , index ) ; setValue ( line . substring ( index + 2 ) ) ; } public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public String getKey ( ) { if ( name == null ) { return null ; } return name . toLowerCase ( ) ; } public void setValue ( String value ) { if ( currentIndex >= values . size ( ) ) { values . addElement ( value ) ; currentIndex = values . size ( ) - 1 ; } else { values . setElementAt ( value , currentIndex ) ; } } public String getValue ( ) { if ( values . size ( ) == 0 ) { return null ; } String fullValue = "" ; for ( Enumeration e = getValues ( ) ; e . hasMoreElements ( ) ; ) { String value = ( String ) e . nextElement ( ) ; fullValue += value + " " ; } return fullValue . trim ( ) ; } public void addValue ( String value ) { currentIndex ++ ; setValue ( value ) ; } public Enumeration getValues ( ) { return values . elements ( ) ; } public void addContinuation ( String line ) { String currentValue = ( String ) values . elementAt ( currentIndex ) ; setValue ( currentValue + line . substring ( 1 ) ) ; } public void write ( PrintWriter writer ) throws IOException { for ( Enumeration e = getValues ( ) ; e . hasMoreElements ( ) ; ) { writeValue ( writer , ( String ) e . nextElement ( ) ) ; } } private void writeValue ( PrintWriter writer , String value ) throws IOException { String line = name + ": " + value ; while ( line . getBytes ( ) . length > MAX_LINE_LENGTH ) { int breakIndex = MAX_SECTION_LENGTH ; String section = line . substring ( 0 , breakIndex ) ; while ( section . getBytes ( ) . length > MAX_SECTION_LENGTH && breakIndex > 0 ) { breakIndex -- ; section = line . substring ( 0 , breakIndex ) ; } if ( breakIndex == 0 ) { throw new IOException ( "Unable to write manifest line " + name + ": " + value ) ; } writer . print ( section + EOL ) ; line = " " + line . substring ( breakIndex ) ; } writer . print ( line + EOL ) ; } } public static class Section { private Vector warnings = new Vector ( ) ; private String name = null ; private Hashtable attributes = new Hashtable ( ) ; private Vector attributeIndex = new Vector ( ) ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public String read ( BufferedReader reader ) throws ManifestException , IOException { Attribute attribute = null ; while ( true ) { String line = reader . readLine ( ) ; if ( line == null || line . length ( ) == 0 ) { return null ; } if ( line . charAt ( 0 ) == ' ' ) { if ( attribute == null ) { if ( name != null ) { name += line . substring ( 1 ) ; } else { throw new ManifestException ( "Can't start an " + "attribute with a continuation line " + line ) ; } } else { attribute . addContinuation ( line ) ; } } else { attribute = new Attribute ( line ) ; String nameReadAhead = addAttributeAndCheck ( attribute ) ; attribute = getAttribute ( attribute . getKey ( ) ) ; if ( nameReadAhead != null ) { return nameReadAhead ; } } } } public void merge ( Section section ) throws ManifestException { if ( name == null && section . getName ( ) != null || name != null && ! ( name . equalsIgnoreCase ( section . getName ( ) ) ) ) { throw new ManifestException ( "Unable to merge sections " + "with different names" ) ; } Enumeration e = section . getAttributeKeys ( ) ; Attribute classpathAttribute = null ; while ( e . hasMoreElements ( ) ) { String attributeName = ( String ) e . nextElement ( ) ; Attribute attribute = section . getAttribute ( attributeName ) ; if ( attributeName . equalsIgnoreCase ( ATTRIBUTE_CLASSPATH ) ) { if ( classpathAttribute == null ) { classpathAttribute = new Attribute ( ) ; classpathAttribute . setName ( ATTRIBUTE_CLASSPATH ) ; } Enumeration cpe = attribute . getValues ( ) ; while ( cpe . hasMoreElements ( ) ) { String value = ( String ) cpe . nextElement ( ) ; classpathAttribute . addValue ( value ) ; } } else { storeAttribute ( attribute ) ; } } if ( classpathAttribute != null ) { storeAttribute ( classpathAttribute ) ; } Enumeration warnEnum = section . warnings . elements ( ) ; while ( warnEnum . hasMoreElements ( ) ) { warnings . addElement ( warnEnum . nextElement ( ) ) ; } } public void write ( PrintWriter writer ) throws IOException { if ( name != null ) { Attribute nameAttr = new Attribute ( ATTRIBUTE_NAME , name ) ; nameAttr . write ( writer ) ; } Enumeration e = getAttributeKeys ( ) ; while ( e . hasMoreElements ( ) ) { String key = ( String ) e . nextElement ( ) ; Attribute attribute = getAttribute ( key ) ; attribute . write ( writer ) ; } writer . print ( EOL ) ; } public Attribute getAttribute ( String attributeName ) { return ( Attribute ) attributes . get ( attributeName . toLowerCase ( ) ) ; } public Enumeration getAttributeKeys ( ) { return attributeIndex . elements ( ) ; } public String getAttributeValue ( String attributeName ) { Attribute attribute = getAttribute ( attributeName . toLowerCase ( ) ) ; if ( attribute == null ) { return null ; } return attribute . getValue ( ) ; } public void removeAttribute ( String attributeName ) { String key = attributeName . toLowerCase ( ) ; attributes . remove ( key ) ; attributeIndex . removeElement ( key ) ; } public void addConfiguredAttribute ( Attribute attribute ) throws ManifestException { String check = addAttributeAndCheck ( attribute ) ; if ( check != null ) { throw new BuildException ( "Specify the section name using " + "the \"name\" attribute of the <section> element rather " + "than using a \"Name\" manifest attribute" ) ; } } public String addAttributeAndCheck ( Attribute attribute ) throws ManifestException { if ( attribute . getName ( ) == null || attribute . getValue ( ) == null ) { throw new BuildException ( "Attributes must have name and value" ) ; } if ( attribute . getKey ( ) . equalsIgnoreCase ( ATTRIBUTE_NAME ) ) { warnings . addElement ( "\"" + ATTRIBUTE_NAME + "\" attributes " + "should not occur in the main section and must be the " + "first element in all other sections: \"" + attribute . getName ( ) + ": " + attribute . getValue ( ) + "\"" ) ; return attribute . getValue ( ) ; } if ( attribute . getKey ( ) . startsWith ( ATTRIBUTE_FROM . toLowerCase ( ) ) ) { warnings . addElement ( "Manifest attributes should not start " + "with \"" + ATTRIBUTE_FROM + "\" in \"" + attribute . getName ( ) + ": " + attribute . getValue ( ) + "\"" ) ; } else { String attributeKey = attribute . getKey ( ) ; if ( attributeKey . equalsIgnoreCase ( ATTRIBUTE_CLASSPATH ) ) { Attribute classpathAttribute = ( Attribute ) attributes . get ( attributeKey ) ; if ( classpathAttribute == null ) { storeAttribute ( attribute ) ; } else { warnings . addElement ( "Multiple Class-Path attributes " + "are supported but violate the Jar " + "specification and may not be correctly " + "processed in all environments" ) ; Enumeration e = attribute . getValues ( ) ; while ( e . hasMoreElements ( ) ) { String value = ( String ) e . nextElement ( ) ; classpathAttribute . addValue ( value ) ; } } } else if ( attributes . containsKey ( attributeKey ) ) { throw new ManifestException ( "The attribute \"" + attribute . getName ( ) + "\" may not occur more " + "than once in the same section" ) ; } else { storeAttribute ( attribute ) ; } } return null ; } public Object clone ( ) { Section cloned = new Section ( ) ; cloned . setName ( name ) ; Enumeration e = getAttributeKeys ( ) ; while ( e . hasMoreElements ( ) ) { String key = ( String ) e . nextElement ( ) ; Attribute attribute = getAttribute ( key ) ; cloned . storeAttribute ( new Attribute ( attribute . getName ( ) , attribute . getValue ( ) ) ) ; } return cloned ; } private void storeAttribute ( Attribute attribute ) { if ( attribute == null ) { return ; } String attributeKey = attribute . getKey ( ) ; attributes . put ( attributeKey , attribute ) ; if ( ! attributeIndex . contains ( attributeKey ) ) { attributeIndex . addElement ( attributeKey ) ; } } public Enumeration getWarnings ( ) { return warnings . elements ( ) ; } public int hashCode ( ) { int hashCode = 0 ; if ( name != null ) { hashCode += name . hashCode ( ) ; } hashCode += attributes . hashCode ( ) ; return hashCode ; } public boolean equals ( Object rhs ) { if ( rhs == null || rhs . getClass ( ) != getClass ( ) ) { return false ; } if ( rhs == this ) { return true ; } Section rhsSection = ( Section ) rhs ; return CollectionUtils . equals ( attributes , rhsSection . attributes ) ; } } private String manifestVersion = DEFAULT_MANIFEST_VERSION ; private Section mainSection = new Section ( ) ; private Hashtable sections = new Hashtable ( ) ; private Vector sectionIndex = new Vector ( ) ; public static Manifest getDefaultManifest ( ) throws BuildException { try { String defManifest = "/org/apache/tools/ant/defaultManifest.mf" ; InputStream in = Manifest . class . getResourceAsStream ( defManifest ) ; if ( in == null ) { throw new BuildException ( "Could not find default manifest: " + defManifest ) ; } try { Manifest defaultManifest = new Manifest ( new InputStreamReader ( in , "UTF-8" ) ) ; Attribute createdBy = new Attribute ( "Created-By" , System . getProperty ( "java.vm.version" ) + " (" + System . getProperty ( "java.vm.vendor" ) + ")" ) ; defaultManifest . getMainSection ( ) . storeAttribute ( createdBy ) ; return defaultManifest ; } catch ( UnsupportedEncodingException e ) { return new Manifest ( new InputStreamReader ( in ) ) ; } } catch ( ManifestException e ) { throw new BuildException ( "Default manifest is invalid !!" , e ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to read default manifest" , e ) ; } } public Manifest ( ) { manifestVersion = null ; } public Manifest ( Reader r ) throws ManifestException , IOException { BufferedReader reader = new BufferedReader ( r ) ; String nextSectionName = mainSection . read ( reader ) ; String readManifestVersion = mainSection . getAttributeValue ( ATTRIBUTE_MANIFEST_VERSION ) ; if ( readManifestVersion != null ) { manifestVersion = readManifestVersion ; mainSection . removeAttribute ( ATTRIBUTE_MANIFEST_VERSION ) ; } String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { if ( line . length ( ) == 0 ) { continue ; } Section section = new Section ( ) ; if ( nextSectionName == null ) { Attribute sectionName = new Attribute ( line ) ; if ( ! sectionName . getName ( ) . equalsIgnoreCase ( ATTRIBUTE_NAME ) ) { throw new ManifestException ( "Manifest sections should " + "start with a \"" + ATTRIBUTE_NAME + "\" attribute and not \"" + sectionName . getName ( ) + "\"" ) ; } nextSectionName = sectionName . getValue ( ) ; } else { Attribute firstAttribute = new Attribute ( line ) ; section . addAttributeAndCheck ( firstAttribute ) ; } section . setName ( nextSectionName ) ; nextSectionName = section . read ( reader ) ; addConfiguredSection ( section ) ; } } public void addConfiguredSection ( Section section ) throws ManifestException { String sectionName = section . getName ( ) ; if ( sectionName == null ) { throw new BuildException ( "Sections must have a name" ) ; } sections . put ( sectionName , section ) ; if ( ! sectionIndex . contains ( sectionName ) ) { sectionIndex . addElement ( sectionName ) ; } } public void addConfiguredAttribute ( Attribute attribute ) throws ManifestException { if ( attribute . getKey ( ) == null || attribute . getValue ( ) == null ) { throw new BuildException ( "Attributes must have name and value" ) ; } if ( attribute . getKey ( ) . equalsIgnoreCase ( ATTRIBUTE_MANIFEST_VERSION ) ) { manifestVersion = attribute . getValue ( ) ; } else { mainSection . addConfiguredAttribute ( attribute ) ; } } public void merge ( Manifest other ) throws ManifestException { merge ( other , false ) ; } public void merge ( Manifest other , boolean overwriteMain ) throws ManifestException { if ( other != null ) { if ( overwriteMain ) { mainSection = ( Section ) other . mainSection . clone ( ) ; } else { mainSection . merge ( other . mainSection ) ; } if ( other . manifestVersion != null ) { manifestVersion = other . manifestVersion ; } Enumeration e = other . getSectionNames ( ) ; while ( e . hasMoreElements ( ) ) { String sectionName = ( String ) e . nextElement ( ) ; Section ourSection = ( Section ) sections . get ( sectionName ) ; Section otherSection = ( Section ) other . sections . get ( sectionName ) ; if ( ourSection == null ) { if ( otherSection != null ) { addConfiguredSection ( ( Section ) otherSection . clone ( ) ) ; } } else { ourSection . merge ( otherSection ) ; } } } } public void write ( PrintWriter writer ) throws IOException { writer . print ( ATTRIBUTE_MANIFEST_VERSION + ": " + manifestVersion + EOL ) ; String signatureVersion = mainSection . getAttributeValue ( ATTRIBUTE_SIGNATURE_VERSION ) ; if ( signatureVersion != null ) { writer . print ( ATTRIBUTE_SIGNATURE_VERSION + ": " + signatureVersion + EOL ) ; mainSection . removeAttribute ( ATTRIBUTE_SIGNATURE_VERSION ) ; } mainSection . write ( writer ) ; if ( signatureVersion != null ) { try { Attribute svAttr = new Attribute ( ATTRIBUTE_SIGNATURE_VERSION , signatureVersion ) ; mainSection . addConfiguredAttribute ( svAttr ) ; } catch ( ManifestException e ) { } } Enumeration e = sectionIndex . elements ( ) ; while ( e . hasMoreElements ( ) ) { String sectionName = ( String ) e . nextElement ( ) ; Section section = getSection ( sectionName ) ; section . write ( writer ) ; } } public String toString ( ) { StringWriter sw = new StringWriter ( ) ; try { write ( new PrintWriter ( sw ) ) ; } catch ( IOException e ) { return null ; } return sw . toString ( ) ; } public Enumeration getWarnings ( ) { Vector warnings = new Vector ( ) ; Enumeration warnEnum = mainSection . getWarnings ( ) ; while ( warnEnum . hasMoreElements ( ) ) { warnings . addElement ( warnEnum . nextElement ( ) ) ; } Enumeration e = sections . elements ( ) ; while ( e . hasMoreElements ( ) ) { Section section = ( Section ) e . nextElement ( ) ; Enumeration e2 = section . getWarnings ( ) ; while ( e2 . hasMoreElements ( ) ) { warnings . addElement ( e2 . nextElement ( ) ) ; } } return warnings . elements ( ) ; } public int hashCode ( ) { int hashCode = 0 ; if ( manifestVersion != null ) { hashCode += manifestVersion . hashCode ( ) ; } hashCode += mainSection . hashCode ( ) ; hashCode += sections . hashCode ( ) ; return hashCode ; } public boolean equals ( Object rhs ) { if ( rhs == null || rhs . getClass ( ) != getClass ( ) ) { return false ; } if ( rhs == this ) { return true ; } Manifest rhsManifest = ( Manifest ) rhs ; if ( manifestVersion == null ) { if ( rhsManifest . manifestVersion != null ) { return false ; } } else if ( ! manifestVersion . equals ( rhsManifest . manifestVersion ) ) { return false ; } if ( ! mainSection . equals ( rhsManifest . mainSection ) ) { return false ; } return CollectionUtils . equals ( sections , rhsManifest . sections ) ; } public String getManifestVersion ( ) { return manifestVersion ; } public Section getMainSection ( ) { return mainSection ; } public Section getSection ( String name ) { return ( Section ) sections . get ( name ) ; } public Enumeration getSectionNames ( ) { return sectionIndex . elements ( ) ; } } 	1	['17', '1', '0', '8', '74', '14', '3', '5', '16', '0.866071429', '599', '0.285714286', '1', '0', '0.163398693', '1', '1', '33.41176471', '8', '1.5294', '1']
package org . apache . tools . ant ; import java . io . File ; import java . util . NoSuchElementException ; import java . util . StringTokenizer ; import org . apache . tools . ant . taskdefs . condition . Os ; public class PathTokenizer { private StringTokenizer tokenizer ; private String lookahead = null ; private boolean onNetWare = Os . isFamily ( "netware" ) ; private boolean dosStyleFilesystem ; public PathTokenizer ( String path ) { if ( onNetWare ) { tokenizer = new StringTokenizer ( path , ":;" , true ) ; } else { tokenizer = new StringTokenizer ( path , ":;" , false ) ; } dosStyleFilesystem = File . pathSeparatorChar == ';' ; } public boolean hasMoreTokens ( ) { if ( lookahead != null ) { return true ; } return tokenizer . hasMoreTokens ( ) ; } public String nextToken ( ) throws NoSuchElementException { String token = null ; if ( lookahead != null ) { token = lookahead ; lookahead = null ; } else { token = tokenizer . nextToken ( ) . trim ( ) ; } if ( ! onNetWare ) { if ( token . length ( ) == 1 && Character . isLetter ( token . charAt ( 0 ) ) && dosStyleFilesystem && tokenizer . hasMoreTokens ( ) ) { String nextToken = tokenizer . nextToken ( ) . trim ( ) ; if ( nextToken . startsWith ( "\\" ) || nextToken . startsWith ( "/" ) ) { token += ":" + nextToken ; } else { lookahead = nextToken ; } } } else { if ( token . equals ( File . pathSeparator ) || token . equals ( ":" ) ) { token = tokenizer . nextToken ( ) . trim ( ) ; } if ( tokenizer . hasMoreTokens ( ) ) { String nextToken = tokenizer . nextToken ( ) . trim ( ) ; if ( ! nextToken . equals ( File . pathSeparator ) ) { if ( nextToken . equals ( ":" ) ) { if ( ! token . startsWith ( "/" ) && ! token . startsWith ( "\\" ) && ! token . startsWith ( "." ) && ! token . startsWith ( ".." ) ) { String oneMore = tokenizer . nextToken ( ) . trim ( ) ; if ( ! oneMore . equals ( File . pathSeparator ) ) { token += ":" + oneMore ; } else { token += ":" ; lookahead = oneMore ; } } } else { lookahead = nextToken ; } } } } return token ; } } 	0	['3', '1', '0', '3', '17', '0', '2', '1', '3', '0.25', '204', '1', '0', '0', '0.666666667', '0', '0', '65.66666667', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ExitException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . CommandlineJava ; import org . apache . tools . ant . types . Environment ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . PropertySet ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . types . Assertions ; import org . apache . tools . ant . types . Permissions ; public class Java extends Task { private CommandlineJava cmdl = new CommandlineJava ( ) ; private Environment env = new Environment ( ) ; private boolean fork = false ; private boolean newEnvironment = false ; private File dir = null ; private boolean failOnError = false ; private boolean append = false ; private Long timeout = null ; private Redirector redirector = new Redirector ( this ) ; private String resultProperty ; private Permissions perm = null ; private boolean spawn = false ; private boolean incompatibleWithSpawn = false ; public void execute ( ) throws BuildException { File savedDir = dir ; Permissions savedPermissions = perm ; int err = - 1 ; try { err = executeJava ( ) ; if ( err != 0 ) { if ( failOnError ) { throw new BuildException ( "Java returned: " + err , getLocation ( ) ) ; } else { log ( "Java Result: " + err , Project . MSG_ERR ) ; } } maybeSetResultPropertyValue ( err ) ; } finally { dir = savedDir ; perm = savedPermissions ; } } public int executeJava ( ) throws BuildException { String classname = cmdl . getClassname ( ) ; if ( classname == null && cmdl . getJar ( ) == null ) { throw new BuildException ( "Classname must not be null." ) ; } if ( ! fork && cmdl . getJar ( ) != null ) { throw new BuildException ( "Cannot execute a jar in non-forked mode." + " Please set fork='true'. " ) ; } if ( spawn && ! fork ) { throw new BuildException ( "Cannot spawn a java process in non-forked mode." + " Please set fork='true'. " ) ; } if ( spawn && incompatibleWithSpawn ) { getProject ( ) . log ( "spawn does not allow attributes related to input, " + "output, error, result" , Project . MSG_ERR ) ; getProject ( ) . log ( "spawn does not also not allow timeout" , Project . MSG_ERR ) ; throw new BuildException ( "You have used an attribute which is " + "not compatible with spawn" ) ; } if ( cmdl . getAssertions ( ) != null && ! fork ) { log ( "Assertion statements are currently ignored in non-forked mode" ) ; } if ( fork ) { if ( perm != null ) { log ( "Permissions can not be set this way in forked mode." , Project . MSG_WARN ) ; } log ( cmdl . describeCommand ( ) , Project . MSG_VERBOSE ) ; } else { if ( cmdl . getVmCommand ( ) . size ( ) > 1 ) { log ( "JVM args ignored when same JVM is used." , Project . MSG_WARN ) ; } if ( dir != null ) { log ( "Working directory ignored when same JVM is used." , Project . MSG_WARN ) ; } if ( newEnvironment || null != env . getVariables ( ) ) { log ( "Changes to environment variables are ignored when same " + "JVM is used." , Project . MSG_WARN ) ; } if ( cmdl . getBootclasspath ( ) != null ) { log ( "bootclasspath ignored when same JVM is used." , Project . MSG_WARN ) ; } if ( perm == null && failOnError == true ) { perm = new Permissions ( true ) ; log ( "running " + this . cmdl . getClassname ( ) + " with default permissions (exit forbidden)" , Project . MSG_VERBOSE ) ; } log ( "Running in same VM " + cmdl . describeJavaCommand ( ) , Project . MSG_VERBOSE ) ; } try { if ( fork ) { if ( ! spawn ) { return fork ( cmdl . getCommandline ( ) ) ; } else { spawn ( cmdl . getCommandline ( ) ) ; return 0 ; } } else { try { run ( cmdl ) ; return 0 ; } catch ( ExitException ex ) { return ex . getStatus ( ) ; } } } catch ( BuildException e ) { if ( failOnError ) { throw e ; } else { log ( e . getMessage ( ) , Project . MSG_ERR ) ; return 0 ; } } catch ( Throwable t ) { if ( failOnError ) { throw new BuildException ( t ) ; } else { log ( t . getMessage ( ) , Project . MSG_ERR ) ; return 0 ; } } } public void setSpawn ( boolean spawn ) { this . spawn = spawn ; } public void setClasspath ( Path s ) { createClasspath ( ) . append ( s ) ; } public Path createClasspath ( ) { return cmdl . createClasspath ( getProject ( ) ) . createPath ( ) ; } public Path createBootclasspath ( ) { return cmdl . createBootclasspath ( getProject ( ) ) . createPath ( ) ; } public Permissions createPermissions ( ) { if ( perm == null ) { perm = new Permissions ( ) ; } return perm ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setJar ( File jarfile ) throws BuildException { if ( cmdl . getClassname ( ) != null ) { throw new BuildException ( "Cannot use 'jar' and 'classname' " + "attributes in same command." ) ; } cmdl . setJar ( jarfile . getAbsolutePath ( ) ) ; } public void setClassname ( String s ) throws BuildException { if ( cmdl . getJar ( ) != null ) { throw new BuildException ( "Cannot use 'jar' and 'classname' " + "attributes in same command" ) ; } cmdl . setClassname ( s ) ; } public void setArgs ( String s ) { log ( "The args attribute is deprecated. " + "Please use nested arg elements." , Project . MSG_WARN ) ; cmdl . createArgument ( ) . setLine ( s ) ; } public Commandline . Argument createArg ( ) { return cmdl . createArgument ( ) ; } public void setResultProperty ( String resultProperty ) { this . resultProperty = resultProperty ; } protected void maybeSetResultPropertyValue ( int result ) { String res = Integer . toString ( result ) ; if ( resultProperty != null ) { getProject ( ) . setNewProperty ( resultProperty , res ) ; } } public void setFork ( boolean s ) { this . fork = s ; } public void setJvmargs ( String s ) { log ( "The jvmargs attribute is deprecated. " + "Please use nested jvmarg elements." , Project . MSG_WARN ) ; cmdl . createVmArgument ( ) . setLine ( s ) ; } public Commandline . Argument createJvmarg ( ) { return cmdl . createVmArgument ( ) ; } public void setJvm ( String s ) { cmdl . setVm ( s ) ; } public void addSysproperty ( Environment . Variable sysp ) { cmdl . addSysproperty ( sysp ) ; } public void addSyspropertyset ( PropertySet sysp ) { cmdl . addSyspropertyset ( sysp ) ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; incompatibleWithSpawn = true ; } public void setDir ( File d ) { this . dir = d ; } public void setOutput ( File out ) { redirector . setOutput ( out ) ; incompatibleWithSpawn = true ; } public void setInput ( File input ) { redirector . setInput ( input ) ; incompatibleWithSpawn = true ; } public void setInputString ( String inputString ) { redirector . setInputString ( inputString ) ; incompatibleWithSpawn = true ; } public void setLogError ( boolean logError ) { redirector . setLogError ( logError ) ; incompatibleWithSpawn = true ; } public void setError ( File error ) { redirector . setError ( error ) ; incompatibleWithSpawn = true ; } public void setOutputproperty ( String outputProp ) { redirector . setOutputProperty ( outputProp ) ; incompatibleWithSpawn = true ; } public void setErrorProperty ( String errorProperty ) { redirector . setErrorProperty ( errorProperty ) ; incompatibleWithSpawn = true ; } public void setMaxmemory ( String max ) { cmdl . setMaxmemory ( max ) ; } public void setJVMVersion ( String value ) { cmdl . setVmversion ( value ) ; } public void addEnv ( Environment . Variable var ) { env . addVariable ( var ) ; } public void setNewenvironment ( boolean newenv ) { newEnvironment = newenv ; } public void setAppend ( boolean append ) { this . append = append ; incompatibleWithSpawn = true ; } public void setTimeout ( Long value ) { timeout = value ; incompatibleWithSpawn = true ; } public void addAssertions ( Assertions asserts ) { if ( cmdl . getAssertions ( ) != null ) { throw new BuildException ( "Only one assertion declaration is allowed" ) ; } cmdl . setAssertions ( asserts ) ; } protected void handleOutput ( String output ) { if ( redirector . getOutputStream ( ) != null ) { redirector . handleOutput ( output ) ; } else { super . handleOutput ( output ) ; } } public int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException { if ( redirector . getInputStream ( ) != null ) { return redirector . handleInput ( buffer , offset , length ) ; } else { return super . handleInput ( buffer , offset , length ) ; } } protected void handleFlush ( String output ) { if ( redirector . getOutputStream ( ) != null ) { redirector . handleFlush ( output ) ; } else { super . handleFlush ( output ) ; } } protected void handleErrorOutput ( String output ) { if ( redirector . getErrorStream ( ) != null ) { redirector . handleErrorOutput ( output ) ; } else { super . handleErrorOutput ( output ) ; } } protected void handleErrorFlush ( String output ) { if ( redirector . getErrorStream ( ) != null ) { redirector . handleErrorFlush ( output ) ; } else { super . handleErrorOutput ( output ) ; } } private void run ( CommandlineJava command ) throws BuildException { try { ExecuteJava exe = new ExecuteJava ( ) ; exe . setJavaCommand ( command . getJavaCommand ( ) ) ; exe . setClasspath ( command . getClasspath ( ) ) ; exe . setSystemProperties ( command . getSystemProperties ( ) ) ; exe . setPermissions ( perm ) ; exe . setTimeout ( timeout ) ; redirector . createStreams ( ) ; exe . execute ( getProject ( ) ) ; redirector . complete ( ) ; if ( exe . killedProcess ( ) ) { throw new BuildException ( "Timeout: killed the sub-process" ) ; } } catch ( IOException e ) { throw new BuildException ( e ) ; } } private int fork ( String [ ] command ) throws BuildException { Execute exe = new Execute ( redirector . createHandler ( ) , createWatchdog ( ) ) ; exe . setAntRun ( getProject ( ) ) ; if ( dir == null ) { dir = getProject ( ) . getBaseDir ( ) ; } else if ( ! dir . exists ( ) || ! dir . isDirectory ( ) ) { throw new BuildException ( dir . getAbsolutePath ( ) + " is not a valid directory" , getLocation ( ) ) ; } exe . setWorkingDirectory ( dir ) ; String [ ] environment = env . getVariables ( ) ; if ( environment != null ) { for ( int i = 0 ; i < environment . length ; i ++ ) { log ( "Setting environment variable: " + environment [ i ] , Project . MSG_VERBOSE ) ; } } exe . setNewenvironment ( newEnvironment ) ; exe . setEnvironment ( environment ) ; exe . setCommandline ( command ) ; try { int rc = exe . execute ( ) ; redirector . complete ( ) ; if ( exe . killedProcess ( ) ) { throw new BuildException ( "Timeout: killed the sub-process" ) ; } return rc ; } catch ( IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } private void spawn ( String [ ] command ) throws BuildException { Execute exe = new Execute ( ) ; exe . setAntRun ( getProject ( ) ) ; if ( dir == null ) { dir = getProject ( ) . getBaseDir ( ) ; } else if ( ! dir . exists ( ) || ! dir . isDirectory ( ) ) { throw new BuildException ( dir . getAbsolutePath ( ) + " is not a valid directory" , getLocation ( ) ) ; } exe . setWorkingDirectory ( dir ) ; String [ ] environment = env . getVariables ( ) ; if ( environment != null ) { for ( int i = 0 ; i < environment . length ; i ++ ) { log ( "Setting environment variable: " + environment [ i ] , Project . MSG_VERBOSE ) ; } } exe . setNewenvironment ( newEnvironment ) ; exe . setEnvironment ( environment ) ; exe . setCommandline ( command ) ; try { exe . spawn ( ) ; } catch ( IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } protected void run ( String classname , Vector args ) throws BuildException { CommandlineJava cmdj = new CommandlineJava ( ) ; cmdj . setClassname ( classname ) ; for ( int i = 0 ; i < args . size ( ) ; i ++ ) { cmdj . createArgument ( ) . setValue ( ( String ) args . elementAt ( i ) ) ; } run ( cmdj ) ; } public void clearArgs ( ) { cmdl . clearJavaArgs ( ) ; } protected ExecuteWatchdog createWatchdog ( ) throws BuildException { if ( timeout == null ) { return null ; } return new ExecuteWatchdog ( timeout . longValue ( ) ) ; } } 	1	['48', '3', '0', '22', '151', '498', '0', '22', '38', '0.860883797', '1000', '1', '4', '0.44047619', '0.122222222', '1', '3', '19.5625', '2', '1.125', '3']
package org . apache . tools . ant . input ; public interface InputHandler { void handleInput ( InputRequest request ) throws org . apache . tools . ant . BuildException ; } 	0	['1', '1', '0', '8', '1', '0', '6', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . tar ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . IOException ; public class TarBuffer { public static final int DEFAULT_RCDSIZE = ( 512 ) ; public static final int DEFAULT_BLKSIZE = ( DEFAULT_RCDSIZE * 20 ) ; private InputStream inStream ; private OutputStream outStream ; private byte [ ] blockBuffer ; private int currBlkIdx ; private int currRecIdx ; private int blockSize ; private int recordSize ; private int recsPerBlock ; private boolean debug ; public TarBuffer ( InputStream inStream ) { this ( inStream , TarBuffer . DEFAULT_BLKSIZE ) ; } public TarBuffer ( InputStream inStream , int blockSize ) { this ( inStream , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarBuffer ( InputStream inStream , int blockSize , int recordSize ) { this . inStream = inStream ; this . outStream = null ; this . initialize ( blockSize , recordSize ) ; } public TarBuffer ( OutputStream outStream ) { this ( outStream , TarBuffer . DEFAULT_BLKSIZE ) ; } public TarBuffer ( OutputStream outStream , int blockSize ) { this ( outStream , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarBuffer ( OutputStream outStream , int blockSize , int recordSize ) { this . inStream = null ; this . outStream = outStream ; this . initialize ( blockSize , recordSize ) ; } private void initialize ( int blockSize , int recordSize ) { this . debug = false ; this . blockSize = blockSize ; this . recordSize = recordSize ; this . recsPerBlock = ( this . blockSize / this . recordSize ) ; this . blockBuffer = new byte [ this . blockSize ] ; if ( this . inStream != null ) { this . currBlkIdx = - 1 ; this . currRecIdx = this . recsPerBlock ; } else { this . currBlkIdx = 0 ; this . currRecIdx = 0 ; } } public int getBlockSize ( ) { return this . blockSize ; } public int getRecordSize ( ) { return this . recordSize ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public boolean isEOFRecord ( byte [ ] record ) { for ( int i = 0 , sz = this . getRecordSize ( ) ; i < sz ; ++ i ) { if ( record [ i ] != 0 ) { return false ; } } return true ; } public void skipRecord ( ) throws IOException { if ( this . debug ) { System . err . println ( "SkipRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . inStream == null ) { throw new IOException ( "reading (via skip) from an output buffer" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { if ( ! this . readBlock ( ) ) { return ; } } this . currRecIdx ++ ; } public byte [ ] readRecord ( ) throws IOException { if ( this . debug ) { System . err . println ( "ReadRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . inStream == null ) { throw new IOException ( "reading from an output buffer" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { if ( ! this . readBlock ( ) ) { return null ; } } byte [ ] result = new byte [ this . recordSize ] ; System . arraycopy ( this . blockBuffer , ( this . currRecIdx * this . recordSize ) , result , 0 , this . recordSize ) ; this . currRecIdx ++ ; return result ; } private boolean readBlock ( ) throws IOException { if ( this . debug ) { System . err . println ( "ReadBlock: blkIdx = " + this . currBlkIdx ) ; } if ( this . inStream == null ) { throw new IOException ( "reading from an output buffer" ) ; } this . currRecIdx = 0 ; int offset = 0 ; int bytesNeeded = this . blockSize ; while ( bytesNeeded > 0 ) { long numBytes = this . inStream . read ( this . blockBuffer , offset , bytesNeeded ) ; if ( numBytes == - 1 ) { break ; } offset += numBytes ; bytesNeeded -= numBytes ; if ( numBytes != this . blockSize ) { if ( this . debug ) { System . err . println ( "ReadBlock: INCOMPLETE READ " + numBytes + " of " + this . blockSize + " bytes read." ) ; } } } this . currBlkIdx ++ ; return true ; } public int getCurrentBlockNum ( ) { return this . currBlkIdx ; } public int getCurrentRecordNum ( ) { return this . currRecIdx - 1 ; } public void writeRecord ( byte [ ] record ) throws IOException { if ( this . debug ) { System . err . println ( "WriteRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } if ( record . length != this . recordSize ) { throw new IOException ( "record to write has length '" + record . length + "' which is not the record size of '" + this . recordSize + "'" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { this . writeBlock ( ) ; } System . arraycopy ( record , 0 , this . blockBuffer , ( this . currRecIdx * this . recordSize ) , this . recordSize ) ; this . currRecIdx ++ ; } public void writeRecord ( byte [ ] buf , int offset ) throws IOException { if ( this . debug ) { System . err . println ( "WriteRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } if ( ( offset + this . recordSize ) > buf . length ) { throw new IOException ( "record has length '" + buf . length + "' with offset '" + offset + "' which is less than the record size of '" + this . recordSize + "'" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { this . writeBlock ( ) ; } System . arraycopy ( buf , offset , this . blockBuffer , ( this . currRecIdx * this . recordSize ) , this . recordSize ) ; this . currRecIdx ++ ; } private void writeBlock ( ) throws IOException { if ( this . debug ) { System . err . println ( "WriteBlock: blkIdx = " + this . currBlkIdx ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } this . outStream . write ( this . blockBuffer , 0 , this . blockSize ) ; this . outStream . flush ( ) ; this . currRecIdx = 0 ; this . currBlkIdx ++ ; } private void flushBlock ( ) throws IOException { if ( this . debug ) { System . err . println ( "TarBuffer.flushBlock() called." ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } if ( this . currRecIdx > 0 ) { this . writeBlock ( ) ; } } public void close ( ) throws IOException { if ( this . debug ) { System . err . println ( "TarBuffer.closeBuffer()." ) ; } if ( this . outStream != null ) { this . flushBlock ( ) ; if ( this . outStream != System . out && this . outStream != System . err ) { this . outStream . close ( ) ; this . outStream = null ; } } else if ( this . inStream != null ) { if ( this . inStream != System . in ) { this . inStream . close ( ) ; this . inStream = null ; } } } } 	1	['21', '1', '0', '2', '35', '38', '2', '0', '17', '0.631818182', '617', '0.818181818', '0', '0', '0.293650794', '0', '0', '27.85714286', '3', '0.8571', '1']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . types . Reference ; public class IsReference extends ProjectComponent implements Condition { private Reference ref ; private String type ; public void setRefid ( Reference r ) { ref = r ; } public void setType ( String type ) { this . type = type ; } public boolean eval ( ) throws BuildException { if ( ref == null ) { throw new BuildException ( "No reference specified for isreference " + "condition" ) ; } Object o = getProject ( ) . getReference ( ref . getRefId ( ) ) ; if ( o == null ) { return false ; } else if ( type == null ) { return true ; } else { Class typeClass = ( Class ) getProject ( ) . getDataTypeDefinitions ( ) . get ( type ) ; if ( typeClass == null ) { typeClass = ( Class ) getProject ( ) . getTaskDefinitions ( ) . get ( type ) ; } if ( typeClass == null ) { return false ; } return typeClass . isAssignableFrom ( o . getClass ( ) ) ; } } } 	0	['4', '2', '0', '6', '14', '2', '1', '5', '4', '0.666666667', '68', '1', '1', '0.75', '0.5', '0', '0', '15.5', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . io . IOException ; import java . util . Date ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . PatternSet ; import org . apache . tools . ant . types . selectors . SelectorUtils ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . zip . ZipEntry ; import org . apache . tools . zip . ZipFile ; public class Expand extends Task { private File dest ; private File source ; private boolean overwrite = true ; private Vector patternsets = new Vector ( ) ; private Vector filesets = new Vector ( ) ; private static final String NATIVE_ENCODING = "native-encoding" ; private String encoding = "UTF8" ; public void execute ( ) throws BuildException { if ( "expand" . equals ( getTaskType ( ) ) ) { log ( "!! expand is deprecated. Use unzip instead. !!" ) ; } if ( source == null && filesets . size ( ) == 0 ) { throw new BuildException ( "src attribute and/or filesets must be " + "specified" ) ; } if ( dest == null ) { throw new BuildException ( "Dest attribute must be specified" ) ; } if ( dest . exists ( ) && ! dest . isDirectory ( ) ) { throw new BuildException ( "Dest must be a directory." , getLocation ( ) ) ; } FileUtils fileUtils = FileUtils . newFileUtils ( ) ; if ( source != null ) { if ( source . isDirectory ( ) ) { throw new BuildException ( "Src must not be a directory." + " Use nested filesets instead." , getLocation ( ) ) ; } else { expandFile ( fileUtils , source , dest ) ; } } if ( filesets . size ( ) > 0 ) { for ( int j = 0 ; j < filesets . size ( ) ; j ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( j ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; File fromDir = fs . getDir ( getProject ( ) ) ; String [ ] files = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; ++ i ) { File file = new File ( fromDir , files [ i ] ) ; expandFile ( fileUtils , file , dest ) ; } } } } protected void expandFile ( FileUtils fileUtils , File srcF , File dir ) { log ( "Expanding: " + srcF + " into " + dir , Project . MSG_INFO ) ; ZipFile zf = null ; try { zf = new ZipFile ( srcF , encoding ) ; Enumeration e = zf . getEntries ( ) ; while ( e . hasMoreElements ( ) ) { ZipEntry ze = ( ZipEntry ) e . nextElement ( ) ; extractFile ( fileUtils , srcF , dir , zf . getInputStream ( ze ) , ze . getName ( ) , new Date ( ze . getTime ( ) ) , ze . isDirectory ( ) ) ; } log ( "expand complete" , Project . MSG_VERBOSE ) ; } catch ( IOException ioe ) { throw new BuildException ( "Error while expanding " + srcF . getPath ( ) , ioe ) ; } finally { if ( zf != null ) { try { zf . close ( ) ; } catch ( IOException e ) { } } } } protected void extractFile ( FileUtils fileUtils , File srcF , File dir , InputStream compressedInputStream , String entryName , Date entryDate , boolean isDirectory ) throws IOException { if ( patternsets != null && patternsets . size ( ) > 0 ) { String name = entryName . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; boolean included = false ; for ( int v = 0 ; v < patternsets . size ( ) ; v ++ ) { PatternSet p = ( PatternSet ) patternsets . elementAt ( v ) ; String [ ] incls = p . getIncludePatterns ( getProject ( ) ) ; if ( incls == null || incls . length == 0 ) { incls = new String [ ] { "**" } ; } for ( int w = 0 ; w < incls . length ; w ++ ) { String pattern = incls [ w ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( pattern . endsWith ( File . separator ) ) { pattern += "**" ; } included = SelectorUtils . matchPath ( pattern , name ) ; if ( included ) { break ; } } if ( ! included ) { break ; } String [ ] excls = p . getExcludePatterns ( getProject ( ) ) ; if ( excls != null ) { for ( int w = 0 ; w < excls . length ; w ++ ) { String pattern = excls [ w ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( pattern . endsWith ( File . separator ) ) { pattern += "**" ; } included = ! ( SelectorUtils . matchPath ( pattern , name ) ) ; if ( ! included ) { break ; } } } } if ( ! included ) { return ; } } File f = fileUtils . resolveFile ( dir , entryName ) ; try { if ( ! overwrite && f . exists ( ) && f . lastModified ( ) >= entryDate . getTime ( ) ) { log ( "Skipping " + f + " as it is up-to-date" , Project . MSG_DEBUG ) ; return ; } log ( "expanding " + entryName + " to " + f , Project . MSG_VERBOSE ) ; File dirF = fileUtils . getParentFile ( f ) ; if ( dirF != null ) { dirF . mkdirs ( ) ; } if ( isDirectory ) { f . mkdirs ( ) ; } else { byte [ ] buffer = new byte [ 1024 ] ; int length = 0 ; FileOutputStream fos = null ; try { fos = new FileOutputStream ( f ) ; while ( ( length = compressedInputStream . read ( buffer ) ) >= 0 ) { fos . write ( buffer , 0 , length ) ; } fos . close ( ) ; fos = null ; } finally { if ( fos != null ) { try { fos . close ( ) ; } catch ( IOException e ) { } } } } fileUtils . setFileLastModified ( f , entryDate . getTime ( ) ) ; } catch ( FileNotFoundException ex ) { log ( "Unable to expand to file " + f . getPath ( ) , Project . MSG_WARN ) ; } } public void setDest ( File d ) { this . dest = d ; } public void setSrc ( File s ) { this . source = s ; } public void setOverwrite ( boolean b ) { overwrite = b ; } public void addPatternset ( PatternSet set ) { patternsets . addElement ( set ) ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void setEncoding ( String encoding ) { if ( NATIVE_ENCODING . equals ( encoding ) ) { encoding = null ; } this . encoding = encoding ; } } 	1	['10', '3', '1', '14', '61', '19', '1', '13', '8', '0.80952381', '543', '1', '0', '0.804347826', '0.266666667', '2', '2', '52.6', '5', '1.4', '2']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedInputStream ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . bzip2 . CBZip2InputStream ; public class BUnzip2 extends Unpack { private static final String DEFAULT_EXTENSION = ".bz2" ; protected String getDefaultExtension ( ) { return DEFAULT_EXTENSION ; } protected void extract ( ) { if ( source . lastModified ( ) > dest . lastModified ( ) ) { log ( "Expanding " + source . getAbsolutePath ( ) + " to " + dest . getAbsolutePath ( ) ) ; FileOutputStream out = null ; CBZip2InputStream zIn = null ; FileInputStream fis = null ; BufferedInputStream bis = null ; try { out = new FileOutputStream ( dest ) ; fis = new FileInputStream ( source ) ; bis = new BufferedInputStream ( fis ) ; int b = bis . read ( ) ; if ( b != 'B' ) { throw new BuildException ( "Invalid bz2 file." , getLocation ( ) ) ; } b = bis . read ( ) ; if ( b != 'Z' ) { throw new BuildException ( "Invalid bz2 file." , getLocation ( ) ) ; } zIn = new CBZip2InputStream ( bis ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { out . write ( buffer , 0 , count ) ; count = zIn . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } catch ( IOException ioe ) { String msg = "Problem expanding bzip2 " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } finally { if ( bis != null ) { try { bis . close ( ) ; } catch ( IOException ioex ) { } } if ( fis != null ) { try { fis . close ( ) ; } catch ( IOException ioex ) { } } if ( out != null ) { try { out . close ( ) ; } catch ( IOException ioex ) { } } if ( zIn != null ) { try { zIn . close ( ) ; } catch ( IOException ioex ) { } } } } } } 	0	['3', '4', '0', '5', '25', '3', '0', '5', '1', '1.5', '191', '1', '0', '0.960784314', '1', '2', '3', '62.33333333', '13', '4.6667', '0']
package org . apache . tools . ant . util ; import java . io . BufferedInputStream ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . io . Reader ; import java . lang . reflect . Method ; import java . net . MalformedURLException ; import java . net . URL ; import java . text . CharacterIterator ; import java . text . DecimalFormat ; import java . text . StringCharacterIterator ; import java . util . Random ; import java . util . Stack ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . filters . util . ChainReaderHelper ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . FilterSetCollection ; import org . apache . tools . ant . launch . Locator ; public class FileUtils { private static Random rand = new Random ( System . currentTimeMillis ( ) ) ; private static Object lockReflection = new Object ( ) ; private static java . lang . reflect . Method setLastModified = null ; private boolean onNetWare = Os . isFamily ( "netware" ) ; private static boolean [ ] isSpecial = new boolean [ 256 ] ; private static char [ ] escapedChar1 = new char [ 256 ] ; private static char [ ] escapedChar2 = new char [ 256 ] ; public static final long FAT_FILE_TIMESTAMP_GRANULARITY = 2000 ; static { for ( int i = 0 ; i <= 0x20 ; i ++ ) { isSpecial [ i ] = true ; escapedChar1 [ i ] = Character . forDigit ( i > > 4 , 16 ) ; escapedChar2 [ i ] = Character . forDigit ( i & 0xf , 16 ) ; } isSpecial [ 0x7f ] = true ; escapedChar1 [ 0x7f ] = '7' ; escapedChar2 [ 0x7f ] = 'F' ; char [ ] escChs = { '<' , '>' , '#' , '%' , '"' , '{' , '}' , '|' , '\\' , '^' , '~' , '[' , ']' , '`' } ; int len = escChs . length ; char ch ; for ( int i = 0 ; i < len ; i ++ ) { ch = escChs [ i ] ; isSpecial [ ch ] = true ; escapedChar1 [ ch ] = Character . forDigit ( ch > > 4 , 16 ) ; escapedChar2 [ ch ] = Character . forDigit ( ch & 0xf , 16 ) ; } } public static FileUtils newFileUtils ( ) { return new FileUtils ( ) ; } protected FileUtils ( ) { } public URL getFileURL ( File file ) throws MalformedURLException { return new URL ( toURI ( file . getAbsolutePath ( ) ) ) ; } public void copyFile ( String sourceFile , String destFile ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , null , false , false ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , false , false ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , boolean overwrite ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , overwrite , false ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , overwrite , preserveLastModified ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified , String encoding ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , overwrite , preserveLastModified , encoding ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String encoding , Project project ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , filterChains , overwrite , preserveLastModified , encoding , project ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String inputEncoding , String outputEncoding , Project project ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , filterChains , overwrite , preserveLastModified , inputEncoding , outputEncoding , project ) ; } public void copyFile ( File sourceFile , File destFile ) throws IOException { copyFile ( sourceFile , destFile , null , false , false ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters ) throws IOException { copyFile ( sourceFile , destFile , filters , false , false ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , boolean overwrite ) throws IOException { copyFile ( sourceFile , destFile , filters , overwrite , false ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified ) throws IOException { copyFile ( sourceFile , destFile , filters , overwrite , preserveLastModified , null ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified , String encoding ) throws IOException { copyFile ( sourceFile , destFile , filters , null , overwrite , preserveLastModified , encoding , null ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String encoding , Project project ) throws IOException { copyFile ( sourceFile , destFile , filters , filterChains , overwrite , preserveLastModified , encoding , encoding , project ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String inputEncoding , String outputEncoding , Project project ) throws IOException { if ( overwrite || ! destFile . exists ( ) || destFile . lastModified ( ) < sourceFile . lastModified ( ) ) { if ( destFile . exists ( ) && destFile . isFile ( ) ) { destFile . delete ( ) ; } File parent = getParentFile ( destFile ) ; if ( parent != null && ! parent . exists ( ) ) { parent . mkdirs ( ) ; } final boolean filterSetsAvailable = ( filters != null && filters . hasFilters ( ) ) ; final boolean filterChainsAvailable = ( filterChains != null && filterChains . size ( ) > 0 ) ; if ( filterSetsAvailable ) { BufferedReader in = null ; BufferedWriter out = null ; try { if ( inputEncoding == null ) { in = new BufferedReader ( new FileReader ( sourceFile ) ) ; } else { InputStreamReader isr = new InputStreamReader ( new FileInputStream ( sourceFile ) , inputEncoding ) ; in = new BufferedReader ( isr ) ; } if ( outputEncoding == null ) { out = new BufferedWriter ( new FileWriter ( destFile ) ) ; } else { OutputStreamWriter osw = new OutputStreamWriter ( new FileOutputStream ( destFile ) , outputEncoding ) ; out = new BufferedWriter ( osw ) ; } if ( filterChainsAvailable ) { ChainReaderHelper crh = new ChainReaderHelper ( ) ; crh . setBufferSize ( 8192 ) ; crh . setPrimaryReader ( in ) ; crh . setFilterChains ( filterChains ) ; crh . setProject ( project ) ; Reader rdr = crh . getAssembledReader ( ) ; in = new BufferedReader ( rdr ) ; } LineTokenizer lineTokenizer = new LineTokenizer ( ) ; lineTokenizer . setIncludeDelims ( true ) ; String newline = null ; String line = lineTokenizer . getToken ( in ) ; while ( line != null ) { if ( line . length ( ) == 0 ) { out . newLine ( ) ; } else { newline = filters . replaceTokens ( line ) ; out . write ( newline ) ; } line = lineTokenizer . getToken ( in ) ; } } finally { if ( out != null ) { out . close ( ) ; } if ( in != null ) { in . close ( ) ; } } } else if ( filterChainsAvailable || ( inputEncoding != null && ! inputEncoding . equals ( outputEncoding ) ) || ( inputEncoding == null && outputEncoding != null ) ) { BufferedReader in = null ; BufferedWriter out = null ; try { if ( inputEncoding == null ) { in = new BufferedReader ( new FileReader ( sourceFile ) ) ; } else { in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( sourceFile ) , inputEncoding ) ) ; } if ( outputEncoding == null ) { out = new BufferedWriter ( new FileWriter ( destFile ) ) ; } else { out = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( destFile ) , outputEncoding ) ) ; } if ( filterChainsAvailable ) { ChainReaderHelper crh = new ChainReaderHelper ( ) ; crh . setBufferSize ( 8192 ) ; crh . setPrimaryReader ( in ) ; crh . setFilterChains ( filterChains ) ; crh . setProject ( project ) ; Reader rdr = crh . getAssembledReader ( ) ; in = new BufferedReader ( rdr ) ; } char [ ] buffer = new char [ 1024 * 8 ] ; while ( true ) { int nRead = in . read ( buffer , 0 , buffer . length ) ; if ( nRead == - 1 ) { break ; } out . write ( buffer , 0 , nRead ) ; } } finally { if ( out != null ) { out . close ( ) ; } if ( in != null ) { in . close ( ) ; } } } else { FileInputStream in = null ; FileOutputStream out = null ; try { in = new FileInputStream ( sourceFile ) ; out = new FileOutputStream ( destFile ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { out . write ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } finally { if ( out != null ) { out . close ( ) ; } if ( in != null ) { in . close ( ) ; } } } if ( preserveLastModified ) { setFileLastModified ( destFile , sourceFile . lastModified ( ) ) ; } } } protected final Method getSetLastModified ( ) { if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { return null ; } synchronized ( lockReflection ) { if ( setLastModified == null ) { try { setLastModified = java . io . File . class . getMethod ( "setLastModified" , new Class [ ] { Long . TYPE } ) ; } catch ( NoSuchMethodException nse ) { throw new BuildException ( "File.setlastModified not in JDK > 1.1?" , nse ) ; } } } return setLastModified ; } public void setFileLastModified ( File file , long time ) throws BuildException { if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { return ; } Long [ ] times = new Long [ 1 ] ; if ( time < 0 ) { times [ 0 ] = new Long ( System . currentTimeMillis ( ) ) ; } else { times [ 0 ] = new Long ( time ) ; } try { getSetLastModified ( ) . invoke ( file , times ) ; } catch ( java . lang . reflect . InvocationTargetException ite ) { Throwable nested = ite . getTargetException ( ) ; throw new BuildException ( "Exception setting the modification time " + "of " + file , nested ) ; } catch ( Throwable other ) { throw new BuildException ( "Exception setting the modification time " + "of " + file , other ) ; } } public File resolveFile ( File file , String filename ) { filename = filename . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( ! onNetWare ) { if ( filename . startsWith ( File . separator ) || ( filename . length ( ) >= 2 && Character . isLetter ( filename . charAt ( 0 ) ) && filename . charAt ( 1 ) == ':' ) ) { return normalize ( filename ) ; } } else { int colon = filename . indexOf ( ":" ) ; if ( filename . startsWith ( File . separator ) || ( colon > - 1 ) ) { return normalize ( filename ) ; } } if ( file == null ) { return new File ( filename ) ; } File helpFile = new File ( file . getAbsolutePath ( ) ) ; StringTokenizer tok = new StringTokenizer ( filename , File . separator ) ; while ( tok . hasMoreTokens ( ) ) { String part = tok . nextToken ( ) ; if ( part . equals ( ".." ) ) { helpFile = getParentFile ( helpFile ) ; if ( helpFile == null ) { String msg = "The file or path you specified (" + filename + ") is invalid relative to " + file . getPath ( ) ; throw new BuildException ( msg ) ; } } else if ( part . equals ( "." ) ) { } else { helpFile = new File ( helpFile , part ) ; } } return new File ( helpFile . getAbsolutePath ( ) ) ; } public File normalize ( String path ) { String orig = path ; path = path . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; int colon = path . indexOf ( ":" ) ; if ( ! onNetWare ) { if ( ! path . startsWith ( File . separator ) && ! ( path . length ( ) >= 2 && Character . isLetter ( path . charAt ( 0 ) ) && colon == 1 ) ) { String msg = path + " is not an absolute path" ; throw new BuildException ( msg ) ; } } else { if ( ! path . startsWith ( File . separator ) && ( colon == - 1 ) ) { String msg = path + " is not an absolute path" ; throw new BuildException ( msg ) ; } } boolean dosWithDrive = false ; String root = null ; if ( ( ! onNetWare && path . length ( ) >= 2 && Character . isLetter ( path . charAt ( 0 ) ) && path . charAt ( 1 ) == ':' ) || ( onNetWare && colon > - 1 ) ) { dosWithDrive = true ; char [ ] ca = path . replace ( '/' , '\\' ) . toCharArray ( ) ; StringBuffer sbRoot = new StringBuffer ( ) ; for ( int i = 0 ; i < colon ; i ++ ) { sbRoot . append ( Character . toUpperCase ( ca [ i ] ) ) ; } sbRoot . append ( ':' ) ; if ( colon + 1 < path . length ( ) ) { sbRoot . append ( File . separatorChar ) ; } root = sbRoot . toString ( ) ; StringBuffer sbPath = new StringBuffer ( ) ; for ( int i = colon + 1 ; i < ca . length ; i ++ ) { if ( ( ca [ i ] != '\\' ) || ( ca [ i ] == '\\' && ca [ i - 1 ] != '\\' ) ) { sbPath . append ( ca [ i ] ) ; } } path = sbPath . toString ( ) . replace ( '\\' , File . separatorChar ) ; } else { if ( path . length ( ) == 1 ) { root = File . separator ; path = "" ; } else if ( path . charAt ( 1 ) == File . separatorChar ) { root = File . separator + File . separator ; path = path . substring ( 2 ) ; } else { root = File . separator ; path = path . substring ( 1 ) ; } } Stack s = new Stack ( ) ; s . push ( root ) ; StringTokenizer tok = new StringTokenizer ( path , File . separator ) ; while ( tok . hasMoreTokens ( ) ) { String thisToken = tok . nextToken ( ) ; if ( "." . equals ( thisToken ) ) { continue ; } else if ( ".." . equals ( thisToken ) ) { if ( s . size ( ) < 2 ) { throw new BuildException ( "Cannot resolve path " + orig ) ; } else { s . pop ( ) ; } } else { s . push ( thisToken ) ; } } StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( i > 1 ) { sb . append ( File . separatorChar ) ; } sb . append ( s . elementAt ( i ) ) ; } path = sb . toString ( ) ; if ( dosWithDrive ) { path = path . replace ( '/' , '\\' ) ; } return new File ( path ) ; } public String toVMSPath ( File f ) { String osPath ; String path = normalize ( f . getAbsolutePath ( ) ) . getPath ( ) ; String name = f . getName ( ) ; boolean isAbsolute = path . charAt ( 0 ) == File . separatorChar ; boolean isDirectory = f . isDirectory ( ) && ! name . regionMatches ( true , name . length ( ) - 4 , ".DIR" , 0 , 4 ) ; String device = null ; StringBuffer directory = null ; String file = null ; int index = 0 ; if ( isAbsolute ) { index = path . indexOf ( File . separatorChar , 1 ) ; if ( index == - 1 ) { return path . substring ( 1 ) + ":[000000]" ; } else { device = path . substring ( 1 , index ++ ) ; } } if ( isDirectory ) { directory = new StringBuffer ( path . substring ( index ) . replace ( File . separatorChar , '.' ) ) ; } else { int dirEnd = path . lastIndexOf ( File . separatorChar , path . length ( ) ) ; if ( dirEnd == - 1 || dirEnd < index ) { file = path . substring ( index ) ; } else { directory = new StringBuffer ( path . substring ( index , dirEnd ) . replace ( File . separatorChar , '.' ) ) ; index = dirEnd + 1 ; if ( path . length ( ) > index ) { file = path . substring ( index ) ; } } } if ( ! isAbsolute && directory != null ) { directory . insert ( 0 , '.' ) ; } osPath = ( ( device != null ) ? device + ":" : "" ) + ( ( directory != null ) ? "[" + directory + "]" : "" ) + ( ( file != null ) ? file : "" ) ; return osPath ; } public File createTempFile ( String prefix , String suffix , File parentDir ) { File result = null ; String parent = System . getProperty ( "java.io.tmpdir" ) ; if ( parentDir != null ) { parent = parentDir . getPath ( ) ; } DecimalFormat fmt = new DecimalFormat ( "#####" ) ; synchronized ( rand ) { do { result = new File ( parent , prefix + fmt . format ( Math . abs ( rand . nextInt ( ) ) ) + suffix ) ; } while ( result . exists ( ) ) ; } return result ; } public boolean contentEquals ( File f1 , File f2 ) throws IOException { if ( f1 . exists ( ) != f2 . exists ( ) ) { return false ; } if ( ! f1 . exists ( ) ) { return true ; } if ( f1 . isDirectory ( ) || f2 . isDirectory ( ) ) { return false ; } if ( fileNameEquals ( f1 , f2 ) ) { return true ; } if ( f1 . length ( ) != f2 . length ( ) ) { return false ; } InputStream in1 = null ; InputStream in2 = null ; try { in1 = new BufferedInputStream ( new FileInputStream ( f1 ) ) ; in2 = new BufferedInputStream ( new FileInputStream ( f2 ) ) ; int expectedByte = in1 . read ( ) ; while ( expectedByte != - 1 ) { if ( expectedByte != in2 . read ( ) ) { return false ; } expectedByte = in1 . read ( ) ; } if ( in2 . read ( ) != - 1 ) { return false ; } return true ; } finally { if ( in1 != null ) { try { in1 . close ( ) ; } catch ( IOException e ) { } } if ( in2 != null ) { try { in2 . close ( ) ; } catch ( IOException e ) { } } } } public File getParentFile ( File f ) { if ( f != null ) { String p = f . getParent ( ) ; if ( p != null ) { return new File ( p ) ; } } return null ; } public static final String readFully ( Reader rdr ) throws IOException { return readFully ( rdr , 8192 ) ; } public static final String readFully ( Reader rdr , int bufferSize ) throws IOException { if ( bufferSize <= 0 ) { throw new IllegalArgumentException ( "Buffer size must be greater " + "than 0" ) ; } final char [ ] buffer = new char [ bufferSize ] ; int bufferLength = 0 ; String text = null ; StringBuffer textBuffer = null ; while ( bufferLength != - 1 ) { bufferLength = rdr . read ( buffer ) ; if ( bufferLength != - 1 ) { if ( textBuffer == null ) { textBuffer = new StringBuffer ( new String ( buffer , 0 , bufferLength ) ) ; } else { textBuffer . append ( new String ( buffer , 0 , bufferLength ) ) ; } } } if ( textBuffer != null ) { text = textBuffer . toString ( ) ; } return text ; } public boolean createNewFile ( File f ) throws IOException { if ( f != null ) { if ( f . exists ( ) ) { return false ; } FileOutputStream fos = null ; try { fos = new FileOutputStream ( f ) ; fos . write ( new byte [ 0 ] ) ; } finally { if ( fos != null ) { fos . close ( ) ; } } return true ; } return false ; } public boolean isSymbolicLink ( File parent , String name ) throws IOException { File resolvedParent = new File ( parent . getCanonicalPath ( ) ) ; File toTest = new File ( resolvedParent , name ) ; return ! toTest . getAbsolutePath ( ) . equals ( toTest . getCanonicalPath ( ) ) ; } public String removeLeadingPath ( File leading , File path ) { String l = normalize ( leading . getAbsolutePath ( ) ) . getAbsolutePath ( ) ; String p = normalize ( path . getAbsolutePath ( ) ) . getAbsolutePath ( ) ; if ( l . equals ( p ) ) { return "" ; } if ( ! l . endsWith ( File . separator ) ) { l += File . separator ; } if ( p . startsWith ( l ) ) { return p . substring ( l . length ( ) ) ; } else { return p ; } } public String toURI ( String path ) { boolean isDir = ( new File ( path ) ) . isDirectory ( ) ; StringBuffer sb = new StringBuffer ( "file:" ) ; try { path = normalize ( path ) . getAbsolutePath ( ) ; sb . append ( "//" ) ; if ( ! path . startsWith ( File . separator ) ) { sb . append ( "/" ) ; } } catch ( BuildException e ) { } path = path . replace ( '\\' , '/' ) ; CharacterIterator iter = new StringCharacterIterator ( path ) ; for ( char c = iter . first ( ) ; c != CharacterIterator . DONE ; c = iter . next ( ) ) { if ( isSpecial [ c ] ) { sb . append ( '%' ) ; sb . append ( escapedChar1 [ c ] ) ; sb . append ( escapedChar2 [ c ] ) ; } else { sb . append ( c ) ; } } if ( isDir && ! path . endsWith ( "/" ) ) { sb . append ( '/' ) ; } return sb . toString ( ) ; } public String fromURI ( String uri ) { String path = Locator . fromURI ( uri ) ; try { path = normalize ( path ) . getAbsolutePath ( ) ; } catch ( BuildException e ) { } return path ; } public boolean fileNameEquals ( File f1 , File f2 ) { return normalize ( f1 . getAbsolutePath ( ) ) . equals ( normalize ( f2 . getAbsolutePath ( ) ) ) ; } public void rename ( File from , File to ) throws IOException { if ( to . exists ( ) && ! to . delete ( ) ) { throw new IOException ( "Failed to delete " + to + " while trying to rename " + from ) ; } File parent = getParentFile ( to ) ; if ( parent != null && ! parent . exists ( ) && ! parent . mkdirs ( ) ) { throw new IOException ( "Failed to create directory " + parent + " while trying to rename " + from ) ; } if ( ! from . renameTo ( to ) ) { copyFile ( from , to ) ; if ( ! from . delete ( ) ) { throw new IOException ( "Failed to delete " + from + " while trying to rename it." ) ; } } } public long getFileTimestampGranularity ( ) { if ( Os . isFamily ( "dos" ) ) { return FAT_FILE_TIMESTAMP_GRANULARITY ; } else { return 0 ; } } } 	1	['37', '1', '0', '51', '146', '654', '46', '8', '33', '0.941358025', '2046', '0.777777778', '0', '0', '0.283333333', '0', '0', '54.05405405', '29', '2.8108', '8']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . util . Hashtable ; import java . util . StringTokenizer ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class KeySubst extends Task { private File source = null ; private File dest = null ; private String sep = "*" ; private Hashtable replacements = new Hashtable ( ) ; public void execute ( ) throws BuildException { log ( "!! KeySubst is deprecated. Use Filter + Copy instead. !!" ) ; log ( "Performing Substitutions" ) ; if ( source == null || dest == null ) { log ( "Source and destinations must not be null" ) ; return ; } BufferedReader br = null ; BufferedWriter bw = null ; try { br = new BufferedReader ( new FileReader ( source ) ) ; dest . delete ( ) ; bw = new BufferedWriter ( new FileWriter ( dest ) ) ; String line = null ; String newline = null ; line = br . readLine ( ) ; while ( line != null ) { if ( line . length ( ) == 0 ) { bw . newLine ( ) ; } else { newline = KeySubst . replace ( line , replacements ) ; bw . write ( newline ) ; bw . newLine ( ) ; } line = br . readLine ( ) ; } bw . flush ( ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } finally { if ( bw != null ) { try { bw . close ( ) ; } catch ( IOException e ) { } } if ( br != null ) { try { br . close ( ) ; } catch ( IOException e ) { } } } } public void setSrc ( File s ) { this . source = s ; } public void setDest ( File dest ) { this . dest = dest ; } public void setSep ( String sep ) { this . sep = sep ; } public void setKeys ( String keys ) { if ( keys != null && keys . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( keys , this . sep , false ) ; while ( tok . hasMoreTokens ( ) ) { String token = tok . nextToken ( ) . trim ( ) ; StringTokenizer itok = new StringTokenizer ( token , "=" , false ) ; String name = itok . nextToken ( ) ; String value = itok . nextToken ( ) ; replacements . put ( name , value ) ; } } } public static void main ( String [ ] args ) { try { Hashtable hash = new Hashtable ( ) ; hash . put ( "VERSION" , "1.0.3" ) ; hash . put ( "b" , "ffff" ) ; System . out . println ( KeySubst . replace ( "$f ${VERSION} f ${b} jj $" , hash ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public static String replace ( String origString , Hashtable keys ) throws BuildException { StringBuffer finalString = new StringBuffer ( ) ; int index = 0 ; int i = 0 ; String key = null ; while ( ( index = origString . indexOf ( "${" , i ) ) > - 1 ) { key = origString . substring ( index + 2 , origString . indexOf ( "}" , index + 3 ) ) ; finalString . append ( origString . substring ( i , index ) ) ; if ( keys . containsKey ( key ) ) { finalString . append ( keys . get ( key ) ) ; } else { finalString . append ( "${" ) ; finalString . append ( key ) ; finalString . append ( "}" ) ; } i = index + 3 + key . length ( ) ; } finalString . append ( origString . substring ( i ) ) ; return finalString . toString ( ) ; } } 	0	['8', '3', '0', '2', '39', '10', '0', '2', '8', '0.714285714', '308', '1', '0', '0.840909091', '0.325', '1', '1', '37', '4', '1.25', '0']
package org . apache . tools . ant ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . io . IOException ; import org . apache . tools . ant . taskdefs . PreSetDef ; public class UnknownElement extends Task { private String elementName ; private String namespace ; private String qname ; private Object realThing ; private List children = null ; private boolean presetDefed = false ; public UnknownElement ( String elementName ) { this . elementName = elementName ; } public String getTag ( ) { return elementName ; } public String getNamespace ( ) { return namespace ; } public void setNamespace ( String namespace ) { if ( namespace . equals ( ProjectHelper . ANT_CURRENT_URI ) ) { ComponentHelper helper = ComponentHelper . getComponentHelper ( getProject ( ) ) ; namespace = helper . getCurrentAntlibUri ( ) ; } this . namespace = namespace ; } public String getQName ( ) { return qname ; } public void setQName ( String qname ) { this . qname = qname ; } public RuntimeConfigurable getWrapper ( ) { return super . getWrapper ( ) ; } public void maybeConfigure ( ) throws BuildException { configure ( makeObject ( this , getWrapper ( ) ) ) ; } public void configure ( Object realObject ) { realThing = realObject ; getWrapper ( ) . setProxy ( realThing ) ; Task task = null ; if ( realThing instanceof Task ) { task = ( Task ) realThing ; task . setRuntimeConfigurableWrapper ( getWrapper ( ) ) ; this . getOwningTarget ( ) . replaceChild ( this , ( Task ) realThing ) ; } handleChildren ( realThing , getWrapper ( ) ) ; if ( task != null ) { task . maybeConfigure ( ) ; } else { getWrapper ( ) . maybeConfigure ( getProject ( ) ) ; } } protected void handleOutput ( String output ) { if ( realThing instanceof Task ) { ( ( Task ) realThing ) . handleOutput ( output ) ; } else { super . handleOutput ( output ) ; } } protected int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException { if ( realThing instanceof Task ) { return ( ( Task ) realThing ) . handleInput ( buffer , offset , length ) ; } else { return super . handleInput ( buffer , offset , length ) ; } } protected void handleFlush ( String output ) { if ( realThing instanceof Task ) { ( ( Task ) realThing ) . handleFlush ( output ) ; } else { super . handleFlush ( output ) ; } } protected void handleErrorOutput ( String output ) { if ( realThing instanceof Task ) { ( ( Task ) realThing ) . handleErrorOutput ( output ) ; } else { super . handleErrorOutput ( output ) ; } } protected void handleErrorFlush ( String output ) { if ( realThing instanceof Task ) { ( ( Task ) realThing ) . handleErrorOutput ( output ) ; } else { super . handleErrorOutput ( output ) ; } } public void execute ( ) { if ( realThing == null ) { throw new BuildException ( "Could not create task of type: " + elementName , getLocation ( ) ) ; } if ( realThing instanceof Task ) { ( ( Task ) realThing ) . execute ( ) ; } realThing = null ; } public void addChild ( UnknownElement child ) { if ( children == null ) { children = new ArrayList ( ) ; } children . add ( child ) ; } protected void handleChildren ( Object parent , RuntimeConfigurable parentWrapper ) throws BuildException { if ( parent instanceof TypeAdapter ) { parent = ( ( TypeAdapter ) parent ) . getProxy ( ) ; } String parentUri = getNamespace ( ) ; Class parentClass = parent . getClass ( ) ; IntrospectionHelper ih = IntrospectionHelper . getHelper ( parentClass ) ; if ( children != null ) { Iterator it = children . iterator ( ) ; for ( int i = 0 ; it . hasNext ( ) ; i ++ ) { RuntimeConfigurable childWrapper = parentWrapper . getChild ( i ) ; UnknownElement child = ( UnknownElement ) it . next ( ) ; if ( ! handleChild ( parentUri , ih , parent , child , childWrapper ) ) { if ( ! ( parent instanceof TaskContainer ) ) { ih . throwNotSupported ( getProject ( ) , parent , child . getTag ( ) ) ; } else { TaskContainer container = ( TaskContainer ) parent ; container . addTask ( child ) ; } } } } } protected String getComponentName ( ) { return ProjectHelper . genComponentName ( getNamespace ( ) , getTag ( ) ) ; } public void applyPreSet ( UnknownElement u ) { if ( presetDefed ) { return ; } getWrapper ( ) . applyPreSet ( u . getWrapper ( ) ) ; if ( u . children != null ) { List newChildren = new ArrayList ( ) ; newChildren . addAll ( u . children ) ; if ( children != null ) { newChildren . addAll ( children ) ; } children = newChildren ; } presetDefed = true ; } protected Object makeObject ( UnknownElement ue , RuntimeConfigurable w ) { ComponentHelper helper = ComponentHelper . getComponentHelper ( getProject ( ) ) ; String name = ue . getComponentName ( ) ; Object o = helper . createComponent ( ue , ue . getNamespace ( ) , name ) ; if ( o == null ) { throw getNotFoundException ( "task or type" , name ) ; } if ( o instanceof PreSetDef . PreSetDefinition ) { PreSetDef . PreSetDefinition def = ( PreSetDef . PreSetDefinition ) o ; o = def . createObject ( ue . getProject ( ) ) ; ue . applyPreSet ( def . getPreSets ( ) ) ; if ( o instanceof Task ) { Task task = ( Task ) o ; task . setTaskType ( ue . getTaskType ( ) ) ; task . setTaskName ( ue . getTaskName ( ) ) ; } } if ( o instanceof Task ) { Task task = ( Task ) o ; task . setOwningTarget ( getOwningTarget ( ) ) ; task . init ( ) ; } return o ; } protected Task makeTask ( UnknownElement ue , RuntimeConfigurable w ) { Task task = getProject ( ) . createTask ( ue . getTag ( ) ) ; if ( task != null ) { task . setLocation ( getLocation ( ) ) ; task . setOwningTarget ( getOwningTarget ( ) ) ; task . init ( ) ; } return task ; } protected BuildException getNotFoundException ( String what , String elementName ) { String lSep = System . getProperty ( "line.separator" ) ; String msg = "Could not create " + what + " of type: " + elementName + "." + lSep + lSep + "Ant could not find the task or a class this " + "task relies upon." + lSep + lSep + "This is common and has a number of causes; the usual " + lSep + "solutions are to read the manual pages then download and" + lSep + "install needed JAR files, or fix the build file: " + lSep + " - You have misspelt '" + elementName + "'." + lSep + "   Fix: check your spelling." + lSep + " - The task needs an external JAR file to execute" + lSep + "   and this is not found at the right place in the classpath." + lSep + "   Fix: check the documentation for dependencies." + lSep + "   Fix: declare the task." + lSep + " - The task is an Ant optional task and optional.jar is absent" + lSep + "   Fix: look for optional.jar in ANT_HOME/lib, download if needed" + lSep + " - The task was not built into optional.jar as dependent" + lSep + "   libraries were not found at build time." + lSep + "   Fix: look in the JAR to verify, then rebuild with the needed" + lSep + "   libraries, or download a release version from apache.org" + lSep + " - The build file was written for a later version of Ant" + lSep + "   Fix: upgrade to at least the latest release version of Ant" + lSep + " - The task is not an Ant core or optional task " + lSep + "   and needs to be declared using <taskdef>." + lSep + lSep + "Remember that for JAR files to be visible to Ant tasks implemented" + lSep + "in ANT_HOME/lib, the files must be in the same directory or on the" + lSep + "classpath" + lSep + lSep + "Please neither file bug reports on this problem, nor email the" + lSep + "Ant mailing lists, until all of these causes have been explored," + lSep + "as this is not an Ant bug." ; return new BuildException ( msg , getLocation ( ) ) ; } public String getTaskName ( ) { return realThing == null || ! ( realThing instanceof Task ) ? super . getTaskName ( ) : ( ( Task ) realThing ) . getTaskName ( ) ; } public Task getTask ( ) { if ( realThing instanceof Task ) { return ( Task ) realThing ; } return null ; } public Object getRealThing ( ) { return realThing ; } private boolean handleChild ( String parentUri , IntrospectionHelper ih , Object parent , UnknownElement child , RuntimeConfigurable childWrapper ) { String childName = ProjectHelper . genComponentName ( child . getNamespace ( ) , child . getTag ( ) ) ; if ( ih . supportsNestedElement ( parentUri , childName ) ) { IntrospectionHelper . Creator creator = ih . getElementCreator ( getProject ( ) , parentUri , parent , childName , child ) ; creator . setPolyType ( childWrapper . getPolyType ( ) ) ; Object realChild = creator . create ( ) ; if ( realChild instanceof PreSetDef . PreSetDefinition ) { PreSetDef . PreSetDefinition def = ( PreSetDef . PreSetDefinition ) realChild ; realChild = creator . getRealObject ( ) ; child . applyPreSet ( def . getPreSets ( ) ) ; } childWrapper . setCreator ( creator ) ; childWrapper . setProxy ( realChild ) ; if ( realChild instanceof Task ) { Task childTask = ( Task ) realChild ; childTask . setRuntimeConfigurableWrapper ( childWrapper ) ; childTask . setTaskName ( childName ) ; childTask . setTaskType ( childName ) ; childTask . setLocation ( child . getLocation ( ) ) ; } child . handleChildren ( realChild , childWrapper ) ; return true ; } return false ; } public boolean similar ( Object obj ) { if ( obj == null ) { return false ; } if ( ! getClass ( ) . getName ( ) . equals ( obj . getClass ( ) . getName ( ) ) ) { return false ; } UnknownElement other = ( UnknownElement ) obj ; if ( ! equalsString ( elementName , other . elementName ) ) { return false ; } if ( ! namespace . equals ( other . namespace ) ) { return false ; } if ( ! qname . equals ( other . qname ) ) { return false ; } if ( ! getWrapper ( ) . getAttributeMap ( ) . equals ( other . getWrapper ( ) . getAttributeMap ( ) ) ) { return false ; } if ( ! getWrapper ( ) . getText ( ) . toString ( ) . equals ( other . getWrapper ( ) . getText ( ) . toString ( ) ) ) { return false ; } if ( children == null || children . size ( ) == 0 ) { return other . children == null || other . children . size ( ) == 0 ; } if ( other . children == null ) { return false ; } if ( children . size ( ) != other . children . size ( ) ) { return false ; } for ( int i = 0 ; i < children . size ( ) ; ++ i ) { UnknownElement child = ( UnknownElement ) children . get ( i ) ; if ( ! child . similar ( other . children . get ( i ) ) ) { return false ; } } return true ; } private boolean equalsString ( String a , String b ) { if ( a == null ) { return b == null ; } return a . equals ( b ) ; } } 	1	['28', '3', '0', '26', '89', '246', '17', '14', '16', '0.771604938', '817', '1', '0', '0.578125', '0.241071429', '1', '5', '27.96428571', '16', '2.4286', '4']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . util . LinkedList ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . util . LineTokenizer ; public final class TailFilter extends BaseParamFilterReader implements ChainableReader { private static final String LINES_KEY = "lines" ; private static final String SKIP_KEY = "skip" ; private static final int DEFAULT_NUM_LINES = 10 ; private long lines = DEFAULT_NUM_LINES ; private long skip = 0 ; private boolean completedReadAhead = false ; private LineTokenizer lineTokenizer = null ; private String line = null ; private int linePos = 0 ; private LinkedList lineList = new LinkedList ( ) ; public TailFilter ( ) { super ( ) ; } public TailFilter ( final Reader in ) { super ( in ) ; lineTokenizer = new LineTokenizer ( ) ; lineTokenizer . setIncludeDelims ( true ) ; } public final int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } while ( line == null || line . length ( ) == 0 ) { line = lineTokenizer . getToken ( in ) ; line = tailFilter ( line ) ; if ( line == null ) { return - 1 ; } linePos = 0 ; } int ch = line . charAt ( linePos ) ; linePos ++ ; if ( linePos == line . length ( ) ) { line = null ; } return ch ; } public final void setLines ( final long lines ) { this . lines = lines ; } private final long getLines ( ) { return lines ; } public final void setSkip ( final long skip ) { this . skip = skip ; } private final long getSkip ( ) { return skip ; } public final Reader chain ( final Reader rdr ) { TailFilter newFilter = new TailFilter ( rdr ) ; newFilter . setLines ( getLines ( ) ) ; newFilter . setSkip ( getSkip ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private final void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( LINES_KEY . equals ( params [ i ] . getName ( ) ) ) { setLines ( new Long ( params [ i ] . getValue ( ) ) . longValue ( ) ) ; continue ; } if ( SKIP_KEY . equals ( params [ i ] . getName ( ) ) ) { skip = new Long ( params [ i ] . getValue ( ) ) . longValue ( ) ; continue ; } } } } private String tailFilter ( String line ) { if ( ! completedReadAhead ) { if ( line != null ) { lineList . add ( line ) ; if ( lines == - 1 ) { if ( lineList . size ( ) > skip ) { return ( String ) lineList . removeFirst ( ) ; } } else { long linesToKeep = lines + ( skip > 0 ? skip : 0 ) ; if ( linesToKeep < lineList . size ( ) ) { lineList . removeFirst ( ) ; } } return "" ; } completedReadAhead = true ; if ( skip > 0 ) { for ( int i = 0 ; i < skip ; ++ i ) { lineList . removeLast ( ) ; } } if ( lines > - 1 ) { while ( lineList . size ( ) > lines ) { lineList . removeFirst ( ) ; } } } if ( lineList . size ( ) > 0 ) { return ( String ) lineList . removeFirst ( ) ; } return null ; } } 	0	['10', '5', '0', '6', '30', '0', '1', '5', '6', '0.688888889', '328', '1', '1', '0.777777778', '0.375', '2', '5', '30.8', '12', '2.3', '0']
package org . apache . tools . ant . types ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class FilterSet extends DataType implements Cloneable { public static class Filter { String token ; String value ; public Filter ( String token , String value ) { this . token = token ; this . value = value ; } public Filter ( ) { } public void setToken ( String token ) { this . token = token ; } public void setValue ( String value ) { this . value = value ; } public String getToken ( ) { return token ; } public String getValue ( ) { return value ; } } public class FiltersFile { public FiltersFile ( ) { } public void setFile ( File file ) { readFiltersFromFile ( file ) ; } } public static final String DEFAULT_TOKEN_START = "@" ; public static final String DEFAULT_TOKEN_END = "@" ; private String startOfToken = DEFAULT_TOKEN_START ; private String endOfToken = DEFAULT_TOKEN_END ; private Vector filters = new Vector ( ) ; public FilterSet ( ) { } protected FilterSet ( FilterSet filterset ) { super ( ) ; this . filters = ( Vector ) filterset . getFilters ( ) . clone ( ) ; } protected Vector getFilters ( ) { if ( isReference ( ) ) { return getRef ( ) . getFilters ( ) ; } return filters ; } protected FilterSet getRef ( ) { return ( FilterSet ) getCheckedRef ( FilterSet . class , "filterset" ) ; } public Hashtable getFilterHash ( ) { int filterSize = getFilters ( ) . size ( ) ; Hashtable filterHash = new Hashtable ( filterSize + 1 ) ; for ( Enumeration e = getFilters ( ) . elements ( ) ; e . hasMoreElements ( ) ; ) { Filter filter = ( Filter ) e . nextElement ( ) ; filterHash . put ( filter . getToken ( ) , filter . getValue ( ) ) ; } return filterHash ; } public void setFiltersfile ( File filtersFile ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } readFiltersFromFile ( filtersFile ) ; } public void setBeginToken ( String startOfToken ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( startOfToken == null || "" . equals ( startOfToken ) ) { throw new BuildException ( "beginToken must not be empty" ) ; } this . startOfToken = startOfToken ; } public String getBeginToken ( ) { if ( isReference ( ) ) { return getRef ( ) . getBeginToken ( ) ; } return startOfToken ; } public void setEndToken ( String endOfToken ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( endOfToken == null || "" . equals ( endOfToken ) ) { throw new BuildException ( "endToken must not be empty" ) ; } this . endOfToken = endOfToken ; } public String getEndToken ( ) { if ( isReference ( ) ) { return getRef ( ) . getEndToken ( ) ; } return endOfToken ; } public void readFiltersFromFile ( File filtersFile ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( ! filtersFile . exists ( ) ) { throw new BuildException ( "Could not read filters from file " + filtersFile + " as it doesn't exist." ) ; } if ( filtersFile . isFile ( ) ) { log ( "Reading filters from " + filtersFile , Project . MSG_VERBOSE ) ; FileInputStream in = null ; try { Properties props = new Properties ( ) ; in = new FileInputStream ( filtersFile ) ; props . load ( in ) ; Enumeration e = props . propertyNames ( ) ; Vector filters = getFilters ( ) ; while ( e . hasMoreElements ( ) ) { String strPropName = ( String ) e . nextElement ( ) ; String strValue = props . getProperty ( strPropName ) ; filters . addElement ( new Filter ( strPropName , strValue ) ) ; } } catch ( Exception ex ) { throw new BuildException ( "Could not read filters from file: " + filtersFile ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( IOException ioex ) { } } } } else { throw new BuildException ( "Must specify a file not a directory in " + "the filtersfile attribute:" + filtersFile ) ; } } public String replaceTokens ( String line ) { String beginToken = getBeginToken ( ) ; String endToken = getEndToken ( ) ; int index = line . indexOf ( beginToken ) ; if ( index > - 1 ) { Hashtable tokens = getFilterHash ( ) ; try { StringBuffer b = new StringBuffer ( ) ; int i = 0 ; String token = null ; String value = null ; do { int endIndex = line . indexOf ( endToken , index + beginToken . length ( ) + 1 ) ; if ( endIndex == - 1 ) { break ; } token = line . substring ( index + beginToken . length ( ) , endIndex ) ; b . append ( line . substring ( i , index ) ) ; if ( tokens . containsKey ( token ) ) { value = ( String ) tokens . get ( token ) ; if ( ! value . equals ( token ) ) { value = replaceTokens ( value , token ) ; } log ( "Replacing: " + beginToken + token + endToken + " -> " + value , Project . MSG_VERBOSE ) ; b . append ( value ) ; i = index + beginToken . length ( ) + token . length ( ) + endToken . length ( ) ; } else { b . append ( beginToken ) ; i = index + beginToken . length ( ) ; } } while ( ( index = line . indexOf ( beginToken , i ) ) > - 1 ) ; b . append ( line . substring ( i ) ) ; return b . toString ( ) ; } catch ( StringIndexOutOfBoundsException e ) { return line ; } } else { return line ; } } private Vector passedTokens ; private boolean duplicateToken = false ; private String replaceTokens ( String line , String parent ) throws BuildException { if ( passedTokens == null ) { passedTokens = new Vector ( ) ; } if ( passedTokens . contains ( parent ) && ! duplicateToken ) { duplicateToken = true ; StringBuffer sb = new StringBuffer ( ) ; sb . append ( "Inifinite loop in tokens. Currently known tokens : " ) ; sb . append ( passedTokens ) ; sb . append ( "\nProblem token : " + getBeginToken ( ) + parent + getEndToken ( ) ) ; sb . append ( " called from " + getBeginToken ( ) + passedTokens . lastElement ( ) ) ; sb . append ( getEndToken ( ) ) ; System . out . println ( sb . toString ( ) ) ; return parent ; } passedTokens . addElement ( parent ) ; String value = this . replaceTokens ( line ) ; if ( value . indexOf ( getBeginToken ( ) ) == - 1 && ! duplicateToken ) { duplicateToken = false ; passedTokens = null ; } else if ( duplicateToken ) { if ( passedTokens . size ( ) > 0 ) { value = ( String ) passedTokens . lastElement ( ) ; passedTokens . removeElementAt ( passedTokens . size ( ) - 1 ) ; if ( passedTokens . size ( ) == 0 ) { value = getBeginToken ( ) + value + getEndToken ( ) ; duplicateToken = false ; } } } return value ; } public void addFilter ( Filter filter ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } filters . addElement ( filter ) ; } public FiltersFile createFiltersfile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return new FiltersFile ( ) ; } public void addFilter ( String token , String value ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } filters . addElement ( new Filter ( token , value ) ) ; } public void addConfiguredFilterSet ( FilterSet filterSet ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } for ( Enumeration e = filterSet . getFilters ( ) . elements ( ) ; e . hasMoreElements ( ) ; ) { filters . addElement ( e . nextElement ( ) ) ; } } public boolean hasFilters ( ) { return getFilters ( ) . size ( ) > 0 ; } public Object clone ( ) throws BuildException { if ( isReference ( ) ) { return ( ( FilterSet ) getRef ( ) ) . clone ( ) ; } else { try { FilterSet fs = ( FilterSet ) super . clone ( ) ; fs . filters = ( Vector ) getFilters ( ) . clone ( ) ; fs . setProject ( getProject ( ) ) ; return fs ; } catch ( CloneNotSupportedException e ) { throw new BuildException ( e ) ; } } } } 	1	['20', '3', '0', '11', '71', '124', '7', '6', '15', '0.782894737', '698', '0.625', '0', '0.625', '0.3', '2', '3', '33.5', '6', '2', '3']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . Project ; public final class ExpandProperties extends BaseFilterReader implements ChainableReader { private String queuedData = null ; public ExpandProperties ( ) { super ( ) ; } public ExpandProperties ( final Reader in ) { super ( in ) ; } public final int read ( ) throws IOException { int ch = - 1 ; if ( queuedData != null && queuedData . length ( ) == 0 ) { queuedData = null ; } if ( queuedData != null ) { ch = queuedData . charAt ( 0 ) ; queuedData = queuedData . substring ( 1 ) ; if ( queuedData . length ( ) == 0 ) { queuedData = null ; } } else { queuedData = readFully ( ) ; if ( queuedData == null ) { ch = - 1 ; } else { Project project = getProject ( ) ; queuedData = project . replaceProperties ( queuedData ) ; return read ( ) ; } } return ch ; } public final Reader chain ( final Reader rdr ) { ExpandProperties newFilter = new ExpandProperties ( rdr ) ; newFilter . setProject ( getProject ( ) ) ; return newFilter ; } } 	0	['4', '4', '0', '4', '13', '0', '1', '3', '4', '0', '87', '1', '0', '0.928571429', '0.75', '2', '4', '20.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Stack ; import java . util . Vector ; import java . util . zip . CRC32 ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . FileScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . PatternSet ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ZipFileSet ; import org . apache . tools . ant . types . ZipScanner ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . GlobPatternMapper ; import org . apache . tools . ant . util . IdentityMapper ; import org . apache . tools . ant . util . MergingMapper ; import org . apache . tools . ant . util . ResourceUtils ; import org . apache . tools . zip . ZipEntry ; import org . apache . tools . zip . ZipFile ; import org . apache . tools . zip . ZipOutputStream ; public class Zip extends MatchingTask { protected File zipFile ; private ZipScanner zs ; private File baseDir ; protected Hashtable entries = new Hashtable ( ) ; private Vector groupfilesets = new Vector ( ) ; private Vector filesetsFromGroupfilesets = new Vector ( ) ; protected String duplicate = "add" ; private boolean doCompress = true ; private boolean doUpdate = false ; private boolean savedDoUpdate = false ; private boolean doFilesonly = false ; protected String archiveType = "zip" ; private static final long EMPTY_CRC = new CRC32 ( ) . getValue ( ) ; protected String emptyBehavior = "skip" ; private Vector filesets = new Vector ( ) ; protected Hashtable addedDirs = new Hashtable ( ) ; private Vector addedFiles = new Vector ( ) ; protected boolean doubleFilePass = false ; protected boolean skipWriting = false ; private static FileUtils fileUtils = FileUtils . newFileUtils ( ) ; private boolean addingNewFiles = false ; private String encoding ; private boolean keepCompression = false ; public void setZipfile ( File zipFile ) { setDestFile ( zipFile ) ; } public void setFile ( File file ) { setDestFile ( file ) ; } public void setDestFile ( File destFile ) { this . zipFile = destFile ; } public File getDestFile ( ) { return zipFile ; } public void setBasedir ( File baseDir ) { this . baseDir = baseDir ; } public void setCompress ( boolean c ) { doCompress = c ; } public boolean isCompress ( ) { return doCompress ; } public void setFilesonly ( boolean f ) { doFilesonly = f ; } public void setUpdate ( boolean c ) { doUpdate = c ; savedDoUpdate = c ; } public boolean isInUpdateMode ( ) { return doUpdate ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void addZipfileset ( ZipFileSet set ) { filesets . addElement ( set ) ; } public void addZipGroupFileset ( FileSet set ) { groupfilesets . addElement ( set ) ; } public void setDuplicate ( Duplicate df ) { duplicate = df . getValue ( ) ; } public static class WhenEmpty extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "fail" , "skip" , "create" } ; } } public void setWhenempty ( WhenEmpty we ) { emptyBehavior = we . getValue ( ) ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String getEncoding ( ) { return encoding ; } public void setKeepCompression ( boolean keep ) { keepCompression = keep ; } public void execute ( ) throws BuildException { if ( doubleFilePass ) { skipWriting = true ; executeMain ( ) ; skipWriting = false ; executeMain ( ) ; } else { executeMain ( ) ; } } public void executeMain ( ) throws BuildException { if ( baseDir == null && filesets . size ( ) == 0 && groupfilesets . size ( ) == 0 && "zip" . equals ( archiveType ) ) { throw new BuildException ( "basedir attribute must be set, " + "or at least " + "one fileset must be given!" ) ; } if ( zipFile == null ) { throw new BuildException ( "You must specify the " + archiveType + " file to create!" ) ; } File renamedFile = null ; addingNewFiles = true ; if ( doUpdate && ! zipFile . exists ( ) ) { doUpdate = false ; log ( "ignoring update attribute as " + archiveType + " doesn't exist." , Project . MSG_DEBUG ) ; } for ( int i = 0 ; i < groupfilesets . size ( ) ; i ++ ) { log ( "Processing groupfileset " , Project . MSG_VERBOSE ) ; FileSet fs = ( FileSet ) groupfilesets . elementAt ( i ) ; FileScanner scanner = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] files = scanner . getIncludedFiles ( ) ; File basedir = scanner . getBasedir ( ) ; for ( int j = 0 ; j < files . length ; j ++ ) { log ( "Adding file " + files [ j ] + " to fileset" , Project . MSG_VERBOSE ) ; ZipFileSet zf = new ZipFileSet ( ) ; zf . setProject ( getProject ( ) ) ; zf . setSrc ( new File ( basedir , files [ j ] ) ) ; filesets . addElement ( zf ) ; filesetsFromGroupfilesets . addElement ( zf ) ; } } Vector vfss = new Vector ( ) ; if ( baseDir != null ) { FileSet fs = ( FileSet ) getImplicitFileSet ( ) . clone ( ) ; fs . setDir ( baseDir ) ; vfss . addElement ( fs ) ; } for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; vfss . addElement ( fs ) ; } FileSet [ ] fss = new FileSet [ vfss . size ( ) ] ; vfss . copyInto ( fss ) ; boolean success = false ; try { ArchiveState state = getResourcesToAdd ( fss , zipFile , false ) ; if ( ! state . isOutOfDate ( ) ) { return ; } Resource [ ] [ ] addThem = state . getResourcesToAdd ( ) ; if ( doUpdate ) { renamedFile = fileUtils . createTempFile ( "zip" , ".tmp" , fileUtils . getParentFile ( zipFile ) ) ; renamedFile . deleteOnExit ( ) ; try { fileUtils . rename ( zipFile , renamedFile ) ; } catch ( SecurityException e ) { throw new BuildException ( "Not allowed to rename old file (" + zipFile . getAbsolutePath ( ) + ") to temporary file" ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to rename old file (" + zipFile . getAbsolutePath ( ) + ") to temporary file" ) ; } } String action = doUpdate ? "Updating " : "Building " ; log ( action + archiveType + ": " + zipFile . getAbsolutePath ( ) ) ; ZipOutputStream zOut = null ; try { if ( ! skipWriting ) { zOut = new ZipOutputStream ( zipFile ) ; zOut . setEncoding ( encoding ) ; if ( doCompress ) { zOut . setMethod ( ZipOutputStream . DEFLATED ) ; } else { zOut . setMethod ( ZipOutputStream . STORED ) ; } } initZipOutputStream ( zOut ) ; for ( int i = 0 ; i < fss . length ; i ++ ) { if ( addThem [ i ] . length != 0 ) { addResources ( fss [ i ] , addThem [ i ] , zOut ) ; } } if ( doUpdate ) { addingNewFiles = false ; ZipFileSet oldFiles = new ZipFileSet ( ) ; oldFiles . setProject ( getProject ( ) ) ; oldFiles . setSrc ( renamedFile ) ; for ( int i = 0 ; i < addedFiles . size ( ) ; i ++ ) { PatternSet . NameEntry ne = oldFiles . createExclude ( ) ; ne . setName ( ( String ) addedFiles . elementAt ( i ) ) ; } DirectoryScanner ds = oldFiles . getDirectoryScanner ( getProject ( ) ) ; ( ( ZipScanner ) ds ) . setEncoding ( encoding ) ; String [ ] f = ds . getIncludedFiles ( ) ; Resource [ ] r = new Resource [ f . length ] ; for ( int i = 0 ; i < f . length ; i ++ ) { r [ i ] = ds . getResource ( f [ i ] ) ; } if ( ! doFilesonly ) { String [ ] d = ds . getIncludedDirectories ( ) ; Resource [ ] dr = new Resource [ d . length ] ; for ( int i = 0 ; i < d . length ; i ++ ) { dr [ i ] = ds . getResource ( d [ i ] ) ; } Resource [ ] tmp = r ; r = new Resource [ tmp . length + dr . length ] ; System . arraycopy ( dr , 0 , r , 0 , dr . length ) ; System . arraycopy ( tmp , 0 , r , dr . length , tmp . length ) ; } addResources ( oldFiles , r , zOut ) ; } finalizeZipOutputStream ( zOut ) ; if ( doUpdate ) { if ( ! renamedFile . delete ( ) ) { log ( "Warning: unable to delete temporary file " + renamedFile . getName ( ) , Project . MSG_WARN ) ; } } success = true ; } finally { try { if ( zOut != null ) { zOut . close ( ) ; } } catch ( IOException ex ) { if ( success ) { throw ex ; } } } } catch ( IOException ioe ) { String msg = "Problem creating " + archiveType + ": " + ioe . getMessage ( ) ; if ( ( ! doUpdate || renamedFile != null ) && ! zipFile . delete ( ) ) { msg += " (and the archive is probably corrupt but I could not " + "delete it)" ; } if ( doUpdate && renamedFile != null ) { try { fileUtils . rename ( renamedFile , zipFile ) ; } catch ( IOException e ) { msg += " (and I couldn't rename the temporary file " + renamedFile . getName ( ) + " back)" ; } } throw new BuildException ( msg , ioe , getLocation ( ) ) ; } finally { cleanUp ( ) ; } } protected final boolean isAddingNewFiles ( ) { return addingNewFiles ; } protected final void addResources ( FileSet fileset , Resource [ ] resources , ZipOutputStream zOut ) throws IOException { String prefix = "" ; String fullpath = "" ; int dirMode = ZipFileSet . DEFAULT_DIR_MODE ; int fileMode = ZipFileSet . DEFAULT_FILE_MODE ; ZipFileSet zfs = null ; if ( fileset instanceof ZipFileSet ) { zfs = ( ZipFileSet ) fileset ; prefix = zfs . getPrefix ( getProject ( ) ) ; fullpath = zfs . getFullpath ( getProject ( ) ) ; dirMode = zfs . getDirMode ( getProject ( ) ) ; fileMode = zfs . getFileMode ( getProject ( ) ) ; } if ( prefix . length ( ) > 0 && fullpath . length ( ) > 0 ) { throw new BuildException ( "Both prefix and fullpath attributes must" + " not be set on the same fileset." ) ; } if ( resources . length != 1 && fullpath . length ( ) > 0 ) { throw new BuildException ( "fullpath attribute may only be specified" + " for filesets that specify a single" + " file." ) ; } if ( prefix . length ( ) > 0 ) { if ( ! prefix . endsWith ( "/" ) && ! prefix . endsWith ( "\\" ) ) { prefix += "/" ; } addParentDirs ( null , prefix , zOut , "" , dirMode ) ; } ZipFile zf = null ; try { boolean dealingWithFiles = false ; File base = null ; if ( zfs == null || zfs . getSrc ( getProject ( ) ) == null ) { dealingWithFiles = true ; base = fileset . getDir ( getProject ( ) ) ; } else { zf = new ZipFile ( zfs . getSrc ( getProject ( ) ) , encoding ) ; } for ( int i = 0 ; i < resources . length ; i ++ ) { String name = null ; if ( fullpath . length ( ) > 0 ) { name = fullpath ; } else { name = resources [ i ] . getName ( ) ; } name = name . replace ( File . separatorChar , '/' ) ; if ( "" . equals ( name ) ) { continue ; } if ( resources [ i ] . isDirectory ( ) && ! name . endsWith ( "/" ) ) { name = name + "/" ; } if ( ! doFilesonly && ! dealingWithFiles && resources [ i ] . isDirectory ( ) && ! zfs . hasDirModeBeenSet ( ) ) { int nextToLastSlash = name . lastIndexOf ( "/" , name . length ( ) - 2 ) ; if ( nextToLastSlash != - 1 ) { addParentDirs ( base , name . substring ( 0 , nextToLastSlash + 1 ) , zOut , prefix , dirMode ) ; } ZipEntry ze = zf . getEntry ( resources [ i ] . getName ( ) ) ; addParentDirs ( base , name , zOut , prefix , ze . getUnixMode ( ) ) ; } else { addParentDirs ( base , name , zOut , prefix , dirMode ) ; } if ( ! resources [ i ] . isDirectory ( ) && dealingWithFiles ) { File f = fileUtils . resolveFile ( base , resources [ i ] . getName ( ) ) ; zipFile ( f , zOut , prefix + name , fileMode ) ; } else if ( ! resources [ i ] . isDirectory ( ) ) { ZipEntry ze = zf . getEntry ( resources [ i ] . getName ( ) ) ; if ( ze != null ) { boolean oldCompress = doCompress ; if ( keepCompression ) { doCompress = ( ze . getMethod ( ) == ZipEntry . DEFLATED ) ; } try { zipFile ( zf . getInputStream ( ze ) , zOut , prefix + name , ze . getTime ( ) , zfs . getSrc ( getProject ( ) ) , zfs . hasFileModeBeenSet ( ) ? fileMode : ze . getUnixMode ( ) ) ; } finally { doCompress = oldCompress ; } } } } } finally { if ( zf != null ) { zf . close ( ) ; } } } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { } protected void finalizeZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { } protected boolean createEmptyZip ( File zipFile ) throws BuildException { log ( "Note: creating empty " + archiveType + " archive " + zipFile , Project . MSG_INFO ) ; OutputStream os = null ; try { os = new FileOutputStream ( zipFile ) ; byte [ ] empty = new byte [ 22 ] ; empty [ 0 ] = 80 ; empty [ 1 ] = 75 ; empty [ 2 ] = 5 ; empty [ 3 ] = 6 ; os . write ( empty ) ; } catch ( IOException ioe ) { throw new BuildException ( "Could not create empty ZIP archive " + "(" + ioe . getMessage ( ) + ")" , ioe , getLocation ( ) ) ; } finally { if ( os != null ) { try { os . close ( ) ; } catch ( IOException e ) { } } } return true ; } private synchronized ZipScanner getZipScanner ( ) { if ( zs == null ) { zs = new ZipScanner ( ) ; zs . setEncoding ( encoding ) ; zs . setSrc ( zipFile ) ; } return zs ; } protected ArchiveState getResourcesToAdd ( FileSet [ ] filesets , File zipFile , boolean needsUpdate ) throws BuildException { Resource [ ] [ ] initialResources = grabResources ( filesets ) ; if ( isEmpty ( initialResources ) ) { if ( needsUpdate && doUpdate ) { return new ArchiveState ( true , initialResources ) ; } if ( emptyBehavior . equals ( "skip" ) ) { if ( doUpdate ) { log ( archiveType + " archive " + zipFile + " not updated because no new files were included." , Project . MSG_VERBOSE ) ; } else { log ( "Warning: skipping " + archiveType + " archive " + zipFile + " because no files were included." , Project . MSG_WARN ) ; } } else if ( emptyBehavior . equals ( "fail" ) ) { throw new BuildException ( "Cannot create " + archiveType + " archive " + zipFile + ": no files were included." , getLocation ( ) ) ; } else { createEmptyZip ( zipFile ) ; } return new ArchiveState ( needsUpdate , initialResources ) ; } if ( ! zipFile . exists ( ) ) { return new ArchiveState ( true , initialResources ) ; } if ( needsUpdate && ! doUpdate ) { return new ArchiveState ( true , initialResources ) ; } Resource [ ] [ ] newerResources = new Resource [ filesets . length ] [ ] ; for ( int i = 0 ; i < filesets . length ; i ++ ) { if ( ! ( fileset instanceof ZipFileSet ) || ( ( ZipFileSet ) fileset ) . getSrc ( getProject ( ) ) == null ) { File base = filesets [ i ] . getDir ( getProject ( ) ) ; for ( int j = 0 ; j < initialResources [ i ] . length ; j ++ ) { File resourceAsFile = fileUtils . resolveFile ( base , initialResources [ i ] [ j ] . getName ( ) ) ; if ( resourceAsFile . equals ( zipFile ) ) { throw new BuildException ( "A zip file cannot include " + "itself" , getLocation ( ) ) ; } } } } for ( int i = 0 ; i < filesets . length ; i ++ ) { if ( initialResources [ i ] . length == 0 ) { newerResources [ i ] = new Resource [ ] { } ; continue ; } FileNameMapper myMapper = new IdentityMapper ( ) ; if ( filesets [ i ] instanceof ZipFileSet ) { ZipFileSet zfs = ( ZipFileSet ) filesets [ i ] ; if ( zfs . getFullpath ( getProject ( ) ) != null && ! zfs . getFullpath ( getProject ( ) ) . equals ( "" ) ) { MergingMapper fm = new MergingMapper ( ) ; fm . setTo ( zfs . getFullpath ( getProject ( ) ) ) ; myMapper = fm ; } else if ( zfs . getPrefix ( getProject ( ) ) != null && ! zfs . getPrefix ( getProject ( ) ) . equals ( "" ) ) { GlobPatternMapper gm = new GlobPatternMapper ( ) ; gm . setFrom ( "*" ) ; String prefix = zfs . getPrefix ( getProject ( ) ) ; if ( ! prefix . endsWith ( "/" ) && ! prefix . endsWith ( "\\" ) ) { prefix += "/" ; } gm . setTo ( prefix + "*" ) ; myMapper = gm ; } } Resource [ ] resources = initialResources [ i ] ; if ( doFilesonly ) { resources = selectFileResources ( resources ) ; } newerResources [ i ] = ResourceUtils . selectOutOfDateSources ( this , resources , myMapper , getZipScanner ( ) ) ; needsUpdate = needsUpdate || ( newerResources [ i ] . length > 0 ) ; if ( needsUpdate && ! doUpdate ) { break ; } } if ( needsUpdate && ! doUpdate ) { return new ArchiveState ( true , initialResources ) ; } return new ArchiveState ( needsUpdate , newerResources ) ; } protected Resource [ ] [ ] grabResources ( FileSet [ ] filesets ) { Resource [ ] [ ] result = new Resource [ filesets . length ] [ ] ; for ( int i = 0 ; i < filesets . length ; i ++ ) { DirectoryScanner rs = filesets [ i ] . getDirectoryScanner ( getProject ( ) ) ; if ( rs instanceof ZipScanner ) { ( ( ZipScanner ) rs ) . setEncoding ( encoding ) ; } Vector resources = new Vector ( ) ; String [ ] directories = rs . getIncludedDirectories ( ) ; for ( int j = 0 ; j < directories . length ; j ++ ) { resources . addElement ( rs . getResource ( directories [ j ] ) ) ; } String [ ] files = rs . getIncludedFiles ( ) ; for ( int j = 0 ; j < files . length ; j ++ ) { resources . addElement ( rs . getResource ( files [ j ] ) ) ; } result [ i ] = new Resource [ resources . size ( ) ] ; resources . copyInto ( result [ i ] ) ; } return result ; } protected void zipDir ( File dir , ZipOutputStream zOut , String vPath , int mode ) throws IOException { if ( addedDirs . get ( vPath ) != null ) { return ; } log ( "adding directory " + vPath , Project . MSG_VERBOSE ) ; addedDirs . put ( vPath , vPath ) ; if ( ! skipWriting ) { ZipEntry ze = new ZipEntry ( vPath ) ; if ( dir != null && dir . exists ( ) ) { ze . setTime ( dir . lastModified ( ) + 1999 ) ; } else { ze . setTime ( System . currentTimeMillis ( ) + 1999 ) ; } ze . setSize ( 0 ) ; ze . setMethod ( ZipEntry . STORED ) ; ze . setCrc ( EMPTY_CRC ) ; ze . setUnixMode ( mode ) ; zOut . putNextEntry ( ze ) ; } } protected void zipFile ( InputStream in , ZipOutputStream zOut , String vPath , long lastModified , File fromArchive , int mode ) throws IOException { if ( entries . contains ( vPath ) ) { if ( duplicate . equals ( "preserve" ) ) { log ( vPath + " already added, skipping" , Project . MSG_INFO ) ; return ; } else if ( duplicate . equals ( "fail" ) ) { throw new BuildException ( "Duplicate file " + vPath + " was found and the duplicate " + "attribute is 'fail'." ) ; } else { log ( "duplicate file " + vPath + " found, adding." , Project . MSG_VERBOSE ) ; } } else { log ( "adding entry " + vPath , Project . MSG_VERBOSE ) ; } entries . put ( vPath , vPath ) ; if ( ! skipWriting ) { ZipEntry ze = new ZipEntry ( vPath ) ; ze . setTime ( lastModified ) ; ze . setMethod ( doCompress ? ZipEntry . DEFLATED : ZipEntry . STORED ) ; if ( ! zOut . isSeekable ( ) && ! doCompress ) { long size = 0 ; CRC32 cal = new CRC32 ( ) ; if ( ! in . markSupported ( ) ) { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { size += count ; cal . update ( buffer , 0 , count ) ; bos . write ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; in = new ByteArrayInputStream ( bos . toByteArray ( ) ) ; } else { in . mark ( Integer . MAX_VALUE ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { size += count ; cal . update ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; in . reset ( ) ; } ze . setSize ( size ) ; ze . setCrc ( cal . getValue ( ) ) ; } ze . setUnixMode ( mode ) ; zOut . putNextEntry ( ze ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { if ( count != 0 ) { zOut . write ( buffer , 0 , count ) ; } count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } addedFiles . addElement ( vPath ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath , int mode ) throws IOException { if ( file . equals ( zipFile ) ) { throw new BuildException ( "A zip file cannot include itself" , getLocation ( ) ) ; } FileInputStream fIn = new FileInputStream ( file ) ; try { zipFile ( fIn , zOut , vPath , file . lastModified ( ) + 1999 , null , mode ) ; } finally { fIn . close ( ) ; } } protected final void addParentDirs ( File baseDir , String entry , ZipOutputStream zOut , String prefix , int dirMode ) throws IOException { if ( ! doFilesonly ) { Stack directories = new Stack ( ) ; int slashPos = entry . length ( ) ; while ( ( slashPos = entry . lastIndexOf ( '/' , slashPos - 1 ) ) != - 1 ) { String dir = entry . substring ( 0 , slashPos + 1 ) ; if ( addedDirs . get ( prefix + dir ) != null ) { break ; } directories . push ( dir ) ; } while ( ! directories . isEmpty ( ) ) { String dir = ( String ) directories . pop ( ) ; File f = null ; if ( baseDir != null ) { f = new File ( baseDir , dir ) ; } else { f = new File ( dir ) ; } zipDir ( f , zOut , prefix + dir , dirMode ) ; } } } protected void cleanUp ( ) { addedDirs . clear ( ) ; addedFiles . removeAllElements ( ) ; entries . clear ( ) ; addingNewFiles = false ; doUpdate = savedDoUpdate ; Enumeration e = filesetsFromGroupfilesets . elements ( ) ; while ( e . hasMoreElements ( ) ) { ZipFileSet zf = ( ZipFileSet ) e . nextElement ( ) ; filesets . removeElement ( zf ) ; } filesetsFromGroupfilesets . removeAllElements ( ) ; } public void reset ( ) { filesets . removeAllElements ( ) ; zipFile = null ; baseDir = null ; groupfilesets . removeAllElements ( ) ; duplicate = "add" ; archiveType = "zip" ; doCompress = true ; emptyBehavior = "skip" ; doUpdate = false ; doFilesonly = false ; encoding = null ; } protected static final boolean isEmpty ( Resource [ ] [ ] r ) { for ( int i = 0 ; i < r . length ; i ++ ) { if ( r [ i ] . length > 0 ) { return false ; } } return true ; } protected Resource [ ] selectFileResources ( Resource [ ] orig ) { if ( orig . length == 0 ) { return orig ; } Vector v = new Vector ( orig . length ) ; for ( int i = 0 ; i < orig . length ; i ++ ) { if ( ! orig [ i ] . isDirectory ( ) ) { v . addElement ( orig [ i ] ) ; } else { log ( "Ignoring directory " + orig [ i ] . getName ( ) + " as only files will be added." , Project . MSG_VERBOSE ) ; } } if ( v . size ( ) != orig . length ) { Resource [ ] r = new Resource [ v . size ( ) ] ; v . copyInto ( r ) ; return r ; } return orig ; } public static class Duplicate extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "add" , "preserve" , "fail" } ; } } public static class ArchiveState { private boolean outOfDate ; private Resource [ ] [ ] resourcesToAdd ; ArchiveState ( boolean state , Resource [ ] [ ] r ) { outOfDate = state ; resourcesToAdd = r ; } public boolean isOutOfDate ( ) { return outOfDate ; } public Resource [ ] [ ] getResourcesToAdd ( ) { return resourcesToAdd ; } } } 	1	['38', '4', '1', '31', '169', '453', '3', '28', '22', '0.869565217', '2236', '1', '2', '0.684210526', '0.144144144', '0', '0', '57.23684211', '5', '1.2632', '6']
package org . apache . tools . ant . types ; import java . net . URL ; public class ResourceLocation { private String name = null ; private String publicId = null ; private String location = null ; private URL base = null ; public void setPublicId ( String publicId ) { this . publicId = publicId ; } public void setLocation ( String location ) { this . location = location ; } public void setBase ( URL base ) { this . base = base ; } public String getPublicId ( ) { return publicId ; } public String getLocation ( ) { return location ; } public URL getBase ( ) { return base ; } } 	0	['7', '1', '1', '5', '8', '3', '5', '0', '7', '0.75', '47', '1', '0', '0', '0.476190476', '0', '0', '5.142857143', '1', '0.8571', '0']
package org . apache . tools . ant . util ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import org . apache . bsf . BSFException ; import org . apache . bsf . BSFManager ; import org . apache . tools . ant . BuildException ; import java . util . Map ; import java . util . HashMap ; import java . util . Iterator ; public class ScriptRunner { private String language ; private String script = "" ; private Map beans = new HashMap ( ) ; public void addBeans ( Map dictionary ) { for ( Iterator i = dictionary . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { String key = ( String ) i . next ( ) ; try { Object val = dictionary . get ( key ) ; addBean ( key , val ) ; } catch ( BuildException ex ) { } } } public void addBean ( String key , Object bean ) { boolean isValid = key . length ( ) > 0 && Character . isJavaIdentifierStart ( key . charAt ( 0 ) ) ; for ( int i = 1 ; isValid && i < key . length ( ) ; i ++ ) { isValid = Character . isJavaIdentifierPart ( key . charAt ( i ) ) ; } if ( isValid ) { beans . put ( key , bean ) ; } } public void executeScript ( String execName ) throws BuildException { if ( language == null ) { throw new BuildException ( "script language must be specified" ) ; } try { BSFManager manager = new BSFManager ( ) ; for ( Iterator i = beans . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { String key = ( String ) i . next ( ) ; Object value = beans . get ( key ) ; if ( value != null ) { manager . declareBean ( key , value , value . getClass ( ) ) ; } else { manager . undeclareBean ( key ) ; } } manager . exec ( language , execName , 0 , 0 , script ) ; } catch ( BSFException be ) { Throwable t = be ; Throwable te = be . getTargetException ( ) ; if ( te != null ) { if ( te instanceof BuildException ) { throw ( BuildException ) te ; } else { t = te ; } } throw new BuildException ( t ) ; } } public void setLanguage ( String language ) { this . language = language ; } public String getLanguage ( ) { return language ; } public void setSrc ( File file ) { if ( ! file . exists ( ) ) { throw new BuildException ( "file " + file . getPath ( ) + " not found." ) ; } int count = ( int ) file . length ( ) ; byte [ ] data = new byte [ count ] ; try { FileInputStream inStream = new FileInputStream ( file ) ; inStream . read ( data ) ; inStream . close ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } script += new String ( data ) ; } public void addText ( String text ) { this . script += text ; } } 	1	['8', '1', '0', '3', '38', '6', '0', '3', '8', '0.619047619', '233', '1', '0', '0', '0.375', '0', '0', '27.75', '6', '1.75', '1']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . ZipFileSet ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . zip . ZipOutputStream ; public class War extends Jar { private File deploymentDescriptor ; private boolean descriptorAdded ; private static final FileUtils fu = FileUtils . newFileUtils ( ) ; public War ( ) { super ( ) ; archiveType = "war" ; emptyBehavior = "create" ; } public void setWarfile ( File warFile ) { setDestFile ( warFile ) ; } public void setWebxml ( File descr ) { deploymentDescriptor = descr ; if ( ! deploymentDescriptor . exists ( ) ) { throw new BuildException ( "Deployment descriptor: " + deploymentDescriptor + " does not exist." ) ; } ZipFileSet fs = new ZipFileSet ( ) ; fs . setFile ( deploymentDescriptor ) ; fs . setFullpath ( "WEB-INF/web.xml" ) ; super . addFileset ( fs ) ; } public void addLib ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/lib/" ) ; super . addFileset ( fs ) ; } public void addClasses ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/classes/" ) ; super . addFileset ( fs ) ; } public void addWebinf ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/" ) ; super . addFileset ( fs ) ; } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( deploymentDescriptor == null && ! isInUpdateMode ( ) ) { throw new BuildException ( "webxml attribute is required" , getLocation ( ) ) ; } super . initZipOutputStream ( zOut ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath , int mode ) throws IOException { if ( vPath . equalsIgnoreCase ( "WEB-INF/web.xml" ) ) { if ( deploymentDescriptor == null || ! fu . fileNameEquals ( deploymentDescriptor , file ) || descriptorAdded ) { log ( "Warning: selected " + archiveType + " files include a WEB-INF/web.xml which will be ignored " + "(please use webxml attribute to " + archiveType + " task)" , Project . MSG_WARN ) ; } else { super . zipFile ( file , zOut , vPath , mode ) ; descriptorAdded = true ; } } else { super . zipFile ( file , zOut , vPath , mode ) ; } } protected void cleanUp ( ) { descriptorAdded = false ; super . cleanUp ( ) ; } } 	0	['10', '6', '0', '10', '33', '35', '0', '10', '6', '0.851851852', '165', '1', '1', '0.950617284', '0.351851852', '3', '9', '15.2', '2', '0.9', '0']
package org . apache . tools . tar ; public interface TarConstants { int NAMELEN = 100 ; int MODELEN = 8 ; int UIDLEN = 8 ; int GIDLEN = 8 ; int CHKSUMLEN = 8 ; int SIZELEN = 12 ; int MAGICLEN = 8 ; int MODTIMELEN = 12 ; int UNAMELEN = 32 ; int GNAMELEN = 32 ; int DEVLEN = 8 ; byte LF_OLDNORM = 0 ; byte LF_NORMAL = ( byte ) '0' ; byte LF_LINK = ( byte ) '1' ; byte LF_SYMLINK = ( byte ) '2' ; byte LF_CHR = ( byte ) '3' ; byte LF_BLK = ( byte ) '4' ; byte LF_DIR = ( byte ) '5' ; byte LF_FIFO = ( byte ) '6' ; byte LF_CONTIG = ( byte ) '7' ; String TMAGIC = "ustar" ; String GNU_TMAGIC = "ustar  " ; String GNU_LONGLINK = "././@LongLink" ; byte LF_GNUTYPE_LONGNAME = ( byte ) 'L' ; } 	1	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '24', '0', '0', '0', '0', '0', '0', '0', '0', '0', '1']
package org . apache . tools . ant . taskdefs ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . HashMap ; import org . apache . tools . ant . AntTypeDefinition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ComponentHelper ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . RuntimeConfigurable ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . UnknownElement ; public class MacroDef extends AntlibDefinition { private NestedSequential nestedSequential ; private String name ; private List attributes = new ArrayList ( ) ; private Map elements = new HashMap ( ) ; public void setName ( String name ) { this . name = name ; } public NestedSequential createSequential ( ) { if ( this . nestedSequential != null ) { throw new BuildException ( "Only one sequential allowed" ) ; } this . nestedSequential = new NestedSequential ( ) ; return this . nestedSequential ; } public static class NestedSequential implements TaskContainer { private List nested = new ArrayList ( ) ; public void addTask ( Task task ) { nested . add ( task ) ; } public List getNested ( ) { return nested ; } public boolean similar ( NestedSequential other ) { if ( nested . size ( ) != other . nested . size ( ) ) { return false ; } for ( int i = 0 ; i < nested . size ( ) ; ++ i ) { UnknownElement me = ( UnknownElement ) nested . get ( i ) ; UnknownElement o = ( UnknownElement ) other . nested . get ( i ) ; if ( ! me . similar ( o ) ) { return false ; } } return true ; } } public UnknownElement getNestedTask ( ) { UnknownElement ret = new UnknownElement ( "sequential" ) ; ret . setTaskName ( "sequential" ) ; ret . setNamespace ( "" ) ; ret . setQName ( "sequential" ) ; new RuntimeConfigurable ( ret , "sequential" ) ; for ( int i = 0 ; i < nestedSequential . getNested ( ) . size ( ) ; ++ i ) { UnknownElement e = ( UnknownElement ) nestedSequential . getNested ( ) . get ( i ) ; ret . addChild ( e ) ; ret . getWrapper ( ) . addChild ( e . getWrapper ( ) ) ; } return ret ; } public List getAttributes ( ) { return attributes ; } public Map getElements ( ) { return elements ; } public static boolean isValidNameCharacter ( char c ) { return Character . isLetterOrDigit ( c ) || c == '.' || c == '-' ; } private static boolean isValidName ( String name ) { if ( name . length ( ) == 0 ) { return false ; } for ( int i = 0 ; i < name . length ( ) ; ++ i ) { if ( ! isValidNameCharacter ( name . charAt ( i ) ) ) { return false ; } } return true ; } public void addConfiguredAttribute ( Attribute attribute ) { if ( attribute . getName ( ) == null ) { throw new BuildException ( "the attribute nested element needed a \"name\" attribute" ) ; } for ( int i = 0 ; i < attributes . size ( ) ; ++ i ) { if ( ( ( Attribute ) attributes . get ( i ) ) . getName ( ) . equals ( attribute . getName ( ) ) ) { throw new BuildException ( "the attribute " + attribute . getName ( ) + " has already been specified" ) ; } } attributes . add ( attribute ) ; } public void addConfiguredElement ( TemplateElement element ) { if ( element . getName ( ) == null ) { throw new BuildException ( "the element nested element needed a \"name\" attribute" ) ; } if ( elements . get ( element . getName ( ) ) != null ) { throw new BuildException ( "the element " + element . getName ( ) + " has already been specified" ) ; } elements . put ( element . getName ( ) , element ) ; } public void execute ( ) { if ( nestedSequential == null ) { throw new BuildException ( "Missing sequential element" ) ; } if ( name == null ) { throw new BuildException ( "Name not specified" ) ; } name = ProjectHelper . genComponentName ( getURI ( ) , name ) ; MyAntTypeDefinition def = new MyAntTypeDefinition ( this ) ; def . setName ( name ) ; def . setClass ( MacroInstance . class ) ; ComponentHelper helper = ComponentHelper . getComponentHelper ( getProject ( ) ) ; helper . addDataTypeDefinition ( def ) ; } public static class Attribute { private String name ; private String defaultValue ; public void setName ( String name ) { if ( ! isValidName ( name ) ) { throw new BuildException ( "Illegal name [" + name + "] for attribute" ) ; } this . name = name ; } public String getName ( ) { return name ; } public void setDefault ( String defaultValue ) { this . defaultValue = defaultValue ; } public String getDefault ( ) { return defaultValue ; } public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( obj . getClass ( ) != getClass ( ) ) { return false ; } Attribute other = ( Attribute ) obj ; if ( name == null ) { if ( other . name != null ) { return false ; } } else if ( ! name . equals ( other . name ) ) { return false ; } if ( defaultValue == null ) { if ( other . defaultValue != null ) { return false ; } } else if ( ! defaultValue . equals ( other . defaultValue ) ) { return false ; } return true ; } public int hashCode ( ) { return objectHashCode ( defaultValue ) + objectHashCode ( name ) ; } } public static class TemplateElement { private String name ; private boolean optional = false ; public void setName ( String name ) { if ( ! isValidName ( name ) ) { throw new BuildException ( "Illegal name [" + name + "] for attribute" ) ; } this . name = name ; } public String getName ( ) { return name ; } public void setOptional ( boolean optional ) { this . optional = optional ; } public boolean isOptional ( ) { return optional ; } public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( obj . getClass ( ) != getClass ( ) ) { return false ; } TemplateElement other = ( TemplateElement ) obj ; if ( name == null ) { if ( other . name != null ) { return false ; } } else if ( ! name . equals ( other . name ) ) { return false ; } return optional == other . optional ; } public int hashCode ( ) { return objectHashCode ( name ) + ( optional ? 1 : 0 ) ; } } public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( ! obj . getClass ( ) . equals ( getClass ( ) ) ) { return false ; } MacroDef other = ( MacroDef ) obj ; if ( name == null ) { return other . name == null ; } if ( ! name . equals ( other . name ) ) { return false ; } if ( getURI ( ) == null || getURI ( ) . equals ( "" ) || getURI ( ) . equals ( ProjectHelper . ANT_CORE_URI ) ) { if ( ! ( other . getURI ( ) == null || other . getURI ( ) . equals ( "" ) || other . getURI ( ) . equals ( ProjectHelper . ANT_CORE_URI ) ) ) { return false ; } } else { if ( ! getURI ( ) . equals ( other . getURI ( ) ) ) { return false ; } } if ( ! nestedSequential . similar ( other . nestedSequential ) ) { return false ; } if ( ! attributes . equals ( other . attributes ) ) { return false ; } if ( ! elements . equals ( other . elements ) ) { return false ; } return true ; } public int hashCode ( ) { return objectHashCode ( name ) + objectHashCode ( getURI ( ) ) + objectHashCode ( nestedSequential ) + objectHashCode ( attributes ) + objectHashCode ( elements ) ; } private static class MyAntTypeDefinition extends AntTypeDefinition { private MacroDef macroDef ; public MyAntTypeDefinition ( MacroDef macroDef ) { this . macroDef = macroDef ; } public Object create ( Project project ) { Object o = super . create ( project ) ; if ( o == null ) { return null ; } ( ( MacroInstance ) o ) . setMacroDef ( macroDef ) ; return o ; } public boolean sameDefinition ( AntTypeDefinition other , Project project ) { if ( ! super . sameDefinition ( other , project ) ) { return false ; } MyAntTypeDefinition otherDef = ( MyAntTypeDefinition ) other ; return macroDef . equals ( otherDef . macroDef ) ; } public boolean similarDefinition ( AntTypeDefinition other , Project project ) { if ( ! super . similarDefinition ( other , project ) ) { return false ; } MyAntTypeDefinition otherDef = ( MyAntTypeDefinition ) other ; return macroDef . equals ( otherDef . macroDef ) ; } } private static int objectHashCode ( Object o ) { if ( o == null ) { return 0 ; } else { return o . hashCode ( ) ; } } } 	0	['17', '4', '0', '15', '62', '78', '4', '14', '12', '0.8125', '416', '0.8', '1', '0.719298246', '0.205882353', '0', '0', '23.17647059', '16', '2.8235', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; public final class ClassConstants extends BaseFilterReader implements ChainableReader { private String queuedData = null ; private static final String JAVA_CLASS_HELPER = "org.apache.tools.ant.filters.util.JavaClassHelper" ; public ClassConstants ( ) { super ( ) ; } public ClassConstants ( final Reader in ) { super ( in ) ; } public final int read ( ) throws IOException { int ch = - 1 ; if ( queuedData != null && queuedData . length ( ) == 0 ) { queuedData = null ; } if ( queuedData != null ) { ch = queuedData . charAt ( 0 ) ; queuedData = queuedData . substring ( 1 ) ; if ( queuedData . length ( ) == 0 ) { queuedData = null ; } } else { final String clazz = readFully ( ) ; if ( clazz == null ) { ch = - 1 ; } else { final byte [ ] bytes = clazz . getBytes ( ) ; try { final Class javaClassHelper = Class . forName ( JAVA_CLASS_HELPER ) ; if ( javaClassHelper != null ) { final Class [ ] params = { byte [ ] . class } ; final Method getConstants = javaClassHelper . getMethod ( "getConstants" , params ) ; final Object [ ] args = { bytes } ; final StringBuffer sb = ( StringBuffer ) getConstants . invoke ( null , args ) ; if ( sb . length ( ) > 0 ) { queuedData = sb . toString ( ) ; return read ( ) ; } } } catch ( ClassNotFoundException cnfe ) { throw new IOException ( cnfe . getMessage ( ) ) ; } catch ( NoSuchMethodException nsme ) { throw new IOException ( nsme . getMessage ( ) ) ; } catch ( IllegalAccessException iae ) { throw new IOException ( iae . getMessage ( ) ) ; } catch ( IllegalArgumentException iarge ) { throw new IOException ( iarge . getMessage ( ) ) ; } catch ( InvocationTargetException ite ) { throw new IOException ( ite . getMessage ( ) ) ; } } } return ch ; } public final Reader chain ( final Reader rdr ) { ClassConstants newFilter = new ClassConstants ( rdr ) ; return newFilter ; } } 	1	['5', '4', '0', '3', '20', '4', '1', '2', '4', '0.833333333', '168', '0.666666667', '0', '0.896551724', '0.466666667', '2', '4', '32', '1', '0.6', '1']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; public class Copydir extends MatchingTask { private File srcDir ; private File destDir ; private boolean filtering = false ; private boolean flatten = false ; private boolean forceOverwrite = false ; private Hashtable filecopyList = new Hashtable ( ) ; public void setSrc ( File src ) { srcDir = src ; } public void setDest ( File dest ) { destDir = dest ; } public void setFiltering ( boolean filter ) { filtering = filter ; } public void setFlatten ( boolean flatten ) { this . flatten = flatten ; } public void setForceoverwrite ( boolean force ) { forceOverwrite = force ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The copydir task is deprecated.  Use copy instead." ) ; if ( srcDir == null ) { throw new BuildException ( "src attribute must be set!" , getLocation ( ) ) ; } if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir " + srcDir . toString ( ) + " does not exist!" , getLocation ( ) ) ; } if ( destDir == null ) { throw new BuildException ( "The dest attribute must be set." , getLocation ( ) ) ; } if ( srcDir . equals ( destDir ) ) { log ( "Warning: src == dest" , Project . MSG_WARN ) ; } DirectoryScanner ds = super . getDirectoryScanner ( srcDir ) ; try { String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( srcDir , destDir , files ) ; if ( filecopyList . size ( ) > 0 ) { log ( "Copying " + filecopyList . size ( ) + " file" + ( filecopyList . size ( ) == 1 ? "" : "s" ) + " to " + destDir . getAbsolutePath ( ) ) ; Enumeration e = filecopyList . keys ( ) ; while ( e . hasMoreElements ( ) ) { String fromFile = ( String ) e . nextElement ( ) ; String toFile = ( String ) filecopyList . get ( fromFile ) ; try { getProject ( ) . copyFile ( fromFile , toFile , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } } } } finally { filecopyList . clear ( ) ; } } private void scanDir ( File from , File to , String [ ] files ) { for ( int i = 0 ; i < files . length ; i ++ ) { String filename = files [ i ] ; File srcFile = new File ( from , filename ) ; File destFile ; if ( flatten ) { destFile = new File ( to , new File ( filename ) . getName ( ) ) ; } else { destFile = new File ( to , filename ) ; } if ( forceOverwrite || ( srcFile . lastModified ( ) > destFile . lastModified ( ) ) ) { filecopyList . put ( srcFile . getAbsolutePath ( ) , destFile . getAbsolutePath ( ) ) ; } } } } 	0	['8', '4', '0', '7', '39', '4', '0', '7', '7', '0.714285714', '277', '1', '0', '0.917647059', '0.46875', '4', '4', '32.875', '5', '1.375', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . text . DateFormat ; import java . text . ParseException ; import java . util . Locale ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; public class Touch extends Task { private File file ; private long millis = - 1 ; private String dateTime ; private Vector filesets = new Vector ( ) ; private FileUtils fileUtils ; public Touch ( ) { fileUtils = FileUtils . newFileUtils ( ) ; } public void setFile ( File file ) { this . file = file ; } public void setMillis ( long millis ) { this . millis = millis ; } public void setDatetime ( String dateTime ) { this . dateTime = dateTime ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void execute ( ) throws BuildException { long savedMillis = millis ; if ( file == null && filesets . size ( ) == 0 ) { throw new BuildException ( "Specify at least one source - a file or " + "a fileset." ) ; } if ( file != null && file . exists ( ) && file . isDirectory ( ) ) { throw new BuildException ( "Use a fileset to touch directories." ) ; } try { if ( dateTime != null ) { DateFormat df = DateFormat . getDateTimeInstance ( DateFormat . SHORT , DateFormat . SHORT , Locale . US ) ; try { setMillis ( df . parse ( dateTime ) . getTime ( ) ) ; } catch ( ParseException pe ) { df = DateFormat . getDateTimeInstance ( DateFormat . SHORT , DateFormat . MEDIUM , Locale . US ) ; try { setMillis ( df . parse ( dateTime ) . getTime ( ) ) ; } catch ( ParseException pe2 ) { throw new BuildException ( pe2 . getMessage ( ) , pe , getLocation ( ) ) ; } } if ( millis < 0 ) { throw new BuildException ( "Date of " + dateTime + " results in negative " + "milliseconds value " + "relative to epoch " + "(January 1, 1970, " + "00:00:00 GMT)." ) ; } } touch ( ) ; } finally { millis = savedMillis ; } } protected void touch ( ) throws BuildException { if ( file != null ) { if ( ! file . exists ( ) ) { log ( "Creating " + file , Project . MSG_INFO ) ; try { fileUtils . createNewFile ( file ) ; } catch ( IOException ioe ) { throw new BuildException ( "Could not create " + file , ioe , getLocation ( ) ) ; } } } if ( millis >= 0 && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { log ( "modification time of files cannot be set in JDK 1.1" , Project . MSG_WARN ) ; return ; } boolean resetMillis = false ; if ( millis < 0 ) { resetMillis = true ; millis = System . currentTimeMillis ( ) ; } if ( file != null ) { touch ( file ) ; } for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; File fromDir = fs . getDir ( getProject ( ) ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; String [ ] srcDirs = ds . getIncludedDirectories ( ) ; for ( int j = 0 ; j < srcFiles . length ; j ++ ) { touch ( new File ( fromDir , srcFiles [ j ] ) ) ; } for ( int j = 0 ; j < srcDirs . length ; j ++ ) { touch ( new File ( fromDir , srcDirs [ j ] ) ) ; } } if ( resetMillis ) { millis = - 1 ; } } protected void touch ( File file ) throws BuildException { if ( ! file . canWrite ( ) ) { throw new BuildException ( "Can not change modification date of " + "read-only file " + file ) ; } if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { return ; } fileUtils . setFileLastModified ( file , millis ) ; } } 	1	['8', '3', '0', '10', '39', '0', '0', '10', '6', '0.628571429', '330', '1', '1', '0.840909091', '0.325', '0', '0', '39.625', '1', '0.875', '1']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedInputStream ; import java . io . ByteArrayInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . Reader ; import java . util . Enumeration ; import java . util . Properties ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . filters . util . ChainReaderHelper ; import org . apache . tools . ant . types . FilterChain ; public final class LoadProperties extends Task { private File srcFile = null ; private final Vector filterChains = new Vector ( ) ; private String encoding = null ; public final void setSrcFile ( final File srcFile ) { this . srcFile = srcFile ; } public final void setEncoding ( final String encoding ) { this . encoding = encoding ; } public final void execute ( ) throws BuildException { if ( srcFile == null ) { throw new BuildException ( "Source file not defined." ) ; } if ( ! srcFile . exists ( ) ) { throw new BuildException ( "Source file does not exist." ) ; } if ( ! srcFile . isFile ( ) ) { throw new BuildException ( "Source file is not a file." ) ; } FileInputStream fis = null ; BufferedInputStream bis = null ; Reader instream = null ; ByteArrayInputStream tis = null ; try { final long len = srcFile . length ( ) ; fis = new FileInputStream ( srcFile ) ; bis = new BufferedInputStream ( fis ) ; if ( encoding == null ) { instream = new InputStreamReader ( bis ) ; } else { instream = new InputStreamReader ( bis , encoding ) ; } ChainReaderHelper crh = new ChainReaderHelper ( ) ; crh . setPrimaryReader ( instream ) ; crh . setFilterChains ( filterChains ) ; crh . setProject ( getProject ( ) ) ; instream = crh . getAssembledReader ( ) ; String text = crh . readFully ( instream ) ; if ( text != null ) { if ( ! text . endsWith ( "\n" ) ) { text = text + "\n" ; } if ( encoding == null ) { tis = new ByteArrayInputStream ( text . getBytes ( ) ) ; } else { tis = new ByteArrayInputStream ( text . getBytes ( encoding ) ) ; } final Properties props = new Properties ( ) ; props . load ( tis ) ; Property propertyTask = ( Property ) getProject ( ) . createTask ( "property" ) ; propertyTask . setTaskName ( getTaskName ( ) ) ; propertyTask . addProperties ( props ) ; } } catch ( final IOException ioe ) { final String message = "Unable to load file: " + ioe . toString ( ) ; throw new BuildException ( message , ioe , getLocation ( ) ) ; } catch ( final BuildException be ) { throw be ; } finally { try { if ( fis != null ) { fis . close ( ) ; } } catch ( IOException ioex ) { } try { if ( tis != null ) { tis . close ( ) ; } } catch ( IOException ioex ) { } } } public final void addFilterChain ( FilterChain filter ) { filterChains . addElement ( filter ) ; } } 	0	['5', '3', '0', '8', '41', '0', '0', '8', '5', '0.5', '230', '1', '0', '0.902439024', '0.4', '2', '2', '44.4', '1', '0.8', '0']
package org . apache . tools . zip ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . Vector ; import java . util . zip . ZipException ; public class ZipEntry extends java . util . zip . ZipEntry implements Cloneable { private static final int PLATFORM_UNIX = 3 ; private static final int PLATFORM_FAT = 0 ; private int internalAttributes = 0 ; private int platform = PLATFORM_FAT ; private long externalAttributes = 0 ; private Vector extraFields = new Vector ( ) ; private String name = null ; public ZipEntry ( String name ) { super ( name ) ; } public ZipEntry ( java . util . zip . ZipEntry entry ) throws ZipException { super ( entry . getName ( ) ) ; setComment ( entry . getComment ( ) ) ; setMethod ( entry . getMethod ( ) ) ; setTime ( entry . getTime ( ) ) ; long size = entry . getSize ( ) ; if ( size > 0 ) { setSize ( size ) ; } long cSize = entry . getCompressedSize ( ) ; if ( cSize > 0 ) { setComprSize ( cSize ) ; } long crc = entry . getCrc ( ) ; if ( crc > 0 ) { setCrc ( crc ) ; } byte [ ] extra = entry . getExtra ( ) ; if ( extra != null ) { setExtraFields ( ExtraFieldUtils . parse ( extra ) ) ; } else { setExtra ( ) ; } } public ZipEntry ( ZipEntry entry ) throws ZipException { this ( ( java . util . zip . ZipEntry ) entry ) ; setInternalAttributes ( entry . getInternalAttributes ( ) ) ; setExternalAttributes ( entry . getExternalAttributes ( ) ) ; setExtraFields ( entry . getExtraFields ( ) ) ; } protected ZipEntry ( ) { super ( "" ) ; } public Object clone ( ) { try { ZipEntry e = ( ZipEntry ) super . clone ( ) ; e . setName ( getName ( ) ) ; e . setComment ( getComment ( ) ) ; e . setMethod ( getMethod ( ) ) ; e . setTime ( getTime ( ) ) ; long size = getSize ( ) ; if ( size > 0 ) { e . setSize ( size ) ; } long cSize = getCompressedSize ( ) ; if ( cSize > 0 ) { e . setComprSize ( cSize ) ; } long crc = getCrc ( ) ; if ( crc > 0 ) { e . setCrc ( crc ) ; } e . extraFields = ( Vector ) extraFields . clone ( ) ; e . setInternalAttributes ( getInternalAttributes ( ) ) ; e . setExternalAttributes ( getExternalAttributes ( ) ) ; e . setExtraFields ( getExtraFields ( ) ) ; return e ; } catch ( Throwable t ) { return null ; } } public int getInternalAttributes ( ) { return internalAttributes ; } public void setInternalAttributes ( int value ) { internalAttributes = value ; } public long getExternalAttributes ( ) { return externalAttributes ; } public void setExternalAttributes ( long value ) { externalAttributes = value ; } public void setUnixMode ( int mode ) { setExternalAttributes ( ( mode << 16 ) | ( ( mode & 0200 ) == 0 ? 1 : 0 ) | ( isDirectory ( ) ? 0x10 : 0 ) ) ; platform = PLATFORM_UNIX ; } public int getUnixMode ( ) { return ( int ) ( ( getExternalAttributes ( ) > > 16 ) & 0xFFFF ) ; } public int getPlatform ( ) { return platform ; } protected void setPlatform ( int platform ) { this . platform = platform ; } public void setExtraFields ( ZipExtraField [ ] fields ) { extraFields . removeAllElements ( ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { extraFields . addElement ( fields [ i ] ) ; } setExtra ( ) ; } public ZipExtraField [ ] getExtraFields ( ) { ZipExtraField [ ] result = new ZipExtraField [ extraFields . size ( ) ] ; extraFields . copyInto ( result ) ; return result ; } public void addExtraField ( ZipExtraField ze ) { ZipShort type = ze . getHeaderId ( ) ; boolean done = false ; for ( int i = 0 ; ! done && i < extraFields . size ( ) ; i ++ ) { if ( ( ( ZipExtraField ) extraFields . elementAt ( i ) ) . getHeaderId ( ) . equals ( type ) ) { extraFields . setElementAt ( ze , i ) ; done = true ; } } if ( ! done ) { extraFields . addElement ( ze ) ; } setExtra ( ) ; } public void removeExtraField ( ZipShort type ) { boolean done = false ; for ( int i = 0 ; ! done && i < extraFields . size ( ) ; i ++ ) { if ( ( ( ZipExtraField ) extraFields . elementAt ( i ) ) . getHeaderId ( ) . equals ( type ) ) { extraFields . removeElementAt ( i ) ; done = true ; } } if ( ! done ) { throw new java . util . NoSuchElementException ( ) ; } setExtra ( ) ; } public void setExtra ( byte [ ] extra ) throws RuntimeException { try { setExtraFields ( ExtraFieldUtils . parse ( extra ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e . getMessage ( ) ) ; } } protected void setExtra ( ) { super . setExtra ( ExtraFieldUtils . mergeLocalFileDataData ( getExtraFields ( ) ) ) ; } public byte [ ] getLocalFileDataExtra ( ) { byte [ ] extra = getExtra ( ) ; return extra != null ? extra : new byte [ 0 ] ; } public byte [ ] getCentralDirectoryExtra ( ) { return ExtraFieldUtils . mergeCentralDirectoryData ( getExtraFields ( ) ) ; } private Long compressedSize = null ; public void setComprSize ( long size ) { if ( haveSetCompressedSize ( ) ) { performSetCompressedSize ( this , size ) ; } else { compressedSize = new Long ( size ) ; } } public long getCompressedSize ( ) { if ( compressedSize != null ) { return compressedSize . longValue ( ) ; } return super . getCompressedSize ( ) ; } public String getName ( ) { return name == null ? super . getName ( ) : name ; } public boolean isDirectory ( ) { return getName ( ) . endsWith ( "/" ) ; } protected void setName ( String name ) { this . name = name ; } private static Method setCompressedSizeMethod = null ; private static Object lockReflection = new Object ( ) ; private static boolean triedToGetMethod = false ; private static boolean haveSetCompressedSize ( ) { checkSCS ( ) ; return setCompressedSizeMethod != null ; } private static void performSetCompressedSize ( ZipEntry ze , long size ) { Long [ ] s = { new Long ( size ) } ; try { setCompressedSizeMethod . invoke ( ze , s ) ; } catch ( InvocationTargetException ite ) { Throwable nested = ite . getTargetException ( ) ; throw new RuntimeException ( "Exception setting the compressed size " + "of " + ze + ": " + nested . getMessage ( ) ) ; } catch ( Throwable other ) { throw new RuntimeException ( "Exception setting the compressed size " + "of " + ze + ": " + other . getMessage ( ) ) ; } } private static void checkSCS ( ) { if ( ! triedToGetMethod ) { synchronized ( lockReflection ) { triedToGetMethod = true ; try { setCompressedSizeMethod = java . util . zip . ZipEntry . class . getMethod ( "setCompressedSize" , new Class [ ] { Long . TYPE } ) ; } catch ( NoSuchMethodException nse ) { } } } } } 	1	['31', '2', '0', '8', '77', '317', '5', '3', '22', '0.858333333', '615', '0.916666667', '0', '0.469387755', '0.14', '1', '1', '18.4516129', '5', '1.5161', '2']
package org . apache . tools . ant . util ; public class MergingMapper implements FileNameMapper { protected String [ ] mergedFile = null ; public void setFrom ( String from ) { } public void setTo ( String to ) { mergedFile = new String [ ] { to } ; } public String [ ] mapFileName ( String sourceFileName ) { return mergedFile ; } } 	0	['4', '1', '0', '4', '5', '0', '3', '1', '4', '0.333333333', '24', '1', '0', '0', '0.875', '0', '0', '4.75', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . HttpURLConnection ; import java . net . URL ; import java . net . URLConnection ; import java . util . Date ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; public class Get extends Task { private URL source ; private File dest ; private boolean verbose = false ; private boolean useTimestamp = false ; private boolean ignoreErrors = false ; private String uname = null ; private String pword = null ; public void execute ( ) throws BuildException { if ( source == null ) { throw new BuildException ( "src attribute is required" , getLocation ( ) ) ; } if ( dest == null ) { throw new BuildException ( "dest attribute is required" , getLocation ( ) ) ; } if ( dest . exists ( ) && dest . isDirectory ( ) ) { throw new BuildException ( "The specified destination is a directory" , getLocation ( ) ) ; } if ( dest . exists ( ) && ! dest . canWrite ( ) ) { throw new BuildException ( "Can't write to " + dest . getAbsolutePath ( ) , getLocation ( ) ) ; } try { log ( "Getting: " + source ) ; long timestamp = 0 ; boolean hasTimestamp = false ; if ( useTimestamp && dest . exists ( ) ) { timestamp = dest . lastModified ( ) ; if ( verbose ) { Date t = new Date ( timestamp ) ; log ( "local file date : " + t . toString ( ) ) ; } hasTimestamp = true ; } URLConnection connection = source . openConnection ( ) ; if ( useTimestamp && hasTimestamp ) { connection . setIfModifiedSince ( timestamp ) ; } if ( uname != null || pword != null ) { String up = uname + ":" + pword ; String encoding ; try { Object encoder = Class . forName ( "sun.misc.BASE64Encoder" ) . newInstance ( ) ; encoding = ( String ) encoder . getClass ( ) . getMethod ( "encode" , new Class [ ] { byte [ ] . class } ) . invoke ( encoder , new Object [ ] { up . getBytes ( ) } ) ; } catch ( Exception ex ) { Base64Converter encoder = new Base64Converter ( ) ; encoding = encoder . encode ( up . getBytes ( ) ) ; } connection . setRequestProperty ( "Authorization" , "Basic " + encoding ) ; } connection . connect ( ) ; if ( connection instanceof HttpURLConnection ) { HttpURLConnection httpConnection = ( HttpURLConnection ) connection ; if ( httpConnection . getResponseCode ( ) == HttpURLConnection . HTTP_NOT_MODIFIED ) { log ( "Not modified - so not downloaded" ) ; return ; } if ( httpConnection . getResponseCode ( ) == HttpURLConnection . HTTP_UNAUTHORIZED ) { String message = "HTTP Authorization failure" ; if ( ignoreErrors ) { log ( message , Project . MSG_WARN ) ; return ; } else { throw new BuildException ( message ) ; } } } InputStream is = null ; for ( int i = 0 ; i < 3 ; i ++ ) { try { is = connection . getInputStream ( ) ; break ; } catch ( IOException ex ) { log ( "Error opening connection " + ex ) ; } } if ( is == null ) { log ( "Can't get " + source + " to " + dest ) ; if ( ignoreErrors ) { return ; } throw new BuildException ( "Can't get " + source + " to " + dest , getLocation ( ) ) ; } FileOutputStream fos = new FileOutputStream ( dest ) ; boolean finished = false ; try { byte [ ] buffer = new byte [ 100 * 1024 ] ; int length ; int dots = 0 ; while ( ( length = is . read ( buffer ) ) >= 0 ) { fos . write ( buffer , 0 , length ) ; if ( verbose ) { System . out . print ( "." ) ; if ( dots ++ > 50 ) { System . out . flush ( ) ; dots = 0 ; } } } if ( verbose ) { System . out . println ( ) ; } finished = true ; } finally { if ( fos != null ) { fos . close ( ) ; } is . close ( ) ; if ( ! finished ) { dest . delete ( ) ; } } if ( useTimestamp ) { long remoteTimestamp = connection . getLastModified ( ) ; if ( verbose ) { Date t = new Date ( remoteTimestamp ) ; log ( "last modified = " + t . toString ( ) + ( ( remoteTimestamp == 0 ) ? " - using current time instead" : "" ) ) ; } if ( remoteTimestamp != 0 ) { FileUtils . newFileUtils ( ) . setFileLastModified ( dest , remoteTimestamp ) ; } } } catch ( IOException ioe ) { log ( "Error getting " + source + " to " + dest ) ; if ( ignoreErrors ) { return ; } throw new BuildException ( ioe , getLocation ( ) ) ; } } public void setSrc ( URL u ) { this . source = u ; } public void setDest ( File dest ) { this . dest = dest ; } public void setVerbose ( boolean v ) { verbose = v ; } public void setIgnoreErrors ( boolean v ) { ignoreErrors = v ; } public void setUseTimestamp ( boolean v ) { if ( ! JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { useTimestamp = v ; } } public void setUsername ( String u ) { this . uname = u ; } public void setPassword ( String p ) { this . pword = p ; } private static class Base64Converter { public final char [ ] alphabet = { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' , 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' , 'k' , 'l' , 'm' , 'n' , 'o' , 'p' , 'q' , 'r' , 's' , 't' , 'u' , 'v' , 'w' , 'x' , 'y' , 'z' , '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '+' , '/' } ; public String encode ( String s ) { return encode ( s . getBytes ( ) ) ; } public String encode ( byte [ ] octetString ) { int bits24 ; int bits6 ; char [ ] out = new char [ ( ( octetString . length - 1 ) / 3 + 1 ) * 4 ] ; int outIndex = 0 ; int i = 0 ; while ( ( i + 3 ) <= octetString . length ) { bits24 = ( octetString [ i ++ ] & 0xFF ) << 16 ; bits24 |= ( octetString [ i ++ ] & 0xFF ) << 8 ; bits6 = ( bits24 & 0x00FC0000 ) > > 18 ; out [ outIndex ++ ] = alphabet [ bits6 ] ; bits6 = ( bits24 & 0x0003F000 ) > > 12 ; out [ outIndex ++ ] = alphabet [ bits6 ] ; bits6 = ( bits24 & 0x00000FC0 ) > > 6 ; out [ outIndex ++ ] = alphabet [ bits6 ] ; bits6 = ( bits24 & 0x0000003F ) ; out [ outIndex ++ ] = alphabet [ bits6 ] ; } if ( octetString . length - i == 2 ) { bits24 = ( octetString [ i ] & 0xFF ) << 16 ; bits24 |= ( octetString [ i + 1 ] & 0xFF ) << 8 ; bits6 = ( bits24 & 0x00FC0000 ) > > 18 ; out [ outIndex ++ ] = alphabet [ bits6 ] ; bits6 = ( bits24 & 0x0003F000 ) > > 12 ; out [ outIndex ++ ] = alphabet [ bits6 ] ; bits6 = ( bits24 & 0x00000FC0 ) > > 6 ; out [ outIndex ++ ] = alphabet [ bits6 ] ; out [ outIndex ++ ] = '=' ; } else if ( octetString . length - i == 1 ) { bits24 = ( octetString [ i ] & 0xFF ) << 16 ; bits6 = ( bits24 & 0x00FC0000 ) > > 18 ; out [ outIndex ++ ] = alphabet [ bits6 ] ; bits6 = ( bits24 & 0x0003F000 ) > > 12 ; out [ outIndex ++ ] = alphabet [ bits6 ] ; out [ outIndex ++ ] = '=' ; out [ outIndex ++ ] = '=' ; } return new String ( out ) ; } } } 	1	['10', '3', '0', '7', '57', '19', '0', '7', '9', '0.833333333', '518', '0.875', '0', '0.804347826', '0.34', '2', '2', '50', '2', '1', '2']
package org . apache . tools . ant . types . selectors . modifiedselector ; import java . io . File ; public class HashvalueAlgorithm implements Algorithm { public boolean isValid ( ) { return true ; } public String getValue ( File file ) { try { if ( ! file . canRead ( ) ) { return null ; } java . io . FileInputStream fis = new java . io . FileInputStream ( file ) ; byte [ ] content = new byte [ fis . available ( ) ] ; fis . read ( content ) ; fis . close ( ) ; String s = new String ( content ) ; int hash = s . hashCode ( ) ; return Integer . toString ( hash ) ; } catch ( Exception e ) { return null ; } } public String toString ( ) { return "HashvalueAlgorithm" ; } } 	0	['4', '1', '0', '1', '13', '6', '0', '1', '4', '2', '45', '0', '0', '0', '0.625', '0', '0', '10.25', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . GZIPInputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . bzip2 . CBZip2InputStream ; import org . apache . tools . tar . TarEntry ; import org . apache . tools . tar . TarInputStream ; public class Untar extends Expand { private UntarCompressionMethod compression = new UntarCompressionMethod ( ) ; public void setCompression ( UntarCompressionMethod method ) { compression = method ; } public void setEncoding ( String encoding ) { throw new BuildException ( "The " + getTaskName ( ) + " task doesn't support the encoding" + " attribute" , getLocation ( ) ) ; } protected void expandFile ( FileUtils fileUtils , File srcF , File dir ) { TarInputStream tis = null ; try { log ( "Expanding: " + srcF + " into " + dir , Project . MSG_INFO ) ; tis = new TarInputStream ( compression . decompress ( srcF , new BufferedInputStream ( new FileInputStream ( srcF ) ) ) ) ; TarEntry te = null ; while ( ( te = tis . getNextEntry ( ) ) != null ) { extractFile ( fileUtils , srcF , dir , tis , te . getName ( ) , te . getModTime ( ) , te . isDirectory ( ) ) ; } log ( "expand complete" , Project . MSG_VERBOSE ) ; } catch ( IOException ioe ) { throw new BuildException ( "Error while expanding " + srcF . getPath ( ) , ioe , getLocation ( ) ) ; } finally { if ( tis != null ) { try { tis . close ( ) ; } catch ( IOException e ) { } } } } public static final class UntarCompressionMethod extends EnumeratedAttribute { private static final String NONE = "none" ; private static final String GZIP = "gzip" ; private static final String BZIP2 = "bzip2" ; public UntarCompressionMethod ( ) { super ( ) ; setValue ( NONE ) ; } public String [ ] getValues ( ) { return new String [ ] { NONE , GZIP , BZIP2 } ; } private InputStream decompress ( final File file , final InputStream istream ) throws IOException , BuildException { final String value = getValue ( ) ; if ( GZIP . equals ( value ) ) { return new GZIPInputStream ( istream ) ; } else { if ( BZIP2 . equals ( value ) ) { final char [ ] magic = new char [ ] { 'B' , 'Z' } ; for ( int i = 0 ; i < magic . length ; i ++ ) { if ( istream . read ( ) != magic [ i ] ) { throw new BuildException ( "Invalid bz2 file." + file . toString ( ) ) ; } } return new CBZip2InputStream ( istream ) ; } } return istream ; } } } 	1	['4', '4', '0', '8', '26', '0', '0', '8', '3', '0.333333333', '125', '1', '1', '0.944444444', '0.4', '2', '2', '30', '5', '1.75', '2']
package org . apache . tools . ant . taskdefs . email ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . PrintStream ; import org . apache . tools . ant . BuildException ; import sun . misc . UUEncoder ; class UUMailer extends PlainMailer { protected void attach ( File file , PrintStream out ) throws IOException { if ( ! file . exists ( ) || ! file . canRead ( ) ) { throw new BuildException ( "File \"" + file . getName ( ) + "\" does not exist or is not " + "readable." ) ; } FileInputStream finstr = new FileInputStream ( file ) ; try { BufferedInputStream in = new BufferedInputStream ( finstr ) ; UUEncoder encoder = new UUEncoder ( file . getName ( ) ) ; encoder . encode ( in , out ) ; } finally { finstr . close ( ) ; } } } 	0	['2', '3', '0', '4', '15', '1', '0', '4', '0', '2', '59', '0', '0', '0.952380952', '0.666666667', '1', '1', '28.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileInputStream ; import java . io . InputStreamReader ; import java . io . FileOutputStream ; import java . io . OutputStreamWriter ; import java . io . IOException ; import java . io . PrintWriter ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . EnumeratedAttribute ; public class ManifestTask extends Task { private Manifest nestedManifest = new Manifest ( ) ; private File manifestFile ; private Mode mode ; private String encoding ; public static class Mode extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "update" , "replace" } ; } } public ManifestTask ( ) { mode = new Mode ( ) ; mode . setValue ( "replace" ) ; } public void addConfiguredSection ( Manifest . Section section ) throws ManifestException { nestedManifest . addConfiguredSection ( section ) ; } public void addConfiguredAttribute ( Manifest . Attribute attribute ) throws ManifestException { nestedManifest . addConfiguredAttribute ( attribute ) ; } public void setFile ( File f ) { manifestFile = f ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public void setMode ( Mode m ) { mode = m ; } public void execute ( ) throws BuildException { if ( manifestFile == null ) { throw new BuildException ( "the file attribute is required" ) ; } Manifest toWrite = Manifest . getDefaultManifest ( ) ; Manifest current = null ; BuildException error = null ; if ( manifestFile . exists ( ) ) { FileInputStream fis = null ; InputStreamReader isr = null ; try { fis = new FileInputStream ( manifestFile ) ; if ( encoding == null ) { isr = new InputStreamReader ( fis , "UTF-8" ) ; } else { isr = new InputStreamReader ( fis , encoding ) ; } current = new Manifest ( isr ) ; } catch ( ManifestException m ) { error = new BuildException ( "Existing manifest " + manifestFile + " is invalid" , m , getLocation ( ) ) ; } catch ( IOException e ) { error = new BuildException ( "Failed to read " + manifestFile , e , getLocation ( ) ) ; } finally { if ( isr != null ) { try { isr . close ( ) ; } catch ( IOException e ) { } } } } try { if ( mode . getValue ( ) . equals ( "update" ) && manifestFile . exists ( ) ) { if ( current != null ) { toWrite . merge ( current ) ; } else if ( error != null ) { throw error ; } } toWrite . merge ( nestedManifest ) ; } catch ( ManifestException m ) { throw new BuildException ( "Manifest is invalid" , m , getLocation ( ) ) ; } if ( toWrite . equals ( current ) ) { log ( "Manifest has not changed, do not recreate" , Project . MSG_VERBOSE ) ; return ; } PrintWriter w = null ; try { FileOutputStream fos = new FileOutputStream ( manifestFile ) ; OutputStreamWriter osw = new OutputStreamWriter ( fos , "UTF-8" ) ; w = new PrintWriter ( osw ) ; toWrite . write ( w ) ; } catch ( IOException e ) { throw new BuildException ( "Failed to write " + manifestFile , e , getLocation ( ) ) ; } finally { if ( w != null ) { w . close ( ) ; } } } } 	1	['7', '3', '0', '9', '36', '1', '0', '9', '7', '0.708333333', '250', '1', '2', '0.860465116', '0.285714286', '2', '2', '34.14285714', '1', '0.8571', '1']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . Enumeration ; import java . util . StringTokenizer ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . PatternSet ; import org . apache . tools . ant . types . selectors . AndSelector ; import org . apache . tools . ant . types . selectors . ContainsRegexpSelector ; import org . apache . tools . ant . types . selectors . ContainsSelector ; import org . apache . tools . ant . types . selectors . DateSelector ; import org . apache . tools . ant . types . selectors . DependSelector ; import org . apache . tools . ant . types . selectors . DepthSelector ; import org . apache . tools . ant . types . selectors . DifferentSelector ; import org . apache . tools . ant . types . selectors . ExtendSelector ; import org . apache . tools . ant . types . selectors . FileSelector ; import org . apache . tools . ant . types . selectors . FilenameSelector ; import org . apache . tools . ant . types . selectors . MajoritySelector ; import org . apache . tools . ant . types . selectors . NoneSelector ; import org . apache . tools . ant . types . selectors . NotSelector ; import org . apache . tools . ant . types . selectors . OrSelector ; import org . apache . tools . ant . types . selectors . PresentSelector ; import org . apache . tools . ant . types . selectors . SelectSelector ; import org . apache . tools . ant . types . selectors . SelectorContainer ; import org . apache . tools . ant . types . selectors . SizeSelector ; import org . apache . tools . ant . types . selectors . TypeSelector ; import org . apache . tools . ant . types . selectors . modifiedselector . ModifiedSelector ; public abstract class MatchingTask extends Task implements SelectorContainer { protected FileSet fileset = new FileSet ( ) ; public void setProject ( Project project ) { super . setProject ( project ) ; fileset . setProject ( project ) ; } public PatternSet . NameEntry createInclude ( ) { return fileset . createInclude ( ) ; } public PatternSet . NameEntry createIncludesFile ( ) { return fileset . createIncludesFile ( ) ; } public PatternSet . NameEntry createExclude ( ) { return fileset . createExclude ( ) ; } public PatternSet . NameEntry createExcludesFile ( ) { return fileset . createExcludesFile ( ) ; } public PatternSet createPatternSet ( ) { return fileset . createPatternSet ( ) ; } public void setIncludes ( String includes ) { fileset . setIncludes ( includes ) ; } public void XsetItems ( String itemString ) { log ( "The items attribute is deprecated. " + "Please use the includes attribute." , Project . MSG_WARN ) ; if ( itemString == null || itemString . equals ( "*" ) || itemString . equals ( "." ) ) { createInclude ( ) . setName ( "**" ) ; } else { StringTokenizer tok = new StringTokenizer ( itemString , ", " ) ; while ( tok . hasMoreTokens ( ) ) { String pattern = tok . nextToken ( ) . trim ( ) ; if ( pattern . length ( ) > 0 ) { createInclude ( ) . setName ( pattern + "/**" ) ; } } } } public void setExcludes ( String excludes ) { fileset . setExcludes ( excludes ) ; } public void XsetIgnore ( String ignoreString ) { log ( "The ignore attribute is deprecated." + "Please use the excludes attribute." , Project . MSG_WARN ) ; if ( ignoreString != null && ignoreString . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( ignoreString , ", " , false ) ; while ( tok . hasMoreTokens ( ) ) { createExclude ( ) . setName ( "**/" + tok . nextToken ( ) . trim ( ) + "/**" ) ; } } } public void setDefaultexcludes ( boolean useDefaultExcludes ) { fileset . setDefaultexcludes ( useDefaultExcludes ) ; } protected DirectoryScanner getDirectoryScanner ( File baseDir ) { fileset . setDir ( baseDir ) ; return fileset . getDirectoryScanner ( getProject ( ) ) ; } public void setIncludesfile ( File includesfile ) { fileset . setIncludesfile ( includesfile ) ; } public void setExcludesfile ( File excludesfile ) { fileset . setExcludesfile ( excludesfile ) ; } public void setCaseSensitive ( boolean isCaseSensitive ) { fileset . setCaseSensitive ( isCaseSensitive ) ; } public void setFollowSymlinks ( boolean followSymlinks ) { fileset . setFollowSymlinks ( followSymlinks ) ; } public boolean hasSelectors ( ) { return fileset . hasSelectors ( ) ; } public int selectorCount ( ) { return fileset . selectorCount ( ) ; } public FileSelector [ ] getSelectors ( Project p ) { return fileset . getSelectors ( p ) ; } public Enumeration selectorElements ( ) { return fileset . selectorElements ( ) ; } public void appendSelector ( FileSelector selector ) { fileset . appendSelector ( selector ) ; } public void addSelector ( SelectSelector selector ) { fileset . addSelector ( selector ) ; } public void addAnd ( AndSelector selector ) { fileset . addAnd ( selector ) ; } public void addOr ( OrSelector selector ) { fileset . addOr ( selector ) ; } public void addNot ( NotSelector selector ) { fileset . addNot ( selector ) ; } public void addNone ( NoneSelector selector ) { fileset . addNone ( selector ) ; } public void addMajority ( MajoritySelector selector ) { fileset . addMajority ( selector ) ; } public void addDate ( DateSelector selector ) { fileset . addDate ( selector ) ; } public void addSize ( SizeSelector selector ) { fileset . addSize ( selector ) ; } public void addFilename ( FilenameSelector selector ) { fileset . addFilename ( selector ) ; } public void addCustom ( ExtendSelector selector ) { fileset . addCustom ( selector ) ; } public void addContains ( ContainsSelector selector ) { fileset . addContains ( selector ) ; } public void addPresent ( PresentSelector selector ) { fileset . addPresent ( selector ) ; } public void addDepth ( DepthSelector selector ) { fileset . addDepth ( selector ) ; } public void addDepend ( DependSelector selector ) { fileset . addDepend ( selector ) ; } public void addContainsRegexp ( ContainsRegexpSelector selector ) { fileset . addContainsRegexp ( selector ) ; } public void addDifferent ( DifferentSelector selector ) { fileset . addDifferent ( selector ) ; } public void addType ( TypeSelector selector ) { fileset . addType ( selector ) ; } public void addModified ( ModifiedSelector selector ) { fileset . addModified ( selector ) ; } public void add ( FileSelector selector ) { fileset . add ( selector ) ; } protected final FileSet getImplicitFileSet ( ) { return fileset ; } } 	0	['42', '3', '11', '39', '96', '0', '11', '28', '40', '0', '328', '1', '1', '0.474358974', '0.073412698', '2', '2', '6.785714286', '6', '1.1667', '0']
package org . apache . tools . tar ; import java . io . FilterOutputStream ; import java . io . OutputStream ; import java . io . IOException ; public class TarOutputStream extends FilterOutputStream { public static final int LONGFILE_ERROR = 0 ; public static final int LONGFILE_TRUNCATE = 1 ; public static final int LONGFILE_GNU = 2 ; protected boolean debug ; protected int currSize ; protected int currBytes ; protected byte [ ] oneBuf ; protected byte [ ] recordBuf ; protected int assemLen ; protected byte [ ] assemBuf ; protected TarBuffer buffer ; protected int longFileMode = LONGFILE_ERROR ; public TarOutputStream ( OutputStream os ) { this ( os , TarBuffer . DEFAULT_BLKSIZE , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarOutputStream ( OutputStream os , int blockSize ) { this ( os , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarOutputStream ( OutputStream os , int blockSize , int recordSize ) { super ( os ) ; this . buffer = new TarBuffer ( os , blockSize , recordSize ) ; this . debug = false ; this . assemLen = 0 ; this . assemBuf = new byte [ recordSize ] ; this . recordBuf = new byte [ recordSize ] ; this . oneBuf = new byte [ 1 ] ; } public void setLongFileMode ( int longFileMode ) { this . longFileMode = longFileMode ; } public void setDebug ( boolean debugF ) { this . debug = debugF ; } public void setBufferDebug ( boolean debug ) { this . buffer . setDebug ( debug ) ; } public void finish ( ) throws IOException { this . writeEOFRecord ( ) ; } public void close ( ) throws IOException { this . finish ( ) ; this . buffer . close ( ) ; } public int getRecordSize ( ) { return this . buffer . getRecordSize ( ) ; } public void putNextEntry ( TarEntry entry ) throws IOException { if ( entry . getName ( ) . length ( ) >= TarConstants . NAMELEN ) { if ( longFileMode == LONGFILE_GNU ) { TarEntry longLinkEntry = new TarEntry ( TarConstants . GNU_LONGLINK , TarConstants . LF_GNUTYPE_LONGNAME ) ; longLinkEntry . setSize ( entry . getName ( ) . length ( ) + 1 ) ; putNextEntry ( longLinkEntry ) ; write ( entry . getName ( ) . getBytes ( ) ) ; write ( 0 ) ; closeEntry ( ) ; } else if ( longFileMode != LONGFILE_TRUNCATE ) { throw new RuntimeException ( "file name '" + entry . getName ( ) + "' is too long ( > " + TarConstants . NAMELEN + " bytes)" ) ; } } entry . writeEntryHeader ( this . recordBuf ) ; this . buffer . writeRecord ( this . recordBuf ) ; this . currBytes = 0 ; if ( entry . isDirectory ( ) ) { this . currSize = 0 ; } else { this . currSize = ( int ) entry . getSize ( ) ; } } public void closeEntry ( ) throws IOException { if ( this . assemLen > 0 ) { for ( int i = this . assemLen ; i < this . assemBuf . length ; ++ i ) { this . assemBuf [ i ] = 0 ; } this . buffer . writeRecord ( this . assemBuf ) ; this . currBytes += this . assemLen ; this . assemLen = 0 ; } if ( this . currBytes < this . currSize ) { throw new IOException ( "entry closed at '" + this . currBytes + "' before the '" + this . currSize + "' bytes specified in the header were written" ) ; } } public void write ( int b ) throws IOException { this . oneBuf [ 0 ] = ( byte ) b ; this . write ( this . oneBuf , 0 , 1 ) ; } public void write ( byte [ ] wBuf ) throws IOException { this . write ( wBuf , 0 , wBuf . length ) ; } public void write ( byte [ ] wBuf , int wOffset , int numToWrite ) throws IOException { if ( ( this . currBytes + numToWrite ) > this . currSize ) { throw new IOException ( "request to write '" + numToWrite + "' bytes exceeds size in header of '" + this . currSize + "' bytes" ) ; } if ( this . assemLen > 0 ) { if ( ( this . assemLen + numToWrite ) >= this . recordBuf . length ) { int aLen = this . recordBuf . length - this . assemLen ; System . arraycopy ( this . assemBuf , 0 , this . recordBuf , 0 , this . assemLen ) ; System . arraycopy ( wBuf , wOffset , this . recordBuf , this . assemLen , aLen ) ; this . buffer . writeRecord ( this . recordBuf ) ; this . currBytes += this . recordBuf . length ; wOffset += aLen ; numToWrite -= aLen ; this . assemLen = 0 ; } else { System . arraycopy ( wBuf , wOffset , this . assemBuf , this . assemLen , numToWrite ) ; wOffset += numToWrite ; this . assemLen += numToWrite ; numToWrite -= numToWrite ; } } while ( numToWrite > 0 ) { if ( numToWrite < this . recordBuf . length ) { System . arraycopy ( wBuf , wOffset , this . assemBuf , this . assemLen , numToWrite ) ; this . assemLen += numToWrite ; break ; } this . buffer . writeRecord ( wBuf , wOffset ) ; int num = this . recordBuf . length ; this . currBytes += num ; numToWrite -= num ; wOffset += num ; } } private void writeEOFRecord ( ) throws IOException { for ( int i = 0 ; i < this . recordBuf . length ; ++ i ) { this . recordBuf [ i ] = 0 ; } this . buffer . writeRecord ( this . recordBuf ) ; } } 	1	['15', '3', '0', '3', '37', '41', '1', '2', '14', '0.696428571', '437', '0.75', '1', '0.454545455', '0.311111111', '1', '2', '27.33333333', '1', '0.8', '2']
package org . apache . tools . ant . types ; public class DTDLocation extends ResourceLocation { } 	0	['1', '2', '0', '1', '2', '0', '0', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . tools . zip ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . RandomAccessFile ; import java . io . UnsupportedEncodingException ; import java . util . Calendar ; import java . util . Date ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . zip . Inflater ; import java . util . zip . InflaterInputStream ; import java . util . zip . ZipException ; public class ZipFile { private Hashtable entries = new Hashtable ( ) ; private Hashtable nameMap = new Hashtable ( ) ; private Hashtable dataOffsets = new Hashtable ( ) ; private String encoding = null ; private RandomAccessFile archive ; public ZipFile ( File f ) throws IOException { this ( f , null ) ; } public ZipFile ( String name ) throws IOException { this ( new File ( name ) , null ) ; } public ZipFile ( String name , String encoding ) throws IOException { this ( new File ( name ) , encoding ) ; } public ZipFile ( File f , String encoding ) throws IOException { this . encoding = encoding ; archive = new RandomAccessFile ( f , "r" ) ; populateFromCentralDirectory ( ) ; resolveLocalFileHeaderData ( ) ; } public String getEncoding ( ) { return encoding ; } public void close ( ) throws IOException { archive . close ( ) ; } public Enumeration getEntries ( ) { return entries . keys ( ) ; } public ZipEntry getEntry ( String name ) { return ( ZipEntry ) nameMap . get ( name ) ; } public InputStream getInputStream ( ZipEntry ze ) throws IOException , ZipException { Long start = ( Long ) dataOffsets . get ( ze ) ; if ( start == null ) { return null ; } BoundedInputStream bis = new BoundedInputStream ( start . longValue ( ) , ze . getCompressedSize ( ) ) ; switch ( ze . getMethod ( ) ) { case ZipEntry . STORED : return bis ; case ZipEntry . DEFLATED : bis . addDummy ( ) ; return new InflaterInputStream ( bis , new Inflater ( true ) ) ; default : throw new ZipException ( "Found unsupported compression method " + ze . getMethod ( ) ) ; } } private static final int CFH_LEN = 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 4 + 4 ; private void populateFromCentralDirectory ( ) throws IOException { positionAtCentralDirectory ( ) ; byte [ ] cfh = new byte [ CFH_LEN ] ; byte [ ] signatureBytes = new byte [ 4 ] ; archive . readFully ( signatureBytes ) ; ZipLong sig = new ZipLong ( signatureBytes ) ; while ( sig . equals ( ZipOutputStream . CFH_SIG ) ) { archive . readFully ( cfh ) ; int off = 0 ; ZipEntry ze = new ZipEntry ( ) ; ZipShort versionMadeBy = new ZipShort ( cfh , off ) ; off += 2 ; ze . setPlatform ( ( versionMadeBy . getValue ( ) > > 8 ) & 0x0F ) ; off += 4 ; ze . setMethod ( ( new ZipShort ( cfh , off ) ) . getValue ( ) ) ; off += 2 ; ze . setTime ( fromDosTime ( new ZipLong ( cfh , off ) ) . getTime ( ) ) ; off += 4 ; ze . setCrc ( ( new ZipLong ( cfh , off ) ) . getValue ( ) ) ; off += 4 ; ze . setCompressedSize ( ( new ZipLong ( cfh , off ) ) . getValue ( ) ) ; off += 4 ; ze . setSize ( ( new ZipLong ( cfh , off ) ) . getValue ( ) ) ; off += 4 ; int fileNameLen = ( new ZipShort ( cfh , off ) ) . getValue ( ) ; off += 2 ; int extraLen = ( new ZipShort ( cfh , off ) ) . getValue ( ) ; off += 2 ; int commentLen = ( new ZipShort ( cfh , off ) ) . getValue ( ) ; off += 2 ; off += 2 ; ze . setInternalAttributes ( ( new ZipShort ( cfh , off ) ) . getValue ( ) ) ; off += 2 ; ze . setExternalAttributes ( ( new ZipLong ( cfh , off ) ) . getValue ( ) ) ; off += 4 ; entries . put ( ze , new Long ( ( new ZipLong ( cfh , off ) ) . getValue ( ) ) ) ; byte [ ] fileName = new byte [ fileNameLen ] ; archive . readFully ( fileName ) ; ze . setName ( getString ( fileName ) ) ; nameMap . put ( ze . getName ( ) , ze ) ; archive . skipBytes ( extraLen ) ; byte [ ] comment = new byte [ commentLen ] ; archive . readFully ( comment ) ; ze . setComment ( getString ( comment ) ) ; archive . readFully ( signatureBytes ) ; sig = new ZipLong ( signatureBytes ) ; } } private static final int MIN_EOCD_SIZE = 4 + 2 + + 2 + + 2 + + 2 + 4 + + + 4 + 2 ; private static final int CFD_LOCATOR_OFFSET = 4 + 2 + + 2 + + 2 + + 2 + 4 ; private void positionAtCentralDirectory ( ) throws IOException { long off = archive . length ( ) - MIN_EOCD_SIZE ; archive . seek ( off ) ; byte [ ] sig = ZipOutputStream . EOCD_SIG . getBytes ( ) ; int curr = archive . read ( ) ; boolean found = false ; while ( curr != - 1 ) { if ( curr == sig [ 0 ] ) { curr = archive . read ( ) ; if ( curr == sig [ 1 ] ) { curr = archive . read ( ) ; if ( curr == sig [ 2 ] ) { curr = archive . read ( ) ; if ( curr == sig [ 3 ] ) { found = true ; break ; } } } } archive . seek ( -- off ) ; curr = archive . read ( ) ; } if ( ! found ) { throw new ZipException ( "archive is not a ZIP archive" ) ; } archive . seek ( off + CFD_LOCATOR_OFFSET ) ; byte [ ] cfdOffset = new byte [ 4 ] ; archive . readFully ( cfdOffset ) ; archive . seek ( ( new ZipLong ( cfdOffset ) ) . getValue ( ) ) ; } private static final long LFH_OFFSET_FOR_FILENAME_LENGTH = 4 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 ; private void resolveLocalFileHeaderData ( ) throws IOException { Enumeration e = getEntries ( ) ; while ( e . hasMoreElements ( ) ) { ZipEntry ze = ( ZipEntry ) e . nextElement ( ) ; long offset = ( ( Long ) entries . get ( ze ) ) . longValue ( ) ; archive . seek ( offset + LFH_OFFSET_FOR_FILENAME_LENGTH ) ; byte [ ] b = new byte [ 2 ] ; archive . readFully ( b ) ; int fileNameLen = ( new ZipShort ( b ) ) . getValue ( ) ; archive . readFully ( b ) ; int extraFieldLen = ( new ZipShort ( b ) ) . getValue ( ) ; archive . skipBytes ( fileNameLen ) ; byte [ ] localExtraData = new byte [ extraFieldLen ] ; archive . readFully ( localExtraData ) ; ze . setExtra ( localExtraData ) ; dataOffsets . put ( ze , new Long ( offset + LFH_OFFSET_FOR_FILENAME_LENGTH + 2 + 2 + fileNameLen + extraFieldLen ) ) ; } } protected static Date fromDosTime ( ZipLong l ) { long dosTime = l . getValue ( ) ; Calendar cal = Calendar . getInstance ( ) ; cal . set ( Calendar . YEAR , ( int ) ( ( dosTime > > 25 ) & 0x7f ) + 1980 ) ; cal . set ( Calendar . MONTH , ( int ) ( ( dosTime > > 21 ) & 0x0f ) - 1 ) ; cal . set ( Calendar . DATE , ( int ) ( dosTime > > 16 ) & 0x1f ) ; cal . set ( Calendar . HOUR_OF_DAY , ( int ) ( dosTime > > 11 ) & 0x1f ) ; cal . set ( Calendar . MINUTE , ( int ) ( dosTime > > 5 ) & 0x3f ) ; cal . set ( Calendar . SECOND , ( int ) ( dosTime << 1 ) & 0x3e ) ; return cal . getTime ( ) ; } protected String getString ( byte [ ] bytes ) throws ZipException { if ( encoding == null ) { return new String ( bytes ) ; } else { try { return new String ( bytes , encoding ) ; } catch ( UnsupportedEncodingException uee ) { throw new ZipException ( uee . getMessage ( ) ) ; } } } private class BoundedInputStream extends InputStream { private long remaining ; private long loc ; private boolean addDummyByte = false ; BoundedInputStream ( long start , long remaining ) { this . remaining = remaining ; loc = start ; } public int read ( ) throws IOException { if ( remaining -- <= 0 ) { if ( addDummyByte ) { addDummyByte = false ; return 0 ; } return - 1 ; } synchronized ( archive ) { archive . seek ( loc ++ ) ; return archive . read ( ) ; } } public int read ( byte [ ] b , int off , int len ) throws IOException { if ( remaining <= 0 ) { if ( addDummyByte ) { addDummyByte = false ; b [ off ] = 0 ; return 1 ; } return - 1 ; } if ( len <= 0 ) { return 0 ; } if ( len > remaining ) { len = ( int ) remaining ; } int ret = - 1 ; synchronized ( archive ) { archive . seek ( loc ) ; ret = archive . read ( b , off , len ) ; } if ( ret > 0 ) { loc += ret ; remaining -= ret ; } return ret ; } void addDummy ( ) { addDummyByte = true ; } } } 	1	['15', '1', '0', '8', '71', '55', '4', '5', '9', '0.793650794', '616', '1', '0', '0', '0.219047619', '0', '0', '39.46666667', '3', '0.8667', '2']
package org . apache . tools . ant . taskdefs ; public class Typedef extends Definer { } 	0	['1', '6', '1', '3', '2', '0', '2', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . tools . ant . taskdefs ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . PrintStream ; import java . util . Hashtable ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . EnumeratedAttribute ; public class Recorder extends Task { private String filename = null ; private Boolean append = null ; private Boolean start = null ; private int loglevel = - 1 ; private boolean emacsMode = false ; private static Hashtable recorderEntries = new Hashtable ( ) ; public void setName ( String fname ) { filename = fname ; } public void setAction ( ActionChoices action ) { if ( action . getValue ( ) . equalsIgnoreCase ( "start" ) ) { start = Boolean . TRUE ; } else { start = Boolean . FALSE ; } } public void setAppend ( boolean append ) { this . append = new Boolean ( append ) ; } public void setEmacsMode ( boolean emacsMode ) { this . emacsMode = emacsMode ; } public void setLoglevel ( VerbosityLevelChoices level ) { String lev = level . getValue ( ) ; if ( lev . equalsIgnoreCase ( "error" ) ) { loglevel = Project . MSG_ERR ; } else if ( lev . equalsIgnoreCase ( "warn" ) ) { loglevel = Project . MSG_WARN ; } else if ( lev . equalsIgnoreCase ( "info" ) ) { loglevel = Project . MSG_INFO ; } else if ( lev . equalsIgnoreCase ( "verbose" ) ) { loglevel = Project . MSG_VERBOSE ; } else if ( lev . equalsIgnoreCase ( "debug" ) ) { loglevel = Project . MSG_DEBUG ; } } public void execute ( ) throws BuildException { if ( filename == null ) { throw new BuildException ( "No filename specified" ) ; } getProject ( ) . log ( "setting a recorder for name " + filename , Project . MSG_DEBUG ) ; RecorderEntry recorder = getRecorder ( filename , getProject ( ) ) ; recorder . setMessageOutputLevel ( loglevel ) ; recorder . setRecordState ( start ) ; recorder . setEmacsMode ( emacsMode ) ; } public static class ActionChoices extends EnumeratedAttribute { private static final String [ ] values = { "start" , "stop" } ; public String [ ] getValues ( ) { return values ; } } public static class VerbosityLevelChoices extends EnumeratedAttribute { private static final String [ ] values = { "error" , "warn" , "info" , "verbose" , "debug" } ; public String [ ] getValues ( ) { return values ; } } protected RecorderEntry getRecorder ( String name , Project proj ) throws BuildException { Object o = recorderEntries . get ( name ) ; RecorderEntry entry ; if ( o == null ) { try { entry = new RecorderEntry ( name ) ; PrintStream out = null ; if ( append == null ) { out = new PrintStream ( new FileOutputStream ( name ) ) ; } else { out = new PrintStream ( new FileOutputStream ( name , append . booleanValue ( ) ) ) ; } entry . setErrorPrintStream ( out ) ; entry . setOutputPrintStream ( out ) ; } catch ( IOException ioe ) { throw new BuildException ( "Problems creating a recorder entry" , ioe ) ; } proj . addBuildListener ( entry ) ; recorderEntries . put ( name , entry ) ; } else { entry = ( RecorderEntry ) o ; } return entry ; } } 	1	['9', '3', '0', '9', '34', '10', '0', '9', '7', '0.729166667', '214', '1', '0', '0.840909091', '0.3125', '1', '1', '22.11111111', '6', '1.4444', '1']
package org . apache . tools . ant . types . resolver ; import org . apache . xml . resolver . Catalog ; import org . apache . xml . resolver . CatalogEntry ; import org . apache . xml . resolver . helpers . PublicId ; public class ApacheCatalog extends Catalog { private ApacheCatalogResolver resolver = null ; protected Catalog newCatalog ( ) { ApacheCatalog cat = ( ApacheCatalog ) super . newCatalog ( ) ; cat . setResolver ( resolver ) ; return cat ; } public void setResolver ( ApacheCatalogResolver resolver ) { this . resolver = resolver ; } public void addEntry ( CatalogEntry entry ) { int type = entry . getEntryType ( ) ; if ( type == PUBLIC ) { String publicid = PublicId . normalize ( entry . getEntryArg ( 0 ) ) ; String systemid = normalizeURI ( entry . getEntryArg ( 1 ) ) ; if ( resolver == null ) { catalogManager . debug . message ( 1 , "Internal Error: null ApacheCatalogResolver" ) ; } else { resolver . addPublicEntry ( publicid , systemid , base ) ; } } else if ( type == URI ) { String uri = normalizeURI ( entry . getEntryArg ( 0 ) ) ; String altURI = normalizeURI ( entry . getEntryArg ( 1 ) ) ; if ( resolver == null ) { catalogManager . debug . message ( 1 , "Internal Error: null ApacheCatalogResolver" ) ; } else { resolver . addURIEntry ( uri , altURI , base ) ; } } super . addEntry ( entry ) ; } } 	0	['4', '2', '0', '6', '14', '0', '1', '6', '3', '0', '96', '1', '1', '0.916666667', '0.5', '1', '3', '22.75', '5', '1.75', '0']
package org . apache . tools . ant . taskdefs ; import java . lang . reflect . Method ; import java . util . Enumeration ; import java . util . Vector ; import java . util . List ; import java . util . ArrayList ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Location ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . util . StringUtils ; public class Parallel extends Task implements TaskContainer { public static class TaskList implements TaskContainer { private List tasks = new ArrayList ( ) ; public void addTask ( Task nestedTask ) throws BuildException { tasks . add ( nestedTask ) ; } } private Vector nestedTasks = new Vector ( ) ; private final Object semaphore = new Object ( ) ; private int numThreads = 0 ; private int numThreadsPerProcessor = 0 ; private long timeout ; private volatile boolean stillRunning ; private boolean timedOut ; private boolean failOnAny ; private TaskList daemonTasks ; private StringBuffer exceptionMessage ; private int numExceptions = 0 ; private Throwable firstException ; private Location firstLocation ; public void addDaemons ( TaskList daemonTasks ) { if ( this . daemonTasks != null ) { throw new BuildException ( "Only one daemon group is supported" ) ; } this . daemonTasks = daemonTasks ; } public void setPollInterval ( int pollInterval ) { } public void setFailOnAny ( boolean failOnAny ) { this . failOnAny = failOnAny ; } public void addTask ( Task nestedTask ) { nestedTasks . addElement ( nestedTask ) ; } public void setThreadsPerProcessor ( int numThreadsPerProcessor ) { this . numThreadsPerProcessor = numThreadsPerProcessor ; } public void setThreadCount ( int numThreads ) { this . numThreads = numThreads ; } public void setTimeout ( long timeout ) { this . timeout = timeout ; } public void execute ( ) throws BuildException { updateThreadCounts ( ) ; if ( numThreads == 0 ) { numThreads = nestedTasks . size ( ) ; } spinThreads ( ) ; } private void updateThreadCounts ( ) { if ( numThreadsPerProcessor != 0 ) { int numProcessors = getNumProcessors ( ) ; if ( numProcessors != 0 ) { numThreads = numProcessors * numThreadsPerProcessor ; } } } private void processExceptions ( TaskRunnable [ ] runnables ) { if ( runnables == null ) { return ; } for ( int i = 0 ; i < runnables . length ; ++ i ) { Throwable t = runnables [ i ] . getException ( ) ; if ( t != null ) { numExceptions ++ ; if ( firstException == null ) { firstException = t ; } if ( t instanceof BuildException && firstLocation == Location . UNKNOWN_LOCATION ) { firstLocation = ( ( BuildException ) t ) . getLocation ( ) ; } exceptionMessage . append ( StringUtils . LINE_SEP ) ; exceptionMessage . append ( t . getMessage ( ) ) ; } } } private void spinThreads ( ) throws BuildException { final int numTasks = nestedTasks . size ( ) ; TaskRunnable [ ] runnables = new TaskRunnable [ numTasks ] ; stillRunning = true ; timedOut = false ; int threadNumber = 0 ; for ( Enumeration e = nestedTasks . elements ( ) ; e . hasMoreElements ( ) ; threadNumber ++ ) { Task nestedTask = ( Task ) e . nextElement ( ) ; runnables [ threadNumber ] = new TaskRunnable ( nestedTask ) ; } final int maxRunning = numTasks < numThreads ? numTasks : numThreads ; TaskRunnable [ ] running = new TaskRunnable [ maxRunning ] ; threadNumber = 0 ; ThreadGroup group = new ThreadGroup ( "parallel" ) ; TaskRunnable [ ] daemons = null ; if ( daemonTasks != null && daemonTasks . tasks . size ( ) != 0 ) { daemons = new TaskRunnable [ daemonTasks . tasks . size ( ) ] ; } synchronized ( semaphore ) { if ( daemons != null ) { for ( int i = 0 ; i < daemons . length ; ++ i ) { daemons [ i ] = new TaskRunnable ( ( Task ) daemonTasks . tasks . get ( i ) ) ; Thread daemonThread = new Thread ( group , daemons [ i ] ) ; daemonThread . setDaemon ( true ) ; daemonThread . start ( ) ; } } for ( int i = 0 ; i < maxRunning ; ++ i ) { running [ i ] = runnables [ threadNumber ++ ] ; Thread thread = new Thread ( group , running [ i ] ) ; thread . start ( ) ; } if ( timeout != 0 ) { Thread timeoutThread = new Thread ( ) { public synchronized void run ( ) { try { wait ( timeout ) ; synchronized ( semaphore ) { stillRunning = false ; timedOut = true ; semaphore . notifyAll ( ) ; } } catch ( InterruptedException e ) { } } } ; timeoutThread . start ( ) ; } outer : while ( threadNumber < numTasks && stillRunning ) { for ( int i = 0 ; i < maxRunning ; i ++ ) { if ( running [ i ] == null || running [ i ] . finished ) { running [ i ] = runnables [ threadNumber ++ ] ; Thread thread = new Thread ( group , running [ i ] ) ; thread . start ( ) ; continue outer ; } } try { semaphore . wait ( ) ; } catch ( InterruptedException ie ) { } } outer2 : while ( stillRunning ) { for ( int i = 0 ; i < maxRunning ; ++ i ) { if ( running [ i ] != null && ! running [ i ] . finished ) { try { semaphore . wait ( ) ; } catch ( InterruptedException ie ) { } continue outer2 ; } } stillRunning = false ; } } if ( timedOut ) { throw new BuildException ( "Parallel execution timed out" ) ; } exceptionMessage = new StringBuffer ( ) ; numExceptions = 0 ; firstException = null ; firstLocation = Location . UNKNOWN_LOCATION ; processExceptions ( daemons ) ; processExceptions ( runnables ) ; if ( numExceptions == 1 ) { if ( firstException instanceof BuildException ) { throw ( BuildException ) firstException ; } else { throw new BuildException ( firstException ) ; } } else if ( numExceptions > 1 ) { throw new BuildException ( exceptionMessage . toString ( ) , firstLocation ) ; } } private int getNumProcessors ( ) { try { Class [ ] paramTypes = { } ; Method availableProcessors = Runtime . class . getMethod ( "availableProcessors" , paramTypes ) ; Object [ ] args = { } ; Integer ret = ( Integer ) availableProcessors . invoke ( Runtime . getRuntime ( ) , args ) ; return ret . intValue ( ) ; } catch ( Exception e ) { return 0 ; } } private class TaskRunnable implements Runnable { private Throwable exception ; private Task task ; boolean finished ; TaskRunnable ( Task task ) { this . task = task ; } public void run ( ) { try { task . perform ( ) ; } catch ( Throwable t ) { exception = t ; } finally { synchronized ( semaphore ) { finished = true ; if ( failOnAny ) { stillRunning = false ; } semaphore . notifyAll ( ) ; } } } public Throwable getException ( ) { return exception ; } } } 	1	['19', '3', '0', '8', '52', '119', '2', '8', '9', '0.869047619', '523', '0.928571429', '2', '0.672727273', '0.169590643', '0', '0', '25.78947368', '7', '1.4737', '1']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . InputStream ; import java . io . StringReader ; public class StringInputStream extends InputStream { private StringReader in ; private String encoding ; private byte [ ] slack ; private int begin ; public StringInputStream ( String source ) { in = new StringReader ( source ) ; } public StringInputStream ( String source , String encoding ) { in = new StringReader ( source ) ; this . encoding = encoding ; } public synchronized int read ( ) throws IOException { if ( in == null ) { throw new IOException ( "Stream Closed" ) ; } byte result ; if ( slack != null && begin < slack . length ) { result = slack [ begin ] ; if ( ++ begin == slack . length ) { slack = null ; } } else { byte [ ] buf = new byte [ 1 ] ; if ( read ( buf , 0 , 1 ) <= 0 ) { return - 1 ; } result = buf [ 0 ] ; } if ( result < 0 ) { return 256 + result ; } else { return result ; } } public synchronized int read ( byte [ ] b , int off , int len ) throws IOException { if ( in == null ) { throw new IOException ( "Stream Closed" ) ; } while ( slack == null ) { char [ ] buf = new char [ len ] ; int n = in . read ( buf ) ; if ( n == - 1 ) { return - 1 ; } if ( n > 0 ) { String s = new String ( buf , 0 , n ) ; if ( encoding == null ) { slack = s . getBytes ( ) ; } else { slack = s . getBytes ( encoding ) ; } begin = 0 ; } } if ( len > slack . length - begin ) { len = slack . length - begin ; } System . arraycopy ( slack , begin , b , off , len ) ; if ( ( begin += len ) >= slack . length ) { slack = null ; } return len ; } public synchronized void mark ( final int limit ) { try { in . mark ( limit ) ; } catch ( IOException ioe ) { throw new RuntimeException ( ioe . getMessage ( ) ) ; } } public synchronized int available ( ) throws IOException { if ( in == null ) { throw new IOException ( "Stream Closed" ) ; } if ( slack != null ) { return slack . length - begin ; } if ( in . ready ( ) ) { return 1 ; } else { return 0 ; } } public boolean markSupported ( ) { return false ; } public synchronized void reset ( ) throws IOException { if ( in == null ) { throw new IOException ( "Stream Closed" ) ; } slack = null ; in . reset ( ) ; } public synchronized void close ( ) throws IOException { in . close ( ) ; slack = null ; in = null ; } } 	0	['9', '2', '0', '0', '23', '0', '0', '0', '9', '0.53125', '250', '1', '0', '0.5625', '0.388888889', '1', '2', '26.33333333', '1', '0.7778', '0']
package org . apache . tools . ant . types ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; public class Environment { protected Vector variables ; public static class Variable { private String key , value ; public Variable ( ) { super ( ) ; } public void setKey ( String key ) { this . key = key ; } public void setValue ( String value ) { this . value = value ; } public String getKey ( ) { return this . key ; } public String getValue ( ) { return this . value ; } public void setPath ( Path path ) { this . value = path . toString ( ) ; } public void setFile ( java . io . File file ) { this . value = file . getAbsolutePath ( ) ; } public String getContent ( ) throws BuildException { if ( key == null || value == null ) { throw new BuildException ( "key and value must be specified " + "for environment variables." ) ; } StringBuffer sb = new StringBuffer ( key . trim ( ) ) ; sb . append ( "=" ) . append ( value . trim ( ) ) ; return sb . toString ( ) ; } } public Environment ( ) { variables = new Vector ( ) ; } public void addVariable ( Variable var ) { variables . addElement ( var ) ; } public String [ ] getVariables ( ) throws BuildException { if ( variables . size ( ) == 0 ) { return null ; } String [ ] result = new String [ variables . size ( ) ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = ( ( Variable ) variables . elementAt ( i ) ) . getContent ( ) ; } return result ; } } 	1	['3', '1', '1', '7', '9', '0', '5', '2', '3', '0', '47', '1', '0', '0', '0.666666667', '0', '0', '14.33333333', '1', '0.6667', '1']
package org . apache . tools . ant . taskdefs . cvslib ; import java . io . PrintWriter ; import java . text . SimpleDateFormat ; import java . util . Enumeration ; import java . util . TimeZone ; class ChangeLogWriter { private static final SimpleDateFormat c_outputDate = new SimpleDateFormat ( "yyyy-MM-dd" ) ; private static final SimpleDateFormat c_outputTime = new SimpleDateFormat ( "HH:mm" ) ; static { TimeZone utc = TimeZone . getTimeZone ( "UTC" ) ; c_outputDate . setTimeZone ( utc ) ; c_outputTime . setTimeZone ( utc ) ; } public void printChangeLog ( final PrintWriter output , final CVSEntry [ ] entries ) { output . println ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" ) ; output . println ( "<changelog>" ) ; for ( int i = 0 ; i < entries . length ; i ++ ) { final CVSEntry entry = entries [ i ] ; printEntry ( output , entry ) ; } output . println ( "</changelog>" ) ; output . flush ( ) ; output . close ( ) ; } private void printEntry ( final PrintWriter output , final CVSEntry entry ) { output . println ( "\t<entry>" ) ; output . println ( "\t\t<date>" + c_outputDate . format ( entry . getDate ( ) ) + "</date>" ) ; output . println ( "\t\t<time>" + c_outputTime . format ( entry . getDate ( ) ) + "</time>" ) ; output . println ( "\t\t<author><![CDATA[" + entry . getAuthor ( ) + "]]></author>" ) ; final Enumeration enumeration = entry . getFiles ( ) . elements ( ) ; while ( enumeration . hasMoreElements ( ) ) { final RCSFile file = ( RCSFile ) enumeration . nextElement ( ) ; output . println ( "\t\t<file>" ) ; output . println ( "\t\t\t<name>" + file . getName ( ) + "</name>" ) ; output . println ( "\t\t\t<revision>" + file . getRevision ( ) + "</revision>" ) ; final String previousRevision = file . getPreviousRevision ( ) ; if ( previousRevision != null ) { output . println ( "\t\t\t<prevrevision>" + previousRevision + "</prevrevision>" ) ; } output . println ( "\t\t</file>" ) ; } output . println ( "\t\t<msg><![CDATA[" + entry . getComment ( ) + "]]></msg>" ) ; output . println ( "\t</entry>" ) ; } } 	0	['4', '1', '0', '3', '25', '4', '1', '2', '1', '0.333333333', '183', '1', '0', '0', '0.583333333', '0', '0', '44.25', '3', '1.25', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . Date ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . FileList ; import org . apache . tools . ant . types . FileSet ; public class DependSet extends MatchingTask { private Vector sourceFileSets = new Vector ( ) ; private Vector sourceFileLists = new Vector ( ) ; private Vector targetFileSets = new Vector ( ) ; private Vector targetFileLists = new Vector ( ) ; public DependSet ( ) { } public void addSrcfileset ( FileSet fs ) { sourceFileSets . addElement ( fs ) ; } public void addSrcfilelist ( FileList fl ) { sourceFileLists . addElement ( fl ) ; } public void addTargetfileset ( FileSet fs ) { targetFileSets . addElement ( fs ) ; } public void addTargetfilelist ( FileList fl ) { targetFileLists . addElement ( fl ) ; } public void execute ( ) throws BuildException { if ( ( sourceFileSets . size ( ) == 0 ) && ( sourceFileLists . size ( ) == 0 ) ) { throw new BuildException ( "At least one <srcfileset> or <srcfilelist>" + " element must be set" ) ; } if ( ( targetFileSets . size ( ) == 0 ) && ( targetFileLists . size ( ) == 0 ) ) { throw new BuildException ( "At least one <targetfileset> or" + " <targetfilelist> element must be set" ) ; } long now = ( new Date ( ) ) . getTime ( ) ; if ( Os . isFamily ( "windows" ) ) { now += 2000 ; } Vector allTargets = new Vector ( ) ; long oldestTargetTime = 0 ; File oldestTarget = null ; Enumeration enumTargetSets = targetFileSets . elements ( ) ; while ( enumTargetSets . hasMoreElements ( ) ) { FileSet targetFS = ( FileSet ) enumTargetSets . nextElement ( ) ; if ( ! targetFS . getDir ( getProject ( ) ) . exists ( ) ) { continue ; } DirectoryScanner targetDS = targetFS . getDirectoryScanner ( getProject ( ) ) ; String [ ] targetFiles = targetDS . getIncludedFiles ( ) ; for ( int i = 0 ; i < targetFiles . length ; i ++ ) { File dest = new File ( targetFS . getDir ( getProject ( ) ) , targetFiles [ i ] ) ; allTargets . addElement ( dest ) ; if ( dest . lastModified ( ) > now ) { log ( "Warning: " + targetFiles [ i ] + " modified in the future." , Project . MSG_WARN ) ; } if ( oldestTarget == null || dest . lastModified ( ) < oldestTargetTime ) { oldestTargetTime = dest . lastModified ( ) ; oldestTarget = dest ; } } } boolean upToDate = true ; Enumeration enumTargetLists = targetFileLists . elements ( ) ; while ( enumTargetLists . hasMoreElements ( ) ) { FileList targetFL = ( FileList ) enumTargetLists . nextElement ( ) ; String [ ] targetFiles = targetFL . getFiles ( getProject ( ) ) ; for ( int i = 0 ; i < targetFiles . length ; i ++ ) { File dest = new File ( targetFL . getDir ( getProject ( ) ) , targetFiles [ i ] ) ; if ( ! dest . exists ( ) ) { log ( targetFiles [ i ] + " does not exist." , Project . MSG_VERBOSE ) ; upToDate = false ; continue ; } else { allTargets . addElement ( dest ) ; } if ( dest . lastModified ( ) > now ) { log ( "Warning: " + targetFiles [ i ] + " modified in the future." , Project . MSG_WARN ) ; } if ( oldestTarget == null || dest . lastModified ( ) < oldestTargetTime ) { oldestTargetTime = dest . lastModified ( ) ; oldestTarget = dest ; } } } if ( oldestTarget != null ) { log ( oldestTarget + " is oldest target file" , Project . MSG_VERBOSE ) ; } else { upToDate = false ; } if ( upToDate ) { Enumeration enumSourceLists = sourceFileLists . elements ( ) ; while ( upToDate && enumSourceLists . hasMoreElements ( ) ) { FileList sourceFL = ( FileList ) enumSourceLists . nextElement ( ) ; String [ ] sourceFiles = sourceFL . getFiles ( getProject ( ) ) ; for ( int i = 0 ; upToDate && i < sourceFiles . length ; i ++ ) { File src = new File ( sourceFL . getDir ( getProject ( ) ) , sourceFiles [ i ] ) ; if ( src . lastModified ( ) > now ) { log ( "Warning: " + sourceFiles [ i ] + " modified in the future." , Project . MSG_WARN ) ; } if ( ! src . exists ( ) ) { log ( sourceFiles [ i ] + " does not exist." , Project . MSG_VERBOSE ) ; upToDate = false ; break ; } if ( src . lastModified ( ) > oldestTargetTime ) { upToDate = false ; log ( oldestTarget + " is out of date with respect to " + sourceFiles [ i ] , Project . MSG_VERBOSE ) ; } } } } if ( upToDate ) { Enumeration enumSourceSets = sourceFileSets . elements ( ) ; while ( upToDate && enumSourceSets . hasMoreElements ( ) ) { FileSet sourceFS = ( FileSet ) enumSourceSets . nextElement ( ) ; DirectoryScanner sourceDS = sourceFS . getDirectoryScanner ( getProject ( ) ) ; String [ ] sourceFiles = sourceDS . getIncludedFiles ( ) ; for ( int i = 0 ; upToDate && i < sourceFiles . length ; i ++ ) { File src = new File ( sourceFS . getDir ( getProject ( ) ) , sourceFiles [ i ] ) ; if ( src . lastModified ( ) > now ) { log ( "Warning: " + sourceFiles [ i ] + " modified in the future." , Project . MSG_WARN ) ; } if ( src . lastModified ( ) > oldestTargetTime ) { upToDate = false ; log ( oldestTarget + " is out of date with respect to " + sourceFiles [ i ] , Project . MSG_VERBOSE ) ; } } } } if ( ! upToDate ) { log ( "Deleting all target files. " , Project . MSG_VERBOSE ) ; for ( Enumeration e = allTargets . elements ( ) ; e . hasMoreElements ( ) ; ) { File fileToRemove = ( File ) e . nextElement ( ) ; log ( "Deleting file " + fileToRemove . getAbsolutePath ( ) , Project . MSG_VERBOSE ) ; fileToRemove . delete ( ) ; } } } } 	1	['6', '4', '0', '10', '33', '0', '0', '10', '6', '0.6', '511', '1', '0', '0.939759036', '0.555555556', '1', '1', '83.5', '1', '0.8333', '1']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . Properties ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; public class BuildNumber extends Task { private static final String DEFAULT_PROPERTY_NAME = "build.number" ; private static final String DEFAULT_FILENAME = DEFAULT_PROPERTY_NAME ; private File myFile ; public void setFile ( final File file ) { myFile = file ; } public void execute ( ) throws BuildException { File savedFile = myFile ; validate ( ) ; final Properties properties = loadProperties ( ) ; final int buildNumber = getBuildNumber ( properties ) ; properties . put ( DEFAULT_PROPERTY_NAME , String . valueOf ( buildNumber + 1 ) ) ; FileOutputStream output = null ; try { output = new FileOutputStream ( myFile ) ; final String header = "Build Number for ANT. Do not edit!" ; properties . store ( output , header ) ; } catch ( final IOException ioe ) { final String message = "Error while writing " + myFile ; throw new BuildException ( message , ioe ) ; } finally { if ( null != output ) { try { output . close ( ) ; } catch ( final IOException ioe ) { getProject ( ) . log ( "error closing output stream " + ioe , Project . MSG_ERR ) ; } } myFile = savedFile ; } getProject ( ) . setNewProperty ( DEFAULT_PROPERTY_NAME , String . valueOf ( buildNumber ) ) ; } private int getBuildNumber ( final Properties properties ) throws BuildException { final String buildNumber = properties . getProperty ( DEFAULT_PROPERTY_NAME , "0" ) . trim ( ) ; try { return Integer . parseInt ( buildNumber ) ; } catch ( final NumberFormatException nfe ) { final String message = myFile + " contains a non integer build number: " + buildNumber ; throw new BuildException ( message , nfe ) ; } } private Properties loadProperties ( ) throws BuildException { FileInputStream input = null ; try { final Properties properties = new Properties ( ) ; input = new FileInputStream ( myFile ) ; properties . load ( input ) ; return properties ; } catch ( final IOException ioe ) { throw new BuildException ( ioe ) ; } finally { if ( null != input ) { try { input . close ( ) ; } catch ( final IOException ioe ) { getProject ( ) . log ( "error closing input stream " + ioe , Project . MSG_ERR ) ; } } } } private void validate ( ) throws BuildException { if ( null == myFile ) { myFile = getProject ( ) . resolveFile ( DEFAULT_FILENAME ) ; } if ( ! myFile . exists ( ) ) { try { FileUtils . newFileUtils ( ) . createNewFile ( myFile ) ; } catch ( final IOException ioe ) { final String message = myFile + " doesn't exist and new file can't be created." ; throw new BuildException ( message , ioe ) ; } } if ( ! myFile . canRead ( ) ) { final String message = "Unable to read from " + myFile + "." ; throw new BuildException ( message ) ; } if ( ! myFile . canWrite ( ) ) { final String message = "Unable to write to " + myFile + "." ; throw new BuildException ( message ) ; } } } 	0	['6', '3', '0', '5', '35', '0', '0', '5', '3', '0.866666667', '300', '1', '0', '0.880952381', '0.444444444', '1', '1', '48.5', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . StringUtils ; public class Available extends Task implements Condition { private String property ; private String classname ; private String file ; private Path filepath ; private String resource ; private FileDir type ; private Path classpath ; private AntClassLoader loader ; private String value = "true" ; private boolean isTask = false ; private boolean ignoreSystemclasses = false ; public void setClasspath ( Path classpath ) { createClasspath ( ) . append ( classpath ) ; } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setFilepath ( Path filepath ) { createFilepath ( ) . append ( filepath ) ; } public Path createFilepath ( ) { if ( this . filepath == null ) { this . filepath = new Path ( getProject ( ) ) ; } return this . filepath . createPath ( ) ; } public void setProperty ( String property ) { this . property = property ; } public void setValue ( String value ) { this . value = value ; } public void setClassname ( String classname ) { if ( ! "" . equals ( classname ) ) { this . classname = classname ; } } public void setFile ( File file ) { this . file = FileUtils . newFileUtils ( ) . removeLeadingPath ( getProject ( ) . getBaseDir ( ) , file ) ; } public void setResource ( String resource ) { this . resource = resource ; } public void setType ( String type ) { log ( "DEPRECATED - The setType(String) method has been deprecated." + " Use setType(Available.FileDir) instead." ) ; this . type = new FileDir ( ) ; this . type . setValue ( type ) ; } public void setType ( FileDir type ) { this . type = type ; } public void setIgnoresystemclasses ( boolean ignore ) { this . ignoreSystemclasses = ignore ; } public void execute ( ) throws BuildException { if ( property == null ) { throw new BuildException ( "property attribute is required" , getLocation ( ) ) ; } isTask = true ; try { if ( eval ( ) ) { String oldvalue = getProject ( ) . getProperty ( property ) ; if ( null != oldvalue && ! oldvalue . equals ( value ) ) { log ( "DEPRECATED - <available> used to override an existing" + " property." + StringUtils . LINE_SEP + "  Build file should not reuse the same property" + " name for different values." ) ; } getProject ( ) . setProperty ( property , value ) ; } } finally { isTask = false ; } } public boolean eval ( ) throws BuildException { if ( classname == null && file == null && resource == null ) { throw new BuildException ( "At least one of (classname|file|" + "resource) is required" , getLocation ( ) ) ; } if ( type != null ) { if ( file == null ) { throw new BuildException ( "The type attribute is only valid " + "when specifying the file " + "attribute." , getLocation ( ) ) ; } } if ( classpath != null ) { classpath . setProject ( getProject ( ) ) ; this . loader = getProject ( ) . createClassLoader ( classpath ) ; } String appendix = "" ; if ( isTask ) { appendix = " to set property " + property ; } else { setTaskName ( "available" ) ; } if ( ( classname != null ) && ! checkClass ( classname ) ) { log ( "Unable to load class " + classname + appendix , Project . MSG_VERBOSE ) ; return false ; } if ( ( file != null ) && ! checkFile ( ) ) { if ( type != null ) { log ( "Unable to find " + type + " " + file + appendix , Project . MSG_VERBOSE ) ; } else { log ( "Unable to find " + file + appendix , Project . MSG_VERBOSE ) ; } return false ; } if ( ( resource != null ) && ! checkResource ( resource ) ) { log ( "Unable to load resource " + resource + appendix , Project . MSG_VERBOSE ) ; return false ; } if ( loader != null ) { loader . cleanup ( ) ; loader = null ; } if ( ! isTask ) { setTaskName ( null ) ; } return true ; } private boolean checkFile ( ) { if ( filepath == null ) { return checkFile ( getProject ( ) . resolveFile ( file ) , file ) ; } else { String [ ] paths = filepath . list ( ) ; for ( int i = 0 ; i < paths . length ; ++ i ) { log ( "Searching " + paths [ i ] , Project . MSG_DEBUG ) ; File path = new File ( paths [ i ] ) ; if ( path . exists ( ) && file . equals ( paths [ i ] ) ) { if ( type == null ) { log ( "Found: " + path , Project . MSG_VERBOSE ) ; return true ; } else if ( type . isDir ( ) && path . isDirectory ( ) ) { log ( "Found directory: " + path , Project . MSG_VERBOSE ) ; return true ; } else if ( type . isFile ( ) && path . isFile ( ) ) { log ( "Found file: " + path , Project . MSG_VERBOSE ) ; return true ; } return false ; } FileUtils fileUtils = FileUtils . newFileUtils ( ) ; File parent = fileUtils . getParentFile ( path ) ; if ( parent != null && parent . exists ( ) && file . equals ( parent . getAbsolutePath ( ) ) ) { if ( type == null ) { log ( "Found: " + parent , Project . MSG_VERBOSE ) ; return true ; } else if ( type . isDir ( ) ) { log ( "Found directory: " + parent , Project . MSG_VERBOSE ) ; return true ; } return false ; } if ( path . exists ( ) && path . isDirectory ( ) ) { if ( checkFile ( new File ( path , file ) , file + " in " + path ) ) { return true ; } } if ( parent != null && parent . exists ( ) ) { if ( checkFile ( new File ( parent , file ) , file + " in " + parent ) ) { return true ; } } if ( parent != null ) { File grandParent = fileUtils . getParentFile ( parent ) ; if ( grandParent != null && grandParent . exists ( ) ) { if ( checkFile ( new File ( grandParent , file ) , file + " in " + grandParent ) ) { return true ; } } } } } return false ; } private boolean checkFile ( File f , String text ) { if ( type != null ) { if ( type . isDir ( ) ) { if ( f . isDirectory ( ) ) { log ( "Found directory: " + text , Project . MSG_VERBOSE ) ; } return f . isDirectory ( ) ; } else if ( type . isFile ( ) ) { if ( f . isFile ( ) ) { log ( "Found file: " + text , Project . MSG_VERBOSE ) ; } return f . isFile ( ) ; } } if ( f . exists ( ) ) { log ( "Found: " + text , Project . MSG_VERBOSE ) ; } return f . exists ( ) ; } private boolean checkResource ( String resource ) { if ( loader != null ) { return ( loader . getResourceAsStream ( resource ) != null ) ; } else { ClassLoader cL = this . getClass ( ) . getClassLoader ( ) ; if ( cL != null ) { return ( cL . getResourceAsStream ( resource ) != null ) ; } else { return ( ClassLoader . getSystemResourceAsStream ( resource ) != null ) ; } } } private boolean checkClass ( String classname ) { try { Class requiredClass = null ; if ( ignoreSystemclasses ) { loader = getProject ( ) . createClassLoader ( classpath ) ; loader . setParentFirst ( false ) ; loader . addJavaLibraries ( ) ; if ( loader != null ) { try { requiredClass = loader . findClass ( classname ) ; } catch ( SecurityException se ) { return true ; } } else { return false ; } } else if ( loader != null ) { requiredClass = loader . loadClass ( classname ) ; } else { ClassLoader l = this . getClass ( ) . getClassLoader ( ) ; if ( l != null ) { requiredClass = Class . forName ( classname , true , l ) ; } else { requiredClass = Class . forName ( classname ) ; } } return true ; } catch ( ClassNotFoundException e ) { log ( "class \"" + classname + "\" was not found" , Project . MSG_DEBUG ) ; return false ; } catch ( NoClassDefFoundError e ) { log ( "Could not load dependent class \"" + e . getMessage ( ) + "\" for class \"" + classname + "\"" , Project . MSG_DEBUG ) ; return false ; } } public static class FileDir extends EnumeratedAttribute { private static final String [ ] VALUES = { "file" , "dir" } ; public String [ ] getValues ( ) { return VALUES ; } public boolean isDir ( ) { return "dir" . equalsIgnoreCase ( getValue ( ) ) ; } public boolean isFile ( ) { return "file" . equalsIgnoreCase ( getValue ( ) ) ; } } } 	1	['20', '3', '0', '14', '69', '130', '1', '13', '16', '0.846889952', '819', '1', '4', '0.660714286', '0.25', '2', '2', '39.4', '25', '3.05', '3']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class Reference { private String refid ; public Reference ( ) { super ( ) ; } public Reference ( String id ) { this ( ) ; setRefId ( id ) ; } public void setRefId ( String id ) { refid = id ; } public String getRefId ( ) { return refid ; } public Object getReferencedObject ( Project project ) throws BuildException { if ( refid == null ) { throw new BuildException ( "No reference specified" ) ; } Object o = project . getReference ( refid ) ; if ( o == null ) { throw new BuildException ( "Reference " + refid + " not found." ) ; } return o ; } } 	0	['5', '1', '1', '35', '11', '4', '33', '2', '5', '0.25', '54', '1', '0', '0', '0.533333333', '0', '0', '9.6', '1', '0.6', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . io . Reader ; import java . io . Writer ; import java . util . Enumeration ; import java . util . NoSuchElementException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . util . FileUtils ; public class FixCRLF extends MatchingTask { private static final int UNDEF = - 1 ; private static final int NOTJAVA = 0 ; private static final int LOOKING = 1 ; private static final int IN_CHAR_CONST = 2 ; private static final int IN_STR_CONST = 3 ; private static final int IN_SINGLE_COMMENT = 4 ; private static final int IN_MULTI_COMMENT = 5 ; private static final int ASIS = 0 ; private static final int CR = 1 ; private static final int LF = 2 ; private static final int CRLF = 3 ; private static final int ADD = 1 ; private static final int REMOVE = - 1 ; private static final int SPACES = - 1 ; private static final int TABS = 1 ; private static final int INBUFLEN = 8192 ; private static final int LINEBUFLEN = 200 ; private static final char CTRLZ = '' ; private int tablength = 8 ; private String spaces = "        " ; private StringBuffer linebuf = new StringBuffer ( 1024 ) ; private StringBuffer linebuf2 = new StringBuffer ( 1024 ) ; private int eol ; private String eolstr ; private int ctrlz ; private int tabs ; private boolean javafiles = false ; private File srcDir ; private File destDir = null ; private FileUtils fileUtils = FileUtils . newFileUtils ( ) ; private String encoding = null ; public FixCRLF ( ) { tabs = ASIS ; if ( Os . isFamily ( "mac" ) ) { ctrlz = REMOVE ; eol = CR ; eolstr = "\r" ; } else if ( Os . isFamily ( "dos" ) ) { ctrlz = ASIS ; eol = CRLF ; eolstr = "\r\n" ; } else { ctrlz = REMOVE ; eol = LF ; eolstr = "\n" ; } } public void setSrcdir ( File srcDir ) { this . srcDir = srcDir ; } public void setDestdir ( File destDir ) { this . destDir = destDir ; } public void setJavafiles ( boolean javafiles ) { this . javafiles = javafiles ; } public void setEol ( CrLf attr ) { String option = attr . getValue ( ) ; if ( option . equals ( "asis" ) ) { eol = ASIS ; } else if ( option . equals ( "cr" ) || option . equals ( "mac" ) ) { eol = CR ; eolstr = "\r" ; } else if ( option . equals ( "lf" ) || option . equals ( "unix" ) ) { eol = LF ; eolstr = "\n" ; } else { eol = CRLF ; eolstr = "\r\n" ; } } public void setCr ( AddAsisRemove attr ) { log ( "DEPRECATED: The cr attribute has been deprecated," , Project . MSG_WARN ) ; log ( "Please use the eol attribute instead" , Project . MSG_WARN ) ; String option = attr . getValue ( ) ; CrLf c = new CrLf ( ) ; if ( option . equals ( "remove" ) ) { c . setValue ( "lf" ) ; } else if ( option . equals ( "asis" ) ) { c . setValue ( "asis" ) ; } else { c . setValue ( "crlf" ) ; } setEol ( c ) ; } public void setTab ( AddAsisRemove attr ) { String option = attr . getValue ( ) ; if ( option . equals ( "remove" ) ) { tabs = SPACES ; } else if ( option . equals ( "asis" ) ) { tabs = ASIS ; } else { tabs = TABS ; } } public void setTablength ( int tlength ) throws BuildException { if ( tlength < 2 || tlength > 80 ) { throw new BuildException ( "tablength must be between 2 and 80" , getLocation ( ) ) ; } tablength = tlength ; StringBuffer sp = new StringBuffer ( ) ; for ( int i = 0 ; i < tablength ; i ++ ) { sp . append ( ' ' ) ; } spaces = sp . toString ( ) ; } public void setEof ( AddAsisRemove attr ) { String option = attr . getValue ( ) ; if ( option . equals ( "remove" ) ) { ctrlz = REMOVE ; } else if ( option . equals ( "asis" ) ) { ctrlz = ASIS ; } else { ctrlz = ADD ; } } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public void execute ( ) throws BuildException { if ( srcDir == null ) { throw new BuildException ( "srcdir attribute must be set!" ) ; } if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir does not exist!" ) ; } if ( ! srcDir . isDirectory ( ) ) { throw new BuildException ( "srcdir is not a directory!" ) ; } if ( destDir != null ) { if ( ! destDir . exists ( ) ) { throw new BuildException ( "destdir does not exist!" ) ; } if ( ! destDir . isDirectory ( ) ) { throw new BuildException ( "destdir is not a directory!" ) ; } } log ( "options:" + " eol=" + ( eol == ASIS ? "asis" : eol == CR ? "cr" : eol == LF ? "lf" : "crlf" ) + " tab=" + ( tabs == TABS ? "add" : tabs == ASIS ? "asis" : "remove" ) + " eof=" + ( ctrlz == ADD ? "add" : ctrlz == ASIS ? "asis" : "remove" ) + " tablength=" + tablength + " encoding=" + ( encoding == null ? "default" : encoding ) , Project . MSG_VERBOSE ) ; DirectoryScanner ds = super . getDirectoryScanner ( srcDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { processFile ( files [ i ] ) ; } } private Reader getReader ( File f ) throws IOException { return ( encoding == null ) ? new FileReader ( f ) : new InputStreamReader ( new FileInputStream ( f ) , encoding ) ; } private void processFile ( String file ) throws BuildException { File srcFile = new File ( srcDir , file ) ; File destD = destDir == null ? srcDir : destDir ; File tmpFile = null ; BufferedWriter outWriter ; OneLiner . BufferLine line ; OneLiner lines = new OneLiner ( srcFile ) ; try { try { tmpFile = fileUtils . createTempFile ( "fixcrlf" , "" , null ) ; tmpFile . deleteOnExit ( ) ; Writer writer = ( encoding == null ) ? new FileWriter ( tmpFile ) : new OutputStreamWriter ( new FileOutputStream ( tmpFile ) , encoding ) ; outWriter = new BufferedWriter ( writer ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } while ( lines . hasMoreElements ( ) ) { int endComment ; try { line = ( OneLiner . BufferLine ) lines . nextElement ( ) ; } catch ( NoSuchElementException e ) { throw new BuildException ( e ) ; } String lineString = line . getLineString ( ) ; int linelen = line . length ( ) ; if ( tabs == ASIS ) { try { outWriter . write ( lineString ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } else { while ( line . getNext ( ) < linelen ) { switch ( lines . getState ( ) ) { case NOTJAVA : notInConstant ( line , line . length ( ) , outWriter ) ; break ; case IN_MULTI_COMMENT : endComment = lineString . indexOf ( "*/" , line . getNext ( ) ) ; if ( endComment >= 0 ) { endComment += 2 ; lines . setState ( LOOKING ) ; } else { endComment = linelen ; } notInConstant ( line , endComment , outWriter ) ; break ; case IN_SINGLE_COMMENT : notInConstant ( line , line . length ( ) , outWriter ) ; lines . setState ( LOOKING ) ; break ; case IN_CHAR_CONST : case IN_STR_CONST : int begin = line . getNext ( ) ; char terminator = ( lines . getState ( ) == IN_STR_CONST ? '\"' : '\'' ) ; endOfCharConst ( line , terminator ) ; while ( line . getNext ( ) < line . getLookahead ( ) ) { if ( line . getNextCharInc ( ) == '\t' ) { line . setColumn ( line . getColumn ( ) + tablength - ( line . getColumn ( ) % tablength ) ) ; } else { line . incColumn ( ) ; } } try { outWriter . write ( line . substring ( begin , line . getNext ( ) ) ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } lines . setState ( LOOKING ) ; break ; case LOOKING : nextStateChange ( line ) ; notInConstant ( line , line . getLookahead ( ) , outWriter ) ; break ; } } } try { outWriter . write ( eolstr ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } try { if ( ctrlz == ASIS ) { outWriter . write ( lines . getEofStr ( ) ) ; } else if ( ctrlz == ADD ) { outWriter . write ( CTRLZ ) ; } } catch ( IOException e ) { throw new BuildException ( e ) ; } finally { try { outWriter . close ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } try { lines . close ( ) ; lines = null ; } catch ( IOException e ) { throw new BuildException ( "Unable to close source file " + srcFile ) ; } File destFile = new File ( destD , file ) ; boolean destIsWrong = true ; if ( destFile . exists ( ) ) { log ( "destFile exists" , Project . MSG_DEBUG ) ; if ( ! fileUtils . contentEquals ( destFile , tmpFile ) ) { log ( destFile + " is being written" , Project . MSG_DEBUG ) ; } else { log ( destFile + " is not written, as the contents " + "are identical" , Project . MSG_DEBUG ) ; destIsWrong = false ; } } if ( destIsWrong ) { fileUtils . rename ( tmpFile , destFile ) ; tmpFile = null ; } } catch ( IOException e ) { throw new BuildException ( e ) ; } finally { try { if ( lines != null ) { lines . close ( ) ; } } catch ( IOException io ) { log ( "Error closing " + srcFile , Project . MSG_ERR ) ; } if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } private void nextStateChange ( OneLiner . BufferLine bufline ) throws BuildException { int eol = bufline . length ( ) ; int ptr = bufline . getNext ( ) ; while ( ptr < eol ) { switch ( bufline . getChar ( ptr ++ ) ) { case '\'' : bufline . setState ( IN_CHAR_CONST ) ; bufline . setLookahead ( -- ptr ) ; return ; case '\"' : bufline . setState ( IN_STR_CONST ) ; bufline . setLookahead ( -- ptr ) ; return ; case '/' : if ( ptr < eol ) { if ( bufline . getChar ( ptr ) == '*' ) { bufline . setState ( IN_MULTI_COMMENT ) ; bufline . setLookahead ( -- ptr ) ; return ; } else if ( bufline . getChar ( ptr ) == '/' ) { bufline . setState ( IN_SINGLE_COMMENT ) ; bufline . setLookahead ( -- ptr ) ; return ; } } break ; } } bufline . setLookahead ( ptr ) ; } private void endOfCharConst ( OneLiner . BufferLine bufline , char terminator ) throws BuildException { int ptr = bufline . getNext ( ) ; int eol = bufline . length ( ) ; char c ; ptr ++ ; while ( ptr < eol ) { if ( ( c = bufline . getChar ( ptr ++ ) ) == '\\' ) { ptr ++ ; } else { if ( c == terminator ) { bufline . setLookahead ( ptr ) ; return ; } } } throw new BuildException ( "endOfCharConst: unterminated char constant" ) ; } private void notInConstant ( OneLiner . BufferLine bufline , int end , BufferedWriter outWriter ) { int nextTab ; int nextStop ; int tabspaces ; String line = bufline . substring ( bufline . getNext ( ) , end ) ; int place = 0 ; int col = bufline . getColumn ( ) ; linebuf = new StringBuffer ( ) ; while ( ( nextTab = line . indexOf ( ( int ) '\t' , place ) ) >= 0 ) { linebuf . append ( line . substring ( place , nextTab ) ) ; col += nextTab - place ; tabspaces = tablength - ( col % tablength ) ; linebuf . append ( spaces . substring ( 0 , tabspaces ) ) ; col += tabspaces ; place = nextTab + 1 ; } linebuf . append ( line . substring ( place , line . length ( ) ) ) ; String linestring = new String ( linebuf . substring ( 0 ) ) ; if ( tabs == REMOVE ) { try { outWriter . write ( linestring ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } else { int tabCol ; linebuf2 = new StringBuffer ( ) ; place = 0 ; col = bufline . getColumn ( ) ; int placediff = col - 0 ; nextStop = col + ( tablength - col % tablength ) ; if ( nextStop - col < 2 ) { linebuf2 . append ( linestring . substring ( place , nextStop - placediff ) ) ; place = nextStop - placediff ; nextStop += tablength ; } for ( ; nextStop - placediff <= linestring . length ( ) ; nextStop += tablength ) { for ( tabCol = nextStop ; -- tabCol - placediff >= place && linestring . charAt ( tabCol - placediff ) == ' ' ; ) { ; } if ( nextStop - tabCol > 2 ) { linebuf2 . append ( linestring . substring ( place , ++ tabCol - placediff ) ) ; linebuf2 . append ( '\t' ) ; } else { linebuf2 . append ( linestring . substring ( place , nextStop - placediff ) ) ; } place = nextStop - placediff ; } linebuf2 . append ( linestring . substring ( place , linestring . length ( ) ) ) ; try { outWriter . write ( linebuf2 . substring ( 0 ) ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } bufline . setColumn ( bufline . getColumn ( ) + linestring . length ( ) ) ; bufline . setNext ( end ) ; } class OneLiner implements Enumeration { private int state = javafiles ? LOOKING : NOTJAVA ; private StringBuffer eolStr = new StringBuffer ( LINEBUFLEN ) ; private StringBuffer eofStr = new StringBuffer ( ) ; private BufferedReader reader ; private StringBuffer line = new StringBuffer ( ) ; private boolean reachedEof = false ; private File srcFile ; public OneLiner ( File srcFile ) throws BuildException { this . srcFile = srcFile ; try { reader = new BufferedReader ( getReader ( srcFile ) , INBUFLEN ) ; nextLine ( ) ; } catch ( IOException e ) { throw new BuildException ( srcFile + ": " + e . getMessage ( ) , e , getLocation ( ) ) ; } } protected void nextLine ( ) throws BuildException { int ch = - 1 ; int eolcount = 0 ; eolStr = new StringBuffer ( ) ; line = new StringBuffer ( ) ; try { ch = reader . read ( ) ; while ( ch != - 1 && ch != '\r' && ch != '\n' ) { line . append ( ( char ) ch ) ; ch = reader . read ( ) ; } if ( ch == - 1 && line . length ( ) == 0 ) { reachedEof = true ; return ; } switch ( ( char ) ch ) { case '\r' : ++ eolcount ; eolStr . append ( '\r' ) ; reader . mark ( 2 ) ; switch ( ( ch = reader . read ( ) ) ) { case '\r' : if ( ( char ) ( ch = reader . read ( ) ) == '\n' ) { eolcount += 2 ; eolStr . append ( "\r\n" ) ; } else { reader . reset ( ) ; } break ; case '\n' : ++ eolcount ; eolStr . append ( '\n' ) ; break ; case - 1 : break ; default : reader . reset ( ) ; break ; } break ; case '\n' : ++ eolcount ; eolStr . append ( '\n' ) ; break ; } if ( eolcount == 0 ) { int i = line . length ( ) ; while ( -- i >= 0 && line . charAt ( i ) == CTRLZ ) { } if ( i < line . length ( ) - 1 ) { eofStr . append ( line . toString ( ) . substring ( i + 1 ) ) ; if ( i < 0 ) { line . setLength ( 0 ) ; reachedEof = true ; } else { line . setLength ( i + 1 ) ; } } } } catch ( IOException e ) { throw new BuildException ( srcFile + ": " + e . getMessage ( ) , e , getLocation ( ) ) ; } } public String getEofStr ( ) { return eofStr . substring ( 0 ) ; } public int getState ( ) { return state ; } public void setState ( int state ) { this . state = state ; } public boolean hasMoreElements ( ) { return ! reachedEof ; } public Object nextElement ( ) throws NoSuchElementException { if ( ! hasMoreElements ( ) ) { throw new NoSuchElementException ( "OneLiner" ) ; } BufferLine tmpLine = new BufferLine ( line . toString ( ) , eolStr . substring ( 0 ) ) ; nextLine ( ) ; return tmpLine ; } public void close ( ) throws IOException { if ( reader != null ) { reader . close ( ) ; } } class BufferLine { private int next = 0 ; private int column = 0 ; private int lookahead = UNDEF ; private String line ; private String eolStr ; public BufferLine ( String line , String eolStr ) throws BuildException { next = 0 ; column = 0 ; this . line = line ; this . eolStr = eolStr ; } public int getNext ( ) { return next ; } public void setNext ( int next ) { this . next = next ; } public int getLookahead ( ) { return lookahead ; } public void setLookahead ( int lookahead ) { this . lookahead = lookahead ; } public char getChar ( int i ) { return line . charAt ( i ) ; } public char getNextChar ( ) { return getChar ( next ) ; } public char getNextCharInc ( ) { return getChar ( next ++ ) ; } public int getColumn ( ) { return column ; } public void setColumn ( int col ) { column = col ; } public int incColumn ( ) { return column ++ ; } public int length ( ) { return line . length ( ) ; } public int getEolLength ( ) { return eolStr . length ( ) ; } public String getLineString ( ) { return line ; } public String getEol ( ) { return eolStr ; } public String substring ( int begin ) { return line . substring ( begin ) ; } public String substring ( int begin , int end ) { return line . substring ( begin , end ) ; } public void setState ( int state ) { OneLiner . this . setState ( state ) ; } public int getState ( ) { return OneLiner . this . getState ( ) ; } } } public static class AddAsisRemove extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "add" , "asis" , "remove" } ; } } public static class CrLf extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "asis" , "cr" , "lf" , "crlf" , "mac" , "unix" , "dos" } ; } } } 	1	['18', '4', '0', '12', '84', '83', '1', '12', '11', '0.960151803', '1202', '1', '1', '0.821052632', '0.181818182', '2', '2', '64.05555556', '8', '1.9444', '1']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . PatternSet ; public class Chmod extends ExecuteOn { private FileSet defaultSet = new FileSet ( ) ; private boolean defaultSetDefined = false ; private boolean havePerm = false ; public Chmod ( ) { super . setExecutable ( "chmod" ) ; super . setParallel ( true ) ; super . setSkipEmptyFilesets ( true ) ; } public void setProject ( Project project ) { super . setProject ( project ) ; defaultSet . setProject ( project ) ; } public void setFile ( File src ) { FileSet fs = new FileSet ( ) ; fs . setFile ( src ) ; addFileset ( fs ) ; } public void setDir ( File src ) { defaultSet . setDir ( src ) ; } public void setPerm ( String perm ) { createArg ( ) . setValue ( perm ) ; havePerm = true ; } public PatternSet . NameEntry createInclude ( ) { defaultSetDefined = true ; return defaultSet . createInclude ( ) ; } public PatternSet . NameEntry createExclude ( ) { defaultSetDefined = true ; return defaultSet . createExclude ( ) ; } public PatternSet createPatternSet ( ) { defaultSetDefined = true ; return defaultSet . createPatternSet ( ) ; } public void setIncludes ( String includes ) { defaultSetDefined = true ; defaultSet . setIncludes ( includes ) ; } public void setExcludes ( String excludes ) { defaultSetDefined = true ; defaultSet . setExcludes ( excludes ) ; } public void setDefaultexcludes ( boolean useDefaultExcludes ) { defaultSetDefined = true ; defaultSet . setDefaultexcludes ( useDefaultExcludes ) ; } protected void checkConfiguration ( ) { if ( ! havePerm ) { throw new BuildException ( "Required attribute perm not set in chmod" , getLocation ( ) ) ; } if ( defaultSetDefined && defaultSet . getDir ( getProject ( ) ) != null ) { addFileset ( defaultSet ) ; } super . checkConfiguration ( ) ; } public void execute ( ) throws BuildException { if ( defaultSetDefined || defaultSet . getDir ( getProject ( ) ) == null ) { try { super . execute ( ) ; } finally { if ( defaultSetDefined && defaultSet . getDir ( getProject ( ) ) != null ) { filesets . removeElement ( defaultSet ) ; } } } else if ( isValidOs ( ) ) { Execute execute = prepareExec ( ) ; Commandline cloned = ( Commandline ) cmdl . clone ( ) ; cloned . createArgument ( ) . setValue ( defaultSet . getDir ( getProject ( ) ) . getPath ( ) ) ; try { execute . setCommandline ( cloned . getCommandline ( ) ) ; runExecute ( execute ) ; } catch ( IOException e ) { throw new BuildException ( "Execute failed: " + e , e , getLocation ( ) ) ; } finally { logFlush ( ) ; } } } public void setExecutable ( String e ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the executable attribute" , getLocation ( ) ) ; } public void setCommand ( Commandline cmdl ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the command attribute" , getLocation ( ) ) ; } public void setSkipEmptyFilesets ( boolean skip ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the skipemptyfileset attribute" , getLocation ( ) ) ; } public void setAddsourcefile ( boolean b ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the addsourcefile attribute" , getLocation ( ) ) ; } protected boolean isValidOs ( ) { return Os . isFamily ( "unix" ) && super . isValidOs ( ) ; } } 	0	['18', '5', '0', '15', '58', '39', '0', '15', '16', '0.607843137', '316', '1', '1', '0.862903226', '0.268518519', '4', '7', '16.38888889', '4', '1.2222', '0']
package org . apache . tools . ant . taskdefs ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public class StreamPumper implements Runnable { private static final int SIZE = 128 ; private InputStream is ; private OutputStream os ; private boolean finished ; private boolean closeWhenExhausted ; public StreamPumper ( InputStream is , OutputStream os , boolean closeWhenExhausted ) { this . is = is ; this . os = os ; this . closeWhenExhausted = closeWhenExhausted ; } public StreamPumper ( InputStream is , OutputStream os ) { this ( is , os , false ) ; } public void run ( ) { synchronized ( this ) { finished = false ; } final byte [ ] buf = new byte [ SIZE ] ; int length ; try { while ( ( length = is . read ( buf ) ) > 0 ) { os . write ( buf , 0 , length ) ; } } catch ( Exception e ) { } finally { if ( closeWhenExhausted ) { try { os . close ( ) ; } catch ( IOException e ) { } } synchronized ( this ) { finished = true ; notifyAll ( ) ; } } } public synchronized boolean isFinished ( ) { return finished ; } public synchronized void waitFor ( ) throws InterruptedException { while ( ! isFinished ( ) ) { wait ( ) ; } } } 	1	['5', '1', '0', '1', '11', '6', '1', '0', '5', '0.65', '153', '1', '0', '0', '0.5', '0', '0', '28.6', '5', '1.4', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . Task ; public class AntlibDefinition extends Task { private String uri = "" ; private ClassLoader antlibClassLoader ; public void setURI ( String uri ) throws BuildException { if ( uri . equals ( ProjectHelper . ANT_CORE_URI ) ) { uri = "" ; } if ( uri . startsWith ( "ant:" ) ) { throw new BuildException ( "Attempt to use a reserved URI " + uri ) ; } this . uri = uri ; } public String getURI ( ) { return uri ; } public void setAntlibClassLoader ( ClassLoader classLoader ) { this . antlibClassLoader = classLoader ; } public ClassLoader getAntlibClassLoader ( ) { return antlibClassLoader ; } } 	0	['5', '3', '3', '8', '12', '2', '6', '2', '5', '0.625', '49', '1', '0', '0.902439024', '0.466666667', '0', '0', '8.4', '1', '0.8', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileWriter ; import java . io . FilenameFilter ; import java . io . IOException ; import java . io . PrintWriter ; import java . io . BufferedReader ; import java . io . FileReader ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . Enumeration ; import java . util . Locale ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . DirSet ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . PatternSet ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; public class Javadoc extends Task { public class DocletParam { private String name ; private String value ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } } public static class ExtensionInfo extends ProjectComponent { private String name ; private Path path ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setPath ( Path path ) { if ( this . path == null ) { this . path = path ; } else { this . path . append ( path ) ; } } public Path getPath ( ) { return path ; } public Path createPath ( ) { if ( path == null ) { path = new Path ( getProject ( ) ) ; } return path . createPath ( ) ; } public void setPathRef ( Reference r ) { createPath ( ) . setRefid ( r ) ; } } public class DocletInfo extends ExtensionInfo { private Vector params = new Vector ( ) ; public DocletParam createParam ( ) { DocletParam param = new DocletParam ( ) ; params . addElement ( param ) ; return param ; } public Enumeration getParams ( ) { return params . elements ( ) ; } } public static class PackageName { private String name ; public void setName ( String name ) { this . name = name . trim ( ) ; } public String getName ( ) { return name ; } public String toString ( ) { return getName ( ) ; } } public static class SourceFile { private File file ; public SourceFile ( ) { } public SourceFile ( File file ) { this . file = file ; } public void setFile ( File file ) { this . file = file ; } public File getFile ( ) { return file ; } } public static class Html { private StringBuffer text = new StringBuffer ( ) ; public void addText ( String t ) { text . append ( t ) ; } public String getText ( ) { return text . substring ( 0 ) ; } } public static class AccessType extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "protected" , "public" , "package" , "private" } ; } } private Commandline cmd = new Commandline ( ) ; private static boolean javadoc1 = JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ; private static boolean javadoc4 = ! JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) && ! JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_2 ) && ! JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_3 ) ; private void addArgIf ( boolean b , String arg ) { if ( b ) { cmd . createArgument ( ) . setValue ( arg ) ; } } private void add12ArgIfNotEmpty ( String key , String value ) { if ( ! javadoc1 ) { if ( value != null && value . length ( ) != 0 ) { cmd . createArgument ( ) . setValue ( key ) ; cmd . createArgument ( ) . setValue ( value ) ; } else { log ( "Warning: Leaving out empty argument '" + key + "'" , Project . MSG_WARN ) ; } } } private void add12ArgIf ( boolean b , String arg ) { if ( ! javadoc1 && b ) { cmd . createArgument ( ) . setValue ( arg ) ; } } private boolean failOnError = false ; private Path sourcePath = null ; private File destDir = null ; private Vector sourceFiles = new Vector ( ) ; private Vector packageNames = new Vector ( ) ; private Vector excludePackageNames = new Vector ( 1 ) ; private boolean author = true ; private boolean version = true ; private DocletInfo doclet = null ; private Path classpath = null ; private Path bootclasspath = null ; private String group = null ; private String packageList = null ; private Vector links = new Vector ( ) ; private Vector groups = new Vector ( ) ; private Vector tags = new Vector ( ) ; private boolean useDefaultExcludes = true ; private Html doctitle = null ; private Html header = null ; private Html footer = null ; private Html bottom = null ; private boolean useExternalFile = false ; private FileUtils fileUtils = FileUtils . newFileUtils ( ) ; private String source = null ; private boolean linksource = false ; private boolean breakiterator = false ; private String noqualifier ; private Vector fileSets = new Vector ( ) ; private Vector packageSets = new Vector ( ) ; public void setUseExternalFile ( boolean b ) { if ( ! javadoc1 ) { useExternalFile = b ; } } public void setDefaultexcludes ( boolean useDefaultExcludes ) { this . useDefaultExcludes = useDefaultExcludes ; } public void setMaxmemory ( String max ) { if ( javadoc1 ) { cmd . createArgument ( ) . setValue ( "-J-mx" + max ) ; } else { cmd . createArgument ( ) . setValue ( "-J-Xmx" + max ) ; } } public void setAdditionalparam ( String add ) { cmd . createArgument ( ) . setLine ( add ) ; } public Commandline . Argument createArg ( ) { return cmd . createArgument ( ) ; } public void setSourcepath ( Path src ) { if ( sourcePath == null ) { sourcePath = src ; } else { sourcePath . append ( src ) ; } } public Path createSourcepath ( ) { if ( sourcePath == null ) { sourcePath = new Path ( getProject ( ) ) ; } return sourcePath . createPath ( ) ; } public void setSourcepathRef ( Reference r ) { createSourcepath ( ) . setRefid ( r ) ; } public void setDestdir ( File dir ) { destDir = dir ; cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } public void setSourcefiles ( String src ) { StringTokenizer tok = new StringTokenizer ( src , "," ) ; while ( tok . hasMoreTokens ( ) ) { String f = tok . nextToken ( ) ; SourceFile sf = new SourceFile ( ) ; sf . setFile ( getProject ( ) . resolveFile ( f . trim ( ) ) ) ; addSource ( sf ) ; } } public void addSource ( SourceFile sf ) { sourceFiles . addElement ( sf ) ; } public void setPackagenames ( String packages ) { StringTokenizer tok = new StringTokenizer ( packages , "," ) ; while ( tok . hasMoreTokens ( ) ) { String p = tok . nextToken ( ) ; PackageName pn = new PackageName ( ) ; pn . setName ( p ) ; addPackage ( pn ) ; } } public void addPackage ( PackageName pn ) { packageNames . addElement ( pn ) ; } public void setExcludePackageNames ( String packages ) { StringTokenizer tok = new StringTokenizer ( packages , "," ) ; while ( tok . hasMoreTokens ( ) ) { String p = tok . nextToken ( ) ; PackageName pn = new PackageName ( ) ; pn . setName ( p ) ; addExcludePackage ( pn ) ; } } public void addExcludePackage ( PackageName pn ) { excludePackageNames . addElement ( pn ) ; } public void setOverview ( File f ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-overview" ) ; cmd . createArgument ( ) . setFile ( f ) ; } } public void setPublic ( boolean b ) { addArgIf ( b , "-public" ) ; } public void setProtected ( boolean b ) { addArgIf ( b , "-protected" ) ; } public void setPackage ( boolean b ) { addArgIf ( b , "-package" ) ; } public void setPrivate ( boolean b ) { addArgIf ( b , "-private" ) ; } public void setAccess ( AccessType at ) { cmd . createArgument ( ) . setValue ( "-" + at . getValue ( ) ) ; } public void setDoclet ( String docletName ) { if ( doclet == null ) { doclet = new DocletInfo ( ) ; doclet . setProject ( getProject ( ) ) ; } doclet . setName ( docletName ) ; } public void setDocletPath ( Path docletPath ) { if ( doclet == null ) { doclet = new DocletInfo ( ) ; doclet . setProject ( getProject ( ) ) ; } doclet . setPath ( docletPath ) ; } public void setDocletPathRef ( Reference r ) { if ( doclet == null ) { doclet = new DocletInfo ( ) ; doclet . setProject ( getProject ( ) ) ; } doclet . createPath ( ) . setRefid ( r ) ; } public DocletInfo createDoclet ( ) { doclet = new DocletInfo ( ) ; return doclet ; } public void addTaglet ( ExtensionInfo tagletInfo ) { tags . addElement ( tagletInfo ) ; } public void setOld ( boolean b ) { if ( b ) { if ( javadoc1 ) { log ( "Javadoc 1.1 doesn't support the -1.1 switch" , Project . MSG_WARN ) ; } else if ( javadoc4 ) { log ( "Javadoc 1.4 doesn't support the -1.1 switch anymore" , Project . MSG_WARN ) ; } else { cmd . createArgument ( ) . setValue ( "-1.1" ) ; } } } public void setClasspath ( Path path ) { if ( classpath == null ) { classpath = path ; } else { classpath . append ( path ) ; } } public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( getProject ( ) ) ; } return classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setBootclasspath ( Path path ) { if ( bootclasspath == null ) { bootclasspath = path ; } else { bootclasspath . append ( path ) ; } } public Path createBootclasspath ( ) { if ( bootclasspath == null ) { bootclasspath = new Path ( getProject ( ) ) ; } return bootclasspath . createPath ( ) ; } public void setBootClasspathRef ( Reference r ) { createBootclasspath ( ) . setRefid ( r ) ; } public void setExtdirs ( String path ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-extdirs" ) ; cmd . createArgument ( ) . setValue ( path ) ; } } public void setExtdirs ( Path path ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-extdirs" ) ; cmd . createArgument ( ) . setPath ( path ) ; } } public void setVerbose ( boolean b ) { add12ArgIf ( b , "-verbose" ) ; } public void setLocale ( String locale ) { if ( ! javadoc1 ) { cmd . createArgument ( true ) . setValue ( locale ) ; cmd . createArgument ( true ) . setValue ( "-locale" ) ; } } public void setEncoding ( String enc ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( enc ) ; } public void setVersion ( boolean b ) { this . version = b ; } public void setUse ( boolean b ) { add12ArgIf ( b , "-use" ) ; } public void setAuthor ( boolean b ) { author = b ; } public void setSplitindex ( boolean b ) { add12ArgIf ( b , "-splitindex" ) ; } public void setWindowtitle ( String title ) { add12ArgIfNotEmpty ( "-windowtitle" , title ) ; } public void setDoctitle ( String doctitle ) { Html h = new Html ( ) ; h . addText ( doctitle ) ; addDoctitle ( h ) ; } public void addDoctitle ( Html text ) { if ( ! javadoc1 ) { doctitle = text ; } } public void setHeader ( String header ) { Html h = new Html ( ) ; h . addText ( header ) ; addHeader ( h ) ; } public void addHeader ( Html text ) { if ( ! javadoc1 ) { header = text ; } } public void setFooter ( String footer ) { Html h = new Html ( ) ; h . addText ( footer ) ; addFooter ( h ) ; } public void addFooter ( Html text ) { if ( ! javadoc1 ) { footer = text ; } } public void setBottom ( String bottom ) { Html h = new Html ( ) ; h . addText ( bottom ) ; addBottom ( h ) ; } public void addBottom ( Html text ) { if ( ! javadoc1 ) { bottom = text ; } } public void setLinkoffline ( String src ) { if ( ! javadoc1 ) { LinkArgument le = createLink ( ) ; le . setOffline ( true ) ; String linkOfflineError = "The linkoffline attribute must include" + " a URL and a package-list file location separated by a" + " space" ; if ( src . trim ( ) . length ( ) == 0 ) { throw new BuildException ( linkOfflineError ) ; } StringTokenizer tok = new StringTokenizer ( src , " " , false ) ; le . setHref ( tok . nextToken ( ) ) ; if ( ! tok . hasMoreTokens ( ) ) { throw new BuildException ( linkOfflineError ) ; } le . setPackagelistLoc ( getProject ( ) . resolveFile ( tok . nextToken ( ) ) ) ; } } public void setGroup ( String src ) { group = src ; } public void setLink ( String src ) { if ( ! javadoc1 ) { createLink ( ) . setHref ( src ) ; } } public void setNodeprecated ( boolean b ) { addArgIf ( b , "-nodeprecated" ) ; } public void setNodeprecatedlist ( boolean b ) { add12ArgIf ( b , "-nodeprecatedlist" ) ; } public void setNotree ( boolean b ) { addArgIf ( b , "-notree" ) ; } public void setNoindex ( boolean b ) { addArgIf ( b , "-noindex" ) ; } public void setNohelp ( boolean b ) { add12ArgIf ( b , "-nohelp" ) ; } public void setNonavbar ( boolean b ) { add12ArgIf ( b , "-nonavbar" ) ; } public void setSerialwarn ( boolean b ) { add12ArgIf ( b , "-serialwarn" ) ; } public void setStylesheetfile ( File f ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-stylesheetfile" ) ; cmd . createArgument ( ) . setFile ( f ) ; } } public void setHelpfile ( File f ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-helpfile" ) ; cmd . createArgument ( ) . setFile ( f ) ; } } public void setDocencoding ( String enc ) { cmd . createArgument ( ) . setValue ( "-docencoding" ) ; cmd . createArgument ( ) . setValue ( enc ) ; } public void setPackageList ( String src ) { if ( ! javadoc1 ) { packageList = src ; } } public LinkArgument createLink ( ) { LinkArgument la = new LinkArgument ( ) ; links . addElement ( la ) ; return la ; } public class LinkArgument { private String href ; private boolean offline = false ; private File packagelistLoc ; public LinkArgument ( ) { } public void setHref ( String hr ) { href = hr ; } public String getHref ( ) { return href ; } public void setPackagelistLoc ( File src ) { packagelistLoc = src ; } public File getPackagelistLoc ( ) { return packagelistLoc ; } public void setOffline ( boolean offline ) { this . offline = offline ; } public boolean isLinkOffline ( ) { return offline ; } } public TagArgument createTag ( ) { if ( ! javadoc4 ) { log ( "-tag option not supported on JavaDoc < 1.4" , Project . MSG_VERBOSE ) ; } TagArgument ta = new TagArgument ( ) ; tags . addElement ( ta ) ; return ta ; } static final String [ ] SCOPE_ELEMENTS = { "overview" , "packages" , "types" , "constructors" , "methods" , "fields" } ; public class TagArgument extends FileSet { private String name = null ; private String description = null ; private boolean enabled = true ; private String scope = "a" ; public TagArgument ( ) { } public void setName ( String name ) { this . name = name ; } public void setDescription ( String description ) { this . description = description ; } public void setScope ( String verboseScope ) throws BuildException { verboseScope = verboseScope . toLowerCase ( Locale . US ) ; boolean [ ] elements = new boolean [ SCOPE_ELEMENTS . length ] ; boolean gotAll = false ; boolean gotNotAll = false ; StringTokenizer tok = new StringTokenizer ( verboseScope , "," ) ; while ( tok . hasMoreTokens ( ) ) { String next = tok . nextToken ( ) . trim ( ) ; if ( next . equals ( "all" ) ) { if ( gotAll ) { getProject ( ) . log ( "Repeated tag scope element: all" , Project . MSG_VERBOSE ) ; } gotAll = true ; } else { int i ; for ( i = 0 ; i < SCOPE_ELEMENTS . length ; i ++ ) { if ( next . equals ( SCOPE_ELEMENTS [ i ] ) ) { break ; } } if ( i == SCOPE_ELEMENTS . length ) { throw new BuildException ( "Unrecognised scope element: " + next ) ; } else { if ( elements [ i ] ) { getProject ( ) . log ( "Repeated tag scope element: " + next , Project . MSG_VERBOSE ) ; } elements [ i ] = true ; gotNotAll = true ; } } } if ( gotNotAll && gotAll ) { throw new BuildException ( "Mixture of \"all\" and other scope " + "elements in tag parameter." ) ; } if ( ! gotNotAll && ! gotAll ) { throw new BuildException ( "No scope elements specified in tag " + "parameter." ) ; } if ( gotAll ) { this . scope = "a" ; } else { StringBuffer buff = new StringBuffer ( elements . length ) ; for ( int i = 0 ; i < elements . length ; i ++ ) { if ( elements [ i ] ) { buff . append ( SCOPE_ELEMENTS [ i ] . charAt ( 0 ) ) ; } } this . scope = buff . toString ( ) ; } } public void setEnabled ( boolean enabled ) { this . enabled = enabled ; } public String getParameter ( ) throws BuildException { if ( name == null || name . equals ( "" ) ) { throw new BuildException ( "No name specified for custom tag." ) ; } if ( description != null ) { return name + ":" + ( enabled ? "" : "X" ) + scope + ":" + description ; } else { return name ; } } } public GroupArgument createGroup ( ) { GroupArgument ga = new GroupArgument ( ) ; groups . addElement ( ga ) ; return ga ; } public class GroupArgument { private Html title ; private Vector packages = new Vector ( ) ; public GroupArgument ( ) { } public void setTitle ( String src ) { Html h = new Html ( ) ; h . addText ( src ) ; addTitle ( h ) ; } public void addTitle ( Html text ) { title = text ; } public String getTitle ( ) { return title != null ? title . getText ( ) : null ; } public void setPackages ( String src ) { StringTokenizer tok = new StringTokenizer ( src , "," ) ; while ( tok . hasMoreTokens ( ) ) { String p = tok . nextToken ( ) ; PackageName pn = new PackageName ( ) ; pn . setName ( p ) ; addPackage ( pn ) ; } } public void addPackage ( PackageName pn ) { packages . addElement ( pn ) ; } public String getPackages ( ) { StringBuffer p = new StringBuffer ( ) ; for ( int i = 0 ; i < packages . size ( ) ; i ++ ) { if ( i > 0 ) { p . append ( ":" ) ; } p . append ( packages . elementAt ( i ) . toString ( ) ) ; } return p . toString ( ) ; } } public void setCharset ( String src ) { this . add12ArgIfNotEmpty ( "-charset" , src ) ; } public void setFailonerror ( boolean b ) { failOnError = b ; } public void setSource ( String source ) { if ( ! javadoc4 ) { log ( "-source option not supported on JavaDoc < 1.4" , Project . MSG_VERBOSE ) ; } this . source = source ; } public void addPackageset ( DirSet packageSet ) { packageSets . addElement ( packageSet ) ; } public void addFileset ( FileSet fs ) { fileSets . addElement ( fs ) ; } public void setLinksource ( boolean b ) { if ( ! javadoc4 ) { log ( "-linksource option not supported on JavaDoc < 1.4" , Project . MSG_VERBOSE ) ; } this . linksource = b ; } public void setBreakiterator ( boolean b ) { if ( ! javadoc4 ) { log ( "-breakiterator option not supported on JavaDoc < 1.4" , Project . MSG_VERBOSE ) ; } this . breakiterator = b ; } public void setNoqualifier ( String noqualifier ) { if ( ! javadoc4 ) { log ( "-noqualifier option not supported on JavaDoc < 1.4" , Project . MSG_VERBOSE ) ; } this . noqualifier = noqualifier ; } public void execute ( ) throws BuildException { if ( "javadoc2" . equals ( getTaskType ( ) ) ) { log ( "!! javadoc2 is deprecated. Use javadoc instead. !!" ) ; } Vector packagesToDoc = new Vector ( ) ; Path sourceDirs = new Path ( getProject ( ) ) ; if ( packageList != null && sourcePath == null ) { String msg = "sourcePath attribute must be set when " + "specifying packagelist." ; throw new BuildException ( msg ) ; } if ( sourcePath != null ) { sourceDirs . addExisting ( sourcePath ) ; } parsePackages ( packagesToDoc , sourceDirs ) ; if ( packagesToDoc . size ( ) != 0 && sourceDirs . size ( ) == 0 ) { String msg = "sourcePath attribute must be set when " + "specifying package names." ; throw new BuildException ( msg ) ; } Vector sourceFilesToDoc = ( Vector ) sourceFiles . clone ( ) ; addFileSets ( sourceFilesToDoc ) ; if ( packageList == null && packagesToDoc . size ( ) == 0 && sourceFilesToDoc . size ( ) == 0 ) { throw new BuildException ( "No source files and no packages have " + "been specified." ) ; } log ( "Generating Javadoc" , Project . MSG_INFO ) ; Commandline toExecute = ( Commandline ) cmd . clone ( ) ; toExecute . setExecutable ( JavaEnvUtils . getJdkExecutable ( "javadoc" ) ) ; if ( doctitle != null ) { toExecute . createArgument ( ) . setValue ( "-doctitle" ) ; toExecute . createArgument ( ) . setValue ( expand ( doctitle . getText ( ) ) ) ; } if ( header != null ) { toExecute . createArgument ( ) . setValue ( "-header" ) ; toExecute . createArgument ( ) . setValue ( expand ( header . getText ( ) ) ) ; } if ( footer != null ) { toExecute . createArgument ( ) . setValue ( "-footer" ) ; toExecute . createArgument ( ) . setValue ( expand ( footer . getText ( ) ) ) ; } if ( bottom != null ) { toExecute . createArgument ( ) . setValue ( "-bottom" ) ; toExecute . createArgument ( ) . setValue ( expand ( bottom . getText ( ) ) ) ; } if ( classpath == null ) { classpath = ( new Path ( getProject ( ) ) ) . concatSystemClasspath ( "last" ) ; } else { classpath = classpath . concatSystemClasspath ( "ignore" ) ; } if ( ! javadoc1 ) { if ( classpath . size ( ) > 0 ) { toExecute . createArgument ( ) . setValue ( "-classpath" ) ; toExecute . createArgument ( ) . setPath ( classpath ) ; } if ( sourceDirs . size ( ) > 0 ) { toExecute . createArgument ( ) . setValue ( "-sourcepath" ) ; toExecute . createArgument ( ) . setPath ( sourceDirs ) ; } } else { sourceDirs . append ( classpath ) ; if ( sourceDirs . size ( ) > 0 ) { toExecute . createArgument ( ) . setValue ( "-classpath" ) ; toExecute . createArgument ( ) . setPath ( sourceDirs ) ; } } if ( version && doclet == null ) { toExecute . createArgument ( ) . setValue ( "-version" ) ; } if ( author && doclet == null ) { toExecute . createArgument ( ) . setValue ( "-author" ) ; } if ( javadoc1 || doclet == null ) { if ( destDir == null ) { String msg = "destDir attribute must be set!" ; throw new BuildException ( msg ) ; } } if ( ! javadoc1 ) { if ( doclet != null ) { if ( doclet . getName ( ) == null ) { throw new BuildException ( "The doclet name must be " + "specified." , getLocation ( ) ) ; } else { toExecute . createArgument ( ) . setValue ( "-doclet" ) ; toExecute . createArgument ( ) . setValue ( doclet . getName ( ) ) ; if ( doclet . getPath ( ) != null ) { Path docletPath = doclet . getPath ( ) . concatSystemClasspath ( "ignore" ) ; if ( docletPath . size ( ) != 0 ) { toExecute . createArgument ( ) . setValue ( "-docletpath" ) ; toExecute . createArgument ( ) . setPath ( docletPath ) ; } } for ( Enumeration e = doclet . getParams ( ) ; e . hasMoreElements ( ) ; ) { DocletParam param = ( DocletParam ) e . nextElement ( ) ; if ( param . getName ( ) == null ) { throw new BuildException ( "Doclet parameters must " + "have a name" ) ; } toExecute . createArgument ( ) . setValue ( param . getName ( ) ) ; if ( param . getValue ( ) != null ) { toExecute . createArgument ( ) . setValue ( param . getValue ( ) ) ; } } } } if ( bootclasspath != null && bootclasspath . size ( ) > 0 ) { toExecute . createArgument ( ) . setValue ( "-bootclasspath" ) ; toExecute . createArgument ( ) . setPath ( bootclasspath ) ; } if ( links . size ( ) != 0 ) { for ( Enumeration e = links . elements ( ) ; e . hasMoreElements ( ) ; ) { LinkArgument la = ( LinkArgument ) e . nextElement ( ) ; if ( la . getHref ( ) == null || la . getHref ( ) . length ( ) == 0 ) { log ( "No href was given for the link - skipping" , Project . MSG_VERBOSE ) ; continue ; } else { try { URL base = new URL ( "file://." ) ; new URL ( base , la . getHref ( ) ) ; } catch ( MalformedURLException mue ) { log ( "Link href \"" + la . getHref ( ) + "\" is not a valid url - skipping link" , Project . MSG_WARN ) ; continue ; } } if ( la . isLinkOffline ( ) ) { File packageListLocation = la . getPackagelistLoc ( ) ; if ( packageListLocation == null ) { throw new BuildException ( "The package list " + " location for link " + la . getHref ( ) + " must be provided because the link is " + "offline" ) ; } File packageListFile = new File ( packageListLocation , "package-list" ) ; if ( packageListFile . exists ( ) ) { try { String packageListURL = fileUtils . getFileURL ( packageListLocation ) . toExternalForm ( ) ; toExecute . createArgument ( ) . setValue ( "-linkoffline" ) ; toExecute . createArgument ( ) . setValue ( la . getHref ( ) ) ; toExecute . createArgument ( ) . setValue ( packageListURL ) ; } catch ( MalformedURLException ex ) { log ( "Warning: Package list location was " + "invalid " + packageListLocation , Project . MSG_WARN ) ; } } else { log ( "Warning: No package list was found at " + packageListLocation , Project . MSG_VERBOSE ) ; } } else { toExecute . createArgument ( ) . setValue ( "-link" ) ; toExecute . createArgument ( ) . setValue ( la . getHref ( ) ) ; } } } if ( group != null ) { StringTokenizer tok = new StringTokenizer ( group , "," , false ) ; while ( tok . hasMoreTokens ( ) ) { String grp = tok . nextToken ( ) . trim ( ) ; int space = grp . indexOf ( " " ) ; if ( space > 0 ) { String name = grp . substring ( 0 , space ) ; String pkgList = grp . substring ( space + 1 ) ; toExecute . createArgument ( ) . setValue ( "-group" ) ; toExecute . createArgument ( ) . setValue ( name ) ; toExecute . createArgument ( ) . setValue ( pkgList ) ; } } } if ( groups . size ( ) != 0 ) { for ( Enumeration e = groups . elements ( ) ; e . hasMoreElements ( ) ; ) { GroupArgument ga = ( GroupArgument ) e . nextElement ( ) ; String title = ga . getTitle ( ) ; String packages = ga . getPackages ( ) ; if ( title == null || packages == null ) { throw new BuildException ( "The title and packages must " + "be specified for group " + "elements." ) ; } toExecute . createArgument ( ) . setValue ( "-group" ) ; toExecute . createArgument ( ) . setValue ( expand ( title ) ) ; toExecute . createArgument ( ) . setValue ( packages ) ; } } if ( javadoc4 ) { for ( Enumeration e = tags . elements ( ) ; e . hasMoreElements ( ) ; ) { Object element = e . nextElement ( ) ; if ( element instanceof TagArgument ) { TagArgument ta = ( TagArgument ) element ; File tagDir = ta . getDir ( getProject ( ) ) ; if ( tagDir == null ) { toExecute . createArgument ( ) . setValue ( "-tag" ) ; toExecute . createArgument ( ) . setValue ( ta . getParameter ( ) ) ; } else { DirectoryScanner tagDefScanner = ta . getDirectoryScanner ( getProject ( ) ) ; String [ ] files = tagDefScanner . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File tagDefFile = new File ( tagDir , files [ i ] ) ; try { BufferedReader in = new BufferedReader ( new FileReader ( tagDefFile ) ) ; String line = null ; while ( ( line = in . readLine ( ) ) != null ) { toExecute . createArgument ( ) . setValue ( "-tag" ) ; toExecute . createArgument ( ) . setValue ( line ) ; } in . close ( ) ; } catch ( IOException ioe ) { throw new BuildException ( "Couldn't read " + " tag file from " + tagDefFile . getAbsolutePath ( ) , ioe ) ; } } } } else { ExtensionInfo tagletInfo = ( ExtensionInfo ) element ; toExecute . createArgument ( ) . setValue ( "-taglet" ) ; toExecute . createArgument ( ) . setValue ( tagletInfo . getName ( ) ) ; if ( tagletInfo . getPath ( ) != null ) { Path tagletPath = tagletInfo . getPath ( ) . concatSystemClasspath ( "ignore" ) ; if ( tagletPath . size ( ) != 0 ) { toExecute . createArgument ( ) . setValue ( "-tagletpath" ) ; toExecute . createArgument ( ) . setPath ( tagletPath ) ; } } } } if ( source != null ) { toExecute . createArgument ( ) . setValue ( "-source" ) ; toExecute . createArgument ( ) . setValue ( source ) ; } if ( linksource && doclet == null ) { toExecute . createArgument ( ) . setValue ( "-linksource" ) ; } if ( breakiterator && doclet == null ) { toExecute . createArgument ( ) . setValue ( "-breakiterator" ) ; } if ( noqualifier != null && doclet == null ) { toExecute . createArgument ( ) . setValue ( "-noqualifier" ) ; toExecute . createArgument ( ) . setValue ( noqualifier ) ; } } } File tmpList = null ; PrintWriter srcListWriter = null ; try { if ( useExternalFile ) { if ( tmpList == null ) { tmpList = fileUtils . createTempFile ( "javadoc" , "" , null ) ; tmpList . deleteOnExit ( ) ; toExecute . createArgument ( ) . setValue ( "@" + tmpList . getAbsolutePath ( ) ) ; } srcListWriter = new PrintWriter ( new FileWriter ( tmpList . getAbsolutePath ( ) , true ) ) ; } Enumeration e = packagesToDoc . elements ( ) ; while ( e . hasMoreElements ( ) ) { String packageName = ( String ) e . nextElement ( ) ; if ( useExternalFile ) { srcListWriter . println ( packageName ) ; } else { toExecute . createArgument ( ) . setValue ( packageName ) ; } } e = sourceFilesToDoc . elements ( ) ; while ( e . hasMoreElements ( ) ) { SourceFile sf = ( SourceFile ) e . nextElement ( ) ; String sourceFileName = sf . getFile ( ) . getAbsolutePath ( ) ; if ( useExternalFile ) { if ( javadoc4 && sourceFileName . indexOf ( " " ) > - 1 ) { srcListWriter . println ( "\"" + sourceFileName + "\"" ) ; } else { srcListWriter . println ( sourceFileName ) ; } } else { toExecute . createArgument ( ) . setValue ( sourceFileName ) ; } } } catch ( IOException e ) { tmpList . delete ( ) ; throw new BuildException ( "Error creating temporary file" , e , getLocation ( ) ) ; } finally { if ( srcListWriter != null ) { srcListWriter . close ( ) ; } } if ( packageList != null ) { toExecute . createArgument ( ) . setValue ( "@" + packageList ) ; } log ( toExecute . describeCommand ( ) , Project . MSG_VERBOSE ) ; log ( "Javadoc execution" , Project . MSG_INFO ) ; JavadocOutputStream out = new JavadocOutputStream ( Project . MSG_INFO ) ; JavadocOutputStream err = new JavadocOutputStream ( Project . MSG_WARN ) ; Execute exe = new Execute ( new PumpStreamHandler ( out , err ) ) ; exe . setAntRun ( getProject ( ) ) ; exe . setWorkingDirectory ( null ) ; try { exe . setCommandline ( toExecute . getCommandline ( ) ) ; int ret = exe . execute ( ) ; if ( ret != 0 && failOnError ) { throw new BuildException ( "Javadoc returned " + ret , getLocation ( ) ) ; } } catch ( IOException e ) { throw new BuildException ( "Javadoc failed: " + e , e , getLocation ( ) ) ; } finally { if ( tmpList != null ) { tmpList . delete ( ) ; tmpList = null ; } out . logFlush ( ) ; err . logFlush ( ) ; try { out . close ( ) ; err . close ( ) ; } catch ( IOException e ) { } } } private void addFileSets ( Vector sf ) { Enumeration e = fileSets . elements ( ) ; while ( e . hasMoreElements ( ) ) { FileSet fs = ( FileSet ) e . nextElement ( ) ; if ( ! fs . hasPatterns ( ) && ! fs . hasSelectors ( ) ) { fs = ( FileSet ) fs . clone ( ) ; fs . createInclude ( ) . setName ( "**/*.java" ) ; } File baseDir = fs . getDir ( getProject ( ) ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] files = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { sf . addElement ( new SourceFile ( new File ( baseDir , files [ i ] ) ) ) ; } } } private void parsePackages ( Vector pn , Path sp ) { Vector addedPackages = new Vector ( ) ; Vector dirSets = ( Vector ) packageSets . clone ( ) ; if ( sourcePath != null && packageNames . size ( ) > 0 ) { PatternSet ps = new PatternSet ( ) ; Enumeration e = packageNames . elements ( ) ; while ( e . hasMoreElements ( ) ) { PackageName p = ( PackageName ) e . nextElement ( ) ; String pkg = p . getName ( ) . replace ( '.' , '/' ) ; if ( pkg . endsWith ( "*" ) ) { pkg += "*" ; } ps . createInclude ( ) . setName ( pkg ) ; } e = excludePackageNames . elements ( ) ; while ( e . hasMoreElements ( ) ) { PackageName p = ( PackageName ) e . nextElement ( ) ; String pkg = p . getName ( ) . replace ( '.' , '/' ) ; if ( pkg . endsWith ( "*" ) ) { pkg += "*" ; } ps . createExclude ( ) . setName ( pkg ) ; } String [ ] pathElements = sourcePath . list ( ) ; for ( int i = 0 ; i < pathElements . length ; i ++ ) { DirSet ds = new DirSet ( ) ; ds . setDefaultexcludes ( useDefaultExcludes ) ; ds . setDir ( new File ( pathElements [ i ] ) ) ; ds . createPatternSet ( ) . addConfiguredPatternset ( ps ) ; dirSets . addElement ( ds ) ; } } Enumeration e = dirSets . elements ( ) ; while ( e . hasMoreElements ( ) ) { DirSet ds = ( DirSet ) e . nextElement ( ) ; File baseDir = ds . getDir ( getProject ( ) ) ; log ( "scanning " + baseDir + " for packages." , Project . MSG_DEBUG ) ; DirectoryScanner dsc = ds . getDirectoryScanner ( getProject ( ) ) ; String [ ] dirs = dsc . getIncludedDirectories ( ) ; boolean containsPackages = false ; for ( int i = 0 ; i < dirs . length ; i ++ ) { File pd = new File ( baseDir , dirs [ i ] ) ; String [ ] files = pd . list ( new FilenameFilter ( ) { public boolean accept ( File dir1 , String name ) { if ( name . endsWith ( ".java" ) ) { return true ; } return false ; } } ) ; if ( files . length > 0 ) { containsPackages = true ; String packageName = dirs [ i ] . replace ( File . separatorChar , '.' ) ; if ( ! addedPackages . contains ( packageName ) ) { addedPackages . addElement ( packageName ) ; pn . addElement ( packageName ) ; } } } if ( containsPackages ) { sp . createPathElement ( ) . setLocation ( baseDir ) ; } else { log ( baseDir + " doesn\'t contain any packages, dropping it." , Project . MSG_VERBOSE ) ; } } } private class JavadocOutputStream extends LogOutputStream { JavadocOutputStream ( int level ) { super ( Javadoc . this , level ) ; } private String queuedLine = null ; protected void processLine ( String line , int messageLevel ) { if ( messageLevel == Project . MSG_INFO && line . startsWith ( "Generating " ) ) { if ( queuedLine != null ) { super . processLine ( queuedLine , Project . MSG_VERBOSE ) ; } queuedLine = line ; } else { if ( queuedLine != null ) { if ( line . startsWith ( "Building " ) ) { super . processLine ( queuedLine , Project . MSG_VERBOSE ) ; } else { super . processLine ( queuedLine , Project . MSG_INFO ) ; } queuedLine = null ; } super . processLine ( line , messageLevel ) ; } } protected void logFlush ( ) { if ( queuedLine != null ) { super . processLine ( queuedLine , Project . MSG_VERBOSE ) ; queuedLine = null ; } } } protected String expand ( String content ) { return getProject ( ) . replaceProperties ( content ) ; } } 	1	['85', '3', '0', '35', '227', '2766', '7', '35', '78', '0.944444444', '2412', '0.96969697', '10', '0.308333333', '0.136904762', '3', '3', '26.98823529', '13', '1.6706', '6']
package org . apache . tools . ant . util ; import java . io . File ; public class PackageNameMapper extends GlobPatternMapper { protected String extractVariablePart ( String name ) { String var = name . substring ( prefixLength , name . length ( ) - postfixLength ) ; return var . replace ( File . separatorChar , '.' ) ; } } 	0	['2', '2', '0', '1', '6', '1', '0', '1', '1', '2', '20', '0', '0', '0.875', '0.75', '1', '1', '9', '1', '0.5', '0']
package org . apache . tools . ant . loader ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . Project ; import java . util . jar . Manifest ; import java . util . jar . JarFile ; import java . util . zip . ZipFile ; import java . util . jar . Attributes ; import java . util . jar . Attributes . Name ; import java . net . URL ; import java . net . MalformedURLException ; import java . util . zip . ZipEntry ; import java . util . StringTokenizer ; import org . apache . tools . ant . util . FileUtils ; public class AntClassLoader2 extends AntClassLoader { private FileUtils fileUtils ; public AntClassLoader2 ( ) { fileUtils = FileUtils . newFileUtils ( ) ; } protected Class defineClassFromData ( File container , byte [ ] classData , String className ) throws IOException { definePackage ( container , className ) ; return defineClass ( className , classData , 0 , classData . length , Project . class . getProtectionDomain ( ) ) ; } private Manifest getJarManifest ( File container ) throws IOException { if ( container . isDirectory ( ) ) { return null ; } JarFile jarFile = null ; try { jarFile = new JarFile ( container ) ; return jarFile . getManifest ( ) ; } finally { if ( jarFile != null ) { jarFile . close ( ) ; } } } protected void definePackage ( File container , String className ) throws IOException { int classIndex = className . lastIndexOf ( '.' ) ; if ( classIndex == - 1 ) { return ; } String packageName = className . substring ( 0 , classIndex ) ; if ( getPackage ( packageName ) != null ) { return ; } Manifest manifest = getJarManifest ( container ) ; if ( manifest == null ) { definePackage ( packageName , null , null , null , null , null , null , null ) ; } else { definePackage ( container , packageName , manifest ) ; } } protected void definePackage ( File container , String packageName , Manifest manifest ) { String sectionName = packageName . replace ( '.' , '/' ) + "/" ; String specificationTitle = null ; String specificationVendor = null ; String specificationVersion = null ; String implementationTitle = null ; String implementationVendor = null ; String implementationVersion = null ; String sealedString = null ; URL sealBase = null ; Attributes sectionAttributes = manifest . getAttributes ( sectionName ) ; if ( sectionAttributes != null ) { specificationTitle = sectionAttributes . getValue ( Name . SPECIFICATION_TITLE ) ; specificationVendor = sectionAttributes . getValue ( Name . SPECIFICATION_VENDOR ) ; specificationVersion = sectionAttributes . getValue ( Name . SPECIFICATION_VERSION ) ; implementationTitle = sectionAttributes . getValue ( Name . IMPLEMENTATION_TITLE ) ; implementationVendor = sectionAttributes . getValue ( Name . IMPLEMENTATION_VENDOR ) ; implementationVersion = sectionAttributes . getValue ( Name . IMPLEMENTATION_VERSION ) ; sealedString = sectionAttributes . getValue ( Name . SEALED ) ; } Attributes mainAttributes = manifest . getMainAttributes ( ) ; if ( mainAttributes != null ) { if ( specificationTitle == null ) { specificationTitle = mainAttributes . getValue ( Name . SPECIFICATION_TITLE ) ; } if ( specificationVendor == null ) { specificationVendor = mainAttributes . getValue ( Name . SPECIFICATION_VENDOR ) ; } if ( specificationVersion == null ) { specificationVersion = mainAttributes . getValue ( Name . SPECIFICATION_VERSION ) ; } if ( implementationTitle == null ) { implementationTitle = mainAttributes . getValue ( Name . IMPLEMENTATION_TITLE ) ; } if ( implementationVendor == null ) { implementationVendor = mainAttributes . getValue ( Name . IMPLEMENTATION_VENDOR ) ; } if ( implementationVersion == null ) { implementationVersion = mainAttributes . getValue ( Name . IMPLEMENTATION_VERSION ) ; } if ( sealedString == null ) { sealedString = mainAttributes . getValue ( Name . SEALED ) ; } } if ( sealedString != null && sealedString . equalsIgnoreCase ( "true" ) ) { try { sealBase = new URL ( "file:" + container . getPath ( ) ) ; } catch ( MalformedURLException e ) { } } definePackage ( packageName , specificationTitle , specificationVersion , specificationVendor , implementationTitle , implementationVersion , implementationVendor , sealBase ) ; } protected void addPathFile ( File pathComponent ) throws IOException { super . addPathFile ( pathComponent ) ; if ( pathComponent . isDirectory ( ) ) { return ; } String classpath = null ; ZipFile jarFile = null ; InputStream manifestStream = null ; try { jarFile = new ZipFile ( pathComponent ) ; manifestStream = jarFile . getInputStream ( new ZipEntry ( "META-INF/MANIFEST.MF" ) ) ; if ( manifestStream == null ) { return ; } Reader manifestReader = new InputStreamReader ( manifestStream , "UTF-8" ) ; org . apache . tools . ant . taskdefs . Manifest manifest = new org . apache . tools . ant . taskdefs . Manifest ( manifestReader ) ; classpath = manifest . getMainSection ( ) . getAttributeValue ( "Class-Path" ) ; } catch ( org . apache . tools . ant . taskdefs . ManifestException e ) { } finally { if ( manifestStream != null ) { manifestStream . close ( ) ; } if ( jarFile != null ) { jarFile . close ( ) ; } } if ( classpath != null ) { URL baseURL = fileUtils . getFileURL ( pathComponent ) ; StringTokenizer st = new StringTokenizer ( classpath ) ; while ( st . hasMoreTokens ( ) ) { String classpathElement = st . nextToken ( ) ; URL libraryURL = new URL ( baseURL , classpathElement ) ; if ( ! libraryURL . getProtocol ( ) . equals ( "file" ) ) { log ( "Skipping jar library " + classpathElement + " since only relative URLs are supported by this" + " loader" , Project . MSG_VERBOSE ) ; continue ; } File libraryFile = new File ( libraryURL . getFile ( ) ) ; if ( libraryFile . exists ( ) && ! isInPath ( libraryFile ) ) { addPathFile ( libraryFile ) ; } } } } } 	1	['7', '3', '0', '5', '53', '19', '0', '5', '1', '0.916666667', '404', '0.5', '1', '0.93258427', '0.485714286', '3', '11', '56.42857143', '12', '2.4286', '1']
package org . apache . tools . ant . util ; import java . io . Reader ; import java . io . IOException ; import org . apache . tools . ant . ProjectComponent ; public class LineTokenizer extends ProjectComponent implements Tokenizer { private String lineEnd = "" ; private int pushed = - 2 ; private boolean includeDelims = false ; public void setIncludeDelims ( boolean includeDelims ) { this . includeDelims = includeDelims ; } public String getToken ( Reader in ) throws IOException { int ch = - 1 ; if ( pushed != - 2 ) { ch = pushed ; pushed = - 2 ; } else { ch = in . read ( ) ; } if ( ch == - 1 ) { return null ; } lineEnd = "" ; StringBuffer line = new StringBuffer ( ) ; int state = 0 ; while ( ch != - 1 ) { if ( state == 0 ) { if ( ch == '\r' ) { state = 1 ; } else if ( ch == '\n' ) { lineEnd = "\n" ; break ; } else { line . append ( ( char ) ch ) ; } } else { state = 0 ; if ( ch == '\n' ) { lineEnd = "\r\n" ; } else { pushed = ch ; lineEnd = "\r" ; } break ; } ch = in . read ( ) ; } if ( ch == - 1 && state == 1 ) { lineEnd = "\r" ; } if ( includeDelims ) { line . append ( lineEnd ) ; } return line . toString ( ) ; } public String getPostToken ( ) { if ( includeDelims ) { return "" ; } return lineEnd ; } } 	0	['4', '2', '0', '6', '10', '0', '4', '2', '4', '0.333333333', '125', '1', '0', '0.75', '0.5', '0', '0', '29.5', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . security . DigestInputStream ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . security . NoSuchProviderException ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FileInputStream ; import java . io . FileReader ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . HashMap ; import java . util . Map ; import java . util . Vector ; import java . util . Hashtable ; import java . util . Enumeration ; import java . util . Set ; import java . util . Arrays ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . types . FileSet ; public class Checksum extends MatchingTask implements Condition { private File file = null ; private File todir ; private String algorithm = "MD5" ; private String provider = null ; private String fileext ; private String property ; private Map allDigests = new HashMap ( ) ; private Map relativeFilePaths = new HashMap ( ) ; private String totalproperty ; private boolean forceOverwrite ; private String verifyProperty ; private Vector filesets = new Vector ( ) ; private Hashtable includeFileMap = new Hashtable ( ) ; private MessageDigest messageDigest ; private boolean isCondition ; private int readBufferSize = 8 * 1024 ; public void setFile ( File file ) { this . file = file ; } public void setTodir ( File todir ) { this . todir = todir ; } public void setAlgorithm ( String algorithm ) { this . algorithm = algorithm ; } public void setProvider ( String provider ) { this . provider = provider ; } public void setFileext ( String fileext ) { this . fileext = fileext ; } public void setProperty ( String property ) { this . property = property ; } public void setTotalproperty ( String totalproperty ) { this . totalproperty = totalproperty ; } public void setVerifyproperty ( String verifyProperty ) { this . verifyProperty = verifyProperty ; } public void setForceOverwrite ( boolean forceOverwrite ) { this . forceOverwrite = forceOverwrite ; } public void setReadBufferSize ( int size ) { this . readBufferSize = size ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void execute ( ) throws BuildException { isCondition = false ; boolean value = validateAndExecute ( ) ; if ( verifyProperty != null ) { getProject ( ) . setNewProperty ( verifyProperty , new Boolean ( value ) . toString ( ) ) ; } } public boolean eval ( ) throws BuildException { isCondition = true ; return validateAndExecute ( ) ; } private boolean validateAndExecute ( ) throws BuildException { String savedFileExt = fileext ; if ( file == null && filesets . size ( ) == 0 ) { throw new BuildException ( "Specify at least one source - a file or a fileset." ) ; } if ( file != null && file . exists ( ) && file . isDirectory ( ) ) { throw new BuildException ( "Checksum cannot be generated for directories" ) ; } if ( file != null && totalproperty != null ) { throw new BuildException ( "File and Totalproperty cannot co-exist." ) ; } if ( property != null && fileext != null ) { throw new BuildException ( "Property and FileExt cannot co-exist." ) ; } if ( property != null ) { if ( forceOverwrite ) { throw new BuildException ( "ForceOverwrite cannot be used when Property is specified" ) ; } if ( file != null ) { if ( filesets . size ( ) > 0 ) { throw new BuildException ( "Multiple files cannot be used " + "when Property is specified" ) ; } } else { if ( filesets . size ( ) > 1 ) { throw new BuildException ( "Multiple files cannot be used " + "when Property is specified" ) ; } } } if ( verifyProperty != null ) { isCondition = true ; } if ( verifyProperty != null && forceOverwrite ) { throw new BuildException ( "VerifyProperty and ForceOverwrite cannot co-exist." ) ; } if ( isCondition && forceOverwrite ) { throw new BuildException ( "ForceOverwrite cannot be used when " + "conditions are being used." ) ; } messageDigest = null ; if ( provider != null ) { try { messageDigest = MessageDigest . getInstance ( algorithm , provider ) ; } catch ( NoSuchAlgorithmException noalgo ) { throw new BuildException ( noalgo , getLocation ( ) ) ; } catch ( NoSuchProviderException noprovider ) { throw new BuildException ( noprovider , getLocation ( ) ) ; } } else { try { messageDigest = MessageDigest . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException noalgo ) { throw new BuildException ( noalgo , getLocation ( ) ) ; } } if ( messageDigest == null ) { throw new BuildException ( "Unable to create Message Digest" , getLocation ( ) ) ; } if ( fileext == null ) { fileext = "." + algorithm ; } else if ( fileext . trim ( ) . length ( ) == 0 ) { throw new BuildException ( "File extension when specified must not be an empty string" ) ; } try { int sizeofFileSet = filesets . size ( ) ; for ( int i = 0 ; i < sizeofFileSet ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; for ( int j = 0 ; j < srcFiles . length ; j ++ ) { File src = new File ( fs . getDir ( getProject ( ) ) , srcFiles [ j ] ) ; if ( totalproperty != null || todir != null ) { String relativePath = srcFiles [ j ] . replace ( File . separatorChar , '/' ) ; relativeFilePaths . put ( src , relativePath ) ; } addToIncludeFileMap ( src ) ; } } addToIncludeFileMap ( file ) ; return generateChecksums ( ) ; } finally { fileext = savedFileExt ; includeFileMap . clear ( ) ; } } private void addToIncludeFileMap ( File file ) throws BuildException { if ( file != null ) { if ( file . exists ( ) ) { if ( property == null ) { File checksumFile = getChecksumFile ( file ) ; if ( forceOverwrite || isCondition || ( file . lastModified ( ) > checksumFile . lastModified ( ) ) ) { includeFileMap . put ( file , checksumFile ) ; } else { log ( file + " omitted as " + checksumFile + " is up to date." , Project . MSG_VERBOSE ) ; if ( totalproperty != null ) { String checksum = null ; try { BufferedReader diskChecksumReader = new BufferedReader ( new FileReader ( checksumFile ) ) ; checksum = diskChecksumReader . readLine ( ) ; } catch ( IOException e ) { throw new BuildException ( "Couldn't read checksum file " + checksumFile , e ) ; } byte [ ] digest = decodeHex ( checksum . toCharArray ( ) ) ; allDigests . put ( file , digest ) ; } } } else { includeFileMap . put ( file , property ) ; } } else { String message = "Could not find file " + file . getAbsolutePath ( ) + " to generate checksum for." ; log ( message ) ; throw new BuildException ( message , getLocation ( ) ) ; } } } private File getChecksumFile ( File file ) { File directory ; if ( todir != null ) { String path = ( String ) relativeFilePaths . get ( file ) ; directory = new File ( todir , path ) . getParentFile ( ) ; directory . mkdirs ( ) ; } else { directory = file . getParentFile ( ) ; } File checksumFile = new File ( directory , file . getName ( ) + fileext ) ; return checksumFile ; } private boolean generateChecksums ( ) throws BuildException { boolean checksumMatches = true ; FileInputStream fis = null ; FileOutputStream fos = null ; byte [ ] buf = new byte [ readBufferSize ] ; try { for ( Enumeration e = includeFileMap . keys ( ) ; e . hasMoreElements ( ) ; ) { messageDigest . reset ( ) ; File src = ( File ) e . nextElement ( ) ; if ( ! isCondition ) { log ( "Calculating " + algorithm + " checksum for " + src , Project . MSG_VERBOSE ) ; } fis = new FileInputStream ( src ) ; DigestInputStream dis = new DigestInputStream ( fis , messageDigest ) ; while ( dis . read ( buf , 0 , readBufferSize ) != - 1 ) { ; } dis . close ( ) ; fis . close ( ) ; fis = null ; byte [ ] fileDigest = messageDigest . digest ( ) ; if ( totalproperty != null ) { allDigests . put ( src , fileDigest ) ; } String checksum = createDigestString ( fileDigest ) ; Object destination = includeFileMap . get ( src ) ; if ( destination instanceof java . lang . String ) { String prop = ( String ) destination ; if ( isCondition ) { checksumMatches = checksumMatches && checksum . equals ( property ) ; } else { getProject ( ) . setNewProperty ( prop , checksum ) ; } } else if ( destination instanceof java . io . File ) { if ( isCondition ) { File existingFile = ( File ) destination ; if ( existingFile . exists ( ) ) { fis = new FileInputStream ( existingFile ) ; InputStreamReader isr = new InputStreamReader ( fis ) ; BufferedReader br = new BufferedReader ( isr ) ; String suppliedChecksum = br . readLine ( ) ; fis . close ( ) ; fis = null ; br . close ( ) ; isr . close ( ) ; checksumMatches = checksumMatches && checksum . equals ( suppliedChecksum ) ; } else { checksumMatches = false ; } } else { File dest = ( File ) destination ; fos = new FileOutputStream ( dest ) ; fos . write ( checksum . getBytes ( ) ) ; fos . close ( ) ; fos = null ; } } } if ( totalproperty != null ) { Set keys = allDigests . keySet ( ) ; Object [ ] keyArray = keys . toArray ( ) ; Arrays . sort ( keyArray ) ; messageDigest . reset ( ) ; for ( int i = 0 ; i < keyArray . length ; i ++ ) { File src = ( File ) keyArray [ i ] ; byte [ ] digest = ( byte [ ] ) allDigests . get ( src ) ; messageDigest . update ( digest ) ; String fileName = ( String ) relativeFilePaths . get ( src ) ; messageDigest . update ( fileName . getBytes ( ) ) ; } String totalChecksum = createDigestString ( messageDigest . digest ( ) ) ; getProject ( ) . setNewProperty ( totalproperty , totalChecksum ) ; } } catch ( Exception e ) { throw new BuildException ( e , getLocation ( ) ) ; } finally { if ( fis != null ) { try { fis . close ( ) ; } catch ( IOException e ) { } } if ( fos != null ) { try { fos . close ( ) ; } catch ( IOException e ) { } } } return checksumMatches ; } private String createDigestString ( byte [ ] fileDigest ) { StringBuffer checksumSb = new StringBuffer ( ) ; for ( int i = 0 ; i < fileDigest . length ; i ++ ) { String hexStr = Integer . toHexString ( 0x00ff & fileDigest [ i ] ) ; if ( hexStr . length ( ) < 2 ) { checksumSb . append ( "0" ) ; } checksumSb . append ( hexStr ) ; } return checksumSb . toString ( ) ; } public static byte [ ] decodeHex ( char [ ] data ) throws BuildException { int l = data . length ; if ( ( l & 0x01 ) != 0 ) { throw new BuildException ( "odd number of characters." ) ; } byte [ ] out = new byte [ l > > 1 ] ; for ( int i = 0 , j = 0 ; j < l ; i ++ ) { int f = Character . digit ( data [ j ++ ] , 16 ) << 4 ; f = f | Character . digit ( data [ j ++ ] , 16 ) ; out [ i ] = ( byte ) ( f & 0xFF ) ; } return out ; } } 	1	['20', '4', '0', '11', '91', '108', '1', '10', '15', '0.776315789', '962', '1', '0', '0.804123711', '0.2125', '0', '0', '46.3', '3', '1.1', '2']
package org . apache . tools . ant ; import java . lang . reflect . Method ; public class TaskAdapter extends Task implements TypeAdapter { private Object proxy ; public static void checkTaskClass ( final Class taskClass , final Project project ) { try { final Method executeM = taskClass . getMethod ( "execute" , null ) ; if ( ! Void . TYPE . equals ( executeM . getReturnType ( ) ) ) { final String message = "return type of execute() should be " + "void but was \"" + executeM . getReturnType ( ) + "\" in " + taskClass ; project . log ( message , Project . MSG_WARN ) ; } } catch ( NoSuchMethodException e ) { final String message = "No public execute() in " + taskClass ; project . log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } } public void checkProxyClass ( Class proxyClass ) { checkTaskClass ( proxyClass , getProject ( ) ) ; } public void execute ( ) throws BuildException { Method setProjectM = null ; try { Class c = proxy . getClass ( ) ; setProjectM = c . getMethod ( "setProject" , new Class [ ] { Project . class } ) ; if ( setProjectM != null ) { setProjectM . invoke ( proxy , new Object [ ] { getProject ( ) } ) ; } } catch ( NoSuchMethodException e ) { } catch ( Exception ex ) { log ( "Error setting project in " + proxy . getClass ( ) , Project . MSG_ERR ) ; throw new BuildException ( ex ) ; } Method executeM = null ; try { Class c = proxy . getClass ( ) ; executeM = c . getMethod ( "execute" , new Class [ 0 ] ) ; if ( executeM == null ) { log ( "No public execute() in " + proxy . getClass ( ) , Project . MSG_ERR ) ; throw new BuildException ( "No public execute() in " + proxy . getClass ( ) ) ; } executeM . invoke ( proxy , null ) ; return ; } catch ( java . lang . reflect . InvocationTargetException ie ) { log ( "Error in " + proxy . getClass ( ) , Project . MSG_VERBOSE ) ; Throwable t = ie . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( ( BuildException ) t ) ; } else { throw new BuildException ( t ) ; } } catch ( Exception ex ) { log ( "Error in " + proxy . getClass ( ) , Project . MSG_VERBOSE ) ; throw new BuildException ( ex ) ; } } public void setProxy ( Object o ) { this . proxy = o ; } public Object getProxy ( ) { return proxy ; } } 	0	['7', '3', '0', '6', '26', '15', '2', '5', '6', '0.833333333', '237', '0.5', '0', '0.860465116', '0.285714286', '1', '1', '32.57142857', '1', '0.8571', '0']
package org . apache . tools . ant . types . selectors . modifiedselector ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . security . DigestInputStream ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . security . NoSuchProviderException ; import org . apache . tools . ant . BuildException ; public class DigestAlgorithm implements Algorithm { private String algorithm = "MD5" ; private String provider = null ; private MessageDigest messageDigest = null ; private int readBufferSize = 8 * 1024 ; public void setAlgorithm ( String algorithm ) { this . algorithm = algorithm ; } public void setProvider ( String provider ) { this . provider = provider ; } public void initMessageDigest ( ) { if ( messageDigest != null ) { return ; } if ( ( provider != null ) && ! "" . equals ( provider ) && ! "null" . equals ( provider ) ) { try { messageDigest = MessageDigest . getInstance ( algorithm , provider ) ; } catch ( NoSuchAlgorithmException noalgo ) { throw new BuildException ( noalgo ) ; } catch ( NoSuchProviderException noprovider ) { throw new BuildException ( noprovider ) ; } } else { try { messageDigest = MessageDigest . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException noalgo ) { throw new BuildException ( noalgo ) ; } } } public boolean isValid ( ) { return true ; } public String getValue ( File file ) { initMessageDigest ( ) ; String checksum = null ; try { if ( ! file . canRead ( ) ) { return null ; } FileInputStream fis = null ; FileOutputStream fos = null ; byte [ ] buf = new byte [ readBufferSize ] ; try { messageDigest . reset ( ) ; fis = new FileInputStream ( file ) ; DigestInputStream dis = new DigestInputStream ( fis , messageDigest ) ; while ( dis . read ( buf , 0 , readBufferSize ) != - 1 ) { } dis . close ( ) ; fis . close ( ) ; fis = null ; byte [ ] fileDigest = messageDigest . digest ( ) ; StringBuffer checksumSb = new StringBuffer ( ) ; for ( int i = 0 ; i < fileDigest . length ; i ++ ) { String hexStr = Integer . toHexString ( 0x00ff & fileDigest [ i ] ) ; if ( hexStr . length ( ) < 2 ) { checksumSb . append ( "0" ) ; } checksumSb . append ( hexStr ) ; } checksum = checksumSb . toString ( ) ; } catch ( Exception e ) { return null ; } } catch ( Exception e ) { return null ; } return checksum ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "<DigestAlgorithm:" ) ; buf . append ( "algorithm=" ) . append ( algorithm ) ; buf . append ( ";provider=" ) . append ( provider ) ; buf . append ( ">" ) ; return buf . toString ( ) ; } } 	1	['7', '1', '0', '3', '25', '0', '1', '2', '7', '0.541666667', '211', '1', '0', '0', '0.476190476', '0', '0', '28.57142857', '5', '2', '1']
package org . apache . tools . ant . taskdefs . rmic ; import java . io . File ; import java . util . Random ; import java . util . Vector ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Rmic ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . JavaEnvUtils ; public abstract class DefaultRmicAdapter implements RmicAdapter { private Rmic attributes ; private FileNameMapper mapper ; private static final Random rand = new Random ( ) ; public DefaultRmicAdapter ( ) { } public void setRmic ( Rmic attributes ) { this . attributes = attributes ; mapper = new RmicFileNameMapper ( ) ; } public Rmic getRmic ( ) { return attributes ; } protected String getStubClassSuffix ( ) { return "_Stub" ; } protected String getSkelClassSuffix ( ) { return "_Skel" ; } protected String getTieClassSuffix ( ) { return "_Tie" ; } public FileNameMapper getMapper ( ) { return mapper ; } public Path getClasspath ( ) { return getCompileClasspath ( ) ; } protected Path getCompileClasspath ( ) { Path classpath = new Path ( attributes . getProject ( ) ) ; classpath . setLocation ( attributes . getBase ( ) ) ; Path cp = attributes . getClasspath ( ) ; if ( cp == null ) { cp = new Path ( attributes . getProject ( ) ) ; } if ( attributes . getIncludeantruntime ( ) ) { classpath . addExisting ( cp . concatSystemClasspath ( "last" ) ) ; } else { classpath . addExisting ( cp . concatSystemClasspath ( "ignore" ) ) ; } if ( attributes . getIncludejavaruntime ( ) ) { classpath . addJavaRuntime ( ) ; } return classpath ; } protected Commandline setupRmicCommand ( ) { return setupRmicCommand ( null ) ; } protected Commandline setupRmicCommand ( String [ ] options ) { Commandline cmd = new Commandline ( ) ; if ( options != null ) { for ( int i = 0 ; i < options . length ; i ++ ) { cmd . createArgument ( ) . setValue ( options [ i ] ) ; } } Path classpath = getCompileClasspath ( ) ; cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( attributes . getBase ( ) ) ; if ( attributes . getExtdirs ( ) != null ) { if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { classpath . addExtdirs ( attributes . getExtdirs ( ) ) ; } else { cmd . createArgument ( ) . setValue ( "-extdirs" ) ; cmd . createArgument ( ) . setPath ( attributes . getExtdirs ( ) ) ; } } cmd . createArgument ( ) . setValue ( "-classpath" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; String stubVersion = attributes . getStubVersion ( ) ; if ( null != stubVersion ) { if ( "1.1" . equals ( stubVersion ) ) { cmd . createArgument ( ) . setValue ( "-v1.1" ) ; } else if ( "1.2" . equals ( stubVersion ) ) { cmd . createArgument ( ) . setValue ( "-v1.2" ) ; } else { cmd . createArgument ( ) . setValue ( "-vcompat" ) ; } } if ( null != attributes . getSourceBase ( ) ) { cmd . createArgument ( ) . setValue ( "-keepgenerated" ) ; } if ( attributes . getIiop ( ) ) { attributes . log ( "IIOP has been turned on." , Project . MSG_INFO ) ; cmd . createArgument ( ) . setValue ( "-iiop" ) ; if ( attributes . getIiopopts ( ) != null ) { attributes . log ( "IIOP Options: " + attributes . getIiopopts ( ) , Project . MSG_INFO ) ; cmd . createArgument ( ) . setValue ( attributes . getIiopopts ( ) ) ; } } if ( attributes . getIdl ( ) ) { cmd . createArgument ( ) . setValue ( "-idl" ) ; attributes . log ( "IDL has been turned on." , Project . MSG_INFO ) ; if ( attributes . getIdlopts ( ) != null ) { cmd . createArgument ( ) . setValue ( attributes . getIdlopts ( ) ) ; attributes . log ( "IDL Options: " + attributes . getIdlopts ( ) , Project . MSG_INFO ) ; } } if ( attributes . getDebug ( ) ) { cmd . createArgument ( ) . setValue ( "-g" ) ; } cmd . addArguments ( attributes . getCurrentCompilerArgs ( ) ) ; logAndAddFilesToCompile ( cmd ) ; return cmd ; } protected void logAndAddFilesToCompile ( Commandline cmd ) { Vector compileList = attributes . getCompileList ( ) ; attributes . log ( "Compilation " + cmd . describeArguments ( ) , Project . MSG_VERBOSE ) ; StringBuffer niceSourceList = new StringBuffer ( "File" ) ; if ( compileList . size ( ) != 1 ) { niceSourceList . append ( "s" ) ; } niceSourceList . append ( " to be compiled:" ) ; for ( int i = 0 ; i < compileList . size ( ) ; i ++ ) { String arg = ( String ) compileList . elementAt ( i ) ; cmd . createArgument ( ) . setValue ( arg ) ; niceSourceList . append ( "    " + arg ) ; } attributes . log ( niceSourceList . toString ( ) , Project . MSG_VERBOSE ) ; } private class RmicFileNameMapper implements FileNameMapper { RmicFileNameMapper ( ) { } public void setFrom ( String s ) { } public void setTo ( String s ) { } public String [ ] mapFileName ( String name ) { if ( name == null || ! name . endsWith ( ".class" ) || name . endsWith ( getStubClassSuffix ( ) + ".class" ) || name . endsWith ( getSkelClassSuffix ( ) + ".class" ) || name . endsWith ( getTieClassSuffix ( ) + ".class" ) ) { return null ; } String base = name . substring ( 0 , name . length ( ) - 6 ) ; String classname = base . replace ( File . separatorChar , '.' ) ; if ( attributes . getVerify ( ) && ! attributes . isValidRmiRemote ( classname ) ) { return null ; } String [ ] target = new String [ ] { name + ".tmp." + rand . nextLong ( ) } ; if ( ! attributes . getIiop ( ) && ! attributes . getIdl ( ) ) { if ( "1.2" . equals ( attributes . getStubVersion ( ) ) ) { target = new String [ ] { base + getStubClassSuffix ( ) + ".class" } ; } else { target = new String [ ] { base + getStubClassSuffix ( ) + ".class" , base + getSkelClassSuffix ( ) + ".class" , } ; } } else if ( ! attributes . getIdl ( ) ) { int lastSlash = base . lastIndexOf ( File . separatorChar ) ; String dirname = "" ; int index = - 1 ; if ( lastSlash == - 1 ) { index = 0 ; } else { index = lastSlash + 1 ; dirname = base . substring ( 0 , index ) ; } String filename = base . substring ( index ) ; try { Class c = attributes . getLoader ( ) . loadClass ( classname ) ; if ( c . isInterface ( ) ) { target = new String [ ] { dirname + "_" + filename + getStubClassSuffix ( ) + ".class" } ; } else { Class interf = attributes . getRemoteInterface ( c ) ; String iName = interf . getName ( ) ; String iDir = "" ; int iIndex = - 1 ; int lastDot = iName . lastIndexOf ( "." ) ; if ( lastDot == - 1 ) { iIndex = 0 ; } else { iIndex = lastDot + 1 ; iDir = iName . substring ( 0 , iIndex ) ; iDir = iDir . replace ( '.' , File . separatorChar ) ; } target = new String [ ] { dirname + "_" + filename + getTieClassSuffix ( ) + ".class" , iDir + "_" + iName . substring ( iIndex ) + getStubClassSuffix ( ) + ".class" } ; } } catch ( ClassNotFoundException e ) { attributes . log ( "Unable to verify class " + classname + ". It could not be found." , Project . MSG_WARN ) ; } catch ( NoClassDefFoundError e ) { attributes . log ( "Unable to verify class " + classname + ". It is not defined." , Project . MSG_WARN ) ; } catch ( Throwable t ) { attributes . log ( "Unable to verify class " + classname + ". Loading caused Exception: " + t . getMessage ( ) , Project . MSG_WARN ) ; } } return target ; } } } 	0	['16', '1', '3', '15', '56', '86', '4', '12', '6', '0.8', '372', '1', '2', '0', '0.226666667', '0', '0', '22.0625', '14', '2', '0']
package org . apache . tools . ant . taskdefs . cvslib ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . UnsupportedEncodingException ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Enumeration ; import java . util . Properties ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . FileSet ; public class ChangeLogTask extends Task { private File m_usersFile ; private Vector m_cvsUsers = new Vector ( ) ; private File m_dir ; private File m_destfile ; private Date m_start ; private Date m_stop ; private final Vector m_filesets = new Vector ( ) ; public void setDir ( final File dir ) { m_dir = dir ; } public void setDestfile ( final File destfile ) { m_destfile = destfile ; } public void setUsersfile ( final File usersFile ) { m_usersFile = usersFile ; } public void addUser ( final CvsUser user ) { m_cvsUsers . addElement ( user ) ; } public void setStart ( final Date start ) { m_start = start ; } public void setEnd ( final Date stop ) { m_stop = stop ; } public void setDaysinpast ( final int days ) { final long time = System . currentTimeMillis ( ) - ( long ) days * 24 * 60 * 60 * 1000 ; setStart ( new Date ( time ) ) ; } public void addFileset ( final FileSet fileSet ) { m_filesets . addElement ( fileSet ) ; } public void execute ( ) throws BuildException { File savedDir = m_dir ; try { validate ( ) ; final Properties userList = new Properties ( ) ; loadUserlist ( userList ) ; for ( Enumeration e = m_cvsUsers . elements ( ) ; e . hasMoreElements ( ) ; ) { final CvsUser user = ( CvsUser ) e . nextElement ( ) ; user . validate ( ) ; userList . put ( user . getUserID ( ) , user . getDisplayname ( ) ) ; } final Commandline command = new Commandline ( ) ; command . setExecutable ( "cvs" ) ; command . createArgument ( ) . setValue ( "log" ) ; if ( null != m_start ) { final SimpleDateFormat outputDate = new SimpleDateFormat ( "yyyy-MM-dd" ) ; final String dateRange = ">=" + outputDate . format ( m_start ) ; command . createArgument ( ) . setValue ( "-d" ) ; command . createArgument ( ) . setValue ( dateRange ) ; } if ( ! m_filesets . isEmpty ( ) ) { final Enumeration e = m_filesets . elements ( ) ; while ( e . hasMoreElements ( ) ) { final FileSet fileSet = ( FileSet ) e . nextElement ( ) ; final DirectoryScanner scanner = fileSet . getDirectoryScanner ( getProject ( ) ) ; final String [ ] files = scanner . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { command . createArgument ( ) . setValue ( files [ i ] ) ; } } } final ChangeLogParser parser = new ChangeLogParser ( ) ; final RedirectingStreamHandler handler = new RedirectingStreamHandler ( parser ) ; log ( command . describeCommand ( ) , Project . MSG_VERBOSE ) ; final Execute exe = new Execute ( handler ) ; exe . setWorkingDirectory ( m_dir ) ; exe . setCommandline ( command . getCommandline ( ) ) ; exe . setAntRun ( getProject ( ) ) ; try { final int resultCode = exe . execute ( ) ; if ( Execute . isFailure ( resultCode ) ) { throw new BuildException ( "Error running cvs log" ) ; } } catch ( final IOException ioe ) { throw new BuildException ( ioe . toString ( ) ) ; } final String errors = handler . getErrors ( ) ; if ( null != errors ) { log ( errors , Project . MSG_ERR ) ; } final CVSEntry [ ] entrySet = parser . getEntrySetAsArray ( ) ; final CVSEntry [ ] filteredEntrySet = filterEntrySet ( entrySet ) ; replaceAuthorIdWithName ( userList , filteredEntrySet ) ; writeChangeLog ( filteredEntrySet ) ; } finally { m_dir = savedDir ; } } private void validate ( ) throws BuildException { if ( null == m_dir ) { m_dir = getProject ( ) . getBaseDir ( ) ; } if ( null == m_destfile ) { final String message = "Destfile must be set." ; throw new BuildException ( message ) ; } if ( ! m_dir . exists ( ) ) { final String message = "Cannot find base dir " + m_dir . getAbsolutePath ( ) ; throw new BuildException ( message ) ; } if ( null != m_usersFile && ! m_usersFile . exists ( ) ) { final String message = "Cannot find user lookup list " + m_usersFile . getAbsolutePath ( ) ; throw new BuildException ( message ) ; } } private void loadUserlist ( final Properties userList ) throws BuildException { if ( null != m_usersFile ) { try { userList . load ( new FileInputStream ( m_usersFile ) ) ; } catch ( final IOException ioe ) { throw new BuildException ( ioe . toString ( ) , ioe ) ; } } } private CVSEntry [ ] filterEntrySet ( final CVSEntry [ ] entrySet ) { final Vector results = new Vector ( ) ; for ( int i = 0 ; i < entrySet . length ; i ++ ) { final CVSEntry cvsEntry = entrySet [ i ] ; final Date date = cvsEntry . getDate ( ) ; if ( null != m_start && m_start . after ( date ) ) { continue ; } if ( null != m_stop && m_stop . before ( date ) ) { continue ; } results . addElement ( cvsEntry ) ; } final CVSEntry [ ] resultArray = new CVSEntry [ results . size ( ) ] ; results . copyInto ( resultArray ) ; return resultArray ; } private void replaceAuthorIdWithName ( final Properties userList , final CVSEntry [ ] entrySet ) { for ( int i = 0 ; i < entrySet . length ; i ++ ) { final CVSEntry entry = entrySet [ i ] ; if ( userList . containsKey ( entry . getAuthor ( ) ) ) { entry . setAuthor ( userList . getProperty ( entry . getAuthor ( ) ) ) ; } } } private void writeChangeLog ( final CVSEntry [ ] entrySet ) throws BuildException { FileOutputStream output = null ; try { output = new FileOutputStream ( m_destfile ) ; final PrintWriter writer = new PrintWriter ( new OutputStreamWriter ( output , "UTF-8" ) ) ; final ChangeLogWriter serializer = new ChangeLogWriter ( ) ; serializer . printChangeLog ( writer , entrySet ) ; } catch ( final UnsupportedEncodingException uee ) { getProject ( ) . log ( uee . toString ( ) , Project . MSG_ERR ) ; } catch ( final IOException ioe ) { throw new BuildException ( ioe . toString ( ) , ioe ) ; } finally { if ( null != output ) { try { output . close ( ) ; } catch ( final IOException ioe ) { } } } } } 	1	['15', '3', '0', '16', '78', '69', '0', '16', '10', '0.826530612', '502', '1', '0', '0.725490196', '0.233333333', '1', '1', '32', '6', '1.4', '2']
package org . apache . tools . ant . types ; public final class Parameter { private String name = null ; private String type = null ; private String value = null ; public final void setName ( final String name ) { this . name = name ; } public final void setType ( final String type ) { this . type = type ; } public final void setValue ( final String value ) { this . value = value ; } public final String getName ( ) { return name ; } public final String getType ( ) { return type ; } public final String getValue ( ) { return value ; } } 	0	['7', '1', '0', '24', '8', '3', '24', '0', '7', '0.666666667', '43', '1', '0', '0', '0.714285714', '0', '0', '4.714285714', '1', '0.8571', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import java . io . StringReader ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . Commandline ; public class Execute { public static final int INVALID = Integer . MAX_VALUE ; private String [ ] cmdl = null ; private String [ ] env = null ; private int exitValue = INVALID ; private ExecuteStreamHandler streamHandler ; private ExecuteWatchdog watchdog ; private File workingDirectory = null ; private Project project = null ; private boolean newEnvironment = false ; private boolean useVMLauncher = true ; private static String antWorkingDirectory = System . getProperty ( "user.dir" ) ; private static CommandLauncher vmLauncher = null ; private static CommandLauncher shellLauncher = null ; private static Vector procEnvironment = null ; private boolean spawn = false ; private static ProcessDestroyer processDestroyer = new ProcessDestroyer ( ) ; static { try { if ( Os . isFamily ( "openvms" ) ) { vmLauncher = new VmsCommandLauncher ( ) ; } else if ( ! Os . isFamily ( "os/2" ) ) { vmLauncher = new Java13CommandLauncher ( ) ; } } catch ( NoSuchMethodException exc ) { } if ( Os . isFamily ( "mac" ) && ! Os . isFamily ( "unix" ) ) { shellLauncher = new MacCommandLauncher ( new CommandLauncher ( ) ) ; } else if ( Os . isFamily ( "os/2" ) ) { shellLauncher = new OS2CommandLauncher ( new CommandLauncher ( ) ) ; } else if ( Os . isFamily ( "windows" ) ) { CommandLauncher baseLauncher ; if ( System . getProperty ( "java.version" ) . startsWith ( "1.1" ) ) { baseLauncher = new Java11CommandLauncher ( ) ; } else { baseLauncher = new CommandLauncher ( ) ; } if ( ! Os . isFamily ( "win9x" ) ) { shellLauncher = new WinNTCommandLauncher ( baseLauncher ) ; } else { shellLauncher = new ScriptCommandLauncher ( "bin/antRun.bat" , baseLauncher ) ; } } else if ( Os . isFamily ( "netware" ) ) { CommandLauncher baseLauncher ; if ( System . getProperty ( "java.version" ) . startsWith ( "1.1" ) ) { baseLauncher = new Java11CommandLauncher ( ) ; } else { baseLauncher = new CommandLauncher ( ) ; } shellLauncher = new PerlScriptCommandLauncher ( "bin/antRun.pl" , baseLauncher ) ; } else if ( Os . isFamily ( "openvms" ) ) { shellLauncher = vmLauncher ; } else { shellLauncher = new ScriptCommandLauncher ( "bin/antRun" , new CommandLauncher ( ) ) ; } } public void setSpawn ( boolean spawn ) { this . spawn = spawn ; } public static synchronized Vector getProcEnvironment ( ) { if ( procEnvironment != null ) { return procEnvironment ; } procEnvironment = new Vector ( ) ; try { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; Execute exe = new Execute ( new PumpStreamHandler ( out ) ) ; exe . setCommandline ( getProcEnvCommand ( ) ) ; exe . setNewenvironment ( true ) ; int retval = exe . execute ( ) ; if ( retval != 0 ) { } BufferedReader in = new BufferedReader ( new StringReader ( toString ( out ) ) ) ; if ( Os . isFamily ( "openvms" ) ) { procEnvironment = addVMSLogicals ( procEnvironment , in ) ; return procEnvironment ; } String var = null ; String line , lineSep = System . getProperty ( "line.separator" ) ; while ( ( line = in . readLine ( ) ) != null ) { if ( line . indexOf ( '=' ) == - 1 ) { if ( var == null ) { var = lineSep + line ; } else { var += lineSep + line ; } } else { if ( var != null ) { procEnvironment . addElement ( var ) ; } var = line ; } } if ( var != null ) { procEnvironment . addElement ( var ) ; } } catch ( java . io . IOException exc ) { exc . printStackTrace ( ) ; } return procEnvironment ; } private static String [ ] getProcEnvCommand ( ) { if ( Os . isFamily ( "os/2" ) ) { String [ ] cmd = { "cmd" , "/c" , "set" } ; return cmd ; } else if ( Os . isFamily ( "windows" ) ) { if ( ! Os . isFamily ( "win9x" ) ) { String [ ] cmd = { "cmd" , "/c" , "set" } ; return cmd ; } else { String [ ] cmd = { "command.com" , "/c" , "set" } ; return cmd ; } } else if ( Os . isFamily ( "z/os" ) || Os . isFamily ( "unix" ) ) { String [ ] cmd = new String [ 1 ] ; if ( new File ( "/bin/env" ) . canRead ( ) ) { cmd [ 0 ] = "/bin/env" ; } else if ( new File ( "/usr/bin/env" ) . canRead ( ) ) { cmd [ 0 ] = "/usr/bin/env" ; } else { cmd [ 0 ] = "env" ; } return cmd ; } else if ( Os . isFamily ( "netware" ) || Os . isFamily ( "os/400" ) ) { String [ ] cmd = { "env" } ; return cmd ; } else if ( Os . isFamily ( "openvms" ) ) { String [ ] cmd = { "show" , "logical" } ; return cmd ; } else { String [ ] cmd = null ; return cmd ; } } public static String toString ( ByteArrayOutputStream bos ) { if ( Os . isFamily ( "z/os" ) ) { try { return bos . toString ( "Cp1047" ) ; } catch ( java . io . UnsupportedEncodingException e ) { } } else if ( Os . isFamily ( "os/400" ) ) { try { return bos . toString ( "Cp500" ) ; } catch ( java . io . UnsupportedEncodingException e ) { } } return bos . toString ( ) ; } public Execute ( ) { this ( new PumpStreamHandler ( ) , null ) ; } public Execute ( ExecuteStreamHandler streamHandler ) { this ( streamHandler , null ) ; } public Execute ( ExecuteStreamHandler streamHandler , ExecuteWatchdog watchdog ) { setStreamHandler ( streamHandler ) ; this . watchdog = watchdog ; } public void setStreamHandler ( ExecuteStreamHandler streamHandler ) { this . streamHandler = streamHandler ; } public String [ ] getCommandline ( ) { return cmdl ; } public void setCommandline ( String [ ] commandline ) { cmdl = commandline ; } public void setNewenvironment ( boolean newenv ) { newEnvironment = newenv ; } public String [ ] getEnvironment ( ) { if ( env == null || newEnvironment ) { return env ; } return patchEnvironment ( ) ; } public void setEnvironment ( String [ ] env ) { this . env = env ; } public void setWorkingDirectory ( File wd ) { if ( wd == null || wd . getAbsolutePath ( ) . equals ( antWorkingDirectory ) ) { workingDirectory = null ; } else { workingDirectory = wd ; } } public void setAntRun ( Project project ) throws BuildException { this . project = project ; } public void setVMLauncher ( boolean useVMLauncher ) { this . useVMLauncher = useVMLauncher ; } public static Process launch ( Project project , String [ ] command , String [ ] env , File dir , boolean useVM ) throws IOException { CommandLauncher launcher = vmLauncher != null ? vmLauncher : shellLauncher ; if ( ! useVM ) { launcher = shellLauncher ; } return launcher . exec ( project , command , env , dir ) ; } public int execute ( ) throws IOException { final Process process = launch ( project , getCommandline ( ) , getEnvironment ( ) , workingDirectory , useVMLauncher ) ; try { streamHandler . setProcessInputStream ( process . getOutputStream ( ) ) ; streamHandler . setProcessOutputStream ( process . getInputStream ( ) ) ; streamHandler . setProcessErrorStream ( process . getErrorStream ( ) ) ; } catch ( IOException e ) { process . destroy ( ) ; throw e ; } streamHandler . start ( ) ; try { processDestroyer . add ( process ) ; if ( watchdog != null ) { watchdog . start ( process ) ; } waitFor ( process ) ; if ( watchdog != null ) { watchdog . stop ( ) ; } streamHandler . stop ( ) ; if ( watchdog != null ) { watchdog . checkException ( ) ; } return getExitValue ( ) ; } finally { processDestroyer . remove ( process ) ; } } public void spawn ( ) throws IOException { final Process process = launch ( project , getCommandline ( ) , getEnvironment ( ) , workingDirectory , useVMLauncher ) ; if ( Os . isFamily ( "windows" ) ) { try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException e ) { project . log ( "interruption in the sleep after having spawned a process" , Project . MSG_VERBOSE ) ; } } project . log ( "spawned process " + process . toString ( ) , Project . MSG_VERBOSE ) ; } protected void waitFor ( Process process ) { try { process . waitFor ( ) ; setExitValue ( process . exitValue ( ) ) ; } catch ( InterruptedException e ) { process . destroy ( ) ; } } protected void setExitValue ( int value ) { exitValue = value ; } public int getExitValue ( ) { return exitValue ; } public static boolean isFailure ( int exitValue ) { if ( Os . isFamily ( "openvms" ) ) { return ( exitValue % 2 ) == 0 ; } else { return exitValue != 0 ; } } public boolean killedProcess ( ) { return watchdog != null && watchdog . killedProcess ( ) ; } private String [ ] patchEnvironment ( ) { if ( Os . isFamily ( "openvms" ) ) { return env ; } Vector osEnv = ( Vector ) getProcEnvironment ( ) . clone ( ) ; for ( int i = 0 ; i < env . length ; i ++ ) { int pos = env [ i ] . indexOf ( '=' ) ; String key = env [ i ] . substring ( 0 , pos + 1 ) ; int size = osEnv . size ( ) ; for ( int j = 0 ; j < size ; j ++ ) { if ( ( ( String ) osEnv . elementAt ( j ) ) . startsWith ( key ) ) { osEnv . removeElementAt ( j ) ; break ; } } osEnv . addElement ( env [ i ] ) ; } String [ ] result = new String [ osEnv . size ( ) ] ; osEnv . copyInto ( result ) ; return result ; } public static void runCommand ( Task task , String [ ] cmdline ) throws BuildException { try { task . log ( Commandline . describeCommand ( cmdline ) , Project . MSG_VERBOSE ) ; Execute exe = new Execute ( new LogStreamHandler ( task , Project . MSG_INFO , Project . MSG_ERR ) ) ; exe . setAntRun ( task . getProject ( ) ) ; exe . setCommandline ( cmdline ) ; int retval = exe . execute ( ) ; if ( isFailure ( retval ) ) { throw new BuildException ( cmdline [ 0 ] + " failed with return code " + retval , task . getLocation ( ) ) ; } } catch ( java . io . IOException exc ) { throw new BuildException ( "Could not launch " + cmdline [ 0 ] + ": " + exc , task . getLocation ( ) ) ; } } private static Vector addVMSLogicals ( Vector environment , BufferedReader in ) throws IOException { HashMap logicals = new HashMap ( ) ; String logName = null , logValue = null , newLogName ; String line = null ; while ( ( line = in . readLine ( ) ) != null ) { if ( line . startsWith ( "\t=" ) ) { if ( logName != null ) { logValue += "," + line . substring ( 4 , line . length ( ) - 1 ) ; } } else if ( line . startsWith ( "  \"" ) ) { if ( logName != null ) { logicals . put ( logName , logValue ) ; } int eqIndex = line . indexOf ( '=' ) ; newLogName = line . substring ( 3 , eqIndex - 2 ) ; if ( logicals . containsKey ( newLogName ) ) { logName = null ; } else { logName = newLogName ; logValue = line . substring ( eqIndex + 3 , line . length ( ) - 1 ) ; } } } if ( logName != null ) { logicals . put ( logName , logValue ) ; } for ( Iterator i = logicals . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { String logical = ( String ) i . next ( ) ; environment . add ( logical + "=" + logicals . get ( logical ) ) ; } return environment ; } private static class CommandLauncher { public Process exec ( Project project , String [ ] cmd , String [ ] env ) throws IOException { if ( project != null ) { project . log ( "Execute:CommandLauncher: " + Commandline . describeCommand ( cmd ) , Project . MSG_DEBUG ) ; } return Runtime . getRuntime ( ) . exec ( cmd , env ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } throw new IOException ( "Cannot execute a process in different " + "directory under this JVM" ) ; } } private static class Java11CommandLauncher extends CommandLauncher { public Process exec ( Project project , String [ ] cmd , String [ ] env ) throws IOException { String [ ] newcmd = new String [ cmd . length ] ; for ( int i = 0 ; i < cmd . length ; i ++ ) { newcmd [ i ] = Commandline . quoteArgument ( cmd [ i ] ) ; } if ( project != null ) { project . log ( "Execute:Java11CommandLauncher: " + Commandline . describeCommand ( newcmd ) , Project . MSG_DEBUG ) ; } return Runtime . getRuntime ( ) . exec ( newcmd , env ) ; } } private static class Java13CommandLauncher extends CommandLauncher { public Java13CommandLauncher ( ) throws NoSuchMethodException { myExecWithCWD = Runtime . class . getMethod ( "exec" , new Class [ ] { String [ ] . class , String [ ] . class , File . class } ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { try { if ( project != null ) { project . log ( "Execute:Java13CommandLauncher: " + Commandline . describeCommand ( cmd ) , Project . MSG_DEBUG ) ; } Object [ ] arguments = { cmd , env , workingDir } ; return ( Process ) myExecWithCWD . invoke ( Runtime . getRuntime ( ) , arguments ) ; } catch ( InvocationTargetException exc ) { Throwable realexc = exc . getTargetException ( ) ; if ( realexc instanceof ThreadDeath ) { throw ( ThreadDeath ) realexc ; } else if ( realexc instanceof IOException ) { throw ( IOException ) realexc ; } else { throw new BuildException ( "Unable to execute command" , realexc ) ; } } catch ( Exception exc ) { throw new BuildException ( "Unable to execute command" , exc ) ; } } private Method myExecWithCWD ; } private static class CommandLauncherProxy extends CommandLauncher { CommandLauncherProxy ( CommandLauncher launcher ) { myLauncher = launcher ; } public Process exec ( Project project , String [ ] cmd , String [ ] env ) throws IOException { return myLauncher . exec ( project , cmd , env ) ; } private CommandLauncher myLauncher ; } private static class OS2CommandLauncher extends CommandLauncherProxy { OS2CommandLauncher ( CommandLauncher launcher ) { super ( launcher ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { File commandDir = workingDir ; if ( workingDir == null ) { if ( project != null ) { commandDir = project . getBaseDir ( ) ; } else { return exec ( project , cmd , env ) ; } } final int preCmdLength = 7 ; final String cmdDir = commandDir . getAbsolutePath ( ) ; String [ ] newcmd = new String [ cmd . length + preCmdLength ] ; newcmd [ 0 ] = "cmd" ; newcmd [ 1 ] = "/c" ; newcmd [ 2 ] = cmdDir . substring ( 0 , 2 ) ; newcmd [ 3 ] = "&&" ; newcmd [ 4 ] = "cd" ; newcmd [ 5 ] = cmdDir . substring ( 2 ) ; newcmd [ 6 ] = "&&" ; System . arraycopy ( cmd , 0 , newcmd , preCmdLength , cmd . length ) ; return exec ( project , newcmd , env ) ; } } private static class WinNTCommandLauncher extends CommandLauncherProxy { WinNTCommandLauncher ( CommandLauncher launcher ) { super ( launcher ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { File commandDir = workingDir ; if ( workingDir == null ) { if ( project != null ) { commandDir = project . getBaseDir ( ) ; } else { return exec ( project , cmd , env ) ; } } final int preCmdLength = 6 ; String [ ] newcmd = new String [ cmd . length + preCmdLength ] ; newcmd [ 0 ] = "cmd" ; newcmd [ 1 ] = "/c" ; newcmd [ 2 ] = "cd" ; newcmd [ 3 ] = "/d" ; newcmd [ 4 ] = commandDir . getAbsolutePath ( ) ; newcmd [ 5 ] = "&&" ; System . arraycopy ( cmd , 0 , newcmd , preCmdLength , cmd . length ) ; return exec ( project , newcmd , env ) ; } } private static class MacCommandLauncher extends CommandLauncherProxy { MacCommandLauncher ( CommandLauncher launcher ) { super ( launcher ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } System . getProperties ( ) . put ( "user.dir" , workingDir . getAbsolutePath ( ) ) ; try { return exec ( project , cmd , env ) ; } finally { System . getProperties ( ) . put ( "user.dir" , antWorkingDirectory ) ; } } } private static class ScriptCommandLauncher extends CommandLauncherProxy { ScriptCommandLauncher ( String script , CommandLauncher launcher ) { super ( launcher ) ; myScript = script ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( project == null ) { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } throw new IOException ( "Cannot locate antRun script: " + "No project provided" ) ; } String antHome = project . getProperty ( "ant.home" ) ; if ( antHome == null ) { throw new IOException ( "Cannot locate antRun script: " + "Property 'ant.home' not found" ) ; } String antRun = project . resolveFile ( antHome + File . separator + myScript ) . toString ( ) ; File commandDir = workingDir ; if ( workingDir == null && project != null ) { commandDir = project . getBaseDir ( ) ; } String [ ] newcmd = new String [ cmd . length + 2 ] ; newcmd [ 0 ] = antRun ; newcmd [ 1 ] = commandDir . getAbsolutePath ( ) ; System . arraycopy ( cmd , 0 , newcmd , 2 , cmd . length ) ; return exec ( project , newcmd , env ) ; } private String myScript ; } private static class PerlScriptCommandLauncher extends CommandLauncherProxy { PerlScriptCommandLauncher ( String script , CommandLauncher launcher ) { super ( launcher ) ; myScript = script ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( project == null ) { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } throw new IOException ( "Cannot locate antRun script: " + "No project provided" ) ; } String antHome = project . getProperty ( "ant.home" ) ; if ( antHome == null ) { throw new IOException ( "Cannot locate antRun script: " + "Property 'ant.home' not found" ) ; } String antRun = project . resolveFile ( antHome + File . separator + myScript ) . toString ( ) ; File commandDir = workingDir ; if ( workingDir == null && project != null ) { commandDir = project . getBaseDir ( ) ; } String [ ] newcmd = new String [ cmd . length + 3 ] ; newcmd [ 0 ] = "perl" ; newcmd [ 1 ] = antRun ; newcmd [ 2 ] = commandDir . getAbsolutePath ( ) ; System . arraycopy ( cmd , 0 , newcmd , 3 , cmd . length ) ; return exec ( project , newcmd , env ) ; } private String myScript ; } private static class VmsCommandLauncher extends Java13CommandLauncher { public VmsCommandLauncher ( ) throws NoSuchMethodException { super ( ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env ) throws IOException { String [ ] vmsCmd = { createCommandFile ( cmd , env ) . getPath ( ) } ; return super . exec ( project , vmsCmd , env ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { String [ ] vmsCmd = { createCommandFile ( cmd , env ) . getPath ( ) } ; return super . exec ( project , vmsCmd , env , workingDir ) ; } private File createCommandFile ( String [ ] cmd , String [ ] env ) throws IOException { File script = File . createTempFile ( "ANT" , ".COM" ) ; script . deleteOnExit ( ) ; PrintWriter out = null ; try { out = new PrintWriter ( new FileWriter ( script ) ) ; if ( env != null ) { int eqIndex ; for ( int i = 1 ; i < env . length ; i ++ ) { eqIndex = env [ i ] . indexOf ( '=' ) ; if ( eqIndex != - 1 ) { out . print ( "$ DEFINE/NOLOG " ) ; out . print ( env [ i ] . substring ( 0 , eqIndex ) ) ; out . print ( " \"" ) ; out . print ( env [ i ] . substring ( eqIndex + 1 ) ) ; out . println ( '\"' ) ; } } } out . print ( "$ " + cmd [ 0 ] ) ; for ( int i = 1 ; i < cmd . length ; i ++ ) { out . println ( " -" ) ; out . print ( cmd [ i ] ) ; } } finally { if ( out != null ) { out . close ( ) ; } } return script ; } } } 	1	['30', '1', '0', '34', '111', '363', '14', '22', '22', '0.845735027', '1004', '0.789473684', '6', '0', '0.108374384', '0', '0', '31.83333333', '11', '1.9333', '3']
package org . apache . tools . ant . taskdefs . compilers ; import java . io . IOException ; import java . io . OutputStream ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . types . Commandline ; public class Javac12 extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using classic compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupJavacCommand ( true ) ; OutputStream logstr = new LogOutputStream ( attributes , Project . MSG_WARN ) ; try { Class c = Class . forName ( "sun.tools.javac.Main" ) ; Constructor cons = c . getConstructor ( new Class [ ] { OutputStream . class , String . class } ) ; Object compiler = cons . newInstance ( new Object [ ] { logstr , "javac" } ) ; Method compile = c . getMethod ( "compile" , new Class [ ] { String [ ] . class } ) ; Boolean ok = ( Boolean ) compile . invoke ( compiler , new Object [ ] { cmd . getArguments ( ) } ) ; return ok . booleanValue ( ) ; } catch ( ClassNotFoundException ex ) { throw new BuildException ( "Cannot use classic compiler, as it is " + "not available.  A common solution is " + "to set the environment variable" + " JAVA_HOME to your jdk directory." , location ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting classic compiler: " , ex , location ) ; } } finally { try { logstr . close ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } } } 	0	['3', '2', '0', '8', '20', '3', '1', '7', '2', '1', '151', '0', '0', '0.92', '0.5', '0', '0', '48.33333333', '1', '0.6667', '0']
package org . apache . tools . ant ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Enumeration ; import java . util . Iterator ; import java . util . List ; import java . util . StringTokenizer ; import org . apache . tools . ant . util . CollectionUtils ; public class Target implements TaskContainer { private String name ; private String ifCondition = "" ; private String unlessCondition = "" ; private List dependencies = null ; private List children = new ArrayList ( ) ; private Project project ; private String description = null ; public Target ( ) { } public void setProject ( Project project ) { this . project = project ; } public Project getProject ( ) { return project ; } public void setDepends ( String depS ) { if ( depS . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( depS , "," , true ) ; while ( tok . hasMoreTokens ( ) ) { String token = tok . nextToken ( ) . trim ( ) ; if ( token . equals ( "" ) || token . equals ( "," ) ) { throw new BuildException ( "Syntax Error: Depend " + "attribute for target \"" + getName ( ) + "\" has an empty string for dependency." ) ; } addDependency ( token ) ; if ( tok . hasMoreTokens ( ) ) { token = tok . nextToken ( ) ; if ( ! tok . hasMoreTokens ( ) || ! token . equals ( "," ) ) { throw new BuildException ( "Syntax Error: Depend " + "attribute for target \"" + getName ( ) + "\" ends with a , character" ) ; } } } } } public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void addTask ( Task task ) { children . add ( task ) ; } public void addDataType ( RuntimeConfigurable r ) { children . add ( r ) ; } public Task [ ] getTasks ( ) { List tasks = new ArrayList ( children . size ( ) ) ; Iterator it = children . iterator ( ) ; while ( it . hasNext ( ) ) { Object o = it . next ( ) ; if ( o instanceof Task ) { tasks . add ( o ) ; } } return ( Task [ ] ) tasks . toArray ( new Task [ tasks . size ( ) ] ) ; } public void addDependency ( String dependency ) { if ( dependencies == null ) { dependencies = new ArrayList ( 2 ) ; } dependencies . add ( dependency ) ; } public Enumeration getDependencies ( ) { if ( dependencies != null ) { return Collections . enumeration ( dependencies ) ; } else { return new CollectionUtils . EmptyEnumeration ( ) ; } } public boolean dependsOn ( String other ) { if ( getProject ( ) != null ) { List l = getProject ( ) . topoSort ( getName ( ) , getProject ( ) . getTargets ( ) ) ; int myIdx = l . indexOf ( this ) ; int otherIdx = l . indexOf ( getProject ( ) . getTargets ( ) . get ( other ) ) ; return myIdx >= otherIdx ; } return false ; } public void setIf ( String property ) { this . ifCondition = ( property == null ) ? "" : property ; } public void setUnless ( String property ) { this . unlessCondition = ( property == null ) ? "" : property ; } public void setDescription ( String description ) { this . description = description ; } public String getDescription ( ) { return description ; } public String toString ( ) { return name ; } public void execute ( ) throws BuildException { if ( testIfCondition ( ) && testUnlessCondition ( ) ) { for ( int taskPosition = 0 ; taskPosition < children . size ( ) ; ++ taskPosition ) { Object o = children . get ( taskPosition ) ; if ( o instanceof Task ) { Task task = ( Task ) o ; task . perform ( ) ; } else { RuntimeConfigurable r = ( RuntimeConfigurable ) o ; r . maybeConfigure ( project ) ; } } } else if ( ! testIfCondition ( ) ) { project . log ( this , "Skipped because property '" + project . replaceProperties ( this . ifCondition ) + "' not set." , Project . MSG_VERBOSE ) ; } else { project . log ( this , "Skipped because property '" + project . replaceProperties ( this . unlessCondition ) + "' set." , Project . MSG_VERBOSE ) ; } } public final void performTasks ( ) { try { project . fireTargetStarted ( this ) ; execute ( ) ; project . fireTargetFinished ( this , null ) ; } catch ( RuntimeException exc ) { project . fireTargetFinished ( this , exc ) ; throw exc ; } } void replaceChild ( Task el , RuntimeConfigurable o ) { int index ; while ( ( index = children . indexOf ( el ) ) >= 0 ) { children . set ( index , o ) ; } } void replaceChild ( Task el , Task o ) { int index ; while ( ( index = children . indexOf ( el ) ) >= 0 ) { children . set ( index , o ) ; } } private boolean testIfCondition ( ) { if ( "" . equals ( ifCondition ) ) { return true ; } String test = project . replaceProperties ( ifCondition ) ; return project . getProperty ( test ) != null ; } private boolean testUnlessCondition ( ) { if ( "" . equals ( unlessCondition ) ) { return true ; } String test = project . replaceProperties ( unlessCondition ) ; return project . getProperty ( test ) == null ; } } 	1	['23', '1', '0', '32', '57', '147', '28', '6', '19', '0.805194805', '441', '1', '1', '0', '0.313043478', '0', '0', '17.86956522', '8', '1.8696', '2']
package org . apache . tools . ant . types ; public class FileSet extends AbstractFileSet { public FileSet ( ) { super ( ) ; } protected FileSet ( FileSet fileset ) { super ( fileset ) ; } public Object clone ( ) { if ( isReference ( ) ) { return ( ( FileSet ) getRef ( getProject ( ) ) ) . clone ( ) ; } else { return super . clone ( ) ; } } } 	0	['3', '4', '3', '32', '9', '3', '28', '4', '2', '2', '23', '0', '0', '0.988636364', '0.666666667', '3', '4', '6.666666667', '2', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; import java . io . PrintStream ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . CommandlineJava ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Permissions ; import org . apache . tools . ant . util . TimeoutObserver ; import org . apache . tools . ant . util . Watchdog ; public class ExecuteJava implements Runnable , TimeoutObserver { private Commandline javaCommand = null ; private Path classpath = null ; private CommandlineJava . SysProperties sysProperties = null ; private Permissions perm = null ; private Method main = null ; private Long timeout = null ; private Throwable caught = null ; private boolean timedOut = false ; private Thread thread = null ; public void setJavaCommand ( Commandline javaCommand ) { this . javaCommand = javaCommand ; } public void setClasspath ( Path p ) { classpath = p ; } public void setSystemProperties ( CommandlineJava . SysProperties s ) { sysProperties = s ; } public void setPermissions ( Permissions permissions ) { perm = permissions ; } public void setOutput ( PrintStream out ) { } public void setTimeout ( Long timeout ) { this . timeout = timeout ; } public void execute ( Project project ) throws BuildException { final String classname = javaCommand . getExecutable ( ) ; AntClassLoader loader = null ; try { if ( sysProperties != null ) { sysProperties . setSystem ( ) ; } final Class [ ] param = { Class . forName ( "[Ljava.lang.String;" ) } ; Class target = null ; if ( classpath == null ) { target = Class . forName ( classname ) ; } else { loader = project . createClassLoader ( classpath ) ; loader . setParent ( project . getCoreLoader ( ) ) ; loader . setParentFirst ( false ) ; loader . addJavaLibraries ( ) ; loader . setIsolated ( true ) ; loader . setThreadContextLoader ( ) ; loader . forceLoadClass ( classname ) ; target = Class . forName ( classname , true , loader ) ; } main = target . getMethod ( "main" , param ) ; if ( main == null ) { throw new BuildException ( "Could not find main() method in " + classname ) ; } if ( ( main . getModifiers ( ) & Modifier . STATIC ) == 0 ) { throw new BuildException ( "main() method in " + classname + " is not declared static" ) ; } if ( timeout == null ) { run ( ) ; } else { thread = new Thread ( this , "ExecuteJava" ) ; Task currentThreadTask = project . getThreadTask ( Thread . currentThread ( ) ) ; project . registerThreadTask ( thread , currentThreadTask ) ; thread . setDaemon ( true ) ; Watchdog w = new Watchdog ( timeout . longValue ( ) ) ; w . addTimeoutObserver ( this ) ; synchronized ( this ) { thread . start ( ) ; w . start ( ) ; try { wait ( ) ; } catch ( InterruptedException e ) { } if ( timedOut ) { project . log ( "Timeout: sub-process interrupted" , Project . MSG_WARN ) ; } else { thread = null ; w . stop ( ) ; } } } if ( caught != null ) { throw caught ; } } catch ( ClassNotFoundException e ) { throw new BuildException ( "Could not find " + classname + "." + " Make sure you have it in your" + " classpath" ) ; } catch ( SecurityException e ) { throw e ; } catch ( Throwable e ) { throw new BuildException ( e ) ; } finally { if ( loader != null ) { loader . resetThreadContextLoader ( ) ; loader . cleanup ( ) ; } if ( sysProperties != null ) { sysProperties . restoreSystem ( ) ; } } } public void run ( ) { final Object [ ] argument = { javaCommand . getArguments ( ) } ; try { if ( perm != null ) { perm . setSecurityManager ( ) ; } main . invoke ( null , argument ) ; } catch ( InvocationTargetException e ) { Throwable t = e . getTargetException ( ) ; if ( ! ( t instanceof InterruptedException ) ) { caught = t ; } } catch ( Throwable t ) { caught = t ; } finally { if ( perm != null ) { perm . restoreSecurityManager ( ) ; } synchronized ( this ) { notifyAll ( ) ; } } } public synchronized void timeoutOccured ( Watchdog w ) { if ( thread != null ) { timedOut = true ; thread . interrupt ( ) ; } notifyAll ( ) ; } public synchronized boolean killedProcess ( ) { return timedOut ; } } 	1	['11', '1', '0', '11', '54', '17', '1', '10', '11', '0.766666667', '437', '1', '4', '0', '0.191919192', '0', '0', '37.90909091', '7', '1.5455', '2']
package org . apache . tools . ant . input ; import java . util . Vector ; public class MultipleChoiceInputRequest extends InputRequest { private Vector choices = new Vector ( ) ; public MultipleChoiceInputRequest ( String prompt , Vector choices ) { super ( prompt ) ; if ( choices == null ) { throw new IllegalArgumentException ( "choices must not be null" ) ; } this . choices = choices ; } public Vector getChoices ( ) { return choices ; } public boolean isInputValid ( ) { return choices . contains ( getInput ( ) ) ; } } 	0	['3', '2', '0', '3', '8', '0', '2', '1', '3', '0', '32', '1', '0', '0.75', '0.555555556', '0', '0', '9.333333333', '1', '0.6667', '0']
package org . apache . tools . ant ; import java . util . Enumeration ; import java . io . IOException ; public abstract class Task extends ProjectComponent { protected Target target ; protected String description ; protected Location location = Location . UNKNOWN_LOCATION ; protected String taskName ; protected String taskType ; protected RuntimeConfigurable wrapper ; private boolean invalid ; public Task ( ) { } public void setOwningTarget ( Target target ) { this . target = target ; } public Target getOwningTarget ( ) { return target ; } public void setTaskName ( String name ) { this . taskName = name ; } public String getTaskName ( ) { return taskName ; } public void setTaskType ( String type ) { this . taskType = type ; } public void setDescription ( String desc ) { description = desc ; } public String getDescription ( ) { return description ; } public void init ( ) throws BuildException { } public void execute ( ) throws BuildException { } public Location getLocation ( ) { return location ; } public void setLocation ( Location location ) { this . location = location ; } public RuntimeConfigurable getRuntimeConfigurableWrapper ( ) { if ( wrapper == null ) { wrapper = new RuntimeConfigurable ( this , getTaskName ( ) ) ; } return wrapper ; } public void setRuntimeConfigurableWrapper ( RuntimeConfigurable wrapper ) { this . wrapper = wrapper ; } public void maybeConfigure ( ) throws BuildException { if ( ! invalid ) { if ( wrapper != null ) { wrapper . maybeConfigure ( getProject ( ) ) ; } } else { getReplacement ( ) ; } } public void reconfigure ( ) { if ( wrapper != null ) { wrapper . reconfigure ( getProject ( ) ) ; } } protected void handleOutput ( String output ) { log ( output , Project . MSG_INFO ) ; } protected void handleFlush ( String output ) { handleOutput ( output ) ; } protected int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException { return getProject ( ) . defaultInput ( buffer , offset , length ) ; } protected void handleErrorOutput ( String output ) { log ( output , Project . MSG_WARN ) ; } protected void handleErrorFlush ( String output ) { handleErrorOutput ( output ) ; } public void log ( String msg ) { log ( msg , Project . MSG_INFO ) ; } public void log ( String msg , int msgLevel ) { getProject ( ) . log ( this , msg , msgLevel ) ; } public final void perform ( ) { if ( ! invalid ) { try { getProject ( ) . fireTaskStarted ( this ) ; maybeConfigure ( ) ; execute ( ) ; getProject ( ) . fireTaskFinished ( this , null ) ; } catch ( RuntimeException exc ) { if ( exc instanceof BuildException ) { BuildException be = ( BuildException ) exc ; if ( be . getLocation ( ) == Location . UNKNOWN_LOCATION ) { be . setLocation ( getLocation ( ) ) ; } } getProject ( ) . fireTaskFinished ( this , exc ) ; throw exc ; } } else { UnknownElement ue = getReplacement ( ) ; Task task = ue . getTask ( ) ; task . perform ( ) ; } } final void markInvalid ( ) { invalid = true ; } protected final boolean isInvalid ( ) { return invalid ; } private UnknownElement replacement ; private UnknownElement getReplacement ( ) { if ( replacement == null ) { replacement = new UnknownElement ( taskType ) ; replacement . setProject ( getProject ( ) ) ; replacement . setTaskType ( taskType ) ; replacement . setTaskName ( taskName ) ; replacement . setLocation ( location ) ; replacement . setOwningTarget ( target ) ; replacement . setRuntimeConfigurableWrapper ( wrapper ) ; wrapper . setProxy ( replacement ) ; replaceChildren ( wrapper , replacement ) ; target . replaceChild ( this , replacement ) ; replacement . maybeConfigure ( ) ; } return replacement ; } private void replaceChildren ( RuntimeConfigurable wrapper , UnknownElement parentElement ) { Enumeration e = wrapper . getChildren ( ) ; while ( e . hasMoreElements ( ) ) { RuntimeConfigurable childWrapper = ( RuntimeConfigurable ) e . nextElement ( ) ; UnknownElement childElement = new UnknownElement ( childWrapper . getElementTag ( ) ) ; parentElement . addChild ( childElement ) ; childElement . setProject ( getProject ( ) ) ; childElement . setRuntimeConfigurableWrapper ( childWrapper ) ; childWrapper . setProxy ( childElement ) ; replaceChildren ( childWrapper , childElement ) ; } } public String getTaskType ( ) { return taskType ; } protected RuntimeConfigurable getWrapper ( ) { return wrapper ; } } 	1	['30', '2', '59', '138', '52', '361', '135', '7', '20', '0.86637931', '318', '1', '4', '0.236842105', '0.195833333', '1', '3', '9.333333333', '4', '1.2', '1']
package org . apache . tools . mail ; import java . io . IOException ; import java . io . PrintStream ; import java . io . BufferedOutputStream ; import java . io . OutputStream ; import java . net . Socket ; import java . net . InetAddress ; import java . util . Vector ; import java . util . Enumeration ; public class MailMessage { public static final String DEFAULT_HOST = "localhost" ; public static final int DEFAULT_PORT = 25 ; private String host ; private int port = DEFAULT_PORT ; private String from ; private Vector replyto ; private Vector to ; private Vector cc ; private Vector headersKeys ; private Vector headersValues ; private MailPrintStream out ; private SmtpResponseReader in ; private Socket socket ; private static final int OK_READY = 220 ; private static final int OK_HELO = 250 ; private static final int OK_FROM = 250 ; private static final int OK_RCPT_1 = 250 ; private static final int OK_RCPT_2 = 251 ; private static final int OK_DATA = 354 ; private static final int OK_DOT = 250 ; private static final int OK_QUIT = 221 ; public MailMessage ( ) throws IOException { this ( DEFAULT_HOST , DEFAULT_PORT ) ; } public MailMessage ( String host ) throws IOException { this ( host , DEFAULT_PORT ) ; } public MailMessage ( String host , int port ) throws IOException { this . port = port ; this . host = host ; replyto = new Vector ( ) ; to = new Vector ( ) ; cc = new Vector ( ) ; headersKeys = new Vector ( ) ; headersValues = new Vector ( ) ; connect ( ) ; sendHelo ( ) ; } public void setPort ( int port ) { this . port = port ; } public void from ( String from ) throws IOException { sendFrom ( from ) ; this . from = from ; } public void replyto ( String rto ) { this . replyto . addElement ( rto ) ; } public void to ( String to ) throws IOException { sendRcpt ( to ) ; this . to . addElement ( to ) ; } public void cc ( String cc ) throws IOException { sendRcpt ( cc ) ; this . cc . addElement ( cc ) ; } public void bcc ( String bcc ) throws IOException { sendRcpt ( bcc ) ; } public void setSubject ( String subj ) { setHeader ( "Subject" , subj ) ; } public void setHeader ( String name , String value ) { headersKeys . add ( name ) ; headersValues . add ( value ) ; } public PrintStream getPrintStream ( ) throws IOException { setFromHeader ( ) ; setReplyToHeader ( ) ; setToHeader ( ) ; setCcHeader ( ) ; setHeader ( "X-Mailer" , "org.apache.tools.mail.MailMessage (ant.apache.org)" ) ; sendData ( ) ; flushHeaders ( ) ; return out ; } void setFromHeader ( ) { setHeader ( "From" , from ) ; } void setReplyToHeader ( ) { if ( ! replyto . isEmpty ( ) ) { setHeader ( "Reply-To" , vectorToList ( replyto ) ) ; } } void setToHeader ( ) { if ( ! to . isEmpty ( ) ) { setHeader ( "To" , vectorToList ( to ) ) ; } } void setCcHeader ( ) { if ( ! cc . isEmpty ( ) ) { setHeader ( "Cc" , vectorToList ( cc ) ) ; } } String vectorToList ( Vector v ) { StringBuffer buf = new StringBuffer ( ) ; Enumeration e = v . elements ( ) ; while ( e . hasMoreElements ( ) ) { buf . append ( e . nextElement ( ) ) ; if ( e . hasMoreElements ( ) ) { buf . append ( ", " ) ; } } return buf . toString ( ) ; } void flushHeaders ( ) throws IOException { for ( int i = 0 ; i < headersKeys . size ( ) ; i ++ ) { String name = ( String ) headersKeys . elementAt ( i ) ; String value = ( String ) headersValues . elementAt ( i ) ; out . println ( name + ": " + value ) ; } out . println ( ) ; out . flush ( ) ; } public void sendAndClose ( ) throws IOException { try { sendDot ( ) ; sendQuit ( ) ; } finally { disconnect ( ) ; } } static String sanitizeAddress ( String s ) { int paramDepth = 0 ; int start = 0 ; int end = 0 ; int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = s . charAt ( i ) ; if ( c == '(' ) { paramDepth ++ ; if ( start == 0 ) { end = i ; } } else if ( c == ')' ) { paramDepth -- ; if ( end == 0 ) { start = i + 1 ; } } else if ( paramDepth == 0 && c == '<' ) { start = i + 1 ; } else if ( paramDepth == 0 && c == '>' ) { end = i ; } } if ( end == 0 ) { end = len ; } return s . substring ( start , end ) ; } void connect ( ) throws IOException { socket = new Socket ( host , port ) ; out = new MailPrintStream ( new BufferedOutputStream ( socket . getOutputStream ( ) ) ) ; in = new SmtpResponseReader ( socket . getInputStream ( ) ) ; getReady ( ) ; } void getReady ( ) throws IOException { String response = in . getResponse ( ) ; int [ ] ok = { OK_READY } ; if ( ! isResponseOK ( response , ok ) ) { throw new IOException ( "Didn't get introduction from server: " + response ) ; } } void sendHelo ( ) throws IOException { String local = InetAddress . getLocalHost ( ) . getHostName ( ) ; int [ ] ok = { OK_HELO } ; send ( "HELO " + local , ok ) ; } void sendFrom ( String from ) throws IOException { int [ ] ok = { OK_FROM } ; send ( "MAIL FROM: " + "<" + sanitizeAddress ( from ) + ">" , ok ) ; } void sendRcpt ( String rcpt ) throws IOException { int [ ] ok = { OK_RCPT_1 , OK_RCPT_2 } ; send ( "RCPT TO: " + "<" + sanitizeAddress ( rcpt ) + ">" , ok ) ; } void sendData ( ) throws IOException { int [ ] ok = { OK_DATA } ; send ( "DATA" , ok ) ; } void sendDot ( ) throws IOException { int [ ] ok = { OK_DOT } ; send ( "\r\n." , ok ) ; } void sendQuit ( ) throws IOException { int [ ] ok = { OK_QUIT } ; try { send ( "QUIT" , ok ) ; } catch ( IOException e ) { throw new ErrorInQuitException ( e ) ; } } void send ( String msg , int [ ] ok ) throws IOException { out . rawPrint ( msg + "\r\n" ) ; String response = in . getResponse ( ) ; if ( ! isResponseOK ( response , ok ) ) { throw new IOException ( "Unexpected reply to command: " + msg + ": " + response ) ; } } boolean isResponseOK ( String response , int [ ] ok ) { for ( int i = 0 ; i < ok . length ; i ++ ) { if ( response . startsWith ( "" + ok [ i ] ) ) { return true ; } } return false ; } void disconnect ( ) throws IOException { if ( out != null ) { out . close ( ) ; } if ( in != null ) { try { in . close ( ) ; } catch ( IOException e ) { } } if ( socket != null ) { try { socket . close ( ) ; } catch ( IOException e ) { } } } } class MailPrintStream extends PrintStream { private int lastChar ; public MailPrintStream ( OutputStream out ) { super ( out , true ) ; } public void write ( int b ) { if ( b == '\n' && lastChar != '\r' ) { rawWrite ( '\r' ) ; rawWrite ( b ) ; } else if ( b == '.' && lastChar == '\n' ) { rawWrite ( '.' ) ; rawWrite ( b ) ; } else { rawWrite ( b ) ; } lastChar = b ; } public void write ( byte [ ] buf , int off , int len ) { for ( int i = 0 ; i < len ; i ++ ) { write ( buf [ off + i ] ) ; } } void rawWrite ( int b ) { super . write ( b ) ; } void rawPrint ( String s ) { int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { rawWrite ( s . charAt ( i ) ) ; } } } 	0	['31', '1', '0', '5', '68', '407', '2', '3', '13', '0.904761905', '624', '0.904761905', '2', '0', '0.316129032', '0', '0', '18.4516129', '11', '1.4516', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Hashtable ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileUtils ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . xml . sax . SAXException ; public class XmlProperty extends org . apache . tools . ant . Task { private File src ; private String prefix = "" ; private boolean keepRoot = true ; private boolean validate = false ; private boolean collapseAttributes = false ; private boolean semanticAttributes = false ; private boolean includeSemanticAttribute = false ; private File rootDirectory = null ; private FileUtils fileUtils = FileUtils . newFileUtils ( ) ; private Hashtable addedAttributes = new Hashtable ( ) ; private static final String ID = "id" ; private static final String REF_ID = "refid" ; private static final String LOCATION = "location" ; private static final String VALUE = "value" ; private static final String PATH = "path" ; private static final String PATHID = "pathid" ; private static final String [ ] ATTRIBUTES = new String [ ] { ID , REF_ID , LOCATION , VALUE , PATH , PATHID } ; public XmlProperty ( ) { super ( ) ; } public void init ( ) { super . init ( ) ; } public void execute ( ) throws BuildException { if ( getFile ( ) == null ) { String msg = "XmlProperty task requires a file attribute" ; throw new BuildException ( msg ) ; } try { log ( "Loading " + src . getAbsolutePath ( ) , Project . MSG_VERBOSE ) ; if ( src . exists ( ) ) { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; factory . setValidating ( validate ) ; factory . setNamespaceAware ( false ) ; Document document = factory . newDocumentBuilder ( ) . parse ( src ) ; Element topElement = document . getDocumentElement ( ) ; addedAttributes = new Hashtable ( ) ; if ( keepRoot ) { addNodeRecursively ( topElement , prefix , null ) ; } else { NodeList topChildren = topElement . getChildNodes ( ) ; int numChildren = topChildren . getLength ( ) ; for ( int i = 0 ; i < numChildren ; i ++ ) { addNodeRecursively ( topChildren . item ( i ) , prefix , null ) ; } } } else { log ( "Unable to find property file: " + src . getAbsolutePath ( ) , Project . MSG_VERBOSE ) ; } } catch ( SAXException sxe ) { Exception x = sxe ; if ( sxe . getException ( ) != null ) { x = sxe . getException ( ) ; } throw new BuildException ( x ) ; } catch ( ParserConfigurationException pce ) { throw new BuildException ( pce ) ; } catch ( IOException ioe ) { throw new BuildException ( ioe ) ; } } private void addNodeRecursively ( Node node , String prefix , Object container ) { String nodePrefix = prefix ; if ( node . getNodeType ( ) != Node . TEXT_NODE ) { if ( prefix . trim ( ) . length ( ) > 0 ) { nodePrefix += "." ; } nodePrefix += node . getNodeName ( ) ; } Object nodeObject = processNode ( node , nodePrefix , container ) ; if ( node . hasChildNodes ( ) ) { NodeList nodeChildren = node . getChildNodes ( ) ; int numChildren = nodeChildren . getLength ( ) ; for ( int i = 0 ; i < numChildren ; i ++ ) { addNodeRecursively ( nodeChildren . item ( i ) , nodePrefix , nodeObject ) ; } } } void addNodeRecursively ( org . w3c . dom . Node node , String prefix ) { addNodeRecursively ( node , prefix , null ) ; } public Object processNode ( Node node , String prefix , Object container ) { Object addedPath = null ; String id = null ; if ( node . hasAttributes ( ) ) { NamedNodeMap nodeAttributes = node . getAttributes ( ) ; Node idNode = nodeAttributes . getNamedItem ( ID ) ; id = ( semanticAttributes && idNode != null ? idNode . getNodeValue ( ) : null ) ; for ( int i = 0 ; i < nodeAttributes . getLength ( ) ; i ++ ) { Node attributeNode = nodeAttributes . item ( i ) ; if ( ! semanticAttributes ) { String attributeName = getAttributeName ( attributeNode ) ; String attributeValue = getAttributeValue ( attributeNode ) ; addProperty ( prefix + attributeName , attributeValue , null ) ; } else { String nodeName = attributeNode . getNodeName ( ) ; String attributeValue = getAttributeValue ( attributeNode ) ; Path containingPath = ( container != null && container instanceof Path ? ( Path ) container : null ) ; if ( nodeName . equals ( ID ) ) { continue ; } else if ( containingPath != null && nodeName . equals ( PATH ) ) { containingPath . setPath ( attributeValue ) ; } else if ( container instanceof Path && nodeName . equals ( REF_ID ) ) { containingPath . setPath ( attributeValue ) ; } else if ( container instanceof Path && nodeName . equals ( LOCATION ) ) { containingPath . setLocation ( resolveFile ( attributeValue ) ) ; } else if ( nodeName . equals ( PATHID ) ) { if ( container != null ) { throw new BuildException ( "XmlProperty does not " + "support nested paths" ) ; } addedPath = new Path ( getProject ( ) ) ; getProject ( ) . addReference ( attributeValue , addedPath ) ; } else { String attributeName = getAttributeName ( attributeNode ) ; addProperty ( prefix + attributeName , attributeValue , id ) ; } } } } String nodeText = null ; if ( node . getNodeType ( ) == Node . TEXT_NODE ) { nodeText = getAttributeValue ( node ) ; } else if ( ( node . getNodeType ( ) == Node . ELEMENT_NODE ) && ( node . getChildNodes ( ) . getLength ( ) == 1 ) && ( node . getFirstChild ( ) . getNodeType ( ) == Node . CDATA_SECTION_NODE ) ) { nodeText = node . getFirstChild ( ) . getNodeValue ( ) ; } if ( nodeText != null ) { if ( semanticAttributes && id == null && container instanceof String ) { id = ( String ) container ; System . out . println ( "Setting id = " + id ) ; } if ( nodeText . trim ( ) . length ( ) != 0 ) { addProperty ( prefix , nodeText , id ) ; } } return ( addedPath != null ? addedPath : id ) ; } private void addProperty ( String name , String value , String id ) { String msg = name + ":" + value ; if ( id != null ) { msg += ( "(id=" + id + ")" ) ; } log ( msg , Project . MSG_DEBUG ) ; if ( addedAttributes . containsKey ( name ) ) { value = ( String ) addedAttributes . get ( name ) + "," + value ; getProject ( ) . setProperty ( name , value ) ; } else { getProject ( ) . setNewProperty ( name , value ) ; } addedAttributes . put ( name , value ) ; if ( id != null ) { getProject ( ) . addReference ( id , value ) ; } } private String getAttributeName ( Node attributeNode ) { String attributeName = attributeNode . getNodeName ( ) ; if ( semanticAttributes ) { if ( attributeName . equals ( REF_ID ) ) { return "" ; } else if ( ! isSemanticAttribute ( attributeName ) || includeSemanticAttribute ) { return "." + attributeName ; } else { return "" ; } } else if ( collapseAttributes ) { return "." + attributeName ; } else { return "(" + attributeName + ")" ; } } private static boolean isSemanticAttribute ( String attributeName ) { for ( int i = 0 ; i < ATTRIBUTES . length ; i ++ ) { if ( attributeName . equals ( ATTRIBUTES [ i ] ) ) { return true ; } } return false ; } private String getAttributeValue ( Node attributeNode ) { String nodeValue = attributeNode . getNodeValue ( ) . trim ( ) ; if ( semanticAttributes ) { String attributeName = attributeNode . getNodeName ( ) ; nodeValue = getProject ( ) . replaceProperties ( nodeValue ) ; if ( attributeName . equals ( LOCATION ) ) { File f = resolveFile ( nodeValue ) ; return f . getPath ( ) ; } else if ( attributeName . equals ( REF_ID ) ) { Object ref = getProject ( ) . getReference ( nodeValue ) ; if ( ref != null ) { return ref . toString ( ) ; } } } return nodeValue ; } public void setFile ( File src ) { this . src = src ; } public void setPrefix ( String prefix ) { this . prefix = prefix . trim ( ) ; } public void setKeeproot ( boolean keepRoot ) { this . keepRoot = keepRoot ; } public void setValidate ( boolean validate ) { this . validate = validate ; } public void setCollapseAttributes ( boolean collapseAttributes ) { this . collapseAttributes = collapseAttributes ; } public void setSemanticAttributes ( boolean semanticAttributes ) { this . semanticAttributes = semanticAttributes ; } public void setRootDirectory ( File rootDirectory ) { this . rootDirectory = rootDirectory ; } public void setIncludeSemanticAttribute ( boolean includeSemanticAttribute ) { this . includeSemanticAttribute = includeSemanticAttribute ; } protected File getFile ( ) { return this . src ; } protected String getPrefix ( ) { return this . prefix ; } protected boolean getKeeproot ( ) { return this . keepRoot ; } protected boolean getValidate ( ) { return this . validate ; } protected boolean getCollapseAttributes ( ) { return this . collapseAttributes ; } protected boolean getSemanticAttributes ( ) { return this . semanticAttributes ; } protected File getRootDirectory ( ) { return this . rootDirectory ; } protected boolean getIncludeSementicAttribute ( ) { return this . includeSemanticAttribute ; } private File resolveFile ( String fileName ) { if ( rootDirectory == null ) { return getProject ( ) . resolveFile ( fileName ) ; } return fileUtils . resolveFile ( rootDirectory , fileName ) ; } } 	1	['28', '3', '0', '6', '80', '272', '0', '6', '12', '0.928104575', '777', '1', '1', '0.587301587', '0.290123457', '1', '1', '26.14285714', '27', '2.5357', '2']
package org . apache . tools . ant . taskdefs ; public interface XSLTLogger { void log ( String msg ) ; } 	0	['1', '1', '0', '2', '1', '0', '2', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . util ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceFactory ; import java . io . File ; import java . util . Vector ; public class ResourceUtils { public static Resource [ ] selectOutOfDateSources ( ProjectComponent logTo , Resource [ ] source , FileNameMapper mapper , ResourceFactory targets ) { long now = ( new java . util . Date ( ) ) . getTime ( ) ; if ( Os . isFamily ( "windows" ) ) { now += 2000 ; } Vector vresult = new Vector ( ) ; for ( int counter = 0 ; counter < source . length ; counter ++ ) { if ( source [ counter ] . getLastModified ( ) > now ) { logTo . log ( "Warning: " + source [ counter ] . getName ( ) + " modified in the future." , Project . MSG_WARN ) ; } String [ ] targetnames = mapper . mapFileName ( source [ counter ] . getName ( ) . replace ( '/' , File . separatorChar ) ) ; if ( targetnames != null ) { boolean added = false ; StringBuffer targetList = new StringBuffer ( ) ; for ( int ctarget = 0 ; ! added && ctarget < targetnames . length ; ctarget ++ ) { Resource atarget = targets . getResource ( targetnames [ ctarget ] . replace ( File . separatorChar , '/' ) ) ; if ( ! atarget . isExists ( ) ) { logTo . log ( source [ counter ] . getName ( ) + " added as " + atarget . getName ( ) + " doesn\'t exist." , Project . MSG_VERBOSE ) ; vresult . addElement ( source [ counter ] ) ; added = true ; } else if ( ! atarget . isDirectory ( ) && atarget . getLastModified ( ) < source [ counter ] . getLastModified ( ) ) { logTo . log ( source [ counter ] . getName ( ) + " added as " + atarget . getName ( ) + " is outdated." , Project . MSG_VERBOSE ) ; vresult . addElement ( source [ counter ] ) ; added = true ; } else { if ( targetList . length ( ) > 0 ) { targetList . append ( ", " ) ; } targetList . append ( atarget . getName ( ) ) ; } } if ( ! added ) { logTo . log ( source [ counter ] . getName ( ) + " omitted as " + targetList . toString ( ) + ( targetnames . length == 1 ? " is" : " are " ) + " up to date." , Project . MSG_VERBOSE ) ; } } else { logTo . log ( source [ counter ] . getName ( ) + " skipped - don\'t know how to handle it" , Project . MSG_VERBOSE ) ; } } Resource [ ] result = new Resource [ vresult . size ( ) ] ; vresult . copyInto ( result ) ; return result ; } } 	1	['2', '1', '0', '7', '22', '1', '2', '5', '2', '2', '222', '0', '0', '0', '0.5', '0', '0', '110', '12', '6', '2']
package org . apache . tools . ant ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . util . Hashtable ; public class DemuxOutputStream extends OutputStream { private static class BufferInfo { private ByteArrayOutputStream buffer ; private boolean crSeen = false ; } private static final int MAX_SIZE = 1024 ; private static final int INTIAL_SIZE = 132 ; private static final int CR = 0x0d ; private static final int LF = 0x0a ; private Hashtable buffers = new Hashtable ( ) ; private Project project ; private boolean isErrorStream ; public DemuxOutputStream ( Project project , boolean isErrorStream ) { this . project = project ; this . isErrorStream = isErrorStream ; } private BufferInfo getBufferInfo ( ) { Thread current = Thread . currentThread ( ) ; BufferInfo bufferInfo = ( BufferInfo ) buffers . get ( current ) ; if ( bufferInfo == null ) { bufferInfo = new BufferInfo ( ) ; bufferInfo . buffer = new ByteArrayOutputStream ( INTIAL_SIZE ) ; bufferInfo . crSeen = false ; buffers . put ( current , bufferInfo ) ; } return bufferInfo ; } private void resetBufferInfo ( ) { Thread current = Thread . currentThread ( ) ; BufferInfo bufferInfo = ( BufferInfo ) buffers . get ( current ) ; try { bufferInfo . buffer . close ( ) ; } catch ( IOException e ) { } bufferInfo . buffer = new ByteArrayOutputStream ( ) ; bufferInfo . crSeen = false ; } private void removeBuffer ( ) { Thread current = Thread . currentThread ( ) ; buffers . remove ( current ) ; } public void write ( int cc ) throws IOException { final byte c = ( byte ) cc ; BufferInfo bufferInfo = getBufferInfo ( ) ; if ( c == '\n' ) { bufferInfo . buffer . write ( cc ) ; processBuffer ( bufferInfo . buffer ) ; } else { if ( bufferInfo . crSeen ) { processBuffer ( bufferInfo . buffer ) ; } bufferInfo . buffer . write ( cc ) ; } bufferInfo . crSeen = ( c == '\r' ) ; if ( ! bufferInfo . crSeen && bufferInfo . buffer . size ( ) > MAX_SIZE ) { processBuffer ( bufferInfo . buffer ) ; } } protected void processBuffer ( ByteArrayOutputStream buffer ) { String output = buffer . toString ( ) ; project . demuxOutput ( output , isErrorStream ) ; resetBufferInfo ( ) ; } protected void processFlush ( ByteArrayOutputStream buffer ) { String output = buffer . toString ( ) ; project . demuxFlush ( output , isErrorStream ) ; resetBufferInfo ( ) ; } public void close ( ) throws IOException { flush ( ) ; removeBuffer ( ) ; } public void flush ( ) throws IOException { BufferInfo bufferInfo = getBufferInfo ( ) ; if ( bufferInfo . buffer . size ( ) > 0 ) { processFlush ( bufferInfo . buffer ) ; } } public void write ( byte [ ] b , int off , int len ) throws IOException { int offset = off ; int blockStartOffset = offset ; int remaining = len ; BufferInfo bufferInfo = getBufferInfo ( ) ; while ( remaining > 0 ) { while ( remaining > 0 && b [ offset ] != LF && b [ offset ] != CR ) { offset ++ ; remaining -- ; } int blockLength = offset - blockStartOffset ; if ( blockLength > 0 ) { bufferInfo . buffer . write ( b , blockStartOffset , blockLength ) ; } while ( remaining > 0 && ( b [ offset ] == LF || b [ offset ] == CR ) ) { write ( b [ offset ] ) ; offset ++ ; remaining -- ; } blockStartOffset = offset ; } } } 	0	['10', '2', '0', '4', '30', '27', '1', '3', '5', '0.761904762', '252', '1', '1', '0.357142857', '0.283333333', '1', '1', '23.5', '2', '1', '0']
package org . apache . tools . ant . taskdefs . compilers ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Location ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . Javac ; import org . apache . tools . ant . taskdefs . LogStreamHandler ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; public abstract class DefaultCompilerAdapter implements CompilerAdapter { protected Path src ; protected File destDir ; protected String encoding ; protected boolean debug = false ; protected boolean optimize = false ; protected boolean deprecation = false ; protected boolean depend = false ; protected boolean verbose = false ; protected String target ; protected Path bootclasspath ; protected Path extdirs ; protected Path compileClasspath ; protected Path compileSourcepath ; protected Project project ; protected Location location ; protected boolean includeAntRuntime ; protected boolean includeJavaRuntime ; protected String memoryInitialSize ; protected String memoryMaximumSize ; protected File [ ] compileList ; protected static final String lSep = System . getProperty ( "line.separator" ) ; protected Javac attributes ; private FileUtils fileUtils = FileUtils . newFileUtils ( ) ; public void setJavac ( Javac attributes ) { this . attributes = attributes ; src = attributes . getSrcdir ( ) ; destDir = attributes . getDestdir ( ) ; encoding = attributes . getEncoding ( ) ; debug = attributes . getDebug ( ) ; optimize = attributes . getOptimize ( ) ; deprecation = attributes . getDeprecation ( ) ; depend = attributes . getDepend ( ) ; verbose = attributes . getVerbose ( ) ; target = attributes . getTarget ( ) ; bootclasspath = attributes . getBootclasspath ( ) ; extdirs = attributes . getExtdirs ( ) ; compileList = attributes . getFileList ( ) ; compileClasspath = attributes . getClasspath ( ) ; compileSourcepath = attributes . getSourcepath ( ) ; project = attributes . getProject ( ) ; location = attributes . getLocation ( ) ; includeAntRuntime = attributes . getIncludeantruntime ( ) ; includeJavaRuntime = attributes . getIncludejavaruntime ( ) ; memoryInitialSize = attributes . getMemoryInitialSize ( ) ; memoryMaximumSize = attributes . getMemoryMaximumSize ( ) ; } public Javac getJavac ( ) { return attributes ; } protected Project getProject ( ) { return project ; } protected Path getCompileClasspath ( ) { Path classpath = new Path ( project ) ; if ( destDir != null ) { classpath . setLocation ( destDir ) ; } Path cp = compileClasspath ; if ( cp == null ) { cp = new Path ( project ) ; } if ( includeAntRuntime ) { classpath . addExisting ( cp . concatSystemClasspath ( "last" ) ) ; } else { classpath . addExisting ( cp . concatSystemClasspath ( "ignore" ) ) ; } if ( includeJavaRuntime ) { classpath . addJavaRuntime ( ) ; } return classpath ; } protected Commandline setupJavacCommandlineSwitches ( Commandline cmd ) { return setupJavacCommandlineSwitches ( cmd , false ) ; } protected Commandline setupJavacCommandlineSwitches ( Commandline cmd , boolean useDebugLevel ) { Path classpath = getCompileClasspath ( ) ; Path sourcepath = null ; if ( compileSourcepath != null ) { sourcepath = compileSourcepath ; } else { sourcepath = src ; } String memoryParameterPrefix = assumeJava11 ( ) ? "-J-" : "-J-X" ; if ( memoryInitialSize != null ) { if ( ! attributes . isForkedJavac ( ) ) { attributes . log ( "Since fork is false, ignoring " + "memoryInitialSize setting." , Project . MSG_WARN ) ; } else { cmd . createArgument ( ) . setValue ( memoryParameterPrefix + "ms" + memoryInitialSize ) ; } } if ( memoryMaximumSize != null ) { if ( ! attributes . isForkedJavac ( ) ) { attributes . log ( "Since fork is false, ignoring " + "memoryMaximumSize setting." , Project . MSG_WARN ) ; } else { cmd . createArgument ( ) . setValue ( memoryParameterPrefix + "mx" + memoryMaximumSize ) ; } } if ( attributes . getNowarn ( ) ) { cmd . createArgument ( ) . setValue ( "-nowarn" ) ; } if ( deprecation == true ) { cmd . createArgument ( ) . setValue ( "-deprecation" ) ; } if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "-classpath" ) ; if ( assumeJava11 ( ) ) { Path cp = new Path ( project ) ; if ( bootclasspath != null ) { cp . append ( bootclasspath ) ; } if ( extdirs != null ) { cp . addExtdirs ( extdirs ) ; } cp . append ( classpath ) ; cp . append ( sourcepath ) ; cmd . createArgument ( ) . setPath ( cp ) ; } else { cmd . createArgument ( ) . setPath ( classpath ) ; if ( sourcepath . size ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-sourcepath" ) ; cmd . createArgument ( ) . setPath ( sourcepath ) ; } if ( target != null ) { cmd . createArgument ( ) . setValue ( "-target" ) ; cmd . createArgument ( ) . setValue ( target ) ; } if ( bootclasspath != null && bootclasspath . size ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-bootclasspath" ) ; cmd . createArgument ( ) . setPath ( bootclasspath ) ; } if ( extdirs != null && extdirs . size ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-extdirs" ) ; cmd . createArgument ( ) . setPath ( extdirs ) ; } } if ( encoding != null ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( encoding ) ; } if ( debug ) { if ( useDebugLevel && ! assumeJava11 ( ) ) { String debugLevel = attributes . getDebugLevel ( ) ; if ( debugLevel != null ) { cmd . createArgument ( ) . setValue ( "-g:" + debugLevel ) ; } else { cmd . createArgument ( ) . setValue ( "-g" ) ; } } else { cmd . createArgument ( ) . setValue ( "-g" ) ; } } else if ( ! assumeJava11 ( ) ) { cmd . createArgument ( ) . setValue ( "-g:none" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O" ) ; } if ( depend ) { if ( assumeJava11 ( ) ) { cmd . createArgument ( ) . setValue ( "-depend" ) ; } else if ( assumeJava12 ( ) ) { cmd . createArgument ( ) . setValue ( "-Xdepend" ) ; } else { attributes . log ( "depend attribute is not supported by the " + "modern compiler" , Project . MSG_WARN ) ; } } if ( verbose ) { cmd . createArgument ( ) . setValue ( "-verbose" ) ; } addCurrentCompilerArgs ( cmd ) ; return cmd ; } protected Commandline setupModernJavacCommandlineSwitches ( Commandline cmd ) { setupJavacCommandlineSwitches ( cmd , true ) ; if ( attributes . getSource ( ) != null && ! assumeJava13 ( ) ) { cmd . createArgument ( ) . setValue ( "-source" ) ; cmd . createArgument ( ) . setValue ( attributes . getSource ( ) ) ; } return cmd ; } protected Commandline setupModernJavacCommand ( ) { Commandline cmd = new Commandline ( ) ; setupModernJavacCommandlineSwitches ( cmd ) ; logAndAddFilesToCompile ( cmd ) ; return cmd ; } protected Commandline setupJavacCommand ( ) { return setupJavacCommand ( false ) ; } protected Commandline setupJavacCommand ( boolean debugLevelCheck ) { Commandline cmd = new Commandline ( ) ; setupJavacCommandlineSwitches ( cmd , debugLevelCheck ) ; logAndAddFilesToCompile ( cmd ) ; return cmd ; } protected void logAndAddFilesToCompile ( Commandline cmd ) { attributes . log ( "Compilation " + cmd . describeArguments ( ) , Project . MSG_VERBOSE ) ; StringBuffer niceSourceList = new StringBuffer ( "File" ) ; if ( compileList . length != 1 ) { niceSourceList . append ( "s" ) ; } niceSourceList . append ( " to be compiled:" ) ; niceSourceList . append ( lSep ) ; for ( int i = 0 ; i < compileList . length ; i ++ ) { String arg = compileList [ i ] . getAbsolutePath ( ) ; cmd . createArgument ( ) . setValue ( arg ) ; niceSourceList . append ( "    " + arg + lSep ) ; } attributes . log ( niceSourceList . toString ( ) , Project . MSG_VERBOSE ) ; } protected int executeExternalCompile ( String [ ] args , int firstFileName ) { return executeExternalCompile ( args , firstFileName , true ) ; } protected int executeExternalCompile ( String [ ] args , int firstFileName , boolean quoteFiles ) { String [ ] commandArray = null ; File tmpFile = null ; try { if ( Commandline . toString ( args ) . length ( ) > 4096 && firstFileName >= 0 ) { PrintWriter out = null ; try { File userDir = getJavac ( ) . getTempdir ( ) ; if ( userDir == null ) { String userDirName = System . getProperty ( "user.dir" ) ; userDir = new File ( userDirName ) ; } tmpFile = fileUtils . createTempFile ( "files" , "" , userDir ) ; tmpFile . deleteOnExit ( ) ; out = new PrintWriter ( new FileWriter ( tmpFile ) ) ; for ( int i = firstFileName ; i < args . length ; i ++ ) { if ( quoteFiles && args [ i ] . indexOf ( " " ) > - 1 ) { args [ i ] = args [ i ] . replace ( '\\' , '/' ) ; out . println ( "\"" + args [ i ] + "\"" ) ; } else { out . println ( args [ i ] ) ; } } out . flush ( ) ; commandArray = new String [ firstFileName + 1 ] ; System . arraycopy ( args , 0 , commandArray , 0 , firstFileName ) ; commandArray [ firstFileName ] = "@" + tmpFile ; } catch ( IOException e ) { throw new BuildException ( "Error creating temporary file" , e , location ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( Throwable t ) { } } } } else { commandArray = args ; } try { Execute exe = new Execute ( new LogStreamHandler ( attributes , Project . MSG_INFO , Project . MSG_WARN ) ) ; exe . setAntRun ( project ) ; exe . setWorkingDirectory ( project . getBaseDir ( ) ) ; exe . setCommandline ( commandArray ) ; exe . execute ( ) ; return exe . getExitValue ( ) ; } catch ( IOException e ) { throw new BuildException ( "Error running " + args [ 0 ] + " compiler" , e , location ) ; } } finally { if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } protected void addExtdirsToClasspath ( Path classpath ) { classpath . addExtdirs ( extdirs ) ; } protected void addCurrentCompilerArgs ( Commandline cmd ) { cmd . addArguments ( getJavac ( ) . getCurrentCompilerArgs ( ) ) ; } protected boolean assumeJava11 ( ) { return "javac1.1" . equals ( attributes . getCompilerVersion ( ) ) || ( "classic" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) || ( "extJavac" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) ; } protected boolean assumeJava12 ( ) { return "javac1.2" . equals ( attributes . getCompilerVersion ( ) ) || ( "classic" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_2 ) ) || ( "extJavac" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_2 ) ) ; } protected boolean assumeJava13 ( ) { return "javac1.3" . equals ( attributes . getCompilerVersion ( ) ) || ( "classic" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_3 ) ) || ( "modern" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_3 ) ) || ( "extJavac" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_3 ) ) ; } } 	1	['21', '1', '8', '23', '98', '112', '8', '15', '4', '0.730434783', '951', '1', '9', '0', '0.242857143', '0', '0', '43.19047619', '30', '4.0476', '1']
package org . apache . tools . ant . types . selectors ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . BuildException ; import java . io . File ; import java . io . IOException ; public class DifferentSelector extends MappingSelector { private FileUtils fileUtils = FileUtils . newFileUtils ( ) ; private boolean ignoreFileTimes = true ; public void setIgnoreFileTimes ( boolean ignoreFileTimes ) { this . ignoreFileTimes = ignoreFileTimes ; } protected boolean selectionTest ( File srcfile , File destfile ) { if ( srcfile . exists ( ) != destfile . exists ( ) ) { return true ; } if ( srcfile . length ( ) != destfile . length ( ) ) { return true ; } if ( ! ignoreFileTimes ) { boolean sameDate ; sameDate = destfile . lastModified ( ) >= srcfile . lastModified ( ) - granularity && destfile . lastModified ( ) <= srcfile . lastModified ( ) + granularity ; if ( ! sameDate ) { return true ; } } try { return ! fileUtils . contentEquals ( srcfile , destfile ) ; } catch ( IOException e ) { throw new BuildException ( "while comparing " + srcfile + " and " + destfile , e ) ; } } } 	0	['3', '5', '0', '7', '14', '0', '4', '3', '2', '0.25', '92', '1', '1', '0.953488372', '0.555555556', '1', '1', '29', '8', '3', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . Hashtable ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . IdentityMapper ; public class Sync extends Task { private MyCopy _copy ; public void init ( ) throws BuildException { _copy = new MyCopy ( ) ; configureTask ( _copy ) ; _copy . setFiltering ( false ) ; _copy . setIncludeEmptyDirs ( false ) ; _copy . setPreserveLastModified ( true ) ; } private void configureTask ( Task helper ) { helper . setProject ( getProject ( ) ) ; helper . setTaskName ( getTaskName ( ) ) ; helper . setOwningTarget ( getOwningTarget ( ) ) ; helper . init ( ) ; } public void execute ( ) throws BuildException { File toDir = _copy . getToDir ( ) ; Hashtable allFiles = _copy . _dest2src ; boolean noRemovalNecessary = ! toDir . exists ( ) || toDir . list ( ) . length < 1 ; log ( "PASS#1: Copying files to " + toDir , Project . MSG_DEBUG ) ; _copy . execute ( ) ; if ( noRemovalNecessary ) { log ( "NO removing necessary in " + toDir , Project . MSG_DEBUG ) ; return ; } log ( "PASS#2: Removing orphan files from " + toDir , Project . MSG_DEBUG ) ; int [ ] removedFileCount = removeOrphanFiles ( allFiles , toDir ) ; logRemovedCount ( removedFileCount [ 0 ] , "dangling director" , "y" , "ies" ) ; logRemovedCount ( removedFileCount [ 1 ] , "dangling file" , "" , "s" ) ; if ( ! _copy . getIncludeEmptyDirs ( ) ) { log ( "PASS#3: Removing empty directories from " + toDir , Project . MSG_DEBUG ) ; int removedDirCount = removeEmptyDirectories ( toDir , false ) ; logRemovedCount ( removedDirCount , "empty director" , "y" , "ies" ) ; } } private void logRemovedCount ( int count , String prefix , String singularSuffix , String pluralSuffix ) { File toDir = _copy . getToDir ( ) ; String what = ( prefix == null ) ? "" : prefix ; what += ( count < 2 ) ? singularSuffix : pluralSuffix ; if ( count > 0 ) { log ( "Removed " + count + " " + what + " from " + toDir , Project . MSG_INFO ) ; } else { log ( "NO " + what + " to remove from " + toDir , Project . MSG_VERBOSE ) ; } } private int [ ] removeOrphanFiles ( Hashtable nonOrphans , File file ) { int [ ] removedCount = new int [ ] { 0 , 0 , 0 } ; if ( file . isDirectory ( ) ) { File [ ] children = file . listFiles ( ) ; for ( int i = 0 ; i < children . length ; ++ i ) { int [ ] temp = removeOrphanFiles ( nonOrphans , children [ i ] ) ; removedCount [ 0 ] += temp [ 0 ] ; removedCount [ 1 ] += temp [ 1 ] ; removedCount [ 2 ] += temp [ 2 ] ; } if ( nonOrphans . get ( file ) == null && removedCount [ 2 ] == 0 ) { log ( "Removing orphan directory: " + file , Project . MSG_DEBUG ) ; file . delete ( ) ; ++ removedCount [ 0 ] ; } else { removedCount [ 2 ] = 1 ; } } else { if ( nonOrphans . get ( file ) == null ) { log ( "Removing orphan file: " + file , Project . MSG_DEBUG ) ; file . delete ( ) ; ++ removedCount [ 1 ] ; } else { removedCount [ 2 ] = 1 ; } } return removedCount ; } private int removeEmptyDirectories ( File dir , boolean removeIfEmpty ) { int removedCount = 0 ; if ( dir . isDirectory ( ) ) { File [ ] children = dir . listFiles ( ) ; for ( int i = 0 ; i < children . length ; ++ i ) { File file = children [ i ] ; if ( file . isDirectory ( ) ) { removedCount += removeEmptyDirectories ( file , true ) ; } } if ( children . length > 0 ) { children = dir . listFiles ( ) ; } if ( children . length < 1 && removeIfEmpty ) { log ( "Removing empty directory: " + dir , Project . MSG_DEBUG ) ; dir . delete ( ) ; ++ removedCount ; } } return removedCount ; } public void setTodir ( File destDir ) { _copy . setTodir ( destDir ) ; } public void setVerbose ( boolean verbose ) { _copy . setVerbose ( verbose ) ; } public void setOverwrite ( boolean overwrite ) { _copy . setOverwrite ( overwrite ) ; } public void setIncludeEmptyDirs ( boolean includeEmpty ) { _copy . setIncludeEmptyDirs ( includeEmpty ) ; } public void setFailOnError ( boolean failonerror ) { _copy . setFailOnError ( failonerror ) ; } public void addFileset ( FileSet set ) { _copy . addFileset ( set ) ; } public static class MyCopy extends Copy { private Hashtable _dest2src = new Hashtable ( ) ; public MyCopy ( ) { } protected void buildMap ( File fromDir , File toDir , String [ ] names , FileNameMapper mapper , Hashtable map ) { assertTrue ( "No mapper" , mapper instanceof IdentityMapper ) ; super . buildMap ( fromDir , toDir , names , mapper , map ) ; for ( int i = 0 ; i < names . length ; ++ i ) { String name = names [ i ] ; File dest = new File ( toDir , name ) ; _dest2src . put ( dest , fromDir ) ; } } public File getToDir ( ) { return destDir ; } public boolean getIncludeEmptyDirs ( ) { return includeEmpty ; } } private static void assertTrue ( String message , boolean condition ) { if ( ! condition ) { throw new BuildException ( "Assertion Error: " + message ) ; } } } 	1	['15', '3', '0', '8', '49', '33', '1', '8', '9', '0.428571429', '463', '1', '1', '0.725490196', '0.25', '1', '1', '29.8', '7', '1.9333', '3']
package org . apache . tools . ant ; import java . util . EventListener ; public interface BuildListener extends EventListener { void buildStarted ( BuildEvent event ) ; void buildFinished ( BuildEvent event ) ; void targetStarted ( BuildEvent event ) ; void targetFinished ( BuildEvent event ) ; void taskStarted ( BuildEvent event ) ; void taskFinished ( BuildEvent event ) ; void messageLogged ( BuildEvent event ) ; } 	0	['7', '1', '0', '9', '7', '21', '8', '1', '7', '2', '7', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types . selectors . modifiedselector ; import java . util . Comparator ; import java . util . Vector ; import java . util . Iterator ; import java . io . File ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . IntrospectionHelper ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . types . selectors . BaseExtendSelector ; public class ModifiedSelector extends BaseExtendSelector { private Cache cache = null ; private Algorithm algorithm = null ; private Comparator comparator = null ; private boolean update = true ; private boolean selectDirectories = true ; private boolean isConfigured = false ; private AlgorithmName algoName = null ; private CacheName cacheName = null ; private ComparatorName compName = null ; private Vector configParameter = new Vector ( ) ; private Vector specialParameter = new Vector ( ) ; public ModifiedSelector ( ) { } public void verifySettings ( ) { configure ( ) ; if ( cache == null ) { setError ( "Cache must be set." ) ; } else if ( algorithm == null ) { setError ( "Algorithm must be set." ) ; } else if ( ! cache . isValid ( ) ) { setError ( "Cache must be proper configured." ) ; } else if ( ! algorithm . isValid ( ) ) { setError ( "Algorithm must be proper configured." ) ; } } public void configure ( ) { if ( isConfigured ) { return ; } isConfigured = true ; org . apache . tools . ant . Project project = getProject ( ) ; String filename = "cache.properties" ; File cachefile = null ; if ( project != null ) { cachefile = new File ( project . getBaseDir ( ) , filename ) ; } else { cachefile = new File ( filename ) ; } cache = new PropertiesfileCache ( cachefile ) ; algorithm = new DigestAlgorithm ( ) ; comparator = new EqualComparator ( ) ; update = true ; selectDirectories = true ; for ( Iterator itConfig = configParameter . iterator ( ) ; itConfig . hasNext ( ) ; ) { Parameter par = ( Parameter ) itConfig . next ( ) ; if ( par . getName ( ) . indexOf ( "." ) > 0 ) { specialParameter . add ( par ) ; } else { useParameter ( par ) ; } } configParameter = new Vector ( ) ; String className = null ; String pkg = "org.apache.tools.ant.types.selectors.cacheselector" ; if ( algorithm == null ) { if ( "hashvalue" . equals ( algoName . getValue ( ) ) ) { className = pkg + ".HashvalueAlgorithm" ; } else if ( "digest" . equals ( algoName . getValue ( ) ) ) { className = pkg + ".DigestAlgorithm" ; } if ( className != null ) { try { algorithm = ( Algorithm ) Class . forName ( className ) . newInstance ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } if ( cache == null ) { if ( "propertyfile" . equals ( cacheName . getValue ( ) ) ) { className = pkg + ".PropertiesfileCache" ; } if ( className != null ) { try { cache = ( Cache ) Class . forName ( className ) . newInstance ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } if ( comparator == null ) { if ( "equal" . equals ( compName . getValue ( ) ) ) { className = pkg + ".EqualComparator" ; } else if ( "role" . equals ( compName . getValue ( ) ) ) { className = "java.text.RuleBasedCollator" ; } if ( className != null ) { try { comparator = ( Comparator ) Class . forName ( className ) . newInstance ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } for ( Iterator itSpecial = specialParameter . iterator ( ) ; itSpecial . hasNext ( ) ; ) { Parameter par = ( Parameter ) itSpecial . next ( ) ; useParameter ( par ) ; } specialParameter = new Vector ( ) ; } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; File f = new File ( basedir , filename ) ; if ( f . isDirectory ( ) ) { return selectDirectories ; } String cachedValue = String . valueOf ( cache . get ( f . getAbsolutePath ( ) ) ) ; String newValue = algorithm . getValue ( f ) ; boolean rv = ( comparator . compare ( cachedValue , newValue ) != 0 ) ; if ( update && ! cachedValue . equals ( newValue ) ) { cache . put ( f . getAbsolutePath ( ) , newValue ) ; cache . save ( ) ; } return rv ; } public void setUpdate ( boolean update ) { this . update = update ; } public void setSeldirs ( boolean seldirs ) { selectDirectories = seldirs ; } public void addParam ( String key , Object value ) { Parameter par = new Parameter ( ) ; par . setName ( key ) ; par . setValue ( String . valueOf ( value ) ) ; configParameter . add ( par ) ; } public void addParam ( Parameter parameter ) { configParameter . add ( parameter ) ; } public void setParameters ( Parameter [ ] parameters ) { if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { configParameter . add ( parameters [ i ] ) ; } } } public void useParameter ( Parameter parameter ) { String key = parameter . getName ( ) ; String value = parameter . getValue ( ) ; if ( "cache" . equals ( key ) ) { CacheName cn = new CacheName ( ) ; cn . setValue ( value ) ; setCache ( cn ) ; } else if ( "algorithm" . equals ( key ) ) { AlgorithmName an = new AlgorithmName ( ) ; an . setValue ( value ) ; setAlgorithm ( an ) ; } else if ( "comparator" . equals ( key ) ) { ComparatorName cn = new ComparatorName ( ) ; cn . setValue ( value ) ; setComparator ( cn ) ; } else if ( "update" . equals ( key ) ) { boolean updateValue = ( "true" . equalsIgnoreCase ( value ) ) ? true : false ; setUpdate ( updateValue ) ; } else if ( "seldirs" . equals ( key ) ) { boolean sdValue = ( "true" . equalsIgnoreCase ( value ) ) ? true : false ; setSeldirs ( sdValue ) ; } else if ( key . startsWith ( "cache." ) ) { String name = key . substring ( 6 ) ; tryToSetAParameter ( cache , name , value ) ; } else if ( key . startsWith ( "algorithm." ) ) { String name = key . substring ( 10 ) ; tryToSetAParameter ( algorithm , name , value ) ; } else if ( key . startsWith ( "comparator." ) ) { String name = key . substring ( 11 ) ; tryToSetAParameter ( comparator , name , value ) ; } else { setError ( "Invalid parameter " + key ) ; } } protected void tryToSetAParameter ( Object obj , String name , String value ) { Project prj = ( getProject ( ) != null ) ? getProject ( ) : new Project ( ) ; IntrospectionHelper iHelper = IntrospectionHelper . getHelper ( prj , obj . getClass ( ) ) ; try { iHelper . setAttribute ( prj , obj , name , value ) ; } catch ( org . apache . tools . ant . BuildException e ) { } } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{modifiedselector" ) ; buf . append ( " update=" ) . append ( update ) ; buf . append ( " seldirs=" ) . append ( selectDirectories ) ; buf . append ( " cache=" ) . append ( cache ) ; buf . append ( " algorithm=" ) . append ( algorithm ) ; buf . append ( " comparator=" ) . append ( comparator ) ; buf . append ( "}" ) ; return buf . toString ( ) ; } public Cache getCache ( ) { return cache ; } public void setCache ( CacheName name ) { cacheName = name ; } public static class CacheName extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "propertyfile" } ; } } public Algorithm getAlgorithm ( ) { return algorithm ; } public void setAlgorithm ( AlgorithmName name ) { algoName = name ; } public static class AlgorithmName extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "hashvalue" , "digest" } ; } } public Comparator getComparator ( ) { return comparator ; } public void setComparator ( ComparatorName name ) { compName = name ; } public static class ComparatorName extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "equal" , "rule" } ; } } } 	1	['18', '5', '0', '21', '71', '43', '5', '16', '17', '0.727272727', '661', '1', '5', '0.690909091', '0.177777778', '2', '4', '35.11111111', '17', '3', '3']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; public class Contains implements Condition { private String string , subString ; private boolean caseSensitive = true ; public void setString ( String string ) { this . string = string ; } public void setSubstring ( String subString ) { this . subString = subString ; } public void setCasesensitive ( boolean b ) { caseSensitive = b ; } public boolean eval ( ) throws BuildException { if ( string == null || subString == null ) { throw new BuildException ( "both string and substring are required " + "in contains" ) ; } return caseSensitive ? string . indexOf ( subString ) > - 1 : string . toLowerCase ( ) . indexOf ( subString . toLowerCase ( ) ) > - 1 ; } } 	0	['5', '1', '0', '3', '9', '0', '1', '2', '5', '0.666666667', '64', '1', '0', '0', '0.533333333', '0', '0', '11.2', '1', '0.8', '0']
package org . apache . tools . ant . types ; import java . util . Properties ; import java . util . Stack ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileNameMapper ; public class Mapper extends DataType implements Cloneable { protected MapperType type = null ; public Mapper ( Project p ) { setProject ( p ) ; } public void setType ( MapperType type ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . type = type ; } protected String classname = null ; public void setClassname ( String classname ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . classname = classname ; } protected Path classpath = null ; public void setClasspath ( Path classpath ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createClasspath ( ) . setRefid ( r ) ; } protected String from = null ; public void setFrom ( String from ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . from = from ; } protected String to = null ; public void setTo ( String to ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . to = to ; } public void setRefid ( Reference r ) throws BuildException { if ( type != null || from != null || to != null ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public FileNameMapper getImplementation ( ) throws BuildException { if ( isReference ( ) ) { return getRef ( ) . getImplementation ( ) ; } if ( type == null && classname == null ) { throw new BuildException ( "one of the attributes type or classname is required" ) ; } if ( type != null && classname != null ) { throw new BuildException ( "must not specify both type and classname attribute" ) ; } try { if ( type != null ) { classname = type . getImplementation ( ) ; } Class c = null ; if ( classpath == null ) { c = Class . forName ( classname ) ; } else { AntClassLoader al = getProject ( ) . createClassLoader ( classpath ) ; c = Class . forName ( classname , true , al ) ; } FileNameMapper m = ( FileNameMapper ) c . newInstance ( ) ; final Project project = getProject ( ) ; if ( project != null ) { project . setProjectReference ( m ) ; } m . setFrom ( from ) ; m . setTo ( to ) ; return m ; } catch ( BuildException be ) { throw be ; } catch ( Throwable t ) { throw new BuildException ( t ) ; } finally { if ( type != null ) { classname = null ; } } } protected Mapper getRef ( ) { if ( ! isChecked ( ) ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , getProject ( ) ) ; } Object o = getRefid ( ) . getReferencedObject ( getProject ( ) ) ; if ( ! ( o instanceof Mapper ) ) { String msg = getRefid ( ) . getRefId ( ) + " doesn\'t denote a mapper" ; throw new BuildException ( msg ) ; } else { return ( Mapper ) o ; } } public static class MapperType extends EnumeratedAttribute { private Properties implementations ; public MapperType ( ) { implementations = new Properties ( ) ; implementations . put ( "identity" , "org.apache.tools.ant.util.IdentityMapper" ) ; implementations . put ( "flatten" , "org.apache.tools.ant.util.FlatFileNameMapper" ) ; implementations . put ( "glob" , "org.apache.tools.ant.util.GlobPatternMapper" ) ; implementations . put ( "merge" , "org.apache.tools.ant.util.MergingMapper" ) ; implementations . put ( "regexp" , "org.apache.tools.ant.util.RegexpPatternMapper" ) ; implementations . put ( "package" , "org.apache.tools.ant.util.PackageNameMapper" ) ; implementations . put ( "unpackage" , "org.apache.tools.ant.util.UnPackageNameMapper" ) ; } public String [ ] getValues ( ) { return new String [ ] { "identity" , "flatten" , "glob" , "merge" , "regexp" , "package" , "unpackage" } ; } public String getImplementation ( ) { return implementations . getProperty ( getValue ( ) ) ; } } } 	1	['11', '3', '0', '16', '42', '17', '7', '9', '10', '0.7', '291', '1', '2', '0.75', '0.287878788', '1', '1', '25', '3', '1.9091', '1']
package org . apache . tools . ant . taskdefs ; import java . io . IOException ; import java . net . URL ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ComponentHelper ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . helper . ProjectHelper2 ; import org . apache . tools . ant . UnknownElement ; public class Antlib extends Task implements TaskContainer { public static final String TAG = "antlib" ; public static Antlib createAntlib ( Project project , URL antlibUrl , String uri ) { try { antlibUrl . openConnection ( ) . connect ( ) ; } catch ( IOException ex ) { throw new BuildException ( "Unable to find " + antlibUrl , ex ) ; } ComponentHelper helper = ComponentHelper . getComponentHelper ( project ) ; helper . enterAntLib ( uri ) ; try { ProjectHelper2 parser = new ProjectHelper2 ( ) ; UnknownElement ue = parser . parseUnknownElement ( project , antlibUrl ) ; if ( ! ( ue . getTag ( ) . equals ( TAG ) ) ) { throw new BuildException ( "Unexpected tag " + ue . getTag ( ) + " expecting " + TAG , ue . getLocation ( ) ) ; } Antlib antlib = new Antlib ( ) ; antlib . setProject ( project ) ; antlib . setLocation ( ue . getLocation ( ) ) ; antlib . init ( ) ; ue . configure ( antlib ) ; return antlib ; } finally { helper . exitAntLib ( ) ; } } private ClassLoader classLoader ; private String uri = "" ; private List tasks = new ArrayList ( ) ; protected void setClassLoader ( ClassLoader classLoader ) { this . classLoader = classLoader ; } protected void setURI ( String uri ) { this . uri = uri ; } private ClassLoader getClassLoader ( ) { if ( classLoader == null ) { classLoader = Antlib . class . getClassLoader ( ) ; } return classLoader ; } public void addTask ( Task nestedTask ) { tasks . add ( nestedTask ) ; } public void execute ( ) { for ( Iterator i = tasks . iterator ( ) ; i . hasNext ( ) ; ) { UnknownElement ue = ( UnknownElement ) i . next ( ) ; setLocation ( ue . getLocation ( ) ) ; ue . maybeConfigure ( ) ; Object configuredObject = ue . getRealThing ( ) ; if ( configuredObject == null ) { continue ; } if ( ! ( configuredObject instanceof AntlibDefinition ) ) { throw new BuildException ( "Invalid task in antlib " + ue . getTag ( ) + " " + configuredObject . getClass ( ) + " does not " + "extend org.apache.tools.ant.taskdefs.AntlibDefinition" ) ; } AntlibDefinition def = ( AntlibDefinition ) configuredObject ; def . setURI ( uri ) ; def . setAntlibClassLoader ( getClassLoader ( ) ) ; def . init ( ) ; def . execute ( ) ; } } } 	0	['8', '3', '0', '11', '45', '16', '1', '10', '4', '0.771428571', '216', '0.6', '0', '0.840909091', '0.270833333', '1', '1', '25.375', '4', '1.875', '0']
package org . apache . tools . ant . taskdefs ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . UnsupportedEncodingException ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . Reader ; import java . util . Enumeration ; import java . util . Vector ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . ZipFileSet ; import org . apache . tools . zip . ZipOutputStream ; public class Jar extends Zip { private static final String INDEX_NAME = "META-INF/INDEX.LIST" ; private static final String MANIFEST_NAME = "META-INF/MANIFEST.MF" ; private Manifest configuredManifest ; private Manifest savedConfiguredManifest ; private Manifest filesetManifest ; private Manifest originalManifest ; private FilesetManifestConfig filesetManifestConfig ; private boolean mergeManifestsMain = true ; private Manifest manifest ; private String manifestEncoding ; private File manifestFile ; private boolean index = false ; private boolean createEmpty = false ; private Vector rootEntries ; public Jar ( ) { super ( ) ; archiveType = "jar" ; emptyBehavior = "create" ; setEncoding ( "UTF8" ) ; rootEntries = new Vector ( ) ; } public void setWhenempty ( WhenEmpty we ) { log ( "JARs are never empty, they contain at least a manifest file" , Project . MSG_WARN ) ; } public void setJarfile ( File jarFile ) { setDestFile ( jarFile ) ; } public void setIndex ( boolean flag ) { index = flag ; } public void setManifestEncoding ( String manifestEncoding ) { this . manifestEncoding = manifestEncoding ; } public void addConfiguredManifest ( Manifest newManifest ) throws ManifestException { if ( configuredManifest == null ) { configuredManifest = newManifest ; } else { configuredManifest . merge ( newManifest ) ; } savedConfiguredManifest = configuredManifest ; } public void setManifest ( File manifestFile ) { if ( ! manifestFile . exists ( ) ) { throw new BuildException ( "Manifest file: " + manifestFile + " does not exist." , getLocation ( ) ) ; } this . manifestFile = manifestFile ; } private Manifest getManifest ( File manifestFile ) { Manifest newManifest = null ; FileInputStream fis = null ; InputStreamReader isr = null ; try { fis = new FileInputStream ( manifestFile ) ; if ( manifestEncoding == null ) { isr = new InputStreamReader ( fis ) ; } else { isr = new InputStreamReader ( fis , manifestEncoding ) ; } newManifest = getManifest ( isr ) ; } catch ( UnsupportedEncodingException e ) { throw new BuildException ( "Unsupported encoding while reading manifest: " + e . getMessage ( ) , e ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to read manifest file: " + manifestFile + " (" + e . getMessage ( ) + ")" , e ) ; } finally { if ( isr != null ) { try { isr . close ( ) ; } catch ( IOException e ) { } } } return newManifest ; } private Manifest getManifestFromJar ( File jarFile ) throws IOException { ZipFile zf = null ; try { zf = new ZipFile ( jarFile ) ; Enumeration e = zf . entries ( ) ; while ( e . hasMoreElements ( ) ) { ZipEntry ze = ( ZipEntry ) e . nextElement ( ) ; if ( ze . getName ( ) . equalsIgnoreCase ( MANIFEST_NAME ) ) { InputStreamReader isr = new InputStreamReader ( zf . getInputStream ( ze ) , "UTF-8" ) ; return getManifest ( isr ) ; } } return null ; } finally { if ( zf != null ) { try { zf . close ( ) ; } catch ( IOException e ) { } } } } private Manifest getManifest ( Reader r ) { Manifest newManifest = null ; try { newManifest = new Manifest ( r ) ; } catch ( ManifestException e ) { log ( "Manifest is invalid: " + e . getMessage ( ) , Project . MSG_ERR ) ; throw new BuildException ( "Invalid Manifest: " + manifestFile , e , getLocation ( ) ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to read manifest file" + " (" + e . getMessage ( ) + ")" , e ) ; } return newManifest ; } public void setFilesetmanifest ( FilesetManifestConfig config ) { filesetManifestConfig = config ; mergeManifestsMain = "merge" . equals ( config . getValue ( ) ) ; if ( filesetManifestConfig != null && ! filesetManifestConfig . getValue ( ) . equals ( "skip" ) ) { doubleFilePass = true ; } } public void addMetainf ( ZipFileSet fs ) { fs . setPrefix ( "META-INF/" ) ; super . addFileset ( fs ) ; } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( ! skipWriting ) { Manifest jarManifest = createManifest ( ) ; writeManifest ( zOut , jarManifest ) ; } } private Manifest createManifest ( ) throws BuildException { try { Manifest finalManifest = Manifest . getDefaultManifest ( ) ; if ( manifest == null ) { if ( manifestFile != null ) { manifest = getManifest ( manifestFile ) ; } } if ( isInUpdateMode ( ) ) { finalManifest . merge ( originalManifest ) ; } finalManifest . merge ( filesetManifest ) ; finalManifest . merge ( configuredManifest ) ; finalManifest . merge ( manifest , ! mergeManifestsMain ) ; return finalManifest ; } catch ( ManifestException e ) { log ( "Manifest is invalid: " + e . getMessage ( ) , Project . MSG_ERR ) ; throw new BuildException ( "Invalid Manifest" , e , getLocation ( ) ) ; } } private void writeManifest ( ZipOutputStream zOut , Manifest manifest ) throws IOException { for ( Enumeration e = manifest . getWarnings ( ) ; e . hasMoreElements ( ) ; ) { log ( "Manifest warning: " + ( String ) e . nextElement ( ) , Project . MSG_WARN ) ; } zipDir ( null , zOut , "META-INF/" , ZipFileSet . DEFAULT_DIR_MODE ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; OutputStreamWriter osw = new OutputStreamWriter ( baos , "UTF-8" ) ; PrintWriter writer = new PrintWriter ( osw ) ; manifest . write ( writer ) ; writer . flush ( ) ; ByteArrayInputStream bais = new ByteArrayInputStream ( baos . toByteArray ( ) ) ; super . zipFile ( bais , zOut , MANIFEST_NAME , System . currentTimeMillis ( ) , null , ZipFileSet . DEFAULT_FILE_MODE ) ; super . initZipOutputStream ( zOut ) ; } protected void finalizeZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( index ) { createIndexList ( zOut ) ; } } private void createIndexList ( ZipOutputStream zOut ) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; PrintWriter writer = new PrintWriter ( new OutputStreamWriter ( baos , "UTF8" ) ) ; writer . println ( "JarIndex-Version: 1.0" ) ; writer . println ( ) ; writer . println ( zipFile . getName ( ) ) ; Enumeration e = addedDirs . keys ( ) ; while ( e . hasMoreElements ( ) ) { String dir = ( String ) e . nextElement ( ) ; dir = dir . replace ( '\\' , '/' ) ; int pos = dir . lastIndexOf ( '/' ) ; if ( pos != - 1 ) { dir = dir . substring ( 0 , pos ) ; } if ( dir . startsWith ( "META-INF" ) ) { continue ; } writer . println ( dir ) ; } e = rootEntries . elements ( ) ; while ( e . hasMoreElements ( ) ) { writer . println ( e . nextElement ( ) ) ; } writer . flush ( ) ; ByteArrayInputStream bais = new ByteArrayInputStream ( baos . toByteArray ( ) ) ; super . zipFile ( bais , zOut , INDEX_NAME , System . currentTimeMillis ( ) , null , ZipFileSet . DEFAULT_FILE_MODE ) ; } protected void zipFile ( InputStream is , ZipOutputStream zOut , String vPath , long lastModified , File fromArchive , int mode ) throws IOException { if ( MANIFEST_NAME . equalsIgnoreCase ( vPath ) ) { if ( ! doubleFilePass || ( doubleFilePass && skipWriting ) ) { filesetManifest ( fromArchive , is ) ; } } else if ( INDEX_NAME . equalsIgnoreCase ( vPath ) && index ) { log ( "Warning: selected " + archiveType + " files include a META-INF/INDEX.LIST which will" + " be replaced by a newly generated one." , Project . MSG_WARN ) ; } else { if ( index && vPath . indexOf ( "/" ) == - 1 ) { rootEntries . addElement ( vPath ) ; } super . zipFile ( is , zOut , vPath , lastModified , fromArchive , mode ) ; } } private void filesetManifest ( File file , InputStream is ) throws IOException { if ( manifestFile != null && manifestFile . equals ( file ) ) { log ( "Found manifest " + file , Project . MSG_VERBOSE ) ; try { if ( is != null ) { InputStreamReader isr ; if ( manifestEncoding == null ) { isr = new InputStreamReader ( is ) ; } else { isr = new InputStreamReader ( is , manifestEncoding ) ; } manifest = getManifest ( isr ) ; } else { manifest = getManifest ( file ) ; } } catch ( UnsupportedEncodingException e ) { throw new BuildException ( "Unsupported encoding while reading " + "manifest: " + e . getMessage ( ) , e ) ; } } else if ( filesetManifestConfig != null && ! filesetManifestConfig . getValue ( ) . equals ( "skip" ) ) { log ( "Found manifest to merge in file " + file , Project . MSG_VERBOSE ) ; try { Manifest newManifest = null ; if ( is != null ) { InputStreamReader isr ; if ( manifestEncoding == null ) { isr = new InputStreamReader ( is ) ; } else { isr = new InputStreamReader ( is , manifestEncoding ) ; } newManifest = getManifest ( isr ) ; } else { newManifest = getManifest ( file ) ; } if ( filesetManifest == null ) { filesetManifest = newManifest ; } else { filesetManifest . merge ( newManifest ) ; } } catch ( UnsupportedEncodingException e ) { throw new BuildException ( "Unsupported encoding while reading " + "manifest: " + e . getMessage ( ) , e ) ; } catch ( ManifestException e ) { log ( "Manifest in file " + file + " is invalid: " + e . getMessage ( ) , Project . MSG_ERR ) ; throw new BuildException ( "Invalid Manifest" , e , getLocation ( ) ) ; } } else { } } protected ArchiveState getResourcesToAdd ( FileSet [ ] filesets , File zipFile , boolean needsUpdate ) throws BuildException { if ( zipFile . exists ( ) ) { try { originalManifest = getManifestFromJar ( zipFile ) ; if ( originalManifest == null ) { log ( "Updating jar since the current jar has no manifest" , Project . MSG_VERBOSE ) ; needsUpdate = true ; } else { Manifest mf = createManifest ( ) ; if ( ! mf . equals ( originalManifest ) ) { log ( "Updating jar since jar manifest has changed" , Project . MSG_VERBOSE ) ; needsUpdate = true ; } } } catch ( Throwable t ) { log ( "error while reading original manifest: " + t . getMessage ( ) , Project . MSG_WARN ) ; needsUpdate = true ; } } else { needsUpdate = true ; } createEmpty = needsUpdate ; return super . getResourcesToAdd ( filesets , zipFile , needsUpdate ) ; } protected boolean createEmptyZip ( File zipFile ) throws BuildException { if ( ! createEmpty ) { return true ; } ZipOutputStream zOut = null ; try { log ( "Building MANIFEST-only jar: " + getDestFile ( ) . getAbsolutePath ( ) ) ; zOut = new ZipOutputStream ( new FileOutputStream ( getDestFile ( ) ) ) ; zOut . setEncoding ( getEncoding ( ) ) ; if ( isCompress ( ) ) { zOut . setMethod ( ZipOutputStream . DEFLATED ) ; } else { zOut . setMethod ( ZipOutputStream . STORED ) ; } initZipOutputStream ( zOut ) ; finalizeZipOutputStream ( zOut ) ; } catch ( IOException ioe ) { throw new BuildException ( "Could not create almost empty JAR archive" + " (" + ioe . getMessage ( ) + ")" , ioe , getLocation ( ) ) ; } finally { try { if ( zOut != null ) { zOut . close ( ) ; } } catch ( IOException ex ) { } createEmpty = false ; } return true ; } protected void cleanUp ( ) { super . cleanUp ( ) ; if ( ! doubleFilePass || ( doubleFilePass && ! skipWriting ) ) { manifest = null ; configuredManifest = savedConfiguredManifest ; filesetManifest = null ; originalManifest = null ; } rootEntries . removeAllElements ( ) ; } public void reset ( ) { super . reset ( ) ; configuredManifest = null ; filesetManifestConfig = null ; mergeManifestsMain = false ; manifestFile = null ; index = false ; } public static class FilesetManifestConfig extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "skip" , "merge" , "mergewithoutmain" } ; } } } 	1	['23', '5', '2', '15', '99', '165', '2', '13', '10', '0.814935065', '1007', '1', '6', '0.850340136', '0.158385093', '3', '13', '42.17391304', '5', '1.3913', '3']
package org . apache . tools . ant . taskdefs . cvslib ; import org . apache . tools . ant . BuildException ; public class CvsUser { private String m_userID ; private String m_displayName ; public void setDisplayname ( final String displayName ) { m_displayName = displayName ; } public void setUserid ( final String userID ) { m_userID = userID ; } String getUserID ( ) { return m_userID ; } String getDisplayname ( ) { return m_displayName ; } void validate ( ) throws BuildException { if ( null == m_userID ) { final String message = "Username attribute must be set." ; throw new BuildException ( message ) ; } if ( null == m_displayName ) { final String message = "Displayname attribute must be set for userID " + m_userID ; throw new BuildException ( message ) ; } } } 	0	['6', '1', '0', '2', '11', '3', '1', '1', '3', '0.6', '56', '1', '0', '0', '0.666666667', '0', '0', '8', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . PatternSet ; import org . apache . tools . ant . types . selectors . AndSelector ; import org . apache . tools . ant . types . selectors . ContainsRegexpSelector ; import org . apache . tools . ant . types . selectors . ContainsSelector ; import org . apache . tools . ant . types . selectors . DateSelector ; import org . apache . tools . ant . types . selectors . DependSelector ; import org . apache . tools . ant . types . selectors . DepthSelector ; import org . apache . tools . ant . types . selectors . ExtendSelector ; import org . apache . tools . ant . types . selectors . FilenameSelector ; import org . apache . tools . ant . types . selectors . MajoritySelector ; import org . apache . tools . ant . types . selectors . NoneSelector ; import org . apache . tools . ant . types . selectors . NotSelector ; import org . apache . tools . ant . types . selectors . OrSelector ; import org . apache . tools . ant . types . selectors . PresentSelector ; import org . apache . tools . ant . types . selectors . SelectSelector ; import org . apache . tools . ant . types . selectors . SizeSelector ; import org . apache . tools . ant . types . selectors . FileSelector ; import org . apache . tools . ant . types . selectors . modifiedselector . ModifiedSelector ; public class Delete extends MatchingTask { private static final int DELETE_RETRY_SLEEP_MILLIS = 10 ; protected File file = null ; protected File dir = null ; protected Vector filesets = new Vector ( ) ; protected boolean usedMatchingTask = false ; protected boolean includeEmpty = false ; private int verbosity = Project . MSG_VERBOSE ; private boolean quiet = false ; private boolean failonerror = true ; public void setFile ( File file ) { this . file = file ; } public void setDir ( File dir ) { this . dir = dir ; } public void setVerbose ( boolean verbose ) { if ( verbose ) { this . verbosity = Project . MSG_INFO ; } else { this . verbosity = Project . MSG_VERBOSE ; } } public void setQuiet ( boolean quiet ) { this . quiet = quiet ; if ( quiet ) { this . failonerror = false ; } } public void setFailOnError ( boolean failonerror ) { this . failonerror = failonerror ; } public void setIncludeEmptyDirs ( boolean includeEmpty ) { this . includeEmpty = includeEmpty ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public PatternSet . NameEntry createInclude ( ) { usedMatchingTask = true ; return super . createInclude ( ) ; } public PatternSet . NameEntry createIncludesFile ( ) { usedMatchingTask = true ; return super . createIncludesFile ( ) ; } public PatternSet . NameEntry createExclude ( ) { usedMatchingTask = true ; return super . createExclude ( ) ; } public PatternSet . NameEntry createExcludesFile ( ) { usedMatchingTask = true ; return super . createExcludesFile ( ) ; } public PatternSet createPatternSet ( ) { usedMatchingTask = true ; return super . createPatternSet ( ) ; } public void setIncludes ( String includes ) { usedMatchingTask = true ; super . setIncludes ( includes ) ; } public void setExcludes ( String excludes ) { usedMatchingTask = true ; super . setExcludes ( excludes ) ; } public void setDefaultexcludes ( boolean useDefaultExcludes ) { usedMatchingTask = true ; super . setDefaultexcludes ( useDefaultExcludes ) ; } public void setIncludesfile ( File includesfile ) { usedMatchingTask = true ; super . setIncludesfile ( includesfile ) ; } public void setExcludesfile ( File excludesfile ) { usedMatchingTask = true ; super . setExcludesfile ( excludesfile ) ; } public void setCaseSensitive ( boolean isCaseSensitive ) { usedMatchingTask = true ; super . setCaseSensitive ( isCaseSensitive ) ; } public void setFollowSymlinks ( boolean followSymlinks ) { usedMatchingTask = true ; super . setFollowSymlinks ( followSymlinks ) ; } public void addSelector ( SelectSelector selector ) { usedMatchingTask = true ; super . addSelector ( selector ) ; } public void addAnd ( AndSelector selector ) { usedMatchingTask = true ; super . addAnd ( selector ) ; } public void addOr ( OrSelector selector ) { usedMatchingTask = true ; super . addOr ( selector ) ; } public void addNot ( NotSelector selector ) { usedMatchingTask = true ; super . addNot ( selector ) ; } public void addNone ( NoneSelector selector ) { usedMatchingTask = true ; super . addNone ( selector ) ; } public void addMajority ( MajoritySelector selector ) { usedMatchingTask = true ; super . addMajority ( selector ) ; } public void addDate ( DateSelector selector ) { usedMatchingTask = true ; super . addDate ( selector ) ; } public void addSize ( SizeSelector selector ) { usedMatchingTask = true ; super . addSize ( selector ) ; } public void addFilename ( FilenameSelector selector ) { usedMatchingTask = true ; super . addFilename ( selector ) ; } public void addCustom ( ExtendSelector selector ) { usedMatchingTask = true ; super . addCustom ( selector ) ; } public void addContains ( ContainsSelector selector ) { usedMatchingTask = true ; super . addContains ( selector ) ; } public void addPresent ( PresentSelector selector ) { usedMatchingTask = true ; super . addPresent ( selector ) ; } public void addDepth ( DepthSelector selector ) { usedMatchingTask = true ; super . addDepth ( selector ) ; } public void addDepend ( DependSelector selector ) { usedMatchingTask = true ; super . addDepend ( selector ) ; } public void addContainsRegexp ( ContainsRegexpSelector selector ) { usedMatchingTask = true ; super . addContainsRegexp ( selector ) ; } public void addModified ( ModifiedSelector selector ) { usedMatchingTask = true ; super . addModified ( selector ) ; } public void add ( FileSelector selector ) { usedMatchingTask = true ; super . add ( selector ) ; } public void execute ( ) throws BuildException { if ( usedMatchingTask ) { log ( "DEPRECATED - Use of the implicit FileSet is deprecated.  " + "Use a nested fileset element instead." ) ; } if ( file == null && dir == null && filesets . size ( ) == 0 ) { throw new BuildException ( "At least one of the file or dir " + "attributes, or a fileset element, " + "must be set." ) ; } if ( quiet && failonerror ) { throw new BuildException ( "quiet and failonerror cannot both be " + "set to true" , getLocation ( ) ) ; } if ( file != null ) { if ( file . exists ( ) ) { if ( file . isDirectory ( ) ) { log ( "Directory " + file . getAbsolutePath ( ) + " cannot be removed using the file attribute.  " + "Use dir instead." ) ; } else { log ( "Deleting: " + file . getAbsolutePath ( ) ) ; if ( ! delete ( file ) ) { String message = "Unable to delete file " + file . getAbsolutePath ( ) ; if ( failonerror ) { throw new BuildException ( message ) ; } else { log ( message , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } } } } else { log ( "Could not find file " + file . getAbsolutePath ( ) + " to delete." , Project . MSG_VERBOSE ) ; } } if ( dir != null && dir . exists ( ) && dir . isDirectory ( ) && ! usedMatchingTask ) { if ( verbosity == Project . MSG_VERBOSE ) { log ( "Deleting directory " + dir . getAbsolutePath ( ) ) ; } removeDir ( dir ) ; } for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; try { DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] files = ds . getIncludedFiles ( ) ; String [ ] dirs = ds . getIncludedDirectories ( ) ; removeFiles ( fs . getDir ( getProject ( ) ) , files , dirs ) ; } catch ( BuildException be ) { if ( failonerror ) { throw be ; } else { log ( be . getMessage ( ) , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } } } if ( usedMatchingTask && dir != null ) { try { DirectoryScanner ds = super . getDirectoryScanner ( dir ) ; String [ ] files = ds . getIncludedFiles ( ) ; String [ ] dirs = ds . getIncludedDirectories ( ) ; removeFiles ( dir , files , dirs ) ; } catch ( BuildException be ) { if ( failonerror ) { throw be ; } else { log ( be . getMessage ( ) , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } } } } private boolean delete ( File f ) { if ( ! f . delete ( ) ) { try { Thread . sleep ( DELETE_RETRY_SLEEP_MILLIS ) ; return f . delete ( ) ; } catch ( InterruptedException ex ) { return f . delete ( ) ; } } return true ; } protected void removeDir ( File d ) { String [ ] list = d . list ( ) ; if ( list == null ) { list = new String [ 0 ] ; } for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( d , s ) ; if ( f . isDirectory ( ) ) { removeDir ( f ) ; } else { log ( "Deleting " + f . getAbsolutePath ( ) , verbosity ) ; if ( ! delete ( f ) ) { String message = "Unable to delete file " + f . getAbsolutePath ( ) ; if ( failonerror ) { throw new BuildException ( message ) ; } else { log ( message , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } } } } log ( "Deleting directory " + d . getAbsolutePath ( ) , verbosity ) ; if ( ! delete ( d ) ) { String message = "Unable to delete directory " + dir . getAbsolutePath ( ) ; if ( failonerror ) { throw new BuildException ( message ) ; } else { log ( message , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } } } protected void removeFiles ( File d , String [ ] files , String [ ] dirs ) { if ( files . length > 0 ) { log ( "Deleting " + files . length + " files from " + d . getAbsolutePath ( ) ) ; for ( int j = 0 ; j < files . length ; j ++ ) { File f = new File ( d , files [ j ] ) ; log ( "Deleting " + f . getAbsolutePath ( ) , verbosity ) ; if ( ! delete ( f ) ) { String message = "Unable to delete file " + f . getAbsolutePath ( ) ; if ( failonerror ) { throw new BuildException ( message ) ; } else { log ( message , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } } } } if ( dirs . length > 0 && includeEmpty ) { int dirCount = 0 ; for ( int j = dirs . length - 1 ; j >= 0 ; j -- ) { File dir = new File ( d , dirs [ j ] ) ; String [ ] dirFiles = dir . list ( ) ; if ( dirFiles == null || dirFiles . length == 0 ) { log ( "Deleting " + dir . getAbsolutePath ( ) , verbosity ) ; if ( ! delete ( dir ) ) { String message = "Unable to delete directory " + dir . getAbsolutePath ( ) ; if ( failonerror ) { throw new BuildException ( message ) ; } else { log ( message , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } } else { dirCount ++ ; } } } if ( dirCount > 0 ) { log ( "Deleted " + dirCount + " director" + ( dirCount == 1 ? "y" : "ies" ) + " from " + d . getAbsolutePath ( ) ) ; } } } } 	1	['41', '4', '0', '28', '98', '0', '0', '28', '38', '0.855555556', '890', '1', '0', '0.661016949', '0.080593849', '3', '4', '20.48780488', '16', '1.6341', '3']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedOutputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . bzip2 . CBZip2OutputStream ; public class BZip2 extends Pack { protected void pack ( ) { CBZip2OutputStream zOut = null ; try { BufferedOutputStream bos = new BufferedOutputStream ( new FileOutputStream ( zipFile ) ) ; bos . write ( 'B' ) ; bos . write ( 'Z' ) ; zOut = new CBZip2OutputStream ( bos ) ; zipFile ( source , zOut ) ; } catch ( IOException ioe ) { String msg = "Problem creating bzip2 " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } finally { if ( zOut != null ) { try { zOut . close ( ) ; } catch ( IOException e ) { } } } } } 	0	['2', '4', '0', '5', '15', '1', '0', '5', '1', '2', '67', '0', '0', '0.980392157', '1', '1', '2', '32.5', '4', '2', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; public class JavacExternal extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using external javac compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = new Commandline ( ) ; cmd . setExecutable ( getJavac ( ) . getJavacExecutable ( ) ) ; setupModernJavacCommandlineSwitches ( cmd ) ; int firstFileName = assumeJava11 ( ) ? - 1 : cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName , true ) == 0 ; } } 	1	['2', '2', '0', '6', '14', '1', '1', '5', '2', '2', '45', '0', '0', '0.958333333', '1', '0', '0', '21.5', '1', '0.5', '2']
package org . apache . tools . ant ; public interface TypeAdapter { void setProject ( Project p ) ; Project getProject ( ) ; void setProxy ( Object o ) ; Object getProxy ( ) ; void checkProxyClass ( Class proxyClass ) ; } 	0	['5', '1', '0', '7', '5', '10', '6', '1', '5', '2', '5', '0', '0', '0', '0.4', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant ; public abstract class ProjectComponent { protected Project project ; public ProjectComponent ( ) { } public void setProject ( Project project ) { this . project = project ; } public Project getProject ( ) { return project ; } public void log ( String msg ) { log ( msg , Project . MSG_INFO ) ; } public void log ( String msg , int msgLevel ) { if ( project != null ) { project . log ( msg , msgLevel ) ; } else { if ( msgLevel >= Project . MSG_INFO ) { System . err . println ( msg ) ; } } } } 	1	['5', '1', '19', '128', '8', '4', '128', '1', '5', '0.25', '37', '1', '1', '0', '0.45', '0', '0', '6.2', '3', '1.2', '1']
package org . apache . tools . ant . taskdefs ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . Enumeration ; import java . util . Vector ; class ProcessDestroyer implements Runnable { private Vector processes = new Vector ( ) ; private Method addShutdownHookMethod ; private Method removeShutdownHookMethod ; private ProcessDestroyerImpl destroyProcessThread = null ; private boolean added = false ; private class ProcessDestroyerImpl extends Thread { private boolean shouldDestroy = true ; public ProcessDestroyerImpl ( ) { super ( "ProcessDestroyer Shutdown Hook" ) ; } public void run ( ) { if ( shouldDestroy ) { ProcessDestroyer . this . run ( ) ; } } public void setShouldDestroy ( boolean shouldDestroy ) { this . shouldDestroy = shouldDestroy ; } } public ProcessDestroyer ( ) { try { Class [ ] paramTypes = { Thread . class } ; addShutdownHookMethod = Runtime . class . getMethod ( "addShutdownHook" , paramTypes ) ; removeShutdownHookMethod = Runtime . class . getMethod ( "removeShutdownHook" , paramTypes ) ; } catch ( NoSuchMethodException e ) { } catch ( Exception e ) { e . printStackTrace ( ) ; } } private void addShutdownHook ( ) { if ( addShutdownHookMethod != null ) { destroyProcessThread = new ProcessDestroyerImpl ( ) ; Object [ ] args = { destroyProcessThread } ; try { addShutdownHookMethod . invoke ( Runtime . getRuntime ( ) , args ) ; added = true ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } } } private void removeShutdownHook ( ) { if ( removeShutdownHookMethod != null && destroyProcessThread != null ) { Object [ ] args = { destroyProcessThread } ; try { Boolean removed = ( Boolean ) removeShutdownHookMethod . invoke ( Runtime . getRuntime ( ) , args ) ; if ( ! removed . booleanValue ( ) ) { System . err . println ( "Could not remove shutdown hook" ) ; } destroyProcessThread . setShouldDestroy ( false ) ; destroyProcessThread . start ( ) ; try { destroyProcessThread . join ( 20000 ) ; } catch ( InterruptedException ie ) { } destroyProcessThread = null ; added = false ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } } } public boolean isAddedAsShutdownHook ( ) { return added ; } public boolean add ( Process process ) { synchronized ( processes ) { if ( processes . size ( ) == 0 ) { addShutdownHook ( ) ; } processes . addElement ( process ) ; return processes . contains ( process ) ; } } public boolean remove ( Process process ) { synchronized ( processes ) { boolean processRemoved = processes . removeElement ( process ) ; if ( processes . size ( ) == 0 ) { processes . notifyAll ( ) ; removeShutdownHook ( ) ; } return processRemoved ; } } public void run ( ) { synchronized ( processes ) { Enumeration e = processes . elements ( ) ; while ( e . hasMoreElements ( ) ) { ( ( Process ) e . nextElement ( ) ) . destroy ( ) ; } try { processes . wait ( ) ; } catch ( InterruptedException interrupt ) { } } } } 	0	['8', '1', '0', '2', '33', '4', '2', '1', '5', '0.673469388', '269', '0.714285714', '1', '0', '0.416666667', '0', '0', '31.75', '4', '1.75', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . util . Hashtable ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . BuildException ; public final class ReplaceTokens extends BaseParamFilterReader implements ChainableReader { private static final char DEFAULT_BEGIN_TOKEN = '@' ; private static final char DEFAULT_END_TOKEN = '@' ; private String queuedData = null ; private String replaceData = null ; private int replaceIndex = - 1 ; private int queueIndex = - 1 ; private Hashtable hash = new Hashtable ( ) ; private char beginToken = DEFAULT_BEGIN_TOKEN ; private char endToken = DEFAULT_END_TOKEN ; public ReplaceTokens ( ) { super ( ) ; } public ReplaceTokens ( final Reader in ) { super ( in ) ; } private int getNextChar ( ) throws IOException { if ( queueIndex != - 1 ) { final int ch = queuedData . charAt ( queueIndex ++ ) ; if ( queueIndex >= queuedData . length ( ) ) { queueIndex = - 1 ; } return ch ; } return in . read ( ) ; } public final int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } if ( replaceIndex != - 1 ) { final int ch = replaceData . charAt ( replaceIndex ++ ) ; if ( replaceIndex >= replaceData . length ( ) ) { replaceIndex = - 1 ; } return ch ; } int ch = getNextChar ( ) ; if ( ch == beginToken ) { final StringBuffer key = new StringBuffer ( "" ) ; do { ch = getNextChar ( ) ; if ( ch != - 1 ) { key . append ( ( char ) ch ) ; } else { break ; } } while ( ch != endToken ) ; if ( ch == - 1 ) { if ( queuedData == null || queueIndex == - 1 ) { queuedData = key . toString ( ) ; } else { queuedData = key . toString ( ) + queuedData . substring ( queueIndex ) ; } queueIndex = 0 ; return beginToken ; } else { key . setLength ( key . length ( ) - 1 ) ; final String replaceWith = ( String ) hash . get ( key . toString ( ) ) ; if ( replaceWith != null ) { if ( replaceWith . length ( ) > 0 ) { replaceData = replaceWith ; replaceIndex = 0 ; } return read ( ) ; } else { String newData = key . toString ( ) + endToken ; if ( queuedData == null || queueIndex == - 1 ) { queuedData = newData ; } else { queuedData = newData + queuedData . substring ( queueIndex ) ; } queueIndex = 0 ; return beginToken ; } } } return ch ; } public final void setBeginToken ( final char beginToken ) { this . beginToken = beginToken ; } private final char getBeginToken ( ) { return beginToken ; } public final void setEndToken ( final char endToken ) { this . endToken = endToken ; } private final char getEndToken ( ) { return endToken ; } public final void addConfiguredToken ( final Token token ) { hash . put ( token . getKey ( ) , token . getValue ( ) ) ; } private void setTokens ( final Hashtable hash ) { this . hash = hash ; } private final Hashtable getTokens ( ) { return hash ; } public final Reader chain ( final Reader rdr ) { ReplaceTokens newFilter = new ReplaceTokens ( rdr ) ; newFilter . setBeginToken ( getBeginToken ( ) ) ; newFilter . setEndToken ( getEndToken ( ) ) ; newFilter . setTokens ( getTokens ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private final void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( params [ i ] != null ) { final String type = params [ i ] . getType ( ) ; if ( "tokenchar" . equals ( type ) ) { final String name = params [ i ] . getName ( ) ; String value = params [ i ] . getValue ( ) ; if ( "begintoken" . equals ( name ) ) { if ( value . length ( ) == 0 ) { throw new BuildException ( "Begin token cannot " + "be empty" ) ; } beginToken = params [ i ] . getValue ( ) . charAt ( 0 ) ; } else if ( "endtoken" . equals ( name ) ) { if ( value . length ( ) == 0 ) { throw new BuildException ( "End token cannot " + "be empty" ) ; } endToken = params [ i ] . getValue ( ) . charAt ( 0 ) ; } } else if ( "token" . equals ( type ) ) { final String name = params [ i ] . getName ( ) ; final String value = params [ i ] . getValue ( ) ; hash . put ( name , value ) ; } } } } } public static class Token { private String key ; private String value ; public final void setKey ( String key ) { this . key = key ; } public final void setValue ( String value ) { this . value = value ; } public final String getKey ( ) { return key ; } public final String getValue ( ) { return value ; } } } 	1	['13', '5', '0', '7', '39', '0', '1', '6', '7', '0.712962963', '424', '1', '0', '0.717948718', '0.292307692', '2', '5', '30.92307692', '9', '1.4615', '1']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . IdentityMapper ; public class PresentSelector extends BaseSelector { private File targetdir = null ; private Mapper mapperElement = null ; private FileNameMapper map = null ; private boolean destmustexist = true ; public PresentSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{presentselector targetdir: " ) ; if ( targetdir == null ) { buf . append ( "NOT YET SET" ) ; } else { buf . append ( targetdir . getName ( ) ) ; } buf . append ( " present: " ) ; if ( destmustexist ) { buf . append ( "both" ) ; } else { buf . append ( "srconly" ) ; } if ( map != null ) { buf . append ( map . toString ( ) ) ; } else if ( mapperElement != null ) { buf . append ( mapperElement . toString ( ) ) ; } buf . append ( "}" ) ; return buf . toString ( ) ; } public void setTargetdir ( File targetdir ) { this . targetdir = targetdir ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" ) ; } mapperElement = new Mapper ( getProject ( ) ) ; return mapperElement ; } public void setPresent ( FilePresence fp ) { if ( fp . getIndex ( ) == 0 ) { destmustexist = false ; } } public void verifySettings ( ) { if ( targetdir == null ) { setError ( "The targetdir attribute is required." ) ; } if ( mapperElement == null ) { map = new IdentityMapper ( ) ; } else { map = mapperElement . getImplementation ( ) ; } if ( map == null ) { setError ( "Could not set <mapper> element." ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; String [ ] destfiles = map . mapFileName ( filename ) ; if ( destfiles == null ) { return false ; } if ( destfiles . length != 1 || destfiles [ 0 ] == null ) { throw new BuildException ( "Invalid destination file results for " + targetdir + " with filename " + filename ) ; } String destname = destfiles [ 0 ] ; File destfile = new File ( targetdir , destname ) ; return destfile . exists ( ) == destmustexist ; } public static class FilePresence extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "srconly" , "both" } ; } } } 	0	['7', '4', '0', '14', '26', '0', '5', '9', '7', '0.458333333', '199', '1', '2', '0.853658537', '0.392857143', '1', '3', '26.85714286', '5', '2.5714', '0']
package org . apache . tools . ant . util ; import java . io . File ; import java . util . Vector ; import org . apache . tools . ant . taskdefs . condition . Os ; public class JavaEnvUtils { private static final boolean isDos = Os . isFamily ( "dos" ) ; private static final boolean isNetware = Os . isName ( "netware" ) ; private static final boolean isAix = Os . isName ( "aix" ) ; private static final String javaHome = System . getProperty ( "java.home" ) ; private static final FileUtils fileUtils = FileUtils . newFileUtils ( ) ; private static String javaVersion ; private static int javaVersionNumber ; public static final String JAVA_1_0 = "1.0" ; public static final String JAVA_1_1 = "1.1" ; public static final String JAVA_1_2 = "1.2" ; public static final String JAVA_1_3 = "1.3" ; public static final String JAVA_1_4 = "1.4" ; private static Vector jrePackages ; static { try { javaVersion = JAVA_1_0 ; javaVersionNumber = 10 ; Class . forName ( "java.lang.Void" ) ; javaVersion = JAVA_1_1 ; javaVersionNumber ++ ; Class . forName ( "java.lang.ThreadLocal" ) ; javaVersion = JAVA_1_2 ; javaVersionNumber ++ ; Class . forName ( "java.lang.StrictMath" ) ; javaVersion = JAVA_1_3 ; javaVersionNumber ++ ; Class . forName ( "java.lang.CharSequence" ) ; javaVersion = JAVA_1_4 ; javaVersionNumber ++ ; } catch ( Throwable t ) { } } public static String getJavaVersion ( ) { return javaVersion ; } public static boolean isJavaVersion ( String version ) { return javaVersion == version ; } public static String getJreExecutable ( String command ) { if ( isNetware ) { return command ; } File jExecutable = null ; if ( isAix ) { jExecutable = findInDir ( javaHome + "/sh" , command ) ; } if ( jExecutable == null ) { jExecutable = findInDir ( javaHome + "/bin" , command ) ; } if ( jExecutable != null ) { return jExecutable . getAbsolutePath ( ) ; } else { return addExtension ( command ) ; } } public static String getJdkExecutable ( String command ) { if ( isNetware ) { return command ; } File jExecutable = null ; if ( isAix ) { jExecutable = findInDir ( javaHome + "/../sh" , command ) ; } if ( jExecutable == null ) { jExecutable = findInDir ( javaHome + "/../bin" , command ) ; } if ( jExecutable != null ) { return jExecutable . getAbsolutePath ( ) ; } else { return getJreExecutable ( command ) ; } } private static String addExtension ( String command ) { return command + ( isDos ? ".exe" : "" ) ; } private static File findInDir ( String dirName , String commandName ) { File dir = fileUtils . normalize ( dirName ) ; File executable = null ; if ( dir . exists ( ) ) { executable = new File ( dir , addExtension ( commandName ) ) ; if ( ! executable . exists ( ) ) { executable = null ; } } return executable ; } private static void buildJrePackages ( ) { jrePackages = new Vector ( ) ; switch ( javaVersionNumber ) { case 14 : jrePackages . addElement ( "org.apache.crimson" ) ; jrePackages . addElement ( "org.apache.xalan" ) ; jrePackages . addElement ( "org.apache.xml" ) ; jrePackages . addElement ( "org.apache.xpath" ) ; jrePackages . addElement ( "org.ietf.jgss" ) ; jrePackages . addElement ( "org.w3c.dom" ) ; jrePackages . addElement ( "org.xml.sax" ) ; case 13 : jrePackages . addElement ( "org.omg" ) ; jrePackages . addElement ( "com.sun.corba" ) ; jrePackages . addElement ( "com.sun.jndi" ) ; jrePackages . addElement ( "com.sun.media" ) ; jrePackages . addElement ( "com.sun.naming" ) ; jrePackages . addElement ( "com.sun.org.omg" ) ; jrePackages . addElement ( "com.sun.rmi" ) ; jrePackages . addElement ( "sunw.io" ) ; jrePackages . addElement ( "sunw.util" ) ; case 12 : jrePackages . addElement ( "com.sun.java" ) ; jrePackages . addElement ( "com.sun.image" ) ; case 11 : default : jrePackages . addElement ( "sun" ) ; jrePackages . addElement ( "java" ) ; jrePackages . addElement ( "javax" ) ; break ; } } public static Vector getJrePackageTestCases ( ) { Vector tests = new Vector ( ) ; tests . addElement ( "java.lang.Object" ) ; switch ( javaVersionNumber ) { case 14 : tests . addElement ( "sun.audio.AudioPlayer" ) ; tests . addElement ( "org.apache.crimson.parser.ContentModel" ) ; tests . addElement ( "org.apache.xalan.processor.ProcessorImport" ) ; tests . addElement ( "org.apache.xml.utils.URI" ) ; tests . addElement ( "org.apache.xpath.XPathFactory" ) ; tests . addElement ( "org.ietf.jgss.Oid" ) ; tests . addElement ( "org.w3c.dom.Attr" ) ; tests . addElement ( "org.xml.sax.XMLReader" ) ; case 13 : tests . addElement ( "org.omg.CORBA.Any" ) ; tests . addElement ( "com.sun.corba.se.internal.corba.AnyImpl" ) ; tests . addElement ( "com.sun.jndi.ldap.LdapURL" ) ; tests . addElement ( "com.sun.media.sound.Printer" ) ; tests . addElement ( "com.sun.naming.internal.VersionHelper" ) ; tests . addElement ( "com.sun.org.omg.CORBA.Initializer" ) ; tests . addElement ( "sunw.io.Serializable" ) ; tests . addElement ( "sunw.util.EventListener" ) ; case 12 : tests . addElement ( "javax.accessibility.Accessible" ) ; tests . addElement ( "sun.misc.BASE64Encoder" ) ; tests . addElement ( "com.sun.image.codec.jpeg.JPEGCodec" ) ; case 11 : default : tests . addElement ( "sun.reflect.SerializationConstructorAccessorImpl" ) ; tests . addElement ( "sun.net.www.http.HttpClient" ) ; tests . addElement ( "sun.audio.AudioPlayer" ) ; break ; } return tests ; } public static Vector getJrePackages ( ) { if ( jrePackages == null ) { buildJrePackages ( ) ; } return jrePackages ; } } 	1	['11', '1', '0', '17', '26', '31', '16', '2', '7', '0.892307692', '362', '0.615384615', '1', '0', '0.3', '0', '0', '30.72727273', '5', '2.1818', '3']
package org . apache . tools . ant . types ; import java . util . Enumeration ; import java . util . Vector ; public class FilterSetCollection { private Vector filterSets = new Vector ( ) ; public FilterSetCollection ( ) { } public FilterSetCollection ( FilterSet filterSet ) { addFilterSet ( filterSet ) ; } public void addFilterSet ( FilterSet filterSet ) { filterSets . addElement ( filterSet ) ; } public String replaceTokens ( String line ) { String replacedLine = line ; for ( Enumeration e = filterSets . elements ( ) ; e . hasMoreElements ( ) ; ) { FilterSet filterSet = ( FilterSet ) e . nextElement ( ) ; replacedLine = filterSet . replaceTokens ( replacedLine ) ; } return replacedLine ; } public boolean hasFilters ( ) { for ( Enumeration e = filterSets . elements ( ) ; e . hasMoreElements ( ) ; ) { FilterSet filterSet = ( FilterSet ) e . nextElement ( ) ; if ( filterSet . hasFilters ( ) ) { return true ; } } return false ; } } 	0	['5', '1', '0', '6', '13', '0', '5', '1', '5', '0', '69', '1', '0', '0', '0.533333333', '0', '0', '12.6', '3', '1.2', '0']
package org . apache . tools . ant ; import java . io . File ; import java . io . IOException ; import java . io . EOFException ; import java . io . InputStream ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . Properties ; import java . util . Stack ; import java . util . Vector ; import java . util . Set ; import java . util . HashSet ; import org . apache . tools . ant . input . DefaultInputHandler ; import org . apache . tools . ant . input . InputHandler ; import org . apache . tools . ant . types . FilterSet ; import org . apache . tools . ant . types . FilterSetCollection ; import org . apache . tools . ant . types . Description ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . apache . tools . ant . util . StringUtils ; public class Project { public static final int MSG_ERR = 0 ; public static final int MSG_WARN = 1 ; public static final int MSG_INFO = 2 ; public static final int MSG_VERBOSE = 3 ; public static final int MSG_DEBUG = 4 ; private static final String VISITING = "VISITING" ; private static final String VISITED = "VISITED" ; private static final String ANTCLASSLOADER_JDK12 = "org.apache.tools.ant.loader.AntClassLoader2" ; public static final String JAVA_1_0 = JavaEnvUtils . JAVA_1_0 ; public static final String JAVA_1_1 = JavaEnvUtils . JAVA_1_1 ; public static final String JAVA_1_2 = JavaEnvUtils . JAVA_1_2 ; public static final String JAVA_1_3 = JavaEnvUtils . JAVA_1_3 ; public static final String JAVA_1_4 = JavaEnvUtils . JAVA_1_4 ; public static final String TOKEN_START = FilterSet . DEFAULT_TOKEN_START ; public static final String TOKEN_END = FilterSet . DEFAULT_TOKEN_END ; private String name ; private String description ; private Hashtable references = new AntRefTable ( this ) ; private String defaultTarget ; private Hashtable targets = new Hashtable ( ) ; private FilterSet globalFilterSet = new FilterSet ( ) ; private FilterSetCollection globalFilters = new FilterSetCollection ( globalFilterSet ) ; private File baseDir ; private Vector listeners = new Vector ( ) ; private ClassLoader coreLoader = null ; private Hashtable threadTasks = new Hashtable ( ) ; private Hashtable threadGroupTasks = new Hashtable ( ) ; private InputHandler inputHandler = null ; private InputStream defaultInputStream = null ; private boolean keepGoingMode = false ; public void setInputHandler ( InputHandler handler ) { inputHandler = handler ; } public void setDefaultInputStream ( InputStream defaultInputStream ) { this . defaultInputStream = defaultInputStream ; } public InputStream getDefaultInputStream ( ) { return defaultInputStream ; } public InputHandler getInputHandler ( ) { return inputHandler ; } private FileUtils fileUtils ; private boolean loggingMessage = false ; public Project ( ) { fileUtils = FileUtils . newFileUtils ( ) ; inputHandler = new DefaultInputHandler ( ) ; } public void initSubProject ( Project subProject ) { ComponentHelper . getComponentHelper ( subProject ) . initSubProject ( ComponentHelper . getComponentHelper ( this ) ) ; subProject . setKeepGoingMode ( this . isKeepGoingMode ( ) ) ; } public void init ( ) throws BuildException { setJavaVersionProperty ( ) ; ComponentHelper . getComponentHelper ( this ) . initDefaultDefinitions ( ) ; setSystemProperties ( ) ; } private AntClassLoader createClassLoader ( ) { AntClassLoader loader = null ; if ( ! JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { try { Class loaderClass = Class . forName ( ANTCLASSLOADER_JDK12 ) ; loader = ( AntClassLoader ) loaderClass . newInstance ( ) ; } catch ( Exception e ) { log ( "Unable to create Class Loader: " + e . getMessage ( ) , Project . MSG_DEBUG ) ; } } if ( loader == null ) { loader = new AntClassLoader ( ) ; } loader . setProject ( this ) ; return loader ; } public AntClassLoader createClassLoader ( Path path ) { AntClassLoader loader = createClassLoader ( ) ; loader . setClassPath ( path ) ; return loader ; } public void setCoreLoader ( ClassLoader coreLoader ) { this . coreLoader = coreLoader ; } public ClassLoader getCoreLoader ( ) { return coreLoader ; } public synchronized void addBuildListener ( BuildListener listener ) { Vector newListeners = getBuildListeners ( ) ; newListeners . addElement ( listener ) ; listeners = newListeners ; } public synchronized void removeBuildListener ( BuildListener listener ) { Vector newListeners = getBuildListeners ( ) ; newListeners . removeElement ( listener ) ; listeners = newListeners ; } public Vector getBuildListeners ( ) { return ( Vector ) listeners . clone ( ) ; } public void log ( String message ) { log ( message , MSG_INFO ) ; } public void log ( String message , int msgLevel ) { fireMessageLogged ( this , message , msgLevel ) ; } public void log ( Task task , String message , int msgLevel ) { fireMessageLogged ( task , message , msgLevel ) ; } public void log ( Target target , String message , int msgLevel ) { fireMessageLogged ( target , message , msgLevel ) ; } public FilterSet getGlobalFilterSet ( ) { return globalFilterSet ; } public void setProperty ( String name , String value ) { PropertyHelper . getPropertyHelper ( this ) . setProperty ( null , name , value , true ) ; } public void setNewProperty ( String name , String value ) { PropertyHelper . getPropertyHelper ( this ) . setNewProperty ( null , name , value ) ; } public void setUserProperty ( String name , String value ) { PropertyHelper . getPropertyHelper ( this ) . setUserProperty ( null , name , value ) ; } public void setInheritedProperty ( String name , String value ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; ph . setInheritedProperty ( null , name , value ) ; } private void setPropertyInternal ( String name , String value ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; ph . setProperty ( null , name , value , false ) ; } public String getProperty ( String name ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; return ( String ) ph . getProperty ( null , name ) ; } public String replaceProperties ( String value ) throws BuildException { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; return ph . replaceProperties ( null , value , null ) ; } public String getUserProperty ( String name ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; return ( String ) ph . getUserProperty ( null , name ) ; } public Hashtable getProperties ( ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; return ph . getProperties ( ) ; } public Hashtable getUserProperties ( ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; return ph . getUserProperties ( ) ; } public void copyUserProperties ( Project other ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; ph . copyUserProperties ( other ) ; } public void copyInheritedProperties ( Project other ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; ph . copyInheritedProperties ( other ) ; } public void setDefaultTarget ( String defaultTarget ) { this . defaultTarget = defaultTarget ; } public String getDefaultTarget ( ) { return defaultTarget ; } public void setDefault ( String defaultTarget ) { this . defaultTarget = defaultTarget ; } public void setName ( String name ) { setUserProperty ( "ant.project.name" , name ) ; this . name = name ; } public String getName ( ) { return name ; } public void setDescription ( String description ) { this . description = description ; } public String getDescription ( ) { if ( description == null ) { description = Description . getDescription ( this ) ; } return description ; } public void addFilter ( String token , String value ) { if ( token == null ) { return ; } globalFilterSet . addFilter ( new FilterSet . Filter ( token , value ) ) ; } public Hashtable getFilters ( ) { return globalFilterSet . getFilterHash ( ) ; } public void setBasedir ( String baseD ) throws BuildException { setBaseDir ( new File ( baseD ) ) ; } public void setBaseDir ( File baseDir ) throws BuildException { baseDir = fileUtils . normalize ( baseDir . getAbsolutePath ( ) ) ; if ( ! baseDir . exists ( ) ) { throw new BuildException ( "Basedir " + baseDir . getAbsolutePath ( ) + " does not exist" ) ; } if ( ! baseDir . isDirectory ( ) ) { throw new BuildException ( "Basedir " + baseDir . getAbsolutePath ( ) + " is not a directory" ) ; } this . baseDir = baseDir ; setPropertyInternal ( "basedir" , this . baseDir . getPath ( ) ) ; String msg = "Project base dir set to: " + this . baseDir ; log ( msg , MSG_VERBOSE ) ; } public File getBaseDir ( ) { if ( baseDir == null ) { try { setBasedir ( "." ) ; } catch ( BuildException ex ) { ex . printStackTrace ( ) ; } } return baseDir ; } public void setKeepGoingMode ( boolean keepGoingMode ) { this . keepGoingMode = keepGoingMode ; } public boolean isKeepGoingMode ( ) { return this . keepGoingMode ; } public static String getJavaVersion ( ) { return JavaEnvUtils . getJavaVersion ( ) ; } public void setJavaVersionProperty ( ) throws BuildException { String javaVersion = JavaEnvUtils . getJavaVersion ( ) ; setPropertyInternal ( "ant.java.version" , javaVersion ) ; if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_0 ) ) { throw new BuildException ( "Ant cannot work on Java 1.0" ) ; } log ( "Detected Java version: " + javaVersion + " in: " + System . getProperty ( "java.home" ) , MSG_VERBOSE ) ; log ( "Detected OS: " + System . getProperty ( "os.name" ) , MSG_VERBOSE ) ; } public void setSystemProperties ( ) { Properties systemP = System . getProperties ( ) ; Enumeration e = systemP . keys ( ) ; while ( e . hasMoreElements ( ) ) { Object name = e . nextElement ( ) ; String value = systemP . get ( name ) . toString ( ) ; this . setPropertyInternal ( name . toString ( ) , value ) ; } } public void addTaskDefinition ( String taskName , Class taskClass ) throws BuildException { ComponentHelper . getComponentHelper ( this ) . addTaskDefinition ( taskName , taskClass ) ; } public void checkTaskClass ( final Class taskClass ) throws BuildException { ComponentHelper . getComponentHelper ( this ) . checkTaskClass ( taskClass ) ; if ( ! Modifier . isPublic ( taskClass . getModifiers ( ) ) ) { final String message = taskClass + " is not public" ; log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } if ( Modifier . isAbstract ( taskClass . getModifiers ( ) ) ) { final String message = taskClass + " is abstract" ; log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } try { taskClass . getConstructor ( null ) ; } catch ( NoSuchMethodException e ) { final String message = "No public no-arg constructor in " + taskClass ; log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } if ( ! Task . class . isAssignableFrom ( taskClass ) ) { TaskAdapter . checkTaskClass ( taskClass , this ) ; } } public Hashtable getTaskDefinitions ( ) { return ComponentHelper . getComponentHelper ( this ) . getTaskDefinitions ( ) ; } public void addDataTypeDefinition ( String typeName , Class typeClass ) { ComponentHelper . getComponentHelper ( this ) . addDataTypeDefinition ( typeName , typeClass ) ; } public Hashtable getDataTypeDefinitions ( ) { return ComponentHelper . getComponentHelper ( this ) . getDataTypeDefinitions ( ) ; } public void addTarget ( Target target ) throws BuildException { String name = target . getName ( ) ; if ( targets . get ( name ) != null ) { throw new BuildException ( "Duplicate target: `" + name + "'" ) ; } addOrReplaceTarget ( name , target ) ; } public void addTarget ( String targetName , Target target ) throws BuildException { if ( targets . get ( targetName ) != null ) { throw new BuildException ( "Duplicate target: `" + targetName + "'" ) ; } addOrReplaceTarget ( targetName , target ) ; } public void addOrReplaceTarget ( Target target ) { addOrReplaceTarget ( target . getName ( ) , target ) ; } public void addOrReplaceTarget ( String targetName , Target target ) { String msg = " +Target: " + targetName ; log ( msg , MSG_DEBUG ) ; target . setProject ( this ) ; targets . put ( targetName , target ) ; } public Hashtable getTargets ( ) { return targets ; } public Task createTask ( String taskType ) throws BuildException { return ComponentHelper . getComponentHelper ( this ) . createTask ( taskType ) ; } public Object createDataType ( String typeName ) throws BuildException { return ComponentHelper . getComponentHelper ( this ) . createDataType ( typeName ) ; } public void executeTargets ( Vector targetNames ) throws BuildException { for ( int i = 0 ; i < targetNames . size ( ) ; i ++ ) { executeTarget ( ( String ) targetNames . elementAt ( i ) ) ; } } public void demuxOutput ( String output , boolean isWarning ) { Task task = getThreadTask ( Thread . currentThread ( ) ) ; if ( task == null ) { log ( output , isWarning ? MSG_WARN : MSG_INFO ) ; } else { if ( isWarning ) { task . handleErrorOutput ( output ) ; } else { task . handleOutput ( output ) ; } } } public int defaultInput ( byte [ ] buffer , int offset , int length ) throws IOException { if ( defaultInputStream != null ) { System . out . flush ( ) ; return defaultInputStream . read ( buffer , offset , length ) ; } else { throw new EOFException ( "No input provided for project" ) ; } } public int demuxInput ( byte [ ] buffer , int offset , int length ) throws IOException { Task task = getThreadTask ( Thread . currentThread ( ) ) ; if ( task == null ) { return defaultInput ( buffer , offset , length ) ; } else { return task . handleInput ( buffer , offset , length ) ; } } public void demuxFlush ( String output , boolean isError ) { Task task = getThreadTask ( Thread . currentThread ( ) ) ; if ( task == null ) { fireMessageLogged ( this , output , isError ? MSG_ERR : MSG_INFO ) ; } else { if ( isError ) { task . handleErrorFlush ( output ) ; } else { task . handleFlush ( output ) ; } } } public void executeTarget ( String targetName ) throws BuildException { if ( targetName == null ) { String msg = "No target specified" ; throw new BuildException ( msg ) ; } Vector sortedTargets = topoSort ( targetName , targets ) ; Set succeededTargets = new HashSet ( ) ; BuildException buildException = null ; for ( Enumeration iter = sortedTargets . elements ( ) ; iter . hasMoreElements ( ) ; ) { Target curtarget = ( Target ) iter . nextElement ( ) ; boolean canExecute = true ; for ( Enumeration depIter = curtarget . getDependencies ( ) ; depIter . hasMoreElements ( ) ; ) { String dependencyName = ( ( String ) depIter . nextElement ( ) ) ; if ( ! succeededTargets . contains ( dependencyName ) ) { canExecute = false ; log ( curtarget , "Cannot execute '" + curtarget . getName ( ) + "' - '" + dependencyName + "' failed or was not executed." , MSG_ERR ) ; break ; } } if ( canExecute ) { Throwable thrownException = null ; try { curtarget . performTasks ( ) ; succeededTargets . add ( curtarget . getName ( ) ) ; } catch ( RuntimeException ex ) { if ( ! ( keepGoingMode ) ) { throw ex ; } thrownException = ex ; } catch ( Throwable ex ) { if ( ! ( keepGoingMode ) ) { throw new BuildException ( ex ) ; } thrownException = ex ; } if ( thrownException != null ) { if ( thrownException instanceof BuildException ) { log ( curtarget , "Target '" + curtarget . getName ( ) + "' failed with message '" + thrownException . getMessage ( ) + "'." , MSG_ERR ) ; if ( buildException == null ) { buildException = ( BuildException ) thrownException ; } } else { log ( curtarget , "Target '" + curtarget . getName ( ) + "' failed with message '" + thrownException . getMessage ( ) + "'." , MSG_ERR ) ; thrownException . printStackTrace ( System . err ) ; if ( buildException == null ) { buildException = new BuildException ( thrownException ) ; } } } } if ( curtarget . getName ( ) . equals ( targetName ) ) { break ; } } if ( buildException != null ) { throw buildException ; } } public File resolveFile ( String fileName , File rootDir ) { return fileUtils . resolveFile ( rootDir , fileName ) ; } public File resolveFile ( String fileName ) { return fileUtils . resolveFile ( baseDir , fileName ) ; } public static String translatePath ( String toProcess ) { if ( toProcess == null || toProcess . length ( ) == 0 ) { return "" ; } StringBuffer path = new StringBuffer ( toProcess . length ( ) + 50 ) ; PathTokenizer tokenizer = new PathTokenizer ( toProcess ) ; while ( tokenizer . hasMoreTokens ( ) ) { String pathComponent = tokenizer . nextToken ( ) ; pathComponent = pathComponent . replace ( '/' , File . separatorChar ) ; pathComponent = pathComponent . replace ( '\\' , File . separatorChar ) ; if ( path . length ( ) != 0 ) { path . append ( File . pathSeparatorChar ) ; } path . append ( pathComponent ) ; } return path . toString ( ) ; } public void copyFile ( String sourceFile , String destFile ) throws IOException { fileUtils . copyFile ( sourceFile , destFile ) ; } public void copyFile ( String sourceFile , String destFile , boolean filtering ) throws IOException { fileUtils . copyFile ( sourceFile , destFile , filtering ? globalFilters : null ) ; } public void copyFile ( String sourceFile , String destFile , boolean filtering , boolean overwrite ) throws IOException { fileUtils . copyFile ( sourceFile , destFile , filtering ? globalFilters : null , overwrite ) ; } public void copyFile ( String sourceFile , String destFile , boolean filtering , boolean overwrite , boolean preserveLastModified ) throws IOException { fileUtils . copyFile ( sourceFile , destFile , filtering ? globalFilters : null , overwrite , preserveLastModified ) ; } public void copyFile ( File sourceFile , File destFile ) throws IOException { fileUtils . copyFile ( sourceFile , destFile ) ; } public void copyFile ( File sourceFile , File destFile , boolean filtering ) throws IOException { fileUtils . copyFile ( sourceFile , destFile , filtering ? globalFilters : null ) ; } public void copyFile ( File sourceFile , File destFile , boolean filtering , boolean overwrite ) throws IOException { fileUtils . copyFile ( sourceFile , destFile , filtering ? globalFilters : null , overwrite ) ; } public void copyFile ( File sourceFile , File destFile , boolean filtering , boolean overwrite , boolean preserveLastModified ) throws IOException { fileUtils . copyFile ( sourceFile , destFile , filtering ? globalFilters : null , overwrite , preserveLastModified ) ; } public void setFileLastModified ( File file , long time ) throws BuildException { if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { log ( "Cannot change the modification time of " + file + " in JDK 1.1" , Project . MSG_WARN ) ; return ; } fileUtils . setFileLastModified ( file , time ) ; log ( "Setting modification time for " + file , MSG_VERBOSE ) ; } public static boolean toBoolean ( String s ) { return ( "on" . equalsIgnoreCase ( s ) || "true" . equalsIgnoreCase ( s ) || "yes" . equalsIgnoreCase ( s ) ) ; } public final Vector topoSort ( String root , Hashtable targets ) throws BuildException { Vector ret = new Vector ( ) ; Hashtable state = new Hashtable ( ) ; Stack visiting = new Stack ( ) ; tsort ( root , targets , state , visiting , ret ) ; log ( "Build sequence for target `" + root + "' is " + ret , MSG_VERBOSE ) ; for ( Enumeration en = targets . keys ( ) ; en . hasMoreElements ( ) ; ) { String curTarget = ( String ) en . nextElement ( ) ; String st = ( String ) state . get ( curTarget ) ; if ( st == null ) { tsort ( curTarget , targets , state , visiting , ret ) ; } else if ( st == VISITING ) { throw new RuntimeException ( "Unexpected node in visiting state: " + curTarget ) ; } } log ( "Complete build sequence is " + ret , MSG_VERBOSE ) ; return ret ; } private final void tsort ( String root , Hashtable targets , Hashtable state , Stack visiting , Vector ret ) throws BuildException { state . put ( root , VISITING ) ; visiting . push ( root ) ; Target target = ( Target ) targets . get ( root ) ; if ( target == null ) { StringBuffer sb = new StringBuffer ( "Target `" ) ; sb . append ( root ) ; sb . append ( "' does not exist in this project. " ) ; visiting . pop ( ) ; if ( ! visiting . empty ( ) ) { String parent = ( String ) visiting . peek ( ) ; sb . append ( "It is used from target `" ) ; sb . append ( parent ) ; sb . append ( "'." ) ; } throw new BuildException ( new String ( sb ) ) ; } for ( Enumeration en = target . getDependencies ( ) ; en . hasMoreElements ( ) ; ) { String cur = ( String ) en . nextElement ( ) ; String m = ( String ) state . get ( cur ) ; if ( m == null ) { tsort ( cur , targets , state , visiting , ret ) ; } else if ( m == VISITING ) { throw makeCircularException ( cur , visiting ) ; } } String p = ( String ) visiting . pop ( ) ; if ( root != p ) { throw new RuntimeException ( "Unexpected internal error: expected to " + "pop " + root + " but got " + p ) ; } state . put ( root , VISITED ) ; ret . addElement ( target ) ; } private static BuildException makeCircularException ( String end , Stack stk ) { StringBuffer sb = new StringBuffer ( "Circular dependency: " ) ; sb . append ( end ) ; String c ; do { c = ( String ) stk . pop ( ) ; sb . append ( " <- " ) ; sb . append ( c ) ; } while ( ! c . equals ( end ) ) ; return new BuildException ( new String ( sb ) ) ; } public void addReference ( String name , Object value ) { synchronized ( references ) { Object old = ( ( AntRefTable ) references ) . getReal ( name ) ; if ( old == value ) { return ; } if ( old != null && ! ( old instanceof UnknownElement ) ) { log ( "Overriding previous definition of reference to " + name , MSG_WARN ) ; } log ( "Adding reference: " + name , MSG_DEBUG ) ; references . put ( name , value ) ; } } public Hashtable getReferences ( ) { return references ; } public Object getReference ( String key ) { return references . get ( key ) ; } public String getElementName ( Object element ) { return ComponentHelper . getComponentHelper ( this ) . getElementName ( element ) ; } public void fireBuildStarted ( ) { BuildEvent event = new BuildEvent ( this ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . buildStarted ( event ) ; } } public void fireBuildFinished ( Throwable exception ) { BuildEvent event = new BuildEvent ( this ) ; event . setException ( exception ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . buildFinished ( event ) ; } } protected void fireTargetStarted ( Target target ) { BuildEvent event = new BuildEvent ( target ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . targetStarted ( event ) ; } } protected void fireTargetFinished ( Target target , Throwable exception ) { BuildEvent event = new BuildEvent ( target ) ; event . setException ( exception ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . targetFinished ( event ) ; } } protected void fireTaskStarted ( Task task ) { registerThreadTask ( Thread . currentThread ( ) , task ) ; BuildEvent event = new BuildEvent ( task ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . taskStarted ( event ) ; } } protected void fireTaskFinished ( Task task , Throwable exception ) { registerThreadTask ( Thread . currentThread ( ) , null ) ; System . out . flush ( ) ; System . err . flush ( ) ; BuildEvent event = new BuildEvent ( task ) ; event . setException ( exception ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . taskFinished ( event ) ; } } private void fireMessageLoggedEvent ( BuildEvent event , String message , int priority ) { if ( message . endsWith ( StringUtils . LINE_SEP ) ) { int endIndex = message . length ( ) - StringUtils . LINE_SEP . length ( ) ; event . setMessage ( message . substring ( 0 , endIndex ) , priority ) ; } else { event . setMessage ( message , priority ) ; } synchronized ( this ) { if ( loggingMessage ) { throw new BuildException ( "Listener attempted to access " + ( priority == MSG_ERR ? "System.err" : "System.out" ) + " - infinite loop terminated" ) ; } try { loggingMessage = true ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . messageLogged ( event ) ; } } finally { loggingMessage = false ; } } } protected void fireMessageLogged ( Project project , String message , int priority ) { BuildEvent event = new BuildEvent ( project ) ; fireMessageLoggedEvent ( event , message , priority ) ; } protected void fireMessageLogged ( Target target , String message , int priority ) { BuildEvent event = new BuildEvent ( target ) ; fireMessageLoggedEvent ( event , message , priority ) ; } protected void fireMessageLogged ( Task task , String message , int priority ) { BuildEvent event = new BuildEvent ( task ) ; fireMessageLoggedEvent ( event , message , priority ) ; } public synchronized void registerThreadTask ( Thread thread , Task task ) { if ( task != null ) { threadTasks . put ( thread , task ) ; threadGroupTasks . put ( thread . getThreadGroup ( ) , task ) ; } else { threadTasks . remove ( thread ) ; threadGroupTasks . remove ( thread . getThreadGroup ( ) ) ; } } public Task getThreadTask ( Thread thread ) { Task task = ( Task ) threadTasks . get ( thread ) ; if ( task == null ) { ThreadGroup group = thread . getThreadGroup ( ) ; while ( task == null && group != null ) { task = ( Task ) threadGroupTasks . get ( group ) ; group = group . getParent ( ) ; } } return task ; } private static class AntRefTable extends Hashtable { private Project project ; public AntRefTable ( Project project ) { super ( ) ; this . project = project ; } public Object getReal ( Object key ) { return super . get ( key ) ; } public Object get ( Object key ) { Object o = super . get ( key ) ; if ( o instanceof UnknownElement ) { UnknownElement ue = ( UnknownElement ) o ; ue . maybeConfigure ( ) ; o = ue . getRealThing ( ) ; } return o ; } } public final void setProjectReference ( final Object obj ) { if ( obj instanceof ProjectComponent ) { ( ( ProjectComponent ) obj ) . setProject ( this ) ; return ; } try { Method method = obj . getClass ( ) . getMethod ( "setProject" , new Class [ ] { Project . class } ) ; if ( method != null ) { method . invoke ( obj , new Object [ ] { this } ) ; } } catch ( Throwable e ) { } } } 	1	['100', '1', '0', '202', '247', '4576', '193', '23', '87', '0.979500891', '2015', '0.588235294', '4', '0', '0.090869565', '0', '0', '18.81', '7', '1.4', '5']
package org . apache . tools . ant . taskdefs ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . util . JavaEnvUtils ; public class GenerateKey extends Task { public static class DnameParam { private String name ; private String value ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } } public static class DistinguishedName { private Vector params = new Vector ( ) ; public Object createParam ( ) { DnameParam param = new DnameParam ( ) ; params . addElement ( param ) ; return param ; } public Enumeration getParams ( ) { return params . elements ( ) ; } public String toString ( ) { final int size = params . size ( ) ; final StringBuffer sb = new StringBuffer ( ) ; boolean firstPass = true ; for ( int i = 0 ; i < size ; i ++ ) { if ( ! firstPass ) { sb . append ( " ," ) ; } firstPass = false ; final DnameParam param = ( DnameParam ) params . elementAt ( i ) ; sb . append ( encode ( param . getName ( ) ) ) ; sb . append ( '=' ) ; sb . append ( encode ( param . getValue ( ) ) ) ; } return sb . toString ( ) ; } public String encode ( final String string ) { int end = string . indexOf ( ',' ) ; if ( - 1 == end ) { return string ; } final StringBuffer sb = new StringBuffer ( ) ; int start = 0 ; while ( - 1 != end ) { sb . append ( string . substring ( start , end ) ) ; sb . append ( "\\," ) ; start = end + 1 ; end = string . indexOf ( ',' , start ) ; } sb . append ( string . substring ( start ) ) ; return sb . toString ( ) ; } } protected String alias ; protected String keystore ; protected String storepass ; protected String storetype ; protected String keypass ; protected String sigalg ; protected String keyalg ; protected String dname ; protected DistinguishedName expandedDname ; protected int keysize ; protected int validity ; protected boolean verbose ; public DistinguishedName createDname ( ) throws BuildException { if ( null != expandedDname ) { throw new BuildException ( "DName sub-element can only be " + "specified once." ) ; } if ( null != dname ) { throw new BuildException ( "It is not possible to specify dname " + " both as attribute and element." ) ; } expandedDname = new DistinguishedName ( ) ; return expandedDname ; } public void setDname ( final String dname ) { if ( null != expandedDname ) { throw new BuildException ( "It is not possible to specify dname " + " both as attribute and element." ) ; } this . dname = dname ; } public void setAlias ( final String alias ) { this . alias = alias ; } public void setKeystore ( final String keystore ) { this . keystore = keystore ; } public void setStorepass ( final String storepass ) { this . storepass = storepass ; } public void setStoretype ( final String storetype ) { this . storetype = storetype ; } public void setKeypass ( final String keypass ) { this . keypass = keypass ; } public void setSigalg ( final String sigalg ) { this . sigalg = sigalg ; } public void setKeyalg ( final String keyalg ) { this . keyalg = keyalg ; } public void setKeysize ( final String keysize ) throws BuildException { try { this . keysize = Integer . parseInt ( keysize ) ; } catch ( final NumberFormatException nfe ) { throw new BuildException ( "KeySize attribute should be a integer" ) ; } } public void setValidity ( final String validity ) throws BuildException { try { this . validity = Integer . parseInt ( validity ) ; } catch ( final NumberFormatException nfe ) { throw new BuildException ( "Validity attribute should be a integer" ) ; } } public void setVerbose ( final boolean verbose ) { this . verbose = verbose ; } public void execute ( ) throws BuildException { if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { throw new BuildException ( "The genkey task is only available on JDK" + " versions 1.2 or greater" ) ; } if ( null == alias ) { throw new BuildException ( "alias attribute must be set" ) ; } if ( null == storepass ) { throw new BuildException ( "storepass attribute must be set" ) ; } if ( null == dname && null == expandedDname ) { throw new BuildException ( "dname must be set" ) ; } final StringBuffer sb = new StringBuffer ( ) ; sb . append ( "-genkey " ) ; if ( verbose ) { sb . append ( "-v " ) ; } sb . append ( "-alias \"" ) ; sb . append ( alias ) ; sb . append ( "\" " ) ; if ( null != dname ) { sb . append ( "-dname \"" ) ; sb . append ( dname ) ; sb . append ( "\" " ) ; } if ( null != expandedDname ) { sb . append ( "-dname \"" ) ; sb . append ( expandedDname ) ; sb . append ( "\" " ) ; } if ( null != keystore ) { sb . append ( "-keystore \"" ) ; sb . append ( keystore ) ; sb . append ( "\" " ) ; } if ( null != storepass ) { sb . append ( "-storepass \"" ) ; sb . append ( storepass ) ; sb . append ( "\" " ) ; } if ( null != storetype ) { sb . append ( "-storetype \"" ) ; sb . append ( storetype ) ; sb . append ( "\" " ) ; } sb . append ( "-keypass \"" ) ; if ( null != keypass ) { sb . append ( keypass ) ; } else { sb . append ( storepass ) ; } sb . append ( "\" " ) ; if ( null != sigalg ) { sb . append ( "-sigalg \"" ) ; sb . append ( sigalg ) ; sb . append ( "\" " ) ; } if ( null != keyalg ) { sb . append ( "-keyalg \"" ) ; sb . append ( keyalg ) ; sb . append ( "\" " ) ; } if ( 0 < keysize ) { sb . append ( "-keysize \"" ) ; sb . append ( keysize ) ; sb . append ( "\" " ) ; } if ( 0 < validity ) { sb . append ( "-validity \"" ) ; sb . append ( validity ) ; sb . append ( "\" " ) ; } log ( "Generating Key for " + alias ) ; final ExecTask cmd = ( ExecTask ) getProject ( ) . createTask ( "exec" ) ; cmd . setExecutable ( "keytool" ) ; Commandline . Argument arg = cmd . createArg ( ) ; arg . setLine ( sb . toString ( ) ) ; cmd . setFailonerror ( true ) ; cmd . setTaskName ( getTaskName ( ) ) ; cmd . execute ( ) ; } } 	0	['14', '3', '0', '8', '34', '65', '0', '8', '14', '0.91025641', '404', '1', '1', '0.74', '0.595238095', '1', '2', '27', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . PrintStream ; import org . apache . tools . ant . BuildEvent ; import org . apache . tools . ant . BuildLogger ; import org . apache . tools . ant . DefaultLogger ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . StringUtils ; public class RecorderEntry implements BuildLogger { private String filename = null ; private boolean record = true ; private int loglevel = Project . MSG_INFO ; private PrintStream out = null ; private long targetStartTime = 0L ; private boolean emacsMode = false ; protected RecorderEntry ( String name ) { targetStartTime = System . currentTimeMillis ( ) ; filename = name ; } public String getFilename ( ) { return filename ; } public void setRecordState ( Boolean state ) { if ( state != null ) { record = state . booleanValue ( ) ; } } public void buildStarted ( BuildEvent event ) { log ( "> BUILD STARTED" , Project . MSG_DEBUG ) ; } public void buildFinished ( BuildEvent event ) { log ( "< BUILD FINISHED" , Project . MSG_DEBUG ) ; Throwable error = event . getException ( ) ; if ( error == null ) { out . println ( StringUtils . LINE_SEP + "BUILD SUCCESSFUL" ) ; } else { out . println ( StringUtils . LINE_SEP + "BUILD FAILED" + StringUtils . LINE_SEP ) ; error . printStackTrace ( out ) ; } out . flush ( ) ; out . close ( ) ; } public void targetStarted ( BuildEvent event ) { log ( ">> TARGET STARTED -- " + event . getTarget ( ) , Project . MSG_DEBUG ) ; log ( StringUtils . LINE_SEP + event . getTarget ( ) . getName ( ) + ":" , Project . MSG_INFO ) ; targetStartTime = System . currentTimeMillis ( ) ; } public void targetFinished ( BuildEvent event ) { log ( "<< TARGET FINISHED -- " + event . getTarget ( ) , Project . MSG_DEBUG ) ; String time = formatTime ( System . currentTimeMillis ( ) - targetStartTime ) ; log ( event . getTarget ( ) + ":  duration " + time , Project . MSG_VERBOSE ) ; out . flush ( ) ; } public void taskStarted ( BuildEvent event ) { log ( ">>> TASK STARTED -- " + event . getTask ( ) , Project . MSG_DEBUG ) ; } public void taskFinished ( BuildEvent event ) { log ( "<<< TASK FINISHED -- " + event . getTask ( ) , Project . MSG_DEBUG ) ; out . flush ( ) ; } public void messageLogged ( BuildEvent event ) { log ( "--- MESSAGE LOGGED" , Project . MSG_DEBUG ) ; StringBuffer buf = new StringBuffer ( ) ; if ( event . getTask ( ) != null ) { String name = event . getTask ( ) . getTaskName ( ) ; if ( ! emacsMode ) { String label = "[" + name + "] " ; int size = DefaultLogger . LEFT_COLUMN_SIZE - label . length ( ) ; for ( int i = 0 ; i < size ; i ++ ) { buf . append ( " " ) ; } buf . append ( label ) ; } } buf . append ( event . getMessage ( ) ) ; log ( buf . toString ( ) , event . getPriority ( ) ) ; } private void log ( String mesg , int level ) { if ( record && ( level <= loglevel ) ) { out . println ( mesg ) ; } } public void setMessageOutputLevel ( int level ) { if ( level >= Project . MSG_ERR && level <= Project . MSG_DEBUG ) { loglevel = level ; } } public void setOutputPrintStream ( PrintStream output ) { out = output ; } public void setEmacsMode ( boolean emacsMode ) { this . emacsMode = emacsMode ; } public void setErrorPrintStream ( PrintStream err ) { out = err ; } private static String formatTime ( long millis ) { long seconds = millis / 1000 ; long minutes = seconds / 60 ; if ( minutes > 0 ) { return Long . toString ( minutes ) + " minute" + ( minutes == 1 ? " " : "s " ) + Long . toString ( seconds % 60 ) + " second" + ( seconds % 60 == 1 ? "" : "s" ) ; } else { return Long . toString ( seconds ) + " second" + ( seconds % 60 == 1 ? "" : "s" ) ; } } } 	1	['16', '1', '0', '6', '36', '58', '1', '5', '13', '0.633333333', '366', '1', '0', '0', '0.2421875', '0', '0', '21.5', '5', '1.75', '2']
package org . apache . tools . ant . types . selectors . modifiedselector ; import java . util . Iterator ; public interface Cache { boolean isValid ( ) ; void delete ( ) ; void load ( ) ; void save ( ) ; Object get ( Object key ) ; void put ( Object key , Object value ) ; Iterator iterator ( ) ; } 	0	['7', '1', '0', '2', '7', '21', '2', '0', '7', '2', '7', '0', '0', '0', '0.642857143', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . compilers . CompilerAdapter ; import org . apache . tools . ant . taskdefs . compilers . CompilerAdapterFactory ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . GlobPatternMapper ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . apache . tools . ant . util . SourceFileScanner ; import org . apache . tools . ant . util . facade . FacadeTaskHelper ; public class Javac extends MatchingTask { private static final String FAIL_MSG = "Compile failed; see the compiler error output for details." ; private Path src ; private File destDir ; private Path compileClasspath ; private Path compileSourcepath ; private String encoding ; private boolean debug = false ; private boolean optimize = false ; private boolean deprecation = false ; private boolean depend = false ; private boolean verbose = false ; private String target ; private Path bootclasspath ; private Path extdirs ; private boolean includeAntRuntime = true ; private boolean includeJavaRuntime = false ; private boolean fork = false ; private String forkedExecutable = null ; private boolean nowarn = false ; private String memoryInitialSize ; private String memoryMaximumSize ; private FacadeTaskHelper facade = null ; protected boolean failOnError = true ; protected boolean listFiles = false ; protected File [ ] compileList = new File [ 0 ] ; private String source ; private String debugLevel ; private File tmpDir ; public Javac ( ) { if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { facade = new FacadeTaskHelper ( "javac1.1" ) ; } else if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_2 ) ) { facade = new FacadeTaskHelper ( "javac1.2" ) ; } else if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_3 ) ) { facade = new FacadeTaskHelper ( "javac1.3" ) ; } else if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_4 ) ) { facade = new FacadeTaskHelper ( "javac1.4" ) ; } else { facade = new FacadeTaskHelper ( "classic" ) ; } } public String getDebugLevel ( ) { return debugLevel ; } public void setDebugLevel ( String v ) { this . debugLevel = v ; } public String getSource ( ) { return source ; } public void setSource ( String v ) { this . source = v ; } public Path createSrc ( ) { if ( src == null ) { src = new Path ( getProject ( ) ) ; } return src . createPath ( ) ; } protected Path recreateSrc ( ) { src = null ; return createSrc ( ) ; } public void setSrcdir ( Path srcDir ) { if ( src == null ) { src = srcDir ; } else { src . append ( srcDir ) ; } } public Path getSrcdir ( ) { return src ; } public void setDestdir ( File destDir ) { this . destDir = destDir ; } public File getDestdir ( ) { return destDir ; } public void setSourcepath ( Path sourcepath ) { if ( compileSourcepath == null ) { compileSourcepath = sourcepath ; } else { compileSourcepath . append ( sourcepath ) ; } } public Path getSourcepath ( ) { return compileSourcepath ; } public Path createSourcepath ( ) { if ( compileSourcepath == null ) { compileSourcepath = new Path ( getProject ( ) ) ; } return compileSourcepath . createPath ( ) ; } public void setSourcepathRef ( Reference r ) { createSourcepath ( ) . setRefid ( r ) ; } public void setClasspath ( Path classpath ) { if ( compileClasspath == null ) { compileClasspath = classpath ; } else { compileClasspath . append ( classpath ) ; } } public Path getClasspath ( ) { return compileClasspath ; } public Path createClasspath ( ) { if ( compileClasspath == null ) { compileClasspath = new Path ( getProject ( ) ) ; } return compileClasspath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setBootclasspath ( Path bootclasspath ) { if ( this . bootclasspath == null ) { this . bootclasspath = bootclasspath ; } else { this . bootclasspath . append ( bootclasspath ) ; } } public Path getBootclasspath ( ) { return bootclasspath ; } public Path createBootclasspath ( ) { if ( bootclasspath == null ) { bootclasspath = new Path ( getProject ( ) ) ; } return bootclasspath . createPath ( ) ; } public void setBootClasspathRef ( Reference r ) { createBootclasspath ( ) . setRefid ( r ) ; } public void setExtdirs ( Path extdirs ) { if ( this . extdirs == null ) { this . extdirs = extdirs ; } else { this . extdirs . append ( extdirs ) ; } } public Path getExtdirs ( ) { return extdirs ; } public Path createExtdirs ( ) { if ( extdirs == null ) { extdirs = new Path ( getProject ( ) ) ; } return extdirs . createPath ( ) ; } public void setListfiles ( boolean list ) { listFiles = list ; } public boolean getListfiles ( ) { return listFiles ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } public void setProceed ( boolean proceed ) { failOnError = ! proceed ; } public boolean getFailonerror ( ) { return failOnError ; } public void setDeprecation ( boolean deprecation ) { this . deprecation = deprecation ; } public boolean getDeprecation ( ) { return deprecation ; } public void setMemoryInitialSize ( String memoryInitialSize ) { this . memoryInitialSize = memoryInitialSize ; } public String getMemoryInitialSize ( ) { return memoryInitialSize ; } public void setMemoryMaximumSize ( String memoryMaximumSize ) { this . memoryMaximumSize = memoryMaximumSize ; } public String getMemoryMaximumSize ( ) { return memoryMaximumSize ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String getEncoding ( ) { return encoding ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public boolean getDebug ( ) { return debug ; } public void setOptimize ( boolean optimize ) { this . optimize = optimize ; } public boolean getOptimize ( ) { return optimize ; } public void setDepend ( boolean depend ) { this . depend = depend ; } public boolean getDepend ( ) { return depend ; } public void setVerbose ( boolean verbose ) { this . verbose = verbose ; } public boolean getVerbose ( ) { return verbose ; } public void setTarget ( String target ) { this . target = target ; } public String getTarget ( ) { return target ; } public void setIncludeantruntime ( boolean include ) { includeAntRuntime = include ; } public boolean getIncludeantruntime ( ) { return includeAntRuntime ; } public void setIncludejavaruntime ( boolean include ) { includeJavaRuntime = include ; } public boolean getIncludejavaruntime ( ) { return includeJavaRuntime ; } public void setFork ( boolean f ) { fork = f ; } public void setExecutable ( String forkExec ) { forkedExecutable = forkExec ; } public String getExecutable ( ) { return forkedExecutable ; } public boolean isForkedJavac ( ) { return fork || "extJavac" . equals ( getCompiler ( ) ) ; } public String getJavacExecutable ( ) { if ( forkedExecutable == null && isForkedJavac ( ) ) { forkedExecutable = getSystemJavac ( ) ; } else if ( forkedExecutable != null && ! isForkedJavac ( ) ) { forkedExecutable = null ; } return forkedExecutable ; } public void setNowarn ( boolean flag ) { this . nowarn = flag ; } public boolean getNowarn ( ) { return nowarn ; } public ImplementationSpecificArgument createCompilerArg ( ) { ImplementationSpecificArgument arg = new ImplementationSpecificArgument ( ) ; facade . addImplementationArgument ( arg ) ; return arg ; } public String [ ] getCurrentCompilerArgs ( ) { String chosen = facade . getExplicitChoice ( ) ; facade . setImplementation ( getCompiler ( ) ) ; try { return facade . getArgs ( ) ; } finally { facade . setImplementation ( chosen ) ; } } public void setTempdir ( File tmpDir ) { this . tmpDir = tmpDir ; } public File getTempdir ( ) { return tmpDir ; } public void execute ( ) throws BuildException { checkParameters ( ) ; resetFileLists ( ) ; String [ ] list = src . list ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { File srcDir = getProject ( ) . resolveFile ( list [ i ] ) ; if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir \"" + srcDir . getPath ( ) + "\" does not exist!" , getLocation ( ) ) ; } DirectoryScanner ds = this . getDirectoryScanner ( srcDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( srcDir , destDir != null ? destDir : srcDir , files ) ; } compile ( ) ; } protected void resetFileLists ( ) { compileList = new File [ 0 ] ; } protected void scanDir ( File srcDir , File destDir , String [ ] files ) { GlobPatternMapper m = new GlobPatternMapper ( ) ; m . setFrom ( "*.java" ) ; m . setTo ( "*.class" ) ; SourceFileScanner sfs = new SourceFileScanner ( this ) ; File [ ] newFiles = sfs . restrictAsFiles ( files , srcDir , destDir , m ) ; if ( newFiles . length > 0 ) { File [ ] newCompileList = new File [ compileList . length + newFiles . length ] ; System . arraycopy ( compileList , 0 , newCompileList , 0 , compileList . length ) ; System . arraycopy ( newFiles , 0 , newCompileList , compileList . length , newFiles . length ) ; compileList = newCompileList ; } } public File [ ] getFileList ( ) { return compileList ; } protected boolean isJdkCompiler ( String compilerImpl ) { return "modern" . equals ( compilerImpl ) || "classic" . equals ( compilerImpl ) || "javac1.1" . equals ( compilerImpl ) || "javac1.2" . equals ( compilerImpl ) || "javac1.3" . equals ( compilerImpl ) || "javac1.4" . equals ( compilerImpl ) ; } protected String getSystemJavac ( ) { return JavaEnvUtils . getJdkExecutable ( "javac" ) ; } public void setCompiler ( String compiler ) { facade . setImplementation ( compiler ) ; } public String getCompiler ( ) { String compilerImpl = getCompilerVersion ( ) ; if ( fork ) { if ( isJdkCompiler ( compilerImpl ) ) { if ( facade . hasBeenSet ( ) ) { log ( "Since fork is true, ignoring compiler setting." , Project . MSG_WARN ) ; } compilerImpl = "extJavac" ; } else { log ( "Since compiler setting isn't classic or modern," + "ignoring fork setting." , Project . MSG_WARN ) ; } } return compilerImpl ; } public String getCompilerVersion ( ) { facade . setMagicValue ( getProject ( ) . getProperty ( "build.compiler" ) ) ; return facade . getImplementation ( ) ; } protected void checkParameters ( ) throws BuildException { if ( src == null ) { throw new BuildException ( "srcdir attribute must be set!" , getLocation ( ) ) ; } if ( src . size ( ) == 0 ) { throw new BuildException ( "srcdir attribute must be set!" , getLocation ( ) ) ; } if ( destDir != null && ! destDir . isDirectory ( ) ) { throw new BuildException ( "destination directory \"" + destDir + "\" does not exist " + "or is not a directory" , getLocation ( ) ) ; } } protected void compile ( ) { String compilerImpl = getCompiler ( ) ; if ( compileList . length > 0 ) { log ( "Compiling " + compileList . length + " source file" + ( compileList . length == 1 ? "" : "s" ) + ( destDir != null ? " to " + destDir : "" ) ) ; if ( listFiles ) { for ( int i = 0 ; i < compileList . length ; i ++ ) { String filename = compileList [ i ] . getAbsolutePath ( ) ; log ( filename ) ; } } CompilerAdapter adapter = CompilerAdapterFactory . getCompiler ( compilerImpl , this ) ; adapter . setJavac ( this ) ; if ( ! adapter . execute ( ) ) { if ( failOnError ) { throw new BuildException ( FAIL_MSG , getLocation ( ) ) ; } else { log ( FAIL_MSG , Project . MSG_ERR ) ; } } } } public class ImplementationSpecificArgument extends org . apache . tools . ant . util . facade . ImplementationSpecificArgument { public void setCompiler ( String impl ) { super . setImplementation ( impl ) ; } } } 	1	['75', '4', '0', '27', '121', '2541', '11', '18', '68', '0.96476834', '918', '1', '6', '0.513157895', '0.205714286', '1', '1', '10.86666667', '8', '1.4667', '3']
package org . apache . tools . ant . taskdefs . email ; import java . io . File ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; public class EmailTask extends Task { public static final String AUTO = "auto" ; public static final String MIME = "mime" ; public static final String UU = "uu" ; public static final String PLAIN = "plain" ; public static class Encoding extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { AUTO , MIME , UU , PLAIN } ; } } private String encoding = AUTO ; private String host = "localhost" ; private int port = 25 ; private String subject = null ; private Message message = null ; private boolean failOnError = true ; private boolean includeFileNames = false ; private String messageMimeType = null ; private EmailAddress from = null ; private Vector replyToList = new Vector ( ) ; private Vector toList = new Vector ( ) ; private Vector ccList = new Vector ( ) ; private Vector bccList = new Vector ( ) ; private Vector files = new Vector ( ) ; private Vector filesets = new Vector ( ) ; private String charset = null ; private String user = null ; private String password = null ; private boolean SSL = false ; public void setUser ( String user ) { this . user = user ; } public void setPassword ( String password ) { this . password = password ; } public void setSSL ( boolean SSL ) { this . SSL = SSL ; } public void setEncoding ( Encoding encoding ) { this . encoding = encoding . getValue ( ) ; } public void setMailport ( int port ) { this . port = port ; } public void setMailhost ( String host ) { this . host = host ; } public void setSubject ( String subject ) { this . subject = subject ; } public void setMessage ( String message ) { if ( this . message != null ) { throw new BuildException ( "Only one message can be sent in an " + "email" ) ; } this . message = new Message ( message ) ; this . message . setProject ( getProject ( ) ) ; } public void setMessageFile ( File file ) { if ( this . message != null ) { throw new BuildException ( "Only one message can be sent in an " + "email" ) ; } this . message = new Message ( file ) ; this . message . setProject ( getProject ( ) ) ; } public void setMessageMimeType ( String type ) { this . messageMimeType = type ; } public void addMessage ( Message message ) throws BuildException { if ( this . message != null ) { throw new BuildException ( "Only one message can be sent in an " + "email" ) ; } this . message = message ; } public void addFrom ( EmailAddress address ) { if ( this . from != null ) { throw new BuildException ( "Emails can only be from one address" ) ; } this . from = address ; } public void setFrom ( String address ) { if ( this . from != null ) { throw new BuildException ( "Emails can only be from one address" ) ; } this . from = new EmailAddress ( address ) ; } public void addReplyTo ( EmailAddress address ) { this . replyToList . add ( address ) ; } public void setReplyTo ( String address ) { this . replyToList . add ( new EmailAddress ( address ) ) ; } public void addTo ( EmailAddress address ) { toList . addElement ( address ) ; } public void setToList ( String list ) { StringTokenizer tokens = new StringTokenizer ( list , "," ) ; while ( tokens . hasMoreTokens ( ) ) { toList . addElement ( new EmailAddress ( tokens . nextToken ( ) ) ) ; } } public void addCc ( EmailAddress address ) { ccList . addElement ( address ) ; } public void setCcList ( String list ) { StringTokenizer tokens = new StringTokenizer ( list , "," ) ; while ( tokens . hasMoreTokens ( ) ) { ccList . addElement ( new EmailAddress ( tokens . nextToken ( ) ) ) ; } } public void addBcc ( EmailAddress address ) { bccList . addElement ( address ) ; } public void setBccList ( String list ) { StringTokenizer tokens = new StringTokenizer ( list , "," ) ; while ( tokens . hasMoreTokens ( ) ) { bccList . addElement ( new EmailAddress ( tokens . nextToken ( ) ) ) ; } } public void setFailOnError ( boolean failOnError ) { this . failOnError = failOnError ; } public void setFiles ( String filenames ) { StringTokenizer t = new StringTokenizer ( filenames , ", " ) ; while ( t . hasMoreTokens ( ) ) { files . addElement ( getProject ( ) . resolveFile ( t . nextToken ( ) ) ) ; } } public void addFileset ( FileSet fs ) { filesets . addElement ( fs ) ; } public void setIncludefilenames ( boolean includeFileNames ) { this . includeFileNames = includeFileNames ; } public boolean getIncludeFileNames ( ) { return includeFileNames ; } public void execute ( ) { Message savedMessage = message ; Vector savedFiles = ( Vector ) files . clone ( ) ; try { Mailer mailer = null ; boolean autoFound = false ; if ( encoding . equals ( MIME ) || ( encoding . equals ( AUTO ) && ! autoFound ) ) { try { mailer = ( Mailer ) Class . forName ( "org.apache.tools.ant.taskdefs.email.MimeMailer" ) . newInstance ( ) ; autoFound = true ; log ( "Using MIME mail" , Project . MSG_VERBOSE ) ; } catch ( Throwable e ) { log ( "Failed to initialise MIME mail: " + e . getMessage ( ) , Project . MSG_WARN ) ; } } if ( autoFound == false && ( ( user != null ) || ( password != null ) ) && ( encoding . equals ( UU ) || encoding . equals ( PLAIN ) ) ) { throw new BuildException ( "SMTP auth only possible with MIME mail" ) ; } if ( autoFound == false && ( SSL ) && ( encoding . equals ( UU ) || encoding . equals ( PLAIN ) ) ) { throw new BuildException ( "SSL only possible with MIME mail" ) ; } if ( encoding . equals ( UU ) || ( encoding . equals ( AUTO ) && ! autoFound ) ) { try { mailer = ( Mailer ) Class . forName ( "org.apache.tools.ant.taskdefs.email.UUMailer" ) . newInstance ( ) ; autoFound = true ; log ( "Using UU mail" , Project . MSG_VERBOSE ) ; } catch ( Throwable e ) { log ( "Failed to initialise UU mail" , Project . MSG_WARN ) ; } } if ( encoding . equals ( PLAIN ) || ( encoding . equals ( AUTO ) && ! autoFound ) ) { mailer = new PlainMailer ( ) ; autoFound = true ; log ( "Using plain mail" , Project . MSG_VERBOSE ) ; } if ( mailer == null ) { throw new BuildException ( "Failed to initialise encoding: " + encoding ) ; } if ( message == null ) { message = new Message ( ) ; message . setProject ( getProject ( ) ) ; } if ( from == null || from . getAddress ( ) == null ) { throw new BuildException ( "A from element is required" ) ; } if ( toList . isEmpty ( ) && ccList . isEmpty ( ) && bccList . isEmpty ( ) ) { throw new BuildException ( "At least one of to,cc or bcc must " + "be supplied" ) ; } if ( messageMimeType != null ) { if ( message . isMimeTypeSpecified ( ) ) { throw new BuildException ( "The mime type can only be " + "specified in one location" ) ; } else { message . setMimeType ( messageMimeType ) ; } } if ( charset != null ) { if ( message . getCharset ( ) != null ) { throw new BuildException ( "The charset can only be " + "specified in one location" ) ; } else { message . setCharset ( charset ) ; } } Enumeration e = filesets . elements ( ) ; while ( e . hasMoreElements ( ) ) { FileSet fs = ( FileSet ) e . nextElement ( ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] includedFiles = ds . getIncludedFiles ( ) ; File baseDir = ds . getBasedir ( ) ; for ( int j = 0 ; j < includedFiles . length ; ++ j ) { File file = new File ( baseDir , includedFiles [ j ] ) ; files . addElement ( file ) ; } } log ( "Sending email: " + subject , Project . MSG_INFO ) ; log ( "From " + from , Project . MSG_VERBOSE ) ; log ( "ReplyTo " + replyToList , Project . MSG_VERBOSE ) ; log ( "To " + toList , Project . MSG_VERBOSE ) ; log ( "Cc " + ccList , Project . MSG_VERBOSE ) ; log ( "Bcc " + bccList , Project . MSG_VERBOSE ) ; mailer . setHost ( host ) ; mailer . setPort ( port ) ; mailer . setUser ( user ) ; mailer . setPassword ( password ) ; mailer . setSSL ( SSL ) ; mailer . setMessage ( message ) ; mailer . setFrom ( from ) ; mailer . setReplyToList ( replyToList ) ; mailer . setToList ( toList ) ; mailer . setCcList ( ccList ) ; mailer . setBccList ( bccList ) ; mailer . setFiles ( files ) ; mailer . setSubject ( subject ) ; mailer . setTask ( this ) ; mailer . setIncludeFileNames ( includeFileNames ) ; mailer . send ( ) ; int count = files . size ( ) ; log ( "Sent email with " + count + " attachment" + ( count == 1 ? "" : "s" ) , Project . MSG_INFO ) ; } catch ( BuildException e ) { log ( "Failed to send email" , Project . MSG_WARN ) ; if ( failOnError ) { throw e ; } } catch ( Exception e ) { log ( "Failed to send email" , Project . MSG_WARN ) ; if ( failOnError ) { throw new BuildException ( e ) ; } } finally { message = savedMessage ; files = savedFiles ; } } public void setCharset ( String charset ) { this . charset = charset ; } public String getCharset ( ) { return charset ; } } 	0	['30', '3', '1', '14', '89', '301', '1', '13', '30', '0.935532234', '844', '0.826086957', '2', '0.560606061', '0.207407407', '3', '3', '26.36666667', '39', '2.5', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . FileUtils ; import java . io . File ; import java . io . IOException ; import java . util . Vector ; public class ImportTask extends Task { private String file ; private boolean optional ; private static final FileUtils FILE_UTILS = FileUtils . newFileUtils ( ) ; public void setOptional ( boolean optional ) { this . optional = true ; } public void setFile ( String file ) { this . file = file ; } public void execute ( ) { if ( file == null ) { throw new BuildException ( "import requires file attribute" ) ; } if ( getOwningTarget ( ) == null || ! "" . equals ( getOwningTarget ( ) . getName ( ) ) ) { throw new BuildException ( "import only allowed as a top-level task" ) ; } ProjectHelper helper = ( ProjectHelper ) getProject ( ) . getReference ( "ant.projectHelper" ) ; Vector importStack = helper . getImportStack ( ) ; if ( importStack . size ( ) == 0 ) { throw new BuildException ( "import requires support in ProjectHelper" ) ; } if ( getLocation ( ) == null || getLocation ( ) . getFileName ( ) == null ) { throw new BuildException ( "Unable to get location of import task" ) ; } File buildFile = new File ( getLocation ( ) . getFileName ( ) ) ; buildFile = new File ( buildFile . getAbsolutePath ( ) ) ; getProject ( ) . log ( "Importing file " + file + " from " + buildFile . getAbsolutePath ( ) , Project . MSG_VERBOSE ) ; File buildFileParent = new File ( buildFile . getParent ( ) ) ; File importedFile = FILE_UTILS . resolveFile ( buildFileParent , file ) ; if ( ! importedFile . exists ( ) ) { String message = "Cannot find " + file + " imported from " + buildFile . getAbsolutePath ( ) ; if ( optional ) { getProject ( ) . log ( message , Project . MSG_VERBOSE ) ; return ; } else { throw new BuildException ( message ) ; } } importedFile = new File ( getPath ( importedFile ) ) ; if ( importStack . contains ( importedFile ) ) { getProject ( ) . log ( "Skipped already imported file:\n   " + importedFile + "\n" , Project . MSG_WARN ) ; return ; } try { helper . parse ( getProject ( ) , importedFile ) ; } catch ( BuildException ex ) { throw ProjectHelper . addLocationToBuildException ( ex , getLocation ( ) ) ; } } private static String getPath ( File file ) { try { return file . getCanonicalPath ( ) ; } catch ( IOException e ) { return file . getAbsolutePath ( ) ; } } } 	1	['6', '3', '0', '8', '32', '9', '0', '8', '4', '0.8', '194', '1', '1', '0.902439024', '0.35', '2', '2', '30.83333333', '10', '2.1667', '1']
package org . apache . tools . ant . util ; public class FlatFileNameMapper implements FileNameMapper { public void setFrom ( String from ) { } public void setTo ( String to ) { } public String [ ] mapFileName ( String sourceFileName ) { return new String [ ] { new java . io . File ( sourceFileName ) . getName ( ) } ; } } 	0	['4', '1', '0', '2', '7', '6', '1', '1', '4', '2', '20', '0', '0', '0', '0.875', '0', '0', '4', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . util . Enumeration ; import java . util . Vector ; import java . util . zip . GZIPOutputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . util . MergingMapper ; import org . apache . tools . ant . util . SourceFileScanner ; import org . apache . tools . bzip2 . CBZip2OutputStream ; import org . apache . tools . tar . TarConstants ; import org . apache . tools . tar . TarEntry ; import org . apache . tools . tar . TarOutputStream ; import org . apache . tools . zip . UnixStat ; public class Tar extends MatchingTask { public static final String WARN = "warn" ; public static final String FAIL = "fail" ; public static final String TRUNCATE = "truncate" ; public static final String GNU = "gnu" ; public static final String OMIT = "omit" ; File tarFile ; File baseDir ; private TarLongFileMode longFileMode = new TarLongFileMode ( ) ; Vector filesets = new Vector ( ) ; Vector fileSetFiles = new Vector ( ) ; private boolean longWarningGiven = false ; private TarCompressionMethod compression = new TarCompressionMethod ( ) ; public TarFileSet createTarFileSet ( ) { TarFileSet fileset = new TarFileSet ( ) ; filesets . addElement ( fileset ) ; return fileset ; } public void setTarfile ( File tarFile ) { this . tarFile = tarFile ; } public void setDestFile ( File destFile ) { this . tarFile = destFile ; } public void setBasedir ( File baseDir ) { this . baseDir = baseDir ; } public void setLongfile ( String mode ) { log ( "DEPRECATED - The setLongfile(String) method has been deprecated." + " Use setLongfile(Tar.TarLongFileMode) instead." ) ; this . longFileMode = new TarLongFileMode ( ) ; longFileMode . setValue ( mode ) ; } public void setLongfile ( TarLongFileMode mode ) { this . longFileMode = mode ; } public void setCompression ( TarCompressionMethod mode ) { this . compression = mode ; } public void execute ( ) throws BuildException { if ( tarFile == null ) { throw new BuildException ( "tarfile attribute must be set!" , getLocation ( ) ) ; } if ( tarFile . exists ( ) && tarFile . isDirectory ( ) ) { throw new BuildException ( "tarfile is a directory!" , getLocation ( ) ) ; } if ( tarFile . exists ( ) && ! tarFile . canWrite ( ) ) { throw new BuildException ( "Can not write to the specified tarfile!" , getLocation ( ) ) ; } Vector savedFileSets = ( Vector ) filesets . clone ( ) ; try { if ( baseDir != null ) { if ( ! baseDir . exists ( ) ) { throw new BuildException ( "basedir does not exist!" , getLocation ( ) ) ; } TarFileSet mainFileSet = new TarFileSet ( fileset ) ; mainFileSet . setDir ( baseDir ) ; filesets . addElement ( mainFileSet ) ; } if ( filesets . size ( ) == 0 ) { throw new BuildException ( "You must supply either a basedir " + "attribute or some nested filesets." , getLocation ( ) ) ; } boolean upToDate = true ; for ( Enumeration e = filesets . elements ( ) ; e . hasMoreElements ( ) ; ) { TarFileSet fs = ( TarFileSet ) e . nextElement ( ) ; String [ ] files = fs . getFiles ( getProject ( ) ) ; if ( ! archiveIsUpToDate ( files , fs . getDir ( getProject ( ) ) ) ) { upToDate = false ; } for ( int i = 0 ; i < files . length ; ++ i ) { if ( tarFile . equals ( new File ( fs . getDir ( getProject ( ) ) , files [ i ] ) ) ) { throw new BuildException ( "A tar file cannot include " + "itself" , getLocation ( ) ) ; } } } if ( upToDate ) { log ( "Nothing to do: " + tarFile . getAbsolutePath ( ) + " is up to date." , Project . MSG_INFO ) ; return ; } log ( "Building tar: " + tarFile . getAbsolutePath ( ) , Project . MSG_INFO ) ; TarOutputStream tOut = null ; try { tOut = new TarOutputStream ( compression . compress ( new BufferedOutputStream ( new FileOutputStream ( tarFile ) ) ) ) ; tOut . setDebug ( true ) ; if ( longFileMode . isTruncateMode ( ) ) { tOut . setLongFileMode ( TarOutputStream . LONGFILE_TRUNCATE ) ; } else if ( longFileMode . isFailMode ( ) || longFileMode . isOmitMode ( ) ) { tOut . setLongFileMode ( TarOutputStream . LONGFILE_ERROR ) ; } else { tOut . setLongFileMode ( TarOutputStream . LONGFILE_GNU ) ; } longWarningGiven = false ; for ( Enumeration e = filesets . elements ( ) ; e . hasMoreElements ( ) ; ) { TarFileSet fs = ( TarFileSet ) e . nextElement ( ) ; String [ ] files = fs . getFiles ( getProject ( ) ) ; if ( files . length > 1 && fs . getFullpath ( ) . length ( ) > 0 ) { throw new BuildException ( "fullpath attribute may only " + "be specified for " + "filesets that specify a " + "single file." ) ; } for ( int i = 0 ; i < files . length ; i ++ ) { File f = new File ( fs . getDir ( getProject ( ) ) , files [ i ] ) ; String name = files [ i ] . replace ( File . separatorChar , '/' ) ; tarFile ( f , tOut , name , fs ) ; } } } catch ( IOException ioe ) { String msg = "Problem creating TAR: " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } finally { if ( tOut != null ) { try { tOut . close ( ) ; } catch ( IOException e ) { } } } } finally { filesets = savedFileSets ; } } protected void tarFile ( File file , TarOutputStream tOut , String vPath , TarFileSet tarFileSet ) throws IOException { FileInputStream fIn = null ; String fullpath = tarFileSet . getFullpath ( ) ; if ( fullpath . length ( ) > 0 ) { vPath = fullpath ; } else { if ( vPath . length ( ) <= 0 ) { return ; } if ( file . isDirectory ( ) && ! vPath . endsWith ( "/" ) ) { vPath += "/" ; } String prefix = tarFileSet . getPrefix ( ) ; if ( prefix . length ( ) > 0 && ! prefix . endsWith ( "/" ) ) { prefix = prefix + "/" ; } vPath = prefix + vPath ; } if ( vPath . startsWith ( "/" ) && ! tarFileSet . getPreserveLeadingSlashes ( ) ) { int l = vPath . length ( ) ; if ( l <= 1 ) { return ; } vPath = vPath . substring ( 1 , l ) ; } try { if ( vPath . length ( ) >= TarConstants . NAMELEN ) { if ( longFileMode . isOmitMode ( ) ) { log ( "Omitting: " + vPath , Project . MSG_INFO ) ; return ; } else if ( longFileMode . isWarnMode ( ) ) { log ( "Entry: " + vPath + " longer than " + TarConstants . NAMELEN + " characters." , Project . MSG_WARN ) ; if ( ! longWarningGiven ) { log ( "Resulting tar file can only be processed " + "successfully by GNU compatible tar commands" , Project . MSG_WARN ) ; longWarningGiven = true ; } } else if ( longFileMode . isFailMode ( ) ) { throw new BuildException ( "Entry: " + vPath + " longer than " + TarConstants . NAMELEN + "characters." , getLocation ( ) ) ; } } TarEntry te = new TarEntry ( vPath ) ; te . setModTime ( file . lastModified ( ) ) ; if ( ! file . isDirectory ( ) ) { te . setSize ( file . length ( ) ) ; te . setMode ( tarFileSet . getMode ( ) ) ; } else { te . setMode ( tarFileSet . getDirMode ( ) ) ; } te . setUserName ( tarFileSet . getUserName ( ) ) ; te . setGroupName ( tarFileSet . getGroup ( ) ) ; tOut . putNextEntry ( te ) ; if ( ! file . isDirectory ( ) ) { fIn = new FileInputStream ( file ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { tOut . write ( buffer , 0 , count ) ; count = fIn . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } tOut . closeEntry ( ) ; } finally { if ( fIn != null ) { fIn . close ( ) ; } } } protected boolean archiveIsUpToDate ( String [ ] files ) { return archiveIsUpToDate ( files , baseDir ) ; } protected boolean archiveIsUpToDate ( String [ ] files , File dir ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; MergingMapper mm = new MergingMapper ( ) ; mm . setTo ( tarFile . getAbsolutePath ( ) ) ; return sfs . restrict ( files , dir , null , mm ) . length == 0 ; } public static class TarFileSet extends FileSet { private String [ ] files = null ; private int fileMode = UnixStat . FILE_FLAG | UnixStat . DEFAULT_FILE_PERM ; private int dirMode = UnixStat . DIR_FLAG | UnixStat . DEFAULT_DIR_PERM ; private String userName = "" ; private String groupName = "" ; private String prefix = "" ; private String fullpath = "" ; private boolean preserveLeadingSlashes = false ; public TarFileSet ( FileSet fileset ) { super ( fileset ) ; } public TarFileSet ( ) { super ( ) ; } public String [ ] getFiles ( Project p ) { if ( files == null ) { DirectoryScanner ds = getDirectoryScanner ( p ) ; String [ ] directories = ds . getIncludedDirectories ( ) ; String [ ] filesPerSe = ds . getIncludedFiles ( ) ; files = new String [ directories . length + filesPerSe . length ] ; System . arraycopy ( directories , 0 , files , 0 , directories . length ) ; System . arraycopy ( filesPerSe , 0 , files , directories . length , filesPerSe . length ) ; } return files ; } public void setMode ( String octalString ) { this . fileMode = UnixStat . FILE_FLAG | Integer . parseInt ( octalString , 8 ) ; } public int getMode ( ) { return fileMode ; } public void setDirMode ( String octalString ) { this . dirMode = UnixStat . DIR_FLAG | Integer . parseInt ( octalString , 8 ) ; } public int getDirMode ( ) { return dirMode ; } public void setUserName ( String userName ) { this . userName = userName ; } public String getUserName ( ) { return userName ; } public void setGroup ( String groupName ) { this . groupName = groupName ; } public String getGroup ( ) { return groupName ; } public void setPrefix ( String prefix ) { this . prefix = prefix ; } public String getPrefix ( ) { return prefix ; } public void setFullpath ( String fullpath ) { this . fullpath = fullpath ; } public String getFullpath ( ) { return fullpath ; } public void setPreserveLeadingSlashes ( boolean b ) { this . preserveLeadingSlashes = b ; } public boolean getPreserveLeadingSlashes ( ) { return preserveLeadingSlashes ; } } public static class TarLongFileMode extends EnumeratedAttribute { public static final String WARN = "warn" ; public static final String FAIL = "fail" ; public static final String TRUNCATE = "truncate" ; public static final String GNU = "gnu" ; public static final String OMIT = "omit" ; private final String [ ] validModes = { WARN , FAIL , TRUNCATE , GNU , OMIT } ; public TarLongFileMode ( ) { super ( ) ; setValue ( WARN ) ; } public String [ ] getValues ( ) { return validModes ; } public boolean isTruncateMode ( ) { return TRUNCATE . equalsIgnoreCase ( getValue ( ) ) ; } public boolean isWarnMode ( ) { return WARN . equalsIgnoreCase ( getValue ( ) ) ; } public boolean isGnuMode ( ) { return GNU . equalsIgnoreCase ( getValue ( ) ) ; } public boolean isFailMode ( ) { return FAIL . equalsIgnoreCase ( getValue ( ) ) ; } public boolean isOmitMode ( ) { return OMIT . equalsIgnoreCase ( getValue ( ) ) ; } } public static final class TarCompressionMethod extends EnumeratedAttribute { private static final String NONE = "none" ; private static final String GZIP = "gzip" ; private static final String BZIP2 = "bzip2" ; public TarCompressionMethod ( ) { super ( ) ; setValue ( NONE ) ; } public String [ ] getValues ( ) { return new String [ ] { NONE , GZIP , BZIP2 } ; } private OutputStream compress ( final OutputStream ostream ) throws IOException { final String value = getValue ( ) ; if ( GZIP . equals ( value ) ) { return new GZIPOutputStream ( ostream ) ; } else { if ( BZIP2 . equals ( value ) ) { ostream . write ( 'B' ) ; ostream . write ( 'Z' ) ; return new CBZip2OutputStream ( ostream ) ; } } return ostream ; } } } 	1	['12', '4', '0', '17', '87', '20', '0', '17', '9', '0.916666667', '687', '0.25', '2', '0.876404494', '0.260416667', '2', '2', '55.25', '2', '1', '1']
package org . apache . tools . ant . taskdefs ; public class Transform extends ExecuteOn { } 	0	['1', '5', '0', '1', '2', '0', '0', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . ByteArrayOutputStream ; import java . io . ByteArrayInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . StringReader ; import java . io . OutputStream ; import java . io . InputStream ; import java . io . PrintStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . LazyFileOutputStream ; import org . apache . tools . ant . util . StringUtils ; import org . apache . tools . ant . util . TeeOutputStream ; public class Redirector { private File out ; private File error ; private File input ; private boolean logError = false ; private ByteArrayOutputStream baos = null ; private ByteArrayOutputStream errorBaos = null ; private String outputProperty ; private String errorProperty ; private String inputString ; private boolean append = false ; private Task managingTask ; private OutputStream outputStream = null ; private OutputStream errorStream = null ; private InputStream inputStream = null ; private PrintStream outPrintStream = null ; private PrintStream errorPrintStream = null ; public Redirector ( Task managingTask ) { this . managingTask = managingTask ; } public void setInput ( File input ) { this . input = input ; } public void setInputString ( String inputString ) { this . inputString = inputString ; } public void setOutput ( File out ) { this . out = out ; } public void setLogError ( boolean logError ) { this . logError = logError ; } public void setError ( File error ) { this . error = error ; } public void setOutputProperty ( String outputProperty ) { this . outputProperty = outputProperty ; } public void setAppend ( boolean append ) { this . append = append ; } public void setErrorProperty ( String errorProperty ) { this . errorProperty = errorProperty ; } private void setPropertyFromBAOS ( ByteArrayOutputStream baos , String propertyName ) throws IOException { BufferedReader in = new BufferedReader ( new StringReader ( Execute . toString ( baos ) ) ) ; String line = null ; StringBuffer val = new StringBuffer ( ) ; while ( ( line = in . readLine ( ) ) != null ) { if ( val . length ( ) != 0 ) { val . append ( StringUtils . LINE_SEP ) ; } val . append ( line ) ; } managingTask . getProject ( ) . setNewProperty ( propertyName , val . toString ( ) ) ; } public void createStreams ( ) { if ( out == null && outputProperty == null ) { outputStream = new LogOutputStream ( managingTask , Project . MSG_INFO ) ; errorStream = new LogOutputStream ( managingTask , Project . MSG_WARN ) ; } else { if ( out != null ) { outputStream = new LazyFileOutputStream ( out , append ) ; managingTask . log ( "Output redirected to " + out , Project . MSG_VERBOSE ) ; } if ( outputProperty != null ) { baos = new ByteArrayOutputStream ( ) ; managingTask . log ( "Output redirected to property: " + outputProperty , Project . MSG_VERBOSE ) ; if ( out == null ) { outputStream = baos ; } else { outputStream = new TeeOutputStream ( outputStream , baos ) ; } } else { baos = null ; } errorStream = outputStream ; } if ( logError ) { errorStream = new LogOutputStream ( managingTask , Project . MSG_WARN ) ; } if ( error != null ) { errorStream = new LazyFileOutputStream ( error , append ) ; managingTask . log ( "Error redirected to " + error , Project . MSG_VERBOSE ) ; } if ( errorProperty != null ) { errorBaos = new ByteArrayOutputStream ( ) ; managingTask . log ( "Error redirected to property: " + errorProperty , Project . MSG_VERBOSE ) ; if ( error == null ) { errorStream = errorBaos ; } else { errorStream = new TeeOutputStream ( errorStream , errorBaos ) ; } } else { errorBaos = null ; } if ( input != null && inputString != null ) { throw new BuildException ( "The \"input\" and \"inputstring\" " + "attributes cannot both be specified" ) ; } if ( input != null ) { try { inputStream = new FileInputStream ( input ) ; } catch ( FileNotFoundException fne ) { throw new BuildException ( "Cannot read from " + input , fne ) ; } } else if ( inputString != null ) { inputStream = new ByteArrayInputStream ( inputString . getBytes ( ) ) ; } } public ExecuteStreamHandler createHandler ( ) throws BuildException { createStreams ( ) ; return new PumpStreamHandler ( outputStream , errorStream , inputStream ) ; } protected void handleOutput ( String output ) { if ( outPrintStream == null ) { outPrintStream = new PrintStream ( outputStream ) ; } outPrintStream . print ( output ) ; } protected int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException { if ( inputStream == null ) { return managingTask . getProject ( ) . defaultInput ( buffer , offset , length ) ; } else { return inputStream . read ( buffer , offset , length ) ; } } protected void handleFlush ( String output ) { if ( outPrintStream == null ) { outPrintStream = new PrintStream ( outputStream ) ; } outPrintStream . print ( output ) ; outPrintStream . flush ( ) ; } protected void handleErrorOutput ( String output ) { if ( errorPrintStream == null ) { errorPrintStream = new PrintStream ( errorStream ) ; } errorPrintStream . print ( output ) ; } protected void handleErrorFlush ( String output ) { if ( errorPrintStream == null ) { errorPrintStream = new PrintStream ( errorStream ) ; } errorPrintStream . print ( output ) ; } public OutputStream getOutputStream ( ) { return outputStream ; } public OutputStream getErrorStream ( ) { return errorStream ; } public InputStream getInputStream ( ) { return inputStream ; } public void complete ( ) throws IOException { System . out . flush ( ) ; System . err . flush ( ) ; if ( inputStream != null ) { inputStream . close ( ) ; } if ( outputStream instanceof LazyFileOutputStream ) { ( ( LazyFileOutputStream ) outputStream ) . open ( ) ; } outputStream . close ( ) ; if ( errorStream != outputStream ) { if ( errorStream instanceof LazyFileOutputStream ) { ( ( LazyFileOutputStream ) errorStream ) . open ( ) ; } errorStream . close ( ) ; } if ( baos != null ) { setPropertyFromBAOS ( baos , outputProperty ) ; } if ( errorBaos != null ) { setPropertyFromBAOS ( errorBaos , errorProperty ) ; } } } 	1	['21', '1', '0', '13', '52', '90', '2', '11', '15', '0.8375', '522', '1', '1', '0', '0.226190476', '0', '0', '23.0952381', '14', '1.7619', '3']
package org . apache . tools . ant . util ; public class GlobPatternMapper implements FileNameMapper { protected String fromPrefix = null ; protected String fromPostfix = null ; protected int prefixLength ; protected int postfixLength ; protected String toPrefix = null ; protected String toPostfix = null ; public void setFrom ( String from ) { int index = from . lastIndexOf ( "*" ) ; if ( index == - 1 ) { fromPrefix = from ; fromPostfix = "" ; } else { fromPrefix = from . substring ( 0 , index ) ; fromPostfix = from . substring ( index + 1 ) ; } prefixLength = fromPrefix . length ( ) ; postfixLength = fromPostfix . length ( ) ; } public void setTo ( String to ) { int index = to . lastIndexOf ( "*" ) ; if ( index == - 1 ) { toPrefix = to ; toPostfix = "" ; } else { toPrefix = to . substring ( 0 , index ) ; toPostfix = to . substring ( index + 1 ) ; } } public String [ ] mapFileName ( String sourceFileName ) { if ( fromPrefix == null || ! sourceFileName . startsWith ( fromPrefix ) || ! sourceFileName . endsWith ( fromPostfix ) ) { return null ; } return new String [ ] { toPrefix + extractVariablePart ( sourceFileName ) + toPostfix } ; } protected String extractVariablePart ( String name ) { return name . substring ( prefixLength , name . length ( ) - postfixLength ) ; } } 	0	['5', '1', '2', '5', '15', '0', '4', '1', '4', '0.5', '137', '1', '0', '0', '0.9', '0', '0', '25.2', '4', '1.8', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . FileUtils ; public class TempFile extends Task { private String property ; private File destDir = null ; private String prefix ; private String suffix = "" ; public void setProperty ( String property ) { this . property = property ; } public void setDestDir ( File destDir ) { this . destDir = destDir ; } public void setPrefix ( String prefix ) { this . prefix = prefix ; } public void setSuffix ( String suffix ) { this . suffix = suffix ; } public void execute ( ) throws BuildException { if ( property == null || property . length ( ) == 0 ) { throw new BuildException ( "no property specified" ) ; } if ( destDir == null ) { destDir = getProject ( ) . resolveFile ( "." ) ; } FileUtils utils = FileUtils . newFileUtils ( ) ; File tfile = utils . createTempFile ( prefix , suffix , destDir ) ; getProject ( ) . setNewProperty ( property , tfile . toString ( ) ) ; } } 	1	['6', '3', '0', '5', '15', '1', '0', '5', '6', '0.7', '75', '1', '0', '0.880952381', '0.555555556', '0', '0', '10.83333333', '1', '0.8333', '1']
package org . apache . tools . mail ; import java . io . IOException ; public class ErrorInQuitException extends IOException { public ErrorInQuitException ( IOException e ) { super ( e . getMessage ( ) ) ; } } 	0	['1', '4', '0', '1', '3', '0', '1', '0', '1', '2', '6', '0', '0', '1', '1', '0', '0', '5', '0', '0', '0']
package org . apache . tools . ant . types ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Stack ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class PatternSet extends DataType implements Cloneable { private Vector includeList = new Vector ( ) ; private Vector excludeList = new Vector ( ) ; private Vector includesFileList = new Vector ( ) ; private Vector excludesFileList = new Vector ( ) ; public class NameEntry { private String name ; private String ifCond ; private String unlessCond ; public void setName ( String name ) { this . name = name ; } public void setIf ( String cond ) { ifCond = cond ; } public void setUnless ( String cond ) { unlessCond = cond ; } public String getName ( ) { return name ; } public String evalName ( Project p ) { return valid ( p ) ? name : null ; } private boolean valid ( Project p ) { if ( ifCond != null && p . getProperty ( ifCond ) == null ) { return false ; } else if ( unlessCond != null && p . getProperty ( unlessCond ) != null ) { return false ; } return true ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( name ) ; if ( ( ifCond != null ) || ( unlessCond != null ) ) { buf . append ( ":" ) ; String connector = "" ; if ( ifCond != null ) { buf . append ( "if->" ) ; buf . append ( ifCond ) ; connector = ";" ; } if ( unlessCond != null ) { buf . append ( connector ) ; buf . append ( "unless->" ) ; buf . append ( unlessCond ) ; } } return buf . toString ( ) ; } } public PatternSet ( ) { super ( ) ; } public void setRefid ( Reference r ) throws BuildException { if ( ! includeList . isEmpty ( ) || ! excludeList . isEmpty ( ) ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public void addConfiguredPatternset ( PatternSet p ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } String [ ] nestedIncludes = p . getIncludePatterns ( getProject ( ) ) ; String [ ] nestedExcludes = p . getExcludePatterns ( getProject ( ) ) ; if ( nestedIncludes != null ) { for ( int i = 0 ; i < nestedIncludes . length ; i ++ ) { createInclude ( ) . setName ( nestedIncludes [ i ] ) ; } } if ( nestedExcludes != null ) { for ( int i = 0 ; i < nestedExcludes . length ; i ++ ) { createExclude ( ) . setName ( nestedExcludes [ i ] ) ; } } } public NameEntry createInclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return addPatternToList ( includeList ) ; } public NameEntry createIncludesFile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return addPatternToList ( includesFileList ) ; } public NameEntry createExclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return addPatternToList ( excludeList ) ; } public NameEntry createExcludesFile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return addPatternToList ( excludesFileList ) ; } public void setIncludes ( String includes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( includes != null && includes . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( includes , ", " , false ) ; while ( tok . hasMoreTokens ( ) ) { createInclude ( ) . setName ( tok . nextToken ( ) ) ; } } } public void setExcludes ( String excludes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( excludes != null && excludes . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( excludes , ", " , false ) ; while ( tok . hasMoreTokens ( ) ) { createExclude ( ) . setName ( tok . nextToken ( ) ) ; } } } private NameEntry addPatternToList ( Vector list ) { NameEntry result = new NameEntry ( ) ; list . addElement ( result ) ; return result ; } public void setIncludesfile ( File includesFile ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createIncludesFile ( ) . setName ( includesFile . getAbsolutePath ( ) ) ; } public void setExcludesfile ( File excludesFile ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createExcludesFile ( ) . setName ( excludesFile . getAbsolutePath ( ) ) ; } private void readPatterns ( File patternfile , Vector patternlist , Project p ) throws BuildException { BufferedReader patternReader = null ; try { patternReader = new BufferedReader ( new FileReader ( patternfile ) ) ; String line = patternReader . readLine ( ) ; while ( line != null ) { if ( line . length ( ) > 0 ) { line = p . replaceProperties ( line ) ; addPatternToList ( patternlist ) . setName ( line ) ; } line = patternReader . readLine ( ) ; } } catch ( IOException ioe ) { String msg = "An error occured while reading from pattern file: " + patternfile ; throw new BuildException ( msg , ioe ) ; } finally { if ( null != patternReader ) { try { patternReader . close ( ) ; } catch ( IOException ioe ) { } } } } public void append ( PatternSet other , Project p ) { if ( isReference ( ) ) { throw new BuildException ( "Cannot append to a reference" ) ; } String [ ] incl = other . getIncludePatterns ( p ) ; if ( incl != null ) { for ( int i = 0 ; i < incl . length ; i ++ ) { createInclude ( ) . setName ( incl [ i ] ) ; } } String [ ] excl = other . getExcludePatterns ( p ) ; if ( excl != null ) { for ( int i = 0 ; i < excl . length ; i ++ ) { createExclude ( ) . setName ( excl [ i ] ) ; } } } public String [ ] getIncludePatterns ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getIncludePatterns ( p ) ; } else { readFiles ( p ) ; return makeArray ( includeList , p ) ; } } public String [ ] getExcludePatterns ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getExcludePatterns ( p ) ; } else { readFiles ( p ) ; return makeArray ( excludeList , p ) ; } } boolean hasPatterns ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . hasPatterns ( p ) ; } else { return includesFileList . size ( ) > 0 || excludesFileList . size ( ) > 0 || includeList . size ( ) > 0 || excludeList . size ( ) > 0 ; } } private PatternSet getRef ( Project p ) { if ( ! isChecked ( ) ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , p ) ; } Object o = getRefid ( ) . getReferencedObject ( p ) ; if ( ! ( o instanceof PatternSet ) ) { String msg = getRefid ( ) . getRefId ( ) + " doesn\'t denote a patternset" ; throw new BuildException ( msg ) ; } else { return ( PatternSet ) o ; } } private String [ ] makeArray ( Vector list , Project p ) { if ( list . size ( ) == 0 ) { return null ; } Vector tmpNames = new Vector ( ) ; for ( Enumeration e = list . elements ( ) ; e . hasMoreElements ( ) ; ) { NameEntry ne = ( NameEntry ) e . nextElement ( ) ; String pattern = ne . evalName ( p ) ; if ( pattern != null && pattern . length ( ) > 0 ) { tmpNames . addElement ( pattern ) ; } } String [ ] result = new String [ tmpNames . size ( ) ] ; tmpNames . copyInto ( result ) ; return result ; } private void readFiles ( Project p ) { if ( includesFileList . size ( ) > 0 ) { Enumeration e = includesFileList . elements ( ) ; while ( e . hasMoreElements ( ) ) { NameEntry ne = ( NameEntry ) e . nextElement ( ) ; String fileName = ne . evalName ( p ) ; if ( fileName != null ) { File inclFile = p . resolveFile ( fileName ) ; if ( ! inclFile . exists ( ) ) { throw new BuildException ( "Includesfile " + inclFile . getAbsolutePath ( ) + " not found." ) ; } readPatterns ( inclFile , includeList , p ) ; } } includesFileList . removeAllElements ( ) ; } if ( excludesFileList . size ( ) > 0 ) { Enumeration e = excludesFileList . elements ( ) ; while ( e . hasMoreElements ( ) ) { NameEntry ne = ( NameEntry ) e . nextElement ( ) ; String fileName = ne . evalName ( p ) ; if ( fileName != null ) { File exclFile = p . resolveFile ( fileName ) ; if ( ! exclFile . exists ( ) ) { throw new BuildException ( "Excludesfile " + exclFile . getAbsolutePath ( ) + " not found." ) ; } readPatterns ( exclFile , excludeList , p ) ; } } excludesFileList . removeAllElements ( ) ; } } public String toString ( ) { return "patternSet{ includes: " + includeList + " excludes: " + excludeList + " }" ; } public Object clone ( ) { if ( isReference ( ) ) { return getRef ( getProject ( ) ) . clone ( ) ; } else { try { PatternSet ps = ( PatternSet ) super . clone ( ) ; ps . includeList = ( Vector ) includeList . clone ( ) ; ps . excludeList = ( Vector ) excludeList . clone ( ) ; ps . includesFileList = ( Vector ) includesFileList . clone ( ) ; ps . excludesFileList = ( Vector ) excludesFileList . clone ( ) ; return ps ; } catch ( CloneNotSupportedException e ) { throw new BuildException ( e ) ; } } } } 	1	['22', '3', '0', '12', '68', '133', '7', '6', '16', '0.571428571', '677', '1', '0', '0.588235294', '0.266233766', '2', '3', '29.59090909', '9', '2.9545', '3']
package org . apache . tools . ant . taskdefs . cvslib ; class RCSFile { private String m_name ; private String m_revision ; private String m_previousRevision ; RCSFile ( final String name , final String rev ) { this ( name , rev , null ) ; } RCSFile ( final String name , final String revision , final String previousRevision ) { m_name = name ; m_revision = revision ; if ( ! revision . equals ( previousRevision ) ) { m_previousRevision = previousRevision ; } } String getName ( ) { return m_name ; } String getRevision ( ) { return m_revision ; } String getPreviousRevision ( ) { return m_previousRevision ; } } 	0	['5', '1', '0', '2', '7', '4', '2', '0', '0', '0.5', '39', '1', '0', '0', '0.7', '0', '0', '6.2', '1', '0.6', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . JavaEnvUtils ; public class CompilerAdapterFactory { private static final String MODERN_COMPILER = "com.sun.tools.javac.Main" ; private CompilerAdapterFactory ( ) { } public static CompilerAdapter getCompiler ( String compilerType , Task task ) throws BuildException { boolean isClassicCompilerSupported = true ; if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_4 ) ) { isClassicCompilerSupported = false ; } if ( compilerType . equalsIgnoreCase ( "jikes" ) ) { return new Jikes ( ) ; } if ( compilerType . equalsIgnoreCase ( "extJavac" ) ) { return new JavacExternal ( ) ; } if ( compilerType . equalsIgnoreCase ( "classic" ) || compilerType . equalsIgnoreCase ( "javac1.1" ) || compilerType . equalsIgnoreCase ( "javac1.2" ) ) { if ( isClassicCompilerSupported ) { return new Javac12 ( ) ; } else { task . log ( "This version of java does " + "not support the classic " + "compiler; upgrading to modern" , Project . MSG_WARN ) ; compilerType = "modern" ; } } if ( compilerType . equalsIgnoreCase ( "modern" ) || compilerType . equalsIgnoreCase ( "javac1.3" ) || compilerType . equalsIgnoreCase ( "javac1.4" ) ) { if ( doesModernCompilerExist ( ) ) { return new Javac13 ( ) ; } else { if ( isClassicCompilerSupported ) { task . log ( "Modern compiler not found - looking for " + "classic compiler" , Project . MSG_WARN ) ; return new Javac12 ( ) ; } else { throw new BuildException ( "Unable to find a javac " + "compiler;\n" + MODERN_COMPILER + " is not on the " + "classpath.\n" + "Perhaps JAVA_HOME does not" + " point to the JDK" ) ; } } } if ( compilerType . equalsIgnoreCase ( "jvc" ) || compilerType . equalsIgnoreCase ( "microsoft" ) ) { return new Jvc ( ) ; } if ( compilerType . equalsIgnoreCase ( "kjc" ) ) { return new Kjc ( ) ; } if ( compilerType . equalsIgnoreCase ( "gcj" ) ) { return new Gcj ( ) ; } if ( compilerType . equalsIgnoreCase ( "sj" ) || compilerType . equalsIgnoreCase ( "symantec" ) ) { return new Sj ( ) ; } return resolveClassName ( compilerType ) ; } private static boolean doesModernCompilerExist ( ) { try { Class . forName ( MODERN_COMPILER ) ; return true ; } catch ( ClassNotFoundException cnfe ) { try { CompilerAdapterFactory . class . getClassLoader ( ) . loadClass ( MODERN_COMPILER ) ; return true ; } catch ( ClassNotFoundException cnfe2 ) { } } return false ; } private static CompilerAdapter resolveClassName ( String className ) throws BuildException { try { Class c = Class . forName ( className ) ; Object o = c . newInstance ( ) ; return ( CompilerAdapter ) o ; } catch ( ClassNotFoundException cnfe ) { throw new BuildException ( "Compiler Adapter '" + className + "' can\'t be found." , cnfe ) ; } catch ( ClassCastException cce ) { throw new BuildException ( className + " isn\'t the classname of " + "a compiler adapter." , cce ) ; } catch ( Throwable t ) { throw new BuildException ( "Compiler Adapter " + className + " caused an interesting exception." , t ) ; } } } 	1	['5', '1', '0', '13', '28', '10', '1', '12', '1', '1', '225', '0.5', '0', '0', '0.333333333', '0', '0', '43.6', '2', '1', '1']
package org . apache . tools . ant ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . PrintStream ; import java . io . Writer ; import java . util . Hashtable ; import java . util . Stack ; import java . util . Enumeration ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import org . apache . tools . ant . util . DOMElementWriter ; import org . apache . tools . ant . util . StringUtils ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Text ; public class XmlLogger implements BuildLogger { private int msgOutputLevel = Project . MSG_DEBUG ; private PrintStream outStream ; private static DocumentBuilder builder = getDocumentBuilder ( ) ; private static DocumentBuilder getDocumentBuilder ( ) { try { return DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; } catch ( Exception exc ) { throw new ExceptionInInitializerError ( exc ) ; } } private static final String BUILD_TAG = "build" ; private static final String TARGET_TAG = "target" ; private static final String TASK_TAG = "task" ; private static final String MESSAGE_TAG = "message" ; private static final String NAME_ATTR = "name" ; private static final String TIME_ATTR = "time" ; private static final String PRIORITY_ATTR = "priority" ; private static final String LOCATION_ATTR = "location" ; private static final String ERROR_ATTR = "error" ; private static final String STACKTRACE_TAG = "stacktrace" ; private Document doc = builder . newDocument ( ) ; private Hashtable tasks = new Hashtable ( ) ; private Hashtable targets = new Hashtable ( ) ; private Hashtable threadStacks = new Hashtable ( ) ; private TimedElement buildElement = null ; private static class TimedElement { private long startTime ; private Element element ; } public XmlLogger ( ) { } public void buildStarted ( BuildEvent event ) { buildElement = new TimedElement ( ) ; buildElement . startTime = System . currentTimeMillis ( ) ; buildElement . element = doc . createElement ( BUILD_TAG ) ; } public void buildFinished ( BuildEvent event ) { long totalTime = System . currentTimeMillis ( ) - buildElement . startTime ; buildElement . element . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; if ( event . getException ( ) != null ) { buildElement . element . setAttribute ( ERROR_ATTR , event . getException ( ) . toString ( ) ) ; Throwable t = event . getException ( ) ; Text errText = doc . createCDATASection ( StringUtils . getStackTrace ( t ) ) ; Element stacktrace = doc . createElement ( STACKTRACE_TAG ) ; stacktrace . appendChild ( errText ) ; buildElement . element . appendChild ( stacktrace ) ; } String outFilename = event . getProject ( ) . getProperty ( "XmlLogger.file" ) ; if ( outFilename == null ) { outFilename = "log.xml" ; } String xslUri = event . getProject ( ) . getProperty ( "ant.XmlLogger.stylesheet.uri" ) ; if ( xslUri == null ) { xslUri = "log.xsl" ; } Writer out = null ; try { OutputStream stream = outStream ; if ( stream == null ) { stream = new FileOutputStream ( outFilename ) ; } out = new OutputStreamWriter ( stream , "UTF8" ) ; out . write ( "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n" ) ; if ( xslUri . length ( ) > 0 ) { out . write ( "<?xml-stylesheet type=\"text/xsl\" href=\"" + xslUri + "\"?>\n\n" ) ; } ( new DOMElementWriter ( ) ) . write ( buildElement . element , out , 0 , "\t" ) ; out . flush ( ) ; } catch ( IOException exc ) { throw new BuildException ( "Unable to write log file" , exc ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( IOException e ) { } } } buildElement = null ; } private Stack getStack ( ) { Stack threadStack = ( Stack ) threadStacks . get ( Thread . currentThread ( ) ) ; if ( threadStack == null ) { threadStack = new Stack ( ) ; threadStacks . put ( Thread . currentThread ( ) , threadStack ) ; } return threadStack ; } public void targetStarted ( BuildEvent event ) { Target target = event . getTarget ( ) ; TimedElement targetElement = new TimedElement ( ) ; targetElement . startTime = System . currentTimeMillis ( ) ; targetElement . element = doc . createElement ( TARGET_TAG ) ; targetElement . element . setAttribute ( NAME_ATTR , target . getName ( ) ) ; targets . put ( target , targetElement ) ; getStack ( ) . push ( targetElement ) ; } public void targetFinished ( BuildEvent event ) { Target target = event . getTarget ( ) ; TimedElement targetElement = ( TimedElement ) targets . get ( target ) ; if ( targetElement != null ) { long totalTime = System . currentTimeMillis ( ) - targetElement . startTime ; targetElement . element . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; TimedElement parentElement = null ; Stack threadStack = getStack ( ) ; if ( ! threadStack . empty ( ) ) { TimedElement poppedStack = ( TimedElement ) threadStack . pop ( ) ; if ( poppedStack != targetElement ) { throw new RuntimeException ( "Mismatch - popped element = " + poppedStack . element + " finished target element = " + targetElement . element ) ; } if ( ! threadStack . empty ( ) ) { parentElement = ( TimedElement ) threadStack . peek ( ) ; } } if ( parentElement == null ) { buildElement . element . appendChild ( targetElement . element ) ; } else { parentElement . element . appendChild ( targetElement . element ) ; } } } public void taskStarted ( BuildEvent event ) { TimedElement taskElement = new TimedElement ( ) ; taskElement . startTime = System . currentTimeMillis ( ) ; taskElement . element = doc . createElement ( TASK_TAG ) ; Task task = event . getTask ( ) ; String name = event . getTask ( ) . getTaskName ( ) ; taskElement . element . setAttribute ( NAME_ATTR , name ) ; taskElement . element . setAttribute ( LOCATION_ATTR , event . getTask ( ) . getLocation ( ) . toString ( ) ) ; tasks . put ( task , taskElement ) ; getStack ( ) . push ( taskElement ) ; } public void taskFinished ( BuildEvent event ) { Task task = event . getTask ( ) ; TimedElement taskElement = ( TimedElement ) tasks . get ( task ) ; if ( taskElement != null ) { long totalTime = System . currentTimeMillis ( ) - taskElement . startTime ; taskElement . element . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; Target target = task . getOwningTarget ( ) ; TimedElement targetElement = null ; if ( target != null ) { targetElement = ( TimedElement ) targets . get ( target ) ; } if ( targetElement == null ) { buildElement . element . appendChild ( taskElement . element ) ; } else { targetElement . element . appendChild ( taskElement . element ) ; } Stack threadStack = getStack ( ) ; if ( ! threadStack . empty ( ) ) { TimedElement poppedStack = ( TimedElement ) threadStack . pop ( ) ; if ( poppedStack != taskElement ) { throw new RuntimeException ( "Mismatch - popped element = " + poppedStack . element + " finished task element = " + taskElement . element ) ; } } } } private TimedElement getTaskElement ( Task task ) { TimedElement element = ( TimedElement ) tasks . get ( task ) ; if ( element != null ) { return element ; } for ( Enumeration e = tasks . keys ( ) ; e . hasMoreElements ( ) ; ) { Task key = ( Task ) e . nextElement ( ) ; if ( key instanceof UnknownElement ) { if ( ( ( UnknownElement ) key ) . getTask ( ) == task ) { return ( TimedElement ) tasks . get ( key ) ; } } } return null ; } public void messageLogged ( BuildEvent event ) { int priority = event . getPriority ( ) ; if ( priority > msgOutputLevel ) { return ; } Element messageElement = doc . createElement ( MESSAGE_TAG ) ; String name = "debug" ; switch ( event . getPriority ( ) ) { case Project . MSG_ERR : name = "error" ; break ; case Project . MSG_WARN : name = "warn" ; break ; case Project . MSG_INFO : name = "info" ; break ; default : name = "debug" ; break ; } messageElement . setAttribute ( PRIORITY_ATTR , name ) ; Text messageText = doc . createCDATASection ( event . getMessage ( ) ) ; messageElement . appendChild ( messageText ) ; TimedElement parentElement = null ; Task task = event . getTask ( ) ; Target target = event . getTarget ( ) ; if ( task != null ) { parentElement = getTaskElement ( task ) ; } if ( parentElement == null && target != null ) { parentElement = ( TimedElement ) targets . get ( target ) ; } if ( parentElement != null ) { parentElement . element . appendChild ( messageElement ) ; } else { buildElement . element . appendChild ( messageElement ) ; } } public void setMessageOutputLevel ( int level ) { msgOutputLevel = level ; } public void setOutputPrintStream ( PrintStream output ) { this . outStream = new PrintStream ( output , true ) ; } public void setEmacsMode ( boolean emacsMode ) { } public void setErrorPrintStream ( PrintStream err ) { } } 	0	['16', '1', '0', '13', '74', '50', '0', '13', '12', '0.937037037', '635', '1', '1', '0', '0.288888889', '0', '0', '37.5625', '9', '2.6875', '0']
package org . apache . tools . ant . taskdefs ; import java . sql . Connection ; import java . sql . DatabaseMetaData ; import java . sql . Driver ; import java . sql . SQLException ; import java . util . Hashtable ; import java . util . Properties ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; public abstract class JDBCTask extends Task { private static Hashtable loaderMap = new Hashtable ( 3 ) ; private boolean caching = true ; private Path classpath ; private AntClassLoader loader ; private boolean autocommit = false ; private String driver = null ; private String url = null ; private String userId = null ; private String password = null ; private String rdbms = null ; private String version = null ; public void setClasspath ( Path classpath ) { this . classpath = classpath ; } public void setCaching ( boolean enable ) { caching = enable ; } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setDriver ( String driver ) { this . driver = driver ; } public void setUrl ( String url ) { this . url = url ; } public void setPassword ( String password ) { this . password = password ; } public void setAutocommit ( boolean autocommit ) { this . autocommit = autocommit ; } public void setRdbms ( String rdbms ) { this . rdbms = rdbms ; } public void setVersion ( String version ) { this . version = version ; } protected boolean isValidRdbms ( Connection conn ) { if ( rdbms == null && version == null ) { return true ; } try { DatabaseMetaData dmd = conn . getMetaData ( ) ; if ( rdbms != null ) { String theVendor = dmd . getDatabaseProductName ( ) . toLowerCase ( ) ; log ( "RDBMS = " + theVendor , Project . MSG_VERBOSE ) ; if ( theVendor == null || theVendor . indexOf ( rdbms ) < 0 ) { log ( "Not the required RDBMS: " + rdbms , Project . MSG_VERBOSE ) ; return false ; } } if ( version != null ) { String theVersion = dmd . getDatabaseProductVersion ( ) . toLowerCase ( ) ; log ( "Version = " + theVersion , Project . MSG_VERBOSE ) ; if ( theVersion == null || ! ( theVersion . startsWith ( version ) || theVersion . indexOf ( " " + version ) >= 0 ) ) { log ( "Not the required version: \"" + version + "\"" , Project . MSG_VERBOSE ) ; return false ; } } } catch ( SQLException e ) { log ( "Failed to obtain required RDBMS information" , Project . MSG_ERR ) ; return false ; } return true ; } protected static Hashtable getLoaderMap ( ) { return loaderMap ; } protected AntClassLoader getLoader ( ) { return loader ; } protected Connection getConnection ( ) throws BuildException { if ( userId == null ) { throw new BuildException ( "User Id attribute must be set!" , getLocation ( ) ) ; } if ( password == null ) { throw new BuildException ( "Password attribute must be set!" , getLocation ( ) ) ; } if ( url == null ) { throw new BuildException ( "Url attribute must be set!" , getLocation ( ) ) ; } try { log ( "connecting to " + getUrl ( ) , Project . MSG_VERBOSE ) ; Properties info = new Properties ( ) ; info . put ( "user" , getUserId ( ) ) ; info . put ( "password" , getPassword ( ) ) ; Connection conn = getDriver ( ) . connect ( getUrl ( ) , info ) ; if ( conn == null ) { throw new SQLException ( "No suitable Driver for " + url ) ; } conn . setAutoCommit ( autocommit ) ; return conn ; } catch ( SQLException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } private Driver getDriver ( ) throws BuildException { if ( driver == null ) { throw new BuildException ( "Driver attribute must be set!" , getLocation ( ) ) ; } Driver driverInstance = null ; try { Class dc ; if ( classpath != null ) { synchronized ( loaderMap ) { if ( caching ) { loader = ( AntClassLoader ) loaderMap . get ( driver ) ; } if ( loader == null ) { log ( "Loading " + driver + " using AntClassLoader with classpath " + classpath , Project . MSG_VERBOSE ) ; loader = getProject ( ) . createClassLoader ( classpath ) ; if ( caching ) { loaderMap . put ( driver , loader ) ; } } else { log ( "Loading " + driver + " using a cached AntClassLoader." , Project . MSG_VERBOSE ) ; } } dc = loader . loadClass ( driver ) ; } else { log ( "Loading " + driver + " using system loader." , Project . MSG_VERBOSE ) ; dc = Class . forName ( driver ) ; } driverInstance = ( Driver ) dc . newInstance ( ) ; } catch ( ClassNotFoundException e ) { throw new BuildException ( "Class Not Found: JDBC driver " + driver + " could not be loaded" , getLocation ( ) ) ; } catch ( IllegalAccessException e ) { throw new BuildException ( "Illegal Access: JDBC driver " + driver + " could not be loaded" , getLocation ( ) ) ; } catch ( InstantiationException e ) { throw new BuildException ( "Instantiation Exception: JDBC driver " + driver + " could not be loaded" , getLocation ( ) ) ; } return driverInstance ; } public void isCaching ( boolean value ) { caching = value ; } public Path getClasspath ( ) { return classpath ; } public boolean isAutocommit ( ) { return autocommit ; } public String getUrl ( ) { return url ; } public String getUserId ( ) { return userId ; } public void setUserid ( String userId ) { this . userId = userId ; } public String getPassword ( ) { return password ; } public String getRdbms ( ) { return rdbms ; } public String getVersion ( ) { return version ; } } 	1	['26', '3', '1', '9', '56', '225', '1', '8', '20', '0.872727273', '537', '1', '2', '0.606557377', '0.24', '0', '0', '19.23076923', '7', '1.1923', '1']
package org . apache . tools . ant . types ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . UnknownElement ; import org . apache . tools . ant . Target ; import org . apache . tools . ant . helper . ProjectHelperImpl ; import java . util . Vector ; public class Description extends DataType { public void addText ( String text ) { ProjectHelper ph = ProjectHelper . getProjectHelper ( ) ; if ( ! ( ph instanceof ProjectHelperImpl ) ) { return ; } String currentDescription = getProject ( ) . getDescription ( ) ; if ( currentDescription == null ) { getProject ( ) . setDescription ( text ) ; } else { getProject ( ) . setDescription ( currentDescription + text ) ; } } public static String getDescription ( Project project ) { StringBuffer description = new StringBuffer ( ) ; Vector targets = ( Vector ) project . getReference ( "ant.targets" ) ; for ( int i = 0 ; i < targets . size ( ) ; i ++ ) { Target t = ( Target ) targets . elementAt ( i ) ; concatDescriptions ( project , t , description ) ; } return description . toString ( ) ; } private static void concatDescriptions ( Project project , Target t , StringBuffer description ) { if ( t == null ) { return ; } Vector tasks = findElementInTarget ( project , t , "description" ) ; if ( tasks == null ) { return ; } for ( int i = 0 ; i < tasks . size ( ) ; i ++ ) { Task task = ( Task ) tasks . elementAt ( i ) ; if ( ! ( task instanceof UnknownElement ) ) { continue ; } UnknownElement ue = ( ( UnknownElement ) task ) ; StringBuffer descComp = ue . getWrapper ( ) . getText ( ) ; if ( descComp != null ) { description . append ( ( Object ) descComp ) ; } } } private static Vector findElementInTarget ( Project project , Target t , String name ) { Task [ ] tasks = t . getTasks ( ) ; Vector elems = new Vector ( ) ; for ( int i = 0 ; i < tasks . length ; i ++ ) { if ( name . equals ( tasks [ i ] . getTaskName ( ) ) ) { elems . addElement ( tasks [ i ] ) ; } } return elems ; } } 	0	['5', '3', '0', '9', '24', '10', '1', '9', '3', '2', '137', '0', '0', '0.882352941', '0.4', '0', '0', '26.4', '6', '2.8', '0']
package org . apache . tools . ant . util ; import java . io . File ; import java . util . Vector ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . ResourceFactory ; import org . apache . tools . ant . types . Resource ; public class SourceFileScanner implements ResourceFactory { protected Task task ; private FileUtils fileUtils ; private File destDir ; public SourceFileScanner ( Task task ) { this . task = task ; fileUtils = FileUtils . newFileUtils ( ) ; } public String [ ] restrict ( String [ ] files , File srcDir , File destDir , FileNameMapper mapper ) { this . destDir = destDir ; Vector v = new Vector ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File src = fileUtils . resolveFile ( srcDir , files [ i ] ) ; v . addElement ( new Resource ( files [ i ] , src . exists ( ) , src . lastModified ( ) , src . isDirectory ( ) ) ) ; } Resource [ ] sourceresources = new Resource [ v . size ( ) ] ; v . copyInto ( sourceresources ) ; Resource [ ] outofdate = ResourceUtils . selectOutOfDateSources ( task , sourceresources , mapper , this ) ; String [ ] result = new String [ outofdate . length ] ; for ( int counter = 0 ; counter < outofdate . length ; counter ++ ) { result [ counter ] = outofdate [ counter ] . getName ( ) ; } return result ; } public File [ ] restrictAsFiles ( String [ ] files , File srcDir , File destDir , FileNameMapper mapper ) { String [ ] res = restrict ( files , srcDir , destDir , mapper ) ; File [ ] result = new File [ res . length ] ; for ( int i = 0 ; i < res . length ; i ++ ) { result [ i ] = new File ( srcDir , res [ i ] ) ; } return result ; } public Resource getResource ( String name ) { File src = fileUtils . resolveFile ( destDir , name ) ; return new Resource ( name , src . exists ( ) , src . lastModified ( ) , src . isDirectory ( ) ) ; } } 	1	['4', '1', '0', '13', '18', '0', '6', '7', '4', '0.222222222', '137', '1', '2', '0', '0.5', '0', '0', '32.5', '3', '1.5', '1']
package org . apache . tools . ant ; import java . io . Serializable ; import org . apache . tools . ant . util . FileUtils ; import org . xml . sax . Locator ; public class Location implements Serializable { private String fileName ; private int lineNumber ; private int columnNumber ; public static final Location UNKNOWN_LOCATION = new Location ( ) ; private Location ( ) { this ( null , 0 , 0 ) ; } public Location ( String fileName ) { this ( fileName , 0 , 0 ) ; } public Location ( Locator loc ) { this ( loc . getSystemId ( ) , loc . getLineNumber ( ) , loc . getColumnNumber ( ) ) ; } public Location ( String fileName , int lineNumber , int columnNumber ) { if ( fileName != null && fileName . startsWith ( "file:" ) ) { this . fileName = FileUtils . newFileUtils ( ) . fromURI ( fileName ) ; } else { this . fileName = fileName ; } this . lineNumber = lineNumber ; this . columnNumber = columnNumber ; } public String getFileName ( ) { return fileName ; } public int getLineNumber ( ) { return lineNumber ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( fileName != null ) { buf . append ( fileName ) ; if ( lineNumber != 0 ) { buf . append ( ":" ) ; buf . append ( lineNumber ) ; } buf . append ( ": " ) ; } return buf . toString ( ) ; } } 	0	['8', '1', '0', '80', '19', '18', '79', '1', '6', '0.428571429', '99', '0.75', '1', '0', '0.392857143', '0', '0', '10.875', '3', '0.625', '0']
package org . apache . tools . ant . util ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; public class ClasspathUtils { private static final String LOADER_ID_PREFIX = "ant.loader." ; public static final String REUSE_LOADER_REF = "ant.reuse.loader" ; public static ClassLoader getClassLoaderForPath ( Project p , Reference ref ) { return getClassLoaderForPath ( p , ref , false ) ; } public static ClassLoader getClassLoaderForPath ( Project p , Reference ref , boolean reverseLoader ) { String pathId = ref . getRefId ( ) ; Object path = p . getReference ( pathId ) ; if ( ! ( path instanceof Path ) ) { throw new BuildException ( "The specified classpathref " + pathId + " does not reference a Path." ) ; } String loaderId = LOADER_ID_PREFIX + pathId ; return getClassLoaderForPath ( p , ( Path ) path , loaderId , reverseLoader ) ; } public static ClassLoader getClassLoaderForPath ( Project p , Path path , String loaderId ) { return getClassLoaderForPath ( p , path , loaderId , false ) ; } public static ClassLoader getClassLoaderForPath ( Project p , Path path , String loaderId , boolean reverseLoader ) { return getClassLoaderForPath ( p , path , loaderId , reverseLoader , isMagicPropertySet ( p ) ) ; } public static ClassLoader getClassLoaderForPath ( Project p , Path path , String loaderId , boolean reverseLoader , boolean reuseLoader ) { ClassLoader cl = null ; if ( loaderId != null && reuseLoader ) { Object reusedLoader = p . getReference ( loaderId ) ; if ( reusedLoader != null && ! ( reusedLoader instanceof ClassLoader ) ) { throw new BuildException ( "The specified loader id " + loaderId + " does not reference a class loader" ) ; } cl = ( ClassLoader ) reusedLoader ; } if ( cl == null ) { cl = getUniqueClassLoaderForPath ( p , path , reverseLoader ) ; if ( loaderId != null && reuseLoader ) { p . addReference ( loaderId , cl ) ; } } return cl ; } public static ClassLoader getUniqueClassLoaderForPath ( Project p , Path path , boolean reverseLoader ) { AntClassLoader acl = p . createClassLoader ( path != null ? path : Path . systemClasspath ) ; if ( reverseLoader ) { acl . setParentFirst ( false ) ; acl . addJavaLibraries ( ) ; } return acl ; } public static Object newInstance ( String className , ClassLoader userDefinedLoader ) { try { Class clazz = userDefinedLoader . loadClass ( className ) ; Object o = clazz . newInstance ( ) ; return o ; } catch ( ClassNotFoundException e ) { throw new BuildException ( "Class " + className + " not found by the specific classLoader." , e ) ; } catch ( InstantiationException e ) { throw new BuildException ( "Could not instantiate " + className + ". Specified class should have a no " + "argument constructor." , e ) ; } catch ( IllegalAccessException e ) { throw new BuildException ( "Could not instantiate " + className + ". Specified class should have a " + "public constructor." , e ) ; } } public static Delegate getDelegate ( ProjectComponent component ) { return new Delegate ( component ) ; } private static boolean isMagicPropertySet ( Project p ) { return p . getProperty ( REUSE_LOADER_REF ) != null ; } public static class Delegate { private final ProjectComponent component ; private Path classpath ; private String classpathId ; private String className ; private String loaderId ; private boolean reverseLoader = false ; Delegate ( ProjectComponent component ) { this . component = component ; } public void setClasspath ( Path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( component . getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public void setClassname ( String fcqn ) { this . className = fcqn ; } public void setClasspathref ( Reference r ) { this . classpathId = r . getRefId ( ) ; createClasspath ( ) . setRefid ( r ) ; } public void setReverseLoader ( boolean reverseLoader ) { this . reverseLoader = reverseLoader ; } public void setLoaderRef ( Reference r ) { this . loaderId = r . getRefId ( ) ; } public ClassLoader getClassLoader ( ) { ClassLoader cl ; cl = ClasspathUtils . getClassLoaderForPath ( getContextProject ( ) , this . classpath , getClassLoadId ( ) , this . reverseLoader , loaderId != null || isMagicPropertySet ( getContextProject ( ) ) ) ; return cl ; } private Project getContextProject ( ) { return this . component . getProject ( ) ; } public String getClassLoadId ( ) { if ( this . loaderId == null && this . classpathId != null ) { return ClasspathUtils . LOADER_ID_PREFIX + this . classpathId ; } else { return this . loaderId ; } } public Object newInstance ( ) { ClassLoader cl = getClassLoader ( ) ; return ClasspathUtils . newInstance ( this . className , cl ) ; } public Path getClasspath ( ) { return classpath ; } public boolean isReverseLoader ( ) { return reverseLoader ; } } } 	1	['11', '1', '0', '8', '27', '55', '2', '7', '9', '1.1', '218', '0.5', '0', '0', '0.284090909', '0', '0', '18.63636364', '8', '1.9091', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import java . io . IOException ; public class CallTarget extends Task { private Ant callee ; private String subTarget ; private boolean inheritAll = true ; private boolean inheritRefs = false ; public void setInheritAll ( boolean inherit ) { inheritAll = inherit ; } public void setInheritRefs ( boolean inheritRefs ) { this . inheritRefs = inheritRefs ; } public void init ( ) { callee = ( Ant ) getProject ( ) . createTask ( "ant" ) ; callee . setOwningTarget ( getOwningTarget ( ) ) ; callee . setTaskName ( getTaskName ( ) ) ; callee . setLocation ( getLocation ( ) ) ; callee . init ( ) ; } public void execute ( ) throws BuildException { if ( callee == null ) { init ( ) ; } if ( subTarget == null ) { throw new BuildException ( "Attribute target is required." , getLocation ( ) ) ; } callee . setAntfile ( getProject ( ) . getProperty ( "ant.file" ) ) ; callee . setTarget ( subTarget ) ; callee . setInheritAll ( inheritAll ) ; callee . setInheritRefs ( inheritRefs ) ; callee . execute ( ) ; } public Property createParam ( ) { if ( callee == null ) { init ( ) ; } return callee . createProperty ( ) ; } public void addReference ( Ant . Reference r ) { if ( callee == null ) { init ( ) ; } callee . addReference ( r ) ; } public void addPropertyset ( org . apache . tools . ant . types . PropertySet ps ) { if ( callee == null ) { init ( ) ; } callee . addPropertyset ( ps ) ; } public void setTarget ( String target ) { subTarget = target ; } public void handleOutput ( String output ) { if ( callee != null ) { callee . handleOutput ( output ) ; } else { super . handleOutput ( output ) ; } } public int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException { if ( callee != null ) { return callee . handleInput ( buffer , offset , length ) ; } else { return super . handleInput ( buffer , offset , length ) ; } } public void handleFlush ( String output ) { if ( callee != null ) { callee . handleFlush ( output ) ; } else { super . handleFlush ( output ) ; } } public void handleErrorOutput ( String output ) { if ( callee != null ) { callee . handleErrorOutput ( output ) ; } else { super . handleErrorOutput ( output ) ; } } public void handleErrorFlush ( String output ) { if ( callee != null ) { callee . handleErrorFlush ( output ) ; } else { super . handleErrorFlush ( output ) ; } } } 	0	['14', '3', '0', '10', '44', '0', '0', '10', '14', '0.730769231', '199', '1', '1', '0.74', '0.255102041', '2', '4', '12.92857143', '2', '1.4286', '0']
package org . apache . tools . zip ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FilterOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . RandomAccessFile ; import java . io . UnsupportedEncodingException ; import java . util . Date ; import java . util . Hashtable ; import java . util . Vector ; import java . util . zip . CRC32 ; import java . util . zip . Deflater ; import java . util . zip . ZipException ; public class ZipOutputStream extends FilterOutputStream { private ZipEntry entry ; private String comment = "" ; private int level = Deflater . DEFAULT_COMPRESSION ; private boolean hasCompressionLevelChanged = false ; private int method = DEFLATED ; private Vector entries = new Vector ( ) ; private CRC32 crc = new CRC32 ( ) ; private long written = 0 ; private long dataStart = 0 ; private long localDataStart = 0 ; private ZipLong cdOffset = new ZipLong ( 0 ) ; private ZipLong cdLength = new ZipLong ( 0 ) ; private static final byte [ ] ZERO = { 0 , 0 } ; private static final byte [ ] LZERO = { 0 , 0 , 0 , 0 } ; private Hashtable offsets = new Hashtable ( ) ; private String encoding = null ; protected Deflater def = new Deflater ( Deflater . DEFAULT_COMPRESSION , true ) ; protected byte [ ] buf = new byte [ 512 ] ; private RandomAccessFile raf = null ; public static final int DEFLATED = ZipEntry . DEFLATED ; public static final int STORED = ZipEntry . STORED ; public ZipOutputStream ( OutputStream out ) { super ( out ) ; } public ZipOutputStream ( File file ) throws IOException { super ( null ) ; try { raf = new RandomAccessFile ( file , "rw" ) ; raf . setLength ( 0 ) ; } catch ( IOException e ) { if ( raf != null ) { try { raf . close ( ) ; } catch ( IOException inner ) { } raf = null ; } out = new FileOutputStream ( file ) ; } } public boolean isSeekable ( ) { return raf != null ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String getEncoding ( ) { return encoding ; } public void finish ( ) throws IOException { closeEntry ( ) ; cdOffset = new ZipLong ( written ) ; for ( int i = 0 ; i < entries . size ( ) ; i ++ ) { writeCentralFileHeader ( ( ZipEntry ) entries . elementAt ( i ) ) ; } cdLength = new ZipLong ( written - cdOffset . getValue ( ) ) ; writeCentralDirectoryEnd ( ) ; offsets . clear ( ) ; entries . removeAllElements ( ) ; } public void closeEntry ( ) throws IOException { if ( entry == null ) { return ; } long realCrc = crc . getValue ( ) ; crc . reset ( ) ; if ( entry . getMethod ( ) == DEFLATED ) { def . finish ( ) ; while ( ! def . finished ( ) ) { deflate ( ) ; } entry . setSize ( def . getTotalIn ( ) ) ; entry . setComprSize ( def . getTotalOut ( ) ) ; entry . setCrc ( realCrc ) ; def . reset ( ) ; written += entry . getCompressedSize ( ) ; } else if ( raf == null ) { if ( entry . getCrc ( ) != realCrc ) { throw new ZipException ( "bad CRC checksum for entry " + entry . getName ( ) + ": " + Long . toHexString ( entry . getCrc ( ) ) + " instead of " + Long . toHexString ( realCrc ) ) ; } if ( entry . getSize ( ) != written - dataStart ) { throw new ZipException ( "bad size for entry " + entry . getName ( ) + ": " + entry . getSize ( ) + " instead of " + ( written - dataStart ) ) ; } } else { long size = written - dataStart ; entry . setSize ( size ) ; entry . setComprSize ( size ) ; entry . setCrc ( realCrc ) ; } if ( raf != null ) { long save = raf . getFilePointer ( ) ; raf . seek ( localDataStart ) ; writeOut ( ( new ZipLong ( entry . getCrc ( ) ) ) . getBytes ( ) ) ; writeOut ( ( new ZipLong ( entry . getCompressedSize ( ) ) ) . getBytes ( ) ) ; writeOut ( ( new ZipLong ( entry . getSize ( ) ) ) . getBytes ( ) ) ; raf . seek ( save ) ; } writeDataDescriptor ( entry ) ; entry = null ; } public void putNextEntry ( ZipEntry ze ) throws IOException { closeEntry ( ) ; entry = ze ; entries . addElement ( entry ) ; if ( entry . getMethod ( ) == - 1 ) { entry . setMethod ( method ) ; } if ( entry . getTime ( ) == - 1 ) { entry . setTime ( System . currentTimeMillis ( ) ) ; } if ( entry . getMethod ( ) == STORED && raf == null ) { if ( entry . getSize ( ) == - 1 ) { throw new ZipException ( "uncompressed size is required for" + " STORED method when not writing to a" + " file" ) ; } if ( entry . getCrc ( ) == - 1 ) { throw new ZipException ( "crc checksum is required for STORED" + " method when not writing to a file" ) ; } entry . setComprSize ( entry . getSize ( ) ) ; } if ( entry . getMethod ( ) == DEFLATED && hasCompressionLevelChanged ) { def . setLevel ( level ) ; hasCompressionLevelChanged = false ; } writeLocalFileHeader ( entry ) ; } public void setComment ( String comment ) { this . comment = comment ; } public void setLevel ( int level ) { hasCompressionLevelChanged = ( this . level != level ) ; this . level = level ; } public void setMethod ( int method ) { this . method = method ; } public void write ( byte [ ] b , int offset , int length ) throws IOException { if ( entry . getMethod ( ) == DEFLATED ) { if ( length > 0 ) { if ( ! def . finished ( ) ) { def . setInput ( b , offset , length ) ; while ( ! def . needsInput ( ) ) { deflate ( ) ; } } } } else { writeOut ( b , offset , length ) ; written += length ; } crc . update ( b , offset , length ) ; } public void write ( int b ) throws IOException { byte [ ] buf = new byte [ 1 ] ; buf [ 0 ] = ( byte ) ( b & 0xff ) ; write ( buf , 0 , 1 ) ; } public void close ( ) throws IOException { finish ( ) ; if ( raf != null ) { raf . close ( ) ; } if ( out != null ) { out . close ( ) ; } } public void flush ( ) throws IOException { if ( out == null ) { out . flush ( ) ; } } protected static final ZipLong LFH_SIG = new ZipLong ( 0X04034B50L ) ; protected static final ZipLong DD_SIG = new ZipLong ( 0X08074B50L ) ; protected static final ZipLong CFH_SIG = new ZipLong ( 0X02014B50L ) ; protected static final ZipLong EOCD_SIG = new ZipLong ( 0X06054B50L ) ; protected final void deflate ( ) throws IOException { int len = def . deflate ( buf , 0 , buf . length ) ; if ( len > 0 ) { writeOut ( buf , 0 , len ) ; } } protected void writeLocalFileHeader ( ZipEntry ze ) throws IOException { offsets . put ( ze , new ZipLong ( written ) ) ; writeOut ( LFH_SIG . getBytes ( ) ) ; written += 4 ; if ( ze . getMethod ( ) == DEFLATED && raf == null ) { writeOut ( ( new ZipShort ( 20 ) ) . getBytes ( ) ) ; writeOut ( ( new ZipShort ( 8 ) ) . getBytes ( ) ) ; } else { writeOut ( ( new ZipShort ( 10 ) ) . getBytes ( ) ) ; writeOut ( ZERO ) ; } written += 4 ; writeOut ( ( new ZipShort ( ze . getMethod ( ) ) ) . getBytes ( ) ) ; written += 2 ; writeOut ( toDosTime ( new Date ( ze . getTime ( ) ) ) . getBytes ( ) ) ; written += 4 ; localDataStart = written ; if ( ze . getMethod ( ) == DEFLATED || raf != null ) { writeOut ( LZERO ) ; writeOut ( LZERO ) ; writeOut ( LZERO ) ; } else { writeOut ( ( new ZipLong ( ze . getCrc ( ) ) ) . getBytes ( ) ) ; writeOut ( ( new ZipLong ( ze . getSize ( ) ) ) . getBytes ( ) ) ; writeOut ( ( new ZipLong ( ze . getSize ( ) ) ) . getBytes ( ) ) ; } written += 12 ; byte [ ] name = getBytes ( ze . getName ( ) ) ; writeOut ( ( new ZipShort ( name . length ) ) . getBytes ( ) ) ; written += 2 ; byte [ ] extra = ze . getLocalFileDataExtra ( ) ; writeOut ( ( new ZipShort ( extra . length ) ) . getBytes ( ) ) ; written += 2 ; writeOut ( name ) ; written += name . length ; writeOut ( extra ) ; written += extra . length ; dataStart = written ; } protected void writeDataDescriptor ( ZipEntry ze ) throws IOException { if ( ze . getMethod ( ) != DEFLATED || raf != null ) { return ; } writeOut ( DD_SIG . getBytes ( ) ) ; writeOut ( ( new ZipLong ( entry . getCrc ( ) ) ) . getBytes ( ) ) ; writeOut ( ( new ZipLong ( entry . getCompressedSize ( ) ) ) . getBytes ( ) ) ; writeOut ( ( new ZipLong ( entry . getSize ( ) ) ) . getBytes ( ) ) ; written += 16 ; } protected void writeCentralFileHeader ( ZipEntry ze ) throws IOException { writeOut ( CFH_SIG . getBytes ( ) ) ; written += 4 ; writeOut ( ( new ZipShort ( ( ze . getPlatform ( ) << 8 ) | 20 ) ) . getBytes ( ) ) ; written += 2 ; if ( ze . getMethod ( ) == DEFLATED && raf == null ) { writeOut ( ( new ZipShort ( 20 ) ) . getBytes ( ) ) ; writeOut ( ( new ZipShort ( 8 ) ) . getBytes ( ) ) ; } else { writeOut ( ( new ZipShort ( 10 ) ) . getBytes ( ) ) ; writeOut ( ZERO ) ; } written += 4 ; writeOut ( ( new ZipShort ( ze . getMethod ( ) ) ) . getBytes ( ) ) ; written += 2 ; writeOut ( toDosTime ( new Date ( ze . getTime ( ) ) ) . getBytes ( ) ) ; written += 4 ; writeOut ( ( new ZipLong ( ze . getCrc ( ) ) ) . getBytes ( ) ) ; writeOut ( ( new ZipLong ( ze . getCompressedSize ( ) ) ) . getBytes ( ) ) ; writeOut ( ( new ZipLong ( ze . getSize ( ) ) ) . getBytes ( ) ) ; written += 12 ; byte [ ] name = getBytes ( ze . getName ( ) ) ; writeOut ( ( new ZipShort ( name . length ) ) . getBytes ( ) ) ; written += 2 ; byte [ ] extra = ze . getCentralDirectoryExtra ( ) ; writeOut ( ( new ZipShort ( extra . length ) ) . getBytes ( ) ) ; written += 2 ; String comm = ze . getComment ( ) ; if ( comm == null ) { comm = "" ; } byte [ ] comment = getBytes ( comm ) ; writeOut ( ( new ZipShort ( comment . length ) ) . getBytes ( ) ) ; written += 2 ; writeOut ( ZERO ) ; written += 2 ; writeOut ( ( new ZipShort ( ze . getInternalAttributes ( ) ) ) . getBytes ( ) ) ; written += 2 ; writeOut ( ( new ZipLong ( ze . getExternalAttributes ( ) ) ) . getBytes ( ) ) ; written += 4 ; writeOut ( ( ( ZipLong ) offsets . get ( ze ) ) . getBytes ( ) ) ; written += 4 ; writeOut ( name ) ; written += name . length ; writeOut ( extra ) ; written += extra . length ; writeOut ( comment ) ; written += comment . length ; } protected void writeCentralDirectoryEnd ( ) throws IOException { writeOut ( EOCD_SIG . getBytes ( ) ) ; writeOut ( ZERO ) ; writeOut ( ZERO ) ; byte [ ] num = ( new ZipShort ( entries . size ( ) ) ) . getBytes ( ) ; writeOut ( num ) ; writeOut ( num ) ; writeOut ( cdLength . getBytes ( ) ) ; writeOut ( cdOffset . getBytes ( ) ) ; byte [ ] data = getBytes ( comment ) ; writeOut ( ( new ZipShort ( data . length ) ) . getBytes ( ) ) ; writeOut ( data ) ; } private static final ZipLong DOS_TIME_MIN = new ZipLong ( 0x00002100L ) ; protected static ZipLong toDosTime ( Date time ) { int year = time . getYear ( ) + 1900 ; int month = time . getMonth ( ) + 1 ; if ( year < 1980 ) { return DOS_TIME_MIN ; } long value = ( ( year - 1980 ) << 25 ) | ( month << 21 ) | ( time . getDate ( ) << 16 ) | ( time . getHours ( ) << 11 ) | ( time . getMinutes ( ) << 5 ) | ( time . getSeconds ( ) > > 1 ) ; byte [ ] result = new byte [ 4 ] ; result [ 0 ] = ( byte ) ( ( value & 0xFF ) ) ; result [ 1 ] = ( byte ) ( ( value & 0xFF00 ) > > 8 ) ; result [ 2 ] = ( byte ) ( ( value & 0xFF0000 ) > > 16 ) ; result [ 3 ] = ( byte ) ( ( value & 0xFF000000L ) > > 24 ) ; return new ZipLong ( result ) ; } protected byte [ ] getBytes ( String name ) throws ZipException { if ( encoding == null ) { return name . getBytes ( ) ; } else { try { return name . getBytes ( encoding ) ; } catch ( UnsupportedEncodingException uee ) { throw new ZipException ( uee . getMessage ( ) ) ; } } } protected final void writeOut ( byte [ ] data ) throws IOException { writeOut ( data , 0 , data . length ) ; } protected final void writeOut ( byte [ ] data , int offset , int length ) throws IOException { if ( raf != null ) { raf . write ( data , offset , length ) ; } else { out . write ( data , offset , length ) ; } } } 	1	['25', '3', '0', '8', '99', '112', '5', '3', '15', '0.802884615', '1445', '0.923076923', '8', '0.3125', '0.213541667', '1', '7', '55.76', '2', '1', '1']
package org . apache . tools . ant . taskdefs ; public class ManifestException extends Exception { public ManifestException ( String msg ) { super ( msg ) ; } } 	0	['1', '3', '0', '6', '2', '0', '6', '0', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . io . Reader ; import java . io . Writer ; import java . util . Enumeration ; import java . util . Properties ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . StringUtils ; public class Replace extends MatchingTask { private File src = null ; private NestedString token = null ; private NestedString value = new NestedString ( ) ; private File propertyFile = null ; private File replaceFilterFile = null ; private Properties properties = null ; private Vector replacefilters = new Vector ( ) ; private File dir = null ; private int fileCount ; private int replaceCount ; private boolean summary = false ; private String encoding = null ; private FileUtils fileUtils = FileUtils . newFileUtils ( ) ; public class NestedString { private StringBuffer buf = new StringBuffer ( ) ; public void addText ( String val ) { buf . append ( val ) ; } public String getText ( ) { return buf . substring ( 0 ) ; } } public class Replacefilter { private String token ; private String value ; private String property ; public void validate ( ) throws BuildException { if ( token == null ) { String message = "token is a mandatory attribute " + "of replacefilter." ; throw new BuildException ( message ) ; } if ( "" . equals ( token ) ) { String message = "The token attribute must not be an empty " + "string." ; throw new BuildException ( message ) ; } if ( ( value != null ) && ( property != null ) ) { String message = "Either value or property " + "can be specified, but a replacefilter " + "element cannot have both." ; throw new BuildException ( message ) ; } if ( ( property != null ) ) { if ( propertyFile == null ) { String message = "The replacefilter's property attribute " + "can only be used with the replacetask's " + "propertyFile attribute." ; throw new BuildException ( message ) ; } if ( properties == null || properties . getProperty ( property ) == null ) { String message = "property \"" + property + "\" was not found in " + propertyFile . getPath ( ) ; throw new BuildException ( message ) ; } } } public String getReplaceValue ( ) { if ( property != null ) { return properties . getProperty ( property ) ; } else if ( value != null ) { return value ; } else if ( Replace . this . value != null ) { return Replace . this . value . getText ( ) ; } else { return new String ( "" ) ; } } public void setToken ( String token ) { this . token = token ; } public String getToken ( ) { return token ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } public void setProperty ( String property ) { this . property = property ; } public String getProperty ( ) { return property ; } } public void execute ( ) throws BuildException { Vector savedFilters = ( Vector ) replacefilters . clone ( ) ; Properties savedProperties = properties == null ? null : ( Properties ) properties . clone ( ) ; try { if ( replaceFilterFile != null ) { Properties props = getProperties ( replaceFilterFile ) ; Enumeration e = props . keys ( ) ; while ( e . hasMoreElements ( ) ) { String token = e . nextElement ( ) . toString ( ) ; Replacefilter replaceFilter = createReplacefilter ( ) ; replaceFilter . setToken ( token ) ; replaceFilter . setValue ( props . getProperty ( token ) ) ; } } validateAttributes ( ) ; if ( propertyFile != null ) { properties = getProperties ( propertyFile ) ; } validateReplacefilters ( ) ; fileCount = 0 ; replaceCount = 0 ; if ( src != null ) { processFile ( src ) ; } if ( dir != null ) { DirectoryScanner ds = super . getDirectoryScanner ( dir ) ; String [ ] srcs = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < srcs . length ; i ++ ) { File file = new File ( dir , srcs [ i ] ) ; processFile ( file ) ; } } if ( summary ) { log ( "Replaced " + replaceCount + " occurrences in " + fileCount + " files." , Project . MSG_INFO ) ; } } finally { replacefilters = savedFilters ; properties = savedProperties ; } } public void validateAttributes ( ) throws BuildException { if ( src == null && dir == null ) { String message = "Either the file or the dir attribute " + "must be specified" ; throw new BuildException ( message , getLocation ( ) ) ; } if ( propertyFile != null && ! propertyFile . exists ( ) ) { String message = "Property file " + propertyFile . getPath ( ) + " does not exist." ; throw new BuildException ( message , getLocation ( ) ) ; } if ( token == null && replacefilters . size ( ) == 0 ) { String message = "Either token or a nested replacefilter " + "must be specified" ; throw new BuildException ( message , getLocation ( ) ) ; } if ( token != null && "" . equals ( token . getText ( ) ) ) { String message = "The token attribute must not be an empty string." ; throw new BuildException ( message , getLocation ( ) ) ; } } public void validateReplacefilters ( ) throws BuildException { for ( int i = 0 ; i < replacefilters . size ( ) ; i ++ ) { Replacefilter element = ( Replacefilter ) replacefilters . elementAt ( i ) ; element . validate ( ) ; } } public Properties getProperties ( File propertyFile ) throws BuildException { Properties properties = new Properties ( ) ; try { properties . load ( new FileInputStream ( propertyFile ) ) ; } catch ( FileNotFoundException e ) { String message = "Property file (" + propertyFile . getPath ( ) + ") not found." ; throw new BuildException ( message ) ; } catch ( IOException e ) { String message = "Property file (" + propertyFile . getPath ( ) + ") cannot be loaded." ; throw new BuildException ( message ) ; } return properties ; } private void processFile ( File src ) throws BuildException { if ( ! src . exists ( ) ) { throw new BuildException ( "Replace: source file " + src . getPath ( ) + " doesn't exist" , getLocation ( ) ) ; } File temp = fileUtils . createTempFile ( "rep" , ".tmp" , fileUtils . getParentFile ( src ) ) ; temp . deleteOnExit ( ) ; Reader reader = null ; Writer writer = null ; try { reader = encoding == null ? new FileReader ( src ) : new InputStreamReader ( new FileInputStream ( src ) , encoding ) ; writer = encoding == null ? new FileWriter ( temp ) : new OutputStreamWriter ( new FileOutputStream ( temp ) , encoding ) ; BufferedReader br = new BufferedReader ( reader ) ; BufferedWriter bw = new BufferedWriter ( writer ) ; String buf = fileUtils . readFully ( br ) ; if ( buf == null ) { buf = "" ; } String newString = new String ( buf ) ; if ( token != null ) { String val = stringReplace ( value . getText ( ) , "\r\n" , "\n" , false ) ; val = stringReplace ( val , "\n" , StringUtils . LINE_SEP , false ) ; String tok = stringReplace ( token . getText ( ) , "\r\n" , "\n" , false ) ; tok = stringReplace ( tok , "\n" , StringUtils . LINE_SEP , false ) ; log ( "Replacing in " + src . getPath ( ) + ": " + token . getText ( ) + " --> " + value . getText ( ) , Project . MSG_VERBOSE ) ; newString = stringReplace ( newString , tok , val , true ) ; } if ( replacefilters . size ( ) > 0 ) { newString = processReplacefilters ( newString , src . getPath ( ) ) ; } boolean changes = ! newString . equals ( buf ) ; if ( changes ) { bw . write ( newString , 0 , newString . length ( ) ) ; bw . flush ( ) ; } bw . close ( ) ; writer = null ; br . close ( ) ; reader = null ; if ( changes ) { ++ fileCount ; fileUtils . rename ( temp , src ) ; temp = null ; } } catch ( IOException ioe ) { throw new BuildException ( "IOException in " + src + " - " + ioe . getClass ( ) . getName ( ) + ":" + ioe . getMessage ( ) , ioe , getLocation ( ) ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { } } if ( writer != null ) { try { writer . close ( ) ; } catch ( IOException e ) { } } if ( temp != null ) { temp . delete ( ) ; } } } private String processReplacefilters ( String buffer , String filename ) { String newString = new String ( buffer ) ; for ( int i = 0 ; i < replacefilters . size ( ) ; i ++ ) { Replacefilter filter = ( Replacefilter ) replacefilters . elementAt ( i ) ; log ( "Replacing in " + filename + ": " + filter . getToken ( ) + " --> " + filter . getReplaceValue ( ) , Project . MSG_VERBOSE ) ; newString = stringReplace ( newString , filter . getToken ( ) , filter . getReplaceValue ( ) , true ) ; } return newString ; } public void setFile ( File file ) { this . src = file ; } public void setSummary ( boolean summary ) { this . summary = summary ; } public void setReplaceFilterFile ( File filename ) { replaceFilterFile = filename ; } public void setDir ( File dir ) { this . dir = dir ; } public void setToken ( String token ) { createReplaceToken ( ) . addText ( token ) ; } public void setValue ( String value ) { createReplaceValue ( ) . addText ( value ) ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public NestedString createReplaceToken ( ) { if ( token == null ) { token = new NestedString ( ) ; } return token ; } public NestedString createReplaceValue ( ) { return value ; } public void setPropertyFile ( File filename ) { propertyFile = filename ; } public Replacefilter createReplacefilter ( ) { Replacefilter filter = new Replacefilter ( ) ; replacefilters . addElement ( filter ) ; return filter ; } private String stringReplace ( String str , String str1 , String str2 , boolean countReplaces ) { StringBuffer ret = new StringBuffer ( ) ; int start = 0 ; int found = str . indexOf ( str1 ) ; while ( found >= 0 ) { if ( found > start ) { ret . append ( str . substring ( start , found ) ) ; } if ( str2 != null ) { ret . append ( str2 ) ; } start = found + str1 . length ( ) ; found = str . indexOf ( str1 , start ) ; if ( countReplaces ) { ++ replaceCount ; } } if ( str . length ( ) > start ) { ret . append ( str . substring ( start , str . length ( ) ) ) ; } return ret . toString ( ) ; } } 	1	['22', '4', '0', '9', '90', '129', '2', '9', '16', '0.84981685', '826', '1', '3', '0.787878788', '0.318181818', '2', '2', '35.95454545', '6', '1.2727', '1']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class Jvc extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using jvc compiler" , Project . MSG_VERBOSE ) ; Path classpath = new Path ( project ) ; if ( bootclasspath != null ) { classpath . append ( bootclasspath ) ; } if ( includeJavaRuntime ) { classpath . addExtdirs ( extdirs ) ; } classpath . append ( getCompileClasspath ( ) ) ; if ( compileSourcepath != null ) { classpath . append ( compileSourcepath ) ; } else { classpath . append ( src ) ; } Commandline cmd = new Commandline ( ) ; String exec = getJavac ( ) . getExecutable ( ) ; cmd . setExecutable ( exec == null ? "jvc" : exec ) ; if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "/d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "/cp:p" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; boolean msExtensions = true ; String mse = getProject ( ) . getProperty ( "build.compiler.jvc.extensions" ) ; if ( mse != null ) { msExtensions = Project . toBoolean ( mse ) ; } if ( msExtensions ) { cmd . createArgument ( ) . setValue ( "/x-" ) ; cmd . createArgument ( ) . setValue ( "/nomessage" ) ; } cmd . createArgument ( ) . setValue ( "/nologo" ) ; if ( debug ) { cmd . createArgument ( ) . setValue ( "/g" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "/O" ) ; } if ( verbose ) { cmd . createArgument ( ) . setValue ( "/verbose" ) ; } addCurrentCompilerArgs ( cmd ) ; int firstFileName = cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } } 	0	['2', '2', '0', '9', '24', '1', '1', '8', '2', '2', '147', '0', '0', '0.958333333', '1', '0', '0', '72.5', '1', '0.5', '0']
package org . apache . tools . ant . helper ; import java . io . File ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Vector ; import org . xml . sax . Locator ; import org . xml . sax . Attributes ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Target ; import org . apache . tools . ant . RuntimeConfigurable ; public class AntXMLContext { private Project project ; private File buildFile ; private Vector targetVector = new Vector ( ) ; private File buildFileParent ; private String currentProjectName ; private Locator locator ; private Target implicitTarget = new Target ( ) ; private Target currentTarget = null ; private Vector wStack = new Vector ( ) ; private boolean ignoreProjectTag = false ; private Map prefixMapping = new HashMap ( ) ; public AntXMLContext ( Project project ) { this . project = project ; implicitTarget . setProject ( project ) ; implicitTarget . setName ( "" ) ; targetVector . addElement ( implicitTarget ) ; } public void setBuildFile ( File buildFile ) { this . buildFile = buildFile ; this . buildFileParent = new File ( buildFile . getParent ( ) ) ; } public File getBuildFile ( ) { return buildFile ; } public File getBuildFileParent ( ) { return buildFileParent ; } public Project getProject ( ) { return project ; } public String getCurrentProjectName ( ) { return currentProjectName ; } public void setCurrentProjectName ( String name ) { this . currentProjectName = name ; } public RuntimeConfigurable currentWrapper ( ) { if ( wStack . size ( ) < 1 ) { return null ; } return ( RuntimeConfigurable ) wStack . elementAt ( wStack . size ( ) - 1 ) ; } public RuntimeConfigurable parentWrapper ( ) { if ( wStack . size ( ) < 2 ) { return null ; } return ( RuntimeConfigurable ) wStack . elementAt ( wStack . size ( ) - 2 ) ; } public void pushWrapper ( RuntimeConfigurable wrapper ) { wStack . addElement ( wrapper ) ; } public void popWrapper ( ) { if ( wStack . size ( ) > 0 ) { wStack . removeElementAt ( wStack . size ( ) - 1 ) ; } } public Vector getWrapperStack ( ) { return wStack ; } public void addTarget ( Target target ) { targetVector . addElement ( target ) ; currentTarget = target ; } public Target getCurrentTarget ( ) { return currentTarget ; } public Target getImplicitTarget ( ) { return implicitTarget ; } public void setCurrentTarget ( Target target ) { this . currentTarget = target ; } public void setImplicitTarget ( Target target ) { this . implicitTarget = target ; } public Vector getTargets ( ) { return targetVector ; } public void configureId ( Object element , Attributes attr ) { String id = attr . getValue ( "id" ) ; if ( id != null ) { project . addReference ( id , element ) ; } } public Locator getLocator ( ) { return locator ; } public void setLocator ( Locator locator ) { this . locator = locator ; } public boolean isIgnoringProjectTag ( ) { return ignoreProjectTag ; } public void setIgnoreProjectTag ( boolean flag ) { this . ignoreProjectTag = flag ; } public void startPrefixMapping ( String prefix , String uri ) { List list = ( List ) prefixMapping . get ( prefix ) ; if ( list == null ) { list = new ArrayList ( ) ; prefixMapping . put ( prefix , list ) ; } list . add ( uri ) ; } public void endPrefixMapping ( String prefix ) { List list = ( List ) prefixMapping . get ( prefix ) ; if ( list == null || list . size ( ) == 0 ) { return ; } list . remove ( list . size ( ) - 1 ) ; } public String getPrefixMapping ( String prefix ) { List list = ( List ) prefixMapping . get ( prefix ) ; if ( list == null || list . size ( ) == 0 ) { return null ; } return ( String ) list . get ( list . size ( ) - 1 ) ; } } 	1	['26', '1', '0', '10', '47', '241', '7', '3', '26', '0.916363636', '279', '1', '3', '0', '0.153846154', '0', '0', '9.307692308', '3', '1.3077', '1']
package org . apache . tools . ant . types . selectors ; import org . apache . tools . ant . types . Parameterizable ; public interface ExtendFileSelector extends FileSelector , Parameterizable { } 	0	['0', '1', '0', '4', '0', '0', '2', '2', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . tools . ant ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Properties ; import java . util . Set ; import java . util . Stack ; import java . util . Vector ; import java . io . InputStream ; import java . io . IOException ; import java . lang . ref . WeakReference ; import java . lang . reflect . Modifier ; import org . apache . tools . ant . taskdefs . Typedef ; public class ComponentHelper { private AntTypeTable antTypeTable ; private Hashtable taskClassDefinitions = new Hashtable ( ) ; private boolean rebuildTaskClassDefinitions = true ; private Hashtable typeClassDefinitions = new Hashtable ( ) ; private boolean rebuildTypeClassDefinitions = true ; private Set checkedNamespaces = new HashSet ( ) ; private Stack antLibStack = new Stack ( ) ; private String antLibCurrentUri = null ; private Hashtable createdTasks = new Hashtable ( ) ; private ComponentHelper next ; private Project project ; public static ComponentHelper getComponentHelper ( Project project ) { ComponentHelper ph = ( ComponentHelper ) project . getReference ( "ant.ComponentHelper" ) ; if ( ph != null ) { return ph ; } ph = new ComponentHelper ( ) ; ph . setProject ( project ) ; project . addReference ( "ant.ComponentHelper" , ph ) ; return ph ; } protected ComponentHelper ( ) { } public void setNext ( ComponentHelper next ) { this . next = next ; } public ComponentHelper getNext ( ) { return next ; } public void setProject ( Project project ) { this . project = project ; antTypeTable = new AntTypeTable ( project ) ; } public void initSubProject ( ComponentHelper helper ) { AntTypeTable typeTable = helper . antTypeTable ; for ( Iterator i = typeTable . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { AntTypeDefinition def = ( AntTypeDefinition ) i . next ( ) ; antTypeTable . put ( def . getName ( ) , def ) ; } checkedNamespaces . add ( helper . checkedNamespaces ) ; } public Object createComponent ( UnknownElement ue , String ns , String componentType ) throws BuildException { Object component = createComponent ( componentType ) ; if ( component == null ) { return null ; } if ( component instanceof Task ) { Task task = ( Task ) component ; task . setLocation ( ue . getLocation ( ) ) ; task . setTaskType ( componentType ) ; task . setTaskName ( ue . getTaskName ( ) ) ; task . setOwningTarget ( ue . getOwningTarget ( ) ) ; task . init ( ) ; addCreatedTask ( componentType , task ) ; } return component ; } public Object createComponent ( String componentName ) { AntTypeDefinition def = getDefinition ( componentName ) ; if ( def == null ) { return null ; } return def . create ( project ) ; } public Class getComponentClass ( String componentName ) { AntTypeDefinition def = getDefinition ( componentName ) ; if ( def == null ) { return null ; } return def . getExposedClass ( project ) ; } public AntTypeDefinition getDefinition ( String componentName ) { checkNamespace ( componentName ) ; AntTypeDefinition ret = null ; ret = antTypeTable . getDefinition ( componentName ) ; return ret ; } public void initDefaultDefinitions ( ) { initTasks ( ) ; initTypes ( ) ; } public void addTaskDefinition ( String taskName , Class taskClass ) { checkTaskClass ( taskClass ) ; AntTypeDefinition def = new AntTypeDefinition ( ) ; def . setName ( taskName ) ; def . setClassLoader ( taskClass . getClassLoader ( ) ) ; def . setClass ( taskClass ) ; def . setAdapterClass ( TaskAdapter . class ) ; def . setClassName ( taskClass . getName ( ) ) ; def . setAdaptToClass ( Task . class ) ; updateDataTypeDefinition ( def ) ; } public void checkTaskClass ( final Class taskClass ) throws BuildException { if ( ! Modifier . isPublic ( taskClass . getModifiers ( ) ) ) { final String message = taskClass + " is not public" ; project . log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } if ( Modifier . isAbstract ( taskClass . getModifiers ( ) ) ) { final String message = taskClass + " is abstract" ; project . log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } try { taskClass . getConstructor ( null ) ; } catch ( NoSuchMethodException e ) { final String message = "No public no-arg constructor in " + taskClass ; project . log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } if ( ! Task . class . isAssignableFrom ( taskClass ) ) { TaskAdapter . checkTaskClass ( taskClass , project ) ; } } public Hashtable getTaskDefinitions ( ) { synchronized ( taskClassDefinitions ) { synchronized ( antTypeTable ) { if ( rebuildTaskClassDefinitions ) { taskClassDefinitions . clear ( ) ; for ( Iterator i = antTypeTable . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { String name = ( String ) i . next ( ) ; Class clazz = ( Class ) antTypeTable . getExposedClass ( name ) ; if ( clazz == null ) { continue ; } if ( Task . class . isAssignableFrom ( clazz ) ) { taskClassDefinitions . put ( name , antTypeTable . getTypeClass ( name ) ) ; } } rebuildTaskClassDefinitions = false ; } } } return taskClassDefinitions ; } public Hashtable getDataTypeDefinitions ( ) { synchronized ( typeClassDefinitions ) { synchronized ( antTypeTable ) { if ( rebuildTypeClassDefinitions ) { typeClassDefinitions . clear ( ) ; for ( Iterator i = antTypeTable . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { String name = ( String ) i . next ( ) ; Class clazz = ( Class ) antTypeTable . getExposedClass ( name ) ; if ( clazz == null ) { continue ; } if ( ! ( Task . class . isAssignableFrom ( clazz ) ) ) { typeClassDefinitions . put ( name , antTypeTable . getTypeClass ( name ) ) ; } } rebuildTypeClassDefinitions = false ; } } } return typeClassDefinitions ; } public void addDataTypeDefinition ( String typeName , Class typeClass ) { AntTypeDefinition def = new AntTypeDefinition ( ) ; def . setName ( typeName ) ; def . setClass ( typeClass ) ; updateDataTypeDefinition ( def ) ; String msg = " +User datatype: " + typeName + "     " + typeClass . getName ( ) ; project . log ( msg , Project . MSG_DEBUG ) ; } public void addDataTypeDefinition ( AntTypeDefinition def ) { updateDataTypeDefinition ( def ) ; } public Hashtable getAntTypeTable ( ) { return antTypeTable ; } public Task createTask ( String taskType ) throws BuildException { Task task = createNewTask ( taskType ) ; if ( task == null && taskType . equals ( "property" ) ) { addTaskDefinition ( "property" , org . apache . tools . ant . taskdefs . Property . class ) ; task = createNewTask ( taskType ) ; } if ( task != null ) { addCreatedTask ( taskType , task ) ; } return task ; } private Task createNewTask ( String taskType ) throws BuildException { Class c = getComponentClass ( taskType ) ; if ( c == null ) { return null ; } if ( ! ( Task . class . isAssignableFrom ( c ) ) ) { return null ; } Task task = ( Task ) createComponent ( taskType ) ; if ( task == null ) { return null ; } task . setTaskType ( taskType ) ; task . setTaskName ( taskType ) ; String msg = "   +Task: " + taskType ; project . log ( msg , Project . MSG_DEBUG ) ; return task ; } private void addCreatedTask ( String type , Task task ) { synchronized ( createdTasks ) { Vector v = ( Vector ) createdTasks . get ( type ) ; if ( v == null ) { v = new Vector ( ) ; createdTasks . put ( type , v ) ; } v . addElement ( new WeakReference ( task ) ) ; } } private void invalidateCreatedTasks ( String type ) { synchronized ( createdTasks ) { Vector v = ( Vector ) createdTasks . get ( type ) ; if ( v != null ) { Enumeration taskEnum = v . elements ( ) ; while ( taskEnum . hasMoreElements ( ) ) { WeakReference ref = ( WeakReference ) taskEnum . nextElement ( ) ; Task t = ( Task ) ref . get ( ) ; if ( t != null ) { t . markInvalid ( ) ; } } v . removeAllElements ( ) ; createdTasks . remove ( type ) ; } } } public Object createDataType ( String typeName ) throws BuildException { return createComponent ( typeName ) ; } public String getElementName ( Object element ) { Class elementClass = element . getClass ( ) ; for ( Iterator i = antTypeTable . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { AntTypeDefinition def = ( AntTypeDefinition ) i . next ( ) ; if ( elementClass == def . getExposedClass ( project ) ) { return "The <" + def . getName ( ) + "> type" ; } } return "Class " + elementClass . getName ( ) ; } private boolean validDefinition ( AntTypeDefinition def ) { if ( def . getTypeClass ( project ) == null || def . getExposedClass ( project ) == null ) { return false ; } return true ; } private boolean sameDefinition ( AntTypeDefinition def , AntTypeDefinition old ) { if ( ! validDefinition ( def ) || ! validDefinition ( old ) ) { return validDefinition ( def ) == validDefinition ( old ) ; } return def . sameDefinition ( old , project ) ; } private void updateDataTypeDefinition ( AntTypeDefinition def ) { String name = def . getName ( ) ; synchronized ( antTypeTable ) { rebuildTaskClassDefinitions = true ; rebuildTypeClassDefinitions = true ; AntTypeDefinition old = antTypeTable . getDefinition ( name ) ; if ( old != null ) { if ( sameDefinition ( def , old ) ) { return ; } int logLevel = Project . MSG_WARN ; if ( def . similarDefinition ( old , project ) ) { logLevel = Project . MSG_VERBOSE ; } Class oldClass = antTypeTable . getExposedClass ( name ) ; boolean isTask = ( oldClass != null && Task . class . isAssignableFrom ( oldClass ) ) ; project . log ( "Trying to override old definition of " + ( isTask ? "task" : "datatype" ) + " " + name , logLevel ) ; if ( isTask ) { invalidateCreatedTasks ( name ) ; } } project . log ( " +Datatype " + name + " " + def . getClassName ( ) , Project . MSG_DEBUG ) ; antTypeTable . put ( name , def ) ; } } public void enterAntLib ( String uri ) { antLibCurrentUri = uri ; antLibStack . push ( uri ) ; } public String getCurrentAntlibUri ( ) { return antLibCurrentUri ; } public void exitAntLib ( ) { antLibStack . pop ( ) ; if ( antLibStack . size ( ) != 0 ) { antLibCurrentUri = ( String ) antLibStack . peek ( ) ; } else { antLibCurrentUri = null ; } } private void initTasks ( ) { ClassLoader classLoader = null ; if ( project . getCoreLoader ( ) != null && ! ( "only" . equals ( project . getProperty ( "build.sysclasspath" ) ) ) ) { classLoader = project . getCoreLoader ( ) ; } String dataDefs = "/org/apache/tools/ant/taskdefs/defaults.properties" ; InputStream in = null ; try { Properties props = new Properties ( ) ; in = this . getClass ( ) . getResourceAsStream ( dataDefs ) ; if ( in == null ) { throw new BuildException ( "Can't load default task list" ) ; } props . load ( in ) ; Enumeration e = props . propertyNames ( ) ; while ( e . hasMoreElements ( ) ) { String name = ( String ) e . nextElement ( ) ; String className = props . getProperty ( name ) ; AntTypeDefinition def = new AntTypeDefinition ( ) ; def . setName ( name ) ; def . setClassName ( className ) ; def . setClassLoader ( classLoader ) ; def . setAdaptToClass ( Task . class ) ; def . setAdapterClass ( TaskAdapter . class ) ; antTypeTable . put ( name , def ) ; } } catch ( IOException ex ) { throw new BuildException ( "Can't load default type list" ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( Exception ignore ) { } } } } private void initTypes ( ) { ClassLoader classLoader = null ; if ( project . getCoreLoader ( ) != null && ! ( "only" . equals ( project . getProperty ( "build.sysclasspath" ) ) ) ) { classLoader = project . getCoreLoader ( ) ; } String dataDefs = "/org/apache/tools/ant/types/defaults.properties" ; InputStream in = null ; try { Properties props = new Properties ( ) ; in = this . getClass ( ) . getResourceAsStream ( dataDefs ) ; if ( in == null ) { throw new BuildException ( "Can't load default datatype list" ) ; } props . load ( in ) ; Enumeration e = props . propertyNames ( ) ; while ( e . hasMoreElements ( ) ) { String name = ( String ) e . nextElement ( ) ; String className = props . getProperty ( name ) ; AntTypeDefinition def = new AntTypeDefinition ( ) ; def . setName ( name ) ; def . setClassName ( className ) ; def . setClassLoader ( classLoader ) ; antTypeTable . put ( name , def ) ; } } catch ( IOException ex ) { throw new BuildException ( "Can't load default type list" ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( Exception ignore ) { } } } } private synchronized void checkNamespace ( String componentName ) { if ( componentName . indexOf ( ':' ) == - 1 ) { return ; } String uri = ProjectHelper . extractUriFromComponentName ( componentName ) ; if ( ! uri . startsWith ( ProjectHelper . ANTLIB_URI ) ) { return ; } if ( checkedNamespaces . contains ( uri ) ) { return ; } checkedNamespaces . add ( uri ) ; Typedef definer = new Typedef ( ) ; definer . setProject ( project ) ; definer . setURI ( uri ) ; definer . setResource ( uri . substring ( "antlib:" . length ( ) ) . replace ( '.' , '/' ) + "/antlib.xml" ) ; definer . setOnError ( new Typedef . OnError ( "ignore" ) ) ; definer . init ( ) ; definer . execute ( ) ; } private static class AntTypeTable extends Hashtable { private Project project ; public AntTypeTable ( Project project ) { this . project = project ; } public AntTypeDefinition getDefinition ( String key ) { AntTypeDefinition ret = ( AntTypeDefinition ) super . get ( key ) ; return ret ; } public Object get ( Object key ) { return getTypeClass ( ( String ) key ) ; } public Object create ( String name ) { AntTypeDefinition def = getDefinition ( name ) ; if ( def == null ) { return null ; } return def . create ( project ) ; } public Class getTypeClass ( String name ) { AntTypeDefinition def = getDefinition ( name ) ; if ( def == null ) { return null ; } return def . getTypeClass ( project ) ; } public Class getExposedClass ( String name ) { AntTypeDefinition def = getDefinition ( name ) ; if ( def == null ) { return null ; } return def . getExposedClass ( project ) ; } public boolean contains ( Object clazz ) { for ( Iterator i = values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { AntTypeDefinition def = ( AntTypeDefinition ) i . next ( ) ; Class c = def . getExposedClass ( project ) ; if ( c == clazz ) { return true ; } } return false ; } public boolean containsValue ( Object value ) { return contains ( value ) ; } } } 	1	['34', '1', '0', '21', '132', '283', '8', '16', '23', '0.80952381', '1255', '0.785714286', '3', '0', '0.196078431', '0', '0', '35.5', '10', '2.5882', '2']
package org . apache . tools . ant . types . selectors ; import java . io . File ; public class DependSelector extends MappingSelector { public DependSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{dependselector targetdir: " ) ; if ( targetdir == null ) { buf . append ( "NOT YET SET" ) ; } else { buf . append ( targetdir . getName ( ) ) ; } buf . append ( " granularity: " ) ; buf . append ( granularity ) ; if ( map != null ) { buf . append ( " mapper: " ) ; buf . append ( map . toString ( ) ) ; } else if ( mapperElement != null ) { buf . append ( " mapper: " ) ; buf . append ( mapperElement . toString ( ) ) ; } buf . append ( "}" ) ; return buf . toString ( ) ; } public boolean selectionTest ( File srcfile , File destfile ) { boolean selected = SelectorUtils . isOutOfDate ( srcfile , destfile , granularity ) ; return selected ; } } 	0	['3', '5', '0', '9', '11', '3', '5', '4', '3', '2', '76', '0', '0', '0.953488372', '0.666666667', '1', '1', '24.33333333', '4', '1.6667', '0']
package org . apache . tools . ant ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . apache . tools . ant . util . LoaderUtils ; public class AntClassLoader extends ClassLoader implements BuildListener { private class ResourceEnumeration implements Enumeration { private String resourceName ; private int pathElementsIndex ; private URL nextResource ; ResourceEnumeration ( String name ) { this . resourceName = name ; this . pathElementsIndex = 0 ; findNextResource ( ) ; } public boolean hasMoreElements ( ) { return ( this . nextResource != null ) ; } public Object nextElement ( ) { URL ret = this . nextResource ; findNextResource ( ) ; return ret ; } private void findNextResource ( ) { URL url = null ; while ( ( pathElementsIndex < pathComponents . size ( ) ) && ( url == null ) ) { try { File pathComponent = ( File ) pathComponents . elementAt ( pathElementsIndex ) ; url = getResourceURL ( pathComponent , this . resourceName ) ; pathElementsIndex ++ ; } catch ( BuildException e ) { } } this . nextResource = url ; } } private static final int BUFFER_SIZE = 8192 ; private static final int NUMBER_OF_STRINGS = 256 ; private Vector pathComponents = new Vector ( ) ; private Project project ; private boolean parentFirst = true ; private Vector systemPackages = new Vector ( ) ; private Vector loaderPackages = new Vector ( ) ; private boolean ignoreBase = false ; private ClassLoader parent = null ; private Hashtable zipFiles = new Hashtable ( ) ; private ClassLoader savedContextLoader = null ; private boolean isContextLoaderSaved = false ; private static Method getProtectionDomain = null ; private static Method defineClassProtectionDomain = null ; static { try { getProtectionDomain = Class . class . getMethod ( "getProtectionDomain" , new Class [ 0 ] ) ; Class protectionDomain = Class . forName ( "java.security.ProtectionDomain" ) ; Class [ ] args = new Class [ ] { String . class , byte [ ] . class , Integer . TYPE , Integer . TYPE , protectionDomain } ; defineClassProtectionDomain = ClassLoader . class . getDeclaredMethod ( "defineClass" , args ) ; } catch ( Exception e ) { } } public AntClassLoader ( ) { setParent ( null ) ; } public AntClassLoader ( Project project , Path classpath ) { setParent ( null ) ; setProject ( project ) ; setClassPath ( classpath ) ; } public AntClassLoader ( ClassLoader parent , Project project , Path classpath , boolean parentFirst ) { this ( project , classpath ) ; if ( parent != null ) { setParent ( parent ) ; } setParentFirst ( parentFirst ) ; addJavaLibraries ( ) ; } public AntClassLoader ( Project project , Path classpath , boolean parentFirst ) { this ( null , project , classpath , parentFirst ) ; } public AntClassLoader ( ClassLoader parent , boolean parentFirst ) { setParent ( parent ) ; project = null ; this . parentFirst = parentFirst ; } public void setProject ( Project project ) { this . project = project ; if ( project != null ) { project . addBuildListener ( this ) ; } } public void setClassPath ( Path classpath ) { pathComponents . removeAllElements ( ) ; if ( classpath != null ) { Path actualClasspath = classpath . concatSystemClasspath ( "ignore" ) ; String [ ] pathElements = actualClasspath . list ( ) ; for ( int i = 0 ; i < pathElements . length ; ++ i ) { try { addPathElement ( pathElements [ i ] ) ; } catch ( BuildException e ) { } } } } public void setParent ( ClassLoader parent ) { if ( parent == null ) { this . parent = AntClassLoader . class . getClassLoader ( ) ; } else { this . parent = parent ; } } public void setParentFirst ( boolean parentFirst ) { this . parentFirst = parentFirst ; } protected void log ( String message , int priority ) { if ( project != null ) { project . log ( message , priority ) ; } } public void setThreadContextLoader ( ) { if ( isContextLoaderSaved ) { throw new BuildException ( "Context loader has not been reset" ) ; } if ( LoaderUtils . isContextLoaderAvailable ( ) ) { savedContextLoader = LoaderUtils . getContextClassLoader ( ) ; ClassLoader loader = this ; if ( project != null && "only" . equals ( project . getProperty ( "build.sysclasspath" ) ) ) { loader = this . getClass ( ) . getClassLoader ( ) ; } LoaderUtils . setContextClassLoader ( loader ) ; isContextLoaderSaved = true ; } } public void resetThreadContextLoader ( ) { if ( LoaderUtils . isContextLoaderAvailable ( ) && isContextLoaderSaved ) { LoaderUtils . setContextClassLoader ( savedContextLoader ) ; savedContextLoader = null ; isContextLoaderSaved = false ; } } public void addPathElement ( String pathElement ) throws BuildException { File pathComponent = project != null ? project . resolveFile ( pathElement ) : new File ( pathElement ) ; try { addPathFile ( pathComponent ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } protected void addPathFile ( File pathComponent ) throws IOException { pathComponents . addElement ( pathComponent ) ; } public String getClasspath ( ) { StringBuffer sb = new StringBuffer ( ) ; boolean firstPass = true ; Enumeration componentEnum = pathComponents . elements ( ) ; while ( componentEnum . hasMoreElements ( ) ) { if ( ! firstPass ) { sb . append ( System . getProperty ( "path.separator" ) ) ; } else { firstPass = false ; } sb . append ( ( ( File ) componentEnum . nextElement ( ) ) . getAbsolutePath ( ) ) ; } return sb . toString ( ) ; } public synchronized void setIsolated ( boolean isolated ) { ignoreBase = isolated ; } public static void initializeClass ( Class theClass ) { final Constructor [ ] cons = theClass . getDeclaredConstructors ( ) ; if ( cons != null ) { if ( cons . length > 0 && cons [ 0 ] != null ) { final String [ ] strs = new String [ NUMBER_OF_STRINGS ] ; try { cons [ 0 ] . newInstance ( strs ) ; } catch ( Throwable t ) { } } } } public void addSystemPackageRoot ( String packageRoot ) { systemPackages . addElement ( packageRoot + ( packageRoot . endsWith ( "." ) ? "" : "." ) ) ; } public void addLoaderPackageRoot ( String packageRoot ) { loaderPackages . addElement ( packageRoot + ( packageRoot . endsWith ( "." ) ? "" : "." ) ) ; } public Class forceLoadClass ( String classname ) throws ClassNotFoundException { log ( "force loading " + classname , Project . MSG_DEBUG ) ; Class theClass = findLoadedClass ( classname ) ; if ( theClass == null ) { theClass = findClass ( classname ) ; } return theClass ; } public Class forceLoadSystemClass ( String classname ) throws ClassNotFoundException { log ( "force system loading " + classname , Project . MSG_DEBUG ) ; Class theClass = findLoadedClass ( classname ) ; if ( theClass == null ) { theClass = findBaseClass ( classname ) ; } return theClass ; } public InputStream getResourceAsStream ( String name ) { InputStream resourceStream = null ; if ( isParentFirst ( name ) ) { resourceStream = loadBaseResource ( name ) ; if ( resourceStream != null ) { log ( "ResourceStream for " + name + " loaded from parent loader" , Project . MSG_DEBUG ) ; } else { resourceStream = loadResource ( name ) ; if ( resourceStream != null ) { log ( "ResourceStream for " + name + " loaded from ant loader" , Project . MSG_DEBUG ) ; } } } else { resourceStream = loadResource ( name ) ; if ( resourceStream != null ) { log ( "ResourceStream for " + name + " loaded from ant loader" , Project . MSG_DEBUG ) ; } else { resourceStream = loadBaseResource ( name ) ; if ( resourceStream != null ) { log ( "ResourceStream for " + name + " loaded from parent loader" , Project . MSG_DEBUG ) ; } } } if ( resourceStream == null ) { log ( "Couldn't load ResourceStream for " + name , Project . MSG_DEBUG ) ; } return resourceStream ; } private InputStream loadResource ( String name ) { InputStream stream = null ; Enumeration e = pathComponents . elements ( ) ; while ( e . hasMoreElements ( ) && stream == null ) { File pathComponent = ( File ) e . nextElement ( ) ; stream = getResourceStream ( pathComponent , name ) ; } return stream ; } private InputStream loadBaseResource ( String name ) { if ( parent == null ) { return getSystemResourceAsStream ( name ) ; } else { return parent . getResourceAsStream ( name ) ; } } private InputStream getResourceStream ( File file , String resourceName ) { try { if ( ! file . exists ( ) ) { return null ; } if ( file . isDirectory ( ) ) { File resource = new File ( file , resourceName ) ; if ( resource . exists ( ) ) { return new FileInputStream ( resource ) ; } } else { ZipFile zipFile = ( ZipFile ) zipFiles . get ( file ) ; if ( zipFile == null ) { zipFile = new ZipFile ( file ) ; zipFiles . put ( file , zipFile ) ; } ZipEntry entry = zipFile . getEntry ( resourceName ) ; if ( entry != null ) { return zipFile . getInputStream ( entry ) ; } } } catch ( Exception e ) { log ( "Ignoring Exception " + e . getClass ( ) . getName ( ) + ": " + e . getMessage ( ) + " reading resource " + resourceName + " from " + file , Project . MSG_VERBOSE ) ; } return null ; } private boolean isParentFirst ( String resourceName ) { boolean useParentFirst = parentFirst ; for ( Enumeration e = systemPackages . elements ( ) ; e . hasMoreElements ( ) ; ) { String packageName = ( String ) e . nextElement ( ) ; if ( resourceName . startsWith ( packageName ) ) { useParentFirst = true ; break ; } } for ( Enumeration e = loaderPackages . elements ( ) ; e . hasMoreElements ( ) ; ) { String packageName = ( String ) e . nextElement ( ) ; if ( resourceName . startsWith ( packageName ) ) { useParentFirst = false ; break ; } } return useParentFirst ; } public URL getResource ( String name ) { URL url = null ; if ( isParentFirst ( name ) ) { url = ( parent == null ) ? super . getResource ( name ) : parent . getResource ( name ) ; } if ( url != null ) { log ( "Resource " + name + " loaded from parent loader" , Project . MSG_DEBUG ) ; } else { Enumeration e = pathComponents . elements ( ) ; while ( e . hasMoreElements ( ) && url == null ) { File pathComponent = ( File ) e . nextElement ( ) ; url = getResourceURL ( pathComponent , name ) ; if ( url != null ) { log ( "Resource " + name + " loaded from ant loader" , Project . MSG_DEBUG ) ; } } } if ( url == null && ! isParentFirst ( name ) ) { url = ( parent == null ) ? super . getResource ( name ) : parent . getResource ( name ) ; if ( url != null ) { log ( "Resource " + name + " loaded from parent loader" , Project . MSG_DEBUG ) ; } } if ( url == null ) { log ( "Couldn't load Resource " + name , Project . MSG_DEBUG ) ; } return url ; } protected Enumeration findResources ( String name ) throws IOException { return new ResourceEnumeration ( name ) ; } protected URL getResourceURL ( File file , String resourceName ) { try { if ( ! file . exists ( ) ) { return null ; } if ( file . isDirectory ( ) ) { File resource = new File ( file , resourceName ) ; if ( resource . exists ( ) ) { try { return new URL ( "file:" + resource . toString ( ) ) ; } catch ( MalformedURLException ex ) { return null ; } } } else { ZipFile zipFile = ( ZipFile ) zipFiles . get ( file ) ; if ( zipFile == null ) { zipFile = new ZipFile ( file ) ; zipFiles . put ( file , zipFile ) ; } ZipEntry entry = zipFile . getEntry ( resourceName ) ; if ( entry != null ) { try { return new URL ( "jar:file:" + file . toString ( ) + "!/" + entry ) ; } catch ( MalformedURLException ex ) { return null ; } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; } protected synchronized Class loadClass ( String classname , boolean resolve ) throws ClassNotFoundException { Class theClass = findLoadedClass ( classname ) ; if ( theClass != null ) { return theClass ; } if ( isParentFirst ( classname ) ) { try { theClass = findBaseClass ( classname ) ; log ( "Class " + classname + " loaded from parent loader " + "(parentFirst)" , Project . MSG_DEBUG ) ; } catch ( ClassNotFoundException cnfe ) { theClass = findClass ( classname ) ; log ( "Class " + classname + " loaded from ant loader " + "(parentFirst)" , Project . MSG_DEBUG ) ; } } else { try { theClass = findClass ( classname ) ; log ( "Class " + classname + " loaded from ant loader" , Project . MSG_DEBUG ) ; } catch ( ClassNotFoundException cnfe ) { if ( ignoreBase ) { throw cnfe ; } theClass = findBaseClass ( classname ) ; log ( "Class " + classname + " loaded from parent loader" , Project . MSG_DEBUG ) ; } } if ( resolve ) { resolveClass ( theClass ) ; } return theClass ; } private String getClassFilename ( String classname ) { return classname . replace ( '.' , '/' ) + ".class" ; } protected Class defineClassFromData ( File container , byte [ ] classData , String classname ) throws IOException { if ( defineClassProtectionDomain != null ) { try { Object domain = getProtectionDomain . invoke ( Project . class , new Object [ 0 ] ) ; Object [ ] args = new Object [ ] { classname , classData , new Integer ( 0 ) , new Integer ( classData . length ) , domain } ; return ( Class ) defineClassProtectionDomain . invoke ( this , args ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof ClassFormatError ) { throw ( ClassFormatError ) t ; } else if ( t instanceof NoClassDefFoundError ) { throw ( NoClassDefFoundError ) t ; } else if ( t instanceof SecurityException ) { throw ( SecurityException ) t ; } else { throw new IOException ( t . toString ( ) ) ; } } catch ( Exception e ) { throw new IOException ( e . toString ( ) ) ; } } else { return defineClass ( classname , classData , 0 , classData . length ) ; } } private Class getClassFromStream ( InputStream stream , String classname , File container ) throws IOException , SecurityException { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; int bytesRead = - 1 ; byte [ ] buffer = new byte [ BUFFER_SIZE ] ; while ( ( bytesRead = stream . read ( buffer , 0 , BUFFER_SIZE ) ) != - 1 ) { baos . write ( buffer , 0 , bytesRead ) ; } byte [ ] classData = baos . toByteArray ( ) ; return defineClassFromData ( container , classData , classname ) ; } public Class findClass ( String name ) throws ClassNotFoundException { log ( "Finding class " + name , Project . MSG_DEBUG ) ; return findClassInComponents ( name ) ; } protected boolean isInPath ( File component ) { for ( Enumeration e = pathComponents . elements ( ) ; e . hasMoreElements ( ) ; ) { File pathComponent = ( File ) e . nextElement ( ) ; if ( pathComponent . equals ( component ) ) { return true ; } } return false ; } private Class findClassInComponents ( String name ) throws ClassNotFoundException { InputStream stream = null ; String classFilename = getClassFilename ( name ) ; try { Enumeration e = pathComponents . elements ( ) ; while ( e . hasMoreElements ( ) ) { File pathComponent = ( File ) e . nextElement ( ) ; try { stream = getResourceStream ( pathComponent , classFilename ) ; if ( stream != null ) { log ( "Loaded from " + pathComponent + " " + classFilename , Project . MSG_DEBUG ) ; return getClassFromStream ( stream , name , pathComponent ) ; } } catch ( SecurityException se ) { throw se ; } catch ( IOException ioe ) { log ( "Exception reading component " + pathComponent + " (reason: " + ioe . getMessage ( ) + ")" , Project . MSG_VERBOSE ) ; } } throw new ClassNotFoundException ( name ) ; } finally { try { if ( stream != null ) { stream . close ( ) ; } } catch ( IOException e ) { } } } private Class findBaseClass ( String name ) throws ClassNotFoundException { if ( parent == null ) { return findSystemClass ( name ) ; } else { return parent . loadClass ( name ) ; } } public synchronized void cleanup ( ) { for ( Enumeration e = zipFiles . elements ( ) ; e . hasMoreElements ( ) ; ) { ZipFile zipFile = ( ZipFile ) e . nextElement ( ) ; try { zipFile . close ( ) ; } catch ( IOException ioe ) { } } zipFiles = new Hashtable ( ) ; if ( project != null ) { project . removeBuildListener ( this ) ; } project = null ; } public void buildStarted ( BuildEvent event ) { } public void buildFinished ( BuildEvent event ) { cleanup ( ) ; } public void targetStarted ( BuildEvent event ) { } public void targetFinished ( BuildEvent event ) { } public void taskStarted ( BuildEvent event ) { } public void taskFinished ( BuildEvent event ) { } public void messageLogged ( BuildEvent event ) { } public void addJavaLibraries ( ) { Vector packages = JavaEnvUtils . getJrePackages ( ) ; Enumeration e = packages . elements ( ) ; while ( e . hasMoreElements ( ) ) { String packageName = ( String ) e . nextElement ( ) ; addSystemPackageRoot ( packageName ) ; } } } 	1	['49', '2', '1', '24', '126', '926', '18', '8', '31', '0.883333333', '1512', '0.7', '1', '0.441558442', '0.163461538', '1', '5', '29.44897959', '12', '1.9796', '10']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; public class Not extends ConditionBase implements Condition { public boolean eval ( ) throws BuildException { if ( countConditions ( ) > 1 ) { throw new BuildException ( "You must not nest more than one " + "condition into <not>" ) ; } if ( countConditions ( ) < 1 ) { throw new BuildException ( "You must nest a condition into <not>" ) ; } return ! ( ( Condition ) getConditions ( ) . nextElement ( ) ) . eval ( ) ; } } 	0	['2', '3', '0', '3', '8', '1', '1', '3', '2', '2', '33', '0', '0', '0.96969697', '1', '0', '0', '15.5', '1', '0.5', '0']
package org . apache . tools . ant . util ; import org . apache . tools . ant . BuildException ; import java . lang . reflect . Constructor ; public abstract class WeakishReference { private static Constructor referenceConstructor ; private final static String WEAK_REFERENCE_NAME = "org.apache.tools.ant.util.optional.WeakishReference12" ; public static WeakishReference createReference ( Object object ) { if ( referenceConstructor == null ) { createReferenceConstructor ( ) ; } try { return ( WeakishReference ) referenceConstructor . newInstance ( new Object [ ] { object } ) ; } catch ( Exception e ) { throw new BuildException ( "while creating a weakish reference" , e ) ; } } private static void createReferenceConstructor ( ) { Class [ ] ctor = new Class [ ] { Object . class } ; try { referenceConstructor = HardReference . class . getConstructor ( ctor ) ; } catch ( NoSuchMethodException e ) { throw new BuildException ( "when creating a Hard Reference constructor" , e ) ; } if ( ! JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { try { Class clazz = Class . forName ( WEAK_REFERENCE_NAME ) ; referenceConstructor = clazz . getConstructor ( ctor ) ; } catch ( ClassNotFoundException e ) { } catch ( NoSuchMethodException e ) { } } } public abstract Object get ( ) ; public static class HardReference extends WeakishReference { private Object object ; public HardReference ( Object object ) { this . object = object ; } public Object get ( ) { return object ; } } } 	1	['5', '1', '1', '3', '13', '8', '1', '2', '3', '0.875', '91', '0.5', '0', '0', '0.266666667', '0', '0', '16.4', '4', '1.6', '1']
package org . apache . tools . ant . types . selectors ; import java . util . Enumeration ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . selectors . modifiedselector . ModifiedSelector ; public interface SelectorContainer { boolean hasSelectors ( ) ; int selectorCount ( ) ; FileSelector [ ] getSelectors ( Project p ) ; Enumeration selectorElements ( ) ; void appendSelector ( FileSelector selector ) ; void addSelector ( SelectSelector selector ) ; void addAnd ( AndSelector selector ) ; void addOr ( OrSelector selector ) ; void addNot ( NotSelector selector ) ; void addNone ( NoneSelector selector ) ; void addMajority ( MajoritySelector selector ) ; void addDate ( DateSelector selector ) ; void addSize ( SizeSelector selector ) ; void addFilename ( FilenameSelector selector ) ; void addCustom ( ExtendSelector selector ) ; void addContains ( ContainsSelector selector ) ; void addPresent ( PresentSelector selector ) ; void addDepth ( DepthSelector selector ) ; void addDepend ( DependSelector selector ) ; void addContainsRegexp ( ContainsRegexpSelector selector ) ; void addType ( TypeSelector selector ) ; void addDifferent ( DifferentSelector selector ) ; void addModified ( ModifiedSelector selector ) ; void add ( FileSelector selector ) ; } 	0	['24', '1', '0', '23', '24', '276', '3', '20', '24', '2', '24', '0', '0', '0', '0.089285714', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Enumeration ; import java . util . HashMap ; import java . util . Hashtable ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Iterator ; import org . apache . tools . ant . util . CollectionUtils ; import org . xml . sax . AttributeList ; import org . xml . sax . helpers . AttributeListImpl ; public class RuntimeConfigurable implements Serializable { private static final String ANT_TYPE = "ant-type" ; private String elementTag = null ; private List children = null ; private transient Object wrappedObject = null ; private transient IntrospectionHelper . Creator creator ; private transient AttributeList attributes ; private List attributeNames = null ; private Map attributeMap = null ; private StringBuffer characters = null ; private boolean proxyConfigured = false ; private String polyType = null ; public RuntimeConfigurable ( Object proxy , String elementTag ) { wrappedObject = proxy ; this . elementTag = elementTag ; proxyConfigured = false ; if ( proxy instanceof Task ) { ( ( Task ) proxy ) . setRuntimeConfigurableWrapper ( this ) ; } } public void setProxy ( Object proxy ) { wrappedObject = proxy ; proxyConfigured = false ; } void setCreator ( IntrospectionHelper . Creator creator ) { this . creator = creator ; } public Object getProxy ( ) { return wrappedObject ; } public String getPolyType ( ) { return polyType ; } public void setPolyType ( String polyType ) { this . polyType = polyType ; } public void setAttributes ( AttributeList attributes ) { this . attributes = new AttributeListImpl ( attributes ) ; for ( int i = 0 ; i < attributes . getLength ( ) ; i ++ ) { setAttribute ( attributes . getName ( i ) , attributes . getValue ( i ) ) ; } } public void setAttribute ( String name , String value ) { if ( name . equalsIgnoreCase ( ANT_TYPE ) ) { this . polyType = value ; } else { if ( attributeNames == null ) { attributeNames = new ArrayList ( ) ; attributeMap = new HashMap ( ) ; } attributeNames . add ( name ) ; attributeMap . put ( name , value ) ; } } public Hashtable getAttributeMap ( ) { if ( attributeMap != null ) { return new Hashtable ( attributeMap ) ; } else { return new Hashtable ( 1 ) ; } } public AttributeList getAttributes ( ) { return attributes ; } public void addChild ( RuntimeConfigurable child ) { if ( children == null ) { children = new ArrayList ( ) ; } children . add ( child ) ; } RuntimeConfigurable getChild ( int index ) { return ( RuntimeConfigurable ) children . get ( index ) ; } public Enumeration getChildren ( ) { if ( children != null ) { return Collections . enumeration ( children ) ; } else { return new CollectionUtils . EmptyEnumeration ( ) ; } } public void addText ( String data ) { if ( data . length ( ) == 0 ) { return ; } if ( characters != null ) { characters . append ( data ) ; } else { characters = new StringBuffer ( data ) ; } } public void addText ( char [ ] buf , int start , int count ) { if ( count == 0 ) { return ; } if ( characters == null ) { characters = new StringBuffer ( count ) ; } characters . append ( buf , start , count ) ; } public StringBuffer getText ( ) { if ( characters != null ) { return characters ; } else { return new StringBuffer ( 0 ) ; } } public String getElementTag ( ) { return elementTag ; } public void maybeConfigure ( Project p ) throws BuildException { maybeConfigure ( p , true ) ; } public void maybeConfigure ( Project p , boolean configureChildren ) throws BuildException { String id = null ; if ( proxyConfigured ) { return ; } Object target = ( wrappedObject instanceof TypeAdapter ) ? ( ( TypeAdapter ) wrappedObject ) . getProxy ( ) : wrappedObject ; IntrospectionHelper ih = IntrospectionHelper . getHelper ( p , target . getClass ( ) ) ; if ( attributeNames != null ) { for ( int i = 0 ; i < attributeNames . size ( ) ; i ++ ) { String name = ( String ) attributeNames . get ( i ) ; String value = ( String ) attributeMap . get ( name ) ; value = p . replaceProperties ( value ) ; try { ih . setAttribute ( p , target , name . toLowerCase ( Locale . US ) , value ) ; } catch ( BuildException be ) { if ( ! name . equals ( "id" ) ) { throw be ; } } } id = ( String ) attributeMap . get ( "id" ) ; } if ( characters != null ) { ProjectHelper . addText ( p , wrappedObject , characters . substring ( 0 ) ) ; } Enumeration e = getChildren ( ) ; while ( e . hasMoreElements ( ) ) { RuntimeConfigurable child = ( RuntimeConfigurable ) e . nextElement ( ) ; if ( child . wrappedObject instanceof Task ) { Task childTask = ( Task ) child . wrappedObject ; childTask . setRuntimeConfigurableWrapper ( child ) ; } if ( ( child . creator != null ) && configureChildren ) { child . maybeConfigure ( p ) ; child . creator . store ( ) ; continue ; } String tag = child . getElementTag ( ) . toLowerCase ( Locale . US ) ; if ( configureChildren && ih . supportsNestedElement ( tag ) ) { child . maybeConfigure ( p ) ; ProjectHelper . storeChild ( p , target , child . wrappedObject , tag ) ; } } if ( id != null ) { p . addReference ( id , wrappedObject ) ; } proxyConfigured = true ; } public void reconfigure ( Project p ) { proxyConfigured = false ; maybeConfigure ( p ) ; } public void applyPreSet ( RuntimeConfigurable r ) { if ( r . attributeMap != null ) { for ( Iterator i = r . attributeMap . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { String name = ( String ) i . next ( ) ; if ( attributeMap == null || attributeMap . get ( name ) == null ) { setAttribute ( name , ( String ) r . attributeMap . get ( name ) ) ; } } } if ( r . polyType != null && polyType == null ) { polyType = r . polyType ; } if ( r . children != null ) { List newChildren = new ArrayList ( ) ; newChildren . addAll ( r . children ) ; if ( children != null ) { newChildren . addAll ( children ) ; } children = newChildren ; } if ( r . characters != null ) { if ( characters == null || characters . toString ( ) . trim ( ) . length ( ) == 0 ) { characters = new StringBuffer ( r . characters . toString ( ) ) ; } } } } 	1	['21', '1', '0', '19', '66', '112', '12', '8', '19', '0.8', '502', '1', '1', '0', '0.180952381', '0', '0', '22.38095238', '12', '2', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class Exit extends Task { private String message ; private String ifCondition , unlessCondition ; public void setMessage ( String value ) { this . message = value ; } public void setIf ( String c ) { ifCondition = c ; } public void setUnless ( String c ) { unlessCondition = c ; } public void execute ( ) throws BuildException { if ( testIfCondition ( ) && testUnlessCondition ( ) ) { String text = null ; if ( message != null && message . length ( ) > 0 ) { text = message ; } else { if ( getProject ( ) . getProperty ( ifCondition ) != null ) { text = "if=" + ifCondition ; } if ( unlessCondition != null && unlessCondition . length ( ) > 0 && getProject ( ) . getProperty ( unlessCondition ) == null ) { if ( text == null ) { text = "" ; } else { text += " and " ; } text += "unless=" + unlessCondition ; } else { if ( text == null ) { text = "No message" ; } } } throw new BuildException ( text ) ; } } public void addText ( String msg ) { if ( message == null ) { message = "" ; } message += getProject ( ) . replaceProperties ( msg ) ; } private boolean testIfCondition ( ) { if ( ifCondition == null || "" . equals ( ifCondition ) ) { return true ; } return getProject ( ) . getProperty ( ifCondition ) != null ; } private boolean testUnlessCondition ( ) { if ( unlessCondition == null || "" . equals ( unlessCondition ) ) { return true ; } return getProject ( ) . getProperty ( unlessCondition ) == null ; } } 	0	['8', '3', '0', '4', '18', '10', '0', '4', '6', '0.714285714', '172', '1', '0', '0.840909091', '0.75', '0', '0', '20.125', '4', '1.75', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FileWriter ; import java . io . IOException ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . UnsupportedEncodingException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . IntrospectionHelper ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Reference ; public class AntStructure extends Task { private final String lSep = System . getProperty ( "line.separator" ) ; private static final String BOOLEAN = "%boolean;" ; private static final String TASKS = "%tasks;" ; private static final String TYPES = "%types;" ; private Hashtable visited = new Hashtable ( ) ; private File output ; public void setOutput ( File output ) { this . output = output ; } public void execute ( ) throws BuildException { if ( output == null ) { throw new BuildException ( "output attribute is required" , getLocation ( ) ) ; } PrintWriter out = null ; try { try { out = new PrintWriter ( new OutputStreamWriter ( new FileOutputStream ( output ) , "UTF8" ) ) ; } catch ( UnsupportedEncodingException ue ) { out = new PrintWriter ( new FileWriter ( output ) ) ; } printHead ( out , getProject ( ) . getTaskDefinitions ( ) . keys ( ) , getProject ( ) . getDataTypeDefinitions ( ) . keys ( ) ) ; printTargetDecl ( out ) ; Enumeration dataTypes = getProject ( ) . getDataTypeDefinitions ( ) . keys ( ) ; while ( dataTypes . hasMoreElements ( ) ) { String typeName = ( String ) dataTypes . nextElement ( ) ; printElementDecl ( out , typeName , ( Class ) getProject ( ) . getDataTypeDefinitions ( ) . get ( typeName ) ) ; } Enumeration tasks = getProject ( ) . getTaskDefinitions ( ) . keys ( ) ; while ( tasks . hasMoreElements ( ) ) { String taskName = ( String ) tasks . nextElement ( ) ; printElementDecl ( out , taskName , ( Class ) getProject ( ) . getTaskDefinitions ( ) . get ( taskName ) ) ; } } catch ( IOException ioe ) { throw new BuildException ( "Error writing " + output . getAbsolutePath ( ) , ioe , getLocation ( ) ) ; } finally { if ( out != null ) { out . close ( ) ; } visited . clear ( ) ; } } private void printHead ( PrintWriter out , Enumeration tasks , Enumeration types ) { out . println ( "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>" ) ; out . println ( "<!ENTITY % boolean \"(true|false|on|off|yes|no)\">" ) ; out . print ( "<!ENTITY % tasks \"" ) ; boolean first = true ; while ( tasks . hasMoreElements ( ) ) { String taskName = ( String ) tasks . nextElement ( ) ; if ( ! first ) { out . print ( " | " ) ; } else { first = false ; } out . print ( taskName ) ; } out . println ( "\">" ) ; out . print ( "<!ENTITY % types \"" ) ; first = true ; while ( types . hasMoreElements ( ) ) { String typeName = ( String ) types . nextElement ( ) ; if ( ! first ) { out . print ( " | " ) ; } else { first = false ; } out . print ( typeName ) ; } out . println ( "\">" ) ; out . println ( "" ) ; out . print ( "<!ELEMENT project (target | " ) ; out . print ( TASKS ) ; out . print ( " | " ) ; out . print ( TYPES ) ; out . println ( ")*>" ) ; out . println ( "<!ATTLIST project" ) ; out . println ( "          name    CDATA #IMPLIED" ) ; out . println ( "          default CDATA #IMPLIED" ) ; out . println ( "          basedir CDATA #IMPLIED>" ) ; out . println ( "" ) ; } private void printTargetDecl ( PrintWriter out ) { out . print ( "<!ELEMENT target (" ) ; out . print ( TASKS ) ; out . print ( " | " ) ; out . print ( TYPES ) ; out . println ( ")*>" ) ; out . println ( "" ) ; out . println ( "<!ATTLIST target" ) ; out . println ( "          id          ID    #IMPLIED" ) ; out . println ( "          name        CDATA #REQUIRED" ) ; out . println ( "          if          CDATA #IMPLIED" ) ; out . println ( "          unless      CDATA #IMPLIED" ) ; out . println ( "          depends     CDATA #IMPLIED" ) ; out . println ( "          description CDATA #IMPLIED>" ) ; out . println ( "" ) ; } private void printElementDecl ( PrintWriter out , String name , Class element ) throws BuildException { if ( visited . containsKey ( name ) ) { return ; } visited . put ( name , "" ) ; IntrospectionHelper ih = null ; try { ih = IntrospectionHelper . getHelper ( element ) ; } catch ( Throwable t ) { return ; } StringBuffer sb = new StringBuffer ( "<!ELEMENT " ) ; sb . append ( name ) . append ( " " ) ; if ( org . apache . tools . ant . types . Reference . class . equals ( element ) ) { sb . append ( "EMPTY>" ) . append ( lSep ) ; sb . append ( "<!ATTLIST " ) . append ( name ) ; sb . append ( lSep ) . append ( "          id ID #IMPLIED" ) ; sb . append ( lSep ) . append ( "          refid IDREF #IMPLIED" ) ; sb . append ( ">" ) . append ( lSep ) ; out . println ( sb ) ; return ; } Vector v = new Vector ( ) ; if ( ih . supportsCharacters ( ) ) { v . addElement ( "#PCDATA" ) ; } if ( TaskContainer . class . isAssignableFrom ( element ) ) { v . addElement ( TASKS ) ; } Enumeration e = ih . getNestedElements ( ) ; while ( e . hasMoreElements ( ) ) { v . addElement ( e . nextElement ( ) ) ; } if ( v . isEmpty ( ) ) { sb . append ( "EMPTY" ) ; } else { sb . append ( "(" ) ; final int count = v . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { if ( i != 0 ) { sb . append ( " | " ) ; } sb . append ( v . elementAt ( i ) ) ; } sb . append ( ")" ) ; if ( count > 1 || ! v . elementAt ( 0 ) . equals ( "#PCDATA" ) ) { sb . append ( "*" ) ; } } sb . append ( ">" ) ; out . println ( sb ) ; sb = new StringBuffer ( "<!ATTLIST " ) ; sb . append ( name ) ; sb . append ( lSep ) . append ( "          id ID #IMPLIED" ) ; e = ih . getAttributes ( ) ; while ( e . hasMoreElements ( ) ) { String attrName = ( String ) e . nextElement ( ) ; if ( "id" . equals ( attrName ) ) { continue ; } sb . append ( lSep ) . append ( "          " ) . append ( attrName ) . append ( " " ) ; Class type = ih . getAttributeType ( attrName ) ; if ( type . equals ( java . lang . Boolean . class ) || type . equals ( java . lang . Boolean . TYPE ) ) { sb . append ( BOOLEAN ) . append ( " " ) ; } else if ( Reference . class . isAssignableFrom ( type ) ) { sb . append ( "IDREF " ) ; } else if ( EnumeratedAttribute . class . isAssignableFrom ( type ) ) { try { EnumeratedAttribute ea = ( EnumeratedAttribute ) type . newInstance ( ) ; String [ ] values = ea . getValues ( ) ; if ( values == null || values . length == 0 || ! areNmtokens ( values ) ) { sb . append ( "CDATA " ) ; } else { sb . append ( "(" ) ; for ( int i = 0 ; i < values . length ; i ++ ) { if ( i != 0 ) { sb . append ( " | " ) ; } sb . append ( values [ i ] ) ; } sb . append ( ") " ) ; } } catch ( InstantiationException ie ) { sb . append ( "CDATA " ) ; } catch ( IllegalAccessException ie ) { sb . append ( "CDATA " ) ; } } else { sb . append ( "CDATA " ) ; } sb . append ( "#IMPLIED" ) ; } sb . append ( ">" ) . append ( lSep ) ; out . println ( sb ) ; final int count = v . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { String nestedName = ( String ) v . elementAt ( i ) ; if ( ! "#PCDATA" . equals ( nestedName ) && ! TASKS . equals ( nestedName ) && ! TYPES . equals ( nestedName ) ) { printElementDecl ( out , nestedName , ih . getElementType ( nestedName ) ) ; } } } protected boolean isNmtoken ( String s ) { final int length = s . length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { char c = s . charAt ( i ) ; if ( ! Character . isLetterOrDigit ( c ) && c != '.' && c != '-' && c != '_' && c != ':' ) { return false ; } } return true ; } protected boolean areNmtokens ( String [ ] s ) { for ( int i = 0 ; i < s . length ; i ++ ) { if ( ! isNmtoken ( s [ i ] ) ) { return false ; } } return true ; } } 	1	['9', '3', '0', '7', '61', '28', '0', '7', '3', '0.925', '749', '0.6', '0', '0.822222222', '0.285714286', '0', '0', '81.11111111', '7', '2.2222', '1']
