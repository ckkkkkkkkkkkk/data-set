package org . apache . tools . ant . taskdefs ; import java . util . HashMap ; import java . util . Map ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . taskdefs . condition . ConditionBase ; import org . apache . tools . ant . types . EnumeratedAttribute ; public class WaitFor extends ConditionBase { private long maxWaitMillis = 1000L * 60L * 3L ; private long maxWaitMultiplier = 1L ; private long checkEveryMillis = 500L ; private long checkEveryMultiplier = 1L ; private String timeoutProperty ; public WaitFor ( ) { super ( "waitfor" ) ; } public void setMaxWait ( long time ) { maxWaitMillis = time ; } public void setMaxWaitUnit ( Unit unit ) { maxWaitMultiplier = unit . getMultiplier ( ) ; } public void setCheckEvery ( long time ) { checkEveryMillis = time ; } public void setCheckEveryUnit ( Unit unit ) { checkEveryMultiplier = unit . getMultiplier ( ) ; } public void setTimeoutProperty ( String p ) { timeoutProperty = p ; } public void execute ( ) throws BuildException { if ( countConditions ( ) > 1 ) { throw new BuildException ( "You must not nest more than one " + "condition into " + getTaskName ( ) ) ; } if ( countConditions ( ) < 1 ) { throw new BuildException ( "You must nest a condition into " + getTaskName ( ) ) ; } Condition c = ( Condition ) getConditions ( ) . nextElement ( ) ; long savedMaxWaitMillis = maxWaitMillis ; long savedCheckEveryMillis = checkEveryMillis ; try { maxWaitMillis *= maxWaitMultiplier ; checkEveryMillis *= checkEveryMultiplier ; long start = System . currentTimeMillis ( ) ; long end = start + maxWaitMillis ; while ( System . currentTimeMillis ( ) < end ) { if ( c . eval ( ) ) { processSuccess ( ) ; return ; } try { Thread . sleep ( checkEveryMillis ) ; } catch ( InterruptedException e ) { } } processTimeout ( ) ; } finally { maxWaitMillis = savedMaxWaitMillis ; checkEveryMillis = savedCheckEveryMillis ; } } protected void processSuccess ( ) { log ( getTaskName ( ) + ": condition was met" , Project . MSG_VERBOSE ) ; } protected void processTimeout ( ) { log ( getTaskName ( ) + ": timeout" , Project . MSG_VERBOSE ) ; if ( timeoutProperty != null ) { getProject ( ) . setNewProperty ( timeoutProperty , "true" ) ; } } public static class Unit extends EnumeratedAttribute { public static final String MILLISECOND = "millisecond" ; public static final String SECOND = "second" ; public static final String MINUTE = "minute" ; public static final String HOUR = "hour" ; public static final String DAY = "day" ; public static final String WEEK = "week" ; private static final String [ ] UNITS = { MILLISECOND , SECOND , MINUTE , HOUR , DAY , WEEK } ; private Map timeTable = new HashMap ( ) ; public Unit ( ) { timeTable . put ( MILLISECOND , new Long ( 1L ) ) ; timeTable . put ( SECOND , new Long ( 1000L ) ) ; timeTable . put ( MINUTE , new Long ( 1000L * 60L ) ) ; timeTable . put ( HOUR , new Long ( 1000L * 60L * 60L ) ) ; timeTable . put ( DAY , new Long ( 1000L * 60L * 60L * 24L ) ) ; timeTable . put ( WEEK , new Long ( 1000L * 60L * 60L * 24L * 7L ) ) ; } public long getMultiplier ( ) { String key = getValue ( ) . toLowerCase ( ) ; Long l = ( Long ) timeTable . get ( key ) ; return l . longValue ( ) ; } public String [ ] getValues ( ) { return UNITS ; } } } 	1	['9', '3', '0', '5', '26', '16', '0', '5', '7', '0.75', '185', '1', '0', '0.8', '0.388888889', '0', '0', '19', '2', '1', '1']
package org . apache . tools . zip ; import java . util . zip . CRC32 ; import java . util . zip . ZipException ; public class AsiExtraField implements ZipExtraField , UnixStat , Cloneable { private static final ZipShort HEADER_ID = new ZipShort ( 0x756E ) ; private int mode = 0 ; private int uid = 0 ; private int gid = 0 ; private String link = "" ; private boolean dirFlag = false ; private CRC32 crc = new CRC32 ( ) ; public AsiExtraField ( ) { } public ZipShort getHeaderId ( ) { return HEADER_ID ; } public ZipShort getLocalFileDataLength ( ) { return new ZipShort ( 4 + 2 + 4 + 2 + 2 + getLinkedFile ( ) . getBytes ( ) . length ) ; } public ZipShort getCentralDirectoryLength ( ) { return getLocalFileDataLength ( ) ; } public byte [ ] getLocalFileDataData ( ) { byte [ ] data = new byte [ getLocalFileDataLength ( ) . getValue ( ) - 4 ] ; System . arraycopy ( ZipShort . getBytes ( getMode ( ) ) , 0 , data , 0 , 2 ) ; byte [ ] linkArray = getLinkedFile ( ) . getBytes ( ) ; System . arraycopy ( ZipLong . getBytes ( linkArray . length ) , 0 , data , 2 , 4 ) ; System . arraycopy ( ZipShort . getBytes ( getUserId ( ) ) , 0 , data , 6 , 2 ) ; System . arraycopy ( ZipShort . getBytes ( getGroupId ( ) ) , 0 , data , 8 , 2 ) ; System . arraycopy ( linkArray , 0 , data , 10 , linkArray . length ) ; crc . reset ( ) ; crc . update ( data ) ; long checksum = crc . getValue ( ) ; byte [ ] result = new byte [ data . length + 4 ] ; System . arraycopy ( ZipLong . getBytes ( checksum ) , 0 , result , 0 , 4 ) ; System . arraycopy ( data , 0 , result , 4 , data . length ) ; return result ; } public byte [ ] getCentralDirectoryData ( ) { return getLocalFileDataData ( ) ; } public void setUserId ( int uid ) { this . uid = uid ; } public int getUserId ( ) { return uid ; } public void setGroupId ( int gid ) { this . gid = gid ; } public int getGroupId ( ) { return gid ; } public void setLinkedFile ( String name ) { link = name ; mode = getMode ( mode ) ; } public String getLinkedFile ( ) { return link ; } public boolean isLink ( ) { return getLinkedFile ( ) . length ( ) != 0 ; } public void setMode ( int mode ) { this . mode = getMode ( mode ) ; } public int getMode ( ) { return mode ; } public void setDirectory ( boolean dirFlag ) { this . dirFlag = dirFlag ; mode = getMode ( mode ) ; } public boolean isDirectory ( ) { return dirFlag && ! isLink ( ) ; } public void parseFromLocalFileData ( byte [ ] data , int offset , int length ) throws ZipException { long givenChecksum = ZipLong . getValue ( data , offset ) ; byte [ ] tmp = new byte [ length - 4 ] ; System . arraycopy ( data , offset + 4 , tmp , 0 , length - 4 ) ; crc . reset ( ) ; crc . update ( tmp ) ; long realChecksum = crc . getValue ( ) ; if ( givenChecksum != realChecksum ) { throw new ZipException ( "bad CRC checksum " + Long . toHexString ( givenChecksum ) + " instead of " + Long . toHexString ( realChecksum ) ) ; } int newMode = ZipShort . getValue ( tmp , 0 ) ; byte [ ] linkArray = new byte [ ( int ) ZipLong . getValue ( tmp , 2 ) ] ; uid = ZipShort . getValue ( tmp , 6 ) ; gid = ZipShort . getValue ( tmp , 8 ) ; if ( linkArray . length == 0 ) { link = "" ; } else { System . arraycopy ( tmp , 10 , linkArray , 0 , linkArray . length ) ; link = new String ( linkArray ) ; } setDirectory ( ( newMode & DIR_FLAG ) != 0 ) ; setMode ( newMode ) ; } protected int getMode ( int mode ) { int type = FILE_FLAG ; if ( isLink ( ) ) { type = LINK_FLAG ; } else if ( isDirectory ( ) ) { type = DIR_FLAG ; } return type | ( mode & PERM_MASK ) ; } } 	1	['20', '1', '0', '4', '40', '130', '0', '4', '18', '0.736842105', '345', '1', '1', '0', '0.284210526', '0', '0', '15.9', '3', '1.15', '1']
package org . apache . tools . ant . types . resources . comparators ; import java . io . File ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . util . FileUtils ; public class FileSystem extends ResourceComparator { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; protected int resourceCompare ( Resource foo , Resource bar ) { File foofile = ( ( FileResource ) foo ) . getFile ( ) ; File barfile = ( ( FileResource ) bar ) . getFile ( ) ; return foofile . equals ( barfile ) ? 0 : FILE_UTILS . isLeadingPath ( foofile , barfile ) ? - 1 : FILE_UTILS . normalize ( foofile . getAbsolutePath ( ) ) . compareTo ( FILE_UTILS . normalize ( barfile . getAbsolutePath ( ) ) ) ; } } 	1	['3', '4', '0', '5', '11', '1', '1', '4', '1', '0.5', '41', '1', '1', '0.971428571', '0.75', '1', '2', '12.33333333', '3', '1', '1']
package org . apache . tools . ant . taskdefs . optional ; import java . io . BufferedOutputStream ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . PrintStream ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . ExecuteStreamHandler ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . taskdefs . LogStreamHandler ; import org . apache . tools . ant . taskdefs . PumpStreamHandler ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class Rpm extends Task { private static final String PATH1 = "PATH=" ; private static final String PATH2 = "Path=" ; private static final String PATH3 = "path=" ; private static final int PATH_LEN = PATH1 . length ( ) ; private String specFile ; private File topDir ; private String command = "-bb" ; private String rpmBuildCommand = null ; private boolean cleanBuildDir = false ; private boolean removeSpec = false ; private boolean removeSource = false ; private File output ; private File error ; private boolean failOnError = false ; private boolean quiet = false ; public void execute ( ) throws BuildException { Commandline toExecute = new Commandline ( ) ; toExecute . setExecutable ( rpmBuildCommand == null ? guessRpmBuildCommand ( ) : rpmBuildCommand ) ; if ( topDir != null ) { toExecute . createArgument ( ) . setValue ( "--define" ) ; toExecute . createArgument ( ) . setValue ( "_topdir" + topDir ) ; } toExecute . createArgument ( ) . setLine ( command ) ; if ( cleanBuildDir ) { toExecute . createArgument ( ) . setValue ( "--clean" ) ; } if ( removeSpec ) { toExecute . createArgument ( ) . setValue ( "--rmspec" ) ; } if ( removeSource ) { toExecute . createArgument ( ) . setValue ( "--rmsource" ) ; } toExecute . createArgument ( ) . setValue ( "SPECS/" + specFile ) ; ExecuteStreamHandler streamhandler = null ; OutputStream outputstream = null ; OutputStream errorstream = null ; if ( error == null && output == null ) { if ( ! quiet ) { streamhandler = new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) ; } else { streamhandler = new LogStreamHandler ( this , Project . MSG_DEBUG , Project . MSG_DEBUG ) ; } } else { if ( output != null ) { try { BufferedOutputStream bos = new BufferedOutputStream ( new FileOutputStream ( output ) ) ; outputstream = new PrintStream ( bos ) ; } catch ( IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } else if ( ! quiet ) { outputstream = new LogOutputStream ( this , Project . MSG_INFO ) ; } else { outputstream = new LogOutputStream ( this , Project . MSG_DEBUG ) ; } if ( error != null ) { try { BufferedOutputStream bos = new BufferedOutputStream ( new FileOutputStream ( error ) ) ; errorstream = new PrintStream ( bos ) ; } catch ( IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } else if ( ! quiet ) { errorstream = new LogOutputStream ( this , Project . MSG_WARN ) ; } else { errorstream = new LogOutputStream ( this , Project . MSG_DEBUG ) ; } streamhandler = new PumpStreamHandler ( outputstream , errorstream ) ; } Execute exe = getExecute ( toExecute , streamhandler ) ; try { log ( "Building the RPM based on the " + specFile + " file" ) ; int returncode = exe . execute ( ) ; if ( Execute . isFailure ( returncode ) ) { String msg = "'" + toExecute . getExecutable ( ) + "' failed with exit code " + returncode ; if ( failOnError ) { throw new BuildException ( msg ) ; } else { log ( msg , Project . MSG_ERR ) ; } } } catch ( IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } finally { FileUtils . close ( outputstream ) ; FileUtils . close ( errorstream ) ; } } public void setTopDir ( File td ) { this . topDir = td ; } public void setCommand ( String c ) { this . command = c ; } public void setSpecFile ( String sf ) { if ( ( sf == null ) || ( sf . trim ( ) . equals ( "" ) ) ) { throw new BuildException ( "You must specify a spec file" , getLocation ( ) ) ; } this . specFile = sf ; } public void setCleanBuildDir ( boolean cbd ) { cleanBuildDir = cbd ; } public void setRemoveSpec ( boolean rs ) { removeSpec = rs ; } public void setRemoveSource ( boolean rs ) { removeSource = rs ; } public void setOutput ( File output ) { this . output = output ; } public void setError ( File error ) { this . error = error ; } public void setRpmBuildCommand ( String c ) { this . rpmBuildCommand = c ; } public void setFailOnError ( boolean value ) { failOnError = value ; } public void setQuiet ( boolean value ) { quiet = value ; } protected String guessRpmBuildCommand ( ) { Vector env = Execute . getProcEnvironment ( ) ; String path = null ; for ( Enumeration e = env . elements ( ) ; e . hasMoreElements ( ) ; ) { String var = ( String ) e . nextElement ( ) ; if ( var . startsWith ( PATH1 ) || var . startsWith ( PATH2 ) || var . startsWith ( PATH3 ) ) { path = var . substring ( PATH_LEN ) ; break ; } } if ( path != null ) { Path p = new Path ( getProject ( ) , path ) ; String [ ] pElements = p . list ( ) ; for ( int i = 0 ; i < pElements . length ; i ++ ) { File f = new File ( pElements [ i ] , "rpmbuild" + ( Os . isFamily ( "dos" ) ? ".exe" : "" ) ) ; if ( f . canRead ( ) ) { return f . getAbsolutePath ( ) ; } } } return "rpm" ; } protected Execute getExecute ( Commandline toExecute , ExecuteStreamHandler streamhandler ) { Execute exe = new Execute ( streamhandler , null ) ; exe . setAntRun ( getProject ( ) ) ; if ( topDir == null ) { topDir = getProject ( ) . getBaseDir ( ) ; } exe . setWorkingDirectory ( topDir ) ; exe . setCommandline ( toExecute . getCommandline ( ) ) ; return exe ; } } 	1	['16', '3', '0', '15', '65', '76', '0', '15', '13', '0.92', '483', '1', '0', '0.725490196', '0.311111111', '0', '0', '28.25', '9', '1.5625', '1']
package org . apache . tools . zip ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FilterOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . RandomAccessFile ; import java . io . UnsupportedEncodingException ; import java . util . Date ; import java . util . Hashtable ; import java . util . Vector ; import java . util . zip . CRC32 ; import java . util . zip . Deflater ; import java . util . zip . ZipException ; public class ZipOutputStream extends FilterOutputStream { public static final int DEFLATED = java . util . zip . ZipEntry . DEFLATED ; public static final int DEFAULT_COMPRESSION = Deflater . DEFAULT_COMPRESSION ; public static final int STORED = java . util . zip . ZipEntry . STORED ; private ZipEntry entry ; private String comment = "" ; private int level = DEFAULT_COMPRESSION ; private boolean hasCompressionLevelChanged = false ; private int method = java . util . zip . ZipEntry . DEFLATED ; private Vector entries = new Vector ( ) ; private CRC32 crc = new CRC32 ( ) ; private long written = 0 ; private long dataStart = 0 ; private long localDataStart = 0 ; private long cdOffset = 0 ; private long cdLength = 0 ; private static final byte [ ] ZERO = { 0 , 0 } ; private static final byte [ ] LZERO = { 0 , 0 , 0 , 0 } ; private Hashtable offsets = new Hashtable ( ) ; private String encoding = null ; protected Deflater def = new Deflater ( level , true ) ; protected byte [ ] buf = new byte [ 512 ] ; private RandomAccessFile raf = null ; public ZipOutputStream ( OutputStream out ) { super ( out ) ; } public ZipOutputStream ( File file ) throws IOException { super ( null ) ; try { raf = new RandomAccessFile ( file , "rw" ) ; raf . setLength ( 0 ) ; } catch ( IOException e ) { if ( raf != null ) { try { raf . close ( ) ; } catch ( IOException inner ) { } raf = null ; } out = new FileOutputStream ( file ) ; } } public boolean isSeekable ( ) { return raf != null ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String getEncoding ( ) { return encoding ; } public void finish ( ) throws IOException { closeEntry ( ) ; cdOffset = written ; for ( int i = 0 , entriesSize = entries . size ( ) ; i < entriesSize ; i ++ ) { writeCentralFileHeader ( ( ZipEntry ) entries . elementAt ( i ) ) ; } cdLength = written - cdOffset ; writeCentralDirectoryEnd ( ) ; offsets . clear ( ) ; entries . removeAllElements ( ) ; } public void closeEntry ( ) throws IOException { if ( entry == null ) { return ; } long realCrc = crc . getValue ( ) ; crc . reset ( ) ; if ( entry . getMethod ( ) == DEFLATED ) { def . finish ( ) ; while ( ! def . finished ( ) ) { deflate ( ) ; } entry . setSize ( adjustToLong ( def . getTotalIn ( ) ) ) ; entry . setCompressedSize ( adjustToLong ( def . getTotalOut ( ) ) ) ; entry . setCrc ( realCrc ) ; def . reset ( ) ; written += entry . getCompressedSize ( ) ; } else if ( raf == null ) { if ( entry . getCrc ( ) != realCrc ) { throw new ZipException ( "bad CRC checksum for entry " + entry . getName ( ) + ": " + Long . toHexString ( entry . getCrc ( ) ) + " instead of " + Long . toHexString ( realCrc ) ) ; } if ( entry . getSize ( ) != written - dataStart ) { throw new ZipException ( "bad size for entry " + entry . getName ( ) + ": " + entry . getSize ( ) + " instead of " + ( written - dataStart ) ) ; } } else { long size = written - dataStart ; entry . setSize ( size ) ; entry . setCompressedSize ( size ) ; entry . setCrc ( realCrc ) ; } if ( raf != null ) { long save = raf . getFilePointer ( ) ; raf . seek ( localDataStart ) ; writeOut ( ZipLong . getBytes ( entry . getCrc ( ) ) ) ; writeOut ( ZipLong . getBytes ( entry . getCompressedSize ( ) ) ) ; writeOut ( ZipLong . getBytes ( entry . getSize ( ) ) ) ; raf . seek ( save ) ; } writeDataDescriptor ( entry ) ; entry = null ; } public void putNextEntry ( ZipEntry ze ) throws IOException { closeEntry ( ) ; entry = ze ; entries . addElement ( entry ) ; if ( entry . getMethod ( ) == - 1 ) { entry . setMethod ( method ) ; } if ( entry . getTime ( ) == - 1 ) { entry . setTime ( System . currentTimeMillis ( ) ) ; } if ( entry . getMethod ( ) == STORED && raf == null ) { if ( entry . getSize ( ) == - 1 ) { throw new ZipException ( "uncompressed size is required for" + " STORED method when not writing to a" + " file" ) ; } if ( entry . getCrc ( ) == - 1 ) { throw new ZipException ( "crc checksum is required for STORED" + " method when not writing to a file" ) ; } entry . setCompressedSize ( entry . getSize ( ) ) ; } if ( entry . getMethod ( ) == DEFLATED && hasCompressionLevelChanged ) { def . setLevel ( level ) ; hasCompressionLevelChanged = false ; } writeLocalFileHeader ( entry ) ; } public void setComment ( String comment ) { this . comment = comment ; } public void setLevel ( int level ) { if ( level < Deflater . DEFAULT_COMPRESSION || level > Deflater . BEST_COMPRESSION ) { throw new IllegalArgumentException ( "Invalid compression level: " + level ) ; } hasCompressionLevelChanged = ( this . level != level ) ; this . level = level ; } public void setMethod ( int method ) { this . method = method ; } public void write ( byte [ ] b , int offset , int length ) throws IOException { if ( entry . getMethod ( ) == DEFLATED ) { if ( length > 0 ) { if ( ! def . finished ( ) ) { def . setInput ( b , offset , length ) ; while ( ! def . needsInput ( ) ) { deflate ( ) ; } } } } else { writeOut ( b , offset , length ) ; written += length ; } crc . update ( b , offset , length ) ; } public void write ( int b ) throws IOException { byte [ ] buff = new byte [ 1 ] ; buff [ 0 ] = ( byte ) ( b & 0xff ) ; write ( buff , 0 , 1 ) ; } public void close ( ) throws IOException { finish ( ) ; if ( raf != null ) { raf . close ( ) ; } if ( out != null ) { out . close ( ) ; } } public void flush ( ) throws IOException { if ( out != null ) { out . flush ( ) ; } } protected static final byte [ ] LFH_SIG = ZipLong . getBytes ( 0X04034B50L ) ; protected static final byte [ ] DD_SIG = ZipLong . getBytes ( 0X08074B50L ) ; protected static final byte [ ] CFH_SIG = ZipLong . getBytes ( 0X02014B50L ) ; protected static final byte [ ] EOCD_SIG = ZipLong . getBytes ( 0X06054B50L ) ; protected final void deflate ( ) throws IOException { int len = def . deflate ( buf , 0 , buf . length ) ; if ( len > 0 ) { writeOut ( buf , 0 , len ) ; } } protected void writeLocalFileHeader ( ZipEntry ze ) throws IOException { offsets . put ( ze , ZipLong . getBytes ( written ) ) ; writeOut ( LFH_SIG ) ; written += 4 ; final int zipMethod = ze . getMethod ( ) ; if ( zipMethod == DEFLATED && raf == null ) { writeOut ( ZipShort . getBytes ( 20 ) ) ; writeOut ( ZipShort . getBytes ( 8 ) ) ; } else { writeOut ( ZipShort . getBytes ( 10 ) ) ; writeOut ( ZERO ) ; } written += 4 ; writeOut ( ZipShort . getBytes ( zipMethod ) ) ; written += 2 ; writeOut ( toDosTime ( ze . getTime ( ) ) ) ; written += 4 ; localDataStart = written ; if ( zipMethod == DEFLATED || raf != null ) { writeOut ( LZERO ) ; writeOut ( LZERO ) ; writeOut ( LZERO ) ; } else { writeOut ( ZipLong . getBytes ( ze . getCrc ( ) ) ) ; writeOut ( ZipLong . getBytes ( ze . getSize ( ) ) ) ; writeOut ( ZipLong . getBytes ( ze . getSize ( ) ) ) ; } written += 12 ; byte [ ] name = getBytes ( ze . getName ( ) ) ; writeOut ( ZipShort . getBytes ( name . length ) ) ; written += 2 ; byte [ ] extra = ze . getLocalFileDataExtra ( ) ; writeOut ( ZipShort . getBytes ( extra . length ) ) ; written += 2 ; writeOut ( name ) ; written += name . length ; writeOut ( extra ) ; written += extra . length ; dataStart = written ; } protected void writeDataDescriptor ( ZipEntry ze ) throws IOException { if ( ze . getMethod ( ) != DEFLATED || raf != null ) { return ; } writeOut ( DD_SIG ) ; writeOut ( ZipLong . getBytes ( entry . getCrc ( ) ) ) ; writeOut ( ZipLong . getBytes ( entry . getCompressedSize ( ) ) ) ; writeOut ( ZipLong . getBytes ( entry . getSize ( ) ) ) ; written += 16 ; } protected void writeCentralFileHeader ( ZipEntry ze ) throws IOException { writeOut ( CFH_SIG ) ; written += 4 ; writeOut ( ZipShort . getBytes ( ( ze . getPlatform ( ) << 8 ) | 20 ) ) ; written += 2 ; if ( ze . getMethod ( ) == DEFLATED && raf == null ) { writeOut ( ZipShort . getBytes ( 20 ) ) ; writeOut ( ZipShort . getBytes ( 8 ) ) ; } else { writeOut ( ZipShort . getBytes ( 10 ) ) ; writeOut ( ZERO ) ; } written += 4 ; writeOut ( ZipShort . getBytes ( ze . getMethod ( ) ) ) ; written += 2 ; writeOut ( toDosTime ( ze . getTime ( ) ) ) ; written += 4 ; writeOut ( ZipLong . getBytes ( ze . getCrc ( ) ) ) ; writeOut ( ZipLong . getBytes ( ze . getCompressedSize ( ) ) ) ; writeOut ( ZipLong . getBytes ( ze . getSize ( ) ) ) ; written += 12 ; byte [ ] name = getBytes ( ze . getName ( ) ) ; writeOut ( ZipShort . getBytes ( name . length ) ) ; written += 2 ; byte [ ] extra = ze . getCentralDirectoryExtra ( ) ; writeOut ( ZipShort . getBytes ( extra . length ) ) ; written += 2 ; String comm = ze . getComment ( ) ; if ( comm == null ) { comm = "" ; } byte [ ] commentB = getBytes ( comm ) ; writeOut ( ZipShort . getBytes ( commentB . length ) ) ; written += 2 ; writeOut ( ZERO ) ; written += 2 ; writeOut ( ZipShort . getBytes ( ze . getInternalAttributes ( ) ) ) ; written += 2 ; writeOut ( ZipLong . getBytes ( ze . getExternalAttributes ( ) ) ) ; written += 4 ; writeOut ( ( byte [ ] ) offsets . get ( ze ) ) ; written += 4 ; writeOut ( name ) ; written += name . length ; writeOut ( extra ) ; written += extra . length ; writeOut ( commentB ) ; written += commentB . length ; } protected void writeCentralDirectoryEnd ( ) throws IOException { writeOut ( EOCD_SIG ) ; writeOut ( ZERO ) ; writeOut ( ZERO ) ; byte [ ] num = ZipShort . getBytes ( entries . size ( ) ) ; writeOut ( num ) ; writeOut ( num ) ; writeOut ( ZipLong . getBytes ( cdLength ) ) ; writeOut ( ZipLong . getBytes ( cdOffset ) ) ; byte [ ] data = getBytes ( comment ) ; writeOut ( ZipShort . getBytes ( data . length ) ) ; writeOut ( data ) ; } private static final byte [ ] DOS_TIME_MIN = ZipLong . getBytes ( 0x00002100L ) ; protected static ZipLong toDosTime ( Date time ) { return new ZipLong ( toDosTime ( time . getTime ( ) ) ) ; } protected static byte [ ] toDosTime ( long t ) { Date time = new Date ( t ) ; int year = time . getYear ( ) + 1900 ; if ( year < 1980 ) { return DOS_TIME_MIN ; } int month = time . getMonth ( ) + 1 ; long value = ( ( year - 1980 ) << 25 ) | ( month << 21 ) | ( time . getDate ( ) << 16 ) | ( time . getHours ( ) << 11 ) | ( time . getMinutes ( ) << 5 ) | ( time . getSeconds ( ) > > 1 ) ; return ZipLong . getBytes ( value ) ; } protected byte [ ] getBytes ( String name ) throws ZipException { if ( encoding == null ) { return name . getBytes ( ) ; } else { try { return name . getBytes ( encoding ) ; } catch ( UnsupportedEncodingException uee ) { throw new ZipException ( uee . getMessage ( ) ) ; } } } protected final void writeOut ( byte [ ] data ) throws IOException { writeOut ( data , 0 , data . length ) ; } protected final void writeOut ( byte [ ] data , int offset , int length ) throws IOException { if ( raf != null ) { raf . write ( data , offset , length ) ; } else { out . write ( data , offset , length ) ; } } protected static long adjustToLong ( int i ) { if ( i < 0 ) { return 2 * ( ( long ) Integer . MAX_VALUE ) + 2 + i ; } else { return i ; } } } 	1	['27', '3', '0', '8', '101', '157', '5', '3', '15', '0.824786325', '1286', '0.888888889', '1', '0.294117647', '0.183760684', '1', '7', '45.62962963', '4', '1.1111', '1']
package org . apache . tools . ant ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; import java . util . Vector ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceFactory ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . selectors . FileSelector ; import org . apache . tools . ant . types . selectors . SelectorScanner ; import org . apache . tools . ant . types . selectors . SelectorUtils ; import org . apache . tools . ant . util . FileUtils ; public class DirectoryScanner implements FileScanner , SelectorScanner , ResourceFactory { private static final boolean ON_VMS = Os . isFamily ( "openvms" ) ; protected static final String [ ] DEFAULTEXCLUDES = { "**/*~" , "**/#*#" , "**/.#*" , "**/%*%" , "**/._*" , "**/CVS" , "**/CVS/**" , "**/.cvsignore" , "**/SCCS" , "**/SCCS/**" , "**/vssver.scc" , "**/.svn" , "**/.svn/**" , "**/.DS_Store" } ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private static final boolean [ ] CS_SCAN_ONLY = new boolean [ ] { true } ; private static final boolean [ ] CS_THEN_NON_CS = new boolean [ ] { true , false } ; private static Vector defaultExcludes = new Vector ( ) ; static { resetDefaultExcludes ( ) ; } protected File basedir ; protected String [ ] includes ; protected String [ ] excludes ; protected FileSelector [ ] selectors = null ; protected Vector filesIncluded ; protected Vector filesNotIncluded ; protected Vector filesExcluded ; protected Vector dirsIncluded ; protected Vector dirsNotIncluded ; protected Vector dirsExcluded ; protected Vector filesDeselected ; protected Vector dirsDeselected ; protected boolean haveSlowResults = false ; protected boolean isCaseSensitive = true ; private boolean followSymlinks = true ; protected boolean everythingIncluded = true ; private Map fileListMap = new HashMap ( ) ; private Set scannedDirs = new HashSet ( ) ; private Set includeNonPatterns = new HashSet ( ) ; private Set excludeNonPatterns = new HashSet ( ) ; private String [ ] includePatterns ; private String [ ] excludePatterns ; private boolean areNonPatternSetsReady = false ; private boolean scanning = false ; private Object scanLock = new Object ( ) ; private boolean slowScanning = false ; private Object slowScanLock = new Object ( ) ; private IllegalStateException illegal = null ; public DirectoryScanner ( ) { } protected static boolean matchPatternStart ( String pattern , String str ) { return SelectorUtils . matchPatternStart ( pattern , str ) ; } protected static boolean matchPatternStart ( String pattern , String str , boolean isCaseSensitive ) { return SelectorUtils . matchPatternStart ( pattern , str , isCaseSensitive ) ; } protected static boolean matchPath ( String pattern , String str ) { return SelectorUtils . matchPath ( pattern , str ) ; } protected static boolean matchPath ( String pattern , String str , boolean isCaseSensitive ) { return SelectorUtils . matchPath ( pattern , str , isCaseSensitive ) ; } public static boolean match ( String pattern , String str ) { return SelectorUtils . match ( pattern , str ) ; } protected static boolean match ( String pattern , String str , boolean isCaseSensitive ) { return SelectorUtils . match ( pattern , str , isCaseSensitive ) ; } public static String [ ] getDefaultExcludes ( ) { return ( String [ ] ) defaultExcludes . toArray ( new String [ defaultExcludes . size ( ) ] ) ; } public static boolean addDefaultExclude ( String s ) { if ( defaultExcludes . indexOf ( s ) == - 1 ) { defaultExcludes . add ( s ) ; return true ; } return false ; } public static boolean removeDefaultExclude ( String s ) { return defaultExcludes . remove ( s ) ; } public static void resetDefaultExcludes ( ) { defaultExcludes = new Vector ( ) ; for ( int i = 0 ; i < DEFAULTEXCLUDES . length ; i ++ ) { defaultExcludes . add ( DEFAULTEXCLUDES [ i ] ) ; } } public void setBasedir ( String basedir ) { setBasedir ( basedir == null ? ( File ) null : new File ( basedir . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ) ) ; } public synchronized void setBasedir ( File basedir ) { this . basedir = basedir ; } public synchronized File getBasedir ( ) { return basedir ; } public synchronized boolean isCaseSensitive ( ) { return isCaseSensitive ; } public synchronized void setCaseSensitive ( boolean isCaseSensitive ) { this . isCaseSensitive = isCaseSensitive ; } public synchronized boolean isFollowSymlinks ( ) { return followSymlinks ; } public synchronized void setFollowSymlinks ( boolean followSymlinks ) { this . followSymlinks = followSymlinks ; } public synchronized void setIncludes ( String [ ] includes ) { if ( includes == null ) { this . includes = null ; } else { this . includes = new String [ includes . length ] ; for ( int i = 0 ; i < includes . length ; i ++ ) { this . includes [ i ] = normalizePattern ( includes [ i ] ) ; } } } public synchronized void setExcludes ( String [ ] excludes ) { if ( excludes == null ) { this . excludes = null ; } else { this . excludes = new String [ excludes . length ] ; for ( int i = 0 ; i < excludes . length ; i ++ ) { this . excludes [ i ] = normalizePattern ( excludes [ i ] ) ; } } } public synchronized void addExcludes ( String [ ] excludes ) { if ( excludes != null && excludes . length > 0 ) { if ( this . excludes != null && this . excludes . length > 0 ) { String [ ] tmp = new String [ excludes . length + this . excludes . length ] ; System . arraycopy ( this . excludes , 0 , tmp , 0 , this . excludes . length ) ; for ( int i = 0 ; i < excludes . length ; i ++ ) { tmp [ this . excludes . length + i ] = normalizePattern ( excludes [ i ] ) ; } this . excludes = tmp ; } else { setExcludes ( excludes ) ; } } } private static String normalizePattern ( String p ) { String pattern = p . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( pattern . endsWith ( File . separator ) ) { pattern += "**" ; } return pattern ; } public synchronized void setSelectors ( FileSelector [ ] selectors ) { this . selectors = selectors ; } public synchronized boolean isEverythingIncluded ( ) { return everythingIncluded ; } public void scan ( ) throws IllegalStateException { synchronized ( scanLock ) { if ( scanning ) { while ( scanning ) { try { scanLock . wait ( ) ; } catch ( InterruptedException e ) { continue ; } } if ( illegal != null ) { throw illegal ; } return ; } scanning = true ; } try { synchronized ( this ) { illegal = null ; clearResults ( ) ; boolean nullIncludes = ( includes == null ) ; includes = nullIncludes ? new String [ ] { "**" } : includes ; boolean nullExcludes = ( excludes == null ) ; excludes = nullExcludes ? new String [ 0 ] : excludes ; if ( basedir == null ) { if ( nullIncludes ) { return ; } } else { if ( ! basedir . exists ( ) ) { illegal = new IllegalStateException ( "basedir " + basedir + " does not exist" ) ; } if ( ! basedir . isDirectory ( ) ) { illegal = new IllegalStateException ( "basedir " + basedir + " is not a directory" ) ; } if ( illegal != null ) { throw illegal ; } } if ( isIncluded ( "" ) ) { if ( ! isExcluded ( "" ) ) { if ( isSelected ( "" , basedir ) ) { dirsIncluded . addElement ( "" ) ; } else { dirsDeselected . addElement ( "" ) ; } } else { dirsExcluded . addElement ( "" ) ; } } else { dirsNotIncluded . addElement ( "" ) ; } checkIncludePatterns ( ) ; clearCaches ( ) ; includes = nullIncludes ? null : includes ; excludes = nullExcludes ? null : excludes ; } } finally { synchronized ( scanLock ) { scanning = false ; scanLock . notifyAll ( ) ; } } } private void checkIncludePatterns ( ) { Map newroots = new HashMap ( ) ; for ( int i = 0 ; i < includes . length ; i ++ ) { if ( FileUtils . isAbsolutePath ( includes [ i ] ) ) { if ( basedir != null && ! SelectorUtils . matchPatternStart ( includes [ i ] , basedir . getAbsolutePath ( ) , isCaseSensitive ( ) ) ) { continue ; } } else if ( basedir == null ) { continue ; } newroots . put ( SelectorUtils . rtrimWildcardTokens ( includes [ i ] ) , includes [ i ] ) ; } if ( newroots . containsKey ( "" ) && basedir != null ) { scandir ( basedir , "" , true ) ; } else { Iterator it = newroots . entrySet ( ) . iterator ( ) ; File canonBase = null ; if ( basedir != null ) { try { canonBase = basedir . getCanonicalFile ( ) ; } catch ( IOException ex ) { throw new BuildException ( ex ) ; } } while ( it . hasNext ( ) ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; String currentelement = ( String ) entry . getKey ( ) ; if ( basedir == null && ! FileUtils . isAbsolutePath ( currentelement ) ) { continue ; } String originalpattern = ( String ) entry . getValue ( ) ; File myfile = new File ( basedir , currentelement ) ; if ( myfile . exists ( ) ) { try { String path = ( basedir == null ) ? myfile . getCanonicalPath ( ) : FILE_UTILS . removeLeadingPath ( canonBase , myfile . getCanonicalFile ( ) ) ; if ( ! path . equals ( currentelement ) || ON_VMS ) { myfile = findFile ( basedir , currentelement , true ) ; if ( myfile != null && basedir != null ) { currentelement = FILE_UTILS . removeLeadingPath ( basedir , myfile ) ; } } } catch ( IOException ex ) { throw new BuildException ( ex ) ; } } if ( ( myfile == null || ! myfile . exists ( ) ) && ! isCaseSensitive ( ) ) { File f = findFile ( basedir , currentelement , false ) ; if ( f != null && f . exists ( ) ) { currentelement = ( basedir == null ) ? f . getAbsolutePath ( ) : FILE_UTILS . removeLeadingPath ( basedir , f ) ; myfile = f ; } } if ( myfile != null && myfile . exists ( ) ) { if ( ! followSymlinks && isSymlink ( basedir , currentelement ) ) { continue ; } if ( myfile . isDirectory ( ) ) { if ( isIncluded ( currentelement ) && currentelement . length ( ) > 0 ) { accountForIncludedDir ( currentelement , myfile , true ) ; } else { if ( currentelement . length ( ) > 0 ) { if ( currentelement . charAt ( currentelement . length ( ) - 1 ) != File . separatorChar ) { currentelement = currentelement + File . separatorChar ; } } scandir ( myfile , currentelement , true ) ; } } else { boolean included = isCaseSensitive ( ) ? originalpattern . equals ( currentelement ) : originalpattern . equalsIgnoreCase ( currentelement ) ; if ( included ) { accountForIncludedFile ( currentelement , myfile ) ; } } } } } } protected synchronized void clearResults ( ) { filesIncluded = new Vector ( ) ; filesNotIncluded = new Vector ( ) ; filesExcluded = new Vector ( ) ; filesDeselected = new Vector ( ) ; dirsIncluded = new Vector ( ) ; dirsNotIncluded = new Vector ( ) ; dirsExcluded = new Vector ( ) ; dirsDeselected = new Vector ( ) ; everythingIncluded = ( basedir != null ) ; scannedDirs . clear ( ) ; } protected void slowScan ( ) { synchronized ( slowScanLock ) { if ( haveSlowResults ) { return ; } if ( slowScanning ) { while ( slowScanning ) { try { slowScanLock . wait ( ) ; } catch ( InterruptedException e ) { } } return ; } slowScanning = true ; } try { synchronized ( this ) { boolean nullIncludes = ( includes == null ) ; includes = nullIncludes ? new String [ ] { "**" } : includes ; boolean nullExcludes = ( excludes == null ) ; excludes = nullExcludes ? new String [ 0 ] : excludes ; String [ ] excl = new String [ dirsExcluded . size ( ) ] ; dirsExcluded . copyInto ( excl ) ; String [ ] notIncl = new String [ dirsNotIncluded . size ( ) ] ; dirsNotIncluded . copyInto ( notIncl ) ; processSlowScan ( excl ) ; processSlowScan ( notIncl ) ; clearCaches ( ) ; includes = nullIncludes ? null : includes ; excludes = nullExcludes ? null : excludes ; } } finally { synchronized ( slowScanLock ) { haveSlowResults = true ; slowScanning = false ; slowScanLock . notifyAll ( ) ; } } } private void processSlowScan ( String [ ] arr ) { for ( int i = 0 ; i < arr . length ; i ++ ) { if ( ! couldHoldIncluded ( arr [ i ] ) ) { scandir ( new File ( basedir , arr [ i ] ) , arr [ i ] + File . separator , false ) ; } } } protected void scandir ( File dir , String vpath , boolean fast ) { if ( dir == null ) { throw new BuildException ( "dir must not be null." ) ; } else if ( ! dir . exists ( ) ) { throw new BuildException ( dir + " doesn't exist." ) ; } else if ( ! dir . isDirectory ( ) ) { throw new BuildException ( dir + " is not a directory." ) ; } if ( fast && hasBeenScanned ( vpath ) ) { return ; } String [ ] newfiles = dir . list ( ) ; if ( newfiles == null ) { throw new BuildException ( "IO error scanning directory '" + dir . getAbsolutePath ( ) + "'" ) ; } if ( ! followSymlinks ) { Vector noLinks = new Vector ( ) ; for ( int i = 0 ; i < newfiles . length ; i ++ ) { try { if ( FILE_UTILS . isSymbolicLink ( dir , newfiles [ i ] ) ) { String name = vpath + newfiles [ i ] ; File file = new File ( dir , newfiles [ i ] ) ; ( file . isDirectory ( ) ? dirsExcluded : filesExcluded ) . addElement ( name ) ; } else { noLinks . addElement ( newfiles [ i ] ) ; } } catch ( IOException ioe ) { String msg = "IOException caught while checking " + "for links, couldn't get canonical path!" ; System . err . println ( msg ) ; noLinks . addElement ( newfiles [ i ] ) ; } } newfiles = ( String [ ] ) ( noLinks . toArray ( new String [ noLinks . size ( ) ] ) ) ; } for ( int i = 0 ; i < newfiles . length ; i ++ ) { String name = vpath + newfiles [ i ] ; File file = new File ( dir , newfiles [ i ] ) ; if ( file . isDirectory ( ) ) { if ( isIncluded ( name ) ) { accountForIncludedDir ( name , file , fast ) ; } else { everythingIncluded = false ; dirsNotIncluded . addElement ( name ) ; if ( fast && couldHoldIncluded ( name ) ) { scandir ( file , name + File . separator , fast ) ; } } if ( ! fast ) { scandir ( file , name + File . separator , fast ) ; } } else if ( file . isFile ( ) ) { if ( isIncluded ( name ) ) { accountForIncludedFile ( name , file ) ; } else { everythingIncluded = false ; filesNotIncluded . addElement ( name ) ; } } } } private void accountForIncludedFile ( String name , File file ) { processIncluded ( name , file , filesIncluded , filesExcluded , filesDeselected ) ; } private void accountForIncludedDir ( String name , File file , boolean fast ) { processIncluded ( name , file , dirsIncluded , dirsExcluded , dirsDeselected ) ; if ( fast && couldHoldIncluded ( name ) && ! contentsExcluded ( name ) ) { scandir ( file , name + File . separator , fast ) ; } } private void processIncluded ( String name , File file , Vector inc , Vector exc , Vector des ) { if ( inc . contains ( name ) || exc . contains ( name ) || des . contains ( name ) ) { return ; } boolean included = false ; if ( isExcluded ( name ) ) { exc . add ( name ) ; } else if ( isSelected ( name , file ) ) { included = true ; inc . add ( name ) ; } else { des . add ( name ) ; } everythingIncluded &= included ; } protected boolean isIncluded ( String name ) { ensureNonPatternSetsReady ( ) ; if ( isCaseSensitive ( ) ? includeNonPatterns . contains ( name ) : includeNonPatterns . contains ( name . toUpperCase ( ) ) ) { return true ; } for ( int i = 0 ; i < includePatterns . length ; i ++ ) { if ( matchPath ( includePatterns [ i ] , name , isCaseSensitive ( ) ) ) { return true ; } } return false ; } protected boolean couldHoldIncluded ( String name ) { for ( int i = 0 ; i < includes . length ; i ++ ) { if ( matchPatternStart ( includes [ i ] , name , isCaseSensitive ( ) ) && isMorePowerfulThanExcludes ( name , includes [ i ] ) && isDeeper ( includes [ i ] , name ) ) { return true ; } } return false ; } private boolean isDeeper ( String pattern , String name ) { Vector p = SelectorUtils . tokenizePath ( pattern ) ; Vector n = SelectorUtils . tokenizePath ( name ) ; return p . contains ( "**" ) || p . size ( ) > n . size ( ) ; } private boolean isMorePowerfulThanExcludes ( String name , String includepattern ) { String soughtexclude = name + File . separator + "**" ; for ( int counter = 0 ; counter < excludes . length ; counter ++ ) { if ( excludes [ counter ] . equals ( soughtexclude ) ) { return false ; } } return true ; } private boolean contentsExcluded ( String name ) { name = ( name . endsWith ( File . separator ) ) ? name : name + File . separator ; for ( int i = 0 ; i < excludes . length ; i ++ ) { String e = excludes [ i ] ; if ( e . endsWith ( "**" ) && SelectorUtils . matchPath ( e . substring ( 0 , e . length ( ) - 2 ) , name , isCaseSensitive ( ) ) ) { return true ; } } return false ; } protected boolean isExcluded ( String name ) { ensureNonPatternSetsReady ( ) ; if ( isCaseSensitive ( ) ? excludeNonPatterns . contains ( name ) : excludeNonPatterns . contains ( name . toUpperCase ( ) ) ) { return true ; } for ( int i = 0 ; i < excludePatterns . length ; i ++ ) { if ( matchPath ( excludePatterns [ i ] , name , isCaseSensitive ( ) ) ) { return true ; } } return false ; } protected boolean isSelected ( String name , File file ) { if ( selectors != null ) { for ( int i = 0 ; i < selectors . length ; i ++ ) { if ( ! selectors [ i ] . isSelected ( basedir , name , file ) ) { return false ; } } } return true ; } public synchronized String [ ] getIncludedFiles ( ) { if ( filesIncluded == null ) { throw new IllegalStateException ( "Must call scan() first" ) ; } String [ ] files = new String [ filesIncluded . size ( ) ] ; filesIncluded . copyInto ( files ) ; Arrays . sort ( files ) ; return files ; } public synchronized int getIncludedFilesCount ( ) { if ( filesIncluded == null ) { throw new IllegalStateException ( "Must call scan() first" ) ; } return filesIncluded . size ( ) ; } public synchronized String [ ] getNotIncludedFiles ( ) { slowScan ( ) ; String [ ] files = new String [ filesNotIncluded . size ( ) ] ; filesNotIncluded . copyInto ( files ) ; return files ; } public synchronized String [ ] getExcludedFiles ( ) { slowScan ( ) ; String [ ] files = new String [ filesExcluded . size ( ) ] ; filesExcluded . copyInto ( files ) ; return files ; } public synchronized String [ ] getDeselectedFiles ( ) { slowScan ( ) ; String [ ] files = new String [ filesDeselected . size ( ) ] ; filesDeselected . copyInto ( files ) ; return files ; } public synchronized String [ ] getIncludedDirectories ( ) { if ( dirsIncluded == null ) { throw new IllegalStateException ( "Must call scan() first" ) ; } String [ ] directories = new String [ dirsIncluded . size ( ) ] ; dirsIncluded . copyInto ( directories ) ; Arrays . sort ( directories ) ; return directories ; } public synchronized int getIncludedDirsCount ( ) { if ( dirsIncluded == null ) { throw new IllegalStateException ( "Must call scan() first" ) ; } return dirsIncluded . size ( ) ; } public synchronized String [ ] getNotIncludedDirectories ( ) { slowScan ( ) ; String [ ] directories = new String [ dirsNotIncluded . size ( ) ] ; dirsNotIncluded . copyInto ( directories ) ; return directories ; } public synchronized String [ ] getExcludedDirectories ( ) { slowScan ( ) ; String [ ] directories = new String [ dirsExcluded . size ( ) ] ; dirsExcluded . copyInto ( directories ) ; return directories ; } public synchronized String [ ] getDeselectedDirectories ( ) { slowScan ( ) ; String [ ] directories = new String [ dirsDeselected . size ( ) ] ; dirsDeselected . copyInto ( directories ) ; return directories ; } public synchronized void addDefaultExcludes ( ) { int excludesLength = excludes == null ? 0 : excludes . length ; String [ ] newExcludes ; newExcludes = new String [ excludesLength + defaultExcludes . size ( ) ] ; if ( excludesLength > 0 ) { System . arraycopy ( excludes , 0 , newExcludes , 0 , excludesLength ) ; } String [ ] defaultExcludesTemp = getDefaultExcludes ( ) ; for ( int i = 0 ; i < defaultExcludesTemp . length ; i ++ ) { newExcludes [ i + excludesLength ] = defaultExcludesTemp [ i ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; } excludes = newExcludes ; } public synchronized Resource getResource ( String name ) { return new FileResource ( basedir , name ) ; } private String [ ] list ( File file ) { String [ ] files = ( String [ ] ) fileListMap . get ( file ) ; if ( files == null ) { files = file . list ( ) ; if ( files != null ) { fileListMap . put ( file , files ) ; } } return files ; } private File findFile ( File base , String path , boolean cs ) { if ( FileUtils . isAbsolutePath ( path ) ) { if ( base == null ) { String [ ] s = FILE_UTILS . dissect ( path ) ; base = new File ( s [ 0 ] ) ; path = s [ 1 ] ; } else { File f = FILE_UTILS . normalize ( path ) ; String s = FILE_UTILS . removeLeadingPath ( base , f ) ; if ( s . equals ( f . getAbsolutePath ( ) ) ) { return null ; } path = s ; } } return findFile ( base , SelectorUtils . tokenizePath ( path ) , cs ) ; } private File findFile ( File base , Vector pathElements , boolean cs ) { if ( pathElements . size ( ) == 0 ) { return base ; } String current = ( String ) pathElements . remove ( 0 ) ; if ( base == null ) { return findFile ( new File ( current ) , pathElements , cs ) ; } if ( ! base . isDirectory ( ) ) { return null ; } String [ ] files = list ( base ) ; if ( files == null ) { throw new BuildException ( "IO error scanning directory " + base . getAbsolutePath ( ) ) ; } boolean [ ] matchCase = cs ? CS_SCAN_ONLY : CS_THEN_NON_CS ; for ( int i = 0 ; i < matchCase . length ; i ++ ) { for ( int j = 0 ; j < files . length ; j ++ ) { if ( matchCase [ i ] ? files [ j ] . equals ( current ) : files [ j ] . equalsIgnoreCase ( current ) ) { return findFile ( new File ( base , files [ j ] ) , pathElements , cs ) ; } } } return null ; } private boolean isSymlink ( File base , String path ) { return isSymlink ( base , SelectorUtils . tokenizePath ( path ) ) ; } private boolean isSymlink ( File base , Vector pathElements ) { if ( pathElements . size ( ) > 0 ) { String current = ( String ) pathElements . remove ( 0 ) ; try { return FILE_UTILS . isSymbolicLink ( base , current ) || isSymlink ( new File ( base , current ) , pathElements ) ; } catch ( IOException ioe ) { String msg = "IOException caught while checking " + "for links, couldn't get canonical path!" ; System . err . println ( msg ) ; } } return false ; } private boolean hasBeenScanned ( String vpath ) { return ! scannedDirs . add ( vpath ) ; } Set getScannedDirs ( ) { return scannedDirs ; } private synchronized void clearCaches ( ) { fileListMap . clear ( ) ; includeNonPatterns . clear ( ) ; excludeNonPatterns . clear ( ) ; includePatterns = null ; excludePatterns = null ; areNonPatternSetsReady = false ; } private synchronized void ensureNonPatternSetsReady ( ) { if ( ! areNonPatternSetsReady ) { includePatterns = fillNonPatternSet ( includeNonPatterns , includes ) ; excludePatterns = fillNonPatternSet ( excludeNonPatterns , excludes ) ; areNonPatternSetsReady = true ; } } private String [ ] fillNonPatternSet ( Set set , String [ ] patterns ) { ArrayList al = new ArrayList ( patterns . length ) ; for ( int i = 0 ; i < patterns . length ; i ++ ) { if ( ! SelectorUtils . hasWildcards ( patterns [ i ] ) ) { set . add ( isCaseSensitive ( ) ? patterns [ i ] : patterns [ i ] . toUpperCase ( ) ) ; } else { al . add ( patterns [ i ] ) ; } } return set . size ( ) == 0 ? patterns : ( String [ ] ) al . toArray ( new String [ al . size ( ) ] ) ; } } 	1	['63', '1', '2', '61', '144', '1603', '51', '10', '31', '0.874288425', '2303', '1', '2', '0', '0.213709677', '0', '0', '35.01587302', '35', '3.2381', '3']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . compilers . AptExternalCompilerAdapter ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . JavaEnvUtils ; import java . util . Vector ; import java . io . File ; public class Apt extends Javac { private boolean compile = true ; private String factory ; private Path factoryPath ; private Vector options = new Vector ( ) ; private File preprocessDir ; public static final String EXECUTABLE_NAME = "apt" ; public static final String ERROR_IGNORING_COMPILER_OPTION = "Ignoring compiler attribute for the APT task, as it is fixed" ; public static final String ERROR_WRONG_JAVA_VERSION = "Apt task requires Java 1.5+" ; public static final String WARNING_IGNORING_FORK = "Apt only runs in its own JVM; fork=false option ignored" ; public static final class Option { private String name ; private String value ; public Option ( ) { } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } } public Apt ( ) { super ( ) ; super . setCompiler ( AptExternalCompilerAdapter . class . getName ( ) ) ; setFork ( true ) ; } public String getAptExecutable ( ) { return JavaEnvUtils . getJdkExecutable ( EXECUTABLE_NAME ) ; } public void setCompiler ( String compiler ) { log ( ERROR_IGNORING_COMPILER_OPTION , Project . MSG_WARN ) ; } public void setFork ( boolean fork ) { if ( ! fork ) { log ( WARNING_IGNORING_FORK , Project . MSG_WARN ) ; } } public String getCompiler ( ) { return super . getCompiler ( ) ; } public boolean isCompile ( ) { return compile ; } public void setCompile ( boolean compile ) { this . compile = compile ; } public String getFactory ( ) { return factory ; } public void setFactory ( String factory ) { this . factory = factory ; } public void setFactoryPathRef ( Reference ref ) { createFactoryPath ( ) . setRefid ( ref ) ; } public Path createFactoryPath ( ) { if ( factoryPath == null ) { factoryPath = new Path ( getProject ( ) ) ; } return factoryPath . createPath ( ) ; } public Path getFactoryPath ( ) { return factoryPath ; } public Option createOption ( ) { Option opt = new Option ( ) ; options . add ( opt ) ; return opt ; } public Vector getOptions ( ) { return options ; } public File getPreprocessDir ( ) { return preprocessDir ; } public void setPreprocessDir ( File preprocessDir ) { this . preprocessDir = preprocessDir ; } public void execute ( ) throws BuildException { super . execute ( ) ; } } 	1	['17', '5', '0', '9', '34', '118', '2', '7', '17', '0.975', '137', '0.5', '1', '0.905882353', '0.270588235', '3', '5', '6.470588235', '2', '1.0588', '1']
package org . apache . tools . ant . taskdefs ; import java . util . ArrayList ; import java . util . List ; import java . util . Iterator ; import java . util . Locale ; import java . util . Map ; import java . util . Set ; import java . util . HashSet ; import java . util . HashMap ; import java . util . Hashtable ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DynamicAttribute ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . RuntimeConfigurable ; import org . apache . tools . ant . Target ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . UnknownElement ; public class MacroInstance extends Task implements DynamicAttribute , TaskContainer { private MacroDef macroDef ; private Map map = new HashMap ( ) ; private Map nsElements = null ; private Map presentElements ; private Hashtable localAttributes ; private String text = null ; private String implicitTag = null ; private List unknownElements = new ArrayList ( ) ; public void setMacroDef ( MacroDef macroDef ) { this . macroDef = macroDef ; } public MacroDef getMacroDef ( ) { return macroDef ; } public void setDynamicAttribute ( String name , String value ) { map . put ( name , value ) ; } public Object createDynamicElement ( String name ) throws BuildException { throw new BuildException ( "Not implemented any more" ) ; } private Map getNsElements ( ) { if ( nsElements == null ) { nsElements = new HashMap ( ) ; for ( Iterator i = macroDef . getElements ( ) . entrySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) i . next ( ) ; nsElements . put ( ( String ) entry . getKey ( ) , entry . getValue ( ) ) ; MacroDef . TemplateElement te = ( MacroDef . TemplateElement ) entry . getValue ( ) ; if ( te . isImplicit ( ) ) { implicitTag = te . getName ( ) ; } } } return nsElements ; } public void addTask ( Task nestedTask ) { unknownElements . add ( nestedTask ) ; } private void processTasks ( ) { if ( implicitTag != null ) { return ; } for ( Iterator i = unknownElements . iterator ( ) ; i . hasNext ( ) ; ) { UnknownElement ue = ( UnknownElement ) i . next ( ) ; String name = ProjectHelper . extractNameFromComponentName ( ue . getTag ( ) ) . toLowerCase ( Locale . US ) ; if ( getNsElements ( ) . get ( name ) == null ) { throw new BuildException ( "unsupported element " + name ) ; } if ( presentElements . get ( name ) != null ) { throw new BuildException ( "Element " + name + " already present" ) ; } presentElements . put ( name , ue ) ; } } public static class Element implements TaskContainer { private List unknownElements = new ArrayList ( ) ; public void addTask ( Task nestedTask ) { unknownElements . add ( nestedTask ) ; } public List getUnknownElements ( ) { return unknownElements ; } } private static final int STATE_NORMAL = 0 ; private static final int STATE_EXPECT_BRACKET = 1 ; private static final int STATE_EXPECT_NAME = 2 ; private String macroSubs ( String s , Map macroMapping ) { if ( s == null ) { return null ; } StringBuffer ret = new StringBuffer ( ) ; StringBuffer macroName = null ; int state = STATE_NORMAL ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { char ch = s . charAt ( i ) ; switch ( state ) { case STATE_NORMAL : if ( ch == '@' ) { state = STATE_EXPECT_BRACKET ; } else { ret . append ( ch ) ; } break ; case STATE_EXPECT_BRACKET : if ( ch == '{' ) { state = STATE_EXPECT_NAME ; macroName = new StringBuffer ( ) ; } else if ( ch == '@' ) { state = STATE_NORMAL ; ret . append ( '@' ) ; } else { state = STATE_NORMAL ; ret . append ( '@' ) ; ret . append ( ch ) ; } break ; case STATE_EXPECT_NAME : if ( ch == '}' ) { state = STATE_NORMAL ; String name = macroName . toString ( ) . toLowerCase ( Locale . US ) ; String value = ( String ) macroMapping . get ( name ) ; if ( value == null ) { ret . append ( "@{" ) ; ret . append ( name ) ; ret . append ( "}" ) ; } else { ret . append ( value ) ; } macroName = null ; } else { macroName . append ( ch ) ; } break ; default : break ; } } switch ( state ) { case STATE_NORMAL : break ; case STATE_EXPECT_BRACKET : ret . append ( '@' ) ; break ; case STATE_EXPECT_NAME : ret . append ( "@{" ) ; ret . append ( macroName . toString ( ) ) ; break ; default : break ; } return ret . toString ( ) ; } public void addText ( String text ) { this . text = text ; } private UnknownElement copy ( UnknownElement ue ) { UnknownElement ret = new UnknownElement ( ue . getTag ( ) ) ; ret . setNamespace ( ue . getNamespace ( ) ) ; ret . setProject ( getProject ( ) ) ; ret . setQName ( ue . getQName ( ) ) ; ret . setTaskType ( ue . getTaskType ( ) ) ; ret . setTaskName ( ue . getTaskName ( ) ) ; ret . setLocation ( macroDef . getBackTrace ( ) ? ue . getLocation ( ) : getLocation ( ) ) ; if ( getOwningTarget ( ) == null ) { Target t = new Target ( ) ; t . setProject ( getProject ( ) ) ; ret . setOwningTarget ( t ) ; } else { ret . setOwningTarget ( getOwningTarget ( ) ) ; } RuntimeConfigurable rc = new RuntimeConfigurable ( ret , ue . getTaskName ( ) ) ; rc . setPolyType ( ue . getWrapper ( ) . getPolyType ( ) ) ; Map m = ue . getWrapper ( ) . getAttributeMap ( ) ; for ( Iterator i = m . entrySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) i . next ( ) ; rc . setAttribute ( ( String ) entry . getKey ( ) , macroSubs ( ( String ) entry . getValue ( ) , localAttributes ) ) ; } rc . addText ( macroSubs ( ue . getWrapper ( ) . getText ( ) . toString ( ) , localAttributes ) ) ; Enumeration e = ue . getWrapper ( ) . getChildren ( ) ; while ( e . hasMoreElements ( ) ) { RuntimeConfigurable r = ( RuntimeConfigurable ) e . nextElement ( ) ; UnknownElement unknownElement = ( UnknownElement ) r . getProxy ( ) ; String tag = unknownElement . getTaskType ( ) ; if ( tag != null ) { tag = tag . toLowerCase ( Locale . US ) ; } MacroDef . TemplateElement templateElement = ( MacroDef . TemplateElement ) getNsElements ( ) . get ( tag ) ; if ( templateElement == null ) { UnknownElement child = copy ( unknownElement ) ; rc . addChild ( child . getWrapper ( ) ) ; ret . addChild ( child ) ; } else if ( templateElement . isImplicit ( ) ) { if ( unknownElements . size ( ) == 0 && ! templateElement . isOptional ( ) ) { throw new BuildException ( "Missing nested elements for implicit element " + templateElement . getName ( ) ) ; } for ( Iterator i = unknownElements . iterator ( ) ; i . hasNext ( ) ; ) { UnknownElement child = copy ( ( UnknownElement ) i . next ( ) ) ; rc . addChild ( child . getWrapper ( ) ) ; ret . addChild ( child ) ; } } else { UnknownElement presentElement = ( UnknownElement ) presentElements . get ( tag ) ; if ( presentElement == null ) { if ( ! templateElement . isOptional ( ) ) { throw new BuildException ( "Required nested element " + templateElement . getName ( ) + " missing" ) ; } continue ; } String presentText = presentElement . getWrapper ( ) . getText ( ) . toString ( ) ; if ( ! "" . equals ( presentText ) ) { rc . addText ( macroSubs ( presentText , localAttributes ) ) ; } List list = presentElement . getChildren ( ) ; if ( list != null ) { for ( Iterator i = list . iterator ( ) ; i . hasNext ( ) ; ) { UnknownElement child = copy ( ( UnknownElement ) i . next ( ) ) ; rc . addChild ( child . getWrapper ( ) ) ; ret . addChild ( child ) ; } } } } return ret ; } public void execute ( ) { presentElements = new HashMap ( ) ; getNsElements ( ) ; processTasks ( ) ; localAttributes = new Hashtable ( ) ; Set copyKeys = new HashSet ( map . keySet ( ) ) ; for ( Iterator i = macroDef . getAttributes ( ) . iterator ( ) ; i . hasNext ( ) ; ) { MacroDef . Attribute attribute = ( MacroDef . Attribute ) i . next ( ) ; String value = ( String ) map . get ( attribute . getName ( ) ) ; if ( value == null && "description" . equals ( attribute . getName ( ) ) ) { value = getDescription ( ) ; } if ( value == null ) { value = attribute . getDefault ( ) ; value = macroSubs ( value , localAttributes ) ; } if ( value == null ) { throw new BuildException ( "required attribute " + attribute . getName ( ) + " not set" ) ; } localAttributes . put ( attribute . getName ( ) , value ) ; copyKeys . remove ( attribute . getName ( ) ) ; } if ( copyKeys . contains ( "id" ) ) { copyKeys . remove ( "id" ) ; } if ( macroDef . getText ( ) != null ) { if ( text == null ) { if ( ! macroDef . getText ( ) . getOptional ( ) ) { throw new BuildException ( "required text missing" ) ; } text = "" ; } if ( macroDef . getText ( ) . getTrim ( ) ) { text = text . trim ( ) ; } localAttributes . put ( macroDef . getText ( ) . getName ( ) , text ) ; } else { if ( text != null && ! text . trim ( ) . equals ( "" ) ) { throw new BuildException ( "The \"" + getTaskName ( ) + "\" macro does not support" + " nested text data." ) ; } } if ( copyKeys . size ( ) != 0 ) { throw new BuildException ( "Unknown attribute" + ( copyKeys . size ( ) > 1 ? "s " : " " ) + copyKeys ) ; } UnknownElement c = copy ( macroDef . getNestedTask ( ) ) ; c . init ( ) ; try { c . perform ( ) ; } catch ( BuildException ex ) { if ( macroDef . getBackTrace ( ) ) { throw ProjectHelper . addLocationToBuildException ( ex , getLocation ( ) ) ; } else { ex . setLocation ( getLocation ( ) ) ; throw ex ; } } finally { presentElements = null ; localAttributes = null ; } } } 	1	['12', '3', '0', '15', '99', '18', '1', '14', '8', '0.826446281', '804', '1', '1', '0.770833333', '0.277777778', '2', '2', '65.08333333', '18', '4.8333', '2']
package org . apache . tools . ant . types ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Map ; import java . util . zip . ZipException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . ZipResource ; import org . apache . tools . zip . ZipEntry ; import org . apache . tools . zip . ZipFile ; public class ZipScanner extends ArchiveScanner { protected void fillMapsFromArchive ( Resource src , String encoding , Map fileEntries , Map matchFileEntries , Map dirEntries , Map matchDirEntries ) { ZipEntry entry = null ; ZipFile zf = null ; File srcFile = null ; if ( src instanceof FileResource ) { srcFile = ( ( FileResource ) src ) . getFile ( ) ; } else { throw new BuildException ( "only file resources are supported" ) ; } try { try { zf = new ZipFile ( srcFile , encoding ) ; } catch ( ZipException ex ) { throw new BuildException ( "problem reading " + srcFile , ex ) ; } catch ( IOException ex ) { throw new BuildException ( "problem opening " + srcFile , ex ) ; } Enumeration e = zf . getEntries ( ) ; while ( e . hasMoreElements ( ) ) { entry = ( ZipEntry ) e . nextElement ( ) ; Resource r = new ZipResource ( srcFile , encoding , entry ) ; String name = entry . getName ( ) ; if ( entry . isDirectory ( ) ) { name = trimSeparator ( name ) ; dirEntries . put ( name , r ) ; if ( match ( name ) ) { matchDirEntries . put ( name , r ) ; } } else { fileEntries . put ( name , r ) ; if ( match ( name ) ) { matchFileEntries . put ( name , r ) ; } } } } finally { if ( zf != null ) { try { zf . close ( ) ; } catch ( IOException ex ) { } } } } } 	1	['2', '3', '0', '9', '20', '1', '2', '7', '1', '2', '128', '0', '0', '0.987179487', '0.625', '1', '3', '63', '9', '4.5', '1']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Vector ; import java . util . Locale ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Environment ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . RedirectorElement ; import org . apache . tools . ant . util . FileUtils ; public class ExecTask extends Task { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private String os ; private String osFamily ; private File dir ; protected boolean failOnError = false ; protected boolean newEnvironment = false ; private Long timeout = null ; private Environment env = new Environment ( ) ; protected Commandline cmdl = new Commandline ( ) ; private String resultProperty ; private boolean failIfExecFails = true ; private String executable ; private boolean resolveExecutable = false ; private boolean searchPath = false ; private boolean spawn = false ; private boolean incompatibleWithSpawn = false ; private String inputString ; private File input ; private File output ; private File error ; protected Redirector redirector = new Redirector ( this ) ; protected RedirectorElement redirectorElement ; private boolean vmLauncher = true ; public ExecTask ( ) { } public ExecTask ( Task owner ) { bindToOwner ( owner ) ; } public void setSpawn ( boolean spawn ) { this . spawn = spawn ; } public void setTimeout ( Long value ) { timeout = value ; incompatibleWithSpawn = true ; } public void setTimeout ( Integer value ) { setTimeout ( ( Long ) ( ( value == null ) ? null : new Long ( value . intValue ( ) ) ) ) ; } public void setExecutable ( String value ) { this . executable = value ; cmdl . setExecutable ( value ) ; } public void setDir ( File d ) { this . dir = d ; } public void setOs ( String os ) { this . os = os ; } public void setCommand ( Commandline cmdl ) { log ( "The command attribute is deprecated.\n" + "Please use the executable attribute and nested arg elements." , Project . MSG_WARN ) ; this . cmdl = cmdl ; } public void setOutput ( File out ) { this . output = out ; incompatibleWithSpawn = true ; } public void setInput ( File input ) { if ( inputString != null ) { throw new BuildException ( "The \"input\" and \"inputstring\" " + "attributes cannot both be specified" ) ; } this . input = input ; incompatibleWithSpawn = true ; } public void setInputString ( String inputString ) { if ( input != null ) { throw new BuildException ( "The \"input\" and \"inputstring\" " + "attributes cannot both be specified" ) ; } this . inputString = inputString ; incompatibleWithSpawn = true ; } public void setLogError ( boolean logError ) { redirector . setLogError ( logError ) ; incompatibleWithSpawn |= logError ; } public void setError ( File error ) { this . error = error ; incompatibleWithSpawn = true ; } public void setOutputproperty ( String outputProp ) { redirector . setOutputProperty ( outputProp ) ; incompatibleWithSpawn = true ; } public void setErrorProperty ( String errorProperty ) { redirector . setErrorProperty ( errorProperty ) ; incompatibleWithSpawn = true ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; incompatibleWithSpawn |= fail ; } public void setNewenvironment ( boolean newenv ) { newEnvironment = newenv ; } public void setResolveExecutable ( boolean resolveExecutable ) { this . resolveExecutable = resolveExecutable ; } public void setSearchPath ( boolean searchPath ) { this . searchPath = searchPath ; } public boolean getResolveExecutable ( ) { return resolveExecutable ; } public void addEnv ( Environment . Variable var ) { env . addVariable ( var ) ; } public Commandline . Argument createArg ( ) { return cmdl . createArgument ( ) ; } public void setResultProperty ( String resultProperty ) { this . resultProperty = resultProperty ; incompatibleWithSpawn = true ; } protected void maybeSetResultPropertyValue ( int result ) { if ( resultProperty != null ) { String res = Integer . toString ( result ) ; getProject ( ) . setNewProperty ( resultProperty , res ) ; } } public void setFailIfExecutionFails ( boolean flag ) { failIfExecFails = flag ; incompatibleWithSpawn = true ; } public void setAppend ( boolean append ) { redirector . setAppend ( append ) ; incompatibleWithSpawn = true ; } public void addConfiguredRedirector ( RedirectorElement redirectorElement ) { if ( this . redirectorElement != null ) { throw new BuildException ( "cannot have > 1 nested <redirector>s" ) ; } this . redirectorElement = redirectorElement ; incompatibleWithSpawn = true ; } public void setOsFamily ( String osFamily ) { this . osFamily = osFamily . toLowerCase ( Locale . US ) ; } protected String resolveExecutable ( String exec , boolean mustSearchPath ) { if ( ! resolveExecutable ) { return exec ; } File executableFile = getProject ( ) . resolveFile ( exec ) ; if ( executableFile . exists ( ) ) { return executableFile . getAbsolutePath ( ) ; } if ( dir != null ) { executableFile = FILE_UTILS . resolveFile ( dir , exec ) ; if ( executableFile . exists ( ) ) { return executableFile . getAbsolutePath ( ) ; } } if ( mustSearchPath ) { Path p = null ; String [ ] environment = env . getVariables ( ) ; if ( environment != null ) { for ( int i = 0 ; i < environment . length ; i ++ ) { if ( isPath ( environment [ i ] ) ) { p = new Path ( getProject ( ) , environment [ i ] . substring ( 5 ) ) ; break ; } } } if ( p == null ) { Vector envVars = Execute . getProcEnvironment ( ) ; Enumeration e = envVars . elements ( ) ; while ( e . hasMoreElements ( ) ) { String line = ( String ) e . nextElement ( ) ; if ( isPath ( line ) ) { p = new Path ( getProject ( ) , line . substring ( 5 ) ) ; break ; } } } if ( p != null ) { String [ ] dirs = p . list ( ) ; for ( int i = 0 ; i < dirs . length ; i ++ ) { executableFile = FILE_UTILS . resolveFile ( new File ( dirs [ i ] ) , exec ) ; if ( executableFile . exists ( ) ) { return executableFile . getAbsolutePath ( ) ; } } } } return exec ; } public void execute ( ) throws BuildException { if ( ! isValidOs ( ) ) { return ; } File savedDir = dir ; cmdl . setExecutable ( resolveExecutable ( executable , searchPath ) ) ; checkConfiguration ( ) ; try { runExec ( prepareExec ( ) ) ; } finally { dir = savedDir ; } } protected void checkConfiguration ( ) throws BuildException { if ( cmdl . getExecutable ( ) == null ) { throw new BuildException ( "no executable specified" , getLocation ( ) ) ; } if ( dir != null && ! dir . exists ( ) ) { throw new BuildException ( "The directory " + dir + " does not exist" ) ; } if ( dir != null && ! dir . isDirectory ( ) ) { throw new BuildException ( dir + " is not a directory" ) ; } if ( spawn && incompatibleWithSpawn ) { getProject ( ) . log ( "spawn does not allow attributes related to input, " + "output, error, result" , Project . MSG_ERR ) ; getProject ( ) . log ( "spawn also does not allow timeout" , Project . MSG_ERR ) ; getProject ( ) . log ( "finally, spawn is not compatible " + "with a nested I/O <redirector>" , Project . MSG_ERR ) ; throw new BuildException ( "You have used an attribute " + "or nested element which is not compatible with spawn" ) ; } setupRedirector ( ) ; } protected void setupRedirector ( ) { redirector . setInput ( input ) ; redirector . setInputString ( inputString ) ; redirector . setOutput ( output ) ; redirector . setError ( error ) ; } protected boolean isValidOs ( ) { if ( osFamily != null && ! Os . isOs ( osFamily , null , null , null ) ) { return false ; } String myos = System . getProperty ( "os.name" ) ; log ( "Current OS is " + myos , Project . MSG_VERBOSE ) ; if ( ( os != null ) && ( os . indexOf ( myos ) < 0 ) ) { log ( "This OS, " + myos + " was not found in the specified list of valid OSes: " + os , Project . MSG_VERBOSE ) ; return false ; } return true ; } public void setVMLauncher ( boolean vmLauncher ) { this . vmLauncher = vmLauncher ; } protected Execute prepareExec ( ) throws BuildException { if ( dir == null ) { dir = getProject ( ) . getBaseDir ( ) ; } if ( redirectorElement != null ) { redirectorElement . configure ( redirector ) ; } Execute exe = new Execute ( createHandler ( ) , createWatchdog ( ) ) ; exe . setAntRun ( getProject ( ) ) ; exe . setWorkingDirectory ( dir ) ; exe . setVMLauncher ( vmLauncher ) ; exe . setSpawn ( spawn ) ; String [ ] environment = env . getVariables ( ) ; if ( environment != null ) { for ( int i = 0 ; i < environment . length ; i ++ ) { log ( "Setting environment variable: " + environment [ i ] , Project . MSG_VERBOSE ) ; } } exe . setNewenvironment ( newEnvironment ) ; exe . setEnvironment ( environment ) ; return exe ; } protected final void runExecute ( Execute exe ) throws IOException { int returnCode = - 1 ; if ( ! spawn ) { returnCode = exe . execute ( ) ; if ( exe . killedProcess ( ) ) { String msg = "Timeout: killed the sub-process" ; if ( failOnError ) { throw new BuildException ( msg ) ; } else { log ( msg , Project . MSG_WARN ) ; } } maybeSetResultPropertyValue ( returnCode ) ; redirector . complete ( ) ; if ( Execute . isFailure ( returnCode ) ) { if ( failOnError ) { throw new BuildException ( getTaskType ( ) + " returned: " + returnCode , getLocation ( ) ) ; } else { log ( "Result: " + returnCode , Project . MSG_ERR ) ; } } } else { exe . spawn ( ) ; } } protected void runExec ( Execute exe ) throws BuildException { log ( cmdl . describeCommand ( ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( cmdl . getCommandline ( ) ) ; try { runExecute ( exe ) ; } catch ( IOException e ) { if ( failIfExecFails ) { throw new BuildException ( "Execute failed: " + e . toString ( ) , e , getLocation ( ) ) ; } else { log ( "Execute failed: " + e . toString ( ) , Project . MSG_ERR ) ; } } finally { logFlush ( ) ; } } protected ExecuteStreamHandler createHandler ( ) throws BuildException { return redirector . createHandler ( ) ; } protected ExecuteWatchdog createWatchdog ( ) throws BuildException { return ( timeout == null ) ? null : new ExecuteWatchdog ( timeout . longValue ( ) ) ; } protected void logFlush ( ) { } private boolean isPath ( String line ) { return line . startsWith ( "PATH=" ) || line . startsWith ( "Path=" ) ; } } 	1	['43', '3', '1', '25', '120', '451', '9', '16', '30', '0.893374741', '920', '1', '5', '0.480519481', '0.146825397', '0', '0', '19.86046512', '15', '1.5116', '1']
package org . apache . tools . ant . types ; import java . io . File ; import java . util . Iterator ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . zip . UnixStat ; public abstract class ArchiveFileSet extends FileSet { private static final int BASE_OCTAL = 8 ; public static final int DEFAULT_DIR_MODE = UnixStat . DIR_FLAG | UnixStat . DEFAULT_DIR_PERM ; public static final int DEFAULT_FILE_MODE = UnixStat . FILE_FLAG | UnixStat . DEFAULT_FILE_PERM ; private Resource src = null ; private String prefix = "" ; private String fullpath = "" ; private boolean hasDir = false ; private int fileMode = DEFAULT_FILE_MODE ; private int dirMode = DEFAULT_DIR_MODE ; private boolean fileModeHasBeenSet = false ; private boolean dirModeHasBeenSet = false ; public ArchiveFileSet ( ) { super ( ) ; } protected ArchiveFileSet ( FileSet fileset ) { super ( fileset ) ; } protected ArchiveFileSet ( ArchiveFileSet fileset ) { super ( fileset ) ; src = fileset . src ; prefix = fileset . prefix ; fullpath = fileset . fullpath ; hasDir = fileset . hasDir ; fileMode = fileset . fileMode ; dirMode = fileset . dirMode ; fileModeHasBeenSet = fileset . fileModeHasBeenSet ; dirModeHasBeenSet = fileset . dirModeHasBeenSet ; } public void setDir ( File dir ) throws BuildException { checkAttributesAllowed ( ) ; if ( src != null ) { throw new BuildException ( "Cannot set both dir and src attributes" ) ; } else { super . setDir ( dir ) ; hasDir = true ; } } public void addConfigured ( ResourceCollection a ) { checkChildrenAllowed ( ) ; if ( a . size ( ) != 1 ) { throw new BuildException ( "only single argument resource collections" + " are supported as archives" ) ; } setSrcResource ( ( Resource ) a . iterator ( ) . next ( ) ) ; } public void setSrc ( File srcFile ) { setSrcResource ( new FileResource ( srcFile ) ) ; } public void setSrcResource ( Resource src ) { checkArchiveAttributesAllowed ( ) ; if ( hasDir ) { throw new BuildException ( "Cannot set both dir and src attributes" ) ; } this . src = src ; } public File getSrc ( Project p ) { if ( isReference ( ) ) { return ( ( ArchiveFileSet ) getRef ( p ) ) . getSrc ( p ) ; } return getSrc ( ) ; } public File getSrc ( ) { if ( src instanceof FileResource ) { return ( ( FileResource ) src ) . getFile ( ) ; } return null ; } public void setPrefix ( String prefix ) { checkArchiveAttributesAllowed ( ) ; if ( ! prefix . equals ( "" ) && ! fullpath . equals ( "" ) ) { throw new BuildException ( "Cannot set both fullpath and prefix attributes" ) ; } this . prefix = prefix ; } public String getPrefix ( Project p ) { if ( isReference ( ) ) { return ( ( ArchiveFileSet ) getRef ( p ) ) . getPrefix ( p ) ; } return prefix ; } public void setFullpath ( String fullpath ) { checkArchiveAttributesAllowed ( ) ; if ( ! prefix . equals ( "" ) && ! fullpath . equals ( "" ) ) { throw new BuildException ( "Cannot set both fullpath and prefix attributes" ) ; } this . fullpath = fullpath ; } public String getFullpath ( Project p ) { if ( isReference ( ) ) { return ( ( ArchiveFileSet ) getRef ( p ) ) . getFullpath ( p ) ; } return fullpath ; } protected abstract ArchiveScanner newArchiveScanner ( ) ; public DirectoryScanner getDirectoryScanner ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getDirectoryScanner ( p ) ; } if ( src == null ) { return super . getDirectoryScanner ( p ) ; } if ( ! src . isExists ( ) ) { throw new BuildException ( "the archive doesn't exist" ) ; } if ( src . isDirectory ( ) ) { throw new BuildException ( "the archive can't be a directory" ) ; } ArchiveScanner as = newArchiveScanner ( ) ; as . setSrc ( src ) ; super . setDir ( p . getBaseDir ( ) ) ; setupDirectoryScanner ( as , p ) ; as . init ( ) ; return as ; } public Iterator iterator ( ) { if ( isReference ( ) ) { return ( ( ResourceCollection ) ( getRef ( getProject ( ) ) ) ) . iterator ( ) ; } if ( src == null ) { return super . iterator ( ) ; } ArchiveScanner as = ( ArchiveScanner ) getDirectoryScanner ( getProject ( ) ) ; return as . getResourceFiles ( ) ; } public int size ( ) { if ( isReference ( ) ) { return ( ( ResourceCollection ) ( getRef ( getProject ( ) ) ) ) . size ( ) ; } if ( src == null ) { return super . size ( ) ; } ArchiveScanner as = ( ArchiveScanner ) getDirectoryScanner ( getProject ( ) ) ; return as . getIncludedFilesCount ( ) ; } public boolean isFilesystemOnly ( ) { return src == null ; } public void setFileMode ( String octalString ) { checkArchiveAttributesAllowed ( ) ; integerSetFileMode ( Integer . parseInt ( octalString , BASE_OCTAL ) ) ; } public void integerSetFileMode ( int mode ) { fileModeHasBeenSet = true ; this . fileMode = UnixStat . FILE_FLAG | mode ; } public int getFileMode ( Project p ) { if ( isReference ( ) ) { return ( ( ArchiveFileSet ) getRef ( p ) ) . getFileMode ( p ) ; } return fileMode ; } public boolean hasFileModeBeenSet ( ) { if ( isReference ( ) ) { return ( ( ArchiveFileSet ) getRef ( getProject ( ) ) ) . hasFileModeBeenSet ( ) ; } return fileModeHasBeenSet ; } public void setDirMode ( String octalString ) { checkArchiveAttributesAllowed ( ) ; integerSetDirMode ( Integer . parseInt ( octalString , BASE_OCTAL ) ) ; } public void integerSetDirMode ( int mode ) { dirModeHasBeenSet = true ; this . dirMode = UnixStat . DIR_FLAG | mode ; } public int getDirMode ( Project p ) { if ( isReference ( ) ) { return ( ( ArchiveFileSet ) getRef ( p ) ) . getDirMode ( p ) ; } return dirMode ; } public boolean hasDirModeBeenSet ( ) { if ( isReference ( ) ) { return ( ( ArchiveFileSet ) getRef ( getProject ( ) ) ) . hasDirModeBeenSet ( ) ; } return dirModeHasBeenSet ; } protected void configureFileSet ( ArchiveFileSet zfs ) { zfs . setPrefix ( prefix ) ; zfs . setFullpath ( fullpath ) ; zfs . fileModeHasBeenSet = fileModeHasBeenSet ; zfs . fileMode = fileMode ; zfs . dirModeHasBeenSet = dirModeHasBeenSet ; zfs . dirMode = dirMode ; } public Object clone ( ) { if ( isReference ( ) ) { return ( ( ArchiveFileSet ) getRef ( getProject ( ) ) ) . clone ( ) ; } else { return super . clone ( ) ; } } public String toString ( ) { if ( hasDir && getProject ( ) != null ) { return super . toString ( ) ; } else if ( src != null ) { return src . getName ( ) ; } else { return null ; } } public String getPrefix ( ) { return prefix ; } public String getFullpath ( ) { return fullpath ; } public int getFileMode ( ) { return fileMode ; } public int getDirMode ( ) { return dirMode ; } private void checkArchiveAttributesAllowed ( ) { if ( getProject ( ) == null || ( isReference ( ) && ( getRefid ( ) . getReferencedObject ( getProject ( ) ) instanceof ArchiveFileSet ) ) ) { checkAttributesAllowed ( ) ; } } } 	1	['34', '5', '2', '15', '67', '295', '4', '11', '29', '0.842975207', '586', '0.818181818', '1', '0.745901639', '0.173202614', '3', '15', '15.91176471', '5', '1.7941', '3']
package org . apache . tools . ant . taskdefs . optional . junit ; import java . lang . reflect . Method ; import junit . framework . Test ; import junit . framework . TestCase ; public class JUnitVersionHelper { private static Method testCaseName = null ; static { try { testCaseName = TestCase . class . getMethod ( "getName" , new Class [ 0 ] ) ; } catch ( NoSuchMethodException e ) { try { testCaseName = TestCase . class . getMethod ( "name" , new Class [ 0 ] ) ; } catch ( NoSuchMethodException e2 ) { } } } public static String getTestCaseName ( Test t ) { if ( t != null && t . getClass ( ) . getName ( ) . equals ( "junit.framework.JUnit4TestCaseFacade" ) ) { String name = t . toString ( ) ; if ( name . endsWith ( ")" ) ) { int paren = name . lastIndexOf ( '(' ) ; return name . substring ( 0 , paren ) ; } else { return name ; } } if ( t instanceof TestCase && testCaseName != null ) { try { return ( String ) testCaseName . invoke ( t , new Object [ 0 ] ) ; } catch ( Throwable e ) { } } else { try { Method getNameMethod = null ; try { getNameMethod = t . getClass ( ) . getMethod ( "getName" , new Class [ 0 ] ) ; } catch ( NoSuchMethodException e ) { getNameMethod = t . getClass ( ) . getMethod ( "name" , new Class [ 0 ] ) ; } if ( getNameMethod != null && getNameMethod . getReturnType ( ) == String . class ) { return ( String ) getNameMethod . invoke ( t , new Object [ 0 ] ) ; } } catch ( Throwable e ) { } } return "unknown" ; } static String getTestCaseClassName ( Test test ) { String className = test . getClass ( ) . getName ( ) ; if ( test instanceof JUnitTaskMirrorImpl . VmExitErrorTest ) { className = ( ( JUnitTaskMirrorImpl . VmExitErrorTest ) test ) . getClassName ( ) ; } else if ( className . equals ( "junit.framework.JUnit4TestCaseFacade" ) ) { String name = test . toString ( ) ; int paren = name . lastIndexOf ( '(' ) ; if ( paren != - 1 && name . endsWith ( ")" ) ) { className = name . substring ( paren + 1 , name . length ( ) - 1 ) ; } } return className ; } } 	1	['4', '1', '0', '7', '20', '4', '4', '3', '2', '0.888888889', '187', '0.333333333', '0', '0', '0.5', '0', '0', '45', '9', '3.5', '1']
package org . apache . tools . ant ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import java . lang . reflect . Constructor ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . Collections ; import java . util . Enumeration ; import java . util . HashMap ; import java . util . Hashtable ; import java . util . Map ; import java . util . StringTokenizer ; import java . util . Vector ; import java . util . jar . Attributes ; import java . util . jar . Attributes . Name ; import java . util . jar . JarFile ; import java . util . jar . Manifest ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . CollectionUtils ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . apache . tools . ant . util . LoaderUtils ; import org . apache . tools . ant . launch . Locator ; public class AntClassLoader extends ClassLoader implements SubBuildListener { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private class ResourceEnumeration implements Enumeration { private String resourceName ; private int pathElementsIndex ; private URL nextResource ; ResourceEnumeration ( String name ) { this . resourceName = name ; this . pathElementsIndex = 0 ; findNextResource ( ) ; } public boolean hasMoreElements ( ) { return ( this . nextResource != null ) ; } public Object nextElement ( ) { URL ret = this . nextResource ; findNextResource ( ) ; return ret ; } private void findNextResource ( ) { URL url = null ; while ( ( pathElementsIndex < pathComponents . size ( ) ) && ( url == null ) ) { try { File pathComponent = ( File ) pathComponents . elementAt ( pathElementsIndex ) ; url = getResourceURL ( pathComponent , this . resourceName ) ; pathElementsIndex ++ ; } catch ( BuildException e ) { } } this . nextResource = url ; } } private static final int BUFFER_SIZE = 8192 ; private static final int NUMBER_OF_STRINGS = 256 ; private Vector pathComponents = new Vector ( ) ; private Project project ; private boolean parentFirst = true ; private Vector systemPackages = new Vector ( ) ; private Vector loaderPackages = new Vector ( ) ; private boolean ignoreBase = false ; private ClassLoader parent = null ; private Hashtable zipFiles = new Hashtable ( ) ; private static Map pathMap = Collections . synchronizedMap ( new HashMap ( ) ) ; private ClassLoader savedContextLoader = null ; private boolean isContextLoaderSaved = false ; public AntClassLoader ( ClassLoader parent , Project project , Path classpath ) { setParent ( parent ) ; setClassPath ( classpath ) ; setProject ( project ) ; } public AntClassLoader ( ) { setParent ( null ) ; } public AntClassLoader ( Project project , Path classpath ) { setParent ( null ) ; setProject ( project ) ; setClassPath ( classpath ) ; } public AntClassLoader ( ClassLoader parent , Project project , Path classpath , boolean parentFirst ) { this ( project , classpath ) ; if ( parent != null ) { setParent ( parent ) ; } setParentFirst ( parentFirst ) ; addJavaLibraries ( ) ; } public AntClassLoader ( Project project , Path classpath , boolean parentFirst ) { this ( null , project , classpath , parentFirst ) ; } public AntClassLoader ( ClassLoader parent , boolean parentFirst ) { setParent ( parent ) ; project = null ; this . parentFirst = parentFirst ; } public void setProject ( Project project ) { this . project = project ; if ( project != null ) { project . addBuildListener ( this ) ; } } public void setClassPath ( Path classpath ) { pathComponents . removeAllElements ( ) ; if ( classpath != null ) { Path actualClasspath = classpath . concatSystemClasspath ( "ignore" ) ; String [ ] pathElements = actualClasspath . list ( ) ; for ( int i = 0 ; i < pathElements . length ; ++ i ) { try { addPathElement ( pathElements [ i ] ) ; } catch ( BuildException e ) { } } } } public void setParent ( ClassLoader parent ) { if ( parent == null ) { this . parent = AntClassLoader . class . getClassLoader ( ) ; } else { this . parent = parent ; } } public void setParentFirst ( boolean parentFirst ) { this . parentFirst = parentFirst ; } protected void log ( String message , int priority ) { if ( project != null ) { project . log ( message , priority ) ; } } public void setThreadContextLoader ( ) { if ( isContextLoaderSaved ) { throw new BuildException ( "Context loader has not been reset" ) ; } if ( LoaderUtils . isContextLoaderAvailable ( ) ) { savedContextLoader = LoaderUtils . getContextClassLoader ( ) ; ClassLoader loader = this ; if ( project != null && "only" . equals ( project . getProperty ( "build.sysclasspath" ) ) ) { loader = this . getClass ( ) . getClassLoader ( ) ; } LoaderUtils . setContextClassLoader ( loader ) ; isContextLoaderSaved = true ; } } public void resetThreadContextLoader ( ) { if ( LoaderUtils . isContextLoaderAvailable ( ) && isContextLoaderSaved ) { LoaderUtils . setContextClassLoader ( savedContextLoader ) ; savedContextLoader = null ; isContextLoaderSaved = false ; } } public void addPathElement ( String pathElement ) throws BuildException { File pathComponent = project != null ? project . resolveFile ( pathElement ) : new File ( pathElement ) ; try { addPathFile ( pathComponent ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } protected void addPathFile ( File pathComponent ) throws IOException { pathComponents . addElement ( pathComponent ) ; if ( pathComponent . isDirectory ( ) ) { return ; } String absPathPlusTimeAndLength = pathComponent . getAbsolutePath ( ) + pathComponent . lastModified ( ) + "-" + pathComponent . length ( ) ; String classpath = ( String ) pathMap . get ( absPathPlusTimeAndLength ) ; if ( classpath == null ) { ZipFile jarFile = null ; InputStream manifestStream = null ; try { jarFile = new ZipFile ( pathComponent ) ; manifestStream = jarFile . getInputStream ( new ZipEntry ( "META-INF/MANIFEST.MF" ) ) ; if ( manifestStream == null ) { return ; } Reader manifestReader = new InputStreamReader ( manifestStream , "UTF-8" ) ; org . apache . tools . ant . taskdefs . Manifest manifest = new org . apache . tools . ant . taskdefs . Manifest ( manifestReader ) ; classpath = manifest . getMainSection ( ) . getAttributeValue ( "Class-Path" ) ; } catch ( org . apache . tools . ant . taskdefs . ManifestException e ) { } finally { if ( manifestStream != null ) { manifestStream . close ( ) ; } if ( jarFile != null ) { jarFile . close ( ) ; } } if ( classpath == null ) { classpath = "" ; } pathMap . put ( absPathPlusTimeAndLength , classpath ) ; } if ( ! "" . equals ( classpath ) ) { URL baseURL = FILE_UTILS . getFileURL ( pathComponent ) ; StringTokenizer st = new StringTokenizer ( classpath ) ; while ( st . hasMoreTokens ( ) ) { String classpathElement = st . nextToken ( ) ; URL libraryURL = new URL ( baseURL , classpathElement ) ; if ( ! libraryURL . getProtocol ( ) . equals ( "file" ) ) { log ( "Skipping jar library " + classpathElement + " since only relative URLs are supported by this" + " loader" , Project . MSG_VERBOSE ) ; continue ; } String decodedPath = Locator . decodeUri ( libraryURL . getFile ( ) ) ; File libraryFile = new File ( decodedPath ) ; if ( libraryFile . exists ( ) && ! isInPath ( libraryFile ) ) { addPathFile ( libraryFile ) ; } } } } public String getClasspath ( ) { StringBuffer sb = new StringBuffer ( ) ; boolean firstPass = true ; Enumeration componentEnum = pathComponents . elements ( ) ; while ( componentEnum . hasMoreElements ( ) ) { if ( ! firstPass ) { sb . append ( System . getProperty ( "path.separator" ) ) ; } else { firstPass = false ; } sb . append ( ( ( File ) componentEnum . nextElement ( ) ) . getAbsolutePath ( ) ) ; } return sb . toString ( ) ; } public synchronized void setIsolated ( boolean isolated ) { ignoreBase = isolated ; } public static void initializeClass ( Class theClass ) { final Constructor [ ] cons = theClass . getDeclaredConstructors ( ) ; if ( cons != null ) { if ( cons . length > 0 && cons [ 0 ] != null ) { final String [ ] strs = new String [ NUMBER_OF_STRINGS ] ; try { cons [ 0 ] . newInstance ( ( Object [ ] ) strs ) ; } catch ( Exception e ) { } } } } public void addSystemPackageRoot ( String packageRoot ) { systemPackages . addElement ( packageRoot + ( packageRoot . endsWith ( "." ) ? "" : "." ) ) ; } public void addLoaderPackageRoot ( String packageRoot ) { loaderPackages . addElement ( packageRoot + ( packageRoot . endsWith ( "." ) ? "" : "." ) ) ; } public Class forceLoadClass ( String classname ) throws ClassNotFoundException { log ( "force loading " + classname , Project . MSG_DEBUG ) ; Class theClass = findLoadedClass ( classname ) ; if ( theClass == null ) { theClass = findClass ( classname ) ; } return theClass ; } public Class forceLoadSystemClass ( String classname ) throws ClassNotFoundException { log ( "force system loading " + classname , Project . MSG_DEBUG ) ; Class theClass = findLoadedClass ( classname ) ; if ( theClass == null ) { theClass = findBaseClass ( classname ) ; } return theClass ; } public InputStream getResourceAsStream ( String name ) { InputStream resourceStream = null ; if ( isParentFirst ( name ) ) { resourceStream = loadBaseResource ( name ) ; if ( resourceStream != null ) { log ( "ResourceStream for " + name + " loaded from parent loader" , Project . MSG_DEBUG ) ; } else { resourceStream = loadResource ( name ) ; if ( resourceStream != null ) { log ( "ResourceStream for " + name + " loaded from ant loader" , Project . MSG_DEBUG ) ; } } } else { resourceStream = loadResource ( name ) ; if ( resourceStream != null ) { log ( "ResourceStream for " + name + " loaded from ant loader" , Project . MSG_DEBUG ) ; } else { resourceStream = loadBaseResource ( name ) ; if ( resourceStream != null ) { log ( "ResourceStream for " + name + " loaded from parent loader" , Project . MSG_DEBUG ) ; } } } if ( resourceStream == null ) { log ( "Couldn't load ResourceStream for " + name , Project . MSG_DEBUG ) ; } return resourceStream ; } private InputStream loadResource ( String name ) { InputStream stream = null ; Enumeration e = pathComponents . elements ( ) ; while ( e . hasMoreElements ( ) && stream == null ) { File pathComponent = ( File ) e . nextElement ( ) ; stream = getResourceStream ( pathComponent , name ) ; } return stream ; } private InputStream loadBaseResource ( String name ) { if ( parent == null ) { return getSystemResourceAsStream ( name ) ; } else { return parent . getResourceAsStream ( name ) ; } } private InputStream getResourceStream ( File file , String resourceName ) { try { if ( ! file . exists ( ) ) { return null ; } if ( file . isDirectory ( ) ) { File resource = new File ( file , resourceName ) ; if ( resource . exists ( ) ) { return new FileInputStream ( resource ) ; } } else { ZipFile zipFile = ( ZipFile ) zipFiles . get ( file ) ; if ( zipFile == null ) { zipFile = new ZipFile ( file ) ; zipFiles . put ( file , zipFile ) ; } ZipEntry entry = zipFile . getEntry ( resourceName ) ; if ( entry != null ) { return zipFile . getInputStream ( entry ) ; } } } catch ( Exception e ) { log ( "Ignoring Exception " + e . getClass ( ) . getName ( ) + ": " + e . getMessage ( ) + " reading resource " + resourceName + " from " + file , Project . MSG_VERBOSE ) ; } return null ; } private boolean isParentFirst ( String resourceName ) { boolean useParentFirst = parentFirst ; for ( Enumeration e = systemPackages . elements ( ) ; e . hasMoreElements ( ) ; ) { String packageName = ( String ) e . nextElement ( ) ; if ( resourceName . startsWith ( packageName ) ) { useParentFirst = true ; break ; } } for ( Enumeration e = loaderPackages . elements ( ) ; e . hasMoreElements ( ) ; ) { String packageName = ( String ) e . nextElement ( ) ; if ( resourceName . startsWith ( packageName ) ) { useParentFirst = false ; break ; } } return useParentFirst ; } private ClassLoader getRootLoader ( ) { ClassLoader ret = getClass ( ) . getClassLoader ( ) ; while ( ret != null && ret . getParent ( ) != null ) { ret = ret . getParent ( ) ; } return ret ; } public URL getResource ( String name ) { URL url = null ; if ( isParentFirst ( name ) ) { url = ( parent == null ) ? super . getResource ( name ) : parent . getResource ( name ) ; } if ( url != null ) { log ( "Resource " + name + " loaded from parent loader" , Project . MSG_DEBUG ) ; } else { Enumeration e = pathComponents . elements ( ) ; while ( e . hasMoreElements ( ) && url == null ) { File pathComponent = ( File ) e . nextElement ( ) ; url = getResourceURL ( pathComponent , name ) ; if ( url != null ) { log ( "Resource " + name + " loaded from ant loader" , Project . MSG_DEBUG ) ; } } } if ( url == null && ! isParentFirst ( name ) ) { if ( ignoreBase ) { url = ( getRootLoader ( ) == null ) ? null : getRootLoader ( ) . getResource ( name ) ; } else { url = ( parent == null ) ? super . getResource ( name ) : parent . getResource ( name ) ; } if ( url != null ) { log ( "Resource " + name + " loaded from parent loader" , Project . MSG_DEBUG ) ; } } if ( url == null ) { log ( "Couldn't load Resource " + name , Project . MSG_DEBUG ) ; } return url ; } protected Enumeration findResources ( String name ) throws IOException { Enumeration mine = new ResourceEnumeration ( name ) ; Enumeration base ; if ( parent != null && parent != getParent ( ) ) { base = parent . getResources ( name ) ; } else { base = new CollectionUtils . EmptyEnumeration ( ) ; } if ( isParentFirst ( name ) ) { return CollectionUtils . append ( base , mine ) ; } else if ( ignoreBase ) { return getRootLoader ( ) == null ? mine : CollectionUtils . append ( mine , getRootLoader ( ) . getResources ( name ) ) ; } else { return CollectionUtils . append ( mine , base ) ; } } protected URL getResourceURL ( File file , String resourceName ) { try { if ( ! file . exists ( ) ) { return null ; } if ( file . isDirectory ( ) ) { File resource = new File ( file , resourceName ) ; if ( resource . exists ( ) ) { try { return FILE_UTILS . getFileURL ( resource ) ; } catch ( MalformedURLException ex ) { return null ; } } } else { ZipFile zipFile = ( ZipFile ) zipFiles . get ( file ) ; if ( zipFile == null ) { zipFile = new ZipFile ( file ) ; zipFiles . put ( file , zipFile ) ; } ZipEntry entry = zipFile . getEntry ( resourceName ) ; if ( entry != null ) { try { return new URL ( "jar:" + FILE_UTILS . getFileURL ( file ) + "!/" + entry ) ; } catch ( MalformedURLException ex ) { return null ; } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; } protected synchronized Class loadClass ( String classname , boolean resolve ) throws ClassNotFoundException { Class theClass = findLoadedClass ( classname ) ; if ( theClass != null ) { return theClass ; } if ( isParentFirst ( classname ) ) { try { theClass = findBaseClass ( classname ) ; log ( "Class " + classname + " loaded from parent loader " + "(parentFirst)" , Project . MSG_DEBUG ) ; } catch ( ClassNotFoundException cnfe ) { theClass = findClass ( classname ) ; log ( "Class " + classname + " loaded from ant loader " + "(parentFirst)" , Project . MSG_DEBUG ) ; } } else { try { theClass = findClass ( classname ) ; log ( "Class " + classname + " loaded from ant loader" , Project . MSG_DEBUG ) ; } catch ( ClassNotFoundException cnfe ) { if ( ignoreBase ) { throw cnfe ; } theClass = findBaseClass ( classname ) ; log ( "Class " + classname + " loaded from parent loader" , Project . MSG_DEBUG ) ; } } if ( resolve ) { resolveClass ( theClass ) ; } return theClass ; } private String getClassFilename ( String classname ) { return classname . replace ( '.' , '/' ) + ".class" ; } protected Class defineClassFromData ( File container , byte [ ] classData , String classname ) throws IOException { definePackage ( container , classname ) ; return defineClass ( classname , classData , 0 , classData . length , Project . class . getProtectionDomain ( ) ) ; } protected void definePackage ( File container , String className ) throws IOException { int classIndex = className . lastIndexOf ( '.' ) ; if ( classIndex == - 1 ) { return ; } String packageName = className . substring ( 0 , classIndex ) ; if ( getPackage ( packageName ) != null ) { return ; } Manifest manifest = getJarManifest ( container ) ; if ( manifest == null ) { definePackage ( packageName , null , null , null , null , null , null , null ) ; } else { definePackage ( container , packageName , manifest ) ; } } private Manifest getJarManifest ( File container ) throws IOException { if ( container . isDirectory ( ) ) { return null ; } JarFile jarFile = null ; try { jarFile = new JarFile ( container ) ; return jarFile . getManifest ( ) ; } finally { if ( jarFile != null ) { jarFile . close ( ) ; } } } protected void definePackage ( File container , String packageName , Manifest manifest ) { String sectionName = packageName . replace ( '.' , '/' ) + "/" ; String specificationTitle = null ; String specificationVendor = null ; String specificationVersion = null ; String implementationTitle = null ; String implementationVendor = null ; String implementationVersion = null ; String sealedString = null ; URL sealBase = null ; Attributes sectionAttributes = manifest . getAttributes ( sectionName ) ; if ( sectionAttributes != null ) { specificationTitle = sectionAttributes . getValue ( Name . SPECIFICATION_TITLE ) ; specificationVendor = sectionAttributes . getValue ( Name . SPECIFICATION_VENDOR ) ; specificationVersion = sectionAttributes . getValue ( Name . SPECIFICATION_VERSION ) ; implementationTitle = sectionAttributes . getValue ( Name . IMPLEMENTATION_TITLE ) ; implementationVendor = sectionAttributes . getValue ( Name . IMPLEMENTATION_VENDOR ) ; implementationVersion = sectionAttributes . getValue ( Name . IMPLEMENTATION_VERSION ) ; sealedString = sectionAttributes . getValue ( Name . SEALED ) ; } Attributes mainAttributes = manifest . getMainAttributes ( ) ; if ( mainAttributes != null ) { if ( specificationTitle == null ) { specificationTitle = mainAttributes . getValue ( Name . SPECIFICATION_TITLE ) ; } if ( specificationVendor == null ) { specificationVendor = mainAttributes . getValue ( Name . SPECIFICATION_VENDOR ) ; } if ( specificationVersion == null ) { specificationVersion = mainAttributes . getValue ( Name . SPECIFICATION_VERSION ) ; } if ( implementationTitle == null ) { implementationTitle = mainAttributes . getValue ( Name . IMPLEMENTATION_TITLE ) ; } if ( implementationVendor == null ) { implementationVendor = mainAttributes . getValue ( Name . IMPLEMENTATION_VENDOR ) ; } if ( implementationVersion == null ) { implementationVersion = mainAttributes . getValue ( Name . IMPLEMENTATION_VERSION ) ; } if ( sealedString == null ) { sealedString = mainAttributes . getValue ( Name . SEALED ) ; } } if ( sealedString != null && sealedString . equalsIgnoreCase ( "true" ) ) { try { sealBase = new URL ( FileUtils . getFileUtils ( ) . toURI ( container . getAbsolutePath ( ) ) ) ; } catch ( MalformedURLException e ) { } } definePackage ( packageName , specificationTitle , specificationVersion , specificationVendor , implementationTitle , implementationVersion , implementationVendor , sealBase ) ; } private Class getClassFromStream ( InputStream stream , String classname , File container ) throws IOException , SecurityException { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; int bytesRead = - 1 ; byte [ ] buffer = new byte [ BUFFER_SIZE ] ; while ( ( bytesRead = stream . read ( buffer , 0 , BUFFER_SIZE ) ) != - 1 ) { baos . write ( buffer , 0 , bytesRead ) ; } byte [ ] classData = baos . toByteArray ( ) ; return defineClassFromData ( container , classData , classname ) ; } public Class findClass ( String name ) throws ClassNotFoundException { log ( "Finding class " + name , Project . MSG_DEBUG ) ; return findClassInComponents ( name ) ; } protected boolean isInPath ( File component ) { for ( Enumeration e = pathComponents . elements ( ) ; e . hasMoreElements ( ) ; ) { File pathComponent = ( File ) e . nextElement ( ) ; if ( pathComponent . equals ( component ) ) { return true ; } } return false ; } private Class findClassInComponents ( String name ) throws ClassNotFoundException { InputStream stream = null ; String classFilename = getClassFilename ( name ) ; try { Enumeration e = pathComponents . elements ( ) ; while ( e . hasMoreElements ( ) ) { File pathComponent = ( File ) e . nextElement ( ) ; try { stream = getResourceStream ( pathComponent , classFilename ) ; if ( stream != null ) { log ( "Loaded from " + pathComponent + " " + classFilename , Project . MSG_DEBUG ) ; return getClassFromStream ( stream , name , pathComponent ) ; } } catch ( SecurityException se ) { throw se ; } catch ( IOException ioe ) { log ( "Exception reading component " + pathComponent + " (reason: " + ioe . getMessage ( ) + ")" , Project . MSG_VERBOSE ) ; } } throw new ClassNotFoundException ( name ) ; } finally { try { if ( stream != null ) { stream . close ( ) ; } } catch ( IOException e ) { } } } private Class findBaseClass ( String name ) throws ClassNotFoundException { if ( parent == null ) { return findSystemClass ( name ) ; } else { return parent . loadClass ( name ) ; } } public synchronized void cleanup ( ) { for ( Enumeration e = zipFiles . elements ( ) ; e . hasMoreElements ( ) ; ) { ZipFile zipFile = ( ZipFile ) e . nextElement ( ) ; try { zipFile . close ( ) ; } catch ( IOException ioe ) { } } zipFiles = new Hashtable ( ) ; if ( project != null ) { project . removeBuildListener ( this ) ; } project = null ; } public void buildStarted ( BuildEvent event ) { } public void buildFinished ( BuildEvent event ) { cleanup ( ) ; } public void subBuildFinished ( BuildEvent event ) { if ( event . getProject ( ) == project ) { cleanup ( ) ; } } public void subBuildStarted ( BuildEvent event ) { } public void targetStarted ( BuildEvent event ) { } public void targetFinished ( BuildEvent event ) { } public void taskStarted ( BuildEvent event ) { } public void taskFinished ( BuildEvent event ) { } public void messageLogged ( BuildEvent event ) { } public void addJavaLibraries ( ) { Vector packages = JavaEnvUtils . getJrePackages ( ) ; Enumeration e = packages . elements ( ) ; while ( e . hasMoreElements ( ) ) { String packageName = ( String ) e . nextElement ( ) ; addSystemPackageRoot ( packageName ) ; } } public String toString ( ) { return "AntClassLoader[" + getClasspath ( ) + "]" ; } } 	1	['56', '2', '2', '51', '169', '1200', '37', '16', '35', '0.848863636', '1842', '0.875', '2', '0.409638554', '0.155844156', '1', '5', '31.60714286', '14', '2.1964', '6']
package org . apache . tools . ant . taskdefs . optional . windows ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . ExecuteOn ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . FileSet ; import java . io . File ; public class Attrib extends ExecuteOn { private static final String ATTR_READONLY = "R" ; private static final String ATTR_ARCHIVE = "A" ; private static final String ATTR_SYSTEM = "S" ; private static final String ATTR_HIDDEN = "H" ; private static final String SET = "+" ; private static final String UNSET = "-" ; private boolean haveAttr = false ; public Attrib ( ) { super . setExecutable ( "attrib" ) ; super . setParallel ( false ) ; } public void setFile ( File src ) { FileSet fs = new FileSet ( ) ; fs . setFile ( src ) ; addFileset ( fs ) ; } public void setReadonly ( boolean value ) { addArg ( value , ATTR_READONLY ) ; } public void setArchive ( boolean value ) { addArg ( value , ATTR_ARCHIVE ) ; } public void setSystem ( boolean value ) { addArg ( value , ATTR_SYSTEM ) ; } public void setHidden ( boolean value ) { addArg ( value , ATTR_HIDDEN ) ; } protected void checkConfiguration ( ) { if ( ! haveAttr ( ) ) { throw new BuildException ( "Missing attribute parameter" , getLocation ( ) ) ; } super . checkConfiguration ( ) ; } public void setExecutable ( String e ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the executable attribute" , getLocation ( ) ) ; } public void setCommand ( String e ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the command attribute" , getLocation ( ) ) ; } public void setAddsourcefile ( boolean b ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the addsourcefile attribute" , getLocation ( ) ) ; } public void setSkipEmptyFilesets ( boolean skip ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the " + "skipemptyfileset attribute" , getLocation ( ) ) ; } public void setParallel ( boolean parallel ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the parallel attribute" , getLocation ( ) ) ; } public void setMaxParallel ( int max ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the maxparallel attribute" , getLocation ( ) ) ; } protected boolean isValidOs ( ) { return Os . isFamily ( "windows" ) && super . isValidOs ( ) ; } private static String getSignString ( boolean attr ) { return ( attr ? SET : UNSET ) ; } private void addArg ( boolean sign , String attribute ) { createArg ( ) . setValue ( getSignString ( sign ) + attribute ) ; haveAttr = true ; } private boolean haveAttr ( ) { return haveAttr ; } } 	1	['17', '5', '0', '6', '35', '130', '0', '6', '12', '0.991071429', '207', '1', '0', '0.869918699', '0.352941176', '2', '3', '10.76470588', '3', '1.1765', '1']
package org . apache . tools . ant . taskdefs . optional . ssh ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . TeeOutputStream ; import org . apache . tools . ant . util . KeepAliveOutputStream ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . StringReader ; import com . jcraft . jsch . ChannelExec ; import com . jcraft . jsch . JSchException ; import com . jcraft . jsch . Session ; public class SSHExec extends SSHBase { private String command = null ; private long maxwait = 0 ; private Thread thread = null ; private String outputProperty = null ; private File outputFile = null ; private boolean append = false ; private static final String TIMEOUT_MESSAGE = "Timeout period exceeded, connection dropped." ; public SSHExec ( ) { super ( ) ; } public void setCommand ( String command ) { this . command = command ; } public void setTimeout ( long timeout ) { maxwait = timeout ; } public void setOutput ( File output ) { outputFile = output ; } public void setAppend ( boolean append ) { this . append = append ; } public void setOutputproperty ( String property ) { outputProperty = property ; } public void execute ( ) throws BuildException { if ( getHost ( ) == null ) { throw new BuildException ( "Host is required." ) ; } if ( getUserInfo ( ) . getName ( ) == null ) { throw new BuildException ( "Username is required." ) ; } if ( getUserInfo ( ) . getKeyfile ( ) == null && getUserInfo ( ) . getPassword ( ) == null ) { throw new BuildException ( "Password or Keyfile is required." ) ; } if ( command == null ) { throw new BuildException ( "Command is required." ) ; } ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; TeeOutputStream tee = new TeeOutputStream ( out , new KeepAliveOutputStream ( System . out ) ) ; Session session = null ; try { session = openSession ( ) ; session . setTimeout ( ( int ) maxwait ) ; final ChannelExec channel = ( ChannelExec ) session . openChannel ( "exec" ) ; channel . setCommand ( command ) ; channel . setOutputStream ( tee ) ; channel . setExtOutputStream ( tee ) ; channel . connect ( ) ; thread = new Thread ( ) { public void run ( ) { while ( ! channel . isEOF ( ) ) { if ( thread == null ) { return ; } try { sleep ( 500 ) ; } catch ( Exception e ) { } } } } ; thread . start ( ) ; thread . join ( maxwait ) ; if ( thread . isAlive ( ) ) { thread = null ; if ( getFailonerror ( ) ) { throw new BuildException ( TIMEOUT_MESSAGE ) ; } else { log ( TIMEOUT_MESSAGE , Project . MSG_ERR ) ; } } else { if ( outputProperty != null ) { getProject ( ) . setProperty ( outputProperty , out . toString ( ) ) ; } if ( outputFile != null ) { writeToFile ( out . toString ( ) , append , outputFile ) ; } int ec = channel . getExitStatus ( ) ; if ( ec != 0 ) { String msg = "Remote command failed with exit status " + ec ; if ( getFailonerror ( ) ) { throw new BuildException ( msg ) ; } else { log ( msg , Project . MSG_ERR ) ; } } } } catch ( BuildException e ) { throw e ; } catch ( JSchException e ) { if ( e . getMessage ( ) . indexOf ( "session is down" ) >= 0 ) { if ( getFailonerror ( ) ) { throw new BuildException ( TIMEOUT_MESSAGE , e ) ; } else { log ( TIMEOUT_MESSAGE , Project . MSG_ERR ) ; } } else { if ( getFailonerror ( ) ) { throw new BuildException ( e ) ; } else { log ( "Caught exception: " + e . getMessage ( ) , Project . MSG_ERR ) ; } } } catch ( Exception e ) { if ( getFailonerror ( ) ) { throw new BuildException ( e ) ; } else { log ( "Caught exception: " + e . getMessage ( ) , Project . MSG_ERR ) ; } } finally { if ( session != null && session . isConnected ( ) ) { session . disconnect ( ) ; } } } private void writeToFile ( String from , boolean append , File to ) throws IOException { FileWriter out = null ; try { out = new FileWriter ( to . getAbsolutePath ( ) , append ) ; StringReader in = new StringReader ( from ) ; char [ ] buffer = new char [ 8192 ] ; int bytesRead ; while ( true ) { bytesRead = in . read ( buffer ) ; if ( bytesRead == - 1 ) { break ; } out . write ( buffer , 0 , bytesRead ) ; } out . flush ( ) ; } finally { if ( out != null ) { out . close ( ) ; } } } } 	1	['9', '4', '0', '11', '54', '10', '1', '11', '7', '0.803571429', '345', '1', '0', '0.870967742', '0.314814815', '1', '1', '36.55555556', '1', '0.8889', '4']
package org . apache . tools . zip ; import java . util . Vector ; import java . util . zip . ZipException ; public class ZipEntry extends java . util . zip . ZipEntry implements Cloneable { private static final int PLATFORM_UNIX = 3 ; private static final int PLATFORM_FAT = 0 ; private int internalAttributes = 0 ; private int platform = PLATFORM_FAT ; private long externalAttributes = 0 ; private Vector extraFields = null ; private String name = null ; public ZipEntry ( String name ) { super ( name ) ; } public ZipEntry ( java . util . zip . ZipEntry entry ) throws ZipException { super ( entry ) ; byte [ ] extra = entry . getExtra ( ) ; if ( extra != null ) { setExtraFields ( ExtraFieldUtils . parse ( extra ) ) ; } else { setExtra ( ) ; } } public ZipEntry ( ZipEntry entry ) throws ZipException { this ( ( java . util . zip . ZipEntry ) entry ) ; setInternalAttributes ( entry . getInternalAttributes ( ) ) ; setExternalAttributes ( entry . getExternalAttributes ( ) ) ; setExtraFields ( entry . getExtraFields ( ) ) ; } protected ZipEntry ( ) { super ( "" ) ; } public Object clone ( ) { ZipEntry e = ( ZipEntry ) super . clone ( ) ; e . extraFields = extraFields != null ? ( Vector ) extraFields . clone ( ) : null ; e . setInternalAttributes ( getInternalAttributes ( ) ) ; e . setExternalAttributes ( getExternalAttributes ( ) ) ; e . setExtraFields ( getExtraFields ( ) ) ; return e ; } public int getInternalAttributes ( ) { return internalAttributes ; } public void setInternalAttributes ( int value ) { internalAttributes = value ; } public long getExternalAttributes ( ) { return externalAttributes ; } public void setExternalAttributes ( long value ) { externalAttributes = value ; } public void setUnixMode ( int mode ) { setExternalAttributes ( ( mode << 16 ) | ( ( mode & 0200 ) == 0 ? 1 : 0 ) | ( isDirectory ( ) ? 0x10 : 0 ) ) ; platform = PLATFORM_UNIX ; } public int getUnixMode ( ) { return ( int ) ( ( getExternalAttributes ( ) > > 16 ) & 0xFFFF ) ; } public int getPlatform ( ) { return platform ; } protected void setPlatform ( int platform ) { this . platform = platform ; } public void setExtraFields ( ZipExtraField [ ] fields ) { extraFields = new Vector ( ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { extraFields . addElement ( fields [ i ] ) ; } setExtra ( ) ; } public ZipExtraField [ ] getExtraFields ( ) { if ( extraFields == null ) { return new ZipExtraField [ 0 ] ; } ZipExtraField [ ] result = new ZipExtraField [ extraFields . size ( ) ] ; extraFields . copyInto ( result ) ; return result ; } public void addExtraField ( ZipExtraField ze ) { if ( extraFields == null ) { extraFields = new Vector ( ) ; } ZipShort type = ze . getHeaderId ( ) ; boolean done = false ; for ( int i = 0 , fieldsSize = extraFields . size ( ) ; ! done && i < fieldsSize ; i ++ ) { if ( ( ( ZipExtraField ) extraFields . elementAt ( i ) ) . getHeaderId ( ) . equals ( type ) ) { extraFields . setElementAt ( ze , i ) ; done = true ; } } if ( ! done ) { extraFields . addElement ( ze ) ; } setExtra ( ) ; } public void removeExtraField ( ZipShort type ) { if ( extraFields == null ) { extraFields = new Vector ( ) ; } boolean done = false ; for ( int i = 0 , fieldsSize = extraFields . size ( ) ; ! done && i < fieldsSize ; i ++ ) { if ( ( ( ZipExtraField ) extraFields . elementAt ( i ) ) . getHeaderId ( ) . equals ( type ) ) { extraFields . removeElementAt ( i ) ; done = true ; } } if ( ! done ) { throw new java . util . NoSuchElementException ( ) ; } setExtra ( ) ; } public void setExtra ( byte [ ] extra ) throws RuntimeException { try { setExtraFields ( ExtraFieldUtils . parse ( extra ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e . getMessage ( ) ) ; } } protected void setExtra ( ) { super . setExtra ( ExtraFieldUtils . mergeLocalFileDataData ( getExtraFields ( ) ) ) ; } public byte [ ] getLocalFileDataExtra ( ) { byte [ ] extra = getExtra ( ) ; return extra != null ? extra : new byte [ 0 ] ; } public byte [ ] getCentralDirectoryExtra ( ) { return ExtraFieldUtils . mergeCentralDirectoryData ( getExtraFields ( ) ) ; } public void setComprSize ( long size ) { setCompressedSize ( size ) ; } public String getName ( ) { return name == null ? super . getName ( ) : name ; } public boolean isDirectory ( ) { return getName ( ) . endsWith ( "/" ) ; } protected void setName ( String name ) { this . name = name ; } public int hashCode ( ) { return getName ( ) . hashCode ( ) ; } public boolean equals ( Object o ) { return ( this == o ) ; } } 	1	['27', '2', '0', '11', '53', '229', '8', '3', '23', '0.802197802', '405', '1', '0', '0.5', '0.138047138', '1', '1', '13.74074074', '6', '1.5185', '1']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedInputStream ; import java . io . ByteArrayInputStream ; import java . io . File ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . Reader ; import java . util . Properties ; import java . util . Vector ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . filters . util . ChainReaderHelper ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . FilterChain ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . JavaResource ; import org . apache . tools . ant . util . FileUtils ; public class LoadProperties extends Task { private Resource src = null ; private final Vector filterChains = new Vector ( ) ; private String encoding = null ; public final void setSrcFile ( final File srcFile ) { addConfigured ( new FileResource ( srcFile ) ) ; } public void setResource ( String resource ) { assertSrcIsJavaResource ( ) ; ( ( JavaResource ) src ) . setName ( resource ) ; } public final void setEncoding ( final String encoding ) { this . encoding = encoding ; } public void setClasspath ( Path classpath ) { assertSrcIsJavaResource ( ) ; ( ( JavaResource ) src ) . setClasspath ( classpath ) ; } public Path createClasspath ( ) { assertSrcIsJavaResource ( ) ; return ( ( JavaResource ) src ) . createClasspath ( ) ; } public void setClasspathRef ( Reference r ) { assertSrcIsJavaResource ( ) ; ( ( JavaResource ) src ) . setClasspathRef ( r ) ; } public Path getClasspath ( ) { assertSrcIsJavaResource ( ) ; return ( ( JavaResource ) src ) . getClasspath ( ) ; } public final void execute ( ) throws BuildException { if ( src == null ) { throw new BuildException ( "A source resource is required." ) ; } if ( ! src . isExists ( ) ) { if ( src instanceof JavaResource ) { log ( "Unable to find resource " + src , Project . MSG_WARN ) ; return ; } throw new BuildException ( "Source resource does not exist: " + src ) ; } BufferedInputStream bis = null ; Reader instream = null ; ByteArrayInputStream tis = null ; try { bis = new BufferedInputStream ( src . getInputStream ( ) ) ; if ( encoding == null ) { instream = new InputStreamReader ( bis ) ; } else { instream = new InputStreamReader ( bis , encoding ) ; } ChainReaderHelper crh = new ChainReaderHelper ( ) ; crh . setPrimaryReader ( instream ) ; crh . setFilterChains ( filterChains ) ; crh . setProject ( getProject ( ) ) ; instream = crh . getAssembledReader ( ) ; String text = crh . readFully ( instream ) ; if ( text != null ) { if ( ! text . endsWith ( "\n" ) ) { text = text + "\n" ; } if ( encoding == null ) { tis = new ByteArrayInputStream ( text . getBytes ( ) ) ; } else { tis = new ByteArrayInputStream ( text . getBytes ( encoding ) ) ; } final Properties props = new Properties ( ) ; props . load ( tis ) ; Property propertyTask = new Property ( ) ; propertyTask . bindToOwner ( this ) ; propertyTask . addProperties ( props ) ; } } catch ( final IOException ioe ) { final String message = "Unable to load file: " + ioe . toString ( ) ; throw new BuildException ( message , ioe , getLocation ( ) ) ; } finally { FileUtils . close ( bis ) ; FileUtils . close ( tis ) ; } } public final void addFilterChain ( FilterChain filter ) { filterChains . addElement ( filter ) ; } public void addConfigured ( ResourceCollection a ) { if ( src != null ) { throw new BuildException ( "only a single source is supported" ) ; } if ( a . size ( ) != 1 ) { throw new BuildException ( "only single argument resource collections" + " are supported" ) ; } src = ( Resource ) a . iterator ( ) . next ( ) ; } private void assertSrcIsJavaResource ( ) { if ( src == null ) { src = new JavaResource ( ) ; src . setProject ( getProject ( ) ) ; } else if ( ! ( src instanceof JavaResource ) ) { throw new BuildException ( "expected a java resource as source" ) ; } } } 	1	['12', '3', '0', '14', '58', '0', '0', '14', '11', '0.606060606', '303', '1', '1', '0.770833333', '0.226190476', '2', '3', '24', '3', '1.25', '1']
package org . apache . tools . ant . taskdefs . optional ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileReader ; import java . io . FileOutputStream ; import java . io . FileWriter ; import java . io . InputStreamReader ; import java . io . IOException ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . Reader ; import java . io . Writer ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . RegularExpression ; import org . apache . tools . ant . types . Substitution ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . regexp . Regexp ; public class ReplaceRegExp extends Task { private File file ; private String flags ; private boolean byline ; private Vector filesets ; private RegularExpression regex ; private Substitution subs ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private String encoding = null ; public ReplaceRegExp ( ) { super ( ) ; this . file = null ; this . filesets = new Vector ( ) ; this . flags = "" ; this . byline = false ; this . regex = null ; this . subs = null ; } public void setFile ( File file ) { this . file = file ; } public void setMatch ( String match ) { if ( regex != null ) { throw new BuildException ( "Only one regular expression is allowed" ) ; } regex = new RegularExpression ( ) ; regex . setPattern ( match ) ; } public void setReplace ( String replace ) { if ( subs != null ) { throw new BuildException ( "Only one substitution expression is " + "allowed" ) ; } subs = new Substitution ( ) ; subs . setExpression ( replace ) ; } public void setFlags ( String flags ) { this . flags = flags ; } public void setByLine ( String byline ) { Boolean res = Boolean . valueOf ( byline ) ; if ( res == null ) { res = Boolean . FALSE ; } this . byline = res . booleanValue ( ) ; } public void setByLine ( boolean byline ) { this . byline = byline ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public RegularExpression createRegexp ( ) { if ( regex != null ) { throw new BuildException ( "Only one regular expression is allowed." ) ; } regex = new RegularExpression ( ) ; return regex ; } public Substitution createSubstitution ( ) { if ( subs != null ) { throw new BuildException ( "Only one substitution expression is " + "allowed" ) ; } subs = new Substitution ( ) ; return subs ; } protected String doReplace ( RegularExpression r , Substitution s , String input , int options ) { String res = input ; Regexp regexp = r . getRegexp ( getProject ( ) ) ; if ( regexp . matches ( input , options ) ) { log ( "Found match; substituting" , Project . MSG_DEBUG ) ; res = regexp . substitute ( input , s . getExpression ( getProject ( ) ) , options ) ; } return res ; } protected void doReplace ( File f , int options ) throws IOException { File temp = FILE_UTILS . createTempFile ( "replace" , ".txt" , null ) ; temp . deleteOnExit ( ) ; Reader r = null ; Writer w = null ; try { if ( encoding == null ) { r = new FileReader ( f ) ; w = new FileWriter ( temp ) ; } else { r = new InputStreamReader ( new FileInputStream ( f ) , encoding ) ; w = new OutputStreamWriter ( new FileOutputStream ( temp ) , encoding ) ; } BufferedReader br = new BufferedReader ( r ) ; BufferedWriter bw = new BufferedWriter ( w ) ; PrintWriter pw = new PrintWriter ( bw ) ; boolean changes = false ; log ( "Replacing pattern '" + regex . getPattern ( getProject ( ) ) + "' with '" + subs . getExpression ( getProject ( ) ) + "' in '" + f . getPath ( ) + "'" + ( byline ? " by line" : "" ) + ( flags . length ( ) > 0 ? " with flags: '" + flags + "'" : "" ) + "." , Project . MSG_VERBOSE ) ; if ( byline ) { StringBuffer linebuf = new StringBuffer ( ) ; String line = null ; String res = null ; int c ; boolean hasCR = false ; do { c = br . read ( ) ; if ( c == '\r' ) { if ( hasCR ) { line = linebuf . toString ( ) ; res = doReplace ( regex , subs , line , options ) ; if ( ! res . equals ( line ) ) { changes = true ; } pw . print ( res ) ; pw . print ( '\r' ) ; linebuf = new StringBuffer ( ) ; } else { hasCR = true ; } } else if ( c == '\n' ) { line = linebuf . toString ( ) ; res = doReplace ( regex , subs , line , options ) ; if ( ! res . equals ( line ) ) { changes = true ; } pw . print ( res ) ; if ( hasCR ) { pw . print ( '\r' ) ; hasCR = false ; } pw . print ( '\n' ) ; linebuf = new StringBuffer ( ) ; } else { if ( ( hasCR ) || ( c < 0 ) ) { line = linebuf . toString ( ) ; res = doReplace ( regex , subs , line , options ) ; if ( ! res . equals ( line ) ) { changes = true ; } pw . print ( res ) ; if ( hasCR ) { pw . print ( '\r' ) ; hasCR = false ; } linebuf = new StringBuffer ( ) ; } if ( c >= 0 ) { linebuf . append ( ( char ) c ) ; } } } while ( c >= 0 ) ; pw . flush ( ) ; } else { String buf = FileUtils . readFully ( br ) ; if ( buf == null ) { buf = "" ; } String res = doReplace ( regex , subs , buf , options ) ; if ( ! res . equals ( buf ) ) { changes = true ; } pw . print ( res ) ; pw . flush ( ) ; } r . close ( ) ; r = null ; w . close ( ) ; w = null ; if ( changes ) { log ( "File has changed; saving the updated file" , Project . MSG_VERBOSE ) ; try { FILE_UTILS . rename ( temp , f ) ; temp = null ; } catch ( IOException e ) { throw new BuildException ( "Couldn't rename temporary file " + temp , getLocation ( ) ) ; } } else { log ( "No change made" , Project . MSG_DEBUG ) ; } } finally { FileUtils . close ( r ) ; FileUtils . close ( w ) ; if ( temp != null ) { temp . delete ( ) ; } } } public void execute ( ) throws BuildException { if ( regex == null ) { throw new BuildException ( "No expression to match." ) ; } if ( subs == null ) { throw new BuildException ( "Nothing to replace expression with." ) ; } if ( file != null && filesets . size ( ) > 0 ) { throw new BuildException ( "You cannot supply the 'file' attribute " + "and filesets at the same time." ) ; } int options = 0 ; if ( flags . indexOf ( 'g' ) != - 1 ) { options |= Regexp . REPLACE_ALL ; } if ( flags . indexOf ( 'i' ) != - 1 ) { options |= Regexp . MATCH_CASE_INSENSITIVE ; } if ( flags . indexOf ( 'm' ) != - 1 ) { options |= Regexp . MATCH_MULTILINE ; } if ( flags . indexOf ( 's' ) != - 1 ) { options |= Regexp . MATCH_SINGLELINE ; } if ( file != null && file . exists ( ) ) { try { doReplace ( file , options ) ; } catch ( IOException e ) { log ( "An error occurred processing file: '" + file . getAbsolutePath ( ) + "': " + e . toString ( ) , Project . MSG_ERR ) ; } } else if ( file != null ) { log ( "The following file is missing: '" + file . getAbsolutePath ( ) + "'" , Project . MSG_ERR ) ; } int sz = filesets . size ( ) ; for ( int i = 0 ; i < sz ; i ++ ) { FileSet fs = ( FileSet ) ( filesets . elementAt ( i ) ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] files = ds . getIncludedFiles ( ) ; for ( int j = 0 ; j < files . length ; j ++ ) { File f = new File ( fs . getDir ( getProject ( ) ) , files [ j ] ) ; if ( f . exists ( ) ) { try { doReplace ( f , options ) ; } catch ( Exception e ) { log ( "An error occurred processing file: '" + f . getAbsolutePath ( ) + "': " + e . toString ( ) , Project . MSG_ERR ) ; } } else { log ( "The following file is missing: '" + f . getAbsolutePath ( ) + "'" , Project . MSG_ERR ) ; } } } } } 	1	['15', '3', '0', '10', '77', '41', '0', '10', '12', '0.785714286', '725', '1', '3', '0.74', '0.25', '1', '1', '46.8', '2', '1.2667', '3']
package org . apache . tools . ant . taskdefs . email ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . DateUtils ; public abstract class Mailer { protected String host = null ; protected int port = - 1 ; protected String user = null ; protected String password = null ; protected boolean SSL = false ; protected Message message ; protected EmailAddress from ; protected Vector replyToList = null ; protected Vector toList = null ; protected Vector ccList = null ; protected Vector bccList = null ; protected Vector files = null ; protected String subject = null ; protected Task task ; protected boolean includeFileNames = false ; protected Vector headers = null ; public void setHost ( String host ) { this . host = host ; } public void setPort ( int port ) { this . port = port ; } public void setUser ( String user ) { this . user = user ; } public void setPassword ( String password ) { this . password = password ; } public void setSSL ( boolean ssl ) { this . SSL = ssl ; } public void setMessage ( Message m ) { this . message = m ; } public void setFrom ( EmailAddress from ) { this . from = from ; } public void setReplyToList ( Vector list ) { this . replyToList = list ; } public void setToList ( Vector list ) { this . toList = list ; } public void setCcList ( Vector list ) { this . ccList = list ; } public void setBccList ( Vector list ) { this . bccList = list ; } public void setFiles ( Vector files ) { this . files = files ; } public void setSubject ( String subject ) { this . subject = subject ; } public void setTask ( Task task ) { this . task = task ; } public void setIncludeFileNames ( boolean b ) { this . includeFileNames = b ; } public void setHeaders ( Vector v ) { this . headers = v ; } public abstract void send ( ) throws BuildException ; protected final String getDate ( ) { return DateUtils . getDateForHeader ( ) ; } } 	1	['19', '1', '2', '9', '21', '145', '4', '5', '18', '0.954861111', '143', '1', '3', '0', '0.230263158', '0', '0', '5.684210526', '1', '0.9474', '1']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . FileResource ; public abstract class Pack extends Task { protected File zipFile ; protected File source ; private Resource src ; public void setZipfile ( File zipFile ) { this . zipFile = zipFile ; } public void setDestfile ( File zipFile ) { setZipfile ( zipFile ) ; } public void setSrc ( File src ) { setSrcResource ( new FileResource ( src ) ) ; } public void setSrcResource ( Resource src ) { if ( src . isDirectory ( ) ) { throw new BuildException ( "the source can't be a directory" ) ; } if ( src instanceof FileResource ) { source = ( ( FileResource ) src ) . getFile ( ) ; } else if ( ! supportsNonFileResources ( ) ) { throw new BuildException ( "Only FileSystem resources are" + " supported." ) ; } this . src = src ; } public void addConfigured ( ResourceCollection a ) { if ( a . size ( ) != 1 ) { throw new BuildException ( "only single argument resource collections" + " are supported as archives" ) ; } setSrcResource ( ( Resource ) a . iterator ( ) . next ( ) ) ; } private void validate ( ) throws BuildException { if ( zipFile == null ) { throw new BuildException ( "zipfile attribute is required" , getLocation ( ) ) ; } if ( zipFile . isDirectory ( ) ) { throw new BuildException ( "zipfile attribute must not " + "represent a directory!" , getLocation ( ) ) ; } if ( getSrcResource ( ) == null ) { throw new BuildException ( "src attribute or nested resource is" + " required" , getLocation ( ) ) ; } } public void execute ( ) throws BuildException { validate ( ) ; Resource s = getSrcResource ( ) ; if ( ! s . isExists ( ) ) { log ( "Nothing to do: " + s . toString ( ) + " doesn't exist." ) ; } else if ( zipFile . lastModified ( ) < s . getLastModified ( ) ) { log ( "Building: " + zipFile . getAbsolutePath ( ) ) ; pack ( ) ; } else { log ( "Nothing to do: " + zipFile . getAbsolutePath ( ) + " is up to date." ) ; } } private void zipFile ( InputStream in , OutputStream zOut ) throws IOException { byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { zOut . write ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } protected void zipFile ( File file , OutputStream zOut ) throws IOException { zipResource ( new FileResource ( file ) , zOut ) ; } protected void zipResource ( Resource resource , OutputStream zOut ) throws IOException { InputStream rIn = resource . getInputStream ( ) ; try { zipFile ( rIn , zOut ) ; } finally { rIn . close ( ) ; } } protected abstract void pack ( ) ; public Resource getSrcResource ( ) { return src ; } protected boolean supportsNonFileResources ( ) { return false ; } } 	1	['14', '3', '2', '8', '38', '83', '2', '6', '8', '0.743589744', '220', '1', '1', '0.74', '0.297619048', '1', '1', '14.5', '4', '1.2143', '2']
package org . apache . tools . ant . types . resources ; import java . io . File ; import java . util . Vector ; import java . util . Iterator ; import java . util . Collections ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . types . PatternSet ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . selectors . FileSelector ; import org . apache . tools . ant . types . selectors . AbstractSelectorContainer ; public class Files extends AbstractSelectorContainer implements Cloneable , ResourceCollection { private static final Iterator EMPTY_ITERATOR = Collections . EMPTY_SET . iterator ( ) ; private PatternSet defaultPatterns = new PatternSet ( ) ; private Vector additionalPatterns = new Vector ( ) ; private Vector selectors = new Vector ( ) ; private boolean useDefaultExcludes = true ; private boolean caseSensitive = true ; private boolean followSymlinks = true ; private DirectoryScanner ds = null ; public Files ( ) { super ( ) ; } protected Files ( Files f ) { this . defaultPatterns = f . defaultPatterns ; this . additionalPatterns = f . additionalPatterns ; this . selectors = f . selectors ; this . useDefaultExcludes = f . useDefaultExcludes ; this . caseSensitive = f . caseSensitive ; this . followSymlinks = f . followSymlinks ; this . ds = f . ds ; setProject ( f . getProject ( ) ) ; } public void setRefid ( Reference r ) throws BuildException { if ( hasPatterns ( defaultPatterns ) ) { throw tooManyAttributes ( ) ; } if ( ! additionalPatterns . isEmpty ( ) ) { throw noChildrenAllowed ( ) ; } if ( ! selectors . isEmpty ( ) ) { throw noChildrenAllowed ( ) ; } super . setRefid ( r ) ; } public synchronized PatternSet createPatternSet ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } PatternSet patterns = new PatternSet ( ) ; additionalPatterns . addElement ( patterns ) ; ds = null ; return patterns ; } public synchronized PatternSet . NameEntry createInclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } ds = null ; return defaultPatterns . createInclude ( ) ; } public synchronized PatternSet . NameEntry createIncludesFile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } ds = null ; return defaultPatterns . createIncludesFile ( ) ; } public synchronized PatternSet . NameEntry createExclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } ds = null ; return defaultPatterns . createExclude ( ) ; } public synchronized PatternSet . NameEntry createExcludesFile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } ds = null ; return defaultPatterns . createExcludesFile ( ) ; } public synchronized void setIncludes ( String includes ) { checkAttributesAllowed ( ) ; defaultPatterns . setIncludes ( includes ) ; ds = null ; } public synchronized void appendIncludes ( String [ ] includes ) { checkAttributesAllowed ( ) ; if ( includes != null ) { for ( int i = 0 ; i < includes . length ; i ++ ) { defaultPatterns . createInclude ( ) . setName ( includes [ i ] ) ; } ds = null ; } } public synchronized void setExcludes ( String excludes ) { checkAttributesAllowed ( ) ; defaultPatterns . setExcludes ( excludes ) ; ds = null ; } public synchronized void appendExcludes ( String [ ] excludes ) { checkAttributesAllowed ( ) ; if ( excludes != null ) { for ( int i = 0 ; i < excludes . length ; i ++ ) { defaultPatterns . createExclude ( ) . setName ( excludes [ i ] ) ; } ds = null ; } } public synchronized void setIncludesfile ( File incl ) throws BuildException { checkAttributesAllowed ( ) ; defaultPatterns . setIncludesfile ( incl ) ; ds = null ; } public synchronized void setExcludesfile ( File excl ) throws BuildException { checkAttributesAllowed ( ) ; defaultPatterns . setExcludesfile ( excl ) ; ds = null ; } public synchronized void setDefaultexcludes ( boolean useDefaultExcludes ) { checkAttributesAllowed ( ) ; this . useDefaultExcludes = useDefaultExcludes ; ds = null ; } public synchronized boolean getDefaultexcludes ( ) { return ( isReference ( ) ) ? getRef ( ) . getDefaultexcludes ( ) : useDefaultExcludes ; } public synchronized void setCaseSensitive ( boolean caseSensitive ) { checkAttributesAllowed ( ) ; this . caseSensitive = caseSensitive ; ds = null ; } public synchronized boolean isCaseSensitive ( ) { return ( isReference ( ) ) ? getRef ( ) . isCaseSensitive ( ) : caseSensitive ; } public synchronized void setFollowSymlinks ( boolean followSymlinks ) { checkAttributesAllowed ( ) ; this . followSymlinks = followSymlinks ; ds = null ; } public synchronized boolean isFollowSymlinks ( ) { return ( isReference ( ) ) ? getRef ( ) . isFollowSymlinks ( ) : followSymlinks ; } public synchronized Iterator iterator ( ) { if ( isReference ( ) ) { return getRef ( ) . iterator ( ) ; } ensureDirectoryScannerSetup ( ) ; ds . scan ( ) ; int fct = ds . getIncludedFilesCount ( ) ; int dct = ds . getIncludedDirsCount ( ) ; if ( fct + dct == 0 ) { return EMPTY_ITERATOR ; } FileResourceIterator result = new FileResourceIterator ( ) ; if ( fct > 0 ) { result . addFiles ( ds . getIncludedFiles ( ) ) ; } if ( dct > 0 ) { result . addFiles ( ds . getIncludedDirectories ( ) ) ; } return result ; } public synchronized int size ( ) { if ( isReference ( ) ) { return getRef ( ) . size ( ) ; } ensureDirectoryScannerSetup ( ) ; ds . scan ( ) ; return ds . getIncludedFilesCount ( ) + ds . getIncludedDirsCount ( ) ; } public synchronized boolean hasPatterns ( ) { if ( isReference ( ) ) { return getRef ( ) . hasPatterns ( ) ; } if ( hasPatterns ( defaultPatterns ) ) { return true ; } for ( Iterator i = additionalPatterns . iterator ( ) ; i . hasNext ( ) ; ) { if ( hasPatterns ( ( PatternSet ) i . next ( ) ) ) { return true ; } } return false ; } public synchronized void appendSelector ( FileSelector selector ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } super . appendSelector ( selector ) ; ds = null ; } public String toString ( ) { if ( isReference ( ) ) { return getRef ( ) . toString ( ) ; } Iterator i = iterator ( ) ; if ( ! i . hasNext ( ) ) { return "" ; } StringBuffer sb = new StringBuffer ( ) ; while ( i . hasNext ( ) ) { if ( sb . length ( ) > 0 ) { sb . append ( File . pathSeparatorChar ) ; } sb . append ( i . next ( ) ) ; } return sb . toString ( ) ; } public synchronized Object clone ( ) { if ( isReference ( ) ) { return getRef ( ) . clone ( ) ; } try { Files f = ( Files ) super . clone ( ) ; f . defaultPatterns = ( PatternSet ) defaultPatterns . clone ( ) ; f . additionalPatterns = new Vector ( additionalPatterns . size ( ) ) ; for ( Iterator iter = additionalPatterns . iterator ( ) ; iter . hasNext ( ) ; ) { PatternSet ps = ( PatternSet ) iter . next ( ) ; f . additionalPatterns . add ( ps . clone ( ) ) ; } f . selectors = new Vector ( selectors ) ; return f ; } catch ( CloneNotSupportedException e ) { throw new BuildException ( e ) ; } } public String [ ] mergeIncludes ( Project p ) { return mergePatterns ( p ) . getIncludePatterns ( p ) ; } public String [ ] mergeExcludes ( Project p ) { return mergePatterns ( p ) . getExcludePatterns ( p ) ; } public synchronized PatternSet mergePatterns ( Project p ) { if ( isReference ( ) ) { return getRef ( ) . mergePatterns ( p ) ; } PatternSet ps = new PatternSet ( ) ; ps . append ( defaultPatterns , p ) ; final int count = additionalPatterns . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { Object o = additionalPatterns . elementAt ( i ) ; ps . append ( ( PatternSet ) o , p ) ; } return ps ; } public boolean isFilesystemOnly ( ) { return true ; } protected Files getRef ( ) { return ( Files ) getCheckedRef ( ) ; } private synchronized void ensureDirectoryScannerSetup ( ) { if ( ds == null ) { ds = new DirectoryScanner ( ) ; PatternSet ps = mergePatterns ( getProject ( ) ) ; ds . setIncludes ( ps . getIncludePatterns ( getProject ( ) ) ) ; ds . setExcludes ( ps . getExcludePatterns ( getProject ( ) ) ) ; ds . setSelectors ( getSelectors ( getProject ( ) ) ) ; if ( useDefaultExcludes ) { ds . addDefaultExcludes ( ) ; } ds . setCaseSensitive ( caseSensitive ) ; ds . setFollowSymlinks ( followSymlinks ) ; } } private boolean hasPatterns ( PatternSet ps ) { return ps . getIncludePatterns ( getProject ( ) ) . length > 0 || ps . getExcludePatterns ( getProject ( ) ) . length > 0 ; } } 	1	['34', '4', '0', '10', '92', '39', '0', '10', '29', '0.723484848', '710', '1', '2', '0.643678161', '0.148484848', '3', '4', '19.64705882', '5', '1.9118', '1']
package org . apache . tools . ant ; import java . util . EventListener ; public interface BuildListener extends EventListener { void buildStarted ( BuildEvent event ) ; void buildFinished ( BuildEvent event ) ; void targetStarted ( BuildEvent event ) ; void targetFinished ( BuildEvent event ) ; void taskStarted ( BuildEvent event ) ; void taskFinished ( BuildEvent event ) ; void messageLogged ( BuildEvent event ) ; } 	1	['7', '1', '0', '16', '7', '21', '15', '1', '7', '2', '7', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . tools . ant . filters ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . Reader ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Properties ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . util . FileUtils ; public final class ReplaceTokens extends BaseParamFilterReader implements ChainableReader { private static final char DEFAULT_BEGIN_TOKEN = '@' ; private static final char DEFAULT_END_TOKEN = '@' ; private String queuedData = null ; private String replaceData = null ; private int replaceIndex = - 1 ; private int queueIndex = - 1 ; private Hashtable hash = new Hashtable ( ) ; private char beginToken = DEFAULT_BEGIN_TOKEN ; private char endToken = DEFAULT_END_TOKEN ; public ReplaceTokens ( ) { super ( ) ; } public ReplaceTokens ( final Reader in ) { super ( in ) ; } private int getNextChar ( ) throws IOException { if ( queueIndex != - 1 ) { final int ch = queuedData . charAt ( queueIndex ++ ) ; if ( queueIndex >= queuedData . length ( ) ) { queueIndex = - 1 ; } return ch ; } return in . read ( ) ; } public int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } if ( replaceIndex != - 1 ) { final int ch = replaceData . charAt ( replaceIndex ++ ) ; if ( replaceIndex >= replaceData . length ( ) ) { replaceIndex = - 1 ; } return ch ; } int ch = getNextChar ( ) ; if ( ch == beginToken ) { final StringBuffer key = new StringBuffer ( "" ) ; do { ch = getNextChar ( ) ; if ( ch != - 1 ) { key . append ( ( char ) ch ) ; } else { break ; } } while ( ch != endToken ) ; if ( ch == - 1 ) { if ( queuedData == null || queueIndex == - 1 ) { queuedData = key . toString ( ) ; } else { queuedData = key . toString ( ) + queuedData . substring ( queueIndex ) ; } queueIndex = 0 ; return beginToken ; } else { key . setLength ( key . length ( ) - 1 ) ; final String replaceWith = ( String ) hash . get ( key . toString ( ) ) ; if ( replaceWith != null ) { if ( replaceWith . length ( ) > 0 ) { replaceData = replaceWith ; replaceIndex = 0 ; } return read ( ) ; } else { String newData = key . toString ( ) + endToken ; if ( queuedData == null || queueIndex == - 1 ) { queuedData = newData ; } else { queuedData = newData + queuedData . substring ( queueIndex ) ; } queueIndex = 0 ; return beginToken ; } } } return ch ; } public void setBeginToken ( final char beginToken ) { this . beginToken = beginToken ; } private char getBeginToken ( ) { return beginToken ; } public void setEndToken ( final char endToken ) { this . endToken = endToken ; } private char getEndToken ( ) { return endToken ; } public void addConfiguredToken ( final Token token ) { hash . put ( token . getKey ( ) , token . getValue ( ) ) ; } private Properties getPropertiesFromFile ( String fileName ) { FileInputStream in = null ; Properties props = new Properties ( ) ; try { in = new FileInputStream ( fileName ) ; props . load ( in ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } finally { FileUtils . close ( in ) ; } return props ; } private void setTokens ( final Hashtable hash ) { this . hash = hash ; } private Hashtable getTokens ( ) { return hash ; } public Reader chain ( final Reader rdr ) { ReplaceTokens newFilter = new ReplaceTokens ( rdr ) ; newFilter . setBeginToken ( getBeginToken ( ) ) ; newFilter . setEndToken ( getEndToken ( ) ) ; newFilter . setTokens ( getTokens ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( params [ i ] != null ) { final String type = params [ i ] . getType ( ) ; if ( "tokenchar" . equals ( type ) ) { final String name = params [ i ] . getName ( ) ; String value = params [ i ] . getValue ( ) ; if ( "begintoken" . equals ( name ) ) { if ( value . length ( ) == 0 ) { throw new BuildException ( "Begin token cannot " + "be empty" ) ; } beginToken = params [ i ] . getValue ( ) . charAt ( 0 ) ; } else if ( "endtoken" . equals ( name ) ) { if ( value . length ( ) == 0 ) { throw new BuildException ( "End token cannot " + "be empty" ) ; } endToken = params [ i ] . getValue ( ) . charAt ( 0 ) ; } } else if ( "token" . equals ( type ) ) { final String name = params [ i ] . getName ( ) ; final String value = params [ i ] . getValue ( ) ; hash . put ( name , value ) ; } else if ( "propertiesfile" . equals ( type ) ) { Properties props = getPropertiesFromFile ( params [ i ] . getValue ( ) ) ; for ( Enumeration e = props . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; String value = props . getProperty ( key ) ; hash . put ( key , value ) ; } } } } } } public static class Token { private String key ; private String value ; public final void setKey ( String key ) { this . key = key ; } public final void setValue ( String value ) { this . value = value ; } public final String getKey ( ) { return key ; } public final String getValue ( ) { return value ; } } } 	1	['14', '5', '0', '7', '49', '7', '1', '6', '7', '0.735042735', '488', '1', '0', '0.7', '0.25', '2', '5', '33.21428571', '12', '1.7857', '1']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . resources . Union ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . MergingMapper ; import org . apache . tools . ant . util . ResourceUtils ; import org . apache . tools . ant . util . SourceFileScanner ; public class UpToDate extends Task implements Condition { private String property ; private String value ; private File sourceFile ; private File targetFile ; private Vector sourceFileSets = new Vector ( ) ; private Union sourceResources = new Union ( ) ; protected Mapper mapperElement = null ; public void setProperty ( final String property ) { this . property = property ; } public void setValue ( final String value ) { this . value = value ; } private String getValue ( ) { return ( value != null ) ? value : "true" ; } public void setTargetFile ( final File file ) { this . targetFile = file ; } public void setSrcfile ( final File file ) { this . sourceFile = file ; } public void addSrcfiles ( final FileSet fs ) { sourceFileSets . addElement ( fs ) ; } public Union createSrcResources ( ) { return sourceResources ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" , getLocation ( ) ) ; } mapperElement = new Mapper ( getProject ( ) ) ; return mapperElement ; } public void add ( FileNameMapper fileNameMapper ) { createMapper ( ) . add ( fileNameMapper ) ; } public boolean eval ( ) { if ( sourceFileSets . size ( ) == 0 && sourceResources . size ( ) == 0 && sourceFile == null ) { throw new BuildException ( "At least one srcfile or a nested " + "<srcfiles> or <srcresources> element " + "must be set." ) ; } if ( ( sourceFileSets . size ( ) > 0 || sourceResources . size ( ) > 0 ) && sourceFile != null ) { throw new BuildException ( "Cannot specify both the srcfile " + "attribute and a nested <srcfiles> " + "or <srcresources> element." ) ; } if ( targetFile == null && mapperElement == null ) { throw new BuildException ( "The targetfile attribute or a nested " + "mapper element must be set." ) ; } if ( targetFile != null && ! targetFile . exists ( ) ) { log ( "The targetfile \"" + targetFile . getAbsolutePath ( ) + "\" does not exist." , Project . MSG_VERBOSE ) ; return false ; } if ( sourceFile != null && ! sourceFile . exists ( ) ) { throw new BuildException ( sourceFile . getAbsolutePath ( ) + " not found." ) ; } boolean upToDate = true ; if ( sourceFile != null ) { if ( mapperElement == null ) { upToDate = upToDate && ( targetFile . lastModified ( ) >= sourceFile . lastModified ( ) ) ; } else { SourceFileScanner sfs = new SourceFileScanner ( this ) ; upToDate = upToDate && ( sfs . restrict ( new String [ ] { sourceFile . getAbsolutePath ( ) } , null , null , mapperElement . getImplementation ( ) ) . length == 0 ) ; } } Enumeration e = sourceFileSets . elements ( ) ; while ( upToDate && e . hasMoreElements ( ) ) { FileSet fs = ( FileSet ) e . nextElement ( ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; upToDate = upToDate && scanDir ( fs . getDir ( getProject ( ) ) , ds . getIncludedFiles ( ) ) ; } if ( upToDate ) { Resource [ ] r = sourceResources . listResources ( ) ; upToDate = upToDate && ( ResourceUtils . selectOutOfDateSources ( this , r , getMapper ( ) , getProject ( ) ) . length == 0 ) ; } return upToDate ; } public void execute ( ) throws BuildException { if ( property == null ) { throw new BuildException ( "property attribute is required." , getLocation ( ) ) ; } boolean upToDate = eval ( ) ; if ( upToDate ) { getProject ( ) . setNewProperty ( property , getValue ( ) ) ; if ( mapperElement == null ) { log ( "File \"" + targetFile . getAbsolutePath ( ) + "\" is up-to-date." , Project . MSG_VERBOSE ) ; } else { log ( "All target files are up-to-date." , Project . MSG_VERBOSE ) ; } } } protected boolean scanDir ( File srcDir , String [ ] files ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; FileNameMapper mapper = getMapper ( ) ; File dir = srcDir ; if ( mapperElement == null ) { dir = null ; } return sfs . restrict ( files , srcDir , dir , mapper ) . length == 0 ; } private FileNameMapper getMapper ( ) { FileNameMapper mapper = null ; if ( mapperElement == null ) { MergingMapper mm = new MergingMapper ( ) ; mm . setTo ( targetFile . getAbsolutePath ( ) ) ; mapper = mm ; } else { mapper = mapperElement . getImplementation ( ) ; } return mapper ; } } 	1	['14', '3', '0', '17', '48', '41', '1', '16', '11', '0.769230769', '384', '1', '2', '0.74', '0.261904762', '1', '1', '25.92857143', '26', '3', '1']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileInputStream ; import java . io . InputStreamReader ; import java . io . FileOutputStream ; import java . io . OutputStreamWriter ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . types . EnumeratedAttribute ; public class ManifestTask extends Task { private Manifest nestedManifest = new Manifest ( ) ; private File manifestFile ; private Mode mode ; private String encoding ; public static class Mode extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "update" , "replace" } ; } } public ManifestTask ( ) { mode = new Mode ( ) ; mode . setValue ( "replace" ) ; } public void addConfiguredSection ( Manifest . Section section ) throws ManifestException { nestedManifest . addConfiguredSection ( section ) ; } public void addConfiguredAttribute ( Manifest . Attribute attribute ) throws ManifestException { nestedManifest . addConfiguredAttribute ( attribute ) ; } public void setFile ( File f ) { manifestFile = f ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public void setMode ( Mode m ) { mode = m ; } public void execute ( ) throws BuildException { if ( manifestFile == null ) { throw new BuildException ( "the file attribute is required" ) ; } Manifest toWrite = Manifest . getDefaultManifest ( ) ; Manifest current = null ; BuildException error = null ; if ( manifestFile . exists ( ) ) { FileInputStream fis = null ; InputStreamReader isr = null ; try { fis = new FileInputStream ( manifestFile ) ; if ( encoding == null ) { isr = new InputStreamReader ( fis , "UTF-8" ) ; } else { isr = new InputStreamReader ( fis , encoding ) ; } current = new Manifest ( isr ) ; } catch ( ManifestException m ) { error = new BuildException ( "Existing manifest " + manifestFile + " is invalid" , m , getLocation ( ) ) ; } catch ( IOException e ) { error = new BuildException ( "Failed to read " + manifestFile , e , getLocation ( ) ) ; } finally { FileUtils . close ( isr ) ; } } for ( Enumeration e = nestedManifest . getWarnings ( ) ; e . hasMoreElements ( ) ; ) { log ( "Manifest warning: " + ( String ) e . nextElement ( ) , Project . MSG_WARN ) ; } try { if ( mode . getValue ( ) . equals ( "update" ) && manifestFile . exists ( ) ) { if ( current != null ) { toWrite . merge ( current ) ; } else if ( error != null ) { throw error ; } } toWrite . merge ( nestedManifest ) ; } catch ( ManifestException m ) { throw new BuildException ( "Manifest is invalid" , m , getLocation ( ) ) ; } if ( toWrite . equals ( current ) ) { log ( "Manifest has not changed, do not recreate" , Project . MSG_VERBOSE ) ; return ; } PrintWriter w = null ; try { FileOutputStream fos = new FileOutputStream ( manifestFile ) ; OutputStreamWriter osw = new OutputStreamWriter ( fos , Manifest . JAR_ENCODING ) ; w = new PrintWriter ( osw ) ; toWrite . write ( w ) ; } catch ( IOException e ) { throw new BuildException ( "Failed to write " + manifestFile , e , getLocation ( ) ) ; } finally { if ( w != null ) { w . close ( ) ; } } } } 	1	['7', '3', '0', '9', '39', '1', '0', '9', '7', '0.708333333', '260', '1', '2', '0.860465116', '0.285714286', '2', '2', '35.57142857', '1', '0.8571', '1']
package org . apache . tools . ant . types . resources ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . Reference ; public class FileResource extends Resource implements Touchable { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private static final int NULL_FILE = Resource . getMagicNumber ( "null file" . getBytes ( ) ) ; private File file ; private File baseDir ; public FileResource ( ) { } public FileResource ( File b , String name ) { setFile ( FILE_UTILS . resolveFile ( b , name ) ) ; setBaseDir ( b ) ; } public FileResource ( File f ) { setFile ( f ) ; } public FileResource ( Project p , String s ) { this ( p . resolveFile ( s ) ) ; setProject ( p ) ; } public void setFile ( File f ) { checkAttributesAllowed ( ) ; file = f ; } public File getFile ( ) { return isReference ( ) ? ( ( FileResource ) getCheckedRef ( ) ) . getFile ( ) : file ; } public void setBaseDir ( File b ) { checkAttributesAllowed ( ) ; baseDir = b ; } public File getBaseDir ( ) { return isReference ( ) ? ( ( FileResource ) getCheckedRef ( ) ) . getBaseDir ( ) : baseDir ; } public void setRefid ( Reference r ) { if ( file != null || baseDir != null ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public String getName ( ) { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getName ( ) ; } File b = getBaseDir ( ) ; return b == null ? getNotNullFile ( ) . getName ( ) : FILE_UTILS . removeLeadingPath ( b , getNotNullFile ( ) ) ; } public boolean isExists ( ) { return isReference ( ) ? ( ( Resource ) getCheckedRef ( ) ) . isExists ( ) : getNotNullFile ( ) . exists ( ) ; } public long getLastModified ( ) { return isReference ( ) ? ( ( Resource ) getCheckedRef ( ) ) . getLastModified ( ) : getNotNullFile ( ) . lastModified ( ) ; } public boolean isDirectory ( ) { return isReference ( ) ? ( ( Resource ) getCheckedRef ( ) ) . isDirectory ( ) : getNotNullFile ( ) . isDirectory ( ) ; } public long getSize ( ) { return isReference ( ) ? ( ( Resource ) getCheckedRef ( ) ) . getSize ( ) : getNotNullFile ( ) . length ( ) ; } public InputStream getInputStream ( ) throws IOException { return isReference ( ) ? ( ( Resource ) getCheckedRef ( ) ) . getInputStream ( ) : new FileInputStream ( getNotNullFile ( ) ) ; } public OutputStream getOutputStream ( ) throws IOException { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getOutputStream ( ) ; } File f = getNotNullFile ( ) ; if ( f . exists ( ) ) { if ( f . isFile ( ) ) { f . delete ( ) ; } } else { File p = f . getParentFile ( ) ; if ( p != null && ! ( p . exists ( ) ) ) { p . mkdirs ( ) ; } } return new FileOutputStream ( f ) ; } public int compareTo ( Object another ) { if ( isReference ( ) ) { return ( ( Comparable ) getCheckedRef ( ) ) . compareTo ( another ) ; } if ( this . equals ( another ) ) { return 0 ; } if ( another . getClass ( ) . equals ( getClass ( ) ) ) { FileResource otherfr = ( FileResource ) another ; File f = getFile ( ) ; if ( f == null ) { return - 1 ; } File of = otherfr . getFile ( ) ; if ( of == null ) { return 1 ; } return f . compareTo ( of ) ; } return super . compareTo ( another ) ; } public boolean equals ( Object another ) { if ( this == another ) { return true ; } if ( isReference ( ) ) { return getCheckedRef ( ) . equals ( another ) ; } if ( ! ( another . getClass ( ) . equals ( getClass ( ) ) ) ) { return false ; } FileResource otherfr = ( FileResource ) another ; return getFile ( ) == null ? otherfr . getFile ( ) == null : getFile ( ) . equals ( otherfr . getFile ( ) ) ; } public int hashCode ( ) { if ( isReference ( ) ) { return getCheckedRef ( ) . hashCode ( ) ; } return MAGIC * ( getFile ( ) == null ? NULL_FILE : getFile ( ) . hashCode ( ) ) ; } public String toString ( ) { if ( isReference ( ) ) { return getCheckedRef ( ) . toString ( ) ; } if ( file == null ) { return "(unbound file resource)" ; } String absolutePath = file . getAbsolutePath ( ) ; return FILE_UTILS . normalize ( absolutePath ) . getAbsolutePath ( ) ; } public boolean isFilesystemOnly ( ) { return ! isReference ( ) || ( ( FileResource ) getCheckedRef ( ) ) . isFilesystemOnly ( ) ; } public void touch ( long modTime ) { if ( isReference ( ) ) { ( ( FileResource ) getCheckedRef ( ) ) . touch ( modTime ) ; return ; } getNotNullFile ( ) . setLastModified ( modTime ) ; } protected File getNotNullFile ( ) { if ( getFile ( ) == null ) { throw new BuildException ( "file attribute is null!" ) ; } return getFile ( ) ; } } 	1	['24', '4', '0', '45', '68', '244', '41', '6', '22', '0.804347826', '397', '1', '1', '0.736111111', '0.211180124', '2', '14', '15.375', '6', '1.9583', '2']
package org . apache . tools . ant . launch ; import java . net . URL ; import java . net . URLClassLoader ; import java . net . MalformedURLException ; import java . io . File ; import java . util . StringTokenizer ; import java . util . List ; import java . util . ArrayList ; import java . util . Iterator ; public class Launcher { public static final String ANTHOME_PROPERTY = "ant.home" ; public static final String ANTLIBDIR_PROPERTY = "ant.library.dir" ; public static final String ANT_PRIVATEDIR = ".ant" ; public static final String ANT_PRIVATELIB = "lib" ; public static final String USER_LIBDIR = ANT_PRIVATEDIR + File . separatorChar + ANT_PRIVATELIB ; public static final String MAIN_CLASS = "org.apache.tools.ant.Main" ; public static final String USER_HOMEDIR = "user.home" ; private static final String JAVA_CLASS_PATH = "java.class.path" ; protected static final int EXIT_CODE_ERROR = 2 ; public static void main ( String [ ] args ) { int exitCode ; try { Launcher launcher = new Launcher ( ) ; exitCode = launcher . run ( args ) ; } catch ( LaunchException e ) { exitCode = EXIT_CODE_ERROR ; System . err . println ( e . getMessage ( ) ) ; } catch ( Throwable t ) { exitCode = EXIT_CODE_ERROR ; t . printStackTrace ( System . err ) ; } if ( exitCode != 0 ) { System . exit ( exitCode ) ; } } private void addPath ( String path , boolean getJars , List libPathURLs ) throws MalformedURLException { StringTokenizer tokenizer = new StringTokenizer ( path , File . pathSeparator ) ; while ( tokenizer . hasMoreElements ( ) ) { String elementName = tokenizer . nextToken ( ) ; File element = new File ( elementName ) ; if ( elementName . indexOf ( "%" ) != - 1 && ! element . exists ( ) ) { continue ; } if ( getJars && element . isDirectory ( ) ) { URL [ ] dirURLs = Locator . getLocationURLs ( element ) ; for ( int j = 0 ; j < dirURLs . length ; ++ j ) { libPathURLs . add ( dirURLs [ j ] ) ; } } libPathURLs . add ( Locator . fileToURL ( element ) ) ; } } private int run ( String [ ] args ) throws LaunchException , MalformedURLException { String antHomeProperty = System . getProperty ( ANTHOME_PROPERTY ) ; File antHome = null ; File sourceJar = Locator . getClassSource ( getClass ( ) ) ; File jarDir = sourceJar . getParentFile ( ) ; String mainClassname = MAIN_CLASS ; if ( antHomeProperty != null ) { antHome = new File ( antHomeProperty ) ; } if ( antHome == null || ! antHome . exists ( ) ) { antHome = jarDir . getParentFile ( ) ; System . setProperty ( ANTHOME_PROPERTY , antHome . getAbsolutePath ( ) ) ; } if ( ! antHome . exists ( ) ) { throw new LaunchException ( "Ant home is set incorrectly or " + "ant could not be located" ) ; } List libPaths = new ArrayList ( ) ; String cpString = null ; List argList = new ArrayList ( ) ; String [ ] newArgs ; boolean noUserLib = false ; boolean noClassPath = false ; for ( int i = 0 ; i < args . length ; ++ i ) { if ( args [ i ] . equals ( "-lib" ) ) { if ( i == args . length - 1 ) { throw new LaunchException ( "The -lib argument must " + "be followed by a library location" ) ; } libPaths . add ( args [ ++ i ] ) ; } else if ( args [ i ] . equals ( "-cp" ) ) { if ( i == args . length - 1 ) { throw new LaunchException ( "The -cp argument must " + "be followed by a classpath expression" ) ; } if ( cpString != null ) { throw new LaunchException ( "The -cp argument must " + "not be repeated" ) ; } cpString = args [ ++ i ] ; } else if ( args [ i ] . equals ( "--nouserlib" ) || args [ i ] . equals ( "-nouserlib" ) ) { noUserLib = true ; } else if ( args [ i ] . equals ( "--noclasspath" ) || args [ i ] . equals ( "-noclasspath" ) ) { noClassPath = true ; } else if ( args [ i ] . equals ( "-main" ) ) { if ( i == args . length - 1 ) { throw new LaunchException ( "The -main argument must " + "be followed by a library location" ) ; } mainClassname = args [ ++ i ] ; } else { argList . add ( args [ i ] ) ; } } if ( argList . size ( ) == args . length ) { newArgs = args ; } else { newArgs = ( String [ ] ) argList . toArray ( new String [ argList . size ( ) ] ) ; } URL [ ] libURLs = getLibPathURLs ( noClassPath ? null : cpString , libPaths ) ; URL [ ] systemURLs = getSystemURLs ( jarDir ) ; URL [ ] userURLs = noUserLib ? new URL [ 0 ] : getUserURLs ( ) ; URL [ ] jars = getJarArray ( libURLs , userURLs , systemURLs , Locator . getToolsJar ( ) ) ; StringBuffer baseClassPath = new StringBuffer ( System . getProperty ( JAVA_CLASS_PATH ) ) ; if ( baseClassPath . charAt ( baseClassPath . length ( ) - 1 ) == File . pathSeparatorChar ) { baseClassPath . setLength ( baseClassPath . length ( ) - 1 ) ; } for ( int i = 0 ; i < jars . length ; ++ i ) { baseClassPath . append ( File . pathSeparatorChar ) ; baseClassPath . append ( Locator . fromURI ( jars [ i ] . toString ( ) ) ) ; } System . setProperty ( JAVA_CLASS_PATH , baseClassPath . toString ( ) ) ; URLClassLoader loader = new URLClassLoader ( jars ) ; Thread . currentThread ( ) . setContextClassLoader ( loader ) ; Class mainClass = null ; int exitCode = 0 ; try { mainClass = loader . loadClass ( mainClassname ) ; AntMain main = ( AntMain ) mainClass . newInstance ( ) ; main . startAnt ( newArgs , null , null ) ; } catch ( InstantiationException ex ) { System . err . println ( "Incompatible version of " + mainClassname + " detected" ) ; File mainJar = Locator . getClassSource ( mainClass ) ; System . err . println ( "Location of this class " + mainJar ) ; exitCode = EXIT_CODE_ERROR ; } catch ( Throwable t ) { t . printStackTrace ( System . err ) ; exitCode = EXIT_CODE_ERROR ; } return exitCode ; } private URL [ ] getLibPathURLs ( String cpString , List libPaths ) throws MalformedURLException { List libPathURLs = new ArrayList ( ) ; if ( cpString != null ) { addPath ( cpString , false , libPathURLs ) ; } for ( Iterator i = libPaths . iterator ( ) ; i . hasNext ( ) ; ) { String libPath = ( String ) i . next ( ) ; addPath ( libPath , true , libPathURLs ) ; } return ( URL [ ] ) libPathURLs . toArray ( new URL [ libPathURLs . size ( ) ] ) ; } private URL [ ] getSystemURLs ( File antLauncherDir ) throws MalformedURLException { File antLibDir = null ; String antLibDirProperty = System . getProperty ( ANTLIBDIR_PROPERTY ) ; if ( antLibDirProperty != null ) { antLibDir = new File ( antLibDirProperty ) ; } if ( ( antLibDir == null ) || ! antLibDir . exists ( ) ) { antLibDir = antLauncherDir ; System . setProperty ( ANTLIBDIR_PROPERTY , antLibDir . getAbsolutePath ( ) ) ; } return Locator . getLocationURLs ( antLibDir ) ; } private URL [ ] getUserURLs ( ) throws MalformedURLException { File userLibDir = new File ( System . getProperty ( USER_HOMEDIR ) , USER_LIBDIR ) ; return Locator . getLocationURLs ( userLibDir ) ; } private URL [ ] getJarArray ( URL [ ] libJars , URL [ ] userJars , URL [ ] systemJars , File toolsJar ) throws MalformedURLException { int numJars = libJars . length + userJars . length + systemJars . length ; if ( toolsJar != null ) { numJars ++ ; } URL [ ] jars = new URL [ numJars ] ; System . arraycopy ( libJars , 0 , jars , 0 , libJars . length ) ; System . arraycopy ( userJars , 0 , jars , libJars . length , userJars . length ) ; System . arraycopy ( systemJars , 0 , jars , userJars . length + libJars . length , systemJars . length ) ; if ( toolsJar != null ) { jars [ jars . length - 1 ] = Locator . fileToURL ( toolsJar ) ; } return jars ; } } 	1	['9', '1', '0', '5', '57', '34', '2', '3', '2', '1.083333333', '566', '0.222222222', '0', '0', '0.303571429', '0', '0', '60.88888889', '2', '0.8889', '1']
package org . apache . tools . ant . taskdefs ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . ArrayList ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . Stack ; import java . util . Vector ; import java . util . zip . CRC32 ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . FileScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . ArchiveFileSet ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . PatternSet ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . ZipFileSet ; import org . apache . tools . ant . types . ZipScanner ; import org . apache . tools . ant . types . resources . ArchiveResource ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . GlobPatternMapper ; import org . apache . tools . ant . util . IdentityMapper ; import org . apache . tools . ant . util . MergingMapper ; import org . apache . tools . ant . util . ResourceUtils ; import org . apache . tools . zip . ZipEntry ; import org . apache . tools . zip . ZipExtraField ; import org . apache . tools . zip . ZipFile ; import org . apache . tools . zip . ZipOutputStream ; public class Zip extends MatchingTask { protected File zipFile ; private ZipScanner zs ; private File baseDir ; protected Hashtable entries = new Hashtable ( ) ; private Vector groupfilesets = new Vector ( ) ; private Vector filesetsFromGroupfilesets = new Vector ( ) ; protected String duplicate = "add" ; private boolean doCompress = true ; private boolean doUpdate = false ; private boolean savedDoUpdate = false ; private boolean doFilesonly = false ; protected String archiveType = "zip" ; private static final long EMPTY_CRC = new CRC32 ( ) . getValue ( ) ; protected String emptyBehavior = "skip" ; private Vector resources = new Vector ( ) ; protected Hashtable addedDirs = new Hashtable ( ) ; private Vector addedFiles = new Vector ( ) ; protected boolean doubleFilePass = false ; protected boolean skipWriting = false ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private boolean addingNewFiles = false ; private String encoding ; private boolean keepCompression = false ; private boolean roundUp = true ; private String comment = "" ; private int level = ZipOutputStream . DEFAULT_COMPRESSION ; public void setZipfile ( File zipFile ) { setDestFile ( zipFile ) ; } public void setFile ( File file ) { setDestFile ( file ) ; } public void setDestFile ( File destFile ) { this . zipFile = destFile ; } public File getDestFile ( ) { return zipFile ; } public void setBasedir ( File baseDir ) { this . baseDir = baseDir ; } public void setCompress ( boolean c ) { doCompress = c ; } public boolean isCompress ( ) { return doCompress ; } public void setFilesonly ( boolean f ) { doFilesonly = f ; } public void setUpdate ( boolean c ) { doUpdate = c ; savedDoUpdate = c ; } public boolean isInUpdateMode ( ) { return doUpdate ; } public void addFileset ( FileSet set ) { add ( set ) ; } public void addZipfileset ( ZipFileSet set ) { add ( set ) ; } public void add ( ResourceCollection a ) { resources . add ( a ) ; } public void addZipGroupFileset ( FileSet set ) { groupfilesets . addElement ( set ) ; } public void setDuplicate ( Duplicate df ) { duplicate = df . getValue ( ) ; } public static class WhenEmpty extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "fail" , "skip" , "create" } ; } } public void setWhenempty ( WhenEmpty we ) { emptyBehavior = we . getValue ( ) ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String getEncoding ( ) { return encoding ; } public void setKeepCompression ( boolean keep ) { keepCompression = keep ; } public void setComment ( String comment ) { this . comment = comment ; } public String getComment ( ) { return comment ; } public void setLevel ( int level ) { this . level = level ; } public int getLevel ( ) { return level ; } public void setRoundUp ( boolean r ) { roundUp = r ; } public void execute ( ) throws BuildException { if ( doubleFilePass ) { skipWriting = true ; executeMain ( ) ; skipWriting = false ; executeMain ( ) ; } else { executeMain ( ) ; } } public void executeMain ( ) throws BuildException { if ( baseDir == null && resources . size ( ) == 0 && groupfilesets . size ( ) == 0 && "zip" . equals ( archiveType ) ) { throw new BuildException ( "basedir attribute must be set, " + "or at least one " + "resource collection must be given!" ) ; } if ( zipFile == null ) { throw new BuildException ( "You must specify the " + archiveType + " file to create!" ) ; } if ( zipFile . exists ( ) && ! zipFile . isFile ( ) ) { throw new BuildException ( zipFile + " is not a file." ) ; } if ( zipFile . exists ( ) && ! zipFile . canWrite ( ) ) { throw new BuildException ( zipFile + " is read-only." ) ; } File renamedFile = null ; addingNewFiles = true ; if ( doUpdate && ! zipFile . exists ( ) ) { doUpdate = false ; log ( "ignoring update attribute as " + archiveType + " doesn't exist." , Project . MSG_DEBUG ) ; } for ( int i = 0 ; i < groupfilesets . size ( ) ; i ++ ) { log ( "Processing groupfileset " , Project . MSG_VERBOSE ) ; FileSet fs = ( FileSet ) groupfilesets . elementAt ( i ) ; FileScanner scanner = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] files = scanner . getIncludedFiles ( ) ; File basedir = scanner . getBasedir ( ) ; for ( int j = 0 ; j < files . length ; j ++ ) { log ( "Adding file " + files [ j ] + " to fileset" , Project . MSG_VERBOSE ) ; ZipFileSet zf = new ZipFileSet ( ) ; zf . setProject ( getProject ( ) ) ; zf . setSrc ( new File ( basedir , files [ j ] ) ) ; add ( zf ) ; filesetsFromGroupfilesets . addElement ( zf ) ; } } Vector vfss = new Vector ( ) ; if ( baseDir != null ) { FileSet fs = ( FileSet ) getImplicitFileSet ( ) . clone ( ) ; fs . setDir ( baseDir ) ; vfss . addElement ( fs ) ; } for ( int i = 0 ; i < resources . size ( ) ; i ++ ) { ResourceCollection rc = ( ResourceCollection ) resources . elementAt ( i ) ; vfss . addElement ( rc ) ; } ResourceCollection [ ] fss = new ResourceCollection [ vfss . size ( ) ] ; vfss . copyInto ( fss ) ; boolean success = false ; try { ArchiveState state = getResourcesToAdd ( fss , zipFile , false ) ; if ( ! state . isOutOfDate ( ) ) { return ; } if ( ! zipFile . exists ( ) && state . isWithoutAnyResources ( ) ) { createEmptyZip ( zipFile ) ; return ; } Resource [ ] [ ] addThem = state . getResourcesToAdd ( ) ; if ( doUpdate ) { renamedFile = FILE_UTILS . createTempFile ( "zip" , ".tmp" , zipFile . getParentFile ( ) ) ; renamedFile . deleteOnExit ( ) ; try { FILE_UTILS . rename ( zipFile , renamedFile ) ; } catch ( SecurityException e ) { throw new BuildException ( "Not allowed to rename old file (" + zipFile . getAbsolutePath ( ) + ") to temporary file" ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to rename old file (" + zipFile . getAbsolutePath ( ) + ") to temporary file" ) ; } } String action = doUpdate ? "Updating " : "Building " ; log ( action + archiveType + ": " + zipFile . getAbsolutePath ( ) ) ; ZipOutputStream zOut = null ; try { if ( ! skipWriting ) { zOut = new ZipOutputStream ( zipFile ) ; zOut . setEncoding ( encoding ) ; zOut . setMethod ( doCompress ? ZipOutputStream . DEFLATED : ZipOutputStream . STORED ) ; zOut . setLevel ( level ) ; } initZipOutputStream ( zOut ) ; for ( int i = 0 ; i < fss . length ; i ++ ) { if ( addThem [ i ] . length != 0 ) { addResources ( fss [ i ] , addThem [ i ] , zOut ) ; } } if ( doUpdate ) { addingNewFiles = false ; ZipFileSet oldFiles = new ZipFileSet ( ) ; oldFiles . setProject ( getProject ( ) ) ; oldFiles . setSrc ( renamedFile ) ; oldFiles . setDefaultexcludes ( false ) ; for ( int i = 0 ; i < addedFiles . size ( ) ; i ++ ) { PatternSet . NameEntry ne = oldFiles . createExclude ( ) ; ne . setName ( ( String ) addedFiles . elementAt ( i ) ) ; } DirectoryScanner ds = oldFiles . getDirectoryScanner ( getProject ( ) ) ; ( ( ZipScanner ) ds ) . setEncoding ( encoding ) ; String [ ] f = ds . getIncludedFiles ( ) ; Resource [ ] r = new Resource [ f . length ] ; for ( int i = 0 ; i < f . length ; i ++ ) { r [ i ] = ds . getResource ( f [ i ] ) ; } if ( ! doFilesonly ) { String [ ] d = ds . getIncludedDirectories ( ) ; Resource [ ] dr = new Resource [ d . length ] ; for ( int i = 0 ; i < d . length ; i ++ ) { dr [ i ] = ds . getResource ( d [ i ] ) ; } Resource [ ] tmp = r ; r = new Resource [ tmp . length + dr . length ] ; System . arraycopy ( dr , 0 , r , 0 , dr . length ) ; System . arraycopy ( tmp , 0 , r , dr . length , tmp . length ) ; } addResources ( oldFiles , r , zOut ) ; } if ( zOut != null ) { zOut . setComment ( comment ) ; } finalizeZipOutputStream ( zOut ) ; if ( doUpdate ) { if ( ! renamedFile . delete ( ) ) { log ( "Warning: unable to delete temporary file " + renamedFile . getName ( ) , Project . MSG_WARN ) ; } } success = true ; } finally { try { if ( zOut != null ) { zOut . close ( ) ; } } catch ( IOException ex ) { if ( success ) { throw ex ; } } } } catch ( IOException ioe ) { String msg = "Problem creating " + archiveType + ": " + ioe . getMessage ( ) ; if ( ( ! doUpdate || renamedFile != null ) && ! zipFile . delete ( ) ) { msg += " (and the archive is probably corrupt but I could not " + "delete it)" ; } if ( doUpdate && renamedFile != null ) { try { FILE_UTILS . rename ( renamedFile , zipFile ) ; } catch ( IOException e ) { msg += " (and I couldn't rename the temporary file " + renamedFile . getName ( ) + " back)" ; } } throw new BuildException ( msg , ioe , getLocation ( ) ) ; } finally { cleanUp ( ) ; } } protected final boolean isAddingNewFiles ( ) { return addingNewFiles ; } protected final void addResources ( FileSet fileset , Resource [ ] resources , ZipOutputStream zOut ) throws IOException { String prefix = "" ; String fullpath = "" ; int dirMode = ArchiveFileSet . DEFAULT_DIR_MODE ; int fileMode = ArchiveFileSet . DEFAULT_FILE_MODE ; ArchiveFileSet zfs = null ; if ( fileset instanceof ArchiveFileSet ) { zfs = ( ArchiveFileSet ) fileset ; prefix = zfs . getPrefix ( getProject ( ) ) ; fullpath = zfs . getFullpath ( getProject ( ) ) ; dirMode = zfs . getDirMode ( getProject ( ) ) ; fileMode = zfs . getFileMode ( getProject ( ) ) ; } if ( prefix . length ( ) > 0 && fullpath . length ( ) > 0 ) { throw new BuildException ( "Both prefix and fullpath attributes must" + " not be set on the same fileset." ) ; } if ( resources . length != 1 && fullpath . length ( ) > 0 ) { throw new BuildException ( "fullpath attribute may only be specified" + " for filesets that specify a single" + " file." ) ; } if ( prefix . length ( ) > 0 ) { if ( ! prefix . endsWith ( "/" ) && ! prefix . endsWith ( "\\" ) ) { prefix += "/" ; } addParentDirs ( null , prefix , zOut , "" , dirMode ) ; } ZipFile zf = null ; try { boolean dealingWithFiles = false ; File base = null ; if ( zfs == null || zfs . getSrc ( getProject ( ) ) == null ) { dealingWithFiles = true ; base = fileset . getDir ( getProject ( ) ) ; } else if ( zfs instanceof ZipFileSet ) { zf = new ZipFile ( zfs . getSrc ( getProject ( ) ) , encoding ) ; } for ( int i = 0 ; i < resources . length ; i ++ ) { String name = null ; if ( fullpath . length ( ) > 0 ) { name = fullpath ; } else { name = resources [ i ] . getName ( ) ; } name = name . replace ( File . separatorChar , '/' ) ; if ( "" . equals ( name ) ) { continue ; } if ( resources [ i ] . isDirectory ( ) && ! name . endsWith ( "/" ) ) { name = name + "/" ; } if ( ! doFilesonly && ! dealingWithFiles && resources [ i ] . isDirectory ( ) && ! zfs . hasDirModeBeenSet ( ) ) { int nextToLastSlash = name . lastIndexOf ( "/" , name . length ( ) - 2 ) ; if ( nextToLastSlash != - 1 ) { addParentDirs ( base , name . substring ( 0 , nextToLastSlash + 1 ) , zOut , prefix , dirMode ) ; } if ( zf != null ) { ZipEntry ze = zf . getEntry ( resources [ i ] . getName ( ) ) ; addParentDirs ( base , name , zOut , prefix , ze . getUnixMode ( ) ) ; } else { ArchiveResource tr = ( ArchiveResource ) resources [ i ] ; addParentDirs ( base , name , zOut , prefix , tr . getMode ( ) ) ; } } else { addParentDirs ( base , name , zOut , prefix , dirMode ) ; } if ( ! resources [ i ] . isDirectory ( ) && dealingWithFiles ) { File f = FILE_UTILS . resolveFile ( base , resources [ i ] . getName ( ) ) ; zipFile ( f , zOut , prefix + name , fileMode ) ; } else if ( ! resources [ i ] . isDirectory ( ) ) { if ( zf != null ) { ZipEntry ze = zf . getEntry ( resources [ i ] . getName ( ) ) ; if ( ze != null ) { boolean oldCompress = doCompress ; if ( keepCompression ) { doCompress = ( ze . getMethod ( ) == ZipEntry . DEFLATED ) ; } try { zipFile ( zf . getInputStream ( ze ) , zOut , prefix + name , ze . getTime ( ) , zfs . getSrc ( getProject ( ) ) , zfs . hasFileModeBeenSet ( ) ? fileMode : ze . getUnixMode ( ) ) ; } finally { doCompress = oldCompress ; } } } else { ArchiveResource tr = ( ArchiveResource ) resources [ i ] ; InputStream is = null ; try { is = tr . getInputStream ( ) ; zipFile ( is , zOut , prefix + name , resources [ i ] . getLastModified ( ) , zfs . getSrc ( getProject ( ) ) , zfs . hasFileModeBeenSet ( ) ? fileMode : tr . getMode ( ) ) ; } finally { FileUtils . close ( is ) ; } } } } } finally { if ( zf != null ) { zf . close ( ) ; } } } protected final void addResources ( ResourceCollection rc , Resource [ ] resources , ZipOutputStream zOut ) throws IOException { if ( rc instanceof FileSet ) { addResources ( ( FileSet ) rc , resources , zOut ) ; return ; } for ( int i = 0 ; i < resources . length ; i ++ ) { String name = resources [ i ] . getName ( ) . replace ( File . separatorChar , '/' ) ; if ( "" . equals ( name ) ) { continue ; } if ( resources [ i ] . isDirectory ( ) && doFilesonly ) { continue ; } File base = null ; if ( resources [ i ] instanceof FileResource ) { base = ( ( FileResource ) resources [ i ] ) . getBaseDir ( ) ; } if ( resources [ i ] . isDirectory ( ) ) { if ( ! name . endsWith ( "/" ) ) { name = name + "/" ; } } addParentDirs ( base , name , zOut , "" , ArchiveFileSet . DEFAULT_DIR_MODE ) ; if ( ! resources [ i ] . isDirectory ( ) ) { if ( resources [ i ] instanceof FileResource ) { File f = ( ( FileResource ) resources [ i ] ) . getFile ( ) ; zipFile ( f , zOut , name , ArchiveFileSet . DEFAULT_FILE_MODE ) ; } else { InputStream is = null ; try { is = resources [ i ] . getInputStream ( ) ; zipFile ( is , zOut , name , resources [ i ] . getLastModified ( ) , null , ArchiveFileSet . DEFAULT_FILE_MODE ) ; } finally { FileUtils . close ( is ) ; } } } } } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { } protected void finalizeZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { } protected boolean createEmptyZip ( File zipFile ) throws BuildException { log ( "Note: creating empty " + archiveType + " archive " + zipFile , Project . MSG_INFO ) ; OutputStream os = null ; try { os = new FileOutputStream ( zipFile ) ; byte [ ] empty = new byte [ 22 ] ; empty [ 0 ] = 80 ; empty [ 1 ] = 75 ; empty [ 2 ] = 5 ; empty [ 3 ] = 6 ; os . write ( empty ) ; } catch ( IOException ioe ) { throw new BuildException ( "Could not create empty ZIP archive " + "(" + ioe . getMessage ( ) + ")" , ioe , getLocation ( ) ) ; } finally { if ( os != null ) { try { os . close ( ) ; } catch ( IOException e ) { } } } return true ; } private synchronized ZipScanner getZipScanner ( ) { if ( zs == null ) { zs = new ZipScanner ( ) ; zs . setEncoding ( encoding ) ; zs . setSrc ( zipFile ) ; } return zs ; } protected ArchiveState getResourcesToAdd ( ResourceCollection [ ] rcs , File zipFile , boolean needsUpdate ) throws BuildException { ArrayList filesets = new ArrayList ( ) ; ArrayList rest = new ArrayList ( ) ; for ( int i = 0 ; i < rcs . length ; i ++ ) { if ( rcs [ i ] instanceof FileSet ) { filesets . add ( rcs [ i ] ) ; } else { rest . add ( rcs [ i ] ) ; } } ResourceCollection [ ] rc = ( ResourceCollection [ ] ) rest . toArray ( new ResourceCollection [ rest . size ( ) ] ) ; ArchiveState as = getNonFileSetResourcesToAdd ( rc , zipFile , needsUpdate ) ; FileSet [ ] fs = ( FileSet [ ] ) filesets . toArray ( new FileSet [ filesets . size ( ) ] ) ; ArchiveState as2 = getResourcesToAdd ( fs , zipFile , as . isOutOfDate ( ) ) ; if ( ! as . isOutOfDate ( ) && as2 . isOutOfDate ( ) ) { as = getNonFileSetResourcesToAdd ( rc , zipFile , true ) ; } Resource [ ] [ ] toAdd = new Resource [ rcs . length ] [ ] ; int fsIndex = 0 ; int restIndex = 0 ; for ( int i = 0 ; i < rcs . length ; i ++ ) { if ( rcs [ i ] instanceof FileSet ) { toAdd [ i ] = as2 . getResourcesToAdd ( ) [ fsIndex ++ ] ; } else { toAdd [ i ] = as . getResourcesToAdd ( ) [ restIndex ++ ] ; } } return new ArchiveState ( as2 . isOutOfDate ( ) , toAdd ) ; } protected ArchiveState getResourcesToAdd ( FileSet [ ] filesets , File zipFile , boolean needsUpdate ) throws BuildException { Resource [ ] [ ] initialResources = grabResources ( filesets ) ; if ( isEmpty ( initialResources ) ) { if ( needsUpdate && doUpdate ) { return new ArchiveState ( true , initialResources ) ; } if ( emptyBehavior . equals ( "skip" ) ) { if ( doUpdate ) { log ( archiveType + " archive " + zipFile + " not updated because no new files were included." , Project . MSG_VERBOSE ) ; } else { log ( "Warning: skipping " + archiveType + " archive " + zipFile + " because no files were included." , Project . MSG_WARN ) ; } } else if ( emptyBehavior . equals ( "fail" ) ) { throw new BuildException ( "Cannot create " + archiveType + " archive " + zipFile + ": no files were included." , getLocation ( ) ) ; } else { if ( ! zipFile . exists ( ) ) { needsUpdate = true ; } } return new ArchiveState ( needsUpdate , initialResources ) ; } if ( ! zipFile . exists ( ) ) { return new ArchiveState ( true , initialResources ) ; } if ( needsUpdate && ! doUpdate ) { return new ArchiveState ( true , initialResources ) ; } Resource [ ] [ ] newerResources = new Resource [ filesets . length ] [ ] ; for ( int i = 0 ; i < filesets . length ; i ++ ) { if ( ! ( fileset instanceof ZipFileSet ) || ( ( ZipFileSet ) fileset ) . getSrc ( getProject ( ) ) == null ) { File base = filesets [ i ] . getDir ( getProject ( ) ) ; for ( int j = 0 ; j < initialResources [ i ] . length ; j ++ ) { File resourceAsFile = FILE_UTILS . resolveFile ( base , initialResources [ i ] [ j ] . getName ( ) ) ; if ( resourceAsFile . equals ( zipFile ) ) { throw new BuildException ( "A zip file cannot include " + "itself" , getLocation ( ) ) ; } } } } for ( int i = 0 ; i < filesets . length ; i ++ ) { if ( initialResources [ i ] . length == 0 ) { newerResources [ i ] = new Resource [ ] { } ; continue ; } FileNameMapper myMapper = new IdentityMapper ( ) ; if ( filesets [ i ] instanceof ZipFileSet ) { ZipFileSet zfs = ( ZipFileSet ) filesets [ i ] ; if ( zfs . getFullpath ( getProject ( ) ) != null && ! zfs . getFullpath ( getProject ( ) ) . equals ( "" ) ) { MergingMapper fm = new MergingMapper ( ) ; fm . setTo ( zfs . getFullpath ( getProject ( ) ) ) ; myMapper = fm ; } else if ( zfs . getPrefix ( getProject ( ) ) != null && ! zfs . getPrefix ( getProject ( ) ) . equals ( "" ) ) { GlobPatternMapper gm = new GlobPatternMapper ( ) ; gm . setFrom ( "*" ) ; String prefix = zfs . getPrefix ( getProject ( ) ) ; if ( ! prefix . endsWith ( "/" ) && ! prefix . endsWith ( "\\" ) ) { prefix += "/" ; } gm . setTo ( prefix + "*" ) ; myMapper = gm ; } } Resource [ ] resources = initialResources [ i ] ; if ( doFilesonly ) { resources = selectFileResources ( resources ) ; } newerResources [ i ] = ResourceUtils . selectOutOfDateSources ( this , resources , myMapper , getZipScanner ( ) ) ; needsUpdate = needsUpdate || ( newerResources [ i ] . length > 0 ) ; if ( needsUpdate && ! doUpdate ) { break ; } } if ( needsUpdate && ! doUpdate ) { return new ArchiveState ( true , initialResources ) ; } return new ArchiveState ( needsUpdate , newerResources ) ; } protected ArchiveState getNonFileSetResourcesToAdd ( ResourceCollection [ ] rcs , File zipFile , boolean needsUpdate ) throws BuildException { Resource [ ] [ ] initialResources = grabNonFileSetResources ( rcs ) ; if ( isEmpty ( initialResources ) ) { return new ArchiveState ( needsUpdate , initialResources ) ; } if ( ! zipFile . exists ( ) ) { return new ArchiveState ( true , initialResources ) ; } if ( needsUpdate && ! doUpdate ) { return new ArchiveState ( true , initialResources ) ; } Resource [ ] [ ] newerResources = new Resource [ rcs . length ] [ ] ; for ( int i = 0 ; i < rcs . length ; i ++ ) { if ( initialResources [ i ] . length == 0 ) { newerResources [ i ] = new Resource [ ] { } ; continue ; } for ( int j = 0 ; j < initialResources [ i ] . length ; j ++ ) { if ( initialResources [ i ] [ j ] instanceof FileResource && zipFile . equals ( ( ( FileResource ) initialResources [ i ] [ j ] ) . getFile ( ) ) ) { throw new BuildException ( "A zip file cannot include " + "itself" , getLocation ( ) ) ; } } Resource [ ] rs = initialResources [ i ] ; if ( doFilesonly ) { rs = selectFileResources ( rs ) ; } newerResources [ i ] = ResourceUtils . selectOutOfDateSources ( this , rs , new IdentityMapper ( ) , getZipScanner ( ) ) ; needsUpdate = needsUpdate || ( newerResources [ i ] . length > 0 ) ; if ( needsUpdate && ! doUpdate ) { break ; } } if ( needsUpdate && ! doUpdate ) { return new ArchiveState ( true , initialResources ) ; } return new ArchiveState ( needsUpdate , newerResources ) ; } protected Resource [ ] [ ] grabResources ( FileSet [ ] filesets ) { Resource [ ] [ ] result = new Resource [ filesets . length ] [ ] ; for ( int i = 0 ; i < filesets . length ; i ++ ) { boolean skipEmptyNames = true ; if ( filesets [ i ] instanceof ZipFileSet ) { ZipFileSet zfs = ( ZipFileSet ) filesets [ i ] ; skipEmptyNames = zfs . getPrefix ( getProject ( ) ) . equals ( "" ) && zfs . getFullpath ( getProject ( ) ) . equals ( "" ) ; } DirectoryScanner rs = filesets [ i ] . getDirectoryScanner ( getProject ( ) ) ; if ( rs instanceof ZipScanner ) { ( ( ZipScanner ) rs ) . setEncoding ( encoding ) ; } Vector resources = new Vector ( ) ; if ( ! doFilesonly ) { String [ ] directories = rs . getIncludedDirectories ( ) ; for ( int j = 0 ; j < directories . length ; j ++ ) { if ( ! "" . equals ( directories [ j ] ) || ! skipEmptyNames ) { resources . addElement ( rs . getResource ( directories [ j ] ) ) ; } } } String [ ] files = rs . getIncludedFiles ( ) ; for ( int j = 0 ; j < files . length ; j ++ ) { if ( ! "" . equals ( files [ j ] ) || ! skipEmptyNames ) { resources . addElement ( rs . getResource ( files [ j ] ) ) ; } } result [ i ] = new Resource [ resources . size ( ) ] ; resources . copyInto ( result [ i ] ) ; } return result ; } protected Resource [ ] [ ] grabNonFileSetResources ( ResourceCollection [ ] rcs ) { Resource [ ] [ ] result = new Resource [ rcs . length ] [ ] ; for ( int i = 0 ; i < rcs . length ; i ++ ) { Iterator iter = rcs [ i ] . iterator ( ) ; ArrayList rs = new ArrayList ( ) ; int lastDir = 0 ; while ( iter . hasNext ( ) ) { Resource r = ( Resource ) iter . next ( ) ; if ( r . isExists ( ) ) { if ( r . isDirectory ( ) ) { rs . add ( lastDir ++ , r ) ; } else { rs . add ( r ) ; } } } result [ i ] = ( Resource [ ] ) rs . toArray ( new Resource [ rs . size ( ) ] ) ; } return result ; } protected void zipDir ( File dir , ZipOutputStream zOut , String vPath , int mode ) throws IOException { zipDir ( dir , zOut , vPath , mode , null ) ; } protected void zipDir ( File dir , ZipOutputStream zOut , String vPath , int mode , ZipExtraField [ ] extra ) throws IOException { if ( doFilesonly ) { log ( "skipping directory " + vPath + " for file-only archive" , Project . MSG_VERBOSE ) ; return ; } if ( addedDirs . get ( vPath ) != null ) { return ; } log ( "adding directory " + vPath , Project . MSG_VERBOSE ) ; addedDirs . put ( vPath , vPath ) ; if ( ! skipWriting ) { ZipEntry ze = new ZipEntry ( vPath ) ; if ( dir != null && dir . exists ( ) ) { ze . setTime ( dir . lastModified ( ) + ( roundUp ? 1999 : 0 ) ) ; } else { ze . setTime ( System . currentTimeMillis ( ) + ( roundUp ? 1999 : 0 ) ) ; } ze . setSize ( 0 ) ; ze . setMethod ( ZipEntry . STORED ) ; ze . setCrc ( EMPTY_CRC ) ; ze . setUnixMode ( mode ) ; if ( extra != null ) { ze . setExtraFields ( extra ) ; } zOut . putNextEntry ( ze ) ; } } protected void zipFile ( InputStream in , ZipOutputStream zOut , String vPath , long lastModified , File fromArchive , int mode ) throws IOException { if ( entries . contains ( vPath ) ) { if ( duplicate . equals ( "preserve" ) ) { log ( vPath + " already added, skipping" , Project . MSG_INFO ) ; return ; } else if ( duplicate . equals ( "fail" ) ) { throw new BuildException ( "Duplicate file " + vPath + " was found and the duplicate " + "attribute is 'fail'." ) ; } else { log ( "duplicate file " + vPath + " found, adding." , Project . MSG_VERBOSE ) ; } } else { log ( "adding entry " + vPath , Project . MSG_VERBOSE ) ; } entries . put ( vPath , vPath ) ; if ( ! skipWriting ) { ZipEntry ze = new ZipEntry ( vPath ) ; ze . setTime ( lastModified ) ; ze . setMethod ( doCompress ? ZipEntry . DEFLATED : ZipEntry . STORED ) ; if ( ! zOut . isSeekable ( ) && ! doCompress ) { long size = 0 ; CRC32 cal = new CRC32 ( ) ; if ( ! in . markSupported ( ) ) { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { size += count ; cal . update ( buffer , 0 , count ) ; bos . write ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; in = new ByteArrayInputStream ( bos . toByteArray ( ) ) ; } else { in . mark ( Integer . MAX_VALUE ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { size += count ; cal . update ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; in . reset ( ) ; } ze . setSize ( size ) ; ze . setCrc ( cal . getValue ( ) ) ; } ze . setUnixMode ( mode ) ; zOut . putNextEntry ( ze ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { if ( count != 0 ) { zOut . write ( buffer , 0 , count ) ; } count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } addedFiles . addElement ( vPath ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath , int mode ) throws IOException { if ( file . equals ( zipFile ) ) { throw new BuildException ( "A zip file cannot include itself" , getLocation ( ) ) ; } FileInputStream fIn = new FileInputStream ( file ) ; try { zipFile ( fIn , zOut , vPath , file . lastModified ( ) + ( roundUp ? 1999 : 0 ) , null , mode ) ; } finally { fIn . close ( ) ; } } protected final void addParentDirs ( File baseDir , String entry , ZipOutputStream zOut , String prefix , int dirMode ) throws IOException { if ( ! doFilesonly ) { Stack directories = new Stack ( ) ; int slashPos = entry . length ( ) ; while ( ( slashPos = entry . lastIndexOf ( '/' , slashPos - 1 ) ) != - 1 ) { String dir = entry . substring ( 0 , slashPos + 1 ) ; if ( addedDirs . get ( prefix + dir ) != null ) { break ; } directories . push ( dir ) ; } while ( ! directories . isEmpty ( ) ) { String dir = ( String ) directories . pop ( ) ; File f = null ; if ( baseDir != null ) { f = new File ( baseDir , dir ) ; } else { f = new File ( dir ) ; } zipDir ( f , zOut , prefix + dir , dirMode ) ; } } } protected void cleanUp ( ) { addedDirs . clear ( ) ; addedFiles . removeAllElements ( ) ; entries . clear ( ) ; addingNewFiles = false ; doUpdate = savedDoUpdate ; Enumeration e = filesetsFromGroupfilesets . elements ( ) ; while ( e . hasMoreElements ( ) ) { ZipFileSet zf = ( ZipFileSet ) e . nextElement ( ) ; resources . removeElement ( zf ) ; } filesetsFromGroupfilesets . removeAllElements ( ) ; } public void reset ( ) { resources . removeAllElements ( ) ; zipFile = null ; baseDir = null ; groupfilesets . removeAllElements ( ) ; duplicate = "add" ; archiveType = "zip" ; doCompress = true ; emptyBehavior = "skip" ; doUpdate = false ; doFilesonly = false ; encoding = null ; } protected static final boolean isEmpty ( Resource [ ] [ ] r ) { for ( int i = 0 ; i < r . length ; i ++ ) { if ( r [ i ] . length > 0 ) { return false ; } } return true ; } protected Resource [ ] selectFileResources ( Resource [ ] orig ) { if ( orig . length == 0 ) { return orig ; } Vector v = new Vector ( orig . length ) ; for ( int i = 0 ; i < orig . length ; i ++ ) { if ( ! orig [ i ] . isDirectory ( ) ) { v . addElement ( orig [ i ] ) ; } else { log ( "Ignoring directory " + orig [ i ] . getName ( ) + " as only files will be added." , Project . MSG_VERBOSE ) ; } } if ( v . size ( ) != orig . length ) { Resource [ ] r = new Resource [ v . size ( ) ] ; v . copyInto ( r ) ; return r ; } return orig ; } public static class Duplicate extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "add" , "preserve" , "fail" } ; } } public static class ArchiveState { private boolean outOfDate ; private Resource [ ] [ ] resourcesToAdd ; ArchiveState ( boolean state , Resource [ ] [ ] r ) { outOfDate = state ; resourcesToAdd = r ; } public boolean isOutOfDate ( ) { return outOfDate ; } public Resource [ ] [ ] getResourcesToAdd ( ) { return resourcesToAdd ; } public boolean isWithoutAnyResources ( ) { if ( resourcesToAdd == null ) { return true ; } for ( int counter = 0 ; counter < resourcesToAdd . length ; counter ++ ) { if ( resourcesToAdd [ counter ] != null ) { if ( resourcesToAdd [ counter ] . length > 0 ) { return false ; } } } return true ; } } } 	1	['49', '4', '1', '31', '210', '844', '1', '30', '28', '0.877403846', '2937', '1', '2', '0.624', '0.127314815', '0', '0', '58.40816327', '13', '1.449', '8']
package org . apache . tools . ant . taskdefs . optional . unix ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . FileSet ; public abstract class AbstractAccessTask extends org . apache . tools . ant . taskdefs . ExecuteOn { public AbstractAccessTask ( ) { super . setParallel ( true ) ; super . setSkipEmptyFilesets ( true ) ; } public void setFile ( File src ) { FileSet fs = new FileSet ( ) ; fs . setFile ( src ) ; addFileset ( fs ) ; } public void setCommand ( Commandline cmdl ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the command attribute" , getLocation ( ) ) ; } public void setSkipEmptyFilesets ( boolean skip ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the " + "skipemptyfileset attribute" , getLocation ( ) ) ; } public void setAddsourcefile ( boolean b ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the addsourcefile attribute" , getLocation ( ) ) ; } protected boolean isValidOs ( ) { return Os . isFamily ( "unix" ) && super . isValidOs ( ) ; } } 	1	['6', '5', '2', '8', '21', '15', '2', '6', '5', '2', '83', '0', '0', '0.955357143', '0.416666667', '1', '1', '12.83333333', '3', '1.1667', '1']
package org . apache . tools . ant . util ; public class GlobPatternMapper implements FileNameMapper { protected String fromPrefix = null ; protected String fromPostfix = null ; protected int prefixLength ; protected int postfixLength ; protected String toPrefix = null ; protected String toPostfix = null ; private boolean handleDirSep = false ; private boolean caseSensitive = true ; public void setHandleDirSep ( boolean handleDirSep ) { this . handleDirSep = handleDirSep ; } public void setCaseSensitive ( boolean caseSensitive ) { this . caseSensitive = caseSensitive ; } public void setFrom ( String from ) { int index = from . lastIndexOf ( "*" ) ; if ( index == - 1 ) { fromPrefix = from ; fromPostfix = "" ; } else { fromPrefix = from . substring ( 0 , index ) ; fromPostfix = from . substring ( index + 1 ) ; } prefixLength = fromPrefix . length ( ) ; postfixLength = fromPostfix . length ( ) ; } public void setTo ( String to ) { int index = to . lastIndexOf ( "*" ) ; if ( index == - 1 ) { toPrefix = to ; toPostfix = "" ; } else { toPrefix = to . substring ( 0 , index ) ; toPostfix = to . substring ( index + 1 ) ; } } public String [ ] mapFileName ( String sourceFileName ) { if ( fromPrefix == null || ! modifyName ( sourceFileName ) . startsWith ( modifyName ( fromPrefix ) ) || ! modifyName ( sourceFileName ) . endsWith ( modifyName ( fromPostfix ) ) ) { return null ; } return new String [ ] { toPrefix + extractVariablePart ( sourceFileName ) + toPostfix } ; } protected String extractVariablePart ( String name ) { return name . substring ( prefixLength , name . length ( ) - postfixLength ) ; } private String modifyName ( String name ) { if ( ! caseSensitive ) { name = name . toLowerCase ( ) ; } if ( handleDirSep ) { if ( name . indexOf ( '\\' ) != - 1 ) { name = name . replace ( '\\' , '/' ) ; } } return name ; } } 	1	['8', '1', '2', '5', '22', '6', '4', '1', '6', '0.678571429', '185', '1', '0', '0', '0.625', '0', '0', '21.125', '4', '1.875', '3']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Locale ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . ZipFileSet ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . zip . ZipOutputStream ; public class War extends Jar { private File deploymentDescriptor ; private boolean needxmlfile = true ; private File addedWebXmlFile ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private static final String XML_DESCRIPTOR_PATH = "WEB-INF/web.xml" ; private static final String XML_DESCRIPTOR_PATH_LC = XML_DESCRIPTOR_PATH . toLowerCase ( Locale . ENGLISH ) ; public War ( ) { super ( ) ; archiveType = "war" ; emptyBehavior = "create" ; } public void setWarfile ( File warFile ) { setDestFile ( warFile ) ; } public void setWebxml ( File descr ) { deploymentDescriptor = descr ; if ( ! deploymentDescriptor . exists ( ) ) { throw new BuildException ( "Deployment descriptor: " + deploymentDescriptor + " does not exist." ) ; } ZipFileSet fs = new ZipFileSet ( ) ; fs . setFile ( deploymentDescriptor ) ; fs . setFullpath ( XML_DESCRIPTOR_PATH ) ; super . addFileset ( fs ) ; } public void setNeedxmlfile ( boolean needxmlfile ) { this . needxmlfile = needxmlfile ; } public void addLib ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/lib/" ) ; super . addFileset ( fs ) ; } public void addClasses ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/classes/" ) ; super . addFileset ( fs ) ; } public void addWebinf ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/" ) ; super . addFileset ( fs ) ; } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { super . initZipOutputStream ( zOut ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath , int mode ) throws IOException { String vPathLowerCase = vPath . toLowerCase ( Locale . ENGLISH ) ; boolean addFile = true ; if ( XML_DESCRIPTOR_PATH_LC . equals ( vPathLowerCase ) ) { if ( addedWebXmlFile != null ) { addFile = false ; if ( ! FILE_UTILS . fileNameEquals ( addedWebXmlFile , file ) ) { log ( "Warning: selected " + archiveType + " files include a second " + XML_DESCRIPTOR_PATH + " which will be ignored.\n" + "The duplicate entry is at " + file + '\n' + "The file that will be used is " + addedWebXmlFile , Project . MSG_WARN ) ; } } else { addedWebXmlFile = file ; addFile = true ; deploymentDescriptor = file ; } } if ( addFile ) { super . zipFile ( file , zOut , vPath , mode ) ; } } protected void cleanUp ( ) { if ( addedWebXmlFile == null && deploymentDescriptor == null && needxmlfile && ! isInUpdateMode ( ) ) { throw new BuildException ( "No WEB-INF/web.xml file was added.\n" + "If this is your intent, set needxml='false' " ) ; } addedWebXmlFile = null ; super . cleanUp ( ) ; } } 	1	['11', '6', '0', '6', '34', '39', '0', '6', '7', '0.9', '195', '1', '1', '0.944785276', '0.3', '4', '10', '16.18181818', '5', '1.2727', '2']
package org . apache . tools . ant . util ; import java . io . File ; import java . io . Reader ; import java . io . InputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . io . BufferedInputStream ; import java . util . Arrays ; import java . util . Vector ; import java . util . Iterator ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . filters . util . ChainReaderHelper ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . TimeComparison ; import org . apache . tools . ant . types . ResourceFactory ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . FilterSetCollection ; import org . apache . tools . ant . types . resources . Union ; import org . apache . tools . ant . types . resources . Restrict ; import org . apache . tools . ant . types . resources . Resources ; import org . apache . tools . ant . types . resources . Touchable ; import org . apache . tools . ant . types . resources . selectors . Or ; import org . apache . tools . ant . types . resources . selectors . And ; import org . apache . tools . ant . types . resources . selectors . Not ; import org . apache . tools . ant . types . resources . selectors . Date ; import org . apache . tools . ant . types . resources . selectors . Type ; import org . apache . tools . ant . types . resources . selectors . Exists ; import org . apache . tools . ant . types . resources . selectors . ResourceSelector ; import org . apache . tools . ant . types . selectors . SelectorUtils ; public class ResourceUtils { private static final class Outdated implements ResourceSelector { private Resource control ; private long granularity ; private Outdated ( Resource control , long granularity ) { this . control = control ; this . granularity = granularity ; } public boolean isSelected ( Resource r ) { return SelectorUtils . isOutOfDate ( control , r , granularity ) ; } } private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private static final ResourceSelector NOT_EXISTS = new Not ( new Exists ( ) ) ; public static Resource [ ] selectOutOfDateSources ( ProjectComponent logTo , Resource [ ] source , FileNameMapper mapper , ResourceFactory targets ) { return selectOutOfDateSources ( logTo , source , mapper , targets , FILE_UTILS . getFileTimestampGranularity ( ) ) ; } public static Resource [ ] selectOutOfDateSources ( ProjectComponent logTo , Resource [ ] source , FileNameMapper mapper , ResourceFactory targets , long granularity ) { Union u = new Union ( ) ; u . addAll ( Arrays . asList ( source ) ) ; ResourceCollection rc = selectOutOfDateSources ( logTo , u , mapper , targets , granularity ) ; return rc . size ( ) == 0 ? new Resource [ 0 ] : ( ( Union ) rc ) . listResources ( ) ; } public static ResourceCollection selectOutOfDateSources ( ProjectComponent logTo , ResourceCollection source , FileNameMapper mapper , ResourceFactory targets , long granularity ) { if ( source . size ( ) == 0 ) { logTo . log ( "No sources found." , Project . MSG_VERBOSE ) ; return Resources . NONE ; } source = Union . getInstance ( source ) ; logFuture ( logTo , source , granularity ) ; Union result = new Union ( ) ; for ( Iterator iter = source . iterator ( ) ; iter . hasNext ( ) ; ) { Resource sr = ( Resource ) iter . next ( ) ; String srName = sr . getName ( ) ; srName = srName == null ? srName : srName . replace ( '/' , File . separatorChar ) ; String [ ] targetnames = null ; try { targetnames = mapper . mapFileName ( srName ) ; } catch ( Exception e ) { logTo . log ( "Caught " + e + " mapping resource " + sr , Project . MSG_VERBOSE ) ; } if ( targetnames == null || targetnames . length == 0 ) { logTo . log ( sr + " skipped - don\'t know how to handle it" , Project . MSG_VERBOSE ) ; continue ; } Union targetColl = new Union ( ) ; for ( int i = 0 ; i < targetnames . length ; i ++ ) { targetColl . add ( targets . getResource ( targetnames [ i ] . replace ( File . separatorChar , '/' ) ) ) ; } Restrict r = new Restrict ( ) ; r . add ( new And ( new ResourceSelector [ ] { Type . FILE , new Or ( new ResourceSelector [ ] { NOT_EXISTS , new Outdated ( sr , granularity ) } ) } ) ) ; r . add ( targetColl ) ; if ( r . size ( ) > 0 ) { result . add ( sr ) ; Resource t = ( Resource ) ( r . iterator ( ) . next ( ) ) ; logTo . log ( sr . getName ( ) + " added as " + t . getName ( ) + ( t . isExists ( ) ? " is outdated." : " doesn\'t exist." ) , Project . MSG_VERBOSE ) ; continue ; } logTo . log ( sr . getName ( ) + " omitted as " + targetColl . toString ( ) + ( targetColl . size ( ) == 1 ? " is" : " are " ) + " up to date." , Project . MSG_VERBOSE ) ; } return result ; } public static void copyResource ( Resource source , Resource dest ) throws IOException { copyResource ( source , dest , null ) ; } public static void copyResource ( Resource source , Resource dest , Project project ) throws IOException { copyResource ( source , dest , null , null , false , false , null , null , project ) ; } public static void copyResource ( Resource source , Resource dest , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String inputEncoding , String outputEncoding , Project project ) throws IOException { if ( ! overwrite ) { long slm = source . getLastModified ( ) ; if ( dest . isExists ( ) && slm != 0 && dest . getLastModified ( ) > slm ) { return ; } } final boolean filterSetsAvailable = ( filters != null && filters . hasFilters ( ) ) ; final boolean filterChainsAvailable = ( filterChains != null && filterChains . size ( ) > 0 ) ; if ( filterSetsAvailable ) { BufferedReader in = null ; BufferedWriter out = null ; try { InputStreamReader isr = null ; if ( inputEncoding == null ) { isr = new InputStreamReader ( source . getInputStream ( ) ) ; } else { isr = new InputStreamReader ( source . getInputStream ( ) , inputEncoding ) ; } in = new BufferedReader ( isr ) ; OutputStreamWriter osw = null ; if ( outputEncoding == null ) { osw = new OutputStreamWriter ( dest . getOutputStream ( ) ) ; } else { osw = new OutputStreamWriter ( dest . getOutputStream ( ) , outputEncoding ) ; } out = new BufferedWriter ( osw ) ; if ( filterChainsAvailable ) { ChainReaderHelper crh = new ChainReaderHelper ( ) ; crh . setBufferSize ( FileUtils . BUF_SIZE ) ; crh . setPrimaryReader ( in ) ; crh . setFilterChains ( filterChains ) ; crh . setProject ( project ) ; Reader rdr = crh . getAssembledReader ( ) ; in = new BufferedReader ( rdr ) ; } LineTokenizer lineTokenizer = new LineTokenizer ( ) ; lineTokenizer . setIncludeDelims ( true ) ; String newline = null ; String line = lineTokenizer . getToken ( in ) ; while ( line != null ) { if ( line . length ( ) == 0 ) { out . newLine ( ) ; } else { newline = filters . replaceTokens ( line ) ; out . write ( newline ) ; } line = lineTokenizer . getToken ( in ) ; } } finally { FileUtils . close ( out ) ; FileUtils . close ( in ) ; } } else if ( filterChainsAvailable || ( inputEncoding != null && ! inputEncoding . equals ( outputEncoding ) ) || ( inputEncoding == null && outputEncoding != null ) ) { BufferedReader in = null ; BufferedWriter out = null ; try { InputStreamReader isr = null ; if ( inputEncoding == null ) { isr = new InputStreamReader ( source . getInputStream ( ) ) ; } else { isr = new InputStreamReader ( source . getInputStream ( ) , inputEncoding ) ; } in = new BufferedReader ( isr ) ; OutputStreamWriter osw = null ; if ( outputEncoding == null ) { osw = new OutputStreamWriter ( dest . getOutputStream ( ) ) ; } else { osw = new OutputStreamWriter ( dest . getOutputStream ( ) , outputEncoding ) ; } out = new BufferedWriter ( osw ) ; if ( filterChainsAvailable ) { ChainReaderHelper crh = new ChainReaderHelper ( ) ; crh . setBufferSize ( FileUtils . BUF_SIZE ) ; crh . setPrimaryReader ( in ) ; crh . setFilterChains ( filterChains ) ; crh . setProject ( project ) ; Reader rdr = crh . getAssembledReader ( ) ; in = new BufferedReader ( rdr ) ; } char [ ] buffer = new char [ FileUtils . BUF_SIZE ] ; while ( true ) { int nRead = in . read ( buffer , 0 , buffer . length ) ; if ( nRead == - 1 ) { break ; } out . write ( buffer , 0 , nRead ) ; } } finally { FileUtils . close ( out ) ; FileUtils . close ( in ) ; } } else { InputStream in = null ; OutputStream out = null ; try { in = source . getInputStream ( ) ; out = dest . getOutputStream ( ) ; byte [ ] buffer = new byte [ FileUtils . BUF_SIZE ] ; int count = 0 ; do { out . write ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } finally { FileUtils . close ( out ) ; FileUtils . close ( in ) ; } } if ( preserveLastModified && dest instanceof Touchable ) { setLastModified ( ( Touchable ) dest , source . getLastModified ( ) ) ; } } public static void setLastModified ( Touchable t , long time ) { t . touch ( ( time < 0 ) ? System . currentTimeMillis ( ) : time ) ; } public static boolean contentEquals ( Resource r1 , Resource r2 , boolean text ) throws IOException { if ( r1 . isExists ( ) != r2 . isExists ( ) ) { return false ; } if ( ! r1 . isExists ( ) ) { return true ; } if ( r1 . isDirectory ( ) || r2 . isDirectory ( ) ) { return false ; } if ( r1 . equals ( r2 ) ) { return true ; } if ( ! text && r1 . getSize ( ) != r2 . getSize ( ) ) { return false ; } return compareContent ( r1 , r2 , text ) == 0 ; } public static int compareContent ( Resource r1 , Resource r2 , boolean text ) throws IOException { if ( r1 . equals ( r2 ) ) { return 0 ; } boolean e1 = r1 . isExists ( ) ; boolean e2 = r2 . isExists ( ) ; if ( ! ( e1 || e2 ) ) { return 0 ; } if ( e1 != e2 ) { return e1 ? 1 : - 1 ; } boolean d1 = r1 . isDirectory ( ) ; boolean d2 = r2 . isDirectory ( ) ; if ( d1 && d2 ) { return 0 ; } if ( d1 || d2 ) { return d1 ? - 1 : 1 ; } return text ? textCompare ( r1 , r2 ) : binaryCompare ( r1 , r2 ) ; } private static int binaryCompare ( Resource r1 , Resource r2 ) throws IOException { InputStream in1 = null ; InputStream in2 = null ; try { in1 = new BufferedInputStream ( r1 . getInputStream ( ) ) ; in2 = new BufferedInputStream ( r2 . getInputStream ( ) ) ; for ( int b1 = in1 . read ( ) ; b1 != - 1 ; b1 = in1 . read ( ) ) { int b2 = in2 . read ( ) ; if ( b1 != b2 ) { return b1 > b2 ? 1 : - 1 ; } } return in2 . read ( ) == - 1 ? 0 : - 1 ; } finally { FileUtils . close ( in1 ) ; FileUtils . close ( in2 ) ; } } private static int textCompare ( Resource r1 , Resource r2 ) throws IOException { BufferedReader in1 = null ; BufferedReader in2 = null ; try { in1 = new BufferedReader ( new InputStreamReader ( r1 . getInputStream ( ) ) ) ; in2 = new BufferedReader ( new InputStreamReader ( r2 . getInputStream ( ) ) ) ; String expected = in1 . readLine ( ) ; while ( expected != null ) { String actual = in2 . readLine ( ) ; if ( ! expected . equals ( actual ) ) { return expected . compareTo ( actual ) ; } expected = in1 . readLine ( ) ; } return in2 . readLine ( ) == null ? 0 : - 1 ; } finally { FileUtils . close ( in1 ) ; FileUtils . close ( in2 ) ; } } private static void logFuture ( ProjectComponent logTo , ResourceCollection rc , long granularity ) { long now = System . currentTimeMillis ( ) + granularity ; Date sel = new Date ( ) ; sel . setMillis ( now ) ; sel . setWhen ( TimeComparison . AFTER ) ; Restrict future = new Restrict ( ) ; future . add ( sel ) ; future . add ( rc ) ; for ( Iterator iter = future . iterator ( ) ; iter . hasNext ( ) ; ) { logTo . log ( "Warning: " + ( ( Resource ) iter . next ( ) ) . getName ( ) + " modified in the future." , Project . MSG_WARN ) ; } } } 	1	['14', '1', '0', '30', '96', '87', '8', '23', '10', '0.884615385', '905', '1', '2', '0', '0.192307692', '0', '0', '63.5', '10', '1.7143', '1']
package org . apache . tools . ant . util . optional ; import org . apache . tools . ant . BuildException ; import java . util . Iterator ; import org . apache . tools . ant . util . ScriptRunnerBase ; import org . apache . tools . ant . util . ReflectUtil ; import org . apache . tools . ant . util . ReflectWrapper ; public class JavaxScriptRunner extends ScriptRunnerBase { private ReflectWrapper engine ; public String getManagerName ( ) { return "javax" ; } public boolean supportsLanguage ( ) { if ( engine != null ) { return true ; } checkLanguage ( ) ; ClassLoader origLoader = replaceContextLoader ( ) ; try { return createEngine ( ) != null ; } catch ( Exception ex ) { return false ; } finally { restoreContextLoader ( origLoader ) ; } } public void executeScript ( String execName ) throws BuildException { evaluateScript ( execName ) ; } public Object evaluateScript ( String execName ) throws BuildException { checkLanguage ( ) ; ClassLoader origLoader = replaceContextLoader ( ) ; try { ReflectWrapper engine = createEngine ( ) ; if ( engine == null ) { throw new BuildException ( "Unable to create javax script engine for " + getLanguage ( ) ) ; } for ( Iterator i = getBeans ( ) . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { String key = ( String ) i . next ( ) ; Object value = getBeans ( ) . get ( key ) ; engine . invoke ( "put" , String . class , key , Object . class , value ) ; } return engine . invoke ( "eval" , String . class , getScript ( ) ) ; } catch ( Exception be ) { Throwable t = be ; Throwable te = ( Throwable ) ReflectUtil . invoke ( be , "getCause" ) ; if ( te != null ) { if ( te instanceof BuildException ) { throw ( BuildException ) te ; } else { t = te ; } } throw new BuildException ( t ) ; } finally { restoreContextLoader ( origLoader ) ; } } private ReflectWrapper createEngine ( ) throws Exception { if ( engine != null ) { return engine ; } ReflectWrapper manager = new ReflectWrapper ( getClass ( ) . getClassLoader ( ) , "javax.script.ScriptEngineManager" ) ; Object e = manager . invoke ( "getEngineByName" , String . class , getLanguage ( ) ) ; if ( e == null ) { return null ; } ReflectWrapper ret = new ReflectWrapper ( e ) ; if ( getKeepEngine ( ) ) { this . engine = ret ; } return ret ; } } 	1	['6', '2', '0', '4', '34', '11', '0', '4', '5', '0.6', '236', '0.333333333', '1', '0.827586207', '0.666666667', '1', '2', '37.83333333', '6', '1.6667', '1']
package org . apache . tools . ant . taskdefs . optional . ssh ; import com . jcraft . jsch . JSchException ; import com . jcraft . jsch . Session ; import java . io . IOException ; import java . io . File ; import java . util . List ; import java . util . LinkedList ; import java . util . Iterator ; import java . util . ArrayList ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . FileSet ; public class Scp extends SSHBase { private static final String [ ] FROM_ATTRS = { "file" , "localfile" , "remotefile" } ; private static final String [ ] TO_ATTRS = { "todir" , "localtodir" , "remotetodir" , "localtofile" , "remotetofile" } ; private String fromUri ; private String toUri ; private List fileSets = null ; private boolean isFromRemote , isToRemote ; private boolean isSftp = false ; public void setFile ( String aFromUri ) { setFromUri ( aFromUri ) ; this . isFromRemote = isRemoteUri ( this . fromUri ) ; } public void setTodir ( String aToUri ) { setToUri ( aToUri ) ; this . isToRemote = isRemoteUri ( this . toUri ) ; } public void setLocalFile ( String aFromUri ) { setFromUri ( aFromUri ) ; this . isFromRemote = false ; } public void setRemoteFile ( String aFromUri ) { setFromUri ( aFromUri ) ; this . isFromRemote = true ; } public void setLocalTodir ( String aToUri ) { setToUri ( aToUri ) ; this . isToRemote = false ; } public void setRemoteTodir ( String aToUri ) { setToUri ( aToUri ) ; this . isToRemote = true ; } public void setLocalTofile ( String aToUri ) { setToUri ( aToUri ) ; this . isToRemote = false ; } public void setRemoteTofile ( String aToUri ) { setToUri ( aToUri ) ; this . isToRemote = true ; } public void setSftp ( boolean yesOrNo ) { isSftp = yesOrNo ; } public void addFileset ( FileSet set ) { if ( fileSets == null ) { fileSets = new LinkedList ( ) ; } fileSets . add ( set ) ; } public void init ( ) throws BuildException { super . init ( ) ; this . toUri = null ; this . fromUri = null ; this . fileSets = null ; } public void execute ( ) throws BuildException { if ( toUri == null ) { throw exactlyOne ( TO_ATTRS ) ; } if ( fromUri == null && fileSets == null ) { throw exactlyOne ( FROM_ATTRS , "one or more nested filesets" ) ; } try { if ( isFromRemote && ! isToRemote ) { download ( fromUri , toUri ) ; } else if ( ! isFromRemote && isToRemote ) { if ( fileSets != null ) { upload ( fileSets , toUri ) ; } else { upload ( fromUri , toUri ) ; } } else if ( isFromRemote && isToRemote ) { throw new BuildException ( "Copying from a remote server to a remote server is not supported." ) ; } else { throw new BuildException ( "'todir' and 'file' attributes " + "must have syntax like the following: " + "user:password@host:/path" ) ; } } catch ( Exception e ) { if ( getFailonerror ( ) ) { throw new BuildException ( e ) ; } else { log ( "Caught exception: " + e . getMessage ( ) , Project . MSG_ERR ) ; } } } private void download ( String fromSshUri , String toPath ) throws JSchException , IOException { String file = parseUri ( fromSshUri ) ; Session session = null ; try { session = openSession ( ) ; ScpFromMessage message = null ; if ( ! isSftp ) { message = new ScpFromMessage ( getVerbose ( ) , session , file , getProject ( ) . resolveFile ( toPath ) , fromSshUri . endsWith ( "*" ) ) ; } else { message = new ScpFromMessageBySftp ( getVerbose ( ) , session , file , getProject ( ) . resolveFile ( toPath ) , fromSshUri . endsWith ( "*" ) ) ; } log ( "Receiving file: " + file ) ; message . setLogListener ( this ) ; message . execute ( ) ; } finally { if ( session != null ) { session . disconnect ( ) ; } } } private void upload ( List fileSet , String toSshUri ) throws IOException , JSchException { String file = parseUri ( toSshUri ) ; Session session = null ; try { List list = new ArrayList ( fileSet . size ( ) ) ; for ( Iterator i = fileSet . iterator ( ) ; i . hasNext ( ) ; ) { FileSet set = ( FileSet ) i . next ( ) ; Directory d = createDirectory ( set ) ; if ( d != null ) { list . add ( d ) ; } } if ( ! list . isEmpty ( ) ) { session = openSession ( ) ; ScpToMessage message = null ; if ( ! isSftp ) { message = new ScpToMessage ( getVerbose ( ) , session , list , file ) ; } else { message = new ScpToMessageBySftp ( getVerbose ( ) , session , list , file ) ; } message . setLogListener ( this ) ; message . execute ( ) ; } } finally { if ( session != null ) { session . disconnect ( ) ; } } } private void upload ( String fromPath , String toSshUri ) throws IOException , JSchException { String file = parseUri ( toSshUri ) ; Session session = null ; try { session = openSession ( ) ; ScpToMessage message = null ; if ( ! isSftp ) { message = new ScpToMessage ( getVerbose ( ) , session , getProject ( ) . resolveFile ( fromPath ) , file ) ; } else { message = new ScpToMessageBySftp ( getVerbose ( ) , session , getProject ( ) . resolveFile ( fromPath ) , file ) ; } message . setLogListener ( this ) ; message . execute ( ) ; } finally { if ( session != null ) { session . disconnect ( ) ; } } } private String parseUri ( String uri ) { int indexOfAt = uri . lastIndexOf ( '@' ) ; int indexOfColon = uri . indexOf ( ':' ) ; if ( indexOfColon > - 1 && indexOfColon < indexOfAt ) { setUsername ( uri . substring ( 0 , indexOfColon ) ) ; setPassword ( uri . substring ( indexOfColon + 1 , indexOfAt ) ) ; } else { setUsername ( uri . substring ( 0 , indexOfAt ) ) ; } if ( getUserInfo ( ) . getPassword ( ) == null && getUserInfo ( ) . getPassphrase ( ) == null ) { throw new BuildException ( "neither password nor passphrase for user " + getUserInfo ( ) . getName ( ) + " has been " + "given.  Can't authenticate." ) ; } int indexOfPath = uri . indexOf ( ':' , indexOfAt + 1 ) ; if ( indexOfPath == - 1 ) { throw new BuildException ( "no remote path in " + uri ) ; } setHost ( uri . substring ( indexOfAt + 1 , indexOfPath ) ) ; String remotePath = uri . substring ( indexOfPath + 1 ) ; if ( remotePath . equals ( "" ) ) { remotePath = "." ; } return remotePath ; } private boolean isRemoteUri ( String uri ) { boolean isRemote = true ; int indexOfAt = uri . indexOf ( '@' ) ; if ( indexOfAt < 0 ) { isRemote = false ; } return isRemote ; } private Directory createDirectory ( FileSet set ) { DirectoryScanner scanner = set . getDirectoryScanner ( getProject ( ) ) ; Directory root = new Directory ( scanner . getBasedir ( ) ) ; String [ ] files = scanner . getIncludedFiles ( ) ; if ( files . length != 0 ) { for ( int j = 0 ; j < files . length ; j ++ ) { String [ ] path = Directory . getPath ( files [ j ] ) ; Directory current = root ; File currentParent = scanner . getBasedir ( ) ; for ( int i = 0 ; i < path . length ; i ++ ) { File file = new File ( currentParent , path [ i ] ) ; if ( file . isDirectory ( ) ) { current . addDirectory ( new Directory ( file ) ) ; current = current . getChild ( file ) ; currentParent = current . getDirectory ( ) ; } else if ( file . isFile ( ) ) { current . addFile ( file ) ; } } } } else { root = null ; } return root ; } private void setFromUri ( String fromUri ) { if ( this . fromUri != null ) { throw exactlyOne ( FROM_ATTRS ) ; } this . fromUri = fromUri ; } private void setToUri ( String toUri ) { if ( this . toUri != null ) { throw exactlyOne ( TO_ATTRS ) ; } this . toUri = toUri ; } private BuildException exactlyOne ( String [ ] attrs ) { return exactlyOne ( attrs , null ) ; } private BuildException exactlyOne ( String [ ] attrs , String alt ) { StringBuffer buf = new StringBuffer ( "Exactly one of " ) . append ( '[' ) . append ( attrs [ 0 ] ) ; for ( int i = 1 ; i < attrs . length ; i ++ ) { buf . append ( '|' ) . append ( attrs [ i ] ) ; } buf . append ( ']' ) ; if ( alt != null ) { buf . append ( " or " ) . append ( alt ) ; } return new BuildException ( buf . append ( " is required." ) . toString ( ) ) ; } } 	1	['24', '4', '0', '14', '85', '180', '0', '14', '13', '0.782608696', '741', '1', '0', '0.710526316', '0.326086957', '2', '2', '29.54166667', '7', '1.625', '4']
package org . apache . tools . ant . taskdefs . optional . junit ; public class Constants { static final String HALT_ON_ERROR = "haltOnError=" ; static final String HALT_ON_FAILURE = "haltOnFailure=" ; static final String FILTERTRACE = "filtertrace=" ; static final String CRASHFILE = "crashfile=" ; static final String BEFORE_FIRST_TEST = "BeforeFirstTest" ; static final String PROPSFILE = "propsfile=" ; static final String SHOWOUTPUT = "showoutput=" ; static final String OUTPUT_TO_FORMATTERS = "outputtoformatters=" ; static final String FORMATTER = "formatter=" ; static final String LOGTESTLISTENEREVENTS = "logtestlistenerevents=" ; static final String TESTSFILE = "testsfile=" ; static final String TERMINATED_SUCCESSFULLY = "terminated successfully" ; } 	1	['1', '1', '0', '0', '2', '0', '0', '0', '1', '2', '16', '0', '0', '0', '1', '0', '0', '3', '0', '0', '1']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . StringUtils ; public class Available extends Task implements Condition { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private String property ; private String classname ; private String filename ; private File file ; private Path filepath ; private String resource ; private FileDir type ; private Path classpath ; private AntClassLoader loader ; private String value = "true" ; private boolean isTask = false ; private boolean ignoreSystemclasses = false ; private boolean searchParents = false ; public void setSearchParents ( boolean searchParents ) { this . searchParents = searchParents ; } public void setClasspath ( Path classpath ) { createClasspath ( ) . append ( classpath ) ; } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setFilepath ( Path filepath ) { createFilepath ( ) . append ( filepath ) ; } public Path createFilepath ( ) { if ( this . filepath == null ) { this . filepath = new Path ( getProject ( ) ) ; } return this . filepath . createPath ( ) ; } public void setProperty ( String property ) { this . property = property ; } public void setValue ( String value ) { this . value = value ; } public void setClassname ( String classname ) { if ( ! "" . equals ( classname ) ) { this . classname = classname ; } } public void setFile ( File file ) { this . file = file ; this . filename = FILE_UTILS . removeLeadingPath ( getProject ( ) . getBaseDir ( ) , file ) ; } public void setResource ( String resource ) { this . resource = resource ; } public void setType ( String type ) { log ( "DEPRECATED - The setType(String) method has been deprecated." + " Use setType(Available.FileDir) instead." , Project . MSG_WARN ) ; this . type = new FileDir ( ) ; this . type . setValue ( type ) ; } public void setType ( FileDir type ) { this . type = type ; } public void setIgnoresystemclasses ( boolean ignore ) { this . ignoreSystemclasses = ignore ; } public void execute ( ) throws BuildException { if ( property == null ) { throw new BuildException ( "property attribute is required" , getLocation ( ) ) ; } isTask = true ; try { if ( eval ( ) ) { String oldvalue = getProject ( ) . getProperty ( property ) ; if ( null != oldvalue && ! oldvalue . equals ( value ) ) { log ( "DEPRECATED - <available> used to override an existing" + " property." + StringUtils . LINE_SEP + "  Build file should not reuse the same property" + " name for different values." , Project . MSG_WARN ) ; } getProject ( ) . setProperty ( property , value ) ; } } finally { isTask = false ; } } public boolean eval ( ) throws BuildException { try { if ( classname == null && file == null && resource == null ) { throw new BuildException ( "At least one of (classname|file|" + "resource) is required" , getLocation ( ) ) ; } if ( type != null ) { if ( file == null ) { throw new BuildException ( "The type attribute is only valid " + "when specifying the file " + "attribute." , getLocation ( ) ) ; } } if ( classpath != null ) { classpath . setProject ( getProject ( ) ) ; this . loader = getProject ( ) . createClassLoader ( classpath ) ; } String appendix = "" ; if ( isTask ) { appendix = " to set property " + property ; } else { setTaskName ( "available" ) ; } if ( ( classname != null ) && ! checkClass ( classname ) ) { log ( "Unable to load class " + classname + appendix , Project . MSG_VERBOSE ) ; return false ; } if ( ( file != null ) && ! checkFile ( ) ) { StringBuffer buf = new StringBuffer ( "Unable to find " ) ; if ( type != null ) { buf . append ( type ) . append ( ' ' ) ; } buf . append ( filename ) . append ( appendix ) ; log ( buf . toString ( ) , Project . MSG_VERBOSE ) ; return false ; } if ( ( resource != null ) && ! checkResource ( resource ) ) { log ( "Unable to load resource " + resource + appendix , Project . MSG_VERBOSE ) ; return false ; } } finally { if ( loader != null ) { loader . cleanup ( ) ; loader = null ; } if ( ! isTask ) { setTaskName ( null ) ; } } return true ; } private boolean checkFile ( ) { if ( filepath == null ) { return checkFile ( file , filename ) ; } else { String [ ] paths = filepath . list ( ) ; for ( int i = 0 ; i < paths . length ; ++ i ) { log ( "Searching " + paths [ i ] , Project . MSG_DEBUG ) ; File path = new File ( paths [ i ] ) ; if ( path . exists ( ) && filename . equals ( paths [ i ] ) ) { if ( type == null ) { log ( "Found: " + path , Project . MSG_VERBOSE ) ; return true ; } else if ( type . isDir ( ) && path . isDirectory ( ) ) { log ( "Found directory: " + path , Project . MSG_VERBOSE ) ; return true ; } else if ( type . isFile ( ) && path . isFile ( ) ) { log ( "Found file: " + path , Project . MSG_VERBOSE ) ; return true ; } return false ; } File parent = path . getParentFile ( ) ; if ( parent != null && parent . exists ( ) && filename . equals ( parent . getAbsolutePath ( ) ) ) { if ( type == null ) { log ( "Found: " + parent , Project . MSG_VERBOSE ) ; return true ; } else if ( type . isDir ( ) ) { log ( "Found directory: " + parent , Project . MSG_VERBOSE ) ; return true ; } return false ; } if ( path . exists ( ) && path . isDirectory ( ) ) { if ( checkFile ( new File ( path , filename ) , filename + " in " + path ) ) { return true ; } } while ( searchParents && parent != null && parent . exists ( ) ) { if ( checkFile ( new File ( parent , filename ) , filename + " in " + parent ) ) { return true ; } parent = parent . getParentFile ( ) ; } } } return false ; } private boolean checkFile ( File f , String text ) { if ( type != null ) { if ( type . isDir ( ) ) { if ( f . isDirectory ( ) ) { log ( "Found directory: " + text , Project . MSG_VERBOSE ) ; } return f . isDirectory ( ) ; } else if ( type . isFile ( ) ) { if ( f . isFile ( ) ) { log ( "Found file: " + text , Project . MSG_VERBOSE ) ; } return f . isFile ( ) ; } } if ( f . exists ( ) ) { log ( "Found: " + text , Project . MSG_VERBOSE ) ; } return f . exists ( ) ; } private boolean checkResource ( String resource ) { if ( loader != null ) { return ( loader . getResourceAsStream ( resource ) != null ) ; } else { ClassLoader cL = this . getClass ( ) . getClassLoader ( ) ; if ( cL != null ) { return ( cL . getResourceAsStream ( resource ) != null ) ; } else { return ( ClassLoader . getSystemResourceAsStream ( resource ) != null ) ; } } } private boolean checkClass ( String classname ) { try { if ( ignoreSystemclasses ) { loader = getProject ( ) . createClassLoader ( classpath ) ; loader . setParentFirst ( false ) ; loader . addJavaLibraries ( ) ; if ( loader != null ) { try { loader . findClass ( classname ) ; } catch ( SecurityException se ) { return true ; } } else { return false ; } } else if ( loader != null ) { loader . loadClass ( classname ) ; } else { ClassLoader l = this . getClass ( ) . getClassLoader ( ) ; if ( l != null ) { Class . forName ( classname , true , l ) ; } else { Class . forName ( classname ) ; } } return true ; } catch ( ClassNotFoundException e ) { log ( "class \"" + classname + "\" was not found" , Project . MSG_DEBUG ) ; return false ; } catch ( NoClassDefFoundError e ) { log ( "Could not load dependent class \"" + e . getMessage ( ) + "\" for class \"" + classname + "\"" , Project . MSG_DEBUG ) ; return false ; } } public static class FileDir extends EnumeratedAttribute { private static final String [ ] VALUES = { "file" , "dir" } ; public String [ ] getValues ( ) { return VALUES ; } public boolean isDir ( ) { return "dir" . equalsIgnoreCase ( getValue ( ) ) ; } public boolean isFile ( ) { return "file" . equalsIgnoreCase ( getValue ( ) ) ; } } } 	1	['22', '3', '0', '12', '71', '163', '1', '11', '17', '0.867346939', '783', '1', '5', '0.649122807', '0.25170068', '2', '2', '33.95454545', '22', '2.6818', '1']
package org . apache . tools . ant ; import java . util . ArrayList ; import java . util . Enumeration ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . io . IOException ; import org . apache . tools . ant . taskdefs . PreSetDef ; public class UnknownElement extends Task { private String elementName ; private String namespace = "" ; private String qname ; private Object realThing ; private List children = null ; private boolean presetDefed = false ; public UnknownElement ( String elementName ) { this . elementName = elementName ; } public List getChildren ( ) { return children ; } public String getTag ( ) { return elementName ; } public String getNamespace ( ) { return namespace ; } public void setNamespace ( String namespace ) { if ( namespace . equals ( ProjectHelper . ANT_CURRENT_URI ) ) { ComponentHelper helper = ComponentHelper . getComponentHelper ( getProject ( ) ) ; namespace = helper . getCurrentAntlibUri ( ) ; } this . namespace = namespace == null ? "" : namespace ; } public String getQName ( ) { return qname ; } public void setQName ( String qname ) { this . qname = qname ; } public RuntimeConfigurable getWrapper ( ) { return super . getWrapper ( ) ; } public void maybeConfigure ( ) throws BuildException { if ( realThing != null ) { return ; } configure ( makeObject ( this , getWrapper ( ) ) ) ; } public void configure ( Object realObject ) { realThing = realObject ; getWrapper ( ) . setProxy ( realThing ) ; Task task = null ; if ( realThing instanceof Task ) { task = ( Task ) realThing ; task . setRuntimeConfigurableWrapper ( getWrapper ( ) ) ; if ( getWrapper ( ) . getId ( ) != null ) { this . getOwningTarget ( ) . replaceChild ( this , ( Task ) realThing ) ; } } if ( task != null ) { task . maybeConfigure ( ) ; } else { getWrapper ( ) . maybeConfigure ( getProject ( ) ) ; } handleChildren ( realThing , getWrapper ( ) ) ; } protected void handleOutput ( String output ) { if ( realThing instanceof Task ) { ( ( Task ) realThing ) . handleOutput ( output ) ; } else { super . handleOutput ( output ) ; } } protected int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException { if ( realThing instanceof Task ) { return ( ( Task ) realThing ) . handleInput ( buffer , offset , length ) ; } else { return super . handleInput ( buffer , offset , length ) ; } } protected void handleFlush ( String output ) { if ( realThing instanceof Task ) { ( ( Task ) realThing ) . handleFlush ( output ) ; } else { super . handleFlush ( output ) ; } } protected void handleErrorOutput ( String output ) { if ( realThing instanceof Task ) { ( ( Task ) realThing ) . handleErrorOutput ( output ) ; } else { super . handleErrorOutput ( output ) ; } } protected void handleErrorFlush ( String output ) { if ( realThing instanceof Task ) { ( ( Task ) realThing ) . handleErrorOutput ( output ) ; } else { super . handleErrorOutput ( output ) ; } } public void execute ( ) { if ( realThing == null ) { throw new BuildException ( "Could not create task of type: " + elementName , getLocation ( ) ) ; } if ( realThing instanceof Task ) { ( ( Task ) realThing ) . execute ( ) ; } realThing = null ; getWrapper ( ) . setProxy ( null ) ; } public void addChild ( UnknownElement child ) { if ( children == null ) { children = new ArrayList ( ) ; } children . add ( child ) ; } protected void handleChildren ( Object parent , RuntimeConfigurable parentWrapper ) throws BuildException { if ( parent instanceof TypeAdapter ) { parent = ( ( TypeAdapter ) parent ) . getProxy ( ) ; } String parentUri = getNamespace ( ) ; Class parentClass = parent . getClass ( ) ; IntrospectionHelper ih = IntrospectionHelper . getHelper ( getProject ( ) , parentClass ) ; if ( children != null ) { Iterator it = children . iterator ( ) ; for ( int i = 0 ; it . hasNext ( ) ; i ++ ) { RuntimeConfigurable childWrapper = parentWrapper . getChild ( i ) ; UnknownElement child = ( UnknownElement ) it . next ( ) ; try { if ( ! handleChild ( parentUri , ih , parent , child , childWrapper ) ) { if ( ! ( parent instanceof TaskContainer ) ) { ih . throwNotSupported ( getProject ( ) , parent , child . getTag ( ) ) ; } else { TaskContainer container = ( TaskContainer ) parent ; container . addTask ( child ) ; } } } catch ( UnsupportedElementException ex ) { throw new BuildException ( parentWrapper . getElementTag ( ) + " doesn't support the nested \"" + ex . getElement ( ) + "\" element." , ex ) ; } } } } protected String getComponentName ( ) { return ProjectHelper . genComponentName ( getNamespace ( ) , getTag ( ) ) ; } public void applyPreSet ( UnknownElement u ) { if ( presetDefed ) { return ; } getWrapper ( ) . applyPreSet ( u . getWrapper ( ) ) ; if ( u . children != null ) { List newChildren = new ArrayList ( ) ; newChildren . addAll ( u . children ) ; if ( children != null ) { newChildren . addAll ( children ) ; } children = newChildren ; } presetDefed = true ; } protected Object makeObject ( UnknownElement ue , RuntimeConfigurable w ) { ComponentHelper helper = ComponentHelper . getComponentHelper ( getProject ( ) ) ; String name = ue . getComponentName ( ) ; Object o = helper . createComponent ( ue , ue . getNamespace ( ) , name ) ; if ( o == null ) { throw getNotFoundException ( "task or type" , name ) ; } if ( o instanceof PreSetDef . PreSetDefinition ) { PreSetDef . PreSetDefinition def = ( PreSetDef . PreSetDefinition ) o ; o = def . createObject ( ue . getProject ( ) ) ; if ( o == null ) { throw getNotFoundException ( "preset " + name , def . getPreSets ( ) . getComponentName ( ) ) ; } ue . applyPreSet ( def . getPreSets ( ) ) ; if ( o instanceof Task ) { Task task = ( Task ) o ; task . setTaskType ( ue . getTaskType ( ) ) ; task . setTaskName ( ue . getTaskName ( ) ) ; task . init ( ) ; } } if ( o instanceof UnknownElement ) { o = ( ( UnknownElement ) o ) . makeObject ( ( UnknownElement ) o , w ) ; } if ( o instanceof Task ) { ( ( Task ) o ) . setOwningTarget ( getOwningTarget ( ) ) ; } if ( o instanceof ProjectComponent ) { ( ( ProjectComponent ) o ) . setLocation ( getLocation ( ) ) ; } return o ; } protected Task makeTask ( UnknownElement ue , RuntimeConfigurable w ) { Task task = getProject ( ) . createTask ( ue . getTag ( ) ) ; if ( task != null ) { task . setLocation ( getLocation ( ) ) ; task . setOwningTarget ( getOwningTarget ( ) ) ; task . init ( ) ; } return task ; } protected BuildException getNotFoundException ( String what , String name ) { ComponentHelper helper = ComponentHelper . getComponentHelper ( getProject ( ) ) ; String msg = helper . diagnoseCreationFailure ( name , what ) ; return new BuildException ( msg , getLocation ( ) ) ; } public String getTaskName ( ) { return realThing == null || ! ( realThing instanceof Task ) ? super . getTaskName ( ) : ( ( Task ) realThing ) . getTaskName ( ) ; } public Task getTask ( ) { if ( realThing instanceof Task ) { return ( Task ) realThing ; } return null ; } public Object getRealThing ( ) { return realThing ; } public void setRealThing ( Object realThing ) { this . realThing = realThing ; } private boolean handleChild ( String parentUri , IntrospectionHelper ih , Object parent , UnknownElement child , RuntimeConfigurable childWrapper ) { String childName = ProjectHelper . genComponentName ( child . getNamespace ( ) , child . getTag ( ) ) ; if ( ih . supportsNestedElement ( parentUri , childName ) ) { IntrospectionHelper . Creator creator = ih . getElementCreator ( getProject ( ) , parentUri , parent , childName , child ) ; creator . setPolyType ( childWrapper . getPolyType ( ) ) ; Object realChild = creator . create ( ) ; if ( realChild instanceof PreSetDef . PreSetDefinition ) { PreSetDef . PreSetDefinition def = ( PreSetDef . PreSetDefinition ) realChild ; realChild = creator . getRealObject ( ) ; child . applyPreSet ( def . getPreSets ( ) ) ; } childWrapper . setCreator ( creator ) ; childWrapper . setProxy ( realChild ) ; if ( realChild instanceof Task ) { Task childTask = ( Task ) realChild ; childTask . setRuntimeConfigurableWrapper ( childWrapper ) ; childTask . setTaskName ( childName ) ; childTask . setTaskType ( childName ) ; } if ( realChild instanceof ProjectComponent ) { ( ( ProjectComponent ) realChild ) . setLocation ( child . getLocation ( ) ) ; } childWrapper . maybeConfigure ( getProject ( ) ) ; child . handleChildren ( realChild , childWrapper ) ; creator . store ( ) ; return true ; } return false ; } public boolean similar ( Object obj ) { if ( obj == null ) { return false ; } if ( ! getClass ( ) . getName ( ) . equals ( obj . getClass ( ) . getName ( ) ) ) { return false ; } UnknownElement other = ( UnknownElement ) obj ; if ( ! equalsString ( elementName , other . elementName ) ) { return false ; } if ( ! namespace . equals ( other . namespace ) ) { return false ; } if ( ! qname . equals ( other . qname ) ) { return false ; } if ( ! getWrapper ( ) . getAttributeMap ( ) . equals ( other . getWrapper ( ) . getAttributeMap ( ) ) ) { return false ; } if ( ! getWrapper ( ) . getText ( ) . toString ( ) . equals ( other . getWrapper ( ) . getText ( ) . toString ( ) ) ) { return false ; } if ( children == null || children . size ( ) == 0 ) { return other . children == null || other . children . size ( ) == 0 ; } if ( other . children == null ) { return false ; } if ( children . size ( ) != other . children . size ( ) ) { return false ; } for ( int i = 0 ; i < children . size ( ) ; ++ i ) { UnknownElement child = ( UnknownElement ) children . get ( i ) ; if ( ! child . similar ( other . children . get ( i ) ) ) { return false ; } } return true ; } private static boolean equalsString ( String a , String b ) { return ( a == null ) ? ( b == null ) : a . equals ( b ) ; } public UnknownElement copy ( Project newProject ) { UnknownElement ret = new UnknownElement ( getTag ( ) ) ; ret . setNamespace ( getNamespace ( ) ) ; ret . setProject ( newProject ) ; ret . setQName ( getQName ( ) ) ; ret . setTaskType ( getTaskType ( ) ) ; ret . setTaskName ( getTaskName ( ) ) ; ret . setLocation ( getLocation ( ) ) ; if ( getOwningTarget ( ) == null ) { Target t = new Target ( ) ; t . setProject ( getProject ( ) ) ; ret . setOwningTarget ( t ) ; } else { ret . setOwningTarget ( getOwningTarget ( ) ) ; } RuntimeConfigurable copyRC = new RuntimeConfigurable ( ret , getTaskName ( ) ) ; copyRC . setPolyType ( getWrapper ( ) . getPolyType ( ) ) ; Map m = getWrapper ( ) . getAttributeMap ( ) ; for ( Iterator i = m . entrySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) i . next ( ) ; copyRC . setAttribute ( ( String ) entry . getKey ( ) , ( String ) entry . getValue ( ) ) ; } copyRC . addText ( getWrapper ( ) . getText ( ) . toString ( ) ) ; for ( Enumeration e = getWrapper ( ) . getChildren ( ) ; e . hasMoreElements ( ) ; ) { RuntimeConfigurable r = ( RuntimeConfigurable ) e . nextElement ( ) ; UnknownElement ueChild = ( UnknownElement ) r . getProxy ( ) ; UnknownElement copyChild = ueChild . copy ( newProject ) ; copyRC . addChild ( copyChild . getWrapper ( ) ) ; ret . addChild ( copyChild ) ; } return ret ; } } 	1	['31', '3', '0', '29', '119', '277', '19', '15', '19', '0.744444444', '900', '1', '0', '0.552238806', '0.207885305', '1', '5', '27.83870968', '16', '2.5806', '3']
package org . apache . tools . ant . taskdefs ; import java . security . DigestInputStream ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . security . NoSuchProviderException ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FileInputStream ; import java . io . FileReader ; import java . io . BufferedReader ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import java . util . Iterator ; import java . util . Hashtable ; import java . util . Enumeration ; import java . util . Set ; import java . util . Arrays ; import java . text . MessageFormat ; import java . text . ParseException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . Union ; import org . apache . tools . ant . types . resources . Restrict ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . selectors . Type ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . StringUtils ; public class Checksum extends MatchingTask implements Condition { private static class FileUnion extends Restrict { private Union u ; FileUnion ( ) { u = new Union ( ) ; super . add ( u ) ; super . add ( Type . FILE ) ; } public void add ( ResourceCollection rc ) { u . add ( rc ) ; } } private File file = null ; private File todir ; private String algorithm = "MD5" ; private String provider = null ; private String fileext ; private String property ; private Map allDigests = new HashMap ( ) ; private Map relativeFilePaths = new HashMap ( ) ; private String totalproperty ; private boolean forceOverwrite ; private String verifyProperty ; private FileUnion resources = null ; private Hashtable includeFileMap = new Hashtable ( ) ; private MessageDigest messageDigest ; private boolean isCondition ; private int readBufferSize = 8 * 1024 ; private MessageFormat format = FormatElement . getDefault ( ) . getFormat ( ) ; public void setFile ( File file ) { this . file = file ; } public void setTodir ( File todir ) { this . todir = todir ; } public void setAlgorithm ( String algorithm ) { this . algorithm = algorithm ; } public void setProvider ( String provider ) { this . provider = provider ; } public void setFileext ( String fileext ) { this . fileext = fileext ; } public void setProperty ( String property ) { this . property = property ; } public void setTotalproperty ( String totalproperty ) { this . totalproperty = totalproperty ; } public void setVerifyproperty ( String verifyProperty ) { this . verifyProperty = verifyProperty ; } public void setForceOverwrite ( boolean forceOverwrite ) { this . forceOverwrite = forceOverwrite ; } public void setReadBufferSize ( int size ) { this . readBufferSize = size ; } public void setFormat ( FormatElement e ) { format = e . getFormat ( ) ; } public void setPattern ( String p ) { format = new MessageFormat ( p ) ; } public void addFileset ( FileSet set ) { add ( set ) ; } public void add ( ResourceCollection rc ) { if ( rc == null ) { return ; } resources = ( resources == null ) ? new FileUnion ( ) : resources ; resources . add ( rc ) ; } public void execute ( ) throws BuildException { isCondition = false ; boolean value = validateAndExecute ( ) ; if ( verifyProperty != null ) { getProject ( ) . setNewProperty ( verifyProperty , ( value ? Boolean . TRUE . toString ( ) : Boolean . FALSE . toString ( ) ) ) ; } } public boolean eval ( ) throws BuildException { isCondition = true ; return validateAndExecute ( ) ; } private boolean validateAndExecute ( ) throws BuildException { String savedFileExt = fileext ; if ( file == null && ( resources == null || resources . size ( ) == 0 ) ) { throw new BuildException ( "Specify at least one source - a file or a resource collection." ) ; } if ( ! ( resources == null || resources . isFilesystemOnly ( ) ) ) { throw new BuildException ( "Can only calculate checksums for file-based resources." ) ; } if ( file != null && file . exists ( ) && file . isDirectory ( ) ) { throw new BuildException ( "Checksum cannot be generated for directories" ) ; } if ( file != null && totalproperty != null ) { throw new BuildException ( "File and Totalproperty cannot co-exist." ) ; } if ( property != null && fileext != null ) { throw new BuildException ( "Property and FileExt cannot co-exist." ) ; } if ( property != null ) { if ( forceOverwrite ) { throw new BuildException ( "ForceOverwrite cannot be used when Property is specified" ) ; } int ct = 0 ; if ( resources != null ) { ct += resources . size ( ) ; } if ( file != null ) { ct ++ ; } if ( ct > 1 ) { throw new BuildException ( "Multiple files cannot be used when Property is specified" ) ; } } if ( verifyProperty != null ) { isCondition = true ; } if ( verifyProperty != null && forceOverwrite ) { throw new BuildException ( "VerifyProperty and ForceOverwrite cannot co-exist." ) ; } if ( isCondition && forceOverwrite ) { throw new BuildException ( "ForceOverwrite cannot be used when conditions are being used." ) ; } messageDigest = null ; if ( provider != null ) { try { messageDigest = MessageDigest . getInstance ( algorithm , provider ) ; } catch ( NoSuchAlgorithmException noalgo ) { throw new BuildException ( noalgo , getLocation ( ) ) ; } catch ( NoSuchProviderException noprovider ) { throw new BuildException ( noprovider , getLocation ( ) ) ; } } else { try { messageDigest = MessageDigest . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException noalgo ) { throw new BuildException ( noalgo , getLocation ( ) ) ; } } if ( messageDigest == null ) { throw new BuildException ( "Unable to create Message Digest" , getLocation ( ) ) ; } if ( fileext == null ) { fileext = "." + algorithm ; } else if ( fileext . trim ( ) . length ( ) == 0 ) { throw new BuildException ( "File extension when specified must not be an empty string" ) ; } try { if ( resources != null ) { for ( Iterator i = resources . iterator ( ) ; i . hasNext ( ) ; ) { FileResource fr = ( FileResource ) i . next ( ) ; File src = fr . getFile ( ) ; if ( totalproperty != null || todir != null ) { relativeFilePaths . put ( src , fr . getName ( ) . replace ( File . separatorChar , '/' ) ) ; } addToIncludeFileMap ( src ) ; } } if ( file != null ) { if ( totalproperty != null || todir != null ) { relativeFilePaths . put ( file , file . getName ( ) . replace ( File . separatorChar , '/' ) ) ; } addToIncludeFileMap ( file ) ; } return generateChecksums ( ) ; } finally { fileext = savedFileExt ; includeFileMap . clear ( ) ; } } private void addToIncludeFileMap ( File file ) throws BuildException { if ( file . exists ( ) ) { if ( property == null ) { File checksumFile = getChecksumFile ( file ) ; if ( forceOverwrite || isCondition || ( file . lastModified ( ) > checksumFile . lastModified ( ) ) ) { includeFileMap . put ( file , checksumFile ) ; } else { log ( file + " omitted as " + checksumFile + " is up to date." , Project . MSG_VERBOSE ) ; if ( totalproperty != null ) { String checksum = readChecksum ( checksumFile ) ; byte [ ] digest = decodeHex ( checksum . toCharArray ( ) ) ; allDigests . put ( file , digest ) ; } } } else { includeFileMap . put ( file , property ) ; } } else { String message = "Could not find file " + file . getAbsolutePath ( ) + " to generate checksum for." ; log ( message ) ; throw new BuildException ( message , getLocation ( ) ) ; } } private File getChecksumFile ( File file ) { File directory ; if ( todir != null ) { String path = ( String ) relativeFilePaths . get ( file ) ; if ( path == null ) { throw new BuildException ( "Internal error: " + "relativeFilePaths could not match file" + file + "\n" + "please file a bug report on this" ) ; } directory = new File ( todir , path ) . getParentFile ( ) ; directory . mkdirs ( ) ; } else { directory = file . getParentFile ( ) ; } File checksumFile = new File ( directory , file . getName ( ) + fileext ) ; return checksumFile ; } private boolean generateChecksums ( ) throws BuildException { boolean checksumMatches = true ; FileInputStream fis = null ; FileOutputStream fos = null ; byte [ ] buf = new byte [ readBufferSize ] ; try { for ( Enumeration e = includeFileMap . keys ( ) ; e . hasMoreElements ( ) ; ) { messageDigest . reset ( ) ; File src = ( File ) e . nextElement ( ) ; if ( ! isCondition ) { log ( "Calculating " + algorithm + " checksum for " + src , Project . MSG_VERBOSE ) ; } fis = new FileInputStream ( src ) ; DigestInputStream dis = new DigestInputStream ( fis , messageDigest ) ; while ( dis . read ( buf , 0 , readBufferSize ) != - 1 ) { } dis . close ( ) ; fis . close ( ) ; fis = null ; byte [ ] fileDigest = messageDigest . digest ( ) ; if ( totalproperty != null ) { allDigests . put ( src , fileDigest ) ; } String checksum = createDigestString ( fileDigest ) ; Object destination = includeFileMap . get ( src ) ; if ( destination instanceof java . lang . String ) { String prop = ( String ) destination ; if ( isCondition ) { checksumMatches = checksumMatches && checksum . equals ( property ) ; } else { getProject ( ) . setNewProperty ( prop , checksum ) ; } } else if ( destination instanceof java . io . File ) { if ( isCondition ) { File existingFile = ( File ) destination ; if ( existingFile . exists ( ) ) { try { String suppliedChecksum = readChecksum ( existingFile ) ; checksumMatches = checksumMatches && checksum . equals ( suppliedChecksum ) ; } catch ( BuildException be ) { checksumMatches = false ; } } else { checksumMatches = false ; } } else { File dest = ( File ) destination ; fos = new FileOutputStream ( dest ) ; fos . write ( format . format ( new Object [ ] { checksum , src . getName ( ) , } ) . getBytes ( ) ) ; fos . write ( StringUtils . LINE_SEP . getBytes ( ) ) ; fos . close ( ) ; fos = null ; } } } if ( totalproperty != null ) { Set keys = allDigests . keySet ( ) ; Object [ ] keyArray = keys . toArray ( ) ; Arrays . sort ( keyArray ) ; messageDigest . reset ( ) ; for ( int i = 0 ; i < keyArray . length ; i ++ ) { File src = ( File ) keyArray [ i ] ; byte [ ] digest = ( byte [ ] ) allDigests . get ( src ) ; messageDigest . update ( digest ) ; String fileName = ( String ) relativeFilePaths . get ( src ) ; messageDigest . update ( fileName . getBytes ( ) ) ; } String totalChecksum = createDigestString ( messageDigest . digest ( ) ) ; getProject ( ) . setNewProperty ( totalproperty , totalChecksum ) ; } } catch ( Exception e ) { throw new BuildException ( e , getLocation ( ) ) ; } finally { FileUtils . close ( fis ) ; FileUtils . close ( fos ) ; } return checksumMatches ; } private String createDigestString ( byte [ ] fileDigest ) { StringBuffer checksumSb = new StringBuffer ( ) ; for ( int i = 0 ; i < fileDigest . length ; i ++ ) { String hexStr = Integer . toHexString ( 0x00ff & fileDigest [ i ] ) ; if ( hexStr . length ( ) < 2 ) { checksumSb . append ( "0" ) ; } checksumSb . append ( hexStr ) ; } return checksumSb . toString ( ) ; } public static byte [ ] decodeHex ( char [ ] data ) throws BuildException { int l = data . length ; if ( ( l & 0x01 ) != 0 ) { throw new BuildException ( "odd number of characters." ) ; } byte [ ] out = new byte [ l > > 1 ] ; for ( int i = 0 , j = 0 ; j < l ; i ++ ) { int f = Character . digit ( data [ j ++ ] , 16 ) << 4 ; f = f | Character . digit ( data [ j ++ ] , 16 ) ; out [ i ] = ( byte ) ( f & 0xFF ) ; } return out ; } private String readChecksum ( File f ) { BufferedReader diskChecksumReader = null ; try { diskChecksumReader = new BufferedReader ( new FileReader ( f ) ) ; Object [ ] result = format . parse ( diskChecksumReader . readLine ( ) ) ; if ( result == null || result . length == 0 || result [ 0 ] == null ) { throw new BuildException ( "failed to find a checksum" ) ; } return ( String ) result [ 0 ] ; } catch ( IOException e ) { throw new BuildException ( "Couldn't read checksum file " + f , e ) ; } catch ( ParseException e ) { throw new BuildException ( "Couldn't read checksum file " + f , e ) ; } finally { FileUtils . close ( diskChecksumReader ) ; } } public static class FormatElement extends EnumeratedAttribute { private static HashMap formatMap = new HashMap ( ) ; private static final String CHECKSUM = "CHECKSUM" ; private static final String MD5SUM = "MD5SUM" ; private static final String SVF = "SVF" ; static { formatMap . put ( CHECKSUM , new MessageFormat ( "{0}" ) ) ; formatMap . put ( MD5SUM , new MessageFormat ( "{0} *{1}" ) ) ; formatMap . put ( SVF , new MessageFormat ( "MD5 ({1}) = {0}" ) ) ; } public FormatElement ( ) { super ( ) ; } public static FormatElement getDefault ( ) { FormatElement e = new FormatElement ( ) ; e . setValue ( CHECKSUM ) ; return e ; } public MessageFormat getFormat ( ) { return ( MessageFormat ) formatMap . get ( getValue ( ) ) ; } public String [ ] getValues ( ) { return new String [ ] { CHECKSUM , MD5SUM , SVF } ; } } } 	1	['24', '4', '0', '13', '103', '176', '1', '12', '18', '0.808184143', '1046', '1', '1', '0.772277228', '0.175', '0', '0', '41.875', '6', '1.4167', '2']
package org . apache . tools . ant . types . resources ; import java . io . File ; import java . util . Stack ; import java . util . Iterator ; import java . util . Collection ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . ant . types . ResourceCollection ; public abstract class BaseResourceCollectionWrapper extends DataType implements ResourceCollection , Cloneable { private static final String ONE_NESTED_MESSAGE = " expects exactly one nested resource collection." ; private ResourceCollection rc ; private Collection coll = null ; private boolean cache = true ; public synchronized void setCache ( boolean b ) { cache = b ; } public synchronized boolean isCache ( ) { return cache ; } public synchronized void add ( ResourceCollection c ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( c == null ) { return ; } if ( rc != null ) { throw oneNested ( ) ; } rc = c ; setChecked ( false ) ; } public final synchronized Iterator iterator ( ) { if ( isReference ( ) ) { return ( ( BaseResourceCollectionWrapper ) getCheckedRef ( ) ) . iterator ( ) ; } dieOnCircularReference ( ) ; return new FailFast ( this , cacheCollection ( ) . iterator ( ) ) ; } public synchronized int size ( ) { if ( isReference ( ) ) { return ( ( BaseResourceCollectionWrapper ) getCheckedRef ( ) ) . size ( ) ; } dieOnCircularReference ( ) ; return cacheCollection ( ) . size ( ) ; } public synchronized boolean isFilesystemOnly ( ) { if ( isReference ( ) ) { return ( ( BaseResourceCollectionContainer ) getCheckedRef ( ) ) . isFilesystemOnly ( ) ; } dieOnCircularReference ( ) ; if ( rc == null || rc . isFilesystemOnly ( ) ) { return true ; } for ( Iterator i = cacheCollection ( ) . iterator ( ) ; i . hasNext ( ) ; ) { if ( ! ( i . next ( ) instanceof FileResource ) ) { return false ; } } return true ; } protected synchronized void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( isChecked ( ) ) { return ; } if ( isReference ( ) ) { super . dieOnCircularReference ( stk , p ) ; } else { if ( rc instanceof DataType ) { stk . push ( rc ) ; invokeCircularReferenceCheck ( ( DataType ) rc , stk , p ) ; stk . pop ( ) ; } setChecked ( true ) ; } } protected final synchronized ResourceCollection getResourceCollection ( ) { dieOnCircularReference ( ) ; if ( rc == null ) { throw oneNested ( ) ; } return rc ; } protected abstract Collection getCollection ( ) ; public synchronized String toString ( ) { if ( isReference ( ) ) { return getCheckedRef ( ) . toString ( ) ; } if ( cacheCollection ( ) . size ( ) == 0 ) { return "" ; } StringBuffer sb = new StringBuffer ( ) ; for ( Iterator i = coll . iterator ( ) ; i . hasNext ( ) ; ) { if ( sb . length ( ) > 0 ) { sb . append ( File . pathSeparatorChar ) ; } sb . append ( i . next ( ) ) ; } return sb . toString ( ) ; } private synchronized Collection cacheCollection ( ) { if ( coll == null || ! isCache ( ) ) { coll = getCollection ( ) ; } return coll ; } private BuildException oneNested ( ) { return new BuildException ( super . toString ( ) + ONE_NESTED_MESSAGE ) ; } } 	1	['13', '3', '4', '12', '42', '54', '5', '7', '8', '0.791666667', '233', '1', '1', '0.714285714', '0.261538462', '1', '3', '16.61538462', '6', '2', '1']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . Reader ; import java . io . FileReader ; import java . io . IOException ; import java . io . BufferedReader ; import java . io . FileInputStream ; import java . io . InputStreamReader ; import java . util . Vector ; import java . util . Enumeration ; import java . util . NoSuchElementException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . filters . FixCrLfFilter ; import org . apache . tools . ant . filters . ChainableReader ; import org . apache . tools . ant . types . FilterChain ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . util . FileUtils ; public class FixCRLF extends MatchingTask implements ChainableReader { public static final String ERROR_FILE_AND_SRCDIR = "srcdir and file are mutually exclusive" ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private boolean preserveLastModified = false ; private File srcDir ; private File destDir = null ; private File file ; private FixCrLfFilter filter = new FixCrLfFilter ( ) ; private Vector fcv = null ; private String encoding = null ; private String outputEncoding = null ; public final Reader chain ( final Reader rdr ) { return filter . chain ( rdr ) ; } public void setSrcdir ( File srcDir ) { this . srcDir = srcDir ; } public void setDestdir ( File destDir ) { this . destDir = destDir ; } public void setJavafiles ( boolean javafiles ) { filter . setJavafiles ( javafiles ) ; } public void setFile ( File file ) { this . file = file ; } public void setEol ( CrLf attr ) { filter . setEol ( FixCrLfFilter . CrLf . newInstance ( attr . getValue ( ) ) ) ; } public void setCr ( AddAsisRemove attr ) { log ( "DEPRECATED: The cr attribute has been deprecated," , Project . MSG_WARN ) ; log ( "Please use the eol attribute instead" , Project . MSG_WARN ) ; String option = attr . getValue ( ) ; CrLf c = new CrLf ( ) ; if ( option . equals ( "remove" ) ) { c . setValue ( "lf" ) ; } else if ( option . equals ( "asis" ) ) { c . setValue ( "asis" ) ; } else { c . setValue ( "crlf" ) ; } setEol ( c ) ; } public void setTab ( AddAsisRemove attr ) { filter . setTab ( FixCrLfFilter . AddAsisRemove . newInstance ( attr . getValue ( ) ) ) ; } public void setTablength ( int tlength ) throws BuildException { try { filter . setTablength ( tlength ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } public void setEof ( AddAsisRemove attr ) { filter . setEof ( FixCrLfFilter . AddAsisRemove . newInstance ( attr . getValue ( ) ) ) ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public void setOutputEncoding ( String outputEncoding ) { this . outputEncoding = outputEncoding ; } public void setFixlast ( boolean fixlast ) { filter . setFixlast ( fixlast ) ; } public void setPreserveLastModified ( boolean preserve ) { preserveLastModified = preserve ; } public void execute ( ) throws BuildException { validate ( ) ; String enc = encoding == null ? "default" : encoding ; log ( "options:" + " eol=" + filter . getEol ( ) . getValue ( ) + " tab=" + filter . getTab ( ) . getValue ( ) + " eof=" + filter . getEof ( ) . getValue ( ) + " tablength=" + filter . getTablength ( ) + " encoding=" + enc + " outputencoding=" + ( outputEncoding == null ? enc : outputEncoding ) , Project . MSG_VERBOSE ) ; DirectoryScanner ds = super . getDirectoryScanner ( srcDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { processFile ( files [ i ] ) ; } } private void validate ( ) throws BuildException { if ( file != null ) { if ( srcDir != null ) { throw new BuildException ( ERROR_FILE_AND_SRCDIR ) ; } fileset . setFile ( file ) ; srcDir = file . getParentFile ( ) ; } if ( srcDir == null ) { throw new BuildException ( "srcdir attribute must be set!" ) ; } if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir does not exist!" ) ; } if ( ! srcDir . isDirectory ( ) ) { throw new BuildException ( "srcdir is not a directory!" ) ; } if ( destDir != null ) { if ( ! destDir . exists ( ) ) { throw new BuildException ( "destdir does not exist!" ) ; } if ( ! destDir . isDirectory ( ) ) { throw new BuildException ( "destdir is not a directory!" ) ; } } } private void processFile ( String file ) throws BuildException { File srcFile = new File ( srcDir , file ) ; long lastModified = srcFile . lastModified ( ) ; File destD = destDir == null ? srcDir : destDir ; if ( fcv == null ) { FilterChain fc = new FilterChain ( ) ; fc . add ( filter ) ; fcv = new Vector ( 1 ) ; fcv . add ( fc ) ; } File tmpFile = FILE_UTILS . createTempFile ( "fixcrlf" , "" , null ) ; tmpFile . deleteOnExit ( ) ; try { FILE_UTILS . copyFile ( srcFile , tmpFile , null , fcv , false , false , encoding , outputEncoding == null ? encoding : outputEncoding , getProject ( ) ) ; File destFile = new File ( destD , file ) ; boolean destIsWrong = true ; if ( destFile . exists ( ) ) { log ( "destFile exists" , Project . MSG_DEBUG ) ; destIsWrong = ! FILE_UTILS . contentEquals ( destFile , tmpFile ) ; log ( destFile + ( destIsWrong ? " is being written" : " is not written, as the contents are identical" ) , Project . MSG_DEBUG ) ; } if ( destIsWrong ) { FILE_UTILS . rename ( tmpFile , destFile ) ; if ( preserveLastModified ) { log ( "preserved lastModified" , Project . MSG_DEBUG ) ; FILE_UTILS . setFileLastModified ( destFile , lastModified ) ; } tmpFile = null ; } } catch ( IOException e ) { throw new BuildException ( e ) ; } } protected class OneLiner implements Enumeration { private static final int UNDEF = - 1 ; private static final int NOTJAVA = 0 ; private static final int LOOKING = 1 ; private static final int INBUFLEN = 8192 ; private static final int LINEBUFLEN = 200 ; private static final char CTRLZ = '' ; private int state = filter . getJavafiles ( ) ? LOOKING : NOTJAVA ; private StringBuffer eolStr = new StringBuffer ( LINEBUFLEN ) ; private StringBuffer eofStr = new StringBuffer ( ) ; private BufferedReader reader ; private StringBuffer line = new StringBuffer ( ) ; private boolean reachedEof = false ; private File srcFile ; public OneLiner ( File srcFile ) throws BuildException { this . srcFile = srcFile ; try { reader = new BufferedReader ( ( ( encoding == null ) ? new FileReader ( srcFile ) : new InputStreamReader ( new FileInputStream ( srcFile ) , encoding ) ) , INBUFLEN ) ; nextLine ( ) ; } catch ( IOException e ) { throw new BuildException ( srcFile + ": " + e . getMessage ( ) , e , getLocation ( ) ) ; } } protected void nextLine ( ) throws BuildException { int ch = - 1 ; int eolcount = 0 ; eolStr = new StringBuffer ( ) ; line = new StringBuffer ( ) ; try { ch = reader . read ( ) ; while ( ch != - 1 && ch != '\r' && ch != '\n' ) { line . append ( ( char ) ch ) ; ch = reader . read ( ) ; } if ( ch == - 1 && line . length ( ) == 0 ) { reachedEof = true ; return ; } switch ( ( char ) ch ) { case '\r' : ++ eolcount ; eolStr . append ( '\r' ) ; reader . mark ( 2 ) ; ch = reader . read ( ) ; switch ( ch ) { case '\r' : ch = reader . read ( ) ; if ( ( char ) ( ch ) == '\n' ) { eolcount += 2 ; eolStr . append ( "\r\n" ) ; } else { reader . reset ( ) ; } break ; case '\n' : ++ eolcount ; eolStr . append ( '\n' ) ; break ; case - 1 : break ; default : reader . reset ( ) ; break ; } break ; case '\n' : ++ eolcount ; eolStr . append ( '\n' ) ; break ; default : } if ( eolcount == 0 ) { int i = line . length ( ) ; while ( -- i >= 0 && line . charAt ( i ) == CTRLZ ) { } if ( i < line . length ( ) - 1 ) { eofStr . append ( line . toString ( ) . substring ( i + 1 ) ) ; if ( i < 0 ) { line . setLength ( 0 ) ; reachedEof = true ; } else { line . setLength ( i + 1 ) ; } } } } catch ( IOException e ) { throw new BuildException ( srcFile + ": " + e . getMessage ( ) , e , getLocation ( ) ) ; } } public String getEofStr ( ) { return eofStr . substring ( 0 ) ; } public int getState ( ) { return state ; } public void setState ( int state ) { this . state = state ; } public boolean hasMoreElements ( ) { return ! reachedEof ; } public Object nextElement ( ) throws NoSuchElementException { if ( ! hasMoreElements ( ) ) { throw new NoSuchElementException ( "OneLiner" ) ; } BufferLine tmpLine = new BufferLine ( line . toString ( ) , eolStr . substring ( 0 ) ) ; nextLine ( ) ; return tmpLine ; } public void close ( ) throws IOException { if ( reader != null ) { reader . close ( ) ; } } class BufferLine { private int next = 0 ; private int column = 0 ; private int lookahead = UNDEF ; private String line ; private String eolStr ; public BufferLine ( String line , String eolStr ) throws BuildException { next = 0 ; column = 0 ; this . line = line ; this . eolStr = eolStr ; } public int getNext ( ) { return next ; } public void setNext ( int next ) { this . next = next ; } public int getLookahead ( ) { return lookahead ; } public void setLookahead ( int lookahead ) { this . lookahead = lookahead ; } public char getChar ( int i ) { return line . charAt ( i ) ; } public char getNextChar ( ) { return getChar ( next ) ; } public char getNextCharInc ( ) { return getChar ( next ++ ) ; } public int getColumn ( ) { return column ; } public void setColumn ( int col ) { column = col ; } public int incColumn ( ) { return column ++ ; } public int length ( ) { return line . length ( ) ; } public int getEolLength ( ) { return eolStr . length ( ) ; } public String getLineString ( ) { return line ; } public String getEol ( ) { return eolStr ; } public String substring ( int begin ) { return line . substring ( begin ) ; } public String substring ( int begin , int end ) { return line . substring ( begin , end ) ; } public void setState ( int state ) { OneLiner . this . setState ( state ) ; } public int getState ( ) { return OneLiner . this . getState ( ) ; } } } public static class AddAsisRemove extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "add" , "asis" , "remove" } ; } } public static class CrLf extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "asis" , "cr" , "lf" , "crlf" , "mac" , "unix" , "dos" } ; } } } 	1	['21', '4', '0', '15', '72', '54', '1', '14', '16', '0.835', '457', '0.9', '2', '0.804123711', '0.194444444', '2', '2', '20.28571429', '3', '1', '2']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . MagicNames ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . compilers . CompilerAdapter ; import org . apache . tools . ant . taskdefs . compilers . CompilerAdapterFactory ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . GlobPatternMapper ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . apache . tools . ant . util . SourceFileScanner ; import org . apache . tools . ant . util . facade . FacadeTaskHelper ; public class Javac extends MatchingTask { private static final String FAIL_MSG = "Compile failed; see the compiler error output for details." ; private static final String JAVAC16 = "javac1.6" ; private static final String JAVAC15 = "javac1.5" ; private static final String JAVAC14 = "javac1.4" ; private static final String JAVAC13 = "javac1.3" ; private static final String JAVAC12 = "javac1.2" ; private static final String JAVAC11 = "javac1.1" ; private static final String MODERN = "modern" ; private static final String CLASSIC = "classic" ; private static final String EXTJAVAC = "extJavac" ; private Path src ; private File destDir ; private Path compileClasspath ; private Path compileSourcepath ; private String encoding ; private boolean debug = false ; private boolean optimize = false ; private boolean deprecation = false ; private boolean depend = false ; private boolean verbose = false ; private String targetAttribute ; private Path bootclasspath ; private Path extdirs ; private boolean includeAntRuntime = true ; private boolean includeJavaRuntime = false ; private boolean fork = false ; private String forkedExecutable = null ; private boolean nowarn = false ; private String memoryInitialSize ; private String memoryMaximumSize ; private FacadeTaskHelper facade = null ; protected boolean failOnError = true ; protected boolean listFiles = false ; protected File [ ] compileList = new File [ 0 ] ; private String source ; private String debugLevel ; private File tmpDir ; public Javac ( ) { facade = new FacadeTaskHelper ( assumedJavaVersion ( ) ) ; } private String assumedJavaVersion ( ) { if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_2 ) ) { return JAVAC12 ; } else if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_3 ) ) { return JAVAC13 ; } else if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_4 ) ) { return JAVAC14 ; } else if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_5 ) ) { return JAVAC15 ; } else if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_6 ) ) { return JAVAC16 ; } else { return CLASSIC ; } } public String getDebugLevel ( ) { return debugLevel ; } public void setDebugLevel ( String v ) { this . debugLevel = v ; } public String getSource ( ) { return source != null ? source : getProject ( ) . getProperty ( MagicNames . BUILD_JAVAC_SOURCE ) ; } public void setSource ( String v ) { this . source = v ; } public Path createSrc ( ) { if ( src == null ) { src = new Path ( getProject ( ) ) ; } return src . createPath ( ) ; } protected Path recreateSrc ( ) { src = null ; return createSrc ( ) ; } public void setSrcdir ( Path srcDir ) { if ( src == null ) { src = srcDir ; } else { src . append ( srcDir ) ; } } public Path getSrcdir ( ) { return src ; } public void setDestdir ( File destDir ) { this . destDir = destDir ; } public File getDestdir ( ) { return destDir ; } public void setSourcepath ( Path sourcepath ) { if ( compileSourcepath == null ) { compileSourcepath = sourcepath ; } else { compileSourcepath . append ( sourcepath ) ; } } public Path getSourcepath ( ) { return compileSourcepath ; } public Path createSourcepath ( ) { if ( compileSourcepath == null ) { compileSourcepath = new Path ( getProject ( ) ) ; } return compileSourcepath . createPath ( ) ; } public void setSourcepathRef ( Reference r ) { createSourcepath ( ) . setRefid ( r ) ; } public void setClasspath ( Path classpath ) { if ( compileClasspath == null ) { compileClasspath = classpath ; } else { compileClasspath . append ( classpath ) ; } } public Path getClasspath ( ) { return compileClasspath ; } public Path createClasspath ( ) { if ( compileClasspath == null ) { compileClasspath = new Path ( getProject ( ) ) ; } return compileClasspath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setBootclasspath ( Path bootclasspath ) { if ( this . bootclasspath == null ) { this . bootclasspath = bootclasspath ; } else { this . bootclasspath . append ( bootclasspath ) ; } } public Path getBootclasspath ( ) { return bootclasspath ; } public Path createBootclasspath ( ) { if ( bootclasspath == null ) { bootclasspath = new Path ( getProject ( ) ) ; } return bootclasspath . createPath ( ) ; } public void setBootClasspathRef ( Reference r ) { createBootclasspath ( ) . setRefid ( r ) ; } public void setExtdirs ( Path extdirs ) { if ( this . extdirs == null ) { this . extdirs = extdirs ; } else { this . extdirs . append ( extdirs ) ; } } public Path getExtdirs ( ) { return extdirs ; } public Path createExtdirs ( ) { if ( extdirs == null ) { extdirs = new Path ( getProject ( ) ) ; } return extdirs . createPath ( ) ; } public void setListfiles ( boolean list ) { listFiles = list ; } public boolean getListfiles ( ) { return listFiles ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } public void setProceed ( boolean proceed ) { failOnError = ! proceed ; } public boolean getFailonerror ( ) { return failOnError ; } public void setDeprecation ( boolean deprecation ) { this . deprecation = deprecation ; } public boolean getDeprecation ( ) { return deprecation ; } public void setMemoryInitialSize ( String memoryInitialSize ) { this . memoryInitialSize = memoryInitialSize ; } public String getMemoryInitialSize ( ) { return memoryInitialSize ; } public void setMemoryMaximumSize ( String memoryMaximumSize ) { this . memoryMaximumSize = memoryMaximumSize ; } public String getMemoryMaximumSize ( ) { return memoryMaximumSize ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String getEncoding ( ) { return encoding ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public boolean getDebug ( ) { return debug ; } public void setOptimize ( boolean optimize ) { this . optimize = optimize ; } public boolean getOptimize ( ) { return optimize ; } public void setDepend ( boolean depend ) { this . depend = depend ; } public boolean getDepend ( ) { return depend ; } public void setVerbose ( boolean verbose ) { this . verbose = verbose ; } public boolean getVerbose ( ) { return verbose ; } public void setTarget ( String target ) { this . targetAttribute = target ; } public String getTarget ( ) { return targetAttribute != null ? targetAttribute : getProject ( ) . getProperty ( MagicNames . BUILD_JAVAC_TARGET ) ; } public void setIncludeantruntime ( boolean include ) { includeAntRuntime = include ; } public boolean getIncludeantruntime ( ) { return includeAntRuntime ; } public void setIncludejavaruntime ( boolean include ) { includeJavaRuntime = include ; } public boolean getIncludejavaruntime ( ) { return includeJavaRuntime ; } public void setFork ( boolean f ) { fork = f ; } public void setExecutable ( String forkExec ) { forkedExecutable = forkExec ; } public String getExecutable ( ) { return forkedExecutable ; } public boolean isForkedJavac ( ) { return fork || "extJavac" . equals ( getCompiler ( ) ) ; } public String getJavacExecutable ( ) { if ( forkedExecutable == null && isForkedJavac ( ) ) { forkedExecutable = getSystemJavac ( ) ; } else if ( forkedExecutable != null && ! isForkedJavac ( ) ) { forkedExecutable = null ; } return forkedExecutable ; } public void setNowarn ( boolean flag ) { this . nowarn = flag ; } public boolean getNowarn ( ) { return nowarn ; } public ImplementationSpecificArgument createCompilerArg ( ) { ImplementationSpecificArgument arg = new ImplementationSpecificArgument ( ) ; facade . addImplementationArgument ( arg ) ; return arg ; } public String [ ] getCurrentCompilerArgs ( ) { String chosen = facade . getExplicitChoice ( ) ; try { String appliedCompiler = getCompiler ( ) ; facade . setImplementation ( appliedCompiler ) ; String [ ] result = facade . getArgs ( ) ; String altCompilerName = getAltCompilerName ( facade . getImplementation ( ) ) ; if ( result . length == 0 && altCompilerName != null ) { facade . setImplementation ( altCompilerName ) ; result = facade . getArgs ( ) ; } return result ; } finally { facade . setImplementation ( chosen ) ; } } private String getAltCompilerName ( String anImplementation ) { if ( JAVAC16 . equalsIgnoreCase ( anImplementation ) || JAVAC15 . equalsIgnoreCase ( anImplementation ) || JAVAC14 . equalsIgnoreCase ( anImplementation ) || JAVAC13 . equalsIgnoreCase ( anImplementation ) ) { return MODERN ; } if ( JAVAC12 . equalsIgnoreCase ( anImplementation ) || JAVAC11 . equalsIgnoreCase ( anImplementation ) ) { return CLASSIC ; } if ( MODERN . equalsIgnoreCase ( anImplementation ) ) { String nextSelected = assumedJavaVersion ( ) ; if ( JAVAC16 . equalsIgnoreCase ( nextSelected ) || JAVAC15 . equalsIgnoreCase ( nextSelected ) || JAVAC14 . equalsIgnoreCase ( nextSelected ) || JAVAC13 . equalsIgnoreCase ( nextSelected ) ) { return nextSelected ; } } if ( CLASSIC . equals ( anImplementation ) ) { return assumedJavaVersion ( ) ; } if ( EXTJAVAC . equalsIgnoreCase ( anImplementation ) ) { return assumedJavaVersion ( ) ; } return null ; } public void setTempdir ( File tmpDir ) { this . tmpDir = tmpDir ; } public File getTempdir ( ) { return tmpDir ; } public void execute ( ) throws BuildException { checkParameters ( ) ; resetFileLists ( ) ; String [ ] list = src . list ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { File srcDir = getProject ( ) . resolveFile ( list [ i ] ) ; if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir \"" + srcDir . getPath ( ) + "\" does not exist!" , getLocation ( ) ) ; } DirectoryScanner ds = this . getDirectoryScanner ( srcDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( srcDir , destDir != null ? destDir : srcDir , files ) ; } compile ( ) ; } protected void resetFileLists ( ) { compileList = new File [ 0 ] ; } protected void scanDir ( File srcDir , File destDir , String [ ] files ) { GlobPatternMapper m = new GlobPatternMapper ( ) ; m . setFrom ( "*.java" ) ; m . setTo ( "*.class" ) ; SourceFileScanner sfs = new SourceFileScanner ( this ) ; File [ ] newFiles = sfs . restrictAsFiles ( files , srcDir , destDir , m ) ; if ( newFiles . length > 0 ) { File [ ] newCompileList = new File [ compileList . length + newFiles . length ] ; System . arraycopy ( compileList , 0 , newCompileList , 0 , compileList . length ) ; System . arraycopy ( newFiles , 0 , newCompileList , compileList . length , newFiles . length ) ; compileList = newCompileList ; } } public File [ ] getFileList ( ) { return compileList ; } protected boolean isJdkCompiler ( String compilerImpl ) { return MODERN . equals ( compilerImpl ) || CLASSIC . equals ( compilerImpl ) || JAVAC16 . equals ( compilerImpl ) || JAVAC15 . equals ( compilerImpl ) || JAVAC14 . equals ( compilerImpl ) || JAVAC13 . equals ( compilerImpl ) || JAVAC12 . equals ( compilerImpl ) || JAVAC11 . equals ( compilerImpl ) ; } protected String getSystemJavac ( ) { return JavaEnvUtils . getJdkExecutable ( "javac" ) ; } public void setCompiler ( String compiler ) { facade . setImplementation ( compiler ) ; } public String getCompiler ( ) { String compilerImpl = getCompilerVersion ( ) ; if ( fork ) { if ( isJdkCompiler ( compilerImpl ) ) { compilerImpl = "extJavac" ; } else { log ( "Since compiler setting isn't classic or modern," + "ignoring fork setting." , Project . MSG_WARN ) ; } } return compilerImpl ; } public String getCompilerVersion ( ) { facade . setMagicValue ( getProject ( ) . getProperty ( "build.compiler" ) ) ; return facade . getImplementation ( ) ; } protected void checkParameters ( ) throws BuildException { if ( src == null ) { throw new BuildException ( "srcdir attribute must be set!" , getLocation ( ) ) ; } if ( src . size ( ) == 0 ) { throw new BuildException ( "srcdir attribute must be set!" , getLocation ( ) ) ; } if ( destDir != null && ! destDir . isDirectory ( ) ) { throw new BuildException ( "destination directory \"" + destDir + "\" does not exist " + "or is not a directory" , getLocation ( ) ) ; } } protected void compile ( ) { String compilerImpl = getCompiler ( ) ; if ( compileList . length > 0 ) { log ( "Compiling " + compileList . length + " source file" + ( compileList . length == 1 ? "" : "s" ) + ( destDir != null ? " to " + destDir : "" ) ) ; if ( listFiles ) { for ( int i = 0 ; i < compileList . length ; i ++ ) { String filename = compileList [ i ] . getAbsolutePath ( ) ; log ( filename ) ; } } CompilerAdapter adapter = CompilerAdapterFactory . getCompiler ( compilerImpl , this ) ; adapter . setJavac ( this ) ; if ( ! adapter . execute ( ) ) { if ( failOnError ) { throw new BuildException ( FAIL_MSG , getLocation ( ) ) ; } else { log ( FAIL_MSG , Project . MSG_ERR ) ; } } } } public class ImplementationSpecificArgument extends org . apache . tools . ant . util . facade . ImplementationSpecificArgument { public void setCompiler ( String impl ) { super . setImplementation ( impl ) ; } } } 	1	['77', '4', '1', '29', '123', '2700', '14', '17', '68', '0.977951636', '1021', '1', '6', '0.506493506', '0.20593692', '1', '1', '11.77922078', '14', '1.7532', '3']
package org . apache . tools . ant . types ; import java . io . File ; import java . util . Map ; import java . util . Set ; import java . util . TreeMap ; import java . util . Iterator ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . FileResourceIterator ; public abstract class ArchiveScanner extends DirectoryScanner { protected File srcFile ; private Resource src ; private Resource lastScannedResource ; private TreeMap fileEntries = new TreeMap ( ) ; private TreeMap dirEntries = new TreeMap ( ) ; private TreeMap matchFileEntries = new TreeMap ( ) ; private TreeMap matchDirEntries = new TreeMap ( ) ; private String encoding ; public void scan ( ) { if ( src == null ) { return ; } super . scan ( ) ; } public void setSrc ( File srcFile ) { setSrc ( new FileResource ( srcFile ) ) ; } public void setSrc ( Resource src ) { this . src = src ; if ( src instanceof FileResource ) { srcFile = ( ( FileResource ) src ) . getFile ( ) ; } } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String [ ] getIncludedFiles ( ) { if ( src == null ) { return super . getIncludedFiles ( ) ; } scanme ( ) ; Set s = matchFileEntries . keySet ( ) ; return ( String [ ] ) ( s . toArray ( new String [ s . size ( ) ] ) ) ; } public int getIncludedFilesCount ( ) { if ( src == null ) { return super . getIncludedFilesCount ( ) ; } scanme ( ) ; return matchFileEntries . size ( ) ; } public String [ ] getIncludedDirectories ( ) { if ( src == null ) { return super . getIncludedDirectories ( ) ; } scanme ( ) ; Set s = matchDirEntries . keySet ( ) ; return ( String [ ] ) ( s . toArray ( new String [ s . size ( ) ] ) ) ; } public int getIncludedDirsCount ( ) { if ( src == null ) { return super . getIncludedDirsCount ( ) ; } scanme ( ) ; return matchDirEntries . size ( ) ; } Iterator getResourceFiles ( ) { if ( src == null ) { return new FileResourceIterator ( getBasedir ( ) , getIncludedFiles ( ) ) ; } scanme ( ) ; return matchFileEntries . values ( ) . iterator ( ) ; } Iterator getResourceDirectories ( ) { if ( src == null ) { return new FileResourceIterator ( getBasedir ( ) , getIncludedDirectories ( ) ) ; } scanme ( ) ; return matchDirEntries . values ( ) . iterator ( ) ; } public void init ( ) { if ( includes == null ) { includes = new String [ 1 ] ; includes [ 0 ] = "**" ; } if ( excludes == null ) { excludes = new String [ 0 ] ; } } public boolean match ( String path ) { String vpath = path . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; return isIncluded ( vpath ) && ! isExcluded ( vpath ) ; } public Resource getResource ( String name ) { if ( src == null ) { return super . getResource ( name ) ; } if ( name . equals ( "" ) ) { return new Resource ( "" , true , Long . MAX_VALUE , true ) ; } scanme ( ) ; if ( fileEntries . containsKey ( name ) ) { return ( Resource ) fileEntries . get ( name ) ; } name = trimSeparator ( name ) ; if ( dirEntries . containsKey ( name ) ) { return ( Resource ) dirEntries . get ( name ) ; } return new Resource ( name ) ; } protected abstract void fillMapsFromArchive ( Resource archive , String encoding , Map fileEntries , Map matchFileEntries , Map dirEntries , Map matchDirEntries ) ; private void scanme ( ) { Resource thisresource = new Resource ( src . getName ( ) , src . isExists ( ) , src . getLastModified ( ) ) ; if ( lastScannedResource != null && lastScannedResource . getName ( ) . equals ( thisresource . getName ( ) ) && lastScannedResource . getLastModified ( ) == thisresource . getLastModified ( ) ) { return ; } init ( ) ; fileEntries . clear ( ) ; dirEntries . clear ( ) ; matchFileEntries . clear ( ) ; matchDirEntries . clear ( ) ; fillMapsFromArchive ( src , encoding , fileEntries , matchFileEntries , dirEntries , matchDirEntries ) ; lastScannedResource = thisresource ; } protected static final String trimSeparator ( String s ) { return s . endsWith ( "/" ) ? s . substring ( 0 , s . length ( ) - 1 ) : s ; } } 	1	['17', '2', '2', '9', '51', '28', '5', '4', '12', '0.546875', '344', '1', '2', '0.792207792', '0.294117647', '2', '4', '18.76470588', '5', '2.1176', '2']
package org . apache . tools . ant . types . resources ; import java . io . IOException ; import java . io . InputStream ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . Reference ; public class JavaResource extends Resource { private Path classpath ; private Reference loader ; public JavaResource ( ) { } public JavaResource ( String name , Path path ) { setName ( name ) ; classpath = path ; } public void setClasspath ( Path classpath ) { checkAttributesAllowed ( ) ; if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { checkChildrenAllowed ( ) ; if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { checkAttributesAllowed ( ) ; createClasspath ( ) . setRefid ( r ) ; } public Path getClasspath ( ) { return isReference ( ) ? ( ( JavaResource ) getCheckedRef ( ) ) . getClasspath ( ) : classpath ; } public void setLoaderRef ( Reference r ) { checkAttributesAllowed ( ) ; loader = r ; } public void setRefid ( Reference r ) { if ( loader != null || classpath != null ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public boolean isExists ( ) { InputStream is = null ; try { return isReference ( ) ? ( ( Resource ) getCheckedRef ( ) ) . isExists ( ) : ( is = getInputStream ( ) ) != null ; } catch ( IOException ex ) { return false ; } finally { FileUtils . close ( is ) ; } } public InputStream getInputStream ( ) throws IOException { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getInputStream ( ) ; } ClassLoader cl = null ; if ( loader != null ) { cl = ( ClassLoader ) loader . getReferencedObject ( ) ; } if ( cl == null ) { if ( getClasspath ( ) != null ) { cl = getProject ( ) . createClassLoader ( classpath ) ; } else { cl = JavaResource . class . getClassLoader ( ) ; } if ( loader != null && cl != null ) { getProject ( ) . addReference ( loader . getRefId ( ) , cl ) ; } } return cl == null ? ClassLoader . getSystemResourceAsStream ( getName ( ) ) : cl . getResourceAsStream ( getName ( ) ) ; } public int compareTo ( Object another ) { if ( isReference ( ) ) { return ( ( Comparable ) getCheckedRef ( ) ) . compareTo ( another ) ; } if ( another . getClass ( ) . equals ( getClass ( ) ) ) { JavaResource otherjr = ( JavaResource ) another ; if ( ! getName ( ) . equals ( otherjr . getName ( ) ) ) { return getName ( ) . compareTo ( otherjr . getName ( ) ) ; } if ( loader != otherjr . loader ) { if ( loader == null ) { return - 1 ; } if ( otherjr . loader == null ) { return 1 ; } return loader . getRefId ( ) . compareTo ( otherjr . loader . getRefId ( ) ) ; } Path p = getClasspath ( ) ; Path op = otherjr . getClasspath ( ) ; if ( p != op ) { if ( p == null ) { return - 1 ; } if ( op == null ) { return 1 ; } return p . toString ( ) . compareTo ( op . toString ( ) ) ; } return 0 ; } return super . compareTo ( another ) ; } } 	1	['11', '4', '0', '8', '45', '15', '1', '7', '11', '0.566666667', '279', '0.666666667', '2', '0.85483871', '0.327272727', '3', '6', '24.09090909', '10', '2.5455', '1']
package org . apache . tools . ant . taskdefs . optional . ejb ; import java . io . File ; import java . io . IOException ; import java . util . Hashtable ; import javax . xml . parsers . SAXParser ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . xml . sax . SAXException ; public class IPlanetDeploymentTool extends GenericDeploymentTool { private File iashome ; private String jarSuffix = ".jar" ; private boolean keepgenerated = false ; private boolean debug = false ; private String descriptorName ; private String iasDescriptorName ; private String displayName ; private static final String IAS_DD = "ias-ejb-jar.xml" ; public void setIashome ( File iashome ) { this . iashome = iashome ; } public void setKeepgenerated ( boolean keepgenerated ) { this . keepgenerated = keepgenerated ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public void setSuffix ( String jarSuffix ) { this . jarSuffix = jarSuffix ; } public void setGenericJarSuffix ( String inString ) { log ( "Since a generic JAR file is not created during processing, the " + "iPlanet Deployment Tool does not support the " + "\"genericjarsuffix\" attribute.  It will be ignored." , Project . MSG_WARN ) ; } public void processDescriptor ( String descriptorName , SAXParser saxParser ) { this . descriptorName = descriptorName ; this . iasDescriptorName = null ; log ( "iPlanet Deployment Tool processing: " + descriptorName + " (and " + getIasDescriptorName ( ) + ")" , Project . MSG_VERBOSE ) ; super . processDescriptor ( descriptorName , saxParser ) ; } protected void checkConfiguration ( String descriptorFileName , SAXParser saxParser ) throws BuildException { int startOfName = descriptorFileName . lastIndexOf ( File . separatorChar ) + 1 ; String stdXml = descriptorFileName . substring ( startOfName ) ; if ( stdXml . equals ( EJB_DD ) && ( getConfig ( ) . baseJarName == null ) ) { String msg = "No name specified for the completed JAR file.  The EJB" + " descriptor should be prepended with the JAR " + "name or it should be specified using the " + "attribute \"basejarname\" in the \"ejbjar\" task." ; throw new BuildException ( msg , getLocation ( ) ) ; } File iasDescriptor = new File ( getConfig ( ) . descriptorDir , getIasDescriptorName ( ) ) ; if ( ( ! iasDescriptor . exists ( ) ) || ( ! iasDescriptor . isFile ( ) ) ) { String msg = "The iAS-specific EJB descriptor (" + iasDescriptor + ") was not found." ; throw new BuildException ( msg , getLocation ( ) ) ; } if ( ( iashome != null ) && ( ! iashome . isDirectory ( ) ) ) { String msg = "If \"iashome\" is specified, it must be a valid " + "directory (it was set to " + iashome + ")." ; throw new BuildException ( msg , getLocation ( ) ) ; } } protected Hashtable parseEjbFiles ( String descriptorFileName , SAXParser saxParser ) throws IOException , SAXException { Hashtable files ; IPlanetEjbc ejbc = new IPlanetEjbc ( new File ( getConfig ( ) . descriptorDir , descriptorFileName ) , new File ( getConfig ( ) . descriptorDir , getIasDescriptorName ( ) ) , getConfig ( ) . srcDir , getCombinedClasspath ( ) . toString ( ) , saxParser ) ; ejbc . setRetainSource ( keepgenerated ) ; ejbc . setDebugOutput ( debug ) ; if ( iashome != null ) { ejbc . setIasHomeDir ( iashome ) ; } try { ejbc . execute ( ) ; } catch ( IPlanetEjbc . EjbcException e ) { throw new BuildException ( "An error has occurred while trying to " + "execute the iAS ejbc utility" , e , getLocation ( ) ) ; } displayName = ejbc . getDisplayName ( ) ; files = ejbc . getEjbFiles ( ) ; String [ ] cmpDescriptors = ejbc . getCmpDescriptors ( ) ; if ( cmpDescriptors . length > 0 ) { File baseDir = getConfig ( ) . descriptorDir ; int endOfPath = descriptorFileName . lastIndexOf ( File . separator ) ; String relativePath = descriptorFileName . substring ( 0 , endOfPath + 1 ) ; for ( int i = 0 ; i < cmpDescriptors . length ; i ++ ) { int endOfCmp = cmpDescriptors [ i ] . lastIndexOf ( '/' ) ; String cmpDescriptor = cmpDescriptors [ i ] . substring ( endOfCmp + 1 ) ; File cmpFile = new File ( baseDir , relativePath + cmpDescriptor ) ; if ( ! cmpFile . exists ( ) ) { throw new BuildException ( "The CMP descriptor file (" + cmpFile + ") could not be found." , getLocation ( ) ) ; } files . put ( cmpDescriptors [ i ] , cmpFile ) ; } } return files ; } protected void addVendorFiles ( Hashtable ejbFiles , String ddPrefix ) { ejbFiles . put ( META_DIR + IAS_DD , new File ( getConfig ( ) . descriptorDir , getIasDescriptorName ( ) ) ) ; } File getVendorOutputJarFile ( String baseName ) { File jarFile = new File ( getDestDir ( ) , baseName + jarSuffix ) ; log ( "JAR file name: " + jarFile . toString ( ) , Project . MSG_VERBOSE ) ; return jarFile ; } protected String getPublicId ( ) { return null ; } private String getIasDescriptorName ( ) { if ( iasDescriptorName != null ) { return iasDescriptorName ; } String path = "" ; String basename ; String remainder ; int startOfFileName = descriptorName . lastIndexOf ( File . separatorChar ) ; if ( startOfFileName != - 1 ) { path = descriptorName . substring ( 0 , startOfFileName + 1 ) ; } if ( descriptorName . substring ( startOfFileName + 1 ) . equals ( EJB_DD ) ) { basename = "" ; remainder = EJB_DD ; } else { int endOfBaseName = descriptorName . indexOf ( getConfig ( ) . baseNameTerminator , startOfFileName ) ; if ( endOfBaseName < 0 ) { endOfBaseName = descriptorName . lastIndexOf ( '.' ) - 1 ; if ( endOfBaseName < 0 ) { endOfBaseName = descriptorName . length ( ) - 1 ; } } basename = descriptorName . substring ( startOfFileName + 1 , endOfBaseName + 1 ) ; remainder = descriptorName . substring ( endOfBaseName + 1 ) ; } iasDescriptorName = path + basename + "ias-" + remainder ; return iasDescriptorName ; } } 	1	['13', '2', '0', '8', '49', '54', '1', '7', '7', '0.84375', '450', '1', '0', '0.727272727', '0.346153846', '2', '6', '33', '6', '1.3077', '1']
package org . apache . tools . ant . taskdefs . email ; import java . io . File ; import java . io . InputStream ; import java . io . IOException ; import java . io . PrintStream ; import java . io . OutputStream ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . UnsupportedEncodingException ; import java . util . Vector ; import java . util . Iterator ; import java . util . Properties ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . security . Provider ; import java . security . Security ; import javax . activation . DataHandler ; import javax . activation . FileDataSource ; import javax . mail . Message ; import javax . mail . Session ; import javax . mail . Transport ; import javax . mail . Authenticator ; import javax . mail . MessagingException ; import javax . mail . PasswordAuthentication ; import javax . mail . internet . MimeMessage ; import javax . mail . internet . MimeBodyPart ; import javax . mail . internet . MimeMultipart ; import javax . mail . internet . InternetAddress ; import javax . mail . internet . AddressException ; import org . apache . tools . ant . BuildException ; public class MimeMailer extends Mailer { private static final String SSL_FACTORY = "javax.net.ssl.SSLSocketFactory" ; private static final String DEFAULT_CHARSET = System . getProperty ( "file.encoding" ) ; class StringDataSource implements javax . activation . DataSource { private String data = null ; private String type = null ; private String charset = null ; private ByteArrayOutputStream out ; public InputStream getInputStream ( ) throws IOException { if ( data == null && out == null ) { throw new IOException ( "No data" ) ; } if ( out != null ) { String encodedOut = out . toString ( charset ) ; data = ( data != null ) ? data . concat ( encodedOut ) : encodedOut ; out = null ; } return new ByteArrayInputStream ( data . getBytes ( charset ) ) ; } public OutputStream getOutputStream ( ) throws IOException { out = ( out == null ) ? new ByteArrayOutputStream ( ) : out ; return out ; } public void setContentType ( String type ) { this . type = type . toLowerCase ( ) ; } public String getContentType ( ) { if ( type != null && type . indexOf ( "charset" ) > 0 && type . startsWith ( "text/" ) ) { return type ; } return new StringBuffer ( type != null ? type : "text/plain" ) . append ( "; charset=" ) . append ( charset ) . toString ( ) ; } public String getName ( ) { return "StringDataSource" ; } public void setCharset ( String charset ) { this . charset = charset ; } public String getCharset ( ) { return charset ; } } public void send ( ) { try { Properties props = new Properties ( ) ; props . put ( "mail.smtp.host" , host ) ; props . put ( "mail.smtp.port" , String . valueOf ( port ) ) ; Session sesh ; Authenticator auth ; if ( SSL ) { try { Provider p = ( Provider ) Class . forName ( "com.sun.net.ssl.internal.ssl.Provider" ) . newInstance ( ) ; Security . addProvider ( p ) ; } catch ( Exception e ) { throw new BuildException ( "could not instantiate ssl " + "security provider, check that you have JSSE in " + "your classpath" ) ; } props . put ( "mail.smtp.socketFactory.class" , SSL_FACTORY ) ; props . put ( "mail.smtp.socketFactory.fallback" , "false" ) ; } if ( user == null && password == null ) { sesh = Session . getDefaultInstance ( props , null ) ; } else { props . put ( "mail.smtp.auth" , "true" ) ; auth = new SimpleAuthenticator ( user , password ) ; sesh = Session . getInstance ( props , auth ) ; } MimeMessage msg = new MimeMessage ( sesh ) ; MimeMultipart attachments = new MimeMultipart ( ) ; if ( from . getName ( ) == null ) { msg . setFrom ( new InternetAddress ( from . getAddress ( ) ) ) ; } else { msg . setFrom ( new InternetAddress ( from . getAddress ( ) , from . getName ( ) ) ) ; } msg . setReplyTo ( internetAddresses ( replyToList ) ) ; msg . setRecipients ( Message . RecipientType . TO , internetAddresses ( toList ) ) ; msg . setRecipients ( Message . RecipientType . CC , internetAddresses ( ccList ) ) ; msg . setRecipients ( Message . RecipientType . BCC , internetAddresses ( bccList ) ) ; String charset = parseCharSetFromMimeType ( message . getMimeType ( ) ) ; if ( charset != null ) { message . setCharset ( charset ) ; } else { charset = message . getCharset ( ) ; if ( charset == null ) { charset = DEFAULT_CHARSET ; message . setCharset ( charset ) ; } } StringDataSource sds = new StringDataSource ( ) ; sds . setContentType ( message . getMimeType ( ) ) ; sds . setCharset ( charset ) ; if ( subject != null ) { msg . setSubject ( subject , charset ) ; } msg . addHeader ( "Date" , getDate ( ) ) ; for ( Iterator iter = headers . iterator ( ) ; iter . hasNext ( ) ; ) { Header h = ( Header ) iter . next ( ) ; msg . addHeader ( h . getName ( ) , h . getValue ( ) ) ; } PrintStream out = new PrintStream ( sds . getOutputStream ( ) ) ; message . print ( out ) ; out . close ( ) ; MimeBodyPart textbody = new MimeBodyPart ( ) ; textbody . setDataHandler ( new DataHandler ( sds ) ) ; attachments . addBodyPart ( textbody ) ; Enumeration e = files . elements ( ) ; while ( e . hasMoreElements ( ) ) { File file = ( File ) e . nextElement ( ) ; MimeBodyPart body ; body = new MimeBodyPart ( ) ; if ( ! file . exists ( ) || ! file . canRead ( ) ) { throw new BuildException ( "File \"" + file . getAbsolutePath ( ) + "\" does not exist or is not " + "readable." ) ; } FileDataSource fileData = new FileDataSource ( file ) ; DataHandler fileDataHandler = new DataHandler ( fileData ) ; body . setDataHandler ( fileDataHandler ) ; body . setFileName ( file . getName ( ) ) ; attachments . addBodyPart ( body ) ; } msg . setContent ( attachments ) ; Transport . send ( msg ) ; } catch ( MessagingException e ) { throw new BuildException ( "Problem while sending mime mail:" , e ) ; } catch ( IOException e ) { throw new BuildException ( "Problem while sending mime mail:" , e ) ; } } private static InternetAddress [ ] internetAddresses ( Vector list ) throws AddressException , UnsupportedEncodingException { InternetAddress [ ] addrs = new InternetAddress [ list . size ( ) ] ; for ( int i = 0 ; i < list . size ( ) ; ++ i ) { EmailAddress addr = ( EmailAddress ) list . elementAt ( i ) ; String name = addr . getName ( ) ; addrs [ i ] = ( name == null ) ? new InternetAddress ( addr . getAddress ( ) ) : new InternetAddress ( addr . getAddress ( ) , name ) ; } return addrs ; } private String parseCharSetFromMimeType ( String type ) { int pos ; if ( type == null || ( pos = type . indexOf ( "charset" ) ) < 0 ) { return null ; } StringTokenizer token = new StringTokenizer ( type . substring ( pos ) , "=; " ) ; token . nextToken ( ) ; return token . nextToken ( ) ; } static class SimpleAuthenticator extends Authenticator { private String user = null ; private String password = null ; public SimpleAuthenticator ( String user , String password ) { this . user = user ; this . password = password ; } public PasswordAuthentication getPasswordAuthentication ( ) { return new PasswordAuthentication ( user , password ) ; } } } 	1	['5', '2', '0', '7', '69', '8', '1', '7', '2', '1', '379', '1', '0', '0.857142857', '0.416666667', '0', '0', '74.4', '12', '3.2', '4']
package org . apache . tools . ant . taskdefs . condition ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . zip . ZipEntry ; import org . apache . tools . zip . ZipFile ; public class IsSigned extends DataType implements Condition { private static final String SIG_START = "META-INF/" ; private static final String SIG_END = ".SF" ; private static final int SHORT_SIG_LIMIT = 8 ; private String name ; private File file ; public void setFile ( File file ) { this . file = file ; } public void setName ( String name ) { this . name = name ; } public static boolean isSigned ( File zipFile , String name ) throws IOException { ZipFile jarFile = null ; try { jarFile = new ZipFile ( zipFile ) ; if ( null == name ) { Enumeration entries = jarFile . getEntries ( ) ; while ( entries . hasMoreElements ( ) ) { String eName = ( ( ZipEntry ) entries . nextElement ( ) ) . getName ( ) ; if ( eName . startsWith ( SIG_START ) && eName . endsWith ( SIG_END ) ) { return true ; } } return false ; } boolean shortSig = jarFile . getEntry ( SIG_START + name . toUpperCase ( ) + SIG_END ) != null ; boolean longSig = false ; if ( name . length ( ) > SHORT_SIG_LIMIT ) { longSig = jarFile . getEntry ( SIG_START + name . substring ( 0 , SHORT_SIG_LIMIT ) . toUpperCase ( ) + SIG_END ) != null ; } return shortSig || longSig ; } finally { ZipFile . closeQuietly ( jarFile ) ; } } public boolean eval ( ) { if ( file == null ) { throw new BuildException ( "The file attribute must be set." ) ; } if ( file != null && ! file . exists ( ) ) { log ( "The file \"" + file . getAbsolutePath ( ) + "\" does not exist." , Project . MSG_VERBOSE ) ; return false ; } boolean r = false ; try { r = isSigned ( file , name ) ; } catch ( IOException e ) { log ( "Got IOException reading file \"" + file . getAbsolutePath ( ) + "\"" + e , Project . MSG_WARN ) ; } if ( r ) { log ( "File \"" + file . getAbsolutePath ( ) + "\" is signed." , Project . MSG_VERBOSE ) ; } return r ; } } 	1	['5', '3', '0', '7', '26', '6', '2', '5', '5', '1.05', '193', '1', '0', '0.882352941', '0.533333333', '0', '0', '36.6', '5', '1.6', '1']
package org . apache . tools . ant . taskdefs . cvslib ; import org . apache . tools . ant . taskdefs . AbstractCvsTask ; import java . io . ByteArrayOutputStream ; import java . util . StringTokenizer ; public class CvsVersion extends AbstractCvsTask { static final long VERSION_1_11_2 = 11102 ; static final long MULTIPLY = 100 ; private String clientVersion ; private String serverVersion ; private String clientVersionProperty ; private String serverVersionProperty ; public String getClientVersion ( ) { return clientVersion ; } public String getServerVersion ( ) { return serverVersion ; } public void setClientVersionProperty ( String clientVersionProperty ) { this . clientVersionProperty = clientVersionProperty ; } public void setServerVersionProperty ( String serverVersionProperty ) { this . serverVersionProperty = serverVersionProperty ; } public boolean supportsCvsLogWithSOption ( ) { if ( serverVersion == null ) { return false ; } StringTokenizer tokenizer = new StringTokenizer ( serverVersion , "." ) ; long counter = MULTIPLY * MULTIPLY ; long version = 0 ; while ( tokenizer . hasMoreTokens ( ) ) { String s = tokenizer . nextToken ( ) ; int i = 0 ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( ! Character . isDigit ( s . charAt ( i ) ) ) { break ; } } String s2 = s . substring ( 0 , i ) ; version = version + counter * Long . parseLong ( s2 ) ; if ( counter == 1 ) { break ; } counter = counter / MULTIPLY ; } return ( version >= VERSION_1_11_2 ) ; } public void execute ( ) { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; this . setOutputStream ( bos ) ; ByteArrayOutputStream berr = new ByteArrayOutputStream ( ) ; this . setErrorStream ( berr ) ; setCommand ( "version" ) ; super . execute ( ) ; String output = bos . toString ( ) ; StringTokenizer st = new StringTokenizer ( output ) ; boolean client = false ; boolean server = false ; boolean cvs = false ; while ( st . hasMoreTokens ( ) ) { String currentToken = st . nextToken ( ) ; if ( currentToken . equals ( "Client:" ) ) { client = true ; } else if ( currentToken . equals ( "Server:" ) ) { server = true ; } else if ( currentToken . equals ( "(CVS)" ) ) { cvs = true ; } if ( client && cvs ) { if ( st . hasMoreTokens ( ) ) { clientVersion = st . nextToken ( ) ; } client = false ; cvs = false ; } else if ( server && cvs ) { if ( st . hasMoreTokens ( ) ) { serverVersion = st . nextToken ( ) ; } server = false ; cvs = false ; } } if ( clientVersionProperty != null ) { getProject ( ) . setNewProperty ( clientVersionProperty , clientVersion ) ; } if ( serverVersionProperty != null ) { getProject ( ) . setNewProperty ( serverVersionProperty , serverVersion ) ; } } } 	1	['7', '4', '0', '3', '26', '9', '1', '2', '7', '0.916666667', '210', '0.666666667', '0', '0.928571429', '0.642857143', '2', '2', '28.14285714', '13', '3.4286', '1']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . Enumeration ; import java . util . Iterator ; import java . util . Vector ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . DynamicConfigurator ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . XMLCatalog ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . Resources ; import org . apache . tools . ant . types . resources . Union ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . FileUtils ; public class XSLTProcess extends MatchingTask implements XSLTLogger { private File destDir = null ; private File baseDir = null ; private String xslFile = null ; private Resource xslResource = null ; private String targetExtension = ".html" ; private String fileNameParameter = null ; private String fileDirParameter = null ; private Vector params = new Vector ( ) ; private File inFile = null ; private File outFile = null ; private String processor ; private Path classpath = null ; private XSLTLiaison liaison ; private boolean stylesheetLoaded = false ; private boolean force = false ; private Vector outputProperties = new Vector ( ) ; private XMLCatalog xmlCatalog = new XMLCatalog ( ) ; private static final String TRAX_LIAISON_CLASS = "org.apache.tools.ant.taskdefs.optional.TraXLiaison" ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private boolean performDirectoryScan = true ; private Factory factory = null ; private boolean reuseLoadedStylesheet = true ; private AntClassLoader loader = null ; private Mapper mapperElement = null ; private Union resources = new Union ( ) ; private boolean useImplicitFileset = true ; public static final String PROCESSOR_TRAX = "trax" ; public XSLTProcess ( ) { } public void setScanIncludedDirectories ( boolean b ) { performDirectoryScan = b ; } public void setReloadStylesheet ( boolean b ) { reuseLoadedStylesheet = ! b ; } public void addMapper ( Mapper mapper ) { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" , getLocation ( ) ) ; } mapperElement = mapper ; } public void add ( ResourceCollection rc ) { resources . add ( rc ) ; } public void addConfiguredStyle ( Resources rc ) { if ( rc . size ( ) != 1 ) { throw new BuildException ( "The style element must be specified" + " with exactly one nested resource." ) ; } setXslResource ( ( Resource ) rc . iterator ( ) . next ( ) ) ; } public void setXslResource ( Resource xslResource ) { this . xslResource = xslResource ; } public void add ( FileNameMapper fileNameMapper ) throws BuildException { Mapper mapper = new Mapper ( getProject ( ) ) ; mapper . add ( fileNameMapper ) ; addMapper ( mapper ) ; } public void execute ( ) throws BuildException { if ( "style" . equals ( getTaskType ( ) ) ) { log ( "Warning: the task name <style> is deprecated. Use <xslt> instead." , Project . MSG_WARN ) ; } File savedBaseDir = baseDir ; DirectoryScanner scanner ; String [ ] list ; String [ ] dirs ; if ( xslResource == null && xslFile == null ) { throw new BuildException ( "specify the " + "stylesheet either as a filename in style " + "attribute or as a nested resource" , getLocation ( ) ) ; } if ( xslResource != null && xslFile != null ) { throw new BuildException ( "specify the " + "stylesheet either as a filename in style " + "attribute or as a nested resource but not " + "as both" , getLocation ( ) ) ; } if ( inFile != null && ! inFile . exists ( ) ) { throw new BuildException ( "input file " + inFile . toString ( ) + " does not exist" , getLocation ( ) ) ; } try { if ( baseDir == null ) { baseDir = getProject ( ) . resolveFile ( "." ) ; } liaison = getLiaison ( ) ; if ( liaison instanceof XSLTLoggerAware ) { ( ( XSLTLoggerAware ) liaison ) . setLogger ( this ) ; } log ( "Using " + liaison . getClass ( ) . toString ( ) , Project . MSG_VERBOSE ) ; if ( xslFile != null ) { File stylesheet = getProject ( ) . resolveFile ( xslFile ) ; if ( ! stylesheet . exists ( ) ) { stylesheet = FILE_UTILS . resolveFile ( baseDir , xslFile ) ; if ( stylesheet . exists ( ) ) { log ( "DEPRECATED - the 'style' attribute should be relative " + "to the project's" ) ; log ( "             basedir, not the tasks's basedir." ) ; } } FileResource fr = new FileResource ( ) ; fr . setProject ( getProject ( ) ) ; fr . setFile ( stylesheet ) ; xslResource = fr ; } if ( inFile != null && outFile != null ) { process ( inFile , outFile , xslResource ) ; return ; } checkDest ( ) ; if ( useImplicitFileset ) { scanner = getDirectoryScanner ( baseDir ) ; log ( "Transforming into " + destDir , Project . MSG_INFO ) ; list = scanner . getIncludedFiles ( ) ; for ( int i = 0 ; i < list . length ; ++ i ) { process ( baseDir , list [ i ] , destDir , xslResource ) ; } if ( performDirectoryScan ) { dirs = scanner . getIncludedDirectories ( ) ; for ( int j = 0 ; j < dirs . length ; ++ j ) { list = new File ( baseDir , dirs [ j ] ) . list ( ) ; for ( int i = 0 ; i < list . length ; ++ i ) { process ( baseDir , dirs [ j ] + File . separator + list [ i ] , destDir , xslResource ) ; } } } } else { if ( resources . size ( ) == 0 ) { throw new BuildException ( "no resources specified" ) ; } } processResources ( xslResource ) ; } finally { if ( loader != null ) { loader . resetThreadContextLoader ( ) ; loader . cleanup ( ) ; loader = null ; } liaison = null ; stylesheetLoaded = false ; baseDir = savedBaseDir ; } } public void setForce ( boolean force ) { this . force = force ; } public void setBasedir ( File dir ) { baseDir = dir ; } public void setDestdir ( File dir ) { destDir = dir ; } public void setExtension ( String name ) { targetExtension = name ; } public void setStyle ( String xslFile ) { this . xslFile = xslFile ; } public void setClasspath ( Path classpath ) { createClasspath ( ) . append ( classpath ) ; } public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( getProject ( ) ) ; } return classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setProcessor ( String processor ) { this . processor = processor ; } public void setUseImplicitFileset ( boolean useimplicitfileset ) { useImplicitFileset = useimplicitfileset ; } public void addConfiguredXMLCatalog ( XMLCatalog xmlCatalog ) { this . xmlCatalog . addConfiguredXMLCatalog ( xmlCatalog ) ; } public void setFileNameParameter ( String fileNameParameter ) { this . fileNameParameter = fileNameParameter ; } public void setFileDirParameter ( String fileDirParameter ) { this . fileDirParameter = fileDirParameter ; } private void resolveProcessor ( String proc ) throws Exception { String classname ; if ( proc . equals ( PROCESSOR_TRAX ) ) { classname = TRAX_LIAISON_CLASS ; } else { classname = proc ; } Class clazz = loadClass ( classname ) ; liaison = ( XSLTLiaison ) clazz . newInstance ( ) ; } private Class loadClass ( String classname ) throws Exception { if ( classpath == null ) { return Class . forName ( classname ) ; } else { loader = getProject ( ) . createClassLoader ( classpath ) ; loader . setThreadContextLoader ( ) ; Class c = Class . forName ( classname , true , loader ) ; return c ; } } public void setOut ( File outFile ) { this . outFile = outFile ; } public void setIn ( File inFile ) { this . inFile = inFile ; } private void checkDest ( ) { if ( destDir == null ) { String msg = "destdir attributes must be set!" ; throw new BuildException ( msg ) ; } } private void processResources ( Resource stylesheet ) { Iterator iter = resources . iterator ( ) ; while ( iter . hasNext ( ) ) { Resource r = ( Resource ) iter . next ( ) ; if ( ! r . isExists ( ) ) { continue ; } File base = baseDir ; String name = r . getName ( ) ; if ( r instanceof FileResource ) { FileResource f = ( FileResource ) r ; base = f . getBaseDir ( ) ; if ( base == null ) { name = f . getFile ( ) . getAbsolutePath ( ) ; } } process ( base , name , destDir , stylesheet ) ; } } private void process ( File baseDir , String xmlFile , File destDir , Resource stylesheet ) throws BuildException { File outF = null ; File inF = null ; try { long styleSheetLastModified = stylesheet . getLastModified ( ) ; inF = new File ( baseDir , xmlFile ) ; if ( inF . isDirectory ( ) ) { log ( "Skipping " + inF + " it is a directory." , Project . MSG_VERBOSE ) ; return ; } FileNameMapper mapper = null ; if ( mapperElement != null ) { mapper = mapperElement . getImplementation ( ) ; } else { mapper = new StyleMapper ( ) ; } String [ ] outFileName = mapper . mapFileName ( xmlFile ) ; if ( outFileName == null || outFileName . length == 0 ) { log ( "Skipping " + inFile + " it cannot get mapped to output." , Project . MSG_VERBOSE ) ; return ; } else if ( outFileName == null || outFileName . length > 1 ) { log ( "Skipping " + inFile + " its mapping is ambiguos." , Project . MSG_VERBOSE ) ; return ; } outF = new File ( destDir , outFileName [ 0 ] ) ; if ( force || inF . lastModified ( ) > outF . lastModified ( ) || styleSheetLastModified > outF . lastModified ( ) ) { ensureDirectoryFor ( outF ) ; log ( "Processing " + inF + " to " + outF ) ; configureLiaison ( stylesheet ) ; setLiaisonDynamicFileParameters ( liaison , inF ) ; liaison . transform ( inF , outF ) ; } } catch ( Exception ex ) { log ( "Failed to process " + inFile , Project . MSG_INFO ) ; if ( outF != null ) { outF . delete ( ) ; } throw new BuildException ( ex ) ; } } private void process ( File inFile , File outFile , Resource stylesheet ) throws BuildException { try { long styleSheetLastModified = stylesheet . getLastModified ( ) ; log ( "In file " + inFile + " time: " + inFile . lastModified ( ) , Project . MSG_DEBUG ) ; log ( "Out file " + outFile + " time: " + outFile . lastModified ( ) , Project . MSG_DEBUG ) ; log ( "Style file " + xslFile + " time: " + styleSheetLastModified , Project . MSG_DEBUG ) ; if ( force || inFile . lastModified ( ) >= outFile . lastModified ( ) || styleSheetLastModified >= outFile . lastModified ( ) ) { ensureDirectoryFor ( outFile ) ; log ( "Processing " + inFile + " to " + outFile , Project . MSG_INFO ) ; configureLiaison ( stylesheet ) ; setLiaisonDynamicFileParameters ( liaison , inFile ) ; liaison . transform ( inFile , outFile ) ; } else { log ( "Skipping input file " + inFile + " because it is older than output file " + outFile + " and so is the stylesheet " + stylesheet , Project . MSG_DEBUG ) ; } } catch ( Exception ex ) { log ( "Failed to process " + inFile , Project . MSG_INFO ) ; if ( outFile != null ) { outFile . delete ( ) ; } throw new BuildException ( ex ) ; } } private void ensureDirectoryFor ( File targetFile ) throws BuildException { File directory = targetFile . getParentFile ( ) ; if ( ! directory . exists ( ) ) { if ( ! directory . mkdirs ( ) ) { throw new BuildException ( "Unable to create directory: " + directory . getAbsolutePath ( ) ) ; } } } public Factory getFactory ( ) { return factory ; } public XMLCatalog getXMLCatalog ( ) { xmlCatalog . setProject ( getProject ( ) ) ; return xmlCatalog ; } public Enumeration getOutputProperties ( ) { return outputProperties . elements ( ) ; } protected XSLTLiaison getLiaison ( ) { if ( liaison == null ) { if ( processor != null ) { try { resolveProcessor ( processor ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } else { try { resolveProcessor ( PROCESSOR_TRAX ) ; } catch ( Throwable e1 ) { e1 . printStackTrace ( ) ; throw new BuildException ( e1 ) ; } } } return liaison ; } public Param createParam ( ) { Param p = new Param ( ) ; params . addElement ( p ) ; return p ; } public static class Param { private String name = null ; private String expression = null ; private String ifProperty ; private String unlessProperty ; private Project project ; public void setProject ( Project project ) { this . project = project ; } public void setName ( String name ) { this . name = name ; } public void setExpression ( String expression ) { this . expression = expression ; } public String getName ( ) throws BuildException { if ( name == null ) { throw new BuildException ( "Name attribute is missing." ) ; } return name ; } public String getExpression ( ) throws BuildException { if ( expression == null ) { throw new BuildException ( "Expression attribute is missing." ) ; } return expression ; } public void setIf ( String ifProperty ) { this . ifProperty = ifProperty ; } public void setUnless ( String unlessProperty ) { this . unlessProperty = unlessProperty ; } public boolean shouldUse ( ) { if ( ifProperty != null && project . getProperty ( ifProperty ) == null ) { return false ; } else if ( unlessProperty != null && project . getProperty ( unlessProperty ) != null ) { return false ; } return true ; } } public OutputProperty createOutputProperty ( ) { OutputProperty p = new OutputProperty ( ) ; outputProperties . addElement ( p ) ; return p ; } public static class OutputProperty { private String name ; private String value ; public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } } public void init ( ) throws BuildException { super . init ( ) ; xmlCatalog . setProject ( getProject ( ) ) ; } protected void configureLiaison ( File stylesheet ) throws BuildException { FileResource fr = new FileResource ( ) ; fr . setProject ( getProject ( ) ) ; fr . setFile ( stylesheet ) ; configureLiaison ( fr ) ; } protected void configureLiaison ( Resource stylesheet ) throws BuildException { if ( stylesheetLoaded && reuseLoadedStylesheet ) { return ; } stylesheetLoaded = true ; try { log ( "Loading stylesheet " + stylesheet , Project . MSG_INFO ) ; if ( liaison instanceof XSLTLiaison2 ) { ( ( XSLTLiaison2 ) liaison ) . configure ( this ) ; } if ( liaison instanceof XSLTLiaison3 ) { ( ( XSLTLiaison3 ) liaison ) . setStylesheet ( stylesheet ) ; } else { if ( stylesheet instanceof FileResource ) { liaison . setStylesheet ( ( ( FileResource ) stylesheet ) . getFile ( ) ) ; } else { throw new BuildException ( liaison . getClass ( ) . toString ( ) + " accepts the stylesheet only as a file" , getLocation ( ) ) ; } } for ( Enumeration e = params . elements ( ) ; e . hasMoreElements ( ) ; ) { Param p = ( Param ) e . nextElement ( ) ; if ( p . shouldUse ( ) ) { liaison . addParam ( p . getName ( ) , p . getExpression ( ) ) ; } } } catch ( Exception ex ) { log ( "Failed to transform using stylesheet " + stylesheet , Project . MSG_INFO ) ; throw new BuildException ( ex ) ; } } private void setLiaisonDynamicFileParameters ( XSLTLiaison liaison , File inFile ) throws Exception { if ( fileNameParameter != null ) { liaison . addParam ( fileNameParameter , inFile . getName ( ) ) ; } if ( fileDirParameter != null ) { String fileName = FileUtils . getRelativePath ( baseDir , inFile ) ; File file = new File ( fileName ) ; liaison . addParam ( fileDirParameter , ( file . getParent ( ) != null ) ? file . getParent ( ) . replace ( '\\' , '/' ) : "." ) ; } } public Factory createFactory ( ) throws BuildException { if ( factory != null ) { throw new BuildException ( "'factory' element must be unique" ) ; } factory = new Factory ( ) ; return factory ; } public static class Factory { private String name ; private Vector attributes = new Vector ( ) ; public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public void addAttribute ( Attribute attr ) { attributes . addElement ( attr ) ; } public Enumeration getAttributes ( ) { return attributes . elements ( ) ; } public static class Attribute implements DynamicConfigurator { private String name ; private Object value ; public String getName ( ) { return name ; } public Object getValue ( ) { return value ; } public Object createDynamicElement ( String name ) throws BuildException { return null ; } public void setDynamicAttribute ( String name , String value ) throws BuildException { if ( "name" . equalsIgnoreCase ( name ) ) { this . name = value ; } else if ( "value" . equalsIgnoreCase ( name ) ) { if ( "true" . equalsIgnoreCase ( value ) ) { this . value = Boolean . TRUE ; } else if ( "false" . equalsIgnoreCase ( value ) ) { this . value = Boolean . FALSE ; } else { try { this . value = new Integer ( value ) ; } catch ( NumberFormatException e ) { this . value = value ; } } } else { throw new BuildException ( "Unsupported attribute: " + name ) ; } } } } private class StyleMapper implements FileNameMapper { public void setFrom ( String from ) { } public void setTo ( String to ) { } public String [ ] mapFileName ( String xmlFile ) { int dotPos = xmlFile . lastIndexOf ( '.' ) ; if ( dotPos > 0 ) { xmlFile = xmlFile . substring ( 0 , dotPos ) ; } return new String [ ] { xmlFile + targetExtension } ; } } } 	1	['44', '4', '0', '28', '137', '774', '4', '26', '31', '0.923341947', '1254', '0.962962963', '9', '0.65', '0.127906977', '4', '6', '26.88636364', '5', '1.2045', '2']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . StringUtils ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . Union ; import java . io . File ; import java . io . PrintStream ; import java . io . BufferedOutputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . Reader ; import java . io . BufferedReader ; import java . io . StringReader ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . util . Enumeration ; import java . util . Iterator ; import java . util . StringTokenizer ; import java . util . Vector ; import java . sql . Connection ; import java . sql . Statement ; import java . sql . SQLException ; import java . sql . SQLWarning ; import java . sql . ResultSet ; import java . sql . ResultSetMetaData ; public class SQLExec extends JDBCTask { public static class DelimiterType extends EnumeratedAttribute { public static final String NORMAL = "normal" , ROW = "row" ; public String [ ] getValues ( ) { return new String [ ] { NORMAL , ROW } ; } } private int goodSql = 0 ; private int totalSql = 0 ; private Connection conn = null ; private Union resources = new Union ( ) ; private Statement statement = null ; private File srcFile = null ; private String sqlCommand = "" ; private Vector transactions = new Vector ( ) ; private String delimiter = ";" ; private String delimiterType = DelimiterType . NORMAL ; private boolean print = false ; private boolean showheaders = true ; private boolean showtrailers = true ; private File output = null ; private String onError = "abort" ; private String encoding = null ; private boolean append = false ; private boolean keepformat = false ; private boolean escapeProcessing = true ; private boolean expandProperties = false ; public void setSrc ( File srcFile ) { this . srcFile = srcFile ; } public void setExpandProperties ( boolean expandProperties ) { this . expandProperties = expandProperties ; } public boolean getExpandProperties ( ) { return expandProperties ; } public void addText ( String sql ) { this . sqlCommand += sql ; } public void addFileset ( FileSet set ) { add ( set ) ; } public void add ( ResourceCollection rc ) { resources . add ( rc ) ; } public Transaction createTransaction ( ) { Transaction t = new Transaction ( ) ; transactions . addElement ( t ) ; return t ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public void setDelimiter ( String delimiter ) { this . delimiter = delimiter ; } public void setDelimiterType ( DelimiterType delimiterType ) { this . delimiterType = delimiterType . getValue ( ) ; } public void setPrint ( boolean print ) { this . print = print ; } public void setShowheaders ( boolean showheaders ) { this . showheaders = showheaders ; } public void setShowtrailers ( boolean showtrailers ) { this . showtrailers = showtrailers ; } public void setOutput ( File output ) { this . output = output ; } public void setAppend ( boolean append ) { this . append = append ; } public void setOnerror ( OnError action ) { this . onError = action . getValue ( ) ; } public void setKeepformat ( boolean keepformat ) { this . keepformat = keepformat ; } public void setEscapeProcessing ( boolean enable ) { escapeProcessing = enable ; } public void execute ( ) throws BuildException { Vector savedTransaction = ( Vector ) transactions . clone ( ) ; String savedSqlCommand = sqlCommand ; sqlCommand = sqlCommand . trim ( ) ; try { if ( srcFile == null && sqlCommand . length ( ) == 0 && resources . size ( ) == 0 ) { if ( transactions . size ( ) == 0 ) { throw new BuildException ( "Source file or resource " + "collection, " + "transactions or sql statement " + "must be set!" , getLocation ( ) ) ; } } if ( srcFile != null && ! srcFile . exists ( ) ) { throw new BuildException ( "Source file does not exist!" , getLocation ( ) ) ; } Iterator iter = resources . iterator ( ) ; while ( iter . hasNext ( ) ) { Resource r = ( Resource ) iter . next ( ) ; Transaction t = createTransaction ( ) ; t . setSrcResource ( r ) ; } Transaction t = createTransaction ( ) ; t . setSrc ( srcFile ) ; t . addText ( sqlCommand ) ; conn = getConnection ( ) ; if ( ! isValidRdbms ( conn ) ) { return ; } try { statement = conn . createStatement ( ) ; statement . setEscapeProcessing ( escapeProcessing ) ; PrintStream out = System . out ; try { if ( output != null ) { log ( "Opening PrintStream to output file " + output , Project . MSG_VERBOSE ) ; out = new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( output . getAbsolutePath ( ) , append ) ) ) ; } for ( Enumeration e = transactions . elements ( ) ; e . hasMoreElements ( ) ; ) { ( ( Transaction ) e . nextElement ( ) ) . runTransaction ( out ) ; if ( ! isAutocommit ( ) ) { log ( "Committing transaction" , Project . MSG_VERBOSE ) ; conn . commit ( ) ; } } } finally { if ( out != null && out != System . out ) { out . close ( ) ; } } } catch ( IOException e ) { closeQuietly ( ) ; throw new BuildException ( e , getLocation ( ) ) ; } catch ( SQLException e ) { closeQuietly ( ) ; throw new BuildException ( e , getLocation ( ) ) ; } finally { try { if ( statement != null ) { statement . close ( ) ; } if ( conn != null ) { conn . close ( ) ; } } catch ( SQLException ex ) { } } log ( goodSql + " of " + totalSql + " SQL statements executed successfully" ) ; } finally { transactions = savedTransaction ; sqlCommand = savedSqlCommand ; } } protected void runStatements ( Reader reader , PrintStream out ) throws SQLException , IOException { StringBuffer sql = new StringBuffer ( ) ; String line ; BufferedReader in = new BufferedReader ( reader ) ; while ( ( line = in . readLine ( ) ) != null ) { if ( ! keepformat ) { line = line . trim ( ) ; } line = getProject ( ) . replaceProperties ( line ) ; if ( ! keepformat ) { if ( line . startsWith ( "//" ) ) { continue ; } if ( line . startsWith ( "--" ) ) { continue ; } StringTokenizer st = new StringTokenizer ( line ) ; if ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) ; if ( "REM" . equalsIgnoreCase ( token ) ) { continue ; } } } if ( ! keepformat ) { sql . append ( " " ) ; sql . append ( line ) ; } else { sql . append ( "\n" ) ; sql . append ( line ) ; } if ( ! keepformat ) { if ( line . indexOf ( "--" ) >= 0 ) { sql . append ( "\n" ) ; } } if ( ( delimiterType . equals ( DelimiterType . NORMAL ) && StringUtils . endsWith ( sql , delimiter ) ) || ( delimiterType . equals ( DelimiterType . ROW ) && line . equals ( delimiter ) ) ) { execSQL ( sql . substring ( 0 , sql . length ( ) - delimiter . length ( ) ) , out ) ; sql . replace ( 0 , sql . length ( ) , "" ) ; } } if ( sql . length ( ) > 0 ) { execSQL ( sql . toString ( ) , out ) ; } } protected void execSQL ( String sql , PrintStream out ) throws SQLException { if ( "" . equals ( sql . trim ( ) ) ) { return ; } ResultSet resultSet = null ; try { totalSql ++ ; log ( "SQL: " + sql , Project . MSG_VERBOSE ) ; boolean ret ; int updateCount = 0 , updateCountTotal = 0 ; ret = statement . execute ( sql ) ; updateCount = statement . getUpdateCount ( ) ; resultSet = statement . getResultSet ( ) ; do { if ( ! ret ) { if ( updateCount != - 1 ) { updateCountTotal += updateCount ; } } else { if ( print ) { printResults ( resultSet , out ) ; } } ret = statement . getMoreResults ( ) ; if ( ret ) { updateCount = statement . getUpdateCount ( ) ; resultSet = statement . getResultSet ( ) ; } } while ( ret ) ; log ( updateCountTotal + " rows affected" , Project . MSG_VERBOSE ) ; if ( print && showtrailers ) { out . println ( updateCountTotal + " rows affected" ) ; } SQLWarning warning = conn . getWarnings ( ) ; while ( warning != null ) { log ( warning + " sql warning" , Project . MSG_VERBOSE ) ; warning = warning . getNextWarning ( ) ; } conn . clearWarnings ( ) ; goodSql ++ ; } catch ( SQLException e ) { log ( "Failed to execute: " + sql , Project . MSG_ERR ) ; if ( ! onError . equals ( "continue" ) ) { throw e ; } log ( e . toString ( ) , Project . MSG_ERR ) ; } finally { if ( resultSet != null ) { resultSet . close ( ) ; } } } protected void printResults ( PrintStream out ) throws SQLException { ResultSet rs = statement . getResultSet ( ) ; try { printResults ( rs , out ) ; } finally { if ( rs != null ) { rs . close ( ) ; } } } protected void printResults ( ResultSet rs , PrintStream out ) throws SQLException { if ( rs != null ) { log ( "Processing new result set." , Project . MSG_VERBOSE ) ; ResultSetMetaData md = rs . getMetaData ( ) ; int columnCount = md . getColumnCount ( ) ; StringBuffer line = new StringBuffer ( ) ; if ( showheaders ) { for ( int col = 1 ; col < columnCount ; col ++ ) { line . append ( md . getColumnName ( col ) ) ; line . append ( "," ) ; } line . append ( md . getColumnName ( columnCount ) ) ; out . println ( line ) ; line = new StringBuffer ( ) ; } while ( rs . next ( ) ) { boolean first = true ; for ( int col = 1 ; col <= columnCount ; col ++ ) { String columnValue = rs . getString ( col ) ; if ( columnValue != null ) { columnValue = columnValue . trim ( ) ; } if ( first ) { first = false ; } else { line . append ( "," ) ; } line . append ( columnValue ) ; } out . println ( line ) ; line = new StringBuffer ( ) ; } } out . println ( ) ; } private void closeQuietly ( ) { if ( ! isAutocommit ( ) && conn != null && onError . equals ( "abort" ) ) { try { conn . rollback ( ) ; } catch ( SQLException ex ) { } } } public static class OnError extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "continue" , "stop" , "abort" } ; } } public class Transaction { private Resource tSrcResource = null ; private String tSqlCommand = "" ; public void setSrc ( File src ) { if ( src != null ) { setSrcResource ( new FileResource ( src ) ) ; } } public void setSrcResource ( Resource src ) { if ( tSrcResource != null ) { throw new BuildException ( "only one resource per transaction" ) ; } tSrcResource = src ; } public void addText ( String sql ) { if ( sql != null ) { if ( getExpandProperties ( ) ) { sql = getProject ( ) . replaceProperties ( sql ) ; } this . tSqlCommand += sql ; } } public void addConfigured ( ResourceCollection a ) { if ( a . size ( ) != 1 ) { throw new BuildException ( "only single argument resource " + "collections are supported." ) ; } setSrcResource ( ( Resource ) a . iterator ( ) . next ( ) ) ; } private void runTransaction ( PrintStream out ) throws IOException , SQLException { if ( tSqlCommand . length ( ) != 0 ) { log ( "Executing commands" , Project . MSG_INFO ) ; runStatements ( new StringReader ( tSqlCommand ) , out ) ; } if ( tSrcResource != null ) { log ( "Executing resource: " + tSrcResource . toString ( ) , Project . MSG_INFO ) ; InputStream is = null ; Reader reader = null ; try { is = tSrcResource . getInputStream ( ) ; reader = ( encoding == null ) ? new InputStreamReader ( is ) : new InputStreamReader ( is , encoding ) ; runStatements ( reader , out ) ; } finally { FileUtils . close ( is ) ; FileUtils . close ( reader ) ; } } } } } 	1	['26', '4', '0', '12', '109', '233', '1', '12', '20', '0.892', '881', '1', '1', '0.709302326', '0.157051282', '2', '2', '32.11538462', '4', '1.0769', '8']
package org . apache . tools . ant . util ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import java . io . UnsupportedEncodingException ; import java . io . Writer ; import java . io . OutputStream ; import java . net . MalformedURLException ; import java . net . URL ; import java . text . DecimalFormat ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Iterator ; import java . util . List ; import java . util . Random ; import java . util . Stack ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . PathTokenizer ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . FilterSetCollection ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . launch . Locator ; public class FileUtils { private static final FileUtils PRIMARY_INSTANCE = new FileUtils ( ) ; private static Random rand = new Random ( System . currentTimeMillis ( ) + Runtime . getRuntime ( ) . freeMemory ( ) ) ; private static boolean onNetWare = Os . isFamily ( "netware" ) ; private static boolean onDos = Os . isFamily ( "dos" ) ; private static boolean onWin9x = Os . isFamily ( "win9x" ) ; private static boolean onWindows = Os . isFamily ( "windows" ) ; static final int BUF_SIZE = 8192 ; public static final long FAT_FILE_TIMESTAMP_GRANULARITY = 2000 ; public static final long UNIX_FILE_TIMESTAMP_GRANULARITY = 1000 ; public static final long NTFS_FILE_TIMESTAMP_GRANULARITY = 1 ; private Object cacheFromUriLock = new Object ( ) ; private String cacheFromUriRequest = null ; private String cacheFromUriResponse = null ; public static FileUtils newFileUtils ( ) { return new FileUtils ( ) ; } public static FileUtils getFileUtils ( ) { return PRIMARY_INSTANCE ; } protected FileUtils ( ) { } public URL getFileURL ( File file ) throws MalformedURLException { return new URL ( toURI ( file . getAbsolutePath ( ) ) ) ; } public void copyFile ( String sourceFile , String destFile ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , null , false , false ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , false , false ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , boolean overwrite ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , overwrite , false ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , overwrite , preserveLastModified ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified , String encoding ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , overwrite , preserveLastModified , encoding ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String encoding , Project project ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , filterChains , overwrite , preserveLastModified , encoding , project ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String inputEncoding , String outputEncoding , Project project ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , filterChains , overwrite , preserveLastModified , inputEncoding , outputEncoding , project ) ; } public void copyFile ( File sourceFile , File destFile ) throws IOException { copyFile ( sourceFile , destFile , null , false , false ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters ) throws IOException { copyFile ( sourceFile , destFile , filters , false , false ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , boolean overwrite ) throws IOException { copyFile ( sourceFile , destFile , filters , overwrite , false ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified ) throws IOException { copyFile ( sourceFile , destFile , filters , overwrite , preserveLastModified , null ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified , String encoding ) throws IOException { copyFile ( sourceFile , destFile , filters , null , overwrite , preserveLastModified , encoding , null ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String encoding , Project project ) throws IOException { copyFile ( sourceFile , destFile , filters , filterChains , overwrite , preserveLastModified , encoding , encoding , project ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String inputEncoding , String outputEncoding , Project project ) throws IOException { ResourceUtils . copyResource ( new FileResource ( sourceFile ) , new FileResource ( destFile ) , filters , filterChains , overwrite , preserveLastModified , inputEncoding , outputEncoding , project ) ; } public void setFileLastModified ( File file , long time ) { ResourceUtils . setLastModified ( new FileResource ( file ) , time ) ; } public File resolveFile ( File file , String filename ) { if ( ! isAbsolutePath ( filename ) ) { char sep = File . separatorChar ; filename = filename . replace ( '/' , sep ) . replace ( '\\' , sep ) ; if ( isContextRelativePath ( filename ) ) { file = null ; String udir = System . getProperty ( "user.dir" ) ; if ( filename . charAt ( 0 ) == sep && udir . charAt ( 0 ) == sep ) { filename = dissect ( udir ) [ 0 ] + filename . substring ( 1 ) ; } } filename = new File ( file , filename ) . getAbsolutePath ( ) ; } return normalize ( filename ) ; } public static boolean isContextRelativePath ( String filename ) { if ( ! ( onDos || onNetWare ) || filename . length ( ) == 0 ) { return false ; } char sep = File . separatorChar ; filename = filename . replace ( '/' , sep ) . replace ( '\\' , sep ) ; char c = filename . charAt ( 0 ) ; int len = filename . length ( ) ; return ( c == sep && ( len == 1 || filename . charAt ( 1 ) != sep ) ) || ( Character . isLetter ( c ) && len > 1 && filename . indexOf ( ':' ) == 1 && ( len == 2 || filename . charAt ( 2 ) != sep ) ) ; } public static boolean isAbsolutePath ( String filename ) { int len = filename . length ( ) ; if ( len == 0 ) { return false ; } char sep = File . separatorChar ; filename = filename . replace ( '/' , sep ) . replace ( '\\' , sep ) ; char c = filename . charAt ( 0 ) ; if ( ! ( onDos || onNetWare ) ) { return ( c == sep ) ; } if ( c == sep ) { if ( ! ( onDos && len > 4 && filename . charAt ( 1 ) == sep ) ) { return false ; } int nextsep = filename . indexOf ( sep , 2 ) ; return nextsep > 2 && nextsep + 1 < len ; } int colon = filename . indexOf ( ':' ) ; return ( Character . isLetter ( c ) && colon == 1 && filename . length ( ) > 2 && filename . charAt ( 2 ) == sep ) || ( onNetWare && colon > 0 ) ; } public static String translatePath ( String toProcess ) { if ( toProcess == null || toProcess . length ( ) == 0 ) { return "" ; } StringBuffer path = new StringBuffer ( toProcess . length ( ) + 50 ) ; PathTokenizer tokenizer = new PathTokenizer ( toProcess ) ; while ( tokenizer . hasMoreTokens ( ) ) { String pathComponent = tokenizer . nextToken ( ) ; pathComponent = pathComponent . replace ( '/' , File . separatorChar ) ; pathComponent = pathComponent . replace ( '\\' , File . separatorChar ) ; if ( path . length ( ) != 0 ) { path . append ( File . pathSeparatorChar ) ; } path . append ( pathComponent ) ; } return path . toString ( ) ; } public File normalize ( final String path ) { Stack s = new Stack ( ) ; String [ ] dissect = dissect ( path ) ; s . push ( dissect [ 0 ] ) ; StringTokenizer tok = new StringTokenizer ( dissect [ 1 ] , File . separator ) ; while ( tok . hasMoreTokens ( ) ) { String thisToken = tok . nextToken ( ) ; if ( "." . equals ( thisToken ) ) { continue ; } else if ( ".." . equals ( thisToken ) ) { if ( s . size ( ) < 2 ) { return new File ( path ) ; } s . pop ( ) ; } else { s . push ( thisToken ) ; } } StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( i > 1 ) { sb . append ( File . separatorChar ) ; } sb . append ( s . elementAt ( i ) ) ; } return new File ( sb . toString ( ) ) ; } public String [ ] dissect ( String path ) { char sep = File . separatorChar ; path = path . replace ( '/' , sep ) . replace ( '\\' , sep ) ; if ( ! isAbsolutePath ( path ) ) { throw new BuildException ( path + " is not an absolute path" ) ; } String root = null ; int colon = path . indexOf ( ':' ) ; if ( colon > 0 && ( onDos || onNetWare ) ) { int next = colon + 1 ; root = path . substring ( 0 , next ) ; char [ ] ca = path . toCharArray ( ) ; root += sep ; next = ( ca [ next ] == sep ) ? next + 1 : next ; StringBuffer sbPath = new StringBuffer ( ) ; for ( int i = next ; i < ca . length ; i ++ ) { if ( ca [ i ] != sep || ca [ i - 1 ] != sep ) { sbPath . append ( ca [ i ] ) ; } } path = sbPath . toString ( ) ; } else if ( path . length ( ) > 1 && path . charAt ( 1 ) == sep ) { int nextsep = path . indexOf ( sep , 2 ) ; nextsep = path . indexOf ( sep , nextsep + 1 ) ; root = ( nextsep > 2 ) ? path . substring ( 0 , nextsep + 1 ) : path ; path = path . substring ( root . length ( ) ) ; } else { root = File . separator ; path = path . substring ( 1 ) ; } return new String [ ] { root , path } ; } public String toVMSPath ( File f ) { String osPath ; String path = normalize ( f . getAbsolutePath ( ) ) . getPath ( ) ; String name = f . getName ( ) ; boolean isAbsolute = path . charAt ( 0 ) == File . separatorChar ; boolean isDirectory = f . isDirectory ( ) && ! name . regionMatches ( true , name . length ( ) - 4 , ".DIR" , 0 , 4 ) ; String device = null ; StringBuffer directory = null ; String file = null ; int index = 0 ; if ( isAbsolute ) { index = path . indexOf ( File . separatorChar , 1 ) ; if ( index == - 1 ) { return path . substring ( 1 ) + ":[000000]" ; } else { device = path . substring ( 1 , index ++ ) ; } } if ( isDirectory ) { directory = new StringBuffer ( path . substring ( index ) . replace ( File . separatorChar , '.' ) ) ; } else { int dirEnd = path . lastIndexOf ( File . separatorChar , path . length ( ) ) ; if ( dirEnd == - 1 || dirEnd < index ) { file = path . substring ( index ) ; } else { directory = new StringBuffer ( path . substring ( index , dirEnd ) . replace ( File . separatorChar , '.' ) ) ; index = dirEnd + 1 ; if ( path . length ( ) > index ) { file = path . substring ( index ) ; } } } if ( ! isAbsolute && directory != null ) { directory . insert ( 0 , '.' ) ; } osPath = ( ( device != null ) ? device + ":" : "" ) + ( ( directory != null ) ? "[" + directory + "]" : "" ) + ( ( file != null ) ? file : "" ) ; return osPath ; } public File createTempFile ( String prefix , String suffix , File parentDir ) { return createTempFile ( prefix , suffix , parentDir , false ) ; } public File createTempFile ( String prefix , String suffix , File parentDir , boolean deleteOnExit ) { File result = null ; String parent = ( parentDir == null ) ? System . getProperty ( "java.io.tmpdir" ) : parentDir . getPath ( ) ; DecimalFormat fmt = new DecimalFormat ( "#####" ) ; synchronized ( rand ) { do { result = new File ( parent , prefix + fmt . format ( Math . abs ( rand . nextInt ( ) ) ) + suffix ) ; } while ( result . exists ( ) ) ; } if ( deleteOnExit ) { result . deleteOnExit ( ) ; } return result ; } public boolean contentEquals ( File f1 , File f2 ) throws IOException { return contentEquals ( f1 , f2 , false ) ; } public boolean contentEquals ( File f1 , File f2 , boolean textfile ) throws IOException { return ResourceUtils . contentEquals ( new FileResource ( f1 ) , new FileResource ( f2 ) , textfile ) ; } public File getParentFile ( File f ) { return ( f == null ) ? null : f . getParentFile ( ) ; } public static final String readFully ( Reader rdr ) throws IOException { return readFully ( rdr , BUF_SIZE ) ; } public static final String readFully ( Reader rdr , int bufferSize ) throws IOException { if ( bufferSize <= 0 ) { throw new IllegalArgumentException ( "Buffer size must be greater " + "than 0" ) ; } final char [ ] buffer = new char [ bufferSize ] ; int bufferLength = 0 ; StringBuffer textBuffer = null ; while ( bufferLength != - 1 ) { bufferLength = rdr . read ( buffer ) ; if ( bufferLength > 0 ) { textBuffer = ( textBuffer == null ) ? new StringBuffer ( ) : textBuffer ; textBuffer . append ( new String ( buffer , 0 , bufferLength ) ) ; } } return ( textBuffer == null ) ? null : textBuffer . toString ( ) ; } public boolean createNewFile ( File f ) throws IOException { return f . createNewFile ( ) ; } public boolean createNewFile ( File f , boolean mkdirs ) throws IOException { File parent = f . getParentFile ( ) ; if ( mkdirs && ! ( parent . exists ( ) ) ) { parent . mkdirs ( ) ; } return f . createNewFile ( ) ; } public boolean isSymbolicLink ( File parent , String name ) throws IOException { if ( parent == null ) { File f = new File ( name ) ; parent = f . getParentFile ( ) ; name = f . getName ( ) ; } File toTest = new File ( parent . getCanonicalPath ( ) , name ) ; return ! toTest . getAbsolutePath ( ) . equals ( toTest . getCanonicalPath ( ) ) ; } public String removeLeadingPath ( File leading , File path ) { String l = normalize ( leading . getAbsolutePath ( ) ) . getAbsolutePath ( ) ; String p = normalize ( path . getAbsolutePath ( ) ) . getAbsolutePath ( ) ; if ( l . equals ( p ) ) { return "" ; } if ( ! l . endsWith ( File . separator ) ) { l += File . separator ; } return ( p . startsWith ( l ) ) ? p . substring ( l . length ( ) ) : p ; } public boolean isLeadingPath ( File leading , File path ) { String l = normalize ( leading . getAbsolutePath ( ) ) . getAbsolutePath ( ) ; String p = normalize ( path . getAbsolutePath ( ) ) . getAbsolutePath ( ) ; if ( l . equals ( p ) ) { return true ; } if ( ! l . endsWith ( File . separator ) ) { l += File . separator ; } return p . startsWith ( l ) ; } public String toURI ( String path ) { Class uriClazz = null ; try { uriClazz = Class . forName ( "java.net.URI" ) ; } catch ( ClassNotFoundException e ) { } if ( uriClazz != null ) { try { File f = new File ( path ) . getAbsoluteFile ( ) ; java . lang . reflect . Method toURIMethod = File . class . getMethod ( "toURI" , new Class [ 0 ] ) ; Object uriObj = toURIMethod . invoke ( f , new Object [ ] { } ) ; java . lang . reflect . Method toASCIIStringMethod = uriClazz . getMethod ( "toASCIIString" , new Class [ 0 ] ) ; return ( String ) toASCIIStringMethod . invoke ( uriObj , new Object [ ] { } ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } boolean isDir = new File ( path ) . isDirectory ( ) ; StringBuffer sb = new StringBuffer ( "file:" ) ; path = resolveFile ( null , path ) . getPath ( ) ; sb . append ( "//" ) ; if ( ! path . startsWith ( File . separator ) ) { sb . append ( "/" ) ; } path = path . replace ( '\\' , '/' ) ; try { sb . append ( Locator . encodeURI ( path ) ) ; } catch ( UnsupportedEncodingException exc ) { throw new BuildException ( exc ) ; } if ( isDir && ! path . endsWith ( "/" ) ) { sb . append ( '/' ) ; } return sb . toString ( ) ; } public String fromURI ( String uri ) { synchronized ( cacheFromUriLock ) { if ( uri . equals ( cacheFromUriRequest ) ) { return cacheFromUriResponse ; } String path = Locator . fromURI ( uri ) ; String ret = isAbsolutePath ( path ) ? normalize ( path ) . getAbsolutePath ( ) : path ; cacheFromUriRequest = uri ; cacheFromUriResponse = ret ; return ret ; } } public boolean fileNameEquals ( File f1 , File f2 ) { return normalize ( f1 . getAbsolutePath ( ) ) . equals ( normalize ( f2 . getAbsolutePath ( ) ) ) ; } public void rename ( File from , File to ) throws IOException { if ( to . exists ( ) && ! to . delete ( ) ) { throw new IOException ( "Failed to delete " + to + " while trying to rename " + from ) ; } File parent = to . getParentFile ( ) ; if ( parent != null && ! parent . exists ( ) && ! parent . mkdirs ( ) ) { throw new IOException ( "Failed to create directory " + parent + " while trying to rename " + from ) ; } if ( ! from . renameTo ( to ) ) { copyFile ( from , to ) ; if ( ! from . delete ( ) ) { throw new IOException ( "Failed to delete " + from + " while trying to rename it." ) ; } } } public long getFileTimestampGranularity ( ) { if ( onWin9x ) { return FAT_FILE_TIMESTAMP_GRANULARITY ; } else if ( onWindows ) { return NTFS_FILE_TIMESTAMP_GRANULARITY ; } else if ( onDos ) { return FAT_FILE_TIMESTAMP_GRANULARITY ; } return UNIX_FILE_TIMESTAMP_GRANULARITY ; } public boolean isUpToDate ( File source , File dest , long granularity ) { if ( ! dest . exists ( ) ) { return false ; } long sourceTime = source . lastModified ( ) ; long destTime = dest . lastModified ( ) ; return isUpToDate ( sourceTime , destTime , granularity ) ; } public boolean isUpToDate ( File source , File dest ) { return isUpToDate ( source , dest , getFileTimestampGranularity ( ) ) ; } public boolean isUpToDate ( long sourceTime , long destTime , long granularity ) { if ( destTime == - 1 ) { return false ; } return destTime >= sourceTime + granularity ; } public boolean isUpToDate ( long sourceTime , long destTime ) { return isUpToDate ( sourceTime , destTime , getFileTimestampGranularity ( ) ) ; } public static void close ( Writer device ) { if ( device != null ) { try { device . close ( ) ; } catch ( IOException ioex ) { } } } public static void close ( Reader device ) { if ( device != null ) { try { device . close ( ) ; } catch ( IOException ioex ) { } } } public static void close ( OutputStream device ) { if ( device != null ) { try { device . close ( ) ; } catch ( IOException ioex ) { } } } public static void close ( InputStream device ) { if ( device != null ) { try { device . close ( ) ; } catch ( IOException ioex ) { } } } public static void delete ( File file ) { if ( file != null ) { file . delete ( ) ; } } public static String getRelativePath ( File fromFile , File toFile ) throws Exception { String fromPath = fromFile . getCanonicalPath ( ) ; String toPath = toFile . getCanonicalPath ( ) ; String [ ] fromPathStack = getPathStack ( fromPath ) ; String [ ] toPathStack = getPathStack ( toPath ) ; if ( 0 < toPathStack . length && 0 < fromPathStack . length ) { if ( ! fromPathStack [ 0 ] . equals ( toPathStack [ 0 ] ) ) { return getPath ( Arrays . asList ( toPathStack ) ) ; } } else { return getPath ( Arrays . asList ( toPathStack ) ) ; } int minLength = Math . min ( fromPathStack . length , toPathStack . length ) ; int same = 1 ; for ( ; same < minLength ; same ++ ) { if ( ! fromPathStack [ same ] . equals ( toPathStack [ same ] ) ) { break ; } } List relativePathStack = new ArrayList ( ) ; for ( int i = same ; i < fromPathStack . length ; i ++ ) { relativePathStack . add ( ".." ) ; } for ( int i = same ; i < toPathStack . length ; i ++ ) { relativePathStack . add ( toPathStack [ i ] ) ; } return getPath ( relativePathStack ) ; } public static String [ ] getPathStack ( String path ) { String normalizedPath = path . replace ( File . separatorChar , '/' ) ; Object [ ] tokens = StringUtils . split ( normalizedPath , '/' ) . toArray ( ) ; String [ ] rv = new String [ tokens . length ] ; System . arraycopy ( tokens , 0 , rv , 0 , tokens . length ) ; return rv ; } public static String getPath ( List pathStack ) { return getPath ( pathStack , '/' ) ; } public static String getPath ( final List pathStack , final char separatorChar ) { final StringBuffer buffer = new StringBuffer ( ) ; final Iterator iter = pathStack . iterator ( ) ; if ( iter . hasNext ( ) ) { buffer . append ( iter . next ( ) ) ; } while ( iter . hasNext ( ) ) { buffer . append ( separatorChar ) ; buffer . append ( iter . next ( ) ) ; } return buffer . toString ( ) ; } public String getDefaultEncoding ( ) { InputStreamReader is = new InputStreamReader ( new InputStream ( ) { public int read ( ) { return - 1 ; } } ) ; try { return is . getEncoding ( ) ; } finally { close ( is ) ; } } } 	1	['58', '1', '0', '142', '158', '1627', '134', '12', '56', '0.949874687', '1752', '0.642857143', '1', '0', '0.160233918', '0', '0', '28.96551724', '17', '2.6379', '4']
package org . apache . tools . ant ; import java . util . Hashtable ; import java . util . Vector ; import java . util . Enumeration ; public class PropertyHelper { private Project project ; private PropertyHelper next ; private Hashtable properties = new Hashtable ( ) ; private Hashtable userProperties = new Hashtable ( ) ; private Hashtable inheritedProperties = new Hashtable ( ) ; protected PropertyHelper ( ) { } public void setProject ( Project p ) { this . project = p ; } public void setNext ( PropertyHelper next ) { this . next = next ; } public PropertyHelper getNext ( ) { return next ; } public static synchronized PropertyHelper getPropertyHelper ( Project project ) { PropertyHelper helper = ( PropertyHelper ) project . getReference ( MagicNames . REFID_PROPERTY_HELPER ) ; if ( helper != null ) { return helper ; } helper = new PropertyHelper ( ) ; helper . setProject ( project ) ; project . addReference ( MagicNames . REFID_PROPERTY_HELPER , helper ) ; return helper ; } public boolean setPropertyHook ( String ns , String name , Object value , boolean inherited , boolean user , boolean isNew ) { if ( getNext ( ) != null ) { boolean subst = getNext ( ) . setPropertyHook ( ns , name , value , inherited , user , isNew ) ; if ( subst ) { return true ; } } return false ; } public Object getPropertyHook ( String ns , String name , boolean user ) { if ( getNext ( ) != null ) { Object o = getNext ( ) . getPropertyHook ( ns , name , user ) ; if ( o != null ) { return o ; } } if ( name . startsWith ( "toString:" ) ) { name = name . substring ( "toString:" . length ( ) ) ; Object v = project . getReference ( name ) ; return ( v == null ) ? null : v . toString ( ) ; } return null ; } public void parsePropertyString ( String value , Vector fragments , Vector propertyRefs ) throws BuildException { parsePropertyStringDefault ( value , fragments , propertyRefs ) ; } public String replaceProperties ( String ns , String value , Hashtable keys ) throws BuildException { if ( value == null || value . indexOf ( '$' ) == - 1 ) { return value ; } Vector fragments = new Vector ( ) ; Vector propertyRefs = new Vector ( ) ; parsePropertyString ( value , fragments , propertyRefs ) ; StringBuffer sb = new StringBuffer ( ) ; Enumeration i = fragments . elements ( ) ; Enumeration j = propertyRefs . elements ( ) ; while ( i . hasMoreElements ( ) ) { String fragment = ( String ) i . nextElement ( ) ; if ( fragment == null ) { String propertyName = ( String ) j . nextElement ( ) ; Object replacement = null ; if ( keys != null ) { replacement = keys . get ( propertyName ) ; } if ( replacement == null ) { replacement = getProperty ( ns , propertyName ) ; } if ( replacement == null ) { project . log ( "Property \"" + propertyName + "\" has not been set" , Project . MSG_VERBOSE ) ; } fragment = ( replacement != null ) ? replacement . toString ( ) : "${" + propertyName + "}" ; } sb . append ( fragment ) ; } return sb . toString ( ) ; } public synchronized boolean setProperty ( String ns , String name , Object value , boolean verbose ) { if ( null != userProperties . get ( name ) ) { if ( verbose ) { project . log ( "Override ignored for user property \"" + name + "\"" , Project . MSG_VERBOSE ) ; } return false ; } boolean done = setPropertyHook ( ns , name , value , false , false , false ) ; if ( done ) { return true ; } if ( null != properties . get ( name ) && verbose ) { project . log ( "Overriding previous definition of property \"" + name + "\"" , Project . MSG_VERBOSE ) ; } if ( verbose ) { project . log ( "Setting project property: " + name + " -> " + value , Project . MSG_DEBUG ) ; } properties . put ( name , value ) ; return true ; } public synchronized void setNewProperty ( String ns , String name , Object value ) { if ( null != properties . get ( name ) ) { project . log ( "Override ignored for property \"" + name + "\"" , Project . MSG_VERBOSE ) ; return ; } boolean done = setPropertyHook ( ns , name , value , false , false , true ) ; if ( done ) { return ; } project . log ( "Setting project property: " + name + " -> " + value , Project . MSG_DEBUG ) ; if ( name != null && value != null ) { properties . put ( name , value ) ; } } public synchronized void setUserProperty ( String ns , String name , Object value ) { project . log ( "Setting ro project property: " + name + " -> " + value , Project . MSG_DEBUG ) ; userProperties . put ( name , value ) ; boolean done = setPropertyHook ( ns , name , value , false , true , false ) ; if ( done ) { return ; } properties . put ( name , value ) ; } public synchronized void setInheritedProperty ( String ns , String name , Object value ) { inheritedProperties . put ( name , value ) ; project . log ( "Setting ro project property: " + name + " -> " + value , Project . MSG_DEBUG ) ; userProperties . put ( name , value ) ; boolean done = setPropertyHook ( ns , name , value , true , false , false ) ; if ( done ) { return ; } properties . put ( name , value ) ; } public synchronized Object getProperty ( String ns , String name ) { if ( name == null ) { return null ; } Object o = getPropertyHook ( ns , name , false ) ; if ( o != null ) { return o ; } return properties . get ( name ) ; } public synchronized Object getUserProperty ( String ns , String name ) { if ( name == null ) { return null ; } Object o = getPropertyHook ( ns , name , true ) ; if ( o != null ) { return o ; } return userProperties . get ( name ) ; } public Hashtable getProperties ( ) { return new Hashtable ( properties ) ; } public Hashtable getUserProperties ( ) { return new Hashtable ( userProperties ) ; } protected Hashtable getInternalProperties ( ) { return properties ; } protected Hashtable getInternalUserProperties ( ) { return userProperties ; } protected Hashtable getInternalInheritedProperties ( ) { return inheritedProperties ; } public void copyInheritedProperties ( Project other ) { Enumeration e = inheritedProperties . keys ( ) ; while ( e . hasMoreElements ( ) ) { String arg = e . nextElement ( ) . toString ( ) ; if ( other . getUserProperty ( arg ) != null ) { continue ; } Object value = inheritedProperties . get ( arg ) ; other . setInheritedProperty ( arg , value . toString ( ) ) ; } } public void copyUserProperties ( Project other ) { Enumeration e = userProperties . keys ( ) ; while ( e . hasMoreElements ( ) ) { Object arg = e . nextElement ( ) ; if ( inheritedProperties . containsKey ( arg ) ) { continue ; } Object value = userProperties . get ( arg ) ; other . setUserProperty ( arg . toString ( ) , value . toString ( ) ) ; } } static void parsePropertyStringDefault ( String value , Vector fragments , Vector propertyRefs ) throws BuildException { int prev = 0 ; int pos ; while ( ( pos = value . indexOf ( "$" , prev ) ) >= 0 ) { if ( pos > 0 ) { fragments . addElement ( value . substring ( prev , pos ) ) ; } if ( pos == ( value . length ( ) - 1 ) ) { fragments . addElement ( "$" ) ; prev = pos + 1 ; } else if ( value . charAt ( pos + 1 ) != '{' ) { if ( value . charAt ( pos + 1 ) == '$' ) { fragments . addElement ( "$" ) ; prev = pos + 2 ; } else { fragments . addElement ( value . substring ( pos , pos + 2 ) ) ; prev = pos + 2 ; } } else { int endName = value . indexOf ( '}' , pos ) ; if ( endName < 0 ) { throw new BuildException ( "Syntax error in property: " + value ) ; } String propertyName = value . substring ( pos + 2 , endName ) ; fragments . addElement ( null ) ; propertyRefs . addElement ( propertyName ) ; prev = endName + 1 ; } } if ( prev < value . length ( ) ) { fragments . addElement ( value . substring ( prev ) ) ; } } } 	1	['23', '1', '0', '4', '56', '107', '3', '2', '18', '0.636363636', '689', '1', '2', '0', '0.260869565', '0', '0', '28.73913043', '7', '2.1304', '3']
package org . apache . tools . ant . types ; import org . apache . tools . ant . Project ; public class Substitution extends DataType { public static final String DATA_TYPE_NAME = "substitition" ; private String expression ; public Substitution ( ) { this . expression = null ; } public void setExpression ( String expression ) { this . expression = expression ; } public String getExpression ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getExpression ( p ) ; } return expression ; } public Substitution getRef ( Project p ) { return ( Substitution ) getCheckedRef ( p ) ; } } 	1	['4', '3', '0', '5', '7', '0', '3', '2', '4', '0.833333333', '33', '0.5', '0', '0.909090909', '0.583333333', '0', '0', '6.75', '2', '1', '1']
package org . apache . tools . zip ; import java . util . Hashtable ; import java . util . Vector ; import java . util . zip . ZipException ; public class ExtraFieldUtils { private static Hashtable implementations ; static { implementations = new Hashtable ( ) ; register ( AsiExtraField . class ) ; register ( JarMarker . class ) ; } public static void register ( Class c ) { try { ZipExtraField ze = ( ZipExtraField ) c . newInstance ( ) ; implementations . put ( ze . getHeaderId ( ) , c ) ; } catch ( ClassCastException cc ) { throw new RuntimeException ( c + " doesn\'t implement ZipExtraField" ) ; } catch ( InstantiationException ie ) { throw new RuntimeException ( c + " is not a concrete class" ) ; } catch ( IllegalAccessException ie ) { throw new RuntimeException ( c + "\'s no-arg constructor is not public" ) ; } } public static ZipExtraField createExtraField ( ZipShort headerId ) throws InstantiationException , IllegalAccessException { Class c = ( Class ) implementations . get ( headerId ) ; if ( c != null ) { return ( ZipExtraField ) c . newInstance ( ) ; } UnrecognizedExtraField u = new UnrecognizedExtraField ( ) ; u . setHeaderId ( headerId ) ; return u ; } public static ZipExtraField [ ] parse ( byte [ ] data ) throws ZipException { Vector v = new Vector ( ) ; int start = 0 ; while ( start <= data . length - 4 ) { ZipShort headerId = new ZipShort ( data , start ) ; int length = ( new ZipShort ( data , start + 2 ) ) . getValue ( ) ; if ( start + 4 + length > data . length ) { throw new ZipException ( "data starting at " + start + " is in unknown format" ) ; } try { ZipExtraField ze = createExtraField ( headerId ) ; ze . parseFromLocalFileData ( data , start + 4 , length ) ; v . addElement ( ze ) ; } catch ( InstantiationException ie ) { throw new ZipException ( ie . getMessage ( ) ) ; } catch ( IllegalAccessException iae ) { throw new ZipException ( iae . getMessage ( ) ) ; } start += ( length + 4 ) ; } if ( start != data . length ) { throw new ZipException ( "data starting at " + start + " is in unknown format" ) ; } ZipExtraField [ ] result = new ZipExtraField [ v . size ( ) ] ; v . copyInto ( result ) ; return result ; } public static byte [ ] mergeLocalFileDataData ( ZipExtraField [ ] data ) { int sum = 4 * data . length ; for ( int i = 0 ; i < data . length ; i ++ ) { sum += data [ i ] . getLocalFileDataLength ( ) . getValue ( ) ; } byte [ ] result = new byte [ sum ] ; int start = 0 ; for ( int i = 0 ; i < data . length ; i ++ ) { System . arraycopy ( data [ i ] . getHeaderId ( ) . getBytes ( ) , 0 , result , start , 2 ) ; System . arraycopy ( data [ i ] . getLocalFileDataLength ( ) . getBytes ( ) , 0 , result , start + 2 , 2 ) ; byte [ ] local = data [ i ] . getLocalFileDataData ( ) ; System . arraycopy ( local , 0 , result , start + 4 , local . length ) ; start += ( local . length + 4 ) ; } return result ; } public static byte [ ] mergeCentralDirectoryData ( ZipExtraField [ ] data ) { int sum = 4 * data . length ; for ( int i = 0 ; i < data . length ; i ++ ) { sum += data [ i ] . getCentralDirectoryLength ( ) . getValue ( ) ; } byte [ ] result = new byte [ sum ] ; int start = 0 ; for ( int i = 0 ; i < data . length ; i ++ ) { System . arraycopy ( data [ i ] . getHeaderId ( ) . getBytes ( ) , 0 , result , start , 2 ) ; System . arraycopy ( data [ i ] . getCentralDirectoryLength ( ) . getBytes ( ) , 0 , result , start + 2 , 2 ) ; byte [ ] local = data [ i ] . getCentralDirectoryData ( ) ; System . arraycopy ( local , 0 , result , start + 4 , local . length ) ; start += ( local . length + 4 ) ; } return result ; } } 	1	['7', '1', '0', '4', '41', '15', '1', '3', '6', '0.833333333', '388', '0.333333333', '0', '0', '0.2', '0', '0', '54', '3', '1.2857', '2']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . PrintStream ; import java . io . OutputStream ; import java . util . Iterator ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . Comparison ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . resources . Resources ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . util . PropertyOutputStream ; public class Length extends Task implements Condition { private static final String ALL = "all" ; private static final String EACH = "each" ; private static final String STRING = "string" ; private static final String LENGTH_REQUIRED = "Use of the Length condition requires that the length attribute be set." ; private String property ; private String string ; private Boolean trim ; private String mode = ALL ; private Comparison when = Comparison . EQUAL ; private Long length ; private Resources resources ; public synchronized void setProperty ( String property ) { this . property = property ; } public synchronized void setFile ( File file ) { add ( new FileResource ( file ) ) ; } public synchronized void add ( FileSet fs ) { add ( ( ResourceCollection ) fs ) ; } public synchronized void add ( ResourceCollection c ) { if ( c == null ) { return ; } resources = ( resources == null ) ? new Resources ( ) : resources ; resources . add ( c ) ; } public synchronized void setLength ( long ell ) { length = new Long ( ell ) ; } public synchronized void setWhen ( When w ) { setWhen ( ( Comparison ) w ) ; } public synchronized void setWhen ( Comparison c ) { when = c ; } public synchronized void setMode ( FileMode m ) { this . mode = m . getValue ( ) ; } public synchronized void setString ( String string ) { this . string = string ; this . mode = STRING ; } public synchronized void setTrim ( boolean trim ) { this . trim = trim ? Boolean . TRUE : Boolean . FALSE ; } public boolean getTrim ( ) { return trim != null && trim . booleanValue ( ) ; } public void execute ( ) { validate ( ) ; PrintStream ps = new PrintStream ( ( property != null ) ? ( OutputStream ) new PropertyOutputStream ( getProject ( ) , property ) : ( OutputStream ) new LogOutputStream ( this , Project . MSG_INFO ) ) ; if ( STRING . equals ( mode ) ) { ps . print ( getLength ( string , getTrim ( ) ) ) ; ps . close ( ) ; } else if ( EACH . equals ( mode ) ) { handleResources ( new EachHandler ( ps ) ) ; } else if ( ALL . equals ( mode ) ) { handleResources ( new AllHandler ( ps ) ) ; } } public boolean eval ( ) { validate ( ) ; if ( length == null ) { throw new BuildException ( LENGTH_REQUIRED ) ; } Long ell = null ; if ( STRING . equals ( mode ) ) { ell = new Long ( getLength ( string , getTrim ( ) ) ) ; } else { ConditionHandler h = new ConditionHandler ( ) ; handleResources ( h ) ; ell = new Long ( h . getLength ( ) ) ; } return when . evaluate ( ell . compareTo ( length ) ) ; } private void validate ( ) { if ( string != null ) { if ( resources != null ) { throw new BuildException ( "the string length function" + " is incompatible with the file/resource length function" ) ; } if ( ! ( STRING . equals ( mode ) ) ) { throw new BuildException ( "the mode attribute is for use" + " with the file/resource length function" ) ; } } else if ( resources != null ) { if ( ! ( EACH . equals ( mode ) || ALL . equals ( mode ) ) ) { throw new BuildException ( "invalid mode setting for" + " file/resource length function: \"" + mode + "\"" ) ; } else if ( trim != null ) { throw new BuildException ( "the trim attribute is" + " for use with the string length function only" ) ; } } else { throw new BuildException ( "you must set either the string attribute" + " or specify one or more files using the file attribute or" + " nested resource collections" ) ; } } private void handleResources ( Handler h ) { for ( Iterator i = resources . iterator ( ) ; i . hasNext ( ) ; ) { Resource r = ( Resource ) i . next ( ) ; if ( ! r . isExists ( ) ) { log ( r + " does not exist" , Project . MSG_ERR ) ; } else if ( r . isDirectory ( ) ) { log ( r + " is a directory; length unspecified" , Project . MSG_ERR ) ; } else { h . handle ( r ) ; } } h . complete ( ) ; } private static long getLength ( String s , boolean t ) { return ( t ? s . trim ( ) : s ) . length ( ) ; } public static class FileMode extends EnumeratedAttribute { static final String [ ] MODES = new String [ ] { EACH , ALL } ; public String [ ] getValues ( ) { return MODES ; } } public static class When extends Comparison { } private abstract class Handler { private PrintStream ps ; Handler ( PrintStream ps ) { this . ps = ps ; } protected PrintStream getPs ( ) { return ps ; } protected abstract void handle ( Resource r ) ; void complete ( ) { ps . close ( ) ; } } private class EachHandler extends Handler { EachHandler ( PrintStream ps ) { super ( ps ) ; } protected void handle ( Resource r ) { getPs ( ) . print ( r . toString ( ) ) ; getPs ( ) . print ( " : " ) ; long size = r . getSize ( ) ; if ( size == Resource . UNKNOWN_SIZE ) { getPs ( ) . println ( "unknown" ) ; } else { getPs ( ) . println ( size ) ; } } } private class AllHandler extends Handler { private long accum = 0L ; AllHandler ( PrintStream ps ) { super ( ps ) ; } protected long getAccum ( ) { return accum ; } protected synchronized void handle ( Resource r ) { long size = r . getSize ( ) ; if ( size == Resource . UNKNOWN_SIZE ) { log ( "Size unknown for " + r . toString ( ) , Project . MSG_WARN ) ; } else { accum += size ; } } void complete ( ) { getPs ( ) . print ( accum ) ; super . complete ( ) ; } } private class ConditionHandler extends AllHandler { ConditionHandler ( ) { super ( null ) ; } void complete ( ) { } long getLength ( ) { return getAccum ( ) ; } } } 	1	['17', '3', '0', '18', '53', '86', '4', '18', '14', '0.892045455', '348', '1', '2', '0.698113208', '0.155080214', '1', '1', '18.82352941', '8', '2.2353', '1']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . Reader ; import java . io . Writer ; import java . io . FileReader ; import java . io . InputStream ; import java . io . IOException ; import java . io . PrintWriter ; import java . io . OutputStream ; import java . io . StringReader ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . util . Arrays ; import java . util . Vector ; import java . util . Iterator ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . filters . util . ChainReaderHelper ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . FileList ; import org . apache . tools . ant . types . FilterChain ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . Restrict ; import org . apache . tools . ant . types . resources . Resources ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . StringResource ; import org . apache . tools . ant . types . resources . selectors . Not ; import org . apache . tools . ant . types . resources . selectors . Exists ; import org . apache . tools . ant . types . resources . selectors . ResourceSelector ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . ConcatResourceInputStream ; public class Concat extends Task { private static final int BUFFER_SIZE = 8192 ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private static final ResourceSelector EXISTS = new Exists ( ) ; private static final ResourceSelector NOT_EXISTS = new Not ( EXISTS ) ; private File destinationFile ; private boolean append ; private String encoding ; private String outputEncoding ; private boolean binary ; private StringBuffer textBuffer ; private Resources rc ; private Vector filterChains ; private boolean forceOverwrite = true ; private TextElement footer ; private TextElement header ; private boolean fixLastLine = false ; private String eolString ; private Writer outputWriter = null ; public Concat ( ) { reset ( ) ; } public void reset ( ) { append = false ; forceOverwrite = true ; destinationFile = null ; encoding = null ; outputEncoding = null ; fixLastLine = false ; filterChains = null ; footer = null ; header = null ; binary = false ; outputWriter = null ; textBuffer = null ; eolString = System . getProperty ( "line.separator" ) ; rc = null ; } public void setDestfile ( File destinationFile ) { this . destinationFile = destinationFile ; } public void setAppend ( boolean append ) { this . append = append ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; if ( outputEncoding == null ) { outputEncoding = encoding ; } } public void setOutputEncoding ( String outputEncoding ) { this . outputEncoding = outputEncoding ; } public void setForce ( boolean force ) { this . forceOverwrite = force ; } public Path createPath ( ) { Path path = new Path ( getProject ( ) ) ; add ( path ) ; return path ; } public void addFileset ( FileSet set ) { add ( set ) ; } public void addFilelist ( FileList list ) { add ( list ) ; } public void add ( ResourceCollection c ) { rc = rc == null ? new Resources ( ) : rc ; rc . add ( c ) ; } public void addFilterChain ( FilterChain filterChain ) { if ( filterChains == null ) { filterChains = new Vector ( ) ; } filterChains . addElement ( filterChain ) ; } public void addText ( String text ) { if ( textBuffer == null ) { textBuffer = new StringBuffer ( text . length ( ) ) ; } textBuffer . append ( text ) ; } public void addHeader ( TextElement headerToAdd ) { this . header = headerToAdd ; } public void addFooter ( TextElement footerToAdd ) { this . footer = footerToAdd ; } public void setFixLastLine ( boolean fixLastLine ) { this . fixLastLine = fixLastLine ; } public void setEol ( FixCRLF . CrLf crlf ) { String s = crlf . getValue ( ) ; if ( s . equals ( "cr" ) || s . equals ( "mac" ) ) { eolString = "\r" ; } else if ( s . equals ( "lf" ) || s . equals ( "unix" ) ) { eolString = "\n" ; } else if ( s . equals ( "crlf" ) || s . equals ( "dos" ) ) { eolString = "\r\n" ; } } public void setWriter ( Writer outputWriter ) { this . outputWriter = outputWriter ; } public void setBinary ( boolean binary ) { this . binary = binary ; } private ResourceCollection validate ( ) { sanitizeText ( ) ; if ( binary ) { if ( destinationFile == null ) { throw new BuildException ( "destfile attribute is required for binary concatenation" ) ; } if ( textBuffer != null ) { throw new BuildException ( "Nested text is incompatible with binary concatenation" ) ; } if ( encoding != null || outputEncoding != null ) { throw new BuildException ( "Seting input or output encoding is incompatible with binary" + " concatenation" ) ; } if ( filterChains != null ) { throw new BuildException ( "Setting filters is incompatible with binary concatenation" ) ; } if ( fixLastLine ) { throw new BuildException ( "Setting fixlastline is incompatible with binary concatenation" ) ; } if ( header != null || footer != null ) { throw new BuildException ( "Nested header or footer is incompatible with binary concatenation" ) ; } } if ( destinationFile != null && outputWriter != null ) { throw new BuildException ( "Cannot specify both a destination file and an output writer" ) ; } if ( rc == null && textBuffer == null ) { throw new BuildException ( "At least one resource must be provided, or some text." ) ; } if ( rc != null ) { if ( textBuffer != null ) { throw new BuildException ( "Cannot include inline text when using resources." ) ; } Restrict noexistRc = new Restrict ( ) ; noexistRc . add ( NOT_EXISTS ) ; noexistRc . add ( rc ) ; for ( Iterator i = noexistRc . iterator ( ) ; i . hasNext ( ) ; ) { log ( i . next ( ) + " does not exist." , Project . MSG_ERR ) ; } if ( destinationFile != null ) { for ( Iterator i = rc . iterator ( ) ; i . hasNext ( ) ; ) { Object o = i . next ( ) ; if ( o instanceof FileResource ) { File f = ( ( FileResource ) o ) . getFile ( ) ; if ( FILE_UTILS . fileNameEquals ( f , destinationFile ) ) { throw new BuildException ( "Input file \"" + f + "\" is the same as the output file." ) ; } } } } Restrict existRc = new Restrict ( ) ; existRc . add ( EXISTS ) ; existRc . add ( rc ) ; boolean outofdate = destinationFile == null || forceOverwrite ; if ( ! outofdate ) { for ( Iterator i = existRc . iterator ( ) ; ! outofdate && i . hasNext ( ) ; ) { Resource r = ( Resource ) i . next ( ) ; outofdate = ( r . getLastModified ( ) == 0L || r . getLastModified ( ) > destinationFile . lastModified ( ) ) ; } } if ( ! outofdate ) { log ( destinationFile + " is up-to-date." , Project . MSG_VERBOSE ) ; return null ; } return existRc ; } else { StringResource s = new StringResource ( ) ; s . setProject ( getProject ( ) ) ; s . setValue ( textBuffer . toString ( ) ) ; return s ; } } public void execute ( ) { ResourceCollection c = validate ( ) ; if ( c == null ) { return ; } if ( c . size ( ) < 1 && header == null && footer == null ) { log ( "No existing resources and no nested text, doing nothing" , Project . MSG_INFO ) ; return ; } if ( binary ) { binaryCat ( c ) ; } else { cat ( c ) ; } } private void binaryCat ( ResourceCollection c ) { log ( "Binary concatenation of " + c . size ( ) + " resources to " + destinationFile ) ; FileOutputStream out = null ; InputStream in = null ; try { try { out = new FileOutputStream ( destinationFile ) ; } catch ( Exception t ) { throw new BuildException ( "Unable to open " + destinationFile + " for writing" , t ) ; } in = new ConcatResourceInputStream ( c ) ; ( ( ConcatResourceInputStream ) in ) . setManagingComponent ( this ) ; Thread t = new Thread ( new StreamPumper ( in , out ) ) ; t . start ( ) ; try { t . join ( ) ; } catch ( InterruptedException e ) { try { t . join ( ) ; } catch ( InterruptedException ee ) { } } } finally { FileUtils . close ( in ) ; if ( out != null ) { try { out . close ( ) ; } catch ( Exception ex ) { throw new BuildException ( "Unable to close " + destinationFile , ex ) ; } } } } private void cat ( ResourceCollection c ) { OutputStream os = null ; char [ ] buffer = new char [ BUFFER_SIZE ] ; try { PrintWriter writer = null ; if ( outputWriter != null ) { writer = new PrintWriter ( outputWriter ) ; } else { if ( destinationFile == null ) { os = new LogOutputStream ( this , Project . MSG_WARN ) ; } else { File parent = destinationFile . getParentFile ( ) ; if ( ! parent . exists ( ) ) { parent . mkdirs ( ) ; } os = new FileOutputStream ( destinationFile . getAbsolutePath ( ) , append ) ; } if ( outputEncoding == null ) { writer = new PrintWriter ( new BufferedWriter ( new OutputStreamWriter ( os ) ) ) ; } else { writer = new PrintWriter ( new BufferedWriter ( new OutputStreamWriter ( os , outputEncoding ) ) ) ; } } if ( header != null ) { if ( header . getFiltering ( ) ) { concatenate ( buffer , writer , new StringReader ( header . getValue ( ) ) ) ; } else { writer . print ( header . getValue ( ) ) ; } } if ( c . size ( ) > 0 ) { concatenate ( buffer , writer , new MultiReader ( c ) ) ; } if ( footer != null ) { if ( footer . getFiltering ( ) ) { concatenate ( buffer , writer , new StringReader ( footer . getValue ( ) ) ) ; } else { writer . print ( footer . getValue ( ) ) ; } } writer . flush ( ) ; if ( os != null ) { os . flush ( ) ; } } catch ( IOException ioex ) { throw new BuildException ( "Error while concatenating: " + ioex . getMessage ( ) , ioex ) ; } finally { FileUtils . close ( os ) ; } } private void concatenate ( char [ ] buffer , Writer writer , Reader in ) throws IOException { if ( filterChains != null ) { ChainReaderHelper helper = new ChainReaderHelper ( ) ; helper . setBufferSize ( BUFFER_SIZE ) ; helper . setPrimaryReader ( in ) ; helper . setFilterChains ( filterChains ) ; helper . setProject ( getProject ( ) ) ; in = new BufferedReader ( helper . getAssembledReader ( ) ) ; } while ( true ) { int nRead = in . read ( buffer , 0 , buffer . length ) ; if ( nRead == - 1 ) { break ; } writer . write ( buffer , 0 , nRead ) ; } writer . flush ( ) ; } private void sanitizeText ( ) { if ( textBuffer != null ) { if ( textBuffer . substring ( 0 ) . trim ( ) . length ( ) == 0 ) { textBuffer = null ; } } } public static class TextElement extends ProjectComponent { private String value = "" ; private boolean trimLeading = false ; private boolean trim = false ; private boolean filtering = true ; private String encoding = null ; public void setFiltering ( boolean filtering ) { this . filtering = filtering ; } private boolean getFiltering ( ) { return filtering ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public void setFile ( File file ) throws BuildException { if ( ! file . exists ( ) ) { throw new BuildException ( "File " + file + " does not exist." ) ; } BufferedReader reader = null ; try { if ( this . encoding == null ) { reader = new BufferedReader ( new FileReader ( file ) ) ; } else { reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) , this . encoding ) ) ; } value = FileUtils . readFully ( reader ) ; } catch ( IOException ex ) { throw new BuildException ( ex ) ; } finally { FileUtils . close ( reader ) ; } } public void addText ( String value ) { this . value += getProject ( ) . replaceProperties ( value ) ; } public void setTrimLeading ( boolean strip ) { this . trimLeading = strip ; } public void setTrim ( boolean trim ) { this . trim = trim ; } public String getValue ( ) { if ( value == null ) { value = "" ; } if ( value . trim ( ) . length ( ) == 0 ) { value = "" ; } if ( trimLeading ) { char [ ] current = value . toCharArray ( ) ; StringBuffer b = new StringBuffer ( current . length ) ; boolean startOfLine = true ; int pos = 0 ; while ( pos < current . length ) { char ch = current [ pos ++ ] ; if ( startOfLine ) { if ( ch == ' ' || ch == '\t' ) { continue ; } startOfLine = false ; } b . append ( ch ) ; if ( ch == '\n' || ch == '\r' ) { startOfLine = true ; } } value = b . toString ( ) ; } if ( trim ) { value = value . trim ( ) ; } return value ; } } private class MultiReader extends Reader { private Reader reader = null ; private int lastPos = 0 ; private char [ ] lastChars = new char [ eolString . length ( ) ] ; private boolean needAddSeparator = false ; private Iterator i ; private MultiReader ( ResourceCollection c ) { i = c . iterator ( ) ; } private Reader getReader ( ) throws IOException { if ( reader == null && i . hasNext ( ) ) { Resource r = ( Resource ) i . next ( ) ; log ( "Concating " + r . toLongString ( ) , Project . MSG_VERBOSE ) ; InputStream is = r . getInputStream ( ) ; reader = new BufferedReader ( encoding == null ? new InputStreamReader ( is ) : new InputStreamReader ( is , encoding ) ) ; Arrays . fill ( lastChars , ( char ) 0 ) ; } return reader ; } private void nextReader ( ) throws IOException { close ( ) ; reader = null ; } public int read ( ) throws IOException { if ( needAddSeparator ) { int ret = eolString . charAt ( lastPos ++ ) ; if ( lastPos >= eolString . length ( ) ) { lastPos = 0 ; needAddSeparator = false ; } return ret ; } while ( getReader ( ) != null ) { int ch = getReader ( ) . read ( ) ; if ( ch == - 1 ) { nextReader ( ) ; if ( fixLastLine && isMissingEndOfLine ( ) ) { needAddSeparator = true ; lastPos = 0 ; } } else { addLastChar ( ( char ) ch ) ; return ch ; } } return - 1 ; } public int read ( char [ ] cbuf , int off , int len ) throws IOException { int amountRead = 0 ; while ( getReader ( ) != null || needAddSeparator ) { if ( needAddSeparator ) { cbuf [ off ] = eolString . charAt ( lastPos ++ ) ; if ( lastPos >= eolString . length ( ) ) { lastPos = 0 ; needAddSeparator = false ; } len -- ; off ++ ; amountRead ++ ; if ( len == 0 ) { return amountRead ; } continue ; } int nRead = getReader ( ) . read ( cbuf , off , len ) ; if ( nRead == - 1 || nRead == 0 ) { nextReader ( ) ; if ( fixLastLine && isMissingEndOfLine ( ) ) { needAddSeparator = true ; lastPos = 0 ; } } else { if ( fixLastLine ) { for ( int i = nRead ; i > ( nRead - lastChars . length ) ; -- i ) { if ( i <= 0 ) { break ; } addLastChar ( cbuf [ off + i - 1 ] ) ; } } len -= nRead ; off += nRead ; amountRead += nRead ; if ( len == 0 ) { return amountRead ; } } } if ( amountRead == 0 ) { return - 1 ; } else { return amountRead ; } } public void close ( ) throws IOException { if ( reader != null ) { reader . close ( ) ; } } private void addLastChar ( char ch ) { for ( int i = lastChars . length - 2 ; i >= 0 ; -- i ) { lastChars [ i ] = lastChars [ i + 1 ] ; } lastChars [ lastChars . length - 1 ] = ch ; } private boolean isMissingEndOfLine ( ) { for ( int i = 0 ; i < lastChars . length ; ++ i ) { if ( lastChars [ i ] != eolString . charAt ( i ) ) { return true ; } } return false ; } } } 	1	['29', '3', '0', '25', '109', '268', '1', '25', '20', '0.851190476', '879', '1', '6', '0.578125', '0.125', '1', '1', '28.68965517', '29', '3', '4']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . FileResource ; public abstract class Unpack extends Task { protected File source ; protected File dest ; protected Resource srcResource ; public void setSrc ( String src ) { log ( "DEPRECATED - The setSrc(String) method has been deprecated." + " Use setSrc(File) instead." ) ; setSrc ( getProject ( ) . resolveFile ( src ) ) ; } public void setDest ( String dest ) { log ( "DEPRECATED - The setDest(String) method has been deprecated." + " Use setDest(File) instead." ) ; setDest ( getProject ( ) . resolveFile ( dest ) ) ; } public void setSrc ( File src ) { setSrcResource ( new FileResource ( src ) ) ; } public void setSrcResource ( Resource src ) { if ( ! src . isExists ( ) ) { throw new BuildException ( "the archive doesn't exist" ) ; } if ( src . isDirectory ( ) ) { throw new BuildException ( "the archive can't be a directory" ) ; } if ( src instanceof FileResource ) { source = ( ( FileResource ) src ) . getFile ( ) ; } else if ( ! supportsNonFileResources ( ) ) { throw new BuildException ( "Only FileSystem resources are" + " supported." ) ; } srcResource = src ; } public void addConfigured ( ResourceCollection a ) { if ( a . size ( ) != 1 ) { throw new BuildException ( "only single argument resource collections" + " are supported as archives" ) ; } setSrcResource ( ( Resource ) a . iterator ( ) . next ( ) ) ; } public void setDest ( File dest ) { this . dest = dest ; } private void validate ( ) throws BuildException { if ( srcResource == null ) { throw new BuildException ( "No Src specified" , getLocation ( ) ) ; } if ( dest == null ) { dest = new File ( source . getParent ( ) ) ; } if ( dest . isDirectory ( ) ) { String defaultExtension = getDefaultExtension ( ) ; createDestFile ( defaultExtension ) ; } } private void createDestFile ( String defaultExtension ) { String sourceName = source . getName ( ) ; int len = sourceName . length ( ) ; if ( defaultExtension != null && len > defaultExtension . length ( ) && defaultExtension . equalsIgnoreCase ( sourceName . substring ( len - defaultExtension . length ( ) ) ) ) { dest = new File ( dest , sourceName . substring ( 0 , len - defaultExtension . length ( ) ) ) ; } else { dest = new File ( dest , sourceName ) ; } } public void execute ( ) throws BuildException { File savedDest = dest ; try { validate ( ) ; extract ( ) ; } finally { dest = savedDest ; } } protected abstract String getDefaultExtension ( ) ; protected abstract void extract ( ) ; protected boolean supportsNonFileResources ( ) { return false ; } } 	1	['13', '3', '2', '9', '36', '62', '2', '7', '8', '0.638888889', '202', '1', '1', '0.755102041', '0.307692308', '0', '0', '14.30769231', '5', '1.5385', '1']
package org . apache . tools . ant . taskdefs . optional ; import java . io . BufferedInputStream ; import java . io . BufferedOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . Hashtable ; import java . util . Vector ; import java . util . Enumeration ; import java . net . URL ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParserFactory ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . Source ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . Templates ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerException ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . URIResolver ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import javax . xml . transform . TransformerConfigurationException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . XSLTLiaison3 ; import org . apache . tools . ant . taskdefs . XSLTLogger ; import org . apache . tools . ant . taskdefs . XSLTLoggerAware ; import org . apache . tools . ant . taskdefs . XSLTProcess ; import org . apache . tools . ant . types . XMLCatalog ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . URLResource ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JAXPUtils ; import org . xml . sax . EntityResolver ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; public class TraXLiaison implements XSLTLiaison3 , ErrorListener , XSLTLoggerAware { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private Project project ; private String factoryName = null ; private TransformerFactory tfactory = null ; private Resource stylesheet ; private XSLTLogger logger ; private EntityResolver entityResolver ; private Transformer transformer ; private Templates templates ; private long templatesModTime ; private URIResolver uriResolver ; private Vector outputProperties = new Vector ( ) ; private Hashtable params = new Hashtable ( ) ; private Vector attributes = new Vector ( ) ; public TraXLiaison ( ) throws Exception { } public void setStylesheet ( File stylesheet ) throws Exception { FileResource fr = new FileResource ( ) ; fr . setProject ( project ) ; fr . setFile ( stylesheet ) ; setStylesheet ( fr ) ; } public void setStylesheet ( Resource stylesheet ) throws Exception { if ( this . stylesheet != null ) { transformer = null ; if ( ! this . stylesheet . equals ( stylesheet ) || ( stylesheet . getLastModified ( ) != templatesModTime ) ) { templates = null ; } } this . stylesheet = stylesheet ; } public void transform ( File infile , File outfile ) throws Exception { if ( transformer == null ) { createTransformer ( ) ; } InputStream fis = null ; OutputStream fos = null ; try { fis = new BufferedInputStream ( new FileInputStream ( infile ) ) ; fos = new BufferedOutputStream ( new FileOutputStream ( outfile ) ) ; StreamResult res = new StreamResult ( fos ) ; res . setSystemId ( JAXPUtils . getSystemId ( outfile ) ) ; Source src = getSource ( fis , infile ) ; setTransformationParameters ( ) ; transformer . transform ( src , res ) ; } finally { try { if ( fis != null ) { fis . close ( ) ; } } catch ( IOException ignored ) { } try { if ( fos != null ) { fos . close ( ) ; } } catch ( IOException ignored ) { } } } private Source getSource ( InputStream is , File infile ) throws ParserConfigurationException , SAXException { Source src = null ; if ( entityResolver != null ) { if ( getFactory ( ) . getFeature ( SAXSource . FEATURE ) ) { SAXParserFactory spFactory = SAXParserFactory . newInstance ( ) ; spFactory . setNamespaceAware ( true ) ; XMLReader reader = spFactory . newSAXParser ( ) . getXMLReader ( ) ; reader . setEntityResolver ( entityResolver ) ; src = new SAXSource ( reader , new InputSource ( is ) ) ; } else { throw new IllegalStateException ( "xcatalog specified, but " + "parser doesn't support SAX" ) ; } } else { src = new StreamSource ( is ) ; } src . setSystemId ( JAXPUtils . getSystemId ( infile ) ) ; return src ; } private Source getSource ( InputStream is , Resource resource ) throws ParserConfigurationException , SAXException { Source src = null ; if ( entityResolver != null ) { if ( getFactory ( ) . getFeature ( SAXSource . FEATURE ) ) { SAXParserFactory spFactory = SAXParserFactory . newInstance ( ) ; spFactory . setNamespaceAware ( true ) ; XMLReader reader = spFactory . newSAXParser ( ) . getXMLReader ( ) ; reader . setEntityResolver ( entityResolver ) ; src = new SAXSource ( reader , new InputSource ( is ) ) ; } else { throw new IllegalStateException ( "xcatalog specified, but " + "parser doesn't support SAX" ) ; } } else { src = new StreamSource ( is ) ; } src . setSystemId ( resourceToURI ( resource ) ) ; return src ; } private String resourceToURI ( Resource resource ) { if ( resource instanceof FileResource ) { File f = ( ( FileResource ) resource ) . getFile ( ) ; return FILE_UTILS . toURI ( f . getAbsolutePath ( ) ) ; } if ( resource instanceof URLResource ) { URL u = ( ( URLResource ) resource ) . getURL ( ) ; return String . valueOf ( u ) ; } else { return resource . getName ( ) ; } } private void readTemplates ( ) throws IOException , TransformerConfigurationException , ParserConfigurationException , SAXException { InputStream xslStream = null ; try { xslStream = new BufferedInputStream ( stylesheet . getInputStream ( ) ) ; templatesModTime = stylesheet . getLastModified ( ) ; Source src = getSource ( xslStream , stylesheet ) ; templates = getFactory ( ) . newTemplates ( src ) ; } finally { if ( xslStream != null ) { xslStream . close ( ) ; } } } private void createTransformer ( ) throws Exception { if ( templates == null ) { readTemplates ( ) ; } transformer = templates . newTransformer ( ) ; transformer . setErrorListener ( this ) ; if ( uriResolver != null ) { transformer . setURIResolver ( uriResolver ) ; } for ( int i = 0 ; i < outputProperties . size ( ) ; i ++ ) { final String [ ] pair = ( String [ ] ) outputProperties . elementAt ( i ) ; transformer . setOutputProperty ( pair [ 0 ] , pair [ 1 ] ) ; } } private void setTransformationParameters ( ) { for ( final Enumeration enumeration = params . keys ( ) ; enumeration . hasMoreElements ( ) ; ) { final String name = ( String ) enumeration . nextElement ( ) ; final String value = ( String ) params . get ( name ) ; transformer . setParameter ( name , value ) ; } } private TransformerFactory getFactory ( ) throws BuildException { if ( tfactory != null ) { return tfactory ; } if ( factoryName == null ) { tfactory = TransformerFactory . newInstance ( ) ; } else { try { Class clazz = Class . forName ( factoryName ) ; tfactory = ( TransformerFactory ) clazz . newInstance ( ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } tfactory . setErrorListener ( this ) ; for ( int i = 0 ; i < attributes . size ( ) ; i ++ ) { final Object [ ] pair = ( Object [ ] ) attributes . elementAt ( i ) ; tfactory . setAttribute ( ( String ) pair [ 0 ] , pair [ 1 ] ) ; } if ( uriResolver != null ) { tfactory . setURIResolver ( uriResolver ) ; } return tfactory ; } public void setFactory ( String name ) { factoryName = name ; } public void setAttribute ( String name , Object value ) { final Object [ ] pair = new Object [ ] { name , value } ; attributes . addElement ( pair ) ; } public void setOutputProperty ( String name , String value ) { final String [ ] pair = new String [ ] { name , value } ; outputProperties . addElement ( pair ) ; } public void setEntityResolver ( EntityResolver aResolver ) { entityResolver = aResolver ; } public void setURIResolver ( URIResolver aResolver ) { uriResolver = aResolver ; } public void addParam ( String name , String value ) { params . put ( name , value ) ; } public void setLogger ( XSLTLogger l ) { logger = l ; } public void error ( TransformerException e ) { logError ( e , "Error" ) ; } public void fatalError ( TransformerException e ) { logError ( e , "Fatal Error" ) ; throw new BuildException ( "Fatal error during transformation" , e ) ; } public void warning ( TransformerException e ) { logError ( e , "Warning" ) ; } private void logError ( TransformerException e , String type ) { if ( logger == null ) { return ; } StringBuffer msg = new StringBuffer ( ) ; SourceLocator locator = e . getLocator ( ) ; if ( locator != null ) { String systemid = locator . getSystemId ( ) ; if ( systemid != null ) { String url = systemid ; if ( url . startsWith ( "file:" ) ) { url = FileUtils . getFileUtils ( ) . fromURI ( url ) ; } msg . append ( url ) ; } else { msg . append ( "Unknown file" ) ; } int line = locator . getLineNumber ( ) ; if ( line != - 1 ) { msg . append ( ":" ) ; msg . append ( line ) ; int column = locator . getColumnNumber ( ) ; if ( column != - 1 ) { msg . append ( ":" ) ; msg . append ( column ) ; } } } msg . append ( ": " ) ; msg . append ( type ) ; msg . append ( "! " ) ; msg . append ( e . getMessage ( ) ) ; if ( e . getCause ( ) != null ) { msg . append ( " Cause: " ) ; msg . append ( e . getCause ( ) ) ; } logger . log ( msg . toString ( ) ) ; } protected String getSystemId ( File file ) { return JAXPUtils . getSystemId ( file ) ; } public void configure ( XSLTProcess xsltTask ) { project = xsltTask . getProject ( ) ; XSLTProcess . Factory factory = xsltTask . getFactory ( ) ; if ( factory != null ) { setFactory ( factory . getName ( ) ) ; for ( Enumeration attrs = factory . getAttributes ( ) ; attrs . hasMoreElements ( ) ; ) { XSLTProcess . Factory . Attribute attr = ( XSLTProcess . Factory . Attribute ) attrs . nextElement ( ) ; setAttribute ( attr . getName ( ) , attr . getValue ( ) ) ; } } XMLCatalog xmlCatalog = xsltTask . getXMLCatalog ( ) ; if ( xmlCatalog != null ) { setEntityResolver ( xmlCatalog ) ; setURIResolver ( xmlCatalog ) ; } for ( Enumeration props = xsltTask . getOutputProperties ( ) ; props . hasMoreElements ( ) ; ) { XSLTProcess . OutputProperty prop = ( XSLTProcess . OutputProperty ) props . nextElement ( ) ; setOutputProperty ( prop . getName ( ) , prop . getValue ( ) ) ; } } } 	1	['25', '1', '0', '15', '108', '244', '0', '15', '15', '0.81547619', '712', '1', '4', '0', '0.178030303', '0', '0', '26.92', '8', '1.48', '2']
package org . apache . tools . ant . launch ; import java . net . MalformedURLException ; import java . net . URL ; import java . io . File ; import java . io . FilenameFilter ; import java . io . ByteArrayOutputStream ; import java . io . UnsupportedEncodingException ; import java . text . CharacterIterator ; import java . text . StringCharacterIterator ; import java . util . Locale ; public final class Locator { public static final String URI_ENCODING = "UTF-8" ; private static boolean [ ] gNeedEscaping = new boolean [ 128 ] ; private static char [ ] gAfterEscaping1 = new char [ 128 ] ; private static char [ ] gAfterEscaping2 = new char [ 128 ] ; private static char [ ] gHexChs = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } ; static { for ( int i = 0 ; i <= 0x1f ; i ++ ) { gNeedEscaping [ i ] = true ; gAfterEscaping1 [ i ] = gHexChs [ i > > 4 ] ; gAfterEscaping2 [ i ] = gHexChs [ i & 0xf ] ; } gNeedEscaping [ 0x7f ] = true ; gAfterEscaping1 [ 0x7f ] = '7' ; gAfterEscaping2 [ 0x7f ] = 'F' ; char [ ] escChs = { ' ' , '<' , '>' , '#' , '%' , '"' , '{' , '}' , '|' , '\\' , '^' , '~' , '[' , ']' , '`' } ; int len = escChs . length ; char ch ; for ( int i = 0 ; i < len ; i ++ ) { ch = escChs [ i ] ; gNeedEscaping [ ch ] = true ; gAfterEscaping1 [ ch ] = gHexChs [ ch > > 4 ] ; gAfterEscaping2 [ ch ] = gHexChs [ ch & 0xf ] ; } } private Locator ( ) { } public static File getClassSource ( Class c ) { String classResource = c . getName ( ) . replace ( '.' , '/' ) + ".class" ; return getResourceSource ( c . getClassLoader ( ) , classResource ) ; } public static File getResourceSource ( ClassLoader c , String resource ) { if ( c == null ) { c = Locator . class . getClassLoader ( ) ; } URL url = null ; if ( c == null ) { url = ClassLoader . getSystemResource ( resource ) ; } else { url = c . getResource ( resource ) ; } if ( url != null ) { String u = url . toString ( ) ; if ( u . startsWith ( "jar:file:" ) ) { int pling = u . indexOf ( "!" ) ; String jarName = u . substring ( 4 , pling ) ; return new File ( fromURI ( jarName ) ) ; } else if ( u . startsWith ( "file:" ) ) { int tail = u . indexOf ( resource ) ; String dirName = u . substring ( 0 , tail ) ; return new File ( fromURI ( dirName ) ) ; } } return null ; } public static String fromURI ( String uri ) { Class uriClazz = null ; try { uriClazz = Class . forName ( "java.net.URI" ) ; } catch ( ClassNotFoundException cnfe ) { } if ( uriClazz != null && uri . startsWith ( "file:/" ) ) { try { java . lang . reflect . Method createMethod = uriClazz . getMethod ( "create" , new Class [ ] { String . class } ) ; Object uriObj = createMethod . invoke ( null , new Object [ ] { uri } ) ; java . lang . reflect . Constructor fileConst = File . class . getConstructor ( new Class [ ] { uriClazz } ) ; File f = ( File ) fileConst . newInstance ( new Object [ ] { uriObj } ) ; return f . getAbsolutePath ( ) ; } catch ( java . lang . reflect . InvocationTargetException e ) { Throwable e2 = e . getTargetException ( ) ; if ( e2 instanceof IllegalArgumentException ) { throw ( IllegalArgumentException ) e2 ; } else { e2 . printStackTrace ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } URL url = null ; try { url = new URL ( uri ) ; } catch ( MalformedURLException emYouEarlEx ) { } if ( url == null || ! ( "file" . equals ( url . getProtocol ( ) ) ) ) { throw new IllegalArgumentException ( "Can only handle valid file: URIs" ) ; } StringBuffer buf = new StringBuffer ( url . getHost ( ) ) ; if ( buf . length ( ) > 0 ) { buf . insert ( 0 , File . separatorChar ) . insert ( 0 , File . separatorChar ) ; } String file = url . getFile ( ) ; int queryPos = file . indexOf ( '?' ) ; buf . append ( ( queryPos < 0 ) ? file : file . substring ( 0 , queryPos ) ) ; uri = buf . toString ( ) . replace ( '/' , File . separatorChar ) ; if ( File . pathSeparatorChar == ';' && uri . startsWith ( "\\" ) && uri . length ( ) > 2 && Character . isLetter ( uri . charAt ( 1 ) ) && uri . lastIndexOf ( ':' ) > - 1 ) { uri = uri . substring ( 1 ) ; } String path = null ; try { path = decodeUri ( uri ) ; String cwd = System . getProperty ( "user.dir" ) ; int posi = cwd . indexOf ( ":" ) ; if ( ( posi > 0 ) && path . startsWith ( File . separator ) ) { path = cwd . substring ( 0 , posi + 1 ) + path ; } } catch ( UnsupportedEncodingException exc ) { throw new IllegalStateException ( "Could not convert URI to path: " + exc . getMessage ( ) ) ; } return path ; } public static String decodeUri ( String uri ) throws UnsupportedEncodingException { if ( uri . indexOf ( '%' ) == - 1 ) { return uri ; } ByteArrayOutputStream sb = new ByteArrayOutputStream ( uri . length ( ) ) ; CharacterIterator iter = new StringCharacterIterator ( uri ) ; for ( char c = iter . first ( ) ; c != CharacterIterator . DONE ; c = iter . next ( ) ) { if ( c == '%' ) { char c1 = iter . next ( ) ; if ( c1 != CharacterIterator . DONE ) { int i1 = Character . digit ( c1 , 16 ) ; char c2 = iter . next ( ) ; if ( c2 != CharacterIterator . DONE ) { int i2 = Character . digit ( c2 , 16 ) ; sb . write ( ( char ) ( ( i1 << 4 ) + i2 ) ) ; } } } else { sb . write ( c ) ; } } return sb . toString ( URI_ENCODING ) ; } public static String encodeURI ( String path ) throws UnsupportedEncodingException { int i = 0 ; int len = path . length ( ) ; int ch = 0 ; StringBuffer sb = null ; for ( ; i < len ; i ++ ) { ch = path . charAt ( i ) ; if ( ch >= 128 ) { break ; } if ( gNeedEscaping [ ch ] ) { if ( sb == null ) { sb = new StringBuffer ( path . substring ( 0 , i ) ) ; } sb . append ( '%' ) ; sb . append ( gAfterEscaping1 [ ch ] ) ; sb . append ( gAfterEscaping2 [ ch ] ) ; } else if ( sb != null ) { sb . append ( ( char ) ch ) ; } } if ( i < len ) { if ( sb == null ) { sb = new StringBuffer ( path . substring ( 0 , i ) ) ; } byte [ ] bytes = null ; byte b ; bytes = path . substring ( i ) . getBytes ( URI_ENCODING ) ; len = bytes . length ; for ( i = 0 ; i < len ; i ++ ) { b = bytes [ i ] ; if ( b < 0 ) { ch = b + 256 ; sb . append ( '%' ) ; sb . append ( gHexChs [ ch > > 4 ] ) ; sb . append ( gHexChs [ ch & 0xf ] ) ; } else if ( gNeedEscaping [ b ] ) { sb . append ( '%' ) ; sb . append ( gAfterEscaping1 [ b ] ) ; sb . append ( gAfterEscaping2 [ b ] ) ; } else { sb . append ( ( char ) b ) ; } } } return sb == null ? path : sb . toString ( ) ; } public static URL fileToURL ( File file ) throws MalformedURLException { try { return new URL ( encodeURI ( file . toURL ( ) . toString ( ) ) ) ; } catch ( UnsupportedEncodingException ex ) { throw new MalformedURLException ( ex . toString ( ) ) ; } } public static File getToolsJar ( ) { boolean toolsJarAvailable = false ; try { Class . forName ( "com.sun.tools.javac.Main" ) ; toolsJarAvailable = true ; } catch ( Exception e ) { try { Class . forName ( "sun.tools.javac.Main" ) ; toolsJarAvailable = true ; } catch ( Exception e2 ) { } } if ( toolsJarAvailable ) { return null ; } String javaHome = System . getProperty ( "java.home" ) ; File toolsJar = new File ( javaHome + "/lib/tools.jar" ) ; if ( toolsJar . exists ( ) ) { return toolsJar ; } if ( javaHome . toLowerCase ( Locale . US ) . endsWith ( File . separator + "jre" ) ) { javaHome = javaHome . substring ( 0 , javaHome . length ( ) - 4 ) ; toolsJar = new File ( javaHome + "/lib/tools.jar" ) ; } if ( ! toolsJar . exists ( ) ) { System . out . println ( "Unable to locate tools.jar. " + "Expected to find it in " + toolsJar . getPath ( ) ) ; return null ; } return toolsJar ; } public static URL [ ] getLocationURLs ( File location ) throws MalformedURLException { return getLocationURLs ( location , new String [ ] { ".jar" } ) ; } public static URL [ ] getLocationURLs ( File location , final String [ ] extensions ) throws MalformedURLException { URL [ ] urls = new URL [ 0 ] ; if ( ! location . exists ( ) ) { return urls ; } if ( ! location . isDirectory ( ) ) { urls = new URL [ 1 ] ; String path = location . getPath ( ) ; for ( int i = 0 ; i < extensions . length ; ++ i ) { if ( path . toLowerCase ( ) . endsWith ( extensions [ i ] ) ) { urls [ 0 ] = fileToURL ( location ) ; break ; } } return urls ; } File [ ] matches = location . listFiles ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { for ( int i = 0 ; i < extensions . length ; ++ i ) { if ( name . toLowerCase ( ) . endsWith ( extensions [ i ] ) ) { return true ; } } return false ; } } ) ; urls = new URL [ matches . length ] ; for ( int i = 0 ; i < matches . length ; ++ i ) { urls [ i ] = fileToURL ( matches [ i ] ) ; } return urls ; } } 	1	['11', '1', '0', '8', '75', '53', '7', '1', '9', '0.825', '968', '0.5', '0', '0', '0.183333333', '0', '0', '86.27272727', '17', '3.1818', '4']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . util . FileUtils ; public final class SelectorUtils { private static SelectorUtils instance = new SelectorUtils ( ) ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private SelectorUtils ( ) { } public static SelectorUtils getInstance ( ) { return instance ; } public static boolean matchPatternStart ( String pattern , String str ) { return matchPatternStart ( pattern , str , true ) ; } public static boolean matchPatternStart ( String pattern , String str , boolean isCaseSensitive ) { if ( str . startsWith ( File . separator ) != pattern . startsWith ( File . separator ) ) { return false ; } String [ ] patDirs = tokenizePathAsArray ( pattern ) ; String [ ] strDirs = tokenizePathAsArray ( str ) ; int patIdxStart = 0 ; int patIdxEnd = patDirs . length - 1 ; int strIdxStart = 0 ; int strIdxEnd = strDirs . length - 1 ; while ( patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd ) { String patDir = patDirs [ patIdxStart ] ; if ( patDir . equals ( "**" ) ) { break ; } if ( ! match ( patDir , strDirs [ strIdxStart ] , isCaseSensitive ) ) { return false ; } patIdxStart ++ ; strIdxStart ++ ; } if ( strIdxStart > strIdxEnd ) { return true ; } else if ( patIdxStart > patIdxEnd ) { return false ; } else { return true ; } } public static boolean matchPath ( String pattern , String str ) { return matchPath ( pattern , str , true ) ; } public static boolean matchPath ( String pattern , String str , boolean isCaseSensitive ) { String [ ] patDirs = tokenizePathAsArray ( pattern ) ; String [ ] strDirs = tokenizePathAsArray ( str ) ; int patIdxStart = 0 ; int patIdxEnd = patDirs . length - 1 ; int strIdxStart = 0 ; int strIdxEnd = strDirs . length - 1 ; while ( patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd ) { String patDir = patDirs [ patIdxStart ] ; if ( patDir . equals ( "**" ) ) { break ; } if ( ! match ( patDir , strDirs [ strIdxStart ] , isCaseSensitive ) ) { patDirs = null ; strDirs = null ; return false ; } patIdxStart ++ ; strIdxStart ++ ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( ! patDirs [ i ] . equals ( "**" ) ) { patDirs = null ; strDirs = null ; return false ; } } return true ; } else { if ( patIdxStart > patIdxEnd ) { patDirs = null ; strDirs = null ; return false ; } } while ( patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd ) { String patDir = patDirs [ patIdxEnd ] ; if ( patDir . equals ( "**" ) ) { break ; } if ( ! match ( patDir , strDirs [ strIdxEnd ] , isCaseSensitive ) ) { patDirs = null ; strDirs = null ; return false ; } patIdxEnd -- ; strIdxEnd -- ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( ! patDirs [ i ] . equals ( "**" ) ) { patDirs = null ; strDirs = null ; return false ; } } return true ; } while ( patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd ) { int patIdxTmp = - 1 ; for ( int i = patIdxStart + 1 ; i <= patIdxEnd ; i ++ ) { if ( patDirs [ i ] . equals ( "**" ) ) { patIdxTmp = i ; break ; } } if ( patIdxTmp == patIdxStart + 1 ) { patIdxStart ++ ; continue ; } int patLength = ( patIdxTmp - patIdxStart - 1 ) ; int strLength = ( strIdxEnd - strIdxStart + 1 ) ; int foundIdx = - 1 ; strLoop : for ( int i = 0 ; i <= strLength - patLength ; i ++ ) { for ( int j = 0 ; j < patLength ; j ++ ) { String subPat = patDirs [ patIdxStart + j + 1 ] ; String subStr = strDirs [ strIdxStart + i + j ] ; if ( ! match ( subPat , subStr , isCaseSensitive ) ) { continue strLoop ; } } foundIdx = strIdxStart + i ; break ; } if ( foundIdx == - 1 ) { patDirs = null ; strDirs = null ; return false ; } patIdxStart = patIdxTmp ; strIdxStart = foundIdx + patLength ; } for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( ! patDirs [ i ] . equals ( "**" ) ) { patDirs = null ; strDirs = null ; return false ; } } return true ; } public static boolean match ( String pattern , String str ) { return match ( pattern , str , true ) ; } public static boolean match ( String pattern , String str , boolean isCaseSensitive ) { char [ ] patArr = pattern . toCharArray ( ) ; char [ ] strArr = str . toCharArray ( ) ; int patIdxStart = 0 ; int patIdxEnd = patArr . length - 1 ; int strIdxStart = 0 ; int strIdxEnd = strArr . length - 1 ; char ch ; boolean containsStar = false ; for ( int i = 0 ; i < patArr . length ; i ++ ) { if ( patArr [ i ] == '*' ) { containsStar = true ; break ; } } if ( ! containsStar ) { if ( patIdxEnd != strIdxEnd ) { return false ; } for ( int i = 0 ; i <= patIdxEnd ; i ++ ) { ch = patArr [ i ] ; if ( ch != '?' ) { if ( isCaseSensitive && ch != strArr [ i ] ) { return false ; } if ( ! isCaseSensitive && Character . toUpperCase ( ch ) != Character . toUpperCase ( strArr [ i ] ) ) { return false ; } } } return true ; } if ( patIdxEnd == 0 ) { return true ; } while ( ( ch = patArr [ patIdxStart ] ) != '*' && strIdxStart <= strIdxEnd ) { if ( ch != '?' ) { if ( isCaseSensitive && ch != strArr [ strIdxStart ] ) { return false ; } if ( ! isCaseSensitive && Character . toUpperCase ( ch ) != Character . toUpperCase ( strArr [ strIdxStart ] ) ) { return false ; } } patIdxStart ++ ; strIdxStart ++ ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != '*' ) { return false ; } } return true ; } while ( ( ch = patArr [ patIdxEnd ] ) != '*' && strIdxStart <= strIdxEnd ) { if ( ch != '?' ) { if ( isCaseSensitive && ch != strArr [ strIdxEnd ] ) { return false ; } if ( ! isCaseSensitive && Character . toUpperCase ( ch ) != Character . toUpperCase ( strArr [ strIdxEnd ] ) ) { return false ; } } patIdxEnd -- ; strIdxEnd -- ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != '*' ) { return false ; } } return true ; } while ( patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd ) { int patIdxTmp = - 1 ; for ( int i = patIdxStart + 1 ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] == '*' ) { patIdxTmp = i ; break ; } } if ( patIdxTmp == patIdxStart + 1 ) { patIdxStart ++ ; continue ; } int patLength = ( patIdxTmp - patIdxStart - 1 ) ; int strLength = ( strIdxEnd - strIdxStart + 1 ) ; int foundIdx = - 1 ; strLoop : for ( int i = 0 ; i <= strLength - patLength ; i ++ ) { for ( int j = 0 ; j < patLength ; j ++ ) { ch = patArr [ patIdxStart + j + 1 ] ; if ( ch != '?' ) { if ( isCaseSensitive && ch != strArr [ strIdxStart + i + j ] ) { continue strLoop ; } if ( ! isCaseSensitive && Character . toUpperCase ( ch ) != Character . toUpperCase ( strArr [ strIdxStart + i + j ] ) ) { continue strLoop ; } } } foundIdx = strIdxStart + i ; break ; } if ( foundIdx == - 1 ) { return false ; } patIdxStart = patIdxTmp ; strIdxStart = foundIdx + patLength ; } for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != '*' ) { return false ; } } return true ; } public static Vector tokenizePath ( String path ) { return tokenizePath ( path , File . separator ) ; } public static Vector tokenizePath ( String path , String separator ) { Vector ret = new Vector ( ) ; if ( FileUtils . isAbsolutePath ( path ) ) { String [ ] s = FILE_UTILS . dissect ( path ) ; ret . add ( s [ 0 ] ) ; path = s [ 1 ] ; } StringTokenizer st = new StringTokenizer ( path , separator ) ; while ( st . hasMoreTokens ( ) ) { ret . addElement ( st . nextToken ( ) ) ; } return ret ; } private static String [ ] tokenizePathAsArray ( String path ) { String root = null ; if ( FileUtils . isAbsolutePath ( path ) ) { String [ ] s = FILE_UTILS . dissect ( path ) ; root = s [ 0 ] ; path = s [ 1 ] ; } char sep = File . separatorChar ; int start = 0 ; int len = path . length ( ) ; int count = 0 ; for ( int pos = 0 ; pos < len ; pos ++ ) { if ( path . charAt ( pos ) == sep ) { if ( pos != start ) { count ++ ; } start = pos + 1 ; } } if ( len != start ) { count ++ ; } String [ ] l = new String [ count + ( ( root == null ) ? 0 : 1 ) ] ; if ( root != null ) { l [ 0 ] = root ; count = 1 ; } else { count = 0 ; } start = 0 ; for ( int pos = 0 ; pos < len ; pos ++ ) { if ( path . charAt ( pos ) == sep ) { if ( pos != start ) { String tok = path . substring ( start , pos ) ; l [ count ++ ] = tok ; } start = pos + 1 ; } } if ( len != start ) { String tok = path . substring ( start ) ; l [ count ] = tok ; } return l ; } public static boolean isOutOfDate ( File src , File target , int granularity ) { if ( ! src . exists ( ) ) { return false ; } if ( ! target . exists ( ) ) { return true ; } if ( ( src . lastModified ( ) - granularity ) > target . lastModified ( ) ) { return true ; } return false ; } public static boolean isOutOfDate ( Resource src , Resource target , int granularity ) { return isOutOfDate ( src , target , ( long ) granularity ) ; } public static boolean isOutOfDate ( Resource src , Resource target , long granularity ) { if ( ! src . isExists ( ) ) { return false ; } if ( ! target . isExists ( ) ) { return true ; } if ( ( src . getLastModified ( ) - granularity ) > target . getLastModified ( ) ) { return true ; } return false ; } public static String removeWhitespace ( String input ) { StringBuffer result = new StringBuffer ( ) ; if ( input != null ) { StringTokenizer st = new StringTokenizer ( input ) ; while ( st . hasMoreTokens ( ) ) { result . append ( st . nextToken ( ) ) ; } } return result . toString ( ) ; } public static boolean hasWildcards ( String input ) { return ( input . indexOf ( '*' ) != - 1 || input . indexOf ( '?' ) != - 1 ) ; } public static String rtrimWildcardTokens ( String input ) { String [ ] tokens = tokenizePathAsArray ( input ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < tokens . length ; i ++ ) { if ( hasWildcards ( tokens [ i ] ) ) { break ; } if ( i > 0 && sb . charAt ( sb . length ( ) - 1 ) != File . separatorChar ) { sb . append ( File . separator ) ; } sb . append ( tokens [ i ] ) ; } return sb . toString ( ) ; } } 	1	['18', '1', '0', '10', '47', '145', '8', '2', '15', '0.794117647', '1004', '1', '2', '0', '0.18487395', '0', '0', '54.66666667', '47', '6.7778', '1']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . FilterSet ; import org . apache . tools . ant . types . FilterSetCollection ; public class Move extends Copy { public Move ( ) { super ( ) ; setOverwrite ( true ) ; } protected void validateAttributes ( ) throws BuildException { if ( file != null && file . isDirectory ( ) ) { if ( ( destFile != null && destDir != null ) || ( destFile == null && destDir == null ) ) { throw new BuildException ( "One and only one of tofile and todir " + "must be set." ) ; } destFile = ( destFile == null ) ? new File ( destDir , file . getName ( ) ) : destFile ; destDir = ( destDir == null ) ? destFile . getParentFile ( ) : destDir ; completeDirMap . put ( file , destFile ) ; file = null ; } else { super . validateAttributes ( ) ; } } protected void doFileOperations ( ) { if ( completeDirMap . size ( ) > 0 ) { Enumeration e = completeDirMap . keys ( ) ; while ( e . hasMoreElements ( ) ) { File fromDir = ( File ) e . nextElement ( ) ; File toDir = ( File ) completeDirMap . get ( fromDir ) ; boolean renamed = false ; try { log ( "Attempting to rename dir: " + fromDir + " to " + toDir , verbosity ) ; renamed = renameFile ( fromDir , toDir , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Failed to rename dir " + fromDir + " to " + toDir + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } if ( ! renamed ) { FileSet fs = new FileSet ( ) ; fs . setProject ( getProject ( ) ) ; fs . setDir ( fromDir ) ; addFileset ( fs ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] files = ds . getIncludedFiles ( ) ; String [ ] dirs = ds . getIncludedDirectories ( ) ; scan ( fromDir , toDir , files , dirs ) ; } } } int moveCount = fileCopyMap . size ( ) ; if ( moveCount > 0 ) { log ( "Moving " + moveCount + " file" + ( ( moveCount == 1 ) ? "" : "s" ) + " to " + destDir . getAbsolutePath ( ) ) ; Enumeration e = fileCopyMap . keys ( ) ; while ( e . hasMoreElements ( ) ) { String fromFile = ( String ) e . nextElement ( ) ; File f = new File ( fromFile ) ; boolean selfMove = false ; if ( f . exists ( ) ) { String [ ] toFiles = ( String [ ] ) fileCopyMap . get ( fromFile ) ; for ( int i = 0 ; i < toFiles . length ; i ++ ) { String toFile = ( String ) toFiles [ i ] ; if ( fromFile . equals ( toFile ) ) { log ( "Skipping self-move of " + fromFile , verbosity ) ; selfMove = true ; continue ; } File d = new File ( toFile ) ; if ( ( i + 1 ) == toFiles . length && ! selfMove ) { moveFile ( f , d , filtering , forceOverwrite ) ; } else { copyFile ( f , d , filtering , forceOverwrite ) ; } } } } } if ( includeEmpty ) { Enumeration e = dirCopyMap . keys ( ) ; int createCount = 0 ; while ( e . hasMoreElements ( ) ) { String fromDirName = ( String ) e . nextElement ( ) ; String [ ] toDirNames = ( String [ ] ) dirCopyMap . get ( fromDirName ) ; boolean selfMove = false ; for ( int i = 0 ; i < toDirNames . length ; i ++ ) { if ( fromDirName . equals ( toDirNames [ i ] ) ) { log ( "Skipping self-move of " + fromDirName , verbosity ) ; selfMove = true ; continue ; } File d = new File ( toDirNames [ i ] ) ; if ( ! d . exists ( ) ) { if ( ! d . mkdirs ( ) ) { log ( "Unable to create directory " + d . getAbsolutePath ( ) , Project . MSG_ERR ) ; } else { createCount ++ ; } } } File fromDir = new File ( fromDirName ) ; if ( ! selfMove && okToDelete ( fromDir ) ) { deleteDir ( fromDir ) ; } } if ( createCount > 0 ) { log ( "Moved " + dirCopyMap . size ( ) + " empty director" + ( dirCopyMap . size ( ) == 1 ? "y" : "ies" ) + " to " + createCount + " empty director" + ( createCount == 1 ? "y" : "ies" ) + " under " + destDir . getAbsolutePath ( ) ) ; } } } private void moveFile ( File fromFile , File toFile , boolean filtering , boolean overwrite ) { boolean moved = false ; try { log ( "Attempting to rename: " + fromFile + " to " + toFile , verbosity ) ; moved = renameFile ( fromFile , toFile , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Failed to rename " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } if ( ! moved ) { copyFile ( fromFile , toFile , filtering , overwrite ) ; if ( ! fromFile . delete ( ) ) { throw new BuildException ( "Unable to delete " + "file " + fromFile . getAbsolutePath ( ) ) ; } } } private void copyFile ( File fromFile , File toFile , boolean filtering , boolean overwrite ) { try { log ( "Copying " + fromFile + " to " + toFile , verbosity ) ; FilterSetCollection executionFilters = new FilterSetCollection ( ) ; if ( filtering ) { executionFilters . addFilterSet ( getProject ( ) . getGlobalFilterSet ( ) ) ; } for ( Enumeration filterEnum = getFilterSets ( ) . elements ( ) ; filterEnum . hasMoreElements ( ) ; ) { executionFilters . addFilterSet ( ( FilterSet ) filterEnum . nextElement ( ) ) ; } getFileUtils ( ) . copyFile ( fromFile , toFile , executionFilters , getFilterChains ( ) , forceOverwrite , getPreserveLastModified ( ) , getEncoding ( ) , getOutputEncoding ( ) , getProject ( ) ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } } protected boolean okToDelete ( File d ) { String [ ] list = d . list ( ) ; if ( list == null ) { return false ; } for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( d , s ) ; if ( f . isDirectory ( ) ) { if ( ! okToDelete ( f ) ) { return false ; } } else { return false ; } } return true ; } protected void deleteDir ( File d ) { deleteDir ( d , false ) ; } protected void deleteDir ( File d , boolean deleteFiles ) { String [ ] list = d . list ( ) ; if ( list == null ) { return ; } for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( d , s ) ; if ( f . isDirectory ( ) ) { deleteDir ( f ) ; } else if ( deleteFiles && ! ( f . delete ( ) ) ) { throw new BuildException ( "Unable to delete file " + f . getAbsolutePath ( ) ) ; } else { throw new BuildException ( "UNEXPECTED ERROR - The file " + f . getAbsolutePath ( ) + " should not exist!" ) ; } } log ( "Deleting directory " + d . getAbsolutePath ( ) , verbosity ) ; if ( ! d . delete ( ) ) { throw new BuildException ( "Unable to delete directory " + d . getAbsolutePath ( ) ) ; } } protected boolean renameFile ( File sourceFile , File destFile , boolean filtering , boolean overwrite ) throws IOException , BuildException { boolean renamed = false ; if ( ( getFilterSets ( ) . size ( ) + getFilterChains ( ) . size ( ) == 0 ) && ! ( filtering || destFile . isDirectory ( ) ) ) { File parent = destFile . getParentFile ( ) ; if ( parent != null && ! parent . exists ( ) ) { parent . mkdirs ( ) ; } if ( destFile . isFile ( ) && ! destFile . equals ( sourceFile ) && ! destFile . delete ( ) ) { throw new BuildException ( "Unable to remove existing " + "file " + destFile ) ; } renamed = sourceFile . renameTo ( destFile ) ; } return renamed ; } } 	1	['9', '4', '0', '10', '64', '22', '1', '9', '1', '2', '791', '0', '0', '0.909090909', '0.703703704', '4', '9', '86.88888889', '23', '4.8889', '1']
package org . apache . tools . ant ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . HashMap ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . taskdefs . PreSetDef ; public final class IntrospectionHelper { private static final Map EMPTY_MAP = Collections . unmodifiableMap ( new HashMap ( 0 ) ) ; private static final Map HELPERS = new Hashtable ( ) ; private static final Map PRIMITIVE_TYPE_MAP = new HashMap ( 8 ) ; static { Class [ ] primitives = { Boolean . TYPE , Byte . TYPE , Character . TYPE , Short . TYPE , Integer . TYPE , Long . TYPE , Float . TYPE , Double . TYPE } ; Class [ ] wrappers = { Boolean . class , Byte . class , Character . class , Short . class , Integer . class , Long . class , Float . class , Double . class } ; for ( int i = 0 ; i < primitives . length ; i ++ ) { PRIMITIVE_TYPE_MAP . put ( primitives [ i ] , wrappers [ i ] ) ; } } private static final int MAX_REPORT_NESTED_TEXT = 20 ; private static final String ELLIPSIS = "..." ; private Hashtable attributeTypes = new Hashtable ( ) ; private Hashtable attributeSetters = new Hashtable ( ) ; private Hashtable nestedTypes = new Hashtable ( ) ; private Hashtable nestedCreators = new Hashtable ( ) ; private List addTypeMethods = new ArrayList ( ) ; private Method addText = null ; private Class bean ; private IntrospectionHelper ( final Class bean ) { this . bean = bean ; Method [ ] methods = bean . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { final Method m = methods [ i ] ; final String name = m . getName ( ) ; Class returnType = m . getReturnType ( ) ; Class [ ] args = m . getParameterTypes ( ) ; if ( args . length == 1 && java . lang . Void . TYPE . equals ( returnType ) && ( "add" . equals ( name ) || "addConfigured" . equals ( name ) ) ) { insertAddTypeMethod ( m ) ; continue ; } if ( org . apache . tools . ant . ProjectComponent . class . isAssignableFrom ( bean ) && args . length == 1 && isHiddenSetMethod ( name , args [ 0 ] ) ) { continue ; } if ( isContainer ( ) && args . length == 1 && "addTask" . equals ( name ) && org . apache . tools . ant . Task . class . equals ( args [ 0 ] ) ) { continue ; } if ( "addText" . equals ( name ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && java . lang . String . class . equals ( args [ 0 ] ) ) { addText = methods [ i ] ; } else if ( name . startsWith ( "set" ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && ! args [ 0 ] . isArray ( ) ) { String propName = getPropertyName ( name , "set" ) ; if ( attributeSetters . get ( propName ) != null ) { if ( java . lang . String . class . equals ( args [ 0 ] ) ) { continue ; } } AttributeSetter as = createAttributeSetter ( m , args [ 0 ] , propName ) ; if ( as != null ) { attributeTypes . put ( propName , args [ 0 ] ) ; attributeSetters . put ( propName , as ) ; } } else if ( name . startsWith ( "create" ) && ! returnType . isArray ( ) && ! returnType . isPrimitive ( ) && args . length == 0 ) { String propName = getPropertyName ( name , "create" ) ; if ( nestedCreators . get ( propName ) == null ) { nestedTypes . put ( propName , returnType ) ; nestedCreators . put ( propName , new CreateNestedCreator ( m ) ) ; } } else if ( name . startsWith ( "addConfigured" ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && ! java . lang . String . class . equals ( args [ 0 ] ) && ! args [ 0 ] . isArray ( ) && ! args [ 0 ] . isPrimitive ( ) ) { try { Constructor constructor = null ; try { constructor = args [ 0 ] . getConstructor ( new Class [ ] { } ) ; } catch ( NoSuchMethodException ex ) { constructor = args [ 0 ] . getConstructor ( new Class [ ] { Project . class } ) ; } String propName = getPropertyName ( name , "addConfigured" ) ; nestedTypes . put ( propName , args [ 0 ] ) ; nestedCreators . put ( propName , new AddNestedCreator ( m , constructor , AddNestedCreator . ADD_CONFIGURED ) ) ; } catch ( NoSuchMethodException nse ) { } } else if ( name . startsWith ( "add" ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && ! java . lang . String . class . equals ( args [ 0 ] ) && ! args [ 0 ] . isArray ( ) && ! args [ 0 ] . isPrimitive ( ) ) { try { Constructor constructor = null ; try { constructor = args [ 0 ] . getConstructor ( new Class [ ] { } ) ; } catch ( NoSuchMethodException ex ) { constructor = args [ 0 ] . getConstructor ( new Class [ ] { Project . class } ) ; } String propName = getPropertyName ( name , "add" ) ; if ( nestedTypes . get ( propName ) != null ) { continue ; } nestedTypes . put ( propName , args [ 0 ] ) ; nestedCreators . put ( propName , new AddNestedCreator ( m , constructor , AddNestedCreator . ADD ) ) ; } catch ( NoSuchMethodException nse ) { } } } } private boolean isHiddenSetMethod ( String name , Class type ) { if ( "setLocation" . equals ( name ) && org . apache . tools . ant . Location . class . equals ( type ) ) { return true ; } if ( "setTaskType" . equals ( name ) && java . lang . String . class . equals ( type ) ) { return true ; } return false ; } public static synchronized IntrospectionHelper getHelper ( Class c ) { return getHelper ( null , c ) ; } public static IntrospectionHelper getHelper ( Project p , Class c ) { IntrospectionHelper ih = ( IntrospectionHelper ) HELPERS . get ( c . getName ( ) ) ; if ( ih == null || ih . bean != c ) { ih = new IntrospectionHelper ( c ) ; if ( p != null ) { HELPERS . put ( c . getName ( ) , ih ) ; } } return ih ; } public void setAttribute ( Project p , Object element , String attributeName , String value ) throws BuildException { AttributeSetter as = ( AttributeSetter ) attributeSetters . get ( attributeName . toLowerCase ( Locale . US ) ) ; if ( as == null ) { if ( element instanceof DynamicAttributeNS ) { DynamicAttributeNS dc = ( DynamicAttributeNS ) element ; String uriPlusPrefix = ProjectHelper . extractUriFromComponentName ( attributeName ) ; String uri = ProjectHelper . extractUriFromComponentName ( uriPlusPrefix ) ; String localName = ProjectHelper . extractNameFromComponentName ( attributeName ) ; String qName = ( "" . equals ( uri ) ? localName : ( uri + ":" + localName ) ) ; dc . setDynamicAttribute ( uri , localName , qName , value ) ; return ; } else if ( element instanceof DynamicAttribute ) { DynamicAttribute dc = ( DynamicAttribute ) element ; dc . setDynamicAttribute ( attributeName . toLowerCase ( Locale . US ) , value ) ; return ; } else { if ( attributeName . indexOf ( ':' ) != - 1 ) { return ; } String msg = getElementName ( p , element ) + " doesn't support the \"" + attributeName + "\" attribute." ; throw new UnsupportedAttributeException ( msg , attributeName ) ; } } try { as . set ( p , element , value ) ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public void addText ( Project project , Object element , String text ) throws BuildException { if ( addText == null ) { text = text . trim ( ) ; if ( text . length ( ) == 0 ) { return ; } else { String msg = project . getElementName ( element ) + " doesn't support nested text data (\"" + condenseText ( text ) + "\")." ; throw new BuildException ( msg ) ; } } try { addText . invoke ( element , new Object [ ] { text } ) ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public void throwNotSupported ( Project project , Object parent , String elementName ) { String msg = project . getElementName ( parent ) + " doesn't support the nested \"" + elementName + "\" element." ; throw new UnsupportedElementException ( msg , elementName ) ; } private NestedCreator getNestedCreator ( Project project , String parentUri , Object parent , String elementName , UnknownElement child ) throws BuildException { String uri = ProjectHelper . extractUriFromComponentName ( elementName ) ; String name = ProjectHelper . extractNameFromComponentName ( elementName ) ; if ( uri . equals ( ProjectHelper . ANT_CORE_URI ) ) { uri = "" ; } if ( parentUri . equals ( ProjectHelper . ANT_CORE_URI ) ) { parentUri = "" ; } NestedCreator nc = null ; if ( uri . equals ( parentUri ) || uri . equals ( "" ) ) { nc = ( NestedCreator ) nestedCreators . get ( name . toLowerCase ( Locale . US ) ) ; } if ( nc == null ) { nc = createAddTypeCreator ( project , parent , elementName ) ; } if ( nc == null && parent instanceof DynamicElementNS ) { DynamicElementNS dc = ( DynamicElementNS ) parent ; String qName = ( child == null ? name : child . getQName ( ) ) ; final Object nestedElement = dc . createDynamicElement ( ( child == null ? "" : child . getNamespace ( ) ) , name , qName ) ; if ( nestedElement != null ) { nc = new NestedCreator ( null ) { Object create ( Project project , Object parent , Object ignore ) { return nestedElement ; } } ; } } if ( nc == null && parent instanceof DynamicElement ) { DynamicElement dc = ( DynamicElement ) parent ; final Object nestedElement = dc . createDynamicElement ( name . toLowerCase ( Locale . US ) ) ; if ( nestedElement != null ) { nc = new NestedCreator ( null ) { Object create ( Project project , Object parent , Object ignore ) { return nestedElement ; } } ; } } if ( nc == null ) { throwNotSupported ( project , parent , elementName ) ; } return nc ; } public Object createElement ( Project project , Object parent , String elementName ) throws BuildException { NestedCreator nc = getNestedCreator ( project , "" , parent , elementName , null ) ; try { Object nestedElement = nc . create ( project , parent , null ) ; if ( project != null ) { project . setProjectReference ( nestedElement ) ; } return nestedElement ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InstantiationException ine ) { throw new BuildException ( ine ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public Creator getElementCreator ( Project project , String parentUri , Object parent , String elementName , UnknownElement ue ) { NestedCreator nc = getNestedCreator ( project , parentUri , parent , elementName , ue ) ; return new Creator ( project , parent , nc ) ; } public boolean isDynamic ( ) { return DynamicElement . class . isAssignableFrom ( bean ) || DynamicElementNS . class . isAssignableFrom ( bean ) ; } public boolean isContainer ( ) { return TaskContainer . class . isAssignableFrom ( bean ) ; } public boolean supportsNestedElement ( String elementName ) { return nestedCreators . containsKey ( elementName . toLowerCase ( Locale . US ) ) || isDynamic ( ) || addTypeMethods . size ( ) != 0 ; } public boolean supportsNestedElement ( String parentUri , String elementName ) { if ( parentUri . equals ( ProjectHelper . ANT_CORE_URI ) ) { parentUri = "" ; } String uri = ProjectHelper . extractUriFromComponentName ( elementName ) ; if ( uri . equals ( ProjectHelper . ANT_CORE_URI ) ) { uri = "" ; } String name = ProjectHelper . extractNameFromComponentName ( elementName ) ; return ( nestedCreators . containsKey ( name . toLowerCase ( Locale . US ) ) && ( uri . equals ( parentUri ) || "" . equals ( uri ) ) ) || isDynamic ( ) || addTypeMethods . size ( ) != 0 ; } public void storeElement ( Project project , Object parent , Object child , String elementName ) throws BuildException { if ( elementName == null ) { return ; } NestedCreator ns = ( NestedCreator ) nestedCreators . get ( elementName . toLowerCase ( Locale . US ) ) ; if ( ns == null ) { return ; } try { ns . store ( parent , child ) ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InstantiationException ine ) { throw new BuildException ( ine ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public Class getElementType ( String elementName ) throws BuildException { Class nt = ( Class ) nestedTypes . get ( elementName ) ; if ( nt == null ) { throw new UnsupportedElementException ( "Class " + bean . getName ( ) + " doesn't support the nested \"" + elementName + "\" element." , elementName ) ; } return nt ; } public Class getAttributeType ( String attributeName ) throws BuildException { Class at = ( Class ) attributeTypes . get ( attributeName ) ; if ( at == null ) { throw new UnsupportedAttributeException ( "Class " + bean . getName ( ) + " doesn't support the \"" + attributeName + "\" attribute." , attributeName ) ; } return at ; } public Method getAddTextMethod ( ) throws BuildException { if ( ! supportsCharacters ( ) ) { throw new BuildException ( "Class " + bean . getName ( ) + " doesn't support nested text data." ) ; } return addText ; } public Method getElementMethod ( String elementName ) throws BuildException { Object creator = nestedCreators . get ( elementName ) ; if ( creator == null ) { throw new UnsupportedElementException ( "Class " + bean . getName ( ) + " doesn't support the nested \"" + elementName + "\" element." , elementName ) ; } return ( ( NestedCreator ) creator ) . method ; } public Method getAttributeMethod ( String attributeName ) throws BuildException { Object setter = attributeSetters . get ( attributeName ) ; if ( setter == null ) { throw new UnsupportedAttributeException ( "Class " + bean . getName ( ) + " doesn't support the \"" + attributeName + "\" attribute." , attributeName ) ; } return ( ( AttributeSetter ) setter ) . method ; } public boolean supportsCharacters ( ) { return addText != null ; } public Enumeration getAttributes ( ) { return attributeSetters . keys ( ) ; } public Map getAttributeMap ( ) { return ( attributeTypes . size ( ) < 1 ) ? EMPTY_MAP : Collections . unmodifiableMap ( attributeTypes ) ; } public Enumeration getNestedElements ( ) { return nestedTypes . keys ( ) ; } public Map getNestedElementMap ( ) { return ( nestedTypes . size ( ) < 1 ) ? EMPTY_MAP : Collections . unmodifiableMap ( nestedTypes ) ; } public List getExtensionPoints ( ) { return ( addTypeMethods . size ( ) < 1 ) ? Collections . EMPTY_LIST : Collections . unmodifiableList ( addTypeMethods ) ; } private AttributeSetter createAttributeSetter ( final Method m , Class arg , final String attrName ) { final Class reflectedArg = PRIMITIVE_TYPE_MAP . containsKey ( arg ) ? ( Class ) PRIMITIVE_TYPE_MAP . get ( arg ) : arg ; if ( java . lang . String . class . equals ( reflectedArg ) ) { return new AttributeSetter ( m ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , ( Object [ ] ) ( new String [ ] { value } ) ) ; } } ; } else if ( java . lang . Character . class . equals ( reflectedArg ) ) { return new AttributeSetter ( m ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { if ( value . length ( ) == 0 ) { throw new BuildException ( "The value \"\" is not a " + "legal value for attribute \"" + attrName + "\"" ) ; } m . invoke ( parent , ( Object [ ] ) ( new Character [ ] { new Character ( value . charAt ( 0 ) ) } ) ) ; } } ; } else if ( java . lang . Boolean . class . equals ( reflectedArg ) ) { return new AttributeSetter ( m ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , ( Object [ ] ) ( new Boolean [ ] { Project . toBoolean ( value ) ? Boolean . TRUE : Boolean . FALSE } ) ) ; } } ; } else if ( java . lang . Class . class . equals ( reflectedArg ) ) { return new AttributeSetter ( m ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException { try { m . invoke ( parent , new Object [ ] { Class . forName ( value ) } ) ; } catch ( ClassNotFoundException ce ) { throw new BuildException ( ce ) ; } } } ; } else if ( java . io . File . class . equals ( reflectedArg ) ) { return new AttributeSetter ( m ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Object [ ] { p . resolveFile ( value ) } ) ; } } ; } else if ( EnumeratedAttribute . class . isAssignableFrom ( reflectedArg ) ) { return new AttributeSetter ( m ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException { try { EnumeratedAttribute ea = ( EnumeratedAttribute ) reflectedArg . newInstance ( ) ; ea . setValue ( value ) ; m . invoke ( parent , new Object [ ] { ea } ) ; } catch ( InstantiationException ie ) { throw new BuildException ( ie ) ; } } } ; } else if ( reflectedArg . getSuperclass ( ) != null && reflectedArg . getSuperclass ( ) . getName ( ) . equals ( "java.lang.Enum" ) ) { return new AttributeSetter ( m ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException { try { m . invoke ( parent , new Object [ ] { reflectedArg . getMethod ( "valueOf" , new Class [ ] { String . class } ) . invoke ( null , new Object [ ] { value } ) } ) ; } catch ( InvocationTargetException x ) { if ( x . getTargetException ( ) instanceof IllegalArgumentException ) { throw new BuildException ( "'" + value + "' is not a permitted value for " + reflectedArg . getName ( ) ) ; } else { throw new BuildException ( x . getTargetException ( ) ) ; } } catch ( Exception x ) { throw new BuildException ( x ) ; } } } ; } else { boolean includeProject ; Constructor c ; try { c = reflectedArg . getConstructor ( new Class [ ] { Project . class , String . class } ) ; includeProject = true ; } catch ( NoSuchMethodException nme ) { try { c = reflectedArg . getConstructor ( new Class [ ] { String . class } ) ; includeProject = false ; } catch ( NoSuchMethodException nme2 ) { return null ; } } final boolean finalIncludeProject = includeProject ; final Constructor finalConstructor = c ; return new AttributeSetter ( m ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException { try { Object [ ] args = ( finalIncludeProject ) ? new Object [ ] { p , value } : new Object [ ] { value } ; Object attribute = finalConstructor . newInstance ( args ) ; if ( p != null ) { p . setProjectReference ( attribute ) ; } m . invoke ( parent , new Object [ ] { attribute } ) ; } catch ( InstantiationException ie ) { throw new BuildException ( ie ) ; } } } ; } } protected String getElementName ( Project project , Object element ) { return project . getElementName ( element ) ; } private String getPropertyName ( String methodName , String prefix ) { return methodName . substring ( prefix . length ( ) ) . toLowerCase ( Locale . US ) ; } public static final class Creator { private NestedCreator nestedCreator ; private Object parent ; private Project project ; private Object nestedObject ; private String polyType ; private Creator ( Project project , Object parent , NestedCreator nestedCreator ) { this . project = project ; this . parent = parent ; this . nestedCreator = nestedCreator ; } public void setPolyType ( String polyType ) { this . polyType = polyType ; } public Object create ( ) { if ( polyType != null ) { if ( ! nestedCreator . isPolyMorphic ( ) ) { throw new BuildException ( "Not allowed to use the polymorphic form" + " for this element" ) ; } ComponentHelper helper = ComponentHelper . getComponentHelper ( project ) ; nestedObject = helper . createComponent ( polyType ) ; if ( nestedObject == null ) { throw new BuildException ( "Unable to create object of type " + polyType ) ; } } try { nestedObject = nestedCreator . create ( project , parent , nestedObject ) ; if ( project != null ) { project . setProjectReference ( nestedObject ) ; } return nestedObject ; } catch ( IllegalAccessException ex ) { throw new BuildException ( ex ) ; } catch ( InstantiationException ex ) { throw new BuildException ( ex ) ; } catch ( IllegalArgumentException ex ) { if ( polyType != null ) { throw new BuildException ( "Invalid type used " + polyType ) ; } throw ex ; } catch ( InvocationTargetException ex ) { Throwable t = ex . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public Object getRealObject ( ) { return nestedCreator . getRealObject ( ) ; } public void store ( ) { try { nestedCreator . store ( parent , nestedObject ) ; } catch ( IllegalAccessException ex ) { throw new BuildException ( ex ) ; } catch ( InstantiationException ex ) { throw new BuildException ( ex ) ; } catch ( IllegalArgumentException ex ) { if ( polyType != null ) { throw new BuildException ( "Invalid type used " + polyType ) ; } throw ex ; } catch ( InvocationTargetException ex ) { Throwable t = ex . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } } private abstract static class NestedCreator { private Method method ; NestedCreator ( Method m ) { this . method = m ; } Method getMethod ( ) { return method ; } boolean isPolyMorphic ( ) { return false ; } Object getRealObject ( ) { return null ; } abstract Object create ( Project project , Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException ; void store ( Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException { } } private class CreateNestedCreator extends NestedCreator { CreateNestedCreator ( Method m ) { super ( m ) ; } Object create ( Project project , Object parent , Object ignore ) throws InvocationTargetException , IllegalAccessException { return getMethod ( ) . invoke ( parent , new Object [ ] { } ) ; } } private class AddNestedCreator extends NestedCreator { static final int ADD = 1 ; static final int ADD_CONFIGURED = 2 ; private Constructor constructor ; private int behavior ; AddNestedCreator ( Method m , Constructor c , int behavior ) { super ( m ) ; this . constructor = c ; this . behavior = behavior ; } boolean isPolyMorphic ( ) { return true ; } Object create ( Project project , Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException { if ( child == null ) { child = constructor . newInstance ( ( constructor . getParameterTypes ( ) . length == 0 ) ? new Object [ ] { } : new Object [ ] { project } ) ; } if ( child instanceof PreSetDef . PreSetDefinition ) { child = ( ( PreSetDef . PreSetDefinition ) child ) . createObject ( project ) ; } if ( behavior == ADD ) { istore ( parent , child ) ; } return child ; } void store ( Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException { if ( behavior == ADD_CONFIGURED ) { istore ( parent , child ) ; } } private void istore ( Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException { getMethod ( ) . invoke ( parent , new Object [ ] { child } ) ; } } private abstract static class AttributeSetter { private Method method ; AttributeSetter ( Method m ) { this . method = m ; } abstract void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException ; } public static void clearCache ( ) { HELPERS . clear ( ) ; } private NestedCreator createAddTypeCreator ( Project project , Object parent , String elementName ) throws BuildException { if ( addTypeMethods . size ( ) == 0 ) { return null ; } ComponentHelper helper = ComponentHelper . getComponentHelper ( project ) ; Object addedObject = null ; Method addMethod = null ; Class clazz = helper . getComponentClass ( elementName ) ; if ( clazz == null ) { return null ; } addMethod = findMatchingMethod ( clazz , addTypeMethods ) ; if ( addMethod == null ) { return null ; } addedObject = helper . createComponent ( elementName ) ; if ( addedObject == null ) { return null ; } Object rObject = addedObject ; if ( addedObject instanceof PreSetDef . PreSetDefinition ) { rObject = ( ( PreSetDef . PreSetDefinition ) addedObject ) . createObject ( project ) ; } final Object nestedObject = addedObject ; final Object realObject = rObject ; return new NestedCreator ( addMethod ) { Object create ( Project project , Object parent , Object ignore ) throws InvocationTargetException , IllegalAccessException { if ( ! getMethod ( ) . getName ( ) . endsWith ( "Configured" ) ) { getMethod ( ) . invoke ( parent , new Object [ ] { realObject } ) ; } return nestedObject ; } Object getRealObject ( ) { return realObject ; } void store ( Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException { if ( getMethod ( ) . getName ( ) . endsWith ( "Configured" ) ) { getMethod ( ) . invoke ( parent , new Object [ ] { realObject } ) ; } } } ; } private void insertAddTypeMethod ( Method method ) { Class argClass = method . getParameterTypes ( ) [ 0 ] ; for ( int c = 0 ; c < addTypeMethods . size ( ) ; ++ c ) { Method current = ( Method ) addTypeMethods . get ( c ) ; if ( current . getParameterTypes ( ) [ 0 ] . equals ( argClass ) ) { if ( method . getName ( ) . equals ( "addConfigured" ) ) { addTypeMethods . set ( c , method ) ; } return ; } if ( current . getParameterTypes ( ) [ 0 ] . isAssignableFrom ( argClass ) ) { addTypeMethods . add ( c , method ) ; return ; } } addTypeMethods . add ( method ) ; } private Method findMatchingMethod ( Class paramClass , List methods ) { Class matchedClass = null ; Method matchedMethod = null ; for ( int i = 0 ; i < methods . size ( ) ; ++ i ) { Method method = ( Method ) methods . get ( i ) ; Class methodClass = method . getParameterTypes ( ) [ 0 ] ; if ( methodClass . isAssignableFrom ( paramClass ) ) { if ( matchedClass == null ) { matchedClass = methodClass ; matchedMethod = method ; } else { if ( ! methodClass . isAssignableFrom ( matchedClass ) ) { throw new BuildException ( "ambiguous: types " + matchedClass . getName ( ) + " and " + methodClass . getName ( ) + " match " + paramClass . getName ( ) ) ; } } } } return matchedMethod ; } private String condenseText ( final String text ) { if ( text . length ( ) <= MAX_REPORT_NESTED_TEXT ) { return text ; } int ends = ( MAX_REPORT_NESTED_TEXT - ELLIPSIS . length ( ) ) / 2 ; return new StringBuffer ( text ) . replace ( ends , text . length ( ) - ends , ELLIPSIS ) . toString ( ) ; } } 	1	['35', '1', '0', '32', '120', '417', '20', '28', '24', '0.927893738', '2098', '0.387096774', '0', '0', '0.290441176', '0', '0', '58.05714286', '19', '2.5143', '4']
package org . apache . tools . ant . taskdefs . cvslib ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . UnsupportedEncodingException ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Enumeration ; import java . util . Properties ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . AbstractCvsTask ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . util . FileUtils ; public class ChangeLogTask extends AbstractCvsTask { private File usersFile ; private Vector cvsUsers = new Vector ( ) ; private File inputDir ; private File destFile ; private Date startDate ; private Date endDate ; private final Vector filesets = new Vector ( ) ; public void setDir ( final File inputDir ) { this . inputDir = inputDir ; } public void setDestfile ( final File destFile ) { this . destFile = destFile ; } public void setUsersfile ( final File usersFile ) { this . usersFile = usersFile ; } public void addUser ( final CvsUser user ) { cvsUsers . addElement ( user ) ; } public void setStart ( final Date start ) { this . startDate = start ; } public void setEnd ( final Date endDate ) { this . endDate = endDate ; } public void setDaysinpast ( final int days ) { final long time = System . currentTimeMillis ( ) - ( long ) days * 24 * 60 * 60 * 1000 ; setStart ( new Date ( time ) ) ; } public void addFileset ( final FileSet fileSet ) { filesets . addElement ( fileSet ) ; } public void execute ( ) throws BuildException { File savedDir = inputDir ; try { validate ( ) ; final Properties userList = new Properties ( ) ; loadUserlist ( userList ) ; for ( int i = 0 , size = cvsUsers . size ( ) ; i < size ; i ++ ) { final CvsUser user = ( CvsUser ) cvsUsers . get ( i ) ; user . validate ( ) ; userList . put ( user . getUserID ( ) , user . getDisplayname ( ) ) ; } setCommand ( "log" ) ; if ( getTag ( ) != null ) { CvsVersion myCvsVersion = new CvsVersion ( ) ; myCvsVersion . setProject ( getProject ( ) ) ; myCvsVersion . setTaskName ( "cvsversion" ) ; myCvsVersion . setCvsRoot ( getCvsRoot ( ) ) ; myCvsVersion . setCvsRsh ( getCvsRsh ( ) ) ; myCvsVersion . setPassfile ( getPassFile ( ) ) ; myCvsVersion . setDest ( inputDir ) ; myCvsVersion . execute ( ) ; if ( myCvsVersion . supportsCvsLogWithSOption ( ) ) { addCommandArgument ( "-S" ) ; } } if ( null != startDate ) { final SimpleDateFormat outputDate = new SimpleDateFormat ( "yyyy-MM-dd" ) ; final String dateRange = ">=" + outputDate . format ( startDate ) ; addCommandArgument ( "-d" ) ; addCommandArgument ( dateRange ) ; } if ( ! filesets . isEmpty ( ) ) { final Enumeration e = filesets . elements ( ) ; while ( e . hasMoreElements ( ) ) { final FileSet fileSet = ( FileSet ) e . nextElement ( ) ; final DirectoryScanner scanner = fileSet . getDirectoryScanner ( getProject ( ) ) ; final String [ ] files = scanner . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { addCommandArgument ( files [ i ] ) ; } } } final ChangeLogParser parser = new ChangeLogParser ( ) ; final RedirectingStreamHandler handler = new RedirectingStreamHandler ( parser ) ; log ( getCommand ( ) , Project . MSG_VERBOSE ) ; setDest ( inputDir ) ; setExecuteStreamHandler ( handler ) ; try { super . execute ( ) ; } finally { final String errors = handler . getErrors ( ) ; if ( null != errors ) { log ( errors , Project . MSG_ERR ) ; } } final CVSEntry [ ] entrySet = parser . getEntrySetAsArray ( ) ; final CVSEntry [ ] filteredEntrySet = filterEntrySet ( entrySet ) ; replaceAuthorIdWithName ( userList , filteredEntrySet ) ; writeChangeLog ( filteredEntrySet ) ; } finally { inputDir = savedDir ; } } private void validate ( ) throws BuildException { if ( null == inputDir ) { inputDir = getProject ( ) . getBaseDir ( ) ; } if ( null == destFile ) { final String message = "Destfile must be set." ; throw new BuildException ( message ) ; } if ( ! inputDir . exists ( ) ) { final String message = "Cannot find base dir " + inputDir . getAbsolutePath ( ) ; throw new BuildException ( message ) ; } if ( null != usersFile && ! usersFile . exists ( ) ) { final String message = "Cannot find user lookup list " + usersFile . getAbsolutePath ( ) ; throw new BuildException ( message ) ; } } private void loadUserlist ( final Properties userList ) throws BuildException { if ( null != usersFile ) { try { userList . load ( new FileInputStream ( usersFile ) ) ; } catch ( final IOException ioe ) { throw new BuildException ( ioe . toString ( ) , ioe ) ; } } } private CVSEntry [ ] filterEntrySet ( final CVSEntry [ ] entrySet ) { final Vector results = new Vector ( ) ; for ( int i = 0 ; i < entrySet . length ; i ++ ) { final CVSEntry cvsEntry = entrySet [ i ] ; final Date date = cvsEntry . getDate ( ) ; if ( null == date ) { continue ; } if ( null != startDate && startDate . after ( date ) ) { continue ; } if ( null != endDate && endDate . before ( date ) ) { continue ; } results . addElement ( cvsEntry ) ; } final CVSEntry [ ] resultArray = new CVSEntry [ results . size ( ) ] ; results . copyInto ( resultArray ) ; return resultArray ; } private void replaceAuthorIdWithName ( final Properties userList , final CVSEntry [ ] entrySet ) { for ( int i = 0 ; i < entrySet . length ; i ++ ) { final CVSEntry entry = entrySet [ i ] ; if ( userList . containsKey ( entry . getAuthor ( ) ) ) { entry . setAuthor ( userList . getProperty ( entry . getAuthor ( ) ) ) ; } } } private void writeChangeLog ( final CVSEntry [ ] entrySet ) throws BuildException { FileOutputStream output = null ; try { output = new FileOutputStream ( destFile ) ; final PrintWriter writer = new PrintWriter ( new OutputStreamWriter ( output , "UTF-8" ) ) ; final ChangeLogWriter serializer = new ChangeLogWriter ( ) ; serializer . printChangeLog ( writer , entrySet ) ; } catch ( final UnsupportedEncodingException uee ) { getProject ( ) . log ( uee . toString ( ) , Project . MSG_ERR ) ; } catch ( final IOException ioe ) { throw new BuildException ( ioe . toString ( ) , ioe ) ; } finally { FileUtils . close ( output ) ; } } } 	1	['15', '4', '0', '13', '87', '69', '0', '13', '10', '0.826530612', '498', '1', '0', '0.847826087', '0.233333333', '3', '5', '31.73333333', '7', '1.4667', '2']
package org . apache . tools . ant . taskdefs . cvslib ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Locale ; import java . util . TimeZone ; class ChangeLogParser { private static final int GET_FILE = 1 ; private static final int GET_DATE = 2 ; private static final int GET_COMMENT = 3 ; private static final int GET_REVISION = 4 ; private static final int GET_PREVIOUS_REV = 5 ; private static final SimpleDateFormat INPUT_DATE = new SimpleDateFormat ( "yyyy/MM/dd HH:mm:ss" , Locale . US ) ; private static final SimpleDateFormat CVS1129_INPUT_DATE = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss Z" , Locale . US ) ; static { TimeZone utc = TimeZone . getTimeZone ( "UTC" ) ; INPUT_DATE . setTimeZone ( utc ) ; CVS1129_INPUT_DATE . setTimeZone ( utc ) ; } private String file ; private String date ; private String author ; private String comment ; private String revision ; private String previousRevision ; private int status = GET_FILE ; private final Hashtable entries = new Hashtable ( ) ; public CVSEntry [ ] getEntrySetAsArray ( ) { final CVSEntry [ ] array = new CVSEntry [ entries . size ( ) ] ; int i = 0 ; for ( Enumeration e = entries . elements ( ) ; e . hasMoreElements ( ) ; ) { array [ i ++ ] = ( CVSEntry ) e . nextElement ( ) ; } return array ; } public void stdout ( final String line ) { switch ( status ) { case GET_FILE : reset ( ) ; processFile ( line ) ; break ; case GET_REVISION : processRevision ( line ) ; break ; case GET_DATE : processDate ( line ) ; break ; case GET_COMMENT : processComment ( line ) ; break ; case GET_PREVIOUS_REV : processGetPreviousRevision ( line ) ; break ; default : break ; } } private void processComment ( final String line ) { final String lineSeparator = System . getProperty ( "line.separator" ) ; if ( line . equals ( "=============================================================================" ) ) { final int end = comment . length ( ) - lineSeparator . length ( ) ; comment = comment . substring ( 0 , end ) ; saveEntry ( ) ; status = GET_FILE ; } else if ( line . equals ( "----------------------------" ) ) { final int end = comment . length ( ) - lineSeparator . length ( ) ; comment = comment . substring ( 0 , end ) ; status = GET_PREVIOUS_REV ; } else { comment += line + lineSeparator ; } } private void processFile ( final String line ) { if ( line . startsWith ( "Working file:" ) ) { file = line . substring ( 14 , line . length ( ) ) ; status = GET_REVISION ; } } private void processRevision ( final String line ) { if ( line . startsWith ( "revision" ) ) { revision = line . substring ( 9 ) ; status = GET_DATE ; } else if ( line . startsWith ( "======" ) ) { status = GET_FILE ; } } private void processDate ( final String line ) { if ( line . startsWith ( "date:" ) ) { int endOfDateIndex = line . indexOf ( ';' ) ; date = line . substring ( "date: " . length ( ) , endOfDateIndex ) ; int startOfAuthorIndex = line . indexOf ( "author: " , endOfDateIndex + 1 ) ; int endOfAuthorIndex = line . indexOf ( ';' , startOfAuthorIndex + 1 ) ; author = line . substring ( "author: " . length ( ) + startOfAuthorIndex , endOfAuthorIndex ) ; status = GET_COMMENT ; comment = "" ; } } private void processGetPreviousRevision ( final String line ) { if ( ! line . startsWith ( "revision " ) ) { throw new IllegalStateException ( "Unexpected line from CVS: " + line ) ; } previousRevision = line . substring ( "revision " . length ( ) ) ; saveEntry ( ) ; revision = previousRevision ; status = GET_DATE ; } private void saveEntry ( ) { final String entryKey = date + author + comment ; CVSEntry entry ; if ( ! entries . containsKey ( entryKey ) ) { Date dateObject = parseDate ( date ) ; entry = new CVSEntry ( dateObject , author , comment ) ; entries . put ( entryKey , entry ) ; } else { entry = ( CVSEntry ) entries . get ( entryKey ) ; } entry . addFile ( file , revision , previousRevision ) ; } private Date parseDate ( final String date ) { try { return INPUT_DATE . parse ( date ) ; } catch ( ParseException e ) { try { return CVS1129_INPUT_DATE . parse ( date ) ; } catch ( ParseException e2 ) { throw new IllegalStateException ( "Invalid date format: " + date ) ; } } } public void reset ( ) { this . file = null ; this . date = null ; this . author = null ; this . comment = null ; this . revision = null ; this . previousRevision = null ; } } 	1	['12', '1', '0', '4', '41', '0', '3', '1', '3', '0.76969697', '381', '1', '0', '0', '0.818181818', '0', '0', '29.5', '3', '1.6667', '1']
package org . apache . tools . ant . taskdefs . cvslib ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . IOException ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . UnsupportedEncodingException ; import java . util . Vector ; import java . util . StringTokenizer ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . AbstractCvsTask ; import org . apache . tools . ant . util . DOMElementWriter ; import org . apache . tools . ant . util . DOMUtils ; import org . apache . tools . ant . util . FileUtils ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; public class CvsTagDiff extends AbstractCvsTask { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private static final DOMElementWriter DOM_WRITER = new DOMElementWriter ( ) ; static final String FILE_STRING = "File " ; static final String TO_STRING = " to " ; static final String FILE_IS_NEW = " is new;" ; static final String REVISION = "revision " ; static final String FILE_HAS_CHANGED = " changed from revision " ; static final String FILE_WAS_REMOVED = " is removed" ; private String mypackage ; private String mystartTag ; private String myendTag ; private String mystartDate ; private String myendDate ; private File mydestfile ; public void setPackage ( String p ) { mypackage = p ; } public void setStartTag ( String s ) { mystartTag = s ; } public void setStartDate ( String s ) { mystartDate = s ; } public void setEndTag ( String s ) { myendTag = s ; } public void setEndDate ( String s ) { myendDate = s ; } public void setDestFile ( File f ) { mydestfile = f ; } public void execute ( ) throws BuildException { validate ( ) ; addCommandArgument ( "rdiff" ) ; addCommandArgument ( "-s" ) ; if ( mystartTag != null ) { addCommandArgument ( "-r" ) ; addCommandArgument ( mystartTag ) ; } else { addCommandArgument ( "-D" ) ; addCommandArgument ( mystartDate ) ; } if ( myendTag != null ) { addCommandArgument ( "-r" ) ; addCommandArgument ( myendTag ) ; } else { addCommandArgument ( "-D" ) ; addCommandArgument ( myendDate ) ; } StringTokenizer myTokenizer = new StringTokenizer ( mypackage ) ; while ( myTokenizer . hasMoreTokens ( ) ) { addCommandArgument ( myTokenizer . nextToken ( ) ) ; } setCommand ( "" ) ; File tmpFile = null ; try { tmpFile = FILE_UTILS . createTempFile ( "cvstagdiff" , ".log" , null ) ; tmpFile . deleteOnExit ( ) ; setOutput ( tmpFile ) ; super . execute ( ) ; CvsTagEntry [ ] entries = parseRDiff ( tmpFile ) ; writeTagDiff ( entries ) ; } finally { if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } private CvsTagEntry [ ] parseRDiff ( File tmpFile ) throws BuildException { BufferedReader reader = null ; try { reader = new BufferedReader ( new FileReader ( tmpFile ) ) ; String toBeRemoved = FILE_STRING + mypackage + "/" ; int headerLength = toBeRemoved . length ( ) ; Vector entries = new Vector ( ) ; String line = reader . readLine ( ) ; int index ; CvsTagEntry entry = null ; while ( null != line ) { if ( line . length ( ) > headerLength ) { if ( line . startsWith ( toBeRemoved ) ) { line = line . substring ( headerLength ) ; } else { line = line . substring ( FILE_STRING . length ( ) ) ; } if ( ( index = line . indexOf ( FILE_IS_NEW ) ) != - 1 ) { String filename = line . substring ( 0 , index ) ; String rev = null ; int indexrev = - 1 ; if ( ( indexrev = line . indexOf ( REVISION , index ) ) != - 1 ) { rev = line . substring ( indexrev + REVISION . length ( ) ) ; } entry = new CvsTagEntry ( filename , rev ) ; entries . addElement ( entry ) ; log ( entry . toString ( ) , Project . MSG_VERBOSE ) ; } else if ( ( index = line . indexOf ( FILE_HAS_CHANGED ) ) != - 1 ) { String filename = line . substring ( 0 , index ) ; int revSeparator = line . indexOf ( " to " , index ) ; String prevRevision = line . substring ( index + FILE_HAS_CHANGED . length ( ) , revSeparator ) ; String revision = line . substring ( revSeparator + TO_STRING . length ( ) ) ; entry = new CvsTagEntry ( filename , revision , prevRevision ) ; entries . addElement ( entry ) ; log ( entry . toString ( ) , Project . MSG_VERBOSE ) ; } else if ( ( index = line . indexOf ( FILE_WAS_REMOVED ) ) != - 1 ) { String filename = line . substring ( 0 , index ) ; String rev = null ; int indexrev = - 1 ; if ( ( indexrev = line . indexOf ( REVISION , index ) ) != - 1 ) { rev = line . substring ( indexrev + REVISION . length ( ) ) ; } entry = new CvsTagEntry ( filename , null , rev ) ; entries . addElement ( entry ) ; log ( entry . toString ( ) , Project . MSG_VERBOSE ) ; } } line = reader . readLine ( ) ; } CvsTagEntry [ ] array = new CvsTagEntry [ entries . size ( ) ] ; entries . copyInto ( array ) ; return array ; } catch ( IOException e ) { throw new BuildException ( "Error in parsing" , e ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { log ( e . toString ( ) , Project . MSG_ERR ) ; } } } } private void writeTagDiff ( CvsTagEntry [ ] entries ) throws BuildException { FileOutputStream output = null ; try { output = new FileOutputStream ( mydestfile ) ; PrintWriter writer = new PrintWriter ( new OutputStreamWriter ( output , "UTF-8" ) ) ; writer . println ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" ) ; Document doc = DOMUtils . newDocument ( ) ; Element root = doc . createElement ( "tagdiff" ) ; if ( mystartTag != null ) { root . setAttribute ( "startTag" , mystartTag ) ; } else { root . setAttribute ( "startDate" , mystartDate ) ; } if ( myendTag != null ) { root . setAttribute ( "endTag" , myendTag ) ; } else { root . setAttribute ( "endDate" , myendDate ) ; } root . setAttribute ( "cvsroot" , getCvsRoot ( ) ) ; root . setAttribute ( "package" , mypackage ) ; DOM_WRITER . openElement ( root , writer , 0 , "\t" ) ; writer . println ( ) ; for ( int i = 0 , c = entries . length ; i < c ; i ++ ) { writeTagEntry ( doc , writer , entries [ i ] ) ; } DOM_WRITER . closeElement ( root , writer , 0 , "\t" , true ) ; writer . flush ( ) ; writer . close ( ) ; } catch ( UnsupportedEncodingException uee ) { log ( uee . toString ( ) , Project . MSG_ERR ) ; } catch ( IOException ioe ) { throw new BuildException ( ioe . toString ( ) , ioe ) ; } finally { if ( null != output ) { try { output . close ( ) ; } catch ( IOException ioe ) { log ( ioe . toString ( ) , Project . MSG_ERR ) ; } } } } private void writeTagEntry ( Document doc , PrintWriter writer , CvsTagEntry entry ) throws IOException { Element ent = doc . createElement ( "entry" ) ; Element f = DOMUtils . createChildElement ( ent , "file" ) ; DOMUtils . appendCDATAElement ( f , "name" , entry . getFile ( ) ) ; if ( entry . getRevision ( ) != null ) { DOMUtils . appendTextElement ( f , "revision" , entry . getRevision ( ) ) ; } if ( entry . getPreviousRevision ( ) != null ) { DOMUtils . appendTextElement ( f , "prevrevision" , entry . getPreviousRevision ( ) ) ; } DOM_WRITER . write ( ent , writer , 1 , "\t" ) ; } private void validate ( ) throws BuildException { if ( null == mypackage ) { throw new BuildException ( "Package/module must be set." ) ; } if ( null == mydestfile ) { throw new BuildException ( "Destfile must be set." ) ; } if ( null == mystartTag && null == mystartDate ) { throw new BuildException ( "Start tag or start date must be set." ) ; } if ( null != mystartTag && null != mystartDate ) { throw new BuildException ( "Only one of start tag and start date " + "must be set." ) ; } if ( null == myendTag && null == myendDate ) { throw new BuildException ( "End tag or end date must be set." ) ; } if ( null != myendTag && null != myendDate ) { throw new BuildException ( "Only one of end tag and end date must " + "be set." ) ; } } } 	1	['13', '4', '0', '6', '72', '22', '0', '6', '8', '0.898809524', '623', '0.571428571', '2', '0.876404494', '0.273809524', '1', '2', '45.84615385', '1', '0.8462', '1']
package org . apache . tools . bzip2 ; import java . io . OutputStream ; import java . io . IOException ; public class CBZip2OutputStream extends OutputStream implements BZip2Constants { public static final int MIN_BLOCKSIZE = 1 ; public static final int MAX_BLOCKSIZE = 9 ; protected static final int SETMASK = ( 1 << 21 ) ; protected static final int CLEARMASK = ( ~ SETMASK ) ; protected static final int GREATER_ICOST = 15 ; protected static final int LESSER_ICOST = 0 ; protected static final int SMALL_THRESH = 20 ; protected static final int DEPTH_THRESH = 10 ; protected static final int WORK_FACTOR = 30 ; protected static final int QSORT_STACK_SIZE = 1000 ; private static final int [ ] INCS = { 1 , 4 , 13 , 40 , 121 , 364 , 1093 , 3280 , 9841 , 29524 , 88573 , 265720 , 797161 , 2391484 } ; protected static void hbMakeCodeLengths ( char [ ] len , int [ ] freq , int alphaSize , int maxLen ) { final int [ ] heap = new int [ MAX_ALPHA_SIZE * 2 ] ; final int [ ] weight = new int [ MAX_ALPHA_SIZE * 2 ] ; final int [ ] parent = new int [ MAX_ALPHA_SIZE * 2 ] ; for ( int i = alphaSize ; -- i >= 0 ; ) { weight [ i + 1 ] = ( freq [ i ] == 0 ? 1 : freq [ i ] ) << 8 ; } for ( boolean tooLong = true ; tooLong ; ) { tooLong = false ; int nNodes = alphaSize ; int nHeap = 0 ; heap [ 0 ] = 0 ; weight [ 0 ] = 0 ; parent [ 0 ] = - 2 ; for ( int i = 1 ; i <= alphaSize ; i ++ ) { parent [ i ] = - 1 ; nHeap ++ ; heap [ nHeap ] = i ; int zz = nHeap ; int tmp = heap [ zz ] ; while ( weight [ tmp ] < weight [ heap [ zz > > 1 ] ] ) { heap [ zz ] = heap [ zz > > 1 ] ; zz >>= 1 ; } heap [ zz ] = tmp ; } while ( nHeap > 1 ) { int n1 = heap [ 1 ] ; heap [ 1 ] = heap [ nHeap ] ; nHeap -- ; int yy = 0 ; int zz = 1 ; int tmp = heap [ 1 ] ; while ( true ) { yy = zz << 1 ; if ( yy > nHeap ) { break ; } if ( ( yy < nHeap ) && ( weight [ heap [ yy + 1 ] ] < weight [ heap [ yy ] ] ) ) { yy ++ ; } if ( weight [ tmp ] < weight [ heap [ yy ] ] ) { break ; } heap [ zz ] = heap [ yy ] ; zz = yy ; } heap [ zz ] = tmp ; int n2 = heap [ 1 ] ; heap [ 1 ] = heap [ nHeap ] ; nHeap -- ; yy = 0 ; zz = 1 ; tmp = heap [ 1 ] ; while ( true ) { yy = zz << 1 ; if ( yy > nHeap ) { break ; } if ( ( yy < nHeap ) && ( weight [ heap [ yy + 1 ] ] < weight [ heap [ yy ] ] ) ) { yy ++ ; } if ( weight [ tmp ] < weight [ heap [ yy ] ] ) { break ; } heap [ zz ] = heap [ yy ] ; zz = yy ; } heap [ zz ] = tmp ; nNodes ++ ; parent [ n1 ] = parent [ n2 ] = nNodes ; final int weight_n1 = weight [ n1 ] ; final int weight_n2 = weight [ n2 ] ; weight [ nNodes ] = ( ( ( weight_n1 & 0xffffff00 ) + ( weight_n2 & 0xffffff00 ) ) | ( 1 + ( ( ( weight_n1 & 0x000000ff ) > ( weight_n2 & 0x000000ff ) ) ? ( weight_n1 & 0x000000ff ) : ( weight_n2 & 0x000000ff ) ) ) ) ; parent [ nNodes ] = - 1 ; nHeap ++ ; heap [ nHeap ] = nNodes ; tmp = 0 ; zz = nHeap ; tmp = heap [ zz ] ; final int weight_tmp = weight [ tmp ] ; while ( weight_tmp < weight [ heap [ zz > > 1 ] ] ) { heap [ zz ] = heap [ zz > > 1 ] ; zz >>= 1 ; } heap [ zz ] = tmp ; } for ( int i = 1 ; i <= alphaSize ; i ++ ) { int j = 0 ; int k = i ; for ( int parent_k ; ( parent_k = parent [ k ] ) >= 0 ; ) { k = parent_k ; j ++ ; } len [ i - 1 ] = ( char ) j ; if ( j > maxLen ) { tooLong = true ; } } if ( tooLong ) { for ( int i = 1 ; i < alphaSize ; i ++ ) { int j = weight [ i ] > > 8 ; j = 1 + ( j > > 1 ) ; weight [ i ] = j << 8 ; } } } } private static void hbMakeCodeLengths ( final byte [ ] len , final int [ ] freq , final Data dat , final int alphaSize , final int maxLen ) { final int [ ] heap = dat . heap ; final int [ ] weight = dat . weight ; final int [ ] parent = dat . parent ; for ( int i = alphaSize ; -- i >= 0 ; ) { weight [ i + 1 ] = ( freq [ i ] == 0 ? 1 : freq [ i ] ) << 8 ; } for ( boolean tooLong = true ; tooLong ; ) { tooLong = false ; int nNodes = alphaSize ; int nHeap = 0 ; heap [ 0 ] = 0 ; weight [ 0 ] = 0 ; parent [ 0 ] = - 2 ; for ( int i = 1 ; i <= alphaSize ; i ++ ) { parent [ i ] = - 1 ; nHeap ++ ; heap [ nHeap ] = i ; int zz = nHeap ; int tmp = heap [ zz ] ; while ( weight [ tmp ] < weight [ heap [ zz > > 1 ] ] ) { heap [ zz ] = heap [ zz > > 1 ] ; zz >>= 1 ; } heap [ zz ] = tmp ; } while ( nHeap > 1 ) { int n1 = heap [ 1 ] ; heap [ 1 ] = heap [ nHeap ] ; nHeap -- ; int yy = 0 ; int zz = 1 ; int tmp = heap [ 1 ] ; while ( true ) { yy = zz << 1 ; if ( yy > nHeap ) { break ; } if ( ( yy < nHeap ) && ( weight [ heap [ yy + 1 ] ] < weight [ heap [ yy ] ] ) ) { yy ++ ; } if ( weight [ tmp ] < weight [ heap [ yy ] ] ) { break ; } heap [ zz ] = heap [ yy ] ; zz = yy ; } heap [ zz ] = tmp ; int n2 = heap [ 1 ] ; heap [ 1 ] = heap [ nHeap ] ; nHeap -- ; yy = 0 ; zz = 1 ; tmp = heap [ 1 ] ; while ( true ) { yy = zz << 1 ; if ( yy > nHeap ) { break ; } if ( ( yy < nHeap ) && ( weight [ heap [ yy + 1 ] ] < weight [ heap [ yy ] ] ) ) { yy ++ ; } if ( weight [ tmp ] < weight [ heap [ yy ] ] ) { break ; } heap [ zz ] = heap [ yy ] ; zz = yy ; } heap [ zz ] = tmp ; nNodes ++ ; parent [ n1 ] = parent [ n2 ] = nNodes ; final int weight_n1 = weight [ n1 ] ; final int weight_n2 = weight [ n2 ] ; weight [ nNodes ] = ( ( weight_n1 & 0xffffff00 ) + ( weight_n2 & 0xffffff00 ) ) | ( 1 + ( ( ( weight_n1 & 0x000000ff ) > ( weight_n2 & 0x000000ff ) ) ? ( weight_n1 & 0x000000ff ) : ( weight_n2 & 0x000000ff ) ) ) ; parent [ nNodes ] = - 1 ; nHeap ++ ; heap [ nHeap ] = nNodes ; tmp = 0 ; zz = nHeap ; tmp = heap [ zz ] ; final int weight_tmp = weight [ tmp ] ; while ( weight_tmp < weight [ heap [ zz > > 1 ] ] ) { heap [ zz ] = heap [ zz > > 1 ] ; zz >>= 1 ; } heap [ zz ] = tmp ; } for ( int i = 1 ; i <= alphaSize ; i ++ ) { int j = 0 ; int k = i ; for ( int parent_k ; ( parent_k = parent [ k ] ) >= 0 ; ) { k = parent_k ; j ++ ; } len [ i - 1 ] = ( byte ) j ; if ( j > maxLen ) { tooLong = true ; } } if ( tooLong ) { for ( int i = 1 ; i < alphaSize ; i ++ ) { int j = weight [ i ] > > 8 ; j = 1 + ( j > > 1 ) ; weight [ i ] = j << 8 ; } } } } private int last ; private int origPtr ; private final int blockSize100k ; private boolean blockRandomised ; private int bsBuff ; private int bsLive ; private final CRC crc = new CRC ( ) ; private int nInUse ; private int nMTF ; private int workDone ; private int workLimit ; private boolean firstAttempt ; private int currentChar = - 1 ; private int runLength = 0 ; private int blockCRC ; private int combinedCRC ; private int allowableBlockSize ; private CBZip2OutputStream . Data data ; private OutputStream out ; public static int chooseBlockSize ( long inputLength ) { return ( inputLength > 0 ) ? ( int ) Math . min ( ( inputLength / 132000 ) + 1 , 9 ) : MAX_BLOCKSIZE ; } public CBZip2OutputStream ( final OutputStream out ) throws IOException { this ( out , MAX_BLOCKSIZE ) ; } public CBZip2OutputStream ( final OutputStream out , final int blockSize ) throws IOException { super ( ) ; if ( blockSize < 1 ) { throw new IllegalArgumentException ( "blockSize(" + blockSize + ") < 1" ) ; } if ( blockSize > 9 ) { throw new IllegalArgumentException ( "blockSize(" + blockSize + ") > 9" ) ; } this . blockSize100k = blockSize ; this . out = out ; init ( ) ; } public void write ( final int b ) throws IOException { if ( this . out != null ) { write0 ( b ) ; } else { throw new IOException ( "closed" ) ; } } private void writeRun ( ) throws IOException { final int lastShadow = this . last ; if ( lastShadow < this . allowableBlockSize ) { final int currentCharShadow = this . currentChar ; final Data dataShadow = this . data ; dataShadow . inUse [ currentCharShadow ] = true ; final byte ch = ( byte ) currentCharShadow ; int runLengthShadow = this . runLength ; this . crc . updateCRC ( currentCharShadow , runLengthShadow ) ; switch ( runLengthShadow ) { case 1 : dataShadow . block [ lastShadow + 2 ] = ch ; this . last = lastShadow + 1 ; break ; case 2 : dataShadow . block [ lastShadow + 2 ] = ch ; dataShadow . block [ lastShadow + 3 ] = ch ; this . last = lastShadow + 2 ; break ; case 3 : { final byte [ ] block = dataShadow . block ; block [ lastShadow + 2 ] = ch ; block [ lastShadow + 3 ] = ch ; block [ lastShadow + 4 ] = ch ; this . last = lastShadow + 3 ; } break ; default : { runLengthShadow -= 4 ; dataShadow . inUse [ runLengthShadow ] = true ; final byte [ ] block = dataShadow . block ; block [ lastShadow + 2 ] = ch ; block [ lastShadow + 3 ] = ch ; block [ lastShadow + 4 ] = ch ; block [ lastShadow + 5 ] = ch ; block [ lastShadow + 6 ] = ( byte ) runLengthShadow ; this . last = lastShadow + 5 ; } break ; } } else { endBlock ( ) ; initBlock ( ) ; writeRun ( ) ; } } protected void finalize ( ) throws Throwable { close ( ) ; super . finalize ( ) ; } public void close ( ) throws IOException { OutputStream outShadow = this . out ; if ( outShadow != null ) { try { if ( this . runLength > 0 ) { writeRun ( ) ; } this . currentChar = - 1 ; endBlock ( ) ; endCompression ( ) ; outShadow . close ( ) ; } finally { this . out = null ; this . data = null ; } } } public void flush ( ) throws IOException { OutputStream outShadow = this . out ; if ( outShadow != null ) { outShadow . flush ( ) ; } } private void init ( ) throws IOException { this . data = new Data ( this . blockSize100k ) ; bsPutUByte ( 'h' ) ; bsPutUByte ( '0' + this . blockSize100k ) ; this . combinedCRC = 0 ; initBlock ( ) ; } private void initBlock ( ) { this . crc . initialiseCRC ( ) ; this . last = - 1 ; boolean [ ] inUse = this . data . inUse ; for ( int i = 256 ; -- i >= 0 ; ) { inUse [ i ] = false ; } this . allowableBlockSize = ( this . blockSize100k * BZip2Constants . baseBlockSize ) - 20 ; } private void endBlock ( ) throws IOException { this . blockCRC = this . crc . getFinalCRC ( ) ; this . combinedCRC = ( this . combinedCRC << 1 ) | ( this . combinedCRC > > > 31 ) ; this . combinedCRC ^= this . blockCRC ; if ( this . last == - 1 ) { return ; } blockSort ( ) ; bsPutUByte ( 0x31 ) ; bsPutUByte ( 0x41 ) ; bsPutUByte ( 0x59 ) ; bsPutUByte ( 0x26 ) ; bsPutUByte ( 0x53 ) ; bsPutUByte ( 0x59 ) ; bsPutInt ( this . blockCRC ) ; if ( this . blockRandomised ) { bsW ( 1 , 1 ) ; } else { bsW ( 1 , 0 ) ; } moveToFrontCodeAndSend ( ) ; } private void endCompression ( ) throws IOException { bsPutUByte ( 0x17 ) ; bsPutUByte ( 0x72 ) ; bsPutUByte ( 0x45 ) ; bsPutUByte ( 0x38 ) ; bsPutUByte ( 0x50 ) ; bsPutUByte ( 0x90 ) ; bsPutInt ( this . combinedCRC ) ; bsFinishedWithStream ( ) ; } public final int getBlockSize ( ) { return this . blockSize100k ; } public void write ( final byte [ ] buf , int offs , final int len ) throws IOException { if ( offs < 0 ) { throw new IndexOutOfBoundsException ( "offs(" + offs + ") < 0." ) ; } if ( len < 0 ) { throw new IndexOutOfBoundsException ( "len(" + len + ") < 0." ) ; } if ( offs + len > buf . length ) { throw new IndexOutOfBoundsException ( "offs(" + offs + ") + len(" + len + ") > buf.length(" + buf . length + ")." ) ; } if ( this . out == null ) { throw new IOException ( "stream closed" ) ; } for ( int hi = offs + len ; offs < hi ; ) { write0 ( buf [ offs ++ ] ) ; } } private void write0 ( int b ) throws IOException { if ( this . currentChar != - 1 ) { b &= 0xff ; if ( this . currentChar == b ) { if ( ++ this . runLength > 254 ) { writeRun ( ) ; this . currentChar = - 1 ; this . runLength = 0 ; } } else { writeRun ( ) ; this . runLength = 1 ; this . currentChar = b ; } } else { this . currentChar = b & 0xff ; this . runLength ++ ; } } private static void hbAssignCodes ( final int [ ] code , final byte [ ] length , final int minLen , final int maxLen , final int alphaSize ) { int vec = 0 ; for ( int n = minLen ; n <= maxLen ; n ++ ) { for ( int i = 0 ; i < alphaSize ; i ++ ) { if ( ( length [ i ] & 0xff ) == n ) { code [ i ] = vec ; vec ++ ; } } vec <<= 1 ; } } private void bsFinishedWithStream ( ) throws IOException { while ( this . bsLive > 0 ) { int ch = this . bsBuff > > 24 ; this . out . write ( ch ) ; this . bsBuff <<= 8 ; this . bsLive -= 8 ; } } private void bsW ( final int n , final int v ) throws IOException { final OutputStream outShadow = this . out ; int bsLiveShadow = this . bsLive ; int bsBuffShadow = this . bsBuff ; while ( bsLiveShadow >= 8 ) { outShadow . write ( bsBuffShadow > > 24 ) ; bsBuffShadow <<= 8 ; bsLiveShadow -= 8 ; } this . bsBuff = bsBuffShadow | ( v << ( 32 - bsLiveShadow - n ) ) ; this . bsLive = bsLiveShadow + n ; } private void bsPutUByte ( final int c ) throws IOException { bsW ( 8 , c ) ; } private void bsPutInt ( final int u ) throws IOException { bsW ( 8 , ( u > > 24 ) & 0xff ) ; bsW ( 8 , ( u > > 16 ) & 0xff ) ; bsW ( 8 , ( u > > 8 ) & 0xff ) ; bsW ( 8 , u & 0xff ) ; } private void sendMTFValues ( ) throws IOException { final byte [ ] [ ] len = this . data . sendMTFValues_len ; final int alphaSize = this . nInUse + 2 ; for ( int t = N_GROUPS ; -- t >= 0 ; ) { byte [ ] len_t = len [ t ] ; for ( int v = alphaSize ; -- v >= 0 ; ) { len_t [ v ] = GREATER_ICOST ; } } final int nGroups = ( this . nMTF < 200 ) ? 2 : ( this . nMTF < 600 ) ? 3 : ( this . nMTF < 1200 ) ? 4 : ( this . nMTF < 2400 ) ? 5 : 6 ; sendMTFValues0 ( nGroups , alphaSize ) ; final int nSelectors = sendMTFValues1 ( nGroups , alphaSize ) ; sendMTFValues2 ( nGroups , nSelectors ) ; sendMTFValues3 ( nGroups , alphaSize ) ; sendMTFValues4 ( ) ; sendMTFValues5 ( nGroups , nSelectors ) ; sendMTFValues6 ( nGroups , alphaSize ) ; sendMTFValues7 ( nSelectors ) ; } private void sendMTFValues0 ( final int nGroups , final int alphaSize ) { final byte [ ] [ ] len = this . data . sendMTFValues_len ; final int [ ] mtfFreq = this . data . mtfFreq ; int remF = this . nMTF ; int gs = 0 ; for ( int nPart = nGroups ; nPart > 0 ; nPart -- ) { final int tFreq = remF / nPart ; int ge = gs - 1 ; int aFreq = 0 ; for ( final int a = alphaSize - 1 ; ( aFreq < tFreq ) && ( ge < a ) ; ) { aFreq += mtfFreq [ ++ ge ] ; } if ( ( ge > gs ) && ( nPart != nGroups ) && ( nPart != 1 ) && ( ( ( nGroups - nPart ) & 1 ) != 0 ) ) { aFreq -= mtfFreq [ ge -- ] ; } final byte [ ] len_np = len [ nPart - 1 ] ; for ( int v = alphaSize ; -- v >= 0 ; ) { if ( ( v >= gs ) && ( v <= ge ) ) { len_np [ v ] = LESSER_ICOST ; } else { len_np [ v ] = GREATER_ICOST ; } } gs = ge + 1 ; remF -= aFreq ; } } private int sendMTFValues1 ( final int nGroups , final int alphaSize ) { final Data dataShadow = this . data ; final int [ ] [ ] rfreq = dataShadow . sendMTFValues_rfreq ; final int [ ] fave = dataShadow . sendMTFValues_fave ; final short [ ] cost = dataShadow . sendMTFValues_cost ; final char [ ] sfmap = dataShadow . sfmap ; final byte [ ] selector = dataShadow . selector ; final byte [ ] [ ] len = dataShadow . sendMTFValues_len ; final byte [ ] len_0 = len [ 0 ] ; final byte [ ] len_1 = len [ 1 ] ; final byte [ ] len_2 = len [ 2 ] ; final byte [ ] len_3 = len [ 3 ] ; final byte [ ] len_4 = len [ 4 ] ; final byte [ ] len_5 = len [ 5 ] ; final int nMTFShadow = this . nMTF ; int nSelectors = 0 ; for ( int iter = 0 ; iter < N_ITERS ; iter ++ ) { for ( int t = nGroups ; -- t >= 0 ; ) { fave [ t ] = 0 ; int [ ] rfreqt = rfreq [ t ] ; for ( int i = alphaSize ; -- i >= 0 ; ) { rfreqt [ i ] = 0 ; } } nSelectors = 0 ; for ( int gs = 0 ; gs < this . nMTF ; ) { final int ge = Math . min ( gs + G_SIZE - 1 , nMTFShadow - 1 ) ; if ( nGroups == N_GROUPS ) { short cost0 = 0 ; short cost1 = 0 ; short cost2 = 0 ; short cost3 = 0 ; short cost4 = 0 ; short cost5 = 0 ; for ( int i = gs ; i <= ge ; i ++ ) { final int icv = sfmap [ i ] ; cost0 += len_0 [ icv ] & 0xff ; cost1 += len_1 [ icv ] & 0xff ; cost2 += len_2 [ icv ] & 0xff ; cost3 += len_3 [ icv ] & 0xff ; cost4 += len_4 [ icv ] & 0xff ; cost5 += len_5 [ icv ] & 0xff ; } cost [ 0 ] = cost0 ; cost [ 1 ] = cost1 ; cost [ 2 ] = cost2 ; cost [ 3 ] = cost3 ; cost [ 4 ] = cost4 ; cost [ 5 ] = cost5 ; } else { for ( int t = nGroups ; -- t >= 0 ; ) { cost [ t ] = 0 ; } for ( int i = gs ; i <= ge ; i ++ ) { final int icv = sfmap [ i ] ; for ( int t = nGroups ; -- t >= 0 ; ) { cost [ t ] += len [ t ] [ icv ] & 0xff ; } } } int bt = - 1 ; for ( int t = nGroups , bc = 999999999 ; -- t >= 0 ; ) { final int cost_t = cost [ t ] ; if ( cost_t < bc ) { bc = cost_t ; bt = t ; } } fave [ bt ] ++ ; selector [ nSelectors ] = ( byte ) bt ; nSelectors ++ ; final int [ ] rfreq_bt = rfreq [ bt ] ; for ( int i = gs ; i <= ge ; i ++ ) { rfreq_bt [ sfmap [ i ] ] ++ ; } gs = ge + 1 ; } for ( int t = 0 ; t < nGroups ; t ++ ) { hbMakeCodeLengths ( len [ t ] , rfreq [ t ] , this . data , alphaSize , 20 ) ; } } return nSelectors ; } private void sendMTFValues2 ( final int nGroups , final int nSelectors ) { final Data dataShadow = this . data ; byte [ ] pos = dataShadow . sendMTFValues2_pos ; for ( int i = nGroups ; -- i >= 0 ; ) { pos [ i ] = ( byte ) i ; } for ( int i = 0 ; i < nSelectors ; i ++ ) { final byte ll_i = dataShadow . selector [ i ] ; byte tmp = pos [ 0 ] ; int j = 0 ; while ( ll_i != tmp ) { j ++ ; byte tmp2 = tmp ; tmp = pos [ j ] ; pos [ j ] = tmp2 ; } pos [ 0 ] = tmp ; dataShadow . selectorMtf [ i ] = ( byte ) j ; } } private void sendMTFValues3 ( final int nGroups , final int alphaSize ) { int [ ] [ ] code = this . data . sendMTFValues_code ; byte [ ] [ ] len = this . data . sendMTFValues_len ; for ( int t = 0 ; t < nGroups ; t ++ ) { int minLen = 32 ; int maxLen = 0 ; final byte [ ] len_t = len [ t ] ; for ( int i = alphaSize ; -- i >= 0 ; ) { final int l = len_t [ i ] & 0xff ; if ( l > maxLen ) { maxLen = l ; } if ( l < minLen ) { minLen = l ; } } hbAssignCodes ( code [ t ] , len [ t ] , minLen , maxLen , alphaSize ) ; } } private void sendMTFValues4 ( ) throws IOException { final boolean [ ] inUse = this . data . inUse ; final boolean [ ] inUse16 = this . data . sentMTFValues4_inUse16 ; for ( int i = 16 ; -- i >= 0 ; ) { inUse16 [ i ] = false ; final int i16 = i * 16 ; for ( int j = 16 ; -- j >= 0 ; ) { if ( inUse [ i16 + j ] ) { inUse16 [ i ] = true ; } } } for ( int i = 0 ; i < 16 ; i ++ ) { bsW ( 1 , inUse16 [ i ] ? 1 : 0 ) ; } final OutputStream outShadow = this . out ; int bsLiveShadow = this . bsLive ; int bsBuffShadow = this . bsBuff ; for ( int i = 0 ; i < 16 ; i ++ ) { if ( inUse16 [ i ] ) { final int i16 = i * 16 ; for ( int j = 0 ; j < 16 ; j ++ ) { while ( bsLiveShadow >= 8 ) { outShadow . write ( bsBuffShadow > > 24 ) ; bsBuffShadow <<= 8 ; bsLiveShadow -= 8 ; } if ( inUse [ i16 + j ] ) { bsBuffShadow |= 1 << ( 32 - bsLiveShadow - 1 ) ; } bsLiveShadow ++ ; } } } this . bsBuff = bsBuffShadow ; this . bsLive = bsLiveShadow ; } private void sendMTFValues5 ( final int nGroups , final int nSelectors ) throws IOException { bsW ( 3 , nGroups ) ; bsW ( 15 , nSelectors ) ; final OutputStream outShadow = this . out ; final byte [ ] selectorMtf = this . data . selectorMtf ; int bsLiveShadow = this . bsLive ; int bsBuffShadow = this . bsBuff ; for ( int i = 0 ; i < nSelectors ; i ++ ) { for ( int j = 0 , hj = selectorMtf [ i ] & 0xff ; j < hj ; j ++ ) { while ( bsLiveShadow >= 8 ) { outShadow . write ( bsBuffShadow > > 24 ) ; bsBuffShadow <<= 8 ; bsLiveShadow -= 8 ; } bsBuffShadow |= 1 << ( 32 - bsLiveShadow - 1 ) ; bsLiveShadow ++ ; } while ( bsLiveShadow >= 8 ) { outShadow . write ( bsBuffShadow > > 24 ) ; bsBuffShadow <<= 8 ; bsLiveShadow -= 8 ; } bsLiveShadow ++ ; } this . bsBuff = bsBuffShadow ; this . bsLive = bsLiveShadow ; } private void sendMTFValues6 ( final int nGroups , final int alphaSize ) throws IOException { final byte [ ] [ ] len = this . data . sendMTFValues_len ; final OutputStream outShadow = this . out ; int bsLiveShadow = this . bsLive ; int bsBuffShadow = this . bsBuff ; for ( int t = 0 ; t < nGroups ; t ++ ) { byte [ ] len_t = len [ t ] ; int curr = len_t [ 0 ] & 0xff ; while ( bsLiveShadow >= 8 ) { outShadow . write ( bsBuffShadow > > 24 ) ; bsBuffShadow <<= 8 ; bsLiveShadow -= 8 ; } bsBuffShadow |= curr << ( 32 - bsLiveShadow - 5 ) ; bsLiveShadow += 5 ; for ( int i = 0 ; i < alphaSize ; i ++ ) { int lti = len_t [ i ] & 0xff ; while ( curr < lti ) { while ( bsLiveShadow >= 8 ) { outShadow . write ( bsBuffShadow > > 24 ) ; bsBuffShadow <<= 8 ; bsLiveShadow -= 8 ; } bsBuffShadow |= 2 << ( 32 - bsLiveShadow - 2 ) ; bsLiveShadow += 2 ; curr ++ ; } while ( curr > lti ) { while ( bsLiveShadow >= 8 ) { outShadow . write ( bsBuffShadow > > 24 ) ; bsBuffShadow <<= 8 ; bsLiveShadow -= 8 ; } bsBuffShadow |= 3 << ( 32 - bsLiveShadow - 2 ) ; bsLiveShadow += 2 ; curr -- ; } while ( bsLiveShadow >= 8 ) { outShadow . write ( bsBuffShadow > > 24 ) ; bsBuffShadow <<= 8 ; bsLiveShadow -= 8 ; } bsLiveShadow ++ ; } } this . bsBuff = bsBuffShadow ; this . bsLive = bsLiveShadow ; } private void sendMTFValues7 ( final int nSelectors ) throws IOException { final Data dataShadow = this . data ; final byte [ ] [ ] len = dataShadow . sendMTFValues_len ; final int [ ] [ ] code = dataShadow . sendMTFValues_code ; final OutputStream outShadow = this . out ; final byte [ ] selector = dataShadow . selector ; final char [ ] sfmap = dataShadow . sfmap ; final int nMTFShadow = this . nMTF ; int selCtr = 0 ; int bsLiveShadow = this . bsLive ; int bsBuffShadow = this . bsBuff ; for ( int gs = 0 ; gs < nMTFShadow ; ) { final int ge = Math . min ( gs + G_SIZE - 1 , nMTFShadow - 1 ) ; final int selector_selCtr = selector [ selCtr ] & 0xff ; final int [ ] code_selCtr = code [ selector_selCtr ] ; final byte [ ] len_selCtr = len [ selector_selCtr ] ; while ( gs <= ge ) { final int sfmap_i = sfmap [ gs ] ; while ( bsLiveShadow >= 8 ) { outShadow . write ( bsBuffShadow > > 24 ) ; bsBuffShadow <<= 8 ; bsLiveShadow -= 8 ; } final int n = len_selCtr [ sfmap_i ] & 0xFF ; bsBuffShadow |= code_selCtr [ sfmap_i ] << ( 32 - bsLiveShadow - n ) ; bsLiveShadow += n ; gs ++ ; } gs = ge + 1 ; selCtr ++ ; } this . bsBuff = bsBuffShadow ; this . bsLive = bsLiveShadow ; } private void moveToFrontCodeAndSend ( ) throws IOException { bsW ( 24 , this . origPtr ) ; generateMTFValues ( ) ; sendMTFValues ( ) ; } private boolean mainSimpleSort ( final Data dataShadow , final int lo , final int hi , final int d ) { final int bigN = hi - lo + 1 ; if ( bigN < 2 ) { return this . firstAttempt && ( this . workDone > this . workLimit ) ; } int hp = 0 ; while ( INCS [ hp ] < bigN ) { hp ++ ; } final int [ ] fmap = dataShadow . fmap ; final char [ ] quadrant = dataShadow . quadrant ; final byte [ ] block = dataShadow . block ; final int lastShadow = this . last ; final int lastPlus1 = lastShadow + 1 ; final boolean firstAttemptShadow = this . firstAttempt ; final int workLimitShadow = this . workLimit ; int workDoneShadow = this . workDone ; HP : while ( -- hp >= 0 ) { final int h = INCS [ hp ] ; final int mj = lo + h - 1 ; for ( int i = lo + h ; i <= hi ; ) { for ( int k = 3 ; ( i <= hi ) && ( -- k >= 0 ) ; i ++ ) { final int v = fmap [ i ] ; final int vd = v + d ; int j = i ; boolean onceRunned = false ; int a = 0 ; HAMMER : while ( true ) { if ( onceRunned ) { fmap [ j ] = a ; if ( ( j -= h ) <= mj ) { break HAMMER ; } } else { onceRunned = true ; } a = fmap [ j - h ] ; int i1 = a + d ; int i2 = vd ; if ( block [ i1 + 1 ] == block [ i2 + 1 ] ) { if ( block [ i1 + 2 ] == block [ i2 + 2 ] ) { if ( block [ i1 + 3 ] == block [ i2 + 3 ] ) { if ( block [ i1 + 4 ] == block [ i2 + 4 ] ) { if ( block [ i1 + 5 ] == block [ i2 + 5 ] ) { if ( block [ ( i1 += 6 ) ] == block [ ( i2 += 6 ) ] ) { int x = lastShadow ; X : while ( x > 0 ) { x -= 4 ; if ( block [ i1 + 1 ] == block [ i2 + 1 ] ) { if ( quadrant [ i1 ] == quadrant [ i2 ] ) { if ( block [ i1 + 2 ] == block [ i2 + 2 ] ) { if ( quadrant [ i1 + 1 ] == quadrant [ i2 + 1 ] ) { if ( block [ i1 + 3 ] == block [ i2 + 3 ] ) { if ( quadrant [ i1 + 2 ] == quadrant [ i2 + 2 ] ) { if ( block [ i1 + 4 ] == block [ i2 + 4 ] ) { if ( quadrant [ i1 + 3 ] == quadrant [ i2 + 3 ] ) { if ( ( i1 += 4 ) >= lastPlus1 ) { i1 -= lastPlus1 ; } if ( ( i2 += 4 ) >= lastPlus1 ) { i2 -= lastPlus1 ; } workDoneShadow ++ ; continue X ; } else if ( ( quadrant [ i1 + 3 ] > quadrant [ i2 + 3 ] ) ) { continue HAMMER ; } else { break HAMMER ; } } else if ( ( block [ i1 + 4 ] & 0xff ) > ( block [ i2 + 4 ] & 0xff ) ) { continue HAMMER ; } else { break HAMMER ; } } else if ( ( quadrant [ i1 + 2 ] > quadrant [ i2 + 2 ] ) ) { continue HAMMER ; } else { break HAMMER ; } } else if ( ( block [ i1 + 3 ] & 0xff ) > ( block [ i2 + 3 ] & 0xff ) ) { continue HAMMER ; } else { break HAMMER ; } } else if ( ( quadrant [ i1 + 1 ] > quadrant [ i2 + 1 ] ) ) { continue HAMMER ; } else { break HAMMER ; } } else if ( ( block [ i1 + 2 ] & 0xff ) > ( block [ i2 + 2 ] & 0xff ) ) { continue HAMMER ; } else { break HAMMER ; } } else if ( ( quadrant [ i1 ] > quadrant [ i2 ] ) ) { continue HAMMER ; } else { break HAMMER ; } } else if ( ( block [ i1 + 1 ] & 0xff ) > ( block [ i2 + 1 ] & 0xff ) ) { continue HAMMER ; } else { break HAMMER ; } } break HAMMER ; } else { if ( ( block [ i1 ] & 0xff ) > ( block [ i2 ] & 0xff ) ) { continue HAMMER ; } else { break HAMMER ; } } } else if ( ( block [ i1 + 5 ] & 0xff ) > ( block [ i2 + 5 ] & 0xff ) ) { continue HAMMER ; } else { break HAMMER ; } } else if ( ( block [ i1 + 4 ] & 0xff ) > ( block [ i2 + 4 ] & 0xff ) ) { continue HAMMER ; } else { break HAMMER ; } } else if ( ( block [ i1 + 3 ] & 0xff ) > ( block [ i2 + 3 ] & 0xff ) ) { continue HAMMER ; } else { break HAMMER ; } } else if ( ( block [ i1 + 2 ] & 0xff ) > ( block [ i2 + 2 ] & 0xff ) ) { continue HAMMER ; } else { break HAMMER ; } } else if ( ( block [ i1 + 1 ] & 0xff ) > ( block [ i2 + 1 ] & 0xff ) ) { continue HAMMER ; } else { break HAMMER ; } } fmap [ j ] = v ; } if ( firstAttemptShadow && ( i <= hi ) && ( workDoneShadow > workLimitShadow ) ) { break HP ; } } } this . workDone = workDoneShadow ; return firstAttemptShadow && ( workDoneShadow > workLimitShadow ) ; } private static void vswap ( int [ ] fmap , int p1 , int p2 , int n ) { n += p1 ; while ( p1 < n ) { int t = fmap [ p1 ] ; fmap [ p1 ++ ] = fmap [ p2 ] ; fmap [ p2 ++ ] = t ; } } private static byte med3 ( byte a , byte b , byte c ) { return ( a < b ) ? ( b < c ? b : a < c ? c : a ) : ( b > c ? b : a > c ? c : a ) ; } private void blockSort ( ) { this . workLimit = WORK_FACTOR * this . last ; this . workDone = 0 ; this . blockRandomised = false ; this . firstAttempt = true ; mainSort ( ) ; if ( this . firstAttempt && ( this . workDone > this . workLimit ) ) { randomiseBlock ( ) ; this . workLimit = this . workDone = 0 ; this . firstAttempt = false ; mainSort ( ) ; } int [ ] fmap = this . data . fmap ; this . origPtr = - 1 ; for ( int i = 0 , lastShadow = this . last ; i <= lastShadow ; i ++ ) { if ( fmap [ i ] == 0 ) { this . origPtr = i ; break ; } } } private void mainQSort3 ( final Data dataShadow , final int loSt , final int hiSt , final int dSt ) { final int [ ] stack_ll = dataShadow . stack_ll ; final int [ ] stack_hh = dataShadow . stack_hh ; final int [ ] stack_dd = dataShadow . stack_dd ; final int [ ] fmap = dataShadow . fmap ; final byte [ ] block = dataShadow . block ; stack_ll [ 0 ] = loSt ; stack_hh [ 0 ] = hiSt ; stack_dd [ 0 ] = dSt ; for ( int sp = 1 ; -- sp >= 0 ; ) { final int lo = stack_ll [ sp ] ; final int hi = stack_hh [ sp ] ; final int d = stack_dd [ sp ] ; if ( ( hi - lo < SMALL_THRESH ) || ( d > DEPTH_THRESH ) ) { if ( mainSimpleSort ( dataShadow , lo , hi , d ) ) { return ; } } else { final int d1 = d + 1 ; final int med = med3 ( block [ fmap [ lo ] + d1 ] , block [ fmap [ hi ] + d1 ] , block [ fmap [ ( lo + hi ) > > 1 ] + d1 ] ) & 0xff ; int unLo = lo ; int unHi = hi ; int ltLo = lo ; int gtHi = hi ; while ( true ) { while ( unLo <= unHi ) { final int n = ( ( int ) block [ fmap [ unLo ] + d1 ] & 0xff ) - med ; if ( n == 0 ) { final int temp = fmap [ unLo ] ; fmap [ unLo ++ ] = fmap [ ltLo ] ; fmap [ ltLo ++ ] = temp ; } else if ( n < 0 ) { unLo ++ ; } else { break ; } } while ( unLo <= unHi ) { final int n = ( ( int ) block [ fmap [ unHi ] + d1 ] & 0xff ) - med ; if ( n == 0 ) { final int temp = fmap [ unHi ] ; fmap [ unHi -- ] = fmap [ gtHi ] ; fmap [ gtHi -- ] = temp ; } else if ( n > 0 ) { unHi -- ; } else { break ; } } if ( unLo <= unHi ) { final int temp = fmap [ unLo ] ; fmap [ unLo ++ ] = fmap [ unHi ] ; fmap [ unHi -- ] = temp ; } else { break ; } } if ( gtHi < ltLo ) { stack_ll [ sp ] = lo ; stack_hh [ sp ] = hi ; stack_dd [ sp ] = d1 ; sp ++ ; } else { int n = ( ( ltLo - lo ) < ( unLo - ltLo ) ) ? ( ltLo - lo ) : ( unLo - ltLo ) ; vswap ( fmap , lo , unLo - n , n ) ; int m = ( ( hi - gtHi ) < ( gtHi - unHi ) ) ? ( hi - gtHi ) : ( gtHi - unHi ) ; vswap ( fmap , unLo , hi - m + 1 , m ) ; n = lo + unLo - ltLo - 1 ; m = hi - ( gtHi - unHi ) + 1 ; stack_ll [ sp ] = lo ; stack_hh [ sp ] = n ; stack_dd [ sp ] = d ; sp ++ ; stack_ll [ sp ] = n + 1 ; stack_hh [ sp ] = m - 1 ; stack_dd [ sp ] = d1 ; sp ++ ; stack_ll [ sp ] = m ; stack_hh [ sp ] = hi ; stack_dd [ sp ] = d ; sp ++ ; } } } } private void mainSort ( ) { final Data dataShadow = this . data ; final int [ ] runningOrder = dataShadow . mainSort_runningOrder ; final int [ ] copy = dataShadow . mainSort_copy ; final boolean [ ] bigDone = dataShadow . mainSort_bigDone ; final int [ ] ftab = dataShadow . ftab ; final byte [ ] block = dataShadow . block ; final int [ ] fmap = dataShadow . fmap ; final char [ ] quadrant = dataShadow . quadrant ; final int lastShadow = this . last ; final int workLimitShadow = this . workLimit ; final boolean firstAttemptShadow = this . firstAttempt ; for ( int i = 65537 ; -- i >= 0 ; ) { ftab [ i ] = 0 ; } for ( int i = 0 ; i < NUM_OVERSHOOT_BYTES ; i ++ ) { block [ lastShadow + i + 2 ] = block [ ( i % ( lastShadow + 1 ) ) + 1 ] ; } for ( int i = lastShadow + NUM_OVERSHOOT_BYTES ; -- i >= 0 ; ) { quadrant [ i ] = 0 ; } block [ 0 ] = block [ lastShadow + 1 ] ; int c1 = block [ 0 ] & 0xff ; for ( int i = 0 ; i <= lastShadow ; i ++ ) { final int c2 = block [ i + 1 ] & 0xff ; ftab [ ( c1 << 8 ) + c2 ] ++ ; c1 = c2 ; } for ( int i = 1 ; i <= 65536 ; i ++ ) ftab [ i ] += ftab [ i - 1 ] ; c1 = block [ 1 ] & 0xff ; for ( int i = 0 ; i < lastShadow ; i ++ ) { final int c2 = block [ i + 2 ] & 0xff ; fmap [ -- ftab [ ( c1 << 8 ) + c2 ] ] = i ; c1 = c2 ; } fmap [ -- ftab [ ( ( block [ lastShadow + 1 ] & 0xff ) << 8 ) + ( block [ 1 ] & 0xff ) ] ] = lastShadow ; for ( int i = 256 ; -- i >= 0 ; ) { bigDone [ i ] = false ; runningOrder [ i ] = i ; } for ( int h = 364 ; h != 1 ; ) { h /= 3 ; for ( int i = h ; i <= 255 ; i ++ ) { final int vv = runningOrder [ i ] ; final int a = ftab [ ( vv + 1 ) << 8 ] - ftab [ vv << 8 ] ; final int b = h - 1 ; int j = i ; for ( int ro = runningOrder [ j - h ] ; ( ftab [ ( ro + 1 ) << 8 ] - ftab [ ro << 8 ] ) > a ; ro = runningOrder [ j - h ] ) { runningOrder [ j ] = ro ; j -= h ; if ( j <= b ) { break ; } } runningOrder [ j ] = vv ; } } for ( int i = 0 ; i <= 255 ; i ++ ) { final int ss = runningOrder [ i ] ; for ( int j = 0 ; j <= 255 ; j ++ ) { final int sb = ( ss << 8 ) + j ; final int ftab_sb = ftab [ sb ] ; if ( ( ftab_sb & SETMASK ) != SETMASK ) { final int lo = ftab_sb & CLEARMASK ; final int hi = ( ftab [ sb + 1 ] & CLEARMASK ) - 1 ; if ( hi > lo ) { mainQSort3 ( dataShadow , lo , hi , 2 ) ; if ( firstAttemptShadow && ( this . workDone > workLimitShadow ) ) { return ; } } ftab [ sb ] = ftab_sb | SETMASK ; } } for ( int j = 0 ; j <= 255 ; j ++ ) { copy [ j ] = ftab [ ( j << 8 ) + ss ] & CLEARMASK ; } for ( int j = ftab [ ss << 8 ] & CLEARMASK , hj = ( ftab [ ( ss + 1 ) << 8 ] & CLEARMASK ) ; j < hj ; j ++ ) { final int fmap_j = fmap [ j ] ; c1 = block [ fmap_j ] & 0xff ; if ( ! bigDone [ c1 ] ) { fmap [ copy [ c1 ] ] = ( fmap_j == 0 ) ? lastShadow : ( fmap_j - 1 ) ; copy [ c1 ] ++ ; } } for ( int j = 256 ; -- j >= 0 ; ) ftab [ ( j << 8 ) + ss ] |= SETMASK ; bigDone [ ss ] = true ; if ( i < 255 ) { final int bbStart = ftab [ ss << 8 ] & CLEARMASK ; final int bbSize = ( ftab [ ( ss + 1 ) << 8 ] & CLEARMASK ) - bbStart ; int shifts = 0 ; while ( ( bbSize > > shifts ) > 65534 ) { shifts ++ ; } for ( int j = 0 ; j < bbSize ; j ++ ) { final int a2update = fmap [ bbStart + j ] ; final char qVal = ( char ) ( j > > shifts ) ; quadrant [ a2update ] = qVal ; if ( a2update < NUM_OVERSHOOT_BYTES ) { quadrant [ a2update + lastShadow + 1 ] = qVal ; } } } } } private void randomiseBlock ( ) { final boolean [ ] inUse = this . data . inUse ; final byte [ ] block = this . data . block ; final int lastShadow = this . last ; for ( int i = 256 ; -- i >= 0 ; ) inUse [ i ] = false ; int rNToGo = 0 ; int rTPos = 0 ; for ( int i = 0 , j = 1 ; i <= lastShadow ; i = j , j ++ ) { if ( rNToGo == 0 ) { rNToGo = ( char ) BZip2Constants . rNums [ rTPos ] ; if ( ++ rTPos == 512 ) { rTPos = 0 ; } } rNToGo -- ; block [ j ] ^= ( ( rNToGo == 1 ) ? 1 : 0 ) ; inUse [ block [ j ] & 0xff ] = true ; } this . blockRandomised = true ; } private void generateMTFValues ( ) { final int lastShadow = this . last ; final Data dataShadow = this . data ; final boolean [ ] inUse = dataShadow . inUse ; final byte [ ] block = dataShadow . block ; final int [ ] fmap = dataShadow . fmap ; final char [ ] sfmap = dataShadow . sfmap ; final int [ ] mtfFreq = dataShadow . mtfFreq ; final byte [ ] unseqToSeq = dataShadow . unseqToSeq ; final byte [ ] yy = dataShadow . generateMTFValues_yy ; int nInUseShadow = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { if ( inUse [ i ] ) { unseqToSeq [ i ] = ( byte ) nInUseShadow ; nInUseShadow ++ ; } } this . nInUse = nInUseShadow ; final int eob = nInUseShadow + 1 ; for ( int i = eob ; i >= 0 ; i -- ) { mtfFreq [ i ] = 0 ; } for ( int i = nInUseShadow ; -- i >= 0 ; ) { yy [ i ] = ( byte ) i ; } int wr = 0 ; int zPend = 0 ; for ( int i = 0 ; i <= lastShadow ; i ++ ) { final byte ll_i = unseqToSeq [ block [ fmap [ i ] ] & 0xff ] ; byte tmp = yy [ 0 ] ; int j = 0 ; while ( ll_i != tmp ) { j ++ ; byte tmp2 = tmp ; tmp = yy [ j ] ; yy [ j ] = tmp2 ; } yy [ 0 ] = tmp ; if ( j == 0 ) { zPend ++ ; } else { if ( zPend > 0 ) { zPend -- ; while ( true ) { if ( ( zPend & 1 ) == 0 ) { sfmap [ wr ] = RUNA ; wr ++ ; mtfFreq [ RUNA ] ++ ; } else { sfmap [ wr ] = RUNB ; wr ++ ; mtfFreq [ RUNB ] ++ ; } if ( zPend >= 2 ) { zPend = ( zPend - 2 ) > > 1 ; } else { break ; } } zPend = 0 ; } sfmap [ wr ] = ( char ) ( j + 1 ) ; wr ++ ; mtfFreq [ j + 1 ] ++ ; } } if ( zPend > 0 ) { zPend -- ; while ( true ) { if ( ( zPend & 1 ) == 0 ) { sfmap [ wr ] = RUNA ; wr ++ ; mtfFreq [ RUNA ] ++ ; } else { sfmap [ wr ] = RUNB ; wr ++ ; mtfFreq [ RUNB ] ++ ; } if ( zPend >= 2 ) { zPend = ( zPend - 2 ) > > 1 ; } else { break ; } } } sfmap [ wr ] = ( char ) eob ; mtfFreq [ eob ] ++ ; this . nMTF = wr + 1 ; } private static final class Data extends Object { final boolean [ ] inUse = new boolean [ 256 ] ; final byte [ ] unseqToSeq = new byte [ 256 ] ; final int [ ] mtfFreq = new int [ MAX_ALPHA_SIZE ] ; final byte [ ] selector = new byte [ MAX_SELECTORS ] ; final byte [ ] selectorMtf = new byte [ MAX_SELECTORS ] ; final byte [ ] generateMTFValues_yy = new byte [ 256 ] ; final byte [ ] [ ] sendMTFValues_len = new byte [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; final int [ ] [ ] sendMTFValues_rfreq = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; final int [ ] sendMTFValues_fave = new int [ N_GROUPS ] ; final short [ ] sendMTFValues_cost = new short [ N_GROUPS ] ; final int [ ] [ ] sendMTFValues_code = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; final byte [ ] sendMTFValues2_pos = new byte [ N_GROUPS ] ; final boolean [ ] sentMTFValues4_inUse16 = new boolean [ 16 ] ; final int [ ] stack_ll = new int [ QSORT_STACK_SIZE ] ; final int [ ] stack_hh = new int [ QSORT_STACK_SIZE ] ; final int [ ] stack_dd = new int [ QSORT_STACK_SIZE ] ; final int [ ] mainSort_runningOrder = new int [ 256 ] ; final int [ ] mainSort_copy = new int [ 256 ] ; final boolean [ ] mainSort_bigDone = new boolean [ 256 ] ; final int [ ] heap = new int [ MAX_ALPHA_SIZE + 2 ] ; final int [ ] weight = new int [ MAX_ALPHA_SIZE * 2 ] ; final int [ ] parent = new int [ MAX_ALPHA_SIZE * 2 ] ; final int [ ] ftab = new int [ 65537 ] ; final byte [ ] block ; final int [ ] fmap ; final char [ ] sfmap ; final char [ ] quadrant ; Data ( int blockSize100k ) { super ( ) ; final int n = blockSize100k * BZip2Constants . baseBlockSize ; this . block = new byte [ ( n + 1 + NUM_OVERSHOOT_BYTES ) ] ; this . fmap = new int [ n ] ; this . sfmap = new char [ 2 * n ] ; this . quadrant = this . sfmap ; } } } 	1	['41', '2', '0', '6', '60', '402', '3', '3', '8', '0.889166667', '4541', '0.933333333', '2', '0.11627907', '0.191666667', '1', '1', '109.0243902', '47', '5.5854', '6']
package org . apache . tools . ant . taskdefs . condition ; import java . util . Locale ; import org . apache . tools . ant . BuildException ; public class Os implements Condition { private static final String OS_NAME = System . getProperty ( "os.name" ) . toLowerCase ( Locale . US ) ; private static final String OS_ARCH = System . getProperty ( "os.arch" ) . toLowerCase ( Locale . US ) ; private static final String OS_VERSION = System . getProperty ( "os.version" ) . toLowerCase ( Locale . US ) ; private static final String PATH_SEP = System . getProperty ( "path.separator" ) ; private String family ; private String name ; private String version ; private String arch ; public static final String FAMILY_WINDOWS = "windows" ; public static final String FAMILY_9X = "win9x" ; public static final String FAMILY_NT = "winnt" ; public static final String FAMILY_OS2 = "os/2" ; public static final String FAMILY_NETWARE = "netware" ; public static final String FAMILY_DOS = "dos" ; public static final String FAMILY_MAC = "mac" ; public static final String FAMILY_TANDEM = "tandem" ; public static final String FAMILY_UNIX = "unix" ; public static final String FAMILY_VMS = "openvms" ; public static final String FAMILY_ZOS = "z/os" ; public static final String FAMILY_OS400 = "os/400" ; public Os ( ) { } public Os ( String family ) { setFamily ( family ) ; } public void setFamily ( String f ) { family = f . toLowerCase ( Locale . US ) ; } public void setName ( String name ) { this . name = name . toLowerCase ( Locale . US ) ; } public void setArch ( String arch ) { this . arch = arch . toLowerCase ( Locale . US ) ; } public void setVersion ( String version ) { this . version = version . toLowerCase ( Locale . US ) ; } public boolean eval ( ) throws BuildException { return isOs ( family , name , arch , version ) ; } public static boolean isFamily ( String family ) { return isOs ( family , null , null , null ) ; } public static boolean isName ( String name ) { return isOs ( null , name , null , null ) ; } public static boolean isArch ( String arch ) { return isOs ( null , null , arch , null ) ; } public static boolean isVersion ( String version ) { return isOs ( null , null , null , version ) ; } public static boolean isOs ( String family , String name , String arch , String version ) { boolean retValue = false ; if ( family != null || name != null || arch != null || version != null ) { boolean isFamily = true ; boolean isName = true ; boolean isArch = true ; boolean isVersion = true ; if ( family != null ) { boolean isWindows = OS_NAME . indexOf ( FAMILY_WINDOWS ) > - 1 ; boolean is9x = false ; boolean isNT = false ; if ( isWindows ) { is9x = ( OS_NAME . indexOf ( "95" ) >= 0 || OS_NAME . indexOf ( "98" ) >= 0 || OS_NAME . indexOf ( "me" ) >= 0 || OS_NAME . indexOf ( "ce" ) >= 0 ) ; isNT = ! is9x ; } if ( family . equals ( FAMILY_WINDOWS ) ) { isFamily = isWindows ; } else if ( family . equals ( FAMILY_9X ) ) { isFamily = isWindows && is9x ; } else if ( family . equals ( FAMILY_NT ) ) { isFamily = isWindows && isNT ; } else if ( family . equals ( FAMILY_OS2 ) ) { isFamily = OS_NAME . indexOf ( FAMILY_OS2 ) > - 1 ; } else if ( family . equals ( FAMILY_NETWARE ) ) { isFamily = OS_NAME . indexOf ( FAMILY_NETWARE ) > - 1 ; } else if ( family . equals ( FAMILY_DOS ) ) { isFamily = PATH_SEP . equals ( ";" ) && ! isFamily ( FAMILY_NETWARE ) ; } else if ( family . equals ( FAMILY_MAC ) ) { isFamily = OS_NAME . indexOf ( FAMILY_MAC ) > - 1 ; } else if ( family . equals ( FAMILY_TANDEM ) ) { isFamily = OS_NAME . indexOf ( "nonstop_kernel" ) > - 1 ; } else if ( family . equals ( FAMILY_UNIX ) ) { isFamily = PATH_SEP . equals ( ":" ) && ! isFamily ( FAMILY_VMS ) && ( ! isFamily ( FAMILY_MAC ) || OS_NAME . endsWith ( "x" ) ) ; } else if ( family . equals ( FAMILY_ZOS ) ) { isFamily = OS_NAME . indexOf ( FAMILY_ZOS ) > - 1 || OS_NAME . indexOf ( "os/390" ) > - 1 ; } else if ( family . equals ( FAMILY_OS400 ) ) { isFamily = OS_NAME . indexOf ( FAMILY_OS400 ) > - 1 ; } else if ( family . equals ( FAMILY_VMS ) ) { isFamily = OS_NAME . indexOf ( FAMILY_VMS ) > - 1 ; } else { throw new BuildException ( "Don\'t know how to detect os family \"" + family + "\"" ) ; } } if ( name != null ) { isName = name . equals ( OS_NAME ) ; } if ( arch != null ) { isArch = arch . equals ( OS_ARCH ) ; } if ( version != null ) { isVersion = version . equals ( OS_VERSION ) ; } retValue = isFamily && isName && isArch && isVersion ; } return retValue ; } } 	1	['13', '1', '0', '27', '23', '68', '25', '2', '12', '0.929166667', '400', '0.4', '0', '0', '0.708333333', '0', '0', '28.23076923', '50', '4.5385', '1']
package org . apache . tools . ant . taskdefs ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . Locale ; import java . util . HashMap ; import java . util . Iterator ; import org . apache . tools . ant . AntTypeDefinition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ComponentHelper ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . RuntimeConfigurable ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . UnknownElement ; public class MacroDef extends AntlibDefinition { private NestedSequential nestedSequential ; private String name ; private boolean backTrace = true ; private List attributes = new ArrayList ( ) ; private Map elements = new HashMap ( ) ; private String textName = null ; private Text text = null ; private boolean hasImplicitElement = false ; public void setName ( String name ) { this . name = name ; } public void addConfiguredText ( Text text ) { if ( this . text != null ) { throw new BuildException ( "Only one nested text element allowed" ) ; } if ( text . getName ( ) == null ) { throw new BuildException ( "the text nested element needed a \"name\" attribute" ) ; } for ( Iterator i = attributes . iterator ( ) ; i . hasNext ( ) ; ) { Attribute attribute = ( Attribute ) i . next ( ) ; if ( text . getName ( ) . equals ( attribute . getName ( ) ) ) { throw new BuildException ( "the name \"" + text . getName ( ) + "\" is already used as an attribute" ) ; } } this . text = text ; this . textName = text . getName ( ) ; } public Text getText ( ) { return text ; } public void setBackTrace ( boolean backTrace ) { this . backTrace = backTrace ; } public boolean getBackTrace ( ) { return backTrace ; } public NestedSequential createSequential ( ) { if ( this . nestedSequential != null ) { throw new BuildException ( "Only one sequential allowed" ) ; } this . nestedSequential = new NestedSequential ( ) ; return this . nestedSequential ; } public static class NestedSequential implements TaskContainer { private List nested = new ArrayList ( ) ; public void addTask ( Task task ) { nested . add ( task ) ; } public List getNested ( ) { return nested ; } public boolean similar ( NestedSequential other ) { if ( nested . size ( ) != other . nested . size ( ) ) { return false ; } for ( int i = 0 ; i < nested . size ( ) ; ++ i ) { UnknownElement me = ( UnknownElement ) nested . get ( i ) ; UnknownElement o = ( UnknownElement ) other . nested . get ( i ) ; if ( ! me . similar ( o ) ) { return false ; } } return true ; } } public UnknownElement getNestedTask ( ) { UnknownElement ret = new UnknownElement ( "sequential" ) ; ret . setTaskName ( "sequential" ) ; ret . setNamespace ( "" ) ; ret . setQName ( "sequential" ) ; new RuntimeConfigurable ( ret , "sequential" ) ; for ( int i = 0 ; i < nestedSequential . getNested ( ) . size ( ) ; ++ i ) { UnknownElement e = ( UnknownElement ) nestedSequential . getNested ( ) . get ( i ) ; ret . addChild ( e ) ; ret . getWrapper ( ) . addChild ( e . getWrapper ( ) ) ; } return ret ; } public List getAttributes ( ) { return attributes ; } public Map getElements ( ) { return elements ; } public static boolean isValidNameCharacter ( char c ) { return Character . isLetterOrDigit ( c ) || c == '.' || c == '-' ; } private static boolean isValidName ( String name ) { if ( name . length ( ) == 0 ) { return false ; } for ( int i = 0 ; i < name . length ( ) ; ++ i ) { if ( ! isValidNameCharacter ( name . charAt ( i ) ) ) { return false ; } } return true ; } public void addConfiguredAttribute ( Attribute attribute ) { if ( attribute . getName ( ) == null ) { throw new BuildException ( "the attribute nested element needed a \"name\" attribute" ) ; } if ( attribute . getName ( ) . equals ( textName ) ) { throw new BuildException ( "the name \"" + attribute . getName ( ) + "\" has already been used by the text element" ) ; } for ( int i = 0 ; i < attributes . size ( ) ; ++ i ) { Attribute att = ( Attribute ) attributes . get ( i ) ; if ( att . getName ( ) . equals ( attribute . getName ( ) ) ) { throw new BuildException ( "the name \"" + attribute . getName ( ) + "\" has already been used in " + "another attribute element" ) ; } } attributes . add ( attribute ) ; } public void addConfiguredElement ( TemplateElement element ) { if ( element . getName ( ) == null ) { throw new BuildException ( "the element nested element needed a \"name\" attribute" ) ; } if ( elements . get ( element . getName ( ) ) != null ) { throw new BuildException ( "the element " + element . getName ( ) + " has already been specified" ) ; } if ( hasImplicitElement || ( element . isImplicit ( ) && elements . size ( ) != 0 ) ) { throw new BuildException ( "Only one element allowed when using implicit elements" ) ; } hasImplicitElement = element . isImplicit ( ) ; elements . put ( element . getName ( ) , element ) ; } public void execute ( ) { if ( nestedSequential == null ) { throw new BuildException ( "Missing sequential element" ) ; } if ( name == null ) { throw new BuildException ( "Name not specified" ) ; } name = ProjectHelper . genComponentName ( getURI ( ) , name ) ; MyAntTypeDefinition def = new MyAntTypeDefinition ( this ) ; def . setName ( name ) ; def . setClass ( MacroInstance . class ) ; ComponentHelper helper = ComponentHelper . getComponentHelper ( getProject ( ) ) ; helper . addDataTypeDefinition ( def ) ; log ( "creating macro  " + name , Project . MSG_VERBOSE ) ; } public static class Attribute { private String name ; private String defaultValue ; private String description ; public void setName ( String name ) { if ( ! isValidName ( name ) ) { throw new BuildException ( "Illegal name [" + name + "] for attribute" ) ; } this . name = name . toLowerCase ( Locale . US ) ; } public String getName ( ) { return name ; } public void setDefault ( String defaultValue ) { this . defaultValue = defaultValue ; } public String getDefault ( ) { return defaultValue ; } public void setDescription ( String desc ) { description = desc ; } public String getDescription ( ) { return description ; } public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( obj . getClass ( ) != getClass ( ) ) { return false ; } Attribute other = ( Attribute ) obj ; if ( name == null ) { if ( other . name != null ) { return false ; } } else if ( ! name . equals ( other . name ) ) { return false ; } if ( defaultValue == null ) { if ( other . defaultValue != null ) { return false ; } } else if ( ! defaultValue . equals ( other . defaultValue ) ) { return false ; } return true ; } public int hashCode ( ) { return objectHashCode ( defaultValue ) + objectHashCode ( name ) ; } } public static class Text { private String name ; private boolean optional ; private boolean trim ; private String description ; public void setName ( String name ) { if ( ! isValidName ( name ) ) { throw new BuildException ( "Illegal name [" + name + "] for attribute" ) ; } this . name = name . toLowerCase ( Locale . US ) ; } public String getName ( ) { return name ; } public void setOptional ( boolean optional ) { this . optional = optional ; } public boolean getOptional ( ) { return optional ; } public void setTrim ( boolean trim ) { this . trim = trim ; } public boolean getTrim ( ) { return trim ; } public void setDescription ( String desc ) { description = desc ; } public String getDescription ( ) { return description ; } public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( obj . getClass ( ) != getClass ( ) ) { return false ; } Text other = ( Text ) obj ; if ( name == null ) { if ( other . name != null ) { return false ; } } else if ( ! name . equals ( other . name ) ) { return false ; } if ( optional != other . optional ) { return false ; } if ( trim != other . trim ) { return false ; } return true ; } public int hashCode ( ) { return objectHashCode ( name ) ; } } public static class TemplateElement { private String name ; private String description ; private boolean optional = false ; private boolean implicit = false ; public void setName ( String name ) { if ( ! isValidName ( name ) ) { throw new BuildException ( "Illegal name [" + name + "] for macro element" ) ; } this . name = name . toLowerCase ( Locale . US ) ; } public String getName ( ) { return name ; } public void setDescription ( String desc ) { description = desc ; } public String getDescription ( ) { return description ; } public void setOptional ( boolean optional ) { this . optional = optional ; } public boolean isOptional ( ) { return optional ; } public void setImplicit ( boolean implicit ) { this . implicit = implicit ; } public boolean isImplicit ( ) { return implicit ; } public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( obj == null || ! obj . getClass ( ) . equals ( getClass ( ) ) ) { return false ; } TemplateElement t = ( TemplateElement ) obj ; return ( name == null ? t . name == null : name . equals ( t . name ) ) && optional == t . optional && implicit == t . implicit ; } public int hashCode ( ) { return objectHashCode ( name ) + ( optional ? 1 : 0 ) + ( implicit ? 1 : 0 ) ; } } private boolean sameOrSimilar ( Object obj , boolean same ) { if ( obj == this ) { return true ; } if ( obj == null ) { return false ; } if ( ! obj . getClass ( ) . equals ( getClass ( ) ) ) { return false ; } MacroDef other = ( MacroDef ) obj ; if ( name == null ) { return other . name == null ; } if ( ! name . equals ( other . name ) ) { return false ; } if ( other . getLocation ( ) != null && other . getLocation ( ) . equals ( getLocation ( ) ) && ! same ) { return true ; } if ( text == null ) { if ( other . text != null ) { return false ; } } else { if ( ! text . equals ( other . text ) ) { return false ; } } if ( getURI ( ) == null || getURI ( ) . equals ( "" ) || getURI ( ) . equals ( ProjectHelper . ANT_CORE_URI ) ) { if ( ! ( other . getURI ( ) == null || other . getURI ( ) . equals ( "" ) || other . getURI ( ) . equals ( ProjectHelper . ANT_CORE_URI ) ) ) { return false ; } } else { if ( ! getURI ( ) . equals ( other . getURI ( ) ) ) { return false ; } } if ( ! nestedSequential . similar ( other . nestedSequential ) ) { return false ; } if ( ! attributes . equals ( other . attributes ) ) { return false ; } if ( ! elements . equals ( other . elements ) ) { return false ; } return true ; } public boolean similar ( Object obj ) { return sameOrSimilar ( obj , false ) ; } public boolean sameDefinition ( Object obj ) { return sameOrSimilar ( obj , true ) ; } private static class MyAntTypeDefinition extends AntTypeDefinition { private MacroDef macroDef ; public MyAntTypeDefinition ( MacroDef macroDef ) { this . macroDef = macroDef ; } public Object create ( Project project ) { Object o = super . create ( project ) ; if ( o == null ) { return null ; } ( ( MacroInstance ) o ) . setMacroDef ( macroDef ) ; return o ; } public boolean sameDefinition ( AntTypeDefinition other , Project project ) { if ( ! super . sameDefinition ( other , project ) ) { return false ; } MyAntTypeDefinition otherDef = ( MyAntTypeDefinition ) other ; return macroDef . sameDefinition ( otherDef . macroDef ) ; } public boolean similarDefinition ( AntTypeDefinition other , Project project ) { if ( ! super . similarDefinition ( other , project ) ) { return false ; } MyAntTypeDefinition otherDef = ( MyAntTypeDefinition ) other ; return macroDef . similar ( otherDef . macroDef ) ; } } private static int objectHashCode ( Object o ) { if ( o == null ) { return 0 ; } else { return o . hashCode ( ) ; } } } 	1	['21', '4', '0', '15', '76', '152', '5', '14', '16', '0.833333333', '573', '0.888888889', '2', '0.672131148', '0.178571429', '1', '1', '25.85714286', '23', '3.1905', '1']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . FileUtils ; public class TempFile extends Task { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private String property ; private File destDir = null ; private String prefix ; private String suffix = "" ; private boolean deleteOnExit ; public void setProperty ( String property ) { this . property = property ; } public void setDestDir ( File destDir ) { this . destDir = destDir ; } public void setPrefix ( String prefix ) { this . prefix = prefix ; } public void setSuffix ( String suffix ) { this . suffix = suffix ; } public void setDeleteOnExit ( boolean deleteOnExit ) { this . deleteOnExit = deleteOnExit ; } public boolean isDeleteOnExit ( ) { return deleteOnExit ; } public void execute ( ) throws BuildException { if ( property == null || property . length ( ) == 0 ) { throw new BuildException ( "no property specified" ) ; } if ( destDir == null ) { destDir = getProject ( ) . resolveFile ( "." ) ; } File tfile = FILE_UTILS . createTempFile ( prefix , suffix , destDir , deleteOnExit ) ; getProject ( ) . setNewProperty ( property , tfile . toString ( ) ) ; } } 	1	['9', '3', '0', '5', '18', '14', '1', '4', '8', '0.8125', '90', '1', '1', '0.840909091', '0.40625', '0', '0', '8.333333333', '1', '0.7778', '1']
package org . apache . tools . ant ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . PrintStream ; import java . io . StringReader ; import org . apache . tools . ant . util . DateUtils ; import org . apache . tools . ant . util . StringUtils ; public class DefaultLogger implements BuildLogger { public static final int LEFT_COLUMN_SIZE = 12 ; protected PrintStream out ; protected PrintStream err ; protected int msgOutputLevel = Project . MSG_ERR ; private long startTime = System . currentTimeMillis ( ) ; protected static final String lSep = StringUtils . LINE_SEP ; protected boolean emacsMode = false ; public DefaultLogger ( ) { } public void setMessageOutputLevel ( int level ) { this . msgOutputLevel = level ; } public void setOutputPrintStream ( PrintStream output ) { this . out = new PrintStream ( output , true ) ; } public void setErrorPrintStream ( PrintStream err ) { this . err = new PrintStream ( err , true ) ; } public void setEmacsMode ( boolean emacsMode ) { this . emacsMode = emacsMode ; } public void buildStarted ( BuildEvent event ) { startTime = System . currentTimeMillis ( ) ; } public void buildFinished ( BuildEvent event ) { Throwable error = event . getException ( ) ; StringBuffer message = new StringBuffer ( ) ; if ( error == null ) { message . append ( StringUtils . LINE_SEP ) ; message . append ( getBuildSuccessfulMessage ( ) ) ; } else { message . append ( StringUtils . LINE_SEP ) ; message . append ( getBuildFailedMessage ( ) ) ; message . append ( StringUtils . LINE_SEP ) ; if ( Project . MSG_VERBOSE <= msgOutputLevel || ! ( error instanceof BuildException ) ) { message . append ( StringUtils . getStackTrace ( error ) ) ; } else { message . append ( error . toString ( ) ) . append ( lSep ) ; } } message . append ( StringUtils . LINE_SEP ) ; message . append ( "Total time: " ) ; message . append ( formatTime ( System . currentTimeMillis ( ) - startTime ) ) ; String msg = message . toString ( ) ; if ( error == null ) { printMessage ( msg , out , Project . MSG_VERBOSE ) ; } else { printMessage ( msg , err , Project . MSG_ERR ) ; } log ( msg ) ; } protected String getBuildFailedMessage ( ) { return "BUILD FAILED" ; } protected String getBuildSuccessfulMessage ( ) { return "BUILD SUCCESSFUL" ; } public void targetStarted ( BuildEvent event ) { if ( Project . MSG_INFO <= msgOutputLevel && ! event . getTarget ( ) . getName ( ) . equals ( "" ) ) { String msg = StringUtils . LINE_SEP + event . getTarget ( ) . getName ( ) + ":" ; printMessage ( msg , out , event . getPriority ( ) ) ; log ( msg ) ; } } public void targetFinished ( BuildEvent event ) { } public void taskStarted ( BuildEvent event ) { } public void taskFinished ( BuildEvent event ) { } public void messageLogged ( BuildEvent event ) { int priority = event . getPriority ( ) ; if ( priority <= msgOutputLevel ) { StringBuffer message = new StringBuffer ( ) ; if ( event . getTask ( ) != null && ! emacsMode ) { String name = event . getTask ( ) . getTaskName ( ) ; String label = "[" + name + "] " ; int size = LEFT_COLUMN_SIZE - label . length ( ) ; StringBuffer tmp = new StringBuffer ( ) ; for ( int i = 0 ; i < size ; i ++ ) { tmp . append ( " " ) ; } tmp . append ( label ) ; label = tmp . toString ( ) ; try { BufferedReader r = new BufferedReader ( new StringReader ( event . getMessage ( ) ) ) ; String line = r . readLine ( ) ; boolean first = true ; do { if ( first ) { if ( line == null ) { message . append ( label ) ; break ; } } else { message . append ( StringUtils . LINE_SEP ) ; } first = false ; message . append ( label ) . append ( line ) ; line = r . readLine ( ) ; } while ( line != null ) ; } catch ( IOException e ) { message . append ( label ) . append ( event . getMessage ( ) ) ; } } else { message . append ( event . getMessage ( ) ) ; } Throwable ex = event . getException ( ) ; if ( Project . MSG_DEBUG <= msgOutputLevel && ex != null ) { message . append ( StringUtils . getStackTrace ( ex ) ) ; } String msg = message . toString ( ) ; if ( priority != Project . MSG_ERR ) { printMessage ( msg , out , priority ) ; } else { printMessage ( msg , err , priority ) ; } log ( msg ) ; } } protected static String formatTime ( final long millis ) { return DateUtils . formatElapsedTime ( millis ) ; } protected void printMessage ( final String message , final PrintStream stream , final int priority ) { stream . println ( message ) ; } protected void log ( String message ) { } } 	1	['18', '1', '4', '14', '42', '113', '7', '7', '12', '0.890756303', '356', '0.857142857', '0', '0', '0.268907563', '0', '0', '18.38888889', '11', '1.7778', '3']
package org . apache . tools . ant . types . resources ; import java . util . Stack ; import java . util . TreeMap ; import java . util . Iterator ; import java . util . Collection ; import java . util . Comparator ; import java . util . Collections ; import java . util . AbstractCollection ; import java . util . NoSuchElementException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . comparators . ResourceComparator ; import org . apache . tools . ant . types . resources . comparators . DelegatedResourceComparator ; public class Sort extends BaseResourceCollectionWrapper { private static class SortedBag extends AbstractCollection { private class MutableInt { private int value = 0 ; } private class MyIterator implements Iterator { private Iterator keyIter = t . keySet ( ) . iterator ( ) ; private Object current ; private int occurrence ; public synchronized boolean hasNext ( ) { return occurrence > 0 || keyIter . hasNext ( ) ; } public synchronized Object next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } if ( occurrence == 0 ) { current = keyIter . next ( ) ; occurrence = ( ( MutableInt ) t . get ( current ) ) . value ; } -- occurrence ; return current ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } private TreeMap t ; private int size ; SortedBag ( Comparator c ) { t = new TreeMap ( c ) ; } public synchronized Iterator iterator ( ) { return new MyIterator ( ) ; } public synchronized boolean add ( Object o ) { if ( size < Integer . MAX_VALUE ) { ++ size ; } MutableInt m = ( MutableInt ) ( t . get ( o ) ) ; if ( m == null ) { m = new MutableInt ( ) ; t . put ( o , m ) ; } m . value ++ ; return true ; } public synchronized int size ( ) { return size ; } } private DelegatedResourceComparator comp = new DelegatedResourceComparator ( ) ; protected synchronized Collection getCollection ( ) { ResourceCollection rc = getResourceCollection ( ) ; Iterator iter = rc . iterator ( ) ; if ( ! ( iter . hasNext ( ) ) ) { return Collections . EMPTY_SET ; } SortedBag b = new SortedBag ( comp ) ; while ( iter . hasNext ( ) ) { b . add ( iter . next ( ) ) ; } return b ; } public synchronized void add ( ResourceComparator c ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } comp . add ( c ) ; FailFast . invalidate ( this ) ; } protected synchronized void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( isChecked ( ) ) { return ; } if ( isReference ( ) ) { super . dieOnCircularReference ( stk , p ) ; } else { DataType . invokeCircularReferenceCheck ( comp , stk , p ) ; setChecked ( true ) ; } } } 	1	['4', '4', '1', '11', '20', '0', '2', '9', '2', '0', '75', '1', '1', '0.933333333', '0.4375', '2', '5', '17.5', '3', '1.5', '2']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Date ; import java . util . Enumeration ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Set ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . types . PatternSet ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . Union ; import org . apache . tools . ant . types . selectors . SelectorUtils ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . IdentityMapper ; import org . apache . tools . zip . ZipEntry ; import org . apache . tools . zip . ZipFile ; public class Expand extends Task { private File dest ; private File source ; private boolean overwrite = true ; private Mapper mapperElement = null ; private Vector patternsets = new Vector ( ) ; private Union resources = new Union ( ) ; private boolean resourcesSpecified = false ; private static final String NATIVE_ENCODING = "native-encoding" ; private String encoding = "UTF8" ; public static final String ERROR_MULTIPLE_MAPPERS = "Cannot define more than one mapper" ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; public void execute ( ) throws BuildException { if ( "expand" . equals ( getTaskType ( ) ) ) { log ( "!! expand is deprecated. Use unzip instead. !!" ) ; } if ( source == null && ! resourcesSpecified ) { throw new BuildException ( "src attribute and/or resources must be " + "specified" ) ; } if ( dest == null ) { throw new BuildException ( "Dest attribute must be specified" ) ; } if ( dest . exists ( ) && ! dest . isDirectory ( ) ) { throw new BuildException ( "Dest must be a directory." , getLocation ( ) ) ; } if ( source != null ) { if ( source . isDirectory ( ) ) { throw new BuildException ( "Src must not be a directory." + " Use nested filesets instead." , getLocation ( ) ) ; } else { expandFile ( FILE_UTILS , source , dest ) ; } } Iterator iter = resources . iterator ( ) ; while ( iter . hasNext ( ) ) { Resource r = ( Resource ) iter . next ( ) ; if ( ! r . isExists ( ) ) { continue ; } if ( r instanceof FileResource ) { expandFile ( FILE_UTILS , ( ( FileResource ) r ) . getFile ( ) , dest ) ; } else { expandResource ( r , dest ) ; } } } protected void expandFile ( FileUtils fileUtils , File srcF , File dir ) { log ( "Expanding: " + srcF + " into " + dir , Project . MSG_INFO ) ; ZipFile zf = null ; FileNameMapper mapper = getMapper ( ) ; try { zf = new ZipFile ( srcF , encoding ) ; Enumeration e = zf . getEntries ( ) ; while ( e . hasMoreElements ( ) ) { ZipEntry ze = ( ZipEntry ) e . nextElement ( ) ; extractFile ( fileUtils , srcF , dir , zf . getInputStream ( ze ) , ze . getName ( ) , new Date ( ze . getTime ( ) ) , ze . isDirectory ( ) , mapper ) ; } log ( "expand complete" , Project . MSG_VERBOSE ) ; } catch ( IOException ioe ) { throw new BuildException ( "Error while expanding " + srcF . getPath ( ) , ioe ) ; } finally { ZipFile . closeQuietly ( zf ) ; } } protected void expandResource ( Resource srcR , File dir ) { throw new BuildException ( "only filesystem based resources are" + " supported by this task." ) ; } protected FileNameMapper getMapper ( ) { FileNameMapper mapper = null ; if ( mapperElement != null ) { mapper = mapperElement . getImplementation ( ) ; } else { mapper = new IdentityMapper ( ) ; } return mapper ; } protected void extractFile ( FileUtils fileUtils , File srcF , File dir , InputStream compressedInputStream , String entryName , Date entryDate , boolean isDirectory , FileNameMapper mapper ) throws IOException { if ( patternsets != null && patternsets . size ( ) > 0 ) { String name = entryName . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; boolean included = false ; Set includePatterns = new HashSet ( ) ; Set excludePatterns = new HashSet ( ) ; for ( int v = 0 , size = patternsets . size ( ) ; v < size ; v ++ ) { PatternSet p = ( PatternSet ) patternsets . elementAt ( v ) ; String [ ] incls = p . getIncludePatterns ( getProject ( ) ) ; if ( incls == null || incls . length == 0 ) { incls = new String [ ] { "**" } ; } for ( int w = 0 ; w < incls . length ; w ++ ) { String pattern = incls [ w ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( pattern . endsWith ( File . separator ) ) { pattern += "**" ; } includePatterns . add ( pattern ) ; } String [ ] excls = p . getExcludePatterns ( getProject ( ) ) ; if ( excls != null ) { for ( int w = 0 ; w < excls . length ; w ++ ) { String pattern = excls [ w ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( pattern . endsWith ( File . separator ) ) { pattern += "**" ; } excludePatterns . add ( pattern ) ; } } } for ( Iterator iter = includePatterns . iterator ( ) ; ! included && iter . hasNext ( ) ; ) { String pattern = ( String ) iter . next ( ) ; included = SelectorUtils . matchPath ( pattern , name ) ; } for ( Iterator iter = excludePatterns . iterator ( ) ; included && iter . hasNext ( ) ; ) { String pattern = ( String ) iter . next ( ) ; included = ! SelectorUtils . matchPath ( pattern , name ) ; } if ( ! included ) { return ; } } String [ ] mappedNames = mapper . mapFileName ( entryName ) ; if ( mappedNames == null || mappedNames . length == 0 ) { mappedNames = new String [ ] { entryName } ; } File f = fileUtils . resolveFile ( dir , mappedNames [ 0 ] ) ; try { if ( ! overwrite && f . exists ( ) && f . lastModified ( ) >= entryDate . getTime ( ) ) { log ( "Skipping " + f + " as it is up-to-date" , Project . MSG_DEBUG ) ; return ; } log ( "expanding " + entryName + " to " + f , Project . MSG_VERBOSE ) ; File dirF = f . getParentFile ( ) ; if ( dirF != null ) { dirF . mkdirs ( ) ; } if ( isDirectory ) { f . mkdirs ( ) ; } else { byte [ ] buffer = new byte [ 1024 ] ; int length = 0 ; FileOutputStream fos = null ; try { fos = new FileOutputStream ( f ) ; while ( ( length = compressedInputStream . read ( buffer ) ) >= 0 ) { fos . write ( buffer , 0 , length ) ; } fos . close ( ) ; fos = null ; } finally { FileUtils . close ( fos ) ; } } fileUtils . setFileLastModified ( f , entryDate . getTime ( ) ) ; } catch ( FileNotFoundException ex ) { log ( "Unable to expand to file " + f . getPath ( ) , Project . MSG_WARN ) ; } } public void setDest ( File d ) { this . dest = d ; } public void setSrc ( File s ) { this . source = s ; } public void setOverwrite ( boolean b ) { overwrite = b ; } public void addPatternset ( PatternSet set ) { patternsets . addElement ( set ) ; } public void addFileset ( FileSet set ) { add ( set ) ; } public void add ( ResourceCollection rc ) { resourcesSpecified = true ; resources . add ( rc ) ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( ERROR_MULTIPLE_MAPPERS , getLocation ( ) ) ; } mapperElement = new Mapper ( getProject ( ) ) ; return mapperElement ; } public void add ( FileNameMapper fileNameMapper ) { createMapper ( ) . add ( fileNameMapper ) ; } public void setEncoding ( String encoding ) { if ( NATIVE_ENCODING . equals ( encoding ) ) { encoding = null ; } this . encoding = encoding ; } } 	1	['16', '3', '1', '18', '80', '86', '1', '17', '11', '0.878787879', '631', '0.909090909', '3', '0.725490196', '0.188888889', '2', '2', '37.75', '4', '1.1875', '4']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . selectors . modifiedselector . ModifiedSelector ; public abstract class BaseSelectorContainer extends BaseSelector implements SelectorContainer { private Vector selectorsList = new Vector ( ) ; public BaseSelectorContainer ( ) { } public boolean hasSelectors ( ) { return ! ( selectorsList . isEmpty ( ) ) ; } public int selectorCount ( ) { return selectorsList . size ( ) ; } public FileSelector [ ] getSelectors ( Project p ) { FileSelector [ ] result = new FileSelector [ selectorsList . size ( ) ] ; selectorsList . copyInto ( result ) ; return result ; } public Enumeration selectorElements ( ) { return selectorsList . elements ( ) ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; Enumeration e = selectorElements ( ) ; if ( e . hasMoreElements ( ) ) { while ( e . hasMoreElements ( ) ) { buf . append ( e . nextElement ( ) . toString ( ) ) ; if ( e . hasMoreElements ( ) ) { buf . append ( ", " ) ; } } } return buf . toString ( ) ; } public void appendSelector ( FileSelector selector ) { selectorsList . addElement ( selector ) ; } public void validate ( ) { verifySettings ( ) ; String errmsg = getError ( ) ; if ( errmsg != null ) { throw new BuildException ( errmsg ) ; } Enumeration e = selectorElements ( ) ; while ( e . hasMoreElements ( ) ) { Object o = e . nextElement ( ) ; if ( o instanceof BaseSelector ) { ( ( BaseSelector ) o ) . validate ( ) ; } } } public abstract boolean isSelected ( File basedir , String filename , File file ) ; public void addSelector ( SelectSelector selector ) { appendSelector ( selector ) ; } public void addAnd ( AndSelector selector ) { appendSelector ( selector ) ; } public void addOr ( OrSelector selector ) { appendSelector ( selector ) ; } public void addNot ( NotSelector selector ) { appendSelector ( selector ) ; } public void addNone ( NoneSelector selector ) { appendSelector ( selector ) ; } public void addMajority ( MajoritySelector selector ) { appendSelector ( selector ) ; } public void addDate ( DateSelector selector ) { appendSelector ( selector ) ; } public void addSize ( SizeSelector selector ) { appendSelector ( selector ) ; } public void addFilename ( FilenameSelector selector ) { appendSelector ( selector ) ; } public void addCustom ( ExtendSelector selector ) { appendSelector ( selector ) ; } public void addContains ( ContainsSelector selector ) { appendSelector ( selector ) ; } public void addPresent ( PresentSelector selector ) { appendSelector ( selector ) ; } public void addDepth ( DepthSelector selector ) { appendSelector ( selector ) ; } public void addDepend ( DependSelector selector ) { appendSelector ( selector ) ; } public void addDifferent ( DifferentSelector selector ) { appendSelector ( selector ) ; } public void addType ( TypeSelector selector ) { appendSelector ( selector ) ; } public void addContainsRegexp ( ContainsRegexpSelector selector ) { appendSelector ( selector ) ; } public void addModified ( ModifiedSelector selector ) { appendSelector ( selector ) ; } public void add ( FileSelector selector ) { appendSelector ( selector ) ; } } 	1	['28', '4', '5', '23', '45', '348', '5', '23', '28', '0.037037037', '204', '1', '0', '0.564516129', '0.079192547', '0', '0', '6.25', '4', '1.2143', '1']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . OutputStream ; import java . io . FileOutputStream ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . XMLFragment ; import org . apache . tools . ant . util . DOMElementWriter ; import org . apache . tools . ant . util . FileUtils ; import org . w3c . dom . Node ; import org . w3c . dom . Element ; public class EchoXML extends XMLFragment { private File file ; private boolean append ; private static final String ERROR_NO_XML = "No nested XML specified" ; public void setFile ( File f ) { file = f ; } public void setAppend ( boolean b ) { append = b ; } public void execute ( ) { DOMElementWriter writer = new DOMElementWriter ( ! append ) ; OutputStream os = null ; try { if ( file != null ) { os = new FileOutputStream ( file . getAbsolutePath ( ) , append ) ; } else { os = new LogOutputStream ( this , Project . MSG_INFO ) ; } Node n = getFragment ( ) . getFirstChild ( ) ; if ( n == null ) { throw new BuildException ( ERROR_NO_XML ) ; } writer . write ( ( Element ) n , os ) ; } catch ( BuildException e ) { throw e ; } catch ( Exception e ) { throw new BuildException ( e ) ; } finally { FileUtils . close ( os ) ; } } } 	1	['4', '3', '0', '6', '15', '2', '0', '6', '4', '0.888888889', '85', '1', '0', '0.833333333', '0.5', '0', '0', '19.5', '6', '2', '1']
package org . apache . tools . ant ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . List ; import java . util . StringTokenizer ; import org . apache . tools . ant . util . CollectionUtils ; public class Target implements TaskContainer { private String name ; private String ifCondition = "" ; private String unlessCondition = "" ; private List dependencies = null ; private List children = new ArrayList ( ) ; private Location location = Location . UNKNOWN_LOCATION ; private Project project ; private String description = null ; public Target ( ) { } public Target ( Target other ) { this . name = other . name ; this . ifCondition = other . ifCondition ; this . unlessCondition = other . unlessCondition ; this . dependencies = other . dependencies ; this . location = other . location ; this . project = other . project ; this . description = other . description ; this . children = other . children ; } public void setProject ( Project project ) { this . project = project ; } public Project getProject ( ) { return project ; } public void setLocation ( Location location ) { this . location = location ; } public Location getLocation ( ) { return location ; } public void setDepends ( String depS ) { if ( depS . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( depS , "," , true ) ; while ( tok . hasMoreTokens ( ) ) { String token = tok . nextToken ( ) . trim ( ) ; if ( "" . equals ( token ) || "," . equals ( token ) ) { throw new BuildException ( "Syntax Error: depends " + "attribute of target \"" + getName ( ) + "\" has an empty string as dependency." ) ; } addDependency ( token ) ; if ( tok . hasMoreTokens ( ) ) { token = tok . nextToken ( ) ; if ( ! tok . hasMoreTokens ( ) || ! "," . equals ( token ) ) { throw new BuildException ( "Syntax Error: Depend " + "attribute for target \"" + getName ( ) + "\" ends with a , character" ) ; } } } } } public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void addTask ( Task task ) { children . add ( task ) ; } public void addDataType ( RuntimeConfigurable r ) { children . add ( r ) ; } public Task [ ] getTasks ( ) { List tasks = new ArrayList ( children . size ( ) ) ; Iterator it = children . iterator ( ) ; while ( it . hasNext ( ) ) { Object o = it . next ( ) ; if ( o instanceof Task ) { tasks . add ( o ) ; } } return ( Task [ ] ) tasks . toArray ( new Task [ tasks . size ( ) ] ) ; } public void addDependency ( String dependency ) { if ( dependencies == null ) { dependencies = new ArrayList ( 2 ) ; } dependencies . add ( dependency ) ; } public Enumeration getDependencies ( ) { return ( dependencies != null ? Collections . enumeration ( dependencies ) : new CollectionUtils . EmptyEnumeration ( ) ) ; } public boolean dependsOn ( String other ) { Project p = getProject ( ) ; Hashtable t = ( p == null ) ? null : p . getTargets ( ) ; return ( p != null && p . topoSort ( getName ( ) , t , false ) . contains ( t . get ( other ) ) ) ; } public void setIf ( String property ) { ifCondition = ( property == null ) ? "" : property ; } public String getIf ( ) { return ( "" . equals ( ifCondition ) ? null : ifCondition ) ; } public void setUnless ( String property ) { unlessCondition = ( property == null ) ? "" : property ; } public String getUnless ( ) { return ( "" . equals ( unlessCondition ) ? null : unlessCondition ) ; } public void setDescription ( String description ) { this . description = description ; } public String getDescription ( ) { return description ; } public String toString ( ) { return name ; } public void execute ( ) throws BuildException { if ( testIfCondition ( ) && testUnlessCondition ( ) ) { for ( int taskPosition = 0 ; taskPosition < children . size ( ) ; ++ taskPosition ) { Object o = children . get ( taskPosition ) ; if ( o instanceof Task ) { Task task = ( Task ) o ; task . perform ( ) ; } else { RuntimeConfigurable r = ( RuntimeConfigurable ) o ; r . maybeConfigure ( project ) ; } } } else if ( ! testIfCondition ( ) ) { project . log ( this , "Skipped because property '" + project . replaceProperties ( ifCondition ) + "' not set." , Project . MSG_VERBOSE ) ; } else { project . log ( this , "Skipped because property '" + project . replaceProperties ( unlessCondition ) + "' set." , Project . MSG_VERBOSE ) ; } } public final void performTasks ( ) { RuntimeException thrown = null ; project . fireTargetStarted ( this ) ; try { execute ( ) ; } catch ( RuntimeException exc ) { thrown = exc ; throw exc ; } finally { project . fireTargetFinished ( this , thrown ) ; } } void replaceChild ( Task el , RuntimeConfigurable o ) { int index ; while ( ( index = children . indexOf ( el ) ) >= 0 ) { children . set ( index , o ) ; } } void replaceChild ( Task el , Task o ) { int index ; while ( ( index = children . indexOf ( el ) ) >= 0 ) { children . set ( index , o ) ; } } private boolean testIfCondition ( ) { if ( "" . equals ( ifCondition ) ) { return true ; } String test = project . replaceProperties ( ifCondition ) ; return project . getProperty ( test ) != null ; } private boolean testUnlessCondition ( ) { if ( "" . equals ( unlessCondition ) ) { return true ; } String test = project . replaceProperties ( unlessCondition ) ; return project . getProperty ( test ) == null ; } } 	1	['28', '1', '0', '34', '63', '200', '29', '7', '24', '0.805555556', '528', '1', '2', '0', '0.219387755', '0', '0', '17.57142857', '8', '1.8571', '1']
package org . apache . tools . tar ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . IOException ; import java . util . Arrays ; public class TarBuffer { public static final int DEFAULT_RCDSIZE = ( 512 ) ; public static final int DEFAULT_BLKSIZE = ( DEFAULT_RCDSIZE * 20 ) ; private InputStream inStream ; private OutputStream outStream ; private byte [ ] blockBuffer ; private int currBlkIdx ; private int currRecIdx ; private int blockSize ; private int recordSize ; private int recsPerBlock ; private boolean debug ; public TarBuffer ( InputStream inStream ) { this ( inStream , TarBuffer . DEFAULT_BLKSIZE ) ; } public TarBuffer ( InputStream inStream , int blockSize ) { this ( inStream , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarBuffer ( InputStream inStream , int blockSize , int recordSize ) { this . inStream = inStream ; this . outStream = null ; this . initialize ( blockSize , recordSize ) ; } public TarBuffer ( OutputStream outStream ) { this ( outStream , TarBuffer . DEFAULT_BLKSIZE ) ; } public TarBuffer ( OutputStream outStream , int blockSize ) { this ( outStream , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarBuffer ( OutputStream outStream , int blockSize , int recordSize ) { this . inStream = null ; this . outStream = outStream ; this . initialize ( blockSize , recordSize ) ; } private void initialize ( int blockSize , int recordSize ) { this . debug = false ; this . blockSize = blockSize ; this . recordSize = recordSize ; this . recsPerBlock = ( this . blockSize / this . recordSize ) ; this . blockBuffer = new byte [ this . blockSize ] ; if ( this . inStream != null ) { this . currBlkIdx = - 1 ; this . currRecIdx = this . recsPerBlock ; } else { this . currBlkIdx = 0 ; this . currRecIdx = 0 ; } } public int getBlockSize ( ) { return this . blockSize ; } public int getRecordSize ( ) { return this . recordSize ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public boolean isEOFRecord ( byte [ ] record ) { for ( int i = 0 , sz = this . getRecordSize ( ) ; i < sz ; ++ i ) { if ( record [ i ] != 0 ) { return false ; } } return true ; } public void skipRecord ( ) throws IOException { if ( this . debug ) { System . err . println ( "SkipRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . inStream == null ) { throw new IOException ( "reading (via skip) from an output buffer" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { if ( ! this . readBlock ( ) ) { return ; } } this . currRecIdx ++ ; } public byte [ ] readRecord ( ) throws IOException { if ( this . debug ) { System . err . println ( "ReadRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . inStream == null ) { throw new IOException ( "reading from an output buffer" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { if ( ! this . readBlock ( ) ) { return null ; } } byte [ ] result = new byte [ this . recordSize ] ; System . arraycopy ( this . blockBuffer , ( this . currRecIdx * this . recordSize ) , result , 0 , this . recordSize ) ; this . currRecIdx ++ ; return result ; } private boolean readBlock ( ) throws IOException { if ( this . debug ) { System . err . println ( "ReadBlock: blkIdx = " + this . currBlkIdx ) ; } if ( this . inStream == null ) { throw new IOException ( "reading from an output buffer" ) ; } this . currRecIdx = 0 ; int offset = 0 ; int bytesNeeded = this . blockSize ; while ( bytesNeeded > 0 ) { long numBytes = this . inStream . read ( this . blockBuffer , offset , bytesNeeded ) ; if ( numBytes == - 1 ) { if ( offset == 0 ) { return false ; } Arrays . fill ( blockBuffer , offset , offset + bytesNeeded , ( byte ) 0 ) ; break ; } offset += numBytes ; bytesNeeded -= numBytes ; if ( numBytes != this . blockSize ) { if ( this . debug ) { System . err . println ( "ReadBlock: INCOMPLETE READ " + numBytes + " of " + this . blockSize + " bytes read." ) ; } } } this . currBlkIdx ++ ; return true ; } public int getCurrentBlockNum ( ) { return this . currBlkIdx ; } public int getCurrentRecordNum ( ) { return this . currRecIdx - 1 ; } public void writeRecord ( byte [ ] record ) throws IOException { if ( this . debug ) { System . err . println ( "WriteRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } if ( record . length != this . recordSize ) { throw new IOException ( "record to write has length '" + record . length + "' which is not the record size of '" + this . recordSize + "'" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { this . writeBlock ( ) ; } System . arraycopy ( record , 0 , this . blockBuffer , ( this . currRecIdx * this . recordSize ) , this . recordSize ) ; this . currRecIdx ++ ; } public void writeRecord ( byte [ ] buf , int offset ) throws IOException { if ( this . debug ) { System . err . println ( "WriteRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } if ( ( offset + this . recordSize ) > buf . length ) { throw new IOException ( "record has length '" + buf . length + "' with offset '" + offset + "' which is less than the record size of '" + this . recordSize + "'" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { this . writeBlock ( ) ; } System . arraycopy ( buf , offset , this . blockBuffer , ( this . currRecIdx * this . recordSize ) , this . recordSize ) ; this . currRecIdx ++ ; } private void writeBlock ( ) throws IOException { if ( this . debug ) { System . err . println ( "WriteBlock: blkIdx = " + this . currBlkIdx ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } this . outStream . write ( this . blockBuffer , 0 , this . blockSize ) ; this . outStream . flush ( ) ; this . currRecIdx = 0 ; this . currBlkIdx ++ ; } private void flushBlock ( ) throws IOException { if ( this . debug ) { System . err . println ( "TarBuffer.flushBlock() called." ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } if ( this . currRecIdx > 0 ) { this . writeBlock ( ) ; } } public void close ( ) throws IOException { if ( this . debug ) { System . err . println ( "TarBuffer.closeBuffer()." ) ; } if ( this . outStream != null ) { this . flushBlock ( ) ; if ( this . outStream != System . out && this . outStream != System . err ) { this . outStream . close ( ) ; this . outStream = null ; } } else if ( this . inStream != null ) { if ( this . inStream != System . in ) { this . inStream . close ( ) ; this . inStream = null ; } } } } 	1	['21', '1', '0', '2', '36', '38', '2', '0', '17', '0.631818182', '620', '0.818181818', '0', '0', '0.293650794', '0', '0', '28', '3', '0.8571', '1']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . Iterator ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . FileList ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . TimeComparison ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . Sort ; import org . apache . tools . ant . types . resources . Union ; import org . apache . tools . ant . types . resources . Restrict ; import org . apache . tools . ant . types . resources . Resources ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . selectors . Not ; import org . apache . tools . ant . types . resources . selectors . Exists ; import org . apache . tools . ant . types . resources . selectors . ResourceSelector ; import org . apache . tools . ant . types . resources . comparators . Reverse ; import org . apache . tools . ant . types . resources . comparators . ResourceComparator ; public class DependSet extends MatchingTask { private static final ResourceSelector NOT_EXISTS = new Not ( new Exists ( ) ) ; private static final ResourceComparator DATE_ASC = new org . apache . tools . ant . types . resources . comparators . Date ( ) ; private static final ResourceComparator DATE_DESC = new Reverse ( DATE_ASC ) ; private static class NonExistent extends Restrict { private NonExistent ( ResourceCollection rc ) { super . add ( rc ) ; super . add ( NOT_EXISTS ) ; } } private static class Xest extends Sort { private Xest ( ResourceCollection rc , ResourceComparator c ) { super . add ( c ) ; super . add ( rc ) ; } } private static class Oldest extends Xest { private Oldest ( ResourceCollection rc ) { super ( rc , DATE_ASC ) ; } } private static class Newest extends Xest { private Newest ( ResourceCollection rc ) { super ( rc , DATE_DESC ) ; } } private static class HideMissingBasedir implements ResourceCollection { private FileSet fs ; private HideMissingBasedir ( FileSet fs ) { this . fs = fs ; } public Iterator iterator ( ) { return basedirExists ( ) ? fs . iterator ( ) : Resources . EMPTY_ITERATOR ; } public int size ( ) { return basedirExists ( ) ? fs . size ( ) : 0 ; } public boolean isFilesystemOnly ( ) { return true ; } private boolean basedirExists ( ) { File basedir = fs . getDir ( ) ; return basedir == null || basedir . exists ( ) ; } } private Union sources = null ; private Path targets = null ; public synchronized Union createSources ( ) { sources = ( sources == null ) ? new Union ( ) : sources ; return sources ; } public void addSrcfileset ( FileSet fs ) { createSources ( ) . add ( fs ) ; } public void addSrcfilelist ( FileList fl ) { createSources ( ) . add ( fl ) ; } public synchronized Path createTargets ( ) { targets = ( targets == null ) ? new Path ( getProject ( ) ) : targets ; return targets ; } public void addTargetfileset ( FileSet fs ) { createTargets ( ) . add ( new HideMissingBasedir ( fs ) ) ; } public void addTargetfilelist ( FileList fl ) { createTargets ( ) . add ( fl ) ; } public void execute ( ) throws BuildException { if ( sources == null ) { throw new BuildException ( "At least one set of source resources must be specified" ) ; } if ( targets == null ) { throw new BuildException ( "At least one set of target files must be specified" ) ; } if ( sources . size ( ) > 0 && targets . size ( ) > 0 && ! uptodate ( sources , targets ) ) { log ( "Deleting all target files." , Project . MSG_VERBOSE ) ; Delete delete = new Delete ( ) ; delete . bindToOwner ( this ) ; delete . add ( targets ) ; delete . perform ( ) ; } } private boolean uptodate ( ResourceCollection src , ResourceCollection target ) { org . apache . tools . ant . types . resources . selectors . Date datesel = new org . apache . tools . ant . types . resources . selectors . Date ( ) ; datesel . setMillis ( System . currentTimeMillis ( ) ) ; datesel . setWhen ( TimeComparison . AFTER ) ; logFuture ( targets , datesel ) ; int neTargets = new NonExistent ( targets ) . size ( ) ; if ( neTargets > 0 ) { log ( neTargets + " nonexistent targets" , Project . MSG_VERBOSE ) ; return false ; } FileResource oldestTarget = ( FileResource ) ( new Oldest ( targets ) . iterator ( ) . next ( ) ) ; log ( oldestTarget + " is oldest target file" , Project . MSG_VERBOSE ) ; logFuture ( sources , datesel ) ; int neSources = new NonExistent ( sources ) . size ( ) ; if ( neSources > 0 ) { log ( neSources + " nonexistent sources" , Project . MSG_VERBOSE ) ; return false ; } Resource newestSource = ( Resource ) ( new Newest ( sources ) . iterator ( ) . next ( ) ) ; log ( newestSource . toLongString ( ) + " is newest source" , Project . MSG_VERBOSE ) ; return oldestTarget . getLastModified ( ) >= newestSource . getLastModified ( ) ; } private void logFuture ( ResourceCollection rc , ResourceSelector rsel ) { Restrict r = new Restrict ( ) ; r . add ( rsel ) ; r . add ( rc ) ; for ( Iterator i = r . iterator ( ) ; i . hasNext ( ) ; ) { log ( "Warning: " + i . next ( ) + " modified in the future." , Project . MSG_WARN ) ; } } } 	1	['14', '4', '0', '25', '59', '67', '3', '25', '8', '0.8', '304', '1', '5', '0.866666667', '0.261538462', '1', '2', '20.35714286', '4', '1.2857', '3']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Enumeration ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Vector ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . FilterSet ; import org . apache . tools . ant . types . FilterChain ; import org . apache . tools . ant . types . FilterSetCollection ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . ResourceFactory ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . IdentityMapper ; import org . apache . tools . ant . util . ResourceUtils ; import org . apache . tools . ant . util . SourceFileScanner ; import org . apache . tools . ant . util . FlatFileNameMapper ; public class Copy extends Task { static final File NULL_FILE_PLACEHOLDER = new File ( "/NULL_FILE" ) ; static final String LINE_SEPARATOR = System . getProperty ( "line.separator" ) ; protected File file = null ; protected File destFile = null ; protected File destDir = null ; protected Vector rcs = new Vector ( ) ; private boolean enableMultipleMappings = false ; protected boolean filtering = false ; protected boolean preserveLastModified = false ; protected boolean forceOverwrite = false ; protected boolean flatten = false ; protected int verbosity = Project . MSG_VERBOSE ; protected boolean includeEmpty = true ; protected boolean failonerror = true ; protected Hashtable fileCopyMap = new Hashtable ( ) ; protected Hashtable dirCopyMap = new Hashtable ( ) ; protected Hashtable completeDirMap = new Hashtable ( ) ; protected Mapper mapperElement = null ; protected FileUtils fileUtils ; private Vector filterChains = new Vector ( ) ; private Vector filterSets = new Vector ( ) ; private String inputEncoding = null ; private String outputEncoding = null ; private long granularity = 0 ; public Copy ( ) { fileUtils = FileUtils . getFileUtils ( ) ; granularity = fileUtils . getFileTimestampGranularity ( ) ; } protected FileUtils getFileUtils ( ) { return fileUtils ; } public void setFile ( File file ) { this . file = file ; } public void setTofile ( File destFile ) { this . destFile = destFile ; } public void setTodir ( File destDir ) { this . destDir = destDir ; } public FilterChain createFilterChain ( ) { FilterChain filterChain = new FilterChain ( ) ; filterChains . addElement ( filterChain ) ; return filterChain ; } public FilterSet createFilterSet ( ) { FilterSet filterSet = new FilterSet ( ) ; filterSets . addElement ( filterSet ) ; return filterSet ; } public void setPreserveLastModified ( String preserve ) { setPreserveLastModified ( Project . toBoolean ( preserve ) ) ; } public void setPreserveLastModified ( boolean preserve ) { preserveLastModified = preserve ; } public boolean getPreserveLastModified ( ) { return preserveLastModified ; } protected Vector getFilterSets ( ) { return filterSets ; } protected Vector getFilterChains ( ) { return filterChains ; } public void setFiltering ( boolean filtering ) { this . filtering = filtering ; } public void setOverwrite ( boolean overwrite ) { this . forceOverwrite = overwrite ; } public void setFlatten ( boolean flatten ) { this . flatten = flatten ; } public void setVerbose ( boolean verbose ) { this . verbosity = verbose ? Project . MSG_INFO : Project . MSG_VERBOSE ; } public void setIncludeEmptyDirs ( boolean includeEmpty ) { this . includeEmpty = includeEmpty ; } public void setEnableMultipleMappings ( boolean enableMultipleMappings ) { this . enableMultipleMappings = enableMultipleMappings ; } public boolean isEnableMultipleMapping ( ) { return enableMultipleMappings ; } public void setFailOnError ( boolean failonerror ) { this . failonerror = failonerror ; } public void addFileset ( FileSet set ) { add ( set ) ; } public void add ( ResourceCollection res ) { rcs . add ( res ) ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" , getLocation ( ) ) ; } mapperElement = new Mapper ( getProject ( ) ) ; return mapperElement ; } public void add ( FileNameMapper fileNameMapper ) { createMapper ( ) . add ( fileNameMapper ) ; } public void setEncoding ( String encoding ) { this . inputEncoding = encoding ; if ( outputEncoding == null ) { outputEncoding = encoding ; } } public String getEncoding ( ) { return inputEncoding ; } public void setOutputEncoding ( String encoding ) { this . outputEncoding = encoding ; } public String getOutputEncoding ( ) { return outputEncoding ; } public void setGranularity ( long granularity ) { this . granularity = granularity ; } public void execute ( ) throws BuildException { File savedFile = file ; File savedDestFile = destFile ; File savedDestDir = destDir ; ResourceCollection savedRc = null ; if ( file == null && destFile != null && rcs . size ( ) == 1 ) { savedRc = ( ResourceCollection ) rcs . elementAt ( 0 ) ; } validateAttributes ( ) ; try { if ( file != null ) { if ( file . exists ( ) ) { if ( destFile == null ) { destFile = new File ( destDir , file . getName ( ) ) ; } if ( forceOverwrite || ! destFile . exists ( ) || ( file . lastModified ( ) - granularity > destFile . lastModified ( ) ) ) { fileCopyMap . put ( file . getAbsolutePath ( ) , new String [ ] { destFile . getAbsolutePath ( ) } ) ; } else { log ( file + " omitted as " + destFile + " is up to date." , Project . MSG_VERBOSE ) ; } } else { String message = "Warning: Could not find file " + file . getAbsolutePath ( ) + " to copy." ; if ( ! failonerror ) { log ( message , Project . MSG_ERR ) ; } else { throw new BuildException ( message ) ; } } } HashMap filesByBasedir = new HashMap ( ) ; HashMap dirsByBasedir = new HashMap ( ) ; HashSet baseDirs = new HashSet ( ) ; ArrayList nonFileResources = new ArrayList ( ) ; for ( int i = 0 ; i < rcs . size ( ) ; i ++ ) { ResourceCollection rc = ( ResourceCollection ) rcs . elementAt ( i ) ; if ( rc instanceof FileSet && rc . isFilesystemOnly ( ) ) { FileSet fs = ( FileSet ) rc ; DirectoryScanner ds = null ; try { ds = fs . getDirectoryScanner ( getProject ( ) ) ; } catch ( BuildException e ) { if ( failonerror || ! getMessage ( e ) . endsWith ( " not found." ) ) { throw e ; } else { log ( "Warning: " + getMessage ( e ) , Project . MSG_ERR ) ; continue ; } } File fromDir = fs . getDir ( getProject ( ) ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; String [ ] srcDirs = ds . getIncludedDirectories ( ) ; if ( ! flatten && mapperElement == null && ds . isEverythingIncluded ( ) && ! fs . hasPatterns ( ) ) { completeDirMap . put ( fromDir , destDir ) ; } add ( fromDir , srcFiles , filesByBasedir ) ; add ( fromDir , srcDirs , dirsByBasedir ) ; baseDirs . add ( fromDir ) ; } else { if ( ! rc . isFilesystemOnly ( ) && ! supportsNonFileResources ( ) ) { throw new BuildException ( "Only FileSystem resources are supported." ) ; } Iterator resources = rc . iterator ( ) ; while ( resources . hasNext ( ) ) { Resource r = ( Resource ) resources . next ( ) ; if ( ! r . isExists ( ) ) { continue ; } File baseDir = NULL_FILE_PLACEHOLDER ; String name = r . getName ( ) ; if ( r instanceof FileResource ) { FileResource fr = ( FileResource ) r ; baseDir = getKeyFile ( fr . getBaseDir ( ) ) ; if ( fr . getBaseDir ( ) == null ) { name = fr . getFile ( ) . getAbsolutePath ( ) ; } } if ( r . isDirectory ( ) || r instanceof FileResource ) { add ( baseDir , name , r . isDirectory ( ) ? dirsByBasedir : filesByBasedir ) ; baseDirs . add ( baseDir ) ; } else { nonFileResources . add ( r ) ; } } } } Iterator iter = baseDirs . iterator ( ) ; while ( iter . hasNext ( ) ) { File f = ( File ) iter . next ( ) ; List files = ( List ) filesByBasedir . get ( f ) ; List dirs = ( List ) dirsByBasedir . get ( f ) ; String [ ] srcFiles = new String [ 0 ] ; if ( files != null ) { srcFiles = ( String [ ] ) files . toArray ( srcFiles ) ; } String [ ] srcDirs = new String [ 0 ] ; if ( dirs != null ) { srcDirs = ( String [ ] ) dirs . toArray ( srcDirs ) ; } scan ( f == NULL_FILE_PLACEHOLDER ? null : f , destDir , srcFiles , srcDirs ) ; } try { doFileOperations ( ) ; } catch ( BuildException e ) { if ( ! failonerror ) { log ( "Warning: " + getMessage ( e ) , Project . MSG_ERR ) ; } else { throw e ; } } if ( nonFileResources . size ( ) > 0 ) { Resource [ ] nonFiles = ( Resource [ ] ) nonFileResources . toArray ( new Resource [ nonFileResources . size ( ) ] ) ; Map map = scan ( nonFiles , destDir ) ; try { doResourceOperations ( map ) ; } catch ( BuildException e ) { if ( ! failonerror ) { log ( "Warning: " + getMessage ( e ) , Project . MSG_ERR ) ; } else { throw e ; } } } } finally { file = savedFile ; destFile = savedDestFile ; destDir = savedDestDir ; if ( savedRc != null ) { rcs . insertElementAt ( savedRc , 0 ) ; } fileCopyMap . clear ( ) ; dirCopyMap . clear ( ) ; completeDirMap . clear ( ) ; } } protected void validateAttributes ( ) throws BuildException { if ( file == null && rcs . size ( ) == 0 ) { throw new BuildException ( "Specify at least one source--a file or a resource collection." ) ; } if ( destFile != null && destDir != null ) { throw new BuildException ( "Only one of tofile and todir may be set." ) ; } if ( destFile == null && destDir == null ) { throw new BuildException ( "One of tofile or todir must be set." ) ; } if ( file != null && file . isDirectory ( ) ) { throw new BuildException ( "Use a resource collection to copy directories." ) ; } if ( destFile != null && rcs . size ( ) > 0 ) { if ( rcs . size ( ) > 1 ) { throw new BuildException ( "Cannot concatenate multiple files into a single file." ) ; } else { ResourceCollection rc = ( ResourceCollection ) rcs . elementAt ( 0 ) ; if ( ! rc . isFilesystemOnly ( ) ) { throw new BuildException ( "Only FileSystem resources are" + " supported when concatenating" + " files." ) ; } if ( rc . size ( ) == 0 ) { throw new BuildException ( "Cannot perform operation from directory to file." ) ; } else if ( rc . size ( ) == 1 ) { FileResource r = ( FileResource ) rc . iterator ( ) . next ( ) ; if ( file == null ) { file = r . getFile ( ) ; rcs . removeElementAt ( 0 ) ; } else { throw new BuildException ( "Cannot concatenate multiple files into a single file." ) ; } } else { throw new BuildException ( "Cannot concatenate multiple files into a single file." ) ; } } } if ( destFile != null ) { destDir = destFile . getParentFile ( ) ; } } protected void scan ( File fromDir , File toDir , String [ ] files , String [ ] dirs ) { FileNameMapper mapper = getMapper ( ) ; buildMap ( fromDir , toDir , files , mapper , fileCopyMap ) ; if ( includeEmpty ) { buildMap ( fromDir , toDir , dirs , mapper , dirCopyMap ) ; } } protected Map scan ( Resource [ ] fromResources , File toDir ) { return buildMap ( fromResources , toDir , getMapper ( ) ) ; } protected void buildMap ( File fromDir , File toDir , String [ ] names , FileNameMapper mapper , Hashtable map ) { String [ ] toCopy = null ; if ( forceOverwrite ) { Vector v = new Vector ( ) ; for ( int i = 0 ; i < names . length ; i ++ ) { if ( mapper . mapFileName ( names [ i ] ) != null ) { v . addElement ( names [ i ] ) ; } } toCopy = new String [ v . size ( ) ] ; v . copyInto ( toCopy ) ; } else { SourceFileScanner ds = new SourceFileScanner ( this ) ; toCopy = ds . restrict ( names , fromDir , toDir , mapper , granularity ) ; } for ( int i = 0 ; i < toCopy . length ; i ++ ) { File src = new File ( fromDir , toCopy [ i ] ) ; String [ ] mappedFiles = mapper . mapFileName ( toCopy [ i ] ) ; if ( ! enableMultipleMappings ) { map . put ( src . getAbsolutePath ( ) , new String [ ] { new File ( toDir , mappedFiles [ 0 ] ) . getAbsolutePath ( ) } ) ; } else { for ( int k = 0 ; k < mappedFiles . length ; k ++ ) { mappedFiles [ k ] = new File ( toDir , mappedFiles [ k ] ) . getAbsolutePath ( ) ; } map . put ( src . getAbsolutePath ( ) , mappedFiles ) ; } } } protected Map buildMap ( Resource [ ] fromResources , final File toDir , FileNameMapper mapper ) { HashMap map = new HashMap ( ) ; Resource [ ] toCopy = null ; if ( forceOverwrite ) { Vector v = new Vector ( ) ; for ( int i = 0 ; i < fromResources . length ; i ++ ) { if ( mapper . mapFileName ( fromResources [ i ] . getName ( ) ) != null ) { v . addElement ( fromResources [ i ] ) ; } } toCopy = new Resource [ v . size ( ) ] ; v . copyInto ( toCopy ) ; } else { toCopy = ResourceUtils . selectOutOfDateSources ( this , fromResources , mapper , new ResourceFactory ( ) { public Resource getResource ( String name ) { return new FileResource ( toDir , name ) ; } } , granularity ) ; } for ( int i = 0 ; i < toCopy . length ; i ++ ) { String [ ] mappedFiles = mapper . mapFileName ( toCopy [ i ] . getName ( ) ) ; if ( ! enableMultipleMappings ) { map . put ( toCopy [ i ] , new String [ ] { new File ( toDir , mappedFiles [ 0 ] ) . getAbsolutePath ( ) } ) ; } else { for ( int k = 0 ; k < mappedFiles . length ; k ++ ) { mappedFiles [ k ] = new File ( toDir , mappedFiles [ k ] ) . getAbsolutePath ( ) ; } map . put ( toCopy [ i ] , mappedFiles ) ; } } return map ; } protected void doFileOperations ( ) { if ( fileCopyMap . size ( ) > 0 ) { log ( "Copying " + fileCopyMap . size ( ) + " file" + ( fileCopyMap . size ( ) == 1 ? "" : "s" ) + " to " + destDir . getAbsolutePath ( ) ) ; Enumeration e = fileCopyMap . keys ( ) ; while ( e . hasMoreElements ( ) ) { String fromFile = ( String ) e . nextElement ( ) ; String [ ] toFiles = ( String [ ] ) fileCopyMap . get ( fromFile ) ; for ( int i = 0 ; i < toFiles . length ; i ++ ) { String toFile = toFiles [ i ] ; if ( fromFile . equals ( toFile ) ) { log ( "Skipping self-copy of " + fromFile , verbosity ) ; continue ; } try { log ( "Copying " + fromFile + " to " + toFile , verbosity ) ; FilterSetCollection executionFilters = new FilterSetCollection ( ) ; if ( filtering ) { executionFilters . addFilterSet ( getProject ( ) . getGlobalFilterSet ( ) ) ; } for ( Enumeration filterEnum = filterSets . elements ( ) ; filterEnum . hasMoreElements ( ) ; ) { executionFilters . addFilterSet ( ( FilterSet ) filterEnum . nextElement ( ) ) ; } fileUtils . copyFile ( fromFile , toFile , executionFilters , filterChains , forceOverwrite , preserveLastModified , inputEncoding , outputEncoding , getProject ( ) ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + fromFile + " to " + toFile + " due to " + getDueTo ( ioe ) ; File targetFile = new File ( toFile ) ; if ( targetFile . exists ( ) && ! targetFile . delete ( ) ) { msg += " and I couldn't delete the corrupt " + toFile ; } if ( failonerror ) { throw new BuildException ( msg , ioe , getLocation ( ) ) ; } log ( msg , Project . MSG_ERR ) ; } } } } if ( includeEmpty ) { Enumeration e = dirCopyMap . elements ( ) ; int createCount = 0 ; while ( e . hasMoreElements ( ) ) { String [ ] dirs = ( String [ ] ) e . nextElement ( ) ; for ( int i = 0 ; i < dirs . length ; i ++ ) { File d = new File ( dirs [ i ] ) ; if ( ! d . exists ( ) ) { if ( ! d . mkdirs ( ) ) { log ( "Unable to create directory " + d . getAbsolutePath ( ) , Project . MSG_ERR ) ; } else { createCount ++ ; } } } } if ( createCount > 0 ) { log ( "Copied " + dirCopyMap . size ( ) + " empty director" + ( dirCopyMap . size ( ) == 1 ? "y" : "ies" ) + " to " + createCount + " empty director" + ( createCount == 1 ? "y" : "ies" ) + " under " + destDir . getAbsolutePath ( ) ) ; } } } protected void doResourceOperations ( Map map ) { if ( map . size ( ) > 0 ) { log ( "Copying " + map . size ( ) + " resource" + ( map . size ( ) == 1 ? "" : "s" ) + " to " + destDir . getAbsolutePath ( ) ) ; Iterator iter = map . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Resource fromResource = ( Resource ) iter . next ( ) ; String [ ] toFiles = ( String [ ] ) map . get ( fromResource ) ; for ( int i = 0 ; i < toFiles . length ; i ++ ) { String toFile = toFiles [ i ] ; try { log ( "Copying " + fromResource + " to " + toFile , verbosity ) ; FilterSetCollection executionFilters = new FilterSetCollection ( ) ; if ( filtering ) { executionFilters . addFilterSet ( getProject ( ) . getGlobalFilterSet ( ) ) ; } for ( Enumeration filterEnum = filterSets . elements ( ) ; filterEnum . hasMoreElements ( ) ; ) { executionFilters . addFilterSet ( ( FilterSet ) filterEnum . nextElement ( ) ) ; } ResourceUtils . copyResource ( fromResource , new FileResource ( destDir , toFile ) , executionFilters , filterChains , forceOverwrite , preserveLastModified , inputEncoding , outputEncoding , getProject ( ) ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + fromResource + " to " + toFile + " due to " + getDueTo ( ioe ) ; File targetFile = new File ( toFile ) ; if ( targetFile . exists ( ) && ! targetFile . delete ( ) ) { msg += " and I couldn't delete the corrupt " + toFile ; } if ( failonerror ) { throw new BuildException ( msg , ioe , getLocation ( ) ) ; } log ( msg , Project . MSG_ERR ) ; } } } } } protected boolean supportsNonFileResources ( ) { return getClass ( ) . equals ( Copy . class ) ; } private static void add ( File baseDir , String [ ] names , Map m ) { if ( names != null ) { baseDir = getKeyFile ( baseDir ) ; List l = ( List ) m . get ( baseDir ) ; if ( l == null ) { l = new ArrayList ( names . length ) ; m . put ( baseDir , l ) ; } l . addAll ( java . util . Arrays . asList ( names ) ) ; } } private static void add ( File baseDir , String name , Map m ) { if ( name != null ) { add ( baseDir , new String [ ] { name } , m ) ; } } private static File getKeyFile ( File f ) { return f == null ? NULL_FILE_PLACEHOLDER : f ; } private FileNameMapper getMapper ( ) { FileNameMapper mapper = null ; if ( mapperElement != null ) { mapper = mapperElement . getImplementation ( ) ; } else if ( flatten ) { mapper = new FlatFileNameMapper ( ) ; } else { mapper = new IdentityMapper ( ) ; } return mapper ; } private String getMessage ( Exception ex ) { return ex . getMessage ( ) == null ? ex . toString ( ) : ex . getMessage ( ) ; } private String getDueTo ( Exception ex ) { boolean baseIOException = ex . getClass ( ) == IOException . class ; StringBuffer message = new StringBuffer ( ) ; if ( ! baseIOException || ex . getMessage ( ) == null ) { message . append ( ex . getClass ( ) . getName ( ) ) ; } if ( ex . getMessage ( ) != null ) { if ( ! baseIOException ) { message . append ( " " ) ; } message . append ( ex . getMessage ( ) ) ; } if ( ex . getClass ( ) . getName ( ) . indexOf ( "MalformedInput" ) != - 1 ) { message . append ( LINE_SEPARATOR ) ; message . append ( "This is normally due to the input file containing invalid" ) ; message . append ( LINE_SEPARATOR ) ; message . append ( "bytes for the character encoding used : " ) ; message . append ( ( inputEncoding == null ? fileUtils . getDefaultEncoding ( ) : inputEncoding ) ) ; message . append ( LINE_SEPARATOR ) ; } return message . toString ( ) ; } } 	1	['45', '3', '2', '25', '157', '744', '4', '22', '27', '0.902097902', '1828', '0.846153846', '2', '0.4625', '0.13986014', '1', '1', '39.04444444', '19', '2.2444', '5']
package org . apache . tools . ant . util ; import java . util . Vector ; import java . util . Iterator ; import java . util . Dictionary ; import java . util . Enumeration ; import java . util . NoSuchElementException ; public class CollectionUtils { public static boolean equals ( Vector v1 , Vector v2 ) { if ( v1 == v2 ) { return true ; } if ( v1 == null || v2 == null ) { return false ; } return v1 . equals ( v2 ) ; } public static boolean equals ( Dictionary d1 , Dictionary d2 ) { if ( d1 == d2 ) { return true ; } if ( d1 == null || d2 == null ) { return false ; } if ( d1 . size ( ) != d2 . size ( ) ) { return false ; } Enumeration e1 = d1 . keys ( ) ; while ( e1 . hasMoreElements ( ) ) { Object key = e1 . nextElement ( ) ; Object value1 = d1 . get ( key ) ; Object value2 = d2 . get ( key ) ; if ( value2 == null || ! value1 . equals ( value2 ) ) { return false ; } } return true ; } public static void putAll ( Dictionary m1 , Dictionary m2 ) { for ( Enumeration it = m2 . keys ( ) ; it . hasMoreElements ( ) ; ) { Object key = it . nextElement ( ) ; m1 . put ( key , m2 . get ( key ) ) ; } } public static final class EmptyEnumeration implements Enumeration { public EmptyEnumeration ( ) { } public boolean hasMoreElements ( ) { return false ; } public Object nextElement ( ) throws NoSuchElementException { throw new NoSuchElementException ( ) ; } } public static Enumeration append ( Enumeration e1 , Enumeration e2 ) { return new CompoundEnumeration ( e1 , e2 ) ; } public static Enumeration asEnumeration ( final Iterator iter ) { return new Enumeration ( ) { public boolean hasMoreElements ( ) { return iter . hasNext ( ) ; } public Object nextElement ( ) { return iter . next ( ) ; } } ; } public static Iterator asIterator ( final Enumeration e ) { return new Iterator ( ) { public boolean hasNext ( ) { return e . hasMoreElements ( ) ; } public Object next ( ) { return e . nextElement ( ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } private static final class CompoundEnumeration implements Enumeration { private final Enumeration e1 , e2 ; public CompoundEnumeration ( Enumeration e1 , Enumeration e2 ) { this . e1 = e1 ; this . e2 = e2 ; } public boolean hasMoreElements ( ) { return e1 . hasMoreElements ( ) || e2 . hasMoreElements ( ) ; } public Object nextElement ( ) throws NoSuchElementException { if ( e1 . hasMoreElements ( ) ) { return e1 . nextElement ( ) ; } else { return e2 . nextElement ( ) ; } } } } 	1	['7', '1', '0', '5', '19', '21', '2', '3', '7', '2', '105', '0', '0', '0', '0.2', '1', '1', '14', '8', '2.4286', '4']
package org . apache . tools . ant ; import java . io . File ; import java . io . IOException ; import java . io . EOFException ; import java . io . InputStream ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . Collections ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . Properties ; import java . util . Stack ; import java . util . Vector ; import java . util . Set ; import java . util . HashSet ; import java . util . HashMap ; import java . util . Map ; import java . util . WeakHashMap ; import org . apache . tools . ant . input . DefaultInputHandler ; import org . apache . tools . ant . input . InputHandler ; import org . apache . tools . ant . helper . DefaultExecutor ; import org . apache . tools . ant . types . FilterSet ; import org . apache . tools . ant . types . FilterSetCollection ; import org . apache . tools . ant . types . Description ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceFactory ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . apache . tools . ant . util . StringUtils ; public class Project implements ResourceFactory { private static final String LINE_SEP = System . getProperty ( "line.separator" ) ; public static final int MSG_ERR = 0 ; public static final int MSG_WARN = 1 ; public static final int MSG_INFO = 2 ; public static final int MSG_VERBOSE = 3 ; public static final int MSG_DEBUG = 4 ; private static final String VISITING = "VISITING" ; private static final String VISITED = "VISITED" ; public static final String JAVA_1_0 = JavaEnvUtils . JAVA_1_0 ; public static final String JAVA_1_1 = JavaEnvUtils . JAVA_1_1 ; public static final String JAVA_1_2 = JavaEnvUtils . JAVA_1_2 ; public static final String JAVA_1_3 = JavaEnvUtils . JAVA_1_3 ; public static final String JAVA_1_4 = JavaEnvUtils . JAVA_1_4 ; public static final String TOKEN_START = FilterSet . DEFAULT_TOKEN_START ; public static final String TOKEN_END = FilterSet . DEFAULT_TOKEN_END ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private String name ; private String description ; private Hashtable references = new AntRefTable ( ) ; private HashMap idReferences = new HashMap ( ) ; private Project parentIdProject = null ; private String defaultTarget ; private Hashtable targets = new Hashtable ( ) ; private FilterSet globalFilterSet = new FilterSet ( ) ; { globalFilterSet . setProject ( this ) ; } private FilterSetCollection globalFilters = new FilterSetCollection ( globalFilterSet ) ; private File baseDir ; private Vector listeners = new Vector ( ) ; private ClassLoader coreLoader = null ; private Map threadTasks = Collections . synchronizedMap ( new WeakHashMap ( ) ) ; private Map threadGroupTasks = Collections . synchronizedMap ( new WeakHashMap ( ) ) ; private InputHandler inputHandler = null ; private InputStream defaultInputStream = null ; private boolean keepGoingMode = false ; private boolean loggingMessage = false ; public void setInputHandler ( InputHandler handler ) { inputHandler = handler ; } public void setDefaultInputStream ( InputStream defaultInputStream ) { this . defaultInputStream = defaultInputStream ; } public InputStream getDefaultInputStream ( ) { return defaultInputStream ; } public InputHandler getInputHandler ( ) { return inputHandler ; } public Project ( ) { inputHandler = new DefaultInputHandler ( ) ; } public Project createSubProject ( ) { Project subProject = null ; try { subProject = ( Project ) ( getClass ( ) . newInstance ( ) ) ; } catch ( Exception e ) { subProject = new Project ( ) ; } initSubProject ( subProject ) ; return subProject ; } public void initSubProject ( Project subProject ) { ComponentHelper . getComponentHelper ( subProject ) . initSubProject ( ComponentHelper . getComponentHelper ( this ) ) ; subProject . setDefaultInputStream ( getDefaultInputStream ( ) ) ; subProject . setKeepGoingMode ( this . isKeepGoingMode ( ) ) ; subProject . setExecutor ( getExecutor ( ) . getSubProjectExecutor ( ) ) ; } public void init ( ) throws BuildException { initProperties ( ) ; ComponentHelper . getComponentHelper ( this ) . initDefaultDefinitions ( ) ; } public void initProperties ( ) throws BuildException { setJavaVersionProperty ( ) ; setSystemProperties ( ) ; setPropertyInternal ( MagicNames . ANT_VERSION , Main . getAntVersion ( ) ) ; setAntLib ( ) ; } private void setAntLib ( ) { File antlib = org . apache . tools . ant . launch . Locator . getClassSource ( Project . class ) ; if ( antlib != null ) { setPropertyInternal ( MagicNames . ANT_LIB , antlib . getAbsolutePath ( ) ) ; } } public AntClassLoader createClassLoader ( Path path ) { return new AntClassLoader ( getClass ( ) . getClassLoader ( ) , this , path ) ; } public AntClassLoader createClassLoader ( ClassLoader parent , Path path ) { return new AntClassLoader ( parent , this , path ) ; } public void setCoreLoader ( ClassLoader coreLoader ) { this . coreLoader = coreLoader ; } public ClassLoader getCoreLoader ( ) { return coreLoader ; } public synchronized void addBuildListener ( BuildListener listener ) { if ( listeners . contains ( listener ) ) { return ; } Vector newListeners = getBuildListeners ( ) ; newListeners . addElement ( listener ) ; listeners = newListeners ; } public synchronized void removeBuildListener ( BuildListener listener ) { Vector newListeners = getBuildListeners ( ) ; newListeners . removeElement ( listener ) ; listeners = newListeners ; } public Vector getBuildListeners ( ) { return ( Vector ) listeners . clone ( ) ; } public void log ( String message ) { log ( message , MSG_INFO ) ; } public void log ( String message , int msgLevel ) { log ( message , null , msgLevel ) ; } public void log ( String message , Throwable throwable , int msgLevel ) { fireMessageLogged ( this , message , throwable , msgLevel ) ; } public void log ( Task task , String message , int msgLevel ) { fireMessageLogged ( task , message , null , msgLevel ) ; } public void log ( Task task , String message , Throwable throwable , int msgLevel ) { fireMessageLogged ( task , message , throwable , msgLevel ) ; } public void log ( Target target , String message , int msgLevel ) { log ( target , message , null , msgLevel ) ; } public void log ( Target target , String message , Throwable throwable , int msgLevel ) { fireMessageLogged ( target , message , throwable , msgLevel ) ; } public FilterSet getGlobalFilterSet ( ) { return globalFilterSet ; } public void setProperty ( String name , String value ) { PropertyHelper . getPropertyHelper ( this ) . setProperty ( null , name , value , true ) ; } public void setNewProperty ( String name , String value ) { PropertyHelper . getPropertyHelper ( this ) . setNewProperty ( null , name , value ) ; } public void setUserProperty ( String name , String value ) { PropertyHelper . getPropertyHelper ( this ) . setUserProperty ( null , name , value ) ; } public void setInheritedProperty ( String name , String value ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; ph . setInheritedProperty ( null , name , value ) ; } private void setPropertyInternal ( String name , String value ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; ph . setProperty ( null , name , value , false ) ; } public String getProperty ( String propertyName ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; return ( String ) ph . getProperty ( null , propertyName ) ; } public String replaceProperties ( String value ) throws BuildException { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; return ph . replaceProperties ( null , value , null ) ; } public String getUserProperty ( String propertyName ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; return ( String ) ph . getUserProperty ( null , propertyName ) ; } public Hashtable getProperties ( ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; return ph . getProperties ( ) ; } public Hashtable getUserProperties ( ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; return ph . getUserProperties ( ) ; } public void copyUserProperties ( Project other ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; ph . copyUserProperties ( other ) ; } public void copyInheritedProperties ( Project other ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; ph . copyInheritedProperties ( other ) ; } public void setDefaultTarget ( String defaultTarget ) { this . defaultTarget = defaultTarget ; } public String getDefaultTarget ( ) { return defaultTarget ; } public void setDefault ( String defaultTarget ) { this . defaultTarget = defaultTarget ; } public void setName ( String name ) { setUserProperty ( "ant.project.name" , name ) ; this . name = name ; } public String getName ( ) { return name ; } public void setDescription ( String description ) { this . description = description ; } public String getDescription ( ) { if ( description == null ) { description = Description . getDescription ( this ) ; } return description ; } public void addFilter ( String token , String value ) { if ( token == null ) { return ; } globalFilterSet . addFilter ( new FilterSet . Filter ( token , value ) ) ; } public Hashtable getFilters ( ) { return globalFilterSet . getFilterHash ( ) ; } public void setBasedir ( String baseD ) throws BuildException { setBaseDir ( new File ( baseD ) ) ; } public void setBaseDir ( File baseDir ) throws BuildException { baseDir = FILE_UTILS . normalize ( baseDir . getAbsolutePath ( ) ) ; if ( ! baseDir . exists ( ) ) { throw new BuildException ( "Basedir " + baseDir . getAbsolutePath ( ) + " does not exist" ) ; } if ( ! baseDir . isDirectory ( ) ) { throw new BuildException ( "Basedir " + baseDir . getAbsolutePath ( ) + " is not a directory" ) ; } this . baseDir = baseDir ; setPropertyInternal ( MagicNames . PROJECT_BASEDIR , this . baseDir . getPath ( ) ) ; String msg = "Project base dir set to: " + this . baseDir ; log ( msg , MSG_VERBOSE ) ; } public File getBaseDir ( ) { if ( baseDir == null ) { try { setBasedir ( "." ) ; } catch ( BuildException ex ) { ex . printStackTrace ( ) ; } } return baseDir ; } public void setKeepGoingMode ( boolean keepGoingMode ) { this . keepGoingMode = keepGoingMode ; } public boolean isKeepGoingMode ( ) { return this . keepGoingMode ; } public static String getJavaVersion ( ) { return JavaEnvUtils . getJavaVersion ( ) ; } public void setJavaVersionProperty ( ) throws BuildException { String javaVersion = JavaEnvUtils . getJavaVersion ( ) ; setPropertyInternal ( MagicNames . ANT_JAVA_VERSION , javaVersion ) ; if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_0 ) || JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { throw new BuildException ( "Ant cannot work on Java 1.0 / 1.1" ) ; } log ( "Detected Java version: " + javaVersion + " in: " + System . getProperty ( "java.home" ) , MSG_VERBOSE ) ; log ( "Detected OS: " + System . getProperty ( "os.name" ) , MSG_VERBOSE ) ; } public void setSystemProperties ( ) { Properties systemP = System . getProperties ( ) ; Enumeration e = systemP . propertyNames ( ) ; while ( e . hasMoreElements ( ) ) { String propertyName = ( String ) e . nextElement ( ) ; String value = systemP . getProperty ( propertyName ) ; this . setPropertyInternal ( propertyName , value ) ; } } public void addTaskDefinition ( String taskName , Class taskClass ) throws BuildException { ComponentHelper . getComponentHelper ( this ) . addTaskDefinition ( taskName , taskClass ) ; } public void checkTaskClass ( final Class taskClass ) throws BuildException { ComponentHelper . getComponentHelper ( this ) . checkTaskClass ( taskClass ) ; if ( ! Modifier . isPublic ( taskClass . getModifiers ( ) ) ) { final String message = taskClass + " is not public" ; log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } if ( Modifier . isAbstract ( taskClass . getModifiers ( ) ) ) { final String message = taskClass + " is abstract" ; log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } try { taskClass . getConstructor ( ( Class [ ] ) null ) ; } catch ( NoSuchMethodException e ) { final String message = "No public no-arg constructor in " + taskClass ; log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } catch ( LinkageError e ) { String message = "Could not load " + taskClass + ": " + e ; log ( message , Project . MSG_ERR ) ; throw new BuildException ( message , e ) ; } if ( ! Task . class . isAssignableFrom ( taskClass ) ) { TaskAdapter . checkTaskClass ( taskClass , this ) ; } } public Hashtable getTaskDefinitions ( ) { return ComponentHelper . getComponentHelper ( this ) . getTaskDefinitions ( ) ; } public void addDataTypeDefinition ( String typeName , Class typeClass ) { ComponentHelper . getComponentHelper ( this ) . addDataTypeDefinition ( typeName , typeClass ) ; } public Hashtable getDataTypeDefinitions ( ) { return ComponentHelper . getComponentHelper ( this ) . getDataTypeDefinitions ( ) ; } public void addTarget ( Target target ) throws BuildException { addTarget ( target . getName ( ) , target ) ; } public void addTarget ( String targetName , Target target ) throws BuildException { if ( targets . get ( targetName ) != null ) { throw new BuildException ( "Duplicate target: `" + targetName + "'" ) ; } addOrReplaceTarget ( targetName , target ) ; } public void addOrReplaceTarget ( Target target ) { addOrReplaceTarget ( target . getName ( ) , target ) ; } public void addOrReplaceTarget ( String targetName , Target target ) { String msg = " +Target: " + targetName ; log ( msg , MSG_DEBUG ) ; target . setProject ( this ) ; targets . put ( targetName , target ) ; } public Hashtable getTargets ( ) { return targets ; } public Task createTask ( String taskType ) throws BuildException { return ComponentHelper . getComponentHelper ( this ) . createTask ( taskType ) ; } public Object createDataType ( String typeName ) throws BuildException { return ComponentHelper . getComponentHelper ( this ) . createDataType ( typeName ) ; } public void setExecutor ( Executor e ) { addReference ( MagicNames . ANT_EXECUTOR_REFERENCE , e ) ; } public Executor getExecutor ( ) { Object o = getReference ( MagicNames . ANT_EXECUTOR_REFERENCE ) ; if ( o == null ) { String classname = getProperty ( MagicNames . ANT_EXECUTOR_CLASSNAME ) ; if ( classname == null ) { classname = DefaultExecutor . class . getName ( ) ; } log ( "Attempting to create object of type " + classname , MSG_DEBUG ) ; try { o = Class . forName ( classname , true , coreLoader ) . newInstance ( ) ; } catch ( ClassNotFoundException seaEnEfEx ) { try { o = Class . forName ( classname ) . newInstance ( ) ; } catch ( Exception ex ) { log ( ex . toString ( ) , MSG_ERR ) ; } } catch ( Exception ex ) { log ( ex . toString ( ) , MSG_ERR ) ; } if ( o == null ) { throw new BuildException ( "Unable to obtain a Target Executor instance." ) ; } setExecutor ( ( Executor ) o ) ; } return ( Executor ) o ; } public void executeTargets ( Vector names ) throws BuildException { getExecutor ( ) . executeTargets ( this , ( String [ ] ) ( names . toArray ( new String [ names . size ( ) ] ) ) ) ; } public void demuxOutput ( String output , boolean isWarning ) { Task task = getThreadTask ( Thread . currentThread ( ) ) ; if ( task == null ) { log ( output , isWarning ? MSG_WARN : MSG_INFO ) ; } else { if ( isWarning ) { task . handleErrorOutput ( output ) ; } else { task . handleOutput ( output ) ; } } } public int defaultInput ( byte [ ] buffer , int offset , int length ) throws IOException { if ( defaultInputStream != null ) { System . out . flush ( ) ; return defaultInputStream . read ( buffer , offset , length ) ; } else { throw new EOFException ( "No input provided for project" ) ; } } public int demuxInput ( byte [ ] buffer , int offset , int length ) throws IOException { Task task = getThreadTask ( Thread . currentThread ( ) ) ; if ( task == null ) { return defaultInput ( buffer , offset , length ) ; } else { return task . handleInput ( buffer , offset , length ) ; } } public void demuxFlush ( String output , boolean isError ) { Task task = getThreadTask ( Thread . currentThread ( ) ) ; if ( task == null ) { fireMessageLogged ( this , output , isError ? MSG_ERR : MSG_INFO ) ; } else { if ( isError ) { task . handleErrorFlush ( output ) ; } else { task . handleFlush ( output ) ; } } } public void executeTarget ( String targetName ) throws BuildException { if ( targetName == null ) { String msg = "No target specified" ; throw new BuildException ( msg ) ; } executeSortedTargets ( topoSort ( targetName , targets , false ) ) ; } public void executeSortedTargets ( Vector sortedTargets ) throws BuildException { Set succeededTargets = new HashSet ( ) ; BuildException buildException = null ; for ( Enumeration iter = sortedTargets . elements ( ) ; iter . hasMoreElements ( ) ; ) { Target curtarget = ( Target ) iter . nextElement ( ) ; boolean canExecute = true ; for ( Enumeration depIter = curtarget . getDependencies ( ) ; depIter . hasMoreElements ( ) ; ) { String dependencyName = ( ( String ) depIter . nextElement ( ) ) ; if ( ! succeededTargets . contains ( dependencyName ) ) { canExecute = false ; log ( curtarget , "Cannot execute '" + curtarget . getName ( ) + "' - '" + dependencyName + "' failed or was not executed." , MSG_ERR ) ; break ; } } if ( canExecute ) { Throwable thrownException = null ; try { curtarget . performTasks ( ) ; succeededTargets . add ( curtarget . getName ( ) ) ; } catch ( RuntimeException ex ) { if ( ! ( keepGoingMode ) ) { throw ex ; } thrownException = ex ; } catch ( Throwable ex ) { if ( ! ( keepGoingMode ) ) { throw new BuildException ( ex ) ; } thrownException = ex ; } if ( thrownException != null ) { if ( thrownException instanceof BuildException ) { log ( curtarget , "Target '" + curtarget . getName ( ) + "' failed with message '" + thrownException . getMessage ( ) + "'." , MSG_ERR ) ; if ( buildException == null ) { buildException = ( BuildException ) thrownException ; } } else { log ( curtarget , "Target '" + curtarget . getName ( ) + "' failed with message '" + thrownException . getMessage ( ) + "'." , MSG_ERR ) ; thrownException . printStackTrace ( System . err ) ; if ( buildException == null ) { buildException = new BuildException ( thrownException ) ; } } } } } if ( buildException != null ) { throw buildException ; } } public File resolveFile ( String fileName , File rootDir ) { return FILE_UTILS . resolveFile ( rootDir , fileName ) ; } public File resolveFile ( String fileName ) { return FILE_UTILS . resolveFile ( baseDir , fileName ) ; } public static String translatePath ( String toProcess ) { return FileUtils . translatePath ( toProcess ) ; } public void copyFile ( String sourceFile , String destFile ) throws IOException { FILE_UTILS . copyFile ( sourceFile , destFile ) ; } public void copyFile ( String sourceFile , String destFile , boolean filtering ) throws IOException { FILE_UTILS . copyFile ( sourceFile , destFile , filtering ? globalFilters : null ) ; } public void copyFile ( String sourceFile , String destFile , boolean filtering , boolean overwrite ) throws IOException { FILE_UTILS . copyFile ( sourceFile , destFile , filtering ? globalFilters : null , overwrite ) ; } public void copyFile ( String sourceFile , String destFile , boolean filtering , boolean overwrite , boolean preserveLastModified ) throws IOException { FILE_UTILS . copyFile ( sourceFile , destFile , filtering ? globalFilters : null , overwrite , preserveLastModified ) ; } public void copyFile ( File sourceFile , File destFile ) throws IOException { FILE_UTILS . copyFile ( sourceFile , destFile ) ; } public void copyFile ( File sourceFile , File destFile , boolean filtering ) throws IOException { FILE_UTILS . copyFile ( sourceFile , destFile , filtering ? globalFilters : null ) ; } public void copyFile ( File sourceFile , File destFile , boolean filtering , boolean overwrite ) throws IOException { FILE_UTILS . copyFile ( sourceFile , destFile , filtering ? globalFilters : null , overwrite ) ; } public void copyFile ( File sourceFile , File destFile , boolean filtering , boolean overwrite , boolean preserveLastModified ) throws IOException { FILE_UTILS . copyFile ( sourceFile , destFile , filtering ? globalFilters : null , overwrite , preserveLastModified ) ; } public void setFileLastModified ( File file , long time ) throws BuildException { FILE_UTILS . setFileLastModified ( file , time ) ; log ( "Setting modification time for " + file , MSG_VERBOSE ) ; } public static boolean toBoolean ( String s ) { return ( "on" . equalsIgnoreCase ( s ) || "true" . equalsIgnoreCase ( s ) || "yes" . equalsIgnoreCase ( s ) ) ; } public final Vector topoSort ( String root , Hashtable targetTable ) throws BuildException { return topoSort ( new String [ ] { root } , targetTable , true ) ; } public final Vector topoSort ( String root , Hashtable targetTable , boolean returnAll ) throws BuildException { return topoSort ( new String [ ] { root } , targetTable , returnAll ) ; } public final Vector topoSort ( String [ ] root , Hashtable targetTable , boolean returnAll ) throws BuildException { Vector ret = new Vector ( ) ; Hashtable state = new Hashtable ( ) ; Stack visiting = new Stack ( ) ; for ( int i = 0 ; i < root . length ; i ++ ) { String st = ( String ) ( state . get ( root [ i ] ) ) ; if ( st == null ) { tsort ( root [ i ] , targetTable , state , visiting , ret ) ; } else if ( st == VISITING ) { throw new RuntimeException ( "Unexpected node in visiting state: " + root [ i ] ) ; } } StringBuffer buf = new StringBuffer ( "Build sequence for target(s)" ) ; for ( int j = 0 ; j < root . length ; j ++ ) { buf . append ( ( j == 0 ) ? " `" : ", `" ) . append ( root [ j ] ) . append ( '\'' ) ; } buf . append ( " is " + ret ) ; log ( buf . toString ( ) , MSG_VERBOSE ) ; Vector complete = ( returnAll ) ? ret : new Vector ( ret ) ; for ( Enumeration en = targetTable . keys ( ) ; en . hasMoreElements ( ) ; ) { String curTarget = ( String ) en . nextElement ( ) ; String st = ( String ) state . get ( curTarget ) ; if ( st == null ) { tsort ( curTarget , targetTable , state , visiting , complete ) ; } else if ( st == VISITING ) { throw new RuntimeException ( "Unexpected node in visiting state: " + curTarget ) ; } } log ( "Complete build sequence is " + complete , MSG_VERBOSE ) ; return ret ; } private void tsort ( String root , Hashtable targetTable , Hashtable state , Stack visiting , Vector ret ) throws BuildException { state . put ( root , VISITING ) ; visiting . push ( root ) ; Target target = ( Target ) targetTable . get ( root ) ; if ( target == null ) { StringBuffer sb = new StringBuffer ( "Target \"" ) ; sb . append ( root ) ; sb . append ( "\" does not exist in the project \"" ) ; sb . append ( name ) ; sb . append ( "\". " ) ; visiting . pop ( ) ; if ( ! visiting . empty ( ) ) { String parent = ( String ) visiting . peek ( ) ; sb . append ( "It is used from target \"" ) ; sb . append ( parent ) ; sb . append ( "\"." ) ; } throw new BuildException ( new String ( sb ) ) ; } for ( Enumeration en = target . getDependencies ( ) ; en . hasMoreElements ( ) ; ) { String cur = ( String ) en . nextElement ( ) ; String m = ( String ) state . get ( cur ) ; if ( m == null ) { tsort ( cur , targetTable , state , visiting , ret ) ; } else if ( m == VISITING ) { throw makeCircularException ( cur , visiting ) ; } } String p = ( String ) visiting . pop ( ) ; if ( root != p ) { throw new RuntimeException ( "Unexpected internal error: expected to " + "pop " + root + " but got " + p ) ; } state . put ( root , VISITED ) ; ret . addElement ( target ) ; } private static BuildException makeCircularException ( String end , Stack stk ) { StringBuffer sb = new StringBuffer ( "Circular dependency: " ) ; sb . append ( end ) ; String c ; do { c = ( String ) stk . pop ( ) ; sb . append ( " <- " ) ; sb . append ( c ) ; } while ( ! c . equals ( end ) ) ; return new BuildException ( new String ( sb ) ) ; } public void inheritIDReferences ( Project parent ) { parentIdProject = parent ; } private Object resolveIdReference ( String key , Project callerProject ) { UnknownElement origUE = ( UnknownElement ) idReferences . get ( key ) ; if ( origUE == null ) { return parentIdProject == null ? null : parentIdProject . resolveIdReference ( key , callerProject ) ; } callerProject . log ( "Warning: Reference " + key + " has not been set at runtime," + " but was found during" + LINE_SEP + "build file parsing, attempting to resolve." + " Future versions of Ant may support" + LINE_SEP + " referencing ids defined in non-executed targets." , MSG_WARN ) ; UnknownElement copyUE = origUE . copy ( callerProject ) ; copyUE . maybeConfigure ( ) ; return copyUE . getRealThing ( ) ; } public void addIdReference ( String id , Object value ) { idReferences . put ( id , value ) ; } public void addReference ( String referenceName , Object value ) { synchronized ( references ) { Object old = ( ( AntRefTable ) references ) . getReal ( referenceName ) ; if ( old == value ) { return ; } if ( old != null && ! ( old instanceof UnknownElement ) ) { log ( "Overriding previous definition of reference to " + referenceName , MSG_VERBOSE ) ; } log ( "Adding reference: " + referenceName , MSG_DEBUG ) ; references . put ( referenceName , value ) ; } } public Hashtable getReferences ( ) { return references ; } public Object getReference ( String key ) { Object ret = references . get ( key ) ; if ( ret != null ) { return ret ; } ret = resolveIdReference ( key , this ) ; if ( ret == null && ! key . equals ( MagicNames . REFID_PROPERTY_HELPER ) ) { Vector p = new Vector ( ) ; PropertyHelper . getPropertyHelper ( this ) . parsePropertyString ( key , new Vector ( ) , p ) ; if ( p . size ( ) == 1 ) { log ( "Unresolvable reference " + key + " might be a misuse of property expansion syntax." , MSG_WARN ) ; } } return ret ; } public String getElementName ( Object element ) { return ComponentHelper . getComponentHelper ( this ) . getElementName ( element ) ; } public void fireBuildStarted ( ) { BuildEvent event = new BuildEvent ( this ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . buildStarted ( event ) ; } } public void fireBuildFinished ( Throwable exception ) { BuildEvent event = new BuildEvent ( this ) ; event . setException ( exception ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . buildFinished ( event ) ; } IntrospectionHelper . clearCache ( ) ; } public void fireSubBuildStarted ( ) { BuildEvent event = new BuildEvent ( this ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { Object listener = iter . next ( ) ; if ( listener instanceof SubBuildListener ) { ( ( SubBuildListener ) listener ) . subBuildStarted ( event ) ; } } } public void fireSubBuildFinished ( Throwable exception ) { BuildEvent event = new BuildEvent ( this ) ; event . setException ( exception ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { Object listener = iter . next ( ) ; if ( listener instanceof SubBuildListener ) { ( ( SubBuildListener ) listener ) . subBuildFinished ( event ) ; } } } protected void fireTargetStarted ( Target target ) { BuildEvent event = new BuildEvent ( target ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . targetStarted ( event ) ; } } protected void fireTargetFinished ( Target target , Throwable exception ) { BuildEvent event = new BuildEvent ( target ) ; event . setException ( exception ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . targetFinished ( event ) ; } } protected void fireTaskStarted ( Task task ) { registerThreadTask ( Thread . currentThread ( ) , task ) ; BuildEvent event = new BuildEvent ( task ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . taskStarted ( event ) ; } } protected void fireTaskFinished ( Task task , Throwable exception ) { registerThreadTask ( Thread . currentThread ( ) , null ) ; System . out . flush ( ) ; System . err . flush ( ) ; BuildEvent event = new BuildEvent ( task ) ; event . setException ( exception ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . taskFinished ( event ) ; } } private void fireMessageLoggedEvent ( BuildEvent event , String message , int priority ) { if ( message . endsWith ( StringUtils . LINE_SEP ) ) { int endIndex = message . length ( ) - StringUtils . LINE_SEP . length ( ) ; event . setMessage ( message . substring ( 0 , endIndex ) , priority ) ; } else { event . setMessage ( message , priority ) ; } synchronized ( this ) { if ( loggingMessage ) { return ; } try { loggingMessage = true ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . messageLogged ( event ) ; } } finally { loggingMessage = false ; } } } protected void fireMessageLogged ( Project project , String message , int priority ) { fireMessageLogged ( project , message , null , priority ) ; } protected void fireMessageLogged ( Project project , String message , Throwable throwable , int priority ) { BuildEvent event = new BuildEvent ( project ) ; event . setException ( throwable ) ; fireMessageLoggedEvent ( event , message , priority ) ; } protected void fireMessageLogged ( Target target , String message , int priority ) { fireMessageLogged ( target , message , null , priority ) ; } protected void fireMessageLogged ( Target target , String message , Throwable throwable , int priority ) { BuildEvent event = new BuildEvent ( target ) ; event . setException ( throwable ) ; fireMessageLoggedEvent ( event , message , priority ) ; } protected void fireMessageLogged ( Task task , String message , int priority ) { fireMessageLogged ( task , message , null , priority ) ; } protected void fireMessageLogged ( Task task , String message , Throwable throwable , int priority ) { BuildEvent event = new BuildEvent ( task ) ; event . setException ( throwable ) ; fireMessageLoggedEvent ( event , message , priority ) ; } public synchronized void registerThreadTask ( Thread thread , Task task ) { if ( task != null ) { threadTasks . put ( thread , task ) ; threadGroupTasks . put ( thread . getThreadGroup ( ) , task ) ; } else { threadTasks . remove ( thread ) ; threadGroupTasks . remove ( thread . getThreadGroup ( ) ) ; } } public Task getThreadTask ( Thread thread ) { Task task = ( Task ) threadTasks . get ( thread ) ; if ( task == null ) { ThreadGroup group = thread . getThreadGroup ( ) ; while ( task == null && group != null ) { task = ( Task ) threadGroupTasks . get ( group ) ; group = group . getParent ( ) ; } } return task ; } private static class AntRefTable extends Hashtable { AntRefTable ( ) { super ( ) ; } private Object getReal ( Object key ) { return super . get ( key ) ; } public Object get ( Object key ) { Object o = getReal ( key ) ; if ( o instanceof UnknownElement ) { UnknownElement ue = ( UnknownElement ) o ; ue . maybeConfigure ( ) ; o = ue . getRealThing ( ) ; } return o ; } } public final void setProjectReference ( final Object obj ) { if ( obj instanceof ProjectComponent ) { ( ( ProjectComponent ) obj ) . setProject ( this ) ; return ; } try { Method method = obj . getClass ( ) . getMethod ( "setProject" , new Class [ ] { Project . class } ) ; if ( method != null ) { method . invoke ( obj , new Object [ ] { this } ) ; } } catch ( Throwable e ) { } } public Resource getResource ( String name ) { return new FileResource ( getBaseDir ( ) , name ) ; } } 	1	['120', '1', '0', '365', '288', '6692', '352', '30', '103', '0.97547127', '2384', '0.594594595', '5', '0', '0.090084034', '0', '0', '18.55833333', '6', '1.4167', '10']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . io . Reader ; import java . io . Writer ; import java . util . Enumeration ; import java . util . Properties ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . StringUtils ; public class Replace extends MatchingTask { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private File src = null ; private NestedString token = null ; private NestedString value = new NestedString ( ) ; private File propertyFile = null ; private File replaceFilterFile = null ; private Properties properties = null ; private Vector replacefilters = new Vector ( ) ; private File dir = null ; private int fileCount ; private int replaceCount ; private boolean summary = false ; private String encoding = null ; public class NestedString { private StringBuffer buf = new StringBuffer ( ) ; public void addText ( String val ) { buf . append ( val ) ; } public String getText ( ) { return buf . toString ( ) ; } } public class Replacefilter { private String token ; private String value ; private String replaceValue ; private String property ; private StringBuffer inputBuffer ; private StringBuffer outputBuffer = new StringBuffer ( ) ; public void validate ( ) throws BuildException { if ( token == null ) { String message = "token is a mandatory attribute " + "of replacefilter." ; throw new BuildException ( message ) ; } if ( "" . equals ( token ) ) { String message = "The token attribute must not be an empty " + "string." ; throw new BuildException ( message ) ; } if ( ( value != null ) && ( property != null ) ) { String message = "Either value or property " + "can be specified, but a replacefilter " + "element cannot have both." ; throw new BuildException ( message ) ; } if ( ( property != null ) ) { if ( propertyFile == null ) { String message = "The replacefilter's property attribute " + "can only be used with the replacetask's " + "propertyFile attribute." ; throw new BuildException ( message ) ; } if ( properties == null || properties . getProperty ( property ) == null ) { String message = "property \"" + property + "\" was not found in " + propertyFile . getPath ( ) ; throw new BuildException ( message ) ; } } replaceValue = getReplaceValue ( ) ; } public String getReplaceValue ( ) { if ( property != null ) { return properties . getProperty ( property ) ; } else if ( value != null ) { return value ; } else if ( Replace . this . value != null ) { return Replace . this . value . getText ( ) ; } else { return "" ; } } public void setToken ( String token ) { this . token = token ; } public String getToken ( ) { return token ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } public void setProperty ( String property ) { this . property = property ; } public String getProperty ( ) { return property ; } StringBuffer getOutputBuffer ( ) { return outputBuffer ; } void setInputBuffer ( StringBuffer input ) { inputBuffer = input ; } boolean process ( ) { if ( inputBuffer . length ( ) > token . length ( ) ) { int pos = replace ( ) ; pos = Math . max ( ( inputBuffer . length ( ) - token . length ( ) ) , pos ) ; outputBuffer . append ( inputBuffer . substring ( 0 , pos ) ) ; inputBuffer . delete ( 0 , pos ) ; return true ; } return false ; } void flush ( ) { replace ( ) ; outputBuffer . append ( inputBuffer . toString ( ) ) ; inputBuffer . delete ( 0 , inputBuffer . length ( ) ) ; } private int replace ( ) { int found = inputBuffer . toString ( ) . indexOf ( token ) ; int pos = - 1 ; while ( found >= 0 ) { inputBuffer . replace ( found , found + token . length ( ) , replaceValue ) ; pos = found + replaceValue . length ( ) ; found = inputBuffer . toString ( ) . indexOf ( token , pos ) ; ++ replaceCount ; } return pos ; } } private class FileInput { private StringBuffer outputBuffer ; private Reader reader ; private char [ ] buffer ; private static final int BUFF_SIZE = 4096 ; FileInput ( File source ) throws IOException { outputBuffer = new StringBuffer ( ) ; buffer = new char [ BUFF_SIZE ] ; if ( encoding == null ) { reader = new BufferedReader ( new FileReader ( source ) ) ; } else { reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( source ) , encoding ) ) ; } } StringBuffer getOutputBuffer ( ) { return outputBuffer ; } boolean readChunk ( ) throws IOException { int bufferLength = 0 ; bufferLength = reader . read ( buffer ) ; if ( bufferLength < 0 ) { return false ; } outputBuffer . append ( new String ( buffer , 0 , bufferLength ) ) ; return true ; } void close ( ) throws IOException { reader . close ( ) ; } void closeQuietly ( ) { FileUtils . close ( reader ) ; } } private class FileOutput { private StringBuffer inputBuffer ; private Writer writer ; FileOutput ( File out ) throws IOException { if ( encoding == null ) { writer = new BufferedWriter ( new FileWriter ( out ) ) ; } else { writer = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( out ) , encoding ) ) ; } } void setInputBuffer ( StringBuffer input ) { inputBuffer = input ; } boolean process ( ) throws IOException { writer . write ( inputBuffer . toString ( ) ) ; inputBuffer . delete ( 0 , inputBuffer . length ( ) ) ; return false ; } void flush ( ) throws IOException { process ( ) ; writer . flush ( ) ; } void close ( ) throws IOException { writer . close ( ) ; } void closeQuietly ( ) { FileUtils . close ( writer ) ; } } public void execute ( ) throws BuildException { Vector savedFilters = ( Vector ) replacefilters . clone ( ) ; Properties savedProperties = properties == null ? null : ( Properties ) properties . clone ( ) ; if ( token != null ) { StringBuffer val = new StringBuffer ( value . getText ( ) ) ; stringReplace ( val , "\r\n" , "\n" ) ; stringReplace ( val , "\n" , StringUtils . LINE_SEP ) ; StringBuffer tok = new StringBuffer ( token . getText ( ) ) ; stringReplace ( tok , "\r\n" , "\n" ) ; stringReplace ( tok , "\n" , StringUtils . LINE_SEP ) ; Replacefilter firstFilter = createPrimaryfilter ( ) ; firstFilter . setToken ( tok . toString ( ) ) ; firstFilter . setValue ( val . toString ( ) ) ; } try { if ( replaceFilterFile != null ) { Properties props = getProperties ( replaceFilterFile ) ; Enumeration e = props . keys ( ) ; while ( e . hasMoreElements ( ) ) { String tok = e . nextElement ( ) . toString ( ) ; Replacefilter replaceFilter = createReplacefilter ( ) ; replaceFilter . setToken ( tok ) ; replaceFilter . setValue ( props . getProperty ( tok ) ) ; } } validateAttributes ( ) ; if ( propertyFile != null ) { properties = getProperties ( propertyFile ) ; } validateReplacefilters ( ) ; fileCount = 0 ; replaceCount = 0 ; if ( src != null ) { processFile ( src ) ; } if ( dir != null ) { DirectoryScanner ds = super . getDirectoryScanner ( dir ) ; String [ ] srcs = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < srcs . length ; i ++ ) { File file = new File ( dir , srcs [ i ] ) ; processFile ( file ) ; } } if ( summary ) { log ( "Replaced " + replaceCount + " occurrences in " + fileCount + " files." , Project . MSG_INFO ) ; } } finally { replacefilters = savedFilters ; properties = savedProperties ; } } public void validateAttributes ( ) throws BuildException { if ( src == null && dir == null ) { String message = "Either the file or the dir attribute " + "must be specified" ; throw new BuildException ( message , getLocation ( ) ) ; } if ( propertyFile != null && ! propertyFile . exists ( ) ) { String message = "Property file " + propertyFile . getPath ( ) + " does not exist." ; throw new BuildException ( message , getLocation ( ) ) ; } if ( token == null && replacefilters . size ( ) == 0 ) { String message = "Either token or a nested replacefilter " + "must be specified" ; throw new BuildException ( message , getLocation ( ) ) ; } if ( token != null && "" . equals ( token . getText ( ) ) ) { String message = "The token attribute must not be an empty string." ; throw new BuildException ( message , getLocation ( ) ) ; } } public void validateReplacefilters ( ) throws BuildException { for ( int i = 0 ; i < replacefilters . size ( ) ; i ++ ) { Replacefilter element = ( Replacefilter ) replacefilters . elementAt ( i ) ; element . validate ( ) ; } } public Properties getProperties ( File propertyFile ) throws BuildException { Properties props = new Properties ( ) ; FileInputStream in = null ; try { in = new FileInputStream ( propertyFile ) ; props . load ( in ) ; } catch ( FileNotFoundException e ) { String message = "Property file (" + propertyFile . getPath ( ) + ") not found." ; throw new BuildException ( message ) ; } catch ( IOException e ) { String message = "Property file (" + propertyFile . getPath ( ) + ") cannot be loaded." ; throw new BuildException ( message ) ; } finally { FileUtils . close ( in ) ; } return props ; } private void processFile ( File src ) throws BuildException { if ( ! src . exists ( ) ) { throw new BuildException ( "Replace: source file " + src . getPath ( ) + " doesn't exist" , getLocation ( ) ) ; } File temp = null ; FileInput in = null ; FileOutput out = null ; try { in = new FileInput ( src ) ; temp = FILE_UTILS . createTempFile ( "rep" , ".tmp" , src . getParentFile ( ) ) ; out = new FileOutput ( temp ) ; int repCountStart = replaceCount ; logFilterChain ( src . getPath ( ) ) ; out . setInputBuffer ( buildFilterChain ( in . getOutputBuffer ( ) ) ) ; while ( in . readChunk ( ) ) { if ( processFilterChain ( ) ) { out . process ( ) ; } } flushFilterChain ( ) ; out . flush ( ) ; in . close ( ) ; in = null ; out . close ( ) ; out = null ; boolean changes = ( replaceCount != repCountStart ) ; if ( changes ) { FILE_UTILS . rename ( temp , src ) ; temp = null ; } } catch ( IOException ioe ) { throw new BuildException ( "IOException in " + src + " - " + ioe . getClass ( ) . getName ( ) + ":" + ioe . getMessage ( ) , ioe , getLocation ( ) ) ; } finally { if ( null != in ) { in . closeQuietly ( ) ; } if ( null != out ) { out . closeQuietly ( ) ; } if ( temp != null ) { if ( ! temp . delete ( ) ) { temp . deleteOnExit ( ) ; } } } } private void flushFilterChain ( ) { for ( int i = 0 ; i < replacefilters . size ( ) ; i ++ ) { Replacefilter filter = ( Replacefilter ) replacefilters . elementAt ( i ) ; filter . flush ( ) ; } } private boolean processFilterChain ( ) { for ( int i = 0 ; i < replacefilters . size ( ) ; i ++ ) { Replacefilter filter = ( Replacefilter ) replacefilters . elementAt ( i ) ; if ( ! filter . process ( ) ) { return false ; } } return true ; } private StringBuffer buildFilterChain ( StringBuffer inputBuffer ) { StringBuffer buf = inputBuffer ; for ( int i = 0 ; i < replacefilters . size ( ) ; i ++ ) { Replacefilter filter = ( Replacefilter ) replacefilters . elementAt ( i ) ; filter . setInputBuffer ( buf ) ; buf = filter . getOutputBuffer ( ) ; } return buf ; } private void logFilterChain ( String filename ) { for ( int i = 0 ; i < replacefilters . size ( ) ; i ++ ) { Replacefilter filter = ( Replacefilter ) replacefilters . elementAt ( i ) ; log ( "Replacing in " + filename + ": " + filter . getToken ( ) + " --> " + filter . getReplaceValue ( ) , Project . MSG_VERBOSE ) ; } } public void setFile ( File file ) { this . src = file ; } public void setSummary ( boolean summary ) { this . summary = summary ; } public void setReplaceFilterFile ( File replaceFilterFile ) { this . replaceFilterFile = replaceFilterFile ; } public void setDir ( File dir ) { this . dir = dir ; } public void setToken ( String token ) { createReplaceToken ( ) . addText ( token ) ; } public void setValue ( String value ) { createReplaceValue ( ) . addText ( value ) ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public NestedString createReplaceToken ( ) { if ( token == null ) { token = new NestedString ( ) ; } return token ; } public NestedString createReplaceValue ( ) { return value ; } public void setPropertyFile ( File propertyFile ) { this . propertyFile = propertyFile ; } public Replacefilter createReplacefilter ( ) { Replacefilter filter = new Replacefilter ( ) ; replacefilters . addElement ( filter ) ; return filter ; } private Replacefilter createPrimaryfilter ( ) { Replacefilter filter = new Replacefilter ( ) ; replacefilters . insertElementAt ( filter , 0 ) ; return filter ; } private void stringReplace ( StringBuffer str , String str1 , String str2 ) { int found = str . toString ( ) . indexOf ( str1 ) ; while ( found >= 0 ) { str . replace ( found , found + str1 . length ( ) , str2 ) ; found = str . toString ( ) . indexOf ( str1 , found + str2 . length ( ) ) ; } } } 	1	['30', '4', '0', '10', '100', '271', '4', '10', '16', '0.891246684', '788', '1', '3', '0.735849057', '0.216748768', '2', '2', '24.83333333', '3', '1.1667', '3']
package org . apache . tools . zip ; public class UnrecognizedExtraField implements ZipExtraField { private ZipShort headerId ; public void setHeaderId ( ZipShort headerId ) { this . headerId = headerId ; } public ZipShort getHeaderId ( ) { return headerId ; } private byte [ ] localData ; public void setLocalFileDataData ( byte [ ] data ) { localData = data ; } public ZipShort getLocalFileDataLength ( ) { return new ZipShort ( localData . length ) ; } public byte [ ] getLocalFileDataData ( ) { return localData ; } private byte [ ] centralData ; public void setCentralDirectoryData ( byte [ ] data ) { centralData = data ; } public ZipShort getCentralDirectoryLength ( ) { if ( centralData != null ) { return new ZipShort ( centralData . length ) ; } return getLocalFileDataLength ( ) ; } public byte [ ] getCentralDirectoryData ( ) { if ( centralData != null ) { return centralData ; } return getLocalFileDataData ( ) ; } public void parseFromLocalFileData ( byte [ ] data , int offset , int length ) { byte [ ] tmp = new byte [ length ] ; System . arraycopy ( data , offset , tmp , 0 , length ) ; setLocalFileDataData ( tmp ) ; } } 	1	['10', '1', '0', '3', '13', '31', '1', '2', '10', '0.703703704', '76', '1', '1', '0', '0.375', '0', '0', '6.3', '2', '1.1', '1']
package org . apache . tools . ant . types ; import java . io . File ; import java . util . Collections ; import java . util . Iterator ; import java . util . Locale ; import java . util . Stack ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . PathTokenizer ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . resources . Union ; import org . apache . tools . ant . types . resources . FileResourceIterator ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; public class Path extends DataType implements Cloneable , ResourceCollection { public static Path systemClasspath = new Path ( null , System . getProperty ( "java.class.path" ) ) ; public static Path systemBootClasspath = new Path ( null , System . getProperty ( "sun.boot.class.path" ) ) ; private static final Iterator EMPTY_ITERATOR = Collections . EMPTY_SET . iterator ( ) ; public class PathElement implements ResourceCollection { private String [ ] parts ; public void setLocation ( File loc ) { parts = new String [ ] { translateFile ( loc . getAbsolutePath ( ) ) } ; } public void setPath ( String path ) { parts = Path . translatePath ( getProject ( ) , path ) ; } public String [ ] getParts ( ) { return parts ; } public Iterator iterator ( ) { return new FileResourceIterator ( null , parts ) ; } public boolean isFilesystemOnly ( ) { return true ; } public int size ( ) { return parts == null ? 0 : parts . length ; } } private Union union = null ; public Path ( Project p , String path ) { this ( p ) ; createPathElement ( ) . setPath ( path ) ; } public Path ( Project project ) { setProject ( project ) ; } public void setLocation ( File location ) throws BuildException { checkAttributesAllowed ( ) ; createPathElement ( ) . setLocation ( location ) ; } public void setPath ( String path ) throws BuildException { checkAttributesAllowed ( ) ; createPathElement ( ) . setPath ( path ) ; } public void setRefid ( Reference r ) throws BuildException { if ( union != null ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public PathElement createPathElement ( ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } PathElement pe = new PathElement ( ) ; add ( pe ) ; return pe ; } public void addFileset ( FileSet fs ) throws BuildException { if ( fs . getProject ( ) == null ) { fs . setProject ( getProject ( ) ) ; } add ( fs ) ; } public void addFilelist ( FileList fl ) throws BuildException { if ( fl . getProject ( ) == null ) { fl . setProject ( getProject ( ) ) ; } add ( fl ) ; } public void addDirset ( DirSet dset ) throws BuildException { if ( dset . getProject ( ) == null ) { dset . setProject ( getProject ( ) ) ; } add ( dset ) ; } public void add ( Path path ) throws BuildException { if ( path == this ) { throw circularReference ( ) ; } if ( path . getProject ( ) == null ) { path . setProject ( getProject ( ) ) ; } add ( ( ResourceCollection ) path ) ; } public void add ( ResourceCollection c ) { checkChildrenAllowed ( ) ; if ( c == null ) { return ; } if ( union == null ) { union = new Union ( ) ; union . setProject ( getProject ( ) ) ; union . setCache ( false ) ; } union . add ( c ) ; setChecked ( false ) ; } public Path createPath ( ) throws BuildException { Path p = new Path ( getProject ( ) ) ; add ( p ) ; return p ; } public void append ( Path other ) { if ( other == null ) { return ; } add ( other ) ; } public void addExisting ( Path source ) { addExisting ( source , false ) ; } public void addExisting ( Path source , boolean tryUserDir ) { String [ ] list = source . list ( ) ; File userDir = ( tryUserDir ) ? new File ( System . getProperty ( "user.dir" ) ) : null ; for ( int i = 0 ; i < list . length ; i ++ ) { File f = resolveFile ( getProject ( ) , list [ i ] ) ; if ( tryUserDir && ! f . exists ( ) ) { f = new File ( userDir , list [ i ] ) ; } if ( f . exists ( ) ) { setLocation ( f ) ; } else { log ( "dropping " + f + " from path as it doesn't exist" , Project . MSG_VERBOSE ) ; } } } public String [ ] list ( ) { if ( isReference ( ) ) { return ( ( Path ) getCheckedRef ( ) ) . list ( ) ; } return assertFilesystemOnly ( union ) == null ? new String [ 0 ] : union . list ( ) ; } public String toString ( ) { return isReference ( ) ? getCheckedRef ( ) . toString ( ) : union == null ? "" : union . toString ( ) ; } public static String [ ] translatePath ( Project project , String source ) { final Vector result = new Vector ( ) ; if ( source == null ) { return new String [ 0 ] ; } PathTokenizer tok = new PathTokenizer ( source ) ; StringBuffer element = new StringBuffer ( ) ; while ( tok . hasMoreTokens ( ) ) { String pathElement = tok . nextToken ( ) ; try { element . append ( resolveFile ( project , pathElement ) . getPath ( ) ) ; } catch ( BuildException e ) { project . log ( "Dropping path element " + pathElement + " as it is not valid relative to the project" , Project . MSG_VERBOSE ) ; } for ( int i = 0 ; i < element . length ( ) ; i ++ ) { translateFileSep ( element , i ) ; } result . addElement ( element . toString ( ) ) ; element = new StringBuffer ( ) ; } String [ ] res = new String [ result . size ( ) ] ; result . copyInto ( res ) ; return res ; } public static String translateFile ( String source ) { if ( source == null ) { return "" ; } final StringBuffer result = new StringBuffer ( source ) ; for ( int i = 0 ; i < result . length ( ) ; i ++ ) { translateFileSep ( result , i ) ; } return result . toString ( ) ; } protected static boolean translateFileSep ( StringBuffer buffer , int pos ) { if ( buffer . charAt ( pos ) == '/' || buffer . charAt ( pos ) == '\\' ) { buffer . setCharAt ( pos , File . separatorChar ) ; return true ; } return false ; } public synchronized int size ( ) { if ( isReference ( ) ) { return ( ( Path ) getCheckedRef ( ) ) . size ( ) ; } dieOnCircularReference ( ) ; return union == null ? 0 : assertFilesystemOnly ( union ) . size ( ) ; } public Object clone ( ) { try { Path result = ( Path ) super . clone ( ) ; result . union = union == null ? union : ( Union ) union . clone ( ) ; return result ; } catch ( CloneNotSupportedException e ) { throw new BuildException ( e ) ; } } protected synchronized void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( isChecked ( ) ) { return ; } if ( isReference ( ) ) { super . dieOnCircularReference ( stk , p ) ; } else { if ( union != null ) { stk . push ( union ) ; invokeCircularReferenceCheck ( union , stk , p ) ; stk . pop ( ) ; } setChecked ( true ) ; } } private static File resolveFile ( Project project , String relativeName ) { return FileUtils . getFileUtils ( ) . resolveFile ( ( project == null ) ? null : project . getBaseDir ( ) , relativeName ) ; } public Path concatSystemClasspath ( ) { return concatSystemClasspath ( "last" ) ; } public Path concatSystemClasspath ( String defValue ) { return concatSpecialPath ( defValue , Path . systemClasspath ) ; } public Path concatSystemBootClasspath ( String defValue ) { return concatSpecialPath ( defValue , Path . systemBootClasspath ) ; } private Path concatSpecialPath ( String defValue , Path p ) { Path result = new Path ( getProject ( ) ) ; String order = defValue ; if ( getProject ( ) != null ) { String o = getProject ( ) . getProperty ( "build.sysclasspath" ) ; if ( o != null ) { order = o ; } } if ( order . equals ( "only" ) ) { result . addExisting ( p , true ) ; } else if ( order . equals ( "first" ) ) { result . addExisting ( p , true ) ; result . addExisting ( this ) ; } else if ( order . equals ( "ignore" ) ) { result . addExisting ( this ) ; } else { if ( ! order . equals ( "last" ) ) { log ( "invalid value for build.sysclasspath: " + order , Project . MSG_WARN ) ; } result . addExisting ( this ) ; result . addExisting ( p , true ) ; } return result ; } public void addJavaRuntime ( ) { if ( JavaEnvUtils . isKaffe ( ) ) { File kaffeShare = new File ( System . getProperty ( "java.home" ) + File . separator + "share" + File . separator + "kaffe" ) ; if ( kaffeShare . isDirectory ( ) ) { FileSet kaffeJarFiles = new FileSet ( ) ; kaffeJarFiles . setDir ( kaffeShare ) ; kaffeJarFiles . setIncludes ( "*.jar" ) ; addFileset ( kaffeJarFiles ) ; } } else if ( "GNU libgcj" . equals ( System . getProperty ( "java.vm.name" ) ) ) { addExisting ( systemBootClasspath ) ; } if ( System . getProperty ( "java.vendor" ) . toLowerCase ( Locale . US ) . indexOf ( "microsoft" ) >= 0 ) { FileSet msZipFiles = new FileSet ( ) ; msZipFiles . setDir ( new File ( System . getProperty ( "java.home" ) + File . separator + "Packages" ) ) ; msZipFiles . setIncludes ( "*.ZIP" ) ; addFileset ( msZipFiles ) ; } else { addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + "rt.jar" ) ) ; addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "jre" + File . separator + "lib" + File . separator + "rt.jar" ) ) ; String [ ] secJars = { "jce" , "jsse" } ; for ( int i = 0 ; i < secJars . length ; i ++ ) { addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + secJars [ i ] + ".jar" ) ) ; addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + ".." + File . separator + "Classes" + File . separator + secJars [ i ] + ".jar" ) ) ; } String [ ] ibmJars = { "core" , "graphics" , "security" , "server" , "xml" } ; for ( int i = 0 ; i < ibmJars . length ; i ++ ) { addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + ibmJars [ i ] + ".jar" ) ) ; } addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + ".." + File . separator + "Classes" + File . separator + "classes.jar" ) ) ; addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + ".." + File . separator + "Classes" + File . separator + "ui.jar" ) ) ; } } public void addExtdirs ( Path extdirs ) { if ( extdirs == null ) { String extProp = System . getProperty ( "java.ext.dirs" ) ; if ( extProp != null ) { extdirs = new Path ( getProject ( ) , extProp ) ; } else { return ; } } String [ ] dirs = extdirs . list ( ) ; for ( int i = 0 ; i < dirs . length ; i ++ ) { File dir = resolveFile ( getProject ( ) , dirs [ i ] ) ; if ( dir . exists ( ) && dir . isDirectory ( ) ) { FileSet fs = new FileSet ( ) ; fs . setDir ( dir ) ; fs . setIncludes ( "*" ) ; addFileset ( fs ) ; } } } public final synchronized Iterator iterator ( ) { if ( isReference ( ) ) { return ( ( Path ) getCheckedRef ( ) ) . iterator ( ) ; } dieOnCircularReference ( ) ; return union == null ? EMPTY_ITERATOR : assertFilesystemOnly ( union ) . iterator ( ) ; } public synchronized boolean isFilesystemOnly ( ) { if ( isReference ( ) ) { return ( ( Path ) getCheckedRef ( ) ) . isFilesystemOnly ( ) ; } dieOnCircularReference ( ) ; assertFilesystemOnly ( union ) ; return true ; } protected ResourceCollection assertFilesystemOnly ( ResourceCollection rc ) { if ( rc != null && ! ( rc . isFilesystemOnly ( ) ) ) { throw new BuildException ( getDataTypeName ( ) + " allows only filesystem resources." ) ; } return rc ; } } 	1	['34', '3', '0', '112', '112', '461', '101', '13', '28', '0.803030303', '1021', '0.5', '3', '0.491803279', '0.127705628', '2', '6', '28.91176471', '7', '2.2353', '1']
package org . apache . tools . ant . taskdefs . optional . depend ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import java . net . URL ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . MatchingTask ; import org . apache . tools . ant . taskdefs . rmic . DefaultRmicAdapter ; import org . apache . tools . ant . taskdefs . rmic . WLRmic ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . depend . DependencyAnalyzer ; public class Depend extends MatchingTask { private static class ClassFileInfo { private File absoluteFile ; private String className ; private File sourceFile ; private boolean isUserWarned = false ; } private Path srcPath ; private Path destPath ; private File cache ; private String [ ] srcPathList ; private Hashtable affectedClassMap ; private Hashtable classFileInfoMap ; private Hashtable classpathDependencies ; private Hashtable outOfDateClasses ; private boolean closure = false ; private boolean warnOnRmiStubs = true ; private boolean dump = false ; private Path dependClasspath ; private static final String CACHE_FILE_NAME = "dependencies.txt" ; private static final String CLASSNAME_PREPEND = "||:" ; public void setClasspath ( Path classpath ) { if ( dependClasspath == null ) { dependClasspath = classpath ; } else { dependClasspath . append ( classpath ) ; } } public Path getClasspath ( ) { return dependClasspath ; } public Path createClasspath ( ) { if ( dependClasspath == null ) { dependClasspath = new Path ( getProject ( ) ) ; } return dependClasspath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setWarnOnRmiStubs ( boolean warnOnRmiStubs ) { this . warnOnRmiStubs = warnOnRmiStubs ; } private Hashtable readCachedDependencies ( File depFile ) throws IOException { Hashtable dependencyMap = new Hashtable ( ) ; BufferedReader in = null ; try { in = new BufferedReader ( new FileReader ( depFile ) ) ; String line = null ; Vector dependencyList = null ; String className = null ; int prependLength = CLASSNAME_PREPEND . length ( ) ; while ( ( line = in . readLine ( ) ) != null ) { if ( line . startsWith ( CLASSNAME_PREPEND ) ) { dependencyList = new Vector ( ) ; className = line . substring ( prependLength ) ; dependencyMap . put ( className , dependencyList ) ; } else { dependencyList . addElement ( line ) ; } } } finally { if ( in != null ) { in . close ( ) ; } } return dependencyMap ; } private void writeCachedDependencies ( Hashtable dependencyMap ) throws IOException { if ( cache != null ) { PrintWriter pw = null ; try { cache . mkdirs ( ) ; File depFile = new File ( cache , CACHE_FILE_NAME ) ; pw = new PrintWriter ( new FileWriter ( depFile ) ) ; Enumeration e = dependencyMap . keys ( ) ; while ( e . hasMoreElements ( ) ) { String className = ( String ) e . nextElement ( ) ; pw . println ( CLASSNAME_PREPEND + className ) ; Vector dependencyList = ( Vector ) dependencyMap . get ( className ) ; int size = dependencyList . size ( ) ; for ( int x = 0 ; x < size ; x ++ ) { pw . println ( dependencyList . elementAt ( x ) ) ; } } } finally { if ( pw != null ) { pw . close ( ) ; } } } } private Path getCheckClassPath ( ) { if ( dependClasspath == null ) { return null ; } String [ ] destPathElements = destPath . list ( ) ; String [ ] classpathElements = dependClasspath . list ( ) ; String checkPath = "" ; for ( int i = 0 ; i < classpathElements . length ; ++ i ) { String element = classpathElements [ i ] ; boolean inDestPath = false ; for ( int j = 0 ; j < destPathElements . length && ! inDestPath ; ++ j ) { inDestPath = destPathElements [ j ] . equals ( element ) ; } if ( ! inDestPath ) { if ( checkPath . length ( ) == 0 ) { checkPath = element ; } else { checkPath += ":" + element ; } } } if ( checkPath . length ( ) == 0 ) { return null ; } return new Path ( getProject ( ) , checkPath ) ; } private void determineDependencies ( ) throws IOException { affectedClassMap = new Hashtable ( ) ; classFileInfoMap = new Hashtable ( ) ; boolean cacheDirty = false ; Hashtable dependencyMap = new Hashtable ( ) ; File cacheFile = null ; boolean cacheFileExists = true ; long cacheLastModified = Long . MAX_VALUE ; if ( cache != null ) { cacheFile = new File ( cache , CACHE_FILE_NAME ) ; cacheFileExists = cacheFile . exists ( ) ; cacheLastModified = cacheFile . lastModified ( ) ; if ( cacheFileExists ) { dependencyMap = readCachedDependencies ( cacheFile ) ; } } Enumeration classfileEnum = getClassFiles ( destPath ) . elements ( ) ; while ( classfileEnum . hasMoreElements ( ) ) { ClassFileInfo info = ( ClassFileInfo ) classfileEnum . nextElement ( ) ; log ( "Adding class info for " + info . className , Project . MSG_DEBUG ) ; classFileInfoMap . put ( info . className , info ) ; Vector dependencyList = null ; if ( cache != null ) { if ( cacheFileExists && cacheLastModified > info . absoluteFile . lastModified ( ) ) { dependencyList = ( Vector ) dependencyMap . get ( info . className ) ; } } if ( dependencyList == null ) { DependencyAnalyzer analyzer = new AntAnalyzer ( ) ; analyzer . addRootClass ( info . className ) ; analyzer . addClassPath ( destPath ) ; analyzer . setClosure ( false ) ; dependencyList = new Vector ( ) ; Enumeration depEnum = analyzer . getClassDependencies ( ) ; while ( depEnum . hasMoreElements ( ) ) { dependencyList . addElement ( depEnum . nextElement ( ) ) ; } cacheDirty = true ; dependencyMap . put ( info . className , dependencyList ) ; } Enumeration depEnum = dependencyList . elements ( ) ; while ( depEnum . hasMoreElements ( ) ) { String dependentClass = ( String ) depEnum . nextElement ( ) ; Hashtable affectedClasses = ( Hashtable ) affectedClassMap . get ( dependentClass ) ; if ( affectedClasses == null ) { affectedClasses = new Hashtable ( ) ; affectedClassMap . put ( dependentClass , affectedClasses ) ; } affectedClasses . put ( info . className , info ) ; } } classpathDependencies = null ; Path checkPath = getCheckClassPath ( ) ; if ( checkPath != null ) { classpathDependencies = new Hashtable ( ) ; AntClassLoader loader = getProject ( ) . createClassLoader ( checkPath ) ; Hashtable classpathFileCache = new Hashtable ( ) ; Object nullFileMarker = new Object ( ) ; for ( Enumeration e = dependencyMap . keys ( ) ; e . hasMoreElements ( ) ; ) { String className = ( String ) e . nextElement ( ) ; Vector dependencyList = ( Vector ) dependencyMap . get ( className ) ; Hashtable dependencies = new Hashtable ( ) ; classpathDependencies . put ( className , dependencies ) ; Enumeration e2 = dependencyList . elements ( ) ; while ( e2 . hasMoreElements ( ) ) { String dependency = ( String ) e2 . nextElement ( ) ; Object classpathFileObject = classpathFileCache . get ( dependency ) ; if ( classpathFileObject == null ) { classpathFileObject = nullFileMarker ; if ( ! dependency . startsWith ( "java." ) && ! dependency . startsWith ( "javax." ) ) { URL classURL = loader . getResource ( dependency . replace ( '.' , '/' ) + ".class" ) ; if ( classURL != null ) { if ( classURL . getProtocol ( ) . equals ( "jar" ) ) { String jarFilePath = classURL . getFile ( ) ; int classMarker = jarFilePath . indexOf ( '!' ) ; jarFilePath = jarFilePath . substring ( 0 , classMarker ) ; if ( jarFilePath . startsWith ( "file:" ) ) { classpathFileObject = new File ( FileUtils . getFileUtils ( ) . fromURI ( jarFilePath ) ) ; } else { throw new IOException ( "Bizarre nested path in jar: protocol: " + jarFilePath ) ; } } else if ( classURL . getProtocol ( ) . equals ( "file" ) ) { classpathFileObject = new File ( FileUtils . getFileUtils ( ) . fromURI ( classURL . toExternalForm ( ) ) ) ; } log ( "Class " + className + " depends on " + classpathFileObject + " due to " + dependency , Project . MSG_DEBUG ) ; } } classpathFileCache . put ( dependency , classpathFileObject ) ; } if ( classpathFileObject != null && classpathFileObject != nullFileMarker ) { File jarFile = ( File ) classpathFileObject ; dependencies . put ( jarFile , jarFile ) ; } } } } if ( cache != null && cacheDirty ) { writeCachedDependencies ( dependencyMap ) ; } } private int deleteAllAffectedFiles ( ) { int count = 0 ; for ( Enumeration e = outOfDateClasses . elements ( ) ; e . hasMoreElements ( ) ; ) { String className = ( String ) e . nextElement ( ) ; count += deleteAffectedFiles ( className ) ; ClassFileInfo classInfo = ( ClassFileInfo ) classFileInfoMap . get ( className ) ; if ( classInfo != null && classInfo . absoluteFile . exists ( ) ) { classInfo . absoluteFile . delete ( ) ; count ++ ; } } return count ; } private int deleteAffectedFiles ( String className ) { int count = 0 ; Hashtable affectedClasses = ( Hashtable ) affectedClassMap . get ( className ) ; if ( affectedClasses == null ) { return count ; } for ( Enumeration e = affectedClasses . keys ( ) ; e . hasMoreElements ( ) ; ) { String affectedClass = ( String ) e . nextElement ( ) ; ClassFileInfo affectedClassInfo = ( ClassFileInfo ) affectedClasses . get ( affectedClass ) ; if ( ! affectedClassInfo . absoluteFile . exists ( ) ) { continue ; } if ( affectedClassInfo . sourceFile == null ) { warnOutOfDateButNotDeleted ( affectedClassInfo , affectedClass , className ) ; continue ; } log ( "Deleting file " + affectedClassInfo . absoluteFile . getPath ( ) + " since " + className + " out of date" , Project . MSG_VERBOSE ) ; affectedClassInfo . absoluteFile . delete ( ) ; count ++ ; if ( closure ) { count += deleteAffectedFiles ( affectedClass ) ; } else { if ( affectedClass . indexOf ( "$" ) == - 1 ) { continue ; } String topLevelClassName = affectedClass . substring ( 0 , affectedClass . indexOf ( "$" ) ) ; log ( "Top level class = " + topLevelClassName , Project . MSG_VERBOSE ) ; ClassFileInfo topLevelClassInfo = ( ClassFileInfo ) classFileInfoMap . get ( topLevelClassName ) ; if ( topLevelClassInfo != null && topLevelClassInfo . absoluteFile . exists ( ) ) { log ( "Deleting file " + topLevelClassInfo . absoluteFile . getPath ( ) + " since one of its inner classes was removed" , Project . MSG_VERBOSE ) ; topLevelClassInfo . absoluteFile . delete ( ) ; count ++ ; if ( closure ) { count += deleteAffectedFiles ( topLevelClassName ) ; } } } } return count ; } private void warnOutOfDateButNotDeleted ( ClassFileInfo affectedClassInfo , String affectedClass , String className ) { if ( affectedClassInfo . isUserWarned ) { return ; } int level = Project . MSG_WARN ; if ( ! warnOnRmiStubs ) { if ( isRmiStub ( affectedClass , className ) ) { level = Project . MSG_VERBOSE ; } } log ( "The class " + affectedClass + " in file " + affectedClassInfo . absoluteFile . getPath ( ) + " is out of date due to " + className + " but has not been deleted because its source file" + " could not be determined" , level ) ; affectedClassInfo . isUserWarned = true ; } private boolean isRmiStub ( String affectedClass , String className ) { return isStub ( affectedClass , className , DefaultRmicAdapter . RMI_STUB_SUFFIX ) || isStub ( affectedClass , className , DefaultRmicAdapter . RMI_SKEL_SUFFIX ) || isStub ( affectedClass , className , WLRmic . RMI_STUB_SUFFIX ) || isStub ( affectedClass , className , WLRmic . RMI_SKEL_SUFFIX ) ; } private boolean isStub ( String affectedClass , String baseClass , String suffix ) { return ( baseClass + suffix ) . equals ( affectedClass ) ; } private void dumpDependencies ( ) { log ( "Reverse Dependency Dump for " + affectedClassMap . size ( ) + " classes:" , Project . MSG_DEBUG ) ; Enumeration classEnum = affectedClassMap . keys ( ) ; while ( classEnum . hasMoreElements ( ) ) { String className = ( String ) classEnum . nextElement ( ) ; log ( " Class " + className + " affects:" , Project . MSG_DEBUG ) ; Hashtable affectedClasses = ( Hashtable ) affectedClassMap . get ( className ) ; Enumeration affectedClassEnum = affectedClasses . keys ( ) ; while ( affectedClassEnum . hasMoreElements ( ) ) { String affectedClass = ( String ) affectedClassEnum . nextElement ( ) ; ClassFileInfo info = ( ClassFileInfo ) affectedClasses . get ( affectedClass ) ; log ( "    " + affectedClass + " in " + info . absoluteFile . getPath ( ) , Project . MSG_DEBUG ) ; } } if ( classpathDependencies != null ) { log ( "Classpath file dependencies (Forward):" , Project . MSG_DEBUG ) ; Enumeration classpathEnum = classpathDependencies . keys ( ) ; while ( classpathEnum . hasMoreElements ( ) ) { String className = ( String ) classpathEnum . nextElement ( ) ; log ( " Class " + className + " depends on:" , Project . MSG_DEBUG ) ; Hashtable dependencies = ( Hashtable ) classpathDependencies . get ( className ) ; Enumeration classpathFileEnum = dependencies . elements ( ) ; while ( classpathFileEnum . hasMoreElements ( ) ) { File classpathFile = ( File ) classpathFileEnum . nextElement ( ) ; log ( "    " + classpathFile . getPath ( ) , Project . MSG_DEBUG ) ; } } } } private void determineOutOfDateClasses ( ) { outOfDateClasses = new Hashtable ( ) ; for ( int i = 0 ; i < srcPathList . length ; i ++ ) { File srcDir = getProject ( ) . resolveFile ( srcPathList [ i ] ) ; if ( srcDir . exists ( ) ) { DirectoryScanner ds = this . getDirectoryScanner ( srcDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( srcDir , files ) ; } } if ( classpathDependencies == null ) { return ; } Enumeration classpathDepsEnum = classpathDependencies . keys ( ) ; while ( classpathDepsEnum . hasMoreElements ( ) ) { String className = ( String ) classpathDepsEnum . nextElement ( ) ; if ( outOfDateClasses . containsKey ( className ) ) { continue ; } ClassFileInfo info = ( ClassFileInfo ) classFileInfoMap . get ( className ) ; if ( info != null ) { Hashtable dependencies = ( Hashtable ) classpathDependencies . get ( className ) ; for ( Enumeration e2 = dependencies . elements ( ) ; e2 . hasMoreElements ( ) ; ) { File classpathFile = ( File ) e2 . nextElement ( ) ; if ( classpathFile . lastModified ( ) > info . absoluteFile . lastModified ( ) ) { log ( "Class " + className + " is out of date with respect to " + classpathFile , Project . MSG_DEBUG ) ; outOfDateClasses . put ( className , className ) ; break ; } } } } } public void execute ( ) throws BuildException { try { long start = System . currentTimeMillis ( ) ; if ( srcPath == null ) { throw new BuildException ( "srcdir attribute must be set" , getLocation ( ) ) ; } srcPathList = srcPath . list ( ) ; if ( srcPathList . length == 0 ) { throw new BuildException ( "srcdir attribute must be non-empty" , getLocation ( ) ) ; } if ( destPath == null ) { destPath = srcPath ; } if ( cache != null && cache . exists ( ) && ! cache . isDirectory ( ) ) { throw new BuildException ( "The cache, if specified, must " + "point to a directory" ) ; } if ( cache != null && ! cache . exists ( ) ) { cache . mkdirs ( ) ; } determineDependencies ( ) ; if ( dump ) { dumpDependencies ( ) ; } determineOutOfDateClasses ( ) ; int count = deleteAllAffectedFiles ( ) ; long duration = ( System . currentTimeMillis ( ) - start ) / 1000 ; final int summaryLogLevel ; if ( count > 0 ) { summaryLogLevel = Project . MSG_INFO ; } else { summaryLogLevel = Project . MSG_DEBUG ; } log ( "Deleted " + count + " out of date files in " + duration + " seconds" , summaryLogLevel ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } protected void scanDir ( File srcDir , String [ ] files ) { for ( int i = 0 ; i < files . length ; i ++ ) { File srcFile = new File ( srcDir , files [ i ] ) ; if ( files [ i ] . endsWith ( ".java" ) ) { String filePath = srcFile . getPath ( ) ; String className = filePath . substring ( srcDir . getPath ( ) . length ( ) + 1 , filePath . length ( ) - ".java" . length ( ) ) ; className = ClassFileUtils . convertSlashName ( className ) ; ClassFileInfo info = ( ClassFileInfo ) classFileInfoMap . get ( className ) ; if ( info == null ) { outOfDateClasses . put ( className , className ) ; } else { if ( srcFile . lastModified ( ) > info . absoluteFile . lastModified ( ) ) { outOfDateClasses . put ( className , className ) ; } } } } } private Vector getClassFiles ( Path classLocations ) { String [ ] classLocationsList = classLocations . list ( ) ; Vector classFileList = new Vector ( ) ; for ( int i = 0 ; i < classLocationsList . length ; ++ i ) { File dir = new File ( classLocationsList [ i ] ) ; if ( dir . isDirectory ( ) ) { addClassFiles ( classFileList , dir , dir ) ; } } return classFileList ; } private File findSourceFile ( String classname ) { String sourceFilename = classname + ".java" ; int innerIndex = classname . indexOf ( "$" ) ; if ( innerIndex != - 1 ) { sourceFilename = classname . substring ( 0 , innerIndex ) + ".java" ; } for ( int i = 0 ; i < srcPathList . length ; ++ i ) { File sourceFile = new File ( srcPathList [ i ] , sourceFilename ) ; if ( sourceFile . exists ( ) ) { return sourceFile ; } } return null ; } private void addClassFiles ( Vector classFileList , File dir , File root ) { String [ ] filesInDir = dir . list ( ) ; if ( filesInDir == null ) { return ; } int length = filesInDir . length ; int rootLength = root . getPath ( ) . length ( ) ; for ( int i = 0 ; i < length ; ++ i ) { File file = new File ( dir , filesInDir [ i ] ) ; if ( file . isDirectory ( ) ) { addClassFiles ( classFileList , file , root ) ; } else if ( file . getName ( ) . endsWith ( ".class" ) ) { ClassFileInfo info = new ClassFileInfo ( ) ; info . absoluteFile = file ; String relativeName = file . getPath ( ) . substring ( rootLength + 1 , file . getPath ( ) . length ( ) - 6 ) ; info . className = ClassFileUtils . convertSlashName ( relativeName ) ; info . sourceFile = findSourceFile ( relativeName ) ; classFileList . addElement ( info ) ; } } } public void setSrcdir ( Path srcPath ) { this . srcPath = srcPath ; } public void setDestDir ( Path destPath ) { this . destPath = destPath ; } public void setCache ( File cache ) { this . cache = cache ; } public void setClosure ( boolean closure ) { this . closure = closure ; } public void setDump ( boolean dump ) { this . dump = dump ; } } 	1	['27', '4', '0', '13', '118', '265', '0', '13', '12', '0.895604396', '1542', '1', '3', '0.75', '0.177777778', '1', '1', '55.59259259', '10', '2.963', '2']
package org . apache . tools . tar ; import java . io . FilterOutputStream ; import java . io . OutputStream ; import java . io . IOException ; public class TarOutputStream extends FilterOutputStream { public static final int LONGFILE_ERROR = 0 ; public static final int LONGFILE_TRUNCATE = 1 ; public static final int LONGFILE_GNU = 2 ; protected boolean debug ; protected long currSize ; protected String currName ; protected long currBytes ; protected byte [ ] oneBuf ; protected byte [ ] recordBuf ; protected int assemLen ; protected byte [ ] assemBuf ; protected TarBuffer buffer ; protected int longFileMode = LONGFILE_ERROR ; private boolean closed = false ; public TarOutputStream ( OutputStream os ) { this ( os , TarBuffer . DEFAULT_BLKSIZE , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarOutputStream ( OutputStream os , int blockSize ) { this ( os , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarOutputStream ( OutputStream os , int blockSize , int recordSize ) { super ( os ) ; this . buffer = new TarBuffer ( os , blockSize , recordSize ) ; this . debug = false ; this . assemLen = 0 ; this . assemBuf = new byte [ recordSize ] ; this . recordBuf = new byte [ recordSize ] ; this . oneBuf = new byte [ 1 ] ; } public void setLongFileMode ( int longFileMode ) { this . longFileMode = longFileMode ; } public void setDebug ( boolean debugF ) { this . debug = debugF ; } public void setBufferDebug ( boolean debug ) { this . buffer . setDebug ( debug ) ; } public void finish ( ) throws IOException { this . writeEOFRecord ( ) ; this . writeEOFRecord ( ) ; } public void close ( ) throws IOException { if ( ! closed ) { this . finish ( ) ; this . buffer . close ( ) ; out . close ( ) ; closed = true ; } } public int getRecordSize ( ) { return this . buffer . getRecordSize ( ) ; } public void putNextEntry ( TarEntry entry ) throws IOException { if ( entry . getName ( ) . length ( ) >= TarConstants . NAMELEN ) { if ( longFileMode == LONGFILE_GNU ) { TarEntry longLinkEntry = new TarEntry ( TarConstants . GNU_LONGLINK , TarConstants . LF_GNUTYPE_LONGNAME ) ; longLinkEntry . setSize ( entry . getName ( ) . length ( ) + 1 ) ; putNextEntry ( longLinkEntry ) ; write ( entry . getName ( ) . getBytes ( ) ) ; write ( 0 ) ; closeEntry ( ) ; } else if ( longFileMode != LONGFILE_TRUNCATE ) { throw new RuntimeException ( "file name '" + entry . getName ( ) + "' is too long ( > " + TarConstants . NAMELEN + " bytes)" ) ; } } entry . writeEntryHeader ( this . recordBuf ) ; this . buffer . writeRecord ( this . recordBuf ) ; this . currBytes = 0 ; if ( entry . isDirectory ( ) ) { this . currSize = 0 ; } else { this . currSize = entry . getSize ( ) ; } currName = entry . getName ( ) ; } public void closeEntry ( ) throws IOException { if ( this . assemLen > 0 ) { for ( int i = this . assemLen ; i < this . assemBuf . length ; ++ i ) { this . assemBuf [ i ] = 0 ; } this . buffer . writeRecord ( this . assemBuf ) ; this . currBytes += this . assemLen ; this . assemLen = 0 ; } if ( this . currBytes < this . currSize ) { throw new IOException ( "entry '" + currName + "' closed at '" + this . currBytes + "' before the '" + this . currSize + "' bytes specified in the header were written" ) ; } } public void write ( int b ) throws IOException { this . oneBuf [ 0 ] = ( byte ) b ; this . write ( this . oneBuf , 0 , 1 ) ; } public void write ( byte [ ] wBuf ) throws IOException { this . write ( wBuf , 0 , wBuf . length ) ; } public void write ( byte [ ] wBuf , int wOffset , int numToWrite ) throws IOException { if ( ( this . currBytes + numToWrite ) > this . currSize ) { throw new IOException ( "request to write '" + numToWrite + "' bytes exceeds size in header of '" + this . currSize + "' bytes for entry '" + currName + "'" ) ; } if ( this . assemLen > 0 ) { if ( ( this . assemLen + numToWrite ) >= this . recordBuf . length ) { int aLen = this . recordBuf . length - this . assemLen ; System . arraycopy ( this . assemBuf , 0 , this . recordBuf , 0 , this . assemLen ) ; System . arraycopy ( wBuf , wOffset , this . recordBuf , this . assemLen , aLen ) ; this . buffer . writeRecord ( this . recordBuf ) ; this . currBytes += this . recordBuf . length ; wOffset += aLen ; numToWrite -= aLen ; this . assemLen = 0 ; } else { System . arraycopy ( wBuf , wOffset , this . assemBuf , this . assemLen , numToWrite ) ; wOffset += numToWrite ; this . assemLen += numToWrite ; numToWrite -= numToWrite ; } } while ( numToWrite > 0 ) { if ( numToWrite < this . recordBuf . length ) { System . arraycopy ( wBuf , wOffset , this . assemBuf , this . assemLen , numToWrite ) ; this . assemLen += numToWrite ; break ; } this . buffer . writeRecord ( wBuf , wOffset ) ; int num = this . recordBuf . length ; this . currBytes += num ; numToWrite -= num ; wOffset += num ; } } private void writeEOFRecord ( ) throws IOException { for ( int i = 0 ; i < this . recordBuf . length ; ++ i ) { this . recordBuf [ i ] = 0 ; } this . buffer . writeRecord ( this . recordBuf ) ; } } 	1	['15', '3', '0', '3', '39', '41', '1', '2', '14', '0.704081633', '469', '0.785714286', '1', '0.454545455', '0.311111111', '1', '2', '29.33333333', '1', '0.8', '1']
package org . apache . tools . ant . taskdefs . optional . ssh ; import java . io . File ; import java . io . IOException ; import java . io . EOFException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . FileOutputStream ; import java . io . ByteArrayOutputStream ; import com . jcraft . jsch . JSchException ; import com . jcraft . jsch . Session ; import com . jcraft . jsch . Channel ; public class ScpFromMessage extends AbstractSshMessage { private static final byte LINE_FEED = 0x0a ; private static final int BUFFER_SIZE = 1024 ; private String remoteFile ; private File localFile ; private boolean isRecursive = false ; public ScpFromMessage ( Session session ) { super ( session ) ; } public ScpFromMessage ( boolean verbose , Session session ) { super ( verbose , session ) ; } public ScpFromMessage ( boolean verbose , Session session , String aRemoteFile , File aLocalFile , boolean recursive ) { super ( verbose , session ) ; this . remoteFile = aRemoteFile ; this . localFile = aLocalFile ; this . isRecursive = recursive ; } public ScpFromMessage ( Session session , String aRemoteFile , File aLocalFile , boolean recursive ) { this ( false , session , aRemoteFile , aLocalFile , recursive ) ; } public void execute ( ) throws IOException , JSchException { String command = "scp -f " ; if ( isRecursive ) { command += "-r " ; } command += remoteFile ; Channel channel = openExecChannel ( command ) ; try { OutputStream out = channel . getOutputStream ( ) ; InputStream in = channel . getInputStream ( ) ; channel . connect ( ) ; sendAck ( out ) ; startRemoteCpProtocol ( in , out , localFile ) ; } finally { if ( channel != null ) { channel . disconnect ( ) ; } } log ( "done\n" ) ; } private void startRemoteCpProtocol ( InputStream in , OutputStream out , File localFile ) throws IOException { File startFile = localFile ; while ( true ) { ByteArrayOutputStream stream = new ByteArrayOutputStream ( ) ; while ( true ) { int read = in . read ( ) ; if ( read < 0 ) { return ; } if ( ( byte ) read == LINE_FEED ) { break ; } stream . write ( read ) ; } String serverResponse = stream . toString ( "UTF-8" ) ; if ( serverResponse . charAt ( 0 ) == 'C' ) { parseAndFetchFile ( serverResponse , startFile , out , in ) ; } else if ( serverResponse . charAt ( 0 ) == 'D' ) { startFile = parseAndCreateDirectory ( serverResponse , startFile ) ; sendAck ( out ) ; } else if ( serverResponse . charAt ( 0 ) == 'E' ) { startFile = startFile . getParentFile ( ) ; sendAck ( out ) ; } else if ( serverResponse . charAt ( 0 ) == '\01' || serverResponse . charAt ( 0 ) == '\02' ) { throw new IOException ( serverResponse . substring ( 1 ) ) ; } } } private File parseAndCreateDirectory ( String serverResponse , File localFile ) { int start = serverResponse . indexOf ( " " ) ; start = serverResponse . indexOf ( " " , start + 1 ) ; String directoryName = serverResponse . substring ( start + 1 ) ; if ( localFile . isDirectory ( ) ) { File dir = new File ( localFile , directoryName ) ; dir . mkdir ( ) ; log ( "Creating: " + dir ) ; return dir ; } return null ; } private void parseAndFetchFile ( String serverResponse , File localFile , OutputStream out , InputStream in ) throws IOException { int start = 0 ; int end = serverResponse . indexOf ( " " , start + 1 ) ; start = end + 1 ; end = serverResponse . indexOf ( " " , start + 1 ) ; long filesize = Long . parseLong ( serverResponse . substring ( start , end ) ) ; String filename = serverResponse . substring ( end + 1 ) ; log ( "Receiving: " + filename + " : " + filesize ) ; File transferFile = ( localFile . isDirectory ( ) ) ? new File ( localFile , filename ) : localFile ; fetchFile ( transferFile , filesize , out , in ) ; waitForAck ( in ) ; sendAck ( out ) ; } private void fetchFile ( File localFile , long filesize , OutputStream out , InputStream in ) throws IOException { byte [ ] buf = new byte [ BUFFER_SIZE ] ; sendAck ( out ) ; FileOutputStream fos = new FileOutputStream ( localFile ) ; int length ; long totalLength = 0 ; long startTime = System . currentTimeMillis ( ) ; boolean trackProgress = getVerbose ( ) && filesize > 102400 ; long initFilesize = filesize ; int percentTransmitted = 0 ; try { while ( true ) { length = in . read ( buf , 0 , ( BUFFER_SIZE < filesize ) ? BUFFER_SIZE : ( int ) filesize ) ; if ( length < 0 ) { throw new EOFException ( "Unexpected end of stream." ) ; } fos . write ( buf , 0 , length ) ; filesize -= length ; totalLength += length ; if ( filesize == 0 ) { break ; } if ( trackProgress ) { percentTransmitted = trackProgress ( initFilesize , totalLength , percentTransmitted ) ; } } } finally { long endTime = System . currentTimeMillis ( ) ; logStats ( startTime , endTime , totalLength ) ; fos . flush ( ) ; fos . close ( ) ; } } } 	1	['9', '2', '1', '6', '50', '24', '2', '4', '5', '0.85', '404', '1', '0', '0.6875', '0.458333333', '1', '3', '43.33333333', '2', '0.6667', '1']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . ZipFileSet ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . zip . ZipOutputStream ; public class Ear extends Jar { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private File deploymentDescriptor ; private boolean descriptorAdded ; public Ear ( ) { super ( ) ; archiveType = "ear" ; emptyBehavior = "create" ; } public void setEarfile ( File earFile ) { setDestFile ( earFile ) ; } public void setAppxml ( File descr ) { deploymentDescriptor = descr ; if ( ! deploymentDescriptor . exists ( ) ) { throw new BuildException ( "Deployment descriptor: " + deploymentDescriptor + " does not exist." ) ; } ZipFileSet fs = new ZipFileSet ( ) ; fs . setFile ( deploymentDescriptor ) ; fs . setFullpath ( "META-INF/application.xml" ) ; super . addFileset ( fs ) ; } public void addArchives ( ZipFileSet fs ) { fs . setPrefix ( "/" ) ; super . addFileset ( fs ) ; } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( deploymentDescriptor == null && ! isInUpdateMode ( ) ) { throw new BuildException ( "appxml attribute is required" , getLocation ( ) ) ; } super . initZipOutputStream ( zOut ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath , int mode ) throws IOException { if ( vPath . equalsIgnoreCase ( "META-INF/application.xml" ) ) { if ( deploymentDescriptor == null || ! FILE_UTILS . fileNameEquals ( deploymentDescriptor , file ) || descriptorAdded ) { log ( "Warning: selected " + archiveType + " files include a META-INF/application.xml which will" + " be ignored (please use appxml attribute to " + archiveType + " task)" , Project . MSG_WARN ) ; } else { super . zipFile ( file , zOut , vPath , mode ) ; descriptorAdded = true ; } } else { super . zipFile ( file , zOut , vPath , mode ) ; } } protected void cleanUp ( ) { descriptorAdded = false ; super . cleanUp ( ) ; } } 	1	['8', '6', '0', '7', '31', '16', '0', '7', '4', '0.80952381', '147', '1', '1', '0.9625', '0.357142857', '3', '9', '17', '2', '0.875', '1']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . rmi . Remote ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . rmic . RmicAdapter ; import org . apache . tools . ant . taskdefs . rmic . RmicAdapterFactory ; import org . apache . tools . ant . types . FilterSetCollection ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . SourceFileScanner ; import org . apache . tools . ant . util . facade . FacadeTaskHelper ; public class Rmic extends MatchingTask { public static final String ERROR_RMIC_FAILED = "Rmic failed; see the compiler error output for details." ; private File baseDir ; private String classname ; private File sourceBase ; private String stubVersion ; private Path compileClasspath ; private Path extDirs ; private boolean verify = false ; private boolean filtering = false ; private boolean iiop = false ; private String iiopOpts ; private boolean idl = false ; private String idlOpts ; private boolean debug = false ; private boolean includeAntRuntime = true ; private boolean includeJavaRuntime = false ; private Vector compileList = new Vector ( ) ; private ClassLoader loader = null ; private FacadeTaskHelper facade ; public static final String ERROR_UNABLE_TO_VERIFY_CLASS = "Unable to verify class " ; public static final String ERROR_NOT_FOUND = ". It could not be found." ; public static final String ERROR_NOT_DEFINED = ". It is not defined." ; public static final String ERROR_LOADING_CAUSED_EXCEPTION = ". Loading caused Exception: " ; public static final String ERROR_NO_BASE_EXISTS = "base does not exist: " ; public static final String ERROR_NOT_A_DIR = "base is not a directory:" ; public static final String ERROR_BASE_NOT_SET = "base attribute must be set!" ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; public Rmic ( ) { facade = new FacadeTaskHelper ( RmicAdapterFactory . DEFAULT_COMPILER ) ; } public void setBase ( File base ) { this . baseDir = base ; } public File getBase ( ) { return this . baseDir ; } public void setClassname ( String classname ) { this . classname = classname ; } public String getClassname ( ) { return classname ; } public void setSourceBase ( File sourceBase ) { this . sourceBase = sourceBase ; } public File getSourceBase ( ) { return sourceBase ; } public void setStubVersion ( String stubVersion ) { this . stubVersion = stubVersion ; } public String getStubVersion ( ) { return stubVersion ; } public void setFiltering ( boolean filter ) { this . filtering = filter ; } public boolean getFiltering ( ) { return filtering ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public boolean getDebug ( ) { return debug ; } public void setClasspath ( Path classpath ) { if ( compileClasspath == null ) { compileClasspath = classpath ; } else { compileClasspath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( compileClasspath == null ) { compileClasspath = new Path ( getProject ( ) ) ; } return compileClasspath . createPath ( ) ; } public void setClasspathRef ( Reference pathRef ) { createClasspath ( ) . setRefid ( pathRef ) ; } public Path getClasspath ( ) { return compileClasspath ; } public void setVerify ( boolean verify ) { this . verify = verify ; } public boolean getVerify ( ) { return verify ; } public void setIiop ( boolean iiop ) { this . iiop = iiop ; } public boolean getIiop ( ) { return iiop ; } public void setIiopopts ( String iiopOpts ) { this . iiopOpts = iiopOpts ; } public String getIiopopts ( ) { return iiopOpts ; } public void setIdl ( boolean idl ) { this . idl = idl ; } public boolean getIdl ( ) { return idl ; } public void setIdlopts ( String idlOpts ) { this . idlOpts = idlOpts ; } public String getIdlopts ( ) { return idlOpts ; } public Vector getFileList ( ) { return compileList ; } public void setIncludeantruntime ( boolean include ) { includeAntRuntime = include ; } public boolean getIncludeantruntime ( ) { return includeAntRuntime ; } public void setIncludejavaruntime ( boolean include ) { includeJavaRuntime = include ; } public boolean getIncludejavaruntime ( ) { return includeJavaRuntime ; } public void setExtdirs ( Path extDirs ) { if ( this . extDirs == null ) { this . extDirs = extDirs ; } else { this . extDirs . append ( extDirs ) ; } } public Path createExtdirs ( ) { if ( extDirs == null ) { extDirs = new Path ( getProject ( ) ) ; } return extDirs . createPath ( ) ; } public Path getExtdirs ( ) { return extDirs ; } public Vector getCompileList ( ) { return compileList ; } public void setCompiler ( String compiler ) { if ( compiler . length ( ) > 0 ) { facade . setImplementation ( compiler ) ; } } public String getCompiler ( ) { facade . setMagicValue ( getProject ( ) . getProperty ( "build.rmic" ) ) ; return facade . getImplementation ( ) ; } public ImplementationSpecificArgument createCompilerArg ( ) { ImplementationSpecificArgument arg = new ImplementationSpecificArgument ( ) ; facade . addImplementationArgument ( arg ) ; return arg ; } public String [ ] getCurrentCompilerArgs ( ) { getCompiler ( ) ; return facade . getArgs ( ) ; } public void execute ( ) throws BuildException { if ( baseDir == null ) { throw new BuildException ( ERROR_BASE_NOT_SET , getLocation ( ) ) ; } if ( ! baseDir . exists ( ) ) { throw new BuildException ( ERROR_NO_BASE_EXISTS + baseDir , getLocation ( ) ) ; } if ( ! baseDir . isDirectory ( ) ) { throw new BuildException ( ERROR_NOT_A_DIR + baseDir , getLocation ( ) ) ; } if ( verify ) { log ( "Verify has been turned on." , Project . MSG_VERBOSE ) ; } RmicAdapter adapter = RmicAdapterFactory . getRmic ( getCompiler ( ) , this ) ; adapter . setRmic ( this ) ; Path classpath = adapter . getClasspath ( ) ; loader = getProject ( ) . createClassLoader ( classpath ) ; try { if ( classname == null ) { DirectoryScanner ds = this . getDirectoryScanner ( baseDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( baseDir , files , adapter . getMapper ( ) ) ; } else { scanDir ( baseDir , new String [ ] { classname . replace ( '.' , File . separatorChar ) + ".class" } , adapter . getMapper ( ) ) ; } int fileCount = compileList . size ( ) ; if ( fileCount > 0 ) { log ( "RMI Compiling " + fileCount + " class" + ( fileCount > 1 ? "es" : "" ) + " to " + baseDir , Project . MSG_INFO ) ; if ( ! adapter . execute ( ) ) { throw new BuildException ( ERROR_RMIC_FAILED , getLocation ( ) ) ; } } if ( null != sourceBase && ! baseDir . equals ( sourceBase ) && fileCount > 0 ) { if ( idl ) { log ( "Cannot determine sourcefiles in idl mode, " , Project . MSG_WARN ) ; log ( "sourcebase attribute will be ignored." , Project . MSG_WARN ) ; } else { for ( int j = 0 ; j < fileCount ; j ++ ) { moveGeneratedFile ( baseDir , sourceBase , ( String ) compileList . elementAt ( j ) , adapter ) ; } } } } finally { compileList . removeAllElements ( ) ; } } private void moveGeneratedFile ( File baseDir , File sourceBaseFile , String classname , RmicAdapter adapter ) throws BuildException { String classFileName = classname . replace ( '.' , File . separatorChar ) + ".class" ; String [ ] generatedFiles = adapter . getMapper ( ) . mapFileName ( classFileName ) ; for ( int i = 0 ; i < generatedFiles . length ; i ++ ) { final String generatedFile = generatedFiles [ i ] ; if ( ! generatedFile . endsWith ( ".class" ) ) { continue ; } final int pos = generatedFile . length ( ) - ".class" . length ( ) ; String sourceFileName = generatedFile . substring ( 0 , pos ) + ".java" ; File oldFile = new File ( baseDir , sourceFileName ) ; if ( ! oldFile . exists ( ) ) { continue ; } File newFile = new File ( sourceBaseFile , sourceFileName ) ; try { if ( filtering ) { FILE_UTILS . copyFile ( oldFile , newFile , new FilterSetCollection ( getProject ( ) . getGlobalFilterSet ( ) ) ) ; } else { FILE_UTILS . copyFile ( oldFile , newFile ) ; } oldFile . delete ( ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + oldFile + " to " + newFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } } } protected void scanDir ( File baseDir , String [ ] files , FileNameMapper mapper ) { String [ ] newFiles = files ; if ( idl ) { log ( "will leave uptodate test to rmic implementation in idl mode." , Project . MSG_VERBOSE ) ; } else if ( iiop && iiopOpts != null && iiopOpts . indexOf ( "-always" ) > - 1 ) { log ( "no uptodate test as -always option has been specified" , Project . MSG_VERBOSE ) ; } else { SourceFileScanner sfs = new SourceFileScanner ( this ) ; newFiles = sfs . restrict ( files , baseDir , baseDir , mapper ) ; } for ( int i = 0 ; i < newFiles . length ; i ++ ) { String name = newFiles [ i ] . replace ( File . separatorChar , '.' ) ; name = name . substring ( 0 , name . lastIndexOf ( ".class" ) ) ; compileList . addElement ( name ) ; } } public boolean isValidRmiRemote ( String classname ) { try { Class testClass = loader . loadClass ( classname ) ; if ( testClass . isInterface ( ) && ! iiop && ! idl ) { return false ; } return isValidRmiRemote ( testClass ) ; } catch ( ClassNotFoundException e ) { log ( ERROR_UNABLE_TO_VERIFY_CLASS + classname + ERROR_NOT_FOUND , Project . MSG_WARN ) ; } catch ( NoClassDefFoundError e ) { log ( ERROR_UNABLE_TO_VERIFY_CLASS + classname + ERROR_NOT_DEFINED , Project . MSG_WARN ) ; } catch ( Throwable t ) { log ( ERROR_UNABLE_TO_VERIFY_CLASS + classname + ERROR_LOADING_CAUSED_EXCEPTION + t . getMessage ( ) , Project . MSG_WARN ) ; } return false ; } public Class getRemoteInterface ( Class testClass ) { if ( Remote . class . isAssignableFrom ( testClass ) ) { Class [ ] interfaces = testClass . getInterfaces ( ) ; if ( interfaces != null ) { for ( int i = 0 ; i < interfaces . length ; i ++ ) { if ( Remote . class . isAssignableFrom ( interfaces [ i ] ) ) { return interfaces [ i ] ; } } } } return null ; } private boolean isValidRmiRemote ( Class testClass ) { return getRemoteInterface ( testClass ) != null ; } public ClassLoader getLoader ( ) { return loader ; } public class ImplementationSpecificArgument extends org . apache . tools . ant . util . facade . ImplementationSpecificArgument { public void setCompiler ( String impl ) { super . setImplementation ( impl ) ; } } } 	1	['48', '4', '0', '25', '112', '962', '8', '19', '44', '0.965045593', '837', '0.678571429', '4', '0.629032258', '0.155319149', '3', '3', '15.85416667', '7', '1.375', '2']
package org . apache . tools . ant . util ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . regexp . RegexpMatcher ; import org . apache . tools . ant . util . regexp . RegexpMatcherFactory ; public class RegexpPatternMapper implements FileNameMapper { protected RegexpMatcher reg = null ; protected char [ ] to = null ; protected StringBuffer result = new StringBuffer ( ) ; public RegexpPatternMapper ( ) throws BuildException { reg = ( new RegexpMatcherFactory ( ) ) . newRegexpMatcher ( ) ; } private boolean handleDirSep = false ; private int regexpOptions = 0 ; public void setHandleDirSep ( boolean handleDirSep ) { this . handleDirSep = handleDirSep ; } public void setCaseSensitive ( boolean caseSensitive ) { if ( ! caseSensitive ) { regexpOptions = RegexpMatcher . MATCH_CASE_INSENSITIVE ; } else { regexpOptions = 0 ; } } public void setFrom ( String from ) throws BuildException { try { reg . setPattern ( from ) ; } catch ( NoClassDefFoundError e ) { throw new BuildException ( "Cannot load regular expression matcher" , e ) ; } } public void setTo ( String to ) { this . to = to . toCharArray ( ) ; } public String [ ] mapFileName ( String sourceFileName ) { if ( handleDirSep ) { if ( sourceFileName . indexOf ( "\\" ) != - 1 ) { sourceFileName = sourceFileName . replace ( '\\' , '/' ) ; } } if ( reg == null || to == null || ! reg . matches ( sourceFileName , regexpOptions ) ) { return null ; } return new String [ ] { replaceReferences ( sourceFileName ) } ; } protected String replaceReferences ( String source ) { Vector v = reg . getGroups ( source , regexpOptions ) ; result . setLength ( 0 ) ; for ( int i = 0 ; i < to . length ; i ++ ) { if ( to [ i ] == '\\' ) { if ( ++ i < to . length ) { int value = Character . digit ( to [ i ] , 10 ) ; if ( value > - 1 ) { result . append ( ( String ) v . elementAt ( value ) ) ; } else { result . append ( to [ i ] ) ; } } else { result . append ( '\\' ) ; } } else { result . append ( to [ i ] ) ; } } return result . substring ( 0 ) ; } } 	1	['7', '1', '0', '4', '24', '0', '0', '4', '6', '0.566666667', '186', '1', '1', '0', '0.619047619', '0', '0', '24.85714286', '6', '2.2857', '1']
package org . apache . tools . ant . filters . util ; import java . io . FilterReader ; import java . io . IOException ; import java . io . Reader ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . util . Vector ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . filters . BaseFilterReader ; import org . apache . tools . ant . filters . ChainableReader ; import org . apache . tools . ant . types . AntFilterReader ; import org . apache . tools . ant . types . FilterChain ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . types . Parameterizable ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileUtils ; public final class ChainReaderHelper { private static final int DEFAULT_BUFFER_SIZE = 8192 ; public Reader primaryReader ; public int bufferSize = DEFAULT_BUFFER_SIZE ; public Vector filterChains = new Vector ( ) ; private Project project = null ; public void setPrimaryReader ( Reader rdr ) { primaryReader = rdr ; } public void setProject ( final Project project ) { this . project = project ; } public Project getProject ( ) { return project ; } public void setBufferSize ( int size ) { bufferSize = size ; } public void setFilterChains ( Vector fchain ) { filterChains = fchain ; } public Reader getAssembledReader ( ) throws BuildException { if ( primaryReader == null ) { throw new BuildException ( "primaryReader must not be null." ) ; } Reader instream = primaryReader ; final int filterReadersCount = filterChains . size ( ) ; final Vector finalFilters = new Vector ( ) ; for ( int i = 0 ; i < filterReadersCount ; i ++ ) { final FilterChain filterchain = ( FilterChain ) filterChains . elementAt ( i ) ; final Vector filterReaders = filterchain . getFilterReaders ( ) ; final int readerCount = filterReaders . size ( ) ; for ( int j = 0 ; j < readerCount ; j ++ ) { finalFilters . addElement ( filterReaders . elementAt ( j ) ) ; } } final int filtersCount = finalFilters . size ( ) ; if ( filtersCount > 0 ) { for ( int i = 0 ; i < filtersCount ; i ++ ) { Object o = finalFilters . elementAt ( i ) ; if ( o instanceof AntFilterReader ) { final AntFilterReader filter = ( AntFilterReader ) finalFilters . elementAt ( i ) ; final String className = filter . getClassName ( ) ; final Path classpath = filter . getClasspath ( ) ; final Project pro = filter . getProject ( ) ; if ( className != null ) { try { Class clazz = null ; if ( classpath == null ) { clazz = Class . forName ( className ) ; } else { AntClassLoader al = pro . createClassLoader ( classpath ) ; clazz = Class . forName ( className , true , al ) ; } if ( clazz != null ) { if ( ! FilterReader . class . isAssignableFrom ( clazz ) ) { throw new BuildException ( className + " does not extend java.io.FilterReader" ) ; } final Constructor [ ] constructors = clazz . getConstructors ( ) ; int j = 0 ; boolean consPresent = false ; for ( ; j < constructors . length ; j ++ ) { Class [ ] types = constructors [ j ] . getParameterTypes ( ) ; if ( types . length == 1 && types [ 0 ] . isAssignableFrom ( Reader . class ) ) { consPresent = true ; break ; } } if ( ! consPresent ) { throw new BuildException ( className + " does not define a public constructor" + " that takes in a Reader as its " + "single argument." ) ; } final Reader [ ] rdr = { instream } ; instream = ( Reader ) constructors [ j ] . newInstance ( ( Object [ ] ) rdr ) ; setProjectOnObject ( instream ) ; if ( Parameterizable . class . isAssignableFrom ( clazz ) ) { final Parameter [ ] params = filter . getParams ( ) ; ( ( Parameterizable ) instream ) . setParameters ( params ) ; } } } catch ( final ClassNotFoundException cnfe ) { throw new BuildException ( cnfe ) ; } catch ( final InstantiationException ie ) { throw new BuildException ( ie ) ; } catch ( final IllegalAccessException iae ) { throw new BuildException ( iae ) ; } catch ( final InvocationTargetException ite ) { throw new BuildException ( ite ) ; } } } else if ( o instanceof ChainableReader ) { setProjectOnObject ( o ) ; instream = ( ( ChainableReader ) o ) . chain ( instream ) ; setProjectOnObject ( instream ) ; } } } return instream ; } private void setProjectOnObject ( Object obj ) { if ( project == null ) { return ; } if ( obj instanceof BaseFilterReader ) { ( ( BaseFilterReader ) obj ) . setProject ( project ) ; return ; } project . setProjectReference ( obj ) ; } public String readFully ( Reader rdr ) throws IOException { return FileUtils . readFully ( rdr , bufferSize ) ; } } 	1	['9', '1', '0', '17', '39', '10', '6', '11', '8', '0.875', '353', '0.25', '1', '0', '0.277777778', '0', '0', '37.33333333', '3', '1.1111', '1']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Vector ; import java . util . Enumeration ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . DirSet ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . FileList ; import org . apache . tools . ant . types . PropertySet ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . taskdefs . Ant . TargetElement ; public class SubAnt extends Task { private Path buildpath ; private Ant ant = null ; private String subTarget = null ; private String antfile = "build.xml" ; private File genericantfile = null ; private boolean verbose = false ; private boolean inheritAll = false ; private boolean inheritRefs = false ; private boolean failOnError = true ; private String output = null ; private Vector properties = new Vector ( ) ; private Vector references = new Vector ( ) ; private Vector propertySets = new Vector ( ) ; private Vector targets = new Vector ( ) ; public void handleOutput ( String output ) { if ( ant != null ) { ant . handleOutput ( output ) ; } else { super . handleOutput ( output ) ; } } public int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException { if ( ant != null ) { return ant . handleInput ( buffer , offset , length ) ; } else { return super . handleInput ( buffer , offset , length ) ; } } public void handleFlush ( String output ) { if ( ant != null ) { ant . handleFlush ( output ) ; } else { super . handleFlush ( output ) ; } } public void handleErrorOutput ( String output ) { if ( ant != null ) { ant . handleErrorOutput ( output ) ; } else { super . handleErrorOutput ( output ) ; } } public void handleErrorFlush ( String output ) { if ( ant != null ) { ant . handleErrorFlush ( output ) ; } else { super . handleErrorFlush ( output ) ; } } public void execute ( ) { if ( buildpath == null ) { throw new BuildException ( "No buildpath specified" ) ; } final String [ ] filenames = buildpath . list ( ) ; final int count = filenames . length ; if ( count < 1 ) { log ( "No sub-builds to iterate on" , Project . MSG_WARN ) ; return ; } BuildException buildException = null ; for ( int i = 0 ; i < count ; ++ i ) { File file = null ; String subdirPath = null ; Throwable thrownException = null ; try { File directory = null ; file = new File ( filenames [ i ] ) ; if ( file . isDirectory ( ) ) { if ( verbose ) { subdirPath = file . getPath ( ) ; log ( "Entering directory: " + subdirPath + "\n" , Project . MSG_INFO ) ; } if ( genericantfile != null ) { directory = file ; file = genericantfile ; } else { file = new File ( file , antfile ) ; } } execute ( file , directory ) ; if ( verbose && subdirPath != null ) { log ( "Leaving directory: " + subdirPath + "\n" , Project . MSG_INFO ) ; } } catch ( RuntimeException ex ) { if ( ! ( getProject ( ) . isKeepGoingMode ( ) ) ) { if ( verbose && subdirPath != null ) { log ( "Leaving directory: " + subdirPath + "\n" , Project . MSG_INFO ) ; } throw ex ; } thrownException = ex ; } catch ( Throwable ex ) { if ( ! ( getProject ( ) . isKeepGoingMode ( ) ) ) { if ( verbose && subdirPath != null ) { log ( "Leaving directory: " + subdirPath + "\n" , Project . MSG_INFO ) ; } throw new BuildException ( ex ) ; } thrownException = ex ; } if ( thrownException != null ) { if ( thrownException instanceof BuildException ) { log ( "File '" + file + "' failed with message '" + thrownException . getMessage ( ) + "'." , Project . MSG_ERR ) ; if ( buildException == null ) { buildException = ( BuildException ) thrownException ; } } else { log ( "Target '" + file + "' failed with message '" + thrownException . getMessage ( ) + "'." , Project . MSG_ERR ) ; thrownException . printStackTrace ( System . err ) ; if ( buildException == null ) { buildException = new BuildException ( thrownException ) ; } } if ( verbose && subdirPath != null ) { log ( "Leaving directory: " + subdirPath + "\n" , Project . MSG_INFO ) ; } } } if ( buildException != null ) { throw buildException ; } } private void execute ( File file , File directory ) throws BuildException { if ( ! file . exists ( ) || file . isDirectory ( ) || ! file . canRead ( ) ) { String msg = "Invalid file: " + file ; if ( failOnError ) { throw new BuildException ( msg ) ; } log ( msg , Project . MSG_WARN ) ; return ; } ant = createAntTask ( directory ) ; String antfilename = file . getAbsolutePath ( ) ; ant . setAntfile ( antfilename ) ; for ( int i = 0 ; i < targets . size ( ) ; i ++ ) { TargetElement targetElement = ( TargetElement ) targets . get ( i ) ; ant . addConfiguredTarget ( targetElement ) ; } try { ant . execute ( ) ; } catch ( BuildException e ) { if ( failOnError ) { throw e ; } log ( "Failure for target '" + subTarget + "' of: " + antfilename + "\n" + e . getMessage ( ) , Project . MSG_WARN ) ; } catch ( Throwable e ) { if ( failOnError ) { throw new BuildException ( e ) ; } log ( "Failure for target '" + subTarget + "' of: " + antfilename + "\n" + e . toString ( ) , Project . MSG_WARN ) ; } finally { ant = null ; } } public void setAntfile ( String antfile ) { this . antfile = antfile ; } public void setGenericAntfile ( File afile ) { this . genericantfile = afile ; } public void setFailonerror ( boolean failOnError ) { this . failOnError = failOnError ; } public void setTarget ( String target ) { this . subTarget = target ; } public void addConfiguredTarget ( TargetElement t ) { String name = t . getName ( ) ; if ( "" . equals ( name ) ) { throw new BuildException ( "target name must not be empty" ) ; } targets . add ( t ) ; } public void setVerbose ( boolean on ) { this . verbose = on ; } public void setOutput ( String s ) { this . output = s ; } public void setInheritall ( boolean b ) { this . inheritAll = b ; } public void setInheritrefs ( boolean b ) { this . inheritRefs = b ; } public void addProperty ( Property p ) { properties . addElement ( p ) ; } public void addReference ( Ant . Reference r ) { references . addElement ( r ) ; } public void addPropertyset ( PropertySet ps ) { propertySets . addElement ( ps ) ; } public void addDirset ( DirSet set ) { add ( set ) ; } public void addFileset ( FileSet set ) { add ( set ) ; } public void addFilelist ( FileList list ) { add ( list ) ; } public void add ( ResourceCollection rc ) { getBuildpath ( ) . add ( rc ) ; } public void setBuildpath ( Path s ) { getBuildpath ( ) . append ( s ) ; } public Path createBuildpath ( ) { return getBuildpath ( ) . createPath ( ) ; } public Path . PathElement createBuildpathElement ( ) { return getBuildpath ( ) . createPathElement ( ) ; } private Path getBuildpath ( ) { if ( buildpath == null ) { buildpath = new Path ( getProject ( ) ) ; } return buildpath ; } public void setBuildpathRef ( Reference r ) { createBuildpath ( ) . setRefid ( r ) ; } private Ant createAntTask ( File directory ) { Ant antTask = new Ant ( this ) ; antTask . init ( ) ; if ( subTarget != null && subTarget . length ( ) > 0 ) { antTask . setTarget ( subTarget ) ; } if ( output != null ) { antTask . setOutput ( output ) ; } if ( directory != null ) { antTask . setDir ( directory ) ; } antTask . setInheritAll ( inheritAll ) ; for ( Enumeration i = properties . elements ( ) ; i . hasMoreElements ( ) ; ) { copyProperty ( antTask . createProperty ( ) , ( Property ) i . nextElement ( ) ) ; } for ( Enumeration i = propertySets . elements ( ) ; i . hasMoreElements ( ) ; ) { antTask . addPropertyset ( ( PropertySet ) i . nextElement ( ) ) ; } antTask . setInheritRefs ( inheritRefs ) ; for ( Enumeration i = references . elements ( ) ; i . hasMoreElements ( ) ; ) { antTask . addReference ( ( Ant . Reference ) i . nextElement ( ) ) ; } return antTask ; } private static void copyProperty ( Property to , Property from ) { to . setName ( from . getName ( ) ) ; if ( from . getValue ( ) != null ) { to . setValue ( from . getValue ( ) ) ; } if ( from . getFile ( ) != null ) { to . setFile ( from . getFile ( ) ) ; } if ( from . getResource ( ) != null ) { to . setResource ( from . getResource ( ) ) ; } if ( from . getPrefix ( ) != null ) { to . setPrefix ( from . getPrefix ( ) ) ; } if ( from . getRefid ( ) != null ) { to . setRefid ( from . getRefid ( ) ) ; } if ( from . getEnvironment ( ) != null ) { to . setEnvironment ( from . getEnvironment ( ) ) ; } if ( from . getClasspath ( ) != null ) { to . setClasspath ( from . getClasspath ( ) ) ; } } } 	1	['31', '3', '0', '15', '109', '365', '0', '15', '27', '0.888095238', '778', '1', '2', '0.552238806', '0.114919355', '1', '3', '23.64516129', '22', '2.2903', '1']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . PrintStream ; import java . lang . reflect . Method ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . Vector ; import java . util . Set ; import java . util . HashSet ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . BuildListener ; import org . apache . tools . ant . DefaultLogger ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . Target ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . MagicNames ; import org . apache . tools . ant . Main ; import org . apache . tools . ant . types . PropertySet ; import org . apache . tools . ant . util . FileUtils ; public class Ant extends Task { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private File dir = null ; private String antFile = null ; private String output = null ; private boolean inheritAll = true ; private boolean inheritRefs = false ; private Vector properties = new Vector ( ) ; private Vector references = new Vector ( ) ; private Project newProject ; private PrintStream out = null ; private Vector propertySets = new Vector ( ) ; private Vector targets = new Vector ( ) ; private boolean targetAttributeSet = false ; public Ant ( ) { } public Ant ( Task owner ) { bindToOwner ( owner ) ; } public void setInheritAll ( boolean value ) { inheritAll = value ; } public void setInheritRefs ( boolean value ) { inheritRefs = value ; } public void init ( ) { newProject = getProject ( ) . createSubProject ( ) ; newProject . setJavaVersionProperty ( ) ; } private void reinit ( ) { init ( ) ; } private void initializeProject ( ) { newProject . setInputHandler ( getProject ( ) . getInputHandler ( ) ) ; Iterator iter = getBuildListeners ( ) ; while ( iter . hasNext ( ) ) { newProject . addBuildListener ( ( BuildListener ) iter . next ( ) ) ; } if ( output != null ) { File outfile = null ; if ( dir != null ) { outfile = FILE_UTILS . resolveFile ( dir , output ) ; } else { outfile = getProject ( ) . resolveFile ( output ) ; } try { out = new PrintStream ( new FileOutputStream ( outfile ) ) ; DefaultLogger logger = new DefaultLogger ( ) ; logger . setMessageOutputLevel ( Project . MSG_INFO ) ; logger . setOutputPrintStream ( out ) ; logger . setErrorPrintStream ( out ) ; newProject . addBuildListener ( logger ) ; } catch ( IOException ex ) { log ( "Ant: Can't set output to " + output ) ; } } getProject ( ) . copyUserProperties ( newProject ) ; if ( ! inheritAll ) { newProject . setSystemProperties ( ) ; } else { addAlmostAll ( getProject ( ) . getProperties ( ) ) ; } Enumeration e = propertySets . elements ( ) ; while ( e . hasMoreElements ( ) ) { PropertySet ps = ( PropertySet ) e . nextElement ( ) ; addAlmostAll ( ps . getProperties ( ) ) ; } } public void handleOutput ( String outputToHandle ) { if ( newProject != null ) { newProject . demuxOutput ( outputToHandle , false ) ; } else { super . handleOutput ( outputToHandle ) ; } } public int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException { if ( newProject != null ) { return newProject . demuxInput ( buffer , offset , length ) ; } return super . handleInput ( buffer , offset , length ) ; } public void handleFlush ( String toFlush ) { if ( newProject != null ) { newProject . demuxFlush ( toFlush , false ) ; } else { super . handleFlush ( toFlush ) ; } } public void handleErrorOutput ( String errorOutputToHandle ) { if ( newProject != null ) { newProject . demuxOutput ( errorOutputToHandle , true ) ; } else { super . handleErrorOutput ( errorOutputToHandle ) ; } } public void handleErrorFlush ( String errorOutputToFlush ) { if ( newProject != null ) { newProject . demuxFlush ( errorOutputToFlush , true ) ; } else { super . handleErrorFlush ( errorOutputToFlush ) ; } } public void execute ( ) throws BuildException { File savedDir = dir ; String savedAntFile = antFile ; Vector locals = new Vector ( targets ) ; try { getNewProject ( ) ; if ( dir == null && inheritAll ) { dir = getProject ( ) . getBaseDir ( ) ; } initializeProject ( ) ; if ( dir != null ) { newProject . setBaseDir ( dir ) ; if ( savedDir != null ) { newProject . setInheritedProperty ( MagicNames . PROJECT_BASEDIR , dir . getAbsolutePath ( ) ) ; } } else { dir = getProject ( ) . getBaseDir ( ) ; } overrideProperties ( ) ; if ( antFile == null ) { antFile = Main . DEFAULT_BUILD_FILENAME ; } File file = FILE_UTILS . resolveFile ( dir , antFile ) ; antFile = file . getAbsolutePath ( ) ; log ( "calling target(s) " + ( ( locals . size ( ) > 0 ) ? locals . toString ( ) : "[default]" ) + " in build file " + antFile , Project . MSG_VERBOSE ) ; newProject . setUserProperty ( MagicNames . ANT_FILE , antFile ) ; String thisAntFile = getProject ( ) . getProperty ( MagicNames . ANT_FILE ) ; if ( thisAntFile != null && file . equals ( getProject ( ) . resolveFile ( thisAntFile ) ) && getOwningTarget ( ) != null ) { if ( getOwningTarget ( ) . getName ( ) . equals ( "" ) ) { if ( getTaskName ( ) . equals ( "antcall" ) ) { throw new BuildException ( "antcall must not be used at" + " the top level." ) ; } throw new BuildException ( getTaskName ( ) + " task at the" + " top level must not invoke" + " its own build file." ) ; } } try { ProjectHelper . configureProject ( newProject , file ) ; } catch ( BuildException ex ) { throw ProjectHelper . addLocationToBuildException ( ex , getLocation ( ) ) ; } if ( locals . size ( ) == 0 ) { String defaultTarget = newProject . getDefaultTarget ( ) ; if ( defaultTarget != null ) { locals . add ( defaultTarget ) ; } } if ( newProject . getProperty ( MagicNames . ANT_FILE ) . equals ( getProject ( ) . getProperty ( MagicNames . ANT_FILE ) ) && getOwningTarget ( ) != null ) { String owningTargetName = getOwningTarget ( ) . getName ( ) ; if ( locals . contains ( owningTargetName ) ) { throw new BuildException ( getTaskName ( ) + " task calling " + "its own parent target." ) ; } boolean circular = false ; for ( Iterator it = locals . iterator ( ) ; ! circular && it . hasNext ( ) ; ) { Target other = ( Target ) ( getProject ( ) . getTargets ( ) . get ( it . next ( ) ) ) ; circular |= ( other != null && other . dependsOn ( owningTargetName ) ) ; } if ( circular ) { throw new BuildException ( getTaskName ( ) + " task calling a target" + " that depends on" + " its parent target \'" + owningTargetName + "\'." ) ; } } addReferences ( ) ; if ( locals . size ( ) > 0 && ! ( locals . size ( ) == 1 && "" . equals ( locals . get ( 0 ) ) ) ) { BuildException be = null ; try { log ( "Entering " + antFile + "..." , Project . MSG_VERBOSE ) ; newProject . fireSubBuildStarted ( ) ; newProject . executeTargets ( locals ) ; } catch ( BuildException ex ) { be = ProjectHelper . addLocationToBuildException ( ex , getLocation ( ) ) ; throw be ; } finally { log ( "Exiting " + antFile + "." , Project . MSG_VERBOSE ) ; newProject . fireSubBuildFinished ( be ) ; } } } finally { newProject = null ; Enumeration e = properties . elements ( ) ; while ( e . hasMoreElements ( ) ) { Property p = ( Property ) e . nextElement ( ) ; p . setProject ( null ) ; } if ( output != null && out != null ) { try { out . close ( ) ; } catch ( final Exception ex ) { } } dir = savedDir ; antFile = savedAntFile ; } } private void overrideProperties ( ) throws BuildException { Set set = new HashSet ( ) ; for ( int i = properties . size ( ) - 1 ; i >= 0 ; -- i ) { Property p = ( Property ) properties . get ( i ) ; if ( p . getName ( ) != null && ! p . getName ( ) . equals ( "" ) ) { if ( set . contains ( p . getName ( ) ) ) { properties . remove ( i ) ; } else { set . add ( p . getName ( ) ) ; } } } Enumeration e = properties . elements ( ) ; while ( e . hasMoreElements ( ) ) { Property p = ( Property ) e . nextElement ( ) ; p . setProject ( newProject ) ; p . execute ( ) ; } getProject ( ) . copyInheritedProperties ( newProject ) ; } private void addReferences ( ) throws BuildException { Hashtable thisReferences = ( Hashtable ) getProject ( ) . getReferences ( ) . clone ( ) ; Hashtable newReferences = newProject . getReferences ( ) ; Enumeration e ; if ( references . size ( ) > 0 ) { for ( e = references . elements ( ) ; e . hasMoreElements ( ) ; ) { Reference ref = ( Reference ) e . nextElement ( ) ; String refid = ref . getRefId ( ) ; if ( refid == null ) { throw new BuildException ( "the refid attribute is required" + " for reference elements" ) ; } if ( ! thisReferences . containsKey ( refid ) ) { log ( "Parent project doesn't contain any reference '" + refid + "'" , Project . MSG_WARN ) ; continue ; } thisReferences . remove ( refid ) ; String toRefid = ref . getToRefid ( ) ; if ( toRefid == null ) { toRefid = refid ; } copyReference ( refid , toRefid ) ; } } if ( inheritRefs ) { for ( e = thisReferences . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; if ( newReferences . containsKey ( key ) ) { continue ; } copyReference ( key , key ) ; newProject . inheritIDReferences ( getProject ( ) ) ; } } } private void copyReference ( String oldKey , String newKey ) { Object orig = getProject ( ) . getReference ( oldKey ) ; if ( orig == null ) { log ( "No object referenced by " + oldKey + ". Can't copy to " + newKey , Project . MSG_WARN ) ; return ; } Class c = orig . getClass ( ) ; Object copy = orig ; try { Method cloneM = c . getMethod ( "clone" , new Class [ 0 ] ) ; if ( cloneM != null ) { copy = cloneM . invoke ( orig , new Object [ 0 ] ) ; log ( "Adding clone of reference " + oldKey , Project . MSG_DEBUG ) ; } } catch ( Exception e ) { } if ( copy instanceof ProjectComponent ) { ( ( ProjectComponent ) copy ) . setProject ( newProject ) ; } else { try { Method setProjectM = c . getMethod ( "setProject" , new Class [ ] { Project . class } ) ; if ( setProjectM != null ) { setProjectM . invoke ( copy , new Object [ ] { newProject } ) ; } } catch ( NoSuchMethodException e ) { } catch ( Exception e2 ) { String msg = "Error setting new project instance for " + "reference with id " + oldKey ; throw new BuildException ( msg , e2 , getLocation ( ) ) ; } } newProject . addReference ( newKey , copy ) ; } private void addAlmostAll ( Hashtable props ) { Enumeration e = props . keys ( ) ; while ( e . hasMoreElements ( ) ) { String key = e . nextElement ( ) . toString ( ) ; if ( MagicNames . PROJECT_BASEDIR . equals ( key ) || MagicNames . ANT_FILE . equals ( key ) ) { continue ; } String value = props . get ( key ) . toString ( ) ; if ( newProject . getProperty ( key ) == null ) { newProject . setNewProperty ( key , value ) ; } } } public void setDir ( File dir ) { this . dir = dir ; } public void setAntfile ( String antFile ) { this . antFile = antFile ; } public void setTarget ( String targetToAdd ) { if ( targetToAdd . equals ( "" ) ) { throw new BuildException ( "target attribute must not be empty" ) ; } targets . add ( targetToAdd ) ; targetAttributeSet = true ; } public void setOutput ( String outputFile ) { this . output = outputFile ; } public Property createProperty ( ) { Property p = new Property ( true , getProject ( ) ) ; p . setProject ( getNewProject ( ) ) ; p . setTaskName ( "property" ) ; properties . addElement ( p ) ; return p ; } public void addReference ( Reference ref ) { references . addElement ( ref ) ; } public void addConfiguredTarget ( TargetElement t ) { if ( targetAttributeSet ) { throw new BuildException ( "nested target is incompatible with the target attribute" ) ; } String name = t . getName ( ) ; if ( name . equals ( "" ) ) { throw new BuildException ( "target name must not be empty" ) ; } targets . add ( name ) ; } public void addPropertyset ( PropertySet ps ) { propertySets . addElement ( ps ) ; } protected Project getNewProject ( ) { if ( newProject == null ) { reinit ( ) ; } return newProject ; } private Iterator getBuildListeners ( ) { return getProject ( ) . getBuildListeners ( ) . iterator ( ) ; } public static class Reference extends org . apache . tools . ant . types . Reference { public Reference ( ) { super ( ) ; } private String targetid = null ; public void setToRefid ( String targetid ) { this . targetid = targetid ; } public String getToRefid ( ) { return targetid ; } } public static class TargetElement { private String name ; public TargetElement ( ) { } public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } } } 	1	['28', '3', '0', '18', '132', '130', '3', '15', '19', '0.846560847', '1139', '0.928571429', '2', '0.596774194', '0.151515152', '3', '5', '39.17857143', '6', '1.6786', '3']
package org . apache . tools . ant . util ; import java . text . ChoiceFormat ; import java . text . DateFormat ; import java . text . MessageFormat ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Date ; import java . util . Locale ; import java . util . TimeZone ; public final class DateUtils { public static final String ISO8601_DATETIME_PATTERN = "yyyy-MM-dd'T'HH:mm:ss" ; public static final String ISO8601_DATE_PATTERN = "yyyy-MM-dd" ; public static final String ISO8601_TIME_PATTERN = "HH:mm:ss" ; public static final DateFormat DATE_HEADER_FORMAT = new SimpleDateFormat ( "EEE, dd MMM yyyy HH:mm:ss " , Locale . US ) ; private static final MessageFormat MINUTE_SECONDS = new MessageFormat ( "{0}{1}" ) ; private static final double [ ] LIMITS = { 0 , 1 , 2 } ; private static final String [ ] MINUTES_PART = { "" , "1 minute " , "{0,number} minutes " } ; private static final String [ ] SECONDS_PART = { "0 seconds" , "1 second" , "{1,number} seconds" } ; private static final ChoiceFormat MINUTES_FORMAT = new ChoiceFormat ( LIMITS , MINUTES_PART ) ; private static final ChoiceFormat SECONDS_FORMAT = new ChoiceFormat ( LIMITS , SECONDS_PART ) ; static { MINUTE_SECONDS . setFormat ( 0 , MINUTES_FORMAT ) ; MINUTE_SECONDS . setFormat ( 1 , SECONDS_FORMAT ) ; } private DateUtils ( ) { } public static String format ( long date , String pattern ) { return format ( new Date ( date ) , pattern ) ; } public static String format ( Date date , String pattern ) { DateFormat df = createDateFormat ( pattern ) ; return df . format ( date ) ; } public static String formatElapsedTime ( long millis ) { long seconds = millis / 1000 ; long minutes = seconds / 60 ; Object [ ] args = { new Long ( minutes ) , new Long ( seconds % 60 ) } ; return MINUTE_SECONDS . format ( args ) ; } private static DateFormat createDateFormat ( String pattern ) { SimpleDateFormat sdf = new SimpleDateFormat ( pattern ) ; TimeZone gmt = TimeZone . getTimeZone ( "GMT" ) ; sdf . setTimeZone ( gmt ) ; sdf . setLenient ( true ) ; return sdf ; } public static int getPhaseOfMoon ( Calendar cal ) { int dayOfTheYear = cal . get ( Calendar . DAY_OF_YEAR ) ; int yearInMetonicCycle = ( ( cal . get ( Calendar . YEAR ) - 1900 ) % 19 ) + 1 ; int epact = ( 11 * yearInMetonicCycle + 18 ) % 30 ; if ( ( epact == 25 && yearInMetonicCycle > 11 ) || epact == 24 ) { epact ++ ; } return ( ( ( ( ( dayOfTheYear + epact ) * 6 ) + 11 ) % 177 ) / 22 ) & 7 ; } public static String getDateForHeader ( ) { Calendar cal = Calendar . getInstance ( ) ; TimeZone tz = cal . getTimeZone ( ) ; int offset = tz . getOffset ( cal . get ( Calendar . ERA ) , cal . get ( Calendar . YEAR ) , cal . get ( Calendar . MONTH ) , cal . get ( Calendar . DAY_OF_MONTH ) , cal . get ( Calendar . DAY_OF_WEEK ) , cal . get ( Calendar . MILLISECOND ) ) ; StringBuffer tzMarker = new StringBuffer ( offset < 0 ? "-" : "+" ) ; offset = Math . abs ( offset ) ; int hours = offset / ( 60 * 60 * 1000 ) ; int minutes = offset / ( 60 * 1000 ) - 60 * hours ; if ( hours < 10 ) { tzMarker . append ( "0" ) ; } tzMarker . append ( hours ) ; if ( minutes < 10 ) { tzMarker . append ( "0" ) ; } tzMarker . append ( minutes ) ; return DATE_HEADER_FORMAT . format ( cal . getTime ( ) ) + tzMarker . toString ( ) ; } public static Date parseIso8601DateTime ( String datestr ) throws ParseException { return new SimpleDateFormat ( ISO8601_DATETIME_PATTERN ) . parse ( datestr ) ; } public static Date parseIso8601Date ( String datestr ) throws ParseException { return new SimpleDateFormat ( ISO8601_DATE_PATTERN ) . parse ( datestr ) ; } public static Date parseIso8601DateTimeOrDate ( String datestr ) throws ParseException { try { return parseIso8601DateTime ( datestr ) ; } catch ( ParseException px ) { return parseIso8601Date ( datestr ) ; } } } 	1	['11', '1', '0', '4', '36', '51', '4', '0', '8', '1.01', '314', '0.6', '0', '0', '0.22', '0', '0', '26.63636364', '4', '1.3636', '1']
package org . apache . tools . ant . taskdefs ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public class StreamPumper implements Runnable { private InputStream is ; private OutputStream os ; private volatile boolean finish ; private volatile boolean finished ; private boolean closeWhenExhausted ; private boolean autoflush = false ; private Exception exception = null ; private int bufferSize = 128 ; private boolean started = false ; public StreamPumper ( InputStream is , OutputStream os , boolean closeWhenExhausted ) { this . is = is ; this . os = os ; this . closeWhenExhausted = closeWhenExhausted ; } public StreamPumper ( InputStream is , OutputStream os ) { this ( is , os , false ) ; } void setAutoflush ( boolean autoflush ) { this . autoflush = autoflush ; } public void run ( ) { synchronized ( this ) { started = true ; } finished = false ; finish = false ; final byte [ ] buf = new byte [ bufferSize ] ; int length ; try { while ( ( length = is . read ( buf ) ) > 0 && ! finish ) { os . write ( buf , 0 , length ) ; if ( autoflush ) { os . flush ( ) ; } } os . flush ( ) ; } catch ( Exception e ) { synchronized ( this ) { exception = e ; } } finally { if ( closeWhenExhausted ) { try { os . close ( ) ; } catch ( IOException e ) { } } finished = true ; synchronized ( this ) { notifyAll ( ) ; } } } public boolean isFinished ( ) { return finished ; } public synchronized void waitFor ( ) throws InterruptedException { while ( ! isFinished ( ) ) { wait ( ) ; } } public synchronized void setBufferSize ( int bufferSize ) { if ( started ) { throw new IllegalStateException ( "Cannot set buffer size on a running StreamPumper" ) ; } this . bufferSize = bufferSize ; } public synchronized int getBufferSize ( ) { return bufferSize ; } public synchronized Exception getException ( ) { return exception ; } synchronized void stop ( ) { finish = true ; notifyAll ( ) ; } } 	1	['10', '1', '0', '5', '18', '21', '5', '0', '8', '0.728395062', '182', '1', '0', '0', '0.34', '0', '0', '16.3', '7', '1.5', '1']
package org . apache . tools . ant . taskdefs ; import java . sql . Connection ; import java . sql . DatabaseMetaData ; import java . sql . Driver ; import java . sql . SQLException ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Locale ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; public abstract class JDBCTask extends Task { private static Hashtable loaderMap = new Hashtable ( 3 ) ; private boolean caching = true ; private Path classpath ; private AntClassLoader loader ; private boolean autocommit = false ; private String driver = null ; private String url = null ; private String userId = null ; private String password = null ; private String rdbms = null ; private String version = null ; public void setClasspath ( Path classpath ) { this . classpath = classpath ; } public void setCaching ( boolean enable ) { caching = enable ; } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setDriver ( String driver ) { this . driver = driver . trim ( ) ; } public void setUrl ( String url ) { this . url = url ; } public void setPassword ( String password ) { this . password = password ; } public void setAutocommit ( boolean autocommit ) { this . autocommit = autocommit ; } public void setRdbms ( String rdbms ) { this . rdbms = rdbms ; } public void setVersion ( String version ) { this . version = version ; } protected boolean isValidRdbms ( Connection conn ) { if ( rdbms == null && version == null ) { return true ; } try { DatabaseMetaData dmd = conn . getMetaData ( ) ; if ( rdbms != null ) { String theVendor = dmd . getDatabaseProductName ( ) . toLowerCase ( ) ; log ( "RDBMS = " + theVendor , Project . MSG_VERBOSE ) ; if ( theVendor == null || theVendor . indexOf ( rdbms ) < 0 ) { log ( "Not the required RDBMS: " + rdbms , Project . MSG_VERBOSE ) ; return false ; } } if ( version != null ) { String theVersion = dmd . getDatabaseProductVersion ( ) . toLowerCase ( Locale . ENGLISH ) ; log ( "Version = " + theVersion , Project . MSG_VERBOSE ) ; if ( theVersion == null || ! ( theVersion . startsWith ( version ) || theVersion . indexOf ( " " + version ) >= 0 ) ) { log ( "Not the required version: \"" + version + "\"" , Project . MSG_VERBOSE ) ; return false ; } } } catch ( SQLException e ) { log ( "Failed to obtain required RDBMS information" , Project . MSG_ERR ) ; return false ; } return true ; } protected static Hashtable getLoaderMap ( ) { return loaderMap ; } protected AntClassLoader getLoader ( ) { return loader ; } protected Connection getConnection ( ) throws BuildException { if ( userId == null ) { throw new BuildException ( "UserId attribute must be set!" , getLocation ( ) ) ; } if ( password == null ) { throw new BuildException ( "Password attribute must be set!" , getLocation ( ) ) ; } if ( url == null ) { throw new BuildException ( "Url attribute must be set!" , getLocation ( ) ) ; } try { log ( "connecting to " + getUrl ( ) , Project . MSG_VERBOSE ) ; Properties info = new Properties ( ) ; info . put ( "user" , getUserId ( ) ) ; info . put ( "password" , getPassword ( ) ) ; Connection conn = getDriver ( ) . connect ( getUrl ( ) , info ) ; if ( conn == null ) { throw new SQLException ( "No suitable Driver for " + url ) ; } conn . setAutoCommit ( autocommit ) ; return conn ; } catch ( SQLException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } private Driver getDriver ( ) throws BuildException { if ( driver == null ) { throw new BuildException ( "Driver attribute must be set!" , getLocation ( ) ) ; } Driver driverInstance = null ; try { Class dc ; if ( classpath != null ) { synchronized ( loaderMap ) { if ( caching ) { loader = ( AntClassLoader ) loaderMap . get ( driver ) ; } if ( loader == null ) { log ( "Loading " + driver + " using AntClassLoader with classpath " + classpath , Project . MSG_VERBOSE ) ; loader = getProject ( ) . createClassLoader ( classpath ) ; if ( caching ) { loaderMap . put ( driver , loader ) ; } } else { log ( "Loading " + driver + " using a cached AntClassLoader." , Project . MSG_VERBOSE ) ; } } dc = loader . loadClass ( driver ) ; } else { log ( "Loading " + driver + " using system loader." , Project . MSG_VERBOSE ) ; dc = Class . forName ( driver ) ; } driverInstance = ( Driver ) dc . newInstance ( ) ; } catch ( ClassNotFoundException e ) { throw new BuildException ( "Class Not Found: JDBC driver " + driver + " could not be loaded" , e , getLocation ( ) ) ; } catch ( IllegalAccessException e ) { throw new BuildException ( "Illegal Access: JDBC driver " + driver + " could not be loaded" , e , getLocation ( ) ) ; } catch ( InstantiationException e ) { throw new BuildException ( "Instantiation Exception: JDBC driver " + driver + " could not be loaded" , e , getLocation ( ) ) ; } return driverInstance ; } public void isCaching ( boolean value ) { caching = value ; } public Path getClasspath ( ) { return classpath ; } public boolean isAutocommit ( ) { return autocommit ; } public String getUrl ( ) { return url ; } public String getUserId ( ) { return userId ; } public void setUserid ( String userId ) { this . userId = userId ; } public String getPassword ( ) { return password ; } public String getRdbms ( ) { return rdbms ; } public String getVersion ( ) { return version ; } } 	1	['26', '3', '1', '8', '60', '225', '1', '7', '20', '0.872727273', '526', '1', '2', '0.606557377', '0.24', '0', '0', '18.80769231', '10', '1.3077', '1']
package org . apache . tools . ant . taskdefs . email ; import java . io . File ; import java . util . Iterator ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . util . ClasspathUtils ; public class EmailTask extends Task { public static final String AUTO = "auto" ; public static final String MIME = "mime" ; public static final String UU = "uu" ; public static final String PLAIN = "plain" ; public static class Encoding extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { AUTO , MIME , UU , PLAIN } ; } } private String encoding = AUTO ; private String host = "localhost" ; private int port = 25 ; private String subject = null ; private Message message = null ; private boolean failOnError = true ; private boolean includeFileNames = false ; private String messageMimeType = null ; private EmailAddress from = null ; private Vector replyToList = new Vector ( ) ; private Vector toList = new Vector ( ) ; private Vector ccList = new Vector ( ) ; private Vector bccList = new Vector ( ) ; private Vector headers = new Vector ( ) ; private Path attachments = null ; private String charset = null ; private String user = null ; private String password = null ; private boolean ssl = false ; public void setUser ( String user ) { this . user = user ; } public void setPassword ( String password ) { this . password = password ; } public void setSSL ( boolean ssl ) { this . ssl = ssl ; } public void setEncoding ( Encoding encoding ) { this . encoding = encoding . getValue ( ) ; } public void setMailport ( int port ) { this . port = port ; } public void setMailhost ( String host ) { this . host = host ; } public void setSubject ( String subject ) { this . subject = subject ; } public void setMessage ( String message ) { if ( this . message != null ) { throw new BuildException ( "Only one message can be sent in an " + "email" ) ; } this . message = new Message ( message ) ; this . message . setProject ( getProject ( ) ) ; } public void setMessageFile ( File file ) { if ( this . message != null ) { throw new BuildException ( "Only one message can be sent in an " + "email" ) ; } this . message = new Message ( file ) ; this . message . setProject ( getProject ( ) ) ; } public void setMessageMimeType ( String type ) { this . messageMimeType = type ; } public void addMessage ( Message message ) throws BuildException { if ( this . message != null ) { throw new BuildException ( "Only one message can be sent in an email" ) ; } this . message = message ; } public void addFrom ( EmailAddress address ) { if ( this . from != null ) { throw new BuildException ( "Emails can only be from one address" ) ; } this . from = address ; } public void setFrom ( String address ) { if ( this . from != null ) { throw new BuildException ( "Emails can only be from one address" ) ; } this . from = new EmailAddress ( address ) ; } public void addReplyTo ( EmailAddress address ) { this . replyToList . add ( address ) ; } public void setReplyTo ( String address ) { this . replyToList . add ( new EmailAddress ( address ) ) ; } public void addTo ( EmailAddress address ) { toList . addElement ( address ) ; } public void setToList ( String list ) { StringTokenizer tokens = new StringTokenizer ( list , "," ) ; while ( tokens . hasMoreTokens ( ) ) { toList . addElement ( new EmailAddress ( tokens . nextToken ( ) ) ) ; } } public void addCc ( EmailAddress address ) { ccList . addElement ( address ) ; } public void setCcList ( String list ) { StringTokenizer tokens = new StringTokenizer ( list , "," ) ; while ( tokens . hasMoreTokens ( ) ) { ccList . addElement ( new EmailAddress ( tokens . nextToken ( ) ) ) ; } } public void addBcc ( EmailAddress address ) { bccList . addElement ( address ) ; } public void setBccList ( String list ) { StringTokenizer tokens = new StringTokenizer ( list , "," ) ; while ( tokens . hasMoreTokens ( ) ) { bccList . addElement ( new EmailAddress ( tokens . nextToken ( ) ) ) ; } } public void setFailOnError ( boolean failOnError ) { this . failOnError = failOnError ; } public void setFiles ( String filenames ) { StringTokenizer t = new StringTokenizer ( filenames , ", " ) ; while ( t . hasMoreTokens ( ) ) { createAttachments ( ) . add ( new FileResource ( getProject ( ) . resolveFile ( t . nextToken ( ) ) ) ) ; } } public void addFileset ( FileSet fs ) { createAttachments ( ) . add ( fs ) ; } public Path createAttachments ( ) { if ( attachments == null ) { attachments = new Path ( getProject ( ) ) ; } return attachments . createPath ( ) ; } public Header createHeader ( ) { Header h = new Header ( ) ; headers . add ( h ) ; return h ; } public void setIncludefilenames ( boolean includeFileNames ) { this . includeFileNames = includeFileNames ; } public boolean getIncludeFileNames ( ) { return includeFileNames ; } public void execute ( ) { Message savedMessage = message ; try { Mailer mailer = null ; boolean autoFound = false ; if ( encoding . equals ( MIME ) || ( encoding . equals ( AUTO ) && ! autoFound ) ) { try { mailer = ( Mailer ) ClasspathUtils . newInstance ( "org.apache.tools.ant.taskdefs.email.MimeMailer" , EmailTask . class . getClassLoader ( ) , Mailer . class ) ; autoFound = true ; log ( "Using MIME mail" , Project . MSG_VERBOSE ) ; } catch ( BuildException e ) { Throwable t = e . getCause ( ) == null ? e : e . getCause ( ) ; log ( "Failed to initialise MIME mail: " + t . getMessage ( ) , Project . MSG_WARN ) ; return ; } } if ( ! autoFound && ( ( user != null ) || ( password != null ) ) && ( encoding . equals ( UU ) || encoding . equals ( PLAIN ) ) ) { throw new BuildException ( "SMTP auth only possible with MIME mail" ) ; } if ( ! autoFound && ( ssl ) && ( encoding . equals ( UU ) || encoding . equals ( PLAIN ) ) ) { throw new BuildException ( "SSL only possible with MIME mail" ) ; } if ( encoding . equals ( UU ) || ( encoding . equals ( AUTO ) && ! autoFound ) ) { try { mailer = ( Mailer ) ClasspathUtils . newInstance ( "org.apache.tools.ant.taskdefs.email.UUMailer" , EmailTask . class . getClassLoader ( ) , Mailer . class ) ; autoFound = true ; log ( "Using UU mail" , Project . MSG_VERBOSE ) ; } catch ( BuildException e ) { Throwable t = e . getCause ( ) == null ? e : e . getCause ( ) ; log ( "Failed to initialise UU mail: " + t . getMessage ( ) , Project . MSG_WARN ) ; return ; } } if ( encoding . equals ( PLAIN ) || ( encoding . equals ( AUTO ) && ! autoFound ) ) { mailer = new PlainMailer ( ) ; autoFound = true ; log ( "Using plain mail" , Project . MSG_VERBOSE ) ; } if ( mailer == null ) { throw new BuildException ( "Failed to initialise encoding: " + encoding ) ; } if ( message == null ) { message = new Message ( ) ; message . setProject ( getProject ( ) ) ; } if ( from == null || from . getAddress ( ) == null ) { throw new BuildException ( "A from element is required" ) ; } if ( toList . isEmpty ( ) && ccList . isEmpty ( ) && bccList . isEmpty ( ) ) { throw new BuildException ( "At least one of to, cc or bcc must " + "be supplied" ) ; } if ( messageMimeType != null ) { if ( message . isMimeTypeSpecified ( ) ) { throw new BuildException ( "The mime type can only be " + "specified in one location" ) ; } message . setMimeType ( messageMimeType ) ; } if ( charset != null ) { if ( message . getCharset ( ) != null ) { throw new BuildException ( "The charset can only be " + "specified in one location" ) ; } message . setCharset ( charset ) ; } Vector files = new Vector ( ) ; if ( attachments != null ) { Iterator iter = attachments . iterator ( ) ; while ( iter . hasNext ( ) ) { FileResource fr = ( FileResource ) iter . next ( ) ; files . addElement ( fr . getFile ( ) ) ; } } log ( "Sending email: " + subject , Project . MSG_INFO ) ; log ( "From " + from , Project . MSG_VERBOSE ) ; log ( "ReplyTo " + replyToList , Project . MSG_VERBOSE ) ; log ( "To " + toList , Project . MSG_VERBOSE ) ; log ( "Cc " + ccList , Project . MSG_VERBOSE ) ; log ( "Bcc " + bccList , Project . MSG_VERBOSE ) ; mailer . setHost ( host ) ; mailer . setPort ( port ) ; mailer . setUser ( user ) ; mailer . setPassword ( password ) ; mailer . setSSL ( ssl ) ; mailer . setMessage ( message ) ; mailer . setFrom ( from ) ; mailer . setReplyToList ( replyToList ) ; mailer . setToList ( toList ) ; mailer . setCcList ( ccList ) ; mailer . setBccList ( bccList ) ; mailer . setFiles ( files ) ; mailer . setSubject ( subject ) ; mailer . setTask ( this ) ; mailer . setIncludeFileNames ( includeFileNames ) ; mailer . setHeaders ( headers ) ; mailer . send ( ) ; int count = files . size ( ) ; log ( "Sent email with " + count + " attachment" + ( count == 1 ? "" : "s" ) , Project . MSG_INFO ) ; } catch ( BuildException e ) { Throwable t = e . getCause ( ) == null ? e : e . getCause ( ) ; log ( "Failed to send email: " + t . getMessage ( ) , Project . MSG_WARN ) ; if ( failOnError ) { throw e ; } } catch ( Exception e ) { log ( "Failed to send email: " + e . getMessage ( ) , Project . MSG_WARN ) ; if ( failOnError ) { throw new BuildException ( e ) ; } } finally { message = savedMessage ; } } public void setCharset ( String charset ) { this . charset = charset ; } public String getCharset ( ) { return charset ; } } 	1	['32', '3', '2', '16', '97', '362', '2', '14', '32', '0.941935484', '941', '0.76', '3', '0.544117647', '0.201388889', '3', '3', '27.625', '45', '2.625', '4']
package org . apache . tools . ant ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . PrintStream ; import java . io . Writer ; import java . util . Hashtable ; import java . util . Stack ; import java . util . Enumeration ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import org . apache . tools . ant . util . DOMElementWriter ; import org . apache . tools . ant . util . StringUtils ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Text ; public class XmlLogger implements BuildLogger { private int msgOutputLevel = Project . MSG_DEBUG ; private PrintStream outStream ; private static DocumentBuilder builder = getDocumentBuilder ( ) ; private static DocumentBuilder getDocumentBuilder ( ) { try { return DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; } catch ( Exception exc ) { throw new ExceptionInInitializerError ( exc ) ; } } private static final String BUILD_TAG = "build" ; private static final String TARGET_TAG = "target" ; private static final String TASK_TAG = "task" ; private static final String MESSAGE_TAG = "message" ; private static final String NAME_ATTR = "name" ; private static final String TIME_ATTR = "time" ; private static final String PRIORITY_ATTR = "priority" ; private static final String LOCATION_ATTR = "location" ; private static final String ERROR_ATTR = "error" ; private static final String STACKTRACE_TAG = "stacktrace" ; private Document doc = builder . newDocument ( ) ; private Hashtable tasks = new Hashtable ( ) ; private Hashtable targets = new Hashtable ( ) ; private Hashtable threadStacks = new Hashtable ( ) ; private TimedElement buildElement = null ; private static class TimedElement { private long startTime ; private Element element ; public String toString ( ) { return element . getTagName ( ) + ":" + element . getAttribute ( "name" ) ; } } public XmlLogger ( ) { } public void buildStarted ( BuildEvent event ) { buildElement = new TimedElement ( ) ; buildElement . startTime = System . currentTimeMillis ( ) ; buildElement . element = doc . createElement ( BUILD_TAG ) ; } public void buildFinished ( BuildEvent event ) { long totalTime = System . currentTimeMillis ( ) - buildElement . startTime ; buildElement . element . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; if ( event . getException ( ) != null ) { buildElement . element . setAttribute ( ERROR_ATTR , event . getException ( ) . toString ( ) ) ; Throwable t = event . getException ( ) ; Text errText = doc . createCDATASection ( StringUtils . getStackTrace ( t ) ) ; Element stacktrace = doc . createElement ( STACKTRACE_TAG ) ; stacktrace . appendChild ( errText ) ; buildElement . element . appendChild ( stacktrace ) ; } String outFilename = event . getProject ( ) . getProperty ( "XmlLogger.file" ) ; if ( outFilename == null ) { outFilename = "log.xml" ; } String xslUri = event . getProject ( ) . getProperty ( "ant.XmlLogger.stylesheet.uri" ) ; if ( xslUri == null ) { xslUri = "log.xsl" ; } Writer out = null ; try { OutputStream stream = outStream ; if ( stream == null ) { stream = new FileOutputStream ( outFilename ) ; } out = new OutputStreamWriter ( stream , "UTF8" ) ; out . write ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" ) ; if ( xslUri . length ( ) > 0 ) { out . write ( "<?xml-stylesheet type=\"text/xsl\" href=\"" + xslUri + "\"?>\n\n" ) ; } ( new DOMElementWriter ( ) ) . write ( buildElement . element , out , 0 , "\t" ) ; out . flush ( ) ; } catch ( IOException exc ) { throw new BuildException ( "Unable to write log file" , exc ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( IOException e ) { } } } buildElement = null ; } private Stack getStack ( ) { Stack threadStack = ( Stack ) threadStacks . get ( Thread . currentThread ( ) ) ; if ( threadStack == null ) { threadStack = new Stack ( ) ; threadStacks . put ( Thread . currentThread ( ) , threadStack ) ; } return threadStack ; } public void targetStarted ( BuildEvent event ) { Target target = event . getTarget ( ) ; TimedElement targetElement = new TimedElement ( ) ; targetElement . startTime = System . currentTimeMillis ( ) ; targetElement . element = doc . createElement ( TARGET_TAG ) ; targetElement . element . setAttribute ( NAME_ATTR , target . getName ( ) ) ; targets . put ( target , targetElement ) ; getStack ( ) . push ( targetElement ) ; } public void targetFinished ( BuildEvent event ) { Target target = event . getTarget ( ) ; TimedElement targetElement = ( TimedElement ) targets . get ( target ) ; if ( targetElement != null ) { long totalTime = System . currentTimeMillis ( ) - targetElement . startTime ; targetElement . element . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; TimedElement parentElement = null ; Stack threadStack = getStack ( ) ; if ( ! threadStack . empty ( ) ) { TimedElement poppedStack = ( TimedElement ) threadStack . pop ( ) ; if ( poppedStack != targetElement ) { throw new RuntimeException ( "Mismatch - popped element = " + poppedStack + " finished target element = " + targetElement ) ; } if ( ! threadStack . empty ( ) ) { parentElement = ( TimedElement ) threadStack . peek ( ) ; } } if ( parentElement == null ) { buildElement . element . appendChild ( targetElement . element ) ; } else { parentElement . element . appendChild ( targetElement . element ) ; } } targets . remove ( target ) ; } public void taskStarted ( BuildEvent event ) { TimedElement taskElement = new TimedElement ( ) ; taskElement . startTime = System . currentTimeMillis ( ) ; taskElement . element = doc . createElement ( TASK_TAG ) ; Task task = event . getTask ( ) ; String name = event . getTask ( ) . getTaskName ( ) ; if ( name == null ) { name = "" ; } taskElement . element . setAttribute ( NAME_ATTR , name ) ; taskElement . element . setAttribute ( LOCATION_ATTR , event . getTask ( ) . getLocation ( ) . toString ( ) ) ; tasks . put ( task , taskElement ) ; getStack ( ) . push ( taskElement ) ; } public void taskFinished ( BuildEvent event ) { Task task = event . getTask ( ) ; TimedElement taskElement = ( TimedElement ) tasks . get ( task ) ; if ( taskElement != null ) { long totalTime = System . currentTimeMillis ( ) - taskElement . startTime ; taskElement . element . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; Target target = task . getOwningTarget ( ) ; TimedElement targetElement = null ; if ( target != null ) { targetElement = ( TimedElement ) targets . get ( target ) ; } if ( targetElement == null ) { buildElement . element . appendChild ( taskElement . element ) ; } else { targetElement . element . appendChild ( taskElement . element ) ; } Stack threadStack = getStack ( ) ; if ( ! threadStack . empty ( ) ) { TimedElement poppedStack = ( TimedElement ) threadStack . pop ( ) ; if ( poppedStack != taskElement ) { throw new RuntimeException ( "Mismatch - popped element = " + poppedStack + " finished task element = " + taskElement ) ; } } tasks . remove ( task ) ; } else { throw new RuntimeException ( "Unknown task " + task + " not in " + tasks ) ; } } private TimedElement getTaskElement ( Task task ) { TimedElement element = ( TimedElement ) tasks . get ( task ) ; if ( element != null ) { return element ; } for ( Enumeration e = tasks . keys ( ) ; e . hasMoreElements ( ) ; ) { Task key = ( Task ) e . nextElement ( ) ; if ( key instanceof UnknownElement ) { if ( ( ( UnknownElement ) key ) . getTask ( ) == task ) { return ( TimedElement ) tasks . get ( key ) ; } } } return null ; } public void messageLogged ( BuildEvent event ) { int priority = event . getPriority ( ) ; if ( priority > msgOutputLevel ) { return ; } Element messageElement = doc . createElement ( MESSAGE_TAG ) ; String name = "debug" ; switch ( event . getPriority ( ) ) { case Project . MSG_ERR : name = "error" ; break ; case Project . MSG_WARN : name = "warn" ; break ; case Project . MSG_INFO : name = "info" ; break ; default : name = "debug" ; break ; } messageElement . setAttribute ( PRIORITY_ATTR , name ) ; Throwable ex = event . getException ( ) ; if ( Project . MSG_DEBUG <= msgOutputLevel && ex != null ) { Text errText = doc . createCDATASection ( StringUtils . getStackTrace ( ex ) ) ; Element stacktrace = doc . createElement ( STACKTRACE_TAG ) ; stacktrace . appendChild ( errText ) ; buildElement . element . appendChild ( stacktrace ) ; } Text messageText = doc . createCDATASection ( event . getMessage ( ) ) ; messageElement . appendChild ( messageText ) ; TimedElement parentElement = null ; Task task = event . getTask ( ) ; Target target = event . getTarget ( ) ; if ( task != null ) { parentElement = getTaskElement ( task ) ; } if ( parentElement == null && target != null ) { parentElement = ( TimedElement ) targets . get ( target ) ; } if ( parentElement != null ) { parentElement . element . appendChild ( messageElement ) ; } else { buildElement . element . appendChild ( messageElement ) ; } } public void setMessageOutputLevel ( int level ) { msgOutputLevel = level ; } public void setOutputPrintStream ( PrintStream output ) { this . outStream = new PrintStream ( output , true ) ; } public void setEmacsMode ( boolean emacsMode ) { } public void setErrorPrintStream ( PrintStream err ) { } } 	1	['16', '1', '0', '12', '75', '50', '0', '12', '12', '0.937037037', '682', '1', '1', '0', '0.288888889', '0', '0', '40.5', '9', '2.875', '1']
package org . apache . tools . ant . taskdefs . rmic ; import java . io . File ; import java . util . Random ; import java . util . Vector ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Rmic ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileNameMapper ; public abstract class DefaultRmicAdapter implements RmicAdapter { private Rmic attributes ; private FileNameMapper mapper ; private static final Random RAND = new Random ( ) ; public static final String RMI_STUB_SUFFIX = "_Stub" ; public static final String RMI_SKEL_SUFFIX = "_Skel" ; public static final String RMI_TIE_SUFFIX = "_Tie" ; public static final String STUB_COMPAT = "-vcompat" ; public static final String STUB_1_1 = "-v1.1" ; public static final String STUB_1_2 = "-v1.2" ; public DefaultRmicAdapter ( ) { } public void setRmic ( final Rmic attributes ) { this . attributes = attributes ; mapper = new RmicFileNameMapper ( ) ; } public Rmic getRmic ( ) { return attributes ; } protected String getStubClassSuffix ( ) { return RMI_STUB_SUFFIX ; } protected String getSkelClassSuffix ( ) { return RMI_SKEL_SUFFIX ; } protected String getTieClassSuffix ( ) { return RMI_TIE_SUFFIX ; } public FileNameMapper getMapper ( ) { return mapper ; } public Path getClasspath ( ) { return getCompileClasspath ( ) ; } protected Path getCompileClasspath ( ) { Path classpath = new Path ( attributes . getProject ( ) ) ; classpath . setLocation ( attributes . getBase ( ) ) ; Path cp = attributes . getClasspath ( ) ; if ( cp == null ) { cp = new Path ( attributes . getProject ( ) ) ; } if ( attributes . getIncludeantruntime ( ) ) { classpath . addExisting ( cp . concatSystemClasspath ( "last" ) ) ; } else { classpath . addExisting ( cp . concatSystemClasspath ( "ignore" ) ) ; } if ( attributes . getIncludejavaruntime ( ) ) { classpath . addJavaRuntime ( ) ; } return classpath ; } protected Commandline setupRmicCommand ( ) { return setupRmicCommand ( null ) ; } protected Commandline setupRmicCommand ( String [ ] options ) { Commandline cmd = new Commandline ( ) ; if ( options != null ) { for ( int i = 0 ; i < options . length ; i ++ ) { cmd . createArgument ( ) . setValue ( options [ i ] ) ; } } Path classpath = getCompileClasspath ( ) ; cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( attributes . getBase ( ) ) ; if ( attributes . getExtdirs ( ) != null ) { cmd . createArgument ( ) . setValue ( "-extdirs" ) ; cmd . createArgument ( ) . setPath ( attributes . getExtdirs ( ) ) ; } cmd . createArgument ( ) . setValue ( "-classpath" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; String stubVersion = attributes . getStubVersion ( ) ; String stubOption = null ; if ( null != stubVersion ) { if ( "1.1" . equals ( stubVersion ) ) { stubOption = STUB_1_1 ; } else if ( "1.2" . equals ( stubVersion ) ) { stubOption = STUB_1_2 ; } else if ( "compat" . equals ( stubVersion ) ) { stubOption = STUB_COMPAT ; } else { attributes . log ( "Unknown stub option " + stubVersion ) ; } } if ( stubOption == null && ! attributes . getIiop ( ) && ! attributes . getIdl ( ) ) { stubOption = STUB_COMPAT ; } if ( stubOption != null ) { cmd . createArgument ( ) . setValue ( stubOption ) ; } if ( null != attributes . getSourceBase ( ) ) { cmd . createArgument ( ) . setValue ( "-keepgenerated" ) ; } if ( attributes . getIiop ( ) ) { attributes . log ( "IIOP has been turned on." , Project . MSG_INFO ) ; cmd . createArgument ( ) . setValue ( "-iiop" ) ; if ( attributes . getIiopopts ( ) != null ) { attributes . log ( "IIOP Options: " + attributes . getIiopopts ( ) , Project . MSG_INFO ) ; cmd . createArgument ( ) . setValue ( attributes . getIiopopts ( ) ) ; } } if ( attributes . getIdl ( ) ) { cmd . createArgument ( ) . setValue ( "-idl" ) ; attributes . log ( "IDL has been turned on." , Project . MSG_INFO ) ; if ( attributes . getIdlopts ( ) != null ) { cmd . createArgument ( ) . setValue ( attributes . getIdlopts ( ) ) ; attributes . log ( "IDL Options: " + attributes . getIdlopts ( ) , Project . MSG_INFO ) ; } } if ( attributes . getDebug ( ) ) { cmd . createArgument ( ) . setValue ( "-g" ) ; } cmd . addArguments ( attributes . getCurrentCompilerArgs ( ) ) ; logAndAddFilesToCompile ( cmd ) ; return cmd ; } protected void logAndAddFilesToCompile ( Commandline cmd ) { Vector compileList = attributes . getCompileList ( ) ; attributes . log ( "Compilation " + cmd . describeArguments ( ) , Project . MSG_VERBOSE ) ; StringBuffer niceSourceList = new StringBuffer ( "File" ) ; int cListSize = compileList . size ( ) ; if ( cListSize != 1 ) { niceSourceList . append ( "s" ) ; } niceSourceList . append ( " to be compiled:" ) ; for ( int i = 0 ; i < cListSize ; i ++ ) { String arg = ( String ) compileList . elementAt ( i ) ; cmd . createArgument ( ) . setValue ( arg ) ; niceSourceList . append ( "    " ) ; niceSourceList . append ( arg ) ; } attributes . log ( niceSourceList . toString ( ) , Project . MSG_VERBOSE ) ; } private class RmicFileNameMapper implements FileNameMapper { RmicFileNameMapper ( ) { } public void setFrom ( String s ) { } public void setTo ( String s ) { } public String [ ] mapFileName ( String name ) { if ( name == null || ! name . endsWith ( ".class" ) || name . endsWith ( getStubClassSuffix ( ) + ".class" ) || name . endsWith ( getSkelClassSuffix ( ) + ".class" ) || name . endsWith ( getTieClassSuffix ( ) + ".class" ) ) { return null ; } String base = name . substring ( 0 , name . length ( ) - 6 ) ; String classname = base . replace ( File . separatorChar , '.' ) ; if ( attributes . getVerify ( ) && ! attributes . isValidRmiRemote ( classname ) ) { return null ; } String [ ] target = new String [ ] { name + ".tmp." + RAND . nextLong ( ) } ; if ( ! attributes . getIiop ( ) && ! attributes . getIdl ( ) ) { if ( "1.2" . equals ( attributes . getStubVersion ( ) ) ) { target = new String [ ] { base + getStubClassSuffix ( ) + ".class" } ; } else { target = new String [ ] { base + getStubClassSuffix ( ) + ".class" , base + getSkelClassSuffix ( ) + ".class" , } ; } } else if ( ! attributes . getIdl ( ) ) { int lastSlash = base . lastIndexOf ( File . separatorChar ) ; String dirname = "" ; int index = - 1 ; if ( lastSlash == - 1 ) { index = 0 ; } else { index = lastSlash + 1 ; dirname = base . substring ( 0 , index ) ; } String filename = base . substring ( index ) ; try { Class c = attributes . getLoader ( ) . loadClass ( classname ) ; if ( c . isInterface ( ) ) { target = new String [ ] { dirname + "_" + filename + getStubClassSuffix ( ) + ".class" } ; } else { Class interf = attributes . getRemoteInterface ( c ) ; String iName = interf . getName ( ) ; String iDir = "" ; int iIndex = - 1 ; int lastDot = iName . lastIndexOf ( "." ) ; if ( lastDot == - 1 ) { iIndex = 0 ; } else { iIndex = lastDot + 1 ; iDir = iName . substring ( 0 , iIndex ) ; iDir = iDir . replace ( '.' , File . separatorChar ) ; } target = new String [ ] { dirname + "_" + filename + getTieClassSuffix ( ) + ".class" , iDir + "_" + iName . substring ( iIndex ) + getStubClassSuffix ( ) + ".class" } ; } } catch ( ClassNotFoundException e ) { attributes . log ( "Unable to verify class " + classname + ". It could not be found." , Project . MSG_WARN ) ; } catch ( NoClassDefFoundError e ) { attributes . log ( "Unable to verify class " + classname + ". It is not defined." , Project . MSG_WARN ) ; } catch ( Throwable t ) { attributes . log ( "Unable to verify class " + classname + ". Loading caused Exception: " + t . getMessage ( ) , Project . MSG_WARN ) ; } } return target ; } } } 	1	['15', '1', '4', '12', '53', '71', '5', '8', '5', '0.976190476', '390', '0.333333333', '2', '0', '0.228571429', '0', '0', '24.4', '18', '2.3333', '3']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . Arrays ; import java . util . Vector ; import java . util . Iterator ; import java . util . Comparator ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . PatternSet ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . Sort ; import org . apache . tools . ant . types . resources . Restrict ; import org . apache . tools . ant . types . resources . Resources ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . FileResourceIterator ; import org . apache . tools . ant . types . resources . comparators . Reverse ; import org . apache . tools . ant . types . resources . comparators . FileSystem ; import org . apache . tools . ant . types . resources . comparators . ResourceComparator ; import org . apache . tools . ant . types . resources . selectors . Exists ; import org . apache . tools . ant . types . resources . selectors . ResourceSelector ; import org . apache . tools . ant . types . selectors . OrSelector ; import org . apache . tools . ant . types . selectors . AndSelector ; import org . apache . tools . ant . types . selectors . NotSelector ; import org . apache . tools . ant . types . selectors . DateSelector ; import org . apache . tools . ant . types . selectors . FileSelector ; import org . apache . tools . ant . types . selectors . NoneSelector ; import org . apache . tools . ant . types . selectors . SizeSelector ; import org . apache . tools . ant . types . selectors . DepthSelector ; import org . apache . tools . ant . types . selectors . DependSelector ; import org . apache . tools . ant . types . selectors . ExtendSelector ; import org . apache . tools . ant . types . selectors . SelectSelector ; import org . apache . tools . ant . types . selectors . PresentSelector ; import org . apache . tools . ant . types . selectors . ContainsSelector ; import org . apache . tools . ant . types . selectors . FilenameSelector ; import org . apache . tools . ant . types . selectors . MajoritySelector ; import org . apache . tools . ant . types . selectors . ContainsRegexpSelector ; import org . apache . tools . ant . types . selectors . modifiedselector . ModifiedSelector ; public class Delete extends MatchingTask { private static final int DELETE_RETRY_SLEEP_MILLIS = 10 ; private static final ResourceComparator REVERSE_FILESYSTEM = new Reverse ( new FileSystem ( ) ) ; private static final ResourceSelector EXISTS = new Exists ( ) ; private static class ReverseDirs implements ResourceCollection { static final Comparator REVERSE = new Comparator ( ) { public int compare ( Object foo , Object bar ) { return ( ( Comparable ) foo ) . compareTo ( bar ) * - 1 ; } } ; private File basedir ; private String [ ] dirs ; ReverseDirs ( File basedir , String [ ] dirs ) { this . basedir = basedir ; this . dirs = dirs ; Arrays . sort ( this . dirs , REVERSE ) ; } public Iterator iterator ( ) { return new FileResourceIterator ( basedir , dirs ) ; } public boolean isFilesystemOnly ( ) { return true ; } public int size ( ) { return dirs . length ; } } protected File file = null ; protected File dir = null ; protected Vector filesets = new Vector ( ) ; protected boolean usedMatchingTask = false ; protected boolean includeEmpty = false ; private int verbosity = Project . MSG_VERBOSE ; private boolean quiet = false ; private boolean failonerror = true ; private boolean deleteOnExit = false ; private Resources rcs = null ; public void setFile ( File file ) { this . file = file ; } public void setDir ( File dir ) { this . dir = dir ; getImplicitFileSet ( ) . setDir ( dir ) ; } public void setVerbose ( boolean verbose ) { if ( verbose ) { this . verbosity = Project . MSG_INFO ; } else { this . verbosity = Project . MSG_VERBOSE ; } } public void setQuiet ( boolean quiet ) { this . quiet = quiet ; if ( quiet ) { this . failonerror = false ; } } public void setFailOnError ( boolean failonerror ) { this . failonerror = failonerror ; } public void setDeleteOnExit ( boolean deleteOnExit ) { this . deleteOnExit = deleteOnExit ; } public void setIncludeEmptyDirs ( boolean includeEmpty ) { this . includeEmpty = includeEmpty ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void add ( ResourceCollection rc ) { if ( rc == null ) { return ; } rcs = ( rcs == null ) ? new Resources ( ) : rcs ; rcs . add ( rc ) ; } public PatternSet . NameEntry createInclude ( ) { usedMatchingTask = true ; return super . createInclude ( ) ; } public PatternSet . NameEntry createIncludesFile ( ) { usedMatchingTask = true ; return super . createIncludesFile ( ) ; } public PatternSet . NameEntry createExclude ( ) { usedMatchingTask = true ; return super . createExclude ( ) ; } public PatternSet . NameEntry createExcludesFile ( ) { usedMatchingTask = true ; return super . createExcludesFile ( ) ; } public PatternSet createPatternSet ( ) { usedMatchingTask = true ; return super . createPatternSet ( ) ; } public void setIncludes ( String includes ) { usedMatchingTask = true ; super . setIncludes ( includes ) ; } public void setExcludes ( String excludes ) { usedMatchingTask = true ; super . setExcludes ( excludes ) ; } public void setDefaultexcludes ( boolean useDefaultExcludes ) { usedMatchingTask = true ; super . setDefaultexcludes ( useDefaultExcludes ) ; } public void setIncludesfile ( File includesfile ) { usedMatchingTask = true ; super . setIncludesfile ( includesfile ) ; } public void setExcludesfile ( File excludesfile ) { usedMatchingTask = true ; super . setExcludesfile ( excludesfile ) ; } public void setCaseSensitive ( boolean isCaseSensitive ) { usedMatchingTask = true ; super . setCaseSensitive ( isCaseSensitive ) ; } public void setFollowSymlinks ( boolean followSymlinks ) { usedMatchingTask = true ; super . setFollowSymlinks ( followSymlinks ) ; } public void addSelector ( SelectSelector selector ) { usedMatchingTask = true ; super . addSelector ( selector ) ; } public void addAnd ( AndSelector selector ) { usedMatchingTask = true ; super . addAnd ( selector ) ; } public void addOr ( OrSelector selector ) { usedMatchingTask = true ; super . addOr ( selector ) ; } public void addNot ( NotSelector selector ) { usedMatchingTask = true ; super . addNot ( selector ) ; } public void addNone ( NoneSelector selector ) { usedMatchingTask = true ; super . addNone ( selector ) ; } public void addMajority ( MajoritySelector selector ) { usedMatchingTask = true ; super . addMajority ( selector ) ; } public void addDate ( DateSelector selector ) { usedMatchingTask = true ; super . addDate ( selector ) ; } public void addSize ( SizeSelector selector ) { usedMatchingTask = true ; super . addSize ( selector ) ; } public void addFilename ( FilenameSelector selector ) { usedMatchingTask = true ; super . addFilename ( selector ) ; } public void addCustom ( ExtendSelector selector ) { usedMatchingTask = true ; super . addCustom ( selector ) ; } public void addContains ( ContainsSelector selector ) { usedMatchingTask = true ; super . addContains ( selector ) ; } public void addPresent ( PresentSelector selector ) { usedMatchingTask = true ; super . addPresent ( selector ) ; } public void addDepth ( DepthSelector selector ) { usedMatchingTask = true ; super . addDepth ( selector ) ; } public void addDepend ( DependSelector selector ) { usedMatchingTask = true ; super . addDepend ( selector ) ; } public void addContainsRegexp ( ContainsRegexpSelector selector ) { usedMatchingTask = true ; super . addContainsRegexp ( selector ) ; } public void addModified ( ModifiedSelector selector ) { usedMatchingTask = true ; super . addModified ( selector ) ; } public void add ( FileSelector selector ) { usedMatchingTask = true ; super . add ( selector ) ; } public void execute ( ) throws BuildException { if ( usedMatchingTask ) { log ( "DEPRECATED - Use of the implicit FileSet is deprecated.  " + "Use a nested fileset element instead." , quiet ? Project . MSG_VERBOSE : verbosity ) ; } if ( file == null && dir == null && filesets . size ( ) == 0 && rcs == null ) { throw new BuildException ( "At least one of the file or dir " + "attributes, or a nested resource collection, " + "must be set." ) ; } if ( quiet && failonerror ) { throw new BuildException ( "quiet and failonerror cannot both be " + "set to true" , getLocation ( ) ) ; } if ( file != null ) { if ( file . exists ( ) ) { if ( file . isDirectory ( ) ) { log ( "Directory " + file . getAbsolutePath ( ) + " cannot be removed using the file attribute.  " + "Use dir instead." , quiet ? Project . MSG_VERBOSE : verbosity ) ; } else { log ( "Deleting: " + file . getAbsolutePath ( ) ) ; if ( ! delete ( file ) ) { handle ( "Unable to delete file " + file . getAbsolutePath ( ) ) ; } } } else { log ( "Could not find file " + file . getAbsolutePath ( ) + " to delete." , quiet ? Project . MSG_VERBOSE : verbosity ) ; } } if ( dir != null && dir . exists ( ) && dir . isDirectory ( ) && ! usedMatchingTask ) { if ( verbosity == Project . MSG_VERBOSE ) { log ( "Deleting directory " + dir . getAbsolutePath ( ) ) ; } removeDir ( dir ) ; } Resources resourcesToDelete = new Resources ( ) ; resourcesToDelete . setProject ( getProject ( ) ) ; Resources filesetDirs = new Resources ( ) ; filesetDirs . setProject ( getProject ( ) ) ; FileSet implicit = null ; if ( usedMatchingTask && dir != null && dir . isDirectory ( ) ) { implicit = getImplicitFileSet ( ) ; implicit . setProject ( getProject ( ) ) ; filesets . add ( implicit ) ; } for ( int i = 0 , size = filesets . size ( ) ; i < size ; i ++ ) { FileSet fs = ( FileSet ) filesets . get ( i ) ; if ( fs . getProject ( ) == null ) { log ( "Deleting fileset with no project specified;" + " assuming executing project" , Project . MSG_VERBOSE ) ; fs = ( FileSet ) fs . clone ( ) ; fs . setProject ( getProject ( ) ) ; } if ( ! fs . getDir ( ) . isDirectory ( ) ) { handle ( "Directory does not exist:" + fs . getDir ( ) ) ; } else { resourcesToDelete . add ( fs ) ; if ( includeEmpty ) { filesetDirs . add ( new ReverseDirs ( fs . getDir ( ) , fs . getDirectoryScanner ( ) . getIncludedDirectories ( ) ) ) ; } } } resourcesToDelete . add ( filesetDirs ) ; if ( rcs != null ) { Restrict exists = new Restrict ( ) ; exists . add ( EXISTS ) ; exists . add ( rcs ) ; Sort s = new Sort ( ) ; s . add ( REVERSE_FILESYSTEM ) ; s . add ( exists ) ; resourcesToDelete . add ( s ) ; } try { if ( resourcesToDelete . isFilesystemOnly ( ) ) { for ( Iterator iter = resourcesToDelete . iterator ( ) ; iter . hasNext ( ) ; ) { FileResource r = ( FileResource ) iter . next ( ) ; if ( ! r . isExists ( ) ) { continue ; } if ( ! ( r . isDirectory ( ) ) || r . getFile ( ) . list ( ) . length == 0 ) { log ( "Deleting " + r , verbosity ) ; if ( ! delete ( r . getFile ( ) ) && failonerror ) { handle ( "Unable to delete " + ( r . isDirectory ( ) ? "directory " : "file " ) + r ) ; } } } } else { handle ( getTaskName ( ) + " handles only filesystem resources" ) ; } } catch ( Exception e ) { handle ( e ) ; } finally { if ( implicit != null ) { filesets . remove ( implicit ) ; } } } private void handle ( String msg ) { handle ( new BuildException ( msg ) ) ; } private void handle ( Exception e ) { if ( failonerror ) { throw ( e instanceof BuildException ) ? ( BuildException ) e : new BuildException ( e ) ; } log ( e , quiet ? Project . MSG_VERBOSE : verbosity ) ; } private boolean delete ( File f ) { if ( ! f . delete ( ) ) { if ( Os . isFamily ( "windows" ) ) { System . gc ( ) ; } try { Thread . sleep ( DELETE_RETRY_SLEEP_MILLIS ) ; } catch ( InterruptedException ex ) { } if ( ! f . delete ( ) ) { if ( deleteOnExit ) { int level = quiet ? Project . MSG_VERBOSE : Project . MSG_INFO ; log ( "Failed to delete " + f + ", calling deleteOnExit." + " This attempts to delete the file when the Ant jvm" + " has exited and might not succeed." , level ) ; f . deleteOnExit ( ) ; return true ; } return false ; } } return true ; } protected void removeDir ( File d ) { String [ ] list = d . list ( ) ; if ( list == null ) { list = new String [ 0 ] ; } for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( d , s ) ; if ( f . isDirectory ( ) ) { removeDir ( f ) ; } else { log ( "Deleting " + f . getAbsolutePath ( ) , quiet ? Project . MSG_VERBOSE : verbosity ) ; if ( ! delete ( f ) ) { handle ( "Unable to delete file " + f . getAbsolutePath ( ) ) ; } } } log ( "Deleting directory " + d . getAbsolutePath ( ) , verbosity ) ; if ( ! delete ( d ) ) { handle ( "Unable to delete directory " + dir . getAbsolutePath ( ) ) ; } } protected void removeFiles ( File d , String [ ] files , String [ ] dirs ) { if ( files . length > 0 ) { log ( "Deleting " + files . length + " files from " + d . getAbsolutePath ( ) , quiet ? Project . MSG_VERBOSE : verbosity ) ; for ( int j = 0 ; j < files . length ; j ++ ) { File f = new File ( d , files [ j ] ) ; log ( "Deleting " + f . getAbsolutePath ( ) , quiet ? Project . MSG_VERBOSE : verbosity ) ; if ( ! delete ( f ) ) { handle ( "Unable to delete file " + f . getAbsolutePath ( ) ) ; } } } if ( dirs . length > 0 && includeEmpty ) { int dirCount = 0 ; for ( int j = dirs . length - 1 ; j >= 0 ; j -- ) { File currDir = new File ( d , dirs [ j ] ) ; String [ ] dirFiles = currDir . list ( ) ; if ( dirFiles == null || dirFiles . length == 0 ) { log ( "Deleting " + currDir . getAbsolutePath ( ) , quiet ? Project . MSG_VERBOSE : verbosity ) ; if ( ! delete ( currDir ) ) { handle ( "Unable to delete directory " + currDir . getAbsolutePath ( ) ) ; } else { dirCount ++ ; } } } if ( dirCount > 0 ) { log ( "Deleted " + dirCount + " director" + ( dirCount == 1 ? "y" : "ies" ) + " form " + d . getAbsolutePath ( ) , quiet ? Project . MSG_VERBOSE : verbosity ) ; } } } } 	1	['46', '4', '0', '39', '135', '17', '2', '37', '40', '0.883760684', '1100', '1', '3', '0.639344262', '0.074666667', '3', '5', '22.63043478', '16', '1.6739', '5']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Hashtable ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . ParserConfigurationException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . XMLCatalog ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . util . FileUtils ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . xml . sax . SAXException ; import org . xml . sax . EntityResolver ; public class XmlProperty extends org . apache . tools . ant . Task { private Resource src ; private String prefix = "" ; private boolean keepRoot = true ; private boolean validate = false ; private boolean collapseAttributes = false ; private boolean semanticAttributes = false ; private boolean includeSemanticAttribute = false ; private File rootDirectory = null ; private Hashtable addedAttributes = new Hashtable ( ) ; private XMLCatalog xmlCatalog = new XMLCatalog ( ) ; private static final String ID = "id" ; private static final String REF_ID = "refid" ; private static final String LOCATION = "location" ; private static final String VALUE = "value" ; private static final String PATH = "path" ; private static final String PATHID = "pathid" ; private static final String [ ] ATTRIBUTES = new String [ ] { ID , REF_ID , LOCATION , VALUE , PATH , PATHID } ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; public XmlProperty ( ) { super ( ) ; } public void init ( ) { super . init ( ) ; xmlCatalog . setProject ( getProject ( ) ) ; } protected EntityResolver getEntityResolver ( ) { return xmlCatalog ; } public void execute ( ) throws BuildException { Resource r = getResource ( ) ; if ( r == null ) { String msg = "XmlProperty task requires a source resource" ; throw new BuildException ( msg ) ; } try { log ( "Loading " + src , Project . MSG_VERBOSE ) ; if ( r . isExists ( ) ) { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; factory . setValidating ( validate ) ; factory . setNamespaceAware ( false ) ; DocumentBuilder builder = factory . newDocumentBuilder ( ) ; builder . setEntityResolver ( getEntityResolver ( ) ) ; Document document = null ; if ( src instanceof FileResource ) { document = builder . parse ( ( ( FileResource ) src ) . getFile ( ) ) ; } else { document = builder . parse ( src . getInputStream ( ) ) ; } Element topElement = document . getDocumentElement ( ) ; addedAttributes = new Hashtable ( ) ; if ( keepRoot ) { addNodeRecursively ( topElement , prefix , null ) ; } else { NodeList topChildren = topElement . getChildNodes ( ) ; int numChildren = topChildren . getLength ( ) ; for ( int i = 0 ; i < numChildren ; i ++ ) { addNodeRecursively ( topChildren . item ( i ) , prefix , null ) ; } } } else { log ( "Unable to find property resource: " + r , Project . MSG_VERBOSE ) ; } } catch ( SAXException sxe ) { Exception x = sxe ; if ( sxe . getException ( ) != null ) { x = sxe . getException ( ) ; } throw new BuildException ( "Failed to load " + src , x ) ; } catch ( ParserConfigurationException pce ) { throw new BuildException ( pce ) ; } catch ( IOException ioe ) { throw new BuildException ( "Failed to load " + src , ioe ) ; } } private void addNodeRecursively ( Node node , String prefix , Object container ) { String nodePrefix = prefix ; if ( node . getNodeType ( ) != Node . TEXT_NODE ) { if ( prefix . trim ( ) . length ( ) > 0 ) { nodePrefix += "." ; } nodePrefix += node . getNodeName ( ) ; } Object nodeObject = processNode ( node , nodePrefix , container ) ; if ( node . hasChildNodes ( ) ) { NodeList nodeChildren = node . getChildNodes ( ) ; int numChildren = nodeChildren . getLength ( ) ; for ( int i = 0 ; i < numChildren ; i ++ ) { addNodeRecursively ( nodeChildren . item ( i ) , nodePrefix , nodeObject ) ; } } } void addNodeRecursively ( org . w3c . dom . Node node , String prefix ) { addNodeRecursively ( node , prefix , null ) ; } public Object processNode ( Node node , String prefix , Object container ) { Object addedPath = null ; String id = null ; if ( node . hasAttributes ( ) ) { NamedNodeMap nodeAttributes = node . getAttributes ( ) ; Node idNode = nodeAttributes . getNamedItem ( ID ) ; id = ( semanticAttributes && idNode != null ? idNode . getNodeValue ( ) : null ) ; for ( int i = 0 ; i < nodeAttributes . getLength ( ) ; i ++ ) { Node attributeNode = nodeAttributes . item ( i ) ; if ( ! semanticAttributes ) { String attributeName = getAttributeName ( attributeNode ) ; String attributeValue = getAttributeValue ( attributeNode ) ; addProperty ( prefix + attributeName , attributeValue , null ) ; } else { String nodeName = attributeNode . getNodeName ( ) ; String attributeValue = getAttributeValue ( attributeNode ) ; Path containingPath = ( container != null && container instanceof Path ? ( Path ) container : null ) ; if ( nodeName . equals ( ID ) ) { continue ; } else if ( containingPath != null && nodeName . equals ( PATH ) ) { containingPath . setPath ( attributeValue ) ; } else if ( container instanceof Path && nodeName . equals ( REF_ID ) ) { containingPath . setPath ( attributeValue ) ; } else if ( container instanceof Path && nodeName . equals ( LOCATION ) ) { containingPath . setLocation ( resolveFile ( attributeValue ) ) ; } else if ( nodeName . equals ( PATHID ) ) { if ( container != null ) { throw new BuildException ( "XmlProperty does not " + "support nested paths" ) ; } addedPath = new Path ( getProject ( ) ) ; getProject ( ) . addReference ( attributeValue , addedPath ) ; } else { String attributeName = getAttributeName ( attributeNode ) ; addProperty ( prefix + attributeName , attributeValue , id ) ; } } } } String nodeText = null ; boolean emptyNode = false ; boolean semanticEmptyOverride = false ; if ( node . getNodeType ( ) == Node . ELEMENT_NODE && semanticAttributes && node . hasAttributes ( ) && ( node . getAttributes ( ) . getNamedItem ( VALUE ) != null || node . getAttributes ( ) . getNamedItem ( LOCATION ) != null || node . getAttributes ( ) . getNamedItem ( REF_ID ) != null || node . getAttributes ( ) . getNamedItem ( PATH ) != null || node . getAttributes ( ) . getNamedItem ( PATHID ) != null ) ) { semanticEmptyOverride = true ; } if ( node . getNodeType ( ) == Node . TEXT_NODE ) { nodeText = getAttributeValue ( node ) ; } else if ( ( node . getNodeType ( ) == Node . ELEMENT_NODE ) && ( node . getChildNodes ( ) . getLength ( ) == 1 ) && ( node . getFirstChild ( ) . getNodeType ( ) == Node . CDATA_SECTION_NODE ) ) { nodeText = node . getFirstChild ( ) . getNodeValue ( ) ; if ( "" . equals ( nodeText ) && ! semanticEmptyOverride ) { emptyNode = true ; } } else if ( ( node . getNodeType ( ) == Node . ELEMENT_NODE ) && ( node . getChildNodes ( ) . getLength ( ) == 0 ) && ! semanticEmptyOverride ) { nodeText = "" ; emptyNode = true ; } else if ( ( node . getNodeType ( ) == Node . ELEMENT_NODE ) && ( node . getChildNodes ( ) . getLength ( ) == 1 ) && ( node . getFirstChild ( ) . getNodeType ( ) == Node . TEXT_NODE ) && ( "" . equals ( node . getFirstChild ( ) . getNodeValue ( ) ) ) && ! semanticEmptyOverride ) { nodeText = "" ; emptyNode = true ; } if ( nodeText != null ) { if ( semanticAttributes && id == null && container instanceof String ) { id = ( String ) container ; } if ( nodeText . trim ( ) . length ( ) != 0 || emptyNode ) { addProperty ( prefix , nodeText , id ) ; } } return ( addedPath != null ? addedPath : id ) ; } private void addProperty ( String name , String value , String id ) { String msg = name + ":" + value ; if ( id != null ) { msg += ( "(id=" + id + ")" ) ; } log ( msg , Project . MSG_DEBUG ) ; if ( addedAttributes . containsKey ( name ) ) { value = ( String ) addedAttributes . get ( name ) + "," + value ; getProject ( ) . setProperty ( name , value ) ; addedAttributes . put ( name , value ) ; } else if ( getProject ( ) . getProperty ( name ) == null ) { getProject ( ) . setNewProperty ( name , value ) ; addedAttributes . put ( name , value ) ; } else { log ( "Override ignored for property " + name , Project . MSG_VERBOSE ) ; } if ( id != null ) { getProject ( ) . addReference ( id , value ) ; } } private String getAttributeName ( Node attributeNode ) { String attributeName = attributeNode . getNodeName ( ) ; if ( semanticAttributes ) { if ( attributeName . equals ( REF_ID ) ) { return "" ; } else if ( ! isSemanticAttribute ( attributeName ) || includeSemanticAttribute ) { return "." + attributeName ; } else { return "" ; } } else if ( collapseAttributes ) { return "." + attributeName ; } else { return "(" + attributeName + ")" ; } } private static boolean isSemanticAttribute ( String attributeName ) { for ( int i = 0 ; i < ATTRIBUTES . length ; i ++ ) { if ( attributeName . equals ( ATTRIBUTES [ i ] ) ) { return true ; } } return false ; } private String getAttributeValue ( Node attributeNode ) { String nodeValue = attributeNode . getNodeValue ( ) . trim ( ) ; if ( semanticAttributes ) { String attributeName = attributeNode . getNodeName ( ) ; nodeValue = getProject ( ) . replaceProperties ( nodeValue ) ; if ( attributeName . equals ( LOCATION ) ) { File f = resolveFile ( nodeValue ) ; return f . getPath ( ) ; } else if ( attributeName . equals ( REF_ID ) ) { Object ref = getProject ( ) . getReference ( nodeValue ) ; if ( ref != null ) { return ref . toString ( ) ; } } } return nodeValue ; } public void setFile ( File src ) { setSrcResource ( new FileResource ( src ) ) ; } public void setSrcResource ( Resource src ) { if ( src . isDirectory ( ) ) { throw new BuildException ( "the source can't be a directory" ) ; } if ( src instanceof FileResource && ! supportsNonFileResources ( ) ) { throw new BuildException ( "Only FileSystem resources are" + " supported." ) ; } this . src = src ; } public void addConfigured ( ResourceCollection a ) { if ( a . size ( ) != 1 ) { throw new BuildException ( "only single argument resource collections" + " are supported as archives" ) ; } setSrcResource ( ( Resource ) a . iterator ( ) . next ( ) ) ; } public void setPrefix ( String prefix ) { this . prefix = prefix . trim ( ) ; } public void setKeeproot ( boolean keepRoot ) { this . keepRoot = keepRoot ; } public void setValidate ( boolean validate ) { this . validate = validate ; } public void setCollapseAttributes ( boolean collapseAttributes ) { this . collapseAttributes = collapseAttributes ; } public void setSemanticAttributes ( boolean semanticAttributes ) { this . semanticAttributes = semanticAttributes ; } public void setRootDirectory ( File rootDirectory ) { this . rootDirectory = rootDirectory ; } public void setIncludeSemanticAttribute ( boolean includeSemanticAttribute ) { this . includeSemanticAttribute = includeSemanticAttribute ; } public void addConfiguredXMLCatalog ( XMLCatalog catalog ) { xmlCatalog . addConfiguredXMLCatalog ( catalog ) ; } protected File getFile ( ) { if ( src instanceof FileResource ) { return ( ( FileResource ) src ) . getFile ( ) ; } else { return null ; } } protected Resource getResource ( ) { File f = getFile ( ) ; if ( f != null ) { return new FileResource ( f ) ; } else { return src ; } } protected String getPrefix ( ) { return this . prefix ; } protected boolean getKeeproot ( ) { return this . keepRoot ; } protected boolean getValidate ( ) { return this . validate ; } protected boolean getCollapseAttributes ( ) { return this . collapseAttributes ; } protected boolean getSemanticAttributes ( ) { return this . semanticAttributes ; } protected File getRootDirectory ( ) { return this . rootDirectory ; } protected boolean getIncludeSementicAttribute ( ) { return this . includeSemanticAttribute ; } private File resolveFile ( String fileName ) { if ( rootDirectory == null ) { return FILE_UTILS . resolveFile ( getProject ( ) . getBaseDir ( ) , fileName ) ; } return FILE_UTILS . resolveFile ( rootDirectory , fileName ) ; } protected boolean supportsNonFileResources ( ) { return getClass ( ) . equals ( XmlProperty . class ) ; } } 	1	['34', '3', '0', '9', '106', '435', '0', '9', '15', '0.933014354', '1020', '0.947368421', '3', '0.536231884', '0.188552189', '2', '2', '28.44117647', '46', '3.0588', '1']
package org . apache . tools . ant ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintStream ; import java . util . Enumeration ; import java . util . Properties ; import java . util . Vector ; import java . util . HashMap ; import org . apache . tools . ant . input . DefaultInputHandler ; import org . apache . tools . ant . input . InputHandler ; import org . apache . tools . ant . launch . AntMain ; import org . apache . tools . ant . util . ClasspathUtils ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . ProxySetup ; public class Main implements AntMain { public static final String DEFAULT_BUILD_FILENAME = "build.xml" ; private int msgOutputLevel = Project . MSG_INFO ; private File buildFile ; private static PrintStream out = System . out ; private static PrintStream err = System . err ; private Vector targets = new Vector ( ) ; private Properties definedProps = new Properties ( ) ; private Vector listeners = new Vector ( 1 ) ; private Vector propertyFiles = new Vector ( 1 ) ; private boolean allowInput = true ; private boolean keepGoingMode = false ; private String loggerClassname = null ; private String inputHandlerClassname = null ; private boolean emacsMode = false ; private boolean readyToRun = false ; private boolean projectHelp = false ; private static boolean isLogFileUsed = false ; private Integer threadPriority = null ; private boolean proxy = false ; private static void printMessage ( Throwable t ) { String message = t . getMessage ( ) ; if ( message != null ) { System . err . println ( message ) ; } } public static void start ( String [ ] args , Properties additionalUserProperties , ClassLoader coreLoader ) { Main m = new Main ( ) ; m . startAnt ( args , additionalUserProperties , coreLoader ) ; } public void startAnt ( String [ ] args , Properties additionalUserProperties , ClassLoader coreLoader ) { try { Diagnostics . validateVersion ( ) ; processArgs ( args ) ; } catch ( Throwable exc ) { handleLogfile ( ) ; printMessage ( exc ) ; exit ( 1 ) ; return ; } if ( additionalUserProperties != null ) { for ( Enumeration e = additionalUserProperties . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; String property = additionalUserProperties . getProperty ( key ) ; definedProps . put ( key , property ) ; } } int exitCode = 1 ; try { try { runBuild ( coreLoader ) ; exitCode = 0 ; } catch ( ExitStatusException ese ) { exitCode = ese . getStatus ( ) ; if ( exitCode != 0 ) { throw ese ; } } } catch ( BuildException be ) { if ( err != System . err ) { printMessage ( be ) ; } } catch ( Throwable exc ) { exc . printStackTrace ( ) ; printMessage ( exc ) ; } finally { handleLogfile ( ) ; } exit ( exitCode ) ; } protected void exit ( int exitCode ) { System . exit ( exitCode ) ; } private static void handleLogfile ( ) { if ( isLogFileUsed ) { FileUtils . close ( out ) ; FileUtils . close ( err ) ; } } public static void main ( String [ ] args ) { start ( args , null , null ) ; } public Main ( ) { } protected Main ( String [ ] args ) throws BuildException { processArgs ( args ) ; } private void processArgs ( String [ ] args ) { String searchForThis = null ; PrintStream logTo = null ; HashMap launchCommands = new HashMap ( ) ; launchCommands . put ( "-lib" , "" ) ; launchCommands . put ( "-cp" , "" ) ; launchCommands . put ( "-noclasspath" , "" ) ; launchCommands . put ( "--noclasspath" , "" ) ; launchCommands . put ( "-nouserlib" , "" ) ; launchCommands . put ( "--nouserlib" , "" ) ; launchCommands . put ( "-main" , "" ) ; for ( int i = 0 ; i < args . length ; i ++ ) { String arg = args [ i ] ; if ( arg . equals ( "-help" ) || arg . equals ( "-h" ) ) { printUsage ( ) ; return ; } else if ( arg . equals ( "-version" ) ) { printVersion ( ) ; return ; } else if ( arg . equals ( "-diagnostics" ) ) { Diagnostics . doReport ( System . out ) ; return ; } else if ( arg . equals ( "-quiet" ) || arg . equals ( "-q" ) ) { msgOutputLevel = Project . MSG_WARN ; } else if ( arg . equals ( "-verbose" ) || arg . equals ( "-v" ) ) { printVersion ( ) ; msgOutputLevel = Project . MSG_VERBOSE ; } else if ( arg . equals ( "-debug" ) || arg . equals ( "-d" ) ) { printVersion ( ) ; msgOutputLevel = Project . MSG_DEBUG ; } else if ( arg . equals ( "-noinput" ) ) { allowInput = false ; } else if ( arg . equals ( "-logfile" ) || arg . equals ( "-l" ) ) { try { File logFile = new File ( args [ i + 1 ] ) ; i ++ ; logTo = new PrintStream ( new FileOutputStream ( logFile ) ) ; isLogFileUsed = true ; } catch ( IOException ioe ) { String msg = "Cannot write on the specified log file. " + "Make sure the path exists and you have write " + "permissions." ; throw new BuildException ( msg ) ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a log file when " + "using the -log argument" ; throw new BuildException ( msg ) ; } } else if ( arg . equals ( "-buildfile" ) || arg . equals ( "-file" ) || arg . equals ( "-f" ) ) { try { buildFile = new File ( args [ i + 1 ] . replace ( '/' , File . separatorChar ) ) ; i ++ ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a buildfile when " + "using the -buildfile argument" ; throw new BuildException ( msg ) ; } } else if ( arg . equals ( "-listener" ) ) { try { listeners . addElement ( args [ i + 1 ] ) ; i ++ ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a classname when " + "using the -listener argument" ; throw new BuildException ( msg ) ; } } else if ( arg . startsWith ( "-D" ) ) { String name = arg . substring ( 2 , arg . length ( ) ) ; String value = null ; int posEq = name . indexOf ( "=" ) ; if ( posEq > 0 ) { value = name . substring ( posEq + 1 ) ; name = name . substring ( 0 , posEq ) ; } else if ( i < args . length - 1 ) { value = args [ ++ i ] ; } else { throw new BuildException ( "Missing value for property " + name ) ; } definedProps . put ( name , value ) ; } else if ( arg . equals ( "-logger" ) ) { if ( loggerClassname != null ) { throw new BuildException ( "Only one logger class may " + " be specified." ) ; } try { loggerClassname = args [ ++ i ] ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { throw new BuildException ( "You must specify a classname when" + " using the -logger argument" ) ; } } else if ( arg . equals ( "-inputhandler" ) ) { if ( inputHandlerClassname != null ) { throw new BuildException ( "Only one input handler class may " + "be specified." ) ; } try { inputHandlerClassname = args [ ++ i ] ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { throw new BuildException ( "You must specify a classname when" + " using the -inputhandler" + " argument" ) ; } } else if ( arg . equals ( "-emacs" ) || arg . equals ( "-e" ) ) { emacsMode = true ; } else if ( arg . equals ( "-projecthelp" ) || arg . equals ( "-p" ) ) { projectHelp = true ; } else if ( arg . equals ( "-find" ) || arg . equals ( "-s" ) ) { if ( i < args . length - 1 ) { searchForThis = args [ ++ i ] ; } else { searchForThis = DEFAULT_BUILD_FILENAME ; } } else if ( arg . startsWith ( "-propertyfile" ) ) { try { propertyFiles . addElement ( args [ i + 1 ] ) ; i ++ ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a property filename when " + "using the -propertyfile argument" ; throw new BuildException ( msg ) ; } } else if ( arg . equals ( "-k" ) || arg . equals ( "-keep-going" ) ) { keepGoingMode = true ; } else if ( arg . equals ( "-nice" ) ) { try { threadPriority = Integer . decode ( args [ i + 1 ] ) ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { throw new BuildException ( "You must supply a niceness value (1-10)" + " after the -nice option" ) ; } catch ( NumberFormatException e ) { throw new BuildException ( "Unrecognized niceness value: " + args [ i + 1 ] ) ; } i ++ ; if ( threadPriority . intValue ( ) < Thread . MIN_PRIORITY || threadPriority . intValue ( ) > Thread . MAX_PRIORITY ) { throw new BuildException ( "Niceness value is out of the range 1-10" ) ; } } else if ( launchCommands . get ( arg ) != null ) { String msg = "Ant's Main method is being handed " + "an option " + arg + " that is only for the launcher class." + "\nThis can be caused by a version mismatch between " + "the ant script/.bat file and Ant itself." ; throw new BuildException ( msg ) ; } else if ( arg . equals ( "-autoproxy" ) ) { proxy = false ; } else if ( arg . startsWith ( "-" ) ) { String msg = "Unknown argument: " + arg ; System . err . println ( msg ) ; printUsage ( ) ; throw new BuildException ( "" ) ; } else { targets . addElement ( arg ) ; } } if ( buildFile == null ) { if ( searchForThis != null ) { buildFile = findBuildFile ( System . getProperty ( "user.dir" ) , searchForThis ) ; } else { buildFile = new File ( DEFAULT_BUILD_FILENAME ) ; } } if ( ! buildFile . exists ( ) ) { System . out . println ( "Buildfile: " + buildFile + " does not exist!" ) ; throw new BuildException ( "Build failed" ) ; } if ( buildFile . isDirectory ( ) ) { System . out . println ( "What? Buildfile: " + buildFile + " is a dir!" ) ; throw new BuildException ( "Build failed" ) ; } for ( int propertyFileIndex = 0 ; propertyFileIndex < propertyFiles . size ( ) ; propertyFileIndex ++ ) { String filename = ( String ) propertyFiles . elementAt ( propertyFileIndex ) ; Properties props = new Properties ( ) ; FileInputStream fis = null ; try { fis = new FileInputStream ( filename ) ; props . load ( fis ) ; } catch ( IOException e ) { System . out . println ( "Could not load property file " + filename + ": " + e . getMessage ( ) ) ; } finally { FileUtils . close ( fis ) ; } Enumeration propertyNames = props . propertyNames ( ) ; while ( propertyNames . hasMoreElements ( ) ) { String name = ( String ) propertyNames . nextElement ( ) ; if ( definedProps . getProperty ( name ) == null ) { definedProps . put ( name , props . getProperty ( name ) ) ; } } } if ( msgOutputLevel >= Project . MSG_INFO ) { System . out . println ( "Buildfile: " + buildFile ) ; } if ( logTo != null ) { out = logTo ; err = logTo ; System . setOut ( out ) ; System . setErr ( err ) ; } readyToRun = true ; } private File getParentFile ( File file ) { File parent = file . getParentFile ( ) ; if ( parent != null && msgOutputLevel >= Project . MSG_VERBOSE ) { System . out . println ( "Searching in " + parent . getAbsolutePath ( ) ) ; } return parent ; } private File findBuildFile ( String start , String suffix ) throws BuildException { if ( msgOutputLevel >= Project . MSG_INFO ) { System . out . println ( "Searching for " + suffix + " ..." ) ; } File parent = new File ( new File ( start ) . getAbsolutePath ( ) ) ; File file = new File ( parent , suffix ) ; while ( ! file . exists ( ) ) { parent = getParentFile ( parent ) ; if ( parent == null ) { throw new BuildException ( "Could not locate a build file!" ) ; } file = new File ( parent , suffix ) ; } return file ; } private void runBuild ( ClassLoader coreLoader ) throws BuildException { if ( ! readyToRun ) { return ; } final Project project = new Project ( ) ; project . setCoreLoader ( coreLoader ) ; Throwable error = null ; try { addBuildListeners ( project ) ; addInputHandler ( project ) ; PrintStream savedErr = System . err ; PrintStream savedOut = System . out ; InputStream savedIn = System . in ; SecurityManager oldsm = null ; oldsm = System . getSecurityManager ( ) ; try { if ( allowInput ) { project . setDefaultInputStream ( System . in ) ; } System . setIn ( new DemuxInputStream ( project ) ) ; System . setOut ( new PrintStream ( new DemuxOutputStream ( project , false ) ) ) ; System . setErr ( new PrintStream ( new DemuxOutputStream ( project , true ) ) ) ; if ( ! projectHelp ) { project . fireBuildStarted ( ) ; } if ( threadPriority != null ) { try { project . log ( "Setting Ant's thread priority to " + threadPriority , Project . MSG_VERBOSE ) ; Thread . currentThread ( ) . setPriority ( threadPriority . intValue ( ) ) ; } catch ( SecurityException swallowed ) { project . log ( "A security manager refused to set the -nice value" ) ; } } project . init ( ) ; Enumeration e = definedProps . keys ( ) ; while ( e . hasMoreElements ( ) ) { String arg = ( String ) e . nextElement ( ) ; String value = ( String ) definedProps . get ( arg ) ; project . setUserProperty ( arg , value ) ; } project . setUserProperty ( MagicNames . ANT_FILE , buildFile . getAbsolutePath ( ) ) ; project . setKeepGoingMode ( keepGoingMode ) ; if ( proxy ) { ProxySetup proxySetup = new ProxySetup ( project ) ; proxySetup . enableProxies ( ) ; } ProjectHelper . configureProject ( project , buildFile ) ; if ( projectHelp ) { printDescription ( project ) ; printTargets ( project , msgOutputLevel > Project . MSG_INFO ) ; return ; } if ( targets . size ( ) == 0 ) { if ( project . getDefaultTarget ( ) != null ) { targets . addElement ( project . getDefaultTarget ( ) ) ; } } project . executeTargets ( targets ) ; } finally { if ( oldsm != null ) { System . setSecurityManager ( oldsm ) ; } System . setOut ( savedOut ) ; System . setErr ( savedErr ) ; System . setIn ( savedIn ) ; } } catch ( RuntimeException exc ) { error = exc ; throw exc ; } catch ( Error e ) { error = e ; throw e ; } finally { if ( ! projectHelp ) { project . fireBuildFinished ( error ) ; } else if ( error != null ) { project . log ( error . toString ( ) , Project . MSG_ERR ) ; } } } protected void addBuildListeners ( Project project ) { project . addBuildListener ( createLogger ( ) ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { String className = ( String ) listeners . elementAt ( i ) ; BuildListener listener = ( BuildListener ) ClasspathUtils . newInstance ( className , Main . class . getClassLoader ( ) , BuildListener . class ) ; if ( project != null ) { project . setProjectReference ( listener ) ; } project . addBuildListener ( listener ) ; } } private void addInputHandler ( Project project ) throws BuildException { InputHandler handler = null ; if ( inputHandlerClassname == null ) { handler = new DefaultInputHandler ( ) ; } else { handler = ( InputHandler ) ClasspathUtils . newInstance ( inputHandlerClassname , Main . class . getClassLoader ( ) , InputHandler . class ) ; if ( project != null ) { project . setProjectReference ( handler ) ; } } project . setInputHandler ( handler ) ; } private BuildLogger createLogger ( ) { BuildLogger logger = null ; if ( loggerClassname != null ) { try { logger = ( BuildLogger ) ClasspathUtils . newInstance ( loggerClassname , Main . class . getClassLoader ( ) , BuildLogger . class ) ; } catch ( BuildException e ) { System . err . println ( "The specified logger class " + loggerClassname + " could not be used because " + e . getMessage ( ) ) ; throw new RuntimeException ( ) ; } } else { logger = new DefaultLogger ( ) ; } logger . setMessageOutputLevel ( msgOutputLevel ) ; logger . setOutputPrintStream ( out ) ; logger . setErrorPrintStream ( err ) ; logger . setEmacsMode ( emacsMode ) ; return logger ; } private static void printUsage ( ) { String lSep = System . getProperty ( "line.separator" ) ; StringBuffer msg = new StringBuffer ( ) ; msg . append ( "ant [options] [target [target2 [target3] ...]]" + lSep ) ; msg . append ( "Options: " + lSep ) ; msg . append ( "  -help, -h              print this message" + lSep ) ; msg . append ( "  -projecthelp, -p       print project help information" + lSep ) ; msg . append ( "  -version               print the version information and exit" + lSep ) ; msg . append ( "  -diagnostics           print information that might be helpful to" + lSep ) ; msg . append ( "                         diagnose or report problems." + lSep ) ; msg . append ( "  -quiet, -q             be extra quiet" + lSep ) ; msg . append ( "  -verbose, -v           be extra verbose" + lSep ) ; msg . append ( "  -debug, -d             print debugging information" + lSep ) ; msg . append ( "  -emacs, -e             produce logging information without adornments" + lSep ) ; msg . append ( "  -lib <path>            specifies a path to search for jars and classes" + lSep ) ; msg . append ( "  -logfile <file>        use given file for log" + lSep ) ; msg . append ( "    -l     <file>                ''" + lSep ) ; msg . append ( "  -logger <classname>    the class which is to perform logging" + lSep ) ; msg . append ( "  -listener <classname>  add an instance of class as a project listener" + lSep ) ; msg . append ( "  -noinput               do not allow interactive input" + lSep ) ; msg . append ( "  -buildfile <file>      use given buildfile" + lSep ) ; msg . append ( "    -file    <file>              ''" + lSep ) ; msg . append ( "    -f       <file>              ''" + lSep ) ; msg . append ( "  -D<property>=<value>   use value for given property" + lSep ) ; msg . append ( "  -keep-going, -k        execute all targets that do not depend" + lSep ) ; msg . append ( "                         on failed target(s)" + lSep ) ; msg . append ( "  -propertyfile <name>   load all properties from file with -D" + lSep ) ; msg . append ( "                         properties taking precedence" + lSep ) ; msg . append ( "  -inputhandler <class>  the class which will handle input requests" + lSep ) ; msg . append ( "  -find <file>           (s)earch for buildfile towards the root of" + lSep ) ; msg . append ( "    -s  <file>           the filesystem and use it" + lSep ) ; msg . append ( "  -nice  number          A niceness value for the main thread:" + lSep + "                         1 (lowest) to 10 (highest); 5 is the default" + lSep ) ; msg . append ( "  -nouserlib             Run ant without using the jar files from" + lSep + "                         ${user.home}/.ant/lib" + lSep ) ; msg . append ( "  -noclasspath           Run ant without using CLASSPATH" + lSep ) ; msg . append ( "  -autoproxy             Java1.5+: use the OS proxy settings" + lSep ) ; msg . append ( "  -main <class>          override Ant's normal entry point" ) ; System . out . println ( msg . toString ( ) ) ; } private static void printVersion ( ) throws BuildException { System . out . println ( getAntVersion ( ) ) ; } private static String antVersion = null ; public static synchronized String getAntVersion ( ) throws BuildException { if ( antVersion == null ) { try { Properties props = new Properties ( ) ; InputStream in = Main . class . getResourceAsStream ( "/org/apache/tools/ant/version.txt" ) ; props . load ( in ) ; in . close ( ) ; StringBuffer msg = new StringBuffer ( ) ; msg . append ( "Apache Ant version " ) ; msg . append ( props . getProperty ( "VERSION" ) ) ; msg . append ( " compiled on " ) ; msg . append ( props . getProperty ( "DATE" ) ) ; antVersion = msg . toString ( ) ; } catch ( IOException ioe ) { throw new BuildException ( "Could not load the version information:" + ioe . getMessage ( ) ) ; } catch ( NullPointerException npe ) { throw new BuildException ( "Could not load the version information." ) ; } } return antVersion ; } private static void printDescription ( Project project ) { if ( project . getDescription ( ) != null ) { project . log ( project . getDescription ( ) ) ; } } private static void printTargets ( Project project , boolean printSubTargets ) { int maxLength = 0 ; Enumeration ptargets = project . getTargets ( ) . elements ( ) ; String targetName ; String targetDescription ; Target currentTarget ; Vector topNames = new Vector ( ) ; Vector topDescriptions = new Vector ( ) ; Vector subNames = new Vector ( ) ; while ( ptargets . hasMoreElements ( ) ) { currentTarget = ( Target ) ptargets . nextElement ( ) ; targetName = currentTarget . getName ( ) ; if ( targetName . equals ( "" ) ) { continue ; } targetDescription = currentTarget . getDescription ( ) ; if ( targetDescription == null ) { int pos = findTargetPosition ( subNames , targetName ) ; subNames . insertElementAt ( targetName , pos ) ; } else { int pos = findTargetPosition ( topNames , targetName ) ; topNames . insertElementAt ( targetName , pos ) ; topDescriptions . insertElementAt ( targetDescription , pos ) ; if ( targetName . length ( ) > maxLength ) { maxLength = targetName . length ( ) ; } } } printTargets ( project , topNames , topDescriptions , "Main targets:" , maxLength ) ; if ( topNames . size ( ) == 0 ) { printSubTargets = true ; } if ( printSubTargets ) { printTargets ( project , subNames , null , "Other targets:" , 0 ) ; } String defaultTarget = project . getDefaultTarget ( ) ; if ( defaultTarget != null && ! "" . equals ( defaultTarget ) ) { project . log ( "Default target: " + defaultTarget ) ; } } private static int findTargetPosition ( Vector names , String name ) { int res = names . size ( ) ; for ( int i = 0 ; i < names . size ( ) && res == names . size ( ) ; i ++ ) { if ( name . compareTo ( ( String ) names . elementAt ( i ) ) < 0 ) { res = i ; } } return res ; } private static void printTargets ( Project project , Vector names , Vector descriptions , String heading , int maxlen ) { String lSep = System . getProperty ( "line.separator" ) ; String spaces = "    " ; while ( spaces . length ( ) <= maxlen ) { spaces += spaces ; } StringBuffer msg = new StringBuffer ( ) ; msg . append ( heading + lSep + lSep ) ; for ( int i = 0 ; i < names . size ( ) ; i ++ ) { msg . append ( " " ) ; msg . append ( names . elementAt ( i ) ) ; if ( descriptions != null ) { msg . append ( spaces . substring ( 0 , maxlen - ( ( String ) names . elementAt ( i ) ) . length ( ) + 2 ) ) ; msg . append ( descriptions . elementAt ( i ) ) ; } msg . append ( lSep ) ; } project . log ( msg . toString ( ) , Project . MSG_WARN ) ; } } 	1	['23', '1', '0', '17', '126', '161', '2', '17', '5', '0.770833333', '2117', '0.791666667', '0', '0', '0.148760331', '0', '0', '90', '53', '4.5217', '4']
package org . apache . tools . ant . taskdefs . optional . junit ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . OutputStream ; import java . io . PrintWriter ; import java . lang . reflect . Constructor ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Enumeration ; import java . util . HashMap ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Properties ; import java . util . Vector ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . ExecuteWatchdog ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . taskdefs . PumpStreamHandler ; import org . apache . tools . ant . types . Assertions ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . CommandlineJava ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Environment ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Permissions ; import org . apache . tools . ant . types . PropertySet ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . LoaderUtils ; public class JUnitTask extends Task { private static final String CLASSPATH = "CLASSPATH=" ; private CommandlineJava commandline ; private Vector tests = new Vector ( ) ; private Vector batchTests = new Vector ( ) ; private Vector formatters = new Vector ( ) ; private File dir = null ; private Integer timeout = null ; private boolean summary = false ; private boolean reloading = true ; private String summaryValue = "" ; private JUnitTaskMirror . JUnitTestRunnerMirror runner = null ; private boolean newEnvironment = false ; private Environment env = new Environment ( ) ; private boolean includeAntRuntime = true ; private Path antRuntimeClasses = null ; private boolean showOutput = false ; private boolean outputToFormatters = true ; private File tmpDir ; private AntClassLoader classLoader = null ; private Permissions perm = null ; private ForkMode forkMode = new ForkMode ( "perTest" ) ; private boolean splitJunit = false ; private JUnitTaskMirror delegate ; private boolean haltOnError = false ; private boolean haltOnFail = false ; private boolean filterTrace = true ; private boolean fork = false ; private String failureProperty ; private String errorProperty ; private static final int STRING_BUFFER_SIZE = 128 ; public static final String TESTLISTENER_PREFIX = "junit.framework.TestListener: " ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; public void setReloading ( boolean value ) { reloading = value ; } public void setFiltertrace ( boolean value ) { this . filterTrace = value ; } public void setHaltonerror ( boolean value ) { this . haltOnError = value ; } public void setErrorProperty ( String propertyName ) { this . errorProperty = propertyName ; } public void setHaltonfailure ( boolean value ) { this . haltOnFail = value ; } public void setFailureProperty ( String propertyName ) { this . failureProperty = propertyName ; } public void setFork ( boolean value ) { this . fork = value ; } public void setForkMode ( ForkMode mode ) { this . forkMode = mode ; } public void setPrintsummary ( SummaryAttribute value ) { summaryValue = value . getValue ( ) ; summary = value . asBoolean ( ) ; } public static class SummaryAttribute extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "true" , "yes" , "false" , "no" , "on" , "off" , "withOutAndErr" } ; } public boolean asBoolean ( ) { String v = getValue ( ) ; return "true" . equals ( v ) || "on" . equals ( v ) || "yes" . equals ( v ) || "withOutAndErr" . equals ( v ) ; } } public void setTimeout ( Integer value ) { timeout = value ; } public void setMaxmemory ( String max ) { getCommandline ( ) . setMaxmemory ( max ) ; } public void setJvm ( String value ) { getCommandline ( ) . setVm ( value ) ; } public Commandline . Argument createJvmarg ( ) { return getCommandline ( ) . createVmArgument ( ) ; } public void setDir ( File dir ) { this . dir = dir ; } public void addSysproperty ( Environment . Variable sysp ) { getCommandline ( ) . addSysproperty ( sysp ) ; } public void addConfiguredSysproperty ( Environment . Variable sysp ) { String testString = sysp . getContent ( ) ; getProject ( ) . log ( "sysproperty added : " + testString , Project . MSG_DEBUG ) ; getCommandline ( ) . addSysproperty ( sysp ) ; } public void addSyspropertyset ( PropertySet sysp ) { getCommandline ( ) . addSyspropertyset ( sysp ) ; } public Path createClasspath ( ) { return getCommandline ( ) . createClasspath ( getProject ( ) ) . createPath ( ) ; } public Path createBootclasspath ( ) { return getCommandline ( ) . createBootclasspath ( getProject ( ) ) . createPath ( ) ; } public void addEnv ( Environment . Variable var ) { env . addVariable ( var ) ; } public void setNewenvironment ( boolean newenv ) { newEnvironment = newenv ; } private void preConfigure ( BaseTest test ) { test . setFiltertrace ( filterTrace ) ; test . setHaltonerror ( haltOnError ) ; if ( errorProperty != null ) { test . setErrorProperty ( errorProperty ) ; } test . setHaltonfailure ( haltOnFail ) ; if ( failureProperty != null ) { test . setFailureProperty ( failureProperty ) ; } test . setFork ( fork ) ; } public void addTest ( JUnitTest test ) { tests . addElement ( test ) ; preConfigure ( test ) ; } public BatchTest createBatchTest ( ) { BatchTest test = new BatchTest ( getProject ( ) ) ; batchTests . addElement ( test ) ; preConfigure ( test ) ; return test ; } public void addFormatter ( FormatterElement fe ) { formatters . addElement ( fe ) ; } public void setIncludeantruntime ( boolean b ) { includeAntRuntime = b ; } public void setShowOutput ( boolean showOutput ) { this . showOutput = showOutput ; } public void setOutputToFormatters ( boolean outputToFormatters ) { this . outputToFormatters = outputToFormatters ; } public void addAssertions ( Assertions asserts ) { if ( getCommandline ( ) . getAssertions ( ) != null ) { throw new BuildException ( "Only one assertion declaration is allowed" ) ; } getCommandline ( ) . setAssertions ( asserts ) ; } public Permissions createPermissions ( ) { if ( perm == null ) { perm = new Permissions ( ) ; } return perm ; } public void setCloneVm ( boolean cloneVm ) { getCommandline ( ) . setCloneVm ( cloneVm ) ; } public JUnitTask ( ) throws Exception { getCommandline ( ) . setClassname ( "org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner" ) ; } public void setTempdir ( File tmpDir ) { if ( tmpDir != null ) { if ( ! tmpDir . exists ( ) || ! tmpDir . isDirectory ( ) ) { throw new BuildException ( tmpDir . toString ( ) + " is not a valid temp directory" ) ; } } this . tmpDir = tmpDir ; } public void init ( ) { antRuntimeClasses = new Path ( getProject ( ) ) ; splitJunit = ! addClasspathEntry ( "/junit/framework/TestCase.class" ) ; addClasspathEntry ( "/org/apache/tools/ant/launch/AntMain.class" ) ; addClasspathEntry ( "/org/apache/tools/ant/Task.class" ) ; addClasspathEntry ( "/org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.class" ) ; } private static JUnitTaskMirror createMirror ( JUnitTask task , ClassLoader loader ) { try { loader . loadClass ( "junit.framework.Test" ) ; } catch ( ClassNotFoundException e ) { throw new BuildException ( "The <classpath> for <junit> must include junit.jar " + "if not in Ant's own classpath" , e , task . getLocation ( ) ) ; } try { Class c = loader . loadClass ( JUnitTaskMirror . class . getName ( ) + "Impl" ) ; if ( c . getClassLoader ( ) != loader ) { throw new BuildException ( "Overdelegating loader" , task . getLocation ( ) ) ; } Constructor cons = c . getConstructor ( new Class [ ] { JUnitTask . class } ) ; return ( JUnitTaskMirror ) cons . newInstance ( new Object [ ] { task } ) ; } catch ( Exception e ) { throw new BuildException ( e , task . getLocation ( ) ) ; } } private final class SplitLoader extends AntClassLoader { public SplitLoader ( ClassLoader parent , Path path ) { super ( parent , getProject ( ) , path , true ) ; } protected synchronized Class loadClass ( String classname , boolean resolve ) throws ClassNotFoundException { Class theClass = findLoadedClass ( classname ) ; if ( theClass != null ) { return theClass ; } if ( isSplit ( classname ) ) { theClass = findClass ( classname ) ; if ( resolve ) { resolveClass ( theClass ) ; } return theClass ; } else { return super . loadClass ( classname , resolve ) ; } } private final String [ ] splitClasses = { "BriefJUnitResultFormatter" , "JUnitResultFormatter" , "JUnitTaskMirrorImpl" , "JUnitTestRunner" , "JUnitVersionHelper" , "OutErrSummaryJUnitResultFormatter" , "PlainJUnitResultFormatter" , "SummaryJUnitResultFormatter" , "XMLJUnitResultFormatter" , } ; private boolean isSplit ( String classname ) { String simplename = classname . substring ( classname . lastIndexOf ( '.' ) + 1 ) ; for ( int i = 0 ; i < splitClasses . length ; i ++ ) { if ( simplename . equals ( splitClasses [ i ] ) || simplename . startsWith ( splitClasses [ i ] + '$' ) ) { return true ; } } return false ; } } public void execute ( ) throws BuildException { ClassLoader myLoader = JUnitTask . class . getClassLoader ( ) ; ClassLoader mirrorLoader ; if ( splitJunit ) { Path path = new Path ( getProject ( ) ) ; path . add ( antRuntimeClasses ) ; path . add ( getCommandline ( ) . getClasspath ( ) ) ; mirrorLoader = new SplitLoader ( myLoader , path ) ; } else { mirrorLoader = myLoader ; } delegate = createMirror ( this , mirrorLoader ) ; List testLists = new ArrayList ( ) ; boolean forkPerTest = forkMode . getValue ( ) . equals ( ForkMode . PER_TEST ) ; if ( forkPerTest || forkMode . getValue ( ) . equals ( ForkMode . ONCE ) ) { testLists . addAll ( executeOrQueue ( getIndividualTests ( ) , forkPerTest ) ) ; } else { final int count = batchTests . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { BatchTest batchtest = ( BatchTest ) batchTests . elementAt ( i ) ; testLists . addAll ( executeOrQueue ( batchtest . elements ( ) , false ) ) ; } testLists . addAll ( executeOrQueue ( tests . elements ( ) , forkPerTest ) ) ; } try { Iterator iter = testLists . iterator ( ) ; while ( iter . hasNext ( ) ) { List l = ( List ) iter . next ( ) ; if ( l . size ( ) == 1 ) { execute ( ( JUnitTest ) l . get ( 0 ) ) ; } else { execute ( l ) ; } } } finally { deleteClassLoader ( ) ; if ( mirrorLoader instanceof SplitLoader ) { ( ( SplitLoader ) mirrorLoader ) . cleanup ( ) ; } delegate = null ; } } protected void execute ( JUnitTest arg ) throws BuildException { JUnitTest test = ( JUnitTest ) arg . clone ( ) ; if ( test . getTodir ( ) == null ) { test . setTodir ( getProject ( ) . resolveFile ( "." ) ) ; } if ( test . getOutfile ( ) == null ) { test . setOutfile ( "TEST-" + test . getName ( ) ) ; } TestResultHolder result = null ; if ( ! test . getFork ( ) ) { result = executeInVM ( test ) ; } else { ExecuteWatchdog watchdog = createWatchdog ( ) ; result = executeAsForked ( test , watchdog , null ) ; } actOnTestResult ( result , test , "Test " + test . getName ( ) ) ; } protected void execute ( List tests ) throws BuildException { JUnitTest test = null ; File casesFile = createTempPropertiesFile ( "junittestcases" ) ; PrintWriter writer = null ; try { writer = new PrintWriter ( new BufferedWriter ( new FileWriter ( casesFile ) ) ) ; Iterator iter = tests . iterator ( ) ; while ( iter . hasNext ( ) ) { test = ( JUnitTest ) iter . next ( ) ; writer . print ( test . getName ( ) ) ; if ( test . getTodir ( ) == null ) { writer . print ( "," + getProject ( ) . resolveFile ( "." ) ) ; } else { writer . print ( "," + test . getTodir ( ) ) ; } if ( test . getOutfile ( ) == null ) { writer . println ( "," + "TEST-" + test . getName ( ) ) ; } else { writer . println ( "," + test . getOutfile ( ) ) ; } } writer . flush ( ) ; writer . close ( ) ; writer = null ; ExecuteWatchdog watchdog = createWatchdog ( ) ; TestResultHolder result = executeAsForked ( test , watchdog , casesFile ) ; actOnTestResult ( result , test , "Tests" ) ; } catch ( IOException e ) { log ( e . toString ( ) , Project . MSG_ERR ) ; throw new BuildException ( e ) ; } finally { if ( writer != null ) { writer . close ( ) ; } try { casesFile . delete ( ) ; } catch ( Exception e ) { log ( e . toString ( ) , Project . MSG_ERR ) ; } } } private TestResultHolder executeAsForked ( JUnitTest test , ExecuteWatchdog watchdog , File casesFile ) throws BuildException { if ( perm != null ) { log ( "Permissions ignored when running in forked mode!" , Project . MSG_WARN ) ; } CommandlineJava cmd = null ; try { cmd = ( CommandlineJava ) ( getCommandline ( ) . clone ( ) ) ; } catch ( CloneNotSupportedException e ) { throw new BuildException ( "This shouldn't happen" , e , getLocation ( ) ) ; } cmd . setClassname ( "org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner" ) ; if ( casesFile == null ) { cmd . createArgument ( ) . setValue ( test . getName ( ) ) ; } else { log ( "Running multiple tests in the same VM" , Project . MSG_VERBOSE ) ; cmd . createArgument ( ) . setValue ( Constants . TESTSFILE + casesFile ) ; } cmd . createArgument ( ) . setValue ( Constants . FILTERTRACE + test . getFiltertrace ( ) ) ; cmd . createArgument ( ) . setValue ( Constants . HALT_ON_ERROR + test . getHaltonerror ( ) ) ; cmd . createArgument ( ) . setValue ( Constants . HALT_ON_FAILURE + test . getHaltonfailure ( ) ) ; if ( includeAntRuntime ) { Vector v = Execute . getProcEnvironment ( ) ; Enumeration e = v . elements ( ) ; while ( e . hasMoreElements ( ) ) { String s = ( String ) e . nextElement ( ) ; if ( s . startsWith ( CLASSPATH ) ) { cmd . createClasspath ( getProject ( ) ) . createPath ( ) . append ( new Path ( getProject ( ) , s . substring ( CLASSPATH . length ( ) ) ) ) ; } } log ( "Implicitly adding " + antRuntimeClasses + " to CLASSPATH" , Project . MSG_VERBOSE ) ; cmd . createClasspath ( getProject ( ) ) . createPath ( ) . append ( antRuntimeClasses ) ; } if ( summary ) { String prefix = "" ; if ( "withoutanderr" . equalsIgnoreCase ( summaryValue ) ) { prefix = "OutErr" ; } cmd . createArgument ( ) . setValue ( Constants . FORMATTER + "org.apache.tools.ant.taskdefs.optional.junit." + prefix + "SummaryJUnitResultFormatter" ) ; } cmd . createArgument ( ) . setValue ( Constants . SHOWOUTPUT + String . valueOf ( showOutput ) ) ; cmd . createArgument ( ) . setValue ( Constants . OUTPUT_TO_FORMATTERS + String . valueOf ( outputToFormatters ) ) ; cmd . createArgument ( ) . setValue ( Constants . LOGTESTLISTENEREVENTS + "true" ) ; StringBuffer formatterArg = new StringBuffer ( STRING_BUFFER_SIZE ) ; final FormatterElement [ ] feArray = mergeFormatters ( test ) ; for ( int i = 0 ; i < feArray . length ; i ++ ) { FormatterElement fe = feArray [ i ] ; if ( fe . shouldUse ( this ) ) { formatterArg . append ( Constants . FORMATTER ) ; formatterArg . append ( fe . getClassname ( ) ) ; File outFile = getOutput ( fe , test ) ; if ( outFile != null ) { formatterArg . append ( "," ) ; formatterArg . append ( outFile ) ; } cmd . createArgument ( ) . setValue ( formatterArg . toString ( ) ) ; formatterArg = new StringBuffer ( ) ; } } File vmWatcher = createTempPropertiesFile ( "junitvmwatcher" ) ; cmd . createArgument ( ) . setValue ( Constants . CRASHFILE + vmWatcher . getAbsolutePath ( ) ) ; File propsFile = createTempPropertiesFile ( "junit" ) ; cmd . createArgument ( ) . setValue ( Constants . PROPSFILE + propsFile . getAbsolutePath ( ) ) ; Hashtable p = getProject ( ) . getProperties ( ) ; Properties props = new Properties ( ) ; for ( Enumeration e = p . keys ( ) ; e . hasMoreElements ( ) ; ) { Object key = e . nextElement ( ) ; props . put ( key , p . get ( key ) ) ; } try { FileOutputStream outstream = new FileOutputStream ( propsFile ) ; props . store ( outstream , "Ant JUnitTask generated properties file" ) ; outstream . close ( ) ; } catch ( java . io . IOException e ) { propsFile . delete ( ) ; throw new BuildException ( "Error creating temporary properties " + "file." , e , getLocation ( ) ) ; } Execute execute = new Execute ( new JUnitLogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) , watchdog ) ; execute . setCommandline ( cmd . getCommandline ( ) ) ; execute . setAntRun ( getProject ( ) ) ; if ( dir != null ) { execute . setWorkingDirectory ( dir ) ; } String [ ] environment = env . getVariables ( ) ; if ( environment != null ) { for ( int i = 0 ; i < environment . length ; i ++ ) { log ( "Setting environment variable: " + environment [ i ] , Project . MSG_VERBOSE ) ; } } execute . setNewenvironment ( newEnvironment ) ; execute . setEnvironment ( environment ) ; log ( cmd . describeCommand ( ) , Project . MSG_VERBOSE ) ; TestResultHolder result = new TestResultHolder ( ) ; try { result . exitCode = execute . execute ( ) ; } catch ( IOException e ) { throw new BuildException ( "Process fork failed." , e , getLocation ( ) ) ; } finally { String vmCrashString = "unknown" ; BufferedReader br = null ; try { br = new BufferedReader ( new FileReader ( vmWatcher ) ) ; vmCrashString = br . readLine ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { FileUtils . close ( br ) ; } if ( watchdog != null && watchdog . killedProcess ( ) ) { result . timedOut = true ; logTimeout ( feArray , test , vmCrashString ) ; } else if ( ! Constants . TERMINATED_SUCCESSFULLY . equals ( vmCrashString ) ) { result . crashed = true ; logVmCrash ( feArray , test , vmCrashString ) ; } vmWatcher . delete ( ) ; if ( ! propsFile . delete ( ) ) { throw new BuildException ( "Could not delete temporary " + "properties file." ) ; } } return result ; } private File createTempPropertiesFile ( String prefix ) { File propsFile = FILE_UTILS . createTempFile ( prefix , ".properties" , tmpDir != null ? tmpDir : getProject ( ) . getBaseDir ( ) , true ) ; return propsFile ; } protected void handleOutput ( String output ) { if ( output . startsWith ( TESTLISTENER_PREFIX ) ) { log ( output , Project . MSG_VERBOSE ) ; } else if ( runner != null ) { if ( outputToFormatters ) { runner . handleOutput ( output ) ; } if ( showOutput ) { super . handleOutput ( output ) ; } } else { super . handleOutput ( output ) ; } } protected int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException { if ( runner != null ) { return runner . handleInput ( buffer , offset , length ) ; } else { return super . handleInput ( buffer , offset , length ) ; } } protected void handleFlush ( String output ) { if ( runner != null ) { runner . handleFlush ( output ) ; if ( showOutput ) { super . handleFlush ( output ) ; } } else { super . handleFlush ( output ) ; } } public void handleErrorOutput ( String output ) { if ( runner != null ) { runner . handleErrorOutput ( output ) ; if ( showOutput ) { super . handleErrorOutput ( output ) ; } } else { super . handleErrorOutput ( output ) ; } } public void handleErrorFlush ( String output ) { if ( runner != null ) { runner . handleErrorFlush ( output ) ; if ( showOutput ) { super . handleErrorFlush ( output ) ; } } else { super . handleErrorFlush ( output ) ; } } private TestResultHolder executeInVM ( JUnitTest arg ) throws BuildException { JUnitTest test = ( JUnitTest ) arg . clone ( ) ; test . setProperties ( getProject ( ) . getProperties ( ) ) ; if ( dir != null ) { log ( "dir attribute ignored if running in the same VM" , Project . MSG_WARN ) ; } if ( newEnvironment || null != env . getVariables ( ) ) { log ( "Changes to environment variables are ignored if running in " + "the same VM." , Project . MSG_WARN ) ; } if ( getCommandline ( ) . getBootclasspath ( ) != null ) { log ( "bootclasspath is ignored if running in the same VM." , Project . MSG_WARN ) ; } CommandlineJava . SysProperties sysProperties = getCommandline ( ) . getSystemProperties ( ) ; if ( sysProperties != null ) { sysProperties . setSystem ( ) ; } try { log ( "Using System properties " + System . getProperties ( ) , Project . MSG_VERBOSE ) ; if ( splitJunit ) { classLoader = ( AntClassLoader ) delegate . getClass ( ) . getClassLoader ( ) ; } else { createClassLoader ( ) ; } if ( classLoader != null ) { classLoader . setThreadContextLoader ( ) ; } runner = delegate . newJUnitTestRunner ( test , test . getHaltonerror ( ) , test . getFiltertrace ( ) , test . getHaltonfailure ( ) , false , true , classLoader ) ; if ( summary ) { JUnitTaskMirror . SummaryJUnitResultFormatterMirror f = delegate . newSummaryJUnitResultFormatter ( ) ; f . setWithOutAndErr ( "withoutanderr" . equalsIgnoreCase ( summaryValue ) ) ; f . setOutput ( getDefaultOutput ( ) ) ; runner . addFormatter ( f ) ; } runner . setPermissions ( perm ) ; final FormatterElement [ ] feArray = mergeFormatters ( test ) ; for ( int i = 0 ; i < feArray . length ; i ++ ) { FormatterElement fe = feArray [ i ] ; if ( fe . shouldUse ( this ) ) { File outFile = getOutput ( fe , test ) ; if ( outFile != null ) { fe . setOutfile ( outFile ) ; } else { fe . setOutput ( getDefaultOutput ( ) ) ; } runner . addFormatter ( fe . createFormatter ( classLoader ) ) ; } } runner . run ( ) ; TestResultHolder result = new TestResultHolder ( ) ; result . exitCode = runner . getRetCode ( ) ; return result ; } finally { if ( sysProperties != null ) { sysProperties . restoreSystem ( ) ; } if ( classLoader != null ) { classLoader . resetThreadContextLoader ( ) ; } } } protected ExecuteWatchdog createWatchdog ( ) throws BuildException { if ( timeout == null ) { return null ; } return new ExecuteWatchdog ( ( long ) timeout . intValue ( ) ) ; } protected OutputStream getDefaultOutput ( ) { return new LogOutputStream ( this , Project . MSG_INFO ) ; } protected Enumeration getIndividualTests ( ) { final int count = batchTests . size ( ) ; final Enumeration [ ] enums = new Enumeration [ count + 1 ] ; for ( int i = 0 ; i < count ; i ++ ) { BatchTest batchtest = ( BatchTest ) batchTests . elementAt ( i ) ; enums [ i ] = batchtest . elements ( ) ; } enums [ enums . length - 1 ] = tests . elements ( ) ; return Enumerations . fromCompound ( enums ) ; } protected Enumeration allTests ( ) { Enumeration [ ] enums = { tests . elements ( ) , batchTests . elements ( ) } ; return Enumerations . fromCompound ( enums ) ; } private FormatterElement [ ] mergeFormatters ( JUnitTest test ) { Vector feVector = ( Vector ) formatters . clone ( ) ; test . addFormattersTo ( feVector ) ; FormatterElement [ ] feArray = new FormatterElement [ feVector . size ( ) ] ; feVector . copyInto ( feArray ) ; return feArray ; } protected File getOutput ( FormatterElement fe , JUnitTest test ) { if ( fe . getUseFile ( ) ) { String base = test . getOutfile ( ) ; if ( base == null ) { base = JUnitTaskMirror . JUnitTestRunnerMirror . IGNORED_FILE_NAME ; } String filename = base + fe . getExtension ( ) ; File destFile = new File ( test . getTodir ( ) , filename ) ; String absFilename = destFile . getAbsolutePath ( ) ; return getProject ( ) . resolveFile ( absFilename ) ; } return null ; } protected boolean addClasspathEntry ( String resource ) { if ( resource . startsWith ( "/" ) ) { resource = resource . substring ( 1 ) ; } else { resource = "org/apache/tools/ant/taskdefs/optional/junit/" + resource ; } File f = LoaderUtils . getResourceSource ( getClass ( ) . getClassLoader ( ) , resource ) ; if ( f != null ) { log ( "Found " + f . getAbsolutePath ( ) , Project . MSG_DEBUG ) ; antRuntimeClasses . createPath ( ) . setLocation ( f ) ; return true ; } else { log ( "Couldn\'t find " + resource , Project . MSG_DEBUG ) ; return false ; } } private void logTimeout ( FormatterElement [ ] feArray , JUnitTest test , String testCase ) { logVmExit ( feArray , test , "Timeout occurred. Please note the time in the report does" + " not reflect the time until the timeout." , testCase ) ; } private void logVmCrash ( FormatterElement [ ] feArray , JUnitTest test , String testCase ) { logVmExit ( feArray , test , "Forked Java VM exited abnormally. Please note the time in the report" + " does not reflect the time until the VM exit." , testCase ) ; } private void logVmExit ( FormatterElement [ ] feArray , JUnitTest test , String message , String testCase ) { try { log ( "Using System properties " + System . getProperties ( ) , Project . MSG_VERBOSE ) ; if ( splitJunit ) { classLoader = ( AntClassLoader ) delegate . getClass ( ) . getClassLoader ( ) ; } else { createClassLoader ( ) ; } if ( classLoader != null ) { classLoader . setThreadContextLoader ( ) ; } test . setCounts ( 1 , 0 , 1 ) ; test . setProperties ( getProject ( ) . getProperties ( ) ) ; for ( int i = 0 ; i < feArray . length ; i ++ ) { FormatterElement fe = feArray [ i ] ; File outFile = getOutput ( fe , test ) ; JUnitTaskMirror . JUnitResultFormatterMirror formatter = fe . createFormatter ( classLoader ) ; if ( outFile != null && formatter != null ) { try { OutputStream out = new FileOutputStream ( outFile ) ; delegate . addVmExit ( test , formatter , out , message , testCase ) ; } catch ( IOException e ) { } } } if ( summary ) { JUnitTaskMirror . SummaryJUnitResultFormatterMirror f = delegate . newSummaryJUnitResultFormatter ( ) ; f . setWithOutAndErr ( "withoutanderr" . equalsIgnoreCase ( summaryValue ) ) ; delegate . addVmExit ( test , f , getDefaultOutput ( ) , message , testCase ) ; } } finally { if ( classLoader != null ) { classLoader . resetThreadContextLoader ( ) ; } } } private void createClassLoader ( ) { Path userClasspath = getCommandline ( ) . getClasspath ( ) ; if ( userClasspath != null ) { if ( reloading || classLoader == null ) { deleteClassLoader ( ) ; Path classpath = ( Path ) userClasspath . clone ( ) ; if ( includeAntRuntime ) { log ( "Implicitly adding " + antRuntimeClasses + " to CLASSPATH" , Project . MSG_VERBOSE ) ; classpath . append ( antRuntimeClasses ) ; } classLoader = getProject ( ) . createClassLoader ( classpath ) ; if ( getClass ( ) . getClassLoader ( ) != null && getClass ( ) . getClassLoader ( ) != Project . class . getClassLoader ( ) ) { classLoader . setParent ( getClass ( ) . getClassLoader ( ) ) ; } classLoader . setParentFirst ( false ) ; classLoader . addJavaLibraries ( ) ; log ( "Using CLASSPATH " + classLoader . getClasspath ( ) , Project . MSG_VERBOSE ) ; classLoader . addSystemPackageRoot ( "junit" ) ; classLoader . addSystemPackageRoot ( "org.junit" ) ; classLoader . addSystemPackageRoot ( "org.apache.tools.ant" ) ; } } } private void deleteClassLoader ( ) { if ( classLoader != null ) { classLoader . cleanup ( ) ; classLoader = null ; } } protected CommandlineJava getCommandline ( ) { if ( commandline == null ) { commandline = new CommandlineJava ( ) ; } return commandline ; } private static final class ForkedTestConfiguration { private boolean filterTrace ; private boolean haltOnError ; private boolean haltOnFailure ; private String errorProperty ; private String failureProperty ; ForkedTestConfiguration ( boolean filterTrace , boolean haltOnError , boolean haltOnFailure , String errorProperty , String failureProperty ) { this . filterTrace = filterTrace ; this . haltOnError = haltOnError ; this . haltOnFailure = haltOnFailure ; this . errorProperty = errorProperty ; this . failureProperty = failureProperty ; } ForkedTestConfiguration ( JUnitTest test ) { this ( test . getFiltertrace ( ) , test . getHaltonerror ( ) , test . getHaltonfailure ( ) , test . getErrorProperty ( ) , test . getFailureProperty ( ) ) ; } public boolean equals ( Object other ) { if ( other == null || other . getClass ( ) != ForkedTestConfiguration . class ) { return false ; } ForkedTestConfiguration o = ( ForkedTestConfiguration ) other ; return filterTrace == o . filterTrace && haltOnError == o . haltOnError && haltOnFailure == o . haltOnFailure && ( ( errorProperty == null && o . errorProperty == null ) || ( errorProperty != null && errorProperty . equals ( o . errorProperty ) ) ) && ( ( failureProperty == null && o . failureProperty == null ) || ( failureProperty != null && failureProperty . equals ( o . failureProperty ) ) ) ; } public int hashCode ( ) { return ( filterTrace ? 1 : 0 ) + ( haltOnError ? 2 : 0 ) + ( haltOnFailure ? 4 : 0 ) ; } } public static final class ForkMode extends EnumeratedAttribute { public static final String ONCE = "once" ; public static final String PER_TEST = "perTest" ; public static final String PER_BATCH = "perBatch" ; public ForkMode ( ) { super ( ) ; } public ForkMode ( String value ) { super ( ) ; setValue ( value ) ; } public String [ ] getValues ( ) { return new String [ ] { ONCE , PER_TEST , PER_BATCH } ; } } protected Collection executeOrQueue ( Enumeration testList , boolean runIndividual ) { Map testConfigurations = new HashMap ( ) ; while ( testList . hasMoreElements ( ) ) { JUnitTest test = ( JUnitTest ) testList . nextElement ( ) ; if ( test . shouldRun ( getProject ( ) ) ) { if ( runIndividual || ! test . getFork ( ) ) { execute ( test ) ; } else { ForkedTestConfiguration c = new ForkedTestConfiguration ( test ) ; List l = ( List ) testConfigurations . get ( c ) ; if ( l == null ) { l = new ArrayList ( ) ; testConfigurations . put ( c , l ) ; } l . add ( test ) ; } } } return testConfigurations . values ( ) ; } protected void actOnTestResult ( int exitValue , boolean wasKilled , JUnitTest test , String name ) { TestResultHolder t = new TestResultHolder ( ) ; t . exitCode = exitValue ; t . timedOut = wasKilled ; actOnTestResult ( t , test , name ) ; } protected void actOnTestResult ( TestResultHolder result , JUnitTest test , String name ) { boolean fatal = result . timedOut || result . crashed ; boolean errorOccurredHere = result . exitCode == JUnitTaskMirror . JUnitTestRunnerMirror . ERRORS || fatal ; boolean failureOccurredHere = result . exitCode != JUnitTaskMirror . JUnitTestRunnerMirror . SUCCESS || fatal ; if ( errorOccurredHere || failureOccurredHere ) { if ( ( errorOccurredHere && test . getHaltonerror ( ) ) || ( failureOccurredHere && test . getHaltonfailure ( ) ) ) { throw new BuildException ( name + " failed" + ( result . timedOut ? " (timeout)" : "" ) + ( result . crashed ? " (crashed)" : "" ) , getLocation ( ) ) ; } else { log ( name + " FAILED" + ( result . timedOut ? " (timeout)" : "" ) + ( result . crashed ? " (crashed)" : "" ) , Project . MSG_ERR ) ; if ( errorOccurredHere && test . getErrorProperty ( ) != null ) { getProject ( ) . setNewProperty ( test . getErrorProperty ( ) , "true" ) ; } if ( failureOccurredHere && test . getFailureProperty ( ) != null ) { getProject ( ) . setNewProperty ( test . getFailureProperty ( ) , "true" ) ; } } } } protected class TestResultHolder { public int exitCode = JUnitTaskMirror . JUnitTestRunnerMirror . ERRORS ; public boolean timedOut = false ; public boolean crashed = false ; } protected static class JUnitLogOutputStream extends LogOutputStream { private Task task ; public JUnitLogOutputStream ( Task task , int level ) { super ( task , level ) ; this . task = task ; } protected void processLine ( String line , int level ) { if ( line . startsWith ( TESTLISTENER_PREFIX ) ) { task . log ( line , Project . MSG_VERBOSE ) ; } else { super . processLine ( line , level ) ; } } } protected static class JUnitLogStreamHandler extends PumpStreamHandler { public JUnitLogStreamHandler ( Task task , int outlevel , int errlevel ) { super ( new JUnitLogOutputStream ( task , outlevel ) , new LogOutputStream ( task , errlevel ) ) ; } } } 	1	['63', '3', '0', '36', '267', '1715', '4', '35', '36', '0.922939068', '2328', '0.861111111', '9', '0.37755102', '0.091642229', '2', '4', '35.38095238', '21', '2.0794', '5']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . io . PrintWriter ; import java . io . StringWriter ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ExitException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . ExitStatusException ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . CommandlineJava ; import org . apache . tools . ant . types . Environment ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . PropertySet ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . types . Assertions ; import org . apache . tools . ant . types . Permissions ; import org . apache . tools . ant . types . RedirectorElement ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . util . KeepAliveInputStream ; public class Java extends Task { private CommandlineJava cmdl = new CommandlineJava ( ) ; private Environment env = new Environment ( ) ; private boolean fork = false ; private boolean newEnvironment = false ; private File dir = null ; private boolean failOnError = false ; private Long timeout = null ; private String inputString ; private File input ; private File output ; private File error ; protected Redirector redirector = new Redirector ( this ) ; protected RedirectorElement redirectorElement ; private String resultProperty ; private Permissions perm = null ; private boolean spawn = false ; private boolean incompatibleWithSpawn = false ; public Java ( ) { } public Java ( Task owner ) { bindToOwner ( owner ) ; } public void execute ( ) throws BuildException { File savedDir = dir ; Permissions savedPermissions = perm ; int err = - 1 ; try { err = executeJava ( ) ; if ( err != 0 ) { if ( failOnError ) { throw new ExitStatusException ( "Java returned: " + err , err , getLocation ( ) ) ; } else { log ( "Java Result: " + err , Project . MSG_ERR ) ; } } maybeSetResultPropertyValue ( err ) ; } finally { dir = savedDir ; perm = savedPermissions ; } } public int executeJava ( ) throws BuildException { String classname = getCommandLine ( ) . getClassname ( ) ; if ( classname == null && getCommandLine ( ) . getJar ( ) == null ) { throw new BuildException ( "Classname must not be null." ) ; } if ( ! fork && getCommandLine ( ) . getJar ( ) != null ) { throw new BuildException ( "Cannot execute a jar in non-forked mode." + " Please set fork='true'. " ) ; } if ( spawn && ! fork ) { throw new BuildException ( "Cannot spawn a java process in non-forked mode." + " Please set fork='true'. " ) ; } if ( getCommandLine ( ) . getClasspath ( ) != null && getCommandLine ( ) . getJar ( ) != null ) { log ( "When using 'jar' attribute classpath-settings are ignored. " + "See the manual for more information." , Project . MSG_VERBOSE ) ; } if ( spawn && incompatibleWithSpawn ) { getProject ( ) . log ( "spawn does not allow attributes related to input, " + "output, error, result" , Project . MSG_ERR ) ; getProject ( ) . log ( "spawn also does not allow timeout" , Project . MSG_ERR ) ; getProject ( ) . log ( "finally, spawn is not compatible " + "with a nested I/O <redirector>" , Project . MSG_ERR ) ; throw new BuildException ( "You have used an attribute " + "or nested element which is not compatible with spawn" ) ; } if ( getCommandLine ( ) . getAssertions ( ) != null && ! fork ) { log ( "Assertion statements are currently ignored in non-forked mode" ) ; } if ( fork ) { if ( perm != null ) { log ( "Permissions can not be set this way in forked mode." , Project . MSG_WARN ) ; } log ( getCommandLine ( ) . describeCommand ( ) , Project . MSG_VERBOSE ) ; } else { if ( getCommandLine ( ) . getVmCommand ( ) . size ( ) > 1 ) { log ( "JVM args ignored when same JVM is used." , Project . MSG_WARN ) ; } if ( dir != null ) { log ( "Working directory ignored when same JVM is used." , Project . MSG_WARN ) ; } if ( newEnvironment || null != env . getVariables ( ) ) { log ( "Changes to environment variables are ignored when same " + "JVM is used." , Project . MSG_WARN ) ; } if ( getCommandLine ( ) . getBootclasspath ( ) != null ) { log ( "bootclasspath ignored when same JVM is used." , Project . MSG_WARN ) ; } if ( perm == null ) { perm = new Permissions ( true ) ; log ( "running " + this . getCommandLine ( ) . getClassname ( ) + " with default permissions (exit forbidden)" , Project . MSG_VERBOSE ) ; } log ( "Running in same VM " + getCommandLine ( ) . describeJavaCommand ( ) , Project . MSG_VERBOSE ) ; } setupRedirector ( ) ; try { if ( fork ) { if ( ! spawn ) { return fork ( getCommandLine ( ) . getCommandline ( ) ) ; } else { spawn ( getCommandLine ( ) . getCommandline ( ) ) ; return 0 ; } } else { try { run ( getCommandLine ( ) ) ; return 0 ; } catch ( ExitException ex ) { return ex . getStatus ( ) ; } } } catch ( BuildException e ) { if ( e . getLocation ( ) == null && getLocation ( ) != null ) { e . setLocation ( getLocation ( ) ) ; } if ( failOnError ) { throw e ; } else { log ( e ) ; return 0 ; } } catch ( ThreadDeath t ) { throw t ; } catch ( Throwable t ) { if ( failOnError ) { throw new BuildException ( t , getLocation ( ) ) ; } else { log ( t ) ; return 0 ; } } } public void setSpawn ( boolean spawn ) { this . spawn = spawn ; } public void setClasspath ( Path s ) { createClasspath ( ) . append ( s ) ; } public Path createClasspath ( ) { return getCommandLine ( ) . createClasspath ( getProject ( ) ) . createPath ( ) ; } public Path createBootclasspath ( ) { return getCommandLine ( ) . createBootclasspath ( getProject ( ) ) . createPath ( ) ; } public Permissions createPermissions ( ) { perm = ( perm == null ) ? new Permissions ( ) : perm ; return perm ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setJar ( File jarfile ) throws BuildException { if ( getCommandLine ( ) . getClassname ( ) != null ) { throw new BuildException ( "Cannot use 'jar' and 'classname' " + "attributes in same command." ) ; } getCommandLine ( ) . setJar ( jarfile . getAbsolutePath ( ) ) ; } public void setClassname ( String s ) throws BuildException { if ( getCommandLine ( ) . getJar ( ) != null ) { throw new BuildException ( "Cannot use 'jar' and 'classname' " + "attributes in same command" ) ; } getCommandLine ( ) . setClassname ( s ) ; } public void setArgs ( String s ) { log ( "The args attribute is deprecated. " + "Please use nested arg elements." , Project . MSG_WARN ) ; getCommandLine ( ) . createArgument ( ) . setLine ( s ) ; } public void setCloneVm ( boolean cloneVm ) { getCommandLine ( ) . setCloneVm ( cloneVm ) ; } public Commandline . Argument createArg ( ) { return getCommandLine ( ) . createArgument ( ) ; } public void setResultProperty ( String resultProperty ) { this . resultProperty = resultProperty ; incompatibleWithSpawn = true ; } protected void maybeSetResultPropertyValue ( int result ) { String res = Integer . toString ( result ) ; if ( resultProperty != null ) { getProject ( ) . setNewProperty ( resultProperty , res ) ; } } public void setFork ( boolean s ) { this . fork = s ; } public void setJvmargs ( String s ) { log ( "The jvmargs attribute is deprecated. " + "Please use nested jvmarg elements." , Project . MSG_WARN ) ; getCommandLine ( ) . createVmArgument ( ) . setLine ( s ) ; } public Commandline . Argument createJvmarg ( ) { return getCommandLine ( ) . createVmArgument ( ) ; } public void setJvm ( String s ) { getCommandLine ( ) . setVm ( s ) ; } public void addSysproperty ( Environment . Variable sysp ) { getCommandLine ( ) . addSysproperty ( sysp ) ; } public void addSyspropertyset ( PropertySet sysp ) { getCommandLine ( ) . addSyspropertyset ( sysp ) ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; incompatibleWithSpawn |= fail ; } public void setDir ( File d ) { this . dir = d ; } public void setOutput ( File out ) { this . output = out ; incompatibleWithSpawn = true ; } public void setInput ( File input ) { if ( inputString != null ) { throw new BuildException ( "The \"input\" and \"inputstring\" " + "attributes cannot both be specified" ) ; } this . input = input ; incompatibleWithSpawn = true ; } public void setInputString ( String inputString ) { if ( input != null ) { throw new BuildException ( "The \"input\" and \"inputstring\" " + "attributes cannot both be specified" ) ; } this . inputString = inputString ; incompatibleWithSpawn = true ; } public void setLogError ( boolean logError ) { redirector . setLogError ( logError ) ; incompatibleWithSpawn |= logError ; } public void setError ( File error ) { this . error = error ; incompatibleWithSpawn = true ; } public void setOutputproperty ( String outputProp ) { redirector . setOutputProperty ( outputProp ) ; incompatibleWithSpawn = true ; } public void setErrorProperty ( String errorProperty ) { redirector . setErrorProperty ( errorProperty ) ; incompatibleWithSpawn = true ; } public void setMaxmemory ( String max ) { getCommandLine ( ) . setMaxmemory ( max ) ; } public void setJVMVersion ( String value ) { getCommandLine ( ) . setVmversion ( value ) ; } public void addEnv ( Environment . Variable var ) { env . addVariable ( var ) ; } public void setNewenvironment ( boolean newenv ) { newEnvironment = newenv ; } public void setAppend ( boolean append ) { redirector . setAppend ( append ) ; incompatibleWithSpawn = true ; } public void setTimeout ( Long value ) { timeout = value ; incompatibleWithSpawn |= timeout != null ; } public void addAssertions ( Assertions asserts ) { if ( getCommandLine ( ) . getAssertions ( ) != null ) { throw new BuildException ( "Only one assertion declaration is allowed" ) ; } getCommandLine ( ) . setAssertions ( asserts ) ; } public void addConfiguredRedirector ( RedirectorElement redirectorElement ) { if ( this . redirectorElement != null ) { throw new BuildException ( "cannot have > 1 nested redirectors" ) ; } this . redirectorElement = redirectorElement ; incompatibleWithSpawn = true ; } protected void handleOutput ( String output ) { if ( redirector . getOutputStream ( ) != null ) { redirector . handleOutput ( output ) ; } else { super . handleOutput ( output ) ; } } public int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException { return redirector . handleInput ( buffer , offset , length ) ; } protected void handleFlush ( String output ) { if ( redirector . getOutputStream ( ) != null ) { redirector . handleFlush ( output ) ; } else { super . handleFlush ( output ) ; } } protected void handleErrorOutput ( String output ) { if ( redirector . getErrorStream ( ) != null ) { redirector . handleErrorOutput ( output ) ; } else { super . handleErrorOutput ( output ) ; } } protected void handleErrorFlush ( String output ) { if ( redirector . getErrorStream ( ) != null ) { redirector . handleErrorFlush ( output ) ; } else { super . handleErrorOutput ( output ) ; } } protected void setupRedirector ( ) { redirector . setInput ( input ) ; redirector . setInputString ( inputString ) ; redirector . setOutput ( output ) ; redirector . setError ( error ) ; if ( redirectorElement != null ) { redirectorElement . configure ( redirector ) ; } if ( ! spawn && input == null && inputString == null ) { redirector . setInputStream ( new KeepAliveInputStream ( getProject ( ) . getDefaultInputStream ( ) ) ) ; } } private void run ( CommandlineJava command ) throws BuildException { try { ExecuteJava exe = new ExecuteJava ( ) ; exe . setJavaCommand ( command . getJavaCommand ( ) ) ; exe . setClasspath ( command . getClasspath ( ) ) ; exe . setSystemProperties ( command . getSystemProperties ( ) ) ; exe . setPermissions ( perm ) ; exe . setTimeout ( timeout ) ; redirector . createStreams ( ) ; exe . execute ( getProject ( ) ) ; redirector . complete ( ) ; if ( exe . killedProcess ( ) ) { throw new BuildException ( "Timeout: killed the sub-process" ) ; } } catch ( IOException e ) { throw new BuildException ( e ) ; } } private int fork ( String [ ] command ) throws BuildException { Execute exe = new Execute ( redirector . createHandler ( ) , createWatchdog ( ) ) ; setupExecutable ( exe , command ) ; try { int rc = exe . execute ( ) ; redirector . complete ( ) ; if ( exe . killedProcess ( ) ) { throw new BuildException ( "Timeout: killed the sub-process" ) ; } return rc ; } catch ( IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } private void spawn ( String [ ] command ) throws BuildException { Execute exe = new Execute ( ) ; setupExecutable ( exe , command ) ; try { exe . spawn ( ) ; } catch ( IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } private void setupExecutable ( Execute exe , String [ ] command ) { exe . setAntRun ( getProject ( ) ) ; setupWorkingDir ( exe ) ; setupEnvironment ( exe ) ; setupCommandLine ( exe , command ) ; } private void setupEnvironment ( Execute exe ) { String [ ] environment = env . getVariables ( ) ; if ( environment != null ) { for ( int i = 0 ; i < environment . length ; i ++ ) { log ( "Setting environment variable: " + environment [ i ] , Project . MSG_VERBOSE ) ; } } exe . setNewenvironment ( newEnvironment ) ; exe . setEnvironment ( environment ) ; } private void setupWorkingDir ( Execute exe ) { if ( dir == null ) { dir = getProject ( ) . getBaseDir ( ) ; } else if ( ! dir . exists ( ) || ! dir . isDirectory ( ) ) { throw new BuildException ( dir . getAbsolutePath ( ) + " is not a valid directory" , getLocation ( ) ) ; } exe . setWorkingDirectory ( dir ) ; } private void setupCommandLine ( Execute exe , String [ ] command ) { if ( Os . isFamily ( "openvms" ) ) { setupCommandLineForVMS ( exe , command ) ; } else { exe . setCommandline ( command ) ; } } private void setupCommandLineForVMS ( Execute exe , String [ ] command ) { ExecuteJava . setupCommandLineForVMS ( exe , command ) ; } protected void run ( String classname , Vector args ) throws BuildException { CommandlineJava cmdj = new CommandlineJava ( ) ; cmdj . setClassname ( classname ) ; for ( int i = 0 ; i < args . size ( ) ; i ++ ) { cmdj . createArgument ( ) . setValue ( ( String ) args . elementAt ( i ) ) ; } run ( cmdj ) ; } public void clearArgs ( ) { getCommandLine ( ) . clearJavaArgs ( ) ; } protected ExecuteWatchdog createWatchdog ( ) throws BuildException { if ( timeout == null ) { return null ; } return new ExecuteWatchdog ( timeout . longValue ( ) ) ; } private void log ( Throwable t ) { StringWriter sw = new StringWriter ( ) ; PrintWriter w = new PrintWriter ( sw ) ; t . printStackTrace ( w ) ; w . close ( ) ; log ( sw . toString ( ) , Project . MSG_ERR ) ; } public CommandlineJava getCommandLine ( ) { return cmdl ; } public CommandlineJava . SysProperties getSysProperties ( ) { return getCommandLine ( ) . getSystemProperties ( ) ; } } 	1	['60', '3', '0', '35', '178', '1304', '10', '25', '43', '0.891326022', '1152', '1', '5', '0.389473684', '0.098245614', '1', '4', '17.91666667', '5', '1.3167', '2']
package org . apache . tools . ant . taskdefs . optional . ssh ; import java . io . File ; import java . io . IOException ; import com . jcraft . jsch . JSchException ; import com . jcraft . jsch . Session ; import com . jcraft . jsch . ChannelSftp ; import com . jcraft . jsch . SftpException ; import com . jcraft . jsch . SftpATTRS ; import com . jcraft . jsch . SftpProgressMonitor ; public class ScpFromMessageBySftp extends ScpFromMessage { private String remoteFile ; private File localFile ; private boolean isRecursive = false ; private boolean verbose = false ; public ScpFromMessageBySftp ( boolean verbose , Session session , String aRemoteFile , File aLocalFile , boolean recursive ) { super ( verbose , session ) ; this . verbose = verbose ; this . remoteFile = aRemoteFile ; this . localFile = aLocalFile ; this . isRecursive = recursive ; } public ScpFromMessageBySftp ( Session session , String aRemoteFile , File aLocalFile , boolean recursive ) { this ( false , session , aRemoteFile , aLocalFile , recursive ) ; } public void execute ( ) throws IOException , JSchException { ChannelSftp channel = openSftpChannel ( ) ; try { channel . connect ( ) ; try { SftpATTRS attrs = channel . stat ( remoteFile ) ; if ( attrs . isDir ( ) && ! remoteFile . endsWith ( "/" ) ) { remoteFile = remoteFile + "/" ; } } catch ( SftpException ee ) { } getDir ( channel , remoteFile , localFile ) ; } catch ( SftpException e ) { throw new JSchException ( e . toString ( ) ) ; } finally { if ( channel != null ) { channel . disconnect ( ) ; } } log ( "done\n" ) ; } private void getDir ( ChannelSftp channel , String remoteFile , File localFile ) throws IOException , SftpException { String pwd = remoteFile ; if ( remoteFile . lastIndexOf ( '/' ) != - 1 ) { if ( remoteFile . length ( ) > 1 ) { pwd = remoteFile . substring ( 0 , remoteFile . lastIndexOf ( '/' ) ) ; } } channel . cd ( pwd ) ; if ( ! localFile . exists ( ) ) { localFile . mkdirs ( ) ; } java . util . Vector files = channel . ls ( remoteFile ) ; for ( int i = 0 ; i < files . size ( ) ; i ++ ) { ChannelSftp . LsEntry le = ( ChannelSftp . LsEntry ) files . elementAt ( i ) ; String name = le . getFilename ( ) ; if ( le . getAttrs ( ) . isDir ( ) ) { if ( name . equals ( "." ) || name . equals ( ".." ) ) { continue ; } getDir ( channel , channel . pwd ( ) + "/" + name + "/" , new File ( localFile , le . getFilename ( ) ) ) ; } else { getFile ( channel , le , localFile ) ; } } channel . cd ( ".." ) ; } private void getFile ( ChannelSftp channel , ChannelSftp . LsEntry le , File localFile ) throws IOException , SftpException { String remoteFile = le . getFilename ( ) ; if ( ! localFile . exists ( ) ) { String path = localFile . getAbsolutePath ( ) ; int i = 0 ; if ( ( i = path . lastIndexOf ( File . pathSeparator ) ) != - 1 ) { if ( path . length ( ) > File . pathSeparator . length ( ) ) { new File ( path . substring ( 0 , i ) ) . mkdirs ( ) ; } } } if ( localFile . isDirectory ( ) ) { localFile = new File ( localFile , remoteFile ) ; } long startTime = System . currentTimeMillis ( ) ; long totalLength = le . getAttrs ( ) . getSize ( ) ; SftpProgressMonitor monitor = null ; boolean trackProgress = getVerbose ( ) && totalLength > 102400 ; if ( trackProgress ) { monitor = getProgressMonitor ( ) ; } try { log ( "Receiving: " + remoteFile + " : " + le . getAttrs ( ) . getSize ( ) ) ; channel . get ( remoteFile , localFile . getAbsolutePath ( ) , monitor ) ; } finally { long endTime = System . currentTimeMillis ( ) ; logStats ( startTime , endTime , ( int ) totalLength ) ; } } } 	1	['5', '3', '0', '9', '44', '8', '1', '8', '3', '0.625', '298', '1', '0', '0.842105263', '0.542857143', '1', '1', '57.8', '1', '0.6', '1']
package org . apache . tools . ant ; import org . apache . tools . ant . util . StringUtils ; public class NoBannerLogger extends DefaultLogger { protected String targetName ; public NoBannerLogger ( ) { } public void targetStarted ( BuildEvent event ) { targetName = event . getTarget ( ) . getName ( ) ; } public void targetFinished ( BuildEvent event ) { targetName = null ; } public void messageLogged ( BuildEvent event ) { if ( event . getPriority ( ) > msgOutputLevel || null == event . getMessage ( ) || "" . equals ( event . getMessage ( ) . trim ( ) ) ) { return ; } if ( null != targetName ) { out . println ( StringUtils . LINE_SEP + targetName + ":" ) ; targetName = null ; } super . messageLogged ( event ) ; } } 	1	['4', '2', '0', '4', '17', '0', '0', '4', '4', '0.333333333', '57', '1', '0', '0.842105263', '0.875', '1', '1', '13', '5', '1.75', '1']
package org . apache . tools . ant . taskdefs ; import java . io . IOException ; import java . net . URL ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ComponentHelper ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . helper . ProjectHelper2 ; import org . apache . tools . ant . UnknownElement ; public class Antlib extends Task implements TaskContainer { public static final String TAG = "antlib" ; public static Antlib createAntlib ( Project project , URL antlibUrl , String uri ) { try { antlibUrl . openConnection ( ) . connect ( ) ; } catch ( IOException ex ) { throw new BuildException ( "Unable to find " + antlibUrl , ex ) ; } ComponentHelper helper = ComponentHelper . getComponentHelper ( project ) ; helper . enterAntLib ( uri ) ; try { ProjectHelper2 parser = new ProjectHelper2 ( ) ; UnknownElement ue = parser . parseUnknownElement ( project , antlibUrl ) ; if ( ! ( ue . getTag ( ) . equals ( TAG ) ) ) { throw new BuildException ( "Unexpected tag " + ue . getTag ( ) + " expecting " + TAG , ue . getLocation ( ) ) ; } Antlib antlib = new Antlib ( ) ; antlib . setProject ( project ) ; antlib . setLocation ( ue . getLocation ( ) ) ; antlib . setTaskName ( "antlib" ) ; antlib . init ( ) ; ue . configure ( antlib ) ; return antlib ; } finally { helper . exitAntLib ( ) ; } } private ClassLoader classLoader ; private String uri = "" ; private List tasks = new ArrayList ( ) ; protected void setClassLoader ( ClassLoader classLoader ) { this . classLoader = classLoader ; } protected void setURI ( String uri ) { this . uri = uri ; } private ClassLoader getClassLoader ( ) { if ( classLoader == null ) { classLoader = Antlib . class . getClassLoader ( ) ; } return classLoader ; } public void addTask ( Task nestedTask ) { tasks . add ( nestedTask ) ; } public void execute ( ) { for ( Iterator i = tasks . iterator ( ) ; i . hasNext ( ) ; ) { UnknownElement ue = ( UnknownElement ) i . next ( ) ; setLocation ( ue . getLocation ( ) ) ; ue . maybeConfigure ( ) ; Object configuredObject = ue . getRealThing ( ) ; if ( configuredObject == null ) { continue ; } if ( ! ( configuredObject instanceof AntlibDefinition ) ) { throw new BuildException ( "Invalid task in antlib " + ue . getTag ( ) + " " + configuredObject . getClass ( ) + " does not " + "extend org.apache.tools.ant.taskdefs.AntlibDefinition" ) ; } AntlibDefinition def = ( AntlibDefinition ) configuredObject ; def . setURI ( uri ) ; def . setAntlibClassLoader ( getClassLoader ( ) ) ; def . init ( ) ; def . execute ( ) ; } } } 	1	['7', '3', '0', '10', '46', '9', '1', '9', '4', '0.733333333', '212', '0.6', '0', '0.860465116', '0.285714286', '1', '1', '28.57142857', '4', '2', '1']
package org . apache . tools . ant ; import org . apache . tools . ant . launch . Launcher ; public final class MagicNames { private MagicNames ( ) { } public static final String ANTLIB_PREFIX = "antlib:" ; public static final String ANT_VERSION = "ant.version" ; public static final String BUILD_SYSCLASSPATH = "build.sysclasspath" ; public static final String SCRIPT_REPOSITORY = "org.apache.ant.scriptrepo" ; public static final String SYSTEM_LOADER_REF = "ant.coreLoader" ; public static final String REPOSITORY_DIR_PROPERTY = "ant.maven.repository.dir" ; public static final String REPOSITORY_URL_PROPERTY = "ant.maven.repository.url" ; public static final String TASKDEF_PROPERTIES_RESOURCE = "/org/apache/tools/ant/taskdefs/defaults.properties" ; public static final String TYPEDEFS_PROPERTIES_RESOURCE = "/org/apache/tools/ant/types/defaults.properties" ; public static final String ANT_EXECUTOR_REFERENCE = "ant.executor" ; public static final String ANT_EXECUTOR_CLASSNAME = "ant.executor.class" ; public static final String PROJECT_BASEDIR = "basedir" ; public static final String ANT_FILE = "ant.file" ; public static final String ANT_JAVA_VERSION = "ant.java.version" ; public static final String ANT_HOME = Launcher . ANTHOME_PROPERTY ; public static final String ANT_LIB = "ant.core.lib" ; public static final String REGEXP_IMPL = "ant.regexp.regexpimpl" ; public static final String BUILD_JAVAC_SOURCE = "ant.build.javac.source" ; public static final String BUILD_JAVAC_TARGET = "ant.build.javac.target" ; public static final String REFID_CLASSPATH_REUSE_LOADER = "ant.reuse.loader" ; public static final String REFID_CLASSPATH_LOADER_PREFIX = "ant.loader." ; public static final String REFID_PROPERTY_HELPER = "ant.PropertyHelper" ; } 	1	['1', '1', '0', '0', '2', '0', '0', '0', '0', '2', '26', '0', '0', '0', '1', '0', '0', '3', '0', '0', '2']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . MagicNames ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . types . Path ; import java . io . File ; public class Classloader extends Task { public static final String SYSTEM_LOADER_REF = MagicNames . SYSTEM_LOADER_REF ; private String name = null ; private Path classpath ; private boolean reset = false ; private boolean parentFirst = true ; private String parentName = null ; public Classloader ( ) { } public void setName ( String name ) { this . name = name ; } public void setReset ( boolean b ) { this . reset = b ; } public void setReverse ( boolean b ) { this . parentFirst = ! b ; } public void setParentFirst ( boolean b ) { this . parentFirst = b ; } public void setParentName ( String name ) { this . parentName = name ; } public void setClasspathRef ( Reference pathRef ) throws BuildException { classpath = ( Path ) pathRef . getReferencedObject ( getProject ( ) ) ; } public void setClasspath ( Path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( null ) ; } return this . classpath . createPath ( ) ; } public void execute ( ) { try { if ( "only" . equals ( getProject ( ) . getProperty ( "build.sysclasspath" ) ) && ( name == null || SYSTEM_LOADER_REF . equals ( name ) ) ) { log ( "Changing the system loader is disabled " + "by build.sysclasspath=only" , Project . MSG_WARN ) ; return ; } String loaderName = ( name == null ) ? SYSTEM_LOADER_REF : name ; Object obj = getProject ( ) . getReference ( loaderName ) ; if ( reset ) { obj = null ; } if ( obj != null && ! ( obj instanceof AntClassLoader ) ) { log ( "Referenced object is not an AntClassLoader" , Project . MSG_ERR ) ; return ; } AntClassLoader acl = ( AntClassLoader ) obj ; if ( acl == null ) { Object parent = null ; if ( parentName != null ) { parent = getProject ( ) . getReference ( parentName ) ; if ( ! ( parent instanceof ClassLoader ) ) { parent = null ; } } if ( parent == null ) { parent = this . getClass ( ) . getClassLoader ( ) ; } if ( name == null ) { } getProject ( ) . log ( "Setting parent loader " + name + " " + parent + " " + parentFirst , Project . MSG_DEBUG ) ; acl = new AntClassLoader ( ( ClassLoader ) parent , getProject ( ) , classpath , parentFirst ) ; getProject ( ) . addReference ( loaderName , acl ) ; if ( name == null ) { acl . addLoaderPackageRoot ( "org.apache.tools.ant.taskdefs.optional" ) ; getProject ( ) . setCoreLoader ( acl ) ; } } if ( classpath != null ) { String [ ] list = classpath . list ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { File f = new File ( list [ i ] ) ; if ( f . exists ( ) ) { acl . addPathElement ( f . getAbsolutePath ( ) ) ; log ( "Adding to class loader " + acl + " " + f . getAbsolutePath ( ) , Project . MSG_DEBUG ) ; } } } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } } 	1	['10', '3', '0', '6', '38', '9', '0', '6', '10', '0.796296296', '260', '0.833333333', '1', '0.804347826', '0.34', '3', '3', '24.4', '16', '2.7', '3']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedOutputStream ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . Enumeration ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Vector ; import java . util . zip . GZIPOutputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . ArchiveFileSet ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . ArchiveResource ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . selectors . SelectorUtils ; import org . apache . tools . ant . types . resources . TarResource ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . MergingMapper ; import org . apache . tools . ant . util . SourceFileScanner ; import org . apache . tools . bzip2 . CBZip2OutputStream ; import org . apache . tools . tar . TarConstants ; import org . apache . tools . tar . TarEntry ; import org . apache . tools . tar . TarOutputStream ; public class Tar extends MatchingTask { public static final String WARN = "warn" ; public static final String FAIL = "fail" ; public static final String TRUNCATE = "truncate" ; public static final String GNU = "gnu" ; public static final String OMIT = "omit" ; File tarFile ; File baseDir ; private TarLongFileMode longFileMode = new TarLongFileMode ( ) ; Vector filesets = new Vector ( ) ; private Vector resourceCollections = new Vector ( ) ; Vector fileSetFiles = new Vector ( ) ; private boolean longWarningGiven = false ; private TarCompressionMethod compression = new TarCompressionMethod ( ) ; public TarFileSet createTarFileSet ( ) { TarFileSet fs = new TarFileSet ( ) ; fs . setProject ( getProject ( ) ) ; filesets . addElement ( fs ) ; return fs ; } public void add ( ResourceCollection res ) { resourceCollections . add ( res ) ; } public void setTarfile ( File tarFile ) { this . tarFile = tarFile ; } public void setDestFile ( File destFile ) { this . tarFile = destFile ; } public void setBasedir ( File baseDir ) { this . baseDir = baseDir ; } public void setLongfile ( String mode ) { log ( "DEPRECATED - The setLongfile(String) method has been deprecated." + " Use setLongfile(Tar.TarLongFileMode) instead." ) ; this . longFileMode = new TarLongFileMode ( ) ; longFileMode . setValue ( mode ) ; } public void setLongfile ( TarLongFileMode mode ) { this . longFileMode = mode ; } public void setCompression ( TarCompressionMethod mode ) { this . compression = mode ; } public void execute ( ) throws BuildException { if ( tarFile == null ) { throw new BuildException ( "tarfile attribute must be set!" , getLocation ( ) ) ; } if ( tarFile . exists ( ) && tarFile . isDirectory ( ) ) { throw new BuildException ( "tarfile is a directory!" , getLocation ( ) ) ; } if ( tarFile . exists ( ) && ! tarFile . canWrite ( ) ) { throw new BuildException ( "Can not write to the specified tarfile!" , getLocation ( ) ) ; } Vector savedFileSets = ( Vector ) filesets . clone ( ) ; try { if ( baseDir != null ) { if ( ! baseDir . exists ( ) ) { throw new BuildException ( "basedir does not exist!" , getLocation ( ) ) ; } TarFileSet mainFileSet = new TarFileSet ( fileset ) ; mainFileSet . setDir ( baseDir ) ; filesets . addElement ( mainFileSet ) ; } if ( filesets . size ( ) == 0 && resourceCollections . size ( ) == 0 ) { throw new BuildException ( "You must supply either a basedir " + "attribute or some nested resource" + " collections." , getLocation ( ) ) ; } boolean upToDate = true ; for ( Enumeration e = filesets . elements ( ) ; e . hasMoreElements ( ) ; ) { upToDate &= check ( ( TarFileSet ) e . nextElement ( ) ) ; } for ( Enumeration e = resourceCollections . elements ( ) ; e . hasMoreElements ( ) ; ) { upToDate &= check ( ( ResourceCollection ) e . nextElement ( ) ) ; } if ( upToDate ) { log ( "Nothing to do: " + tarFile . getAbsolutePath ( ) + " is up to date." , Project . MSG_INFO ) ; return ; } log ( "Building tar: " + tarFile . getAbsolutePath ( ) , Project . MSG_INFO ) ; TarOutputStream tOut = null ; try { tOut = new TarOutputStream ( compression . compress ( new BufferedOutputStream ( new FileOutputStream ( tarFile ) ) ) ) ; tOut . setDebug ( true ) ; if ( longFileMode . isTruncateMode ( ) ) { tOut . setLongFileMode ( TarOutputStream . LONGFILE_TRUNCATE ) ; } else if ( longFileMode . isFailMode ( ) || longFileMode . isOmitMode ( ) ) { tOut . setLongFileMode ( TarOutputStream . LONGFILE_ERROR ) ; } else { tOut . setLongFileMode ( TarOutputStream . LONGFILE_GNU ) ; } longWarningGiven = false ; for ( Enumeration e = filesets . elements ( ) ; e . hasMoreElements ( ) ; ) { tar ( ( TarFileSet ) e . nextElement ( ) , tOut ) ; } for ( Enumeration e = resourceCollections . elements ( ) ; e . hasMoreElements ( ) ; ) { tar ( ( ResourceCollection ) e . nextElement ( ) , tOut ) ; } } catch ( IOException ioe ) { String msg = "Problem creating TAR: " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } finally { FileUtils . close ( tOut ) ; } } finally { filesets = savedFileSets ; } } protected void tarFile ( File file , TarOutputStream tOut , String vPath , TarFileSet tarFileSet ) throws IOException { if ( file . equals ( tarFile ) ) { return ; } tarResource ( new FileResource ( file ) , tOut , vPath , tarFileSet ) ; } protected void tarResource ( Resource r , TarOutputStream tOut , String vPath , TarFileSet tarFileSet ) throws IOException { if ( ! r . isExists ( ) ) { return ; } if ( tarFileSet != null ) { String fullpath = tarFileSet . getFullpath ( this . getProject ( ) ) ; if ( fullpath . length ( ) > 0 ) { vPath = fullpath ; } else { if ( vPath . length ( ) <= 0 ) { return ; } String prefix = tarFileSet . getPrefix ( this . getProject ( ) ) ; if ( prefix . length ( ) > 0 && ! prefix . endsWith ( "/" ) ) { prefix = prefix + "/" ; } vPath = prefix + vPath ; } if ( vPath . startsWith ( "/" ) && ! tarFileSet . getPreserveLeadingSlashes ( ) ) { int l = vPath . length ( ) ; if ( l <= 1 ) { return ; } vPath = vPath . substring ( 1 , l ) ; } } if ( r . isDirectory ( ) && ! vPath . endsWith ( "/" ) ) { vPath += "/" ; } if ( vPath . length ( ) >= TarConstants . NAMELEN ) { if ( longFileMode . isOmitMode ( ) ) { log ( "Omitting: " + vPath , Project . MSG_INFO ) ; return ; } else if ( longFileMode . isWarnMode ( ) ) { log ( "Entry: " + vPath + " longer than " + TarConstants . NAMELEN + " characters." , Project . MSG_WARN ) ; if ( ! longWarningGiven ) { log ( "Resulting tar file can only be processed " + "successfully by GNU compatible tar commands" , Project . MSG_WARN ) ; longWarningGiven = true ; } } else if ( longFileMode . isFailMode ( ) ) { throw new BuildException ( "Entry: " + vPath + " longer than " + TarConstants . NAMELEN + "characters." , getLocation ( ) ) ; } } TarEntry te = new TarEntry ( vPath ) ; te . setModTime ( r . getLastModified ( ) ) ; if ( r instanceof ArchiveResource ) { ArchiveResource ar = ( ArchiveResource ) r ; te . setMode ( ar . getMode ( ) ) ; if ( r instanceof TarResource ) { TarResource tr = ( TarResource ) r ; te . setUserName ( tr . getUserName ( ) ) ; te . setUserId ( tr . getUid ( ) ) ; te . setGroupName ( tr . getGroup ( ) ) ; te . setGroupId ( tr . getGid ( ) ) ; } } if ( ! r . isDirectory ( ) ) { if ( r . size ( ) > TarConstants . MAXSIZE ) { throw new BuildException ( "Resource: " + r + " larger than " + TarConstants . MAXSIZE + " bytes." ) ; } te . setSize ( r . getSize ( ) ) ; if ( tarFileSet != null && tarFileSet . hasFileModeBeenSet ( ) ) { te . setMode ( tarFileSet . getMode ( ) ) ; } } else if ( tarFileSet != null && tarFileSet . hasDirModeBeenSet ( ) ) { te . setMode ( tarFileSet . getDirMode ( this . getProject ( ) ) ) ; } if ( tarFileSet != null ) { if ( tarFileSet . hasUserNameBeenSet ( ) ) { te . setUserName ( tarFileSet . getUserName ( ) ) ; } if ( tarFileSet . hasGroupBeenSet ( ) ) { te . setGroupName ( tarFileSet . getGroup ( ) ) ; } if ( tarFileSet . hasUserIdBeenSet ( ) ) { te . setUserId ( tarFileSet . getUid ( ) ) ; } if ( tarFileSet . hasGroupIdBeenSet ( ) ) { te . setGroupId ( tarFileSet . getGid ( ) ) ; } } InputStream in = null ; try { tOut . putNextEntry ( te ) ; if ( ! r . isDirectory ( ) ) { in = r . getInputStream ( ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { tOut . write ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } tOut . closeEntry ( ) ; } finally { FileUtils . close ( in ) ; } } protected boolean archiveIsUpToDate ( String [ ] files ) { return archiveIsUpToDate ( files , baseDir ) ; } protected boolean archiveIsUpToDate ( String [ ] files , File dir ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; MergingMapper mm = new MergingMapper ( ) ; mm . setTo ( tarFile . getAbsolutePath ( ) ) ; return sfs . restrict ( files , dir , null , mm ) . length == 0 ; } protected boolean archiveIsUpToDate ( Resource r ) { return SelectorUtils . isOutOfDate ( new FileResource ( tarFile ) , r , FileUtils . getFileUtils ( ) . getFileTimestampGranularity ( ) ) ; } protected boolean supportsNonFileResources ( ) { return getClass ( ) . equals ( Tar . class ) ; } protected boolean check ( ResourceCollection rc ) { boolean upToDate = true ; if ( isFileFileSet ( rc ) ) { FileSet fs = ( FileSet ) rc ; upToDate = check ( fs . getDir ( getProject ( ) ) , getFileNames ( fs ) ) ; } else if ( ! rc . isFilesystemOnly ( ) && ! supportsNonFileResources ( ) ) { throw new BuildException ( "only filesystem resources are supported" ) ; } else if ( rc . isFilesystemOnly ( ) ) { HashSet basedirs = new HashSet ( ) ; HashMap basedirToFilesMap = new HashMap ( ) ; Iterator iter = rc . iterator ( ) ; while ( iter . hasNext ( ) ) { FileResource r = ( FileResource ) iter . next ( ) ; File base = r . getBaseDir ( ) ; if ( base == null ) { base = Copy . NULL_FILE_PLACEHOLDER ; } basedirs . add ( base ) ; Vector files = ( Vector ) basedirToFilesMap . get ( base ) ; if ( files == null ) { files = new Vector ( ) ; basedirToFilesMap . put ( base , new Vector ( ) ) ; } files . add ( r . getName ( ) ) ; } iter = basedirs . iterator ( ) ; while ( iter . hasNext ( ) ) { File base = ( File ) iter . next ( ) ; Vector f = ( Vector ) basedirToFilesMap . get ( base ) ; String [ ] files = ( String [ ] ) f . toArray ( new String [ f . size ( ) ] ) ; upToDate &= check ( base == Copy . NULL_FILE_PLACEHOLDER ? null : base , files ) ; } } else { Iterator iter = rc . iterator ( ) ; while ( upToDate && iter . hasNext ( ) ) { Resource r = ( Resource ) iter . next ( ) ; upToDate &= archiveIsUpToDate ( r ) ; } } return upToDate ; } protected boolean check ( File basedir , String [ ] files ) { boolean upToDate = true ; if ( ! archiveIsUpToDate ( files , basedir ) ) { upToDate = false ; } for ( int i = 0 ; i < files . length ; ++ i ) { if ( tarFile . equals ( new File ( basedir , files [ i ] ) ) ) { throw new BuildException ( "A tar file cannot include " + "itself" , getLocation ( ) ) ; } } return upToDate ; } protected void tar ( ResourceCollection rc , TarOutputStream tOut ) throws IOException { ArchiveFileSet afs = null ; if ( rc instanceof ArchiveFileSet ) { afs = ( ArchiveFileSet ) rc ; } if ( afs != null && afs . size ( ) > 1 && afs . getFullpath ( this . getProject ( ) ) . length ( ) > 0 ) { throw new BuildException ( "fullpath attribute may only " + "be specified for " + "filesets that specify a " + "single file." ) ; } TarFileSet tfs = asTarFileSet ( afs ) ; if ( isFileFileSet ( rc ) ) { FileSet fs = ( FileSet ) rc ; String [ ] files = getFileNames ( fs ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File f = new File ( fs . getDir ( getProject ( ) ) , files [ i ] ) ; String name = files [ i ] . replace ( File . separatorChar , '/' ) ; tarFile ( f , tOut , name , tfs ) ; } } else if ( rc . isFilesystemOnly ( ) ) { Iterator iter = rc . iterator ( ) ; while ( iter . hasNext ( ) ) { FileResource r = ( FileResource ) iter . next ( ) ; File f = r . getFile ( ) ; if ( f == null ) { f = new File ( r . getBaseDir ( ) , r . getName ( ) ) ; } tarFile ( f , tOut , f . getName ( ) , tfs ) ; } } else { Iterator iter = rc . iterator ( ) ; while ( iter . hasNext ( ) ) { Resource r = ( Resource ) iter . next ( ) ; tarResource ( r , tOut , r . getName ( ) , tfs ) ; } } } protected static final boolean isFileFileSet ( ResourceCollection rc ) { return rc instanceof FileSet && rc . isFilesystemOnly ( ) ; } protected static final String [ ] getFileNames ( FileSet fs ) { DirectoryScanner ds = fs . getDirectoryScanner ( fs . getProject ( ) ) ; String [ ] directories = ds . getIncludedDirectories ( ) ; String [ ] filesPerSe = ds . getIncludedFiles ( ) ; String [ ] files = new String [ directories . length + filesPerSe . length ] ; System . arraycopy ( directories , 0 , files , 0 , directories . length ) ; System . arraycopy ( filesPerSe , 0 , files , directories . length , filesPerSe . length ) ; return files ; } protected TarFileSet asTarFileSet ( ArchiveFileSet archiveFileSet ) { TarFileSet tfs = null ; if ( archiveFileSet != null && archiveFileSet instanceof TarFileSet ) { tfs = ( TarFileSet ) archiveFileSet ; } else { tfs = new TarFileSet ( ) ; tfs . setProject ( getProject ( ) ) ; if ( archiveFileSet != null ) { tfs . setPrefix ( archiveFileSet . getPrefix ( getProject ( ) ) ) ; tfs . setFullpath ( archiveFileSet . getFullpath ( getProject ( ) ) ) ; if ( archiveFileSet . hasFileModeBeenSet ( ) ) { tfs . integerSetFileMode ( archiveFileSet . getFileMode ( getProject ( ) ) ) ; } if ( archiveFileSet . hasDirModeBeenSet ( ) ) { tfs . integerSetDirMode ( archiveFileSet . getDirMode ( getProject ( ) ) ) ; } if ( archiveFileSet instanceof org . apache . tools . ant . types . TarFileSet ) { org . apache . tools . ant . types . TarFileSet t = ( org . apache . tools . ant . types . TarFileSet ) archiveFileSet ; if ( t . hasUserNameBeenSet ( ) ) { tfs . setUserName ( t . getUserName ( ) ) ; } if ( t . hasGroupBeenSet ( ) ) { tfs . setGroup ( t . getGroup ( ) ) ; } if ( t . hasUserIdBeenSet ( ) ) { tfs . setUid ( t . getUid ( ) ) ; } if ( t . hasGroupIdBeenSet ( ) ) { tfs . setGid ( t . getGid ( ) ) ; } } } } return tfs ; } public static class TarFileSet extends org . apache . tools . ant . types . TarFileSet { private String [ ] files = null ; private boolean preserveLeadingSlashes = false ; public TarFileSet ( FileSet fileset ) { super ( fileset ) ; } public TarFileSet ( ) { super ( ) ; } public String [ ] getFiles ( Project p ) { if ( files == null ) { files = getFileNames ( this ) ; } return files ; } public void setMode ( String octalString ) { setFileMode ( octalString ) ; } public int getMode ( ) { return getFileMode ( this . getProject ( ) ) ; } public void setPreserveLeadingSlashes ( boolean b ) { this . preserveLeadingSlashes = b ; } public boolean getPreserveLeadingSlashes ( ) { return preserveLeadingSlashes ; } } public static class TarLongFileMode extends EnumeratedAttribute { public static final String WARN = "warn" , FAIL = "fail" , TRUNCATE = "truncate" , GNU = "gnu" , OMIT = "omit" ; private final String [ ] validModes = { WARN , FAIL , TRUNCATE , GNU , OMIT } ; public TarLongFileMode ( ) { super ( ) ; setValue ( WARN ) ; } public String [ ] getValues ( ) { return validModes ; } public boolean isTruncateMode ( ) { return TRUNCATE . equalsIgnoreCase ( getValue ( ) ) ; } public boolean isWarnMode ( ) { return WARN . equalsIgnoreCase ( getValue ( ) ) ; } public boolean isGnuMode ( ) { return GNU . equalsIgnoreCase ( getValue ( ) ) ; } public boolean isFailMode ( ) { return FAIL . equalsIgnoreCase ( getValue ( ) ) ; } public boolean isOmitMode ( ) { return OMIT . equalsIgnoreCase ( getValue ( ) ) ; } } public static final class TarCompressionMethod extends EnumeratedAttribute { private static final String NONE = "none" ; private static final String GZIP = "gzip" ; private static final String BZIP2 = "bzip2" ; public TarCompressionMethod ( ) { super ( ) ; setValue ( NONE ) ; } public String [ ] getValues ( ) { return new String [ ] { NONE , GZIP , BZIP2 } ; } private OutputStream compress ( final OutputStream ostream ) throws IOException { final String v = getValue ( ) ; if ( GZIP . equals ( v ) ) { return new GZIPOutputStream ( ostream ) ; } else { if ( BZIP2 . equals ( v ) ) { ostream . write ( 'B' ) ; ostream . write ( 'Z' ) ; return new CBZip2OutputStream ( ostream ) ; } } return ostream ; } } } 	1	['22', '4', '0', '25', '172', '151', '1', '25', '10', '0.921768707', '1224', '0.285714286', '2', '0.787878788', '0.178030303', '1', '1', '54', '12', '2.2273', '4']
package org . apache . tools . ant . taskdefs . rmic ; import java . lang . reflect . Method ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; public class WLRmic extends DefaultRmicAdapter { public static final String WLRMIC_CLASSNAME = "weblogic.rmic" ; public static final String COMPILER_NAME = "weblogic" ; public static final String ERROR_NO_WLRMIC_ON_CLASSPATH = "Cannot use WebLogic rmic, as it is not " + "available.  A common solution is to " + "set the environment variable " + "CLASSPATH." ; public static final String ERROR_WLRMIC_FAILED = "Error starting WebLogic rmic: " ; public static final String WL_RMI_STUB_SUFFIX = "_WLStub" ; public static final String WL_RMI_SKEL_SUFFIX = "_WLSkel" ; public boolean execute ( ) throws BuildException { getRmic ( ) . log ( "Using WebLogic rmic" , Project . MSG_VERBOSE ) ; Commandline cmd = setupRmicCommand ( new String [ ] { "-noexit" } ) ; AntClassLoader loader = null ; try { Class c = null ; if ( getRmic ( ) . getClasspath ( ) == null ) { c = Class . forName ( WLRMIC_CLASSNAME ) ; } else { loader = getRmic ( ) . getProject ( ) . createClassLoader ( getRmic ( ) . getClasspath ( ) ) ; c = Class . forName ( WLRMIC_CLASSNAME , true , loader ) ; } Method doRmic = c . getMethod ( "main" , new Class [ ] { String [ ] . class } ) ; doRmic . invoke ( null , new Object [ ] { cmd . getArguments ( ) } ) ; return true ; } catch ( ClassNotFoundException ex ) { throw new BuildException ( ERROR_NO_WLRMIC_ON_CLASSPATH , getRmic ( ) . getLocation ( ) ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( ERROR_WLRMIC_FAILED , ex , getRmic ( ) . getLocation ( ) ) ; } } finally { if ( loader != null ) { loader . cleanup ( ) ; } } } public String getStubClassSuffix ( ) { return WL_RMI_STUB_SUFFIX ; } public String getSkelClassSuffix ( ) { return WL_RMI_SKEL_SUFFIX ; } } 	1	['4', '2', '0', '9', '22', '6', '1', '8', '4', '1.285714286', '130', '0', '0', '0.8125', '1', '0', '0', '29.75', '1', '0.75', '2']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Iterator ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . IsSigned ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . IdentityMapper ; import org . apache . tools . ant . util . FileNameMapper ; public class SignJar extends AbstractJarSignerTask { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; protected String sigfile ; protected File signedjar ; protected boolean internalsf ; protected boolean sectionsonly ; private boolean preserveLastModified ; protected boolean lazy ; protected File destDir ; private FileNameMapper mapper ; protected String tsaurl ; protected String tsacert ; public static final String ERROR_TODIR_AND_SIGNEDJAR = "'destdir' and 'signedjar' cannot both be set" ; public static final String ERROR_TOO_MANY_MAPPERS = "Too many mappers" ; public static final String ERROR_SIGNEDJAR_AND_PATHS = "You cannot specify the signed JAR when using paths or filesets" ; public static final String ERROR_BAD_MAP = "Cannot map source file to anything sensible: " ; public static final String ERROR_MAPPER_WITHOUT_DEST = "The destDir attribute is required if a mapper is set" ; public static final String ERROR_NO_ALIAS = "alias attribute must be set" ; public static final String ERROR_NO_STOREPASS = "storepass attribute must be set" ; public void setSigfile ( final String sigfile ) { this . sigfile = sigfile ; } public void setSignedjar ( final File signedjar ) { this . signedjar = signedjar ; } public void setInternalsf ( final boolean internalsf ) { this . internalsf = internalsf ; } public void setSectionsonly ( final boolean sectionsonly ) { this . sectionsonly = sectionsonly ; } public void setLazy ( final boolean lazy ) { this . lazy = lazy ; } public void setDestDir ( File destDir ) { this . destDir = destDir ; } public void add ( FileNameMapper newMapper ) { if ( mapper != null ) { throw new BuildException ( ERROR_TOO_MANY_MAPPERS ) ; } mapper = newMapper ; } public FileNameMapper getMapper ( ) { return mapper ; } public String getTsaurl ( ) { return tsaurl ; } public void setTsaurl ( String tsaurl ) { this . tsaurl = tsaurl ; } public String getTsacert ( ) { return tsacert ; } public void setTsacert ( String tsacert ) { this . tsacert = tsacert ; } public void execute ( ) throws BuildException { final boolean hasJar = jar != null ; final boolean hasSignedJar = signedjar != null ; final boolean hasDestDir = destDir != null ; final boolean hasMapper = mapper != null ; if ( ! hasJar && ! hasResources ( ) ) { throw new BuildException ( ERROR_NO_SOURCE ) ; } if ( null == alias ) { throw new BuildException ( ERROR_NO_ALIAS ) ; } if ( null == storepass ) { throw new BuildException ( ERROR_NO_STOREPASS ) ; } if ( hasDestDir && hasSignedJar ) { throw new BuildException ( ERROR_TODIR_AND_SIGNEDJAR ) ; } if ( hasResources ( ) && hasSignedJar ) { throw new BuildException ( ERROR_SIGNEDJAR_AND_PATHS ) ; } if ( ! hasDestDir && hasMapper ) { throw new BuildException ( ERROR_MAPPER_WITHOUT_DEST ) ; } beginExecution ( ) ; try { if ( hasJar && hasSignedJar ) { signOneJar ( jar , signedjar ) ; return ; } Path sources = createUnifiedSourcePath ( ) ; FileNameMapper destMapper ; if ( hasMapper ) { destMapper = mapper ; } else { destMapper = new IdentityMapper ( ) ; } Iterator iter = sources . iterator ( ) ; while ( iter . hasNext ( ) ) { FileResource fr = ( FileResource ) iter . next ( ) ; File toDir = hasDestDir ? destDir : fr . getBaseDir ( ) ; String [ ] destFilenames = destMapper . mapFileName ( fr . getName ( ) ) ; if ( destFilenames == null || destFilenames . length != 1 ) { throw new BuildException ( ERROR_BAD_MAP + fr . getFile ( ) ) ; } File destFile = new File ( toDir , destFilenames [ 0 ] ) ; signOneJar ( fr . getFile ( ) , destFile ) ; } } finally { endExecution ( ) ; } } private void signOneJar ( File jarSource , File jarTarget ) throws BuildException { File targetFile = jarTarget ; if ( targetFile == null ) { targetFile = jarSource ; } if ( isUpToDate ( jarSource , targetFile ) ) { return ; } long lastModified = jarSource . lastModified ( ) ; final ExecTask cmd = createJarSigner ( ) ; setCommonOptions ( cmd ) ; bindToKeystore ( cmd ) ; if ( null != sigfile ) { addValue ( cmd , "-sigfile" ) ; String value = this . sigfile ; addValue ( cmd , value ) ; } if ( null != targetFile && ! jarSource . equals ( targetFile ) ) { addValue ( cmd , "-signedjar" ) ; addValue ( cmd , targetFile . getPath ( ) ) ; } if ( internalsf ) { addValue ( cmd , "-internalsf" ) ; } if ( sectionsonly ) { addValue ( cmd , "-sectionsonly" ) ; } addTimestampAuthorityCommands ( cmd ) ; addValue ( cmd , jarSource . getPath ( ) ) ; addValue ( cmd , alias ) ; log ( "Signing JAR: " + jarSource . getAbsolutePath ( ) + " to " + targetFile . getAbsolutePath ( ) + " as " + alias ) ; cmd . execute ( ) ; if ( preserveLastModified ) { targetFile . setLastModified ( lastModified ) ; } } private void addTimestampAuthorityCommands ( final ExecTask cmd ) { if ( tsaurl != null ) { addValue ( cmd , "-tsa" ) ; addValue ( cmd , tsaurl ) ; } if ( tsacert != null ) { addValue ( cmd , "-tsacert" ) ; addValue ( cmd , tsacert ) ; } } protected boolean isUpToDate ( File jarFile , File signedjarFile ) { if ( null == jarFile || ! jarFile . exists ( ) ) { return false ; } File destFile = signedjarFile ; if ( destFile == null ) { destFile = jarFile ; } if ( jarFile . equals ( destFile ) ) { if ( lazy ) { return isSigned ( jarFile ) ; } return false ; } return FILE_UTILS . isUpToDate ( jarFile , destFile ) ; } protected boolean isSigned ( File file ) { try { return IsSigned . isSigned ( file , alias ) ; } catch ( IOException e ) { log ( e . toString ( ) , Project . MSG_VERBOSE ) ; return false ; } } public void setPreserveLastModified ( boolean preserveLastModified ) { this . preserveLastModified = preserveLastModified ; } } 	1	['20', '4', '0', '9', '56', '150', '0', '9', '15', '0.956140351', '455', '0.611111111', '2', '0.769230769', '0.289473684', '0', '0', '20.85', '6', '1.3', '2']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import java . util . Map ; import java . util . HashMap ; import java . util . Enumeration ; import java . util . Locale ; import java . util . NoSuchElementException ; import java . util . Properties ; import org . apache . tools . ant . AntTypeDefinition ; import org . apache . tools . ant . ComponentHelper ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . MagicNames ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . types . EnumeratedAttribute ; public abstract class Definer extends DefBase { private static final String ANTLIB_XML = "/antlib.xml" ; private static class ResourceStack extends ThreadLocal { public Object initialValue ( ) { return new HashMap ( ) ; } Map getStack ( ) { return ( Map ) get ( ) ; } } private static ResourceStack resourceStack = new ResourceStack ( ) ; private String name ; private String classname ; private File file ; private String resource ; private int format = Format . PROPERTIES ; private boolean definerSet = false ; private int onError = OnError . FAIL ; private String adapter ; private String adaptTo ; private Class adapterClass ; private Class adaptToClass ; public static class OnError extends EnumeratedAttribute { public static final int FAIL = 0 , REPORT = 1 , IGNORE = 2 , FAIL_ALL = 3 ; public static final String POLICY_FAIL = "fail" ; public static final String POLICY_REPORT = "report" ; public static final String POLICY_IGNORE = "ignore" ; public static final String POLICY_FAILALL = "failall" ; public OnError ( ) { super ( ) ; } public OnError ( String value ) { setValue ( value ) ; } public String [ ] getValues ( ) { return new String [ ] { POLICY_FAIL , POLICY_REPORT , POLICY_IGNORE , POLICY_FAILALL } ; } } public static class Format extends EnumeratedAttribute { public static final int PROPERTIES = 0 , XML = 1 ; public String [ ] getValues ( ) { return new String [ ] { "properties" , "xml" } ; } } public void setOnError ( OnError onError ) { this . onError = onError . getIndex ( ) ; } public void setFormat ( Format format ) { this . format = format . getIndex ( ) ; } public String getName ( ) { return name ; } public File getFile ( ) { return file ; } public String getResource ( ) { return resource ; } public void execute ( ) throws BuildException { ClassLoader al = createLoader ( ) ; if ( ! definerSet ) { if ( getURI ( ) == null ) { throw new BuildException ( "name, file or resource attribute of " + getTaskName ( ) + " is undefined" , getLocation ( ) ) ; } if ( getURI ( ) . startsWith ( MagicNames . ANTLIB_PREFIX ) ) { String uri1 = getURI ( ) ; setResource ( makeResourceFromURI ( uri1 ) ) ; } else { throw new BuildException ( "Only antlib URIs can be located from the URI alone," + "not the URI " + getURI ( ) ) ; } } if ( name != null ) { if ( classname == null ) { throw new BuildException ( "classname attribute of " + getTaskName ( ) + " element " + "is undefined" , getLocation ( ) ) ; } addDefinition ( al , name , classname ) ; } else { if ( classname != null ) { String msg = "You must not specify classname " + "together with file or resource." ; throw new BuildException ( msg , getLocation ( ) ) ; } Enumeration urls = null ; if ( file != null ) { final URL url = fileToURL ( ) ; if ( url == null ) { return ; } urls = new Enumeration ( ) { private boolean more = true ; public boolean hasMoreElements ( ) { return more ; } public Object nextElement ( ) throws NoSuchElementException { if ( more ) { more = false ; return url ; } else { throw new NoSuchElementException ( ) ; } } } ; } else { urls = resourceToURLs ( al ) ; } while ( urls . hasMoreElements ( ) ) { URL url = ( URL ) urls . nextElement ( ) ; int fmt = this . format ; if ( url . toString ( ) . toLowerCase ( Locale . US ) . endsWith ( ".xml" ) ) { fmt = Format . XML ; } if ( fmt == Format . PROPERTIES ) { loadProperties ( al , url ) ; break ; } else { if ( resourceStack . getStack ( ) . get ( url ) != null ) { log ( "Warning: Recursive loading of " + url + " ignored" + " at " + getLocation ( ) + " originally loaded at " + resourceStack . getStack ( ) . get ( url ) , Project . MSG_WARN ) ; } else { try { resourceStack . getStack ( ) . put ( url , getLocation ( ) ) ; loadAntlib ( al , url ) ; } finally { resourceStack . getStack ( ) . remove ( url ) ; } } } } } } public static String makeResourceFromURI ( String uri ) { String path = uri . substring ( MagicNames . ANTLIB_PREFIX . length ( ) ) ; String resource ; if ( path . startsWith ( "//" ) ) { resource = path . substring ( "//" . length ( ) ) ; if ( ! resource . endsWith ( ".xml" ) ) { resource = resource + ANTLIB_XML ; } } else { resource = path . replace ( '.' , '/' ) + ANTLIB_XML ; } return resource ; } private URL fileToURL ( ) { String message = null ; if ( ! ( file . exists ( ) ) ) { message = "File " + file + " does not exist" ; } if ( message == null && ! ( file . isFile ( ) ) ) { message = "File " + file + " is not a file" ; } try { if ( message == null ) { return file . toURL ( ) ; } } catch ( Exception ex ) { message = "File " + file + " cannot use as URL: " + ex . toString ( ) ; } switch ( onError ) { case OnError . FAIL_ALL : throw new BuildException ( message ) ; case OnError . FAIL : case OnError . REPORT : log ( message , Project . MSG_WARN ) ; break ; case OnError . IGNORE : log ( message , Project . MSG_VERBOSE ) ; break ; default : break ; } return null ; } private Enumeration resourceToURLs ( ClassLoader classLoader ) { Enumeration ret ; try { ret = classLoader . getResources ( resource ) ; } catch ( IOException e ) { throw new BuildException ( "Could not fetch resources named " + resource , e , getLocation ( ) ) ; } if ( ! ret . hasMoreElements ( ) ) { String message = "Could not load definitions from resource " + resource + ". It could not be found." ; switch ( onError ) { case OnError . FAIL_ALL : throw new BuildException ( message ) ; case OnError . FAIL : case OnError . REPORT : log ( message , Project . MSG_WARN ) ; break ; case OnError . IGNORE : log ( message , Project . MSG_VERBOSE ) ; break ; default : break ; } } return ret ; } protected void loadProperties ( ClassLoader al , URL url ) { InputStream is = null ; try { is = url . openStream ( ) ; if ( is == null ) { log ( "Could not load definitions from " + url , Project . MSG_WARN ) ; return ; } Properties props = new Properties ( ) ; props . load ( is ) ; Enumeration keys = props . keys ( ) ; while ( keys . hasMoreElements ( ) ) { name = ( ( String ) keys . nextElement ( ) ) ; classname = props . getProperty ( name ) ; addDefinition ( al , name , classname ) ; } } catch ( IOException ex ) { throw new BuildException ( ex , getLocation ( ) ) ; } finally { FileUtils . close ( is ) ; } } private void loadAntlib ( ClassLoader classLoader , URL url ) { try { Antlib antlib = Antlib . createAntlib ( getProject ( ) , url , getURI ( ) ) ; antlib . setClassLoader ( classLoader ) ; antlib . setURI ( getURI ( ) ) ; antlib . execute ( ) ; } catch ( BuildException ex ) { throw ProjectHelper . addLocationToBuildException ( ex , getLocation ( ) ) ; } } public void setFile ( File file ) { if ( definerSet ) { tooManyDefinitions ( ) ; } definerSet = true ; this . file = file ; } public void setResource ( String res ) { if ( definerSet ) { tooManyDefinitions ( ) ; } definerSet = true ; this . resource = res ; } public void setAntlib ( String antlib ) { if ( definerSet ) { tooManyDefinitions ( ) ; } if ( ! antlib . startsWith ( "antlib:" ) ) { throw new BuildException ( "Invalid antlib attribute - it must start with antlib:" ) ; } setURI ( antlib ) ; this . resource = antlib . substring ( "antlib:" . length ( ) ) . replace ( '.' , '/' ) + "/antlib.xml" ; definerSet = true ; } public void setName ( String name ) { if ( definerSet ) { tooManyDefinitions ( ) ; } definerSet = true ; this . name = name ; } public String getClassname ( ) { return classname ; } public void setClassname ( String classname ) { this . classname = classname ; } public void setAdapter ( String adapter ) { this . adapter = adapter ; } protected void setAdapterClass ( Class adapterClass ) { this . adapterClass = adapterClass ; } public void setAdaptTo ( String adaptTo ) { this . adaptTo = adaptTo ; } protected void setAdaptToClass ( Class adaptToClass ) { this . adaptToClass = adaptToClass ; } protected void addDefinition ( ClassLoader al , String name , String classname ) throws BuildException { Class cl = null ; try { try { name = ProjectHelper . genComponentName ( getURI ( ) , name ) ; if ( onError != OnError . IGNORE ) { cl = Class . forName ( classname , true , al ) ; } if ( adapter != null ) { adapterClass = Class . forName ( adapter , true , al ) ; } if ( adaptTo != null ) { adaptToClass = Class . forName ( adaptTo , true , al ) ; } AntTypeDefinition def = new AntTypeDefinition ( ) ; def . setName ( name ) ; def . setClassName ( classname ) ; def . setClass ( cl ) ; def . setAdapterClass ( adapterClass ) ; def . setAdaptToClass ( adaptToClass ) ; def . setClassLoader ( al ) ; if ( cl != null ) { def . checkClass ( getProject ( ) ) ; } ComponentHelper . getComponentHelper ( getProject ( ) ) . addDataTypeDefinition ( def ) ; } catch ( ClassNotFoundException cnfe ) { String msg = getTaskName ( ) + " class " + classname + " cannot be found" ; throw new BuildException ( msg , cnfe , getLocation ( ) ) ; } catch ( NoClassDefFoundError ncdfe ) { String msg = getTaskName ( ) + " A class needed by class " + classname + " cannot be found: " + ncdfe . getMessage ( ) ; throw new BuildException ( msg , ncdfe , getLocation ( ) ) ; } } catch ( BuildException ex ) { switch ( onError ) { case OnError . FAIL_ALL : case OnError . FAIL : throw ex ; case OnError . REPORT : log ( ex . getLocation ( ) + "Warning: " + ex . getMessage ( ) , Project . MSG_WARN ) ; break ; default : log ( ex . getLocation ( ) + ex . getMessage ( ) , Project . MSG_DEBUG ) ; } } } private void tooManyDefinitions ( ) { throw new BuildException ( "Only one of the attributes name, file and resource" + " can be set" , getLocation ( ) ) ; } } 	1	['25', '5', '1', '14', '91', '196', '3', '13', '16', '0.878205128', '800', '1', '1', '0.701298701', '0.21875', '0', '0', '30.48', '6', '1.68', '1']
package org . apache . tools . ant . types . selectors . modifiedselector ; import java . util . Comparator ; import java . util . Vector ; import java . util . Iterator ; import java . io . File ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . IntrospectionHelper ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . BuildListener ; import org . apache . tools . ant . BuildEvent ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . selectors . ResourceSelector ; import org . apache . tools . ant . types . selectors . BaseExtendSelector ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . ResourceUtils ; public class ModifiedSelector extends BaseExtendSelector implements BuildListener , ResourceSelector { private CacheName cacheName = null ; private String cacheClass ; private AlgorithmName algoName = null ; private String algorithmClass ; private ComparatorName compName = null ; private String comparatorClass ; private boolean update = true ; private boolean selectDirectories = true ; private boolean selectResourcesWithoutInputStream = true ; private boolean delayUpdate = true ; private Comparator comparator = null ; private Algorithm algorithm = null ; private Cache cache = null ; private int modified = 0 ; private boolean isConfigured = false ; private Vector configParameter = new Vector ( ) ; private Vector specialParameter = new Vector ( ) ; private ClassLoader myClassLoader = null ; private Path classpath = null ; public ModifiedSelector ( ) { } public void verifySettings ( ) { configure ( ) ; if ( cache == null ) { setError ( "Cache must be set." ) ; } else if ( algorithm == null ) { setError ( "Algorithm must be set." ) ; } else if ( ! cache . isValid ( ) ) { setError ( "Cache must be proper configured." ) ; } else if ( ! algorithm . isValid ( ) ) { setError ( "Algorithm must be proper configured." ) ; } } public void configure ( ) { if ( isConfigured ) { return ; } isConfigured = true ; Project p = getProject ( ) ; String filename = "cache.properties" ; File cachefile = null ; if ( p != null ) { cachefile = new File ( p . getBaseDir ( ) , filename ) ; getProject ( ) . addBuildListener ( this ) ; } else { cachefile = new File ( filename ) ; setDelayUpdate ( false ) ; } Cache defaultCache = new PropertiesfileCache ( cachefile ) ; Algorithm defaultAlgorithm = new DigestAlgorithm ( ) ; Comparator defaultComparator = new EqualComparator ( ) ; update = true ; selectDirectories = true ; for ( Iterator itConfig = configParameter . iterator ( ) ; itConfig . hasNext ( ) ; ) { Parameter par = ( Parameter ) itConfig . next ( ) ; if ( par . getName ( ) . indexOf ( "." ) > 0 ) { specialParameter . add ( par ) ; } else { useParameter ( par ) ; } } configParameter = new Vector ( ) ; if ( algoName != null ) { if ( "hashvalue" . equals ( algoName . getValue ( ) ) ) { algorithm = new HashvalueAlgorithm ( ) ; } else if ( "digest" . equals ( algoName . getValue ( ) ) ) { algorithm = new DigestAlgorithm ( ) ; } else if ( "checksum" . equals ( algoName . getValue ( ) ) ) { algorithm = new ChecksumAlgorithm ( ) ; } } else { if ( algorithmClass != null ) { algorithm = ( Algorithm ) loadClass ( algorithmClass , "is not an Algorithm." , Algorithm . class ) ; } else { algorithm = defaultAlgorithm ; } } if ( cacheName != null ) { if ( "propertyfile" . equals ( cacheName . getValue ( ) ) ) { cache = new PropertiesfileCache ( ) ; } } else { if ( cacheClass != null ) { cache = ( Cache ) loadClass ( cacheClass , "is not a Cache." , Cache . class ) ; } else { cache = defaultCache ; } } if ( compName != null ) { if ( "equal" . equals ( compName . getValue ( ) ) ) { comparator = new EqualComparator ( ) ; } else if ( "rule" . equals ( compName . getValue ( ) ) ) { throw new BuildException ( "RuleBasedCollator not yet supported." ) ; } } else { if ( comparatorClass != null ) { comparator = ( Comparator ) loadClass ( comparatorClass , "is not a Comparator." , Comparator . class ) ; } else { comparator = defaultComparator ; } } for ( Iterator itSpecial = specialParameter . iterator ( ) ; itSpecial . hasNext ( ) ; ) { Parameter par = ( Parameter ) itSpecial . next ( ) ; useParameter ( par ) ; } specialParameter = new Vector ( ) ; } protected Object loadClass ( String classname , String msg , Class type ) { try { ClassLoader cl = getClassLoader ( ) ; Class clazz = null ; if ( cl != null ) { clazz = cl . loadClass ( classname ) ; } else { clazz = Class . forName ( classname ) ; } Object rv = clazz . newInstance ( ) ; if ( ! type . isInstance ( rv ) ) { throw new BuildException ( "Specified class (" + classname + ") " + msg ) ; } return rv ; } catch ( ClassNotFoundException e ) { throw new BuildException ( "Specified class (" + classname + ") not found." ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } public boolean isSelected ( Resource resource ) { if ( resource . isFilesystemOnly ( ) ) { FileResource fileResource = ( FileResource ) resource ; File file = fileResource . getFile ( ) ; String filename = fileResource . getName ( ) ; File basedir = fileResource . getBaseDir ( ) ; return isSelected ( basedir , filename , file ) ; } else { try { FileUtils fu = FileUtils . getFileUtils ( ) ; File tmpFile = fu . createTempFile ( "modified-" , ".tmp" , null ) ; Resource tmpResource = new FileResource ( tmpFile ) ; ResourceUtils . copyResource ( resource , tmpResource ) ; boolean isSelected = isSelected ( tmpFile . getParentFile ( ) , tmpFile . getName ( ) , resource . toLongString ( ) ) ; tmpFile . delete ( ) ; return isSelected ; } catch ( UnsupportedOperationException uoe ) { log ( "The resource '" + resource . getName ( ) + "' does not provide an InputStream, so it is not checked. " + "Akkording to 'selres' attribute value it is " + ( ( selectResourcesWithoutInputStream ) ? "" : " not" ) + "selected." , Project . MSG_INFO ) ; return selectResourcesWithoutInputStream ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } } public boolean isSelected ( File basedir , String filename , File file ) { return isSelected ( basedir , filename , file . getAbsolutePath ( ) ) ; } private boolean isSelected ( File basedir , String filename , String cacheKey ) { validate ( ) ; File f = new File ( basedir , filename ) ; if ( f . isDirectory ( ) ) { return selectDirectories ; } String cachedValue = String . valueOf ( cache . get ( f . getAbsolutePath ( ) ) ) ; String newValue = algorithm . getValue ( f ) ; boolean rv = ( comparator . compare ( cachedValue , newValue ) != 0 ) ; if ( update && rv ) { cache . put ( f . getAbsolutePath ( ) , newValue ) ; setModified ( getModified ( ) + 1 ) ; if ( ! getDelayUpdate ( ) ) { saveCache ( ) ; } } return rv ; } protected void saveCache ( ) { if ( getModified ( ) > 1 ) { cache . save ( ) ; setModified ( 0 ) ; } } public void setAlgorithmClass ( String classname ) { algorithmClass = classname ; } public void setComparatorClass ( String classname ) { comparatorClass = classname ; } public void setCacheClass ( String classname ) { cacheClass = classname ; } public void setUpdate ( boolean update ) { this . update = update ; } public void setSeldirs ( boolean seldirs ) { selectDirectories = seldirs ; } public void setSelres ( boolean newValue ) { this . selectResourcesWithoutInputStream = newValue ; } public int getModified ( ) { return modified ; } public void setModified ( int modified ) { this . modified = modified ; } public boolean getDelayUpdate ( ) { return delayUpdate ; } public void setDelayUpdate ( boolean delayUpdate ) { this . delayUpdate = delayUpdate ; } public void addClasspath ( Path path ) { if ( classpath != null ) { throw new BuildException ( "<classpath> can be set only once." ) ; } classpath = path ; } public ClassLoader getClassLoader ( ) { if ( myClassLoader == null ) { myClassLoader = ( classpath == null ) ? getClass ( ) . getClassLoader ( ) : getProject ( ) . createClassLoader ( classpath ) ; } return myClassLoader ; } public void setClassLoader ( ClassLoader loader ) { myClassLoader = loader ; } public void addParam ( String key , Object value ) { Parameter par = new Parameter ( ) ; par . setName ( key ) ; par . setValue ( String . valueOf ( value ) ) ; configParameter . add ( par ) ; } public void addParam ( Parameter parameter ) { configParameter . add ( parameter ) ; } public void setParameters ( Parameter [ ] parameters ) { if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { configParameter . add ( parameters [ i ] ) ; } } } public void useParameter ( Parameter parameter ) { String key = parameter . getName ( ) ; String value = parameter . getValue ( ) ; if ( "cache" . equals ( key ) ) { CacheName cn = new CacheName ( ) ; cn . setValue ( value ) ; setCache ( cn ) ; } else if ( "algorithm" . equals ( key ) ) { AlgorithmName an = new AlgorithmName ( ) ; an . setValue ( value ) ; setAlgorithm ( an ) ; } else if ( "comparator" . equals ( key ) ) { ComparatorName cn = new ComparatorName ( ) ; cn . setValue ( value ) ; setComparator ( cn ) ; } else if ( "update" . equals ( key ) ) { boolean updateValue = ( "true" . equalsIgnoreCase ( value ) ) ? true : false ; setUpdate ( updateValue ) ; } else if ( "delayupdate" . equals ( key ) ) { boolean updateValue = ( "true" . equalsIgnoreCase ( value ) ) ? true : false ; setDelayUpdate ( updateValue ) ; } else if ( "seldirs" . equals ( key ) ) { boolean sdValue = ( "true" . equalsIgnoreCase ( value ) ) ? true : false ; setSeldirs ( sdValue ) ; } else if ( key . startsWith ( "cache." ) ) { String name = key . substring ( 6 ) ; tryToSetAParameter ( cache , name , value ) ; } else if ( key . startsWith ( "algorithm." ) ) { String name = key . substring ( 10 ) ; tryToSetAParameter ( algorithm , name , value ) ; } else if ( key . startsWith ( "comparator." ) ) { String name = key . substring ( 11 ) ; tryToSetAParameter ( comparator , name , value ) ; } else { setError ( "Invalid parameter " + key ) ; } } protected void tryToSetAParameter ( Object obj , String name , String value ) { Project prj = ( getProject ( ) != null ) ? getProject ( ) : new Project ( ) ; IntrospectionHelper iHelper = IntrospectionHelper . getHelper ( prj , obj . getClass ( ) ) ; try { iHelper . setAttribute ( prj , obj , name , value ) ; } catch ( org . apache . tools . ant . BuildException e ) { } } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{modifiedselector" ) ; buf . append ( " update=" ) . append ( update ) ; buf . append ( " seldirs=" ) . append ( selectDirectories ) ; buf . append ( " cache=" ) . append ( cache ) ; buf . append ( " algorithm=" ) . append ( algorithm ) ; buf . append ( " comparator=" ) . append ( comparator ) ; buf . append ( "}" ) ; return buf . toString ( ) ; } public void buildFinished ( BuildEvent event ) { if ( getDelayUpdate ( ) ) { saveCache ( ) ; } } public void targetFinished ( BuildEvent event ) { if ( getDelayUpdate ( ) ) { saveCache ( ) ; } } public void taskFinished ( BuildEvent event ) { if ( getDelayUpdate ( ) ) { saveCache ( ) ; } } public void buildStarted ( BuildEvent event ) { } public void targetStarted ( BuildEvent event ) { } public void taskStarted ( BuildEvent event ) { } public void messageLogged ( BuildEvent event ) { } public Cache getCache ( ) { return cache ; } public void setCache ( CacheName name ) { cacheName = name ; } public static class CacheName extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "propertyfile" } ; } } public Algorithm getAlgorithm ( ) { return algorithm ; } public void setAlgorithm ( AlgorithmName name ) { algoName = name ; } public static class AlgorithmName extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "hashvalue" , "digest" , "checksum" } ; } } public Comparator getComparator ( ) { return comparator ; } public void setComparator ( ComparatorName name ) { compName = name ; } public static class ComparatorName extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "equal" , "rule" } ; } } } 	1	['40', '5', '0', '30', '121', '622', '6', '24', '36', '0.886946387', '1031', '0.863636364', '6', '0.493506494', '0.115625', '2', '4', '24.225', '21', '2.35', '2']
package org . apache . tools . ant . taskdefs . optional . depend ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; import org . apache . tools . ant . util . depend . AbstractAnalyzer ; public class AntAnalyzer extends AbstractAnalyzer { public AntAnalyzer ( ) { } protected void determineDependencies ( Vector files , Vector classes ) { Hashtable dependencies = new Hashtable ( ) ; Hashtable containers = new Hashtable ( ) ; Hashtable toAnalyze = new Hashtable ( ) ; for ( Enumeration e = getRootClasses ( ) ; e . hasMoreElements ( ) ; ) { String classname = ( String ) e . nextElement ( ) ; toAnalyze . put ( classname , classname ) ; } int count = 0 ; int maxCount = isClosureRequired ( ) ? MAX_LOOPS : 1 ; Hashtable analyzedDeps = null ; while ( toAnalyze . size ( ) != 0 && count ++ < maxCount ) { analyzedDeps = new Hashtable ( ) ; for ( Enumeration e = toAnalyze . keys ( ) ; e . hasMoreElements ( ) ; ) { String classname = ( String ) e . nextElement ( ) ; dependencies . put ( classname , classname ) ; try { File container = getClassContainer ( classname ) ; if ( container == null ) { continue ; } containers . put ( container , container ) ; ZipFile zipFile = null ; InputStream inStream = null ; try { if ( container . getName ( ) . endsWith ( ".class" ) ) { inStream = new FileInputStream ( container . getPath ( ) ) ; } else { zipFile = new ZipFile ( container . getPath ( ) ) ; String entryName = classname . replace ( '.' , '/' ) + ".class" ; ZipEntry entry = new ZipEntry ( entryName ) ; inStream = zipFile . getInputStream ( entry ) ; } ClassFile classFile = new ClassFile ( ) ; classFile . read ( inStream ) ; Vector dependencyList = classFile . getClassRefs ( ) ; Enumeration depEnum = dependencyList . elements ( ) ; while ( depEnum . hasMoreElements ( ) ) { String dependency = ( String ) depEnum . nextElement ( ) ; analyzedDeps . put ( dependency , dependency ) ; } } finally { if ( inStream != null ) { inStream . close ( ) ; } if ( zipFile != null ) { zipFile . close ( ) ; } } } catch ( IOException ioe ) { } } toAnalyze . clear ( ) ; Enumeration depsEnum = analyzedDeps . elements ( ) ; while ( depsEnum . hasMoreElements ( ) ) { String className = ( String ) depsEnum . nextElement ( ) ; if ( ! dependencies . containsKey ( className ) ) { toAnalyze . put ( className , className ) ; } } } Enumeration depsEnum = analyzedDeps . elements ( ) ; while ( depsEnum . hasMoreElements ( ) ) { String className = ( String ) depsEnum . nextElement ( ) ; dependencies . put ( className , className ) ; } files . removeAllElements ( ) ; for ( Enumeration e = containers . keys ( ) ; e . hasMoreElements ( ) ; ) { files . addElement ( ( File ) e . nextElement ( ) ) ; } classes . removeAllElements ( ) ; for ( Enumeration e = dependencies . keys ( ) ; e . hasMoreElements ( ) ; ) { classes . addElement ( ( String ) e . nextElement ( ) ) ; } } protected boolean supportsFileDependencies ( ) { return true ; } } 	1	['3', '2', '0', '3', '36', '3', '1', '2', '1', '2', '241', '0', '0', '0.882352941', '0.666666667', '1', '2', '79.33333333', '18', '6.3333', '1']
package org . apache . tools . ant . util ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import org . apache . tools . ant . BuildException ; import java . lang . reflect . Field ; public class ReflectUtil { private ReflectUtil ( ) { } public static Object invoke ( Object obj , String methodName ) { try { Method method ; method = obj . getClass ( ) . getMethod ( methodName , ( Class [ ] ) null ) ; return method . invoke ( obj , ( Object [ ] ) null ) ; } catch ( Exception t ) { throwBuildException ( t ) ; return null ; } } public static Object invoke ( Object obj , String methodName , Class argType , Object arg ) { try { Method method ; method = obj . getClass ( ) . getMethod ( methodName , new Class [ ] { argType } ) ; return method . invoke ( obj , new Object [ ] { arg } ) ; } catch ( Exception t ) { throwBuildException ( t ) ; return null ; } } public static Object invoke ( Object obj , String methodName , Class argType1 , Object arg1 , Class argType2 , Object arg2 ) { try { Method method ; method = obj . getClass ( ) . getMethod ( methodName , new Class [ ] { argType1 , argType2 } ) ; return method . invoke ( obj , new Object [ ] { arg1 , arg2 } ) ; } catch ( Exception t ) { throwBuildException ( t ) ; return null ; } } public static Object getField ( Object obj , String fieldName ) throws BuildException { try { Field field = obj . getClass ( ) . getDeclaredField ( fieldName ) ; field . setAccessible ( true ) ; return field . get ( obj ) ; } catch ( Exception t ) { throwBuildException ( t ) ; return null ; } } public static void throwBuildException ( Exception t ) throws BuildException { if ( t instanceof InvocationTargetException ) { Throwable t2 = ( ( InvocationTargetException ) t ) . getTargetException ( ) ; if ( t2 instanceof BuildException ) { throw ( BuildException ) t2 ; } throw new BuildException ( t2 ) ; } else { throw new BuildException ( t ) ; } } } 	1	['6', '1', '0', '4', '15', '15', '3', '1', '5', '2', '125', '0', '0', '0', '0.4', '0', '0', '19.83333333', '1', '0.8333', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . FileUtils ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintStream ; import java . net . HttpURLConnection ; import java . net . URL ; import java . net . URLConnection ; import java . util . Date ; public class Get extends Task { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private URL source ; private File dest ; private boolean verbose = false ; private boolean useTimestamp = false ; private boolean ignoreErrors = false ; private String uname = null ; private String pword = null ; public void execute ( ) throws BuildException { int logLevel = Project . MSG_INFO ; DownloadProgress progress = null ; if ( verbose ) { progress = new VerboseProgress ( System . out ) ; } try { doGet ( logLevel , progress ) ; } catch ( IOException ioe ) { log ( "Error getting " + source + " to " + dest ) ; if ( ! ignoreErrors ) { throw new BuildException ( ioe , getLocation ( ) ) ; } } } public boolean doGet ( int logLevel , DownloadProgress progress ) throws IOException { if ( source == null ) { throw new BuildException ( "src attribute is required" , getLocation ( ) ) ; } if ( dest == null ) { throw new BuildException ( "dest attribute is required" , getLocation ( ) ) ; } if ( dest . exists ( ) && dest . isDirectory ( ) ) { throw new BuildException ( "The specified destination is a directory" , getLocation ( ) ) ; } if ( dest . exists ( ) && ! dest . canWrite ( ) ) { throw new BuildException ( "Can't write to " + dest . getAbsolutePath ( ) , getLocation ( ) ) ; } if ( progress == null ) { progress = new NullProgress ( ) ; } log ( "Getting: " + source , logLevel ) ; log ( "To: " + dest . getAbsolutePath ( ) , logLevel ) ; long timestamp = 0 ; boolean hasTimestamp = false ; if ( useTimestamp && dest . exists ( ) ) { timestamp = dest . lastModified ( ) ; if ( verbose ) { Date t = new Date ( timestamp ) ; log ( "local file date : " + t . toString ( ) , logLevel ) ; } hasTimestamp = true ; } URLConnection connection = source . openConnection ( ) ; if ( hasTimestamp ) { connection . setIfModifiedSince ( timestamp ) ; } if ( uname != null || pword != null ) { String up = uname + ":" + pword ; String encoding ; Base64Converter encoder = new Base64Converter ( ) ; encoding = encoder . encode ( up . getBytes ( ) ) ; connection . setRequestProperty ( "Authorization" , "Basic " + encoding ) ; } connection . connect ( ) ; if ( connection instanceof HttpURLConnection ) { HttpURLConnection httpConnection = ( HttpURLConnection ) connection ; long lastModified = httpConnection . getLastModified ( ) ; if ( httpConnection . getResponseCode ( ) == HttpURLConnection . HTTP_NOT_MODIFIED || ( lastModified != 0 && hasTimestamp && timestamp >= lastModified ) ) { log ( "Not modified - so not downloaded" , logLevel ) ; return false ; } if ( httpConnection . getResponseCode ( ) == HttpURLConnection . HTTP_UNAUTHORIZED ) { String message = "HTTP Authorization failure" ; if ( ignoreErrors ) { log ( message , logLevel ) ; return false ; } else { throw new BuildException ( message ) ; } } } InputStream is = null ; for ( int i = 0 ; i < 3 ; i ++ ) { try { is = connection . getInputStream ( ) ; break ; } catch ( IOException ex ) { log ( "Error opening connection " + ex , logLevel ) ; } } if ( is == null ) { log ( "Can't get " + source + " to " + dest , logLevel ) ; if ( ignoreErrors ) { return false ; } throw new BuildException ( "Can't get " + source + " to " + dest , getLocation ( ) ) ; } FileOutputStream fos = new FileOutputStream ( dest ) ; progress . beginDownload ( ) ; boolean finished = false ; try { byte [ ] buffer = new byte [ 100 * 1024 ] ; int length ; while ( ( length = is . read ( buffer ) ) >= 0 ) { fos . write ( buffer , 0 , length ) ; progress . onTick ( ) ; } finished = true ; } finally { FileUtils . close ( fos ) ; FileUtils . close ( is ) ; if ( ! finished ) { dest . delete ( ) ; } } progress . endDownload ( ) ; if ( useTimestamp ) { long remoteTimestamp = connection . getLastModified ( ) ; if ( verbose ) { Date t = new Date ( remoteTimestamp ) ; log ( "last modified = " + t . toString ( ) + ( ( remoteTimestamp == 0 ) ? " - using current time instead" : "" ) , logLevel ) ; } if ( remoteTimestamp != 0 ) { FILE_UTILS . setFileLastModified ( dest , remoteTimestamp ) ; } } return true ; } public void setSrc ( URL u ) { this . source = u ; } public void setDest ( File dest ) { this . dest = dest ; } public void setVerbose ( boolean v ) { verbose = v ; } public void setIgnoreErrors ( boolean v ) { ignoreErrors = v ; } public void setUseTimestamp ( boolean v ) { useTimestamp = v ; } public void setUsername ( String u ) { this . uname = u ; } public void setPassword ( String p ) { this . pword = p ; } protected static class Base64Converter extends org . apache . tools . ant . util . Base64Converter { } public interface DownloadProgress { void beginDownload ( ) ; void onTick ( ) ; void endDownload ( ) ; } public static class NullProgress implements DownloadProgress { public void beginDownload ( ) { } public void onTick ( ) { } public void endDownload ( ) { } } public static class VerboseProgress implements DownloadProgress { private int dots = 0 ; PrintStream out ; public VerboseProgress ( PrintStream out ) { this . out = out ; } public void beginDownload ( ) { dots = 0 ; } public void onTick ( ) { out . print ( "." ) ; if ( dots ++ > 50 ) { out . flush ( ) ; dots = 0 ; } } public void endDownload ( ) { out . println ( ) ; out . flush ( ) ; } } } 	1	['11', '3', '0', '9', '54', '15', '1', '8', '10', '0.7375', '493', '1', '1', '0.804347826', '0.271428571', '1', '1', '43.09090909', '1', '0.8182', '3']
package org . apache . tools . zip ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . RandomAccessFile ; import java . io . UnsupportedEncodingException ; import java . util . Calendar ; import java . util . Date ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . zip . Inflater ; import java . util . zip . InflaterInputStream ; import java . util . zip . ZipException ; public class ZipFile { private Hashtable entries = new Hashtable ( 509 ) ; private Hashtable nameMap = new Hashtable ( 509 ) ; private static final class OffsetEntry { private long headerOffset = - 1 ; private long dataOffset = - 1 ; } private String encoding = null ; private RandomAccessFile archive ; public ZipFile ( File f ) throws IOException { this ( f , null ) ; } public ZipFile ( String name ) throws IOException { this ( new File ( name ) , null ) ; } public ZipFile ( String name , String encoding ) throws IOException { this ( new File ( name ) , encoding ) ; } public ZipFile ( File f , String encoding ) throws IOException { this . encoding = encoding ; archive = new RandomAccessFile ( f , "r" ) ; try { populateFromCentralDirectory ( ) ; resolveLocalFileHeaderData ( ) ; } catch ( IOException e ) { try { archive . close ( ) ; } catch ( IOException e2 ) { } throw e ; } } public String getEncoding ( ) { return encoding ; } public void close ( ) throws IOException { archive . close ( ) ; } public static void closeQuietly ( ZipFile zipfile ) { if ( zipfile != null ) { try { zipfile . close ( ) ; } catch ( IOException e ) { } } } public Enumeration getEntries ( ) { return entries . keys ( ) ; } public ZipEntry getEntry ( String name ) { return ( ZipEntry ) nameMap . get ( name ) ; } public InputStream getInputStream ( ZipEntry ze ) throws IOException , ZipException { OffsetEntry offsetEntry = ( OffsetEntry ) entries . get ( ze ) ; if ( offsetEntry == null ) { return null ; } long start = offsetEntry . dataOffset ; BoundedInputStream bis = new BoundedInputStream ( start , ze . getCompressedSize ( ) ) ; switch ( ze . getMethod ( ) ) { case ZipEntry . STORED : return bis ; case ZipEntry . DEFLATED : bis . addDummy ( ) ; return new InflaterInputStream ( bis , new Inflater ( true ) ) ; default : throw new ZipException ( "Found unsupported compression method " + ze . getMethod ( ) ) ; } } private static final int CFH_LEN = 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 4 + 4 ; private void populateFromCentralDirectory ( ) throws IOException { positionAtCentralDirectory ( ) ; byte [ ] cfh = new byte [ CFH_LEN ] ; byte [ ] signatureBytes = new byte [ 4 ] ; archive . readFully ( signatureBytes ) ; long sig = ZipLong . getValue ( signatureBytes ) ; final long cfhSig = ZipLong . getValue ( ZipOutputStream . CFH_SIG ) ; while ( sig == cfhSig ) { archive . readFully ( cfh ) ; int off = 0 ; ZipEntry ze = new ZipEntry ( ) ; int versionMadeBy = ZipShort . getValue ( cfh , off ) ; off += 2 ; ze . setPlatform ( ( versionMadeBy > > 8 ) & 0x0F ) ; off += 4 ; ze . setMethod ( ZipShort . getValue ( cfh , off ) ) ; off += 2 ; long time = dosToJavaTime ( ZipLong . getValue ( cfh , off ) ) ; ze . setTime ( time ) ; off += 4 ; ze . setCrc ( ZipLong . getValue ( cfh , off ) ) ; off += 4 ; ze . setCompressedSize ( ZipLong . getValue ( cfh , off ) ) ; off += 4 ; ze . setSize ( ZipLong . getValue ( cfh , off ) ) ; off += 4 ; int fileNameLen = ZipShort . getValue ( cfh , off ) ; off += 2 ; int extraLen = ZipShort . getValue ( cfh , off ) ; off += 2 ; int commentLen = ZipShort . getValue ( cfh , off ) ; off += 2 ; off += 2 ; ze . setInternalAttributes ( ZipShort . getValue ( cfh , off ) ) ; off += 2 ; ze . setExternalAttributes ( ZipLong . getValue ( cfh , off ) ) ; off += 4 ; byte [ ] fileName = new byte [ fileNameLen ] ; archive . readFully ( fileName ) ; ze . setName ( getString ( fileName ) ) ; OffsetEntry offset = new OffsetEntry ( ) ; offset . headerOffset = ZipLong . getValue ( cfh , off ) ; entries . put ( ze , offset ) ; nameMap . put ( ze . getName ( ) , ze ) ; archive . skipBytes ( extraLen ) ; byte [ ] comment = new byte [ commentLen ] ; archive . readFully ( comment ) ; ze . setComment ( getString ( comment ) ) ; archive . readFully ( signatureBytes ) ; sig = ZipLong . getValue ( signatureBytes ) ; } } private static final int MIN_EOCD_SIZE = 4 + 2 + 2 + 2 + 2 + 4 + 4 + 2 ; private static final int CFD_LOCATOR_OFFSET = 4 + 2 + 2 + 2 + 2 + 4 ; private void positionAtCentralDirectory ( ) throws IOException { boolean found = false ; long off = archive . length ( ) - MIN_EOCD_SIZE ; if ( off >= 0 ) { archive . seek ( off ) ; byte [ ] sig = ZipOutputStream . EOCD_SIG ; int curr = archive . read ( ) ; while ( curr != - 1 ) { if ( curr == sig [ 0 ] ) { curr = archive . read ( ) ; if ( curr == sig [ 1 ] ) { curr = archive . read ( ) ; if ( curr == sig [ 2 ] ) { curr = archive . read ( ) ; if ( curr == sig [ 3 ] ) { found = true ; break ; } } } } archive . seek ( -- off ) ; curr = archive . read ( ) ; } } if ( ! found ) { throw new ZipException ( "archive is not a ZIP archive" ) ; } archive . seek ( off + CFD_LOCATOR_OFFSET ) ; byte [ ] cfdOffset = new byte [ 4 ] ; archive . readFully ( cfdOffset ) ; archive . seek ( ZipLong . getValue ( cfdOffset ) ) ; } private static final long LFH_OFFSET_FOR_FILENAME_LENGTH = 4 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 ; private void resolveLocalFileHeaderData ( ) throws IOException { Enumeration e = getEntries ( ) ; while ( e . hasMoreElements ( ) ) { ZipEntry ze = ( ZipEntry ) e . nextElement ( ) ; OffsetEntry offsetEntry = ( OffsetEntry ) entries . get ( ze ) ; long offset = offsetEntry . headerOffset ; archive . seek ( offset + LFH_OFFSET_FOR_FILENAME_LENGTH ) ; byte [ ] b = new byte [ 2 ] ; archive . readFully ( b ) ; int fileNameLen = ZipShort . getValue ( b ) ; archive . readFully ( b ) ; int extraFieldLen = ZipShort . getValue ( b ) ; archive . skipBytes ( fileNameLen ) ; byte [ ] localExtraData = new byte [ extraFieldLen ] ; archive . readFully ( localExtraData ) ; ze . setExtra ( localExtraData ) ; offsetEntry . dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH + 2 + 2 + fileNameLen + extraFieldLen ; } } protected static Date fromDosTime ( ZipLong zipDosTime ) { long dosTime = zipDosTime . getValue ( ) ; return new Date ( dosToJavaTime ( dosTime ) ) ; } private static long dosToJavaTime ( long dosTime ) { Calendar cal = Calendar . getInstance ( ) ; cal . set ( Calendar . YEAR , ( int ) ( ( dosTime > > 25 ) & 0x7f ) + 1980 ) ; cal . set ( Calendar . MONTH , ( int ) ( ( dosTime > > 21 ) & 0x0f ) - 1 ) ; cal . set ( Calendar . DATE , ( int ) ( dosTime > > 16 ) & 0x1f ) ; cal . set ( Calendar . HOUR_OF_DAY , ( int ) ( dosTime > > 11 ) & 0x1f ) ; cal . set ( Calendar . MINUTE , ( int ) ( dosTime > > 5 ) & 0x3f ) ; cal . set ( Calendar . SECOND , ( int ) ( dosTime << 1 ) & 0x3e ) ; return cal . getTime ( ) . getTime ( ) ; } protected String getString ( byte [ ] bytes ) throws ZipException { if ( encoding == null ) { return new String ( bytes ) ; } else { try { return new String ( bytes , encoding ) ; } catch ( UnsupportedEncodingException uee ) { throw new ZipException ( uee . getMessage ( ) ) ; } } } private class BoundedInputStream extends InputStream { private long remaining ; private long loc ; private boolean addDummyByte = false ; BoundedInputStream ( long start , long remaining ) { this . remaining = remaining ; loc = start ; } public int read ( ) throws IOException { if ( remaining -- <= 0 ) { if ( addDummyByte ) { addDummyByte = false ; return 0 ; } return - 1 ; } synchronized ( archive ) { archive . seek ( loc ++ ) ; return archive . read ( ) ; } } public int read ( byte [ ] b , int off , int len ) throws IOException { if ( remaining <= 0 ) { if ( addDummyByte ) { addDummyByte = false ; b [ off ] = 0 ; return 1 ; } return - 1 ; } if ( len <= 0 ) { return 0 ; } if ( len > remaining ) { len = ( int ) remaining ; } int ret = - 1 ; synchronized ( archive ) { archive . seek ( loc ) ; ret = archive . read ( b , off , len ) ; } if ( ret > 0 ) { loc += ret ; remaining -= ret ; } return ret ; } void addDummy ( ) { addDummyByte = true ; } } } 	1	['17', '1', '0', '13', '73', '82', '8', '6', '10', '0.8203125', '598', '1', '0', '0', '0.183823529', '0', '0', '33.70588235', '3', '0.9412', '7']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . AbstractFileSet ; import org . apache . tools . ant . types . DirSet ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileList ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . Union ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . SourceFileScanner ; public class ExecuteOn extends ExecTask { protected Vector filesets = new Vector ( ) ; private Union resources = null ; private boolean relative = false ; private boolean parallel = false ; private boolean forwardSlash = false ; protected String type = FileDirBoth . FILE ; protected Commandline . Marker srcFilePos = null ; private boolean skipEmpty = false ; protected Commandline . Marker targetFilePos = null ; protected Mapper mapperElement = null ; protected FileNameMapper mapper = null ; protected File destDir = null ; private int maxParallel = - 1 ; private boolean addSourceFile = true ; private boolean verbose = false ; private boolean ignoreMissing = true ; private boolean force = false ; protected boolean srcIsFirst = true ; public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void addDirset ( DirSet set ) { filesets . addElement ( set ) ; } public void addFilelist ( FileList list ) { add ( list ) ; } public void add ( ResourceCollection rc ) { if ( resources == null ) { resources = new Union ( ) ; } resources . add ( rc ) ; } public void setRelative ( boolean relative ) { this . relative = relative ; } public void setParallel ( boolean parallel ) { this . parallel = parallel ; } public void setType ( FileDirBoth type ) { this . type = type . getValue ( ) ; } public void setSkipEmptyFilesets ( boolean skip ) { skipEmpty = skip ; } public void setDest ( File destDir ) { this . destDir = destDir ; } public void setForwardslash ( boolean forwardSlash ) { this . forwardSlash = forwardSlash ; } public void setMaxParallel ( int max ) { maxParallel = max ; } public void setAddsourcefile ( boolean b ) { addSourceFile = b ; } public void setVerbose ( boolean b ) { verbose = b ; } public void setIgnoremissing ( boolean b ) { ignoreMissing = b ; } public void setForce ( boolean b ) { force = b ; } public Commandline . Marker createSrcfile ( ) { if ( srcFilePos != null ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support multiple " + "srcfile elements." , getLocation ( ) ) ; } srcFilePos = cmdl . createMarker ( ) ; return srcFilePos ; } public Commandline . Marker createTargetfile ( ) { if ( targetFilePos != null ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support multiple " + "targetfile elements." , getLocation ( ) ) ; } targetFilePos = cmdl . createMarker ( ) ; srcIsFirst = ( srcFilePos != null ) ; return targetFilePos ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" , getLocation ( ) ) ; } mapperElement = new Mapper ( getProject ( ) ) ; return mapperElement ; } public void add ( FileNameMapper fileNameMapper ) { createMapper ( ) . add ( fileNameMapper ) ; } protected void checkConfiguration ( ) { if ( "execon" . equals ( getTaskName ( ) ) ) { log ( "!! execon is deprecated. Use apply instead. !!" ) ; } super . checkConfiguration ( ) ; if ( filesets . size ( ) == 0 && resources == null ) { throw new BuildException ( "no resources specified" , getLocation ( ) ) ; } if ( targetFilePos != null && mapperElement == null ) { throw new BuildException ( "targetfile specified without mapper" , getLocation ( ) ) ; } if ( destDir != null && mapperElement == null ) { throw new BuildException ( "dest specified without mapper" , getLocation ( ) ) ; } if ( mapperElement != null ) { mapper = mapperElement . getImplementation ( ) ; } } protected ExecuteStreamHandler createHandler ( ) throws BuildException { return ( redirectorElement == null ) ? super . createHandler ( ) : new PumpStreamHandler ( ) ; } protected void setupRedirector ( ) { super . setupRedirector ( ) ; redirector . setAppendProperties ( true ) ; } protected void runExec ( Execute exe ) throws BuildException { int totalFiles = 0 ; int totalDirs = 0 ; boolean haveExecuted = false ; try { Vector fileNames = new Vector ( ) ; Vector baseDirs = new Vector ( ) ; for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { String currentType = type ; AbstractFileSet fs = ( AbstractFileSet ) filesets . elementAt ( i ) ; if ( fs instanceof DirSet ) { if ( ! FileDirBoth . DIR . equals ( type ) ) { log ( "Found a nested dirset but type is " + type + ". " + "Temporarily switching to type=\"dir\" on the" + " assumption that you really did mean" + " <dirset> not <fileset>." , Project . MSG_DEBUG ) ; currentType = FileDirBoth . DIR ; } } File base = fs . getDir ( getProject ( ) ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; if ( ! FileDirBoth . DIR . equals ( currentType ) ) { String [ ] s = getFiles ( base , ds ) ; for ( int j = 0 ; j < s . length ; j ++ ) { totalFiles ++ ; fileNames . addElement ( s [ j ] ) ; baseDirs . addElement ( base ) ; } } if ( ! FileDirBoth . FILE . equals ( currentType ) ) { String [ ] s = getDirs ( base , ds ) ; for ( int j = 0 ; j < s . length ; j ++ ) { totalDirs ++ ; fileNames . addElement ( s [ j ] ) ; baseDirs . addElement ( base ) ; } } if ( fileNames . size ( ) == 0 && skipEmpty ) { int includedCount = ( ( ! FileDirBoth . DIR . equals ( currentType ) ) ? ds . getIncludedFilesCount ( ) : 0 ) + ( ( ! FileDirBoth . FILE . equals ( currentType ) ) ? ds . getIncludedDirsCount ( ) : 0 ) ; log ( "Skipping fileset for directory " + base + ". It is " + ( ( includedCount > 0 ) ? "up to date." : "empty." ) , Project . MSG_INFO ) ; continue ; } if ( ! parallel ) { String [ ] s = new String [ fileNames . size ( ) ] ; fileNames . copyInto ( s ) ; for ( int j = 0 ; j < s . length ; j ++ ) { String [ ] command = getCommandline ( s [ j ] , base ) ; log ( Commandline . describeCommand ( command ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( command ) ; if ( redirectorElement != null ) { setupRedirector ( ) ; redirectorElement . configure ( redirector , s [ j ] ) ; } if ( redirectorElement != null || haveExecuted ) { exe . setStreamHandler ( redirector . createHandler ( ) ) ; } runExecute ( exe ) ; haveExecuted = true ; } fileNames . removeAllElements ( ) ; baseDirs . removeAllElements ( ) ; } } if ( resources != null ) { Iterator iter = resources . iterator ( ) ; while ( iter . hasNext ( ) ) { Resource res = ( Resource ) iter . next ( ) ; if ( ! res . isExists ( ) && ignoreMissing ) { continue ; } File base = null ; String name = res . getName ( ) ; if ( res instanceof FileResource ) { FileResource fr = ( FileResource ) res ; base = fr . getBaseDir ( ) ; if ( base == null ) { name = fr . getFile ( ) . getAbsolutePath ( ) ; } } if ( restrict ( new String [ ] { name } , base ) . length == 0 ) { continue ; } if ( ( ! res . isDirectory ( ) || ! res . isExists ( ) ) && ! FileDirBoth . DIR . equals ( type ) ) { totalFiles ++ ; } else if ( res . isDirectory ( ) && ! FileDirBoth . FILE . equals ( type ) ) { totalDirs ++ ; } else { continue ; } baseDirs . add ( base ) ; fileNames . add ( name ) ; if ( ! parallel ) { String [ ] command = getCommandline ( name , base ) ; log ( Commandline . describeCommand ( command ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( command ) ; if ( redirectorElement != null ) { setupRedirector ( ) ; redirectorElement . configure ( redirector , name ) ; } if ( redirectorElement != null || haveExecuted ) { exe . setStreamHandler ( redirector . createHandler ( ) ) ; } runExecute ( exe ) ; haveExecuted = true ; fileNames . removeAllElements ( ) ; baseDirs . removeAllElements ( ) ; } } } if ( parallel && ( fileNames . size ( ) > 0 || ! skipEmpty ) ) { runParallel ( exe , fileNames , baseDirs ) ; haveExecuted = true ; } if ( haveExecuted ) { log ( "Applied " + cmdl . getExecutable ( ) + " to " + totalFiles + " file" + ( totalFiles != 1 ? "s" : "" ) + " and " + totalDirs + " director" + ( totalDirs != 1 ? "ies" : "y" ) + "." , verbose ? Project . MSG_INFO : Project . MSG_VERBOSE ) ; } } catch ( IOException e ) { throw new BuildException ( "Execute failed: " + e , e , getLocation ( ) ) ; } finally { logFlush ( ) ; redirector . setAppendProperties ( false ) ; redirector . setProperties ( ) ; } } protected String [ ] getCommandline ( String [ ] srcFiles , File [ ] baseDirs ) { final char fileSeparator = File . separatorChar ; Vector targets = new Vector ( ) ; if ( targetFilePos != null ) { Hashtable addedFiles = new Hashtable ( ) ; for ( int i = 0 ; i < srcFiles . length ; i ++ ) { String [ ] subTargets = mapper . mapFileName ( srcFiles [ i ] ) ; if ( subTargets != null ) { for ( int j = 0 ; j < subTargets . length ; j ++ ) { String name = null ; if ( ! relative ) { name = ( new File ( destDir , subTargets [ j ] ) ) . getAbsolutePath ( ) ; } else { name = subTargets [ j ] ; } if ( forwardSlash && fileSeparator != '/' ) { name = name . replace ( fileSeparator , '/' ) ; } if ( ! addedFiles . contains ( name ) ) { targets . addElement ( name ) ; addedFiles . put ( name , name ) ; } } } } } String [ ] targetFiles = new String [ targets . size ( ) ] ; targets . copyInto ( targetFiles ) ; if ( ! addSourceFile ) { srcFiles = new String [ 0 ] ; } String [ ] orig = cmdl . getCommandline ( ) ; String [ ] result = new String [ orig . length + srcFiles . length + targetFiles . length ] ; int srcIndex = orig . length ; if ( srcFilePos != null ) { srcIndex = srcFilePos . getPosition ( ) ; } if ( targetFilePos != null ) { int targetIndex = targetFilePos . getPosition ( ) ; if ( srcIndex < targetIndex || ( srcIndex == targetIndex && srcIsFirst ) ) { System . arraycopy ( orig , 0 , result , 0 , srcIndex ) ; System . arraycopy ( orig , srcIndex , result , srcIndex + srcFiles . length , targetIndex - srcIndex ) ; System . arraycopy ( targetFiles , 0 , result , targetIndex + srcFiles . length , targetFiles . length ) ; System . arraycopy ( orig , targetIndex , result , targetIndex + srcFiles . length + targetFiles . length , orig . length - targetIndex ) ; } else { System . arraycopy ( orig , 0 , result , 0 , targetIndex ) ; System . arraycopy ( targetFiles , 0 , result , targetIndex , targetFiles . length ) ; System . arraycopy ( orig , targetIndex , result , targetIndex + targetFiles . length , srcIndex - targetIndex ) ; System . arraycopy ( orig , srcIndex , result , srcIndex + srcFiles . length + targetFiles . length , orig . length - srcIndex ) ; srcIndex += targetFiles . length ; } } else { System . arraycopy ( orig , 0 , result , 0 , srcIndex ) ; System . arraycopy ( orig , srcIndex , result , srcIndex + srcFiles . length , orig . length - srcIndex ) ; } for ( int i = 0 ; i < srcFiles . length ; i ++ ) { if ( ! relative ) { result [ srcIndex + i ] = ( new File ( baseDirs [ i ] , srcFiles [ i ] ) ) . getAbsolutePath ( ) ; } else { result [ srcIndex + i ] = srcFiles [ i ] ; } if ( forwardSlash && fileSeparator != '/' ) { result [ srcIndex + i ] = result [ srcIndex + i ] . replace ( fileSeparator , '/' ) ; } } return result ; } protected String [ ] getCommandline ( String srcFile , File baseDir ) { return getCommandline ( new String [ ] { srcFile } , new File [ ] { baseDir } ) ; } protected String [ ] getFiles ( File baseDir , DirectoryScanner ds ) { return restrict ( ds . getIncludedFiles ( ) , baseDir ) ; } protected String [ ] getDirs ( File baseDir , DirectoryScanner ds ) { return restrict ( ds . getIncludedDirectories ( ) , baseDir ) ; } protected String [ ] getFilesAndDirs ( FileList list ) { return restrict ( list . getFiles ( getProject ( ) ) , list . getDir ( getProject ( ) ) ) ; } private String [ ] restrict ( String [ ] s , File baseDir ) { return ( mapper == null || force ) ? s : new SourceFileScanner ( this ) . restrict ( s , baseDir , destDir , mapper ) ; } protected void runParallel ( Execute exe , Vector fileNames , Vector baseDirs ) throws IOException , BuildException { String [ ] s = new String [ fileNames . size ( ) ] ; fileNames . copyInto ( s ) ; File [ ] b = new File [ baseDirs . size ( ) ] ; baseDirs . copyInto ( b ) ; if ( maxParallel <= 0 || s . length == 0 ) { String [ ] command = getCommandline ( s , b ) ; log ( Commandline . describeCommand ( command ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( command ) ; runExecute ( exe ) ; } else { int stillToDo = fileNames . size ( ) ; int currentOffset = 0 ; while ( stillToDo > 0 ) { int currentAmount = Math . min ( stillToDo , maxParallel ) ; String [ ] cs = new String [ currentAmount ] ; System . arraycopy ( s , currentOffset , cs , 0 , currentAmount ) ; File [ ] cb = new File [ currentAmount ] ; System . arraycopy ( b , currentOffset , cb , 0 , currentAmount ) ; String [ ] command = getCommandline ( cs , cb ) ; log ( Commandline . describeCommand ( command ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( command ) ; if ( redirectorElement != null ) { setupRedirector ( ) ; redirectorElement . configure ( redirector , null ) ; } if ( redirectorElement != null || currentOffset > 0 ) { exe . setStreamHandler ( redirector . createHandler ( ) ) ; } runExecute ( exe ) ; stillToDo -= currentAmount ; currentOffset += currentAmount ; } } } public static class FileDirBoth extends EnumeratedAttribute { public static final String FILE = "file" ; public static final String DIR = "dir" ; public String [ ] getValues ( ) { return new String [ ] { FILE , DIR , "both" } ; } } } 	1	['31', '4', '4', '29', '104', '347', '4', '25', '20', '0.861111111', '1270', '1', '5', '0.719626168', '0.122983871', '3', '9', '39.38709677', '19', '2', '2']
package org . apache . tools . tar ; import java . io . File ; import java . util . Date ; import java . util . Locale ; public class TarEntry implements TarConstants { private StringBuffer name ; private int mode ; private int userId ; private int groupId ; private long size ; private long modTime ; private byte linkFlag ; private StringBuffer linkName ; private StringBuffer magic ; private StringBuffer userName ; private StringBuffer groupName ; private int devMajor ; private int devMinor ; private File file ; public static final int MAX_NAMELEN = 31 ; public static final int DEFAULT_DIR_MODE = 040755 ; public static final int DEFAULT_FILE_MODE = 0100644 ; public static final int MILLIS_PER_SECOND = 1000 ; private TarEntry ( ) { this . magic = new StringBuffer ( TMAGIC ) ; this . name = new StringBuffer ( ) ; this . linkName = new StringBuffer ( ) ; String user = System . getProperty ( "user.name" , "" ) ; if ( user . length ( ) > MAX_NAMELEN ) { user = user . substring ( 0 , MAX_NAMELEN ) ; } this . userId = 0 ; this . groupId = 0 ; this . userName = new StringBuffer ( user ) ; this . groupName = new StringBuffer ( "" ) ; this . file = null ; } public TarEntry ( String name ) { this ( ) ; boolean isDir = name . endsWith ( "/" ) ; this . devMajor = 0 ; this . devMinor = 0 ; this . name = new StringBuffer ( name ) ; this . mode = isDir ? DEFAULT_DIR_MODE : DEFAULT_FILE_MODE ; this . linkFlag = isDir ? LF_DIR : LF_NORMAL ; this . userId = 0 ; this . groupId = 0 ; this . size = 0 ; this . modTime = ( new Date ( ) ) . getTime ( ) / MILLIS_PER_SECOND ; this . linkName = new StringBuffer ( "" ) ; this . userName = new StringBuffer ( "" ) ; this . groupName = new StringBuffer ( "" ) ; this . devMajor = 0 ; this . devMinor = 0 ; } public TarEntry ( String name , byte linkFlag ) { this ( name ) ; this . linkFlag = linkFlag ; } public TarEntry ( File file ) { this ( ) ; this . file = file ; String fileName = file . getPath ( ) ; String osname = System . getProperty ( "os.name" ) . toLowerCase ( Locale . US ) ; if ( osname != null ) { if ( osname . startsWith ( "windows" ) ) { if ( fileName . length ( ) > 2 ) { char ch1 = fileName . charAt ( 0 ) ; char ch2 = fileName . charAt ( 1 ) ; if ( ch2 == ':' && ( ( ch1 >= 'a' && ch1 <= 'z' ) || ( ch1 >= 'A' && ch1 <= 'Z' ) ) ) { fileName = fileName . substring ( 2 ) ; } } } else if ( osname . indexOf ( "netware" ) > - 1 ) { int colon = fileName . indexOf ( ':' ) ; if ( colon != - 1 ) { fileName = fileName . substring ( colon + 1 ) ; } } } fileName = fileName . replace ( File . separatorChar , '/' ) ; while ( fileName . startsWith ( "/" ) ) { fileName = fileName . substring ( 1 ) ; } this . linkName = new StringBuffer ( "" ) ; this . name = new StringBuffer ( fileName ) ; if ( file . isDirectory ( ) ) { this . mode = DEFAULT_DIR_MODE ; this . linkFlag = LF_DIR ; if ( this . name . charAt ( this . name . length ( ) - 1 ) != '/' ) { this . name . append ( "/" ) ; } } else { this . mode = DEFAULT_FILE_MODE ; this . linkFlag = LF_NORMAL ; } this . size = file . length ( ) ; this . modTime = file . lastModified ( ) / MILLIS_PER_SECOND ; this . devMajor = 0 ; this . devMinor = 0 ; } public TarEntry ( byte [ ] headerBuf ) { this ( ) ; this . parseTarHeader ( headerBuf ) ; } public boolean equals ( TarEntry it ) { return this . getName ( ) . equals ( it . getName ( ) ) ; } public boolean equals ( Object it ) { if ( it == null || getClass ( ) != it . getClass ( ) ) { return false ; } return equals ( ( TarEntry ) it ) ; } public int hashCode ( ) { return getName ( ) . hashCode ( ) ; } public boolean isDescendent ( TarEntry desc ) { return desc . getName ( ) . startsWith ( this . getName ( ) ) ; } public String getName ( ) { return this . name . toString ( ) ; } public void setName ( String name ) { this . name = new StringBuffer ( name ) ; } public void setMode ( int mode ) { this . mode = mode ; } public String getLinkName ( ) { return this . linkName . toString ( ) ; } public int getUserId ( ) { return this . userId ; } public void setUserId ( int userId ) { this . userId = userId ; } public int getGroupId ( ) { return this . groupId ; } public void setGroupId ( int groupId ) { this . groupId = groupId ; } public String getUserName ( ) { return this . userName . toString ( ) ; } public void setUserName ( String userName ) { this . userName = new StringBuffer ( userName ) ; } public String getGroupName ( ) { return this . groupName . toString ( ) ; } public void setGroupName ( String groupName ) { this . groupName = new StringBuffer ( groupName ) ; } public void setIds ( int userId , int groupId ) { this . setUserId ( userId ) ; this . setGroupId ( groupId ) ; } public void setNames ( String userName , String groupName ) { this . setUserName ( userName ) ; this . setGroupName ( groupName ) ; } public void setModTime ( long time ) { this . modTime = time / MILLIS_PER_SECOND ; } public void setModTime ( Date time ) { this . modTime = time . getTime ( ) / MILLIS_PER_SECOND ; } public Date getModTime ( ) { return new Date ( this . modTime * MILLIS_PER_SECOND ) ; } public File getFile ( ) { return this . file ; } public int getMode ( ) { return this . mode ; } public long getSize ( ) { return this . size ; } public void setSize ( long size ) { this . size = size ; } public boolean isGNULongNameEntry ( ) { return linkFlag == LF_GNUTYPE_LONGNAME && name . toString ( ) . equals ( GNU_LONGLINK ) ; } public boolean isDirectory ( ) { if ( this . file != null ) { return this . file . isDirectory ( ) ; } if ( this . linkFlag == LF_DIR ) { return true ; } if ( this . getName ( ) . endsWith ( "/" ) ) { return true ; } return false ; } public TarEntry [ ] getDirectoryEntries ( ) { if ( this . file == null || ! this . file . isDirectory ( ) ) { return new TarEntry [ 0 ] ; } String [ ] list = this . file . list ( ) ; TarEntry [ ] result = new TarEntry [ list . length ] ; for ( int i = 0 ; i < list . length ; ++ i ) { result [ i ] = new TarEntry ( new File ( this . file , list [ i ] ) ) ; } return result ; } public void writeEntryHeader ( byte [ ] outbuf ) { int offset = 0 ; offset = TarUtils . getNameBytes ( this . name , outbuf , offset , NAMELEN ) ; offset = TarUtils . getOctalBytes ( this . mode , outbuf , offset , MODELEN ) ; offset = TarUtils . getOctalBytes ( this . userId , outbuf , offset , UIDLEN ) ; offset = TarUtils . getOctalBytes ( this . groupId , outbuf , offset , GIDLEN ) ; offset = TarUtils . getLongOctalBytes ( this . size , outbuf , offset , SIZELEN ) ; offset = TarUtils . getLongOctalBytes ( this . modTime , outbuf , offset , MODTIMELEN ) ; int csOffset = offset ; for ( int c = 0 ; c < CHKSUMLEN ; ++ c ) { outbuf [ offset ++ ] = ( byte ) ' ' ; } outbuf [ offset ++ ] = this . linkFlag ; offset = TarUtils . getNameBytes ( this . linkName , outbuf , offset , NAMELEN ) ; offset = TarUtils . getNameBytes ( this . magic , outbuf , offset , MAGICLEN ) ; offset = TarUtils . getNameBytes ( this . userName , outbuf , offset , UNAMELEN ) ; offset = TarUtils . getNameBytes ( this . groupName , outbuf , offset , GNAMELEN ) ; offset = TarUtils . getOctalBytes ( this . devMajor , outbuf , offset , DEVLEN ) ; offset = TarUtils . getOctalBytes ( this . devMinor , outbuf , offset , DEVLEN ) ; while ( offset < outbuf . length ) { outbuf [ offset ++ ] = 0 ; } long chk = TarUtils . computeCheckSum ( outbuf ) ; TarUtils . getCheckSumOctalBytes ( chk , outbuf , csOffset , CHKSUMLEN ) ; } public void parseTarHeader ( byte [ ] header ) { int offset = 0 ; this . name = TarUtils . parseName ( header , offset , NAMELEN ) ; offset += NAMELEN ; this . mode = ( int ) TarUtils . parseOctal ( header , offset , MODELEN ) ; offset += MODELEN ; this . userId = ( int ) TarUtils . parseOctal ( header , offset , UIDLEN ) ; offset += UIDLEN ; this . groupId = ( int ) TarUtils . parseOctal ( header , offset , GIDLEN ) ; offset += GIDLEN ; this . size = TarUtils . parseOctal ( header , offset , SIZELEN ) ; offset += SIZELEN ; this . modTime = TarUtils . parseOctal ( header , offset , MODTIMELEN ) ; offset += MODTIMELEN ; offset += CHKSUMLEN ; this . linkFlag = header [ offset ++ ] ; this . linkName = TarUtils . parseName ( header , offset , NAMELEN ) ; offset += NAMELEN ; this . magic = TarUtils . parseName ( header , offset , MAGICLEN ) ; offset += MAGICLEN ; this . userName = TarUtils . parseName ( header , offset , UNAMELEN ) ; offset += UNAMELEN ; this . groupName = TarUtils . parseName ( header , offset , GNAMELEN ) ; offset += GNAMELEN ; this . devMajor = ( int ) TarUtils . parseOctal ( header , offset , DEVLEN ) ; offset += DEVLEN ; this . devMinor = ( int ) TarUtils . parseOctal ( header , offset , DEVLEN ) ; } } 	1	['35', '1', '0', '8', '73', '353', '6', '2', '34', '0.807189542', '776', '0.777777778', '0', '0', '0.16', '1', '1', '20.65714286', '4', '1.2', '1']
package org . apache . tools . ant . util ; import java . util . Enumeration ; import java . util . Vector ; public class Watchdog implements Runnable { private Vector observers = new Vector ( 1 ) ; private long timeout = - 1 ; private volatile boolean stopped = false ; public static final String ERROR_INVALID_TIMEOUT = "timeout less than 1." ; public Watchdog ( long timeout ) { if ( timeout < 1 ) { throw new IllegalArgumentException ( ERROR_INVALID_TIMEOUT ) ; } this . timeout = timeout ; } public void addTimeoutObserver ( TimeoutObserver to ) { observers . addElement ( to ) ; } public void removeTimeoutObserver ( TimeoutObserver to ) { observers . removeElement ( to ) ; } protected final void fireTimeoutOccured ( ) { Enumeration e = observers . elements ( ) ; while ( e . hasMoreElements ( ) ) { ( ( TimeoutObserver ) e . nextElement ( ) ) . timeoutOccured ( this ) ; } } public synchronized void start ( ) { stopped = false ; Thread t = new Thread ( this , "WATCHDOG" ) ; t . setDaemon ( true ) ; t . start ( ) ; } public synchronized void stop ( ) { stopped = true ; notifyAll ( ) ; } public synchronized void run ( ) { final long until = System . currentTimeMillis ( ) + timeout ; long now ; while ( ! stopped && until > ( now = System . currentTimeMillis ( ) ) ) { try { wait ( until - now ) ; } catch ( InterruptedException e ) { } } if ( ! stopped ) { fireTimeoutOccured ( ) ; } } } 	1	['7', '1', '0', '3', '22', '0', '3', '1', '6', '0.708333333', '112', '0.75', '0', '0', '0.476190476', '0', '0', '14.42857143', '4', '1.4286', '1']
package org . apache . tools . ant . types ; import java . io . File ; import java . util . StringTokenizer ; import java . util . Vector ; import java . util . ArrayList ; import java . util . List ; import java . util . ListIterator ; import java . util . LinkedList ; import java . util . Iterator ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . util . StringUtils ; import org . apache . tools . ant . taskdefs . condition . Os ; public class Commandline implements Cloneable { private static final boolean IS_WIN_9X = Os . isFamily ( "win9x" ) ; private Vector arguments = new Vector ( ) ; private String executable = null ; protected static final String DISCLAIMER = StringUtils . LINE_SEP + "The \' characters around the executable and arguments are" + StringUtils . LINE_SEP + "not part of the command." + StringUtils . LINE_SEP ; public Commandline ( String toProcess ) { super ( ) ; String [ ] tmp = translateCommandline ( toProcess ) ; if ( tmp != null && tmp . length > 0 ) { setExecutable ( tmp [ 0 ] ) ; for ( int i = 1 ; i < tmp . length ; i ++ ) { createArgument ( ) . setValue ( tmp [ i ] ) ; } } } public Commandline ( ) { super ( ) ; } public static class Argument extends ProjectComponent { private String [ ] parts ; public void setValue ( String value ) { parts = new String [ ] { value } ; } public void setLine ( String line ) { if ( line == null ) { return ; } parts = translateCommandline ( line ) ; } public void setPath ( Path value ) { parts = new String [ ] { value . toString ( ) } ; } public void setPathref ( Reference value ) { Path p = new Path ( getProject ( ) ) ; p . setRefid ( value ) ; parts = new String [ ] { p . toString ( ) } ; } public void setFile ( File value ) { parts = new String [ ] { value . getAbsolutePath ( ) } ; } public String [ ] getParts ( ) { return parts ; } } public class Marker { private int position ; private int realPos = - 1 ; Marker ( int position ) { this . position = position ; } public int getPosition ( ) { if ( realPos == - 1 ) { realPos = ( executable == null ? 0 : 1 ) ; for ( int i = 0 ; i < position ; i ++ ) { Argument arg = ( Argument ) arguments . elementAt ( i ) ; realPos += arg . getParts ( ) . length ; } } return realPos ; } } public Argument createArgument ( ) { return this . createArgument ( false ) ; } public Argument createArgument ( boolean insertAtStart ) { Argument argument = new Argument ( ) ; if ( insertAtStart ) { arguments . insertElementAt ( argument , 0 ) ; } else { arguments . addElement ( argument ) ; } return argument ; } public void setExecutable ( String executable ) { if ( executable == null || executable . length ( ) == 0 ) { return ; } this . executable = executable . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; } public String getExecutable ( ) { return executable ; } public void addArguments ( String [ ] line ) { for ( int i = 0 ; i < line . length ; i ++ ) { createArgument ( ) . setValue ( line [ i ] ) ; } } public String [ ] getCommandline ( ) { List commands = new LinkedList ( ) ; ListIterator list = commands . listIterator ( ) ; addCommandToList ( list ) ; final String [ ] result = new String [ commands . size ( ) ] ; return ( String [ ] ) commands . toArray ( result ) ; } public void addCommandToList ( ListIterator list ) { if ( executable != null ) { list . add ( executable ) ; } addArgumentsToList ( list ) ; } public String [ ] getArguments ( ) { List result = new ArrayList ( arguments . size ( ) * 2 ) ; addArgumentsToList ( result . listIterator ( ) ) ; String [ ] res = new String [ result . size ( ) ] ; return ( String [ ] ) result . toArray ( res ) ; } public void addArgumentsToList ( ListIterator list ) { for ( int i = 0 ; i < arguments . size ( ) ; i ++ ) { Argument arg = ( Argument ) arguments . elementAt ( i ) ; String [ ] s = arg . getParts ( ) ; if ( s != null ) { for ( int j = 0 ; j < s . length ; j ++ ) { list . add ( s [ j ] ) ; } } } } public String toString ( ) { return toString ( getCommandline ( ) ) ; } public static String quoteArgument ( String argument ) { if ( argument . indexOf ( "\"" ) > - 1 ) { if ( argument . indexOf ( "\'" ) > - 1 ) { throw new BuildException ( "Can\'t handle single and double" + " quotes in same argument" ) ; } else { return '\'' + argument + '\'' ; } } else if ( argument . indexOf ( "\'" ) > - 1 || argument . indexOf ( " " ) > - 1 || ( IS_WIN_9X && argument . indexOf ( ';' ) != - 1 ) ) { return '\"' + argument + '\"' ; } else { return argument ; } } public static String toString ( String [ ] line ) { if ( line == null || line . length == 0 ) { return "" ; } final StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < line . length ; i ++ ) { if ( i > 0 ) { result . append ( ' ' ) ; } result . append ( quoteArgument ( line [ i ] ) ) ; } return result . toString ( ) ; } public static String [ ] translateCommandline ( String toProcess ) { if ( toProcess == null || toProcess . length ( ) == 0 ) { return new String [ 0 ] ; } final int normal = 0 ; final int inQuote = 1 ; final int inDoubleQuote = 2 ; int state = normal ; StringTokenizer tok = new StringTokenizer ( toProcess , "\"\' " , true ) ; Vector v = new Vector ( ) ; StringBuffer current = new StringBuffer ( ) ; boolean lastTokenHasBeenQuoted = false ; while ( tok . hasMoreTokens ( ) ) { String nextTok = tok . nextToken ( ) ; switch ( state ) { case inQuote : if ( "\'" . equals ( nextTok ) ) { lastTokenHasBeenQuoted = true ; state = normal ; } else { current . append ( nextTok ) ; } break ; case inDoubleQuote : if ( "\"" . equals ( nextTok ) ) { lastTokenHasBeenQuoted = true ; state = normal ; } else { current . append ( nextTok ) ; } break ; default : if ( "\'" . equals ( nextTok ) ) { state = inQuote ; } else if ( "\"" . equals ( nextTok ) ) { state = inDoubleQuote ; } else if ( " " . equals ( nextTok ) ) { if ( lastTokenHasBeenQuoted || current . length ( ) != 0 ) { v . addElement ( current . toString ( ) ) ; current = new StringBuffer ( ) ; } } else { current . append ( nextTok ) ; } lastTokenHasBeenQuoted = false ; break ; } } if ( lastTokenHasBeenQuoted || current . length ( ) != 0 ) { v . addElement ( current . toString ( ) ) ; } if ( state == inQuote || state == inDoubleQuote ) { throw new BuildException ( "unbalanced quotes in " + toProcess ) ; } String [ ] args = new String [ v . size ( ) ] ; v . copyInto ( args ) ; return args ; } public int size ( ) { return getCommandline ( ) . length ; } public Object clone ( ) { try { Commandline c = ( Commandline ) super . clone ( ) ; c . arguments = ( Vector ) arguments . clone ( ) ; return c ; } catch ( CloneNotSupportedException e ) { throw new BuildException ( e ) ; } } public void clear ( ) { executable = null ; arguments . removeAllElements ( ) ; } public void clearArgs ( ) { arguments . removeAllElements ( ) ; } public Marker createMarker ( ) { return new Marker ( arguments . size ( ) ) ; } public String describeCommand ( ) { return describeCommand ( this ) ; } public String describeArguments ( ) { return describeArguments ( this ) ; } public static String describeCommand ( Commandline line ) { return describeCommand ( line . getCommandline ( ) ) ; } public static String describeArguments ( Commandline line ) { return describeArguments ( line . getArguments ( ) ) ; } public static String describeCommand ( String [ ] args ) { if ( args == null || args . length == 0 ) { return "" ; } StringBuffer buf = new StringBuffer ( "Executing \'" ) ; buf . append ( args [ 0 ] ) ; buf . append ( "\'" ) ; if ( args . length > 1 ) { buf . append ( " with " ) ; buf . append ( describeArguments ( args , 1 ) ) ; } else { buf . append ( DISCLAIMER ) ; } return buf . toString ( ) ; } public static String describeArguments ( String [ ] args ) { return describeArguments ( args , 0 ) ; } protected static String describeArguments ( String [ ] args , int offset ) { if ( args == null || args . length <= offset ) { return "" ; } StringBuffer buf = new StringBuffer ( "argument" ) ; if ( args . length > offset ) { buf . append ( "s" ) ; } buf . append ( ":" ) . append ( StringUtils . LINE_SEP ) ; for ( int i = offset ; i < args . length ; i ++ ) { buf . append ( "\'" ) . append ( args [ i ] ) . append ( "\'" ) . append ( StringUtils . LINE_SEP ) ; } buf . append ( DISCLAIMER ) ; return buf . toString ( ) ; } public Iterator iterator ( ) { return arguments . iterator ( ) ; } } 	1	['31', '1', '0', '81', '71', '311', '78', '5', '27', '0.75', '644', '1', '0', '0', '0.176190476', '0', '0', '19.64516129', '16', '2.1935', '2']
package org . apache . tools . ant . taskdefs ; import java . util . Hashtable ; import org . apache . tools . ant . BuildEvent ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . SubBuildListener ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . LogLevel ; public class Recorder extends Task implements SubBuildListener { private String filename = null ; private Boolean append = null ; private Boolean start = null ; private int loglevel = - 1 ; private boolean emacsMode = false ; private static Hashtable recorderEntries = new Hashtable ( ) ; public void init ( ) { getProject ( ) . addBuildListener ( this ) ; } public void setName ( String fname ) { filename = fname ; } public void setAction ( ActionChoices action ) { if ( action . getValue ( ) . equalsIgnoreCase ( "start" ) ) { start = Boolean . TRUE ; } else { start = Boolean . FALSE ; } } public void setAppend ( boolean append ) { this . append = ( append ? Boolean . TRUE : Boolean . FALSE ) ; } public void setEmacsMode ( boolean emacsMode ) { this . emacsMode = emacsMode ; } public void setLoglevel ( VerbosityLevelChoices level ) { loglevel = level . getLevel ( ) ; } public void execute ( ) throws BuildException { if ( filename == null ) { throw new BuildException ( "No filename specified" ) ; } getProject ( ) . log ( "setting a recorder for name " + filename , Project . MSG_DEBUG ) ; RecorderEntry recorder = getRecorder ( filename , getProject ( ) ) ; recorder . setMessageOutputLevel ( loglevel ) ; recorder . setEmacsMode ( emacsMode ) ; if ( start != null ) { if ( start . booleanValue ( ) ) { recorder . reopenFile ( ) ; recorder . setRecordState ( start ) ; } else { recorder . setRecordState ( start ) ; recorder . closeFile ( ) ; } } } public static class ActionChoices extends EnumeratedAttribute { private static final String [ ] VALUES = { "start" , "stop" } ; public String [ ] getValues ( ) { return VALUES ; } } public static class VerbosityLevelChoices extends LogLevel { } protected RecorderEntry getRecorder ( String name , Project proj ) throws BuildException { Object o = recorderEntries . get ( name ) ; RecorderEntry entry ; if ( o == null ) { entry = new RecorderEntry ( name ) ; if ( append == null ) { entry . openFile ( false ) ; } else { entry . openFile ( append . booleanValue ( ) ) ; } entry . setProject ( proj ) ; recorderEntries . put ( name , entry ) ; } else { entry = ( RecorderEntry ) o ; } return entry ; } public void buildStarted ( BuildEvent event ) { } public void subBuildStarted ( BuildEvent event ) { } public void targetStarted ( BuildEvent event ) { } public void targetFinished ( BuildEvent event ) { } public void taskStarted ( BuildEvent event ) { } public void taskFinished ( BuildEvent event ) { } public void messageLogged ( BuildEvent event ) { } public void buildFinished ( BuildEvent event ) { cleanup ( ) ; } public void subBuildFinished ( BuildEvent event ) { if ( event . getProject ( ) == getProject ( ) ) { cleanup ( ) ; } } private void cleanup ( ) { recorderEntries . clear ( ) ; getProject ( ) . removeBuildListener ( this ) ; } } 	1	['20', '3', '0', '9', '46', '160', '0', '9', '17', '0.859649123', '206', '1', '0', '0.672727273', '0.263157895', '1', '1', '9', '2', '1.05', '2']
package org . apache . tools . ant . types . selectors ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . ant . types . selectors . modifiedselector . ModifiedSelector ; public abstract class AbstractSelectorContainer extends DataType implements SelectorContainer { private Vector selectorsList = new Vector ( ) ; public boolean hasSelectors ( ) { return ! ( selectorsList . isEmpty ( ) ) ; } public int selectorCount ( ) { return selectorsList . size ( ) ; } public FileSelector [ ] getSelectors ( Project p ) { FileSelector [ ] result = new FileSelector [ selectorsList . size ( ) ] ; selectorsList . copyInto ( result ) ; return result ; } public Enumeration selectorElements ( ) { return selectorsList . elements ( ) ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; Enumeration e = selectorElements ( ) ; if ( e . hasMoreElements ( ) ) { while ( e . hasMoreElements ( ) ) { buf . append ( e . nextElement ( ) . toString ( ) ) ; if ( e . hasMoreElements ( ) ) { buf . append ( ", " ) ; } } } return buf . toString ( ) ; } public void appendSelector ( FileSelector selector ) { selectorsList . addElement ( selector ) ; } public void validate ( ) { Enumeration e = selectorElements ( ) ; while ( e . hasMoreElements ( ) ) { Object o = e . nextElement ( ) ; if ( o instanceof BaseSelector ) { ( ( BaseSelector ) o ) . validate ( ) ; } } } public void addSelector ( SelectSelector selector ) { appendSelector ( selector ) ; } public void addAnd ( AndSelector selector ) { appendSelector ( selector ) ; } public void addOr ( OrSelector selector ) { appendSelector ( selector ) ; } public void addNot ( NotSelector selector ) { appendSelector ( selector ) ; } public void addNone ( NoneSelector selector ) { appendSelector ( selector ) ; } public void addMajority ( MajoritySelector selector ) { appendSelector ( selector ) ; } public void addDate ( DateSelector selector ) { appendSelector ( selector ) ; } public void addSize ( SizeSelector selector ) { appendSelector ( selector ) ; } public void addFilename ( FilenameSelector selector ) { appendSelector ( selector ) ; } public void addCustom ( ExtendSelector selector ) { appendSelector ( selector ) ; } public void addContains ( ContainsSelector selector ) { appendSelector ( selector ) ; } public void addPresent ( PresentSelector selector ) { appendSelector ( selector ) ; } public void addDepth ( DepthSelector selector ) { appendSelector ( selector ) ; } public void addDepend ( DependSelector selector ) { appendSelector ( selector ) ; } public void addDifferent ( DifferentSelector selector ) { appendSelector ( selector ) ; } public void addType ( TypeSelector selector ) { appendSelector ( selector ) ; } public void addContainsRegexp ( ContainsRegexpSelector selector ) { appendSelector ( selector ) ; } public void addModified ( ModifiedSelector selector ) { appendSelector ( selector ) ; } public void add ( FileSelector selector ) { appendSelector ( selector ) ; } } 	1	['27', '3', '2', '25', '41', '321', '2', '23', '27', '0', '191', '1', '0', '0.535714286', '0.084656085', '0', '0', '6.037037037', '4', '1.1852', '1']
package org . apache . tools . ant . taskdefs . optional . junit ; import java . io . BufferedReader ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileWriter ; import java . io . IOException ; import java . io . OutputStream ; import java . io . PrintStream ; import java . io . PrintWriter ; import java . io . StringReader ; import java . io . StringWriter ; import java . lang . reflect . Method ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Properties ; import java . util . StringTokenizer ; import java . util . Vector ; import junit . framework . AssertionFailedError ; import junit . framework . Test ; import junit . framework . TestFailure ; import junit . framework . TestListener ; import junit . framework . TestResult ; import junit . framework . TestSuite ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Permissions ; import org . apache . tools . ant . util . StringUtils ; import org . apache . tools . ant . util . TeeOutputStream ; public class JUnitTestRunner implements TestListener , JUnitTaskMirror . JUnitTestRunnerMirror { private Vector formatters = new Vector ( ) ; private TestResult res ; private static boolean filtertrace = true ; private boolean showOutput = false ; private boolean outputToFormatters = true ; private Permissions perm = null ; private static final String [ ] DEFAULT_TRACE_FILTERS = new String [ ] { "junit.framework.TestCase" , "junit.framework.TestResult" , "junit.framework.TestSuite" , "junit.framework.Assert." , "junit.swingui.TestRunner" , "junit.awtui.TestRunner" , "junit.textui.TestRunner" , "java.lang.reflect.Method.invoke(" , "sun.reflect." , "org.apache.tools.ant." , "org.junit." , "junit.framework.JUnit4TestAdapter" , "Caused by: java.lang.AssertionError" , " more" , } ; private boolean haltOnError = false ; private boolean haltOnFailure = false ; private int retCode = SUCCESS ; private JUnitTest junitTest ; private PrintStream systemError ; private PrintStream systemOut ; private boolean forked = false ; private static boolean multipleTests = false ; private ClassLoader loader ; private boolean logTestListenerEvents = false ; private boolean junit4 ; private static String crashFile = null ; public JUnitTestRunner ( JUnitTest test , boolean haltOnError , boolean filtertrace , boolean haltOnFailure ) { this ( test , haltOnError , filtertrace , haltOnFailure , false ) ; } public JUnitTestRunner ( JUnitTest test , boolean haltOnError , boolean filtertrace , boolean haltOnFailure , boolean showOutput ) { this ( test , haltOnError , filtertrace , haltOnFailure , showOutput , false ) ; } public JUnitTestRunner ( JUnitTest test , boolean haltOnError , boolean filtertrace , boolean haltOnFailure , boolean showOutput , boolean logTestListenerEvents ) { this ( test , haltOnError , filtertrace , haltOnFailure , showOutput , logTestListenerEvents , null ) ; } public JUnitTestRunner ( JUnitTest test , boolean haltOnError , boolean filtertrace , boolean haltOnFailure , ClassLoader loader ) { this ( test , haltOnError , filtertrace , haltOnFailure , false , loader ) ; } public JUnitTestRunner ( JUnitTest test , boolean haltOnError , boolean filtertrace , boolean haltOnFailure , boolean showOutput , ClassLoader loader ) { this ( test , haltOnError , filtertrace , haltOnFailure , showOutput , false , loader ) ; } public JUnitTestRunner ( JUnitTest test , boolean haltOnError , boolean filtertrace , boolean haltOnFailure , boolean showOutput , boolean logTestListenerEvents , ClassLoader loader ) { JUnitTestRunner . filtertrace = filtertrace ; this . junitTest = test ; this . haltOnError = haltOnError ; this . haltOnFailure = haltOnFailure ; this . showOutput = showOutput ; this . logTestListenerEvents = logTestListenerEvents ; this . loader = loader ; } private PrintStream savedOut = null ; public void run ( ) { res = new TestResult ( ) ; res . addListener ( wrapListener ( this ) ) ; for ( int i = 0 ; i < formatters . size ( ) ; i ++ ) { res . addListener ( wrapListener ( ( TestListener ) formatters . elementAt ( i ) ) ) ; } ByteArrayOutputStream errStrm = new ByteArrayOutputStream ( ) ; systemError = new PrintStream ( errStrm ) ; ByteArrayOutputStream outStrm = new ByteArrayOutputStream ( ) ; systemOut = new PrintStream ( outStrm ) ; PrintStream savedErr = null ; if ( forked ) { if ( ! outputToFormatters ) { if ( ! showOutput ) { savedOut = System . out ; savedErr = System . err ; System . setOut ( new PrintStream ( new OutputStream ( ) { public void write ( int b ) { } } ) ) ; System . setErr ( new PrintStream ( new OutputStream ( ) { public void write ( int b ) { } } ) ) ; } } else { savedOut = System . out ; savedErr = System . err ; if ( ! showOutput ) { System . setOut ( systemOut ) ; System . setErr ( systemError ) ; } else { System . setOut ( new PrintStream ( new TeeOutputStream ( savedOut , systemOut ) ) ) ; System . setErr ( new PrintStream ( new TeeOutputStream ( savedErr , systemError ) ) ) ; } perm = null ; } } else { if ( perm != null ) { perm . setSecurityManager ( ) ; } } Test suite = null ; Throwable exception = null ; boolean startTestSuiteSuccess = false ; try { try { Class testClass = null ; if ( loader == null ) { testClass = Class . forName ( junitTest . getName ( ) ) ; } else { testClass = Class . forName ( junitTest . getName ( ) , true , loader ) ; } Method suiteMethod = null ; try { suiteMethod = testClass . getMethod ( "suite" , new Class [ 0 ] ) ; } catch ( NoSuchMethodException e ) { } if ( suiteMethod != null ) { suite = ( Test ) suiteMethod . invoke ( null , new Class [ 0 ] ) ; } else { Class junit4TestAdapterClass = null ; try { Class . forName ( "java.lang.annotation.Annotation" ) ; if ( loader == null ) { junit4TestAdapterClass = Class . forName ( "junit.framework.JUnit4TestAdapter" ) ; } else { junit4TestAdapterClass = Class . forName ( "junit.framework.JUnit4TestAdapter" , true , loader ) ; } } catch ( ClassNotFoundException e ) { } junit4 = junit4TestAdapterClass != null ; if ( junit4 ) { suite = ( Test ) junit4TestAdapterClass . getConstructor ( new Class [ ] { Class . class } ) . newInstance ( new Object [ ] { testClass } ) ; } else { suite = new TestSuite ( testClass ) ; } } } catch ( Throwable e ) { retCode = ERRORS ; exception = e ; } long start = System . currentTimeMillis ( ) ; fireStartTestSuite ( ) ; startTestSuiteSuccess = true ; if ( exception != null ) { for ( int i = 0 ; i < formatters . size ( ) ; i ++ ) { ( ( TestListener ) formatters . elementAt ( i ) ) . addError ( null , exception ) ; } junitTest . setCounts ( 1 , 0 , 1 ) ; junitTest . setRunTime ( 0 ) ; } else { try { logTestListenerEvent ( "tests to run: " + suite . countTestCases ( ) ) ; suite . run ( res ) ; } finally { if ( junit4 ) { int [ ] cnts = findJUnit4FailureErrorCount ( res ) ; junitTest . setCounts ( res . runCount ( ) , cnts [ 0 ] , cnts [ 1 ] ) ; } else { junitTest . setCounts ( res . runCount ( ) , res . failureCount ( ) , res . errorCount ( ) ) ; } junitTest . setRunTime ( System . currentTimeMillis ( ) - start ) ; } } } finally { if ( perm != null ) { perm . restoreSecurityManager ( ) ; } if ( savedOut != null ) { System . setOut ( savedOut ) ; } if ( savedErr != null ) { System . setErr ( savedErr ) ; } systemError . close ( ) ; systemError = null ; systemOut . close ( ) ; systemOut = null ; if ( startTestSuiteSuccess ) { sendOutAndErr ( new String ( outStrm . toByteArray ( ) ) , new String ( errStrm . toByteArray ( ) ) ) ; } } fireEndTestSuite ( ) ; if ( retCode != SUCCESS || res . errorCount ( ) != 0 ) { retCode = ERRORS ; } else if ( res . failureCount ( ) != 0 ) { retCode = FAILURES ; } } public int getRetCode ( ) { return retCode ; } public void startTest ( Test t ) { String testName = JUnitVersionHelper . getTestCaseName ( t ) ; logTestListenerEvent ( "startTest(" + testName + ")" ) ; } public void endTest ( Test test ) { String testName = JUnitVersionHelper . getTestCaseName ( test ) ; logTestListenerEvent ( "endTest(" + testName + ")" ) ; } private void logTestListenerEvent ( String msg ) { PrintStream out = savedOut != null ? savedOut : System . out ; if ( logTestListenerEvents ) { out . flush ( ) ; out . println ( JUnitTask . TESTLISTENER_PREFIX + msg ) ; out . flush ( ) ; } } public void addFailure ( Test test , Throwable t ) { String testName = JUnitVersionHelper . getTestCaseName ( test ) ; logTestListenerEvent ( "addFailure(" + testName + ", " + t . getMessage ( ) + ")" ) ; if ( haltOnFailure ) { res . stop ( ) ; } } public void addFailure ( Test test , AssertionFailedError t ) { addFailure ( test , ( Throwable ) t ) ; } public void addError ( Test test , Throwable t ) { String testName = JUnitVersionHelper . getTestCaseName ( test ) ; logTestListenerEvent ( "addError(" + testName + ", " + t . getMessage ( ) + ")" ) ; if ( haltOnError ) { res . stop ( ) ; } } public void setPermissions ( Permissions permissions ) { perm = permissions ; } public void handleOutput ( String output ) { if ( ! logTestListenerEvents && output . startsWith ( JUnitTask . TESTLISTENER_PREFIX ) ) { } else if ( systemOut != null ) { systemOut . print ( output ) ; } } public int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException { return - 1 ; } public void handleErrorOutput ( String output ) { if ( systemError != null ) { systemError . print ( output ) ; } } public void handleFlush ( String output ) { if ( systemOut != null ) { systemOut . print ( output ) ; } } public void handleErrorFlush ( String output ) { if ( systemError != null ) { systemError . print ( output ) ; } } private void sendOutAndErr ( String out , String err ) { for ( int i = 0 ; i < formatters . size ( ) ; i ++ ) { JUnitResultFormatter formatter = ( ( JUnitResultFormatter ) formatters . elementAt ( i ) ) ; formatter . setSystemOutput ( out ) ; formatter . setSystemError ( err ) ; } } private void fireStartTestSuite ( ) { for ( int i = 0 ; i < formatters . size ( ) ; i ++ ) { ( ( JUnitResultFormatter ) formatters . elementAt ( i ) ) . startTestSuite ( junitTest ) ; } } private void fireEndTestSuite ( ) { for ( int i = 0 ; i < formatters . size ( ) ; i ++ ) { ( ( JUnitResultFormatter ) formatters . elementAt ( i ) ) . endTestSuite ( junitTest ) ; } } public void addFormatter ( JUnitResultFormatter f ) { formatters . addElement ( f ) ; } public void addFormatter ( JUnitTaskMirror . JUnitResultFormatterMirror f ) { formatters . addElement ( ( JUnitResultFormatter ) f ) ; } public static void main ( String [ ] args ) throws IOException { boolean haltError = false ; boolean haltFail = false ; boolean stackfilter = true ; Properties props = new Properties ( ) ; boolean showOut = false ; boolean outputToFormat = true ; boolean logTestListenerEvents = false ; if ( args . length == 0 ) { System . err . println ( "required argument TestClassName missing" ) ; System . exit ( ERRORS ) ; } if ( args [ 0 ] . startsWith ( Constants . TESTSFILE ) ) { multipleTests = true ; args [ 0 ] = args [ 0 ] . substring ( Constants . TESTSFILE . length ( ) ) ; } for ( int i = 1 ; i < args . length ; i ++ ) { if ( args [ i ] . startsWith ( Constants . HALT_ON_ERROR ) ) { haltError = Project . toBoolean ( args [ i ] . substring ( Constants . HALT_ON_ERROR . length ( ) ) ) ; } else if ( args [ i ] . startsWith ( Constants . HALT_ON_FAILURE ) ) { haltFail = Project . toBoolean ( args [ i ] . substring ( Constants . HALT_ON_FAILURE . length ( ) ) ) ; } else if ( args [ i ] . startsWith ( Constants . FILTERTRACE ) ) { stackfilter = Project . toBoolean ( args [ i ] . substring ( Constants . FILTERTRACE . length ( ) ) ) ; } else if ( args [ i ] . startsWith ( Constants . CRASHFILE ) ) { crashFile = args [ i ] . substring ( Constants . CRASHFILE . length ( ) ) ; registerTestCase ( Constants . BEFORE_FIRST_TEST ) ; } else if ( args [ i ] . startsWith ( Constants . FORMATTER ) ) { try { createAndStoreFormatter ( args [ i ] . substring ( Constants . FORMATTER . length ( ) ) ) ; } catch ( BuildException be ) { System . err . println ( be . getMessage ( ) ) ; System . exit ( ERRORS ) ; } } else if ( args [ i ] . startsWith ( Constants . PROPSFILE ) ) { FileInputStream in = new FileInputStream ( args [ i ] . substring ( Constants . PROPSFILE . length ( ) ) ) ; props . load ( in ) ; in . close ( ) ; } else if ( args [ i ] . startsWith ( Constants . SHOWOUTPUT ) ) { showOut = Project . toBoolean ( args [ i ] . substring ( Constants . SHOWOUTPUT . length ( ) ) ) ; } else if ( args [ i ] . startsWith ( Constants . LOGTESTLISTENEREVENTS ) ) { logTestListenerEvents = Project . toBoolean ( args [ i ] . substring ( Constants . LOGTESTLISTENEREVENTS . length ( ) ) ) ; } else if ( args [ i ] . startsWith ( Constants . OUTPUT_TO_FORMATTERS ) ) { outputToFormat = Project . toBoolean ( args [ i ] . substring ( Constants . OUTPUT_TO_FORMATTERS . length ( ) ) ) ; } } Hashtable p = System . getProperties ( ) ; for ( Enumeration e = p . keys ( ) ; e . hasMoreElements ( ) ; ) { Object key = e . nextElement ( ) ; props . put ( key , p . get ( key ) ) ; } int returnCode = SUCCESS ; if ( multipleTests ) { try { java . io . BufferedReader reader = new java . io . BufferedReader ( new java . io . FileReader ( args [ 0 ] ) ) ; String testCaseName ; int code = 0 ; boolean errorOccurred = false ; boolean failureOccurred = false ; String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { StringTokenizer st = new StringTokenizer ( line , "," ) ; testCaseName = st . nextToken ( ) ; JUnitTest t = new JUnitTest ( testCaseName ) ; t . setTodir ( new File ( st . nextToken ( ) ) ) ; t . setOutfile ( st . nextToken ( ) ) ; code = launch ( t , haltError , stackfilter , haltFail , showOut , outputToFormat , logTestListenerEvents , props ) ; errorOccurred = ( code == ERRORS ) ; failureOccurred = ( code != SUCCESS ) ; if ( errorOccurred || failureOccurred ) { if ( ( errorOccurred && haltError ) || ( failureOccurred && haltFail ) ) { registerNonCrash ( ) ; System . exit ( code ) ; } else { if ( code > returnCode ) { returnCode = code ; } System . out . println ( "TEST " + t . getName ( ) + " FAILED" ) ; } } } } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { returnCode = launch ( new JUnitTest ( args [ 0 ] ) , haltError , stackfilter , haltFail , showOut , outputToFormat , logTestListenerEvents , props ) ; } registerNonCrash ( ) ; System . exit ( returnCode ) ; } private static Vector fromCmdLine = new Vector ( ) ; private static void transferFormatters ( JUnitTestRunner runner , JUnitTest test ) { runner . addFormatter ( new JUnitResultFormatter ( ) { public void startTestSuite ( JUnitTest suite ) throws BuildException { } public void endTestSuite ( JUnitTest suite ) throws BuildException { } public void setOutput ( OutputStream out ) { } public void setSystemOutput ( String out ) { } public void setSystemError ( String err ) { } public void addError ( Test arg0 , Throwable arg1 ) { } public void addFailure ( Test arg0 , AssertionFailedError arg1 ) { } public void endTest ( Test arg0 ) { } public void startTest ( Test arg0 ) { registerTestCase ( JUnitVersionHelper . getTestCaseName ( arg0 ) ) ; } } ) ; for ( int i = 0 ; i < fromCmdLine . size ( ) ; i ++ ) { FormatterElement fe = ( FormatterElement ) fromCmdLine . elementAt ( i ) ; if ( multipleTests && fe . getUseFile ( ) ) { File destFile = new File ( test . getTodir ( ) , test . getOutfile ( ) + fe . getExtension ( ) ) ; fe . setOutfile ( destFile ) ; } runner . addFormatter ( ( JUnitResultFormatter ) fe . createFormatter ( ) ) ; } } private static void createAndStoreFormatter ( String line ) throws BuildException { FormatterElement fe = new FormatterElement ( ) ; int pos = line . indexOf ( ',' ) ; if ( pos == - 1 ) { fe . setClassname ( line ) ; fe . setUseFile ( false ) ; } else { fe . setClassname ( line . substring ( 0 , pos ) ) ; fe . setUseFile ( true ) ; if ( ! multipleTests ) { fe . setOutfile ( new File ( line . substring ( pos + 1 ) ) ) ; } else { int fName = line . indexOf ( IGNORED_FILE_NAME ) ; if ( fName > - 1 ) { fe . setExtension ( line . substring ( fName + IGNORED_FILE_NAME . length ( ) ) ) ; } } } fromCmdLine . addElement ( fe ) ; } public static String getFilteredTrace ( Throwable t ) { String trace = StringUtils . getStackTrace ( t ) ; return JUnitTestRunner . filterStack ( trace ) ; } public static String filterStack ( String stack ) { if ( ! filtertrace ) { return stack ; } StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; StringReader sr = new StringReader ( stack ) ; BufferedReader br = new BufferedReader ( sr ) ; String line ; try { while ( ( line = br . readLine ( ) ) != null ) { if ( ! filterLine ( line ) ) { pw . println ( line ) ; } } } catch ( Exception e ) { return stack ; } return sw . toString ( ) ; } private static boolean filterLine ( String line ) { for ( int i = 0 ; i < DEFAULT_TRACE_FILTERS . length ; i ++ ) { if ( line . indexOf ( DEFAULT_TRACE_FILTERS [ i ] ) != - 1 ) { return true ; } } return false ; } private static int launch ( JUnitTest t , boolean haltError , boolean stackfilter , boolean haltFail , boolean showOut , boolean outputToFormat , boolean logTestListenerEvents , Properties props ) { t . setProperties ( props ) ; JUnitTestRunner runner = new JUnitTestRunner ( t , haltError , stackfilter , haltFail , showOut , logTestListenerEvents , null ) ; runner . forked = true ; runner . outputToFormatters = outputToFormat ; transferFormatters ( runner , t ) ; runner . run ( ) ; return runner . getRetCode ( ) ; } private static void registerNonCrash ( ) throws IOException { if ( crashFile != null ) { FileWriter out = null ; try { out = new FileWriter ( crashFile ) ; out . write ( Constants . TERMINATED_SUCCESSFULLY + "\n" ) ; out . flush ( ) ; } finally { if ( out != null ) { out . close ( ) ; } } } } private static void registerTestCase ( String testCase ) { if ( crashFile != null ) { try { FileWriter out = null ; try { out = new FileWriter ( crashFile ) ; out . write ( testCase + "\n" ) ; out . flush ( ) ; } finally { if ( out != null ) { out . close ( ) ; } } } catch ( IOException e ) { } } } private TestListener wrapListener ( final TestListener testListener ) { return new TestListener ( ) { public void addError ( Test test , Throwable t ) { if ( junit4 && t instanceof AssertionFailedError ) { testListener . addFailure ( test , ( AssertionFailedError ) t ) ; } else if ( junit4 && t . getClass ( ) . getName ( ) . equals ( "java.lang.AssertionError" ) ) { try { String msg = t . getMessage ( ) ; AssertionFailedError failure = msg != null ? new AssertionFailedError ( msg ) : new AssertionFailedError ( ) ; Method initCause = Throwable . class . getMethod ( "initCause" , new Class [ ] { Throwable . class } ) ; initCause . invoke ( failure , new Object [ ] { t } ) ; testListener . addFailure ( test , failure ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; testListener . addError ( test , t ) ; } } else { testListener . addError ( test , t ) ; } } public void addFailure ( Test test , AssertionFailedError t ) { testListener . addFailure ( test , t ) ; } public void addFailure ( Test test , Throwable t ) { if ( t instanceof AssertionFailedError ) { testListener . addFailure ( test , ( AssertionFailedError ) t ) ; } else { testListener . addError ( test , t ) ; } } public void endTest ( Test test ) { testListener . endTest ( test ) ; } public void startTest ( Test test ) { testListener . startTest ( test ) ; } } ; } private int [ ] findJUnit4FailureErrorCount ( TestResult res ) { int failures = 0 ; int errors = 0 ; Enumeration e = res . failures ( ) ; while ( e . hasMoreElements ( ) ) { e . nextElement ( ) ; failures ++ ; } e = res . errors ( ) ; while ( e . hasMoreElements ( ) ) { Throwable t = ( ( TestFailure ) e . nextElement ( ) ) . thrownException ( ) ; if ( t instanceof AssertionFailedError || t . getClass ( ) . getName ( ) . equals ( "java.lang.AssertionError" ) ) { failures ++ ; } else { errors ++ ; } } return new int [ ] { failures , errors } ; } } 	1	['39', '1', '0', '25', '150', '625', '8', '21', '24', '0.878718535', '1561', '0.913043478', '1', '0', '0.111111111', '0', '0', '38.43589744', '27', '2.2308', '6']
package org . apache . tools . ant . taskdefs ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . UnsupportedEncodingException ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . Reader ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . Enumeration ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . StringTokenizer ; import java . util . TreeMap ; import java . util . Vector ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . ZipFileSet ; import org . apache . tools . ant . types . spi . Service ; import org . apache . tools . zip . JarMarker ; import org . apache . tools . zip . ZipExtraField ; import org . apache . tools . zip . ZipOutputStream ; public class Jar extends Zip { private static final String INDEX_NAME = "META-INF/INDEX.LIST" ; private static final String MANIFEST_NAME = "META-INF/MANIFEST.MF" ; private List serviceList = new ArrayList ( ) ; private Manifest configuredManifest ; private Manifest savedConfiguredManifest ; private Manifest filesetManifest ; private Manifest originalManifest ; private FilesetManifestConfig filesetManifestConfig ; private boolean mergeManifestsMain = true ; private Manifest manifest ; private String manifestEncoding ; private File manifestFile ; private boolean index = false ; private boolean createEmpty = false ; private Vector rootEntries ; private Path indexJars ; private static final ZipExtraField [ ] JAR_MARKER = new ZipExtraField [ ] { JarMarker . getInstance ( ) } ; protected String emptyBehavior = "create" ; public Jar ( ) { super ( ) ; archiveType = "jar" ; emptyBehavior = "create" ; setEncoding ( "UTF8" ) ; rootEntries = new Vector ( ) ; } public void setWhenempty ( WhenEmpty we ) { log ( "JARs are never empty, they contain at least a manifest file" , Project . MSG_WARN ) ; } public void setWhenmanifestonly ( WhenEmpty we ) { emptyBehavior = we . getValue ( ) ; } public void setJarfile ( File jarFile ) { setDestFile ( jarFile ) ; } public void setIndex ( boolean flag ) { index = flag ; } public void setManifestEncoding ( String manifestEncoding ) { this . manifestEncoding = manifestEncoding ; } public void addConfiguredManifest ( Manifest newManifest ) throws ManifestException { if ( configuredManifest == null ) { configuredManifest = newManifest ; } else { configuredManifest . merge ( newManifest ) ; } savedConfiguredManifest = configuredManifest ; } public void setManifest ( File manifestFile ) { if ( ! manifestFile . exists ( ) ) { throw new BuildException ( "Manifest file: " + manifestFile + " does not exist." , getLocation ( ) ) ; } this . manifestFile = manifestFile ; } private Manifest getManifest ( File manifestFile ) { Manifest newManifest = null ; FileInputStream fis = null ; InputStreamReader isr = null ; try { fis = new FileInputStream ( manifestFile ) ; if ( manifestEncoding == null ) { isr = new InputStreamReader ( fis ) ; } else { isr = new InputStreamReader ( fis , manifestEncoding ) ; } newManifest = getManifest ( isr ) ; } catch ( UnsupportedEncodingException e ) { throw new BuildException ( "Unsupported encoding while reading manifest: " + e . getMessage ( ) , e ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to read manifest file: " + manifestFile + " (" + e . getMessage ( ) + ")" , e ) ; } finally { if ( isr != null ) { try { isr . close ( ) ; } catch ( IOException e ) { } } } return newManifest ; } private Manifest getManifestFromJar ( File jarFile ) throws IOException { ZipFile zf = null ; try { zf = new ZipFile ( jarFile ) ; Enumeration e = zf . entries ( ) ; while ( e . hasMoreElements ( ) ) { ZipEntry ze = ( ZipEntry ) e . nextElement ( ) ; if ( ze . getName ( ) . equalsIgnoreCase ( MANIFEST_NAME ) ) { InputStreamReader isr = new InputStreamReader ( zf . getInputStream ( ze ) , "UTF-8" ) ; return getManifest ( isr ) ; } } return null ; } finally { if ( zf != null ) { try { zf . close ( ) ; } catch ( IOException e ) { } } } } private Manifest getManifest ( Reader r ) { Manifest newManifest = null ; try { newManifest = new Manifest ( r ) ; } catch ( ManifestException e ) { log ( "Manifest is invalid: " + e . getMessage ( ) , Project . MSG_ERR ) ; throw new BuildException ( "Invalid Manifest: " + manifestFile , e , getLocation ( ) ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to read manifest file" + " (" + e . getMessage ( ) + ")" , e ) ; } return newManifest ; } public void setFilesetmanifest ( FilesetManifestConfig config ) { filesetManifestConfig = config ; mergeManifestsMain = "merge" . equals ( config . getValue ( ) ) ; if ( filesetManifestConfig != null && ! filesetManifestConfig . getValue ( ) . equals ( "skip" ) ) { doubleFilePass = true ; } } public void addMetainf ( ZipFileSet fs ) { fs . setPrefix ( "META-INF/" ) ; super . addFileset ( fs ) ; } public void addConfiguredIndexJars ( Path p ) { if ( indexJars == null ) { indexJars = new Path ( getProject ( ) ) ; } indexJars . append ( p ) ; } public void addConfiguredService ( Service service ) { service . check ( ) ; serviceList . add ( service ) ; } private void writeServices ( ZipOutputStream zOut ) throws IOException { Iterator serviceIterator ; Service service ; serviceIterator = serviceList . iterator ( ) ; while ( serviceIterator . hasNext ( ) ) { service = ( Service ) serviceIterator . next ( ) ; super . zipFile ( service . getAsStream ( ) , zOut , "META-INF/service/" + service . getType ( ) , System . currentTimeMillis ( ) , null , ZipFileSet . DEFAULT_FILE_MODE ) ; } } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( ! skipWriting ) { Manifest jarManifest = createManifest ( ) ; writeManifest ( zOut , jarManifest ) ; writeServices ( zOut ) ; } } private Manifest createManifest ( ) throws BuildException { try { Manifest finalManifest = Manifest . getDefaultManifest ( ) ; if ( manifest == null ) { if ( manifestFile != null ) { manifest = getManifest ( manifestFile ) ; } } if ( isInUpdateMode ( ) ) { finalManifest . merge ( originalManifest ) ; } finalManifest . merge ( filesetManifest ) ; finalManifest . merge ( configuredManifest ) ; finalManifest . merge ( manifest , ! mergeManifestsMain ) ; return finalManifest ; } catch ( ManifestException e ) { log ( "Manifest is invalid: " + e . getMessage ( ) , Project . MSG_ERR ) ; throw new BuildException ( "Invalid Manifest" , e , getLocation ( ) ) ; } } private void writeManifest ( ZipOutputStream zOut , Manifest manifest ) throws IOException { for ( Enumeration e = manifest . getWarnings ( ) ; e . hasMoreElements ( ) ; ) { log ( "Manifest warning: " + ( String ) e . nextElement ( ) , Project . MSG_WARN ) ; } zipDir ( null , zOut , "META-INF/" , ZipFileSet . DEFAULT_DIR_MODE , JAR_MARKER ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; OutputStreamWriter osw = new OutputStreamWriter ( baos , Manifest . JAR_ENCODING ) ; PrintWriter writer = new PrintWriter ( osw ) ; manifest . write ( writer ) ; writer . flush ( ) ; ByteArrayInputStream bais = new ByteArrayInputStream ( baos . toByteArray ( ) ) ; super . zipFile ( bais , zOut , MANIFEST_NAME , System . currentTimeMillis ( ) , null , ZipFileSet . DEFAULT_FILE_MODE ) ; super . initZipOutputStream ( zOut ) ; } protected void finalizeZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( index ) { createIndexList ( zOut ) ; } } private void createIndexList ( ZipOutputStream zOut ) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; PrintWriter writer = new PrintWriter ( new OutputStreamWriter ( baos , "UTF8" ) ) ; writer . println ( "JarIndex-Version: 1.0" ) ; writer . println ( ) ; writer . println ( zipFile . getName ( ) ) ; writeIndexLikeList ( new ArrayList ( addedDirs . keySet ( ) ) , rootEntries , writer ) ; writer . println ( ) ; if ( indexJars != null ) { Manifest mf = createManifest ( ) ; Manifest . Attribute classpath = mf . getMainSection ( ) . getAttribute ( Manifest . ATTRIBUTE_CLASSPATH ) ; String [ ] cpEntries = null ; if ( classpath != null && classpath . getValue ( ) != null ) { StringTokenizer tok = new StringTokenizer ( classpath . getValue ( ) , " " ) ; cpEntries = new String [ tok . countTokens ( ) ] ; int c = 0 ; while ( tok . hasMoreTokens ( ) ) { cpEntries [ c ++ ] = tok . nextToken ( ) ; } } String [ ] indexJarEntries = indexJars . list ( ) ; for ( int i = 0 ; i < indexJarEntries . length ; i ++ ) { String name = findJarName ( indexJarEntries [ i ] , cpEntries ) ; if ( name != null ) { ArrayList dirs = new ArrayList ( ) ; ArrayList files = new ArrayList ( ) ; grabFilesAndDirs ( indexJarEntries [ i ] , dirs , files ) ; if ( dirs . size ( ) + files . size ( ) > 0 ) { writer . println ( name ) ; writeIndexLikeList ( dirs , files , writer ) ; writer . println ( ) ; } } } } writer . flush ( ) ; ByteArrayInputStream bais = new ByteArrayInputStream ( baos . toByteArray ( ) ) ; super . zipFile ( bais , zOut , INDEX_NAME , System . currentTimeMillis ( ) , null , ZipFileSet . DEFAULT_FILE_MODE ) ; } protected void zipFile ( InputStream is , ZipOutputStream zOut , String vPath , long lastModified , File fromArchive , int mode ) throws IOException { if ( MANIFEST_NAME . equalsIgnoreCase ( vPath ) ) { if ( ! doubleFilePass || ( doubleFilePass && skipWriting ) ) { filesetManifest ( fromArchive , is ) ; } } else if ( INDEX_NAME . equalsIgnoreCase ( vPath ) && index ) { log ( "Warning: selected " + archiveType + " files include a META-INF/INDEX.LIST which will" + " be replaced by a newly generated one." , Project . MSG_WARN ) ; } else { if ( index && vPath . indexOf ( "/" ) == - 1 ) { rootEntries . addElement ( vPath ) ; } super . zipFile ( is , zOut , vPath , lastModified , fromArchive , mode ) ; } } private void filesetManifest ( File file , InputStream is ) throws IOException { if ( manifestFile != null && manifestFile . equals ( file ) ) { log ( "Found manifest " + file , Project . MSG_VERBOSE ) ; try { if ( is != null ) { InputStreamReader isr ; if ( manifestEncoding == null ) { isr = new InputStreamReader ( is ) ; } else { isr = new InputStreamReader ( is , manifestEncoding ) ; } manifest = getManifest ( isr ) ; } else { manifest = getManifest ( file ) ; } } catch ( UnsupportedEncodingException e ) { throw new BuildException ( "Unsupported encoding while reading " + "manifest: " + e . getMessage ( ) , e ) ; } } else if ( filesetManifestConfig != null && ! filesetManifestConfig . getValue ( ) . equals ( "skip" ) ) { log ( "Found manifest to merge in file " + file , Project . MSG_VERBOSE ) ; try { Manifest newManifest = null ; if ( is != null ) { InputStreamReader isr ; if ( manifestEncoding == null ) { isr = new InputStreamReader ( is ) ; } else { isr = new InputStreamReader ( is , manifestEncoding ) ; } newManifest = getManifest ( isr ) ; } else { newManifest = getManifest ( file ) ; } if ( filesetManifest == null ) { filesetManifest = newManifest ; } else { filesetManifest . merge ( newManifest ) ; } } catch ( UnsupportedEncodingException e ) { throw new BuildException ( "Unsupported encoding while reading " + "manifest: " + e . getMessage ( ) , e ) ; } catch ( ManifestException e ) { log ( "Manifest in file " + file + " is invalid: " + e . getMessage ( ) , Project . MSG_ERR ) ; throw new BuildException ( "Invalid Manifest" , e , getLocation ( ) ) ; } } else { } } protected ArchiveState getResourcesToAdd ( ResourceCollection [ ] rcs , File zipFile , boolean needsUpdate ) throws BuildException { if ( zipFile . exists ( ) ) { try { originalManifest = getManifestFromJar ( zipFile ) ; if ( originalManifest == null ) { log ( "Updating jar since the current jar has no manifest" , Project . MSG_VERBOSE ) ; needsUpdate = true ; } else { Manifest mf = createManifest ( ) ; if ( ! mf . equals ( originalManifest ) ) { log ( "Updating jar since jar manifest has changed" , Project . MSG_VERBOSE ) ; needsUpdate = true ; } } } catch ( Throwable t ) { log ( "error while reading original manifest in file: " + zipFile . toString ( ) + t . getMessage ( ) , Project . MSG_WARN ) ; needsUpdate = true ; } } else { needsUpdate = true ; } createEmpty = needsUpdate ; return super . getResourcesToAdd ( rcs , zipFile , needsUpdate ) ; } protected boolean createEmptyZip ( File zipFile ) throws BuildException { if ( ! createEmpty ) { return true ; } if ( emptyBehavior . equals ( "skip" ) ) { log ( "Warning: skipping " + archiveType + " archive " + zipFile + " because no files were included." , Project . MSG_WARN ) ; return true ; } else if ( emptyBehavior . equals ( "fail" ) ) { throw new BuildException ( "Cannot create " + archiveType + " archive " + zipFile + ": no files were included." , getLocation ( ) ) ; } ZipOutputStream zOut = null ; try { log ( "Building MANIFEST-only jar: " + getDestFile ( ) . getAbsolutePath ( ) ) ; zOut = new ZipOutputStream ( new FileOutputStream ( getDestFile ( ) ) ) ; zOut . setEncoding ( getEncoding ( ) ) ; if ( isCompress ( ) ) { zOut . setMethod ( ZipOutputStream . DEFLATED ) ; } else { zOut . setMethod ( ZipOutputStream . STORED ) ; } initZipOutputStream ( zOut ) ; finalizeZipOutputStream ( zOut ) ; } catch ( IOException ioe ) { throw new BuildException ( "Could not create almost empty JAR archive" + " (" + ioe . getMessage ( ) + ")" , ioe , getLocation ( ) ) ; } finally { try { if ( zOut != null ) { zOut . close ( ) ; } } catch ( IOException ex ) { } createEmpty = false ; } return true ; } protected void cleanUp ( ) { super . cleanUp ( ) ; if ( ! doubleFilePass || ( doubleFilePass && ! skipWriting ) ) { manifest = null ; configuredManifest = savedConfiguredManifest ; filesetManifest = null ; originalManifest = null ; } rootEntries . removeAllElements ( ) ; } public void reset ( ) { super . reset ( ) ; emptyBehavior = "create" ; configuredManifest = null ; filesetManifestConfig = null ; mergeManifestsMain = false ; manifestFile = null ; index = false ; } public static class FilesetManifestConfig extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "skip" , "merge" , "mergewithoutmain" } ; } } protected final void writeIndexLikeList ( List dirs , List files , PrintWriter writer ) throws IOException { Collections . sort ( dirs ) ; Collections . sort ( files ) ; Iterator iter = dirs . iterator ( ) ; while ( iter . hasNext ( ) ) { String dir = ( String ) iter . next ( ) ; dir = dir . replace ( '\\' , '/' ) ; if ( dir . startsWith ( "./" ) ) { dir = dir . substring ( 2 ) ; } while ( dir . startsWith ( "/" ) ) { dir = dir . substring ( 1 ) ; } int pos = dir . lastIndexOf ( '/' ) ; if ( pos != - 1 ) { dir = dir . substring ( 0 , pos ) ; } if ( dir . startsWith ( "META-INF" ) ) { continue ; } writer . println ( dir ) ; } iter = files . iterator ( ) ; while ( iter . hasNext ( ) ) { writer . println ( iter . next ( ) ) ; } } protected static final String findJarName ( String fileName , String [ ] classpath ) { if ( classpath == null ) { return ( new File ( fileName ) ) . getName ( ) ; } fileName = fileName . replace ( File . separatorChar , '/' ) ; TreeMap matches = new TreeMap ( new Comparator ( ) { public int compare ( Object o1 , Object o2 ) { if ( o1 instanceof String && o2 instanceof String ) { return ( ( String ) o2 ) . length ( ) - ( ( String ) o1 ) . length ( ) ; } return 0 ; } } ) ; for ( int i = 0 ; i < classpath . length ; i ++ ) { if ( fileName . endsWith ( classpath [ i ] ) ) { matches . put ( classpath [ i ] , classpath [ i ] ) ; } else { int slash = classpath [ i ] . indexOf ( "/" ) ; String candidate = classpath [ i ] ; while ( slash > - 1 ) { candidate = candidate . substring ( slash + 1 ) ; if ( fileName . endsWith ( candidate ) ) { matches . put ( candidate , classpath [ i ] ) ; break ; } slash = candidate . indexOf ( "/" ) ; } } } return matches . size ( ) == 0 ? null : ( String ) matches . get ( matches . firstKey ( ) ) ; } protected static final void grabFilesAndDirs ( String file , List dirs , List files ) throws IOException { org . apache . tools . zip . ZipFile zf = null ; try { zf = new org . apache . tools . zip . ZipFile ( file , "utf-8" ) ; Enumeration entries = zf . getEntries ( ) ; HashSet dirSet = new HashSet ( ) ; while ( entries . hasMoreElements ( ) ) { org . apache . tools . zip . ZipEntry ze = ( org . apache . tools . zip . ZipEntry ) entries . nextElement ( ) ; String name = ze . getName ( ) ; if ( ! name . startsWith ( "META-INF/" ) ) { if ( ze . isDirectory ( ) ) { dirSet . add ( name ) ; } else if ( name . indexOf ( "/" ) == - 1 ) { files . add ( name ) ; } else { dirSet . add ( name . substring ( 0 , name . lastIndexOf ( "/" ) + 1 ) ) ; } } } dirs . addAll ( dirSet ) ; } finally { if ( zf != null ) { zf . close ( ) ; } } } } 	1	['31', '5', '2', '24', '152', '349', '2', '22', '13', '0.857407407', '1413', '1', '8', '0.811688312', '0.115789474', '4', '16', '44', '7', '1.4839', '6']
package org . apache . tools . zip ; public final class ZipLong implements Cloneable { private long value ; public ZipLong ( long value ) { this . value = value ; } public ZipLong ( byte [ ] bytes ) { this ( bytes , 0 ) ; } public ZipLong ( byte [ ] bytes , int offset ) { value = ZipLong . getValue ( bytes , offset ) ; } public byte [ ] getBytes ( ) { return ZipLong . getBytes ( value ) ; } public long getValue ( ) { return value ; } public static byte [ ] getBytes ( long value ) { byte [ ] result = new byte [ 4 ] ; result [ 0 ] = ( byte ) ( ( value & 0xFF ) ) ; result [ 1 ] = ( byte ) ( ( value & 0xFF00 ) > > 8 ) ; result [ 2 ] = ( byte ) ( ( value & 0xFF0000 ) > > 16 ) ; result [ 3 ] = ( byte ) ( ( value & 0xFF000000L ) > > 24 ) ; return result ; } public static long getValue ( byte [ ] bytes , int offset ) { long value = ( bytes [ offset + 3 ] << 24 ) & 0xFF000000L ; value += ( bytes [ offset + 2 ] << 16 ) & 0xFF0000 ; value += ( bytes [ offset + 1 ] << 8 ) & 0xFF00 ; value += ( bytes [ offset ] & 0xFF ) ; return value ; } public static long getValue ( byte [ ] bytes ) { return getValue ( bytes , 0 ) ; } public boolean equals ( Object o ) { if ( o == null || ! ( o instanceof ZipLong ) ) { return false ; } return value == ( ( ZipLong ) o ) . getValue ( ) ; } public int hashCode ( ) { return ( int ) value ; } } 	1	['10', '1', '0', '3', '11', '15', '3', '0', '10', '0.333333333', '154', '1', '0', '0', '0.32', '1', '1', '14.3', '4', '1', '1']
package org . apache . tools . ant . types . resources ; import java . io . File ; import java . util . List ; import java . util . Stack ; import java . util . Iterator ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . ant . types . ResourceCollection ; public abstract class BaseResourceCollectionContainer extends DataType implements ResourceCollection , Cloneable { private List rc = new ArrayList ( ) ; private Collection coll = null ; private boolean cache = true ; public synchronized void setCache ( boolean b ) { cache = b ; } public synchronized boolean isCache ( ) { return cache ; } public synchronized void clear ( ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } rc . clear ( ) ; FailFast . invalidate ( this ) ; coll = null ; setChecked ( false ) ; } public synchronized void add ( ResourceCollection c ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( c == null ) { return ; } rc . add ( c ) ; FailFast . invalidate ( this ) ; coll = null ; setChecked ( false ) ; } public synchronized void addAll ( Collection c ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } try { for ( Iterator i = c . iterator ( ) ; i . hasNext ( ) ; ) { add ( ( ResourceCollection ) i . next ( ) ) ; } } catch ( ClassCastException e ) { throw new BuildException ( e ) ; } } public final synchronized Iterator iterator ( ) { if ( isReference ( ) ) { return ( ( BaseResourceCollectionContainer ) getCheckedRef ( ) ) . iterator ( ) ; } dieOnCircularReference ( ) ; return new FailFast ( this , cacheCollection ( ) . iterator ( ) ) ; } public synchronized int size ( ) { if ( isReference ( ) ) { return ( ( BaseResourceCollectionContainer ) getCheckedRef ( ) ) . size ( ) ; } dieOnCircularReference ( ) ; return cacheCollection ( ) . size ( ) ; } public synchronized boolean isFilesystemOnly ( ) { if ( isReference ( ) ) { return ( ( BaseResourceCollectionContainer ) getCheckedRef ( ) ) . isFilesystemOnly ( ) ; } dieOnCircularReference ( ) ; boolean goEarly = true ; for ( Iterator i = rc . iterator ( ) ; goEarly && i . hasNext ( ) ; ) { goEarly &= ( ( ResourceCollection ) i . next ( ) ) . isFilesystemOnly ( ) ; } if ( goEarly ) { return true ; } for ( Iterator i = cacheCollection ( ) . iterator ( ) ; i . hasNext ( ) ; ) { if ( ! ( i . next ( ) instanceof FileResource ) ) { return false ; } } return true ; } protected synchronized void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( isChecked ( ) ) { return ; } if ( isReference ( ) ) { super . dieOnCircularReference ( stk , p ) ; } else { for ( Iterator i = rc . iterator ( ) ; i . hasNext ( ) ; ) { Object o = i . next ( ) ; if ( o instanceof DataType ) { stk . push ( o ) ; invokeCircularReferenceCheck ( ( DataType ) o , stk , p ) ; stk . pop ( ) ; } } setChecked ( true ) ; } } protected final synchronized List getResourceCollections ( ) { dieOnCircularReference ( ) ; return Collections . unmodifiableList ( rc ) ; } protected abstract Collection getCollection ( ) ; public Object clone ( ) { try { BaseResourceCollectionContainer c = ( BaseResourceCollectionContainer ) super . clone ( ) ; c . rc = new ArrayList ( rc ) ; c . coll = null ; return c ; } catch ( CloneNotSupportedException e ) { throw new BuildException ( e ) ; } } public synchronized String toString ( ) { if ( isReference ( ) ) { return getCheckedRef ( ) . toString ( ) ; } if ( cacheCollection ( ) . size ( ) == 0 ) { return "" ; } StringBuffer sb = new StringBuffer ( ) ; for ( Iterator i = coll . iterator ( ) ; i . hasNext ( ) ; ) { if ( sb . length ( ) > 0 ) { sb . append ( File . pathSeparatorChar ) ; } sb . append ( i . next ( ) ) ; } return sb . toString ( ) ; } private synchronized Collection cacheCollection ( ) { if ( coll == null || ! isCache ( ) ) { coll = getCollection ( ) ; } return coll ; } } 	1	['15', '3', '3', '10', '47', '39', '4', '6', '11', '0.547619048', '310', '1', '0', '0.681818182', '0.222222222', '2', '5', '19.46666667', '7', '1.8667', '1']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedOutputStream ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . PrintStream ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Environment ; import org . apache . tools . ant . util . StringUtils ; import org . apache . tools . ant . util . FileUtils ; public abstract class AbstractCvsTask extends Task { public static final int DEFAULT_COMPRESSION_LEVEL = 3 ; private static final int MAXIMUM_COMRESSION_LEVEL = 9 ; private Commandline cmd = new Commandline ( ) ; private Vector vecCommandlines = new Vector ( ) ; private String cvsRoot ; private String cvsRsh ; private String cvsPackage ; private String tag ; private static final String DEFAULT_COMMAND = "checkout" ; private String command = null ; private boolean quiet = false ; private boolean reallyquiet = false ; private int compression = 0 ; private boolean noexec = false ; private int port = 0 ; private File passFile = null ; private File dest ; private boolean append = false ; private File output ; private File error ; private boolean failOnError = false ; private ExecuteStreamHandler executeStreamHandler ; private OutputStream outputStream ; private OutputStream errorStream ; public AbstractCvsTask ( ) { super ( ) ; } public void setExecuteStreamHandler ( ExecuteStreamHandler handler ) { this . executeStreamHandler = handler ; } protected ExecuteStreamHandler getExecuteStreamHandler ( ) { if ( this . executeStreamHandler == null ) { setExecuteStreamHandler ( new PumpStreamHandler ( getOutputStream ( ) , getErrorStream ( ) ) ) ; } return this . executeStreamHandler ; } protected void setOutputStream ( OutputStream outputStream ) { this . outputStream = outputStream ; } protected OutputStream getOutputStream ( ) { if ( this . outputStream == null ) { if ( output != null ) { try { setOutputStream ( new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( output . getPath ( ) , append ) ) ) ) ; } catch ( IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } else { setOutputStream ( new LogOutputStream ( this , Project . MSG_INFO ) ) ; } } return this . outputStream ; } protected void setErrorStream ( OutputStream errorStream ) { this . errorStream = errorStream ; } protected OutputStream getErrorStream ( ) { if ( this . errorStream == null ) { if ( error != null ) { try { setErrorStream ( new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( error . getPath ( ) , append ) ) ) ) ; } catch ( IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } else { setErrorStream ( new LogOutputStream ( this , Project . MSG_WARN ) ) ; } } return this . errorStream ; } protected void runCommand ( Commandline toExecute ) throws BuildException { Environment env = new Environment ( ) ; if ( port > 0 ) { Environment . Variable var = new Environment . Variable ( ) ; var . setKey ( "CVS_CLIENT_PORT" ) ; var . setValue ( String . valueOf ( port ) ) ; env . addVariable ( var ) ; } if ( passFile == null ) { File defaultPassFile = new File ( System . getProperty ( "cygwin.user.home" , System . getProperty ( "user.home" ) ) + File . separatorChar + ".cvspass" ) ; if ( defaultPassFile . exists ( ) ) { this . setPassfile ( defaultPassFile ) ; } } if ( passFile != null ) { if ( passFile . isFile ( ) && passFile . canRead ( ) ) { Environment . Variable var = new Environment . Variable ( ) ; var . setKey ( "CVS_PASSFILE" ) ; var . setValue ( String . valueOf ( passFile ) ) ; env . addVariable ( var ) ; log ( "Using cvs passfile: " + String . valueOf ( passFile ) , Project . MSG_VERBOSE ) ; } else if ( ! passFile . canRead ( ) ) { log ( "cvs passfile: " + String . valueOf ( passFile ) + " ignored as it is not readable" , Project . MSG_WARN ) ; } else { log ( "cvs passfile: " + String . valueOf ( passFile ) + " ignored as it is not a file" , Project . MSG_WARN ) ; } } if ( cvsRsh != null ) { Environment . Variable var = new Environment . Variable ( ) ; var . setKey ( "CVS_RSH" ) ; var . setValue ( String . valueOf ( cvsRsh ) ) ; env . addVariable ( var ) ; } Execute exe = new Execute ( getExecuteStreamHandler ( ) , null ) ; exe . setAntRun ( getProject ( ) ) ; if ( dest == null ) { dest = getProject ( ) . getBaseDir ( ) ; } if ( ! dest . exists ( ) ) { dest . mkdirs ( ) ; } exe . setWorkingDirectory ( dest ) ; exe . setCommandline ( toExecute . getCommandline ( ) ) ; exe . setEnvironment ( env . getVariables ( ) ) ; try { String actualCommandLine = executeToString ( exe ) ; log ( actualCommandLine , Project . MSG_VERBOSE ) ; int retCode = exe . execute ( ) ; log ( "retCode=" + retCode , Project . MSG_DEBUG ) ; if ( failOnError && Execute . isFailure ( retCode ) ) { throw new BuildException ( "cvs exited with error code " + retCode + StringUtils . LINE_SEP + "Command line was [" + actualCommandLine + "]" , getLocation ( ) ) ; } } catch ( IOException e ) { if ( failOnError ) { throw new BuildException ( e , getLocation ( ) ) ; } log ( "Caught exception: " + e . getMessage ( ) , Project . MSG_WARN ) ; } catch ( BuildException e ) { if ( failOnError ) { throw ( e ) ; } Throwable t = e . getException ( ) ; if ( t == null ) { t = e ; } log ( "Caught exception: " + t . getMessage ( ) , Project . MSG_WARN ) ; } catch ( Exception e ) { if ( failOnError ) { throw new BuildException ( e , getLocation ( ) ) ; } log ( "Caught exception: " + e . getMessage ( ) , Project . MSG_WARN ) ; } } public void execute ( ) throws BuildException { String savedCommand = getCommand ( ) ; if ( this . getCommand ( ) == null && vecCommandlines . size ( ) == 0 ) { this . setCommand ( AbstractCvsTask . DEFAULT_COMMAND ) ; } String c = this . getCommand ( ) ; Commandline cloned = null ; if ( c != null ) { cloned = ( Commandline ) cmd . clone ( ) ; cloned . createArgument ( true ) . setLine ( c ) ; this . addConfiguredCommandline ( cloned , true ) ; } try { for ( int i = 0 ; i < vecCommandlines . size ( ) ; i ++ ) { this . runCommand ( ( Commandline ) vecCommandlines . elementAt ( i ) ) ; } } finally { if ( cloned != null ) { removeCommandline ( cloned ) ; } setCommand ( savedCommand ) ; FileUtils . close ( outputStream ) ; FileUtils . close ( errorStream ) ; } } private String executeToString ( Execute execute ) { StringBuffer stringBuffer = new StringBuffer ( Commandline . describeCommand ( execute . getCommandline ( ) ) ) ; String newLine = StringUtils . LINE_SEP ; String [ ] variableArray = execute . getEnvironment ( ) ; if ( variableArray != null ) { stringBuffer . append ( newLine ) ; stringBuffer . append ( newLine ) ; stringBuffer . append ( "environment:" ) ; stringBuffer . append ( newLine ) ; for ( int z = 0 ; z < variableArray . length ; z ++ ) { stringBuffer . append ( newLine ) ; stringBuffer . append ( "\t" ) ; stringBuffer . append ( variableArray [ z ] ) ; } } return stringBuffer . toString ( ) ; } public void setCvsRoot ( String root ) { if ( root != null ) { if ( root . trim ( ) . equals ( "" ) ) { root = null ; } } this . cvsRoot = root ; } public String getCvsRoot ( ) { return this . cvsRoot ; } public void setCvsRsh ( String rsh ) { if ( rsh != null ) { if ( rsh . trim ( ) . equals ( "" ) ) { rsh = null ; } } this . cvsRsh = rsh ; } public String getCvsRsh ( ) { return this . cvsRsh ; } public void setPort ( int port ) { this . port = port ; } public int getPort ( ) { return this . port ; } public void setPassfile ( File passFile ) { this . passFile = passFile ; } public File getPassFile ( ) { return this . passFile ; } public void setDest ( File dest ) { this . dest = dest ; } public File getDest ( ) { return this . dest ; } public void setPackage ( String p ) { this . cvsPackage = p ; } public String getPackage ( ) { return this . cvsPackage ; } public String getTag ( ) { return tag ; } public void setTag ( String p ) { if ( p != null && p . trim ( ) . length ( ) > 0 ) { tag = p ; addCommandArgument ( "-r" + p ) ; } } public void addCommandArgument ( String arg ) { this . addCommandArgument ( cmd , arg ) ; } public void addCommandArgument ( Commandline c , String arg ) { c . createArgument ( ) . setValue ( arg ) ; } public void setDate ( String p ) { if ( p != null && p . trim ( ) . length ( ) > 0 ) { addCommandArgument ( "-D" ) ; addCommandArgument ( p ) ; } } public void setCommand ( String c ) { this . command = c ; } public String getCommand ( ) { return this . command ; } public void setQuiet ( boolean q ) { quiet = q ; } public void setReallyquiet ( boolean q ) { reallyquiet = q ; } public void setNoexec ( boolean ne ) { noexec = ne ; } public void setOutput ( File output ) { this . output = output ; } public void setError ( File error ) { this . error = error ; } public void setAppend ( boolean value ) { this . append = value ; } public void setFailOnError ( boolean failOnError ) { this . failOnError = failOnError ; } protected void configureCommandline ( Commandline c ) { if ( c == null ) { return ; } c . setExecutable ( "cvs" ) ; if ( cvsPackage != null ) { c . createArgument ( ) . setLine ( cvsPackage ) ; } if ( this . compression > 0 && this . compression <= MAXIMUM_COMRESSION_LEVEL ) { c . createArgument ( true ) . setValue ( "-z" + this . compression ) ; } if ( quiet && ! reallyquiet ) { c . createArgument ( true ) . setValue ( "-q" ) ; } if ( reallyquiet ) { c . createArgument ( true ) . setValue ( "-Q" ) ; } if ( noexec ) { c . createArgument ( true ) . setValue ( "-n" ) ; } if ( cvsRoot != null ) { c . createArgument ( true ) . setLine ( "-d" + cvsRoot ) ; } } protected void removeCommandline ( Commandline c ) { vecCommandlines . removeElement ( c ) ; } public void addConfiguredCommandline ( Commandline c ) { this . addConfiguredCommandline ( c , false ) ; } public void addConfiguredCommandline ( Commandline c , boolean insertAtStart ) { if ( c == null ) { return ; } this . configureCommandline ( c ) ; if ( insertAtStart ) { vecCommandlines . insertElementAt ( c , 0 ) ; } else { vecCommandlines . addElement ( c ) ; } } public void setCompressionLevel ( int level ) { this . compression = level ; } public void setCompression ( boolean usecomp ) { setCompressionLevel ( usecomp ? AbstractCvsTask . DEFAULT_COMPRESSION_LEVEL : 0 ) ; } } 	1	['42', '3', '4', '19', '107', '739', '4', '15', '33', '0.928861789', '898', '0.958333333', '2', '0.474358974', '0.193121693', '0', '0', '19.80952381', '10', '1.619', '1']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . AbstractFileSet ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . PatternSet ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . selectors . FileSelector ; import org . apache . tools . ant . types . selectors . NoneSelector ; public class Sync extends Task { private MyCopy myCopy ; private SyncTarget syncTarget ; public void init ( ) throws BuildException { myCopy = new MyCopy ( ) ; configureTask ( myCopy ) ; myCopy . setFiltering ( false ) ; myCopy . setIncludeEmptyDirs ( false ) ; myCopy . setPreserveLastModified ( true ) ; } private void configureTask ( Task helper ) { helper . setProject ( getProject ( ) ) ; helper . setTaskName ( getTaskName ( ) ) ; helper . setOwningTarget ( getOwningTarget ( ) ) ; helper . init ( ) ; } public void execute ( ) throws BuildException { File toDir = myCopy . getToDir ( ) ; Set allFiles = myCopy . nonOrphans ; boolean noRemovalNecessary = ! toDir . exists ( ) || toDir . list ( ) . length < 1 ; log ( "PASS#1: Copying files to " + toDir , Project . MSG_DEBUG ) ; myCopy . execute ( ) ; if ( noRemovalNecessary ) { log ( "NO removing necessary in " + toDir , Project . MSG_DEBUG ) ; return ; } log ( "PASS#2: Removing orphan files from " + toDir , Project . MSG_DEBUG ) ; int [ ] removedFileCount = removeOrphanFiles ( allFiles , toDir ) ; logRemovedCount ( removedFileCount [ 0 ] , "dangling director" , "y" , "ies" ) ; logRemovedCount ( removedFileCount [ 1 ] , "dangling file" , "" , "s" ) ; if ( ! myCopy . getIncludeEmptyDirs ( ) ) { log ( "PASS#3: Removing empty directories from " + toDir , Project . MSG_DEBUG ) ; int removedDirCount = removeEmptyDirectories ( toDir , false ) ; logRemovedCount ( removedDirCount , "empty director" , "y" , "ies" ) ; } } private void logRemovedCount ( int count , String prefix , String singularSuffix , String pluralSuffix ) { File toDir = myCopy . getToDir ( ) ; String what = ( prefix == null ) ? "" : prefix ; what += ( count < 2 ) ? singularSuffix : pluralSuffix ; if ( count > 0 ) { log ( "Removed " + count + " " + what + " from " + toDir , Project . MSG_INFO ) ; } else { log ( "NO " + what + " to remove from " + toDir , Project . MSG_VERBOSE ) ; } } private int [ ] removeOrphanFiles ( Set nonOrphans , File toDir ) { int [ ] removedCount = new int [ ] { 0 , 0 } ; String [ ] excls = ( String [ ] ) nonOrphans . toArray ( new String [ nonOrphans . size ( ) + 1 ] ) ; excls [ nonOrphans . size ( ) ] = "" ; DirectoryScanner ds = null ; if ( syncTarget != null ) { FileSet fs = new FileSet ( ) ; fs . setDir ( toDir ) ; fs . setCaseSensitive ( syncTarget . isCaseSensitive ( ) ) ; fs . setFollowSymlinks ( syncTarget . isFollowSymlinks ( ) ) ; PatternSet ps = syncTarget . mergePatterns ( getProject ( ) ) ; fs . appendExcludes ( ps . getIncludePatterns ( getProject ( ) ) ) ; fs . appendIncludes ( ps . getExcludePatterns ( getProject ( ) ) ) ; fs . setDefaultexcludes ( ! syncTarget . getDefaultexcludes ( ) ) ; FileSelector [ ] s = syncTarget . getSelectors ( getProject ( ) ) ; if ( s . length > 0 ) { NoneSelector ns = new NoneSelector ( ) ; for ( int i = 0 ; i < s . length ; i ++ ) { ns . appendSelector ( s [ i ] ) ; } fs . appendSelector ( ns ) ; } ds = fs . getDirectoryScanner ( getProject ( ) ) ; } else { ds = new DirectoryScanner ( ) ; ds . setBasedir ( toDir ) ; } ds . addExcludes ( excls ) ; ds . scan ( ) ; String [ ] files = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File f = new File ( toDir , files [ i ] ) ; log ( "Removing orphan file: " + f , Project . MSG_DEBUG ) ; f . delete ( ) ; ++ removedCount [ 1 ] ; } String [ ] dirs = ds . getIncludedDirectories ( ) ; for ( int i = dirs . length - 1 ; i >= 0 ; -- i ) { File f = new File ( toDir , dirs [ i ] ) ; if ( f . list ( ) . length < 1 ) { log ( "Removing orphan directory: " + f , Project . MSG_DEBUG ) ; f . delete ( ) ; ++ removedCount [ 0 ] ; } } return removedCount ; } private int removeEmptyDirectories ( File dir , boolean removeIfEmpty ) { int removedCount = 0 ; if ( dir . isDirectory ( ) ) { File [ ] children = dir . listFiles ( ) ; for ( int i = 0 ; i < children . length ; ++ i ) { File file = children [ i ] ; if ( file . isDirectory ( ) ) { removedCount += removeEmptyDirectories ( file , true ) ; } } if ( children . length > 0 ) { children = dir . listFiles ( ) ; } if ( children . length < 1 && removeIfEmpty ) { log ( "Removing empty directory: " + dir , Project . MSG_DEBUG ) ; dir . delete ( ) ; ++ removedCount ; } } return removedCount ; } public void setTodir ( File destDir ) { myCopy . setTodir ( destDir ) ; } public void setVerbose ( boolean verbose ) { myCopy . setVerbose ( verbose ) ; } public void setOverwrite ( boolean overwrite ) { myCopy . setOverwrite ( overwrite ) ; } public void setIncludeEmptyDirs ( boolean includeEmpty ) { myCopy . setIncludeEmptyDirs ( includeEmpty ) ; } public void setFailOnError ( boolean failonerror ) { myCopy . setFailOnError ( failonerror ) ; } public void addFileset ( FileSet set ) { add ( set ) ; } public void add ( ResourceCollection rc ) { myCopy . add ( rc ) ; } public void setGranularity ( long granularity ) { myCopy . setGranularity ( granularity ) ; } public void addPreserveInTarget ( SyncTarget s ) { if ( syncTarget != null ) { throw new BuildException ( "you must not specify multiple " + "preserveintarget elements." ) ; } syncTarget = s ; } public static class MyCopy extends Copy { private Set nonOrphans = new HashSet ( ) ; public MyCopy ( ) { } protected void scan ( File fromDir , File toDir , String [ ] files , String [ ] dirs ) { assertTrue ( "No mapper" , mapperElement == null ) ; super . scan ( fromDir , toDir , files , dirs ) ; for ( int i = 0 ; i < files . length ; ++ i ) { nonOrphans . add ( files [ i ] ) ; } for ( int i = 0 ; i < dirs . length ; ++ i ) { nonOrphans . add ( dirs [ i ] ) ; } } protected Map scan ( Resource [ ] resources , File toDir ) { assertTrue ( "No mapper" , mapperElement == null ) ; Map m = super . scan ( resources , toDir ) ; Iterator iter = m . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { nonOrphans . add ( ( ( Resource ) iter . next ( ) ) . getName ( ) ) ; } return m ; } public File getToDir ( ) { return destDir ; } public boolean getIncludeEmptyDirs ( ) { return includeEmpty ; } protected boolean supportsNonFileResources ( ) { return true ; } } public static class SyncTarget extends AbstractFileSet { public SyncTarget ( ) { super ( ) ; } public void setDir ( File dir ) throws BuildException { throw new BuildException ( "preserveintarget doesn't support the dir " + "attribute" ) ; } } private static void assertTrue ( String message , boolean condition ) { if ( ! condition ) { throw new BuildException ( "Assertion Error: " + message ) ; } } } 	1	['18', '3', '0', '12', '80', '61', '1', '12', '12', '0.647058824', '549', '1', '2', '0.685185185', '0.181818182', '0', '0', '29.38888889', '8', '1.9444', '4']
package org . apache . tools . ant . taskdefs ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . PrintStream ; import org . apache . tools . ant . BuildEvent ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . BuildLogger ; import org . apache . tools . ant . DefaultLogger ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . SubBuildListener ; import org . apache . tools . ant . util . StringUtils ; public class RecorderEntry implements BuildLogger , SubBuildListener { private String filename = null ; private boolean record = true ; private int loglevel = Project . MSG_INFO ; private PrintStream out = null ; private long targetStartTime = 0L ; private boolean emacsMode = false ; private Project project ; protected RecorderEntry ( String name ) { targetStartTime = System . currentTimeMillis ( ) ; filename = name ; } public String getFilename ( ) { return filename ; } public void setRecordState ( Boolean state ) { if ( state != null ) { flush ( ) ; record = state . booleanValue ( ) ; } } public void buildStarted ( BuildEvent event ) { log ( "> BUILD STARTED" , Project . MSG_DEBUG ) ; } public void buildFinished ( BuildEvent event ) { log ( "< BUILD FINISHED" , Project . MSG_DEBUG ) ; if ( record && out != null ) { Throwable error = event . getException ( ) ; if ( error == null ) { out . println ( StringUtils . LINE_SEP + "BUILD SUCCESSFUL" ) ; } else { out . println ( StringUtils . LINE_SEP + "BUILD FAILED" + StringUtils . LINE_SEP ) ; error . printStackTrace ( out ) ; } } cleanup ( ) ; } public void subBuildFinished ( BuildEvent event ) { if ( event . getProject ( ) == project ) { cleanup ( ) ; } } public void subBuildStarted ( BuildEvent event ) { } public void targetStarted ( BuildEvent event ) { log ( ">> TARGET STARTED -- " + event . getTarget ( ) , Project . MSG_DEBUG ) ; log ( StringUtils . LINE_SEP + event . getTarget ( ) . getName ( ) + ":" , Project . MSG_INFO ) ; targetStartTime = System . currentTimeMillis ( ) ; } public void targetFinished ( BuildEvent event ) { log ( "<< TARGET FINISHED -- " + event . getTarget ( ) , Project . MSG_DEBUG ) ; String time = formatTime ( System . currentTimeMillis ( ) - targetStartTime ) ; log ( event . getTarget ( ) + ":  duration " + time , Project . MSG_VERBOSE ) ; flush ( ) ; } public void taskStarted ( BuildEvent event ) { log ( ">>> TASK STARTED -- " + event . getTask ( ) , Project . MSG_DEBUG ) ; } public void taskFinished ( BuildEvent event ) { log ( "<<< TASK FINISHED -- " + event . getTask ( ) , Project . MSG_DEBUG ) ; flush ( ) ; } public void messageLogged ( BuildEvent event ) { log ( "--- MESSAGE LOGGED" , Project . MSG_DEBUG ) ; StringBuffer buf = new StringBuffer ( ) ; if ( event . getTask ( ) != null ) { String name = event . getTask ( ) . getTaskName ( ) ; if ( ! emacsMode ) { String label = "[" + name + "] " ; int size = DefaultLogger . LEFT_COLUMN_SIZE - label . length ( ) ; for ( int i = 0 ; i < size ; i ++ ) { buf . append ( " " ) ; } buf . append ( label ) ; } } buf . append ( event . getMessage ( ) ) ; log ( buf . toString ( ) , event . getPriority ( ) ) ; } private void log ( String mesg , int level ) { if ( record && ( level <= loglevel ) && out != null ) { out . println ( mesg ) ; } } private void flush ( ) { if ( record && out != null ) { out . flush ( ) ; } } public void setMessageOutputLevel ( int level ) { if ( level >= Project . MSG_ERR && level <= Project . MSG_DEBUG ) { loglevel = level ; } } public void setOutputPrintStream ( PrintStream output ) { closeFile ( ) ; out = output ; } public void setEmacsMode ( boolean emacsMode ) { this . emacsMode = emacsMode ; } public void setErrorPrintStream ( PrintStream err ) { setOutputPrintStream ( err ) ; } private static String formatTime ( long millis ) { long seconds = millis / 1000 ; long minutes = seconds / 60 ; if ( minutes > 0 ) { return Long . toString ( minutes ) + " minute" + ( minutes == 1 ? " " : "s " ) + Long . toString ( seconds % 60 ) + " second" + ( seconds % 60 == 1 ? "" : "s" ) ; } else { return Long . toString ( seconds ) + " second" + ( seconds % 60 == 1 ? "" : "s" ) ; } } public void setProject ( Project project ) { this . project = project ; if ( project != null ) { project . addBuildListener ( this ) ; } } public void cleanup ( ) { closeFile ( ) ; if ( project != null ) { project . removeBuildListener ( this ) ; } project = null ; } void openFile ( boolean append ) throws BuildException { openFileImpl ( append ) ; } void closeFile ( ) { if ( out != null ) { out . close ( ) ; out = null ; } } void reopenFile ( ) throws BuildException { openFileImpl ( true ) ; } private void openFileImpl ( boolean append ) throws BuildException { if ( out == null ) { try { out = new PrintStream ( new FileOutputStream ( filename , append ) ) ; } catch ( IOException ioe ) { throw new BuildException ( "Problems opening file using a " + "recorder entry" , ioe ) ; } } } } 	1	['25', '1', '0', '10', '53', '224', '1', '9', '17', '0.720238095', '460', '1', '1', '0', '0.2', '0', '0', '17.12', '5', '1.84', '1']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . io . Reader ; import java . io . StringWriter ; import java . io . UnsupportedEncodingException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . FileUtils ; public class Manifest { public static final String ATTRIBUTE_MANIFEST_VERSION = "Manifest-Version" ; public static final String ATTRIBUTE_SIGNATURE_VERSION = "Signature-Version" ; public static final String ATTRIBUTE_NAME = "Name" ; public static final String ATTRIBUTE_FROM = "From" ; public static final String ATTRIBUTE_CLASSPATH = "Class-Path" ; public static final String DEFAULT_MANIFEST_VERSION = "1.0" ; public static final int MAX_LINE_LENGTH = 72 ; public static final int MAX_SECTION_LENGTH = MAX_LINE_LENGTH - 2 ; public static final String EOL = "\r\n" ; public static final String ERROR_FROM_FORBIDDEN = "Manifest attributes should not start " + "with \"" + ATTRIBUTE_FROM + "\" in \"" ; public static final String JAR_ENCODING = "UTF-8" ; public static class Attribute { private static final int MAX_NAME_VALUE_LENGTH = 68 ; private static final int MAX_NAME_LENGTH = 70 ; private String name = null ; private Vector values = new Vector ( ) ; private int currentIndex = 0 ; public Attribute ( ) { } public Attribute ( String line ) throws ManifestException { parse ( line ) ; } public Attribute ( String name , String value ) { this . name = name ; setValue ( value ) ; } public int hashCode ( ) { int hashCode = 0 ; if ( name != null ) { hashCode += getKey ( ) . hashCode ( ) ; } hashCode += values . hashCode ( ) ; return hashCode ; } public boolean equals ( Object rhs ) { if ( rhs == null || rhs . getClass ( ) != getClass ( ) ) { return false ; } if ( rhs == this ) { return true ; } Attribute rhsAttribute = ( Attribute ) rhs ; String lhsKey = getKey ( ) ; String rhsKey = rhsAttribute . getKey ( ) ; if ( ( lhsKey == null && rhsKey != null ) || ( lhsKey != null && rhsKey == null ) || ! lhsKey . equals ( rhsKey ) ) { return false ; } return values . equals ( rhsAttribute . values ) ; } public void parse ( String line ) throws ManifestException { int index = line . indexOf ( ": " ) ; if ( index == - 1 ) { throw new ManifestException ( "Manifest line \"" + line + "\" is not valid as it does not " + "contain a name and a value separated by ': ' " ) ; } name = line . substring ( 0 , index ) ; setValue ( line . substring ( index + 2 ) ) ; } public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public String getKey ( ) { if ( name == null ) { return null ; } return name . toLowerCase ( ) ; } public void setValue ( String value ) { if ( currentIndex >= values . size ( ) ) { values . addElement ( value ) ; currentIndex = values . size ( ) - 1 ; } else { values . setElementAt ( value , currentIndex ) ; } } public String getValue ( ) { if ( values . size ( ) == 0 ) { return null ; } String fullValue = "" ; for ( Enumeration e = getValues ( ) ; e . hasMoreElements ( ) ; ) { String value = ( String ) e . nextElement ( ) ; fullValue += value + " " ; } return fullValue . trim ( ) ; } public void addValue ( String value ) { currentIndex ++ ; setValue ( value ) ; } public Enumeration getValues ( ) { return values . elements ( ) ; } public void addContinuation ( String line ) { String currentValue = ( String ) values . elementAt ( currentIndex ) ; setValue ( currentValue + line . substring ( 1 ) ) ; } public void write ( PrintWriter writer ) throws IOException { for ( Enumeration e = getValues ( ) ; e . hasMoreElements ( ) ; ) { writeValue ( writer , ( String ) e . nextElement ( ) ) ; } } private void writeValue ( PrintWriter writer , String value ) throws IOException { String line = null ; int nameLength = name . getBytes ( JAR_ENCODING ) . length ; if ( nameLength > MAX_NAME_VALUE_LENGTH ) { if ( nameLength > MAX_NAME_LENGTH ) { throw new IOException ( "Unable to write manifest line " + name + ": " + value ) ; } writer . print ( name + ": " + EOL ) ; line = " " + value ; } else { line = name + ": " + value ; } while ( line . getBytes ( JAR_ENCODING ) . length > MAX_SECTION_LENGTH ) { int breakIndex = MAX_SECTION_LENGTH ; if ( breakIndex >= line . length ( ) ) { breakIndex = line . length ( ) - 1 ; } String section = line . substring ( 0 , breakIndex ) ; while ( section . getBytes ( JAR_ENCODING ) . length > MAX_SECTION_LENGTH && breakIndex > 0 ) { breakIndex -- ; section = line . substring ( 0 , breakIndex ) ; } if ( breakIndex == 0 ) { throw new IOException ( "Unable to write manifest line " + name + ": " + value ) ; } writer . print ( section + EOL ) ; line = " " + line . substring ( breakIndex ) ; } writer . print ( line + EOL ) ; } } public static class Section { private Vector warnings = new Vector ( ) ; private String name = null ; private Hashtable attributes = new Hashtable ( ) ; private Vector attributeIndex = new Vector ( ) ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public String read ( BufferedReader reader ) throws ManifestException , IOException { Attribute attribute = null ; while ( true ) { String line = reader . readLine ( ) ; if ( line == null || line . length ( ) == 0 ) { return null ; } if ( line . charAt ( 0 ) == ' ' ) { if ( attribute == null ) { if ( name != null ) { name += line . substring ( 1 ) ; } else { throw new ManifestException ( "Can't start an " + "attribute with a continuation line " + line ) ; } } else { attribute . addContinuation ( line ) ; } } else { attribute = new Attribute ( line ) ; String nameReadAhead = addAttributeAndCheck ( attribute ) ; attribute = getAttribute ( attribute . getKey ( ) ) ; if ( nameReadAhead != null ) { return nameReadAhead ; } } } } public void merge ( Section section ) throws ManifestException { if ( name == null && section . getName ( ) != null || name != null && ! ( name . equalsIgnoreCase ( section . getName ( ) ) ) ) { throw new ManifestException ( "Unable to merge sections " + "with different names" ) ; } Enumeration e = section . getAttributeKeys ( ) ; Attribute classpathAttribute = null ; while ( e . hasMoreElements ( ) ) { String attributeName = ( String ) e . nextElement ( ) ; Attribute attribute = section . getAttribute ( attributeName ) ; if ( attributeName . equalsIgnoreCase ( ATTRIBUTE_CLASSPATH ) ) { if ( classpathAttribute == null ) { classpathAttribute = new Attribute ( ) ; classpathAttribute . setName ( ATTRIBUTE_CLASSPATH ) ; } Enumeration cpe = attribute . getValues ( ) ; while ( cpe . hasMoreElements ( ) ) { String value = ( String ) cpe . nextElement ( ) ; classpathAttribute . addValue ( value ) ; } } else { storeAttribute ( attribute ) ; } } if ( classpathAttribute != null ) { storeAttribute ( classpathAttribute ) ; } Enumeration warnEnum = section . warnings . elements ( ) ; while ( warnEnum . hasMoreElements ( ) ) { warnings . addElement ( warnEnum . nextElement ( ) ) ; } } public void write ( PrintWriter writer ) throws IOException { if ( name != null ) { Attribute nameAttr = new Attribute ( ATTRIBUTE_NAME , name ) ; nameAttr . write ( writer ) ; } Enumeration e = getAttributeKeys ( ) ; while ( e . hasMoreElements ( ) ) { String key = ( String ) e . nextElement ( ) ; Attribute attribute = getAttribute ( key ) ; attribute . write ( writer ) ; } writer . print ( EOL ) ; } public Attribute getAttribute ( String attributeName ) { return ( Attribute ) attributes . get ( attributeName . toLowerCase ( ) ) ; } public Enumeration getAttributeKeys ( ) { return attributeIndex . elements ( ) ; } public String getAttributeValue ( String attributeName ) { Attribute attribute = getAttribute ( attributeName . toLowerCase ( ) ) ; if ( attribute == null ) { return null ; } return attribute . getValue ( ) ; } public void removeAttribute ( String attributeName ) { String key = attributeName . toLowerCase ( ) ; attributes . remove ( key ) ; attributeIndex . removeElement ( key ) ; } public void addConfiguredAttribute ( Attribute attribute ) throws ManifestException { String check = addAttributeAndCheck ( attribute ) ; if ( check != null ) { throw new BuildException ( "Specify the section name using " + "the \"name\" attribute of the <section> element rather " + "than using a \"Name\" manifest attribute" ) ; } } public String addAttributeAndCheck ( Attribute attribute ) throws ManifestException { if ( attribute . getName ( ) == null || attribute . getValue ( ) == null ) { throw new BuildException ( "Attributes must have name and value" ) ; } if ( attribute . getKey ( ) . equalsIgnoreCase ( ATTRIBUTE_NAME ) ) { warnings . addElement ( "\"" + ATTRIBUTE_NAME + "\" attributes " + "should not occur in the main section and must be the " + "first element in all other sections: \"" + attribute . getName ( ) + ": " + attribute . getValue ( ) + "\"" ) ; return attribute . getValue ( ) ; } if ( attribute . getKey ( ) . startsWith ( ATTRIBUTE_FROM . toLowerCase ( ) ) ) { warnings . addElement ( ERROR_FROM_FORBIDDEN + attribute . getName ( ) + ": " + attribute . getValue ( ) + "\"" ) ; } else { String attributeKey = attribute . getKey ( ) ; if ( attributeKey . equalsIgnoreCase ( ATTRIBUTE_CLASSPATH ) ) { Attribute classpathAttribute = ( Attribute ) attributes . get ( attributeKey ) ; if ( classpathAttribute == null ) { storeAttribute ( attribute ) ; } else { warnings . addElement ( "Multiple Class-Path attributes " + "are supported but violate the Jar " + "specification and may not be correctly " + "processed in all environments" ) ; Enumeration e = attribute . getValues ( ) ; while ( e . hasMoreElements ( ) ) { String value = ( String ) e . nextElement ( ) ; classpathAttribute . addValue ( value ) ; } } } else if ( attributes . containsKey ( attributeKey ) ) { throw new ManifestException ( "The attribute \"" + attribute . getName ( ) + "\" may not occur more " + "than once in the same section" ) ; } else { storeAttribute ( attribute ) ; } } return null ; } public Object clone ( ) { Section cloned = new Section ( ) ; cloned . setName ( name ) ; Enumeration e = getAttributeKeys ( ) ; while ( e . hasMoreElements ( ) ) { String key = ( String ) e . nextElement ( ) ; Attribute attribute = getAttribute ( key ) ; cloned . storeAttribute ( new Attribute ( attribute . getName ( ) , attribute . getValue ( ) ) ) ; } return cloned ; } private void storeAttribute ( Attribute attribute ) { if ( attribute == null ) { return ; } String attributeKey = attribute . getKey ( ) ; attributes . put ( attributeKey , attribute ) ; if ( ! attributeIndex . contains ( attributeKey ) ) { attributeIndex . addElement ( attributeKey ) ; } } public Enumeration getWarnings ( ) { return warnings . elements ( ) ; } public int hashCode ( ) { return attributes . hashCode ( ) ; } public boolean equals ( Object rhs ) { if ( rhs == null || rhs . getClass ( ) != getClass ( ) ) { return false ; } if ( rhs == this ) { return true ; } Section rhsSection = ( Section ) rhs ; return attributes . equals ( rhsSection . attributes ) ; } } private String manifestVersion = DEFAULT_MANIFEST_VERSION ; private Section mainSection = new Section ( ) ; private Hashtable sections = new Hashtable ( ) ; private Vector sectionIndex = new Vector ( ) ; public static Manifest getDefaultManifest ( ) throws BuildException { InputStream in = null ; InputStreamReader insr = null ; try { String defManifest = "/org/apache/tools/ant/defaultManifest.mf" ; in = Manifest . class . getResourceAsStream ( defManifest ) ; if ( in == null ) { throw new BuildException ( "Could not find default manifest: " + defManifest ) ; } try { insr = new InputStreamReader ( in , "UTF-8" ) ; Manifest defaultManifest = new Manifest ( insr ) ; Attribute createdBy = new Attribute ( "Created-By" , System . getProperty ( "java.vm.version" ) + " (" + System . getProperty ( "java.vm.vendor" ) + ")" ) ; defaultManifest . getMainSection ( ) . storeAttribute ( createdBy ) ; return defaultManifest ; } catch ( UnsupportedEncodingException e ) { insr = new InputStreamReader ( in ) ; return new Manifest ( insr ) ; } } catch ( ManifestException e ) { throw new BuildException ( "Default manifest is invalid !!" , e ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to read default manifest" , e ) ; } finally { FileUtils . close ( insr ) ; FileUtils . close ( in ) ; } } public Manifest ( ) { manifestVersion = null ; } public Manifest ( Reader r ) throws ManifestException , IOException { BufferedReader reader = new BufferedReader ( r ) ; String nextSectionName = mainSection . read ( reader ) ; String readManifestVersion = mainSection . getAttributeValue ( ATTRIBUTE_MANIFEST_VERSION ) ; if ( readManifestVersion != null ) { manifestVersion = readManifestVersion ; mainSection . removeAttribute ( ATTRIBUTE_MANIFEST_VERSION ) ; } String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { if ( line . length ( ) == 0 ) { continue ; } Section section = new Section ( ) ; if ( nextSectionName == null ) { Attribute sectionName = new Attribute ( line ) ; if ( ! sectionName . getName ( ) . equalsIgnoreCase ( ATTRIBUTE_NAME ) ) { throw new ManifestException ( "Manifest sections should " + "start with a \"" + ATTRIBUTE_NAME + "\" attribute and not \"" + sectionName . getName ( ) + "\"" ) ; } nextSectionName = sectionName . getValue ( ) ; } else { Attribute firstAttribute = new Attribute ( line ) ; section . addAttributeAndCheck ( firstAttribute ) ; } section . setName ( nextSectionName ) ; nextSectionName = section . read ( reader ) ; addConfiguredSection ( section ) ; } } public void addConfiguredSection ( Section section ) throws ManifestException { String sectionName = section . getName ( ) ; if ( sectionName == null ) { throw new BuildException ( "Sections must have a name" ) ; } sections . put ( sectionName , section ) ; if ( ! sectionIndex . contains ( sectionName ) ) { sectionIndex . addElement ( sectionName ) ; } } public void addConfiguredAttribute ( Attribute attribute ) throws ManifestException { if ( attribute . getKey ( ) == null || attribute . getValue ( ) == null ) { throw new BuildException ( "Attributes must have name and value" ) ; } if ( attribute . getKey ( ) . equalsIgnoreCase ( ATTRIBUTE_MANIFEST_VERSION ) ) { manifestVersion = attribute . getValue ( ) ; } else { mainSection . addConfiguredAttribute ( attribute ) ; } } public void merge ( Manifest other ) throws ManifestException { merge ( other , false ) ; } public void merge ( Manifest other , boolean overwriteMain ) throws ManifestException { if ( other != null ) { if ( overwriteMain ) { mainSection = ( Section ) other . mainSection . clone ( ) ; } else { mainSection . merge ( other . mainSection ) ; } if ( other . manifestVersion != null ) { manifestVersion = other . manifestVersion ; } Enumeration e = other . getSectionNames ( ) ; while ( e . hasMoreElements ( ) ) { String sectionName = ( String ) e . nextElement ( ) ; Section ourSection = ( Section ) sections . get ( sectionName ) ; Section otherSection = ( Section ) other . sections . get ( sectionName ) ; if ( ourSection == null ) { if ( otherSection != null ) { addConfiguredSection ( ( Section ) otherSection . clone ( ) ) ; } } else { ourSection . merge ( otherSection ) ; } } } } public void write ( PrintWriter writer ) throws IOException { writer . print ( ATTRIBUTE_MANIFEST_VERSION + ": " + manifestVersion + EOL ) ; String signatureVersion = mainSection . getAttributeValue ( ATTRIBUTE_SIGNATURE_VERSION ) ; if ( signatureVersion != null ) { writer . print ( ATTRIBUTE_SIGNATURE_VERSION + ": " + signatureVersion + EOL ) ; mainSection . removeAttribute ( ATTRIBUTE_SIGNATURE_VERSION ) ; } mainSection . write ( writer ) ; if ( signatureVersion != null ) { try { Attribute svAttr = new Attribute ( ATTRIBUTE_SIGNATURE_VERSION , signatureVersion ) ; mainSection . addConfiguredAttribute ( svAttr ) ; } catch ( ManifestException e ) { } } Enumeration e = sectionIndex . elements ( ) ; while ( e . hasMoreElements ( ) ) { String sectionName = ( String ) e . nextElement ( ) ; Section section = getSection ( sectionName ) ; section . write ( writer ) ; } } public String toString ( ) { StringWriter sw = new StringWriter ( ) ; try { write ( new PrintWriter ( sw ) ) ; } catch ( IOException e ) { return null ; } return sw . toString ( ) ; } public Enumeration getWarnings ( ) { Vector warnings = new Vector ( ) ; Enumeration warnEnum = mainSection . getWarnings ( ) ; while ( warnEnum . hasMoreElements ( ) ) { warnings . addElement ( warnEnum . nextElement ( ) ) ; } Enumeration e = sections . elements ( ) ; while ( e . hasMoreElements ( ) ) { Section section = ( Section ) e . nextElement ( ) ; Enumeration e2 = section . getWarnings ( ) ; while ( e2 . hasMoreElements ( ) ) { warnings . addElement ( e2 . nextElement ( ) ) ; } } return warnings . elements ( ) ; } public int hashCode ( ) { int hashCode = 0 ; if ( manifestVersion != null ) { hashCode += manifestVersion . hashCode ( ) ; } hashCode += mainSection . hashCode ( ) ; hashCode += sections . hashCode ( ) ; return hashCode ; } public boolean equals ( Object rhs ) { if ( rhs == null || rhs . getClass ( ) != getClass ( ) ) { return false ; } if ( rhs == this ) { return true ; } Manifest rhsManifest = ( Manifest ) rhs ; if ( manifestVersion == null ) { if ( rhsManifest . manifestVersion != null ) { return false ; } } else if ( ! manifestVersion . equals ( rhsManifest . manifestVersion ) ) { return false ; } if ( ! mainSection . equals ( rhsManifest . mainSection ) ) { return false ; } return sections . equals ( rhsManifest . sections ) ; } public String getManifestVersion ( ) { return manifestVersion ; } public Section getMainSection ( ) { return mainSection ; } public Section getSection ( String name ) { return ( Section ) sections . get ( name ) ; } public Enumeration getSectionNames ( ) { return sectionIndex . elements ( ) ; } } 	1	['16', '1', '0', '8', '76', '0', '3', '5', '16', '0.883333333', '616', '0.25', '1', '0', '0.166666667', '1', '1', '36.5', '8', '1.5625', '1']
package org . apache . tools . bzip2 ; import java . io . InputStream ; import java . io . IOException ; public class CBZip2InputStream extends InputStream implements BZip2Constants { private static void reportCRCError ( ) throws IOException { System . err . println ( "BZip2 CRC error" ) ; } private void makeMaps ( ) { final boolean [ ] inUse = this . data . inUse ; final byte [ ] seqToUnseq = this . data . seqToUnseq ; int nInUseShadow = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { if ( inUse [ i ] ) seqToUnseq [ nInUseShadow ++ ] = ( byte ) i ; } this . nInUse = nInUseShadow ; } private int last ; private int origPtr ; private int blockSize100k ; private boolean blockRandomised ; private int bsBuff ; private int bsLive ; private final CRC crc = new CRC ( ) ; private int nInUse ; private InputStream in ; private int currentChar = - 1 ; private static final int EOF = 0 ; private static final int START_BLOCK_STATE = 1 ; private static final int RAND_PART_A_STATE = 2 ; private static final int RAND_PART_B_STATE = 3 ; private static final int RAND_PART_C_STATE = 4 ; private static final int NO_RAND_PART_A_STATE = 5 ; private static final int NO_RAND_PART_B_STATE = 6 ; private static final int NO_RAND_PART_C_STATE = 7 ; private int currentState = START_BLOCK_STATE ; private int storedBlockCRC , storedCombinedCRC ; private int computedBlockCRC , computedCombinedCRC ; private int su_count ; private int su_ch2 ; private int su_chPrev ; private int su_i2 ; private int su_j2 ; private int su_rNToGo ; private int su_rTPos ; private int su_tPos ; private char su_z ; private CBZip2InputStream . Data data ; public CBZip2InputStream ( final InputStream in ) throws IOException { super ( ) ; this . in = in ; init ( ) ; } public int read ( ) throws IOException { if ( this . in != null ) { return read0 ( ) ; } else { throw new IOException ( "stream closed" ) ; } } public int read ( final byte [ ] dest , final int offs , final int len ) throws IOException { if ( offs < 0 ) { throw new IndexOutOfBoundsException ( "offs(" + offs + ") < 0." ) ; } if ( len < 0 ) { throw new IndexOutOfBoundsException ( "len(" + len + ") < 0." ) ; } if ( offs + len > dest . length ) { throw new IndexOutOfBoundsException ( "offs(" + offs + ") + len(" + len + ") > dest.length(" + dest . length + ")." ) ; } if ( this . in == null ) { throw new IOException ( "stream closed" ) ; } final int hi = offs + len ; int destOffs = offs ; for ( int b ; ( destOffs < hi ) && ( ( b = read0 ( ) ) >= 0 ) ; ) { dest [ destOffs ++ ] = ( byte ) b ; } return ( destOffs == offs ) ? - 1 : ( destOffs - offs ) ; } private int read0 ( ) throws IOException { final int retChar = this . currentChar ; switch ( this . currentState ) { case EOF : return - 1 ; case START_BLOCK_STATE : throw new IllegalStateException ( ) ; case RAND_PART_A_STATE : throw new IllegalStateException ( ) ; case RAND_PART_B_STATE : setupRandPartB ( ) ; break ; case RAND_PART_C_STATE : setupRandPartC ( ) ; break ; case NO_RAND_PART_A_STATE : throw new IllegalStateException ( ) ; case NO_RAND_PART_B_STATE : setupNoRandPartB ( ) ; break ; case NO_RAND_PART_C_STATE : setupNoRandPartC ( ) ; break ; default : throw new IllegalStateException ( ) ; } return retChar ; } private void init ( ) throws IOException { int magic2 = this . in . read ( ) ; if ( magic2 != 'h' ) { throw new IOException ( "Stream is not BZip2 formatted: expected 'h'" + " as first byte but got '" + ( char ) magic2 + "'" ) ; } int blockSize = this . in . read ( ) ; if ( ( blockSize < '1' ) || ( blockSize > '9' ) ) { throw new IOException ( "Stream is not BZip2 formatted: illegal " + "blocksize " + ( char ) blockSize ) ; } this . blockSize100k = blockSize - '0' ; initBlock ( ) ; setupBlock ( ) ; } private void initBlock ( ) throws IOException { char magic0 = bsGetUByte ( ) ; char magic1 = bsGetUByte ( ) ; char magic2 = bsGetUByte ( ) ; char magic3 = bsGetUByte ( ) ; char magic4 = bsGetUByte ( ) ; char magic5 = bsGetUByte ( ) ; if ( magic0 == 0x17 && magic1 == 0x72 && magic2 == 0x45 && magic3 == 0x38 && magic4 == 0x50 && magic5 == 0x90 ) { complete ( ) ; } else if ( magic0 != 0x31 || magic1 != 0x41 || magic2 != 0x59 || magic3 != 0x26 || magic4 != 0x53 || magic5 != 0x59 ) { this . currentState = EOF ; throw new IOException ( "bad block header" ) ; } else { this . storedBlockCRC = bsGetInt ( ) ; this . blockRandomised = bsR ( 1 ) == 1 ; if ( this . data == null ) { this . data = new Data ( this . blockSize100k ) ; } getAndMoveToFrontDecode ( ) ; this . crc . initialiseCRC ( ) ; this . currentState = START_BLOCK_STATE ; } } private void endBlock ( ) throws IOException { this . computedBlockCRC = this . crc . getFinalCRC ( ) ; if ( this . storedBlockCRC != this . computedBlockCRC ) { this . computedCombinedCRC = ( this . storedCombinedCRC << 1 ) | ( this . storedCombinedCRC > > > 31 ) ; this . computedCombinedCRC ^= this . storedBlockCRC ; reportCRCError ( ) ; } this . computedCombinedCRC = ( this . computedCombinedCRC << 1 ) | ( this . computedCombinedCRC > > > 31 ) ; this . computedCombinedCRC ^= this . computedBlockCRC ; } private void complete ( ) throws IOException { this . storedCombinedCRC = bsGetInt ( ) ; this . currentState = EOF ; this . data = null ; if ( this . storedCombinedCRC != this . computedCombinedCRC ) { reportCRCError ( ) ; } } public void close ( ) throws IOException { InputStream inShadow = this . in ; if ( inShadow != null ) { try { if ( inShadow != System . in ) { inShadow . close ( ) ; } } finally { this . data = null ; this . in = null ; } } } private int bsR ( final int n ) throws IOException { int bsLiveShadow = this . bsLive ; int bsBuffShadow = this . bsBuff ; if ( bsLiveShadow < n ) { final InputStream inShadow = this . in ; do { int thech = inShadow . read ( ) ; if ( thech < 0 ) { throw new IOException ( "unexpected end of stream" ) ; } bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; } while ( bsLiveShadow < n ) ; this . bsBuff = bsBuffShadow ; } this . bsLive = bsLiveShadow - n ; return ( bsBuffShadow > > ( bsLiveShadow - n ) ) & ( ( 1 << n ) - 1 ) ; } private boolean bsGetBit ( ) throws IOException { int bsLiveShadow = this . bsLive ; int bsBuffShadow = this . bsBuff ; if ( bsLiveShadow < 1 ) { int thech = this . in . read ( ) ; if ( thech < 0 ) { throw new IOException ( "unexpected end of stream" ) ; } bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; this . bsBuff = bsBuffShadow ; } this . bsLive = bsLiveShadow - 1 ; return ( ( bsBuffShadow > > ( bsLiveShadow - 1 ) ) & 1 ) != 0 ; } private char bsGetUByte ( ) throws IOException { return ( char ) bsR ( 8 ) ; } private int bsGetInt ( ) throws IOException { return ( ( ( ( ( bsR ( 8 ) << 8 ) | bsR ( 8 ) ) << 8 ) | bsR ( 8 ) ) << 8 ) | bsR ( 8 ) ; } private static void hbCreateDecodeTables ( final int [ ] limit , final int [ ] base , final int [ ] perm , final char [ ] length , final int minLen , final int maxLen , final int alphaSize ) { for ( int i = minLen , pp = 0 ; i <= maxLen ; i ++ ) { for ( int j = 0 ; j < alphaSize ; j ++ ) { if ( length [ j ] == i ) { perm [ pp ++ ] = j ; } } } for ( int i = MAX_CODE_LEN ; -- i > 0 ; ) { base [ i ] = 0 ; limit [ i ] = 0 ; } for ( int i = 0 ; i < alphaSize ; i ++ ) { base [ length [ i ] + 1 ] ++ ; } for ( int i = 1 , b = base [ 0 ] ; i < MAX_CODE_LEN ; i ++ ) { b += base [ i ] ; base [ i ] = b ; } for ( int i = minLen , vec = 0 , b = base [ i ] ; i <= maxLen ; i ++ ) { final int nb = base [ i + 1 ] ; vec += nb - b ; b = nb ; limit [ i ] = vec - 1 ; vec <<= 1 ; } for ( int i = minLen + 1 ; i <= maxLen ; i ++ ) { base [ i ] = ( ( limit [ i - 1 ] + 1 ) << 1 ) - base [ i ] ; } } private void recvDecodingTables ( ) throws IOException { final Data dataShadow = this . data ; final boolean [ ] inUse = dataShadow . inUse ; final byte [ ] pos = dataShadow . recvDecodingTables_pos ; final byte [ ] selector = dataShadow . selector ; final byte [ ] selectorMtf = dataShadow . selectorMtf ; int inUse16 = 0 ; for ( int i = 0 ; i < 16 ; i ++ ) { if ( bsGetBit ( ) ) { inUse16 |= 1 << i ; } } for ( int i = 256 ; -- i >= 0 ; ) { inUse [ i ] = false ; } for ( int i = 0 ; i < 16 ; i ++ ) { if ( ( inUse16 & ( 1 << i ) ) != 0 ) { final int i16 = i << 4 ; for ( int j = 0 ; j < 16 ; j ++ ) { if ( bsGetBit ( ) ) { inUse [ i16 + j ] = true ; } } } } makeMaps ( ) ; final int alphaSize = this . nInUse + 2 ; final int nGroups = bsR ( 3 ) ; final int nSelectors = bsR ( 15 ) ; for ( int i = 0 ; i < nSelectors ; i ++ ) { int j = 0 ; while ( bsGetBit ( ) ) { j ++ ; } selectorMtf [ i ] = ( byte ) j ; } for ( int v = nGroups ; -- v >= 0 ; ) { pos [ v ] = ( byte ) v ; } for ( int i = 0 ; i < nSelectors ; i ++ ) { int v = selectorMtf [ i ] & 0xff ; final byte tmp = pos [ v ] ; while ( v > 0 ) { pos [ v ] = pos [ v - 1 ] ; v -- ; } pos [ 0 ] = tmp ; selector [ i ] = tmp ; } final char [ ] [ ] len = dataShadow . temp_charArray2d ; for ( int t = 0 ; t < nGroups ; t ++ ) { int curr = bsR ( 5 ) ; final char [ ] len_t = len [ t ] ; for ( int i = 0 ; i < alphaSize ; i ++ ) { while ( bsGetBit ( ) ) { curr += bsGetBit ( ) ? - 1 : 1 ; } len_t [ i ] = ( char ) curr ; } } createHuffmanDecodingTables ( alphaSize , nGroups ) ; } private void createHuffmanDecodingTables ( final int alphaSize , final int nGroups ) { final Data dataShadow = this . data ; final char [ ] [ ] len = dataShadow . temp_charArray2d ; final int [ ] minLens = dataShadow . minLens ; final int [ ] [ ] limit = dataShadow . limit ; final int [ ] [ ] base = dataShadow . base ; final int [ ] [ ] perm = dataShadow . perm ; for ( int t = 0 ; t < nGroups ; t ++ ) { int minLen = 32 ; int maxLen = 0 ; final char [ ] len_t = len [ t ] ; for ( int i = alphaSize ; -- i >= 0 ; ) { final char lent = len_t [ i ] ; if ( lent > maxLen ) { maxLen = lent ; } if ( lent < minLen ) { minLen = lent ; } } hbCreateDecodeTables ( limit [ t ] , base [ t ] , perm [ t ] , len [ t ] , minLen , maxLen , alphaSize ) ; minLens [ t ] = minLen ; } } private void getAndMoveToFrontDecode ( ) throws IOException { this . origPtr = bsR ( 24 ) ; recvDecodingTables ( ) ; final InputStream inShadow = this . in ; final Data dataShadow = this . data ; final byte [ ] ll8 = dataShadow . ll8 ; final int [ ] unzftab = dataShadow . unzftab ; final byte [ ] selector = dataShadow . selector ; final byte [ ] seqToUnseq = dataShadow . seqToUnseq ; final char [ ] yy = dataShadow . getAndMoveToFrontDecode_yy ; final int [ ] minLens = dataShadow . minLens ; final int [ ] [ ] limit = dataShadow . limit ; final int [ ] [ ] base = dataShadow . base ; final int [ ] [ ] perm = dataShadow . perm ; final int limitLast = this . blockSize100k * 100000 ; for ( int i = 256 ; -- i >= 0 ; ) { yy [ i ] = ( char ) i ; unzftab [ i ] = 0 ; } int groupNo = 0 ; int groupPos = G_SIZE - 1 ; final int eob = this . nInUse + 1 ; int nextSym = getAndMoveToFrontDecode0 ( 0 ) ; int bsBuffShadow = this . bsBuff ; int bsLiveShadow = this . bsLive ; int lastShadow = - 1 ; int zt = selector [ groupNo ] & 0xff ; int [ ] base_zt = base [ zt ] ; int [ ] limit_zt = limit [ zt ] ; int [ ] perm_zt = perm [ zt ] ; int minLens_zt = minLens [ zt ] ; while ( nextSym != eob ) { if ( ( nextSym == RUNA ) || ( nextSym == RUNB ) ) { int s = - 1 ; for ( int n = 1 ; true ; n <<= 1 ) { if ( nextSym == RUNA ) { s += n ; } else if ( nextSym == RUNB ) { s += n << 1 ; } else { break ; } if ( groupPos == 0 ) { groupPos = G_SIZE - 1 ; zt = selector [ ++ groupNo ] & 0xff ; base_zt = base [ zt ] ; limit_zt = limit [ zt ] ; perm_zt = perm [ zt ] ; minLens_zt = minLens [ zt ] ; } else { groupPos -- ; } int zn = minLens_zt ; while ( bsLiveShadow < zn ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } int zvec = ( bsBuffShadow > > ( bsLiveShadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bsLiveShadow -= zn ; while ( zvec > limit_zt [ zn ] ) { zn ++ ; while ( bsLiveShadow < 1 ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } bsLiveShadow -- ; zvec = ( zvec << 1 ) | ( ( bsBuffShadow > > bsLiveShadow ) & 1 ) ; } nextSym = perm_zt [ zvec - base_zt [ zn ] ] ; } final byte ch = seqToUnseq [ yy [ 0 ] ] ; unzftab [ ch & 0xff ] += s + 1 ; while ( s -- >= 0 ) { ll8 [ ++ lastShadow ] = ch ; } if ( lastShadow >= limitLast ) { throw new IOException ( "block overrun" ) ; } } else { if ( ++ lastShadow >= limitLast ) { throw new IOException ( "block overrun" ) ; } final char tmp = yy [ nextSym - 1 ] ; unzftab [ seqToUnseq [ tmp ] & 0xff ] ++ ; ll8 [ lastShadow ] = seqToUnseq [ tmp ] ; if ( nextSym <= 16 ) { for ( int j = nextSym - 1 ; j > 0 ; ) { yy [ j ] = yy [ -- j ] ; } } else { System . arraycopy ( yy , 0 , yy , 1 , nextSym - 1 ) ; } yy [ 0 ] = tmp ; if ( groupPos == 0 ) { groupPos = G_SIZE - 1 ; zt = selector [ ++ groupNo ] & 0xff ; base_zt = base [ zt ] ; limit_zt = limit [ zt ] ; perm_zt = perm [ zt ] ; minLens_zt = minLens [ zt ] ; } else { groupPos -- ; } int zn = minLens_zt ; while ( bsLiveShadow < zn ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } int zvec = ( bsBuffShadow > > ( bsLiveShadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bsLiveShadow -= zn ; while ( zvec > limit_zt [ zn ] ) { zn ++ ; while ( bsLiveShadow < 1 ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } bsLiveShadow -- ; zvec = ( zvec << 1 ) | ( ( bsBuffShadow > > bsLiveShadow ) & 1 ) ; } nextSym = perm_zt [ zvec - base_zt [ zn ] ] ; } } this . last = lastShadow ; this . bsLive = bsLiveShadow ; this . bsBuff = bsBuffShadow ; } private int getAndMoveToFrontDecode0 ( final int groupNo ) throws IOException { final InputStream inShadow = this . in ; final Data dataShadow = this . data ; final int zt = dataShadow . selector [ groupNo ] & 0xff ; final int [ ] limit_zt = dataShadow . limit [ zt ] ; int zn = dataShadow . minLens [ zt ] ; int zvec = bsR ( zn ) ; int bsLiveShadow = this . bsLive ; int bsBuffShadow = this . bsBuff ; while ( zvec > limit_zt [ zn ] ) { zn ++ ; while ( bsLiveShadow < 1 ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } bsLiveShadow -- ; zvec = ( zvec << 1 ) | ( ( bsBuffShadow > > bsLiveShadow ) & 1 ) ; } this . bsLive = bsLiveShadow ; this . bsBuff = bsBuffShadow ; return dataShadow . perm [ zt ] [ zvec - dataShadow . base [ zt ] [ zn ] ] ; } private void setupBlock ( ) throws IOException { if ( this . data == null ) { return ; } final int [ ] cftab = this . data . cftab ; final int [ ] tt = this . data . initTT ( this . last + 1 ) ; final byte [ ] ll8 = this . data . ll8 ; cftab [ 0 ] = 0 ; System . arraycopy ( this . data . unzftab , 0 , cftab , 1 , 256 ) ; for ( int i = 1 , c = cftab [ 0 ] ; i <= 256 ; i ++ ) { c += cftab [ i ] ; cftab [ i ] = c ; } for ( int i = 0 , lastShadow = this . last ; i <= lastShadow ; i ++ ) { tt [ cftab [ ll8 [ i ] & 0xff ] ++ ] = i ; } if ( ( this . origPtr < 0 ) || ( this . origPtr >= tt . length ) ) { throw new IOException ( "stream corrupted" ) ; } this . su_tPos = tt [ this . origPtr ] ; this . su_count = 0 ; this . su_i2 = 0 ; this . su_ch2 = 256 ; if ( this . blockRandomised ) { this . su_rNToGo = 0 ; this . su_rTPos = 0 ; setupRandPartA ( ) ; } else { setupNoRandPartA ( ) ; } } private void setupRandPartA ( ) throws IOException { if ( this . su_i2 <= this . last ) { this . su_chPrev = this . su_ch2 ; int su_ch2Shadow = this . data . ll8 [ this . su_tPos ] & 0xff ; this . su_tPos = this . data . tt [ this . su_tPos ] ; if ( this . su_rNToGo == 0 ) { this . su_rNToGo = BZip2Constants . rNums [ this . su_rTPos ] - 1 ; if ( ++ this . su_rTPos == 512 ) { this . su_rTPos = 0 ; } } else { this . su_rNToGo -- ; } this . su_ch2 = su_ch2Shadow ^= ( this . su_rNToGo == 1 ) ? 1 : 0 ; this . su_i2 ++ ; this . currentChar = su_ch2Shadow ; this . currentState = RAND_PART_B_STATE ; this . crc . updateCRC ( su_ch2Shadow ) ; } else { endBlock ( ) ; initBlock ( ) ; setupBlock ( ) ; } } private void setupNoRandPartA ( ) throws IOException { if ( this . su_i2 <= this . last ) { this . su_chPrev = this . su_ch2 ; int su_ch2Shadow = this . data . ll8 [ this . su_tPos ] & 0xff ; this . su_ch2 = su_ch2Shadow ; this . su_tPos = this . data . tt [ this . su_tPos ] ; this . su_i2 ++ ; this . currentChar = su_ch2Shadow ; this . currentState = NO_RAND_PART_B_STATE ; this . crc . updateCRC ( su_ch2Shadow ) ; } else { this . currentState = NO_RAND_PART_A_STATE ; endBlock ( ) ; initBlock ( ) ; setupBlock ( ) ; } } private void setupRandPartB ( ) throws IOException { if ( this . su_ch2 != this . su_chPrev ) { this . currentState = RAND_PART_A_STATE ; this . su_count = 1 ; setupRandPartA ( ) ; } else if ( ++ this . su_count >= 4 ) { this . su_z = ( char ) ( this . data . ll8 [ this . su_tPos ] & 0xff ) ; this . su_tPos = this . data . tt [ this . su_tPos ] ; if ( this . su_rNToGo == 0 ) { this . su_rNToGo = BZip2Constants . rNums [ this . su_rTPos ] - 1 ; if ( ++ this . su_rTPos == 512 ) { this . su_rTPos = 0 ; } } else { this . su_rNToGo -- ; } this . su_j2 = 0 ; this . currentState = RAND_PART_C_STATE ; if ( this . su_rNToGo == 1 ) { this . su_z ^= 1 ; } setupRandPartC ( ) ; } else { this . currentState = RAND_PART_A_STATE ; setupRandPartA ( ) ; } } private void setupRandPartC ( ) throws IOException { if ( this . su_j2 < this . su_z ) { this . currentChar = this . su_ch2 ; this . crc . updateCRC ( this . su_ch2 ) ; this . su_j2 ++ ; } else { this . currentState = RAND_PART_A_STATE ; this . su_i2 ++ ; this . su_count = 0 ; setupRandPartA ( ) ; } } private void setupNoRandPartB ( ) throws IOException { if ( this . su_ch2 != this . su_chPrev ) { this . su_count = 1 ; setupNoRandPartA ( ) ; } else if ( ++ this . su_count >= 4 ) { this . su_z = ( char ) ( this . data . ll8 [ this . su_tPos ] & 0xff ) ; this . su_tPos = this . data . tt [ this . su_tPos ] ; this . su_j2 = 0 ; setupNoRandPartC ( ) ; } else { setupNoRandPartA ( ) ; } } private void setupNoRandPartC ( ) throws IOException { if ( this . su_j2 < this . su_z ) { int su_ch2Shadow = this . su_ch2 ; this . currentChar = su_ch2Shadow ; this . crc . updateCRC ( su_ch2Shadow ) ; this . su_j2 ++ ; this . currentState = NO_RAND_PART_C_STATE ; } else { this . su_i2 ++ ; this . su_count = 0 ; setupNoRandPartA ( ) ; } } private static final class Data extends Object { final boolean [ ] inUse = new boolean [ 256 ] ; final byte [ ] seqToUnseq = new byte [ 256 ] ; final byte [ ] selector = new byte [ MAX_SELECTORS ] ; final byte [ ] selectorMtf = new byte [ MAX_SELECTORS ] ; final int [ ] unzftab = new int [ 256 ] ; final int [ ] [ ] limit = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; final int [ ] [ ] base = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; final int [ ] [ ] perm = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; final int [ ] minLens = new int [ N_GROUPS ] ; final int [ ] cftab = new int [ 257 ] ; final char [ ] getAndMoveToFrontDecode_yy = new char [ 256 ] ; final char [ ] [ ] temp_charArray2d = new char [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; final byte [ ] recvDecodingTables_pos = new byte [ N_GROUPS ] ; int [ ] tt ; byte [ ] ll8 ; Data ( int blockSize100k ) { super ( ) ; this . ll8 = new byte [ blockSize100k * BZip2Constants . baseBlockSize ] ; } final int [ ] initTT ( int length ) { int [ ] ttShadow = this . tt ; if ( ( ttShadow == null ) || ( ttShadow . length < length ) ) { this . tt = ttShadow = new int [ length ] ; } return ttShadow ; } } } 	1	['27', '2', '0', '6', '46', '53', '3', '3', '4', '0.74009324', '2106', '1', '2', '0.257142857', '0.209876543', '1', '2', '75.77777778', '9', '1.4815', '1']
package org . apache . tools . ant . taskdefs . optional . ejb ; import java . io . BufferedReader ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStream ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . ExecTask ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . ExecuteStreamHandler ; import org . apache . tools . ant . taskdefs . Java ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class BorlandDeploymentTool extends GenericDeploymentTool implements ExecuteStreamHandler { public static final String PUBLICID_BORLAND_EJB = "-//Inprise Corporation//DTD Enterprise JavaBeans 1.1//EN" ; protected static final String DEFAULT_BAS45_EJB11_DTD_LOCATION = "/com/inprise/j2ee/xml/dtds/ejb-jar.dtd" ; protected static final String DEFAULT_BAS_DTD_LOCATION = "/com/inprise/j2ee/xml/dtds/ejb-inprise.dtd" ; protected static final String BAS_DD = "ejb-inprise.xml" ; protected static final String BES_DD = "ejb-borland.xml" ; protected static final String JAVA2IIOP = "java2iiop" ; protected static final String VERIFY = "com.inprise.ejb.util.Verify" ; private String jarSuffix = "-ejb.jar" ; private String borlandDTD ; private boolean java2iiopdebug = false ; private String java2iioparams = null ; private boolean generateclient = false ; static final int BES = 5 ; static final int BAS = 4 ; private int version = BAS ; private boolean verify = true ; private String verifyArgs = "" ; private Hashtable genfiles = new Hashtable ( ) ; public void setDebug ( boolean debug ) { this . java2iiopdebug = debug ; } public void setVerify ( boolean verify ) { this . verify = verify ; } public void setSuffix ( String inString ) { this . jarSuffix = inString ; } public void setVerifyArgs ( String args ) { this . verifyArgs = args ; } public void setBASdtd ( String inString ) { this . borlandDTD = inString ; } public void setGenerateclient ( boolean b ) { this . generateclient = b ; } public void setVersion ( int version ) { this . version = version ; } public void setJava2iiopParams ( String params ) { this . java2iioparams = params ; } protected DescriptorHandler getBorlandDescriptorHandler ( final File srcDir ) { DescriptorHandler handler = new DescriptorHandler ( getTask ( ) , srcDir ) { protected void processElement ( ) { if ( currentElement . equals ( "type-storage" ) ) { String fileNameWithMETA = currentText ; String fileName = fileNameWithMETA . substring ( META_DIR . length ( ) , fileNameWithMETA . length ( ) ) ; File descriptorFile = new File ( srcDir , fileName ) ; ejbFiles . put ( fileNameWithMETA , descriptorFile ) ; } } } ; handler . registerDTD ( PUBLICID_BORLAND_EJB , borlandDTD == null ? DEFAULT_BAS_DTD_LOCATION : borlandDTD ) ; for ( Iterator i = getConfig ( ) . dtdLocations . iterator ( ) ; i . hasNext ( ) ; ) { EjbJar . DTDLocation dtdLocation = ( EjbJar . DTDLocation ) i . next ( ) ; handler . registerDTD ( dtdLocation . getPublicId ( ) , dtdLocation . getLocation ( ) ) ; } return handler ; } protected void addVendorFiles ( Hashtable ejbFiles , String ddPrefix ) { if ( ! ( version == BES || version == BAS ) ) { throw new BuildException ( "version " + version + " is not supported" ) ; } String dd = ( version == BES ? BES_DD : BAS_DD ) ; log ( "vendor file : " + ddPrefix + dd , Project . MSG_DEBUG ) ; File borlandDD = new File ( getConfig ( ) . descriptorDir , ddPrefix + dd ) ; if ( borlandDD . exists ( ) ) { log ( "Borland specific file found " + borlandDD , Project . MSG_VERBOSE ) ; ejbFiles . put ( META_DIR + dd , borlandDD ) ; } else { log ( "Unable to locate borland deployment descriptor. " + "It was expected to be in " + borlandDD . getPath ( ) , Project . MSG_WARN ) ; return ; } } File getVendorOutputJarFile ( String baseName ) { return new File ( getDestDir ( ) , baseName + jarSuffix ) ; } private void verifyBorlandJar ( File sourceJar ) { if ( version == BAS ) { verifyBorlandJarV4 ( sourceJar ) ; return ; } if ( version == BES ) { verifyBorlandJarV5 ( sourceJar ) ; return ; } log ( "verify jar skipped because the version is invalid [" + version + "]" , Project . MSG_WARN ) ; } private void verifyBorlandJarV5 ( File sourceJar ) { log ( "verify BES " + sourceJar , Project . MSG_INFO ) ; try { ExecTask execTask = null ; execTask = new ExecTask ( getTask ( ) ) ; execTask . setDir ( new File ( "." ) ) ; execTask . setExecutable ( "iastool" ) ; if ( getCombinedClasspath ( ) != null ) { execTask . createArg ( ) . setValue ( "-VBJclasspath" ) ; execTask . createArg ( ) . setValue ( getCombinedClasspath ( ) . toString ( ) ) ; } if ( java2iiopdebug ) { execTask . createArg ( ) . setValue ( "-debug" ) ; } execTask . createArg ( ) . setValue ( "-verify" ) ; execTask . createArg ( ) . setValue ( "-src" ) ; execTask . createArg ( ) . setValue ( sourceJar . getPath ( ) ) ; log ( "Calling iastool" , Project . MSG_VERBOSE ) ; execTask . execute ( ) ; } catch ( Exception e ) { String msg = "Exception while calling generateclient Details: " + e . toString ( ) ; throw new BuildException ( msg , e ) ; } } private void verifyBorlandJarV4 ( File sourceJar ) { org . apache . tools . ant . taskdefs . Java javaTask = null ; log ( "verify BAS " + sourceJar , Project . MSG_INFO ) ; try { String args = verifyArgs ; args += " " + sourceJar . getPath ( ) ; javaTask = new Java ( getTask ( ) ) ; javaTask . setTaskName ( "verify" ) ; javaTask . setClassname ( VERIFY ) ; Commandline . Argument arguments = javaTask . createArg ( ) ; arguments . setLine ( args ) ; Path classpath = getCombinedClasspath ( ) ; if ( classpath != null ) { javaTask . setClasspath ( classpath ) ; javaTask . setFork ( true ) ; } log ( "Calling " + VERIFY + " for " + sourceJar . toString ( ) , Project . MSG_VERBOSE ) ; javaTask . execute ( ) ; } catch ( Exception e ) { String msg = "Exception while calling " + VERIFY + " Details: " + e . toString ( ) ; throw new BuildException ( msg , e ) ; } } private void generateClient ( File sourceJar ) { getTask ( ) . getProject ( ) . addTaskDefinition ( "internal_bas_generateclient" , org . apache . tools . ant . taskdefs . optional . ejb . BorlandGenerateClient . class ) ; org . apache . tools . ant . taskdefs . optional . ejb . BorlandGenerateClient gentask = null ; log ( "generate client for " + sourceJar , Project . MSG_INFO ) ; try { Project project = getTask ( ) . getProject ( ) ; gentask = ( BorlandGenerateClient ) project . createTask ( "internal_bas_generateclient" ) ; gentask . setEjbjar ( sourceJar ) ; gentask . setDebug ( java2iiopdebug ) ; Path classpath = getCombinedClasspath ( ) ; if ( classpath != null ) { gentask . setClasspath ( classpath ) ; } gentask . setVersion ( version ) ; gentask . setTaskName ( "generate client" ) ; gentask . execute ( ) ; } catch ( Exception e ) { String msg = "Exception while calling " + VERIFY + " Details: " + e . toString ( ) ; throw new BuildException ( msg , e ) ; } } private void buildBorlandStubs ( Iterator ithomes ) { Execute execTask = null ; execTask = new Execute ( this ) ; Project project = getTask ( ) . getProject ( ) ; execTask . setAntRun ( project ) ; execTask . setWorkingDirectory ( project . getBaseDir ( ) ) ; Commandline commandline = new Commandline ( ) ; commandline . setExecutable ( JAVA2IIOP ) ; if ( java2iiopdebug ) { commandline . createArgument ( ) . setValue ( "-VBJdebug" ) ; } commandline . createArgument ( ) . setValue ( "-VBJclasspath" ) ; commandline . createArgument ( ) . setPath ( getCombinedClasspath ( ) ) ; commandline . createArgument ( ) . setValue ( "-list_files" ) ; commandline . createArgument ( ) . setValue ( "-no_tie" ) ; if ( java2iioparams != null ) { log ( "additional  " + java2iioparams + " to java2iiop " , 0 ) ; commandline . createArgument ( ) . setValue ( java2iioparams ) ; } commandline . createArgument ( ) . setValue ( "-root_dir" ) ; commandline . createArgument ( ) . setValue ( getConfig ( ) . srcDir . getAbsolutePath ( ) ) ; commandline . createArgument ( ) . setValue ( "-compile" ) ; while ( ithomes . hasNext ( ) ) { commandline . createArgument ( ) . setValue ( ithomes . next ( ) . toString ( ) ) ; } try { log ( "Calling java2iiop" , Project . MSG_VERBOSE ) ; log ( commandline . describeCommand ( ) , Project . MSG_DEBUG ) ; execTask . setCommandline ( commandline . getCommandline ( ) ) ; int result = execTask . execute ( ) ; if ( Execute . isFailure ( result ) ) { String msg = "Failed executing java2iiop (ret code is " + result + ")" ; throw new BuildException ( msg , getTask ( ) . getLocation ( ) ) ; } } catch ( java . io . IOException e ) { log ( "java2iiop exception :" + e . getMessage ( ) , Project . MSG_ERR ) ; throw new BuildException ( e , getTask ( ) . getLocation ( ) ) ; } } protected void writeJar ( String baseName , File jarFile , Hashtable files , String publicId ) throws BuildException { Vector homes = new Vector ( ) ; Iterator it = files . keySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { String clazz = ( String ) it . next ( ) ; if ( clazz . endsWith ( "Home.class" ) ) { String home = toClass ( clazz ) ; homes . add ( home ) ; log ( " Home " + home , Project . MSG_VERBOSE ) ; } } buildBorlandStubs ( homes . iterator ( ) ) ; files . putAll ( genfiles ) ; super . writeJar ( baseName , jarFile , files , publicId ) ; if ( verify ) { verifyBorlandJar ( jarFile ) ; } if ( generateclient ) { generateClient ( jarFile ) ; } } private String toClass ( String filename ) { String classname = filename . substring ( 0 , filename . lastIndexOf ( ".class" ) ) ; classname = classname . replace ( '\\' , '.' ) ; return classname ; } private String toClassFile ( String filename ) { String classfile = filename . substring ( 0 , filename . lastIndexOf ( ".java" ) ) ; classfile = classfile + ".class" ; return classfile ; } public void start ( ) throws IOException { } public void stop ( ) { } public void setProcessInputStream ( OutputStream param1 ) throws IOException { } public void setProcessOutputStream ( InputStream is ) throws IOException { try { BufferedReader reader = new BufferedReader ( new InputStreamReader ( is ) ) ; String javafile ; while ( ( javafile = reader . readLine ( ) ) != null ) { if ( javafile . endsWith ( ".java" ) ) { String classfile = toClassFile ( javafile ) ; String key = classfile . substring ( getConfig ( ) . srcDir . getAbsolutePath ( ) . length ( ) + 1 ) ; genfiles . put ( key , new File ( classfile ) ) ; } } reader . close ( ) ; } catch ( Exception e ) { String msg = "Exception while parsing  java2iiop output. Details: " + e . toString ( ) ; throw new BuildException ( msg , e ) ; } } public void setProcessErrorStream ( InputStream is ) throws IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( is ) ) ; String s = reader . readLine ( ) ; if ( s != null ) { log ( "[java2iiop] " + s , Project . MSG_ERR ) ; } } } 	1	['25', '2', '0', '18', '117', '230', '2', '17', '14', '0.958333333', '877', '0.789473684', '0', '0.571428571', '0.222222222', '1', '4', '33.32', '5', '1.64', '2']
package org . apache . tools . ant . listener ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintStream ; import java . util . Hashtable ; import java . util . Vector ; import java . util . Properties ; import java . util . Enumeration ; import java . util . StringTokenizer ; import org . apache . tools . ant . BuildEvent ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DefaultLogger ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . email . EmailAddress ; import org . apache . tools . ant . taskdefs . email . Message ; import org . apache . tools . ant . taskdefs . email . Mailer ; import org . apache . tools . ant . util . ClasspathUtils ; import org . apache . tools . ant . util . DateUtils ; import org . apache . tools . ant . util . StringUtils ; import org . apache . tools . mail . MailMessage ; public class MailLogger extends DefaultLogger { private StringBuffer buffer = new StringBuffer ( ) ; public void buildFinished ( BuildEvent event ) { super . buildFinished ( event ) ; Project project = event . getProject ( ) ; Hashtable properties = project . getProperties ( ) ; Properties fileProperties = new Properties ( ) ; String filename = ( String ) properties . get ( "MailLogger.properties.file" ) ; if ( filename != null ) { InputStream is = null ; try { is = new FileInputStream ( filename ) ; fileProperties . load ( is ) ; } catch ( IOException ioe ) { } finally { if ( is != null ) { try { is . close ( ) ; } catch ( IOException e ) { } } } } for ( Enumeration e = fileProperties . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; String value = fileProperties . getProperty ( key ) ; properties . put ( key , project . replaceProperties ( value ) ) ; } boolean success = ( event . getException ( ) == null ) ; String prefix = success ? "success" : "failure" ; try { boolean notify = Project . toBoolean ( getValue ( properties , prefix + ".notify" , "on" ) ) ; if ( ! notify ) { return ; } String mailhost = getValue ( properties , "mailhost" , "localhost" ) ; int port = Integer . parseInt ( getValue ( properties , "port" , String . valueOf ( MailMessage . DEFAULT_PORT ) ) ) ; String user = getValue ( properties , "user" , "" ) ; String password = getValue ( properties , "password" , "" ) ; boolean ssl = Project . toBoolean ( getValue ( properties , "ssl" , "off" ) ) ; String from = getValue ( properties , "from" , null ) ; String replytoList = getValue ( properties , "replyto" , "" ) ; String toList = getValue ( properties , prefix + ".to" , null ) ; String subject = getValue ( properties , prefix + ".subject" , ( success ) ? "Build Success" : "Build Failure" ) ; if ( user . equals ( "" ) && password . equals ( "" ) && ! ssl ) { sendMail ( mailhost , port , from , replytoList , toList , subject , buffer . substring ( 0 ) ) ; } else { sendMimeMail ( event . getProject ( ) , mailhost , port , user , password , ssl , from , replytoList , toList , subject , buffer . substring ( 0 ) ) ; } } catch ( Exception e ) { System . out . println ( "MailLogger failed to send e-mail!" ) ; e . printStackTrace ( System . err ) ; } } protected void log ( String message ) { buffer . append ( message ) . append ( StringUtils . LINE_SEP ) ; } private String getValue ( Hashtable properties , String name , String defaultValue ) throws Exception { String propertyName = "MailLogger." + name ; String value = ( String ) properties . get ( propertyName ) ; if ( value == null ) { value = defaultValue ; } if ( value == null ) { throw new Exception ( "Missing required parameter: " + propertyName ) ; } return value ; } private void sendMail ( String mailhost , int port , String from , String replyToList , String toList , String subject , String message ) throws IOException { MailMessage mailMessage = new MailMessage ( mailhost , port ) ; mailMessage . setHeader ( "Date" , DateUtils . getDateForHeader ( ) ) ; mailMessage . from ( from ) ; if ( ! replyToList . equals ( "" ) ) { StringTokenizer t = new StringTokenizer ( replyToList , ", " , false ) ; while ( t . hasMoreTokens ( ) ) { mailMessage . replyto ( t . nextToken ( ) ) ; } } StringTokenizer t = new StringTokenizer ( toList , ", " , false ) ; while ( t . hasMoreTokens ( ) ) { mailMessage . to ( t . nextToken ( ) ) ; } mailMessage . setSubject ( subject ) ; PrintStream ps = mailMessage . getPrintStream ( ) ; ps . println ( message ) ; mailMessage . sendAndClose ( ) ; } private void sendMimeMail ( Project project , String host , int port , String user , String password , boolean ssl , String from , String replyToString , String toString , String subject , String message ) { Mailer mailer = null ; try { mailer = ( Mailer ) ClasspathUtils . newInstance ( "org.apache.tools.ant.taskdefs.email.MimeMailer" , MailLogger . class . getClassLoader ( ) , Mailer . class ) ; } catch ( BuildException e ) { Throwable t = e . getCause ( ) == null ? e : e . getCause ( ) ; log ( "Failed to initialise MIME mail: " + t . getMessage ( ) ) ; return ; } Vector replyToList = vectorizeEmailAddresses ( replyToString ) ; mailer . setHost ( host ) ; mailer . setPort ( port ) ; mailer . setUser ( user ) ; mailer . setPassword ( password ) ; mailer . setSSL ( ssl ) ; Message mymessage = new Message ( message ) ; mymessage . setProject ( project ) ; mailer . setMessage ( mymessage ) ; mailer . setFrom ( new EmailAddress ( from ) ) ; mailer . setReplyToList ( replyToList ) ; Vector toList = vectorizeEmailAddresses ( toString ) ; mailer . setToList ( toList ) ; mailer . setCcList ( new Vector ( ) ) ; mailer . setBccList ( new Vector ( ) ) ; mailer . setFiles ( new Vector ( ) ) ; mailer . setSubject ( subject ) ; mailer . send ( ) ; } private Vector vectorizeEmailAddresses ( String listString ) { Vector emailList = new Vector ( ) ; StringTokenizer tokens = new StringTokenizer ( listString , "," ) ; while ( tokens . hasMoreTokens ( ) ) { emailList . addElement ( new EmailAddress ( tokens . nextToken ( ) ) ) ; } return emailList ; } } 	1	['7', '2', '0', '11', '74', '15', '0', '11', '2', '0.722222222', '487', '0.333333333', '0', '0.727272727', '0.367346939', '2', '4', '68.14285714', '13', '3.1429', '4']
package org . apache . tools . ant . types ; import java . io . File ; import java . io . FileInputStream ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Vector ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . FileUtils ; public class FilterSet extends DataType implements Cloneable { public static class Filter { String token ; String value ; public Filter ( String token , String value ) { setToken ( token ) ; setValue ( value ) ; } public Filter ( ) { } public void setToken ( String token ) { this . token = token ; } public void setValue ( String value ) { this . value = value ; } public String getToken ( ) { return token ; } public String getValue ( ) { return value ; } } public class FiltersFile { public FiltersFile ( ) { } public void setFile ( File file ) { filtersFiles . add ( file ) ; } } public static class OnMissing extends EnumeratedAttribute { private static final String [ ] VALUES = new String [ ] { "fail" , "warn" , "ignore" } ; public static final OnMissing FAIL = new OnMissing ( "fail" ) ; public static final OnMissing WARN = new OnMissing ( "warn" ) ; public static final OnMissing IGNORE = new OnMissing ( "ignore" ) ; private static final int FAIL_INDEX = 0 ; private static final int WARN_INDEX = 1 ; private static final int IGNORE_INDEX = 2 ; public OnMissing ( ) { } public OnMissing ( String value ) { setValue ( value ) ; } public String [ ] getValues ( ) { return VALUES ; } } public static final String DEFAULT_TOKEN_START = "@" ; public static final String DEFAULT_TOKEN_END = "@" ; private String startOfToken = DEFAULT_TOKEN_START ; private String endOfToken = DEFAULT_TOKEN_END ; private Vector passedTokens ; private boolean duplicateToken = false ; private boolean recurse = true ; private Hashtable filterHash = null ; private Vector filtersFiles = new Vector ( ) ; private OnMissing onMissingFiltersFile = OnMissing . FAIL ; private boolean readingFiles = false ; private int recurseDepth = 0 ; private Vector filters = new Vector ( ) ; public FilterSet ( ) { } protected FilterSet ( FilterSet filterset ) { super ( ) ; this . filters = ( Vector ) filterset . getFilters ( ) . clone ( ) ; } protected synchronized Vector getFilters ( ) { if ( isReference ( ) ) { return getRef ( ) . getFilters ( ) ; } if ( ! readingFiles ) { readingFiles = true ; for ( int i = 0 , sz = filtersFiles . size ( ) ; i < sz ; i ++ ) { readFiltersFromFile ( ( File ) filtersFiles . get ( i ) ) ; } filtersFiles . clear ( ) ; readingFiles = false ; } return filters ; } protected FilterSet getRef ( ) { return ( FilterSet ) getCheckedRef ( FilterSet . class , "filterset" ) ; } public synchronized Hashtable getFilterHash ( ) { if ( filterHash == null ) { filterHash = new Hashtable ( getFilters ( ) . size ( ) ) ; for ( Enumeration e = getFilters ( ) . elements ( ) ; e . hasMoreElements ( ) ; ) { Filter filter = ( Filter ) e . nextElement ( ) ; filterHash . put ( filter . getToken ( ) , filter . getValue ( ) ) ; } } return filterHash ; } public void setFiltersfile ( File filtersFile ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } filtersFiles . add ( filtersFile ) ; } public void setBeginToken ( String startOfToken ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( startOfToken == null || "" . equals ( startOfToken ) ) { throw new BuildException ( "beginToken must not be empty" ) ; } this . startOfToken = startOfToken ; } public String getBeginToken ( ) { if ( isReference ( ) ) { return getRef ( ) . getBeginToken ( ) ; } return startOfToken ; } public void setEndToken ( String endOfToken ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( endOfToken == null || "" . equals ( endOfToken ) ) { throw new BuildException ( "endToken must not be empty" ) ; } this . endOfToken = endOfToken ; } public String getEndToken ( ) { if ( isReference ( ) ) { return getRef ( ) . getEndToken ( ) ; } return endOfToken ; } public void setRecurse ( boolean recurse ) { this . recurse = recurse ; } public boolean isRecurse ( ) { return recurse ; } public synchronized void readFiltersFromFile ( File filtersFile ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( ! filtersFile . exists ( ) ) { handleMissingFile ( "Could not read filters from file " + filtersFile + " as it doesn't exist." ) ; } if ( filtersFile . isFile ( ) ) { log ( "Reading filters from " + filtersFile , Project . MSG_VERBOSE ) ; FileInputStream in = null ; try { Properties props = new Properties ( ) ; in = new FileInputStream ( filtersFile ) ; props . load ( in ) ; Enumeration e = props . propertyNames ( ) ; Vector filts = getFilters ( ) ; while ( e . hasMoreElements ( ) ) { String strPropName = ( String ) e . nextElement ( ) ; String strValue = props . getProperty ( strPropName ) ; filts . addElement ( new Filter ( strPropName , strValue ) ) ; } } catch ( Exception ex ) { throw new BuildException ( "Could not read filters from file: " + filtersFile ) ; } finally { FileUtils . close ( in ) ; } } else { handleMissingFile ( "Must specify a file rather than a directory in " + "the filtersfile attribute:" + filtersFile ) ; } filterHash = null ; } public synchronized String replaceTokens ( String line ) { return iReplaceTokens ( line ) ; } public synchronized void addFilter ( Filter filter ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } filters . addElement ( filter ) ; filterHash = null ; } public FiltersFile createFiltersfile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return new FiltersFile ( ) ; } public synchronized void addFilter ( String token , String value ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } addFilter ( new Filter ( token , value ) ) ; } public synchronized void addConfiguredFilterSet ( FilterSet filterSet ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } for ( Enumeration e = filterSet . getFilters ( ) . elements ( ) ; e . hasMoreElements ( ) ; ) { addFilter ( ( Filter ) e . nextElement ( ) ) ; } } public synchronized boolean hasFilters ( ) { return getFilters ( ) . size ( ) > 0 ; } public synchronized Object clone ( ) throws BuildException { if ( isReference ( ) ) { return ( ( FilterSet ) getRef ( ) ) . clone ( ) ; } try { FilterSet fs = ( FilterSet ) super . clone ( ) ; fs . filters = ( Vector ) getFilters ( ) . clone ( ) ; fs . setProject ( getProject ( ) ) ; return fs ; } catch ( CloneNotSupportedException e ) { throw new BuildException ( e ) ; } } public void setOnMissingFiltersFile ( OnMissing onMissingFiltersFile ) { this . onMissingFiltersFile = onMissingFiltersFile ; } public OnMissing getOnMissingFiltersFile ( ) { return onMissingFiltersFile ; } private synchronized String iReplaceTokens ( String line ) { String beginToken = getBeginToken ( ) ; String endToken = getEndToken ( ) ; int index = line . indexOf ( beginToken ) ; if ( index > - 1 ) { Hashtable tokens = getFilterHash ( ) ; try { StringBuffer b = new StringBuffer ( ) ; int i = 0 ; String token = null ; String value = null ; while ( index > - 1 ) { int endIndex = line . indexOf ( endToken , index + beginToken . length ( ) + 1 ) ; if ( endIndex == - 1 ) { break ; } token = line . substring ( index + beginToken . length ( ) , endIndex ) ; b . append ( line . substring ( i , index ) ) ; if ( tokens . containsKey ( token ) ) { value = ( String ) tokens . get ( token ) ; if ( recurse && ! value . equals ( token ) ) { value = replaceTokens ( value , token ) ; } log ( "Replacing: " + beginToken + token + endToken + " -> " + value , Project . MSG_VERBOSE ) ; b . append ( value ) ; i = index + beginToken . length ( ) + token . length ( ) + endToken . length ( ) ; } else { b . append ( beginToken ) ; i = index + beginToken . length ( ) ; } index = line . indexOf ( beginToken , i ) ; } b . append ( line . substring ( i ) ) ; return b . toString ( ) ; } catch ( StringIndexOutOfBoundsException e ) { return line ; } } else { return line ; } } private synchronized String replaceTokens ( String line , String parent ) throws BuildException { String beginToken = getBeginToken ( ) ; String endToken = getEndToken ( ) ; if ( recurseDepth == 0 ) { passedTokens = new Vector ( ) ; } recurseDepth ++ ; if ( passedTokens . contains ( parent ) && ! duplicateToken ) { duplicateToken = true ; System . out . println ( "Infinite loop in tokens. Currently known tokens : " + passedTokens . toString ( ) + "\nProblem token : " + beginToken + parent + endToken + " called from " + beginToken + passedTokens . lastElement ( ) . toString ( ) + endToken ) ; recurseDepth -- ; return parent ; } passedTokens . addElement ( parent ) ; String value = iReplaceTokens ( line ) ; if ( value . indexOf ( beginToken ) == - 1 && ! duplicateToken && recurseDepth == 1 ) { passedTokens = null ; } else if ( duplicateToken ) { if ( passedTokens . size ( ) > 0 ) { value = ( String ) passedTokens . remove ( passedTokens . size ( ) - 1 ) ; if ( passedTokens . size ( ) == 0 ) { value = beginToken + value + endToken ; duplicateToken = false ; } } } recurseDepth -- ; return value ; } private void handleMissingFile ( String message ) { switch ( onMissingFiltersFile . getIndex ( ) ) { case OnMissing . IGNORE_INDEX : return ; case OnMissing . FAIL_INDEX : throw new BuildException ( message ) ; case OnMissing . WARN_INDEX : log ( message , Project . MSG_WARN ) ; return ; default : throw new BuildException ( "Invalid value for onMissingFiltersFile" ) ; } } } 	1	['26', '3', '0', '12', '85', '217', '7', '7', '19', '0.777142857', '811', '0.785714286', '1', '0.555555556', '0.21978022', '2', '3', '29.65384615', '7', '1.9615', '2']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . text . DateFormat ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Iterator ; import java . util . Locale ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . FileList ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . Touchable ; import org . apache . tools . ant . types . resources . Union ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . FileNameMapper ; public class Touch extends Task { private interface DateFormatFactory { DateFormat getPrimaryFormat ( ) ; DateFormat getFallbackFormat ( ) ; } private static final DateFormatFactory DEFAULT_DF_FACTORY = new DateFormatFactory ( ) { public DateFormat getPrimaryFormat ( ) { return DateFormat . getDateTimeInstance ( DateFormat . SHORT , DateFormat . SHORT , Locale . US ) ; } public DateFormat getFallbackFormat ( ) { return DateFormat . getDateTimeInstance ( DateFormat . SHORT , DateFormat . MEDIUM , Locale . US ) ; } } ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private File file ; private long millis = - 1 ; private String dateTime ; private Vector filesets = new Vector ( ) ; private Union resources = new Union ( ) ; private boolean dateTimeConfigured ; private boolean mkdirs ; private boolean verbose = true ; private FileNameMapper fileNameMapper = null ; private DateFormatFactory dfFactory = DEFAULT_DF_FACTORY ; public Touch ( ) { } public void setFile ( File file ) { this . file = file ; } public void setMillis ( long millis ) { this . millis = millis ; } public void setDatetime ( String dateTime ) { if ( this . dateTime != null ) { log ( "Resetting datetime attribute to " + dateTime , Project . MSG_VERBOSE ) ; } this . dateTime = dateTime ; dateTimeConfigured = false ; } public void setMkdirs ( boolean mkdirs ) { this . mkdirs = mkdirs ; } public void setVerbose ( boolean verbose ) { this . verbose = verbose ; } public void setPattern ( final String pattern ) { dfFactory = new DateFormatFactory ( ) { public DateFormat getPrimaryFormat ( ) { return new SimpleDateFormat ( pattern ) ; } public DateFormat getFallbackFormat ( ) { return null ; } } ; } public void addConfiguredMapper ( Mapper mapper ) { add ( mapper . getImplementation ( ) ) ; } public void add ( FileNameMapper fileNameMapper ) throws BuildException { if ( this . fileNameMapper != null ) { throw new BuildException ( "Only one mapper may be added to the " + getTaskName ( ) + " task." ) ; } this . fileNameMapper = fileNameMapper ; } public void addFileset ( FileSet set ) { filesets . add ( set ) ; add ( set ) ; } public void addFilelist ( FileList list ) { add ( list ) ; } public void add ( ResourceCollection rc ) { resources . add ( rc ) ; } protected synchronized void checkConfiguration ( ) throws BuildException { if ( file == null && resources . size ( ) == 0 ) { throw new BuildException ( "Specify at least one source" + "--a file or resource collection." ) ; } if ( file != null && file . exists ( ) && file . isDirectory ( ) ) { throw new BuildException ( "Use a resource collection to touch directories." ) ; } if ( dateTime != null && ! dateTimeConfigured ) { long workmillis = millis ; DateFormat df = dfFactory . getPrimaryFormat ( ) ; ParseException pe = null ; try { workmillis = df . parse ( dateTime ) . getTime ( ) ; } catch ( ParseException peOne ) { df = dfFactory . getFallbackFormat ( ) ; if ( df == null ) { pe = peOne ; } else { try { workmillis = df . parse ( dateTime ) . getTime ( ) ; } catch ( ParseException peTwo ) { pe = peTwo ; } } } if ( pe != null ) { throw new BuildException ( pe . getMessage ( ) , pe , getLocation ( ) ) ; } if ( workmillis < 0 ) { throw new BuildException ( "Date of " + dateTime + " results in negative " + "milliseconds value " + "relative to epoch " + "(January 1, 1970, " + "00:00:00 GMT)." ) ; } log ( "Setting millis to " + workmillis + " from datetime attribute" , ( ( millis < 0 ) ? Project . MSG_DEBUG : Project . MSG_VERBOSE ) ) ; setMillis ( workmillis ) ; dateTimeConfigured = true ; } } public void execute ( ) throws BuildException { checkConfiguration ( ) ; touch ( ) ; } protected void touch ( ) throws BuildException { long defaultTimestamp = getTimestamp ( ) ; if ( file != null ) { touch ( new FileResource ( file . getParentFile ( ) , file . getName ( ) ) , defaultTimestamp ) ; } Iterator iter = resources . iterator ( ) ; while ( iter . hasNext ( ) ) { Resource r = ( Resource ) iter . next ( ) ; if ( ! ( r instanceof Touchable ) ) { throw new BuildException ( "Can't touch " + r ) ; } touch ( r , defaultTimestamp ) ; } for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; File fromDir = fs . getDir ( getProject ( ) ) ; String [ ] srcDirs = ds . getIncludedDirectories ( ) ; for ( int j = 0 ; j < srcDirs . length ; j ++ ) { touch ( new FileResource ( fromDir , srcDirs [ j ] ) , defaultTimestamp ) ; } } } protected void touch ( File file ) { touch ( file , getTimestamp ( ) ) ; } private long getTimestamp ( ) { return ( millis < 0 ) ? System . currentTimeMillis ( ) : millis ; } private void touch ( Resource r , long defaultTimestamp ) { if ( fileNameMapper == null ) { if ( r instanceof FileResource ) { touch ( ( ( FileResource ) r ) . getFile ( ) , defaultTimestamp ) ; } else { ( ( Touchable ) r ) . touch ( defaultTimestamp ) ; } } else { String [ ] mapped = fileNameMapper . mapFileName ( r . getName ( ) ) ; if ( mapped != null && mapped . length > 0 ) { long modTime = ( r . isExists ( ) ) ? r . getLastModified ( ) : defaultTimestamp ; for ( int i = 0 ; i < mapped . length ; i ++ ) { touch ( getProject ( ) . resolveFile ( mapped [ i ] ) , modTime ) ; } } } } private void touch ( File file , long modTime ) { if ( ! file . exists ( ) ) { log ( "Creating " + file , ( ( verbose ) ? Project . MSG_INFO : Project . MSG_VERBOSE ) ) ; try { FILE_UTILS . createNewFile ( file , mkdirs ) ; } catch ( IOException ioe ) { throw new BuildException ( "Could not create " + file , ioe , getLocation ( ) ) ; } } if ( ! file . canWrite ( ) ) { throw new BuildException ( "Can not change modification date of " + "read-only file " + file ) ; } FILE_UTILS . setFileLastModified ( file , modTime ) ; } } 	1	['20', '3', '0', '18', '70', '136', '1', '18', '13', '0.824561404', '515', '1', '5', '0.672727273', '0.167464115', '0', '0', '24.15', '7', '1.45', '2']
package org . apache . tools . ant . taskdefs . optional . splash ; import java . io . ByteArrayOutputStream ; import java . io . DataInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import java . net . URLConnection ; import javax . swing . ImageIcon ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . Base64Converter ; public class SplashTask extends Task { private String imgurl = null ; private String proxy = null ; private String user = null ; private String password = null ; private String port = "80" ; private int showDuration = 5000 ; private boolean useProxy = false ; private static SplashScreen splash = null ; public void setImageURL ( String imgurl ) { this . imgurl = imgurl ; } public void setUseproxy ( boolean useProxy ) { this . useProxy = useProxy ; } public void setProxy ( String proxy ) { this . proxy = proxy ; } public void setPort ( String port ) { this . port = port ; } public void setUser ( String user ) { this . user = user ; } public void setPassword ( String password ) { this . password = password ; } public void setShowduration ( int duration ) { this . showDuration = duration ; } public void execute ( ) throws BuildException { if ( splash != null ) { splash . setVisible ( false ) ; getProject ( ) . removeBuildListener ( splash ) ; splash . dispose ( ) ; splash = null ; } log ( "Creating new SplashScreen" , Project . MSG_VERBOSE ) ; InputStream in = null ; if ( imgurl != null ) { try { URLConnection conn = null ; if ( useProxy && ( proxy != null && proxy . length ( ) > 0 ) && ( port != null && port . length ( ) > 0 ) ) { log ( "Using proxied Connection" , Project . MSG_DEBUG ) ; System . getProperties ( ) . put ( "http.proxySet" , "true" ) ; System . getProperties ( ) . put ( "http.proxyHost" , proxy ) ; System . getProperties ( ) . put ( "http.proxyPort" , port ) ; URL url = new URL ( imgurl ) ; conn = url . openConnection ( ) ; if ( user != null && user . length ( ) > 0 ) { String encodedcreds = new Base64Converter ( ) . encode ( user + ":" + password ) ; conn . setRequestProperty ( "Proxy-Authorization" , encodedcreds ) ; } } else { System . getProperties ( ) . put ( "http.proxySet" , "false" ) ; System . getProperties ( ) . put ( "http.proxyHost" , "" ) ; System . getProperties ( ) . put ( "http.proxyPort" , "" ) ; log ( "Using Direction HTTP Connection" , Project . MSG_DEBUG ) ; URL url = new URL ( imgurl ) ; conn = url . openConnection ( ) ; } conn . setDoInput ( true ) ; conn . setDoOutput ( false ) ; in = conn . getInputStream ( ) ; } catch ( Throwable ioe ) { log ( "Unable to download image, trying default Ant Logo" , Project . MSG_DEBUG ) ; log ( "(Exception was \"" + ioe . getMessage ( ) + "\"" , Project . MSG_DEBUG ) ; } } if ( in == null ) { ClassLoader cl = SplashTask . class . getClassLoader ( ) ; if ( cl != null ) { in = cl . getResourceAsStream ( "images/ant_logo_large.gif" ) ; } else { in = ClassLoader . getSystemResourceAsStream ( "images/ant_logo_large.gif" ) ; } } boolean success = false ; if ( in != null ) { DataInputStream din = new DataInputStream ( in ) ; try { ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; int data ; while ( ( data = din . read ( ) ) != - 1 ) { bout . write ( ( byte ) data ) ; } log ( "Got ByteArray, creating splash" , Project . MSG_DEBUG ) ; try { ImageIcon img = new ImageIcon ( bout . toByteArray ( ) ) ; splash = new SplashScreen ( img ) ; success = true ; } catch ( Throwable e ) { logHeadless ( e ) ; } } catch ( Exception e ) { throw new BuildException ( e ) ; } finally { try { din . close ( ) ; } catch ( IOException ioe ) { if ( success ) { throw new BuildException ( ioe ) ; } } } } else { try { splash = new SplashScreen ( "Image Unavailable." ) ; success = true ; } catch ( Throwable e ) { logHeadless ( e ) ; } } if ( success ) { splash . setVisible ( true ) ; splash . toFront ( ) ; getProject ( ) . addBuildListener ( splash ) ; try { Thread . sleep ( showDuration ) ; } catch ( InterruptedException e ) { } } } private void logHeadless ( Throwable e ) { log ( "failed to display SplashScreen, caught " + e . getClass ( ) . getName ( ) + " with message: " + e . getMessage ( ) , Project . MSG_WARN ) ; } } 	1	['11', '3', '0', '6', '53', '23', '0', '6', '9', '0.833333333', '380', '0.888888889', '1', '0.804347826', '0.36', '1', '1', '32.72727273', '1', '0.8182', '1']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . Reader ; import java . io . InputStream ; import java . io . IOException ; import java . io . PrintStream ; import java . io . OutputStream ; import java . io . StringReader ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . io . PipedOutputStream ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . util . Arrays ; import java . util . Vector ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . filters . util . ChainReaderHelper ; import org . apache . tools . ant . util . StringUtils ; import org . apache . tools . ant . util . TeeOutputStream ; import org . apache . tools . ant . util . ReaderInputStream ; import org . apache . tools . ant . util . LeadPipeInputStream ; import org . apache . tools . ant . util . LazyFileOutputStream ; import org . apache . tools . ant . util . OutputStreamFunneler ; import org . apache . tools . ant . util . ConcatFileInputStream ; import org . apache . tools . ant . util . KeepAliveOutputStream ; public class Redirector { private static final String DEFAULT_ENCODING = System . getProperty ( "file.encoding" ) ; private class PropertyOutputStream extends ByteArrayOutputStream { private String property ; private boolean closed = false ; PropertyOutputStream ( String property ) { super ( ) ; this . property = property ; } public void close ( ) throws IOException { if ( ! closed && ! ( append && appendProperties ) ) { setPropertyFromBAOS ( this , property ) ; closed = true ; } } } private File [ ] input ; private File [ ] out ; private File [ ] error ; private boolean logError = false ; private PropertyOutputStream baos = null ; private PropertyOutputStream errorBaos = null ; private String outputProperty ; private String errorProperty ; private String inputString ; private boolean append = false ; private boolean alwaysLog = false ; private boolean createEmptyFiles = true ; private ProjectComponent managingTask ; private OutputStream outputStream = null ; private OutputStream errorStream = null ; private InputStream inputStream = null ; private PrintStream outPrintStream = null ; private PrintStream errorPrintStream = null ; private Vector outputFilterChains ; private Vector errorFilterChains ; private Vector inputFilterChains ; private String outputEncoding = DEFAULT_ENCODING ; private String errorEncoding = DEFAULT_ENCODING ; private String inputEncoding = DEFAULT_ENCODING ; private boolean appendProperties = true ; private ThreadGroup threadGroup = new ThreadGroup ( "redirector" ) ; private boolean logInputString = true ; public Redirector ( Task managingTask ) { this ( ( ProjectComponent ) managingTask ) ; } public Redirector ( ProjectComponent managingTask ) { this . managingTask = managingTask ; } public void setInput ( File input ) { setInput ( ( input == null ) ? null : new File [ ] { input } ) ; } public synchronized void setInput ( File [ ] input ) { this . input = input ; } public synchronized void setInputString ( String inputString ) { this . inputString = inputString ; } public void setLogInputString ( boolean logInputString ) { this . logInputString = logInputString ; } void setInputStream ( InputStream inputStream ) { this . inputStream = inputStream ; } public void setOutput ( File out ) { setOutput ( ( out == null ) ? null : new File [ ] { out } ) ; } public synchronized void setOutput ( File [ ] out ) { this . out = out ; } public synchronized void setOutputEncoding ( String outputEncoding ) { if ( outputEncoding == null ) { throw new IllegalArgumentException ( "outputEncoding must not be null" ) ; } else { this . outputEncoding = outputEncoding ; } } public synchronized void setErrorEncoding ( String errorEncoding ) { if ( errorEncoding == null ) { throw new IllegalArgumentException ( "errorEncoding must not be null" ) ; } else { this . errorEncoding = errorEncoding ; } } public synchronized void setInputEncoding ( String inputEncoding ) { if ( inputEncoding == null ) { throw new IllegalArgumentException ( "inputEncoding must not be null" ) ; } else { this . inputEncoding = inputEncoding ; } } public synchronized void setLogError ( boolean logError ) { this . logError = logError ; } public synchronized void setAppendProperties ( boolean appendProperties ) { this . appendProperties = appendProperties ; } public void setError ( File error ) { setError ( ( error == null ) ? null : new File [ ] { error } ) ; } public synchronized void setError ( File [ ] error ) { this . error = error ; } public synchronized void setOutputProperty ( String outputProperty ) { if ( outputProperty == null || ! ( outputProperty . equals ( this . outputProperty ) ) ) { this . outputProperty = outputProperty ; baos = null ; } } public synchronized void setAppend ( boolean append ) { this . append = append ; } public synchronized void setAlwaysLog ( boolean alwaysLog ) { this . alwaysLog = alwaysLog ; } public synchronized void setCreateEmptyFiles ( boolean createEmptyFiles ) { this . createEmptyFiles = createEmptyFiles ; } public synchronized void setErrorProperty ( String errorProperty ) { if ( errorProperty == null || ! ( errorProperty . equals ( this . errorProperty ) ) ) { this . errorProperty = errorProperty ; errorBaos = null ; } } public synchronized void setInputFilterChains ( Vector inputFilterChains ) { this . inputFilterChains = inputFilterChains ; } public synchronized void setOutputFilterChains ( Vector outputFilterChains ) { this . outputFilterChains = outputFilterChains ; } public synchronized void setErrorFilterChains ( Vector errorFilterChains ) { this . errorFilterChains = errorFilterChains ; } private void setPropertyFromBAOS ( ByteArrayOutputStream baos , String propertyName ) throws IOException { BufferedReader in = new BufferedReader ( new StringReader ( Execute . toString ( baos ) ) ) ; String line = null ; StringBuffer val = new StringBuffer ( ) ; while ( ( line = in . readLine ( ) ) != null ) { if ( val . length ( ) != 0 ) { val . append ( StringUtils . LINE_SEP ) ; } val . append ( line ) ; } managingTask . getProject ( ) . setNewProperty ( propertyName , val . toString ( ) ) ; } public synchronized void createStreams ( ) { if ( out != null && out . length > 0 ) { String logHead = new StringBuffer ( "Output " ) . append ( ( ( append ) ? "appended" : "redirected" ) ) . append ( " to " ) . toString ( ) ; outputStream = foldFiles ( out , logHead , Project . MSG_VERBOSE ) ; } if ( outputProperty != null ) { if ( baos == null ) { baos = new PropertyOutputStream ( outputProperty ) ; managingTask . log ( "Output redirected to property: " + outputProperty , Project . MSG_VERBOSE ) ; } OutputStream keepAliveOutput = new KeepAliveOutputStream ( baos ) ; outputStream = ( outputStream == null ) ? keepAliveOutput : new TeeOutputStream ( outputStream , keepAliveOutput ) ; } else { baos = null ; } if ( error != null && error . length > 0 ) { String logHead = new StringBuffer ( "Error " ) . append ( ( ( append ) ? "appended" : "redirected" ) ) . append ( " to " ) . toString ( ) ; errorStream = foldFiles ( error , logHead , Project . MSG_VERBOSE ) ; } else if ( ! ( logError || outputStream == null ) ) { long funnelTimeout = 0L ; OutputStreamFunneler funneler = new OutputStreamFunneler ( outputStream , funnelTimeout ) ; try { outputStream = funneler . getFunnelInstance ( ) ; errorStream = funneler . getFunnelInstance ( ) ; } catch ( IOException eyeOhEx ) { throw new BuildException ( "error splitting output/error streams" , eyeOhEx ) ; } } if ( errorProperty != null ) { if ( errorBaos == null ) { errorBaos = new PropertyOutputStream ( errorProperty ) ; managingTask . log ( "Error redirected to property: " + errorProperty , Project . MSG_VERBOSE ) ; } OutputStream keepAliveError = new KeepAliveOutputStream ( errorBaos ) ; errorStream = ( error == null || error . length == 0 ) ? keepAliveError : new TeeOutputStream ( errorStream , keepAliveError ) ; } else { errorBaos = null ; } if ( alwaysLog || outputStream == null ) { OutputStream outputLog = new LogOutputStream ( managingTask , Project . MSG_INFO ) ; outputStream = ( outputStream == null ) ? outputLog : new TeeOutputStream ( outputLog , outputStream ) ; } if ( alwaysLog || errorStream == null ) { OutputStream errorLog = new LogOutputStream ( managingTask , Project . MSG_WARN ) ; errorStream = ( errorStream == null ) ? errorLog : new TeeOutputStream ( errorLog , errorStream ) ; } if ( ( outputFilterChains != null && outputFilterChains . size ( ) > 0 ) || ! ( outputEncoding . equalsIgnoreCase ( inputEncoding ) ) ) { try { LeadPipeInputStream snk = new LeadPipeInputStream ( ) ; snk . setManagingComponent ( managingTask ) ; InputStream outPumpIn = snk ; Reader reader = new InputStreamReader ( outPumpIn , inputEncoding ) ; if ( outputFilterChains != null && outputFilterChains . size ( ) > 0 ) { ChainReaderHelper helper = new ChainReaderHelper ( ) ; helper . setProject ( managingTask . getProject ( ) ) ; helper . setPrimaryReader ( reader ) ; helper . setFilterChains ( outputFilterChains ) ; reader = helper . getAssembledReader ( ) ; } outPumpIn = new ReaderInputStream ( reader , outputEncoding ) ; Thread t = new Thread ( threadGroup , new StreamPumper ( outPumpIn , outputStream , true ) , "output pumper" ) ; t . setPriority ( Thread . MAX_PRIORITY ) ; outputStream = new PipedOutputStream ( snk ) ; t . start ( ) ; } catch ( IOException eyeOhEx ) { throw new BuildException ( "error setting up output stream" , eyeOhEx ) ; } } if ( ( errorFilterChains != null && errorFilterChains . size ( ) > 0 ) || ! ( errorEncoding . equalsIgnoreCase ( inputEncoding ) ) ) { try { LeadPipeInputStream snk = new LeadPipeInputStream ( ) ; snk . setManagingComponent ( managingTask ) ; InputStream errPumpIn = snk ; Reader reader = new InputStreamReader ( errPumpIn , inputEncoding ) ; if ( errorFilterChains != null && errorFilterChains . size ( ) > 0 ) { ChainReaderHelper helper = new ChainReaderHelper ( ) ; helper . setProject ( managingTask . getProject ( ) ) ; helper . setPrimaryReader ( reader ) ; helper . setFilterChains ( errorFilterChains ) ; reader = helper . getAssembledReader ( ) ; } errPumpIn = new ReaderInputStream ( reader , errorEncoding ) ; Thread t = new Thread ( threadGroup , new StreamPumper ( errPumpIn , errorStream , true ) , "error pumper" ) ; t . setPriority ( Thread . MAX_PRIORITY ) ; errorStream = new PipedOutputStream ( snk ) ; t . start ( ) ; } catch ( IOException eyeOhEx ) { throw new BuildException ( "error setting up error stream" , eyeOhEx ) ; } } if ( input != null && input . length > 0 ) { managingTask . log ( "Redirecting input from file" + ( ( input . length == 1 ) ? "" : "s" ) , Project . MSG_VERBOSE ) ; try { inputStream = new ConcatFileInputStream ( input ) ; } catch ( IOException eyeOhEx ) { throw new BuildException ( eyeOhEx ) ; } ( ( ConcatFileInputStream ) inputStream ) . setManagingComponent ( managingTask ) ; } else if ( inputString != null ) { StringBuffer buf = new StringBuffer ( "Using input " ) ; if ( logInputString ) { buf . append ( '"' ) . append ( inputString ) . append ( '"' ) ; } else { buf . append ( "string" ) ; } managingTask . log ( buf . toString ( ) , Project . MSG_VERBOSE ) ; inputStream = new ByteArrayInputStream ( inputString . getBytes ( ) ) ; } if ( inputStream != null && inputFilterChains != null && inputFilterChains . size ( ) > 0 ) { ChainReaderHelper helper = new ChainReaderHelper ( ) ; helper . setProject ( managingTask . getProject ( ) ) ; try { helper . setPrimaryReader ( new InputStreamReader ( inputStream , inputEncoding ) ) ; } catch ( IOException eyeOhEx ) { throw new BuildException ( "error setting up input stream" , eyeOhEx ) ; } helper . setFilterChains ( inputFilterChains ) ; inputStream = new ReaderInputStream ( helper . getAssembledReader ( ) , inputEncoding ) ; } } public synchronized ExecuteStreamHandler createHandler ( ) throws BuildException { createStreams ( ) ; return new PumpStreamHandler ( outputStream , errorStream , inputStream ) ; } protected synchronized void handleOutput ( String output ) { if ( outPrintStream == null ) { outPrintStream = new PrintStream ( outputStream ) ; } outPrintStream . print ( output ) ; } protected synchronized int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException { if ( inputStream == null ) { return managingTask . getProject ( ) . defaultInput ( buffer , offset , length ) ; } else { return inputStream . read ( buffer , offset , length ) ; } } protected synchronized void handleFlush ( String output ) { if ( outPrintStream == null ) { outPrintStream = new PrintStream ( outputStream ) ; } outPrintStream . print ( output ) ; outPrintStream . flush ( ) ; } protected synchronized void handleErrorOutput ( String output ) { if ( errorPrintStream == null ) { errorPrintStream = new PrintStream ( errorStream ) ; } errorPrintStream . print ( output ) ; } protected synchronized void handleErrorFlush ( String output ) { if ( errorPrintStream == null ) { errorPrintStream = new PrintStream ( errorStream ) ; } errorPrintStream . print ( output ) ; } public synchronized OutputStream getOutputStream ( ) { return outputStream ; } public synchronized OutputStream getErrorStream ( ) { return errorStream ; } public synchronized InputStream getInputStream ( ) { return inputStream ; } public synchronized void complete ( ) throws IOException { System . out . flush ( ) ; System . err . flush ( ) ; if ( inputStream != null ) { inputStream . close ( ) ; } outputStream . flush ( ) ; outputStream . close ( ) ; errorStream . flush ( ) ; errorStream . close ( ) ; while ( threadGroup . activeCount ( ) > 0 ) { try { managingTask . log ( "waiting for " + threadGroup . activeCount ( ) + " Threads:" , Project . MSG_DEBUG ) ; Thread [ ] thread = new Thread [ threadGroup . activeCount ( ) ] ; threadGroup . enumerate ( thread ) ; for ( int i = 0 ; i < thread . length && thread [ i ] != null ; i ++ ) { try { managingTask . log ( thread [ i ] . toString ( ) , Project . MSG_DEBUG ) ; } catch ( NullPointerException enPeaEx ) { } } wait ( 1000 ) ; } catch ( InterruptedException eyeEx ) { } } setProperties ( ) ; inputStream = null ; outputStream = null ; errorStream = null ; outPrintStream = null ; errorPrintStream = null ; } public synchronized void setProperties ( ) { if ( baos != null ) { try { baos . close ( ) ; } catch ( IOException eyeOhEx ) { } } if ( errorBaos != null ) { try { errorBaos . close ( ) ; } catch ( IOException eyeOhEx ) { } } } private OutputStream foldFiles ( File [ ] file , String logHead , int loglevel ) { OutputStream result = new LazyFileOutputStream ( file [ 0 ] , append , createEmptyFiles ) ; managingTask . log ( logHead + file [ 0 ] , loglevel ) ; char [ ] c = new char [ logHead . length ( ) ] ; Arrays . fill ( c , ' ' ) ; String indent = new String ( c ) ; for ( int i = 1 ; i < file . length ; i ++ ) { outputStream = new TeeOutputStream ( outputStream , new LazyFileOutputStream ( file [ i ] , append , createEmptyFiles ) ) ; managingTask . log ( indent + file [ i ] , loglevel ) ; } return result ; } } 	1	['42', '1', '0', '24', '109', '653', '6', '19', '30', '0.899825784', '1212', '1', '3', '0', '0.146341463', '0', '0', '27.19047619', '40', '2.2619', '2']
package org . apache . tools . zip ; public final class ZipShort implements Cloneable { private int value ; public ZipShort ( int value ) { this . value = value ; } public ZipShort ( byte [ ] bytes ) { this ( bytes , 0 ) ; } public ZipShort ( byte [ ] bytes , int offset ) { value = ZipShort . getValue ( bytes , offset ) ; } public byte [ ] getBytes ( ) { byte [ ] result = new byte [ 2 ] ; result [ 0 ] = ( byte ) ( value & 0xFF ) ; result [ 1 ] = ( byte ) ( ( value & 0xFF00 ) > > 8 ) ; return result ; } public int getValue ( ) { return value ; } public static byte [ ] getBytes ( int value ) { byte [ ] result = new byte [ 2 ] ; result [ 0 ] = ( byte ) ( value & 0xFF ) ; result [ 1 ] = ( byte ) ( ( value & 0xFF00 ) > > 8 ) ; return result ; } public static int getValue ( byte [ ] bytes , int offset ) { int value = ( bytes [ offset + 1 ] << 8 ) & 0xFF00 ; value += ( bytes [ offset ] & 0xFF ) ; return value ; } public static int getValue ( byte [ ] bytes ) { return getValue ( bytes , 0 ) ; } public boolean equals ( Object o ) { if ( o == null || ! ( o instanceof ZipShort ) ) { return false ; } return value == ( ( ZipShort ) o ) . getValue ( ) ; } public int hashCode ( ) { return value ; } } 	1	['10', '1', '0', '8', '11', '15', '8', '0', '10', '0.333333333', '121', '1', '0', '0', '0.4', '1', '1', '11', '4', '1', '1']
package org . apache . tools . ant . types ; import java . io . File ; import java . util . Vector ; import java . util . Enumeration ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . FileScanner ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . types . selectors . OrSelector ; import org . apache . tools . ant . types . selectors . AndSelector ; import org . apache . tools . ant . types . selectors . NotSelector ; import org . apache . tools . ant . types . selectors . DateSelector ; import org . apache . tools . ant . types . selectors . FileSelector ; import org . apache . tools . ant . types . selectors . NoneSelector ; import org . apache . tools . ant . types . selectors . SizeSelector ; import org . apache . tools . ant . types . selectors . TypeSelector ; import org . apache . tools . ant . types . selectors . DepthSelector ; import org . apache . tools . ant . types . selectors . DependSelector ; import org . apache . tools . ant . types . selectors . ExtendSelector ; import org . apache . tools . ant . types . selectors . SelectSelector ; import org . apache . tools . ant . types . selectors . PresentSelector ; import org . apache . tools . ant . types . selectors . SelectorScanner ; import org . apache . tools . ant . types . selectors . ContainsSelector ; import org . apache . tools . ant . types . selectors . FilenameSelector ; import org . apache . tools . ant . types . selectors . MajoritySelector ; import org . apache . tools . ant . types . selectors . DifferentSelector ; import org . apache . tools . ant . types . selectors . SelectorContainer ; import org . apache . tools . ant . types . selectors . ContainsRegexpSelector ; import org . apache . tools . ant . types . selectors . modifiedselector . ModifiedSelector ; public abstract class AbstractFileSet extends DataType implements Cloneable , SelectorContainer { private PatternSet defaultPatterns = new PatternSet ( ) ; private Vector additionalPatterns = new Vector ( ) ; private Vector selectors = new Vector ( ) ; private File dir ; private boolean useDefaultExcludes = true ; private boolean caseSensitive = true ; private boolean followSymlinks = true ; private DirectoryScanner directoryScanner = null ; public AbstractFileSet ( ) { super ( ) ; } protected AbstractFileSet ( AbstractFileSet fileset ) { this . dir = fileset . dir ; this . defaultPatterns = fileset . defaultPatterns ; this . additionalPatterns = fileset . additionalPatterns ; this . selectors = fileset . selectors ; this . useDefaultExcludes = fileset . useDefaultExcludes ; this . caseSensitive = fileset . caseSensitive ; this . followSymlinks = fileset . followSymlinks ; setProject ( fileset . getProject ( ) ) ; } public void setRefid ( Reference r ) throws BuildException { if ( dir != null || defaultPatterns . hasPatterns ( getProject ( ) ) ) { throw tooManyAttributes ( ) ; } if ( ! additionalPatterns . isEmpty ( ) ) { throw noChildrenAllowed ( ) ; } if ( ! selectors . isEmpty ( ) ) { throw noChildrenAllowed ( ) ; } super . setRefid ( r ) ; } public synchronized void setDir ( File dir ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . dir = dir ; directoryScanner = null ; } public File getDir ( ) { return getDir ( getProject ( ) ) ; } public synchronized File getDir ( Project p ) { return ( isReference ( ) ) ? getRef ( p ) . getDir ( p ) : dir ; } public synchronized PatternSet createPatternSet ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } PatternSet patterns = new PatternSet ( ) ; additionalPatterns . addElement ( patterns ) ; directoryScanner = null ; return patterns ; } public synchronized PatternSet . NameEntry createInclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } directoryScanner = null ; return defaultPatterns . createInclude ( ) ; } public synchronized PatternSet . NameEntry createIncludesFile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } directoryScanner = null ; return defaultPatterns . createIncludesFile ( ) ; } public synchronized PatternSet . NameEntry createExclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } directoryScanner = null ; return defaultPatterns . createExclude ( ) ; } public synchronized PatternSet . NameEntry createExcludesFile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } directoryScanner = null ; return defaultPatterns . createExcludesFile ( ) ; } public synchronized void setFile ( File file ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } setDir ( file . getParentFile ( ) ) ; createInclude ( ) . setName ( file . getName ( ) ) ; } public synchronized void setIncludes ( String includes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } defaultPatterns . setIncludes ( includes ) ; directoryScanner = null ; } public synchronized void appendIncludes ( String [ ] includes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( includes != null ) { for ( int i = 0 ; i < includes . length ; i ++ ) { defaultPatterns . createInclude ( ) . setName ( includes [ i ] ) ; } directoryScanner = null ; } } public synchronized void setExcludes ( String excludes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } defaultPatterns . setExcludes ( excludes ) ; directoryScanner = null ; } public synchronized void appendExcludes ( String [ ] excludes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( excludes != null ) { for ( int i = 0 ; i < excludes . length ; i ++ ) { defaultPatterns . createExclude ( ) . setName ( excludes [ i ] ) ; } directoryScanner = null ; } } public synchronized void setIncludesfile ( File incl ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } defaultPatterns . setIncludesfile ( incl ) ; directoryScanner = null ; } public synchronized void setExcludesfile ( File excl ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } defaultPatterns . setExcludesfile ( excl ) ; directoryScanner = null ; } public synchronized void setDefaultexcludes ( boolean useDefaultExcludes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . useDefaultExcludes = useDefaultExcludes ; directoryScanner = null ; } public synchronized boolean getDefaultexcludes ( ) { return ( isReference ( ) ) ? getRef ( getProject ( ) ) . getDefaultexcludes ( ) : useDefaultExcludes ; } public synchronized void setCaseSensitive ( boolean caseSensitive ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . caseSensitive = caseSensitive ; directoryScanner = null ; } public synchronized boolean isCaseSensitive ( ) { return ( isReference ( ) ) ? getRef ( getProject ( ) ) . isCaseSensitive ( ) : caseSensitive ; } public synchronized void setFollowSymlinks ( boolean followSymlinks ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . followSymlinks = followSymlinks ; directoryScanner = null ; } public synchronized boolean isFollowSymlinks ( ) { return ( isReference ( ) ) ? getRef ( getProject ( ) ) . isFollowSymlinks ( ) : followSymlinks ; } public DirectoryScanner getDirectoryScanner ( ) { return getDirectoryScanner ( getProject ( ) ) ; } public DirectoryScanner getDirectoryScanner ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getDirectoryScanner ( p ) ; } DirectoryScanner ds = null ; synchronized ( this ) { if ( directoryScanner != null && p == getProject ( ) ) { ds = directoryScanner ; } else { if ( dir == null ) { throw new BuildException ( "No directory specified for " + getDataTypeName ( ) + "." ) ; } if ( ! dir . exists ( ) ) { throw new BuildException ( dir . getAbsolutePath ( ) + " not found." ) ; } if ( ! dir . isDirectory ( ) ) { throw new BuildException ( dir . getAbsolutePath ( ) + " is not a directory." ) ; } ds = new DirectoryScanner ( ) ; setupDirectoryScanner ( ds , p ) ; ds . setFollowSymlinks ( followSymlinks ) ; directoryScanner = ( p == getProject ( ) ) ? ds : directoryScanner ; } } ds . scan ( ) ; return ds ; } public void setupDirectoryScanner ( FileScanner ds ) { setupDirectoryScanner ( ds , getProject ( ) ) ; } public synchronized void setupDirectoryScanner ( FileScanner ds , Project p ) { if ( isReference ( ) ) { getRef ( p ) . setupDirectoryScanner ( ds , p ) ; return ; } if ( ds == null ) { throw new IllegalArgumentException ( "ds cannot be null" ) ; } ds . setBasedir ( dir ) ; PatternSet ps = mergePatterns ( p ) ; p . log ( getDataTypeName ( ) + ": Setup scanner in dir " + dir + " with " + ps , Project . MSG_DEBUG ) ; ds . setIncludes ( ps . getIncludePatterns ( p ) ) ; ds . setExcludes ( ps . getExcludePatterns ( p ) ) ; if ( ds instanceof SelectorScanner ) { SelectorScanner ss = ( SelectorScanner ) ds ; ss . setSelectors ( getSelectors ( p ) ) ; } if ( useDefaultExcludes ) { ds . addDefaultExcludes ( ) ; } ds . setCaseSensitive ( caseSensitive ) ; } protected AbstractFileSet getRef ( Project p ) { return ( AbstractFileSet ) getCheckedRef ( p ) ; } public synchronized boolean hasSelectors ( ) { return ( isReference ( ) && getProject ( ) != null ) ? getRef ( getProject ( ) ) . hasSelectors ( ) : ! ( selectors . isEmpty ( ) ) ; } public synchronized boolean hasPatterns ( ) { if ( isReference ( ) && getProject ( ) != null ) { return getRef ( getProject ( ) ) . hasPatterns ( ) ; } if ( defaultPatterns . hasPatterns ( getProject ( ) ) ) { return true ; } Enumeration e = additionalPatterns . elements ( ) ; while ( e . hasMoreElements ( ) ) { PatternSet ps = ( PatternSet ) e . nextElement ( ) ; if ( ps . hasPatterns ( getProject ( ) ) ) { return true ; } } return false ; } public synchronized int selectorCount ( ) { return ( isReference ( ) && getProject ( ) != null ) ? getRef ( getProject ( ) ) . selectorCount ( ) : selectors . size ( ) ; } public synchronized FileSelector [ ] getSelectors ( Project p ) { return ( isReference ( ) ) ? getRef ( p ) . getSelectors ( p ) : ( FileSelector [ ] ) ( selectors . toArray ( new FileSelector [ selectors . size ( ) ] ) ) ; } public synchronized Enumeration selectorElements ( ) { return ( isReference ( ) && getProject ( ) != null ) ? getRef ( getProject ( ) ) . selectorElements ( ) : selectors . elements ( ) ; } public synchronized void appendSelector ( FileSelector selector ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } selectors . addElement ( selector ) ; directoryScanner = null ; } public void addSelector ( SelectSelector selector ) { appendSelector ( selector ) ; } public void addAnd ( AndSelector selector ) { appendSelector ( selector ) ; } public void addOr ( OrSelector selector ) { appendSelector ( selector ) ; } public void addNot ( NotSelector selector ) { appendSelector ( selector ) ; } public void addNone ( NoneSelector selector ) { appendSelector ( selector ) ; } public void addMajority ( MajoritySelector selector ) { appendSelector ( selector ) ; } public void addDate ( DateSelector selector ) { appendSelector ( selector ) ; } public void addSize ( SizeSelector selector ) { appendSelector ( selector ) ; } public void addDifferent ( DifferentSelector selector ) { appendSelector ( selector ) ; } public void addFilename ( FilenameSelector selector ) { appendSelector ( selector ) ; } public void addType ( TypeSelector selector ) { appendSelector ( selector ) ; } public void addCustom ( ExtendSelector selector ) { appendSelector ( selector ) ; } public void addContains ( ContainsSelector selector ) { appendSelector ( selector ) ; } public void addPresent ( PresentSelector selector ) { appendSelector ( selector ) ; } public void addDepth ( DepthSelector selector ) { appendSelector ( selector ) ; } public void addDepend ( DependSelector selector ) { appendSelector ( selector ) ; } public void addContainsRegexp ( ContainsRegexpSelector selector ) { appendSelector ( selector ) ; } public void addModified ( ModifiedSelector selector ) { appendSelector ( selector ) ; } public void add ( FileSelector selector ) { appendSelector ( selector ) ; } public String toString ( ) { DirectoryScanner ds = getDirectoryScanner ( getProject ( ) ) ; String [ ] files = ds . getIncludedFiles ( ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { if ( i > 0 ) { sb . append ( ';' ) ; } sb . append ( files [ i ] ) ; } return sb . toString ( ) ; } public synchronized Object clone ( ) { if ( isReference ( ) ) { return ( getRef ( getProject ( ) ) ) . clone ( ) ; } else { try { AbstractFileSet fs = ( AbstractFileSet ) super . clone ( ) ; fs . defaultPatterns = ( PatternSet ) defaultPatterns . clone ( ) ; fs . additionalPatterns = new Vector ( additionalPatterns . size ( ) ) ; Enumeration e = additionalPatterns . elements ( ) ; while ( e . hasMoreElements ( ) ) { fs . additionalPatterns . addElement ( ( ( PatternSet ) e . nextElement ( ) ) . clone ( ) ) ; } fs . selectors = new Vector ( selectors ) ; return fs ; } catch ( CloneNotSupportedException e ) { throw new BuildException ( e ) ; } } } public String [ ] mergeIncludes ( Project p ) { return mergePatterns ( p ) . getIncludePatterns ( p ) ; } public String [ ] mergeExcludes ( Project p ) { return mergePatterns ( p ) . getExcludePatterns ( p ) ; } public synchronized PatternSet mergePatterns ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . mergePatterns ( p ) ; } PatternSet ps = ( PatternSet ) defaultPatterns . clone ( ) ; final int count = additionalPatterns . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { Object o = additionalPatterns . elementAt ( i ) ; ps . append ( ( PatternSet ) o , p ) ; } return ps ; } } 	1	['59', '3', '3', '38', '121', '1145', '9', '29', '57', '0.728448276', '1035', '1', '2', '0.344827586', '0.061743341', '2', '3', '16.40677966', '8', '1.8475', '3']
package org . apache . tools . ant . taskdefs . rmic ; import java . io . IOException ; import java . io . OutputStream ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . types . Commandline ; public class SunRmic extends DefaultRmicAdapter { public static final String RMIC_CLASSNAME = "sun.rmi.rmic.Main" ; public static final String COMPILER_NAME = "sun" ; public static final String RMIC_EXECUTABLE = "rmic" ; public static final String ERROR_NO_RMIC_ON_CLASSPATH = "Cannot use SUN rmic, as it is not " + "available.  A common solution is to " + "set the environment variable " + "JAVA_HOME or CLASSPATH." ; public static final String ERROR_RMIC_FAILED = "Error starting SUN rmic: " ; public boolean execute ( ) throws BuildException { getRmic ( ) . log ( "Using SUN rmic compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupRmicCommand ( ) ; LogOutputStream logstr = new LogOutputStream ( getRmic ( ) , Project . MSG_WARN ) ; try { Class c = Class . forName ( RMIC_CLASSNAME ) ; Constructor cons = c . getConstructor ( new Class [ ] { OutputStream . class , String . class } ) ; Object rmic = cons . newInstance ( new Object [ ] { logstr , "rmic" } ) ; Method doRmic = c . getMethod ( "compile" , new Class [ ] { String [ ] . class } ) ; Boolean ok = ( Boolean ) doRmic . invoke ( rmic , ( new Object [ ] { cmd . getArguments ( ) } ) ) ; return ok . booleanValue ( ) ; } catch ( ClassNotFoundException ex ) { throw new BuildException ( ERROR_NO_RMIC_ON_CLASSPATH , getRmic ( ) . getLocation ( ) ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( ERROR_RMIC_FAILED , ex , getRmic ( ) . getLocation ( ) ) ; } } finally { try { logstr . close ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } } } 	1	['2', '2', '0', '8', '21', '1', '1', '7', '2', '1.625', '167', '0', '0', '0.928571429', '1', '0', '0', '78.5', '1', '0.5', '2']
package org . apache . tools . ant ; import org . apache . tools . ant . util . LoaderUtils ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JAXPUtils ; import org . apache . tools . ant . util . ProxySetup ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . apache . tools . ant . launch . Launcher ; import org . xml . sax . XMLReader ; import javax . xml . parsers . SAXParserFactory ; import javax . xml . parsers . SAXParser ; import java . io . File ; import java . io . FilenameFilter ; import java . io . PrintStream ; import java . io . InputStream ; import java . io . IOException ; import java . io . FileOutputStream ; import java . util . Enumeration ; import java . util . Properties ; import java . util . Calendar ; import java . util . TimeZone ; import java . lang . reflect . Method ; import java . lang . reflect . InvocationTargetException ; public final class Diagnostics { private static final int BIG_DRIFT_LIMIT = 10000 ; private static final int TEST_FILE_SIZE = 32 ; private static final int KILOBYTE = 1024 ; private static final int SECONDS_PER_MILLISECOND = 1000 ; private static final int SECONDS_PER_MINUTE = 60 ; private static final int MINUTES_PER_HOUR = 60 ; private static final String TEST_CLASS = "org.apache.tools.ant.taskdefs.optional.Test" ; protected static final String ERROR_PROPERTY_ACCESS_BLOCKED = "Access to this property blocked by a security manager" ; private Diagnostics ( ) { } public static boolean isOptionalAvailable ( ) { try { Class . forName ( TEST_CLASS ) ; } catch ( ClassNotFoundException e ) { return false ; } return true ; } public static void validateVersion ( ) throws BuildException { try { Class optional = Class . forName ( TEST_CLASS ) ; String coreVersion = getImplementationVersion ( Main . class ) ; String optionalVersion = getImplementationVersion ( optional ) ; if ( coreVersion != null && ! coreVersion . equals ( optionalVersion ) ) { throw new BuildException ( "Invalid implementation version " + "between Ant core and Ant optional tasks.\n" + " core    : " + coreVersion + "\n" + " optional: " + optionalVersion ) ; } } catch ( ClassNotFoundException e ) { ignoreThrowable ( e ) ; } } public static File [ ] listLibraries ( ) { String home = System . getProperty ( MagicNames . ANT_HOME ) ; if ( home == null ) { return null ; } File libDir = new File ( home , "lib" ) ; return listJarFiles ( libDir ) ; } private static File [ ] listJarFiles ( File libDir ) { FilenameFilter filter = new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { return name . endsWith ( ".jar" ) ; } } ; File [ ] files = libDir . listFiles ( filter ) ; return files ; } public static void main ( String [ ] args ) { doReport ( System . out ) ; } private static String getImplementationVersion ( Class clazz ) { Package pkg = clazz . getPackage ( ) ; return pkg . getImplementationVersion ( ) ; } private static String getXmlParserName ( ) { SAXParser saxParser = getSAXParser ( ) ; if ( saxParser == null ) { return "Could not create an XML Parser" ; } String saxParserName = saxParser . getClass ( ) . getName ( ) ; return saxParserName ; } private static SAXParser getSAXParser ( ) { SAXParserFactory saxParserFactory = SAXParserFactory . newInstance ( ) ; if ( saxParserFactory == null ) { return null ; } SAXParser saxParser = null ; try { saxParser = saxParserFactory . newSAXParser ( ) ; } catch ( Exception e ) { ignoreThrowable ( e ) ; } return saxParser ; } private static String getXMLParserLocation ( ) { SAXParser saxParser = getSAXParser ( ) ; if ( saxParser == null ) { return null ; } String location = getClassLocation ( saxParser . getClass ( ) ) ; return location ; } private static String getNamespaceParserName ( ) { try { XMLReader reader = JAXPUtils . getNamespaceXMLReader ( ) ; return reader . getClass ( ) . getName ( ) ; } catch ( BuildException e ) { ignoreThrowable ( e ) ; return null ; } } private static String getNamespaceParserLocation ( ) { try { XMLReader reader = JAXPUtils . getNamespaceXMLReader ( ) ; return getClassLocation ( reader . getClass ( ) ) ; } catch ( BuildException e ) { ignoreThrowable ( e ) ; return null ; } } private static void ignoreThrowable ( Throwable thrown ) { } private static String getClassLocation ( Class clazz ) { File f = LoaderUtils . getClassSource ( clazz ) ; return f == null ? null : f . getAbsolutePath ( ) ; } public static void doReport ( PrintStream out ) { out . println ( "------- Ant diagnostics report -------" ) ; out . println ( Main . getAntVersion ( ) ) ; header ( out , "Implementation Version" ) ; out . println ( "core tasks     : " + getImplementationVersion ( Main . class ) ) ; Class optional = null ; try { optional = Class . forName ( TEST_CLASS ) ; out . println ( "optional tasks : " + getImplementationVersion ( optional ) ) ; } catch ( ClassNotFoundException e ) { ignoreThrowable ( e ) ; out . println ( "optional tasks : not available" ) ; } header ( out , "ANT PROPERTIES" ) ; doReportAntProperties ( out ) ; header ( out , "ANT_HOME/lib jar listing" ) ; doReportAntHomeLibraries ( out ) ; header ( out , "USER_HOME/.ant/lib jar listing" ) ; doReportUserHomeLibraries ( out ) ; header ( out , "Tasks availability" ) ; doReportTasksAvailability ( out ) ; header ( out , "org.apache.env.Which diagnostics" ) ; doReportWhich ( out ) ; header ( out , "XML Parser information" ) ; doReportParserInfo ( out ) ; header ( out , "System properties" ) ; doReportSystemProperties ( out ) ; header ( out , "Temp dir" ) ; doReportTempDir ( out ) ; header ( out , "Locale information" ) ; doReportLocale ( out ) ; header ( out , "Proxy information" ) ; doReportProxy ( out ) ; out . println ( ) ; } private static void header ( PrintStream out , String section ) { out . println ( ) ; out . println ( "-------------------------------------------" ) ; out . print ( " " ) ; out . println ( section ) ; out . println ( "-------------------------------------------" ) ; } private static void doReportSystemProperties ( PrintStream out ) { Properties sysprops = null ; try { sysprops = System . getProperties ( ) ; } catch ( SecurityException e ) { ignoreThrowable ( e ) ; out . println ( "Access to System.getProperties() blocked " + "by a security manager" ) ; } for ( Enumeration keys = sysprops . propertyNames ( ) ; keys . hasMoreElements ( ) ; ) { String key = ( String ) keys . nextElement ( ) ; String value = getProperty ( key ) ; out . println ( key + " : " + value ) ; } } private static String getProperty ( String key ) { String value ; try { value = System . getProperty ( key ) ; } catch ( SecurityException e ) { value = ERROR_PROPERTY_ACCESS_BLOCKED ; } return value ; } private static void doReportAntProperties ( PrintStream out ) { Project p = new Project ( ) ; p . initProperties ( ) ; out . println ( MagicNames . ANT_VERSION + ": " + p . getProperty ( MagicNames . ANT_VERSION ) ) ; out . println ( MagicNames . ANT_JAVA_VERSION + ": " + p . getProperty ( MagicNames . ANT_JAVA_VERSION ) ) ; out . println ( MagicNames . ANT_LIB + ": " + p . getProperty ( MagicNames . ANT_LIB ) ) ; out . println ( MagicNames . ANT_HOME + ": " + p . getProperty ( MagicNames . ANT_HOME ) ) ; } private static void doReportAntHomeLibraries ( PrintStream out ) { out . println ( MagicNames . ANT_HOME + ": " + System . getProperty ( MagicNames . ANT_HOME ) ) ; File [ ] libs = listLibraries ( ) ; printLibraries ( libs , out ) ; } private static void doReportUserHomeLibraries ( PrintStream out ) { String home = System . getProperty ( Launcher . USER_HOMEDIR ) ; out . println ( "user.home: " + home ) ; File libDir = new File ( home , Launcher . USER_LIBDIR ) ; File [ ] libs = listJarFiles ( libDir ) ; printLibraries ( libs , out ) ; } private static void printLibraries ( File [ ] libs , PrintStream out ) { if ( libs == null ) { out . println ( "No such directory." ) ; return ; } for ( int i = 0 ; i < libs . length ; i ++ ) { out . println ( libs [ i ] . getName ( ) + " (" + libs [ i ] . length ( ) + " bytes)" ) ; } } private static void doReportWhich ( PrintStream out ) { Throwable error = null ; try { Class which = Class . forName ( "org.apache.env.Which" ) ; Method method = which . getMethod ( "main" , new Class [ ] { String [ ] . class } ) ; method . invoke ( null , new Object [ ] { new String [ ] { } } ) ; } catch ( ClassNotFoundException e ) { out . println ( "Not available." ) ; out . println ( "Download it at http://xml.apache.org/commons/" ) ; } catch ( InvocationTargetException e ) { error = e . getTargetException ( ) == null ? e : e . getTargetException ( ) ; } catch ( Throwable e ) { error = e ; } if ( error != null ) { out . println ( "Error while running org.apache.env.Which" ) ; error . printStackTrace ( ) ; } } private static void doReportTasksAvailability ( PrintStream out ) { InputStream is = Main . class . getResourceAsStream ( MagicNames . TASKDEF_PROPERTIES_RESOURCE ) ; if ( is == null ) { out . println ( "None available" ) ; } else { Properties props = new Properties ( ) ; try { props . load ( is ) ; for ( Enumeration keys = props . keys ( ) ; keys . hasMoreElements ( ) ; ) { String key = ( String ) keys . nextElement ( ) ; String classname = props . getProperty ( key ) ; try { Class . forName ( classname ) ; props . remove ( key ) ; } catch ( ClassNotFoundException e ) { out . println ( key + " : Not Available " + "(the implementation class is not present)" ) ; } catch ( NoClassDefFoundError e ) { String pkg = e . getMessage ( ) . replace ( '/' , '.' ) ; out . println ( key + " : Missing dependency " + pkg ) ; } catch ( LinkageError e ) { out . println ( key + " : Initialization error" ) ; } } if ( props . size ( ) == 0 ) { out . println ( "All defined tasks are available" ) ; } else { out . println ( "A task being missing/unavailable should only " + "matter if you are trying to use it" ) ; } } catch ( IOException e ) { out . println ( e . getMessage ( ) ) ; } } } private static void doReportParserInfo ( PrintStream out ) { String parserName = getXmlParserName ( ) ; String parserLocation = getXMLParserLocation ( ) ; printParserInfo ( out , "XML Parser" , parserName , parserLocation ) ; printParserInfo ( out , "Namespace-aware parser" , getNamespaceParserName ( ) , getNamespaceParserLocation ( ) ) ; } private static void printParserInfo ( PrintStream out , String parserType , String parserName , String parserLocation ) { if ( parserName == null ) { parserName = "unknown" ; } if ( parserLocation == null ) { parserLocation = "unknown" ; } out . println ( parserType + " : " + parserName ) ; out . println ( parserType + " Location: " + parserLocation ) ; } private static void doReportTempDir ( PrintStream out ) { String tempdir = System . getProperty ( "java.io.tmpdir" ) ; if ( tempdir == null ) { out . println ( "Warning: java.io.tmpdir is undefined" ) ; return ; } out . println ( "Temp dir is " + tempdir ) ; File tempDirectory = new File ( tempdir ) ; if ( ! tempDirectory . exists ( ) ) { out . println ( "Warning, java.io.tmpdir directory does not exist: " + tempdir ) ; return ; } long now = System . currentTimeMillis ( ) ; File tempFile = null ; FileOutputStream fileout = null ; try { tempFile = File . createTempFile ( "diag" , "txt" , tempDirectory ) ; fileout = new FileOutputStream ( tempFile ) ; byte [ ] buffer = new byte [ KILOBYTE ] ; for ( int i = 0 ; i < TEST_FILE_SIZE ; i ++ ) { fileout . write ( buffer ) ; } fileout . close ( ) ; fileout = null ; long filetime = tempFile . lastModified ( ) ; tempFile . delete ( ) ; out . println ( "Temp dir is writeable" ) ; long drift = filetime - now ; out . println ( "Temp dir alignment with system clock is " + drift + " ms" ) ; if ( Math . abs ( drift ) > BIG_DRIFT_LIMIT ) { out . println ( "Warning: big clock drift -maybe a network filesystem" ) ; } } catch ( IOException e ) { ignoreThrowable ( e ) ; out . println ( "Failed to create a temporary file in the temp dir " + tempdir ) ; out . println ( "File  " + tempFile + " could not be created/written to" ) ; } finally { FileUtils . close ( fileout ) ; if ( tempFile != null && tempFile . exists ( ) ) { tempFile . delete ( ) ; } } } private static void doReportLocale ( PrintStream out ) { Calendar cal = Calendar . getInstance ( ) ; TimeZone tz = cal . getTimeZone ( ) ; out . println ( "Timezone " + tz . getDisplayName ( ) + " offset=" + tz . getOffset ( cal . get ( Calendar . ERA ) , cal . get ( Calendar . YEAR ) , cal . get ( Calendar . MONTH ) , cal . get ( Calendar . DAY_OF_MONTH ) , cal . get ( Calendar . DAY_OF_WEEK ) , ( ( cal . get ( Calendar . HOUR_OF_DAY ) * MINUTES_PER_HOUR + cal . get ( Calendar . MINUTE ) ) * SECONDS_PER_MINUTE + cal . get ( Calendar . SECOND ) ) * SECONDS_PER_MILLISECOND + cal . get ( Calendar . MILLISECOND ) ) ) ; } private static void printProperty ( PrintStream out , String key ) { String value = getProperty ( key ) ; if ( value != null ) { out . print ( key ) ; out . print ( " = " ) ; out . print ( '"' ) ; out . print ( value ) ; out . println ( '"' ) ; } } private static void doReportProxy ( PrintStream out ) { printProperty ( out , ProxySetup . HTTP_PROXY_HOST ) ; printProperty ( out , ProxySetup . HTTP_PROXY_PORT ) ; printProperty ( out , ProxySetup . HTTP_PROXY_USERNAME ) ; printProperty ( out , ProxySetup . HTTP_PROXY_PASSWORD ) ; printProperty ( out , ProxySetup . HTTP_NON_PROXY_HOSTS ) ; printProperty ( out , ProxySetup . HTTPS_PROXY_HOST ) ; printProperty ( out , ProxySetup . HTTPS_PROXY_PORT ) ; printProperty ( out , ProxySetup . HTTPS_NON_PROXY_HOSTS ) ; printProperty ( out , ProxySetup . FTP_PROXY_HOST ) ; printProperty ( out , ProxySetup . FTP_PROXY_PORT ) ; printProperty ( out , ProxySetup . FTP_NON_PROXY_HOSTS ) ; printProperty ( out , ProxySetup . SOCKS_PROXY_HOST ) ; printProperty ( out , ProxySetup . SOCKS_PROXY_PORT ) ; printProperty ( out , ProxySetup . SOCKS_PROXY_USERNAME ) ; printProperty ( out , ProxySetup . SOCKS_PROXY_PASSWORD ) ; if ( JavaEnvUtils . getJavaVersionNumber ( ) < 15 ) { return ; } printProperty ( out , ProxySetup . USE_SYSTEM_PROXIES ) ; final String proxyDiagClassname = "org.apache.tools.ant.util.java15.ProxyDiagnostics" ; try { Class proxyDiagClass = Class . forName ( proxyDiagClassname ) ; Object instance = proxyDiagClass . newInstance ( ) ; out . println ( "Java1.5+ proxy settings:" ) ; out . println ( instance . toString ( ) ) ; } catch ( ClassNotFoundException e ) { } catch ( IllegalAccessException e ) { } catch ( InstantiationException e ) { } catch ( NoClassDefFoundError e ) { } } } 	1	['30', '1', '0', '10', '104', '429', '2', '9', '5', '1.013793103', '1038', '0.8', '0', '0', '0.108333333', '0', '0', '33.26666667', '9', '1.9', '3']
package org . apache . tools . ant . taskdefs . optional . splash ; import java . awt . BorderLayout ; import java . awt . Color ; import java . awt . Dimension ; import java . awt . Font ; import java . awt . Toolkit ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import javax . swing . BorderFactory ; import javax . swing . ImageIcon ; import javax . swing . JLabel ; import javax . swing . JPanel ; import javax . swing . JProgressBar ; import javax . swing . JWindow ; import org . apache . tools . ant . BuildEvent ; import org . apache . tools . ant . BuildListener ; class SplashScreen extends JWindow implements ActionListener , BuildListener { private JLabel text ; private JProgressBar pb ; private int total ; private static final int MIN = 0 ; private static final int MAX = 200 ; public SplashScreen ( String msg ) { init ( null ) ; setText ( msg ) ; } public SplashScreen ( ImageIcon img ) { init ( img ) ; } protected void init ( ImageIcon img ) { JPanel pan = ( JPanel ) getContentPane ( ) ; JLabel piccy ; if ( img == null ) { piccy = new JLabel ( ) ; } else { piccy = new JLabel ( img ) ; } piccy . setBorder ( BorderFactory . createLineBorder ( Color . black , 1 ) ) ; text = new JLabel ( "Building...." , JLabel . CENTER ) ; text . setFont ( new Font ( "Sans-Serif" , Font . BOLD , 12 ) ) ; text . setBorder ( BorderFactory . createEtchedBorder ( ) ) ; pb = new JProgressBar ( MIN , MAX ) ; pb . setBorder ( BorderFactory . createBevelBorder ( javax . swing . border . BevelBorder . LOWERED ) ) ; JPanel pan2 = new JPanel ( ) ; pan2 . setLayout ( new BorderLayout ( ) ) ; pan2 . add ( text , BorderLayout . NORTH ) ; pan2 . add ( pb , BorderLayout . SOUTH ) ; pan . setLayout ( new BorderLayout ( ) ) ; pan . add ( piccy , BorderLayout . CENTER ) ; pan . add ( pan2 , BorderLayout . SOUTH ) ; pan . setBorder ( BorderFactory . createBevelBorder ( javax . swing . border . BevelBorder . RAISED ) ) ; pack ( ) ; Dimension size = getSize ( ) ; Dimension scr = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) ; int x = ( scr . width - size . width ) / 2 ; int y = ( scr . height - size . height ) / 2 ; setBounds ( x , y , size . width , size . height ) ; } public void setText ( String txt ) { text . setText ( txt ) ; } public void actionPerformed ( ActionEvent a ) { if ( total < MAX ) { total ++ ; } else { total = MIN ; } pb . setValue ( total ) ; } public void buildStarted ( BuildEvent event ) { actionPerformed ( null ) ; } public void buildFinished ( BuildEvent event ) { pb . setValue ( MAX ) ; setVisible ( false ) ; dispose ( ) ; } public void targetStarted ( BuildEvent event ) { actionPerformed ( null ) ; } public void targetFinished ( BuildEvent event ) { actionPerformed ( null ) ; } public void taskStarted ( BuildEvent event ) { actionPerformed ( null ) ; } public void taskFinished ( BuildEvent event ) { actionPerformed ( null ) ; } public void messageLogged ( BuildEvent event ) { actionPerformed ( null ) ; } } 	1	['12', '5', '0', '3', '39', '58', '1', '2', '11', '0.690909091', '213', '1', '0', '0.975429975', '0.4', '0', '0', '16.33333333', '2', '1', '1']
package org . apache . tools . ant . types . optional ; import org . apache . tools . ant . filters . TokenFilter ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . ScriptRunnerBase ; import org . apache . tools . ant . util . ScriptRunnerHelper ; public class ScriptFilter extends TokenFilter . ChainableReaderFilter { private ScriptRunnerHelper helper = new ScriptRunnerHelper ( ) ; private ScriptRunnerBase runner = null ; private String token ; public void setProject ( Project project ) { super . setProject ( project ) ; helper . setProjectComponent ( this ) ; } public void setLanguage ( String language ) { helper . setLanguage ( language ) ; } private void init ( ) throws BuildException { if ( runner != null ) { return ; } runner = helper . getScriptRunner ( ) ; } public void setToken ( String token ) { this . token = token ; } public String getToken ( ) { return token ; } public String filter ( String token ) { init ( ) ; setToken ( token ) ; runner . executeScript ( "ant_filter" ) ; return getToken ( ) ; } public void setSrc ( File file ) { helper . setSrc ( file ) ; } public void addText ( String text ) { helper . addText ( text ) ; } public void setManager ( String manager ) { helper . setManager ( manager ) ; } public void setClasspath ( Path classpath ) { helper . setClasspath ( classpath ) ; } public Path createClasspath ( ) { return helper . createClasspath ( ) ; } public void setClasspathRef ( Reference r ) { helper . setClasspathRef ( r ) ; } } 	1	['13', '3', '0', '8', '26', '0', '0', '8', '12', '0.611111111', '98', '1', '2', '0.47826087', '0.282051282', '1', '1', '6.307692308', '1', '0.9231', '1']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . filters . util . ChainReaderHelper ; import org . apache . tools . ant . types . FilterChain ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . util . FileUtils ; public class LoadResource extends Task { private Resource src ; private boolean failOnError = true ; private boolean quiet = false ; private String encoding = null ; private String property = null ; private final Vector filterChains = new Vector ( ) ; public final void setEncoding ( final String encoding ) { this . encoding = encoding ; } public final void setProperty ( final String property ) { this . property = property ; } public final void setFailonerror ( final boolean fail ) { failOnError = fail ; } public void setQuiet ( final boolean quiet ) { this . quiet = quiet ; if ( quiet ) { this . failOnError = false ; } } public final void execute ( ) throws BuildException { if ( src == null ) { throw new BuildException ( "source resource not defined" ) ; } if ( property == null ) { throw new BuildException ( "output property not defined" ) ; } if ( quiet && failOnError ) { throw new BuildException ( "quiet and failonerror cannot both be " + "set to true" ) ; } if ( ! src . isExists ( ) ) { String message = src + " doesn't exist" ; if ( failOnError ) { throw new BuildException ( message ) ; } else { log ( message , quiet ? Project . MSG_WARN : Project . MSG_ERR ) ; return ; } } InputStream is = null ; BufferedInputStream bis = null ; Reader instream = null ; log ( "loading " + src + " into property " + property , Project . MSG_VERBOSE ) ; try { final long len = src . getSize ( ) ; log ( "resource size = " + ( len != Resource . UNKNOWN_SIZE ? String . valueOf ( len ) : "unknown" ) , Project . MSG_DEBUG ) ; final int size = ( int ) len ; is = src . getInputStream ( ) ; bis = new BufferedInputStream ( is ) ; if ( encoding == null ) { instream = new InputStreamReader ( bis ) ; } else { instream = new InputStreamReader ( bis , encoding ) ; } String text = "" ; if ( size != 0 ) { ChainReaderHelper crh = new ChainReaderHelper ( ) ; if ( len != Resource . UNKNOWN_SIZE ) { crh . setBufferSize ( size ) ; } crh . setPrimaryReader ( instream ) ; crh . setFilterChains ( filterChains ) ; crh . setProject ( getProject ( ) ) ; instream = crh . getAssembledReader ( ) ; text = crh . readFully ( instream ) ; } if ( text != null ) { if ( text . length ( ) > 0 ) { getProject ( ) . setNewProperty ( property , text ) ; log ( "loaded " + text . length ( ) + " characters" , Project . MSG_VERBOSE ) ; log ( property + " := " + text , Project . MSG_DEBUG ) ; } } } catch ( final IOException ioe ) { final String message = "Unable to load resource: " + ioe . toString ( ) ; if ( failOnError ) { throw new BuildException ( message , ioe , getLocation ( ) ) ; } else { log ( message , quiet ? Project . MSG_VERBOSE : Project . MSG_ERR ) ; } } catch ( final BuildException be ) { if ( failOnError ) { throw be ; } else { log ( be . getMessage ( ) , quiet ? Project . MSG_VERBOSE : Project . MSG_ERR ) ; } } finally { FileUtils . close ( is ) ; } } public final void addFilterChain ( FilterChain filter ) { filterChains . addElement ( filter ) ; } public void addConfigured ( ResourceCollection a ) { if ( a . size ( ) != 1 ) { throw new BuildException ( "only single argument resource collections" + " are supported" ) ; } src = ( Resource ) a . iterator ( ) . next ( ) ; } } 	1	['8', '3', '1', '10', '45', '2', '1', '9', '8', '0.714285714', '336', '1', '1', '0.840909091', '0.35', '2', '2', '40.25', '2', '1.125', '1']
package org . apache . tools . ant . types . resources . comparators ; import org . apache . tools . ant . types . Resource ; public class Date extends ResourceComparator { protected int resourceCompare ( Resource foo , Resource bar ) { return ( int ) ( foo . getLastModified ( ) - bar . getLastModified ( ) ) ; } } 	1	['2', '4', '0', '3', '4', '1', '1', '2', '1', '2', '12', '0', '0', '0.971428571', '0.75', '1', '1', '5', '1', '0.5', '1']
package org . apache . tools . tar ; import java . io . FilterInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public class TarInputStream extends FilterInputStream { protected boolean debug ; protected boolean hasHitEOF ; protected long entrySize ; protected long entryOffset ; protected byte [ ] readBuf ; protected TarBuffer buffer ; protected TarEntry currEntry ; protected byte [ ] oneBuf ; public TarInputStream ( InputStream is ) { this ( is , TarBuffer . DEFAULT_BLKSIZE , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarInputStream ( InputStream is , int blockSize ) { this ( is , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarInputStream ( InputStream is , int blockSize , int recordSize ) { super ( is ) ; this . buffer = new TarBuffer ( is , blockSize , recordSize ) ; this . readBuf = null ; this . oneBuf = new byte [ 1 ] ; this . debug = false ; this . hasHitEOF = false ; } public void setDebug ( boolean debug ) { this . debug = debug ; this . buffer . setDebug ( debug ) ; } public void close ( ) throws IOException { this . buffer . close ( ) ; } public int getRecordSize ( ) { return this . buffer . getRecordSize ( ) ; } public int available ( ) throws IOException { if ( this . entrySize - this . entryOffset > Integer . MAX_VALUE ) { return Integer . MAX_VALUE ; } return ( int ) ( this . entrySize - this . entryOffset ) ; } public long skip ( long numToSkip ) throws IOException { byte [ ] skipBuf = new byte [ 8 * 1024 ] ; long skip = numToSkip ; while ( skip > 0 ) { int realSkip = ( int ) ( skip > skipBuf . length ? skipBuf . length : skip ) ; int numRead = this . read ( skipBuf , 0 , realSkip ) ; if ( numRead == - 1 ) { break ; } skip -= numRead ; } return ( numToSkip - skip ) ; } public boolean markSupported ( ) { return false ; } public void mark ( int markLimit ) { } public void reset ( ) { } public TarEntry getNextEntry ( ) throws IOException { if ( this . hasHitEOF ) { return null ; } if ( this . currEntry != null ) { long numToSkip = this . entrySize - this . entryOffset ; if ( this . debug ) { System . err . println ( "TarInputStream: SKIP currENTRY '" + this . currEntry . getName ( ) + "' SZ " + this . entrySize + " OFF " + this . entryOffset + "  skipping " + numToSkip + " bytes" ) ; } if ( numToSkip > 0 ) { this . skip ( numToSkip ) ; } this . readBuf = null ; } byte [ ] headerBuf = this . buffer . readRecord ( ) ; if ( headerBuf == null ) { if ( this . debug ) { System . err . println ( "READ NULL RECORD" ) ; } this . hasHitEOF = true ; } else if ( this . buffer . isEOFRecord ( headerBuf ) ) { if ( this . debug ) { System . err . println ( "READ EOF RECORD" ) ; } this . hasHitEOF = true ; } if ( this . hasHitEOF ) { this . currEntry = null ; } else { this . currEntry = new TarEntry ( headerBuf ) ; if ( this . debug ) { System . err . println ( "TarInputStream: SET CURRENTRY '" + this . currEntry . getName ( ) + "' size = " + this . currEntry . getSize ( ) ) ; } this . entryOffset = 0 ; this . entrySize = this . currEntry . getSize ( ) ; } if ( this . currEntry != null && this . currEntry . isGNULongNameEntry ( ) ) { StringBuffer longName = new StringBuffer ( ) ; byte [ ] buf = new byte [ 256 ] ; int length = 0 ; while ( ( length = read ( buf ) ) >= 0 ) { longName . append ( new String ( buf , 0 , length ) ) ; } getNextEntry ( ) ; if ( this . currEntry == null ) { return null ; } if ( longName . length ( ) > 0 && longName . charAt ( longName . length ( ) - 1 ) == 0 ) { longName . deleteCharAt ( longName . length ( ) - 1 ) ; } this . currEntry . setName ( longName . toString ( ) ) ; } return this . currEntry ; } public int read ( ) throws IOException { int num = this . read ( this . oneBuf , 0 , 1 ) ; return num == - 1 ? - 1 : ( ( int ) this . oneBuf [ 0 ] ) & 0xFF ; } public int read ( byte [ ] buf , int offset , int numToRead ) throws IOException { int totalRead = 0 ; if ( this . entryOffset >= this . entrySize ) { return - 1 ; } if ( ( numToRead + this . entryOffset ) > this . entrySize ) { numToRead = ( int ) ( this . entrySize - this . entryOffset ) ; } if ( this . readBuf != null ) { int sz = ( numToRead > this . readBuf . length ) ? this . readBuf . length : numToRead ; System . arraycopy ( this . readBuf , 0 , buf , offset , sz ) ; if ( sz >= this . readBuf . length ) { this . readBuf = null ; } else { int newLen = this . readBuf . length - sz ; byte [ ] newBuf = new byte [ newLen ] ; System . arraycopy ( this . readBuf , sz , newBuf , 0 , newLen ) ; this . readBuf = newBuf ; } totalRead += sz ; numToRead -= sz ; offset += sz ; } while ( numToRead > 0 ) { byte [ ] rec = this . buffer . readRecord ( ) ; if ( rec == null ) { throw new IOException ( "unexpected EOF with " + numToRead + " bytes unread" ) ; } int sz = numToRead ; int recLen = rec . length ; if ( recLen > sz ) { System . arraycopy ( rec , 0 , buf , offset , sz ) ; this . readBuf = new byte [ recLen - sz ] ; System . arraycopy ( rec , sz , this . readBuf , 0 , recLen - sz ) ; } else { sz = recLen ; System . arraycopy ( rec , 0 , buf , offset , recLen ) ; } totalRead += sz ; numToRead -= sz ; offset += sz ; } this . entryOffset += totalRead ; return totalRead ; } public void copyEntryContents ( OutputStream out ) throws IOException { byte [ ] buf = new byte [ 32 * 1024 ] ; while ( true ) { int numRead = this . read ( buf , 0 , buf . length ) ; if ( numRead == - 1 ) { break ; } out . write ( buf , 0 , numRead ) ; } } } 	1	['15', '3', '0', '5', '42', '69', '3', '2', '15', '0.669642857', '538', '1', '2', '0.6', '0.247619048', '2', '8', '34.33333333', '1', '0.8', '1']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . PatternSet ; public class Chmod extends ExecuteOn { private FileSet defaultSet = new FileSet ( ) ; private boolean defaultSetDefined = false ; private boolean havePerm = false ; public Chmod ( ) { super . setExecutable ( "chmod" ) ; super . setParallel ( true ) ; super . setSkipEmptyFilesets ( true ) ; } public void setProject ( Project project ) { super . setProject ( project ) ; defaultSet . setProject ( project ) ; } public void setFile ( File src ) { FileSet fs = new FileSet ( ) ; fs . setFile ( src ) ; addFileset ( fs ) ; } public void setDir ( File src ) { defaultSet . setDir ( src ) ; } public void setPerm ( String perm ) { createArg ( ) . setValue ( perm ) ; havePerm = true ; } public PatternSet . NameEntry createInclude ( ) { defaultSetDefined = true ; return defaultSet . createInclude ( ) ; } public PatternSet . NameEntry createExclude ( ) { defaultSetDefined = true ; return defaultSet . createExclude ( ) ; } public PatternSet createPatternSet ( ) { defaultSetDefined = true ; return defaultSet . createPatternSet ( ) ; } public void setIncludes ( String includes ) { defaultSetDefined = true ; defaultSet . setIncludes ( includes ) ; } public void setExcludes ( String excludes ) { defaultSetDefined = true ; defaultSet . setExcludes ( excludes ) ; } public void setDefaultexcludes ( boolean useDefaultExcludes ) { defaultSetDefined = true ; defaultSet . setDefaultexcludes ( useDefaultExcludes ) ; } protected void checkConfiguration ( ) { if ( ! havePerm ) { throw new BuildException ( "Required attribute perm not set in chmod" , getLocation ( ) ) ; } if ( defaultSetDefined && defaultSet . getDir ( getProject ( ) ) != null ) { addFileset ( defaultSet ) ; } super . checkConfiguration ( ) ; } public void execute ( ) throws BuildException { if ( defaultSetDefined || defaultSet . getDir ( getProject ( ) ) == null ) { try { super . execute ( ) ; } finally { if ( defaultSetDefined && defaultSet . getDir ( getProject ( ) ) != null ) { filesets . removeElement ( defaultSet ) ; } } } else if ( isValidOs ( ) ) { Execute execute = prepareExec ( ) ; Commandline cloned = ( Commandline ) cmdl . clone ( ) ; cloned . createArgument ( ) . setValue ( defaultSet . getDir ( getProject ( ) ) . getPath ( ) ) ; try { execute . setCommandline ( cloned . getCommandline ( ) ) ; runExecute ( execute ) ; } catch ( IOException e ) { throw new BuildException ( "Execute failed: " + e , e , getLocation ( ) ) ; } finally { logFlush ( ) ; } } } public void setExecutable ( String e ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the executable attribute" , getLocation ( ) ) ; } public void setCommand ( Commandline cmdl ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the command attribute" , getLocation ( ) ) ; } public void setSkipEmptyFilesets ( boolean skip ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the skipemptyfileset attribute" , getLocation ( ) ) ; } public void setAddsourcefile ( boolean b ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the addsourcefile attribute" , getLocation ( ) ) ; } protected boolean isValidOs ( ) { return Os . isFamily ( Os . FAMILY_UNIX ) && super . isValidOs ( ) ; } } 	1	['18', '5', '0', '11', '60', '39', '0', '11', '16', '0.607843137', '305', '1', '1', '0.862903226', '0.268518519', '4', '7', '15.77777778', '4', '1.2222', '1']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . types . Reference ; public class IsReference extends ProjectComponent implements Condition { private Reference ref ; private String type ; public void setRefid ( Reference r ) { ref = r ; } public void setType ( String type ) { this . type = type ; } public boolean eval ( ) throws BuildException { if ( ref == null ) { throw new BuildException ( "No reference specified for isreference " + "condition" ) ; } Object o = getProject ( ) . getReference ( ref . getRefId ( ) ) ; if ( o == null ) { return false ; } else if ( type == null ) { return true ; } else { Class typeClass = ( Class ) getProject ( ) . getDataTypeDefinitions ( ) . get ( type ) ; if ( typeClass == null ) { typeClass = ( Class ) getProject ( ) . getTaskDefinitions ( ) . get ( type ) ; } if ( typeClass == null ) { return false ; } return typeClass . isAssignableFrom ( o . getClass ( ) ) ; } } } 	1	['4', '2', '0', '6', '14', '2', '1', '5', '4', '0.666666667', '68', '1', '1', '0.75', '0.5', '0', '0', '15.5', '1', '0.75', '1']
package org . apache . tools . ant . helper ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Location ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . RuntimeConfigurable ; import org . apache . tools . ant . Target ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . UnknownElement ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JAXPUtils ; import org . xml . sax . Attributes ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . DefaultHandler ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . io . UnsupportedEncodingException ; import java . net . URL ; import java . util . HashMap ; import java . util . Hashtable ; import java . util . Map ; import java . util . Stack ; public class ProjectHelper2 extends ProjectHelper { private static AntHandler elementHandler = new ElementHandler ( ) ; private static AntHandler targetHandler = new TargetHandler ( ) ; private static AntHandler mainHandler = new MainHandler ( ) ; private static AntHandler projectHandler = new ProjectHandler ( ) ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; public UnknownElement parseUnknownElement ( Project project , URL source ) throws BuildException { Target dummyTarget = new Target ( ) ; dummyTarget . setProject ( project ) ; AntXMLContext context = new AntXMLContext ( project ) ; context . addTarget ( dummyTarget ) ; context . setImplicitTarget ( dummyTarget ) ; parse ( context . getProject ( ) , source , new RootHandler ( context , elementHandler ) ) ; Task [ ] tasks = dummyTarget . getTasks ( ) ; if ( tasks . length != 1 ) { throw new BuildException ( "No tasks defined" ) ; } return ( UnknownElement ) tasks [ 0 ] ; } public void parse ( Project project , Object source ) throws BuildException { getImportStack ( ) . addElement ( source ) ; AntXMLContext context = null ; context = ( AntXMLContext ) project . getReference ( "ant.parsing.context" ) ; if ( context == null ) { context = new AntXMLContext ( project ) ; project . addReference ( "ant.parsing.context" , context ) ; project . addReference ( "ant.targets" , context . getTargets ( ) ) ; } if ( getImportStack ( ) . size ( ) > 1 ) { context . setIgnoreProjectTag ( true ) ; Target currentTarget = context . getCurrentTarget ( ) ; Target currentImplicit = context . getImplicitTarget ( ) ; Map currentTargets = context . getCurrentTargets ( ) ; try { Target newCurrent = new Target ( ) ; newCurrent . setProject ( project ) ; newCurrent . setName ( "" ) ; context . setCurrentTarget ( newCurrent ) ; context . setCurrentTargets ( new HashMap ( ) ) ; context . setImplicitTarget ( newCurrent ) ; parse ( project , source , new RootHandler ( context , mainHandler ) ) ; newCurrent . execute ( ) ; } finally { context . setCurrentTarget ( currentTarget ) ; context . setImplicitTarget ( currentImplicit ) ; context . setCurrentTargets ( currentTargets ) ; } } else { context . setCurrentTargets ( new HashMap ( ) ) ; parse ( project , source , new RootHandler ( context , mainHandler ) ) ; context . getImplicitTarget ( ) . execute ( ) ; } } public void parse ( Project project , Object source , RootHandler handler ) throws BuildException { AntXMLContext context = handler . context ; File buildFile = null ; URL url = null ; String buildFileName = null ; if ( source instanceof File ) { buildFile = ( File ) source ; buildFile = FILE_UTILS . normalize ( buildFile . getAbsolutePath ( ) ) ; context . setBuildFile ( buildFile ) ; buildFileName = buildFile . toString ( ) ; } else if ( source instanceof URL ) { url = ( URL ) source ; buildFileName = url . toString ( ) ; } else { throw new BuildException ( "Source " + source . getClass ( ) . getName ( ) + " not supported by this plugin" ) ; } InputStream inputStream = null ; InputSource inputSource = null ; try { XMLReader parser = JAXPUtils . getNamespaceXMLReader ( ) ; String uri = null ; if ( buildFile != null ) { uri = FILE_UTILS . toURI ( buildFile . getAbsolutePath ( ) ) ; inputStream = new FileInputStream ( buildFile ) ; } else { inputStream = url . openStream ( ) ; uri = url . toString ( ) ; } inputSource = new InputSource ( inputStream ) ; if ( uri != null ) { inputSource . setSystemId ( uri ) ; } project . log ( "parsing buildfile " + buildFileName + " with URI = " + uri , Project . MSG_VERBOSE ) ; DefaultHandler hb = handler ; parser . setContentHandler ( hb ) ; parser . setEntityResolver ( hb ) ; parser . setErrorHandler ( hb ) ; parser . setDTDHandler ( hb ) ; parser . parse ( inputSource ) ; } catch ( SAXParseException exc ) { Location location = new Location ( exc . getSystemId ( ) , exc . getLineNumber ( ) , exc . getColumnNumber ( ) ) ; Throwable t = exc . getException ( ) ; if ( t instanceof BuildException ) { BuildException be = ( BuildException ) t ; if ( be . getLocation ( ) == Location . UNKNOWN_LOCATION ) { be . setLocation ( location ) ; } throw be ; } else if ( t == null ) { t = exc ; } throw new BuildException ( exc . getMessage ( ) , t , location ) ; } catch ( SAXException exc ) { Throwable t = exc . getException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } else if ( t == null ) { t = exc ; } throw new BuildException ( exc . getMessage ( ) , t ) ; } catch ( FileNotFoundException exc ) { throw new BuildException ( exc ) ; } catch ( UnsupportedEncodingException exc ) { throw new BuildException ( "Encoding of project file " + buildFileName + " is invalid." , exc ) ; } catch ( IOException exc ) { throw new BuildException ( "Error reading project file " + buildFileName + ": " + exc . getMessage ( ) , exc ) ; } finally { FileUtils . close ( inputStream ) ; } } protected static AntHandler getMainHandler ( ) { return mainHandler ; } protected static void setMainHandler ( AntHandler handler ) { mainHandler = handler ; } protected static AntHandler getProjectHandler ( ) { return projectHandler ; } protected static void setProjectHandler ( AntHandler handler ) { projectHandler = handler ; } protected static AntHandler getTargetHandler ( ) { return targetHandler ; } protected static void setTargetHandler ( AntHandler handler ) { targetHandler = handler ; } protected static AntHandler getElementHandler ( ) { return elementHandler ; } protected static void setElementHandler ( AntHandler handler ) { elementHandler = handler ; } public static class AntHandler { public void onStartElement ( String uri , String tag , String qname , Attributes attrs , AntXMLContext context ) throws SAXParseException { } public AntHandler onStartChild ( String uri , String tag , String qname , Attributes attrs , AntXMLContext context ) throws SAXParseException { throw new SAXParseException ( "Unexpected element \"" + qname + " \"" , context . getLocator ( ) ) ; } public void onEndChild ( String uri , String tag , String qname , AntXMLContext context ) throws SAXParseException { } public void onEndElement ( String uri , String tag , AntXMLContext context ) { } public void characters ( char [ ] buf , int start , int count , AntXMLContext context ) throws SAXParseException { String s = new String ( buf , start , count ) . trim ( ) ; if ( s . length ( ) > 0 ) { throw new SAXParseException ( "Unexpected text \"" + s + "\"" , context . getLocator ( ) ) ; } } protected void checkNamespace ( String uri ) { } } public static class RootHandler extends DefaultHandler { private Stack antHandlers = new Stack ( ) ; private AntHandler currentHandler = null ; private AntXMLContext context ; public RootHandler ( AntXMLContext context , AntHandler rootHandler ) { currentHandler = rootHandler ; antHandlers . push ( currentHandler ) ; this . context = context ; } public AntHandler getCurrentAntHandler ( ) { return currentHandler ; } public InputSource resolveEntity ( String publicId , String systemId ) { context . getProject ( ) . log ( "resolving systemId: " + systemId , Project . MSG_VERBOSE ) ; if ( systemId . startsWith ( "file:" ) ) { String path = FILE_UTILS . fromURI ( systemId ) ; File file = new File ( path ) ; if ( ! file . isAbsolute ( ) ) { file = FILE_UTILS . resolveFile ( context . getBuildFileParent ( ) , path ) ; context . getProject ( ) . log ( "Warning: '" + systemId + "' in " + context . getBuildFile ( ) + " should be expressed simply as '" + path . replace ( '\\' , '/' ) + "' for compliance with other XML tools" , Project . MSG_WARN ) ; } context . getProject ( ) . log ( "file=" + file , Project . MSG_DEBUG ) ; try { InputSource inputSource = new InputSource ( new FileInputStream ( file ) ) ; inputSource . setSystemId ( FILE_UTILS . toURI ( file . getAbsolutePath ( ) ) ) ; return inputSource ; } catch ( FileNotFoundException fne ) { context . getProject ( ) . log ( file . getAbsolutePath ( ) + " could not be found" , Project . MSG_WARN ) ; } } context . getProject ( ) . log ( "could not resolve systemId" , Project . MSG_DEBUG ) ; return null ; } public void startElement ( String uri , String tag , String qname , Attributes attrs ) throws SAXParseException { AntHandler next = currentHandler . onStartChild ( uri , tag , qname , attrs , context ) ; antHandlers . push ( currentHandler ) ; currentHandler = next ; currentHandler . onStartElement ( uri , tag , qname , attrs , context ) ; } public void setDocumentLocator ( Locator locator ) { context . setLocator ( locator ) ; } public void endElement ( String uri , String name , String qName ) throws SAXException { currentHandler . onEndElement ( uri , name , context ) ; AntHandler prev = ( AntHandler ) antHandlers . pop ( ) ; currentHandler = prev ; if ( currentHandler != null ) { currentHandler . onEndChild ( uri , name , qName , context ) ; } } public void characters ( char [ ] buf , int start , int count ) throws SAXParseException { currentHandler . characters ( buf , start , count , context ) ; } public void startPrefixMapping ( String prefix , String uri ) { context . startPrefixMapping ( prefix , uri ) ; } public void endPrefixMapping ( String prefix ) { context . endPrefixMapping ( prefix ) ; } } public static class MainHandler extends AntHandler { public AntHandler onStartChild ( String uri , String name , String qname , Attributes attrs , AntXMLContext context ) throws SAXParseException { if ( name . equals ( "project" ) && ( uri . equals ( "" ) || uri . equals ( ANT_CORE_URI ) ) ) { return ProjectHelper2 . projectHandler ; } else { if ( name . equals ( qname ) ) { throw new SAXParseException ( "Unexpected element \"{" + uri + "}" + name + "\" {" + ANT_CORE_URI + "}" + name , context . getLocator ( ) ) ; } else { throw new SAXParseException ( "Unexpected element \"" + qname + "\" " + name , context . getLocator ( ) ) ; } } } } public static class ProjectHandler extends AntHandler { public void onStartElement ( String uri , String tag , String qname , Attributes attrs , AntXMLContext context ) throws SAXParseException { String baseDir = null ; boolean nameAttributeSet = false ; Project project = context . getProject ( ) ; context . getImplicitTarget ( ) . setLocation ( new Location ( context . getLocator ( ) ) ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String attrUri = attrs . getURI ( i ) ; if ( attrUri != null && ! attrUri . equals ( "" ) && ! attrUri . equals ( uri ) ) { continue ; } String key = attrs . getLocalName ( i ) ; String value = attrs . getValue ( i ) ; if ( key . equals ( "default" ) ) { if ( value != null && ! value . equals ( "" ) ) { if ( ! context . isIgnoringProjectTag ( ) ) { project . setDefault ( value ) ; } } } else if ( key . equals ( "name" ) ) { if ( value != null ) { context . setCurrentProjectName ( value ) ; nameAttributeSet = true ; if ( ! context . isIgnoringProjectTag ( ) ) { project . setName ( value ) ; project . addReference ( value , project ) ; } } } else if ( key . equals ( "id" ) ) { if ( value != null ) { if ( ! context . isIgnoringProjectTag ( ) ) { project . addReference ( value , project ) ; } } } else if ( key . equals ( "basedir" ) ) { if ( ! context . isIgnoringProjectTag ( ) ) { baseDir = value ; } } else { throw new SAXParseException ( "Unexpected attribute \"" + attrs . getQName ( i ) + "\"" , context . getLocator ( ) ) ; } } String antFileProp = "ant.file." + context . getCurrentProjectName ( ) ; String dup = project . getProperty ( antFileProp ) ; if ( dup != null && nameAttributeSet ) { File dupFile = new File ( dup ) ; if ( context . isIgnoringProjectTag ( ) && ! dupFile . equals ( context . getBuildFile ( ) ) ) { project . log ( "Duplicated project name in import. Project " + context . getCurrentProjectName ( ) + " defined first in " + dup + " and again in " + context . getBuildFile ( ) , Project . MSG_WARN ) ; } } if ( context . getBuildFile ( ) != null && nameAttributeSet ) { project . setUserProperty ( "ant.file." + context . getCurrentProjectName ( ) , context . getBuildFile ( ) . toString ( ) ) ; } if ( context . isIgnoringProjectTag ( ) ) { return ; } if ( project . getProperty ( "basedir" ) != null ) { project . setBasedir ( project . getProperty ( "basedir" ) ) ; } else { if ( baseDir == null ) { project . setBasedir ( context . getBuildFileParent ( ) . getAbsolutePath ( ) ) ; } else { if ( ( new File ( baseDir ) ) . isAbsolute ( ) ) { project . setBasedir ( baseDir ) ; } else { project . setBaseDir ( FILE_UTILS . resolveFile ( context . getBuildFileParent ( ) , baseDir ) ) ; } } } project . addTarget ( "" , context . getImplicitTarget ( ) ) ; context . setCurrentTarget ( context . getImplicitTarget ( ) ) ; } public AntHandler onStartChild ( String uri , String name , String qname , Attributes attrs , AntXMLContext context ) throws SAXParseException { if ( name . equals ( "target" ) && ( uri . equals ( "" ) || uri . equals ( ANT_CORE_URI ) ) ) { return ProjectHelper2 . targetHandler ; } else { return ProjectHelper2 . elementHandler ; } } } public static class TargetHandler extends AntHandler { public void onStartElement ( String uri , String tag , String qname , Attributes attrs , AntXMLContext context ) throws SAXParseException { String name = null ; String depends = "" ; Project project = context . getProject ( ) ; Target target = new Target ( ) ; target . setProject ( project ) ; target . setLocation ( new Location ( context . getLocator ( ) ) ) ; context . addTarget ( target ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String attrUri = attrs . getURI ( i ) ; if ( attrUri != null && ! attrUri . equals ( "" ) && ! attrUri . equals ( uri ) ) { continue ; } String key = attrs . getLocalName ( i ) ; String value = attrs . getValue ( i ) ; if ( key . equals ( "name" ) ) { name = value ; if ( "" . equals ( name ) ) { throw new BuildException ( "name attribute must " + "not be empty" ) ; } } else if ( key . equals ( "depends" ) ) { depends = value ; } else if ( key . equals ( "if" ) ) { target . setIf ( value ) ; } else if ( key . equals ( "unless" ) ) { target . setUnless ( value ) ; } else if ( key . equals ( "id" ) ) { if ( value != null && ! value . equals ( "" ) ) { context . getProject ( ) . addReference ( value , target ) ; } } else if ( key . equals ( "description" ) ) { target . setDescription ( value ) ; } else { throw new SAXParseException ( "Unexpected attribute \"" + key + "\"" , context . getLocator ( ) ) ; } } if ( name == null ) { throw new SAXParseException ( "target element appears without " + "a name attribute" , context . getLocator ( ) ) ; } if ( context . getCurrentTargets ( ) . get ( name ) != null ) { throw new BuildException ( "Duplicate target '" + name + "'" , target . getLocation ( ) ) ; } Hashtable projectTargets = project . getTargets ( ) ; boolean usedTarget = false ; if ( projectTargets . containsKey ( name ) ) { project . log ( "Already defined in main or a previous import, " + "ignore " + name , Project . MSG_VERBOSE ) ; } else { target . setName ( name ) ; context . getCurrentTargets ( ) . put ( name , target ) ; project . addOrReplaceTarget ( name , target ) ; usedTarget = true ; } if ( depends . length ( ) > 0 ) { target . setDepends ( depends ) ; } if ( context . isIgnoringProjectTag ( ) && context . getCurrentProjectName ( ) != null && context . getCurrentProjectName ( ) . length ( ) != 0 ) { String newName = context . getCurrentProjectName ( ) + "." + name ; Target newTarget = usedTarget ? new Target ( target ) : target ; newTarget . setName ( newName ) ; context . getCurrentTargets ( ) . put ( newName , newTarget ) ; project . addOrReplaceTarget ( newName , newTarget ) ; } } public AntHandler onStartChild ( String uri , String name , String qname , Attributes attrs , AntXMLContext context ) throws SAXParseException { return ProjectHelper2 . elementHandler ; } public void onEndElement ( String uri , String tag , AntXMLContext context ) { context . setCurrentTarget ( context . getImplicitTarget ( ) ) ; } } public static class ElementHandler extends AntHandler { public ElementHandler ( ) { } public void onStartElement ( String uri , String tag , String qname , Attributes attrs , AntXMLContext context ) throws SAXParseException { RuntimeConfigurable parentWrapper = context . currentWrapper ( ) ; Object parent = null ; if ( parentWrapper != null ) { parent = parentWrapper . getProxy ( ) ; } UnknownElement task = new UnknownElement ( tag ) ; task . setProject ( context . getProject ( ) ) ; task . setNamespace ( uri ) ; task . setQName ( qname ) ; task . setTaskType ( ProjectHelper . genComponentName ( task . getNamespace ( ) , tag ) ) ; task . setTaskName ( qname ) ; Location location = new Location ( context . getLocator ( ) . getSystemId ( ) , context . getLocator ( ) . getLineNumber ( ) , context . getLocator ( ) . getColumnNumber ( ) ) ; task . setLocation ( location ) ; task . setOwningTarget ( context . getCurrentTarget ( ) ) ; if ( parent != null ) { ( ( UnknownElement ) parent ) . addChild ( task ) ; } else { context . getCurrentTarget ( ) . addTask ( task ) ; } context . configureId ( task , attrs ) ; RuntimeConfigurable wrapper = new RuntimeConfigurable ( task , task . getTaskName ( ) ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String name = attrs . getLocalName ( i ) ; String attrUri = attrs . getURI ( i ) ; if ( attrUri != null && ! attrUri . equals ( "" ) && ! attrUri . equals ( uri ) ) { name = attrUri + ":" + attrs . getQName ( i ) ; } String value = attrs . getValue ( i ) ; if ( ANT_TYPE . equals ( name ) || ( ANT_CORE_URI . equals ( attrUri ) && ANT_TYPE . equals ( attrs . getLocalName ( i ) ) ) ) { name = ANT_TYPE ; int index = value . indexOf ( ":" ) ; if ( index != - 1 ) { String prefix = value . substring ( 0 , index ) ; String mappedUri = context . getPrefixMapping ( prefix ) ; if ( mappedUri == null ) { throw new BuildException ( "Unable to find XML NS prefix " + prefix ) ; } value = ProjectHelper . genComponentName ( mappedUri , value . substring ( index + 1 ) ) ; } } wrapper . setAttribute ( name , value ) ; } if ( parentWrapper != null ) { parentWrapper . addChild ( wrapper ) ; } context . pushWrapper ( wrapper ) ; } public void characters ( char [ ] buf , int start , int count , AntXMLContext context ) throws SAXParseException { RuntimeConfigurable wrapper = context . currentWrapper ( ) ; wrapper . addText ( buf , start , count ) ; } public AntHandler onStartChild ( String uri , String tag , String qname , Attributes attrs , AntXMLContext context ) throws SAXParseException { return ProjectHelper2 . elementHandler ; } public void onEndElement ( String uri , String tag , AntXMLContext context ) { context . popWrapper ( ) ; } } } 	1	['17', '2', '0', '17', '85', '74', '7', '16', '4', '0.7875', '461', '1', '5', '0.53125', '0.15625', '1', '1', '25.82352941', '1', '0.8824', '1']
package org . apache . tools . ant . taskdefs ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public class PumpStreamHandler implements ExecuteStreamHandler { private Thread outputThread ; private Thread errorThread ; private StreamPumper inputPump ; private OutputStream out ; private OutputStream err ; private InputStream input ; public PumpStreamHandler ( OutputStream out , OutputStream err , InputStream input ) { this . out = out ; this . err = err ; this . input = input ; } public PumpStreamHandler ( OutputStream out , OutputStream err ) { this ( out , err , null ) ; } public PumpStreamHandler ( OutputStream outAndErr ) { this ( outAndErr , outAndErr ) ; } public PumpStreamHandler ( ) { this ( System . out , System . err ) ; } public void setProcessOutputStream ( InputStream is ) { createProcessOutputPump ( is , out ) ; } public void setProcessErrorStream ( InputStream is ) { if ( err != null ) { createProcessErrorPump ( is , err ) ; } } public void setProcessInputStream ( OutputStream os ) { if ( input != null ) { inputPump = createInputPump ( input , os , true ) ; } else { try { os . close ( ) ; } catch ( IOException e ) { } } } public void start ( ) { outputThread . start ( ) ; errorThread . start ( ) ; if ( inputPump != null ) { Thread inputThread = new Thread ( inputPump ) ; inputThread . setDaemon ( true ) ; inputThread . start ( ) ; } } public void stop ( ) { try { outputThread . join ( ) ; } catch ( InterruptedException e ) { } try { errorThread . join ( ) ; } catch ( InterruptedException e ) { } if ( inputPump != null ) { inputPump . stop ( ) ; } try { err . flush ( ) ; } catch ( IOException e ) { } try { out . flush ( ) ; } catch ( IOException e ) { } } protected OutputStream getErr ( ) { return err ; } protected OutputStream getOut ( ) { return out ; } protected void createProcessOutputPump ( InputStream is , OutputStream os ) { outputThread = createPump ( is , os ) ; } protected void createProcessErrorPump ( InputStream is , OutputStream os ) { errorThread = createPump ( is , os ) ; } protected Thread createPump ( InputStream is , OutputStream os ) { return createPump ( is , os , false ) ; } protected Thread createPump ( InputStream is , OutputStream os , boolean closeWhenExhausted ) { final Thread result = new Thread ( new StreamPumper ( is , os , closeWhenExhausted ) ) ; result . setDaemon ( true ) ; return result ; } StreamPumper createInputPump ( InputStream is , OutputStream os , boolean closeWhenExhausted ) { StreamPumper pumper = new StreamPumper ( is , os , closeWhenExhausted ) ; pumper . setAutoflush ( true ) ; return pumper ; } } 	1	['16', '1', '3', '14', '26', '82', '12', '2', '9', '0.733333333', '183', '1', '1', '0', '0.546875', '0', '0', '10.0625', '2', '1', '1']
package org . apache . tools . ant . taskdefs ; import java . lang . reflect . Method ; import java . util . Enumeration ; import java . util . Vector ; import java . util . List ; import java . util . ArrayList ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Location ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . util . StringUtils ; public class Parallel extends Task implements TaskContainer { public static class TaskList implements TaskContainer { private List tasks = new ArrayList ( ) ; public void addTask ( Task nestedTask ) { tasks . add ( nestedTask ) ; } } private Vector nestedTasks = new Vector ( ) ; private final Object semaphore = new Object ( ) ; private int numThreads = 0 ; private int numThreadsPerProcessor = 0 ; private long timeout ; private volatile boolean stillRunning ; private boolean timedOut ; private boolean failOnAny ; private TaskList daemonTasks ; private StringBuffer exceptionMessage ; private int numExceptions = 0 ; private Throwable firstException ; private Location firstLocation ; public void addDaemons ( TaskList daemonTasks ) { if ( this . daemonTasks != null ) { throw new BuildException ( "Only one daemon group is supported" ) ; } this . daemonTasks = daemonTasks ; } public void setPollInterval ( int pollInterval ) { } public void setFailOnAny ( boolean failOnAny ) { this . failOnAny = failOnAny ; } public void addTask ( Task nestedTask ) { nestedTasks . addElement ( nestedTask ) ; } public void setThreadsPerProcessor ( int numThreadsPerProcessor ) { this . numThreadsPerProcessor = numThreadsPerProcessor ; } public void setThreadCount ( int numThreads ) { this . numThreads = numThreads ; } public void setTimeout ( long timeout ) { this . timeout = timeout ; } public void execute ( ) throws BuildException { updateThreadCounts ( ) ; if ( numThreads == 0 ) { numThreads = nestedTasks . size ( ) ; } spinThreads ( ) ; } private void updateThreadCounts ( ) { if ( numThreadsPerProcessor != 0 ) { int numProcessors = getNumProcessors ( ) ; if ( numProcessors != 0 ) { numThreads = numProcessors * numThreadsPerProcessor ; } } } private void processExceptions ( TaskRunnable [ ] runnables ) { if ( runnables == null ) { return ; } for ( int i = 0 ; i < runnables . length ; ++ i ) { Throwable t = runnables [ i ] . getException ( ) ; if ( t != null ) { numExceptions ++ ; if ( firstException == null ) { firstException = t ; } if ( t instanceof BuildException && firstLocation == Location . UNKNOWN_LOCATION ) { firstLocation = ( ( BuildException ) t ) . getLocation ( ) ; } exceptionMessage . append ( StringUtils . LINE_SEP ) ; exceptionMessage . append ( t . getMessage ( ) ) ; } } } private void spinThreads ( ) throws BuildException { final int numTasks = nestedTasks . size ( ) ; TaskRunnable [ ] runnables = new TaskRunnable [ numTasks ] ; stillRunning = true ; timedOut = false ; int threadNumber = 0 ; for ( Enumeration e = nestedTasks . elements ( ) ; e . hasMoreElements ( ) ; threadNumber ++ ) { Task nestedTask = ( Task ) e . nextElement ( ) ; runnables [ threadNumber ] = new TaskRunnable ( nestedTask ) ; } final int maxRunning = numTasks < numThreads ? numTasks : numThreads ; TaskRunnable [ ] running = new TaskRunnable [ maxRunning ] ; threadNumber = 0 ; ThreadGroup group = new ThreadGroup ( "parallel" ) ; TaskRunnable [ ] daemons = null ; if ( daemonTasks != null && daemonTasks . tasks . size ( ) != 0 ) { daemons = new TaskRunnable [ daemonTasks . tasks . size ( ) ] ; } synchronized ( semaphore ) { } synchronized ( semaphore ) { if ( daemons != null ) { for ( int i = 0 ; i < daemons . length ; ++ i ) { daemons [ i ] = new TaskRunnable ( ( Task ) daemonTasks . tasks . get ( i ) ) ; Thread daemonThread = new Thread ( group , daemons [ i ] ) ; daemonThread . setDaemon ( true ) ; daemonThread . start ( ) ; } } for ( int i = 0 ; i < maxRunning ; ++ i ) { running [ i ] = runnables [ threadNumber ++ ] ; Thread thread = new Thread ( group , running [ i ] ) ; thread . start ( ) ; } if ( timeout != 0 ) { Thread timeoutThread = new Thread ( ) { public synchronized void run ( ) { try { wait ( timeout ) ; synchronized ( semaphore ) { stillRunning = false ; timedOut = true ; semaphore . notifyAll ( ) ; } } catch ( InterruptedException e ) { } } } ; timeoutThread . start ( ) ; } outer : while ( threadNumber < numTasks && stillRunning ) { for ( int i = 0 ; i < maxRunning ; i ++ ) { if ( running [ i ] == null || running [ i ] . isFinished ( ) ) { running [ i ] = runnables [ threadNumber ++ ] ; Thread thread = new Thread ( group , running [ i ] ) ; thread . start ( ) ; continue outer ; } } try { semaphore . wait ( ) ; } catch ( InterruptedException ie ) { } } outer2 : while ( stillRunning ) { for ( int i = 0 ; i < maxRunning ; ++ i ) { if ( running [ i ] != null && ! running [ i ] . isFinished ( ) ) { try { semaphore . wait ( ) ; } catch ( InterruptedException ie ) { } continue outer2 ; } } stillRunning = false ; } } if ( timedOut ) { throw new BuildException ( "Parallel execution timed out" ) ; } exceptionMessage = new StringBuffer ( ) ; numExceptions = 0 ; firstException = null ; firstLocation = Location . UNKNOWN_LOCATION ; processExceptions ( daemons ) ; processExceptions ( runnables ) ; if ( numExceptions == 1 ) { if ( firstException instanceof BuildException ) { throw ( BuildException ) firstException ; } else { throw new BuildException ( firstException ) ; } } else if ( numExceptions > 1 ) { throw new BuildException ( exceptionMessage . toString ( ) , firstLocation ) ; } } private int getNumProcessors ( ) { try { Class [ ] paramTypes = { } ; Method availableProcessors = Runtime . class . getMethod ( "availableProcessors" , paramTypes ) ; Object [ ] args = { } ; Integer ret = ( Integer ) availableProcessors . invoke ( Runtime . getRuntime ( ) , args ) ; return ret . intValue ( ) ; } catch ( Exception e ) { return 0 ; } } private class TaskRunnable implements Runnable { private Throwable exception ; private Task task ; private boolean finished ; TaskRunnable ( Task task ) { this . task = task ; } public void run ( ) { try { task . perform ( ) ; } catch ( Throwable t ) { exception = t ; if ( failOnAny ) { stillRunning = false ; } } finally { synchronized ( semaphore ) { finished = true ; semaphore . notifyAll ( ) ; } } } public Throwable getException ( ) { return exception ; } boolean isFinished ( ) { return finished ; } } } 	1	['18', '3', '0', '8', '52', '101', '2', '8', '9', '0.861344538', '519', '0.928571429', '2', '0.685185185', '0.194444444', '0', '0', '27.05555556', '7', '1.5', '1']
package org . apache . tools . ant . taskdefs . email ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . PrintStream ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; import org . apache . tools . mail . MailMessage ; class PlainMailer extends Mailer { public void send ( ) { try { MailMessage mailMessage = new MailMessage ( host , port ) ; mailMessage . from ( from . toString ( ) ) ; Enumeration e ; e = replyToList . elements ( ) ; while ( e . hasMoreElements ( ) ) { mailMessage . replyto ( e . nextElement ( ) . toString ( ) ) ; } e = toList . elements ( ) ; while ( e . hasMoreElements ( ) ) { mailMessage . to ( e . nextElement ( ) . toString ( ) ) ; } e = ccList . elements ( ) ; while ( e . hasMoreElements ( ) ) { mailMessage . cc ( e . nextElement ( ) . toString ( ) ) ; } e = bccList . elements ( ) ; while ( e . hasMoreElements ( ) ) { mailMessage . bcc ( e . nextElement ( ) . toString ( ) ) ; } if ( subject != null ) { mailMessage . setSubject ( subject ) ; } mailMessage . setHeader ( "Date" , getDate ( ) ) ; if ( message . getCharset ( ) != null ) { mailMessage . setHeader ( "Content-Type" , message . getMimeType ( ) + "; charset=\"" + message . getCharset ( ) + "\"" ) ; } else { mailMessage . setHeader ( "Content-Type" , message . getMimeType ( ) ) ; } e = headers . elements ( ) ; while ( e . hasMoreElements ( ) ) { Header h = ( Header ) e . nextElement ( ) ; mailMessage . setHeader ( h . getName ( ) , h . getValue ( ) ) ; } PrintStream out = mailMessage . getPrintStream ( ) ; message . print ( out ) ; e = files . elements ( ) ; while ( e . hasMoreElements ( ) ) { attach ( ( File ) e . nextElement ( ) , out ) ; } mailMessage . sendAndClose ( ) ; } catch ( IOException ioe ) { throw new BuildException ( "IO error sending mail" , ioe ) ; } } protected void attach ( File file , PrintStream out ) throws IOException { if ( ! file . exists ( ) || ! file . canRead ( ) ) { throw new BuildException ( "File \"" + file . getName ( ) + "\" does not exist or is not " + "readable." ) ; } if ( includeFileNames ) { out . println ( ) ; String filename = file . getName ( ) ; int filenamelength = filename . length ( ) ; out . println ( filename ) ; for ( int star = 0 ; star < filenamelength ; star ++ ) { out . print ( '=' ) ; } out . println ( ) ; } int length ; final int maxBuf = 1024 ; byte [ ] buf = new byte [ maxBuf ] ; FileInputStream finstr = new FileInputStream ( file ) ; try { BufferedInputStream in = new BufferedInputStream ( finstr , buf . length ) ; while ( ( length = in . read ( buf ) ) != - 1 ) { out . write ( buf , 0 , length ) ; } } finally { finstr . close ( ) ; } } } 	1	['3', '2', '1', '8', '43', '3', '2', '6', '1', '2', '250', '0', '0', '0.9', '0.555555556', '1', '1', '82.33333333', '9', '3.3333', '1']
package org . apache . tools . ant . taskdefs . compilers ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Location ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . Javac ; import org . apache . tools . ant . taskdefs . LogStreamHandler ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . StringUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . apache . tools . ant . taskdefs . condition . Os ; public abstract class DefaultCompilerAdapter implements CompilerAdapter { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; protected Path src ; protected File destDir ; protected String encoding ; protected boolean debug = false ; protected boolean optimize = false ; protected boolean deprecation = false ; protected boolean depend = false ; protected boolean verbose = false ; protected String target ; protected Path bootclasspath ; protected Path extdirs ; protected Path compileClasspath ; protected Path compileSourcepath ; protected Project project ; protected Location location ; protected boolean includeAntRuntime ; protected boolean includeJavaRuntime ; protected String memoryInitialSize ; protected String memoryMaximumSize ; protected File [ ] compileList ; protected Javac attributes ; protected static final String lSep = StringUtils . LINE_SEP ; public void setJavac ( Javac attributes ) { this . attributes = attributes ; src = attributes . getSrcdir ( ) ; destDir = attributes . getDestdir ( ) ; encoding = attributes . getEncoding ( ) ; debug = attributes . getDebug ( ) ; optimize = attributes . getOptimize ( ) ; deprecation = attributes . getDeprecation ( ) ; depend = attributes . getDepend ( ) ; verbose = attributes . getVerbose ( ) ; target = attributes . getTarget ( ) ; bootclasspath = attributes . getBootclasspath ( ) ; extdirs = attributes . getExtdirs ( ) ; compileList = attributes . getFileList ( ) ; compileClasspath = attributes . getClasspath ( ) ; compileSourcepath = attributes . getSourcepath ( ) ; project = attributes . getProject ( ) ; location = attributes . getLocation ( ) ; includeAntRuntime = attributes . getIncludeantruntime ( ) ; includeJavaRuntime = attributes . getIncludejavaruntime ( ) ; memoryInitialSize = attributes . getMemoryInitialSize ( ) ; memoryMaximumSize = attributes . getMemoryMaximumSize ( ) ; } public Javac getJavac ( ) { return attributes ; } protected Project getProject ( ) { return project ; } protected Path getCompileClasspath ( ) { Path classpath = new Path ( project ) ; if ( destDir != null ) { classpath . setLocation ( destDir ) ; } Path cp = compileClasspath ; if ( cp == null ) { cp = new Path ( project ) ; } if ( includeAntRuntime ) { classpath . addExisting ( cp . concatSystemClasspath ( "last" ) ) ; } else { classpath . addExisting ( cp . concatSystemClasspath ( "ignore" ) ) ; } if ( includeJavaRuntime ) { classpath . addJavaRuntime ( ) ; } return classpath ; } protected Commandline setupJavacCommandlineSwitches ( Commandline cmd ) { return setupJavacCommandlineSwitches ( cmd , false ) ; } protected Commandline setupJavacCommandlineSwitches ( Commandline cmd , boolean useDebugLevel ) { Path classpath = getCompileClasspath ( ) ; Path sourcepath = null ; if ( compileSourcepath != null ) { sourcepath = compileSourcepath ; } else { sourcepath = src ; } String memoryParameterPrefix = assumeJava11 ( ) ? "-J-" : "-J-X" ; if ( memoryInitialSize != null ) { if ( ! attributes . isForkedJavac ( ) ) { attributes . log ( "Since fork is false, ignoring " + "memoryInitialSize setting." , Project . MSG_WARN ) ; } else { cmd . createArgument ( ) . setValue ( memoryParameterPrefix + "ms" + memoryInitialSize ) ; } } if ( memoryMaximumSize != null ) { if ( ! attributes . isForkedJavac ( ) ) { attributes . log ( "Since fork is false, ignoring " + "memoryMaximumSize setting." , Project . MSG_WARN ) ; } else { cmd . createArgument ( ) . setValue ( memoryParameterPrefix + "mx" + memoryMaximumSize ) ; } } if ( attributes . getNowarn ( ) ) { cmd . createArgument ( ) . setValue ( "-nowarn" ) ; } if ( deprecation ) { cmd . createArgument ( ) . setValue ( "-deprecation" ) ; } if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "-classpath" ) ; if ( assumeJava11 ( ) ) { Path cp = new Path ( project ) ; Path bp = getBootClassPath ( ) ; if ( bp . size ( ) > 0 ) { cp . append ( bp ) ; } if ( extdirs != null ) { cp . addExtdirs ( extdirs ) ; } cp . append ( classpath ) ; cp . append ( sourcepath ) ; cmd . createArgument ( ) . setPath ( cp ) ; } else { cmd . createArgument ( ) . setPath ( classpath ) ; if ( sourcepath . size ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-sourcepath" ) ; cmd . createArgument ( ) . setPath ( sourcepath ) ; } if ( target != null ) { cmd . createArgument ( ) . setValue ( "-target" ) ; cmd . createArgument ( ) . setValue ( target ) ; } Path bp = getBootClassPath ( ) ; if ( bp . size ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-bootclasspath" ) ; cmd . createArgument ( ) . setPath ( bp ) ; } if ( extdirs != null && extdirs . size ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-extdirs" ) ; cmd . createArgument ( ) . setPath ( extdirs ) ; } } if ( encoding != null ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( encoding ) ; } if ( debug ) { if ( useDebugLevel && ! assumeJava11 ( ) ) { String debugLevel = attributes . getDebugLevel ( ) ; if ( debugLevel != null ) { cmd . createArgument ( ) . setValue ( "-g:" + debugLevel ) ; } else { cmd . createArgument ( ) . setValue ( "-g" ) ; } } else { cmd . createArgument ( ) . setValue ( "-g" ) ; } } else if ( getNoDebugArgument ( ) != null ) { cmd . createArgument ( ) . setValue ( getNoDebugArgument ( ) ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O" ) ; } if ( depend ) { if ( assumeJava11 ( ) ) { cmd . createArgument ( ) . setValue ( "-depend" ) ; } else if ( assumeJava12 ( ) ) { cmd . createArgument ( ) . setValue ( "-Xdepend" ) ; } else { attributes . log ( "depend attribute is not supported by the " + "modern compiler" , Project . MSG_WARN ) ; } } if ( verbose ) { cmd . createArgument ( ) . setValue ( "-verbose" ) ; } addCurrentCompilerArgs ( cmd ) ; return cmd ; } protected Commandline setupModernJavacCommandlineSwitches ( Commandline cmd ) { setupJavacCommandlineSwitches ( cmd , true ) ; if ( attributes . getSource ( ) != null && ! assumeJava13 ( ) ) { cmd . createArgument ( ) . setValue ( "-source" ) ; String source = attributes . getSource ( ) ; if ( ( assumeJava14 ( ) || assumeJava15 ( ) ) && ( source . equals ( "1.1" ) || source . equals ( "1.2" ) ) ) { cmd . createArgument ( ) . setValue ( "1.3" ) ; } else { cmd . createArgument ( ) . setValue ( source ) ; } } else if ( ( assumeJava15 ( ) || assumeJava16 ( ) ) && attributes . getTarget ( ) != null ) { String t = attributes . getTarget ( ) ; if ( t . equals ( "1.1" ) || t . equals ( "1.2" ) || t . equals ( "1.3" ) || t . equals ( "1.4" ) ) { String s = t ; if ( t . equals ( "1.1" ) ) { s = "1.2" ; } attributes . log ( "" , Project . MSG_WARN ) ; attributes . log ( "          WARNING" , Project . MSG_WARN ) ; attributes . log ( "" , Project . MSG_WARN ) ; attributes . log ( "The -source switch defaults to 1.5 in JDK 1.5 and 1.6." , Project . MSG_WARN ) ; attributes . log ( "If you specify -target " + t + " you now must also specify -source " + s + "." , Project . MSG_WARN ) ; attributes . log ( "Ant will implicitly add -source " + s + " for you.  Please change your build file." , Project . MSG_WARN ) ; cmd . createArgument ( ) . setValue ( "-source" ) ; cmd . createArgument ( ) . setValue ( s ) ; } } return cmd ; } protected Commandline setupModernJavacCommand ( ) { Commandline cmd = new Commandline ( ) ; setupModernJavacCommandlineSwitches ( cmd ) ; logAndAddFilesToCompile ( cmd ) ; return cmd ; } protected Commandline setupJavacCommand ( ) { return setupJavacCommand ( false ) ; } protected Commandline setupJavacCommand ( boolean debugLevelCheck ) { Commandline cmd = new Commandline ( ) ; setupJavacCommandlineSwitches ( cmd , debugLevelCheck ) ; logAndAddFilesToCompile ( cmd ) ; return cmd ; } protected void logAndAddFilesToCompile ( Commandline cmd ) { attributes . log ( "Compilation " + cmd . describeArguments ( ) , Project . MSG_VERBOSE ) ; StringBuffer niceSourceList = new StringBuffer ( "File" ) ; if ( compileList . length != 1 ) { niceSourceList . append ( "s" ) ; } niceSourceList . append ( " to be compiled:" ) ; niceSourceList . append ( StringUtils . LINE_SEP ) ; for ( int i = 0 ; i < compileList . length ; i ++ ) { String arg = compileList [ i ] . getAbsolutePath ( ) ; cmd . createArgument ( ) . setValue ( arg ) ; niceSourceList . append ( "    " ) ; niceSourceList . append ( arg ) ; niceSourceList . append ( StringUtils . LINE_SEP ) ; } attributes . log ( niceSourceList . toString ( ) , Project . MSG_VERBOSE ) ; } protected int executeExternalCompile ( String [ ] args , int firstFileName ) { return executeExternalCompile ( args , firstFileName , true ) ; } protected int executeExternalCompile ( String [ ] args , int firstFileName , boolean quoteFiles ) { String [ ] commandArray = null ; File tmpFile = null ; try { if ( Commandline . toString ( args ) . length ( ) > 4096 && firstFileName >= 0 ) { PrintWriter out = null ; try { tmpFile = FILE_UTILS . createTempFile ( "files" , "" , getJavac ( ) . getTempdir ( ) ) ; tmpFile . deleteOnExit ( ) ; out = new PrintWriter ( new FileWriter ( tmpFile ) ) ; for ( int i = firstFileName ; i < args . length ; i ++ ) { if ( quoteFiles && args [ i ] . indexOf ( " " ) > - 1 ) { args [ i ] = args [ i ] . replace ( File . separatorChar , '/' ) ; out . println ( "\"" + args [ i ] + "\"" ) ; } else { out . println ( args [ i ] ) ; } } out . flush ( ) ; commandArray = new String [ firstFileName + 1 ] ; System . arraycopy ( args , 0 , commandArray , 0 , firstFileName ) ; commandArray [ firstFileName ] = "@" + tmpFile ; } catch ( IOException e ) { throw new BuildException ( "Error creating temporary file" , e , location ) ; } finally { FileUtils . close ( out ) ; } } else { commandArray = args ; } try { Execute exe = new Execute ( new LogStreamHandler ( attributes , Project . MSG_INFO , Project . MSG_WARN ) ) ; if ( Os . isFamily ( "openvms" ) ) { exe . setVMLauncher ( true ) ; } exe . setAntRun ( project ) ; exe . setWorkingDirectory ( project . getBaseDir ( ) ) ; exe . setCommandline ( commandArray ) ; exe . execute ( ) ; return exe . getExitValue ( ) ; } catch ( IOException e ) { throw new BuildException ( "Error running " + args [ 0 ] + " compiler" , e , location ) ; } } finally { if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } protected void addExtdirsToClasspath ( Path classpath ) { classpath . addExtdirs ( extdirs ) ; } protected void addCurrentCompilerArgs ( Commandline cmd ) { cmd . addArguments ( getJavac ( ) . getCurrentCompilerArgs ( ) ) ; } protected boolean assumeJava11 ( ) { return "javac1.1" . equals ( attributes . getCompilerVersion ( ) ) ; } protected boolean assumeJava12 ( ) { return "javac1.2" . equals ( attributes . getCompilerVersion ( ) ) || ( "classic" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_2 ) ) || ( "extJavac" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_2 ) ) ; } protected boolean assumeJava13 ( ) { return "javac1.3" . equals ( attributes . getCompilerVersion ( ) ) || ( "classic" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_3 ) ) || ( "modern" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_3 ) ) || ( "extJavac" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_3 ) ) ; } protected boolean assumeJava14 ( ) { return "javac1.4" . equals ( attributes . getCompilerVersion ( ) ) || ( "classic" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_4 ) ) || ( "modern" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_4 ) ) || ( "extJavac" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_4 ) ) ; } protected boolean assumeJava15 ( ) { return "javac1.5" . equals ( attributes . getCompilerVersion ( ) ) || ( "classic" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_5 ) ) || ( "modern" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_5 ) ) || ( "extJavac" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_5 ) ) ; } protected boolean assumeJava16 ( ) { return "javac1.6" . equals ( attributes . getCompilerVersion ( ) ) || ( "classic" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_6 ) ) || ( "modern" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_6 ) ) || ( "extJavac" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_6 ) ) ; } protected Path getBootClassPath ( ) { Path bp = new Path ( project ) ; if ( bootclasspath != null ) { bp . append ( bootclasspath ) ; } return bp . concatSystemBootClasspath ( "ignore" ) ; } protected String getNoDebugArgument ( ) { return assumeJava11 ( ) ? null : "-g:none" ; } } 	1	['25', '1', '10', '26', '103', '134', '10', '16', '3', '0.77173913', '1167', '1', '9', '0', '0.226190476', '0', '0', '44.76', '29', '4.68', '2']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import java . util . Enumeration ; import java . util . Properties ; import java . util . Stack ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . PropertyHelper ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; public class Property extends Task { protected String name ; protected String value ; protected File file ; protected URL url ; protected String resource ; protected Path classpath ; protected String env ; protected Reference ref ; protected String prefix ; private Project fallback ; protected boolean userProperty ; public Property ( ) { this ( false ) ; } protected Property ( boolean userProperty ) { this ( userProperty , null ) ; } protected Property ( boolean userProperty , Project fallback ) { this . userProperty = userProperty ; this . fallback = fallback ; } public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setLocation ( File location ) { setValue ( location . getAbsolutePath ( ) ) ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } public void setFile ( File file ) { this . file = file ; } public File getFile ( ) { return file ; } public void setUrl ( URL url ) { this . url = url ; } public URL getUrl ( ) { return url ; } public void setPrefix ( String prefix ) { this . prefix = prefix ; if ( ! prefix . endsWith ( "." ) ) { this . prefix += "." ; } } public String getPrefix ( ) { return prefix ; } public void setRefid ( Reference ref ) { this . ref = ref ; } public Reference getRefid ( ) { return ref ; } public void setResource ( String resource ) { this . resource = resource ; } public String getResource ( ) { return resource ; } public void setEnvironment ( String env ) { this . env = env ; } public String getEnvironment ( ) { return env ; } public void setClasspath ( Path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public Path getClasspath ( ) { return classpath ; } public void setUserProperty ( boolean userProperty ) { log ( "DEPRECATED: Ignoring request to set user property in Property" + " task." , Project . MSG_WARN ) ; } public String toString ( ) { return value == null ? "" : value ; } public void execute ( ) throws BuildException { if ( getProject ( ) == null ) { throw new IllegalStateException ( "project has not been set" ) ; } if ( name != null ) { if ( value == null && ref == null ) { throw new BuildException ( "You must specify value, location or " + "refid with the name attribute" , getLocation ( ) ) ; } } else { if ( url == null && file == null && resource == null && env == null ) { throw new BuildException ( "You must specify url, file, resource or " + "environment when not using the " + "name attribute" , getLocation ( ) ) ; } } if ( url == null && file == null && resource == null && prefix != null ) { throw new BuildException ( "Prefix is only valid when loading from " + "a url, file or resource" , getLocation ( ) ) ; } if ( ( name != null ) && ( value != null ) ) { addProperty ( name , value ) ; } if ( file != null ) { loadFile ( file ) ; } if ( url != null ) { loadUrl ( url ) ; } if ( resource != null ) { loadResource ( resource ) ; } if ( env != null ) { loadEnvironment ( env ) ; } if ( ( name != null ) && ( ref != null ) ) { try { addProperty ( name , ref . getReferencedObject ( getProject ( ) ) . toString ( ) ) ; } catch ( BuildException be ) { if ( fallback != null ) { addProperty ( name , ref . getReferencedObject ( fallback ) . toString ( ) ) ; } else { throw be ; } } } } protected void loadUrl ( URL url ) throws BuildException { Properties props = new Properties ( ) ; log ( "Loading " + url , Project . MSG_VERBOSE ) ; try { InputStream is = url . openStream ( ) ; try { props . load ( is ) ; } finally { if ( is != null ) { is . close ( ) ; } } addProperties ( props ) ; } catch ( IOException ex ) { throw new BuildException ( ex , getLocation ( ) ) ; } } protected void loadFile ( File file ) throws BuildException { Properties props = new Properties ( ) ; log ( "Loading " + file . getAbsolutePath ( ) , Project . MSG_VERBOSE ) ; try { if ( file . exists ( ) ) { FileInputStream fis = new FileInputStream ( file ) ; try { props . load ( fis ) ; } finally { if ( fis != null ) { fis . close ( ) ; } } addProperties ( props ) ; } else { log ( "Unable to find property file: " + file . getAbsolutePath ( ) , Project . MSG_VERBOSE ) ; } } catch ( IOException ex ) { throw new BuildException ( ex , getLocation ( ) ) ; } } protected void loadResource ( String name ) { Properties props = new Properties ( ) ; log ( "Resource Loading " + name , Project . MSG_VERBOSE ) ; InputStream is = null ; try { ClassLoader cL = null ; if ( classpath != null ) { cL = getProject ( ) . createClassLoader ( classpath ) ; } else { cL = this . getClass ( ) . getClassLoader ( ) ; } if ( cL == null ) { is = ClassLoader . getSystemResourceAsStream ( name ) ; } else { is = cL . getResourceAsStream ( name ) ; } if ( is != null ) { props . load ( is ) ; addProperties ( props ) ; } else { log ( "Unable to find resource " + name , Project . MSG_WARN ) ; } } catch ( IOException ex ) { throw new BuildException ( ex , getLocation ( ) ) ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( IOException e ) { } } } } protected void loadEnvironment ( String prefix ) { Properties props = new Properties ( ) ; if ( ! prefix . endsWith ( "." ) ) { prefix += "." ; } log ( "Loading Environment " + prefix , Project . MSG_VERBOSE ) ; Vector osEnv = Execute . getProcEnvironment ( ) ; for ( Enumeration e = osEnv . elements ( ) ; e . hasMoreElements ( ) ; ) { String entry = ( String ) e . nextElement ( ) ; int pos = entry . indexOf ( '=' ) ; if ( pos == - 1 ) { log ( "Ignoring: " + entry , Project . MSG_WARN ) ; } else { props . put ( prefix + entry . substring ( 0 , pos ) , entry . substring ( pos + 1 ) ) ; } } addProperties ( props ) ; } protected void addProperties ( Properties props ) { resolveAllProperties ( props ) ; Enumeration e = props . keys ( ) ; while ( e . hasMoreElements ( ) ) { String propertyName = ( String ) e . nextElement ( ) ; String propertyValue = props . getProperty ( propertyName ) ; String v = getProject ( ) . replaceProperties ( propertyValue ) ; if ( prefix != null ) { propertyName = prefix + propertyName ; } addProperty ( propertyName , v ) ; } } protected void addProperty ( String n , String v ) { if ( userProperty ) { if ( getProject ( ) . getUserProperty ( n ) == null ) { getProject ( ) . setInheritedProperty ( n , v ) ; } else { log ( "Override ignored for " + n , Project . MSG_VERBOSE ) ; } } else { getProject ( ) . setNewProperty ( n , v ) ; } } private void resolveAllProperties ( Properties props ) throws BuildException { for ( Enumeration e = props . keys ( ) ; e . hasMoreElements ( ) ; ) { String propertyName = ( String ) e . nextElement ( ) ; Stack referencesSeen = new Stack ( ) ; resolve ( props , propertyName , referencesSeen ) ; } } private void resolve ( Properties props , String name , Stack referencesSeen ) throws BuildException { if ( referencesSeen . contains ( name ) ) { throw new BuildException ( "Property " + name + " was circularly " + "defined." ) ; } String propertyValue = props . getProperty ( name ) ; Vector fragments = new Vector ( ) ; Vector propertyRefs = new Vector ( ) ; PropertyHelper . getPropertyHelper ( this . getProject ( ) ) . parsePropertyString ( propertyValue , fragments , propertyRefs ) ; if ( propertyRefs . size ( ) != 0 ) { referencesSeen . push ( name ) ; StringBuffer sb = new StringBuffer ( ) ; Enumeration i = fragments . elements ( ) ; Enumeration j = propertyRefs . elements ( ) ; while ( i . hasMoreElements ( ) ) { String fragment = ( String ) i . nextElement ( ) ; if ( fragment == null ) { String propertyName = ( String ) j . nextElement ( ) ; fragment = getProject ( ) . getProperty ( propertyName ) ; if ( fragment == null ) { if ( props . containsKey ( propertyName ) ) { resolve ( props , propertyName , referencesSeen ) ; fragment = props . getProperty ( propertyName ) ; } else { fragment = "${" + propertyName + "}" ; } } } sb . append ( fragment ) ; } propertyValue = sb . toString ( ) ; props . put ( name , propertyValue ) ; referencesSeen . pop ( ) ; } } } 	1	['35', '3', '0', '13', '93', '519', '4', '9', '25', '0.909090909', '807', '1', '3', '0.536231884', '0.171428571', '0', '0', '21.74285714', '7', '1.4', '1']
package org . apache . tools . ant . types . optional ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . ScriptRunnerBase ; import org . apache . tools . ant . util . ScriptRunnerHelper ; import java . io . File ; public abstract class AbstractScriptComponent extends ProjectComponent { private ScriptRunnerHelper helper = new ScriptRunnerHelper ( ) ; private ScriptRunnerBase runner = null ; public void setProject ( Project project ) { super . setProject ( project ) ; helper . setProjectComponent ( this ) ; } public ScriptRunnerBase getRunner ( ) { initScriptRunner ( ) ; return runner ; } public void setSrc ( File file ) { helper . setSrc ( file ) ; } public void addText ( String text ) { helper . addText ( text ) ; } public void setManager ( String manager ) { helper . setManager ( manager ) ; } public void setLanguage ( String language ) { helper . setLanguage ( language ) ; } protected void initScriptRunner ( ) { if ( runner != null ) { return ; } helper . setProjectComponent ( this ) ; runner = helper . getScriptRunner ( ) ; } public void setClasspath ( Path classpath ) { helper . setClasspath ( classpath ) ; } public Path createClasspath ( ) { return helper . createClasspath ( ) ; } public void setClasspathRef ( Reference r ) { helper . setClasspathRef ( r ) ; } protected void executeScript ( String execName ) { getRunner ( ) . executeScript ( execName ) ; } } 	1	['12', '2', '2', '8', '25', '0', '2', '6', '10', '0.363636364', '91', '1', '2', '0.45', '0.277777778', '1', '1', '6.416666667', '2', '1', '1']
package org . apache . tools . ant . taskdefs . optional . ejb ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . Vector ; import java . util . jar . JarEntry ; import java . util . jar . JarFile ; import java . util . jar . JarOutputStream ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Java ; import org . apache . tools . ant . types . Environment ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileUtils ; import org . xml . sax . InputSource ; public class WeblogicDeploymentTool extends GenericDeploymentTool { public static final String PUBLICID_EJB11 = "-//Sun Microsystems, Inc.//DTD Enterprise JavaBeans 1.1//EN" ; public static final String PUBLICID_EJB20 = "-//Sun Microsystems, Inc.//DTD Enterprise JavaBeans 2.0//EN" ; public static final String PUBLICID_WEBLOGIC_EJB510 = "-//BEA Systems, Inc.//DTD WebLogic 5.1.0 EJB//EN" ; public static final String PUBLICID_WEBLOGIC_EJB600 = "-//BEA Systems, Inc.//DTD WebLogic 6.0.0 EJB//EN" ; public static final String PUBLICID_WEBLOGIC_EJB700 = "-//BEA Systems, Inc.//DTD WebLogic 7.0.0 EJB//EN" ; protected static final String DEFAULT_WL51_EJB11_DTD_LOCATION = "/weblogic/ejb/deployment/xml/ejb-jar.dtd" ; protected static final String DEFAULT_WL60_EJB11_DTD_LOCATION = "/weblogic/ejb20/dd/xml/ejb11-jar.dtd" ; protected static final String DEFAULT_WL60_EJB20_DTD_LOCATION = "/weblogic/ejb20/dd/xml/ejb20-jar.dtd" ; protected static final String DEFAULT_WL51_DTD_LOCATION = "/weblogic/ejb/deployment/xml/weblogic-ejb-jar.dtd" ; protected static final String DEFAULT_WL60_51_DTD_LOCATION = "/weblogic/ejb20/dd/xml/weblogic510-ejb-jar.dtd" ; protected static final String DEFAULT_WL60_DTD_LOCATION = "/weblogic/ejb20/dd/xml/weblogic600-ejb-jar.dtd" ; protected static final String DEFAULT_WL70_DTD_LOCATION = "/weblogic/ejb20/dd/xml/weblogic700-ejb-jar.dtd" ; protected static final String DEFAULT_COMPILER = "default" ; protected static final String WL_DD = "weblogic-ejb-jar.xml" ; protected static final String WL_CMP_DD = "weblogic-cmp-rdbms-jar.xml" ; protected static final String COMPILER_EJB11 = "weblogic.ejbc" ; protected static final String COMPILER_EJB20 = "weblogic.ejbc20" ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private String jarSuffix = ".jar" ; private String weblogicDTD ; private String ejb11DTD ; private boolean keepgenerated = false ; private String ejbcClass = null ; private String additionalArgs = "" ; private String additionalJvmArgs = "" ; private boolean keepGeneric = false ; private String compiler = null ; private boolean alwaysRebuild = true ; private boolean noEJBC = false ; private boolean newCMP = false ; private Path wlClasspath = null ; private Vector sysprops = new Vector ( ) ; private Integer jvmDebugLevel = null ; private File outputDir ; public void addSysproperty ( Environment . Variable sysp ) { sysprops . add ( sysp ) ; } public Path createWLClasspath ( ) { if ( wlClasspath == null ) { wlClasspath = new Path ( getTask ( ) . getProject ( ) ) ; } return wlClasspath . createPath ( ) ; } public void setOutputDir ( File outputDir ) { this . outputDir = outputDir ; } public void setWLClasspath ( Path wlClasspath ) { this . wlClasspath = wlClasspath ; } public void setCompiler ( String compiler ) { this . compiler = compiler ; } public void setRebuild ( boolean rebuild ) { this . alwaysRebuild = rebuild ; } public void setJvmDebugLevel ( Integer jvmDebugLevel ) { this . jvmDebugLevel = jvmDebugLevel ; } public Integer getJvmDebugLevel ( ) { return jvmDebugLevel ; } public void setSuffix ( String inString ) { this . jarSuffix = inString ; } public void setKeepgeneric ( boolean inValue ) { this . keepGeneric = inValue ; } public void setKeepgenerated ( String inValue ) { this . keepgenerated = Boolean . valueOf ( inValue ) . booleanValue ( ) ; } public void setArgs ( String args ) { this . additionalArgs = args ; } public void setJvmargs ( String args ) { this . additionalJvmArgs = args ; } public void setEjbcClass ( String ejbcClass ) { this . ejbcClass = ejbcClass ; } public String getEjbcClass ( ) { return ejbcClass ; } public void setWeblogicdtd ( String inString ) { setEJBdtd ( inString ) ; } public void setWLdtd ( String inString ) { this . weblogicDTD = inString ; } public void setEJBdtd ( String inString ) { this . ejb11DTD = inString ; } public void setOldCMP ( boolean oldCMP ) { this . newCMP = ! oldCMP ; } public void setNewCMP ( boolean newCMP ) { this . newCMP = newCMP ; } public void setNoEJBC ( boolean noEJBC ) { this . noEJBC = noEJBC ; } protected void registerKnownDTDs ( DescriptorHandler handler ) { handler . registerDTD ( PUBLICID_EJB11 , DEFAULT_WL51_EJB11_DTD_LOCATION ) ; handler . registerDTD ( PUBLICID_EJB11 , DEFAULT_WL60_EJB11_DTD_LOCATION ) ; handler . registerDTD ( PUBLICID_EJB11 , ejb11DTD ) ; handler . registerDTD ( PUBLICID_EJB20 , DEFAULT_WL60_EJB20_DTD_LOCATION ) ; } protected DescriptorHandler getWeblogicDescriptorHandler ( final File srcDir ) { DescriptorHandler handler = new DescriptorHandler ( getTask ( ) , srcDir ) { protected void processElement ( ) { if ( currentElement . equals ( "type-storage" ) ) { String fileNameWithMETA = currentText ; String fileName = fileNameWithMETA . substring ( META_DIR . length ( ) , fileNameWithMETA . length ( ) ) ; File descriptorFile = new File ( srcDir , fileName ) ; ejbFiles . put ( fileNameWithMETA , descriptorFile ) ; } } } ; handler . registerDTD ( PUBLICID_WEBLOGIC_EJB510 , DEFAULT_WL51_DTD_LOCATION ) ; handler . registerDTD ( PUBLICID_WEBLOGIC_EJB510 , DEFAULT_WL60_51_DTD_LOCATION ) ; handler . registerDTD ( PUBLICID_WEBLOGIC_EJB600 , DEFAULT_WL60_DTD_LOCATION ) ; handler . registerDTD ( PUBLICID_WEBLOGIC_EJB700 , DEFAULT_WL70_DTD_LOCATION ) ; handler . registerDTD ( PUBLICID_WEBLOGIC_EJB510 , weblogicDTD ) ; handler . registerDTD ( PUBLICID_WEBLOGIC_EJB600 , weblogicDTD ) ; for ( Iterator i = getConfig ( ) . dtdLocations . iterator ( ) ; i . hasNext ( ) ; ) { EjbJar . DTDLocation dtdLocation = ( EjbJar . DTDLocation ) i . next ( ) ; handler . registerDTD ( dtdLocation . getPublicId ( ) , dtdLocation . getLocation ( ) ) ; } return handler ; } protected void addVendorFiles ( Hashtable ejbFiles , String ddPrefix ) { File weblogicDD = new File ( getConfig ( ) . descriptorDir , ddPrefix + WL_DD ) ; if ( weblogicDD . exists ( ) ) { ejbFiles . put ( META_DIR + WL_DD , weblogicDD ) ; } else { log ( "Unable to locate weblogic deployment descriptor. " + "It was expected to be in " + weblogicDD . getPath ( ) , Project . MSG_WARN ) ; return ; } if ( ! newCMP ) { log ( "The old method for locating CMP files has been DEPRECATED." , Project . MSG_VERBOSE ) ; log ( "Please adjust your weblogic descriptor and set " + "newCMP=\"true\" to use the new CMP descriptor " + "inclusion mechanism. " , Project . MSG_VERBOSE ) ; File weblogicCMPDD = new File ( getConfig ( ) . descriptorDir , ddPrefix + WL_CMP_DD ) ; if ( weblogicCMPDD . exists ( ) ) { ejbFiles . put ( META_DIR + WL_CMP_DD , weblogicCMPDD ) ; } } else { try { File ejbDescriptor = ( File ) ejbFiles . get ( META_DIR + EJB_DD ) ; SAXParserFactory saxParserFactory = SAXParserFactory . newInstance ( ) ; saxParserFactory . setValidating ( true ) ; SAXParser saxParser = saxParserFactory . newSAXParser ( ) ; DescriptorHandler handler = getWeblogicDescriptorHandler ( ejbDescriptor . getParentFile ( ) ) ; saxParser . parse ( new InputSource ( new FileInputStream ( weblogicDD ) ) , handler ) ; Hashtable ht = handler . getFiles ( ) ; Enumeration e = ht . keys ( ) ; while ( e . hasMoreElements ( ) ) { String key = ( String ) e . nextElement ( ) ; ejbFiles . put ( key , ht . get ( key ) ) ; } } catch ( Exception e ) { String msg = "Exception while adding Vendor specific files: " + e . toString ( ) ; throw new BuildException ( msg , e ) ; } } } File getVendorOutputJarFile ( String baseName ) { return new File ( getDestDir ( ) , baseName + jarSuffix ) ; } private void buildWeblogicJar ( File sourceJar , File destJar , String publicId ) { Java javaTask = null ; if ( noEJBC ) { try { FILE_UTILS . copyFile ( sourceJar , destJar ) ; if ( ! keepgenerated ) { sourceJar . delete ( ) ; } return ; } catch ( IOException e ) { throw new BuildException ( "Unable to write EJB jar" , e ) ; } } String ejbcClassName = ejbcClass ; try { javaTask = new Java ( getTask ( ) ) ; javaTask . setTaskName ( "ejbc" ) ; javaTask . createJvmarg ( ) . setLine ( additionalJvmArgs ) ; if ( ! ( sysprops . isEmpty ( ) ) ) { for ( Enumeration en = sysprops . elements ( ) ; en . hasMoreElements ( ) ; ) { Environment . Variable entry = ( Environment . Variable ) en . nextElement ( ) ; javaTask . addSysproperty ( entry ) ; } } if ( getJvmDebugLevel ( ) != null ) { javaTask . createJvmarg ( ) . setLine ( " -Dweblogic.StdoutSeverityLevel=" + jvmDebugLevel ) ; } if ( ejbcClassName == null ) { if ( PUBLICID_EJB11 . equals ( publicId ) ) { ejbcClassName = COMPILER_EJB11 ; } else if ( PUBLICID_EJB20 . equals ( publicId ) ) { ejbcClassName = COMPILER_EJB20 ; } else { log ( "Unrecognized publicId " + publicId + " - using EJB 1.1 compiler" , Project . MSG_WARN ) ; ejbcClassName = COMPILER_EJB11 ; } } javaTask . setClassname ( ejbcClassName ) ; javaTask . createArg ( ) . setLine ( additionalArgs ) ; if ( keepgenerated ) { javaTask . createArg ( ) . setValue ( "-keepgenerated" ) ; } if ( compiler == null ) { String buildCompiler = getTask ( ) . getProject ( ) . getProperty ( "build.compiler" ) ; if ( buildCompiler != null && buildCompiler . equals ( "jikes" ) ) { javaTask . createArg ( ) . setValue ( "-compiler" ) ; javaTask . createArg ( ) . setValue ( "jikes" ) ; } } else { if ( ! compiler . equals ( DEFAULT_COMPILER ) ) { javaTask . createArg ( ) . setValue ( "-compiler" ) ; javaTask . createArg ( ) . setLine ( compiler ) ; } } Path combinedClasspath = getCombinedClasspath ( ) ; if ( wlClasspath != null && combinedClasspath != null && combinedClasspath . toString ( ) . trim ( ) . length ( ) > 0 ) { javaTask . createArg ( ) . setValue ( "-classpath" ) ; javaTask . createArg ( ) . setPath ( combinedClasspath ) ; } javaTask . createArg ( ) . setValue ( sourceJar . getPath ( ) ) ; if ( outputDir == null ) { javaTask . createArg ( ) . setValue ( destJar . getPath ( ) ) ; } else { javaTask . createArg ( ) . setValue ( outputDir . getPath ( ) ) ; } Path classpath = wlClasspath ; if ( classpath == null ) { classpath = getCombinedClasspath ( ) ; } javaTask . setFork ( true ) ; if ( classpath != null ) { javaTask . setClasspath ( classpath ) ; } log ( "Calling " + ejbcClassName + " for " + sourceJar . toString ( ) , Project . MSG_VERBOSE ) ; if ( javaTask . executeJava ( ) != 0 ) { throw new BuildException ( "Ejbc reported an error" ) ; } } catch ( Exception e ) { String msg = "Exception while calling " + ejbcClassName + ". Details: " + e . toString ( ) ; throw new BuildException ( msg , e ) ; } } protected void writeJar ( String baseName , File jarFile , Hashtable files , String publicId ) throws BuildException { File genericJarFile = super . getVendorOutputJarFile ( baseName ) ; super . writeJar ( baseName , genericJarFile , files , publicId ) ; if ( alwaysRebuild || isRebuildRequired ( genericJarFile , jarFile ) ) { buildWeblogicJar ( genericJarFile , jarFile , publicId ) ; } if ( ! keepGeneric ) { log ( "deleting generic jar " + genericJarFile . toString ( ) , Project . MSG_VERBOSE ) ; genericJarFile . delete ( ) ; } } public void validateConfigured ( ) throws BuildException { super . validateConfigured ( ) ; } protected boolean isRebuildRequired ( File genericJarFile , File weblogicJarFile ) { boolean rebuild = false ; JarFile genericJar = null ; JarFile wlJar = null ; File newWLJarFile = null ; JarOutputStream newJarStream = null ; ClassLoader genericLoader = null ; try { log ( "Checking if weblogic Jar needs to be rebuilt for jar " + weblogicJarFile . getName ( ) , Project . MSG_VERBOSE ) ; if ( genericJarFile . exists ( ) && genericJarFile . isFile ( ) && weblogicJarFile . exists ( ) && weblogicJarFile . isFile ( ) ) { genericJar = new JarFile ( genericJarFile ) ; wlJar = new JarFile ( weblogicJarFile ) ; Hashtable genericEntries = new Hashtable ( ) ; Hashtable wlEntries = new Hashtable ( ) ; Hashtable replaceEntries = new Hashtable ( ) ; for ( Enumeration e = genericJar . entries ( ) ; e . hasMoreElements ( ) ; ) { JarEntry je = ( JarEntry ) e . nextElement ( ) ; genericEntries . put ( je . getName ( ) . replace ( '\\' , '/' ) , je ) ; } for ( Enumeration e = wlJar . entries ( ) ; e . hasMoreElements ( ) ; ) { JarEntry je = ( JarEntry ) e . nextElement ( ) ; wlEntries . put ( je . getName ( ) , je ) ; } genericLoader = getClassLoaderFromJar ( genericJarFile ) ; for ( Enumeration e = genericEntries . keys ( ) ; e . hasMoreElements ( ) ; ) { String filepath = ( String ) e . nextElement ( ) ; if ( wlEntries . containsKey ( filepath ) ) { JarEntry genericEntry = ( JarEntry ) genericEntries . get ( filepath ) ; JarEntry wlEntry = ( JarEntry ) wlEntries . get ( filepath ) ; if ( ( genericEntry . getCrc ( ) != wlEntry . getCrc ( ) ) || ( genericEntry . getSize ( ) != wlEntry . getSize ( ) ) ) { if ( genericEntry . getName ( ) . endsWith ( ".class" ) ) { String classname = genericEntry . getName ( ) . replace ( File . separatorChar , '.' ) ; classname = classname . substring ( 0 , classname . lastIndexOf ( ".class" ) ) ; Class genclass = genericLoader . loadClass ( classname ) ; if ( genclass . isInterface ( ) ) { log ( "Interface " + genclass . getName ( ) + " has changed" , Project . MSG_VERBOSE ) ; rebuild = true ; break ; } else { replaceEntries . put ( filepath , genericEntry ) ; } } else { if ( ! genericEntry . getName ( ) . equals ( "META-INF/MANIFEST.MF" ) ) { log ( "Non class file " + genericEntry . getName ( ) + " has changed" , Project . MSG_VERBOSE ) ; rebuild = true ; break ; } } } } else { log ( "File " + filepath + " not present in weblogic jar" , Project . MSG_VERBOSE ) ; rebuild = true ; break ; } } if ( ! rebuild ) { log ( "No rebuild needed - updating jar" , Project . MSG_VERBOSE ) ; newWLJarFile = new File ( weblogicJarFile . getAbsolutePath ( ) + ".temp" ) ; if ( newWLJarFile . exists ( ) ) { newWLJarFile . delete ( ) ; } newJarStream = new JarOutputStream ( new FileOutputStream ( newWLJarFile ) ) ; newJarStream . setLevel ( 0 ) ; for ( Enumeration e = wlEntries . elements ( ) ; e . hasMoreElements ( ) ; ) { byte [ ] buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; int bytesRead ; InputStream is ; JarEntry je = ( JarEntry ) e . nextElement ( ) ; if ( je . getCompressedSize ( ) == - 1 || je . getCompressedSize ( ) == je . getSize ( ) ) { newJarStream . setLevel ( 0 ) ; } else { newJarStream . setLevel ( JAR_COMPRESS_LEVEL ) ; } if ( replaceEntries . containsKey ( je . getName ( ) ) ) { log ( "Updating Bean class from generic Jar " + je . getName ( ) , Project . MSG_VERBOSE ) ; je = ( JarEntry ) replaceEntries . get ( je . getName ( ) ) ; is = genericJar . getInputStream ( je ) ; } else { is = wlJar . getInputStream ( je ) ; } newJarStream . putNextEntry ( new JarEntry ( je . getName ( ) ) ) ; while ( ( bytesRead = is . read ( buffer ) ) != - 1 ) { newJarStream . write ( buffer , 0 , bytesRead ) ; } is . close ( ) ; } } else { log ( "Weblogic Jar rebuild needed due to changed " + "interface or XML" , Project . MSG_VERBOSE ) ; } } else { rebuild = true ; } } catch ( ClassNotFoundException cnfe ) { String cnfmsg = "ClassNotFoundException while processing ejb-jar file" + ". Details: " + cnfe . getMessage ( ) ; throw new BuildException ( cnfmsg , cnfe ) ; } catch ( IOException ioe ) { String msg = "IOException while processing ejb-jar file " + ". Details: " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe ) ; } finally { if ( genericJar != null ) { try { genericJar . close ( ) ; } catch ( IOException closeException ) { } } if ( wlJar != null ) { try { wlJar . close ( ) ; } catch ( IOException closeException ) { } } if ( newJarStream != null ) { try { newJarStream . close ( ) ; } catch ( IOException closeException ) { } try { FILE_UTILS . rename ( newWLJarFile , weblogicJarFile ) ; } catch ( IOException renameException ) { log ( renameException . getMessage ( ) , Project . MSG_WARN ) ; rebuild = true ; } } if ( genericLoader != null && genericLoader instanceof AntClassLoader ) { AntClassLoader loader = ( AntClassLoader ) genericLoader ; loader . cleanup ( ) ; } } return rebuild ; } protected ClassLoader getClassLoaderFromJar ( File classjar ) throws IOException { Path lookupPath = new Path ( getTask ( ) . getProject ( ) ) ; lookupPath . setLocation ( classjar ) ; Path classpath = getCombinedClasspath ( ) ; if ( classpath != null ) { lookupPath . append ( classpath ) ; } return getTask ( ) . getProject ( ) . createClassLoader ( lookupPath ) ; } } 	1	['32', '2', '1', '16', '140', '400', '3', '14', '23', '0.970588235', '1196', '0.852941176', '2', '0.516129032', '0.218637993', '1', '5', '35.3125', '28', '2.625', '1']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . GZIPInputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . bzip2 . CBZip2InputStream ; import org . apache . tools . tar . TarEntry ; import org . apache . tools . tar . TarInputStream ; public class Untar extends Expand { private UntarCompressionMethod compression = new UntarCompressionMethod ( ) ; public void setCompression ( UntarCompressionMethod method ) { compression = method ; } public void setEncoding ( String encoding ) { throw new BuildException ( "The " + getTaskName ( ) + " task doesn't support the encoding" + " attribute" , getLocation ( ) ) ; } protected void expandFile ( FileUtils fileUtils , File srcF , File dir ) { FileInputStream fis = null ; try { fis = new FileInputStream ( srcF ) ; expandStream ( srcF . getPath ( ) , fis , dir ) ; } catch ( IOException ioe ) { throw new BuildException ( "Error while expanding " + srcF . getPath ( ) , ioe , getLocation ( ) ) ; } finally { FileUtils . close ( fis ) ; } } protected void expandResource ( Resource srcR , File dir ) { InputStream i = null ; try { i = srcR . getInputStream ( ) ; expandStream ( srcR . getName ( ) , i , dir ) ; } catch ( IOException ioe ) { throw new BuildException ( "Error while expanding " + srcR . getName ( ) , ioe , getLocation ( ) ) ; } finally { FileUtils . close ( i ) ; } } private void expandStream ( String name , InputStream stream , File dir ) throws IOException { TarInputStream tis = null ; try { tis = new TarInputStream ( compression . decompress ( name , new BufferedInputStream ( stream ) ) ) ; log ( "Expanding: " + name + " into " + dir , Project . MSG_INFO ) ; TarEntry te = null ; FileNameMapper mapper = getMapper ( ) ; while ( ( te = tis . getNextEntry ( ) ) != null ) { extractFile ( FileUtils . getFileUtils ( ) , null , dir , tis , te . getName ( ) , te . getModTime ( ) , te . isDirectory ( ) , mapper ) ; } log ( "expand complete" , Project . MSG_VERBOSE ) ; } finally { FileUtils . close ( tis ) ; } } public static final class UntarCompressionMethod extends EnumeratedAttribute { private static final String NONE = "none" ; private static final String GZIP = "gzip" ; private static final String BZIP2 = "bzip2" ; public UntarCompressionMethod ( ) { super ( ) ; setValue ( NONE ) ; } public String [ ] getValues ( ) { return new String [ ] { NONE , GZIP , BZIP2 } ; } public InputStream decompress ( final String name , final InputStream istream ) throws IOException , BuildException { final String v = getValue ( ) ; if ( GZIP . equals ( v ) ) { return new GZIPInputStream ( istream ) ; } else { if ( BZIP2 . equals ( v ) ) { final char [ ] magic = new char [ ] { 'B' , 'Z' } ; for ( int i = 0 ; i < magic . length ; i ++ ) { if ( istream . read ( ) != magic [ i ] ) { throw new BuildException ( "Invalid bz2 file." + name ) ; } } return new CBZip2InputStream ( istream ) ; } } return istream ; } } } 	1	['6', '4', '0', '9', '32', '9', '0', '9', '3', '0.2', '182', '1', '1', '0.910714286', '0.357142857', '1', '1', '29.16666667', '3', '1.5', '2']
package org . apache . tools . ant ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Enumeration ; import java . util . HashMap ; import java . util . Hashtable ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Iterator ; import org . apache . tools . ant . util . CollectionUtils ; import org . xml . sax . AttributeList ; import org . xml . sax . helpers . AttributeListImpl ; public class RuntimeConfigurable implements Serializable { private static final Hashtable EMPTY_HASHTABLE = new Hashtable ( 0 ) ; private String elementTag = null ; private List children = null ; private transient Object wrappedObject = null ; private transient IntrospectionHelper . Creator creator ; private transient AttributeList attributes ; private List attributeNames = null ; private Map attributeMap = null ; private StringBuffer characters = null ; private boolean proxyConfigured = false ; private String polyType = null ; private String id = null ; public RuntimeConfigurable ( Object proxy , String elementTag ) { setProxy ( proxy ) ; setElementTag ( elementTag ) ; if ( proxy instanceof Task ) { ( ( Task ) proxy ) . setRuntimeConfigurableWrapper ( this ) ; } } public synchronized void setProxy ( Object proxy ) { wrappedObject = proxy ; proxyConfigured = false ; } synchronized void setCreator ( IntrospectionHelper . Creator creator ) { this . creator = creator ; } public synchronized Object getProxy ( ) { return wrappedObject ; } public synchronized String getId ( ) { return id ; } public synchronized String getPolyType ( ) { return polyType ; } public synchronized void setPolyType ( String polyType ) { this . polyType = polyType ; } public synchronized void setAttributes ( AttributeList attributes ) { this . attributes = new AttributeListImpl ( attributes ) ; for ( int i = 0 ; i < attributes . getLength ( ) ; i ++ ) { setAttribute ( attributes . getName ( i ) , attributes . getValue ( i ) ) ; } } public synchronized void setAttribute ( String name , String value ) { if ( name . equalsIgnoreCase ( ProjectHelper . ANT_TYPE ) ) { this . polyType = value ; } else { if ( attributeNames == null ) { attributeNames = new ArrayList ( ) ; attributeMap = new HashMap ( ) ; } if ( name . toLowerCase ( Locale . US ) . equals ( "refid" ) ) { attributeNames . add ( 0 , name ) ; } else { attributeNames . add ( name ) ; } attributeMap . put ( name , value ) ; if ( name . equals ( "id" ) ) { this . id = value ; } } } public synchronized void removeAttribute ( String name ) { attributeNames . remove ( name ) ; attributeMap . remove ( name ) ; } public synchronized Hashtable getAttributeMap ( ) { return ( attributeMap == null ) ? EMPTY_HASHTABLE : new Hashtable ( attributeMap ) ; } public synchronized AttributeList getAttributes ( ) { return attributes ; } public synchronized void addChild ( RuntimeConfigurable child ) { children = ( children == null ) ? new ArrayList ( ) : children ; children . add ( child ) ; } synchronized RuntimeConfigurable getChild ( int index ) { return ( RuntimeConfigurable ) children . get ( index ) ; } public synchronized Enumeration getChildren ( ) { return ( children == null ) ? new CollectionUtils . EmptyEnumeration ( ) : Collections . enumeration ( children ) ; } public synchronized void addText ( String data ) { if ( data . length ( ) == 0 ) { return ; } characters = ( characters == null ) ? new StringBuffer ( data ) : characters . append ( data ) ; } public synchronized void addText ( char [ ] buf , int start , int count ) { if ( count == 0 ) { return ; } characters = ( ( characters == null ) ? new StringBuffer ( count ) : characters ) . append ( buf , start , count ) ; } public synchronized StringBuffer getText ( ) { return ( characters == null ) ? new StringBuffer ( 0 ) : characters ; } public synchronized void setElementTag ( String elementTag ) { this . elementTag = elementTag ; } public synchronized String getElementTag ( ) { return elementTag ; } public void maybeConfigure ( Project p ) throws BuildException { maybeConfigure ( p , true ) ; } public synchronized void maybeConfigure ( Project p , boolean configureChildren ) throws BuildException { if ( proxyConfigured ) { return ; } Object target = ( wrappedObject instanceof TypeAdapter ) ? ( ( TypeAdapter ) wrappedObject ) . getProxy ( ) : wrappedObject ; IntrospectionHelper ih = IntrospectionHelper . getHelper ( p , target . getClass ( ) ) ; if ( attributeNames != null ) { for ( int i = 0 ; i < attributeNames . size ( ) ; i ++ ) { String name = ( String ) attributeNames . get ( i ) ; String value = ( String ) attributeMap . get ( name ) ; value = p . replaceProperties ( value ) ; try { ih . setAttribute ( p , target , name , value ) ; } catch ( UnsupportedAttributeException be ) { if ( name . equals ( "id" ) ) { } else if ( getElementTag ( ) == null ) { throw be ; } else { throw new BuildException ( getElementTag ( ) + " doesn't support the \"" + be . getAttribute ( ) + "\" attribute" , be ) ; } } catch ( BuildException be ) { if ( name . equals ( "id" ) ) { } else { throw be ; } } } } if ( characters != null ) { ProjectHelper . addText ( p , wrappedObject , characters . substring ( 0 ) ) ; } if ( id != null ) { p . addReference ( id , wrappedObject ) ; } proxyConfigured = true ; } public void reconfigure ( Project p ) { proxyConfigured = false ; maybeConfigure ( p ) ; } public void applyPreSet ( RuntimeConfigurable r ) { if ( r . attributeMap != null ) { for ( Iterator i = r . attributeMap . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { String name = ( String ) i . next ( ) ; if ( attributeMap == null || attributeMap . get ( name ) == null ) { setAttribute ( name , ( String ) r . attributeMap . get ( name ) ) ; } } } polyType = ( polyType == null ) ? r . polyType : polyType ; if ( r . children != null ) { List newChildren = new ArrayList ( ) ; newChildren . addAll ( r . children ) ; if ( children != null ) { newChildren . addAll ( children ) ; } children = newChildren ; } if ( r . characters != null ) { if ( characters == null || characters . toString ( ) . trim ( ) . length ( ) == 0 ) { characters = new StringBuffer ( r . characters . toString ( ) ) ; } } } } 	1	['25', '1', '0', '20', '71', '182', '12', '9', '22', '0.819444444', '515', '1', '1', '0', '0.179166667', '0', '0', '19.12', '11', '1.84', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . filters . ChainableReader ; import org . apache . tools . ant . types . RedirectorElement ; import org . apache . tools . ant . types . FilterChain ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . resources . FileResource ; import java . util . Iterator ; import java . io . File ; import java . io . Reader ; import java . io . IOException ; public class VerifyJar extends AbstractJarSignerTask { public static final String ERROR_NO_FILE = "Not found :" ; private static final String VERIFIED_TEXT = "jar verified." ; private boolean certificates = false ; private BufferingOutputFilter outputCache = new BufferingOutputFilter ( ) ; public static final String ERROR_NO_VERIFY = "Failed to verify " ; public void setCertificates ( boolean certificates ) { this . certificates = certificates ; } public void execute ( ) throws BuildException { final boolean hasJar = jar != null ; if ( ! hasJar && ! hasResources ( ) ) { throw new BuildException ( ERROR_NO_SOURCE ) ; } beginExecution ( ) ; RedirectorElement redirector = getRedirector ( ) ; redirector . setAlwaysLog ( true ) ; FilterChain outputFilterChain = redirector . createOutputFilterChain ( ) ; outputFilterChain . add ( outputCache ) ; try { Path sources = createUnifiedSourcePath ( ) ; Iterator iter = sources . iterator ( ) ; while ( iter . hasNext ( ) ) { FileResource fr = ( FileResource ) iter . next ( ) ; verifyOneJar ( fr . getFile ( ) ) ; } } finally { endExecution ( ) ; } } private void verifyOneJar ( File jar ) { if ( ! jar . exists ( ) ) { throw new BuildException ( ERROR_NO_FILE + jar ) ; } final ExecTask cmd = createJarSigner ( ) ; setCommonOptions ( cmd ) ; bindToKeystore ( cmd ) ; addValue ( cmd , "-verify" ) ; if ( certificates ) { addValue ( cmd , "-certs" ) ; } addValue ( cmd , jar . getPath ( ) ) ; log ( "Verifying JAR: " + jar . getAbsolutePath ( ) ) ; outputCache . clear ( ) ; BuildException ex = null ; try { cmd . execute ( ) ; } catch ( BuildException e ) { ex = e ; } String results = outputCache . toString ( ) ; if ( ex != null ) { if ( results . indexOf ( "zip file closed" ) >= 0 ) { log ( "You are running " + JARSIGNER_COMMAND + " against a JVM with" + " a known bug that manifests as an IllegalStateException." , Project . MSG_WARN ) ; } else { throw ex ; } } if ( results . indexOf ( VERIFIED_TEXT ) < 0 ) { throw new BuildException ( ERROR_NO_VERIFY + jar ) ; } } private static class BufferingOutputFilter implements ChainableReader { private BufferingOutputFilterReader buffer ; public Reader chain ( Reader rdr ) { buffer = new BufferingOutputFilterReader ( rdr ) ; return buffer ; } public String toString ( ) { return buffer . toString ( ) ; } public void clear ( ) { if ( buffer != null ) { buffer . clear ( ) ; } } } private static class BufferingOutputFilterReader extends Reader { private Reader next ; private StringBuffer buffer = new StringBuffer ( ) ; public BufferingOutputFilterReader ( Reader next ) { this . next = next ; } public int read ( char [ ] cbuf , int off , int len ) throws IOException { int result = next . read ( cbuf , off , len ) ; buffer . append ( cbuf , off , len ) ; return result ; } public void close ( ) throws IOException { next . close ( ) ; } public String toString ( ) { return buffer . toString ( ) ; } public void clear ( ) { buffer = new StringBuffer ( ) ; } } } 	1	['4', '4', '0', '9', '36', '0', '0', '9', '3', '0.866666667', '179', '0.6', '1', '0.952380952', '0.5', '0', '0', '42.5', '6', '2', '1']
package org . apache . tools . ant . taskdefs . optional . ssh ; import com . jcraft . jsch . Channel ; import com . jcraft . jsch . Session ; import com . jcraft . jsch . JSchException ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . FileInputStream ; import java . io . OutputStream ; import java . util . List ; import java . util . Iterator ; public class ScpToMessage extends AbstractSshMessage { private static final int BUFFER_SIZE = 1024 ; private File localFile ; private String remotePath ; private List directoryList ; public ScpToMessage ( Session session ) { super ( session ) ; } public ScpToMessage ( boolean verbose , Session session ) { super ( verbose , session ) ; } public ScpToMessage ( boolean verbose , Session session , File aLocalFile , String aRemotePath ) { this ( verbose , session , aRemotePath ) ; this . localFile = aLocalFile ; } public ScpToMessage ( boolean verbose , Session session , List aDirectoryList , String aRemotePath ) { this ( verbose , session , aRemotePath ) ; this . directoryList = aDirectoryList ; } private ScpToMessage ( boolean verbose , Session session , String aRemotePath ) { super ( verbose , session ) ; this . remotePath = aRemotePath ; } public ScpToMessage ( Session session , File aLocalFile , String aRemotePath ) { this ( false , session , aLocalFile , aRemotePath ) ; } public ScpToMessage ( Session session , List aDirectoryList , String aRemotePath ) { this ( false , session , aDirectoryList , aRemotePath ) ; } public void execute ( ) throws IOException , JSchException { if ( directoryList != null ) { doMultipleTransfer ( ) ; } if ( localFile != null ) { doSingleTransfer ( ) ; } log ( "done.\n" ) ; } private void doSingleTransfer ( ) throws IOException , JSchException { String cmd = "scp -t " + remotePath ; Channel channel = openExecChannel ( cmd ) ; try { OutputStream out = channel . getOutputStream ( ) ; InputStream in = channel . getInputStream ( ) ; channel . connect ( ) ; waitForAck ( in ) ; sendFileToRemote ( localFile , in , out ) ; } finally { if ( channel != null ) { channel . disconnect ( ) ; } } } private void doMultipleTransfer ( ) throws IOException , JSchException { Channel channel = openExecChannel ( "scp -r -d -t " + remotePath ) ; try { OutputStream out = channel . getOutputStream ( ) ; InputStream in = channel . getInputStream ( ) ; channel . connect ( ) ; waitForAck ( in ) ; for ( Iterator i = directoryList . iterator ( ) ; i . hasNext ( ) ; ) { Directory current = ( Directory ) i . next ( ) ; sendDirectory ( current , in , out ) ; } } finally { if ( channel != null ) { channel . disconnect ( ) ; } } } private void sendDirectory ( Directory current , InputStream in , OutputStream out ) throws IOException { for ( Iterator fileIt = current . filesIterator ( ) ; fileIt . hasNext ( ) ; ) { sendFileToRemote ( ( File ) fileIt . next ( ) , in , out ) ; } for ( Iterator dirIt = current . directoryIterator ( ) ; dirIt . hasNext ( ) ; ) { Directory dir = ( Directory ) dirIt . next ( ) ; sendDirectoryToRemote ( dir , in , out ) ; } } private void sendDirectoryToRemote ( Directory directory , InputStream in , OutputStream out ) throws IOException { String command = "D0755 0 " ; command += directory . getDirectory ( ) . getName ( ) ; command += "\n" ; out . write ( command . getBytes ( ) ) ; out . flush ( ) ; waitForAck ( in ) ; sendDirectory ( directory , in , out ) ; out . write ( "E\n" . getBytes ( ) ) ; waitForAck ( in ) ; } private void sendFileToRemote ( File localFile , InputStream in , OutputStream out ) throws IOException { long filesize = localFile . length ( ) ; String command = "C0644 " + filesize + " " ; command += localFile . getName ( ) ; command += "\n" ; out . write ( command . getBytes ( ) ) ; out . flush ( ) ; waitForAck ( in ) ; FileInputStream fis = new FileInputStream ( localFile ) ; byte [ ] buf = new byte [ BUFFER_SIZE ] ; long startTime = System . currentTimeMillis ( ) ; long totalLength = 0 ; boolean trackProgress = getVerbose ( ) && filesize > 102400 ; long initFilesize = filesize ; int percentTransmitted = 0 ; try { if ( this . getVerbose ( ) ) { log ( "Sending: " + localFile . getName ( ) + " : " + localFile . length ( ) ) ; } while ( true ) { int len = fis . read ( buf , 0 , buf . length ) ; if ( len <= 0 ) { break ; } out . write ( buf , 0 , len ) ; totalLength += len ; if ( trackProgress ) { percentTransmitted = trackProgress ( initFilesize , totalLength , percentTransmitted ) ; } } out . flush ( ) ; sendAck ( out ) ; waitForAck ( in ) ; } finally { if ( this . getVerbose ( ) ) { long endTime = System . currentTimeMillis ( ) ; logStats ( startTime , endTime , totalLength ) ; } fis . close ( ) ; } } public File getLocalFile ( ) { return localFile ; } public String getRemotePath ( ) { return remotePath ; } } 	1	['15', '2', '1', '7', '49', '75', '2', '5', '9', '0.75', '402', '1', '0', '0.578947368', '0.325925926', '1', '1', '25.53333333', '1', '0.5333', '1']
package org . apache . tools . ant . taskdefs . optional . unix ; import java . io . File ; import java . io . IOException ; import java . io . PrintStream ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . BufferedInputStream ; import java . io . BufferedOutputStream ; import java . io . FileNotFoundException ; import java . util . Vector ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Hashtable ; import java . util . Properties ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . dispatch . DispatchTask ; import org . apache . tools . ant . dispatch . DispatchUtils ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . util . FileUtils ; public class Symlink extends DispatchTask { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private String resource ; private String link ; private Vector fileSets = new Vector ( ) ; private String linkFileName ; private boolean overwrite ; private boolean failonerror ; private boolean executing = false ; public void init ( ) throws BuildException { super . init ( ) ; setDefaults ( ) ; } public synchronized void execute ( ) throws BuildException { if ( executing ) { throw new BuildException ( "Infinite recursion detected in Symlink.execute()" ) ; } try { executing = true ; DispatchUtils . execute ( this ) ; } finally { executing = false ; } } public void single ( ) throws BuildException { try { if ( resource == null ) { handleError ( "Must define the resource to symlink to!" ) ; return ; } if ( link == null ) { handleError ( "Must define the link name for symlink!" ) ; return ; } doLink ( resource , link ) ; } finally { setDefaults ( ) ; } } public void delete ( ) throws BuildException { try { if ( link == null ) { handleError ( "Must define the link name for symlink!" ) ; return ; } log ( "Removing symlink: " + link ) ; deleteSymlink ( link ) ; } catch ( FileNotFoundException fnfe ) { handleError ( fnfe . toString ( ) ) ; } catch ( IOException ioe ) { handleError ( ioe . toString ( ) ) ; } finally { setDefaults ( ) ; } } public void recreate ( ) throws BuildException { try { if ( fileSets . isEmpty ( ) ) { handleError ( "File set identifying link file(s) " + "required for action recreate" ) ; return ; } Properties links = loadLinks ( fileSets ) ; for ( Iterator kitr = links . keySet ( ) . iterator ( ) ; kitr . hasNext ( ) ; ) { String lnk = ( String ) kitr . next ( ) ; String res = links . getProperty ( lnk ) ; try { File test = new File ( lnk ) ; if ( ! FILE_UTILS . isSymbolicLink ( null , lnk ) ) { doLink ( res , lnk ) ; } else if ( ! test . getCanonicalPath ( ) . equals ( new File ( res ) . getCanonicalPath ( ) ) ) { deleteSymlink ( lnk ) ; doLink ( res , lnk ) ; } } catch ( IOException ioe ) { handleError ( "IO exception while creating link" ) ; } } } finally { setDefaults ( ) ; } } public void record ( ) throws BuildException { try { if ( fileSets . isEmpty ( ) ) { handleError ( "Fileset identifying links to record required" ) ; return ; } if ( linkFileName == null ) { handleError ( "Name of file to record links in required" ) ; return ; } Hashtable byDir = new Hashtable ( ) ; for ( Iterator litr = findLinks ( fileSets ) . iterator ( ) ; litr . hasNext ( ) ; ) { File thisLink = ( File ) litr . next ( ) ; File parent = thisLink . getParentFile ( ) ; Vector v = ( Vector ) byDir . get ( parent ) ; if ( v == null ) { v = new Vector ( ) ; byDir . put ( parent , v ) ; } v . addElement ( thisLink ) ; } for ( Iterator dirs = byDir . keySet ( ) . iterator ( ) ; dirs . hasNext ( ) ; ) { File dir = ( File ) dirs . next ( ) ; Vector linksInDir = ( Vector ) byDir . get ( dir ) ; Properties linksToStore = new Properties ( ) ; for ( Iterator dlnk = linksInDir . iterator ( ) ; dlnk . hasNext ( ) ; ) { File lnk = ( File ) dlnk . next ( ) ; try { linksToStore . put ( lnk . getName ( ) , lnk . getCanonicalPath ( ) ) ; } catch ( IOException ioe ) { handleError ( "Couldn't get canonical name of parent link" ) ; } } writePropertyFile ( linksToStore , dir ) ; } } finally { setDefaults ( ) ; } } private void setDefaults ( ) { resource = null ; link = null ; linkFileName = null ; failonerror = true ; overwrite = false ; setAction ( "single" ) ; fileSets . clear ( ) ; } public void setOverwrite ( boolean owrite ) { this . overwrite = owrite ; } public void setFailOnError ( boolean foe ) { this . failonerror = foe ; } public void setAction ( String action ) { super . setAction ( action ) ; } public void setLink ( String lnk ) { this . link = lnk ; } public void setResource ( String src ) { this . resource = src ; } public void setLinkfilename ( String lf ) { this . linkFileName = lf ; } public void addFileset ( FileSet set ) { fileSets . addElement ( set ) ; } public static void deleteSymlink ( String path ) throws IOException , FileNotFoundException { deleteSymlink ( new File ( path ) ) ; } public static void deleteSymlink ( File linkfil ) throws IOException , FileNotFoundException { if ( ! linkfil . exists ( ) ) { throw new FileNotFoundException ( "No such symlink: " + linkfil ) ; } File canfil = linkfil . getCanonicalFile ( ) ; File temp = FILE_UTILS . createTempFile ( "symlink" , ".tmp" , canfil . getParentFile ( ) ) ; try { try { FILE_UTILS . rename ( canfil , temp ) ; } catch ( IOException e ) { throw new IOException ( "Couldn't rename resource when attempting to delete " + linkfil ) ; } if ( ! linkfil . delete ( ) ) { throw new IOException ( "Couldn't delete symlink: " + linkfil + " (was it a real file? is this not a UNIX system?)" ) ; } } finally { try { FILE_UTILS . rename ( temp , canfil ) ; } catch ( IOException e ) { throw new IOException ( "Couldn't return resource " + temp + " to its original name: " + canfil . getAbsolutePath ( ) + "\n THE RESOURCE'S NAME ON DISK HAS " + "BEEN CHANGED BY THIS ERROR!\n" ) ; } } } private void writePropertyFile ( Properties properties , File dir ) throws BuildException { BufferedOutputStream bos = null ; try { bos = new BufferedOutputStream ( new FileOutputStream ( new File ( dir , linkFileName ) ) ) ; properties . store ( bos , "Symlinks from " + dir ) ; } catch ( IOException ioe ) { throw new BuildException ( ioe , getLocation ( ) ) ; } finally { FileUtils . close ( bos ) ; } } private void handleError ( String msg ) { if ( failonerror ) { throw new BuildException ( msg ) ; } log ( msg ) ; } private void doLink ( String res , String lnk ) throws BuildException { File linkfil = new File ( lnk ) ; if ( overwrite && linkfil . exists ( ) ) { try { deleteSymlink ( linkfil ) ; } catch ( FileNotFoundException fnfe ) { handleError ( "Symlink disappeared before it was deleted: " + lnk ) ; } catch ( IOException ioe ) { handleError ( "Unable to overwrite preexisting link: " + lnk ) ; } } String [ ] cmd = new String [ ] { "ln" , "-s" , res , lnk } ; log ( Commandline . toString ( cmd ) ) ; Execute . runCommand ( this , cmd ) ; } private HashSet findLinks ( Vector v ) { HashSet result = new HashSet ( ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) v . get ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] [ ] fnd = new String [ ] [ ] { ds . getIncludedFiles ( ) , ds . getIncludedDirectories ( ) } ; File dir = fs . getDir ( getProject ( ) ) ; for ( int j = 0 ; j < fnd . length ; j ++ ) { for ( int k = 0 ; k < fnd [ j ] . length ; k ++ ) { try { File f = new File ( dir , fnd [ j ] [ k ] ) ; File pf = f . getParentFile ( ) ; String name = f . getName ( ) ; if ( FILE_UTILS . isSymbolicLink ( pf , name ) ) { result . add ( new File ( pf . getCanonicalFile ( ) , name ) ) ; } } catch ( IOException e ) { handleError ( "IOException: " + fnd [ j ] [ k ] + " omitted" ) ; } } } } return result ; } private Properties loadLinks ( Vector v ) { Properties finalList = new Properties ( ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) v . elementAt ( i ) ; DirectoryScanner ds = new DirectoryScanner ( ) ; fs . setupDirectoryScanner ( ds , getProject ( ) ) ; ds . setFollowSymlinks ( false ) ; ds . scan ( ) ; String [ ] incs = ds . getIncludedFiles ( ) ; File dir = fs . getDir ( getProject ( ) ) ; for ( int j = 0 ; j < incs . length ; j ++ ) { File inc = new File ( dir , incs [ j ] ) ; File pf = inc . getParentFile ( ) ; Properties lnks = new Properties ( ) ; try { lnks . load ( new BufferedInputStream ( new FileInputStream ( inc ) ) ) ; pf = pf . getCanonicalFile ( ) ; } catch ( FileNotFoundException fnfe ) { handleError ( "Unable to find " + incs [ j ] + "; skipping it." ) ; continue ; } catch ( IOException ioe ) { handleError ( "Unable to open " + incs [ j ] + " or its parent dir; skipping it." ) ; continue ; } lnks . list ( new PrintStream ( new LogOutputStream ( this , Project . MSG_INFO ) ) ) ; for ( Iterator kitr = lnks . keySet ( ) . iterator ( ) ; kitr . hasNext ( ) ; ) { String key = ( String ) kitr . next ( ) ; finalList . put ( new File ( pf , key ) . getAbsolutePath ( ) , lnks . getProperty ( key ) ) ; } } } return finalList ; } } 	1	['23', '4', '0', '13', '96', '181', '0', '13', '16', '0.715909091', '856', '1', '1', '0.655737705', '0.227272727', '0', '0', '35.86956522', '5', '1.2609', '5']
package org . apache . tools . ant ; import java . io . BufferedReader ; import java . io . File ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . util . Hashtable ; import java . util . Locale ; import java . util . Vector ; import org . apache . tools . ant . helper . ProjectHelper2 ; import org . apache . tools . ant . util . LoaderUtils ; import org . xml . sax . AttributeList ; public class ProjectHelper { public static final String ANT_CORE_URI = "antlib:org.apache.tools.ant" ; public static final String ANT_CURRENT_URI = "ant:current" ; public static final String ANTLIB_URI = "antlib:" ; public static final String ANT_TYPE = "ant-type" ; public static final String HELPER_PROPERTY = "org.apache.tools.ant.ProjectHelper" ; public static final String SERVICE_ID = "META-INF/services/org.apache.tools.ant.ProjectHelper" ; public static final String PROJECTHELPER_REFERENCE = "ant.projectHelper" ; public static void configureProject ( Project project , File buildFile ) throws BuildException { ProjectHelper helper = ProjectHelper . getProjectHelper ( ) ; project . addReference ( PROJECTHELPER_REFERENCE , helper ) ; helper . parse ( project , buildFile ) ; } public ProjectHelper ( ) { } private Vector importStack = new Vector ( ) ; public Vector getImportStack ( ) { return importStack ; } public void parse ( Project project , Object source ) throws BuildException { throw new BuildException ( "ProjectHelper.parse() must be implemented " + "in a helper plugin " + this . getClass ( ) . getName ( ) ) ; } public static ProjectHelper getProjectHelper ( ) throws BuildException { ProjectHelper helper = null ; String helperClass = System . getProperty ( HELPER_PROPERTY ) ; try { if ( helperClass != null ) { helper = newHelper ( helperClass ) ; } } catch ( SecurityException e ) { System . out . println ( "Unable to load ProjectHelper class \"" + helperClass + " specified in system property " + HELPER_PROPERTY ) ; } if ( helper == null ) { try { ClassLoader classLoader = LoaderUtils . getContextClassLoader ( ) ; InputStream is = null ; if ( classLoader != null ) { is = classLoader . getResourceAsStream ( SERVICE_ID ) ; } if ( is == null ) { is = ClassLoader . getSystemResourceAsStream ( SERVICE_ID ) ; } if ( is != null ) { InputStreamReader isr ; try { isr = new InputStreamReader ( is , "UTF-8" ) ; } catch ( java . io . UnsupportedEncodingException e ) { isr = new InputStreamReader ( is ) ; } BufferedReader rd = new BufferedReader ( isr ) ; String helperClassName = rd . readLine ( ) ; rd . close ( ) ; if ( helperClassName != null && ! "" . equals ( helperClassName ) ) { helper = newHelper ( helperClassName ) ; } } } catch ( Exception ex ) { System . out . println ( "Unable to load ProjectHelper " + "from service \"" + SERVICE_ID ) ; } } if ( helper != null ) { return helper ; } else { return new ProjectHelper2 ( ) ; } } private static ProjectHelper newHelper ( String helperClass ) throws BuildException { ClassLoader classLoader = LoaderUtils . getContextClassLoader ( ) ; try { Class clazz = null ; if ( classLoader != null ) { try { clazz = classLoader . loadClass ( helperClass ) ; } catch ( ClassNotFoundException ex ) { } } if ( clazz == null ) { clazz = Class . forName ( helperClass ) ; } return ( ( ProjectHelper ) clazz . newInstance ( ) ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } public static ClassLoader getContextClassLoader ( ) { if ( ! LoaderUtils . isContextLoaderAvailable ( ) ) { return null ; } return LoaderUtils . getContextClassLoader ( ) ; } public static void configure ( Object target , AttributeList attrs , Project project ) throws BuildException { if ( target instanceof TypeAdapter ) { target = ( ( TypeAdapter ) target ) . getProxy ( ) ; } IntrospectionHelper ih = IntrospectionHelper . getHelper ( project , target . getClass ( ) ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String value = replaceProperties ( project , attrs . getValue ( i ) , project . getProperties ( ) ) ; try { ih . setAttribute ( project , target , attrs . getName ( i ) . toLowerCase ( Locale . US ) , value ) ; } catch ( BuildException be ) { if ( ! attrs . getName ( i ) . equals ( "id" ) ) { throw be ; } } } } public static void addText ( Project project , Object target , char [ ] buf , int start , int count ) throws BuildException { addText ( project , target , new String ( buf , start , count ) ) ; } public static void addText ( Project project , Object target , String text ) throws BuildException { if ( text == null ) { return ; } if ( target instanceof TypeAdapter ) { target = ( ( TypeAdapter ) target ) . getProxy ( ) ; } IntrospectionHelper . getHelper ( project , target . getClass ( ) ) . addText ( project , target , text ) ; } public static void storeChild ( Project project , Object parent , Object child , String tag ) { IntrospectionHelper ih = IntrospectionHelper . getHelper ( project , parent . getClass ( ) ) ; ih . storeElement ( project , parent , child , tag ) ; } public static String replaceProperties ( Project project , String value ) throws BuildException { return project . replaceProperties ( value ) ; } public static String replaceProperties ( Project project , String value , Hashtable keys ) throws BuildException { PropertyHelper ph = PropertyHelper . getPropertyHelper ( project ) ; return ph . replaceProperties ( null , value , keys ) ; } public static void parsePropertyString ( String value , Vector fragments , Vector propertyRefs ) throws BuildException { PropertyHelper . parsePropertyStringDefault ( value , fragments , propertyRefs ) ; } public static String genComponentName ( String uri , String name ) { if ( uri == null || uri . equals ( "" ) || uri . equals ( ANT_CORE_URI ) ) { return name ; } return uri + ":" + name ; } public static String extractUriFromComponentName ( String componentName ) { if ( componentName == null ) { return "" ; } int index = componentName . lastIndexOf ( ':' ) ; if ( index == - 1 ) { return "" ; } return componentName . substring ( 0 , index ) ; } public static String extractNameFromComponentName ( String componentName ) { int index = componentName . lastIndexOf ( ':' ) ; if ( index == - 1 ) { return componentName ; } return componentName . substring ( index + 1 ) ; } public static BuildException addLocationToBuildException ( BuildException ex , Location newLocation ) { if ( ex . getLocation ( ) == null || ex . getMessage ( ) == null ) { return ex ; } String errorMessage = "The following error occurred while executing this line:" + System . getProperty ( "line.separator" ) + ex . getLocation ( ) . toString ( ) + ex . getMessage ( ) ; if ( newLocation == null ) { return new BuildException ( errorMessage , ex ) ; } else { return new BuildException ( errorMessage , ex , newLocation ) ; } } } 	1	['18', '1', '2', '24', '68', '151', '18', '8', '17', '1.044117647', '386', '0.125', '0', '0', '0.152777778', '0', '0', '20', '4', '1.5', '1']
package org . apache . tools . ant . listener ; import org . apache . log4j . Logger ; import org . apache . log4j . helpers . NullEnumeration ; import org . apache . tools . ant . BuildEvent ; import org . apache . tools . ant . BuildListener ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Target ; import org . apache . tools . ant . Task ; public class Log4jListener implements BuildListener { private boolean initialized = false ; public static final String LOG_ANT = "org.apache.tools.ant" ; public Log4jListener ( ) { initialized = false ; Logger log = Logger . getLogger ( LOG_ANT ) ; Logger rootLog = Logger . getRootLogger ( ) ; if ( ! ( rootLog . getAllAppenders ( ) instanceof NullEnumeration ) ) { initialized = true ; } else { log . error ( "No log4j.properties in build area" ) ; } } public void buildStarted ( BuildEvent event ) { if ( initialized ) { Logger log = Logger . getLogger ( Project . class . getName ( ) ) ; log . info ( "Build started." ) ; } } public void buildFinished ( BuildEvent event ) { if ( initialized ) { Logger log = Logger . getLogger ( Project . class . getName ( ) ) ; if ( event . getException ( ) == null ) { log . info ( "Build finished." ) ; } else { log . error ( "Build finished with error." , event . getException ( ) ) ; } } } public void targetStarted ( BuildEvent event ) { if ( initialized ) { Logger log = Logger . getLogger ( Target . class . getName ( ) ) ; log . info ( "Target \"" + event . getTarget ( ) . getName ( ) + "\" started." ) ; } } public void targetFinished ( BuildEvent event ) { if ( initialized ) { String targetName = event . getTarget ( ) . getName ( ) ; Logger cat = Logger . getLogger ( Target . class . getName ( ) ) ; if ( event . getException ( ) == null ) { cat . info ( "Target \"" + targetName + "\" finished." ) ; } else { cat . error ( "Target \"" + targetName + "\" finished with error." , event . getException ( ) ) ; } } } public void taskStarted ( BuildEvent event ) { if ( initialized ) { Task task = event . getTask ( ) ; Logger log = Logger . getLogger ( task . getClass ( ) . getName ( ) ) ; log . info ( "Task \"" + task . getTaskName ( ) + "\" started." ) ; } } public void taskFinished ( BuildEvent event ) { if ( initialized ) { Task task = event . getTask ( ) ; Logger log = Logger . getLogger ( task . getClass ( ) . getName ( ) ) ; if ( event . getException ( ) == null ) { log . info ( "Task \"" + task . getTaskName ( ) + "\" finished." ) ; } else { log . error ( "Task \"" + task . getTaskName ( ) + "\" finished with error." , event . getException ( ) ) ; } } } public void messageLogged ( BuildEvent event ) { if ( initialized ) { Object categoryObject = event . getTask ( ) ; if ( categoryObject == null ) { categoryObject = event . getTarget ( ) ; if ( categoryObject == null ) { categoryObject = event . getProject ( ) ; } } Logger log = Logger . getLogger ( categoryObject . getClass ( ) . getName ( ) ) ; switch ( event . getPriority ( ) ) { case Project . MSG_ERR : log . error ( event . getMessage ( ) ) ; break ; case Project . MSG_WARN : log . warn ( event . getMessage ( ) ) ; break ; case Project . MSG_INFO : log . info ( event . getMessage ( ) ) ; break ; case Project . MSG_VERBOSE : log . debug ( event . getMessage ( ) ) ; break ; case Project . MSG_DEBUG : log . debug ( event . getMessage ( ) ) ; break ; default : log . error ( event . getMessage ( ) ) ; break ; } } } } 	1	['8', '1', '0', '7', '33', '0', '0', '7', '8', '0.714285714', '305', '0.25', '0', '0', '0.9375', '0', '0', '36.625', '5', '3', '1']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . UnsupportedEncodingException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . launch . Locator ; import org . apache . tools . ant . util . FileUtils ; public class ManifestClassPath extends Task { private String name ; private File dir ; private int maxParentLevels = 2 ; private Path path ; public void execute ( ) { if ( name == null ) { throw new BuildException ( "Missing 'property' attribute!" ) ; } if ( dir == null ) { throw new BuildException ( "Missing 'jarfile' attribute!" ) ; } if ( getProject ( ) . getProperty ( name ) != null ) { throw new BuildException ( "Property '" + name + "' already set!" ) ; } if ( path == null ) { throw new BuildException ( "Missing nested <classpath>!" ) ; } final FileUtils fileUtils = FileUtils . getFileUtils ( ) ; dir = fileUtils . normalize ( dir . getAbsolutePath ( ) ) ; File currDir = dir ; String [ ] dirs = new String [ maxParentLevels + 1 ] ; for ( int i = 0 ; i < maxParentLevels + 1 ; ++ i ) { dirs [ i ] = currDir . getAbsolutePath ( ) + File . separatorChar ; currDir = currDir . getParentFile ( ) ; if ( currDir == null ) { maxParentLevels = i + 1 ; break ; } } String [ ] elements = path . list ( ) ; StringBuffer buffer = new StringBuffer ( ) ; StringBuffer element = new StringBuffer ( ) ; for ( int i = 0 ; i < elements . length ; ++ i ) { File pathEntry = new File ( elements [ i ] ) ; pathEntry = fileUtils . normalize ( pathEntry . getAbsolutePath ( ) ) ; String fullPath = pathEntry . getAbsolutePath ( ) ; String relPath = null ; for ( int j = 0 ; j <= maxParentLevels ; ++ j ) { String dir = dirs [ j ] ; if ( ! fullPath . startsWith ( dir ) ) { continue ; } element . setLength ( 0 ) ; for ( int k = 0 ; k < j ; ++ k ) { element . append ( ".." ) ; element . append ( File . separatorChar ) ; } element . append ( fullPath . substring ( dir . length ( ) ) ) ; relPath = element . toString ( ) ; break ; } if ( relPath == null ) { throw new BuildException ( "No suitable relative path from " + dir + " to " + fullPath ) ; } if ( File . separatorChar != '/' ) { relPath = relPath . replace ( File . separatorChar , '/' ) ; } if ( pathEntry . isDirectory ( ) ) { relPath = relPath + '/' ; } try { relPath = Locator . encodeURI ( relPath ) ; } catch ( UnsupportedEncodingException exc ) { throw new BuildException ( exc ) ; } buffer . append ( relPath ) ; buffer . append ( ' ' ) ; } getProject ( ) . setNewProperty ( name , buffer . toString ( ) . trim ( ) ) ; } public void setProperty ( String name ) { this . name = name ; } public void setJarFile ( File jarfile ) { File parent = jarfile . getParentFile ( ) ; if ( ! parent . isDirectory ( ) ) { throw new BuildException ( "Jar's directory not found: " + parent ) ; } this . dir = parent ; } public void setMaxParentLevels ( int levels ) { this . maxParentLevels = levels ; } public void addClassPath ( Path path ) { this . path = path ; } } 	1	['6', '3', '0', '6', '33', '3', '0', '6', '6', '0.75', '292', '1', '1', '0.880952381', '0.333333333', '0', '0', '47', '14', '3.1667', '2']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileWriter ; import java . io . FilenameFilter ; import java . io . IOException ; import java . io . PrintWriter ; import java . io . BufferedReader ; import java . io . FileReader ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . ArrayList ; import java . util . Enumeration ; import java . util . Iterator ; import java . util . Locale ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . MagicNames ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . DirSet ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . PatternSet ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; public class Javadoc extends Task { public class DocletParam { private String name ; private String value ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } } public static class ExtensionInfo extends ProjectComponent { private String name ; private Path path ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setPath ( Path path ) { if ( this . path == null ) { this . path = path ; } else { this . path . append ( path ) ; } } public Path getPath ( ) { return path ; } public Path createPath ( ) { if ( path == null ) { path = new Path ( getProject ( ) ) ; } return path . createPath ( ) ; } public void setPathRef ( Reference r ) { createPath ( ) . setRefid ( r ) ; } } public class DocletInfo extends ExtensionInfo { private Vector params = new Vector ( ) ; public DocletParam createParam ( ) { DocletParam param = new DocletParam ( ) ; params . addElement ( param ) ; return param ; } public Enumeration getParams ( ) { return params . elements ( ) ; } } public static class PackageName { private String name ; public void setName ( String name ) { this . name = name . trim ( ) ; } public String getName ( ) { return name ; } public String toString ( ) { return getName ( ) ; } } public static class SourceFile { private File file ; public SourceFile ( ) { } public SourceFile ( File file ) { this . file = file ; } public void setFile ( File file ) { this . file = file ; } public File getFile ( ) { return file ; } } public static class Html { private StringBuffer text = new StringBuffer ( ) ; public void addText ( String t ) { text . append ( t ) ; } public String getText ( ) { return text . substring ( 0 ) ; } } public static class AccessType extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "protected" , "public" , "package" , "private" } ; } } public class ResourceCollectionContainer { private ArrayList rcs = new ArrayList ( ) ; public void add ( ResourceCollection rc ) { rcs . add ( rc ) ; } private Iterator iterator ( ) { return rcs . iterator ( ) ; } } private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private Commandline cmd = new Commandline ( ) ; private void addArgIf ( boolean b , String arg ) { if ( b ) { cmd . createArgument ( ) . setValue ( arg ) ; } } private void addArgIfNotEmpty ( String key , String value ) { if ( value != null && value . length ( ) != 0 ) { cmd . createArgument ( ) . setValue ( key ) ; cmd . createArgument ( ) . setValue ( value ) ; } else { log ( "Warning: Leaving out empty argument '" + key + "'" , Project . MSG_WARN ) ; } } private boolean failOnError = false ; private Path sourcePath = null ; private File destDir = null ; private Vector sourceFiles = new Vector ( ) ; private Vector packageNames = new Vector ( ) ; private Vector excludePackageNames = new Vector ( 1 ) ; private boolean author = true ; private boolean version = true ; private DocletInfo doclet = null ; private Path classpath = null ; private Path bootclasspath = null ; private String group = null ; private String packageList = null ; private Vector links = new Vector ( ) ; private Vector groups = new Vector ( ) ; private Vector tags = new Vector ( ) ; private boolean useDefaultExcludes = true ; private Html doctitle = null ; private Html header = null ; private Html footer = null ; private Html bottom = null ; private boolean useExternalFile = false ; private String source = null ; private boolean linksource = false ; private boolean breakiterator = false ; private String noqualifier ; private boolean includeNoSourcePackages = false ; private boolean old = false ; private String executable = null ; private ResourceCollectionContainer nestedSourceFiles = new ResourceCollectionContainer ( ) ; private Vector packageSets = new Vector ( ) ; public void setUseExternalFile ( boolean b ) { useExternalFile = b ; } public void setDefaultexcludes ( boolean useDefaultExcludes ) { this . useDefaultExcludes = useDefaultExcludes ; } public void setMaxmemory ( String max ) { cmd . createArgument ( ) . setValue ( "-J-Xmx" + max ) ; } public void setAdditionalparam ( String add ) { cmd . createArgument ( ) . setLine ( add ) ; } public Commandline . Argument createArg ( ) { return cmd . createArgument ( ) ; } public void setSourcepath ( Path src ) { if ( sourcePath == null ) { sourcePath = src ; } else { sourcePath . append ( src ) ; } } public Path createSourcepath ( ) { if ( sourcePath == null ) { sourcePath = new Path ( getProject ( ) ) ; } return sourcePath . createPath ( ) ; } public void setSourcepathRef ( Reference r ) { createSourcepath ( ) . setRefid ( r ) ; } public void setDestdir ( File dir ) { destDir = dir ; cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } public void setSourcefiles ( String src ) { StringTokenizer tok = new StringTokenizer ( src , "," ) ; while ( tok . hasMoreTokens ( ) ) { String f = tok . nextToken ( ) ; SourceFile sf = new SourceFile ( ) ; sf . setFile ( getProject ( ) . resolveFile ( f . trim ( ) ) ) ; addSource ( sf ) ; } } public void addSource ( SourceFile sf ) { sourceFiles . addElement ( sf ) ; } public void setPackagenames ( String packages ) { StringTokenizer tok = new StringTokenizer ( packages , "," ) ; while ( tok . hasMoreTokens ( ) ) { String p = tok . nextToken ( ) ; PackageName pn = new PackageName ( ) ; pn . setName ( p ) ; addPackage ( pn ) ; } } public void addPackage ( PackageName pn ) { packageNames . addElement ( pn ) ; } public void setExcludePackageNames ( String packages ) { StringTokenizer tok = new StringTokenizer ( packages , "," ) ; while ( tok . hasMoreTokens ( ) ) { String p = tok . nextToken ( ) ; PackageName pn = new PackageName ( ) ; pn . setName ( p ) ; addExcludePackage ( pn ) ; } } public void addExcludePackage ( PackageName pn ) { excludePackageNames . addElement ( pn ) ; } public void setOverview ( File f ) { cmd . createArgument ( ) . setValue ( "-overview" ) ; cmd . createArgument ( ) . setFile ( f ) ; } public void setPublic ( boolean b ) { addArgIf ( b , "-public" ) ; } public void setProtected ( boolean b ) { addArgIf ( b , "-protected" ) ; } public void setPackage ( boolean b ) { addArgIf ( b , "-package" ) ; } public void setPrivate ( boolean b ) { addArgIf ( b , "-private" ) ; } public void setAccess ( AccessType at ) { cmd . createArgument ( ) . setValue ( "-" + at . getValue ( ) ) ; } public void setDoclet ( String docletName ) { if ( doclet == null ) { doclet = new DocletInfo ( ) ; doclet . setProject ( getProject ( ) ) ; } doclet . setName ( docletName ) ; } public void setDocletPath ( Path docletPath ) { if ( doclet == null ) { doclet = new DocletInfo ( ) ; doclet . setProject ( getProject ( ) ) ; } doclet . setPath ( docletPath ) ; } public void setDocletPathRef ( Reference r ) { if ( doclet == null ) { doclet = new DocletInfo ( ) ; doclet . setProject ( getProject ( ) ) ; } doclet . createPath ( ) . setRefid ( r ) ; } public DocletInfo createDoclet ( ) { if ( doclet == null ) { doclet = new DocletInfo ( ) ; } return doclet ; } public void addTaglet ( ExtensionInfo tagletInfo ) { tags . addElement ( tagletInfo ) ; } public void setOld ( boolean b ) { old = b ; } public void setClasspath ( Path path ) { if ( classpath == null ) { classpath = path ; } else { classpath . append ( path ) ; } } public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( getProject ( ) ) ; } return classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setBootclasspath ( Path path ) { if ( bootclasspath == null ) { bootclasspath = path ; } else { bootclasspath . append ( path ) ; } } public Path createBootclasspath ( ) { if ( bootclasspath == null ) { bootclasspath = new Path ( getProject ( ) ) ; } return bootclasspath . createPath ( ) ; } public void setBootClasspathRef ( Reference r ) { createBootclasspath ( ) . setRefid ( r ) ; } public void setExtdirs ( String path ) { cmd . createArgument ( ) . setValue ( "-extdirs" ) ; cmd . createArgument ( ) . setValue ( path ) ; } public void setExtdirs ( Path path ) { cmd . createArgument ( ) . setValue ( "-extdirs" ) ; cmd . createArgument ( ) . setPath ( path ) ; } public void setVerbose ( boolean b ) { addArgIf ( b , "-verbose" ) ; } public void setLocale ( String locale ) { cmd . createArgument ( true ) . setValue ( locale ) ; cmd . createArgument ( true ) . setValue ( "-locale" ) ; } public void setEncoding ( String enc ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( enc ) ; } public void setVersion ( boolean b ) { this . version = b ; } public void setUse ( boolean b ) { addArgIf ( b , "-use" ) ; } public void setAuthor ( boolean b ) { author = b ; } public void setSplitindex ( boolean b ) { addArgIf ( b , "-splitindex" ) ; } public void setWindowtitle ( String title ) { addArgIfNotEmpty ( "-windowtitle" , title ) ; } public void setDoctitle ( String doctitle ) { Html h = new Html ( ) ; h . addText ( doctitle ) ; addDoctitle ( h ) ; } public void addDoctitle ( Html text ) { doctitle = text ; } public void setHeader ( String header ) { Html h = new Html ( ) ; h . addText ( header ) ; addHeader ( h ) ; } public void addHeader ( Html text ) { header = text ; } public void setFooter ( String footer ) { Html h = new Html ( ) ; h . addText ( footer ) ; addFooter ( h ) ; } public void addFooter ( Html text ) { footer = text ; } public void setBottom ( String bottom ) { Html h = new Html ( ) ; h . addText ( bottom ) ; addBottom ( h ) ; } public void addBottom ( Html text ) { bottom = text ; } public void setLinkoffline ( String src ) { LinkArgument le = createLink ( ) ; le . setOffline ( true ) ; String linkOfflineError = "The linkoffline attribute must include" + " a URL and a package-list file location separated by a" + " space" ; if ( src . trim ( ) . length ( ) == 0 ) { throw new BuildException ( linkOfflineError ) ; } StringTokenizer tok = new StringTokenizer ( src , " " , false ) ; le . setHref ( tok . nextToken ( ) ) ; if ( ! tok . hasMoreTokens ( ) ) { throw new BuildException ( linkOfflineError ) ; } le . setPackagelistLoc ( getProject ( ) . resolveFile ( tok . nextToken ( ) ) ) ; } public void setGroup ( String src ) { group = src ; } public void setLink ( String src ) { createLink ( ) . setHref ( src ) ; } public void setNodeprecated ( boolean b ) { addArgIf ( b , "-nodeprecated" ) ; } public void setNodeprecatedlist ( boolean b ) { addArgIf ( b , "-nodeprecatedlist" ) ; } public void setNotree ( boolean b ) { addArgIf ( b , "-notree" ) ; } public void setNoindex ( boolean b ) { addArgIf ( b , "-noindex" ) ; } public void setNohelp ( boolean b ) { addArgIf ( b , "-nohelp" ) ; } public void setNonavbar ( boolean b ) { addArgIf ( b , "-nonavbar" ) ; } public void setSerialwarn ( boolean b ) { addArgIf ( b , "-serialwarn" ) ; } public void setStylesheetfile ( File f ) { cmd . createArgument ( ) . setValue ( "-stylesheetfile" ) ; cmd . createArgument ( ) . setFile ( f ) ; } public void setHelpfile ( File f ) { cmd . createArgument ( ) . setValue ( "-helpfile" ) ; cmd . createArgument ( ) . setFile ( f ) ; } public void setDocencoding ( String enc ) { cmd . createArgument ( ) . setValue ( "-docencoding" ) ; cmd . createArgument ( ) . setValue ( enc ) ; } public void setPackageList ( String src ) { packageList = src ; } public LinkArgument createLink ( ) { LinkArgument la = new LinkArgument ( ) ; links . addElement ( la ) ; return la ; } public class LinkArgument { private String href ; private boolean offline = false ; private File packagelistLoc ; private boolean resolveLink = false ; public LinkArgument ( ) { } public void setHref ( String hr ) { href = hr ; } public String getHref ( ) { return href ; } public void setPackagelistLoc ( File src ) { packagelistLoc = src ; } public File getPackagelistLoc ( ) { return packagelistLoc ; } public void setOffline ( boolean offline ) { this . offline = offline ; } public boolean isLinkOffline ( ) { return offline ; } public void setResolveLink ( boolean resolve ) { this . resolveLink = resolve ; } public boolean shouldResolveLink ( ) { return resolveLink ; } } public TagArgument createTag ( ) { TagArgument ta = new TagArgument ( ) ; tags . addElement ( ta ) ; return ta ; } static final String [ ] SCOPE_ELEMENTS = { "overview" , "packages" , "types" , "constructors" , "methods" , "fields" } ; public class TagArgument extends FileSet { private String name = null ; private boolean enabled = true ; private String scope = "a" ; public TagArgument ( ) { } public void setName ( String name ) { this . name = name ; } public void setScope ( String verboseScope ) throws BuildException { verboseScope = verboseScope . toLowerCase ( Locale . US ) ; boolean [ ] elements = new boolean [ SCOPE_ELEMENTS . length ] ; boolean gotAll = false ; boolean gotNotAll = false ; StringTokenizer tok = new StringTokenizer ( verboseScope , "," ) ; while ( tok . hasMoreTokens ( ) ) { String next = tok . nextToken ( ) . trim ( ) ; if ( next . equals ( "all" ) ) { if ( gotAll ) { getProject ( ) . log ( "Repeated tag scope element: all" , Project . MSG_VERBOSE ) ; } gotAll = true ; } else { int i ; for ( i = 0 ; i < SCOPE_ELEMENTS . length ; i ++ ) { if ( next . equals ( SCOPE_ELEMENTS [ i ] ) ) { break ; } } if ( i == SCOPE_ELEMENTS . length ) { throw new BuildException ( "Unrecognised scope element: " + next ) ; } else { if ( elements [ i ] ) { getProject ( ) . log ( "Repeated tag scope element: " + next , Project . MSG_VERBOSE ) ; } elements [ i ] = true ; gotNotAll = true ; } } } if ( gotNotAll && gotAll ) { throw new BuildException ( "Mixture of \"all\" and other scope " + "elements in tag parameter." ) ; } if ( ! gotNotAll && ! gotAll ) { throw new BuildException ( "No scope elements specified in tag " + "parameter." ) ; } if ( gotAll ) { this . scope = "a" ; } else { StringBuffer buff = new StringBuffer ( elements . length ) ; for ( int i = 0 ; i < elements . length ; i ++ ) { if ( elements [ i ] ) { buff . append ( SCOPE_ELEMENTS [ i ] . charAt ( 0 ) ) ; } } this . scope = buff . toString ( ) ; } } public void setEnabled ( boolean enabled ) { this . enabled = enabled ; } public String getParameter ( ) throws BuildException { if ( name == null || name . equals ( "" ) ) { throw new BuildException ( "No name specified for custom tag." ) ; } if ( getDescription ( ) != null ) { return name + ":" + ( enabled ? "" : "X" ) + scope + ":" + getDescription ( ) ; } else { return name + ":" + ( enabled ? "" : "X" ) + scope + ":" + name ; } } } public GroupArgument createGroup ( ) { GroupArgument ga = new GroupArgument ( ) ; groups . addElement ( ga ) ; return ga ; } public class GroupArgument { private Html title ; private Vector packages = new Vector ( ) ; public GroupArgument ( ) { } public void setTitle ( String src ) { Html h = new Html ( ) ; h . addText ( src ) ; addTitle ( h ) ; } public void addTitle ( Html text ) { title = text ; } public String getTitle ( ) { return title != null ? title . getText ( ) : null ; } public void setPackages ( String src ) { StringTokenizer tok = new StringTokenizer ( src , "," ) ; while ( tok . hasMoreTokens ( ) ) { String p = tok . nextToken ( ) ; PackageName pn = new PackageName ( ) ; pn . setName ( p ) ; addPackage ( pn ) ; } } public void addPackage ( PackageName pn ) { packages . addElement ( pn ) ; } public String getPackages ( ) { StringBuffer p = new StringBuffer ( ) ; for ( int i = 0 ; i < packages . size ( ) ; i ++ ) { if ( i > 0 ) { p . append ( ":" ) ; } p . append ( packages . elementAt ( i ) . toString ( ) ) ; } return p . toString ( ) ; } } public void setCharset ( String src ) { this . addArgIfNotEmpty ( "-charset" , src ) ; } public void setFailonerror ( boolean b ) { failOnError = b ; } public void setSource ( String source ) { this . source = source ; } public void setExecutable ( String executable ) { this . executable = executable ; } public void addPackageset ( DirSet packageSet ) { packageSets . addElement ( packageSet ) ; } public void addFileset ( FileSet fs ) { createSourceFiles ( ) . add ( fs ) ; } public ResourceCollectionContainer createSourceFiles ( ) { return nestedSourceFiles ; } public void setLinksource ( boolean b ) { this . linksource = b ; } public void setBreakiterator ( boolean b ) { this . breakiterator = b ; } public void setNoqualifier ( String noqualifier ) { this . noqualifier = noqualifier ; } public void setIncludeNoSourcePackages ( boolean b ) { this . includeNoSourcePackages = b ; } public void execute ( ) throws BuildException { if ( "javadoc2" . equals ( getTaskType ( ) ) ) { log ( "Warning: the task name <javadoc2> is deprecated. Use <javadoc> instead." , Project . MSG_WARN ) ; } boolean javadoc4 = ! JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_2 ) && ! JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_3 ) ; boolean javadoc5 = javadoc4 && ! JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_4 ) ; Vector packagesToDoc = new Vector ( ) ; Path sourceDirs = new Path ( getProject ( ) ) ; if ( packageList != null && sourcePath == null ) { String msg = "sourcePath attribute must be set when " + "specifying packagelist." ; throw new BuildException ( msg ) ; } if ( sourcePath != null ) { sourceDirs . addExisting ( sourcePath ) ; } parsePackages ( packagesToDoc , sourceDirs ) ; if ( packagesToDoc . size ( ) != 0 && sourceDirs . size ( ) == 0 ) { String msg = "sourcePath attribute must be set when " + "specifying package names." ; throw new BuildException ( msg ) ; } Vector sourceFilesToDoc = ( Vector ) sourceFiles . clone ( ) ; addSourceFiles ( sourceFilesToDoc ) ; if ( packageList == null && packagesToDoc . size ( ) == 0 && sourceFilesToDoc . size ( ) == 0 ) { throw new BuildException ( "No source files and no packages have " + "been specified." ) ; } log ( "Generating Javadoc" , Project . MSG_INFO ) ; Commandline toExecute = ( Commandline ) cmd . clone ( ) ; if ( executable != null ) { toExecute . setExecutable ( executable ) ; } else { toExecute . setExecutable ( JavaEnvUtils . getJdkExecutable ( "javadoc" ) ) ; } if ( doctitle != null ) { toExecute . createArgument ( ) . setValue ( "-doctitle" ) ; toExecute . createArgument ( ) . setValue ( expand ( doctitle . getText ( ) ) ) ; } if ( header != null ) { toExecute . createArgument ( ) . setValue ( "-header" ) ; toExecute . createArgument ( ) . setValue ( expand ( header . getText ( ) ) ) ; } if ( footer != null ) { toExecute . createArgument ( ) . setValue ( "-footer" ) ; toExecute . createArgument ( ) . setValue ( expand ( footer . getText ( ) ) ) ; } if ( bottom != null ) { toExecute . createArgument ( ) . setValue ( "-bottom" ) ; toExecute . createArgument ( ) . setValue ( expand ( bottom . getText ( ) ) ) ; } if ( classpath == null ) { classpath = ( new Path ( getProject ( ) ) ) . concatSystemClasspath ( "last" ) ; } else { classpath = classpath . concatSystemClasspath ( "ignore" ) ; } if ( classpath . size ( ) > 0 ) { toExecute . createArgument ( ) . setValue ( "-classpath" ) ; toExecute . createArgument ( ) . setPath ( classpath ) ; } if ( sourceDirs . size ( ) > 0 ) { toExecute . createArgument ( ) . setValue ( "-sourcepath" ) ; toExecute . createArgument ( ) . setPath ( sourceDirs ) ; } if ( version && doclet == null ) { toExecute . createArgument ( ) . setValue ( "-version" ) ; } if ( author && doclet == null ) { toExecute . createArgument ( ) . setValue ( "-author" ) ; } if ( doclet == null && destDir == null ) { throw new BuildException ( "destdir attribute must be set!" ) ; } if ( doclet != null ) { if ( doclet . getName ( ) == null ) { throw new BuildException ( "The doclet name must be " + "specified." , getLocation ( ) ) ; } else { toExecute . createArgument ( ) . setValue ( "-doclet" ) ; toExecute . createArgument ( ) . setValue ( doclet . getName ( ) ) ; if ( doclet . getPath ( ) != null ) { Path docletPath = doclet . getPath ( ) . concatSystemClasspath ( "ignore" ) ; if ( docletPath . size ( ) != 0 ) { toExecute . createArgument ( ) . setValue ( "-docletpath" ) ; toExecute . createArgument ( ) . setPath ( docletPath ) ; } } for ( Enumeration e = doclet . getParams ( ) ; e . hasMoreElements ( ) ; ) { DocletParam param = ( DocletParam ) e . nextElement ( ) ; if ( param . getName ( ) == null ) { throw new BuildException ( "Doclet parameters must " + "have a name" ) ; } toExecute . createArgument ( ) . setValue ( param . getName ( ) ) ; if ( param . getValue ( ) != null ) { toExecute . createArgument ( ) . setValue ( param . getValue ( ) ) ; } } } } Path bcp = new Path ( getProject ( ) ) ; if ( bootclasspath != null ) { bcp . append ( bootclasspath ) ; } bcp = bcp . concatSystemBootClasspath ( "ignore" ) ; if ( bcp . size ( ) > 0 ) { toExecute . createArgument ( ) . setValue ( "-bootclasspath" ) ; toExecute . createArgument ( ) . setPath ( bcp ) ; } if ( links . size ( ) != 0 ) { for ( Enumeration e = links . elements ( ) ; e . hasMoreElements ( ) ; ) { LinkArgument la = ( LinkArgument ) e . nextElement ( ) ; if ( la . getHref ( ) == null || la . getHref ( ) . length ( ) == 0 ) { log ( "No href was given for the link - skipping" , Project . MSG_VERBOSE ) ; continue ; } String link = null ; if ( la . shouldResolveLink ( ) ) { File hrefAsFile = getProject ( ) . resolveFile ( la . getHref ( ) ) ; if ( hrefAsFile . exists ( ) ) { try { link = FILE_UTILS . getFileURL ( hrefAsFile ) . toExternalForm ( ) ; } catch ( MalformedURLException ex ) { log ( "Warning: link location was invalid " + hrefAsFile , Project . MSG_WARN ) ; } } } if ( link == null ) { try { URL base = new URL ( "file://." ) ; new URL ( base , la . getHref ( ) ) ; link = la . getHref ( ) ; } catch ( MalformedURLException mue ) { log ( "Link href \"" + la . getHref ( ) + "\" is not a valid url - skipping link" , Project . MSG_WARN ) ; continue ; } } if ( la . isLinkOffline ( ) ) { File packageListLocation = la . getPackagelistLoc ( ) ; if ( packageListLocation == null ) { throw new BuildException ( "The package list" + " location for link " + la . getHref ( ) + " must be provided " + "because the link is " + "offline" ) ; } File packageListFile = new File ( packageListLocation , "package-list" ) ; if ( packageListFile . exists ( ) ) { try { String packageListURL = FILE_UTILS . getFileURL ( packageListLocation ) . toExternalForm ( ) ; toExecute . createArgument ( ) . setValue ( "-linkoffline" ) ; toExecute . createArgument ( ) . setValue ( link ) ; toExecute . createArgument ( ) . setValue ( packageListURL ) ; } catch ( MalformedURLException ex ) { log ( "Warning: Package list location was " + "invalid " + packageListLocation , Project . MSG_WARN ) ; } } else { log ( "Warning: No package list was found at " + packageListLocation , Project . MSG_VERBOSE ) ; } } else { toExecute . createArgument ( ) . setValue ( "-link" ) ; toExecute . createArgument ( ) . setValue ( link ) ; } } } if ( group != null ) { StringTokenizer tok = new StringTokenizer ( group , "," , false ) ; while ( tok . hasMoreTokens ( ) ) { String grp = tok . nextToken ( ) . trim ( ) ; int space = grp . indexOf ( " " ) ; if ( space > 0 ) { String name = grp . substring ( 0 , space ) ; String pkgList = grp . substring ( space + 1 ) ; toExecute . createArgument ( ) . setValue ( "-group" ) ; toExecute . createArgument ( ) . setValue ( name ) ; toExecute . createArgument ( ) . setValue ( pkgList ) ; } } } if ( groups . size ( ) != 0 ) { for ( Enumeration e = groups . elements ( ) ; e . hasMoreElements ( ) ; ) { GroupArgument ga = ( GroupArgument ) e . nextElement ( ) ; String title = ga . getTitle ( ) ; String packages = ga . getPackages ( ) ; if ( title == null || packages == null ) { throw new BuildException ( "The title and packages must " + "be specified for group " + "elements." ) ; } toExecute . createArgument ( ) . setValue ( "-group" ) ; toExecute . createArgument ( ) . setValue ( expand ( title ) ) ; toExecute . createArgument ( ) . setValue ( packages ) ; } } if ( javadoc4 || executable != null ) { for ( Enumeration e = tags . elements ( ) ; e . hasMoreElements ( ) ; ) { Object element = e . nextElement ( ) ; if ( element instanceof TagArgument ) { TagArgument ta = ( TagArgument ) element ; File tagDir = ta . getDir ( getProject ( ) ) ; if ( tagDir == null ) { toExecute . createArgument ( ) . setValue ( "-tag" ) ; toExecute . createArgument ( ) . setValue ( ta . getParameter ( ) ) ; } else { DirectoryScanner tagDefScanner = ta . getDirectoryScanner ( getProject ( ) ) ; String [ ] files = tagDefScanner . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File tagDefFile = new File ( tagDir , files [ i ] ) ; try { BufferedReader in = new BufferedReader ( new FileReader ( tagDefFile ) ) ; String line = null ; while ( ( line = in . readLine ( ) ) != null ) { toExecute . createArgument ( ) . setValue ( "-tag" ) ; toExecute . createArgument ( ) . setValue ( line ) ; } in . close ( ) ; } catch ( IOException ioe ) { throw new BuildException ( "Couldn't read " + " tag file from " + tagDefFile . getAbsolutePath ( ) , ioe ) ; } } } } else { ExtensionInfo tagletInfo = ( ExtensionInfo ) element ; toExecute . createArgument ( ) . setValue ( "-taglet" ) ; toExecute . createArgument ( ) . setValue ( tagletInfo . getName ( ) ) ; if ( tagletInfo . getPath ( ) != null ) { Path tagletPath = tagletInfo . getPath ( ) . concatSystemClasspath ( "ignore" ) ; if ( tagletPath . size ( ) != 0 ) { toExecute . createArgument ( ) . setValue ( "-tagletpath" ) ; toExecute . createArgument ( ) . setPath ( tagletPath ) ; } } } } String sourceArg = source != null ? source : getProject ( ) . getProperty ( MagicNames . BUILD_JAVAC_SOURCE ) ; if ( sourceArg != null ) { toExecute . createArgument ( ) . setValue ( "-source" ) ; toExecute . createArgument ( ) . setValue ( sourceArg ) ; } if ( linksource && doclet == null ) { toExecute . createArgument ( ) . setValue ( "-linksource" ) ; } if ( breakiterator && ( doclet == null || javadoc5 ) ) { toExecute . createArgument ( ) . setValue ( "-breakiterator" ) ; } if ( noqualifier != null && doclet == null ) { toExecute . createArgument ( ) . setValue ( "-noqualifier" ) ; toExecute . createArgument ( ) . setValue ( noqualifier ) ; } } else { if ( ! tags . isEmpty ( ) ) { log ( "-tag and -taglet options not supported on Javadoc < 1.4" , Project . MSG_VERBOSE ) ; } if ( source != null ) { log ( "-source option not supported on Javadoc < 1.4" , Project . MSG_VERBOSE ) ; } if ( linksource ) { log ( "-linksource option not supported on Javadoc < 1.4" , Project . MSG_VERBOSE ) ; } if ( breakiterator ) { log ( "-breakiterator option not supported on Javadoc < 1.4" , Project . MSG_VERBOSE ) ; } if ( noqualifier != null ) { log ( "-noqualifier option not supported on Javadoc < 1.4" , Project . MSG_VERBOSE ) ; } } if ( ! javadoc4 || executable != null ) { if ( old ) { toExecute . createArgument ( ) . setValue ( "-1.1" ) ; } } else { if ( old ) { log ( "Javadoc 1.4 doesn't support the -1.1 switch anymore" , Project . MSG_WARN ) ; } } if ( useExternalFile && javadoc4 ) { writeExternalArgs ( toExecute ) ; } File tmpList = null ; PrintWriter srcListWriter = null ; try { if ( useExternalFile ) { if ( tmpList == null ) { tmpList = FILE_UTILS . createTempFile ( "javadoc" , "" , null ) ; tmpList . deleteOnExit ( ) ; toExecute . createArgument ( ) . setValue ( "@" + tmpList . getAbsolutePath ( ) ) ; } srcListWriter = new PrintWriter ( new FileWriter ( tmpList . getAbsolutePath ( ) , true ) ) ; } Enumeration e = packagesToDoc . elements ( ) ; while ( e . hasMoreElements ( ) ) { String packageName = ( String ) e . nextElement ( ) ; if ( useExternalFile ) { srcListWriter . println ( packageName ) ; } else { toExecute . createArgument ( ) . setValue ( packageName ) ; } } e = sourceFilesToDoc . elements ( ) ; while ( e . hasMoreElements ( ) ) { SourceFile sf = ( SourceFile ) e . nextElement ( ) ; String sourceFileName = sf . getFile ( ) . getAbsolutePath ( ) ; if ( useExternalFile ) { if ( javadoc4 && sourceFileName . indexOf ( " " ) > - 1 ) { String name = sourceFileName ; if ( File . separatorChar == '\\' ) { name = sourceFileName . replace ( File . separatorChar , '/' ) ; } srcListWriter . println ( "\"" + name + "\"" ) ; } else { srcListWriter . println ( sourceFileName ) ; } } else { toExecute . createArgument ( ) . setValue ( sourceFileName ) ; } } } catch ( IOException e ) { tmpList . delete ( ) ; throw new BuildException ( "Error creating temporary file" , e , getLocation ( ) ) ; } finally { if ( srcListWriter != null ) { srcListWriter . close ( ) ; } } if ( packageList != null ) { toExecute . createArgument ( ) . setValue ( "@" + packageList ) ; } log ( toExecute . describeCommand ( ) , Project . MSG_VERBOSE ) ; log ( "Javadoc execution" , Project . MSG_INFO ) ; JavadocOutputStream out = new JavadocOutputStream ( Project . MSG_INFO ) ; JavadocOutputStream err = new JavadocOutputStream ( Project . MSG_WARN ) ; Execute exe = new Execute ( new PumpStreamHandler ( out , err ) ) ; exe . setAntRun ( getProject ( ) ) ; exe . setWorkingDirectory ( null ) ; try { exe . setCommandline ( toExecute . getCommandline ( ) ) ; int ret = exe . execute ( ) ; if ( ret != 0 && failOnError ) { throw new BuildException ( "Javadoc returned " + ret , getLocation ( ) ) ; } } catch ( IOException e ) { throw new BuildException ( "Javadoc failed: " + e , e , getLocation ( ) ) ; } finally { if ( tmpList != null ) { tmpList . delete ( ) ; tmpList = null ; } out . logFlush ( ) ; err . logFlush ( ) ; try { out . close ( ) ; err . close ( ) ; } catch ( IOException e ) { } } } private void writeExternalArgs ( Commandline toExecute ) { File optionsTmpFile = null ; PrintWriter optionsListWriter = null ; try { optionsTmpFile = FILE_UTILS . createTempFile ( "javadocOptions" , "" , null ) ; optionsTmpFile . deleteOnExit ( ) ; String [ ] listOpt = toExecute . getArguments ( ) ; toExecute . clearArgs ( ) ; toExecute . createArgument ( ) . setValue ( "@" + optionsTmpFile . getAbsolutePath ( ) ) ; optionsListWriter = new PrintWriter ( new FileWriter ( optionsTmpFile . getAbsolutePath ( ) , true ) ) ; for ( int i = 0 ; i < listOpt . length ; i ++ ) { String string = listOpt [ i ] ; if ( string . startsWith ( "-J-" ) ) { toExecute . createArgument ( ) . setValue ( string ) ; } else { if ( string . startsWith ( "-" ) ) { optionsListWriter . print ( string ) ; optionsListWriter . print ( " " ) ; } else { optionsListWriter . println ( quoteString ( string ) ) ; } } } optionsListWriter . close ( ) ; } catch ( IOException ex ) { if ( optionsTmpFile != null ) { optionsTmpFile . delete ( ) ; } throw new BuildException ( "Error creating or writing temporary file for javadoc options" , ex , getLocation ( ) ) ; } finally { FILE_UTILS . close ( optionsListWriter ) ; } } private String quoteString ( String str ) { if ( str . indexOf ( ' ' ) == - 1 && str . indexOf ( '\'' ) == - 1 && str . indexOf ( '"' ) == - 1 ) { return str ; } if ( str . indexOf ( '\'' ) == - 1 ) { return quoteString ( str , '\'' ) ; } else { return quoteString ( str , '"' ) ; } } private String quoteString ( String str , char delim ) { StringBuffer buf = new StringBuffer ( str . length ( ) * 2 ) ; buf . append ( delim ) ; if ( str . indexOf ( '\\' ) != - 1 ) { str = replace ( str , '\\' , "\\\\" ) ; } if ( str . indexOf ( delim ) != - 1 ) { str = replace ( str , delim , "\\" + delim ) ; } buf . append ( str ) ; buf . append ( delim ) ; return buf . toString ( ) ; } private String replace ( String str , char fromChar , String toString ) { StringBuffer buf = new StringBuffer ( str . length ( ) * 2 ) ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { char ch = str . charAt ( i ) ; if ( ch == fromChar ) { buf . append ( toString ) ; } else { buf . append ( ch ) ; } } return buf . toString ( ) ; } private void addSourceFiles ( Vector sf ) { Iterator e = nestedSourceFiles . iterator ( ) ; while ( e . hasNext ( ) ) { ResourceCollection rc = ( ResourceCollection ) e . next ( ) ; if ( ! rc . isFilesystemOnly ( ) ) { throw new BuildException ( "only file system based resources are" + " supported by javadoc" ) ; } if ( rc instanceof FileSet ) { FileSet fs = ( FileSet ) rc ; if ( ! fs . hasPatterns ( ) && ! fs . hasSelectors ( ) ) { fs = ( FileSet ) fs . clone ( ) ; fs . createInclude ( ) . setName ( "**/*.java" ) ; if ( includeNoSourcePackages ) { fs . createInclude ( ) . setName ( "**/package.html" ) ; } } } Iterator iter = rc . iterator ( ) ; while ( iter . hasNext ( ) ) { sf . addElement ( new SourceFile ( ( ( FileResource ) iter . next ( ) ) . getFile ( ) ) ) ; } } } private void parsePackages ( Vector pn , Path sp ) { Vector addedPackages = new Vector ( ) ; Vector dirSets = ( Vector ) packageSets . clone ( ) ; if ( sourcePath != null ) { PatternSet ps = new PatternSet ( ) ; if ( packageNames . size ( ) > 0 ) { Enumeration e = packageNames . elements ( ) ; while ( e . hasMoreElements ( ) ) { PackageName p = ( PackageName ) e . nextElement ( ) ; String pkg = p . getName ( ) . replace ( '.' , '/' ) ; if ( pkg . endsWith ( "*" ) ) { pkg += "*" ; } ps . createInclude ( ) . setName ( pkg ) ; } } else { ps . createInclude ( ) . setName ( "**" ) ; } Enumeration e = excludePackageNames . elements ( ) ; while ( e . hasMoreElements ( ) ) { PackageName p = ( PackageName ) e . nextElement ( ) ; String pkg = p . getName ( ) . replace ( '.' , '/' ) ; if ( pkg . endsWith ( "*" ) ) { pkg += "*" ; } ps . createExclude ( ) . setName ( pkg ) ; } String [ ] pathElements = sourcePath . list ( ) ; for ( int i = 0 ; i < pathElements . length ; i ++ ) { File dir = new File ( pathElements [ i ] ) ; if ( dir . isDirectory ( ) ) { DirSet ds = new DirSet ( ) ; ds . setDefaultexcludes ( useDefaultExcludes ) ; ds . setDir ( dir ) ; ds . createPatternSet ( ) . addConfiguredPatternset ( ps ) ; dirSets . addElement ( ds ) ; } else { log ( "Skipping " + pathElements [ i ] + " since it is no directory." , Project . MSG_WARN ) ; } } } Enumeration e = dirSets . elements ( ) ; while ( e . hasMoreElements ( ) ) { DirSet ds = ( DirSet ) e . nextElement ( ) ; File baseDir = ds . getDir ( getProject ( ) ) ; log ( "scanning " + baseDir + " for packages." , Project . MSG_DEBUG ) ; DirectoryScanner dsc = ds . getDirectoryScanner ( getProject ( ) ) ; String [ ] dirs = dsc . getIncludedDirectories ( ) ; boolean containsPackages = false ; for ( int i = 0 ; i < dirs . length ; i ++ ) { File pd = new File ( baseDir , dirs [ i ] ) ; String [ ] files = pd . list ( new FilenameFilter ( ) { public boolean accept ( File dir1 , String name ) { return name . endsWith ( ".java" ) || ( includeNoSourcePackages && name . equals ( "package.html" ) ) ; } } ) ; if ( files . length > 0 ) { if ( "" . equals ( dirs [ i ] ) ) { log ( baseDir + " contains source files in the default package," + " you must specify them as source files" + " not packages." , Project . MSG_WARN ) ; } else { containsPackages = true ; String packageName = dirs [ i ] . replace ( File . separatorChar , '.' ) ; if ( ! addedPackages . contains ( packageName ) ) { addedPackages . addElement ( packageName ) ; pn . addElement ( packageName ) ; } } } } if ( containsPackages ) { sp . createPathElement ( ) . setLocation ( baseDir ) ; } else { log ( baseDir + " doesn\'t contain any packages, dropping it." , Project . MSG_VERBOSE ) ; } } } private class JavadocOutputStream extends LogOutputStream { JavadocOutputStream ( int level ) { super ( Javadoc . this , level ) ; } private String queuedLine = null ; protected void processLine ( String line , int messageLevel ) { if ( messageLevel == Project . MSG_INFO && line . startsWith ( "Generating " ) ) { if ( queuedLine != null ) { super . processLine ( queuedLine , Project . MSG_VERBOSE ) ; } queuedLine = line ; } else { if ( queuedLine != null ) { if ( line . startsWith ( "Building " ) ) { super . processLine ( queuedLine , Project . MSG_VERBOSE ) ; } else { super . processLine ( queuedLine , Project . MSG_INFO ) ; } queuedLine = null ; } super . processLine ( line , messageLevel ) ; } } protected void logFlush ( ) { if ( queuedLine != null ) { super . processLine ( queuedLine , Project . MSG_VERBOSE ) ; queuedLine = null ; } } } protected String expand ( String content ) { return getProject ( ) . replaceProperties ( content ) ; } } 	1	['92', '3', '0', '34', '261', '3726', '8', '34', '81', '0.960245637', '2704', '0.970588235', '11', '0.291338583', '0.11247576', '2', '2', '28.02173913', '15', '1.5543', '4']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class Gcj extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { Commandline cmd ; attributes . log ( "Using gcj compiler" , Project . MSG_VERBOSE ) ; cmd = setupGCJCommand ( ) ; int firstFileName = cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } protected Commandline setupGCJCommand ( ) { Commandline cmd = new Commandline ( ) ; Path classpath = new Path ( project ) ; Path p = getBootClassPath ( ) ; if ( p . size ( ) > 0 ) { classpath . append ( p ) ; } classpath . addExtdirs ( extdirs ) ; classpath . append ( getCompileClasspath ( ) ) ; if ( compileSourcepath != null ) { classpath . append ( compileSourcepath ) ; } else { classpath . append ( src ) ; } String exec = getJavac ( ) . getExecutable ( ) ; cmd . setExecutable ( exec == null ? "gcj" : exec ) ; if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; if ( ! destDir . exists ( ) && ! destDir . mkdirs ( ) ) { throw new BuildException ( "Can't make output directories. " + "Maybe permission is wrong. " ) ; } } cmd . createArgument ( ) . setValue ( "-classpath" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; if ( encoding != null ) { cmd . createArgument ( ) . setValue ( "--encoding=" + encoding ) ; } if ( debug ) { cmd . createArgument ( ) . setValue ( "-g1" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O" ) ; } if ( ! isNativeBuild ( ) ) { cmd . createArgument ( ) . setValue ( "-C" ) ; } addCurrentCompilerArgs ( cmd ) ; return cmd ; } public boolean isNativeBuild ( ) { boolean nativeBuild = false ; String [ ] additionalArguments = getJavac ( ) . getCurrentCompilerArgs ( ) ; int argsLength = 0 ; while ( ! nativeBuild && argsLength < additionalArguments . length ) { int conflictLength = 0 ; while ( ! nativeBuild && conflictLength < CONFLICT_WITH_DASH_C . length ) { nativeBuild = ( additionalArguments [ argsLength ] . startsWith ( CONFLICT_WITH_DASH_C [ conflictLength ] ) ) ; conflictLength ++ ; } argsLength ++ ; } return nativeBuild ; } private static final String [ ] CONFLICT_WITH_DASH_C = { "-o" , "--main=" , "-D" , "-fjni" , "-L" } ; } 	1	['5', '2', '0', '8', '34', '8', '1', '7', '3', '0.5', '216', '1', '0', '0.884615385', '1', '0', '0', '42', '11', '3.4', '1']
