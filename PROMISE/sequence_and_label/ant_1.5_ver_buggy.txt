package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . ZipFileSet ; import org . apache . tools . zip . ZipOutputStream ; import java . io . File ; import java . io . IOException ; public class War extends Jar { private File deploymentDescriptor ; private boolean descriptorAdded ; public War ( ) { super ( ) ; archiveType = "war" ; emptyBehavior = "create" ; } public void setWarfile ( File warFile ) { setDestFile ( warFile ) ; } public void setWebxml ( File descr ) { deploymentDescriptor = descr ; if ( ! deploymentDescriptor . exists ( ) ) { throw new BuildException ( "Deployment descriptor: " + deploymentDescriptor + " does not exist." ) ; } ZipFileSet fs = new ZipFileSet ( ) ; fs . setDir ( new File ( deploymentDescriptor . getParent ( ) ) ) ; fs . setIncludes ( deploymentDescriptor . getName ( ) ) ; fs . setFullpath ( "WEB-INF/web.xml" ) ; super . addFileset ( fs ) ; } public void addLib ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/lib/" ) ; super . addFileset ( fs ) ; } public void addClasses ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/classes/" ) ; super . addFileset ( fs ) ; } public void addWebinf ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/" ) ; super . addFileset ( fs ) ; } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( deploymentDescriptor == null && ! isInUpdateMode ( ) ) { throw new BuildException ( "webxml attribute is required" , location ) ; } super . initZipOutputStream ( zOut ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath ) throws IOException { if ( vPath . equalsIgnoreCase ( "WEB-INF/web.xml" ) ) { if ( deploymentDescriptor == null || ! deploymentDescriptor . equals ( file ) || descriptorAdded ) { log ( "Warning: selected " + archiveType + " files include a WEB-INF/web.xml which will be ignored " + "(please use webxml attribute to " + archiveType + " task)" , Project . MSG_WARN ) ; } else { super . zipFile ( file , zOut , vPath ) ; descriptorAdded = true ; } } else { super . zipFile ( file , zOut , vPath ) ; } } protected void cleanUp ( ) { descriptorAdded = false ; super . cleanUp ( ) ; } } 	1	['9', '6', '0', '9', '34', '28', '0', '9', '6', '0.8125', '166', '1', '0', '0.950617284', '0.4', '4', '9', '17.22222222', '2', '1', '1']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import java . net . MalformedURLException ; import java . net . HttpURLConnection ; import java . net . URLConnection ; import java . net . URL ; public class Http extends ProjectComponent implements Condition { private String spec = null ; public void setUrl ( String url ) { spec = url ; } private int errorsBeginAt = 400 ; public void SetErrorsBeginAt ( int errorsBeginAt ) { this . errorsBeginAt = errorsBeginAt ; } public boolean eval ( ) throws BuildException { if ( spec == null ) { throw new BuildException ( "No url specified in http condition" ) ; } log ( "Checking for " + spec , Project . MSG_VERBOSE ) ; try { URL url = new URL ( spec ) ; try { URLConnection conn = url . openConnection ( ) ; if ( conn instanceof HttpURLConnection ) { HttpURLConnection http = ( HttpURLConnection ) conn ; int code = http . getResponseCode ( ) ; log ( "Result code for " + spec + " was " + code , Project . MSG_VERBOSE ) ; if ( code > 0 && code < errorsBeginAt ) { return true ; } else { return false ; } } } catch ( java . io . IOException e ) { return false ; } } catch ( MalformedURLException e ) { throw new BuildException ( "Badly formed URL: " + spec , e ) ; } return true ; } } 	1	['4', '2', '0', '4', '15', '0', '1', '3', '4', '0.333333333', '109', '1', '0', '0.75', '0.5', '0', '0', '25.75', '1', '0.75', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . util . FileUtils ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . io . Reader ; import java . io . Writer ; import java . util . Enumeration ; import java . util . NoSuchElementException ; public class FixCRLF extends MatchingTask { private static final int UNDEF = - 1 ; private static final int NOTJAVA = 0 ; private static final int LOOKING = 1 ; private static final int IN_CHAR_CONST = 2 ; private static final int IN_STR_CONST = 3 ; private static final int IN_SINGLE_COMMENT = 4 ; private static final int IN_MULTI_COMMENT = 5 ; private static final int ASIS = 0 ; private static final int CR = 1 ; private static final int LF = 2 ; private static final int CRLF = 3 ; private static final int ADD = 1 ; private static final int REMOVE = - 1 ; private static final int SPACES = - 1 ; private static final int TABS = 1 ; private static final int INBUFLEN = 8192 ; private static final int LINEBUFLEN = 200 ; private static final char CTRLZ = '' ; private int tablength = 8 ; private String spaces = "        " ; private StringBuffer linebuf = new StringBuffer ( 1024 ) ; private StringBuffer linebuf2 = new StringBuffer ( 1024 ) ; private int eol ; private String eolstr ; private int ctrlz ; private int tabs ; private boolean javafiles = false ; private File srcDir ; private File destDir = null ; private FileUtils fileUtils = FileUtils . newFileUtils ( ) ; private String encoding = null ; public FixCRLF ( ) { tabs = ASIS ; if ( Os . isFamily ( "mac" ) ) { ctrlz = REMOVE ; eol = CR ; eolstr = "\r" ; } else if ( Os . isFamily ( "dos" ) ) { ctrlz = ASIS ; eol = CRLF ; eolstr = "\r\n" ; } else { ctrlz = REMOVE ; eol = LF ; eolstr = "\n" ; } } public void setSrcdir ( File srcDir ) { this . srcDir = srcDir ; } public void setDestdir ( File destDir ) { this . destDir = destDir ; } public void setJavafiles ( boolean javafiles ) { this . javafiles = javafiles ; } public void setEol ( CrLf attr ) { String option = attr . getValue ( ) ; if ( option . equals ( "asis" ) ) { eol = ASIS ; } else if ( option . equals ( "cr" ) ) { eol = CR ; eolstr = "\r" ; } else if ( option . equals ( "lf" ) ) { eol = LF ; eolstr = "\n" ; } else { eol = CRLF ; eolstr = "\r\n" ; } } public void setCr ( AddAsisRemove attr ) { log ( "DEPRECATED: The cr attribute has been deprecated," , Project . MSG_WARN ) ; log ( "Please use the eol attribute instead" , Project . MSG_WARN ) ; String option = attr . getValue ( ) ; CrLf c = new CrLf ( ) ; if ( option . equals ( "remove" ) ) { c . setValue ( "lf" ) ; } else if ( option . equals ( "asis" ) ) { c . setValue ( "asis" ) ; } else { c . setValue ( "crlf" ) ; } setEol ( c ) ; } public void setTab ( AddAsisRemove attr ) { String option = attr . getValue ( ) ; if ( option . equals ( "remove" ) ) { tabs = SPACES ; } else if ( option . equals ( "asis" ) ) { tabs = ASIS ; } else { tabs = TABS ; } } public void setTablength ( int tlength ) throws BuildException { if ( tlength < 2 || tlength > 80 ) { throw new BuildException ( "tablength must be between 2 and 80" , location ) ; } tablength = tlength ; StringBuffer sp = new StringBuffer ( ) ; for ( int i = 0 ; i < tablength ; i ++ ) { sp . append ( ' ' ) ; } spaces = sp . toString ( ) ; } public void setEof ( AddAsisRemove attr ) { String option = attr . getValue ( ) ; if ( option . equals ( "remove" ) ) { ctrlz = REMOVE ; } else if ( option . equals ( "asis" ) ) { ctrlz = ASIS ; } else { ctrlz = ADD ; } } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public void execute ( ) throws BuildException { if ( srcDir == null ) { throw new BuildException ( "srcdir attribute must be set!" ) ; } if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir does not exist!" ) ; } if ( ! srcDir . isDirectory ( ) ) { throw new BuildException ( "srcdir is not a directory!" ) ; } if ( destDir != null ) { if ( ! destDir . exists ( ) ) { throw new BuildException ( "destdir does not exist!" ) ; } if ( ! destDir . isDirectory ( ) ) { throw new BuildException ( "destdir is not a directory!" ) ; } } log ( "options:" + " eol=" + ( eol == ASIS ? "asis" : eol == CR ? "cr" : eol == LF ? "lf" : "crlf" ) + " tab=" + ( tabs == TABS ? "add" : tabs == ASIS ? "asis" : "remove" ) + " eof=" + ( ctrlz == ADD ? "add" : ctrlz == ASIS ? "asis" : "remove" ) + " tablength=" + tablength + " encoding=" + ( encoding == null ? "default" : encoding ) , Project . MSG_VERBOSE ) ; DirectoryScanner ds = super . getDirectoryScanner ( srcDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { processFile ( files [ i ] ) ; } } private Reader getReader ( File f ) throws IOException { return ( encoding == null ) ? new FileReader ( f ) : new InputStreamReader ( new FileInputStream ( f ) , encoding ) ; } private void processFile ( String file ) throws BuildException { File srcFile = new File ( srcDir , file ) ; File destD = destDir == null ? srcDir : destDir ; File tmpFile = null ; BufferedWriter outWriter ; OneLiner . BufferLine line ; OneLiner lines = new OneLiner ( srcFile ) ; try { try { tmpFile = fileUtils . createTempFile ( "fixcrlf" , "" , destD ) ; Writer writer = ( encoding == null ) ? new FileWriter ( tmpFile ) : new OutputStreamWriter ( new FileOutputStream ( tmpFile ) , encoding ) ; outWriter = new BufferedWriter ( writer ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } while ( lines . hasMoreElements ( ) ) { int endComment ; try { line = ( OneLiner . BufferLine ) lines . nextElement ( ) ; } catch ( NoSuchElementException e ) { throw new BuildException ( e ) ; } String lineString = line . getLineString ( ) ; int linelen = line . length ( ) ; if ( tabs == ASIS ) { try { outWriter . write ( lineString ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } else { int ptr ; while ( ( ptr = line . getNext ( ) ) < linelen ) { switch ( lines . getState ( ) ) { case NOTJAVA : notInConstant ( line , line . length ( ) , outWriter ) ; break ; case IN_MULTI_COMMENT : endComment = lineString . indexOf ( "*/" , line . getNext ( ) ) ; if ( endComment >= 0 ) { endComment += 2 ; lines . setState ( LOOKING ) ; } else { endComment = linelen ; } notInConstant ( line , endComment , outWriter ) ; break ; case IN_SINGLE_COMMENT : notInConstant ( line , line . length ( ) , outWriter ) ; lines . setState ( LOOKING ) ; break ; case IN_CHAR_CONST : case IN_STR_CONST : int begin = line . getNext ( ) ; char terminator = ( lines . getState ( ) == IN_STR_CONST ? '\"' : '\'' ) ; endOfCharConst ( line , terminator ) ; while ( line . getNext ( ) < line . getLookahead ( ) ) { if ( line . getNextCharInc ( ) == '\t' ) { line . setColumn ( line . getColumn ( ) + tablength - ( line . getColumn ( ) % tablength ) ) ; } else { line . incColumn ( ) ; } } try { outWriter . write ( line . substring ( begin , line . getNext ( ) ) ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } lines . setState ( LOOKING ) ; break ; case LOOKING : nextStateChange ( line ) ; notInConstant ( line , line . getLookahead ( ) , outWriter ) ; break ; } } } try { outWriter . write ( eolstr ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } try { if ( ctrlz == ASIS ) { outWriter . write ( lines . getEofStr ( ) ) ; } else if ( ctrlz == ADD ) { outWriter . write ( CTRLZ ) ; } } catch ( IOException e ) { throw new BuildException ( e ) ; } finally { try { outWriter . close ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } try { lines . close ( ) ; lines = null ; } catch ( IOException e ) { throw new BuildException ( "Unable to close source file " + srcFile ) ; } File destFile = new File ( destD , file ) ; if ( destFile . exists ( ) ) { log ( "destFile exists" , Project . MSG_DEBUG ) ; if ( ! fileUtils . contentEquals ( destFile , tmpFile ) ) { log ( destFile + " is being written" , Project . MSG_DEBUG ) ; if ( ! destFile . delete ( ) ) { throw new BuildException ( "Unable to delete " + destFile ) ; } if ( ! tmpFile . renameTo ( destFile ) ) { throw new BuildException ( "Failed to transform " + srcFile + " to " + destFile + ". Couldn't rename temporary file: " + tmpFile ) ; } } else { log ( destFile + " is not written, as the contents are identical" , Project . MSG_DEBUG ) ; if ( ! tmpFile . delete ( ) ) { throw new BuildException ( "Unable to delete " + tmpFile ) ; } } } else { log ( "destFile does not exist" , Project . MSG_DEBUG ) ; if ( ! tmpFile . renameTo ( destFile ) ) { throw new BuildException ( "Failed to transform " + srcFile + " to " + destFile + ". Couldn't rename temporary file: " + tmpFile ) ; } } tmpFile = null ; } catch ( IOException e ) { throw new BuildException ( e ) ; } finally { try { if ( lines != null ) { lines . close ( ) ; } } catch ( IOException io ) { log ( "Error closing " + srcFile , Project . MSG_ERR ) ; } if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } private void nextStateChange ( OneLiner . BufferLine bufline ) throws BuildException { int eol = bufline . length ( ) ; int ptr = bufline . getNext ( ) ; while ( ptr < eol ) { switch ( bufline . getChar ( ptr ++ ) ) { case '\'' : bufline . setState ( IN_CHAR_CONST ) ; bufline . setLookahead ( -- ptr ) ; return ; case '\"' : bufline . setState ( IN_STR_CONST ) ; bufline . setLookahead ( -- ptr ) ; return ; case '/' : if ( ptr < eol ) { if ( bufline . getChar ( ptr ) == '*' ) { bufline . setState ( IN_MULTI_COMMENT ) ; bufline . setLookahead ( -- ptr ) ; return ; } else if ( bufline . getChar ( ptr ) == '/' ) { bufline . setState ( IN_SINGLE_COMMENT ) ; bufline . setLookahead ( -- ptr ) ; return ; } } break ; } } bufline . setLookahead ( ptr ) ; } private void endOfCharConst ( OneLiner . BufferLine bufline , char terminator ) throws BuildException { int ptr = bufline . getNext ( ) ; int eol = bufline . length ( ) ; char c ; ptr ++ ; while ( ptr < eol ) { if ( ( c = bufline . getChar ( ptr ++ ) ) == '\\' ) { ptr ++ ; } else { if ( c == terminator ) { bufline . setLookahead ( ptr ) ; return ; } } } throw new BuildException ( "endOfCharConst: unterminated char constant" ) ; } private void notInConstant ( OneLiner . BufferLine bufline , int end , BufferedWriter outWriter ) { int nextTab ; int nextStop ; int tabspaces ; String line = bufline . substring ( bufline . getNext ( ) , end ) ; int place = 0 ; int col = bufline . getColumn ( ) ; linebuf . setLength ( 0 ) ; while ( ( nextTab = line . indexOf ( ( int ) '\t' , place ) ) >= 0 ) { linebuf . append ( line . substring ( place , nextTab ) ) ; col += nextTab - place ; tabspaces = tablength - ( col % tablength ) ; linebuf . append ( spaces . substring ( 0 , tabspaces ) ) ; col += tabspaces ; place = nextTab + 1 ; } linebuf . append ( line . substring ( place , line . length ( ) ) ) ; String linestring = new String ( linebuf . toString ( ) ) ; if ( tabs == REMOVE ) { try { outWriter . write ( linestring ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } else { int tabCol ; linebuf2 . setLength ( 0 ) ; place = 0 ; col = bufline . getColumn ( ) ; int placediff = col - 0 ; nextStop = col + ( tablength - col % tablength ) ; if ( nextStop - col < 2 ) { linebuf2 . append ( linestring . substring ( place , nextStop - placediff ) ) ; place = nextStop - placediff ; nextStop += tablength ; } for ( ; nextStop - placediff <= linestring . length ( ) ; nextStop += tablength ) { for ( tabCol = nextStop ; -- tabCol - placediff >= place && linestring . charAt ( tabCol - placediff ) == ' ' ; ) { ; } if ( nextStop - tabCol > 2 ) { linebuf2 . append ( linestring . substring ( place , ++ tabCol - placediff ) ) ; linebuf2 . append ( '\t' ) ; } else { linebuf2 . append ( linestring . substring ( place , nextStop - placediff ) ) ; } place = nextStop - placediff ; } linebuf2 . append ( linestring . substring ( place , linestring . length ( ) ) ) ; try { outWriter . write ( linebuf2 . toString ( ) ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } bufline . setColumn ( bufline . getColumn ( ) + linestring . length ( ) ) ; bufline . setNext ( end ) ; } class OneLiner implements Enumeration { private int state = javafiles ? LOOKING : NOTJAVA ; private StringBuffer eolStr = new StringBuffer ( LINEBUFLEN ) ; private StringBuffer eofStr = new StringBuffer ( ) ; private BufferedReader reader ; private StringBuffer line = new StringBuffer ( ) ; private boolean reachedEof = false ; public OneLiner ( File srcFile ) throws BuildException { try { reader = new BufferedReader ( getReader ( srcFile ) , INBUFLEN ) ; nextLine ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } protected void nextLine ( ) throws BuildException { int ch = - 1 ; int eolcount = 0 ; eolStr . setLength ( 0 ) ; line . setLength ( 0 ) ; try { ch = reader . read ( ) ; while ( ch != - 1 && ch != '\r' && ch != '\n' ) { line . append ( ( char ) ch ) ; ch = reader . read ( ) ; } if ( ch == - 1 && line . length ( ) == 0 ) { reachedEof = true ; return ; } switch ( ( char ) ch ) { case '\r' : ++ eolcount ; eolStr . append ( '\r' ) ; reader . mark ( 2 ) ; switch ( ( ch = reader . read ( ) ) ) { case '\r' : if ( ( char ) ( ch = reader . read ( ) ) == '\n' ) { eolcount += 2 ; eolStr . append ( "\r\n" ) ; } else { reader . reset ( ) ; } break ; case '\n' : ++ eolcount ; eolStr . append ( '\n' ) ; break ; case - 1 : break ; default : reader . reset ( ) ; break ; } break ; case '\n' : ++ eolcount ; eolStr . append ( '\n' ) ; break ; } if ( eolcount == 0 ) { int i = line . length ( ) ; while ( -- i >= 0 && line . charAt ( i ) == CTRLZ ) { } if ( i < line . length ( ) - 1 ) { eofStr . append ( line . toString ( ) . substring ( i + 1 ) ) ; if ( i < 0 ) { line . setLength ( 0 ) ; reachedEof = true ; } else { line . setLength ( i + 1 ) ; } } } } catch ( IOException e ) { throw new BuildException ( e ) ; } } public String getEofStr ( ) { return eofStr . toString ( ) ; } public int getState ( ) { return state ; } public void setState ( int state ) { this . state = state ; } public boolean hasMoreElements ( ) { return ! reachedEof ; } public Object nextElement ( ) throws NoSuchElementException { if ( ! hasMoreElements ( ) ) { throw new NoSuchElementException ( "OneLiner" ) ; } BufferLine tmpLine = new BufferLine ( line . toString ( ) , eolStr . toString ( ) ) ; nextLine ( ) ; return tmpLine ; } public void close ( ) throws IOException { if ( reader != null ) { reader . close ( ) ; } } class BufferLine { private int next = 0 ; private int column = 0 ; private int lookahead = UNDEF ; private String line ; private String eolStr ; public BufferLine ( String line , String eolStr ) throws BuildException { next = 0 ; column = 0 ; this . line = line ; this . eolStr = eolStr ; } public int getNext ( ) { return next ; } public void setNext ( int next ) { this . next = next ; } public int getLookahead ( ) { return lookahead ; } public void setLookahead ( int lookahead ) { this . lookahead = lookahead ; } public char getChar ( int i ) { return line . charAt ( i ) ; } public char getNextChar ( ) { return getChar ( next ) ; } public char getNextCharInc ( ) { return getChar ( next ++ ) ; } public int getColumn ( ) { return column ; } public void setColumn ( int col ) { column = col ; } public int incColumn ( ) { return column ++ ; } public int length ( ) { return line . length ( ) ; } public int getEolLength ( ) { return eolStr . length ( ) ; } public String getLineString ( ) { return line ; } public String getEol ( ) { return eolStr ; } public String substring ( int begin ) { return line . substring ( begin ) ; } public String substring ( int begin , int end ) { return line . substring ( begin , end ) ; } public void setState ( int state ) { OneLiner . this . setState ( state ) ; } public int getState ( ) { return OneLiner . this . getState ( ) ; } } } public static class AddAsisRemove extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "add" , "asis" , "remove" } ; } } public static class CrLf extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "asis" , "cr" , "lf" , "crlf" } ; } } } 	1	['18', '4', '0', '12', '82', '83', '1', '12', '11', '0.960151803', '1238', '1', '1', '0.821052632', '0.181818182', '2', '2', '66.05555556', '8', '1.8333', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . xml . sax . SAXException ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . FactoryConfigurationError ; import javax . xml . parsers . ParserConfigurationException ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . Vector ; public class XmlProperty extends org . apache . tools . ant . Task { private File src ; private String prefix = "" ; private boolean keepRoot = true ; private boolean validate = false ; private boolean collapseAttributes = false ; private org . w3c . dom . Document document ; public XmlProperty ( ) { super ( ) ; } public void init ( ) { super . init ( ) ; } public void execute ( ) throws BuildException { BufferedInputStream configurationStream = null ; try { configurationStream = new BufferedInputStream ( new FileInputStream ( src ) ) ; DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; factory . setValidating ( validate ) ; factory . setNamespaceAware ( false ) ; DocumentBuilder builder = factory . newDocumentBuilder ( ) ; document = builder . parse ( configurationStream ) ; Element topElement = document . getDocumentElement ( ) ; NodeList topChildren = topElement . getChildNodes ( ) ; int numChildren = topChildren . getLength ( ) ; log ( "Using prefix: \"" + prefix + "\"" , Project . MSG_DEBUG ) ; if ( keepRoot ) { addNodeRecursively ( topElement , prefix ) ; } else { for ( int i = 0 ; i < numChildren ; i ++ ) { addNodeRecursively ( topChildren . item ( i ) , prefix ) ; } } } catch ( SAXException sxe ) { Exception x = sxe ; if ( sxe . getException ( ) != null ) x = sxe . getException ( ) ; throw new BuildException ( x ) ; } catch ( ParserConfigurationException pce ) { throw new BuildException ( pce ) ; } catch ( IOException ioe ) { throw new BuildException ( ioe ) ; } finally { if ( configurationStream != null ) { try { configurationStream . close ( ) ; } catch ( Exception e ) { } } } } void addNodeRecursively ( org . w3c . dom . Node node , String prefix ) { if ( node . hasAttributes ( ) ) { org . w3c . dom . NamedNodeMap nodeAttributes = node . getAttributes ( ) ; for ( int i = 0 ; i < nodeAttributes . getLength ( ) ; i ++ ) { Node attributeNode = nodeAttributes . item ( i ) ; String attributeName ; if ( collapseAttributes ) { attributeName = prefix + ( prefix . trim ( ) . equals ( "" ) ? "" : "." ) + node . getNodeName ( ) + "." + attributeNode . getNodeName ( ) ; } else { attributeName = prefix + ( prefix . trim ( ) . equals ( "" ) ? "" : "." ) + node . getNodeName ( ) + "(" + attributeNode . getNodeName ( ) + ")" ; } String attributeValue = attributeNode . getNodeValue ( ) ; log ( attributeName + ":" + attributeValue , Project . MSG_DEBUG ) ; project . setNewProperty ( attributeName , attributeValue ) ; } } if ( node . getNodeType ( ) == Node . TEXT_NODE ) { String nodeText = node . getNodeValue ( ) ; if ( nodeText . trim ( ) . length ( ) != 0 ) { log ( prefix + ":" + nodeText , Project . MSG_DEBUG ) ; project . setNewProperty ( prefix , nodeText ) ; } } if ( node . hasChildNodes ( ) ) { prefix += ( ( prefix . trim ( ) . equals ( "" ) ? "" : "." ) + node . getNodeName ( ) ) ; org . w3c . dom . NodeList nodeChildren = node . getChildNodes ( ) ; int numChildren = nodeChildren . getLength ( ) ; for ( int i = 0 ; i < numChildren ; i ++ ) { addNodeRecursively ( nodeChildren . item ( i ) , prefix ) ; } } } public void setFile ( File src ) { this . src = src ; } public void setPrefix ( String prefix ) { this . prefix = prefix . trim ( ) ; } public void setKeeproot ( boolean keepRoot ) { this . keepRoot = keepRoot ; } public void setValidate ( boolean validate ) { this . validate = validate ; } public void setCollapseAttributes ( boolean collapseAttributes ) { this . collapseAttributes = collapseAttributes ; } } 	1	['9', '3', '0', '4', '41', '14', '0', '4', '8', '0.791666667', '334', '1', '0', '0.822222222', '0.355555556', '1', '1', '35.44444444', '11', '2', '1']
package org . apache . tools . ant ; import java . lang . reflect . Method ; public class TaskAdapter extends Task { private Object proxy ; public static void checkTaskClass ( final Class taskClass , final Project project ) { try { final Method executeM = taskClass . getMethod ( "execute" , null ) ; if ( ! Void . TYPE . equals ( executeM . getReturnType ( ) ) ) { final String message = "return type of execute() should be " + "void but was \"" + executeM . getReturnType ( ) + "\" in " + taskClass ; project . log ( message , Project . MSG_WARN ) ; } } catch ( NoSuchMethodException e ) { final String message = "No public execute() in " + taskClass ; project . log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } } public void execute ( ) throws BuildException { Method setProjectM = null ; try { Class c = proxy . getClass ( ) ; setProjectM = c . getMethod ( "setProject" , new Class [ ] { Project . class } ) ; if ( setProjectM != null ) { setProjectM . invoke ( proxy , new Object [ ] { project } ) ; } } catch ( NoSuchMethodException e ) { } catch ( Exception ex ) { log ( "Error setting project in " + proxy . getClass ( ) , Project . MSG_ERR ) ; throw new BuildException ( ex ) ; } Method executeM = null ; try { Class c = proxy . getClass ( ) ; executeM = c . getMethod ( "execute" , new Class [ 0 ] ) ; if ( executeM == null ) { log ( "No public execute() in " + proxy . getClass ( ) , Project . MSG_ERR ) ; throw new BuildException ( "No public execute() in " + proxy . getClass ( ) ) ; } executeM . invoke ( proxy , null ) ; return ; } catch ( java . lang . reflect . InvocationTargetException ie ) { log ( "Error in " + proxy . getClass ( ) , Project . MSG_ERR ) ; Throwable t = ie . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( ( BuildException ) t ) ; } else { throw new BuildException ( t ) ; } } catch ( Exception ex ) { log ( "Error in " + proxy . getClass ( ) , Project . MSG_ERR ) ; throw new BuildException ( ex ) ; } } public void setProxy ( Object o ) { this . proxy = o ; } public Object getProxy ( ) { return this . proxy ; } } 	1	['6', '3', '0', '7', '24', '9', '4', '4', '5', '0.8', '231', '0.5', '0', '0.880952381', '0.266666667', '1', '1', '37.16666667', '1', '0.8333', '1']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . Location ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Javac ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . LogStreamHandler ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; import java . io . File ; import java . io . PrintWriter ; import java . io . FileWriter ; import java . io . IOException ; public abstract class DefaultCompilerAdapter implements CompilerAdapter { protected Path src ; protected File destDir ; protected String encoding ; protected boolean debug = false ; protected boolean optimize = false ; protected boolean deprecation = false ; protected boolean depend = false ; protected boolean verbose = false ; protected String target ; protected Path bootclasspath ; protected Path extdirs ; protected Path compileClasspath ; protected Path compileSourcepath ; protected Project project ; protected Location location ; protected boolean includeAntRuntime ; protected boolean includeJavaRuntime ; protected String memoryInitialSize ; protected String memoryMaximumSize ; protected File [ ] compileList ; protected static String lSep = System . getProperty ( "line.separator" ) ; protected Javac attributes ; private FileUtils fileUtils = FileUtils . newFileUtils ( ) ; public void setJavac ( Javac attributes ) { this . attributes = attributes ; src = attributes . getSrcdir ( ) ; destDir = attributes . getDestdir ( ) ; encoding = attributes . getEncoding ( ) ; debug = attributes . getDebug ( ) ; optimize = attributes . getOptimize ( ) ; deprecation = attributes . getDeprecation ( ) ; depend = attributes . getDepend ( ) ; verbose = attributes . getVerbose ( ) ; target = attributes . getTarget ( ) ; bootclasspath = attributes . getBootclasspath ( ) ; extdirs = attributes . getExtdirs ( ) ; compileList = attributes . getFileList ( ) ; compileClasspath = attributes . getClasspath ( ) ; compileSourcepath = attributes . getSourcepath ( ) ; project = attributes . getProject ( ) ; location = attributes . getLocation ( ) ; includeAntRuntime = attributes . getIncludeantruntime ( ) ; includeJavaRuntime = attributes . getIncludejavaruntime ( ) ; memoryInitialSize = attributes . getMemoryInitialSize ( ) ; memoryMaximumSize = attributes . getMemoryMaximumSize ( ) ; } public Javac getJavac ( ) { return attributes ; } protected Path getCompileClasspath ( ) { Path classpath = new Path ( project ) ; if ( destDir != null ) { classpath . setLocation ( destDir ) ; } if ( compileClasspath == null ) { if ( includeAntRuntime ) { classpath . addExisting ( Path . systemClasspath ) ; } } else { if ( includeAntRuntime ) { classpath . addExisting ( compileClasspath . concatSystemClasspath ( "last" ) ) ; } else { classpath . addExisting ( compileClasspath . concatSystemClasspath ( "ignore" ) ) ; } } if ( includeJavaRuntime ) { classpath . addJavaRuntime ( ) ; } return classpath ; } protected Commandline setupJavacCommandlineSwitches ( Commandline cmd ) { return setupJavacCommandlineSwitches ( cmd , false ) ; } protected Commandline setupJavacCommandlineSwitches ( Commandline cmd , boolean useDebugLevel ) { Path classpath = getCompileClasspath ( ) ; Path sourcepath = null ; if ( compileSourcepath != null ) { sourcepath = compileSourcepath ; } else { sourcepath = src ; } String memoryParameterPrefix = assumeJava11 ( ) ? "-J-" : "-J-X" ; if ( memoryInitialSize != null ) { if ( ! attributes . isForkedJavac ( ) ) { attributes . log ( "Since fork is false, ignoring " + "memoryInitialSize setting." , Project . MSG_WARN ) ; } else { cmd . createArgument ( ) . setValue ( memoryParameterPrefix + "ms" + memoryInitialSize ) ; } } if ( memoryMaximumSize != null ) { if ( ! attributes . isForkedJavac ( ) ) { attributes . log ( "Since fork is false, ignoring " + "memoryMaximumSize setting." , Project . MSG_WARN ) ; } else { cmd . createArgument ( ) . setValue ( memoryParameterPrefix + "mx" + memoryMaximumSize ) ; } } if ( attributes . getNowarn ( ) ) { cmd . createArgument ( ) . setValue ( "-nowarn" ) ; } if ( deprecation == true ) { cmd . createArgument ( ) . setValue ( "-deprecation" ) ; } if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "-classpath" ) ; if ( assumeJava11 ( ) ) { Path cp = new Path ( project ) ; if ( bootclasspath != null ) { cp . append ( bootclasspath ) ; } if ( extdirs != null ) { cp . addExtdirs ( extdirs ) ; } cp . append ( classpath ) ; cp . append ( sourcepath ) ; cmd . createArgument ( ) . setPath ( cp ) ; } else { cmd . createArgument ( ) . setPath ( classpath ) ; if ( sourcepath . size ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-sourcepath" ) ; cmd . createArgument ( ) . setPath ( sourcepath ) ; } if ( target != null ) { cmd . createArgument ( ) . setValue ( "-target" ) ; cmd . createArgument ( ) . setValue ( target ) ; } if ( bootclasspath != null && bootclasspath . size ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-bootclasspath" ) ; cmd . createArgument ( ) . setPath ( bootclasspath ) ; } if ( extdirs != null && extdirs . size ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-extdirs" ) ; cmd . createArgument ( ) . setPath ( extdirs ) ; } } if ( encoding != null ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( encoding ) ; } if ( debug ) { if ( useDebugLevel && ! assumeJava11 ( ) ) { String debugLevel = attributes . getDebugLevel ( ) ; if ( debugLevel != null ) { cmd . createArgument ( ) . setValue ( "-g:" + debugLevel ) ; } else { cmd . createArgument ( ) . setValue ( "-g" ) ; } } else { cmd . createArgument ( ) . setValue ( "-g" ) ; } } else if ( ! assumeJava11 ( ) ) { cmd . createArgument ( ) . setValue ( "-g:none" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O" ) ; } if ( depend ) { if ( assumeJava11 ( ) ) { cmd . createArgument ( ) . setValue ( "-depend" ) ; } else if ( assumeJava12 ( ) ) { cmd . createArgument ( ) . setValue ( "-Xdepend" ) ; } else { attributes . log ( "depend attribute is not supported by the " + "modern compiler" , Project . MSG_WARN ) ; } } if ( verbose ) { cmd . createArgument ( ) . setValue ( "-verbose" ) ; } addCurrentCompilerArgs ( cmd ) ; return cmd ; } protected Commandline setupModernJavacCommandlineSwitches ( Commandline cmd ) { setupJavacCommandlineSwitches ( cmd , true ) ; if ( attributes . getSource ( ) != null && ! assumeJava13 ( ) ) { cmd . createArgument ( ) . setValue ( "-source" ) ; cmd . createArgument ( ) . setValue ( attributes . getSource ( ) ) ; } return cmd ; } protected Commandline setupModernJavacCommand ( ) { Commandline cmd = new Commandline ( ) ; setupModernJavacCommandlineSwitches ( cmd ) ; logAndAddFilesToCompile ( cmd ) ; return cmd ; } protected Commandline setupJavacCommand ( ) { return setupJavacCommand ( false ) ; } protected Commandline setupJavacCommand ( boolean debugLevelCheck ) { Commandline cmd = new Commandline ( ) ; setupJavacCommandlineSwitches ( cmd , debugLevelCheck ) ; logAndAddFilesToCompile ( cmd ) ; return cmd ; } protected void logAndAddFilesToCompile ( Commandline cmd ) { attributes . log ( "Compilation " + cmd . describeArguments ( ) , Project . MSG_VERBOSE ) ; StringBuffer niceSourceList = new StringBuffer ( "File" ) ; if ( compileList . length != 1 ) { niceSourceList . append ( "s" ) ; } niceSourceList . append ( " to be compiled:" ) ; niceSourceList . append ( lSep ) ; for ( int i = 0 ; i < compileList . length ; i ++ ) { String arg = compileList [ i ] . getAbsolutePath ( ) ; cmd . createArgument ( ) . setValue ( arg ) ; niceSourceList . append ( "    " + arg + lSep ) ; } attributes . log ( niceSourceList . toString ( ) , Project . MSG_VERBOSE ) ; } protected int executeExternalCompile ( String [ ] args , int firstFileName ) { String [ ] commandArray = null ; File tmpFile = null ; try { if ( Commandline . toString ( args ) . length ( ) > 4096 && firstFileName >= 0 ) { PrintWriter out = null ; try { String userDirName = System . getProperty ( "user.dir" ) ; File userDir = new File ( userDirName ) ; tmpFile = fileUtils . createTempFile ( "files" , "" , userDir ) ; out = new PrintWriter ( new FileWriter ( tmpFile ) ) ; for ( int i = firstFileName ; i < args . length ; i ++ ) { out . println ( args [ i ] ) ; } out . flush ( ) ; commandArray = new String [ firstFileName + 1 ] ; System . arraycopy ( args , 0 , commandArray , 0 , firstFileName ) ; commandArray [ firstFileName ] = "@" + tmpFile ; } catch ( IOException e ) { throw new BuildException ( "Error creating temporary file" , e , location ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( Throwable t ) { } } } } else { commandArray = args ; } try { Execute exe = new Execute ( new LogStreamHandler ( attributes , Project . MSG_INFO , Project . MSG_WARN ) ) ; exe . setAntRun ( project ) ; exe . setWorkingDirectory ( project . getBaseDir ( ) ) ; exe . setCommandline ( commandArray ) ; exe . execute ( ) ; return exe . getExitValue ( ) ; } catch ( IOException e ) { throw new BuildException ( "Error running " + args [ 0 ] + " compiler" , e , location ) ; } } finally { if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } protected void addExtdirsToClasspath ( Path classpath ) { classpath . addExtdirs ( extdirs ) ; } protected void addCurrentCompilerArgs ( Commandline cmd ) { cmd . addArguments ( getJavac ( ) . getCurrentCompilerArgs ( ) ) ; } protected boolean assumeJava11 ( ) { return "javac1.1" . equals ( attributes . getCompilerVersion ( ) ) || ( "classic" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) || ( "extJavac" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) ; } protected boolean assumeJava12 ( ) { return "javac1.2" . equals ( attributes . getCompilerVersion ( ) ) || ( "classic" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_2 ) ) || ( "extJavac" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_2 ) ) ; } protected boolean assumeJava13 ( ) { return "javac1.3" . equals ( attributes . getCompilerVersion ( ) ) || ( "classic" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_3 ) ) || ( "modern" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_3 ) ) || ( "extJavac" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_3 ) ) ; } } 	1	['19', '1', '8', '23', '92', '81', '8', '15', '4', '0.712560386', '899', '1', '9', '0', '0.23015873', '0', '0', '45.10526316', '30', '4.2632', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . ZipFileSet ; import org . apache . tools . zip . ZipOutputStream ; import java . io . File ; import java . io . IOException ; public class Ear extends Jar { private File deploymentDescriptor ; private boolean descriptorAdded ; public Ear ( ) { super ( ) ; archiveType = "ear" ; emptyBehavior = "create" ; } public void setEarfile ( File earFile ) { setDestFile ( earFile ) ; } public void setAppxml ( File descr ) { deploymentDescriptor = descr ; if ( ! deploymentDescriptor . exists ( ) ) { throw new BuildException ( "Deployment descriptor: " + deploymentDescriptor + " does not exist." ) ; } ZipFileSet fs = new ZipFileSet ( ) ; fs . setDir ( new File ( deploymentDescriptor . getParent ( ) ) ) ; fs . setIncludes ( deploymentDescriptor . getName ( ) ) ; fs . setFullpath ( "META-INF/application.xml" ) ; super . addFileset ( fs ) ; } public void addArchives ( ZipFileSet fs ) { fs . setPrefix ( "/" ) ; super . addFileset ( fs ) ; } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( deploymentDescriptor == null && ! isInUpdateMode ( ) ) { throw new BuildException ( "appxml attribute is required" , location ) ; } super . initZipOutputStream ( zOut ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath ) throws IOException { if ( vPath . equalsIgnoreCase ( "META-INF/application.xml" ) ) { if ( deploymentDescriptor == null || ! deploymentDescriptor . equals ( file ) || descriptorAdded ) { log ( "Warning: selected " + archiveType + " files include a META-INF/application.xml which will" + " be ignored (please use appxml attribute to " + archiveType + " task)" , Project . MSG_WARN ) ; } else { super . zipFile ( file , zOut , vPath ) ; descriptorAdded = true ; } } else { super . zipFile ( file , zOut , vPath ) ; } } protected void cleanUp ( ) { descriptorAdded = false ; super . cleanUp ( ) ; } } 	1	['7', '6', '0', '9', '32', '13', '0', '9', '4', '0.75', '150', '1', '0', '0.9625', '0.4', '4', '9', '20.14285714', '2', '1', '1']
package org . apache . tools . ant . taskdefs . email ; import org . apache . tools . ant . ProjectComponent ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . IOException ; import java . io . PrintStream ; public class Message extends ProjectComponent { private File messageSource = null ; private StringBuffer buffer = new StringBuffer ( ) ; private String mimeType = "text/plain" ; private boolean specified = false ; public Message ( ) { } public Message ( String text ) { addText ( text ) ; } public Message ( File file ) { messageSource = file ; } public void addText ( String text ) { buffer . append ( text ) ; } public void setSrc ( File src ) { this . messageSource = src ; } public void setMimeType ( String mimeType ) { this . mimeType = mimeType ; specified = true ; } public String getMimeType ( ) { return mimeType ; } public void print ( PrintStream out ) throws IOException { if ( messageSource != null ) { FileReader freader = new FileReader ( messageSource ) ; try { BufferedReader in = new BufferedReader ( freader ) ; String line = null ; while ( ( line = in . readLine ( ) ) != null ) { out . println ( getProject ( ) . replaceProperties ( line ) ) ; } } finally { freader . close ( ) ; } } else { out . println ( getProject ( ) . replaceProperties ( buffer . toString ( ) ) ) ; } } public boolean isMimeTypeSpecified ( ) { return specified ; } } 	1	['9', '2', '0', '5', '20', '0', '3', '2', '9', '0.5', '141', '1', '0', '0.6', '0.416666667', '0', '0', '14.22222222', '1', '0.6667', '1']
package org . apache . tools . ant . taskdefs . email ; import java . io . File ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; public class EmailTask extends Task { public static final String AUTO = "auto" ; public static final String MIME = "mime" ; public static final String UU = "uu" ; public static final String PLAIN = "plain" ; public static class Encoding extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { AUTO , MIME , UU , PLAIN } ; } } private String encoding = AUTO ; private String host = "localhost" ; private int port = 25 ; private String subject = null ; private Message message = null ; private boolean failOnError = true ; private boolean includeFileNames = false ; private String messageMimeType = null ; private EmailAddress from = null ; private Vector toList = new Vector ( ) ; private Vector ccList = new Vector ( ) ; private Vector bccList = new Vector ( ) ; private Vector files = new Vector ( ) ; private Vector filesets = new Vector ( ) ; public void setEncoding ( Encoding encoding ) { this . encoding = encoding . getValue ( ) ; } public void setMailport ( int port ) { this . port = port ; } public void setMailhost ( String host ) { this . host = host ; } public void setSubject ( String subject ) { this . subject = subject ; } public void setMessage ( String message ) { if ( this . message != null ) { throw new BuildException ( "Only one message can be sent in an " + "email" ) ; } this . message = new Message ( message ) ; this . message . setProject ( getProject ( ) ) ; } public void setMessageFile ( File file ) { if ( this . message != null ) { throw new BuildException ( "Only one message can be sent in an " + "email" ) ; } this . message = new Message ( file ) ; this . message . setProject ( getProject ( ) ) ; } public void setMessageMimeType ( String type ) { this . messageMimeType = type ; } public void addMessage ( Message message ) throws BuildException { if ( this . message != null ) { throw new BuildException ( "Only one message can be sent in an " + "email" ) ; } this . message = message ; } public void addFrom ( EmailAddress address ) { if ( this . from != null ) { throw new BuildException ( "Emails can only be from one address" ) ; } this . from = address ; } public void setFrom ( String address ) { if ( this . from != null ) { throw new BuildException ( "Emails can only be from one address" ) ; } this . from = new EmailAddress ( address ) ; } public void addTo ( EmailAddress address ) { toList . addElement ( address ) ; } public void setToList ( String list ) { StringTokenizer tokens = new StringTokenizer ( list , "," ) ; while ( tokens . hasMoreTokens ( ) ) { toList . addElement ( new EmailAddress ( tokens . nextToken ( ) ) ) ; } } public void addCc ( EmailAddress address ) { ccList . addElement ( address ) ; } public void setCcList ( String list ) { StringTokenizer tokens = new StringTokenizer ( list , "," ) ; while ( tokens . hasMoreTokens ( ) ) { ccList . addElement ( new EmailAddress ( tokens . nextToken ( ) ) ) ; } } public void addBcc ( EmailAddress address ) { bccList . addElement ( address ) ; } public void setBccList ( String list ) { StringTokenizer tokens = new StringTokenizer ( list , "," ) ; while ( tokens . hasMoreTokens ( ) ) { bccList . addElement ( new EmailAddress ( tokens . nextToken ( ) ) ) ; } } public void setFailOnError ( boolean failOnError ) { this . failOnError = failOnError ; } public void setFiles ( String filenames ) { StringTokenizer t = new StringTokenizer ( filenames , ", " ) ; while ( t . hasMoreTokens ( ) ) { files . addElement ( project . resolveFile ( t . nextToken ( ) ) ) ; } } public void addFileset ( FileSet fs ) { filesets . addElement ( fs ) ; } public void setIncludefilenames ( boolean includeFileNames ) { this . includeFileNames = includeFileNames ; } public boolean getIncludeFileNames ( ) { return includeFileNames ; } public void execute ( ) { Message savedMessage = message ; Vector savedFiles = ( Vector ) files . clone ( ) ; try { Mailer mailer = null ; boolean autoFound = false ; if ( encoding . equals ( MIME ) || ( encoding . equals ( AUTO ) && ! autoFound ) ) { try { mailer = ( Mailer ) Class . forName ( "org.apache.tools.ant.taskdefs.email.MimeMailer" ) . newInstance ( ) ; autoFound = true ; log ( "Using MIME mail" , Project . MSG_VERBOSE ) ; } catch ( Throwable e ) { log ( "Failed to initialise MIME mail" , Project . MSG_WARN ) ; } } if ( encoding . equals ( UU ) || ( encoding . equals ( AUTO ) && ! autoFound ) ) { try { mailer = ( Mailer ) Class . forName ( "org.apache.tools.ant.taskdefs.email.UUMailer" ) . newInstance ( ) ; autoFound = true ; log ( "Using UU mail" , Project . MSG_VERBOSE ) ; } catch ( Throwable e ) { log ( "Failed to initialise UU mail" , Project . MSG_WARN ) ; } } if ( encoding . equals ( PLAIN ) || ( encoding . equals ( AUTO ) && ! autoFound ) ) { mailer = new PlainMailer ( ) ; autoFound = true ; log ( "Using plain mail" , Project . MSG_VERBOSE ) ; } if ( mailer == null ) { throw new BuildException ( "Failed to initialise encoding: " + encoding ) ; } if ( message == null ) { message = new Message ( ) ; message . setProject ( getProject ( ) ) ; } if ( from == null || from . getAddress ( ) == null ) { throw new BuildException ( "A from element is required" ) ; } if ( toList . isEmpty ( ) && ccList . isEmpty ( ) && bccList . isEmpty ( ) ) { throw new BuildException ( "At least one of to,cc or bcc must " + "be supplied" ) ; } if ( messageMimeType != null ) { if ( message . isMimeTypeSpecified ( ) ) { throw new BuildException ( "The mime type can only be " + "specified in one location" ) ; } else { message . setMimeType ( messageMimeType ) ; } } Enumeration e = filesets . elements ( ) ; while ( e . hasMoreElements ( ) ) { FileSet fs = ( FileSet ) e . nextElement ( ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; String [ ] includedFiles = ds . getIncludedFiles ( ) ; File baseDir = ds . getBasedir ( ) ; for ( int j = 0 ; j < includedFiles . length ; ++ j ) { File file = new File ( baseDir , includedFiles [ j ] ) ; files . addElement ( file ) ; } } log ( "Sending email: " + subject , Project . MSG_INFO ) ; log ( "From " + from , Project . MSG_VERBOSE ) ; log ( "To " + toList , Project . MSG_VERBOSE ) ; log ( "Cc " + ccList , Project . MSG_VERBOSE ) ; log ( "Bcc " + bccList , Project . MSG_VERBOSE ) ; mailer . setHost ( host ) ; mailer . setPort ( port ) ; mailer . setMessage ( message ) ; mailer . setFrom ( from ) ; mailer . setToList ( toList ) ; mailer . setCcList ( ccList ) ; mailer . setBccList ( bccList ) ; mailer . setFiles ( files ) ; mailer . setSubject ( subject ) ; mailer . setTask ( this ) ; mailer . setIncludeFileNames ( includeFileNames ) ; mailer . send ( ) ; int count = files . size ( ) ; log ( "Sent email with " + count + " attachment" + ( count == 1 ? "" : "s" ) , Project . MSG_INFO ) ; } catch ( BuildException e ) { log ( "Failed to send email" , Project . MSG_WARN ) ; if ( failOnError ) { throw e ; } } finally { message = savedMessage ; files = savedFiles ; } } } 	1	['23', '3', '1', '14', '73', '151', '1', '13', '23', '0.921717172', '668', '0.777777778', '2', '0.627118644', '0.207729469', '3', '3', '27.26086957', '26', '2.3913', '1']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . io . FileOutputStream ; import java . io . OutputStream ; import java . io . FileInputStream ; import java . io . BufferedOutputStream ; import java . util . Vector ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . util . SourceFileScanner ; import org . apache . tools . ant . util . MergingMapper ; import org . apache . tools . tar . TarOutputStream ; import org . apache . tools . tar . TarConstants ; import org . apache . tools . tar . TarEntry ; import java . util . zip . GZIPOutputStream ; import org . apache . tools . bzip2 . CBZip2OutputStream ; public class Tar extends MatchingTask { public static final String WARN = "warn" ; public static final String FAIL = "fail" ; public static final String TRUNCATE = "truncate" ; public static final String GNU = "gnu" ; public static final String OMIT = "omit" ; File tarFile ; File baseDir ; private TarLongFileMode longFileMode = new TarLongFileMode ( ) ; Vector filesets = new Vector ( ) ; Vector fileSetFiles = new Vector ( ) ; private boolean longWarningGiven = false ; private TarCompressionMethod compression = new TarCompressionMethod ( ) ; public TarFileSet createTarFileSet ( ) { TarFileSet fileset = new TarFileSet ( ) ; filesets . addElement ( fileset ) ; return fileset ; } public void setTarfile ( File tarFile ) { this . tarFile = tarFile ; } public void setDestFile ( File destFile ) { this . tarFile = destFile ; } public void setBasedir ( File baseDir ) { this . baseDir = baseDir ; } public void setLongfile ( String mode ) { log ( "DEPRECATED - The setLongfile(String) method has been deprecated." + " Use setLongfile(Tar.TarLongFileMode) instead." ) ; this . longFileMode = new TarLongFileMode ( ) ; longFileMode . setValue ( mode ) ; } public void setLongfile ( TarLongFileMode mode ) { this . longFileMode = mode ; } public void setCompression ( TarCompressionMethod mode ) { this . compression = mode ; } public void execute ( ) throws BuildException { if ( tarFile == null ) { throw new BuildException ( "tarfile attribute must be set!" , location ) ; } if ( tarFile . exists ( ) && tarFile . isDirectory ( ) ) { throw new BuildException ( "tarfile is a directory!" , location ) ; } if ( tarFile . exists ( ) && ! tarFile . canWrite ( ) ) { throw new BuildException ( "Can not write to the specified tarfile!" , location ) ; } Vector savedFileSets = ( Vector ) filesets . clone ( ) ; try { if ( baseDir != null ) { if ( ! baseDir . exists ( ) ) { throw new BuildException ( "basedir does not exist!" , location ) ; } TarFileSet mainFileSet = new TarFileSet ( fileset ) ; mainFileSet . setDir ( baseDir ) ; filesets . addElement ( mainFileSet ) ; } if ( filesets . size ( ) == 0 ) { throw new BuildException ( "You must supply either a basedir " + "attribute or some nested filesets." , location ) ; } boolean upToDate = true ; for ( Enumeration e = filesets . elements ( ) ; e . hasMoreElements ( ) ; ) { TarFileSet fs = ( TarFileSet ) e . nextElement ( ) ; String [ ] files = fs . getFiles ( project ) ; if ( ! archiveIsUpToDate ( files ) ) { upToDate = false ; } for ( int i = 0 ; i < files . length ; ++ i ) { if ( tarFile . equals ( new File ( fs . getDir ( project ) , files [ i ] ) ) ) { throw new BuildException ( "A tar file cannot include " + "itself" , location ) ; } } } if ( upToDate ) { log ( "Nothing to do: " + tarFile . getAbsolutePath ( ) + " is up to date." , Project . MSG_INFO ) ; return ; } log ( "Building tar: " + tarFile . getAbsolutePath ( ) , Project . MSG_INFO ) ; TarOutputStream tOut = null ; try { tOut = new TarOutputStream ( compression . compress ( new BufferedOutputStream ( new FileOutputStream ( tarFile ) ) ) ) ; tOut . setDebug ( true ) ; if ( longFileMode . isTruncateMode ( ) ) { tOut . setLongFileMode ( TarOutputStream . LONGFILE_TRUNCATE ) ; } else if ( longFileMode . isFailMode ( ) || longFileMode . isOmitMode ( ) ) { tOut . setLongFileMode ( TarOutputStream . LONGFILE_ERROR ) ; } else { tOut . setLongFileMode ( TarOutputStream . LONGFILE_GNU ) ; } longWarningGiven = false ; for ( Enumeration e = filesets . elements ( ) ; e . hasMoreElements ( ) ; ) { TarFileSet fs = ( TarFileSet ) e . nextElement ( ) ; String [ ] files = fs . getFiles ( project ) ; if ( files . length > 1 && fs . getFullpath ( ) . length ( ) > 0 ) { throw new BuildException ( "fullpath attribute may only " + "be specified for " + "filesets that specify a " + "single file." ) ; } for ( int i = 0 ; i < files . length ; i ++ ) { File f = new File ( fs . getDir ( project ) , files [ i ] ) ; String name = files [ i ] . replace ( File . separatorChar , '/' ) ; tarFile ( f , tOut , name , fs ) ; } } } catch ( IOException ioe ) { String msg = "Problem creating TAR: " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } finally { if ( tOut != null ) { try { tOut . close ( ) ; } catch ( IOException e ) { } } } } finally { filesets = savedFileSets ; } } protected void tarFile ( File file , TarOutputStream tOut , String vPath , TarFileSet tarFileSet ) throws IOException { FileInputStream fIn = null ; String fullpath = tarFileSet . getFullpath ( ) ; if ( fullpath . length ( ) > 0 ) { vPath = fullpath ; } else { if ( vPath . length ( ) <= 0 ) { return ; } if ( file . isDirectory ( ) && ! vPath . endsWith ( "/" ) ) { vPath += "/" ; } String prefix = tarFileSet . getPrefix ( ) ; if ( prefix . length ( ) > 0 && ! prefix . endsWith ( "/" ) ) { prefix = prefix + "/" ; } vPath = prefix + vPath ; } if ( vPath . startsWith ( "/" ) && ! tarFileSet . getPreserveLeadingSlashes ( ) ) { int l = vPath . length ( ) ; if ( l <= 1 ) { return ; } vPath = vPath . substring ( 1 , l ) ; } try { if ( vPath . length ( ) >= TarConstants . NAMELEN ) { if ( longFileMode . isOmitMode ( ) ) { log ( "Omitting: " + vPath , Project . MSG_INFO ) ; return ; } else if ( longFileMode . isWarnMode ( ) ) { log ( "Entry: " + vPath + " longer than " + TarConstants . NAMELEN + " characters." , Project . MSG_WARN ) ; if ( ! longWarningGiven ) { log ( "Resulting tar file can only be processed " + "successfully by GNU compatible tar commands" , Project . MSG_WARN ) ; longWarningGiven = true ; } } else if ( longFileMode . isFailMode ( ) ) { throw new BuildException ( "Entry: " + vPath + " longer than " + TarConstants . NAMELEN + "characters." , location ) ; } } TarEntry te = new TarEntry ( vPath ) ; te . setModTime ( file . lastModified ( ) ) ; if ( ! file . isDirectory ( ) ) { te . setSize ( file . length ( ) ) ; te . setMode ( tarFileSet . getMode ( ) ) ; } te . setUserName ( tarFileSet . getUserName ( ) ) ; te . setGroupName ( tarFileSet . getGroup ( ) ) ; tOut . putNextEntry ( te ) ; if ( ! file . isDirectory ( ) ) { fIn = new FileInputStream ( file ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { tOut . write ( buffer , 0 , count ) ; count = fIn . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } tOut . closeEntry ( ) ; } finally { if ( fIn != null ) { fIn . close ( ) ; } } } protected boolean archiveIsUpToDate ( String [ ] files ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; MergingMapper mm = new MergingMapper ( ) ; mm . setTo ( tarFile . getAbsolutePath ( ) ) ; return sfs . restrict ( files , baseDir , null , mm ) . length == 0 ; } public static class TarFileSet extends FileSet { private String [ ] files = null ; private int mode = 0100644 ; private String userName = "" ; private String groupName = "" ; private String prefix = "" ; private String fullpath = "" ; private boolean preserveLeadingSlashes = false ; public TarFileSet ( FileSet fileset ) { super ( fileset ) ; } public TarFileSet ( ) { super ( ) ; } public String [ ] getFiles ( Project p ) { if ( files == null ) { DirectoryScanner ds = getDirectoryScanner ( p ) ; String [ ] directories = ds . getIncludedDirectories ( ) ; String [ ] filesPerSe = ds . getIncludedFiles ( ) ; files = new String [ directories . length + filesPerSe . length ] ; System . arraycopy ( directories , 0 , files , 0 , directories . length ) ; System . arraycopy ( filesPerSe , 0 , files , directories . length , filesPerSe . length ) ; } return files ; } public void setMode ( String octalString ) { this . mode = 0100000 | Integer . parseInt ( octalString , 8 ) ; } public int getMode ( ) { return mode ; } public void setUserName ( String userName ) { this . userName = userName ; } public String getUserName ( ) { return userName ; } public void setGroup ( String groupName ) { this . groupName = groupName ; } public String getGroup ( ) { return groupName ; } public void setPrefix ( String prefix ) { this . prefix = prefix ; } public String getPrefix ( ) { return prefix ; } public void setFullpath ( String fullpath ) { this . fullpath = fullpath ; } public String getFullpath ( ) { return fullpath ; } public void setPreserveLeadingSlashes ( boolean b ) { this . preserveLeadingSlashes = b ; } public boolean getPreserveLeadingSlashes ( ) { return preserveLeadingSlashes ; } } public static class TarLongFileMode extends EnumeratedAttribute { public static final String WARN = "warn" ; public static final String FAIL = "fail" ; public static final String TRUNCATE = "truncate" ; public static final String GNU = "gnu" ; public static final String OMIT = "omit" ; private final String [ ] validModes = { WARN , FAIL , TRUNCATE , GNU , OMIT } ; public TarLongFileMode ( ) { super ( ) ; setValue ( WARN ) ; } public String [ ] getValues ( ) { return validModes ; } public boolean isTruncateMode ( ) { return TRUNCATE . equalsIgnoreCase ( getValue ( ) ) ; } public boolean isWarnMode ( ) { return WARN . equalsIgnoreCase ( getValue ( ) ) ; } public boolean isGnuMode ( ) { return GNU . equalsIgnoreCase ( getValue ( ) ) ; } public boolean isFailMode ( ) { return FAIL . equalsIgnoreCase ( getValue ( ) ) ; } public boolean isOmitMode ( ) { return OMIT . equalsIgnoreCase ( getValue ( ) ) ; } } public static final class TarCompressionMethod extends EnumeratedAttribute { private static final String NONE = "none" ; private static final String GZIP = "gzip" ; private static final String BZIP2 = "bzip2" ; public TarCompressionMethod ( ) { super ( ) ; setValue ( NONE ) ; } public String [ ] getValues ( ) { return new String [ ] { NONE , GZIP , BZIP2 } ; } private OutputStream compress ( final OutputStream ostream ) throws IOException { final String value = getValue ( ) ; if ( GZIP . equals ( value ) ) { return new GZIPOutputStream ( ostream ) ; } else { if ( BZIP2 . equals ( value ) ) { ostream . write ( 'B' ) ; ostream . write ( 'Z' ) ; return new CBZip2OutputStream ( ostream ) ; } } return ostream ; } } } 	1	['11', '4', '0', '17', '83', '11', '0', '17', '9', '0.916666667', '671', '0.25', '2', '0.886363636', '0.25', '2', '2', '58.90909091', '2', '1', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ExitException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . CommandlineJava ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . types . Environment ; import java . io . File ; import java . io . PrintStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . Vector ; public class Java extends Task { private CommandlineJava cmdl = new CommandlineJava ( ) ; private Environment env = new Environment ( ) ; private boolean fork = false ; private boolean newEnvironment = false ; private File dir = null ; private File out ; private PrintStream outStream = null ; private boolean failOnError = false ; private boolean append = false ; private Long timeout = null ; public void execute ( ) throws BuildException { File savedDir = dir ; int err = - 1 ; try { if ( ( err = executeJava ( ) ) != 0 ) { if ( failOnError ) { throw new BuildException ( "Java returned: " + err , location ) ; } else { log ( "Java Result: " + err , Project . MSG_ERR ) ; } } } finally { dir = savedDir ; } } public int executeJava ( ) throws BuildException { String classname = cmdl . getClassname ( ) ; if ( classname == null && cmdl . getJar ( ) == null ) { throw new BuildException ( "Classname must not be null." ) ; } if ( ! fork && cmdl . getJar ( ) != null ) { throw new BuildException ( "Cannot execute a jar in non-forked mode." + " Please set fork='true'. " ) ; } if ( fork ) { log ( cmdl . describeCommand ( ) , Project . MSG_VERBOSE ) ; } else { if ( cmdl . getVmCommand ( ) . size ( ) > 1 ) { log ( "JVM args ignored when same JVM is used." , Project . MSG_WARN ) ; } if ( dir != null ) { log ( "Working directory ignored when same JVM is used." , Project . MSG_WARN ) ; } if ( newEnvironment || null != env . getVariables ( ) ) { log ( "Changes to environment variables are ignored when same " + "JVM is used." , Project . MSG_WARN ) ; } log ( "Running in same VM " + cmdl . describeJavaCommand ( ) , Project . MSG_VERBOSE ) ; } try { if ( fork ) { return run ( cmdl . getCommandline ( ) ) ; } else { try { run ( cmdl ) ; return 0 ; } catch ( ExitException ex ) { return ex . getStatus ( ) ; } } } catch ( BuildException e ) { if ( failOnError ) { throw e ; } else { log ( e . getMessage ( ) , Project . MSG_ERR ) ; return 0 ; } } catch ( Throwable t ) { if ( failOnError ) { throw new BuildException ( t ) ; } else { log ( t . getMessage ( ) , Project . MSG_ERR ) ; return 0 ; } } } public void setClasspath ( Path s ) { createClasspath ( ) . append ( s ) ; } public Path createClasspath ( ) { return cmdl . createClasspath ( project ) . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setJar ( File jarfile ) throws BuildException { if ( cmdl . getClassname ( ) != null ) { throw new BuildException ( "Cannot use 'jar' and 'classname' " + "attributes in same command." ) ; } cmdl . setJar ( jarfile . getAbsolutePath ( ) ) ; } public void setClassname ( String s ) throws BuildException { if ( cmdl . getJar ( ) != null ) { throw new BuildException ( "Cannot use 'jar' and 'classname' " + "attributes in same command" ) ; } cmdl . setClassname ( s ) ; } public void setArgs ( String s ) { log ( "The args attribute is deprecated. " + "Please use nested arg elements." , Project . MSG_WARN ) ; cmdl . createArgument ( ) . setLine ( s ) ; } public Commandline . Argument createArg ( ) { return cmdl . createArgument ( ) ; } public void setFork ( boolean s ) { this . fork = s ; } public void setJvmargs ( String s ) { log ( "The jvmargs attribute is deprecated. " + "Please use nested jvmarg elements." , Project . MSG_WARN ) ; cmdl . createVmArgument ( ) . setLine ( s ) ; } public Commandline . Argument createJvmarg ( ) { return cmdl . createVmArgument ( ) ; } public void setJvm ( String s ) { cmdl . setVm ( s ) ; } public void addSysproperty ( Environment . Variable sysp ) { cmdl . addSysproperty ( sysp ) ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } public void setDir ( File d ) { this . dir = d ; } public void setOutput ( File out ) { this . out = out ; } public void setMaxmemory ( String max ) { cmdl . setMaxmemory ( max ) ; } public void setJVMVersion ( String value ) { cmdl . setVmversion ( value ) ; } public void addEnv ( Environment . Variable var ) { env . addVariable ( var ) ; } public void setNewenvironment ( boolean newenv ) { newEnvironment = newenv ; } public void setAppend ( boolean append ) { this . append = append ; } public void setTimeout ( Long value ) { timeout = value ; } protected void handleOutput ( String line ) { if ( outStream != null ) { outStream . println ( line ) ; } else { super . handleOutput ( line ) ; } } protected void handleErrorOutput ( String line ) { if ( outStream != null ) { outStream . println ( line ) ; } else { super . handleErrorOutput ( line ) ; } } private void run ( CommandlineJava command ) throws BuildException { ExecuteJava exe = new ExecuteJava ( ) ; exe . setJavaCommand ( command . getJavaCommand ( ) ) ; exe . setClasspath ( command . getClasspath ( ) ) ; exe . setSystemProperties ( command . getSystemProperties ( ) ) ; exe . setTimeout ( timeout ) ; if ( out != null ) { try { outStream = new PrintStream ( new FileOutputStream ( out . getAbsolutePath ( ) , append ) ) ; exe . execute ( project ) ; } catch ( IOException io ) { throw new BuildException ( io , location ) ; } finally { if ( outStream != null ) { outStream . close ( ) ; } } } else { exe . execute ( project ) ; } } private int run ( String [ ] command ) throws BuildException { FileOutputStream fos = null ; try { Execute exe = null ; if ( out == null ) { exe = new Execute ( new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) , createWatchdog ( ) ) ; } else { fos = new FileOutputStream ( out . getAbsolutePath ( ) , append ) ; exe = new Execute ( new PumpStreamHandler ( fos ) , createWatchdog ( ) ) ; } exe . setAntRun ( project ) ; if ( dir == null ) { dir = project . getBaseDir ( ) ; } else if ( ! dir . exists ( ) || ! dir . isDirectory ( ) ) { throw new BuildException ( dir . getAbsolutePath ( ) + " is not a valid directory" , location ) ; } exe . setWorkingDirectory ( dir ) ; String [ ] environment = env . getVariables ( ) ; if ( environment != null ) { for ( int i = 0 ; i < environment . length ; i ++ ) { log ( "Setting environment variable: " + environment [ i ] , Project . MSG_VERBOSE ) ; } } exe . setNewenvironment ( newEnvironment ) ; exe . setEnvironment ( environment ) ; exe . setCommandline ( command ) ; try { int rc = exe . execute ( ) ; if ( exe . killedProcess ( ) ) { log ( "Timeout: killed the sub-process" , Project . MSG_WARN ) ; } return rc ; } catch ( IOException e ) { throw new BuildException ( e , location ) ; } } catch ( IOException io ) { throw new BuildException ( io , location ) ; } finally { if ( fos != null ) { try { fos . close ( ) ; } catch ( IOException io ) { } } } } protected void run ( String classname , Vector args ) throws BuildException { CommandlineJava cmdj = new CommandlineJava ( ) ; cmdj . setClassname ( classname ) ; for ( int i = 0 ; i < args . size ( ) ; i ++ ) { cmdj . createArgument ( ) . setValue ( ( String ) args . elementAt ( i ) ) ; } run ( cmdj ) ; } public void clearArgs ( ) { cmdl . clearJavaArgs ( ) ; } protected ExecuteWatchdog createWatchdog ( ) throws BuildException { if ( timeout == null ) { return null ; } return new ExecuteWatchdog ( timeout . longValue ( ) ) ; } } 	1	['31', '3', '0', '20', '103', '209', '0', '20', '25', '0.82', '673', '1', '2', '0.552238806', '0.161290323', '1', '3', '20.38709677', '2', '1.0323', '1']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . FileOutputStream ; import java . io . FileInputStream ; import java . io . OutputStream ; import java . io . ByteArrayOutputStream ; import java . io . ByteArrayInputStream ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Stack ; import java . util . Vector ; import java . util . zip . CRC32 ; import java . util . zip . ZipInputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . FileScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . PatternSet ; import org . apache . tools . ant . types . ZipFileSet ; import org . apache . tools . ant . types . ZipScanner ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . SourceFileScanner ; import org . apache . tools . ant . util . MergingMapper ; import org . apache . tools . zip . ZipOutputStream ; import org . apache . tools . zip . ZipEntry ; public class Zip extends MatchingTask { protected File zipFile ; private File baseDir ; protected Hashtable entries = new Hashtable ( ) ; private Vector groupfilesets = new Vector ( ) ; private Vector filesetsFromGroupfilesets = new Vector ( ) ; protected String duplicate = "add" ; private boolean doCompress = true ; private boolean doUpdate = false ; private boolean savedDoUpdate = false ; private boolean doFilesonly = false ; protected String archiveType = "zip" ; private static final long EMPTY_CRC = new CRC32 ( ) . getValue ( ) ; protected String emptyBehavior = "skip" ; private Vector filesets = new Vector ( ) ; protected Hashtable addedDirs = new Hashtable ( ) ; private Vector addedFiles = new Vector ( ) ; private boolean addingNewFiles = false ; private String encoding ; public void setZipfile ( File zipFile ) { setDestFile ( zipFile ) ; } public void setFile ( File file ) { setDestFile ( file ) ; } public void setDestFile ( File destFile ) { this . zipFile = destFile ; } public void setBasedir ( File baseDir ) { this . baseDir = baseDir ; } public void setCompress ( boolean c ) { doCompress = c ; } public void setFilesonly ( boolean f ) { doFilesonly = f ; } public void setUpdate ( boolean c ) { doUpdate = c ; savedDoUpdate = c ; } public boolean isInUpdateMode ( ) { return doUpdate ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void addZipfileset ( ZipFileSet set ) { filesets . addElement ( set ) ; } public void addZipGroupFileset ( FileSet set ) { groupfilesets . addElement ( set ) ; } public void setDuplicate ( Duplicate df ) { duplicate = df . getValue ( ) ; } public static class WhenEmpty extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "fail" , "skip" , "create" } ; } } public void setWhenempty ( WhenEmpty we ) { emptyBehavior = we . getValue ( ) ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public void execute ( ) throws BuildException { if ( baseDir == null && filesets . size ( ) == 0 && groupfilesets . size ( ) == 0 && "zip" . equals ( archiveType ) ) { throw new BuildException ( "basedir attribute must be set, " + "or at least " + "one fileset must be given!" ) ; } if ( zipFile == null ) { throw new BuildException ( "You must specify the " + archiveType + " file to create!" ) ; } File renamedFile = null ; addingNewFiles = true ; doUpdate = doUpdate && zipFile . exists ( ) ; for ( int i = 0 ; i < groupfilesets . size ( ) ; i ++ ) { log ( "Processing groupfileset " , Project . MSG_VERBOSE ) ; FileSet fs = ( FileSet ) groupfilesets . elementAt ( i ) ; FileScanner scanner = fs . getDirectoryScanner ( project ) ; String [ ] files = scanner . getIncludedFiles ( ) ; File basedir = scanner . getBasedir ( ) ; for ( int j = 0 ; j < files . length ; j ++ ) { log ( "Adding file " + files [ j ] + " to fileset" , Project . MSG_VERBOSE ) ; ZipFileSet zf = new ZipFileSet ( ) ; zf . setSrc ( new File ( basedir , files [ j ] ) ) ; filesets . addElement ( zf ) ; filesetsFromGroupfilesets . addElement ( zf ) ; } } Vector dss = new Vector ( ) ; if ( baseDir != null ) { dss . addElement ( getDirectoryScanner ( baseDir ) ) ; } for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; dss . addElement ( fs . getDirectoryScanner ( project ) ) ; } int dssSize = dss . size ( ) ; FileScanner [ ] scanners = new FileScanner [ dssSize ] ; dss . copyInto ( scanners ) ; boolean success = false ; try { if ( isUpToDate ( scanners , zipFile ) ) { return ; } if ( doUpdate ) { FileUtils fileUtils = FileUtils . newFileUtils ( ) ; renamedFile = fileUtils . createTempFile ( "zip" , ".tmp" , fileUtils . getParentFile ( zipFile ) ) ; try { if ( ! zipFile . renameTo ( renamedFile ) ) { throw new BuildException ( "Unable to rename old file " + "to temporary file" ) ; } } catch ( SecurityException e ) { throw new BuildException ( "Not allowed to rename old file " + "to temporary file" ) ; } } String action = doUpdate ? "Updating " : "Building " ; log ( action + archiveType + ": " + zipFile . getAbsolutePath ( ) ) ; ZipOutputStream zOut = new ZipOutputStream ( new FileOutputStream ( zipFile ) ) ; zOut . setEncoding ( encoding ) ; try { if ( doCompress ) { zOut . setMethod ( ZipOutputStream . DEFLATED ) ; } else { zOut . setMethod ( ZipOutputStream . STORED ) ; } initZipOutputStream ( zOut ) ; if ( baseDir != null ) { addFiles ( getDirectoryScanner ( baseDir ) , zOut , "" , "" ) ; } addFiles ( filesets , zOut ) ; if ( doUpdate ) { addingNewFiles = false ; ZipFileSet oldFiles = new ZipFileSet ( ) ; oldFiles . setSrc ( renamedFile ) ; for ( int i = 0 ; i < addedFiles . size ( ) ; i ++ ) { PatternSet . NameEntry ne = oldFiles . createExclude ( ) ; ne . setName ( ( String ) addedFiles . elementAt ( i ) ) ; } Vector tmp = new Vector ( 1 ) ; tmp . addElement ( oldFiles ) ; addFiles ( tmp , zOut ) ; } finalizeZipOutputStream ( zOut ) ; if ( doUpdate ) { if ( ! renamedFile . delete ( ) ) { log ( "Warning: unable to delete temporary file " + renamedFile . getName ( ) , Project . MSG_WARN ) ; } } success = true ; } finally { try { if ( zOut != null ) { zOut . close ( ) ; } } catch ( IOException ex ) { if ( success ) { throw ex ; } } } } catch ( IOException ioe ) { String msg = "Problem creating " + archiveType + ": " + ioe . getMessage ( ) ; if ( ( ! doUpdate || renamedFile != null ) && ! zipFile . delete ( ) ) { msg += " (and the archive is probably corrupt but I could not " + "delete it)" ; } if ( doUpdate && renamedFile != null ) { if ( ! renamedFile . renameTo ( zipFile ) ) { msg += " (and I couldn't rename the temporary file " + renamedFile . getName ( ) + " back)" ; } } throw new BuildException ( msg , ioe , location ) ; } finally { cleanUp ( ) ; } } protected boolean isAddingNewFiles ( ) { return addingNewFiles ; } protected void addFiles ( FileScanner scanner , ZipOutputStream zOut , String prefix , String fullpath ) throws IOException { if ( prefix . length ( ) > 0 && fullpath . length ( ) > 0 ) { throw new BuildException ( "Both prefix and fullpath attributes must" + " not be set on the same fileset." ) ; } File thisBaseDir = scanner . getBasedir ( ) ; String [ ] dirs = scanner . getIncludedDirectories ( ) ; if ( dirs . length > 0 && fullpath . length ( ) > 0 ) { throw new BuildException ( "fullpath attribute may only be specified" + " for filesets that specify a single" + " file." ) ; } for ( int i = 0 ; i < dirs . length ; i ++ ) { if ( "" . equals ( dirs [ i ] ) ) { continue ; } String name = dirs [ i ] . replace ( File . separatorChar , '/' ) ; if ( ! name . endsWith ( "/" ) ) { name += "/" ; } addParentDirs ( thisBaseDir , name , zOut , prefix ) ; } String [ ] files = scanner . getIncludedFiles ( ) ; if ( files . length > 1 && fullpath . length ( ) > 0 ) { throw new BuildException ( "fullpath attribute may only be specified" + " for filesets that specify a single" + "file." ) ; } for ( int i = 0 ; i < files . length ; i ++ ) { File f = new File ( thisBaseDir , files [ i ] ) ; if ( fullpath . length ( ) > 0 ) { addParentDirs ( null , fullpath , zOut , "" ) ; zipFile ( f , zOut , fullpath ) ; } else { String name = files [ i ] . replace ( File . separatorChar , '/' ) ; addParentDirs ( thisBaseDir , name , zOut , prefix ) ; zipFile ( f , zOut , prefix + name ) ; } } } protected void addZipEntries ( ZipFileSet fs , DirectoryScanner ds , ZipOutputStream zOut , String prefix , String fullpath ) throws IOException { log ( "adding zip entries: " + fullpath , Project . MSG_VERBOSE ) ; if ( prefix . length ( ) > 0 && fullpath . length ( ) > 0 ) { throw new BuildException ( "Both prefix and fullpath attributes must" + " not be set on the same fileset." ) ; } ZipScanner zipScanner = ( ZipScanner ) ds ; File zipSrc = fs . getSrc ( ) ; ZipEntry entry ; java . util . zip . ZipEntry origEntry ; ZipInputStream in = null ; try { in = new ZipInputStream ( new FileInputStream ( zipSrc ) ) ; while ( ( origEntry = in . getNextEntry ( ) ) != null ) { entry = new ZipEntry ( origEntry ) ; String vPath = entry . getName ( ) ; if ( zipScanner . match ( vPath ) ) { if ( fullpath . length ( ) > 0 ) { addParentDirs ( null , fullpath , zOut , "" ) ; zipFile ( in , zOut , fullpath , entry . getTime ( ) , zipSrc ) ; } else { addParentDirs ( null , vPath , zOut , prefix ) ; if ( ! entry . isDirectory ( ) ) { zipFile ( in , zOut , prefix + vPath , entry . getTime ( ) , zipSrc ) ; } } } } } finally { if ( in != null ) { in . close ( ) ; } } } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { } protected void finalizeZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { } protected boolean createEmptyZip ( File zipFile ) { log ( "Note: creating empty " + archiveType + " archive " + zipFile , Project . MSG_INFO ) ; OutputStream os = null ; try { os = new FileOutputStream ( zipFile ) ; byte [ ] empty = new byte [ 22 ] ; empty [ 0 ] = 80 ; empty [ 1 ] = 75 ; empty [ 2 ] = 5 ; empty [ 3 ] = 6 ; os . write ( empty ) ; } catch ( IOException ioe ) { throw new BuildException ( "Could not create empty ZIP archive " + "(" + ioe . getMessage ( ) + ")" , ioe , location ) ; } finally { if ( os != null ) { try { os . close ( ) ; } catch ( IOException e ) { } } } return true ; } protected boolean isUpToDate ( FileScanner [ ] scanners , File zipFile ) throws BuildException { String [ ] [ ] fileNames = grabFileNames ( scanners ) ; File [ ] files = grabFiles ( scanners , fileNames ) ; if ( files . length == 0 ) { if ( emptyBehavior . equals ( "skip" ) ) { log ( "Warning: skipping " + archiveType + " archive " + zipFile + " because no files were included." , Project . MSG_WARN ) ; return true ; } else if ( emptyBehavior . equals ( "fail" ) ) { throw new BuildException ( "Cannot create " + archiveType + " archive " + zipFile + ": no files were included." , location ) ; } else { return createEmptyZip ( zipFile ) ; } } else { for ( int i = 0 ; i < files . length ; ++ i ) { if ( files [ i ] . equals ( zipFile ) ) { throw new BuildException ( "A zip file cannot include " + "itself" , location ) ; } } if ( ! zipFile . exists ( ) ) { return false ; } SourceFileScanner sfs = new SourceFileScanner ( this ) ; MergingMapper mm = new MergingMapper ( ) ; mm . setTo ( zipFile . getAbsolutePath ( ) ) ; for ( int i = 0 ; i < scanners . length ; i ++ ) { if ( sfs . restrict ( fileNames [ i ] , scanners [ i ] . getBasedir ( ) , null , mm ) . length > 0 ) { return false ; } } return true ; } } protected static File [ ] grabFiles ( FileScanner [ ] scanners ) { return grabFiles ( scanners , grabFileNames ( scanners ) ) ; } protected static File [ ] grabFiles ( FileScanner [ ] scanners , String [ ] [ ] fileNames ) { Vector files = new Vector ( ) ; for ( int i = 0 ; i < fileNames . length ; i ++ ) { File thisBaseDir = scanners [ i ] . getBasedir ( ) ; for ( int j = 0 ; j < fileNames [ i ] . length ; j ++ ) { files . addElement ( new File ( thisBaseDir , fileNames [ i ] [ j ] ) ) ; } } File [ ] toret = new File [ files . size ( ) ] ; files . copyInto ( toret ) ; return toret ; } protected static String [ ] [ ] grabFileNames ( FileScanner [ ] scanners ) { String [ ] [ ] result = new String [ scanners . length ] [ ] ; for ( int i = 0 ; i < scanners . length ; i ++ ) { String [ ] files = scanners [ i ] . getIncludedFiles ( ) ; String [ ] dirs = scanners [ i ] . getIncludedDirectories ( ) ; result [ i ] = new String [ files . length + dirs . length ] ; System . arraycopy ( files , 0 , result [ i ] , 0 , files . length ) ; System . arraycopy ( dirs , 0 , result [ i ] , files . length , dirs . length ) ; } return result ; } protected void zipDir ( File dir , ZipOutputStream zOut , String vPath ) throws IOException { if ( addedDirs . get ( vPath ) != null ) { return ; } log ( "adding directory " + vPath , Project . MSG_VERBOSE ) ; addedDirs . put ( vPath , vPath ) ; ZipEntry ze = new ZipEntry ( vPath ) ; if ( dir != null && dir . exists ( ) ) { ze . setTime ( dir . lastModified ( ) ) ; } else { ze . setTime ( System . currentTimeMillis ( ) ) ; } ze . setSize ( 0 ) ; ze . setMethod ( ZipEntry . STORED ) ; ze . setCrc ( EMPTY_CRC ) ; ze . setExternalAttributes ( 0x41FD0010L ) ; zOut . putNextEntry ( ze ) ; } protected void zipFile ( InputStream in , ZipOutputStream zOut , String vPath , long lastModified , File file ) throws IOException { if ( entries . contains ( vPath ) ) { if ( duplicate . equals ( "preserve" ) ) { log ( vPath + " already added, skipping" , Project . MSG_INFO ) ; return ; } else if ( duplicate . equals ( "fail" ) ) { throw new BuildException ( "Duplicate file " + vPath + " was found and the duplicate " + "attribute is 'fail'." ) ; } else { log ( "duplicate file " + vPath + " found, adding." , Project . MSG_VERBOSE ) ; } } else { log ( "adding entry " + vPath , Project . MSG_VERBOSE ) ; } entries . put ( vPath , vPath ) ; ZipEntry ze = new ZipEntry ( vPath ) ; ze . setTime ( lastModified ) ; if ( ! doCompress ) { long size = 0 ; CRC32 cal = new CRC32 ( ) ; if ( ! in . markSupported ( ) ) { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { size += count ; cal . update ( buffer , 0 , count ) ; bos . write ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; in = new ByteArrayInputStream ( bos . toByteArray ( ) ) ; } else { in . mark ( Integer . MAX_VALUE ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { size += count ; cal . update ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; in . reset ( ) ; } ze . setSize ( size ) ; ze . setCrc ( cal . getValue ( ) ) ; } zOut . putNextEntry ( ze ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { if ( count != 0 ) { zOut . write ( buffer , 0 , count ) ; } count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; addedFiles . addElement ( vPath ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath ) throws IOException { if ( file . equals ( zipFile ) ) { throw new BuildException ( "A zip file cannot include itself" , location ) ; } FileInputStream fIn = new FileInputStream ( file ) ; try { zipFile ( fIn , zOut , vPath , file . lastModified ( ) , null ) ; } finally { fIn . close ( ) ; } } protected void addParentDirs ( File baseDir , String entry , ZipOutputStream zOut , String prefix ) throws IOException { if ( ! doFilesonly ) { Stack directories = new Stack ( ) ; int slashPos = entry . length ( ) ; while ( ( slashPos = entry . lastIndexOf ( '/' , slashPos - 1 ) ) != - 1 ) { String dir = entry . substring ( 0 , slashPos + 1 ) ; if ( addedDirs . get ( prefix + dir ) != null ) { break ; } directories . push ( dir ) ; } while ( ! directories . isEmpty ( ) ) { String dir = ( String ) directories . pop ( ) ; File f = null ; if ( baseDir != null ) { f = new File ( baseDir , dir ) ; } else { f = new File ( dir ) ; } zipDir ( f , zOut , prefix + dir ) ; } } } protected void addFiles ( Vector filesets , ZipOutputStream zOut ) throws IOException { for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; String prefix = "" ; String fullpath = "" ; if ( fs instanceof ZipFileSet ) { ZipFileSet zfs = ( ZipFileSet ) fs ; prefix = zfs . getPrefix ( ) ; fullpath = zfs . getFullpath ( ) ; } if ( prefix . length ( ) > 0 && ! prefix . endsWith ( "/" ) && ! prefix . endsWith ( "\\" ) ) { prefix += "/" ; } if ( prefix . length ( ) > 0 ) { addParentDirs ( null , prefix , zOut , "" ) ; zipDir ( null , zOut , prefix ) ; } else if ( fullpath . length ( ) > 0 ) { addParentDirs ( null , fullpath , zOut , "" ) ; } if ( fs instanceof ZipFileSet && ( ( ZipFileSet ) fs ) . getSrc ( ) != null ) { addZipEntries ( ( ZipFileSet ) fs , ds , zOut , prefix , fullpath ) ; } else { addFiles ( ds , zOut , prefix , fullpath ) ; } } } protected void cleanUp ( ) { addedDirs . clear ( ) ; addedFiles . removeAllElements ( ) ; entries . clear ( ) ; addingNewFiles = false ; doUpdate = savedDoUpdate ; Enumeration enum = filesetsFromGroupfilesets . elements ( ) ; while ( enum . hasMoreElements ( ) ) { ZipFileSet zf = ( ZipFileSet ) enum . nextElement ( ) ; filesets . removeElement ( zf ) ; } filesetsFromGroupfilesets . removeAllElements ( ) ; } public void reset ( ) { filesets . removeAllElements ( ) ; zipFile = null ; baseDir = null ; groupfilesets . removeAllElements ( ) ; duplicate = "add" ; archiveType = "zip" ; doCompress = true ; emptyBehavior = "skip" ; doUpdate = false ; doFilesonly = false ; encoding = null ; } public static class Duplicate extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "add" , "preserve" , "fail" } ; } } } 	1	['34', '4', '1', '25', '138', '421', '3', '22', '17', '0.863636364', '1740', '1', '0', '0.709090909', '0.142045455', '4', '4', '49.64705882', '4', '1.1471', '2']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Environment ; import org . apache . tools . ant . util . StringUtils ; import java . io . File ; import java . io . FileOutputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . BufferedReader ; import java . io . StringReader ; import java . io . FileNotFoundException ; public class ExecTask extends Task { private String os ; private File out ; private File dir ; protected boolean failOnError = false ; protected boolean newEnvironment = false ; private Long timeout = null ; private Environment env = new Environment ( ) ; protected Commandline cmdl = new Commandline ( ) ; private FileOutputStream fos = null ; private ByteArrayOutputStream baos = null ; private String outputprop ; private String resultProperty ; private boolean failIfExecFails = true ; private boolean append = false ; private boolean vmLauncher = true ; public void setTimeout ( Long value ) { timeout = value ; } public void setTimeout ( Integer value ) { if ( value == null ) { timeout = null ; } else { setTimeout ( new Long ( value . intValue ( ) ) ) ; } } public void setExecutable ( String value ) { cmdl . setExecutable ( value ) ; } public void setDir ( File d ) { this . dir = d ; } public void setOs ( String os ) { this . os = os ; } public void setCommand ( Commandline cmdl ) { log ( "The command attribute is deprecated. " + "Please use the executable attribute and nested arg elements." , Project . MSG_WARN ) ; this . cmdl = cmdl ; } public void setOutput ( File out ) { this . out = out ; } public void setOutputproperty ( String outputprop ) { this . outputprop = outputprop ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } public void setNewenvironment ( boolean newenv ) { newEnvironment = newenv ; } public void addEnv ( Environment . Variable var ) { env . addVariable ( var ) ; } public Commandline . Argument createArg ( ) { return cmdl . createArgument ( ) ; } public void setResultProperty ( String resultProperty ) { this . resultProperty = resultProperty ; } protected void maybeSetResultPropertyValue ( int result ) { String res = Integer . toString ( result ) ; if ( resultProperty != null ) { project . setNewProperty ( resultProperty , res ) ; } } public void setFailIfExecutionFails ( boolean flag ) { failIfExecFails = flag ; } public void setAppend ( boolean append ) { this . append = append ; } public void execute ( ) throws BuildException { File savedDir = dir ; checkConfiguration ( ) ; if ( isValidOs ( ) ) { try { runExec ( prepareExec ( ) ) ; } finally { dir = savedDir ; } } } protected void checkConfiguration ( ) throws BuildException { if ( cmdl . getExecutable ( ) == null ) { throw new BuildException ( "no executable specified" , location ) ; } if ( dir != null && ! dir . exists ( ) ) { throw new BuildException ( "The directory you specified does not " + "exist" ) ; } if ( dir != null && ! dir . isDirectory ( ) ) { throw new BuildException ( "The directory you specified is not a " + "directory" ) ; } } protected boolean isValidOs ( ) { String myos = System . getProperty ( "os.name" ) ; log ( "Current OS is " + myos , Project . MSG_VERBOSE ) ; if ( ( os != null ) && ( os . indexOf ( myos ) < 0 ) ) { log ( "This OS, " + myos + " was not found in the specified list of valid OSes: " + os , Project . MSG_VERBOSE ) ; return false ; } return true ; } public void setVMLauncher ( boolean vmLauncher ) { this . vmLauncher = vmLauncher ; } protected Execute prepareExec ( ) throws BuildException { if ( dir == null ) { dir = project . getBaseDir ( ) ; } Execute exe = new Execute ( createHandler ( ) , createWatchdog ( ) ) ; exe . setAntRun ( getProject ( ) ) ; exe . setWorkingDirectory ( dir ) ; exe . setVMLauncher ( vmLauncher ) ; String [ ] environment = env . getVariables ( ) ; if ( environment != null ) { for ( int i = 0 ; i < environment . length ; i ++ ) { log ( "Setting environment variable: " + environment [ i ] , Project . MSG_VERBOSE ) ; } } exe . setNewenvironment ( newEnvironment ) ; exe . setEnvironment ( environment ) ; return exe ; } protected final void runExecute ( Execute exe ) throws IOException { int err = - 1 ; err = exe . execute ( ) ; if ( exe . killedProcess ( ) ) { log ( "Timeout: killed the sub-process" , Project . MSG_WARN ) ; } maybeSetResultPropertyValue ( err ) ; if ( err != 0 ) { if ( failOnError ) { throw new BuildException ( taskType + " returned: " + err , location ) ; } else { log ( "Result: " + err , Project . MSG_ERR ) ; } } if ( baos != null ) { BufferedReader in = new BufferedReader ( new StringReader ( Execute . toString ( baos ) ) ) ; String line = null ; StringBuffer val = new StringBuffer ( ) ; while ( ( line = in . readLine ( ) ) != null ) { if ( val . length ( ) != 0 ) { val . append ( StringUtils . LINE_SEP ) ; } val . append ( line ) ; } project . setNewProperty ( outputprop , val . toString ( ) ) ; } } protected void runExec ( Execute exe ) throws BuildException { log ( cmdl . describeCommand ( ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( cmdl . getCommandline ( ) ) ; try { runExecute ( exe ) ; } catch ( IOException e ) { if ( failIfExecFails ) { throw new BuildException ( "Execute failed: " + e . toString ( ) , e , location ) ; } else { log ( "Execute failed: " + e . toString ( ) , Project . MSG_ERR ) ; } } finally { logFlush ( ) ; } } protected ExecuteStreamHandler createHandler ( ) throws BuildException { if ( out != null ) { try { fos = new FileOutputStream ( out . getAbsolutePath ( ) , append ) ; log ( "Output redirected to " + out , Project . MSG_VERBOSE ) ; return new PumpStreamHandler ( fos ) ; } catch ( FileNotFoundException fne ) { throw new BuildException ( "Cannot write to " + out , fne , location ) ; } catch ( IOException ioe ) { throw new BuildException ( "Cannot write to " + out , ioe , location ) ; } } else if ( outputprop != null ) { baos = new ByteArrayOutputStream ( ) ; log ( "Output redirected to ByteArray" , Project . MSG_VERBOSE ) ; return new PumpStreamHandler ( baos ) ; } else { return new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) ; } } protected ExecuteWatchdog createWatchdog ( ) throws BuildException { if ( timeout == null ) { return null ; } return new ExecuteWatchdog ( timeout . longValue ( ) ) ; } protected void logFlush ( ) { try { if ( fos != null ) { fos . close ( ) ; } if ( baos != null ) { baos . close ( ) ; } } catch ( IOException io ) { } } } 	1	['27', '3', '1', '19', '80', '249', '4', '15', '18', '0.869230769', '607', '1', '2', '0.587301587', '0.166666667', '0', '0', '20.92592593', '3', '1.1481', '1']
package org . apache . tools . ant . taskdefs ; import java . lang . reflect . Method ; import java . io . File ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . taskdefs . optional . TraXLiaison ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . types . XMLCatalog ; import org . xml . sax . EntityResolver ; public class XSLTProcess extends MatchingTask implements XSLTLogger { private File destDir = null ; private File baseDir = null ; private String xslFile = null ; private String targetExtension = ".html" ; private Vector params = new Vector ( ) ; private File inFile = null ; private File outFile = null ; private String processor ; private Path classpath = null ; private XSLTLiaison liaison ; private boolean stylesheetLoaded = false ; private boolean force = false ; private FileUtils fileUtils ; private Vector outputProperties = new Vector ( ) ; private XMLCatalog xmlCatalog = new XMLCatalog ( ) ; private static final String TRAX_LIAISON_CLASS = "org.apache.tools.ant.taskdefs.optional.TraXLiaison" ; private static final String XSLP_LIAISON_CLASS = "org.apache.tools.ant.taskdefs.optional.XslpLiaison" ; private static final String XALAN_LIAISON_CLASS = "org.apache.tools.ant.taskdefs.optional.XalanLiaison" ; private boolean performDirectoryScan = true ; public XSLTProcess ( ) { fileUtils = FileUtils . newFileUtils ( ) ; } public void setScanIncludedDirectories ( boolean b ) { performDirectoryScan = b ; } public void execute ( ) throws BuildException { File savedBaseDir = baseDir ; DirectoryScanner scanner ; String [ ] list ; String [ ] dirs ; if ( xslFile == null ) { throw new BuildException ( "no stylesheet specified" , location ) ; } try { if ( baseDir == null ) { baseDir = project . resolveFile ( "." ) ; } liaison = getLiaison ( ) ; if ( liaison instanceof XSLTLoggerAware ) { ( ( XSLTLoggerAware ) liaison ) . setLogger ( this ) ; } log ( "Using " + liaison . getClass ( ) . toString ( ) , Project . MSG_VERBOSE ) ; File stylesheet = project . resolveFile ( xslFile ) ; if ( ! stylesheet . exists ( ) ) { stylesheet = fileUtils . resolveFile ( baseDir , xslFile ) ; if ( stylesheet . exists ( ) ) { log ( "DEPRECATED - the style attribute should be relative " + "to the project\'s" ) ; log ( "             basedir, not the tasks\'s basedir." ) ; } } if ( inFile != null && outFile != null ) { process ( inFile , outFile , stylesheet ) ; return ; } if ( destDir == null ) { String msg = "destdir attributes must be set!" ; throw new BuildException ( msg ) ; } scanner = getDirectoryScanner ( baseDir ) ; log ( "Transforming into " + destDir , Project . MSG_INFO ) ; list = scanner . getIncludedFiles ( ) ; for ( int i = 0 ; i < list . length ; ++ i ) { process ( baseDir , list [ i ] , destDir , stylesheet ) ; } if ( performDirectoryScan ) { dirs = scanner . getIncludedDirectories ( ) ; for ( int j = 0 ; j < dirs . length ; ++ j ) { list = new File ( baseDir , dirs [ j ] ) . list ( ) ; for ( int i = 0 ; i < list . length ; ++ i ) { process ( baseDir , list [ i ] , destDir , stylesheet ) ; } } } } finally { liaison = null ; stylesheetLoaded = false ; baseDir = savedBaseDir ; } } public void setForce ( boolean force ) { this . force = force ; } public void setBasedir ( File dir ) { baseDir = dir ; } public void setDestdir ( File dir ) { destDir = dir ; } public void setExtension ( String name ) { targetExtension = name ; } public void setStyle ( String xslFile ) { this . xslFile = xslFile ; } public void setClasspath ( Path classpath ) { createClasspath ( ) . append ( classpath ) ; } public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( project ) ; } return classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setProcessor ( String processor ) { this . processor = processor ; } public void addConfiguredXMLCatalog ( XMLCatalog xmlCatalog ) { this . xmlCatalog . addConfiguredXMLCatalog ( xmlCatalog ) ; } private void resolveProcessor ( String proc ) throws Exception { if ( proc . equals ( "trax" ) ) { final Class clazz = loadClass ( TRAX_LIAISON_CLASS ) ; liaison = ( XSLTLiaison ) clazz . newInstance ( ) ; } else if ( proc . equals ( "xslp" ) ) { log ( "DEPRECATED - xslp processor is deprecated. Use trax or " + "xalan instead." ) ; final Class clazz = loadClass ( XSLP_LIAISON_CLASS ) ; liaison = ( XSLTLiaison ) clazz . newInstance ( ) ; } else if ( proc . equals ( "xalan" ) ) { final Class clazz = loadClass ( XALAN_LIAISON_CLASS ) ; liaison = ( XSLTLiaison ) clazz . newInstance ( ) ; } else { liaison = ( XSLTLiaison ) loadClass ( proc ) . newInstance ( ) ; } } private Class loadClass ( String classname ) throws Exception { if ( classpath == null ) { return Class . forName ( classname ) ; } else { AntClassLoader al = new AntClassLoader ( project , classpath ) ; Class c = al . loadClass ( classname ) ; AntClassLoader . initializeClass ( c ) ; return c ; } } public void setOut ( File outFile ) { this . outFile = outFile ; } public void setIn ( File inFile ) { this . inFile = inFile ; } private void process ( File baseDir , String xmlFile , File destDir , File stylesheet ) throws BuildException { String fileExt = targetExtension ; File outFile = null ; File inFile = null ; try { long styleSheetLastModified = stylesheet . lastModified ( ) ; inFile = new File ( baseDir , xmlFile ) ; if ( inFile . isDirectory ( ) ) { log ( "Skipping " + inFile + " it is a directory." , Project . MSG_VERBOSE ) ; return ; } int dotPos = xmlFile . lastIndexOf ( '.' ) ; if ( dotPos > 0 ) { outFile = new File ( destDir , xmlFile . substring ( 0 , xmlFile . lastIndexOf ( '.' ) ) + fileExt ) ; } else { outFile = new File ( destDir , xmlFile + fileExt ) ; } if ( force || inFile . lastModified ( ) > outFile . lastModified ( ) || styleSheetLastModified > outFile . lastModified ( ) ) { ensureDirectoryFor ( outFile ) ; log ( "Processing " + inFile + " to " + outFile ) ; configureLiaison ( stylesheet ) ; liaison . transform ( inFile , outFile ) ; } } catch ( Exception ex ) { log ( "Failed to process " + inFile , Project . MSG_INFO ) ; if ( outFile != null ) { outFile . delete ( ) ; } throw new BuildException ( ex ) ; } } private void process ( File inFile , File outFile , File stylesheet ) throws BuildException { try { long styleSheetLastModified = stylesheet . lastModified ( ) ; log ( "In file " + inFile + " time: " + inFile . lastModified ( ) , Project . MSG_DEBUG ) ; log ( "Out file " + outFile + " time: " + outFile . lastModified ( ) , Project . MSG_DEBUG ) ; log ( "Style file " + xslFile + " time: " + styleSheetLastModified , Project . MSG_DEBUG ) ; if ( force || inFile . lastModified ( ) > outFile . lastModified ( ) || styleSheetLastModified > outFile . lastModified ( ) ) { ensureDirectoryFor ( outFile ) ; log ( "Processing " + inFile + " to " + outFile , Project . MSG_INFO ) ; configureLiaison ( stylesheet ) ; liaison . transform ( inFile , outFile ) ; } } catch ( Exception ex ) { log ( "Failed to process " + inFile , Project . MSG_INFO ) ; if ( outFile != null ) { outFile . delete ( ) ; } throw new BuildException ( ex ) ; } } private void ensureDirectoryFor ( File targetFile ) throws BuildException { File directory = fileUtils . getParentFile ( targetFile ) ; if ( ! directory . exists ( ) ) { if ( ! directory . mkdirs ( ) ) { throw new BuildException ( "Unable to create directory: " + directory . getAbsolutePath ( ) ) ; } } } protected XSLTLiaison getLiaison ( ) { if ( liaison == null ) { if ( processor != null ) { try { resolveProcessor ( processor ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } else { try { resolveProcessor ( "trax" ) ; } catch ( Throwable e1 ) { try { resolveProcessor ( "xalan" ) ; } catch ( Throwable e2 ) { try { resolveProcessor ( "xslp" ) ; } catch ( Throwable e3 ) { e3 . printStackTrace ( ) ; e2 . printStackTrace ( ) ; throw new BuildException ( e1 ) ; } } } } } return liaison ; } public Param createParam ( ) { Param p = new Param ( ) ; params . addElement ( p ) ; return p ; } public class Param { private String name = null ; private String expression = null ; public void setName ( String name ) { this . name = name ; } public void setExpression ( String expression ) { this . expression = expression ; } public String getName ( ) throws BuildException { if ( name == null ) { throw new BuildException ( "Name attribute is missing." ) ; } return name ; } public String getExpression ( ) throws BuildException { if ( expression == null ) { throw new BuildException ( "Expression attribute is missing." ) ; } return expression ; } } public OutputProperty createOutputProperty ( ) { OutputProperty p = new OutputProperty ( ) ; outputProperties . addElement ( p ) ; return p ; } public static class OutputProperty { private String name ; private String value ; public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } } public void init ( ) throws BuildException { super . init ( ) ; xmlCatalog . setProject ( project ) ; } protected void configureLiaison ( File stylesheet ) throws BuildException { if ( stylesheetLoaded ) { return ; } stylesheetLoaded = true ; try { log ( "Loading stylesheet " + stylesheet , Project . MSG_INFO ) ; liaison . setStylesheet ( stylesheet ) ; for ( Enumeration e = params . elements ( ) ; e . hasMoreElements ( ) ; ) { Param p = ( Param ) e . nextElement ( ) ; liaison . addParam ( p . getName ( ) , p . getExpression ( ) ) ; } if ( liaison instanceof TraXLiaison ) { configureTraXLiaison ( ( TraXLiaison ) liaison ) ; } } catch ( Exception ex ) { log ( "Failed to transform using stylesheet " + stylesheet , Project . MSG_INFO ) ; throw new BuildException ( ex ) ; } } protected void configureTraXLiaison ( TraXLiaison liaison ) { if ( xmlCatalog != null ) { liaison . setEntityResolver ( xmlCatalog ) ; liaison . setURIResolver ( xmlCatalog ) ; } for ( Enumeration props = outputProperties . elements ( ) ; props . hasMoreElements ( ) ; ) { OutputProperty prop = ( OutputProperty ) props . nextElement ( ) ; liaison . setOutputProperty ( prop . getName ( ) , prop . getValue ( ) ) ; } } } 	1	['26', '4', '0', '18', '89', '219', '1', '18', '18', '0.896842105', '881', '1', '4', '0.757281553', '0.221153846', '3', '4', '32.15384615', '3', '1.1538', '1']
package org . apache . tools . ant . types ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import java . util . Stack ; public class ZipFileSet extends FileSet { private File srcFile = null ; private String prefix = "" ; private String fullpath = "" ; private boolean hasDir = false ; public ZipFileSet ( ) { super ( ) ; } protected ZipFileSet ( FileSet fileset ) { super ( fileset ) ; } public void setDir ( File dir ) throws BuildException { if ( srcFile != null ) { throw new BuildException ( "Cannot set both dir and src attributes" ) ; } else { super . setDir ( dir ) ; hasDir = true ; } } public void setSrc ( File srcFile ) { if ( hasDir ) { throw new BuildException ( "Cannot set both dir and src attributes" ) ; } this . srcFile = srcFile ; } public File getSrc ( ) { return srcFile ; } public void setPrefix ( String prefix ) { this . prefix = prefix ; } public String getPrefix ( ) { return prefix ; } public void setFullpath ( String fullpath ) { this . fullpath = fullpath ; } public String getFullpath ( ) { return fullpath ; } public DirectoryScanner getDirectoryScanner ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getDirectoryScanner ( p ) ; } if ( srcFile != null ) { ZipScanner zs = new ZipScanner ( ) ; zs . setSrc ( srcFile ) ; super . setDir ( p . getBaseDir ( ) ) ; setupDirectoryScanner ( zs , p ) ; zs . init ( ) ; return zs ; } else { return super . getDirectoryScanner ( p ) ; } } protected AbstractFileSet getRef ( Project p ) { if ( ! checked ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , p ) ; } Object o = ref . getReferencedObject ( p ) ; if ( ! ( o instanceof FileSet ) ) { String msg = ref . getRefId ( ) + " doesn\'t denote a fileset" ; throw new BuildException ( msg ) ; } else { return ( AbstractFileSet ) o ; } } } 	1	['11', '5', '0', '13', '30', '5', '4', '9', '9', '0.65', '168', '1', '0', '0.91', '0.327272727', '2', '10', '13.90909091', '3', '1.2727', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . BuildListener ; import org . apache . tools . ant . DefaultLogger ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . util . FileUtils ; import java . io . File ; import java . io . PrintStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . lang . reflect . Method ; import java . util . Vector ; import java . util . Hashtable ; import java . util . Enumeration ; public class Ant extends Task { private File dir = null ; private String antFile = null ; private String target = null ; private String output = null ; private boolean inheritAll = true ; private boolean inheritRefs = false ; private Vector properties = new Vector ( ) ; private Vector references = new Vector ( ) ; private Project newProject ; private PrintStream out = null ; public void setInheritAll ( boolean value ) { inheritAll = value ; } public void setInheritRefs ( boolean value ) { inheritRefs = value ; } public void init ( ) { newProject = new Project ( ) ; newProject . setJavaVersionProperty ( ) ; newProject . addTaskDefinition ( "property" , ( Class ) project . getTaskDefinitions ( ) . get ( "property" ) ) ; } private void reinit ( ) { init ( ) ; final int count = properties . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { Property p = ( Property ) properties . elementAt ( i ) ; Property newP = ( Property ) newProject . createTask ( "property" ) ; newP . setName ( p . getName ( ) ) ; if ( p . getValue ( ) != null ) { newP . setValue ( p . getValue ( ) ) ; } if ( p . getFile ( ) != null ) { newP . setFile ( p . getFile ( ) ) ; } if ( p . getResource ( ) != null ) { newP . setResource ( p . getResource ( ) ) ; } if ( p . getPrefix ( ) != null ) { newP . setPrefix ( p . getPrefix ( ) ) ; } if ( p . getRefid ( ) != null ) { newP . setRefid ( p . getRefid ( ) ) ; } if ( p . getEnvironment ( ) != null ) { newP . setEnvironment ( p . getEnvironment ( ) ) ; } if ( p . getClasspath ( ) != null ) { newP . setClasspath ( p . getClasspath ( ) ) ; } properties . setElementAt ( newP , i ) ; } } private void initializeProject ( ) { newProject . setInputHandler ( getProject ( ) . getInputHandler ( ) ) ; Vector listeners = project . getBuildListeners ( ) ; final int count = listeners . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { newProject . addBuildListener ( ( BuildListener ) listeners . elementAt ( i ) ) ; } if ( output != null ) { File outfile = null ; if ( dir != null ) { outfile = FileUtils . newFileUtils ( ) . resolveFile ( dir , output ) ; } else { outfile = getProject ( ) . resolveFile ( output ) ; } try { out = new PrintStream ( new FileOutputStream ( outfile ) ) ; DefaultLogger logger = new DefaultLogger ( ) ; logger . setMessageOutputLevel ( Project . MSG_INFO ) ; logger . setOutputPrintStream ( out ) ; logger . setErrorPrintStream ( out ) ; newProject . addBuildListener ( logger ) ; } catch ( IOException ex ) { log ( "Ant: Can't set output to " + output ) ; } } Hashtable taskdefs = project . getTaskDefinitions ( ) ; Enumeration et = taskdefs . keys ( ) ; while ( et . hasMoreElements ( ) ) { String taskName = ( String ) et . nextElement ( ) ; if ( taskName . equals ( "property" ) ) { continue ; } Class taskClass = ( Class ) taskdefs . get ( taskName ) ; newProject . addTaskDefinition ( taskName , taskClass ) ; } Hashtable typedefs = project . getDataTypeDefinitions ( ) ; Enumeration e = typedefs . keys ( ) ; while ( e . hasMoreElements ( ) ) { String typeName = ( String ) e . nextElement ( ) ; Class typeClass = ( Class ) typedefs . get ( typeName ) ; newProject . addDataTypeDefinition ( typeName , typeClass ) ; } getProject ( ) . copyUserProperties ( newProject ) ; if ( ! inheritAll ) { newProject . setSystemProperties ( ) ; } else { Hashtable props = getProject ( ) . getProperties ( ) ; e = props . keys ( ) ; while ( e . hasMoreElements ( ) ) { String arg = e . nextElement ( ) . toString ( ) ; if ( "basedir" . equals ( arg ) || "ant.file" . equals ( arg ) ) { continue ; } String value = props . get ( arg ) . toString ( ) ; if ( newProject . getProperty ( arg ) == null ) { newProject . setNewProperty ( arg , value ) ; } } } } protected void handleOutput ( String line ) { if ( newProject != null ) { newProject . demuxOutput ( line , false ) ; } else { super . handleOutput ( line ) ; } } protected void handleErrorOutput ( String line ) { if ( newProject != null ) { newProject . demuxOutput ( line , true ) ; } else { super . handleErrorOutput ( line ) ; } } public void execute ( ) throws BuildException { File savedDir = dir ; String savedAntFile = antFile ; String savedTarget = target ; try { if ( newProject == null ) { reinit ( ) ; } if ( ( dir == null ) && ( inheritAll ) ) { dir = project . getBaseDir ( ) ; } initializeProject ( ) ; if ( dir != null ) { newProject . setBaseDir ( dir ) ; if ( savedDir != null ) { newProject . setInheritedProperty ( "basedir" , dir . getAbsolutePath ( ) ) ; } } else { dir = project . getBaseDir ( ) ; } overrideProperties ( ) ; if ( antFile == null ) { antFile = "build.xml" ; } File file = FileUtils . newFileUtils ( ) . resolveFile ( dir , antFile ) ; antFile = file . getAbsolutePath ( ) ; log ( "calling target " + ( target != null ? target : "[default]" ) + " in build file " + antFile . toString ( ) , Project . MSG_VERBOSE ) ; newProject . setUserProperty ( "ant.file" , antFile ) ; ProjectHelper . configureProject ( newProject , new File ( antFile ) ) ; if ( target == null ) { target = newProject . getDefaultTarget ( ) ; } addReferences ( ) ; if ( newProject . getBaseDir ( ) . equals ( project . getBaseDir ( ) ) && newProject . getProperty ( "ant.file" ) . equals ( project . getProperty ( "ant.file" ) ) && getOwningTarget ( ) != null && target . equals ( this . getOwningTarget ( ) . getName ( ) ) ) { throw new BuildException ( "ant task calling its own parent " + "target" ) ; } newProject . executeTarget ( target ) ; } finally { newProject = null ; if ( output != null && out != null ) { try { out . close ( ) ; } catch ( final Exception e ) { } } dir = savedDir ; antFile = savedAntFile ; target = savedTarget ; } } private void overrideProperties ( ) throws BuildException { Enumeration e = properties . elements ( ) ; while ( e . hasMoreElements ( ) ) { Property p = ( Property ) e . nextElement ( ) ; p . setProject ( newProject ) ; p . execute ( ) ; } getProject ( ) . copyInheritedProperties ( newProject ) ; } private void addReferences ( ) throws BuildException { Hashtable thisReferences = ( Hashtable ) project . getReferences ( ) . clone ( ) ; Hashtable newReferences = newProject . getReferences ( ) ; Enumeration e ; if ( references . size ( ) > 0 ) { for ( e = references . elements ( ) ; e . hasMoreElements ( ) ; ) { Reference ref = ( Reference ) e . nextElement ( ) ; String refid = ref . getRefId ( ) ; if ( refid == null ) { throw new BuildException ( "the refid attribute is required" + " for reference elements" ) ; } if ( ! thisReferences . containsKey ( refid ) ) { log ( "Parent project doesn't contain any reference '" + refid + "'" , Project . MSG_WARN ) ; continue ; } thisReferences . remove ( refid ) ; String toRefid = ref . getToRefid ( ) ; if ( toRefid == null ) { toRefid = refid ; } copyReference ( refid , toRefid ) ; } } if ( inheritRefs ) { for ( e = thisReferences . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; if ( newReferences . containsKey ( key ) ) { continue ; } copyReference ( key , key ) ; } } } private void copyReference ( String oldKey , String newKey ) { Object orig = project . getReference ( oldKey ) ; Class c = orig . getClass ( ) ; Object copy = orig ; try { Method cloneM = c . getMethod ( "clone" , new Class [ 0 ] ) ; if ( cloneM != null ) { copy = cloneM . invoke ( orig , new Object [ 0 ] ) ; } } catch ( Exception e ) { } if ( copy instanceof ProjectComponent ) { ( ( ProjectComponent ) copy ) . setProject ( newProject ) ; } else { try { Method setProjectM = c . getMethod ( "setProject" , new Class [ ] { Project . class } ) ; if ( setProjectM != null ) { setProjectM . invoke ( copy , new Object [ ] { newProject } ) ; } } catch ( NoSuchMethodException e ) { } catch ( Exception e2 ) { String msg = "Error setting new project instance for " + "reference with id " + oldKey ; throw new BuildException ( msg , e2 , location ) ; } } newProject . addReference ( newKey , copy ) ; } public void setDir ( File d ) { this . dir = d ; } public void setAntfile ( String s ) { this . antFile = s ; } public void setTarget ( String s ) { this . target = s ; } public void setOutput ( String s ) { this . output = s ; } public Property createProperty ( ) { if ( newProject == null ) { reinit ( ) ; } Property p = new Property ( true , getProject ( ) ) ; p . setProject ( newProject ) ; p . setTaskName ( "property" ) ; properties . addElement ( p ) ; return p ; } public void addReference ( Reference r ) { references . addElement ( r ) ; } public static class Reference extends org . apache . tools . ant . types . Reference { public Reference ( ) { super ( ) ; } private String targetid = null ; public void setToRefid ( String targetid ) { this . targetid = targetid ; } public String getToRefid ( ) { return targetid ; } } } 	1	['19', '3', '0', '16', '117', '35', '1', '15', '11', '0.823232323', '849', '0.909090909', '1', '0.672727273', '0.305263158', '2', '3', '43.10526316', '12', '2.2105', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; import java . io . File ; import java . io . PrintStream ; import java . io . BufferedOutputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . Reader ; import java . io . BufferedReader ; import java . io . StringReader ; import java . io . FileReader ; import java . io . InputStreamReader ; import java . io . FileInputStream ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . util . Vector ; import java . sql . Connection ; import java . sql . Statement ; import java . sql . SQLException ; import java . sql . SQLWarning ; import java . sql . ResultSet ; import java . sql . ResultSetMetaData ; public class SQLExec extends JDBCTask { public static class DelimiterType extends EnumeratedAttribute { public static final String NORMAL = "normal" ; public static final String ROW = "row" ; public String [ ] getValues ( ) { return new String [ ] { NORMAL , ROW } ; } } private int goodSql = 0 ; private int totalSql = 0 ; private Connection conn = null ; private Vector filesets = new Vector ( ) ; private Statement statement = null ; private File srcFile = null ; private String sqlCommand = "" ; private Vector transactions = new Vector ( ) ; private String delimiter = ";" ; private String delimiterType = DelimiterType . NORMAL ; private boolean print = false ; private boolean showheaders = true ; private File output = null ; private String onError = "abort" ; private String encoding = null ; private boolean append = false ; public void setSrc ( File srcFile ) { this . srcFile = srcFile ; } public void addText ( String sql ) { this . sqlCommand += sql ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public Transaction createTransaction ( ) { Transaction t = new Transaction ( ) ; transactions . addElement ( t ) ; return t ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public void setDelimiter ( String delimiter ) { this . delimiter = delimiter ; } public void setDelimiterType ( DelimiterType delimiterType ) { this . delimiterType = delimiterType . getValue ( ) ; } public void setPrint ( boolean print ) { this . print = print ; } public void setShowheaders ( boolean showheaders ) { this . showheaders = showheaders ; } public void setOutput ( File output ) { this . output = output ; } public void setAppend ( boolean append ) { this . append = append ; } public void setOnerror ( OnError action ) { this . onError = action . getValue ( ) ; } public void execute ( ) throws BuildException { Vector savedTransaction = ( Vector ) transactions . clone ( ) ; String savedSqlCommand = sqlCommand ; sqlCommand = sqlCommand . trim ( ) ; try { if ( srcFile == null && sqlCommand . length ( ) == 0 && filesets . isEmpty ( ) ) { if ( transactions . size ( ) == 0 ) { throw new BuildException ( "Source file or fileset, " + "transactions or sql statement " + "must be set!" , location ) ; } } if ( srcFile != null && ! srcFile . exists ( ) ) { throw new BuildException ( "Source file does not exist!" , location ) ; } for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; File srcDir = fs . getDir ( project ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; for ( int j = 0 ; j < srcFiles . length ; j ++ ) { Transaction t = createTransaction ( ) ; t . setSrc ( new File ( srcDir , srcFiles [ j ] ) ) ; } } Transaction t = createTransaction ( ) ; t . setSrc ( srcFile ) ; t . addText ( sqlCommand ) ; conn = getConnection ( ) ; if ( ! isValidRdbms ( conn ) ) { return ; } try { statement = conn . createStatement ( ) ; PrintStream out = System . out ; try { if ( output != null ) { log ( "Opening PrintStream to output file " + output , Project . MSG_VERBOSE ) ; out = new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( output . getAbsolutePath ( ) , append ) ) ) ; } for ( Enumeration e = transactions . elements ( ) ; e . hasMoreElements ( ) ; ) { ( ( Transaction ) e . nextElement ( ) ) . runTransaction ( out ) ; if ( ! isAutocommit ( ) ) { log ( "Commiting transaction" , Project . MSG_VERBOSE ) ; conn . commit ( ) ; } } } finally { if ( out != null && out != System . out ) { out . close ( ) ; } } } catch ( IOException e ) { if ( ! isAutocommit ( ) && conn != null && onError . equals ( "abort" ) ) { try { conn . rollback ( ) ; } catch ( SQLException ex ) { } } throw new BuildException ( e , location ) ; } catch ( SQLException e ) { if ( ! isAutocommit ( ) && conn != null && onError . equals ( "abort" ) ) { try { conn . rollback ( ) ; } catch ( SQLException ex ) { } } throw new BuildException ( e , location ) ; } finally { try { if ( statement != null ) { statement . close ( ) ; } if ( conn != null ) { conn . close ( ) ; } } catch ( SQLException e ) { } } log ( goodSql + " of " + totalSql + " SQL statements executed successfully" ) ; } finally { transactions = savedTransaction ; sqlCommand = savedSqlCommand ; } } protected void runStatements ( Reader reader , PrintStream out ) throws SQLException , IOException { String sql = "" ; String line = "" ; BufferedReader in = new BufferedReader ( reader ) ; while ( ( line = in . readLine ( ) ) != null ) { line = line . trim ( ) ; line = project . replaceProperties ( line ) ; if ( line . startsWith ( "//" ) ) { continue ; } if ( line . startsWith ( "--" ) ) { continue ; } StringTokenizer st = new StringTokenizer ( line ) ; if ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) ; if ( "REM" . equalsIgnoreCase ( token ) ) { continue ; } } sql += " " + line ; sql = sql . trim ( ) ; if ( line . indexOf ( "--" ) >= 0 ) { sql += "\n" ; } if ( ( delimiterType . equals ( DelimiterType . NORMAL ) && sql . endsWith ( delimiter ) ) || ( delimiterType . equals ( DelimiterType . ROW ) && line . equals ( delimiter ) ) ) { log ( "SQL: " + sql , Project . MSG_VERBOSE ) ; execSQL ( sql . substring ( 0 , sql . length ( ) - delimiter . length ( ) ) , out ) ; sql = "" ; } } if ( ! sql . equals ( "" ) ) { execSQL ( sql , out ) ; } } protected void execSQL ( String sql , PrintStream out ) throws SQLException { if ( "" . equals ( sql . trim ( ) ) ) { return ; } try { totalSql ++ ; if ( ! statement . execute ( sql ) ) { log ( statement . getUpdateCount ( ) + " rows affected" , Project . MSG_VERBOSE ) ; } else { if ( print ) { printResults ( out ) ; } } SQLWarning warning = conn . getWarnings ( ) ; while ( warning != null ) { log ( warning + " sql warning" , Project . MSG_VERBOSE ) ; warning = warning . getNextWarning ( ) ; } conn . clearWarnings ( ) ; goodSql ++ ; } catch ( SQLException e ) { log ( "Failed to execute: " + sql , Project . MSG_ERR ) ; if ( ! onError . equals ( "continue" ) ) { throw e ; } log ( e . toString ( ) , Project . MSG_ERR ) ; } } protected void printResults ( PrintStream out ) throws java . sql . SQLException { ResultSet rs = null ; do { rs = statement . getResultSet ( ) ; if ( rs != null ) { log ( "Processing new result set." , Project . MSG_VERBOSE ) ; ResultSetMetaData md = rs . getMetaData ( ) ; int columnCount = md . getColumnCount ( ) ; StringBuffer line = new StringBuffer ( ) ; if ( showheaders ) { for ( int col = 1 ; col < columnCount ; col ++ ) { line . append ( md . getColumnName ( col ) ) ; line . append ( "," ) ; } line . append ( md . getColumnName ( columnCount ) ) ; out . println ( line ) ; line . setLength ( 0 ) ; } while ( rs . next ( ) ) { boolean first = true ; for ( int col = 1 ; col <= columnCount ; col ++ ) { String columnValue = rs . getString ( col ) ; if ( columnValue != null ) { columnValue = columnValue . trim ( ) ; } if ( first ) { first = false ; } else { line . append ( "," ) ; } line . append ( columnValue ) ; } out . println ( line ) ; line . setLength ( 0 ) ; } } } while ( statement . getMoreResults ( ) ) ; out . println ( ) ; } public static class OnError extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "continue" , "stop" , "abort" } ; } } public class Transaction { private File tSrcFile = null ; private String tSqlCommand = "" ; public void setSrc ( File src ) { this . tSrcFile = src ; } public void addText ( String sql ) { this . tSqlCommand += sql ; } private void runTransaction ( PrintStream out ) throws IOException , SQLException { if ( tSqlCommand . length ( ) != 0 ) { log ( "Executing commands" , Project . MSG_INFO ) ; runStatements ( new StringReader ( tSqlCommand ) , out ) ; } if ( tSrcFile != null ) { log ( "Executing file: " + tSrcFile . getAbsolutePath ( ) , Project . MSG_INFO ) ; Reader reader = ( encoding == null ) ? new FileReader ( tSrcFile ) : new InputStreamReader ( new FileInputStream ( tSrcFile ) , encoding ) ; try { runStatements ( reader , out ) ; } finally { reader . close ( ) ; } } } } } 	1	['18', '4', '0', '13', '90', '87', '1', '13', '14', '0.849264706', '778', '1', '0', '0.782051282', '0.188888889', '4', '4', '41.33333333', '1', '0.9444', '1']
package org . apache . tools . ant . types ; import java . io . File ; import java . io . FileInputStream ; import java . io . InputStream ; import java . io . IOException ; import java . io . FileNotFoundException ; import java . net . URL ; import java . net . MalformedURLException ; import java . util . Enumeration ; import java . util . Stack ; import java . util . Vector ; import javax . xml . transform . Source ; import javax . xml . transform . TransformerException ; import javax . xml . transform . URIResolver ; import javax . xml . transform . sax . SAXSource ; import javax . xml . parsers . SAXParserFactory ; import javax . xml . parsers . ParserConfigurationException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . util . FileUtils ; import org . xml . sax . EntityResolver ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; public class XMLCatalog extends DataType implements Cloneable , EntityResolver , URIResolver { private FileUtils fileUtils = FileUtils . newFileUtils ( ) ; private Vector elements = new Vector ( ) ; private Path classpath ; public XMLCatalog ( ) { checked = false ; } private Vector getElements ( ) { return elements ; } private Path getClasspath ( ) { return classpath ; } private void setElements ( Vector aVector ) { elements = aVector ; } public Path createClasspath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } checked = false ; return this . classpath . createPath ( ) ; } public void setClasspath ( Path classpath ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } checked = false ; } public void setClasspathRef ( Reference r ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createClasspath ( ) . setRefid ( r ) ; checked = false ; } public void addDTD ( DTDLocation dtd ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } getElements ( ) . addElement ( dtd ) ; checked = false ; } public void addEntity ( DTDLocation dtd ) throws BuildException { addDTD ( dtd ) ; } public void addConfiguredXMLCatalog ( XMLCatalog catalog ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } Vector newElements = catalog . getElements ( ) ; Vector ourElements = getElements ( ) ; Enumeration enum = newElements . elements ( ) ; while ( enum . hasMoreElements ( ) ) { ourElements . addElement ( enum . nextElement ( ) ) ; } Path nestedClasspath = catalog . getClasspath ( ) ; createClasspath ( ) . append ( nestedClasspath ) ; checked = false ; } public void setRefid ( Reference r ) throws BuildException { if ( ! elements . isEmpty ( ) ) { throw tooManyAttributes ( ) ; } Object o = r . getReferencedObject ( getProject ( ) ) ; if ( o instanceof XMLCatalog ) { XMLCatalog catalog = ( XMLCatalog ) o ; setElements ( catalog . getElements ( ) ) ; } else { String msg = r . getRefId ( ) + " does not refer to an XMLCatalog" ; throw new BuildException ( msg ) ; } super . setRefid ( r ) ; } public InputSource resolveEntity ( String publicId , String systemId ) throws SAXException , IOException { if ( ! checked ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , getProject ( ) ) ; } log ( "resolveEntity: '" + publicId + "': '" + systemId + "'" , Project . MSG_DEBUG ) ; InputSource inputSource = resolveEntityImpl ( publicId , systemId ) ; if ( inputSource == null ) { log ( "No matching catalog entry found, parser will use: '" + systemId + "'" , Project . MSG_DEBUG ) ; } return inputSource ; } public Source resolve ( String href , String base ) throws TransformerException { if ( ! checked ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , getProject ( ) ) ; } SAXSource source = null ; String uri = removeFragment ( href ) ; log ( "resolve: '" + uri + "' with base: '" + base + "'" , Project . MSG_DEBUG ) ; source = resolveImpl ( uri , base ) ; if ( source == null ) { log ( "No matching catalog entry found, parser will use: '" + href + "'" , Project . MSG_DEBUG ) ; source = new SAXSource ( ) ; try { URL baseURL = new URL ( base ) ; URL url = ( uri . length ( ) == 0 ? baseURL : new URL ( baseURL , uri ) ) ; source . setInputSource ( new InputSource ( url . toString ( ) ) ) ; } catch ( MalformedURLException ex ) { source . setInputSource ( new InputSource ( uri ) ) ; } } setEntityResolver ( source ) ; return source ; } private DTDLocation findMatchingEntry ( String publicId ) { Enumeration elements = getElements ( ) . elements ( ) ; DTDLocation element = null ; while ( elements . hasMoreElements ( ) ) { element = ( DTDLocation ) elements . nextElement ( ) ; if ( element . getPublicId ( ) . equals ( publicId ) ) { return element ; } } return null ; } private void setEntityResolver ( SAXSource source ) throws TransformerException { XMLReader reader = source . getXMLReader ( ) ; if ( reader == null ) { SAXParserFactory spFactory = SAXParserFactory . newInstance ( ) ; spFactory . setNamespaceAware ( true ) ; try { reader = spFactory . newSAXParser ( ) . getXMLReader ( ) ; } catch ( ParserConfigurationException ex ) { throw new TransformerException ( ex ) ; } catch ( SAXException ex ) { throw new TransformerException ( ex ) ; } } reader . setEntityResolver ( this ) ; source . setXMLReader ( reader ) ; } private String removeFragment ( String uri ) { String result = uri ; String fragment = null ; int hashPos = uri . indexOf ( "#" ) ; if ( hashPos >= 0 ) { result = uri . substring ( 0 , hashPos ) ; fragment = uri . substring ( hashPos + 1 ) ; } return result ; } private InputSource filesystemLookup ( DTDLocation matchingEntry ) { String uri = matchingEntry . getLocation ( ) ; File resFile = project . resolveFile ( uri ) ; InputSource source = null ; if ( resFile . exists ( ) && resFile . canRead ( ) ) { try { source = new InputSource ( new FileInputStream ( resFile ) ) ; URL resFileURL = fileUtils . getFileURL ( resFile ) ; String sysid = resFileURL . toExternalForm ( ) ; source . setSystemId ( sysid ) ; log ( "catalog entry matched a readable file: '" + sysid + "'" , Project . MSG_DEBUG ) ; } catch ( FileNotFoundException ex ) { } catch ( MalformedURLException ex ) { } catch ( IOException ex ) { } } return source ; } private InputSource classpathLookup ( DTDLocation matchingEntry ) { InputSource source = null ; AntClassLoader loader = null ; if ( classpath != null ) { loader = new AntClassLoader ( project , classpath ) ; } else { loader = new AntClassLoader ( project , Path . systemClasspath ) ; } InputStream is = loader . getResourceAsStream ( matchingEntry . getLocation ( ) ) ; if ( is != null ) { source = new InputSource ( is ) ; URL entryURL = loader . getResource ( matchingEntry . getLocation ( ) ) ; String sysid = entryURL . toExternalForm ( ) ; source . setSystemId ( sysid ) ; log ( "catalog entry matched a resource in the classpath: '" + sysid + "'" , Project . MSG_DEBUG ) ; } return source ; } private InputSource urlLookup ( String uri , String base ) { InputSource source = null ; URL url = null ; try { if ( base == null ) { url = new URL ( uri ) ; } else { URL baseURL = new URL ( base ) ; url = ( uri . length ( ) == 0 ? baseURL : new URL ( baseURL , uri ) ) ; } } catch ( MalformedURLException ex ) { } if ( url != null ) { try { InputStream is = url . openStream ( ) ; if ( is != null ) { source = new InputSource ( is ) ; String sysid = url . toExternalForm ( ) ; source . setSystemId ( sysid ) ; log ( "catalog entry matched as a URL: '" + sysid + "'" , Project . MSG_DEBUG ) ; } } catch ( IOException ex ) { } } return source ; } private InputSource resolveEntityImpl ( String publicId , String systemId ) { InputSource result = null ; DTDLocation matchingEntry = findMatchingEntry ( publicId ) ; if ( matchingEntry != null ) { log ( "Matching catalog entry found for publicId: '" + matchingEntry . getPublicId ( ) + "' location: '" + matchingEntry . getLocation ( ) + "'" , Project . MSG_DEBUG ) ; result = filesystemLookup ( matchingEntry ) ; if ( result == null ) { result = classpathLookup ( matchingEntry ) ; } if ( result == null ) { result = urlLookup ( matchingEntry . getLocation ( ) , null ) ; } } return result ; } private SAXSource resolveImpl ( String href , String base ) throws TransformerException { SAXSource result = null ; InputSource source = null ; DTDLocation matchingEntry = findMatchingEntry ( href ) ; if ( matchingEntry != null ) { log ( "Matching catalog entry found for uri: '" + matchingEntry . getPublicId ( ) + "' location: '" + matchingEntry . getLocation ( ) + "'" , Project . MSG_DEBUG ) ; source = filesystemLookup ( matchingEntry ) ; if ( source == null ) { source = classpathLookup ( matchingEntry ) ; } if ( source == null ) { source = urlLookup ( matchingEntry . getLocation ( ) , base ) ; } if ( source != null ) { result = new SAXSource ( source ) ; } } return result ; } } 	1	['21', '3', '0', '10', '82', '184', '1', '9', '10', '0.683333333', '719', '1', '2', '0.6', '0.226190476', '1', '3', '33.0952381', '4', '1.9048', '1']
package org . apache . tools . ant ; import org . apache . tools . ant . input . DefaultInputHandler ; import org . apache . tools . ant . input . InputHandler ; import org . apache . tools . ant . util . JavaEnvUtils ; import java . io . File ; import java . io . FileInputStream ; import java . io . PrintStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Vector ; import java . util . Properties ; import java . util . Enumeration ; public class Main { public static final String DEFAULT_BUILD_FILENAME = "build.xml" ; private int msgOutputLevel = Project . MSG_INFO ; private File buildFile ; private static PrintStream out = System . out ; private static PrintStream err = System . err ; private Vector targets = new Vector ( 5 ) ; private Properties definedProps = new Properties ( ) ; private Vector listeners = new Vector ( 5 ) ; private Vector propertyFiles = new Vector ( 5 ) ; private String loggerClassname = null ; private String inputHandlerClassname = null ; private boolean emacsMode = false ; private boolean readyToRun = false ; private boolean projectHelp = false ; private static boolean isLogFileUsed = false ; private static void printMessage ( Throwable t ) { String message = t . getMessage ( ) ; if ( message != null ) { System . err . println ( message ) ; } } public static void start ( String [ ] args , Properties additionalUserProperties , ClassLoader coreLoader ) { Main m = null ; try { Diagnostics . validateVersion ( ) ; m = new Main ( args ) ; } catch ( Throwable exc ) { printMessage ( exc ) ; System . exit ( 1 ) ; } if ( additionalUserProperties != null ) { for ( Enumeration e = additionalUserProperties . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; String property = additionalUserProperties . getProperty ( key ) ; m . definedProps . put ( key , property ) ; } } try { m . runBuild ( coreLoader ) ; System . exit ( 0 ) ; } catch ( BuildException be ) { if ( m . err != System . err ) { printMessage ( be ) ; } System . exit ( 1 ) ; } catch ( Throwable exc ) { exc . printStackTrace ( ) ; printMessage ( exc ) ; System . exit ( 1 ) ; } finally { if ( isLogFileUsed ) { if ( out != null ) { try { out . close ( ) ; } catch ( final Exception e ) { } } if ( err != null ) { try { err . close ( ) ; } catch ( final Exception e ) { } } } } } public static void main ( String [ ] args ) { start ( args , null , null ) ; } protected Main ( String [ ] args ) throws BuildException { String searchForThis = null ; PrintStream logTo = null ; for ( int i = 0 ; i < args . length ; i ++ ) { String arg = args [ i ] ; if ( arg . equals ( "-help" ) ) { printUsage ( ) ; return ; } else if ( arg . equals ( "-version" ) ) { printVersion ( ) ; return ; } else if ( arg . equals ( "-diagnostics" ) ) { Diagnostics . doReport ( System . out ) ; return ; } else if ( arg . equals ( "-quiet" ) || arg . equals ( "-q" ) ) { msgOutputLevel = Project . MSG_WARN ; } else if ( arg . equals ( "-verbose" ) || arg . equals ( "-v" ) ) { printVersion ( ) ; msgOutputLevel = Project . MSG_VERBOSE ; } else if ( arg . equals ( "-debug" ) ) { printVersion ( ) ; msgOutputLevel = Project . MSG_DEBUG ; } else if ( arg . equals ( "-logfile" ) || arg . equals ( "-l" ) ) { try { File logFile = new File ( args [ i + 1 ] ) ; i ++ ; logTo = new PrintStream ( new FileOutputStream ( logFile ) ) ; isLogFileUsed = true ; } catch ( IOException ioe ) { String msg = "Cannot write on the specified log file. " + "Make sure the path exists and you have write " + "permissions." ; System . out . println ( msg ) ; return ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a log file when " + "using the -log argument" ; System . out . println ( msg ) ; return ; } } else if ( arg . equals ( "-buildfile" ) || arg . equals ( "-file" ) || arg . equals ( "-f" ) ) { try { buildFile = new File ( args [ i + 1 ] ) ; i ++ ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a buildfile when " + "using the -buildfile argument" ; System . out . println ( msg ) ; return ; } } else if ( arg . equals ( "-listener" ) ) { try { listeners . addElement ( args [ i + 1 ] ) ; i ++ ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a classname when " + "using the -listener argument" ; System . out . println ( msg ) ; return ; } } else if ( arg . startsWith ( "-D" ) ) { String name = arg . substring ( 2 , arg . length ( ) ) ; String value = null ; int posEq = name . indexOf ( "=" ) ; if ( posEq > 0 ) { value = name . substring ( posEq + 1 ) ; name = name . substring ( 0 , posEq ) ; } else if ( i < args . length - 1 ) { value = args [ ++ i ] ; } definedProps . put ( name , value ) ; } else if ( arg . equals ( "-logger" ) ) { if ( loggerClassname != null ) { System . out . println ( "Only one logger class may " + " be specified." ) ; return ; } try { loggerClassname = args [ ++ i ] ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { System . out . println ( "You must specify a classname when " + "using the -logger argument" ) ; return ; } } else if ( arg . equals ( "-inputhandler" ) ) { if ( inputHandlerClassname != null ) { System . out . println ( "Only one input handler class may " + "be specified." ) ; return ; } try { inputHandlerClassname = args [ ++ i ] ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { System . out . println ( "You must specify a classname when " + "using the -inputhandler argument" ) ; return ; } } else if ( arg . equals ( "-emacs" ) ) { emacsMode = true ; } else if ( arg . equals ( "-projecthelp" ) ) { projectHelp = true ; } else if ( arg . equals ( "-find" ) ) { if ( i < args . length - 1 ) { searchForThis = args [ ++ i ] ; } else { searchForThis = DEFAULT_BUILD_FILENAME ; } } else if ( arg . startsWith ( "-propertyfile" ) ) { try { propertyFiles . addElement ( args [ i + 1 ] ) ; i ++ ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a property filename when " + "using the -propertyfile argument" ; System . out . println ( msg ) ; return ; } } else if ( arg . startsWith ( "-" ) ) { String msg = "Unknown argument: " + arg ; System . out . println ( msg ) ; printUsage ( ) ; return ; } else { targets . addElement ( arg ) ; } } if ( buildFile == null ) { if ( searchForThis != null ) { buildFile = findBuildFile ( System . getProperty ( "user.dir" ) , searchForThis ) ; } else { buildFile = new File ( DEFAULT_BUILD_FILENAME ) ; } } if ( ! buildFile . exists ( ) ) { System . out . println ( "Buildfile: " + buildFile + " does not exist!" ) ; throw new BuildException ( "Build failed" ) ; } if ( buildFile . isDirectory ( ) ) { System . out . println ( "What? Buildfile: " + buildFile + " is a dir!" ) ; throw new BuildException ( "Build failed" ) ; } for ( int propertyFileIndex = 0 ; propertyFileIndex < propertyFiles . size ( ) ; propertyFileIndex ++ ) { String filename = ( String ) propertyFiles . elementAt ( propertyFileIndex ) ; Properties props = new Properties ( ) ; FileInputStream fis = null ; try { fis = new FileInputStream ( filename ) ; props . load ( fis ) ; } catch ( IOException e ) { System . out . println ( "Could not load property file " + filename + ": " + e . getMessage ( ) ) ; } finally { if ( fis != null ) { try { fis . close ( ) ; } catch ( IOException e ) { } } } Enumeration propertyNames = props . propertyNames ( ) ; while ( propertyNames . hasMoreElements ( ) ) { String name = ( String ) propertyNames . nextElement ( ) ; if ( definedProps . getProperty ( name ) == null ) { definedProps . put ( name , props . getProperty ( name ) ) ; } } } if ( msgOutputLevel >= Project . MSG_INFO ) { System . out . println ( "Buildfile: " + buildFile ) ; } if ( logTo != null ) { out = err = logTo ; System . setOut ( out ) ; System . setErr ( out ) ; } readyToRun = true ; } private File getParentFile ( File file ) { String filename = file . getAbsolutePath ( ) ; file = new File ( filename ) ; filename = file . getParent ( ) ; if ( filename != null && msgOutputLevel >= Project . MSG_VERBOSE ) { System . out . println ( "Searching in " + filename ) ; } return ( filename == null ) ? null : new File ( filename ) ; } private File findBuildFile ( String start , String suffix ) throws BuildException { if ( msgOutputLevel >= Project . MSG_INFO ) { System . out . println ( "Searching for " + suffix + " ..." ) ; } File parent = new File ( new File ( start ) . getAbsolutePath ( ) ) ; File file = new File ( parent , suffix ) ; while ( ! file . exists ( ) ) { parent = getParentFile ( parent ) ; if ( parent == null ) { throw new BuildException ( "Could not locate a build file!" ) ; } file = new File ( parent , suffix ) ; } return file ; } private void runBuild ( ClassLoader coreLoader ) throws BuildException { if ( ! readyToRun ) { return ; } final Project project = new Project ( ) ; project . setCoreLoader ( coreLoader ) ; Throwable error = null ; try { addBuildListeners ( project ) ; addInputHandler ( project ) ; PrintStream err = System . err ; PrintStream out = System . out ; SecurityManager oldsm = null ; if ( ! JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_0 ) && ! JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { oldsm = System . getSecurityManager ( ) ; } try { System . setOut ( new PrintStream ( new DemuxOutputStream ( project , false ) ) ) ; System . setErr ( new PrintStream ( new DemuxOutputStream ( project , true ) ) ) ; if ( ! projectHelp ) { project . fireBuildStarted ( ) ; } project . init ( ) ; project . setUserProperty ( "ant.version" , getAntVersion ( ) ) ; Enumeration e = definedProps . keys ( ) ; while ( e . hasMoreElements ( ) ) { String arg = ( String ) e . nextElement ( ) ; String value = ( String ) definedProps . get ( arg ) ; project . setUserProperty ( arg , value ) ; } project . setUserProperty ( "ant.file" , buildFile . getAbsolutePath ( ) ) ; ProjectHelper . configureProject ( project , buildFile ) ; if ( projectHelp ) { printDescription ( project ) ; printTargets ( project , msgOutputLevel > Project . MSG_INFO ) ; return ; } if ( targets . size ( ) == 0 ) { targets . addElement ( project . getDefaultTarget ( ) ) ; } project . executeTargets ( targets ) ; } finally { if ( oldsm != null ) { System . setSecurityManager ( oldsm ) ; } System . setOut ( out ) ; System . setErr ( err ) ; } } catch ( RuntimeException exc ) { error = exc ; throw exc ; } catch ( Error err ) { error = err ; throw err ; } finally { if ( ! projectHelp ) { project . fireBuildFinished ( error ) ; } } } protected void addBuildListeners ( Project project ) { project . addBuildListener ( createLogger ( ) ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { String className = ( String ) listeners . elementAt ( i ) ; try { BuildListener listener = ( BuildListener ) Class . forName ( className ) . newInstance ( ) ; project . addBuildListener ( listener ) ; } catch ( Throwable exc ) { throw new BuildException ( "Unable to instantiate listener " + className , exc ) ; } } } private void addInputHandler ( Project project ) { InputHandler handler = null ; if ( inputHandlerClassname == null ) { handler = new DefaultInputHandler ( ) ; } else { try { handler = ( InputHandler ) ( Class . forName ( inputHandlerClassname ) . newInstance ( ) ) ; } catch ( ClassCastException e ) { String msg = "The specified input handler class " + inputHandlerClassname + " does not implement the InputHandler interface" ; throw new BuildException ( msg ) ; } catch ( Exception e ) { String msg = "Unable to instantiate specified input handler " + "class " + inputHandlerClassname + " : " + e . getClass ( ) . getName ( ) ; throw new BuildException ( msg ) ; } } project . setInputHandler ( handler ) ; } private BuildLogger createLogger ( ) { BuildLogger logger = null ; if ( loggerClassname != null ) { try { logger = ( BuildLogger ) ( Class . forName ( loggerClassname ) . newInstance ( ) ) ; } catch ( ClassCastException e ) { System . err . println ( "The specified logger class " + loggerClassname + " does not implement the BuildLogger interface" ) ; throw new RuntimeException ( ) ; } catch ( Exception e ) { System . err . println ( "Unable to instantiate specified logger " + "class " + loggerClassname + " : " + e . getClass ( ) . getName ( ) ) ; throw new RuntimeException ( ) ; } } else { logger = new DefaultLogger ( ) ; } logger . setMessageOutputLevel ( msgOutputLevel ) ; logger . setOutputPrintStream ( out ) ; logger . setErrorPrintStream ( err ) ; logger . setEmacsMode ( emacsMode ) ; return logger ; } private static void printUsage ( ) { String lSep = System . getProperty ( "line.separator" ) ; StringBuffer msg = new StringBuffer ( ) ; msg . append ( "ant [options] [target [target2 [target3] ...]]" + lSep ) ; msg . append ( "Options: " + lSep ) ; msg . append ( "  -help                  print this message" + lSep ) ; msg . append ( "  -projecthelp           print project help information" + lSep ) ; msg . append ( "  -version               print the version information and exit" + lSep ) ; msg . append ( "  -diagnostics           print information that might be helpful to" + lSep ) ; msg . append ( "                         diagnose or report problems." + lSep ) ; msg . append ( "  -quiet, -q             be extra quiet" + lSep ) ; msg . append ( "  -verbose, -v           be extra verbose" + lSep ) ; msg . append ( "  -debug                 print debugging information" + lSep ) ; msg . append ( "  -emacs                 produce logging information without adornments" + lSep ) ; msg . append ( "  -logfile <file>        use given file for log" + lSep ) ; msg . append ( "    -l     <file>                ''" + lSep ) ; msg . append ( "  -logger <classname>    the class which is to perform logging" + lSep ) ; msg . append ( "  -listener <classname>  add an instance of class as a project listener" + lSep ) ; msg . append ( "  -buildfile <file>      use given buildfile" + lSep ) ; msg . append ( "    -file    <file>              ''" + lSep ) ; msg . append ( "    -f       <file>              ''" + lSep ) ; msg . append ( "  -D<property>=<value>   use value for given property" + lSep ) ; msg . append ( "  -propertyfile <name>   load all properties from file with -D" + lSep ) ; msg . append ( "                         properties taking precedence" + lSep ) ; msg . append ( "  -inputhandler <class>  the class which will handle input requests" + lSep ) ; msg . append ( "  -find <file>           search for buildfile towards the root of the" + lSep ) ; msg . append ( "                         filesystem and use it" + lSep ) ; System . out . println ( msg . toString ( ) ) ; } private static void printVersion ( ) throws BuildException { System . out . println ( getAntVersion ( ) ) ; } private static String antVersion = null ; public static synchronized String getAntVersion ( ) throws BuildException { if ( antVersion == null ) { try { Properties props = new Properties ( ) ; InputStream in = Main . class . getResourceAsStream ( "/org/apache/tools/ant/version.txt" ) ; props . load ( in ) ; in . close ( ) ; StringBuffer msg = new StringBuffer ( ) ; msg . append ( "Apache Ant version " ) ; msg . append ( props . getProperty ( "VERSION" ) ) ; msg . append ( " compiled on " ) ; msg . append ( props . getProperty ( "DATE" ) ) ; antVersion = msg . toString ( ) ; } catch ( IOException ioe ) { throw new BuildException ( "Could not load the version information:" + ioe . getMessage ( ) ) ; } catch ( NullPointerException npe ) { throw new BuildException ( "Could not load the version information." ) ; } } return antVersion ; } private static void printDescription ( Project project ) { if ( project . getDescription ( ) != null ) { project . log ( project . getDescription ( ) ) ; } } private static void printTargets ( Project project , boolean printSubTargets ) { int maxLength = 0 ; Enumeration ptargets = project . getTargets ( ) . elements ( ) ; String targetName ; String targetDescription ; Target currentTarget ; Vector topNames = new Vector ( ) ; Vector topDescriptions = new Vector ( ) ; Vector subNames = new Vector ( ) ; while ( ptargets . hasMoreElements ( ) ) { currentTarget = ( Target ) ptargets . nextElement ( ) ; targetName = currentTarget . getName ( ) ; targetDescription = currentTarget . getDescription ( ) ; if ( targetDescription == null ) { int pos = findTargetPosition ( subNames , targetName ) ; subNames . insertElementAt ( targetName , pos ) ; } else { int pos = findTargetPosition ( topNames , targetName ) ; topNames . insertElementAt ( targetName , pos ) ; topDescriptions . insertElementAt ( targetDescription , pos ) ; if ( targetName . length ( ) > maxLength ) { maxLength = targetName . length ( ) ; } } } printTargets ( project , topNames , topDescriptions , "Main targets:" , maxLength ) ; if ( topNames . size ( ) == 0 ) { printSubTargets = true ; } if ( printSubTargets ) { printTargets ( project , subNames , null , "Subtargets:" , 0 ) ; } String defaultTarget = project . getDefaultTarget ( ) ; if ( defaultTarget != null && ! "" . equals ( defaultTarget ) ) { project . log ( "Default target: " + defaultTarget ) ; } } private static int findTargetPosition ( Vector names , String name ) { int res = names . size ( ) ; for ( int i = 0 ; i < names . size ( ) && res == names . size ( ) ; i ++ ) { if ( name . compareTo ( ( String ) names . elementAt ( i ) ) < 0 ) { res = i ; } } return res ; } private static void printTargets ( Project project , Vector names , Vector descriptions , String heading , int maxlen ) { String lSep = System . getProperty ( "line.separator" ) ; String spaces = "    " ; while ( spaces . length ( ) < maxlen ) { spaces += spaces ; } StringBuffer msg = new StringBuffer ( ) ; msg . append ( heading + lSep + lSep ) ; for ( int i = 0 ; i < names . size ( ) ; i ++ ) { msg . append ( " " ) ; msg . append ( names . elementAt ( i ) ) ; if ( descriptions != null ) { msg . append ( spaces . substring ( 0 , maxlen - ( ( String ) names . elementAt ( i ) ) . length ( ) + 2 ) ) ; msg . append ( descriptions . elementAt ( i ) ) ; } msg . append ( lSep ) ; } project . log ( msg . toString ( ) ) ; } } 	1	['19', '1', '0', '12', '103', '133', '1', '12', '3', '0.81372549', '1720', '0.882352941', '0', '0', '0.141414141', '0', '0', '88.63157895', '11', '2.5263', '1']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . PrintWriter ; import java . io . FileWriter ; import java . io . IOException ; import java . io . FilenameFilter ; import java . net . URL ; import java . net . MalformedURLException ; import java . util . Locale ; import java . util . Vector ; import java . util . Enumeration ; import java . util . StringTokenizer ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . DirSet ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . PatternSet ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; public class Javadoc extends Task { public class DocletParam { private String name ; private String value ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } } public static class ExtensionInfo extends ProjectComponent { private String name ; private Path path ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setPath ( Path path ) { if ( this . path == null ) { this . path = path ; } else { this . path . append ( path ) ; } } public Path getPath ( ) { return path ; } public Path createPath ( ) { if ( path == null ) { path = new Path ( getProject ( ) ) ; } return path . createPath ( ) ; } public void setPathRef ( Reference r ) { createPath ( ) . setRefid ( r ) ; } } public class DocletInfo extends ExtensionInfo { private Vector params = new Vector ( ) ; public DocletParam createParam ( ) { DocletParam param = new DocletParam ( ) ; params . addElement ( param ) ; return param ; } public Enumeration getParams ( ) { return params . elements ( ) ; } } public static class PackageName { private String name ; public void setName ( String name ) { this . name = name . trim ( ) ; } public String getName ( ) { return name ; } public String toString ( ) { return getName ( ) ; } } public static class SourceFile { private File file ; public SourceFile ( ) { } public SourceFile ( File file ) { this . file = file ; } public void setFile ( File file ) { this . file = file ; } public File getFile ( ) { return file ; } } public static class Html { private StringBuffer text = new StringBuffer ( ) ; public void addText ( String t ) { text . append ( t ) ; } public String getText ( ) { return text . toString ( ) ; } } public static class AccessType extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "protected" , "public" , "package" , "private" } ; } } private Commandline cmd = new Commandline ( ) ; private static boolean javadoc1 = JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ; private static boolean javadoc4 = ( ! JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) && ! JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_2 ) && ! JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_3 ) ) ; private void addArgIf ( boolean b , String arg ) { if ( b ) { cmd . createArgument ( ) . setValue ( arg ) ; } } private void add12ArgIfNotEmpty ( String key , String value ) { if ( ! javadoc1 ) { if ( value != null && value . length ( ) != 0 ) { cmd . createArgument ( ) . setValue ( key ) ; cmd . createArgument ( ) . setValue ( value ) ; } else { log ( "Warning: Leaving out empty argument '" + key + "'" , Project . MSG_WARN ) ; } } } private void add12ArgIf ( boolean b , String arg ) { if ( ! javadoc1 && b ) { cmd . createArgument ( ) . setValue ( arg ) ; } } private boolean failOnError = false ; private Path sourcePath = null ; private File destDir = null ; private Vector sourceFiles = new Vector ( ) ; private Vector packageNames = new Vector ( 5 ) ; private Vector excludePackageNames = new Vector ( 1 ) ; private boolean author = true ; private boolean version = true ; private DocletInfo doclet = null ; private Path classpath = null ; private Path bootclasspath = null ; private String group = null ; private String packageList = null ; private Vector links = new Vector ( 2 ) ; private Vector groups = new Vector ( 2 ) ; private Vector tags = new Vector ( 5 ) ; private boolean useDefaultExcludes = true ; private Html doctitle = null ; private Html header = null ; private Html footer = null ; private Html bottom = null ; private boolean useExternalFile = false ; private FileUtils fileUtils = FileUtils . newFileUtils ( ) ; private String source = null ; private Vector fileSets = new Vector ( ) ; private Vector packageSets = new Vector ( ) ; public void setUseExternalFile ( boolean b ) { if ( ! javadoc1 ) { useExternalFile = b ; } } public void setDefaultexcludes ( boolean useDefaultExcludes ) { this . useDefaultExcludes = useDefaultExcludes ; } public void setMaxmemory ( String max ) { if ( javadoc1 ) { cmd . createArgument ( ) . setValue ( "-J-mx" + max ) ; } else { cmd . createArgument ( ) . setValue ( "-J-Xmx" + max ) ; } } public void setAdditionalparam ( String add ) { cmd . createArgument ( ) . setLine ( add ) ; } public void setSourcepath ( Path src ) { if ( sourcePath == null ) { sourcePath = src ; } else { sourcePath . append ( src ) ; } } public Path createSourcepath ( ) { if ( sourcePath == null ) { sourcePath = new Path ( project ) ; } return sourcePath . createPath ( ) ; } public void setSourcepathRef ( Reference r ) { createSourcepath ( ) . setRefid ( r ) ; } public void setDestdir ( File dir ) { destDir = dir ; cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } public void setSourcefiles ( String src ) { StringTokenizer tok = new StringTokenizer ( src , "," ) ; while ( tok . hasMoreTokens ( ) ) { String f = tok . nextToken ( ) ; SourceFile sf = new SourceFile ( ) ; sf . setFile ( project . resolveFile ( f ) ) ; addSource ( sf ) ; } } public void addSource ( SourceFile sf ) { sourceFiles . addElement ( sf ) ; } public void setPackagenames ( String packages ) { StringTokenizer tok = new StringTokenizer ( packages , "," ) ; while ( tok . hasMoreTokens ( ) ) { String p = tok . nextToken ( ) ; PackageName pn = new PackageName ( ) ; pn . setName ( p ) ; addPackage ( pn ) ; } } public void addPackage ( PackageName pn ) { packageNames . addElement ( pn ) ; } public void setExcludePackageNames ( String packages ) { StringTokenizer tok = new StringTokenizer ( packages , "," ) ; while ( tok . hasMoreTokens ( ) ) { String p = tok . nextToken ( ) ; PackageName pn = new PackageName ( ) ; pn . setName ( p ) ; addExcludePackage ( pn ) ; } } public void addExcludePackage ( PackageName pn ) { excludePackageNames . addElement ( pn ) ; } public void setOverview ( File f ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-overview" ) ; cmd . createArgument ( ) . setFile ( f ) ; } } public void setPublic ( boolean b ) { addArgIf ( b , "-public" ) ; } public void setProtected ( boolean b ) { addArgIf ( b , "-protected" ) ; } public void setPackage ( boolean b ) { addArgIf ( b , "-package" ) ; } public void setPrivate ( boolean b ) { addArgIf ( b , "-private" ) ; } public void setAccess ( AccessType at ) { cmd . createArgument ( ) . setValue ( "-" + at . getValue ( ) ) ; } public void setDoclet ( String docletName ) { if ( doclet == null ) { doclet = new DocletInfo ( ) ; doclet . setProject ( getProject ( ) ) ; } doclet . setName ( docletName ) ; } public void setDocletPath ( Path docletPath ) { if ( doclet == null ) { doclet = new DocletInfo ( ) ; doclet . setProject ( getProject ( ) ) ; } doclet . setPath ( docletPath ) ; } public void setDocletPathRef ( Reference r ) { if ( doclet == null ) { doclet = new DocletInfo ( ) ; doclet . setProject ( getProject ( ) ) ; } doclet . createPath ( ) . setRefid ( r ) ; } public DocletInfo createDoclet ( ) { doclet = new DocletInfo ( ) ; return doclet ; } public void addTaglet ( ExtensionInfo tagletInfo ) { tags . addElement ( tagletInfo ) ; } public void setOld ( boolean b ) { if ( b ) { if ( javadoc1 ) { log ( "Javadoc 1.1 doesn't support the -1.1 switch" , Project . MSG_WARN ) ; } else if ( javadoc4 ) { log ( "Javadoc 1.4 doesn't support the -1.1 switch anymore" , Project . MSG_WARN ) ; } else { cmd . createArgument ( ) . setValue ( "-1.1" ) ; } } } public void setClasspath ( Path path ) { if ( classpath == null ) { classpath = path ; } else { classpath . append ( path ) ; } } public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( project ) ; } return classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setBootclasspath ( Path path ) { if ( bootclasspath == null ) { bootclasspath = path ; } else { bootclasspath . append ( path ) ; } } public Path createBootclasspath ( ) { if ( bootclasspath == null ) { bootclasspath = new Path ( project ) ; } return bootclasspath . createPath ( ) ; } public void setBootClasspathRef ( Reference r ) { createBootclasspath ( ) . setRefid ( r ) ; } public void setExtdirs ( String path ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-extdirs" ) ; cmd . createArgument ( ) . setValue ( path ) ; } } public void setExtdirs ( Path path ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-extdirs" ) ; cmd . createArgument ( ) . setPath ( path ) ; } } public void setVerbose ( boolean b ) { add12ArgIf ( b , "-verbose" ) ; } public void setLocale ( String locale ) { if ( ! javadoc1 ) { cmd . createArgument ( true ) . setValue ( locale ) ; cmd . createArgument ( true ) . setValue ( "-locale" ) ; } } public void setEncoding ( String enc ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( enc ) ; } public void setVersion ( boolean b ) { this . version = b ; } public void setUse ( boolean b ) { add12ArgIf ( b , "-use" ) ; } public void setAuthor ( boolean b ) { author = b ; } public void setSplitindex ( boolean b ) { add12ArgIf ( b , "-splitindex" ) ; } public void setWindowtitle ( String title ) { add12ArgIfNotEmpty ( "-windowtitle" , title ) ; } public void setDoctitle ( String doctitle ) { Html h = new Html ( ) ; h . addText ( doctitle ) ; addDoctitle ( h ) ; } public void addDoctitle ( Html text ) { if ( ! javadoc1 ) { doctitle = text ; } } public void setHeader ( String header ) { Html h = new Html ( ) ; h . addText ( header ) ; addHeader ( h ) ; } public void addHeader ( Html text ) { if ( ! javadoc1 ) { header = text ; } } public void setFooter ( String footer ) { Html h = new Html ( ) ; h . addText ( footer ) ; addFooter ( h ) ; } public void addFooter ( Html text ) { if ( ! javadoc1 ) { footer = text ; } } public void setBottom ( String bottom ) { Html h = new Html ( ) ; h . addText ( bottom ) ; addBottom ( h ) ; } public void addBottom ( Html text ) { if ( ! javadoc1 ) { bottom = text ; } } public void setLinkoffline ( String src ) { if ( ! javadoc1 ) { LinkArgument le = createLink ( ) ; le . setOffline ( true ) ; String linkOfflineError = "The linkoffline attribute must include" + " a URL and a package-list file location separated by a" + " space" ; if ( src . trim ( ) . length ( ) == 0 ) { throw new BuildException ( linkOfflineError ) ; } StringTokenizer tok = new StringTokenizer ( src , " " , false ) ; le . setHref ( tok . nextToken ( ) ) ; if ( ! tok . hasMoreTokens ( ) ) { throw new BuildException ( linkOfflineError ) ; } le . setPackagelistLoc ( project . resolveFile ( tok . nextToken ( ) ) ) ; } } public void setGroup ( String src ) { group = src ; } public void setLink ( String src ) { if ( ! javadoc1 ) { createLink ( ) . setHref ( src ) ; } } public void setNodeprecated ( boolean b ) { addArgIf ( b , "-nodeprecated" ) ; } public void setNodeprecatedlist ( boolean b ) { add12ArgIf ( b , "-nodeprecatedlist" ) ; } public void setNotree ( boolean b ) { addArgIf ( b , "-notree" ) ; } public void setNoindex ( boolean b ) { addArgIf ( b , "-noindex" ) ; } public void setNohelp ( boolean b ) { add12ArgIf ( b , "-nohelp" ) ; } public void setNonavbar ( boolean b ) { add12ArgIf ( b , "-nonavbar" ) ; } public void setSerialwarn ( boolean b ) { add12ArgIf ( b , "-serialwarn" ) ; } public void setStylesheetfile ( File f ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-stylesheetfile" ) ; cmd . createArgument ( ) . setFile ( f ) ; } } public void setHelpfile ( File f ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-helpfile" ) ; cmd . createArgument ( ) . setFile ( f ) ; } } public void setDocencoding ( String enc ) { cmd . createArgument ( ) . setValue ( "-docencoding" ) ; cmd . createArgument ( ) . setValue ( enc ) ; } public void setPackageList ( String src ) { if ( ! javadoc1 ) { packageList = src ; } } public LinkArgument createLink ( ) { LinkArgument la = new LinkArgument ( ) ; links . addElement ( la ) ; return la ; } public class LinkArgument { private String href ; private boolean offline = false ; private File packagelistLoc ; public LinkArgument ( ) { } public void setHref ( String hr ) { href = hr ; } public String getHref ( ) { return href ; } public void setPackagelistLoc ( File src ) { packagelistLoc = src ; } public File getPackagelistLoc ( ) { return packagelistLoc ; } public void setOffline ( boolean offline ) { this . offline = offline ; } public boolean isLinkOffline ( ) { return offline ; } } public TagArgument createTag ( ) { if ( ! javadoc4 ) { log ( "-tag option not supported on JavaDoc < 1.4" , Project . MSG_VERBOSE ) ; } TagArgument ta = new TagArgument ( ) ; tags . addElement ( ta ) ; return ta ; } static final String [ ] SCOPE_ELEMENTS = { "overview" , "packages" , "types" , "constructors" , "methods" , "fields" } ; public class TagArgument { private String name = null ; private String description = null ; private boolean enabled = true ; private String scope = "a" ; public TagArgument ( ) { } public void setName ( String name ) { this . name = name ; } public void setDescription ( String description ) { this . description = description ; } public void setScope ( String verboseScope ) throws BuildException { verboseScope = verboseScope . toLowerCase ( Locale . US ) ; boolean [ ] elements = new boolean [ SCOPE_ELEMENTS . length ] ; boolean gotAll = false ; boolean gotNotAll = false ; StringTokenizer tok = new StringTokenizer ( verboseScope , "," ) ; while ( tok . hasMoreTokens ( ) ) { String next = tok . nextToken ( ) . trim ( ) ; if ( next . equals ( "all" ) ) { if ( gotAll ) { getProject ( ) . log ( "Repeated tag scope element: all" , Project . MSG_VERBOSE ) ; } gotAll = true ; } else { int i ; for ( i = 0 ; i < SCOPE_ELEMENTS . length ; i ++ ) { if ( next . equals ( SCOPE_ELEMENTS [ i ] ) ) break ; } if ( i == SCOPE_ELEMENTS . length ) { throw new BuildException ( "Unrecognised scope element: " + next ) ; } else { if ( elements [ i ] ) { getProject ( ) . log ( "Repeated tag scope element: " + next , Project . MSG_VERBOSE ) ; } elements [ i ] = true ; gotNotAll = true ; } } } if ( gotNotAll && gotAll ) { throw new BuildException ( "Mixture of \"all\" and other scope " + "elements in tag parameter." ) ; } if ( ! gotNotAll && ! gotAll ) { throw new BuildException ( "No scope elements specified in tag " + "parameter." ) ; } if ( gotAll ) { this . scope = "a" ; } else { StringBuffer buff = new StringBuffer ( elements . length ) ; for ( int i = 0 ; i < elements . length ; i ++ ) { if ( elements [ i ] ) { buff . append ( SCOPE_ELEMENTS [ i ] . charAt ( 0 ) ) ; } } this . scope = buff . toString ( ) ; } } public void setEnabled ( boolean enabled ) { this . enabled = enabled ; } public String getParameter ( ) throws BuildException { if ( name == null || name . equals ( "" ) ) { throw new BuildException ( "No name specified for custom tag." ) ; } if ( description == null || description . equals ( "" ) ) { throw new BuildException ( "No description specified for custom tag " + name ) ; } return name + ":" + ( enabled ? "" : "X" ) + scope + ":" + description ; } } public GroupArgument createGroup ( ) { GroupArgument ga = new GroupArgument ( ) ; groups . addElement ( ga ) ; return ga ; } public class GroupArgument { private Html title ; private Vector packages = new Vector ( 3 ) ; public GroupArgument ( ) { } public void setTitle ( String src ) { Html h = new Html ( ) ; h . addText ( src ) ; addTitle ( h ) ; } public void addTitle ( Html text ) { title = text ; } public String getTitle ( ) { return title != null ? title . getText ( ) : null ; } public void setPackages ( String src ) { StringTokenizer tok = new StringTokenizer ( src , "," ) ; while ( tok . hasMoreTokens ( ) ) { String p = tok . nextToken ( ) ; PackageName pn = new PackageName ( ) ; pn . setName ( p ) ; addPackage ( pn ) ; } } public void addPackage ( PackageName pn ) { packages . addElement ( pn ) ; } public String getPackages ( ) { StringBuffer p = new StringBuffer ( ) ; for ( int i = 0 ; i < packages . size ( ) ; i ++ ) { if ( i > 0 ) { p . append ( ":" ) ; } p . append ( packages . elementAt ( i ) . toString ( ) ) ; } return p . toString ( ) ; } } public void setCharset ( String src ) { this . add12ArgIfNotEmpty ( "-charset" , src ) ; } public void setFailonerror ( boolean b ) { failOnError = b ; } public void setSource ( String source ) { this . source = source ; } public void addPackageset ( DirSet packageSet ) { packageSets . addElement ( packageSet ) ; } public void addFileset ( FileSet fs ) { fileSets . addElement ( fs ) ; } public void execute ( ) throws BuildException { if ( "javadoc2" . equals ( taskType ) ) { log ( "!! javadoc2 is deprecated. Use javadoc instead. !!" ) ; } Vector packagesToDoc = new Vector ( ) ; Path sourceDirs = new Path ( getProject ( ) ) ; if ( packageList != null && sourcePath == null ) { String msg = "sourcePath attribute must be set when " + "specifying packagelist." ; throw new BuildException ( msg ) ; } if ( sourcePath != null ) { sourceDirs . addExisting ( sourcePath ) ; } parsePackages ( packagesToDoc , sourceDirs ) ; if ( packagesToDoc . size ( ) != 0 && sourceDirs . size ( ) == 0 ) { String msg = "sourcePath attribute must be set when " + "specifying package names." ; throw new BuildException ( msg ) ; } Vector sourceFilesToDoc = ( Vector ) sourceFiles . clone ( ) ; addFileSets ( sourceFilesToDoc ) ; if ( packageList == null && packagesToDoc . size ( ) == 0 && sourceFilesToDoc . size ( ) == 0 ) { throw new BuildException ( "No source files and no packages have " + "been specified." ) ; } log ( "Generating Javadoc" , Project . MSG_INFO ) ; Commandline toExecute = ( Commandline ) cmd . clone ( ) ; toExecute . setExecutable ( JavaEnvUtils . getJdkExecutable ( "javadoc" ) ) ; if ( doctitle != null ) { toExecute . createArgument ( ) . setValue ( "-doctitle" ) ; toExecute . createArgument ( ) . setValue ( expand ( doctitle . getText ( ) ) ) ; } if ( header != null ) { toExecute . createArgument ( ) . setValue ( "-header" ) ; toExecute . createArgument ( ) . setValue ( expand ( header . getText ( ) ) ) ; } if ( footer != null ) { toExecute . createArgument ( ) . setValue ( "-footer" ) ; toExecute . createArgument ( ) . setValue ( expand ( footer . getText ( ) ) ) ; } if ( bottom != null ) { toExecute . createArgument ( ) . setValue ( "-bottom" ) ; toExecute . createArgument ( ) . setValue ( expand ( bottom . getText ( ) ) ) ; } if ( classpath == null ) { classpath = Path . systemClasspath ; } else { classpath = classpath . concatSystemClasspath ( "ignore" ) ; } if ( ! javadoc1 ) { if ( classpath . size ( ) > 0 ) { toExecute . createArgument ( ) . setValue ( "-classpath" ) ; toExecute . createArgument ( ) . setPath ( classpath ) ; } if ( sourceDirs . size ( ) > 0 ) { toExecute . createArgument ( ) . setValue ( "-sourcepath" ) ; toExecute . createArgument ( ) . setPath ( sourceDirs ) ; } } else { sourceDirs . append ( classpath ) ; if ( sourceDirs . size ( ) > 0 ) { toExecute . createArgument ( ) . setValue ( "-classpath" ) ; toExecute . createArgument ( ) . setPath ( sourceDirs ) ; } } if ( version && doclet == null ) { toExecute . createArgument ( ) . setValue ( "-version" ) ; } if ( author && doclet == null ) { toExecute . createArgument ( ) . setValue ( "-author" ) ; } if ( javadoc1 || doclet == null ) { if ( destDir == null ) { String msg = "destDir attribute must be set!" ; throw new BuildException ( msg ) ; } } if ( ! javadoc1 ) { if ( doclet != null ) { if ( doclet . getName ( ) == null ) { throw new BuildException ( "The doclet name must be " + "specified." , location ) ; } else { toExecute . createArgument ( ) . setValue ( "-doclet" ) ; toExecute . createArgument ( ) . setValue ( doclet . getName ( ) ) ; if ( doclet . getPath ( ) != null ) { Path docletPath = doclet . getPath ( ) . concatSystemClasspath ( "ignore" ) ; if ( docletPath . size ( ) != 0 ) { toExecute . createArgument ( ) . setValue ( "-docletpath" ) ; toExecute . createArgument ( ) . setPath ( docletPath ) ; } } for ( Enumeration e = doclet . getParams ( ) ; e . hasMoreElements ( ) ; ) { DocletParam param = ( DocletParam ) e . nextElement ( ) ; if ( param . getName ( ) == null ) { throw new BuildException ( "Doclet parameters must " + "have a name" ) ; } toExecute . createArgument ( ) . setValue ( param . getName ( ) ) ; if ( param . getValue ( ) != null ) { toExecute . createArgument ( ) . setValue ( param . getValue ( ) ) ; } } } } if ( bootclasspath != null && bootclasspath . size ( ) > 0 ) { toExecute . createArgument ( ) . setValue ( "-bootclasspath" ) ; toExecute . createArgument ( ) . setPath ( bootclasspath ) ; } if ( links . size ( ) != 0 ) { for ( Enumeration e = links . elements ( ) ; e . hasMoreElements ( ) ; ) { LinkArgument la = ( LinkArgument ) e . nextElement ( ) ; if ( la . getHref ( ) == null || la . getHref ( ) . length ( ) == 0 ) { log ( "No href was given for the link - skipping" , Project . MSG_VERBOSE ) ; continue ; } else { try { URL base = new URL ( "file://." ) ; URL testHref = new URL ( base , la . getHref ( ) ) ; } catch ( MalformedURLException mue ) { log ( "Link href \"" + la . getHref ( ) + "\" is not a valid url - skipping link" , Project . MSG_WARN ) ; continue ; } } if ( la . isLinkOffline ( ) ) { File packageListLocation = la . getPackagelistLoc ( ) ; if ( packageListLocation == null ) { throw new BuildException ( "The package list " + " location for link " + la . getHref ( ) + " must be provided because the link is " + "offline" ) ; } File packageListFile = new File ( packageListLocation , "package-list" ) ; if ( packageListFile . exists ( ) ) { toExecute . createArgument ( ) . setValue ( "-linkoffline" ) ; toExecute . createArgument ( ) . setValue ( la . getHref ( ) ) ; toExecute . createArgument ( ) . setValue ( packageListLocation . getAbsolutePath ( ) ) ; } else { log ( "Warning: No package list was found at " + packageListLocation , Project . MSG_VERBOSE ) ; } } else { toExecute . createArgument ( ) . setValue ( "-link" ) ; toExecute . createArgument ( ) . setValue ( la . getHref ( ) ) ; } } } if ( group != null ) { StringTokenizer tok = new StringTokenizer ( group , "," , false ) ; while ( tok . hasMoreTokens ( ) ) { String grp = tok . nextToken ( ) . trim ( ) ; int space = grp . indexOf ( " " ) ; if ( space > 0 ) { String name = grp . substring ( 0 , space ) ; String pkgList = grp . substring ( space + 1 ) ; toExecute . createArgument ( ) . setValue ( "-group" ) ; toExecute . createArgument ( ) . setValue ( name ) ; toExecute . createArgument ( ) . setValue ( pkgList ) ; } } } if ( groups . size ( ) != 0 ) { for ( Enumeration e = groups . elements ( ) ; e . hasMoreElements ( ) ; ) { GroupArgument ga = ( GroupArgument ) e . nextElement ( ) ; String title = ga . getTitle ( ) ; String packages = ga . getPackages ( ) ; if ( title == null || packages == null ) { throw new BuildException ( "The title and packages must " + "be specified for group " + "elements." ) ; } toExecute . createArgument ( ) . setValue ( "-group" ) ; toExecute . createArgument ( ) . setValue ( expand ( title ) ) ; toExecute . createArgument ( ) . setValue ( packages ) ; } } if ( javadoc4 ) { for ( Enumeration e = tags . elements ( ) ; e . hasMoreElements ( ) ; ) { Object element = e . nextElement ( ) ; if ( element instanceof TagArgument ) { TagArgument ta = ( TagArgument ) element ; toExecute . createArgument ( ) . setValue ( "-tag" ) ; toExecute . createArgument ( ) . setValue ( ta . getParameter ( ) ) ; } else { ExtensionInfo tagletInfo = ( ExtensionInfo ) element ; toExecute . createArgument ( ) . setValue ( "-taglet" ) ; toExecute . createArgument ( ) . setValue ( tagletInfo . getName ( ) ) ; if ( tagletInfo . getPath ( ) != null ) { Path tagletPath = tagletInfo . getPath ( ) . concatSystemClasspath ( "ignore" ) ; if ( tagletPath . size ( ) != 0 ) { toExecute . createArgument ( ) . setValue ( "-tagletpath" ) ; toExecute . createArgument ( ) . setPath ( tagletPath ) ; } } } } if ( source != null ) { if ( doclet != null ) { log ( "ignoring source option for custom doclet" , Project . MSG_WARN ) ; } else { toExecute . createArgument ( ) . setValue ( "-source" ) ; toExecute . createArgument ( ) . setValue ( source ) ; } } } } File tmpList = null ; PrintWriter srcListWriter = null ; try { if ( useExternalFile ) { if ( tmpList == null ) { tmpList = fileUtils . createTempFile ( "javadoc" , "" , null ) ; toExecute . createArgument ( ) . setValue ( "@" + tmpList . getAbsolutePath ( ) ) ; } srcListWriter = new PrintWriter ( new FileWriter ( tmpList . getAbsolutePath ( ) , true ) ) ; } Enumeration enum = packagesToDoc . elements ( ) ; while ( enum . hasMoreElements ( ) ) { String packageName = ( String ) enum . nextElement ( ) ; if ( useExternalFile ) { srcListWriter . println ( packageName ) ; } else { toExecute . createArgument ( ) . setValue ( packageName ) ; } } enum = sourceFilesToDoc . elements ( ) ; while ( enum . hasMoreElements ( ) ) { SourceFile sf = ( SourceFile ) enum . nextElement ( ) ; String sourceFileName = sf . getFile ( ) . getAbsolutePath ( ) ; if ( useExternalFile ) { srcListWriter . println ( sourceFileName ) ; } else { toExecute . createArgument ( ) . setValue ( sourceFileName ) ; } } } catch ( IOException e ) { tmpList . delete ( ) ; throw new BuildException ( "Error creating temporary file" , e , location ) ; } finally { if ( srcListWriter != null ) { srcListWriter . close ( ) ; } } if ( packageList != null ) { toExecute . createArgument ( ) . setValue ( "@" + packageList ) ; } log ( toExecute . describeCommand ( ) , Project . MSG_VERBOSE ) ; log ( "Javadoc execution" , Project . MSG_INFO ) ; JavadocOutputStream out = new JavadocOutputStream ( Project . MSG_INFO ) ; JavadocOutputStream err = new JavadocOutputStream ( Project . MSG_WARN ) ; Execute exe = new Execute ( new PumpStreamHandler ( out , err ) ) ; exe . setAntRun ( project ) ; exe . setWorkingDirectory ( null ) ; try { exe . setCommandline ( toExecute . getCommandline ( ) ) ; int ret = exe . execute ( ) ; if ( ret != 0 && failOnError ) { throw new BuildException ( "Javadoc returned " + ret , location ) ; } } catch ( IOException e ) { throw new BuildException ( "Javadoc failed: " + e , e , location ) ; } finally { if ( tmpList != null ) { tmpList . delete ( ) ; tmpList = null ; } out . logFlush ( ) ; err . logFlush ( ) ; try { out . close ( ) ; err . close ( ) ; } catch ( IOException e ) { } } } private void addFileSets ( Vector sf ) { Enumeration enum = fileSets . elements ( ) ; while ( enum . hasMoreElements ( ) ) { FileSet fs = ( FileSet ) enum . nextElement ( ) ; if ( ! fs . hasPatterns ( ) && ! fs . hasSelectors ( ) ) { fs = ( FileSet ) fs . clone ( ) ; fs . createInclude ( ) . setName ( "**/*.java" ) ; } File baseDir = fs . getDir ( getProject ( ) ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] files = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { sf . addElement ( new SourceFile ( new File ( baseDir , files [ i ] ) ) ) ; } } } private void parsePackages ( Vector pn , Path sp ) { Vector addedPackages = new Vector ( ) ; Vector dirSets = ( Vector ) packageSets . clone ( ) ; if ( sourcePath != null && packageNames . size ( ) > 0 ) { PatternSet ps = new PatternSet ( ) ; Enumeration enum = packageNames . elements ( ) ; while ( enum . hasMoreElements ( ) ) { PackageName p = ( PackageName ) enum . nextElement ( ) ; String pkg = p . getName ( ) . replace ( '.' , '/' ) ; if ( pkg . endsWith ( "*" ) ) { pkg += "*" ; } ps . createInclude ( ) . setName ( pkg ) ; } enum = excludePackageNames . elements ( ) ; while ( enum . hasMoreElements ( ) ) { PackageName p = ( PackageName ) enum . nextElement ( ) ; String pkg = p . getName ( ) . replace ( '.' , '/' ) ; if ( pkg . endsWith ( "*" ) ) { pkg += "*" ; } ps . createExclude ( ) . setName ( pkg ) ; } String [ ] pathElements = sourcePath . list ( ) ; for ( int i = 0 ; i < pathElements . length ; i ++ ) { DirSet ds = new DirSet ( ) ; ds . setDefaultexcludes ( useDefaultExcludes ) ; ds . setDir ( new File ( pathElements [ i ] ) ) ; ds . createPatternSet ( ) . addConfiguredPatternset ( ps ) ; dirSets . addElement ( ds ) ; } } Enumeration enum = dirSets . elements ( ) ; while ( enum . hasMoreElements ( ) ) { DirSet ds = ( DirSet ) enum . nextElement ( ) ; File baseDir = ds . getDir ( getProject ( ) ) ; log ( "scanning " + baseDir + " for packages." , Project . MSG_DEBUG ) ; DirectoryScanner dsc = ds . getDirectoryScanner ( getProject ( ) ) ; String [ ] dirs = dsc . getIncludedDirectories ( ) ; boolean containsPackages = false ; for ( int i = 0 ; i < dirs . length ; i ++ ) { File pd = new File ( baseDir , dirs [ i ] ) ; String [ ] files = pd . list ( new FilenameFilter ( ) { public boolean accept ( File dir1 , String name ) { if ( name . endsWith ( ".java" ) ) { return true ; } return false ; } } ) ; if ( files . length > 0 ) { containsPackages = true ; String packageName = dirs [ i ] . replace ( File . separatorChar , '.' ) ; if ( ! addedPackages . contains ( packageName ) ) { addedPackages . addElement ( packageName ) ; pn . addElement ( packageName ) ; } } } if ( containsPackages ) { sp . createPathElement ( ) . setLocation ( baseDir ) ; } else { log ( baseDir + " doesn\'t contain any packages, dropping it." , Project . MSG_VERBOSE ) ; } } } private class JavadocOutputStream extends LogOutputStream { JavadocOutputStream ( int level ) { super ( Javadoc . this , level ) ; } private String queuedLine = null ; protected void processLine ( String line , int messageLevel ) { if ( messageLevel == Project . MSG_INFO && line . startsWith ( "Generating " ) ) { if ( queuedLine != null ) { super . processLine ( queuedLine , Project . MSG_VERBOSE ) ; } queuedLine = line ; } else { if ( queuedLine != null ) { if ( line . startsWith ( "Building " ) ) { super . processLine ( queuedLine , Project . MSG_VERBOSE ) ; } else { super . processLine ( queuedLine , Project . MSG_INFO ) ; } queuedLine = null ; } super . processLine ( line , messageLevel ) ; } } protected void logFlush ( ) { if ( queuedLine != null ) { super . processLine ( queuedLine , Project . MSG_VERBOSE ) ; queuedLine = null ; } } } protected String expand ( String content ) { return project . replaceProperties ( content ) ; } } 	1	['81', '3', '0', '35', '213', '2518', '7', '35', '74', '0.94', '2199', '0.966666667', '10', '0.318965517', '0.1375', '3', '3', '25.77777778', '13', '1.6543', '2']
package org . apache . tools . ant . taskdefs ; import java . lang . reflect . Method ; import java . util . Enumeration ; import java . util . Vector ; class ProcessDestroyer extends Thread { private Vector processes = new Vector ( ) ; public ProcessDestroyer ( ) { try { Class [ ] paramTypes = { Thread . class } ; Method addShutdownHook = Runtime . class . getMethod ( "addShutdownHook" , paramTypes ) ; Object [ ] args = { this } ; addShutdownHook . invoke ( Runtime . getRuntime ( ) , args ) ; } catch ( Exception e ) { } } public boolean add ( Process process ) { processes . addElement ( process ) ; return processes . contains ( process ) ; } public boolean remove ( Process process ) { return processes . removeElement ( process ) ; } public void run ( ) { synchronized ( processes ) { Enumeration e = processes . elements ( ) ; while ( e . hasMoreElements ( ) ) { ( ( Process ) e . nextElement ( ) ) . destroy ( ) ; } } } } 	1	['5', '2', '0', '1', '20', '0', '1', '0', '4', '0.75', '106', '0.333333333', '0', '0.921568627', '0.466666667', '0', '0', '19.6', '2', '1', '1']
package org . apache . tools . ant . taskdefs ; import java . io . InputStream ; import java . io . IOException ; import java . io . OutputStream ; public class PumpStreamHandler implements ExecuteStreamHandler { private Thread inputThread ; private Thread errorThread ; private OutputStream out , err ; public PumpStreamHandler ( OutputStream out , OutputStream err ) { this . out = out ; this . err = err ; } public PumpStreamHandler ( OutputStream outAndErr ) { this ( outAndErr , outAndErr ) ; } public PumpStreamHandler ( ) { this ( System . out , System . err ) ; } public void setProcessOutputStream ( InputStream is ) { createProcessOutputPump ( is , out ) ; } public void setProcessErrorStream ( InputStream is ) { createProcessErrorPump ( is , err ) ; } public void setProcessInputStream ( OutputStream os ) { } public void start ( ) { inputThread . start ( ) ; errorThread . start ( ) ; } public void stop ( ) { try { inputThread . join ( ) ; } catch ( InterruptedException e ) { } try { errorThread . join ( ) ; } catch ( InterruptedException e ) { } try { err . flush ( ) ; } catch ( IOException e ) { } try { out . flush ( ) ; } catch ( IOException e ) { } } protected OutputStream getErr ( ) { return err ; } protected OutputStream getOut ( ) { return out ; } protected void createProcessOutputPump ( InputStream is , OutputStream os ) { inputThread = createPump ( is , os ) ; } protected void createProcessErrorPump ( InputStream is , OutputStream os ) { errorThread = createPump ( is , os ) ; } protected Thread createPump ( InputStream is , OutputStream os ) { final Thread result = new Thread ( new StreamPumper ( is , os ) ) ; result . setDaemon ( true ) ; return result ; } } 	1	['13', '1', '2', '9', '20', '46', '7', '2', '8', '0.666666667', '111', '1', '0', '0', '0.615384615', '0', '0', '7.230769231', '1', '0.7692', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . CommandlineJava ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . TimeoutObserver ; import org . apache . tools . ant . util . Watchdog ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . io . PrintStream ; public class ExecuteJava implements Runnable , TimeoutObserver { private Commandline javaCommand = null ; private Path classpath = null ; private CommandlineJava . SysProperties sysProperties = null ; private Method main = null ; private Long timeout = null ; private Throwable caught = null ; private boolean timedOut = false ; private Thread thread = null ; public void setJavaCommand ( Commandline javaCommand ) { this . javaCommand = javaCommand ; } public void setClasspath ( Path p ) { classpath = p ; } public void setSystemProperties ( CommandlineJava . SysProperties s ) { sysProperties = s ; } public void setOutput ( PrintStream out ) { } public void setTimeout ( Long timeout ) { this . timeout = timeout ; } public void execute ( Project project ) throws BuildException { final String classname = javaCommand . getExecutable ( ) ; AntClassLoader loader = null ; try { if ( sysProperties != null ) { sysProperties . setSystem ( ) ; } final Class [ ] param = { Class . forName ( "[Ljava.lang.String;" ) } ; Class target = null ; if ( classpath == null ) { target = Class . forName ( classname ) ; } else { loader = new AntClassLoader ( project . getCoreLoader ( ) , project , classpath , false ) ; loader . setIsolated ( true ) ; loader . setThreadContextLoader ( ) ; target = loader . forceLoadClass ( classname ) ; AntClassLoader . initializeClass ( target ) ; } main = target . getMethod ( "main" , param ) ; if ( main == null ) { throw new BuildException ( "Could not find main() method in " + classname ) ; } if ( timeout == null ) { run ( ) ; } else { thread = new Thread ( this , "ExecuteJava" ) ; Task currentThreadTask = project . getThreadTask ( Thread . currentThread ( ) ) ; project . registerThreadTask ( thread , currentThreadTask ) ; thread . setDaemon ( true ) ; Watchdog w = new Watchdog ( timeout . longValue ( ) ) ; w . addTimeoutObserver ( this ) ; synchronized ( this ) { thread . start ( ) ; w . start ( ) ; try { wait ( ) ; } catch ( InterruptedException e ) { } if ( timedOut ) { project . log ( "Timeout: sub-process interrupted" , Project . MSG_WARN ) ; } else { thread = null ; w . stop ( ) ; } } } if ( caught != null ) { throw caught ; } } catch ( ClassNotFoundException e ) { throw new BuildException ( "Could not find " + classname + "." + " Make sure you have it in your" + " classpath" ) ; } catch ( SecurityException e ) { throw e ; } catch ( Throwable e ) { throw new BuildException ( e ) ; } finally { if ( loader != null ) { loader . resetThreadContextLoader ( ) ; loader . cleanup ( ) ; } if ( sysProperties != null ) { sysProperties . restoreSystem ( ) ; } } } public void run ( ) { final Object [ ] argument = { javaCommand . getArguments ( ) } ; try { main . invoke ( null , argument ) ; } catch ( InvocationTargetException e ) { Throwable t = e . getTargetException ( ) ; if ( ! ( t instanceof InterruptedException ) ) { caught = t ; } } catch ( Throwable t ) { caught = t ; } finally { synchronized ( this ) { notifyAll ( ) ; } } } public synchronized void timeoutOccured ( Watchdog w ) { if ( thread != null ) { timedOut = true ; thread . interrupt ( ) ; } notifyAll ( ) ; } public boolean killedProcess ( ) { return timedOut ; } } 	1	['10', '1', '0', '10', '47', '11', '1', '9', '10', '0.75', '329', '1', '3', '0', '0.2125', '0', '0', '31.1', '6', '1.5', '1']
package org . apache . tools . ant . util ; import java . io . BufferedInputStream ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . io . Reader ; import java . lang . reflect . Method ; import java . text . DecimalFormat ; import java . util . Random ; import java . util . Stack ; import java . util . StringTokenizer ; import java . util . Vector ; import java . net . URL ; import java . net . MalformedURLException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . filters . util . ChainReaderHelper ; import org . apache . tools . ant . types . FilterSetCollection ; import org . apache . tools . ant . taskdefs . condition . Os ; public class FileUtils { private static Random rand = new Random ( System . currentTimeMillis ( ) ) ; private static Object lockReflection = new Object ( ) ; private static java . lang . reflect . Method setLastModified = null ; private boolean onNetWare = Os . isFamily ( "netware" ) ; public static FileUtils newFileUtils ( ) { return new FileUtils ( ) ; } protected FileUtils ( ) { } public URL getFileURL ( File file ) throws MalformedURLException { String uri = "file:" + file . getAbsolutePath ( ) . replace ( '\\' , '/' ) ; for ( int i = uri . indexOf ( '#' ) ; i != - 1 ; i = uri . indexOf ( '#' ) ) { uri = uri . substring ( 0 , i ) + "%23" + uri . substring ( i + 1 ) ; } if ( file . isDirectory ( ) ) { uri += "/" ; } return new URL ( uri ) ; } public void copyFile ( String sourceFile , String destFile ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , null , false , false ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , false , false ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , boolean overwrite ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , overwrite , false ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , overwrite , preserveLastModified ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified , String encoding ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , overwrite , preserveLastModified , encoding ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String encoding , Project project ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , filterChains , overwrite , preserveLastModified , encoding , project ) ; } public void copyFile ( File sourceFile , File destFile ) throws IOException { copyFile ( sourceFile , destFile , null , false , false ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters ) throws IOException { copyFile ( sourceFile , destFile , filters , false , false ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , boolean overwrite ) throws IOException { copyFile ( sourceFile , destFile , filters , overwrite , false ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified ) throws IOException { copyFile ( sourceFile , destFile , filters , overwrite , preserveLastModified , null ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified , String encoding ) throws IOException { copyFile ( sourceFile , destFile , filters , null , overwrite , preserveLastModified , encoding , null ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String encoding , Project project ) throws IOException { if ( overwrite || ! destFile . exists ( ) || destFile . lastModified ( ) < sourceFile . lastModified ( ) ) { if ( destFile . exists ( ) && destFile . isFile ( ) ) { destFile . delete ( ) ; } File parent = getParentFile ( destFile ) ; if ( ! parent . exists ( ) ) { parent . mkdirs ( ) ; } final boolean filterSetsAvailable = ( filters != null && filters . hasFilters ( ) ) ; final boolean filterChainsAvailable = ( filterChains != null && filterChains . size ( ) > 0 ) ; if ( filterSetsAvailable || filterChainsAvailable ) { BufferedReader in = null ; BufferedWriter out = null ; try { if ( encoding == null ) { in = new BufferedReader ( new FileReader ( sourceFile ) ) ; out = new BufferedWriter ( new FileWriter ( destFile ) ) ; } else { in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( sourceFile ) , encoding ) ) ; out = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( destFile ) , encoding ) ) ; } if ( filterChainsAvailable ) { ChainReaderHelper crh = new ChainReaderHelper ( ) ; crh . setBufferSize ( 8192 ) ; crh . setPrimaryReader ( in ) ; crh . setFilterChains ( filterChains ) ; crh . setProject ( project ) ; Reader rdr = crh . getAssembledReader ( ) ; in = new BufferedReader ( rdr ) ; } int length ; String newline = null ; String line = in . readLine ( ) ; while ( line != null ) { if ( line . length ( ) == 0 ) { out . newLine ( ) ; } else { if ( filterSetsAvailable ) { newline = filters . replaceTokens ( line ) ; } else { newline = line ; } out . write ( newline ) ; out . newLine ( ) ; } line = in . readLine ( ) ; } } finally { if ( out != null ) { out . close ( ) ; } if ( in != null ) { in . close ( ) ; } } } else { FileInputStream in = null ; FileOutputStream out = null ; try { in = new FileInputStream ( sourceFile ) ; out = new FileOutputStream ( destFile ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { out . write ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } finally { if ( out != null ) { out . close ( ) ; } if ( in != null ) { in . close ( ) ; } } } if ( preserveLastModified ) { setFileLastModified ( destFile , sourceFile . lastModified ( ) ) ; } } } protected final Method getSetLastModified ( ) { if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { return null ; } if ( setLastModified == null ) { synchronized ( lockReflection ) { if ( setLastModified == null ) { try { setLastModified = java . io . File . class . getMethod ( "setLastModified" , new Class [ ] { Long . TYPE } ) ; } catch ( NoSuchMethodException nse ) { throw new BuildException ( "File.setlastModified not in JDK > 1.1?" , nse ) ; } } } } return setLastModified ; } public void setFileLastModified ( File file , long time ) throws BuildException { if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { return ; } Long [ ] times = new Long [ 1 ] ; if ( time < 0 ) { times [ 0 ] = new Long ( System . currentTimeMillis ( ) ) ; } else { times [ 0 ] = new Long ( time ) ; } try { getSetLastModified ( ) . invoke ( file , times ) ; } catch ( java . lang . reflect . InvocationTargetException ite ) { Throwable nested = ite . getTargetException ( ) ; throw new BuildException ( "Exception setting the modification time " + "of " + file , nested ) ; } catch ( Throwable other ) { throw new BuildException ( "Exception setting the modification time " + "of " + file , other ) ; } } public File resolveFile ( File file , String filename ) { filename = filename . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( ! onNetWare ) { if ( filename . startsWith ( File . separator ) || ( filename . length ( ) >= 2 && Character . isLetter ( filename . charAt ( 0 ) ) && filename . charAt ( 1 ) == ':' ) ) { return normalize ( filename ) ; } } else { int colon = filename . indexOf ( ":" ) ; if ( filename . startsWith ( File . separator ) || ( colon > - 1 ) ) { return normalize ( filename ) ; } } if ( file == null ) { return new File ( filename ) ; } File helpFile = new File ( file . getAbsolutePath ( ) ) ; StringTokenizer tok = new StringTokenizer ( filename , File . separator ) ; while ( tok . hasMoreTokens ( ) ) { String part = tok . nextToken ( ) ; if ( part . equals ( ".." ) ) { helpFile = getParentFile ( helpFile ) ; if ( helpFile == null ) { String msg = "The file or path you specified (" + filename + ") is invalid relative to " + file . getPath ( ) ; throw new BuildException ( msg ) ; } } else if ( part . equals ( "." ) ) { } else { helpFile = new File ( helpFile , part ) ; } } return new File ( helpFile . getAbsolutePath ( ) ) ; } public File normalize ( String path ) { String orig = path ; path = path . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; int colon = path . indexOf ( ":" ) ; if ( ! onNetWare ) { if ( ! path . startsWith ( File . separator ) && ! ( path . length ( ) >= 2 && Character . isLetter ( path . charAt ( 0 ) ) && colon == 1 ) ) { String msg = path + " is not an absolute path" ; throw new BuildException ( msg ) ; } } else { if ( ! path . startsWith ( File . separator ) && ( colon == - 1 ) ) { String msg = path + " is not an absolute path" ; throw new BuildException ( msg ) ; } } boolean dosWithDrive = false ; String root = null ; if ( ( ! onNetWare && path . length ( ) >= 2 && Character . isLetter ( path . charAt ( 0 ) ) && path . charAt ( 1 ) == ':' ) || ( onNetWare && colon > - 1 ) ) { dosWithDrive = true ; char [ ] ca = path . replace ( '/' , '\\' ) . toCharArray ( ) ; StringBuffer sbRoot = new StringBuffer ( ) ; for ( int i = 0 ; i < colon ; i ++ ) { sbRoot . append ( Character . toUpperCase ( ca [ i ] ) ) ; } sbRoot . append ( ':' ) ; if ( colon + 1 < path . length ( ) ) { sbRoot . append ( File . separatorChar ) ; } root = sbRoot . toString ( ) ; StringBuffer sbPath = new StringBuffer ( ) ; for ( int i = colon + 1 ; i < ca . length ; i ++ ) { if ( ( ca [ i ] != '\\' ) || ( ca [ i ] == '\\' && ca [ i - 1 ] != '\\' ) ) { sbPath . append ( ca [ i ] ) ; } } path = sbPath . toString ( ) . replace ( '\\' , File . separatorChar ) ; } else { if ( path . length ( ) == 1 ) { root = File . separator ; path = "" ; } else if ( path . charAt ( 1 ) == File . separatorChar ) { root = File . separator + File . separator ; path = path . substring ( 2 ) ; } else { root = File . separator ; path = path . substring ( 1 ) ; } } Stack s = new Stack ( ) ; s . push ( root ) ; StringTokenizer tok = new StringTokenizer ( path , File . separator ) ; while ( tok . hasMoreTokens ( ) ) { String thisToken = tok . nextToken ( ) ; if ( "." . equals ( thisToken ) ) { continue ; } else if ( ".." . equals ( thisToken ) ) { if ( s . size ( ) < 2 ) { throw new BuildException ( "Cannot resolve path " + orig ) ; } else { s . pop ( ) ; } } else { s . push ( thisToken ) ; } } StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( i > 1 ) { sb . append ( File . separatorChar ) ; } sb . append ( s . elementAt ( i ) ) ; } path = sb . toString ( ) ; if ( dosWithDrive ) { path = path . replace ( '/' , '\\' ) ; } return new File ( path ) ; } public File createTempFile ( String prefix , String suffix , File parentDir ) { File result = null ; String parent = null ; if ( parentDir != null ) { parent = parentDir . getPath ( ) ; } DecimalFormat fmt = new DecimalFormat ( "#####" ) ; synchronized ( rand ) { do { result = new File ( parent , prefix + fmt . format ( rand . nextInt ( ) ) + suffix ) ; } while ( result . exists ( ) ) ; } return result ; } public boolean contentEquals ( File f1 , File f2 ) throws IOException { if ( f1 . exists ( ) != f2 . exists ( ) ) { return false ; } if ( ! f1 . exists ( ) ) { return true ; } if ( f1 . isDirectory ( ) || f2 . isDirectory ( ) ) { return false ; } if ( f1 . equals ( f2 ) ) { return true ; } if ( f1 . length ( ) != f2 . length ( ) ) { return false ; } InputStream in1 = null ; InputStream in2 = null ; try { in1 = new BufferedInputStream ( new FileInputStream ( f1 ) ) ; in2 = new BufferedInputStream ( new FileInputStream ( f2 ) ) ; int expectedByte = in1 . read ( ) ; while ( expectedByte != - 1 ) { if ( expectedByte != in2 . read ( ) ) { return false ; } expectedByte = in1 . read ( ) ; } if ( in2 . read ( ) != - 1 ) { return false ; } return true ; } finally { if ( in1 != null ) { try { in1 . close ( ) ; } catch ( IOException e ) { } } if ( in2 != null ) { try { in2 . close ( ) ; } catch ( IOException e ) { } } } } public File getParentFile ( File f ) { if ( f != null ) { String p = f . getParent ( ) ; if ( p != null ) { return new File ( p ) ; } } return null ; } public static final String readFully ( Reader rdr ) throws IOException { return readFully ( rdr , 8192 ) ; } public static final String readFully ( Reader rdr , int bufferSize ) throws IOException { if ( bufferSize <= 0 ) { throw new IllegalArgumentException ( "Buffer size must be greater " + "than 0" ) ; } final char [ ] buffer = new char [ bufferSize ] ; int bufferLength = 0 ; String text = null ; StringBuffer textBuffer = null ; while ( bufferLength != - 1 ) { bufferLength = rdr . read ( buffer ) ; if ( bufferLength != - 1 ) { if ( textBuffer == null ) { textBuffer = new StringBuffer ( new String ( buffer , 0 , bufferLength ) ) ; } else { textBuffer . append ( new String ( buffer , 0 , bufferLength ) ) ; } } } if ( textBuffer != null ) { text = textBuffer . toString ( ) ; } return text ; } public boolean createNewFile ( File f ) throws IOException { if ( f != null ) { if ( f . exists ( ) ) { return false ; } FileOutputStream fos = null ; try { fos = new FileOutputStream ( f ) ; fos . write ( new byte [ 0 ] ) ; } finally { if ( fos != null ) { fos . close ( ) ; } } return true ; } return false ; } public boolean isSymbolicLink ( File parent , String name ) throws IOException { File resolvedParent = new File ( parent . getCanonicalPath ( ) ) ; File toTest = new File ( resolvedParent , name ) ; return ! toTest . getAbsolutePath ( ) . equals ( toTest . getCanonicalPath ( ) ) ; } public String removeLeadingPath ( File leading , File path ) { String l = normalize ( leading . getAbsolutePath ( ) ) . getAbsolutePath ( ) + File . separator ; String p = normalize ( path . getAbsolutePath ( ) ) . getAbsolutePath ( ) ; if ( p . startsWith ( l ) ) { return p . substring ( l . length ( ) ) ; } else { return p ; } } } 	1	['29', '1', '0', '28', '120', '396', '25', '6', '25', '0.928571429', '1348', '0.8', '0', '0', '0.278571429', '0', '0', '45.31034483', '29', '2.6207', '1']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedOutputStream ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . PrintStream ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Environment ; import org . apache . tools . ant . util . StringUtils ; public abstract class AbstractCvsTask extends Task { public static final int DEFAULT_COMPRESSION_LEVEL = 3 ; private Commandline cmd = new Commandline ( ) ; private Vector vecCommandlines = new Vector ( ) ; private String cvsRoot ; private String cvsRsh ; private String cvsPackage ; private static final String default_command = "checkout" ; private String command = null ; private boolean quiet = false ; private int compression = 0 ; private boolean noexec = false ; private int port = 0 ; private File passFile = null ; private File dest ; private boolean append = false ; private File output ; private File error ; private boolean failOnError = false ; private ExecuteStreamHandler executeStreamHandler ; private OutputStream outputStream ; private OutputStream errorStream ; public AbstractCvsTask ( ) { super ( ) ; } public void setExecuteStreamHandler ( ExecuteStreamHandler handler ) { this . executeStreamHandler = handler ; } protected ExecuteStreamHandler getExecuteStreamHandler ( ) { if ( this . executeStreamHandler == null ) { setExecuteStreamHandler ( new PumpStreamHandler ( getOutputStream ( ) , getErrorStream ( ) ) ) ; } return this . executeStreamHandler ; } protected void setOutputStream ( OutputStream outputStream ) { this . outputStream = outputStream ; } protected OutputStream getOutputStream ( ) { if ( this . outputStream == null ) { if ( output != null ) { try { setOutputStream ( new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( output . getPath ( ) , append ) ) ) ) ; } catch ( IOException e ) { throw new BuildException ( e , location ) ; } } else { setOutputStream ( new LogOutputStream ( this , Project . MSG_INFO ) ) ; } } return this . outputStream ; } protected void setErrorStream ( OutputStream errorStream ) { this . errorStream = errorStream ; } protected OutputStream getErrorStream ( ) { if ( this . errorStream == null ) { if ( error != null ) { try { setErrorStream ( new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( error . getPath ( ) , append ) ) ) ) ; } catch ( IOException e ) { throw new BuildException ( e , location ) ; } } else { setErrorStream ( new LogOutputStream ( this , Project . MSG_WARN ) ) ; } } return this . errorStream ; } protected void runCommand ( Commandline toExecute ) throws BuildException { Environment env = new Environment ( ) ; if ( port > 0 ) { Environment . Variable var = new Environment . Variable ( ) ; var . setKey ( "CVS_CLIENT_PORT" ) ; var . setValue ( String . valueOf ( port ) ) ; env . addVariable ( var ) ; } if ( passFile == null ) { File defaultPassFile = new File ( System . getProperty ( "cygwin.user.home" , System . getProperty ( "user.home" ) ) + File . separatorChar + ".cvspass" ) ; if ( defaultPassFile . exists ( ) ) this . setPassfile ( defaultPassFile ) ; } if ( passFile != null ) { Environment . Variable var = new Environment . Variable ( ) ; var . setKey ( "CVS_PASSFILE" ) ; var . setValue ( String . valueOf ( passFile ) ) ; env . addVariable ( var ) ; log ( "Using cvs passfile: " + String . valueOf ( passFile ) , Project . MSG_INFO ) ; } if ( cvsRsh != null ) { Environment . Variable var = new Environment . Variable ( ) ; var . setKey ( "CVS_RSH" ) ; var . setValue ( String . valueOf ( cvsRsh ) ) ; env . addVariable ( var ) ; } Execute exe = new Execute ( getExecuteStreamHandler ( ) , null ) ; exe . setAntRun ( project ) ; if ( dest == null ) { dest = project . getBaseDir ( ) ; } if ( ! dest . exists ( ) ) { dest . mkdirs ( ) ; } exe . setWorkingDirectory ( dest ) ; exe . setCommandline ( toExecute . getCommandline ( ) ) ; exe . setEnvironment ( env . getVariables ( ) ) ; try { String actualCommandLine = executeToString ( exe ) ; log ( actualCommandLine , Project . MSG_VERBOSE ) ; int retCode = exe . execute ( ) ; log ( "retCode=" + retCode , Project . MSG_DEBUG ) ; if ( failOnError && retCode != 0 ) { throw new BuildException ( "cvs exited with error code " + retCode + StringUtils . LINE_SEP + "Command line was [" + actualCommandLine + "]" , location ) ; } } catch ( IOException e ) { if ( failOnError ) { throw new BuildException ( e , location ) ; } else { log ( "Caught exception: " + e . getMessage ( ) , Project . MSG_WARN ) ; } } catch ( BuildException e ) { if ( failOnError ) { throw ( e ) ; } else { Throwable t = e . getException ( ) ; if ( t == null ) { t = e ; } log ( "Caught exception: " + t . getMessage ( ) , Project . MSG_WARN ) ; } } catch ( Exception e ) { if ( failOnError ) { throw new BuildException ( e , location ) ; } else { log ( "Caught exception: " + e . getMessage ( ) , Project . MSG_WARN ) ; } } finally { if ( outputStream != null ) { try { outputStream . close ( ) ; } catch ( IOException e ) { } } if ( errorStream != null ) { try { errorStream . close ( ) ; } catch ( IOException e ) { } } } } public void execute ( ) throws BuildException { String savedCommand = getCommand ( ) ; if ( this . getCommand ( ) == null && vecCommandlines . size ( ) == 0 ) { this . setCommand ( AbstractCvsTask . default_command ) ; } String c = this . getCommand ( ) ; Commandline cloned = null ; if ( c != null ) { cloned = ( Commandline ) cmd . clone ( ) ; cloned . createArgument ( true ) . setLine ( c ) ; this . addConfiguredCommandline ( cloned , true ) ; } try { for ( int i = 0 ; i < vecCommandlines . size ( ) ; i ++ ) { this . runCommand ( ( Commandline ) vecCommandlines . elementAt ( i ) ) ; } } finally { if ( cloned != null ) { removeCommandline ( cloned ) ; } setCommand ( savedCommand ) ; } } private String executeToString ( Execute execute ) { StringBuffer stringBuffer = new StringBuffer ( Commandline . describeCommand ( execute . getCommandline ( ) ) ) ; String newLine = StringUtils . LINE_SEP ; String [ ] variableArray = execute . getEnvironment ( ) ; if ( variableArray != null ) { stringBuffer . append ( newLine ) ; stringBuffer . append ( newLine ) ; stringBuffer . append ( "environment:" ) ; stringBuffer . append ( newLine ) ; for ( int z = 0 ; z < variableArray . length ; z ++ ) { stringBuffer . append ( newLine ) ; stringBuffer . append ( "\t" ) ; stringBuffer . append ( variableArray [ z ] ) ; } } return stringBuffer . toString ( ) ; } public void setCvsRoot ( String root ) { if ( root != null ) { if ( root . trim ( ) . equals ( "" ) ) { root = null ; } } this . cvsRoot = root ; } public String getCvsRoot ( ) { return this . cvsRoot ; } public void setCvsRsh ( String rsh ) { if ( rsh != null ) { if ( rsh . trim ( ) . equals ( "" ) ) { rsh = null ; } } this . cvsRsh = rsh ; } public String getCvsRsh ( ) { return this . cvsRsh ; } public void setPort ( int port ) { this . port = port ; } public int getPort ( ) { return this . port ; } public void setPassfile ( File passFile ) { this . passFile = passFile ; } public File getPassFile ( ) { return this . passFile ; } public void setDest ( File dest ) { this . dest = dest ; } public File getDest ( ) { return this . dest ; } public void setPackage ( String p ) { this . cvsPackage = p ; } public String getPackage ( ) { return this . cvsPackage ; } public void setTag ( String p ) { if ( p != null && p . trim ( ) . length ( ) > 0 ) { addCommandArgument ( "-r" ) ; addCommandArgument ( p ) ; } } public void addCommandArgument ( String arg ) { this . addCommandArgument ( cmd , arg ) ; } public void addCommandArgument ( Commandline c , String arg ) { c . createArgument ( ) . setValue ( arg ) ; } public void setDate ( String p ) { if ( p != null && p . trim ( ) . length ( ) > 0 ) { addCommandArgument ( "-D" ) ; addCommandArgument ( p ) ; } } public void setCommand ( String c ) { this . command = c ; } public String getCommand ( ) { return this . command ; } public void setQuiet ( boolean q ) { quiet = q ; } public void setNoexec ( boolean ne ) { noexec = ne ; } public void setOutput ( File output ) { this . output = output ; } public void setError ( File error ) { this . error = error ; } public void setAppend ( boolean value ) { this . append = value ; } public void setFailOnError ( boolean failOnError ) { this . failOnError = failOnError ; } protected void configureCommandline ( Commandline c ) { if ( c == null ) { return ; } c . setExecutable ( "cvs" ) ; if ( cvsPackage != null ) { c . createArgument ( ) . setLine ( cvsPackage ) ; } if ( this . compression > 0 && this . compression < 10 ) { c . createArgument ( true ) . setValue ( "-z" + this . compression ) ; } if ( quiet ) { c . createArgument ( true ) . setValue ( "-q" ) ; } if ( noexec ) { c . createArgument ( true ) . setValue ( "-n" ) ; } if ( cvsRoot != null ) { c . createArgument ( true ) . setLine ( "-d" + cvsRoot ) ; } } protected void removeCommandline ( Commandline c ) { vecCommandlines . removeElement ( c ) ; } public void addConfiguredCommandline ( Commandline c ) { this . addConfiguredCommandline ( c , false ) ; } public void addConfiguredCommandline ( Commandline c , boolean insertAtStart ) { if ( c == null ) { return ; } this . configureCommandline ( c ) ; if ( insertAtStart ) { vecCommandlines . insertElementAt ( c , 0 ) ; } else { vecCommandlines . addElement ( c ) ; } } public void setCompressionLevel ( int level ) { this . compression = level ; } public void setCompression ( boolean usecomp ) { setCompressionLevel ( usecomp ? AbstractCvsTask . DEFAULT_COMPRESSION_LEVEL : 0 ) ; } } 	1	['40', '3', '1', '17', '99', '664', '2', '15', '31', '0.918192918', '855', '0.952380952', '2', '0.486842105', '0.194444444', '0', '0', '19.85', '8', '1.6', '1']
package org . apache . tools . ant ; import org . apache . tools . ant . util . DOMElementWriter ; import org . apache . tools . ant . util . StringUtils ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Text ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . PrintStream ; import java . io . Writer ; import java . util . Hashtable ; import java . util . Stack ; public class XmlLogger implements BuildLogger { private int msgOutputLevel = Project . MSG_DEBUG ; private PrintStream outStream ; private static final DocumentBuilder builder = getDocumentBuilder ( ) ; private static DocumentBuilder getDocumentBuilder ( ) { try { return DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; } catch ( Exception exc ) { throw new ExceptionInInitializerError ( exc ) ; } } private static final String BUILD_TAG = "build" ; private static final String TARGET_TAG = "target" ; private static final String TASK_TAG = "task" ; private static final String MESSAGE_TAG = "message" ; private static final String NAME_ATTR = "name" ; private static final String TIME_ATTR = "time" ; private static final String PRIORITY_ATTR = "priority" ; private static final String LOCATION_ATTR = "location" ; private static final String ERROR_ATTR = "error" ; private static final String STACKTRACE_TAG = "stacktrace" ; private Document doc = builder . newDocument ( ) ; private Hashtable tasks = new Hashtable ( ) ; private Hashtable targets = new Hashtable ( ) ; private Hashtable threadStacks = new Hashtable ( ) ; private TimedElement buildElement = null ; private static class TimedElement { private long startTime ; private Element element ; } public XmlLogger ( ) { } public void buildStarted ( BuildEvent event ) { buildElement = new TimedElement ( ) ; buildElement . startTime = System . currentTimeMillis ( ) ; buildElement . element = doc . createElement ( BUILD_TAG ) ; } public void buildFinished ( BuildEvent event ) { long totalTime = System . currentTimeMillis ( ) - buildElement . startTime ; buildElement . element . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; if ( event . getException ( ) != null ) { buildElement . element . setAttribute ( ERROR_ATTR , event . getException ( ) . toString ( ) ) ; Throwable t = event . getException ( ) ; Text errText = doc . createCDATASection ( StringUtils . getStackTrace ( t ) ) ; Element stacktrace = doc . createElement ( STACKTRACE_TAG ) ; stacktrace . appendChild ( errText ) ; buildElement . element . appendChild ( stacktrace ) ; } String outFilename = event . getProject ( ) . getProperty ( "XmlLogger.file" ) ; if ( outFilename == null ) { outFilename = "log.xml" ; } String xslUri = event . getProject ( ) . getProperty ( "ant.XmlLogger.stylesheet.uri" ) ; if ( xslUri == null ) { xslUri = "log.xsl" ; } Writer out = null ; try { OutputStream stream = outStream ; if ( stream == null ) { stream = new FileOutputStream ( outFilename ) ; } out = new OutputStreamWriter ( stream , "UTF8" ) ; out . write ( "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n" ) ; if ( xslUri . length ( ) > 0 ) { out . write ( "<?xml-stylesheet type=\"text/xsl\" href=\"" + xslUri + "\"?>\n\n" ) ; } ( new DOMElementWriter ( ) ) . write ( buildElement . element , out , 0 , "\t" ) ; out . flush ( ) ; } catch ( IOException exc ) { throw new BuildException ( "Unable to write log file" , exc ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( IOException e ) { } } } buildElement = null ; } private Stack getStack ( ) { Stack threadStack = ( Stack ) threadStacks . get ( Thread . currentThread ( ) ) ; if ( threadStack == null ) { threadStack = new Stack ( ) ; threadStacks . put ( Thread . currentThread ( ) , threadStack ) ; } return threadStack ; } public void targetStarted ( BuildEvent event ) { Target target = event . getTarget ( ) ; TimedElement targetElement = new TimedElement ( ) ; targetElement . startTime = System . currentTimeMillis ( ) ; targetElement . element = doc . createElement ( TARGET_TAG ) ; targetElement . element . setAttribute ( NAME_ATTR , target . getName ( ) ) ; targets . put ( target , targetElement ) ; getStack ( ) . push ( targetElement ) ; } public void targetFinished ( BuildEvent event ) { Target target = event . getTarget ( ) ; TimedElement targetElement = ( TimedElement ) targets . get ( target ) ; if ( targetElement != null ) { long totalTime = System . currentTimeMillis ( ) - targetElement . startTime ; targetElement . element . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; TimedElement parentElement = null ; Stack threadStack = getStack ( ) ; if ( ! threadStack . empty ( ) ) { TimedElement poppedStack = ( TimedElement ) threadStack . pop ( ) ; if ( poppedStack != targetElement ) { throw new RuntimeException ( "Mismatch - popped element = " + poppedStack . element + " finished target element = " + targetElement . element ) ; } if ( ! threadStack . empty ( ) ) { parentElement = ( TimedElement ) threadStack . peek ( ) ; } } if ( parentElement == null ) { buildElement . element . appendChild ( targetElement . element ) ; } else { parentElement . element . appendChild ( targetElement . element ) ; } } } public void taskStarted ( BuildEvent event ) { Task task = event . getTask ( ) ; TimedElement taskElement = new TimedElement ( ) ; taskElement . startTime = System . currentTimeMillis ( ) ; taskElement . element = doc . createElement ( TASK_TAG ) ; String name = event . getTask ( ) . getTaskName ( ) ; taskElement . element . setAttribute ( NAME_ATTR , name ) ; taskElement . element . setAttribute ( LOCATION_ATTR , event . getTask ( ) . getLocation ( ) . toString ( ) ) ; tasks . put ( task , taskElement ) ; getStack ( ) . push ( taskElement ) ; } public void taskFinished ( BuildEvent event ) { Task task = event . getTask ( ) ; TimedElement taskElement = ( TimedElement ) tasks . get ( task ) ; if ( taskElement != null ) { long totalTime = System . currentTimeMillis ( ) - taskElement . startTime ; taskElement . element . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; Target target = task . getOwningTarget ( ) ; TimedElement targetElement = null ; if ( target != null ) { targetElement = ( TimedElement ) targets . get ( target ) ; } if ( targetElement == null ) { buildElement . element . appendChild ( taskElement . element ) ; } else { targetElement . element . appendChild ( taskElement . element ) ; } Stack threadStack = getStack ( ) ; if ( ! threadStack . empty ( ) ) { TimedElement poppedStack = ( TimedElement ) threadStack . pop ( ) ; if ( poppedStack != taskElement ) { throw new RuntimeException ( "Mismatch - popped element = " + poppedStack . element + " finished task element = " + taskElement . element ) ; } } } } public void messageLogged ( BuildEvent event ) { int priority = event . getPriority ( ) ; if ( priority > msgOutputLevel ) { return ; } Element messageElement = doc . createElement ( MESSAGE_TAG ) ; String name = "debug" ; switch ( event . getPriority ( ) ) { case Project . MSG_ERR : name = "error" ; break ; case Project . MSG_WARN : name = "warn" ; break ; case Project . MSG_INFO : name = "info" ; break ; default : name = "debug" ; break ; } messageElement . setAttribute ( PRIORITY_ATTR , name ) ; Text messageText = doc . createCDATASection ( event . getMessage ( ) ) ; messageElement . appendChild ( messageText ) ; TimedElement parentElement = null ; Task task = event . getTask ( ) ; Target target = event . getTarget ( ) ; if ( task != null ) { parentElement = ( TimedElement ) tasks . get ( task ) ; } if ( parentElement == null && target != null ) { parentElement = ( TimedElement ) targets . get ( target ) ; } if ( parentElement == null ) { Stack threadStack = ( Stack ) threadStacks . get ( Thread . currentThread ( ) ) ; if ( threadStack != null ) { if ( ! threadStack . empty ( ) ) { parentElement = ( TimedElement ) threadStack . peek ( ) ; } } } if ( parentElement != null ) { parentElement . element . appendChild ( messageElement ) ; } else { buildElement . element . appendChild ( messageElement ) ; } } public void setMessageOutputLevel ( int level ) { msgOutputLevel = level ; } public void setOutputPrintStream ( PrintStream output ) { this . outStream = new PrintStream ( output , true ) ; } public void setEmacsMode ( boolean emacsMode ) { } public void setErrorPrintStream ( PrintStream err ) { } } 	1	['15', '1', '0', '12', '69', '39', '0', '12', '12', '0.932539683', '614', '1', '1', '0', '0.342857143', '0', '0', '38.73333333', '10', '2.7333', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . taskdefs . condition . Os ; import java . io . File ; import java . io . IOException ; import java . io . BufferedReader ; import java . io . StringReader ; import java . io . ByteArrayOutputStream ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . Vector ; public class Execute { public static final int INVALID = Integer . MAX_VALUE ; private String [ ] cmdl = null ; private String [ ] env = null ; private int exitValue = INVALID ; private ExecuteStreamHandler streamHandler ; private ExecuteWatchdog watchdog ; private File workingDirectory = null ; private Project project = null ; private boolean newEnvironment = false ; private boolean useVMLauncher = true ; private static String antWorkingDirectory = System . getProperty ( "user.dir" ) ; private static CommandLauncher vmLauncher = null ; private static CommandLauncher shellLauncher = null ; private static Vector procEnvironment = null ; private static ProcessDestroyer processDestroyer = new ProcessDestroyer ( ) ; static { try { vmLauncher = new Java13CommandLauncher ( ) ; } catch ( NoSuchMethodException exc ) { } if ( Os . isFamily ( "mac" ) ) { shellLauncher = new MacCommandLauncher ( new CommandLauncher ( ) ) ; } else if ( Os . isFamily ( "os/2" ) ) { shellLauncher = new WinNTCommandLauncher ( new CommandLauncher ( ) ) ; } else if ( Os . isFamily ( "windows" ) ) { CommandLauncher baseLauncher ; if ( System . getProperty ( "java.version" ) . startsWith ( "1.1" ) ) { baseLauncher = new Java11CommandLauncher ( ) ; } else { baseLauncher = new CommandLauncher ( ) ; } if ( ! Os . isFamily ( "win9x" ) ) { shellLauncher = new WinNTCommandLauncher ( baseLauncher ) ; } else { shellLauncher = new ScriptCommandLauncher ( "bin/antRun.bat" , baseLauncher ) ; } } else if ( Os . isFamily ( "netware" ) ) { CommandLauncher baseLauncher ; if ( System . getProperty ( "java.version" ) . startsWith ( "1.1" ) ) { baseLauncher = new Java11CommandLauncher ( ) ; } else { baseLauncher = new CommandLauncher ( ) ; } shellLauncher = new PerlScriptCommandLauncher ( "bin/antRun.pl" , baseLauncher ) ; } else { shellLauncher = new ScriptCommandLauncher ( "bin/antRun" , new CommandLauncher ( ) ) ; } } public static synchronized Vector getProcEnvironment ( ) { if ( procEnvironment != null ) { return procEnvironment ; } procEnvironment = new Vector ( ) ; try { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; Execute exe = new Execute ( new PumpStreamHandler ( out ) ) ; exe . setCommandline ( getProcEnvCommand ( ) ) ; exe . setNewenvironment ( true ) ; int retval = exe . execute ( ) ; if ( retval != 0 ) { } BufferedReader in = new BufferedReader ( new StringReader ( toString ( out ) ) ) ; String var = null ; String line , lineSep = System . getProperty ( "line.separator" ) ; while ( ( line = in . readLine ( ) ) != null ) { if ( line . indexOf ( '=' ) == - 1 ) { if ( var == null ) { var = lineSep + line ; } else { var += lineSep + line ; } } else { if ( var != null ) { procEnvironment . addElement ( var ) ; } var = line ; } } if ( var != null ) { procEnvironment . addElement ( var ) ; } } catch ( java . io . IOException exc ) { exc . printStackTrace ( ) ; } return procEnvironment ; } private static String [ ] getProcEnvCommand ( ) { if ( Os . isFamily ( "os/2" ) ) { String [ ] cmd = { "cmd" , "/c" , "set" } ; return cmd ; } else if ( Os . isFamily ( "windows" ) ) { if ( ! Os . isFamily ( "win9x" ) ) { String [ ] cmd = { "cmd" , "/c" , "set" } ; return cmd ; } else { String [ ] cmd = { "command.com" , "/c" , "set" } ; return cmd ; } } else if ( Os . isFamily ( "z/os" ) ) { String [ ] cmd = { "/bin/env" } ; return cmd ; } else if ( Os . isFamily ( "unix" ) ) { String [ ] cmd = { "/usr/bin/env" } ; return cmd ; } else if ( Os . isFamily ( "netware" ) ) { String [ ] cmd = { "env" } ; return cmd ; } else { String [ ] cmd = null ; return cmd ; } } public static String toString ( ByteArrayOutputStream bos ) { if ( Os . isFamily ( "z/os" ) ) { try { bos . toString ( "Cp1047" ) ; } catch ( java . io . UnsupportedEncodingException e ) { } } return bos . toString ( ) ; } public Execute ( ) { this ( new PumpStreamHandler ( ) , null ) ; } public Execute ( ExecuteStreamHandler streamHandler ) { this ( streamHandler , null ) ; } public Execute ( ExecuteStreamHandler streamHandler , ExecuteWatchdog watchdog ) { this . streamHandler = streamHandler ; this . watchdog = watchdog ; } public String [ ] getCommandline ( ) { return cmdl ; } public void setCommandline ( String [ ] commandline ) { cmdl = commandline ; } public void setNewenvironment ( boolean newenv ) { newEnvironment = newenv ; } public String [ ] getEnvironment ( ) { if ( env == null || newEnvironment ) { return env ; } return patchEnvironment ( ) ; } public void setEnvironment ( String [ ] env ) { this . env = env ; } public void setWorkingDirectory ( File wd ) { if ( wd == null || wd . getAbsolutePath ( ) . equals ( antWorkingDirectory ) ) { workingDirectory = null ; } else { workingDirectory = wd ; } } public void setAntRun ( Project project ) throws BuildException { this . project = project ; } public void setVMLauncher ( boolean useVMLauncher ) { this . useVMLauncher = useVMLauncher ; } public static Process launch ( Project project , String [ ] command , String [ ] env , File dir , boolean useVM ) throws IOException { CommandLauncher launcher = vmLauncher != null ? vmLauncher : shellLauncher ; if ( ! useVM ) { launcher = shellLauncher ; } return launcher . exec ( project , command , env , dir ) ; } public int execute ( ) throws IOException { final Process process = launch ( project , getCommandline ( ) , getEnvironment ( ) , workingDirectory , useVMLauncher ) ; try { streamHandler . setProcessInputStream ( process . getOutputStream ( ) ) ; streamHandler . setProcessOutputStream ( process . getInputStream ( ) ) ; streamHandler . setProcessErrorStream ( process . getErrorStream ( ) ) ; } catch ( IOException e ) { process . destroy ( ) ; throw e ; } streamHandler . start ( ) ; processDestroyer . add ( process ) ; if ( watchdog != null ) { watchdog . start ( process ) ; } waitFor ( process ) ; processDestroyer . remove ( process ) ; if ( watchdog != null ) { watchdog . stop ( ) ; } streamHandler . stop ( ) ; if ( watchdog != null ) { watchdog . checkException ( ) ; } return getExitValue ( ) ; } protected void waitFor ( Process process ) { try { process . waitFor ( ) ; setExitValue ( process . exitValue ( ) ) ; } catch ( InterruptedException e ) { } } protected void setExitValue ( int value ) { exitValue = value ; } public int getExitValue ( ) { return exitValue ; } public boolean killedProcess ( ) { return watchdog != null && watchdog . killedProcess ( ) ; } private String [ ] patchEnvironment ( ) { Vector osEnv = ( Vector ) getProcEnvironment ( ) . clone ( ) ; for ( int i = 0 ; i < env . length ; i ++ ) { int pos = env [ i ] . indexOf ( '=' ) ; String key = env [ i ] . substring ( 0 , pos + 1 ) ; int size = osEnv . size ( ) ; for ( int j = 0 ; j < size ; j ++ ) { if ( ( ( String ) osEnv . elementAt ( j ) ) . startsWith ( key ) ) { osEnv . removeElementAt ( j ) ; break ; } } osEnv . addElement ( env [ i ] ) ; } String [ ] result = new String [ osEnv . size ( ) ] ; osEnv . copyInto ( result ) ; return result ; } public static void runCommand ( Task task , String [ ] cmdline ) throws BuildException { try { task . log ( Commandline . describeCommand ( cmdline ) , Project . MSG_VERBOSE ) ; Execute exe = new Execute ( new LogStreamHandler ( task , Project . MSG_INFO , Project . MSG_ERR ) ) ; exe . setAntRun ( task . getProject ( ) ) ; exe . setCommandline ( cmdline ) ; int retval = exe . execute ( ) ; if ( retval != 0 ) { throw new BuildException ( cmdline [ 0 ] + " failed with return code " + retval , task . getLocation ( ) ) ; } } catch ( java . io . IOException exc ) { throw new BuildException ( "Could not launch " + cmdline [ 0 ] + ": " + exc , task . getLocation ( ) ) ; } } private static class CommandLauncher { public Process exec ( Project project , String [ ] cmd , String [ ] env ) throws IOException { if ( project != null ) { project . log ( "Execute:CommandLauncher: " + Commandline . describeCommand ( cmd ) , Project . MSG_DEBUG ) ; } return Runtime . getRuntime ( ) . exec ( cmd , env ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } throw new IOException ( "Cannot execute a process in different " + "directory under this JVM" ) ; } } private static class Java11CommandLauncher extends CommandLauncher { public Process exec ( Project project , String [ ] cmd , String [ ] env ) throws IOException { String [ ] newcmd = new String [ cmd . length ] ; for ( int i = 0 ; i < cmd . length ; i ++ ) { newcmd [ i ] = Commandline . quoteArgument ( cmd [ i ] ) ; } if ( project != null ) { project . log ( "Execute:Java11CommandLauncher: " + Commandline . describeCommand ( newcmd ) , Project . MSG_DEBUG ) ; } return Runtime . getRuntime ( ) . exec ( newcmd , env ) ; } } private static class Java13CommandLauncher extends CommandLauncher { public Java13CommandLauncher ( ) throws NoSuchMethodException { _execWithCWD = Runtime . class . getMethod ( "exec" , new Class [ ] { String [ ] . class , String [ ] . class , File . class } ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { try { if ( project != null ) { project . log ( "Execute:Java13CommandLauncher: " + Commandline . describeCommand ( cmd ) , Project . MSG_DEBUG ) ; } Object [ ] arguments = { cmd , env , workingDir } ; return ( Process ) _execWithCWD . invoke ( Runtime . getRuntime ( ) , arguments ) ; } catch ( InvocationTargetException exc ) { Throwable realexc = exc . getTargetException ( ) ; if ( realexc instanceof ThreadDeath ) { throw ( ThreadDeath ) realexc ; } else if ( realexc instanceof IOException ) { throw ( IOException ) realexc ; } else { throw new BuildException ( "Unable to execute command" , realexc ) ; } } catch ( Exception exc ) { throw new BuildException ( "Unable to execute command" , exc ) ; } } private Method _execWithCWD ; } private static class CommandLauncherProxy extends CommandLauncher { CommandLauncherProxy ( CommandLauncher launcher ) { _launcher = launcher ; } public Process exec ( Project project , String [ ] cmd , String [ ] env ) throws IOException { return _launcher . exec ( project , cmd , env ) ; } private CommandLauncher _launcher ; } private static class WinNTCommandLauncher extends CommandLauncherProxy { WinNTCommandLauncher ( CommandLauncher launcher ) { super ( launcher ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { File commandDir = workingDir ; if ( workingDir == null ) { if ( project != null ) { commandDir = project . getBaseDir ( ) ; } else { return exec ( project , cmd , env ) ; } } final int preCmdLength = 6 ; String [ ] newcmd = new String [ cmd . length + preCmdLength ] ; newcmd [ 0 ] = "cmd" ; newcmd [ 1 ] = "/c" ; newcmd [ 2 ] = "cd" ; newcmd [ 3 ] = "/d" ; newcmd [ 4 ] = commandDir . getAbsolutePath ( ) ; newcmd [ 5 ] = "&&" ; System . arraycopy ( cmd , 0 , newcmd , preCmdLength , cmd . length ) ; return exec ( project , newcmd , env ) ; } } private static class MacCommandLauncher extends CommandLauncherProxy { MacCommandLauncher ( CommandLauncher launcher ) { super ( launcher ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } System . getProperties ( ) . put ( "user.dir" , workingDir . getAbsolutePath ( ) ) ; try { return exec ( project , cmd , env ) ; } finally { System . getProperties ( ) . put ( "user.dir" , antWorkingDirectory ) ; } } } private static class ScriptCommandLauncher extends CommandLauncherProxy { ScriptCommandLauncher ( String script , CommandLauncher launcher ) { super ( launcher ) ; _script = script ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( project == null ) { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } throw new IOException ( "Cannot locate antRun script: " + "No project provided" ) ; } String antHome = project . getProperty ( "ant.home" ) ; if ( antHome == null ) { throw new IOException ( "Cannot locate antRun script: " + "Property 'ant.home' not found" ) ; } String antRun = project . resolveFile ( antHome + File . separator + _script ) . toString ( ) ; File commandDir = workingDir ; if ( workingDir == null && project != null ) { commandDir = project . getBaseDir ( ) ; } String [ ] newcmd = new String [ cmd . length + 2 ] ; newcmd [ 0 ] = antRun ; newcmd [ 1 ] = commandDir . getAbsolutePath ( ) ; System . arraycopy ( cmd , 0 , newcmd , 2 , cmd . length ) ; return exec ( project , newcmd , env ) ; } private String _script ; } private static class PerlScriptCommandLauncher extends CommandLauncherProxy { PerlScriptCommandLauncher ( String script , CommandLauncher launcher ) { super ( launcher ) ; _script = script ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( project == null ) { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } throw new IOException ( "Cannot locate antRun script: " + "No project provided" ) ; } String antHome = project . getProperty ( "ant.home" ) ; if ( antHome == null ) { throw new IOException ( "Cannot locate antRun script: " + "Property 'ant.home' not found" ) ; } String antRun = project . resolveFile ( antHome + File . separator + _script ) . toString ( ) ; File commandDir = workingDir ; if ( workingDir == null && project != null ) { commandDir = project . getBaseDir ( ) ; } String [ ] newcmd = new String [ cmd . length + 3 ] ; newcmd [ 0 ] = "perl" ; newcmd [ 1 ] = antRun ; newcmd [ 2 ] = commandDir . getAbsolutePath ( ) ; System . arraycopy ( cmd , 0 , newcmd , 3 , cmd . length ) ; return exec ( project , newcmd , env ) ; } private String _script ; } } 	1	['24', '1', '0', '31', '85', '218', '12', '20', '18', '0.776811594', '708', '0.933333333', '6', '0', '0.138339921', '0', '0', '27.875', '7', '1.75', '1']
package org . apache . tools . ant ; public class ExitException extends SecurityException { private int status ; public ExitException ( int status ) { super ( "ExitException: status " + status ) ; this . status = status ; } public int getStatus ( ) { return status ; } } 	1	['2', '5', '0', '1', '7', '0', '1', '0', '2', '0', '20', '1', '0', '0.928571429', '0.75', '0', '0', '8.5', '1', '0.5', '1']
package org . apache . tools . ant . taskdefs . cvslib ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . Cvs ; import org . apache . tools . ant . util . FileUtils ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . IOException ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . UnsupportedEncodingException ; import java . util . Vector ; public class CvsTagDiff extends Task { static final String FILE_IS_NEW = " is new; current revision " ; static final String FILE_HAS_CHANGED = " changed from revision " ; static final String FILE_WAS_REMOVED = " is removed" ; private Cvs m_cvs ; private String m_package ; private String m_startTag ; private String m_endTag ; private String m_startDate ; private String m_endDate ; private File m_destfile ; private FileUtils m_fileUtils = FileUtils . newFileUtils ( ) ; public void init ( ) throws BuildException { m_cvs = ( Cvs ) getProject ( ) . createTask ( "cvs" ) ; } public void setCompressionLevel ( int level ) { m_cvs . setCompressionLevel ( level ) ; } public void setCompression ( boolean usecomp ) { m_cvs . setCompression ( usecomp ) ; } public void setCvsRoot ( String cvsRoot ) { m_cvs . setCvsRoot ( cvsRoot ) ; } public void setCvsRsh ( String rsh ) { m_cvs . setCvsRsh ( rsh ) ; } public void setPackage ( String p ) { m_package = p ; } public void setQuiet ( boolean quiet ) { m_cvs . setQuiet ( quiet ) ; } public void setPort ( int port ) { m_cvs . setPort ( port ) ; } public void setPassfile ( File f ) { m_cvs . setPassfile ( f ) ; } public void setFailOnError ( boolean b ) { m_cvs . setFailOnError ( b ) ; } public void setStartTag ( String s ) { m_startTag = s ; } public void setStartDate ( String s ) { m_startDate = s ; } public void setEndTag ( String s ) { m_endTag = s ; } public void setEndDate ( String s ) { m_endDate = s ; } public void setDestFile ( File f ) { m_destfile = f ; } public void execute ( ) throws BuildException { validate ( ) ; String rdiff = "rdiff -s " + ( m_startTag != null ? ( "-r " + m_startTag ) : ( "-D " + m_startDate ) ) + " " + ( m_endTag != null ? ( "-r " + m_endTag ) : ( "-D " + m_endDate ) ) + " " + m_package ; log ( "Cvs command is " + rdiff , Project . MSG_VERBOSE ) ; m_cvs . setCommand ( rdiff ) ; File tmpFile = null ; try { tmpFile = m_fileUtils . createTempFile ( "cvstagdiff" , ".log" , null ) ; m_cvs . setOutput ( tmpFile ) ; m_cvs . execute ( ) ; CvsTagEntry [ ] entries = parseRDiff ( tmpFile ) ; writeTagDiff ( entries ) ; } finally { if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } private CvsTagEntry [ ] parseRDiff ( File tmpFile ) throws BuildException { BufferedReader reader = null ; try { reader = new BufferedReader ( new FileReader ( tmpFile ) ) ; int headerLength = 5 + m_package . length ( ) + 1 ; Vector entries = new Vector ( ) ; String line = reader . readLine ( ) ; int index ; CvsTagEntry entry = null ; while ( null != line ) { line = line . substring ( headerLength ) ; if ( ( index = line . indexOf ( FILE_IS_NEW ) ) != - 1 ) { String filename = line . substring ( 0 , index ) ; String rev = line . substring ( index + FILE_IS_NEW . length ( ) ) ; entries . addElement ( entry = new CvsTagEntry ( filename , rev ) ) ; log ( entry . toString ( ) , Project . MSG_VERBOSE ) ; } else if ( ( index = line . indexOf ( FILE_HAS_CHANGED ) ) != - 1 ) { String filename = line . substring ( 0 , index ) ; int revSeparator = line . indexOf ( " to " , index ) ; String prevRevision = line . substring ( index + FILE_HAS_CHANGED . length ( ) , revSeparator ) ; String revision = line . substring ( revSeparator + 4 ) ; entries . addElement ( entry = new CvsTagEntry ( filename , revision , prevRevision ) ) ; log ( entry . toString ( ) , Project . MSG_VERBOSE ) ; } else if ( ( index = line . indexOf ( FILE_WAS_REMOVED ) ) != - 1 ) { String filename = line . substring ( 0 , index ) ; entries . addElement ( entry = new CvsTagEntry ( filename ) ) ; log ( entry . toString ( ) , Project . MSG_VERBOSE ) ; } line = reader . readLine ( ) ; } CvsTagEntry [ ] array = new CvsTagEntry [ entries . size ( ) ] ; entries . copyInto ( array ) ; return array ; } catch ( IOException e ) { throw new BuildException ( "Error in parsing" , e ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { } } } } private void writeTagDiff ( CvsTagEntry [ ] entries ) throws BuildException { FileOutputStream output = null ; try { output = new FileOutputStream ( m_destfile ) ; PrintWriter writer = new PrintWriter ( new OutputStreamWriter ( output , "UTF-8" ) ) ; writer . println ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" ) ; writer . print ( "<tagdiff " ) ; if ( m_startTag != null ) { writer . print ( "startTag=\"" + m_startTag + "\" " ) ; } else { writer . print ( "startDate=\"" + m_startDate + "\" " ) ; } if ( m_endTag != null ) { writer . print ( "endTag=\"" + m_endTag + "\" " ) ; } else { writer . print ( "endDate=\"" + m_endDate + "\" " ) ; } writer . println ( ">" ) ; for ( int i = 0 , c = entries . length ; i < c ; i ++ ) { writeTagEntry ( writer , entries [ i ] ) ; } writer . println ( "</tagdiff>" ) ; writer . flush ( ) ; writer . close ( ) ; } catch ( UnsupportedEncodingException uee ) { log ( uee . toString ( ) , Project . MSG_ERR ) ; } catch ( IOException ioe ) { throw new BuildException ( ioe . toString ( ) , ioe ) ; } finally { if ( null != output ) { try { output . close ( ) ; } catch ( IOException ioe ) { } } } } private void writeTagEntry ( PrintWriter writer , CvsTagEntry entry ) { writer . println ( "\t<entry>" ) ; writer . println ( "\t\t<file>" ) ; writer . println ( "\t\t\t<name>" + entry . getFile ( ) + "</name>" ) ; if ( entry . getRevision ( ) != null ) { writer . println ( "\t\t\t<revision>" + entry . getRevision ( ) + "</revision>" ) ; } if ( entry . getPreviousRevision ( ) != null ) { writer . println ( "\t\t\t<prevrevision>" + entry . getPreviousRevision ( ) + "</prevrevision>" ) ; } writer . println ( "\t\t</file>" ) ; writer . println ( "\t</entry>" ) ; } private void validate ( ) throws BuildException { if ( null == m_package ) { throw new BuildException ( "Package/module must be set." ) ; } if ( null == m_destfile ) { throw new BuildException ( "Destfile must be set." ) ; } if ( null == m_startTag && null == m_startDate ) { throw new BuildException ( "Start tag or start date must be set." ) ; } if ( null != m_startTag && null != m_startDate ) { throw new BuildException ( "Only one of start tag and start date " + "must be set." ) ; } if ( null == m_endTag && null == m_endDate ) { throw new BuildException ( "End tag or end date must be set." ) ; } if ( null != m_endTag && null != m_endDate ) { throw new BuildException ( "Only one of end tag and end date must " + "be set." ) ; } } } 	1	['21', '3', '0', '8', '73', '74', '0', '8', '17', '0.886363636', '669', '0.727272727', '2', '0.649122807', '0.232142857', '1', '1', '30.33333333', '3', '1.0476', '2']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . PatternSet ; import org . apache . tools . ant . util . FileUtils ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . io . IOException ; import java . util . Date ; import java . util . Vector ; import java . util . zip . ZipInputStream ; import java . util . zip . ZipEntry ; public class Expand extends Task { private File dest ; private File source ; private boolean overwrite = true ; private Vector patternsets = new Vector ( ) ; private Vector filesets = new Vector ( ) ; public void execute ( ) throws BuildException { if ( "expand" . equals ( taskType ) ) { log ( "!! expand is deprecated. Use unzip instead. !!" ) ; } if ( source == null && filesets . size ( ) == 0 ) { throw new BuildException ( "src attribute and/or filesets must be " + "specified" ) ; } if ( dest == null ) { throw new BuildException ( "Dest attribute must be specified" ) ; } if ( dest . exists ( ) && ! dest . isDirectory ( ) ) { throw new BuildException ( "Dest must be a directory." , location ) ; } FileUtils fileUtils = FileUtils . newFileUtils ( ) ; if ( source != null ) { if ( source . isDirectory ( ) ) { throw new BuildException ( "Src must not be a directory." + " Use nested filesets instead." , location ) ; } else { expandFile ( fileUtils , source , dest ) ; } } if ( filesets . size ( ) > 0 ) { for ( int j = 0 ; j < filesets . size ( ) ; j ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( j ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; File fromDir = fs . getDir ( project ) ; String [ ] files = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; ++ i ) { File file = new File ( fromDir , files [ i ] ) ; expandFile ( fileUtils , file , dest ) ; } } } } protected void expandFile ( FileUtils fileUtils , File srcF , File dir ) { log ( "Expanding: " + srcF + " into " + dir , Project . MSG_INFO ) ; ZipInputStream zis = null ; try { zis = new ZipInputStream ( new FileInputStream ( srcF ) ) ; ZipEntry ze = null ; while ( ( ze = zis . getNextEntry ( ) ) != null ) { extractFile ( fileUtils , srcF , dir , zis , ze . getName ( ) , new Date ( ze . getTime ( ) ) , ze . isDirectory ( ) ) ; } log ( "expand complete" , Project . MSG_VERBOSE ) ; } catch ( IOException ioe ) { throw new BuildException ( "Error while expanding " + srcF . getPath ( ) , ioe ) ; } finally { if ( zis != null ) { try { zis . close ( ) ; } catch ( IOException e ) { } } } } protected void extractFile ( FileUtils fileUtils , File srcF , File dir , InputStream compressedInputStream , String entryName , Date entryDate , boolean isDirectory ) throws IOException { if ( patternsets != null && patternsets . size ( ) > 0 ) { String name = entryName ; boolean included = false ; for ( int v = 0 ; v < patternsets . size ( ) ; v ++ ) { PatternSet p = ( PatternSet ) patternsets . elementAt ( v ) ; String [ ] incls = p . getIncludePatterns ( project ) ; if ( incls != null ) { for ( int w = 0 ; w < incls . length ; w ++ ) { boolean isIncl = DirectoryScanner . match ( incls [ w ] , name ) ; if ( isIncl ) { included = true ; break ; } } } String [ ] excls = p . getExcludePatterns ( project ) ; if ( excls != null ) { for ( int w = 0 ; w < excls . length ; w ++ ) { boolean isExcl = DirectoryScanner . match ( excls [ w ] , name ) ; if ( isExcl ) { included = false ; break ; } } } } if ( ! included ) { return ; } } File f = fileUtils . resolveFile ( dir , entryName ) ; try { if ( ! overwrite && f . exists ( ) && f . lastModified ( ) >= entryDate . getTime ( ) ) { log ( "Skipping " + f + " as it is up-to-date" , Project . MSG_DEBUG ) ; return ; } log ( "expanding " + entryName + " to " + f , Project . MSG_VERBOSE ) ; File dirF = fileUtils . getParentFile ( f ) ; dirF . mkdirs ( ) ; if ( isDirectory ) { f . mkdirs ( ) ; } else { byte [ ] buffer = new byte [ 1024 ] ; int length = 0 ; FileOutputStream fos = null ; try { fos = new FileOutputStream ( f ) ; while ( ( length = compressedInputStream . read ( buffer ) ) >= 0 ) { fos . write ( buffer , 0 , length ) ; } fos . close ( ) ; fos = null ; } finally { if ( fos != null ) { try { fos . close ( ) ; } catch ( IOException e ) { } } } } fileUtils . setFileLastModified ( f , entryDate . getTime ( ) ) ; } catch ( FileNotFoundException ex ) { log ( "Unable to expand to file " + f . getPath ( ) , Project . MSG_WARN ) ; } } public void setDest ( File d ) { this . dest = d ; } public void setSrc ( File s ) { this . source = s ; } public void setOverwrite ( boolean b ) { overwrite = b ; } public void addPatternset ( PatternSet set ) { patternsets . addElement ( set ) ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } } 	1	['9', '3', '1', '11', '53', '16', '1', '10', '7', '0.75', '457', '1', '0', '0.822222222', '0.271604938', '2', '2', '49.22222222', '5', '1.3333', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . StringUtils ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . Reader ; import java . io . FileReader ; import java . io . InputStreamReader ; import java . io . Writer ; import java . io . FileWriter ; import java . io . OutputStreamWriter ; import java . io . FileOutputStream ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . util . Enumeration ; import java . util . Properties ; import java . util . Vector ; public class Replace extends MatchingTask { private File src = null ; private NestedString token = null ; private NestedString value = new NestedString ( ) ; private File propertyFile = null ; private File replaceFilterFile = null ; private Properties properties = null ; private Vector replacefilters = new Vector ( ) ; private File dir = null ; private int fileCount ; private int replaceCount ; private boolean summary = false ; private String encoding = null ; private FileUtils fileUtils = FileUtils . newFileUtils ( ) ; public class NestedString { private StringBuffer buf = new StringBuffer ( ) ; public void addText ( String val ) { buf . append ( val ) ; } public String getText ( ) { return buf . toString ( ) ; } } public class Replacefilter { private String token ; private String value ; private String property ; public void validate ( ) throws BuildException { if ( token == null ) { String message = "token is a mandatory attribute " + "of replacefilter." ; throw new BuildException ( message ) ; } if ( "" . equals ( token ) ) { String message = "The token attribute must not be an empty " + "string." ; throw new BuildException ( message ) ; } if ( ( value != null ) && ( property != null ) ) { String message = "Either value or property " + "can be specified, but a replacefilter " + "element cannot have both." ; throw new BuildException ( message ) ; } if ( ( property != null ) ) { if ( propertyFile == null ) { String message = "The replacefilter's property attribute " + "can only be used with the replacetask's " + "propertyFile attribute." ; throw new BuildException ( message ) ; } if ( properties == null || properties . getProperty ( property ) == null ) { String message = "property \"" + property + "\" was not found in " + propertyFile . getPath ( ) ; throw new BuildException ( message ) ; } } } public String getReplaceValue ( ) { if ( property != null ) { return properties . getProperty ( property ) ; } else if ( value != null ) { return value ; } else if ( Replace . this . value != null ) { return Replace . this . value . getText ( ) ; } else { return new String ( "" ) ; } } public void setToken ( String token ) { this . token = token ; } public String getToken ( ) { return token ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } public void setProperty ( String property ) { this . property = property ; } public String getProperty ( ) { return property ; } } public void execute ( ) throws BuildException { Vector savedFilters = ( Vector ) replacefilters . clone ( ) ; Properties savedProperties = properties == null ? null : ( Properties ) properties . clone ( ) ; try { if ( replaceFilterFile != null ) { Properties props = getProperties ( replaceFilterFile ) ; Enumeration enum = props . keys ( ) ; while ( enum . hasMoreElements ( ) ) { String token = enum . nextElement ( ) . toString ( ) ; Replacefilter replaceFilter = createReplacefilter ( ) ; replaceFilter . setToken ( token ) ; replaceFilter . setValue ( props . getProperty ( token ) ) ; } } validateAttributes ( ) ; if ( propertyFile != null ) { properties = getProperties ( propertyFile ) ; } validateReplacefilters ( ) ; fileCount = 0 ; replaceCount = 0 ; if ( src != null ) { processFile ( src ) ; } if ( dir != null ) { DirectoryScanner ds = super . getDirectoryScanner ( dir ) ; String [ ] srcs = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < srcs . length ; i ++ ) { File file = new File ( dir , srcs [ i ] ) ; processFile ( file ) ; } } if ( summary ) { log ( "Replaced " + replaceCount + " occurrences in " + fileCount + " files." , Project . MSG_INFO ) ; } } finally { replacefilters = savedFilters ; properties = savedProperties ; } } public void validateAttributes ( ) throws BuildException { if ( src == null && dir == null ) { String message = "Either the file or the dir attribute " + "must be specified" ; throw new BuildException ( message , location ) ; } if ( propertyFile != null && ! propertyFile . exists ( ) ) { String message = "Property file " + propertyFile . getPath ( ) + " does not exist." ; throw new BuildException ( message , location ) ; } if ( token == null && replacefilters . size ( ) == 0 ) { String message = "Either token or a nested replacefilter " + "must be specified" ; throw new BuildException ( message , location ) ; } if ( token != null && "" . equals ( token . getText ( ) ) ) { String message = "The token attribute must not be an empty string." ; throw new BuildException ( message , location ) ; } } public void validateReplacefilters ( ) throws BuildException { for ( int i = 0 ; i < replacefilters . size ( ) ; i ++ ) { Replacefilter element = ( Replacefilter ) replacefilters . elementAt ( i ) ; element . validate ( ) ; } } public Properties getProperties ( File propertyFile ) throws BuildException { Properties properties = new Properties ( ) ; try { properties . load ( new FileInputStream ( propertyFile ) ) ; } catch ( FileNotFoundException e ) { String message = "Property file (" + propertyFile . getPath ( ) + ") not found." ; throw new BuildException ( message ) ; } catch ( IOException e ) { String message = "Property file (" + propertyFile . getPath ( ) + ") cannot be loaded." ; throw new BuildException ( message ) ; } return properties ; } private void processFile ( File src ) throws BuildException { if ( ! src . exists ( ) ) { throw new BuildException ( "Replace: source file " + src . getPath ( ) + " doesn't exist" , location ) ; } File temp = fileUtils . createTempFile ( "rep" , ".tmp" , fileUtils . getParentFile ( src ) ) ; Reader reader = null ; Writer writer = null ; try { reader = encoding == null ? new FileReader ( src ) : new InputStreamReader ( new FileInputStream ( src ) , encoding ) ; writer = encoding == null ? new FileWriter ( temp ) : new OutputStreamWriter ( new FileOutputStream ( temp ) , encoding ) ; BufferedReader br = new BufferedReader ( reader ) ; BufferedWriter bw = new BufferedWriter ( writer ) ; int fileLengthInBytes = ( int ) src . length ( ) ; StringBuffer tmpBuf = new StringBuffer ( fileLengthInBytes ) ; int readChar = 0 ; int totread = 0 ; while ( true ) { readChar = br . read ( ) ; if ( readChar < 0 ) { break ; } tmpBuf . append ( ( char ) readChar ) ; totread ++ ; } String buf = tmpBuf . toString ( ) ; String newString = new String ( buf ) ; if ( token != null ) { String val = stringReplace ( value . getText ( ) , "\n" , StringUtils . LINE_SEP ) ; String tok = stringReplace ( token . getText ( ) , "\n" , StringUtils . LINE_SEP ) ; log ( "Replacing in " + src . getPath ( ) + ": " + token . getText ( ) + " --> " + value . getText ( ) , Project . MSG_VERBOSE ) ; newString = stringReplace ( newString , tok , val ) ; } if ( replacefilters . size ( ) > 0 ) { newString = processReplacefilters ( newString , src . getPath ( ) ) ; } boolean changes = ! newString . equals ( buf ) ; if ( changes ) { bw . write ( newString , 0 , newString . length ( ) ) ; bw . flush ( ) ; } bw . close ( ) ; writer = null ; br . close ( ) ; reader = null ; if ( changes ) { ++ fileCount ; if ( ! src . delete ( ) ) { throw new BuildException ( "Couldn't delete " + src , getLocation ( ) ) ; } if ( ! temp . renameTo ( src ) ) { throw new BuildException ( "Couldn't rename temporary file " + temp , getLocation ( ) ) ; } temp = null ; } } catch ( IOException ioe ) { throw new BuildException ( "IOException in " + src + " - " + ioe . getClass ( ) . getName ( ) + ":" + ioe . getMessage ( ) , ioe , location ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { } } if ( writer != null ) { try { writer . close ( ) ; } catch ( IOException e ) { } } if ( temp != null ) { temp . delete ( ) ; } } } private String processReplacefilters ( String buffer , String filename ) { String newString = new String ( buffer ) ; for ( int i = 0 ; i < replacefilters . size ( ) ; i ++ ) { Replacefilter filter = ( Replacefilter ) replacefilters . elementAt ( i ) ; log ( "Replacing in " + filename + ": " + filter . getToken ( ) + " --> " + filter . getReplaceValue ( ) , Project . MSG_VERBOSE ) ; newString = stringReplace ( newString , filter . getToken ( ) , filter . getReplaceValue ( ) ) ; } return newString ; } public void setFile ( File file ) { this . src = file ; } public void setSummary ( boolean summary ) { this . summary = summary ; } public void setReplaceFilterFile ( File filename ) { replaceFilterFile = filename ; } public void setDir ( File dir ) { this . dir = dir ; } public void setToken ( String token ) { createReplaceToken ( ) . addText ( token ) ; } public void setValue ( String value ) { createReplaceValue ( ) . addText ( value ) ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public NestedString createReplaceToken ( ) { if ( token == null ) { token = new NestedString ( ) ; } return token ; } public NestedString createReplaceValue ( ) { return value ; } public void setPropertyFile ( File filename ) { propertyFile = filename ; } public Replacefilter createReplacefilter ( ) { Replacefilter filter = new Replacefilter ( ) ; replacefilters . addElement ( filter ) ; return filter ; } private String stringReplace ( String str , String str1 , String str2 ) { StringBuffer ret = new StringBuffer ( ) ; int start = 0 ; int found = str . indexOf ( str1 ) ; while ( found >= 0 ) { if ( found > start ) { ret . append ( str . substring ( start , found ) ) ; } if ( str2 != null ) { ret . append ( str2 ) ; } start = found + str1 . length ( ) ; found = str . indexOf ( str1 , start ) ; ++ replaceCount ; } if ( str . length ( ) > start ) { ret . append ( str . substring ( start , str . length ( ) ) ) ; } return ret . toString ( ) ; } } 	1	['22', '4', '0', '9', '92', '129', '2', '9', '16', '0.84981685', '837', '1', '3', '0.787878788', '0.309090909', '2', '2', '36.45454545', '5', '1.2273', '1']
package org . apache . tools . ant . taskdefs ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . input . InputRequest ; import org . apache . tools . ant . input . MultipleChoiceInputRequest ; import org . apache . tools . ant . util . StringUtils ; public class Input extends Task { private String validargs = null ; private String message = "" ; private String addproperty = null ; public void setValidargs ( String validargs ) { this . validargs = validargs ; } public void setAddproperty ( String addproperty ) { this . addproperty = addproperty ; } public void setMessage ( String message ) { this . message = message ; } public void addText ( String msg ) { message += getProject ( ) . replaceProperties ( msg ) ; } public Input ( ) { } public void execute ( ) throws BuildException { InputRequest request = null ; if ( validargs != null ) { Vector accept = StringUtils . split ( validargs , ',' ) ; request = new MultipleChoiceInputRequest ( message , accept ) ; } else { request = new InputRequest ( message ) ; } getProject ( ) . getInputHandler ( ) . handleInput ( request ) ; if ( addproperty != null ) { project . setNewProperty ( addproperty , request . getInput ( ) ) ; } } } 	1	['6', '3', '0', '8', '19', '0', '0', '8', '6', '0.533333333', '88', '1', '0', '0.880952381', '0.833333333', '0', '0', '13.16666667', '1', '0.8333', '1']
