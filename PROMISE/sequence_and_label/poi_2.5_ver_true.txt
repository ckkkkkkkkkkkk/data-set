package org . apache . poi . ddf ; import org . apache . poi . util . LittleEndian ; import java . io . PrintWriter ; import java . util . Collections ; import java . util . List ; abstract public class EscherRecord { private short options ; private short recordId ; public EscherRecord ( ) { } protected int fillFields ( byte [ ] data , EscherRecordFactory f ) { return fillFields ( data , 0 , f ) ; } public abstract int fillFields ( byte [ ] data , int offset , EscherRecordFactory recordFactory ) ; protected int readHeader ( byte [ ] data , int offset ) { EscherRecordHeader header = EscherRecordHeader . readHeader ( data , offset ) ; options = header . getOptions ( ) ; recordId = header . getRecordId ( ) ; return header . getRemainingBytes ( ) ; } public boolean isContainerRecord ( ) { return ( options & ( short ) 0x000f ) == ( short ) 0x000f ; } public short getOptions ( ) { return options ; } public void setOptions ( short options ) { this . options = options ; } public byte [ ] serialize ( ) { byte [ ] retval = new byte [ getRecordSize ( ) ] ; serialize ( 0 , retval ) ; return retval ; } public int serialize ( int offset , byte [ ] data ) { return serialize ( offset , data , new NullEscherSerializationListener ( ) ) ; } public abstract int serialize ( int offset , byte [ ] data , EscherSerializationListener listener ) ; abstract public int getRecordSize ( ) ; public short getRecordId ( ) { return recordId ; } public void setRecordId ( short recordId ) { this . recordId = recordId ; } public List getChildRecords ( ) { return Collections . EMPTY_LIST ; } public void setChildRecords ( List childRecords ) { throw new IllegalArgumentException ( "This record does not support child records." ) ; } public Object clone ( ) { throw new RuntimeException ( "The class " + getClass ( ) . getName ( ) + " needs to define a clone method" ) ; } public EscherRecord getChild ( int index ) { return ( EscherRecord ) getChildRecords ( ) . get ( index ) ; } public void display ( PrintWriter w , int indent ) { for ( int i = 0 ; i < indent * 4 ; i ++ ) w . print ( ' ' ) ; w . println ( getRecordName ( ) ) ; } public abstract String getRecordName ( ) ; public short getInstance ( ) { return ( short ) ( options > > 4 ) ; } static class EscherRecordHeader { private short options ; private short recordId ; private int remainingBytes ; private EscherRecordHeader ( ) { } public static EscherRecordHeader readHeader ( byte [ ] data , int offset ) { EscherRecordHeader header = new EscherRecordHeader ( ) ; header . options = LittleEndian . getShort ( data , offset ) ; header . recordId = LittleEndian . getShort ( data , offset + 2 ) ; header . remainingBytes = LittleEndian . getInt ( data , offset + 4 ) ; return header ; } public short getOptions ( ) { return options ; } public short getRecordId ( ) { return recordId ; } public int getRemainingBytes ( ) { return remainingBytes ; } public String toString ( ) { return "EscherRecordHeader{" + "options=" + options + ", recordId=" + recordId + ", remainingBytes=" + remainingBytes + "}" ; } } } 	0	['20', '1', '14', '32', '36', '164', '31', '4', '18', '0.842105263', '141', '1', '0', '0', '0.2375', '0', '0', '5.95', '2', '1.05', '0']
package org . apache . poi . ddf ; public class EscherBoolProperty extends EscherSimpleProperty { public EscherBoolProperty ( short propertyNumber , int value ) { super ( propertyNumber , false , false , value ) ; } public boolean isTrue ( ) { return propertyValue != 0 ; } public boolean isFalse ( ) { return propertyValue == 0 ; } } 	0	['3', '3', '0', '6', '4', '1', '5', '1', '3', '2', '24', '0', '0', '0.875', '0.555555556', '0', '0', '7', '2', '1.3333', '0']
package org . apache . poi . hssf . model ; import org . apache . poi . ddf . * ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . usermodel . * ; public class TextboxShape extends AbstractShape { private EscherContainerRecord spContainer ; private TextObjectRecord textObjectRecord ; private ObjRecord objRecord ; private EscherTextboxRecord escherTextbox ; TextboxShape ( HSSFTextbox hssfShape , int shapeId ) { spContainer = createSpContainer ( hssfShape , shapeId ) ; objRecord = createObjRecord ( hssfShape , shapeId ) ; textObjectRecord = createTextObjectRecord ( hssfShape , shapeId ) ; } private ObjRecord createObjRecord ( HSSFTextbox hssfShape , int shapeId ) { HSSFShape shape = hssfShape ; ObjRecord obj = new ObjRecord ( ) ; CommonObjectDataSubRecord c = new CommonObjectDataSubRecord ( ) ; c . setObjectType ( ( short ) ( ( HSSFSimpleShape ) shape ) . getShapeType ( ) ) ; c . setObjectId ( ( short ) ( shapeId ) ) ; c . setLocked ( true ) ; c . setPrintable ( true ) ; c . setAutofill ( true ) ; c . setAutoline ( true ) ; EndSubRecord e = new EndSubRecord ( ) ; obj . addSubRecord ( c ) ; obj . addSubRecord ( e ) ; return obj ; } private EscherContainerRecord createSpContainer ( HSSFTextbox hssfShape , int shapeId ) { HSSFTextbox shape = hssfShape ; EscherContainerRecord spContainer = new EscherContainerRecord ( ) ; EscherSpRecord sp = new EscherSpRecord ( ) ; EscherOptRecord opt = new EscherOptRecord ( ) ; EscherRecord anchor = new EscherClientAnchorRecord ( ) ; EscherClientDataRecord clientData = new EscherClientDataRecord ( ) ; escherTextbox = new EscherTextboxRecord ( ) ; spContainer . setRecordId ( EscherContainerRecord . SP_CONTAINER ) ; spContainer . setOptions ( ( short ) 0x000F ) ; sp . setRecordId ( EscherSpRecord . RECORD_ID ) ; sp . setOptions ( ( short ) ( ( EscherAggregate . ST_TEXTBOX << 4 ) | 0x2 ) ) ; sp . setShapeId ( shapeId ) ; sp . setFlags ( EscherSpRecord . FLAG_HAVEANCHOR | EscherSpRecord . FLAG_HASSHAPETYPE ) ; opt . setRecordId ( EscherOptRecord . RECORD_ID ) ; opt . addEscherProperty ( new EscherSimpleProperty ( EscherProperties . TEXT__TEXTID , 0 ) ) ; opt . addEscherProperty ( new EscherSimpleProperty ( EscherProperties . TEXT__TEXTLEFT , shape . getMarginLeft ( ) ) ) ; opt . addEscherProperty ( new EscherSimpleProperty ( EscherProperties . TEXT__TEXTRIGHT , shape . getMarginRight ( ) ) ) ; opt . addEscherProperty ( new EscherSimpleProperty ( EscherProperties . TEXT__TEXTBOTTOM , shape . getMarginBottom ( ) ) ) ; opt . addEscherProperty ( new EscherSimpleProperty ( EscherProperties . TEXT__TEXTTOP , shape . getMarginTop ( ) ) ) ; addStandardOptions ( shape , opt ) ; HSSFAnchor userAnchor = shape . getAnchor ( ) ; anchor = createAnchor ( userAnchor ) ; clientData . setRecordId ( EscherClientDataRecord . RECORD_ID ) ; clientData . setOptions ( ( short ) 0x0000 ) ; escherTextbox . setRecordId ( EscherTextboxRecord . RECORD_ID ) ; escherTextbox . setOptions ( ( short ) 0x0000 ) ; spContainer . addChildRecord ( sp ) ; spContainer . addChildRecord ( opt ) ; spContainer . addChildRecord ( anchor ) ; spContainer . addChildRecord ( clientData ) ; spContainer . addChildRecord ( escherTextbox ) ; return spContainer ; } private TextObjectRecord createTextObjectRecord ( HSSFTextbox hssfShape , int shapeId ) { HSSFTextbox shape = hssfShape ; TextObjectRecord obj = new TextObjectRecord ( ) ; obj . setHorizontalTextAlignment ( TextObjectRecord . HORIZONTAL_TEXT_ALIGNMENT_LEFT_ALIGNED ) ; obj . setVerticalTextAlignment ( TextObjectRecord . VERTICAL_TEXT_ALIGNMENT_TOP ) ; obj . setTextLocked ( true ) ; obj . setTextOrientation ( TextObjectRecord . TEXT_ORIENTATION_NONE ) ; int frLength = ( shape . getString ( ) . numFormattingRuns ( ) + 1 ) * 8 ; obj . setFormattingRunLength ( ( short ) frLength ) ; obj . setTextLength ( ( short ) shape . getString ( ) . length ( ) ) ; obj . setStr ( shape . getString ( ) ) ; obj . setReserved7 ( 0 ) ; return obj ; } public EscherContainerRecord getSpContainer ( ) { return spContainer ; } public ObjRecord getObjRecord ( ) { return objRecord ; } public TextObjectRecord getTextObjectRecord ( ) { return textObjectRecord ; } public EscherRecord getEscherTextbox ( ) { return escherTextbox ; } } 	0	['8', '2', '0', '20', '59', '20', '2', '19', '4', '0.821428571', '267', '1', '4', '0.416666667', '0.666666667', '1', '1', '31.875', '1', '0.875', '0']
package org . apache . poi . poifs . property ; public interface PropertyConstants { public static final int PROPERTY_TYPE_OFFSET = 0x42 ; public static final byte DIRECTORY_TYPE = 1 ; public static final byte DOCUMENT_TYPE = 2 ; public static final byte ROOT_TYPE = 5 ; } 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '4', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . poi . hssf . eventusermodel ; import org . apache . poi . hssf . record . Record ; public interface HSSFListener { public void processRecord ( Record record ) ; } 	0	['1', '1', '0', '7', '1', '0', '6', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . poi . poifs . storage ; import java . io . * ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . util . IntegerField ; import org . apache . poi . util . LittleEndianConsts ; import org . apache . poi . util . LongField ; import org . apache . poi . util . ShortField ; public class HeaderBlockWriter extends BigBlock implements HeaderBlockConstants { private static final byte _default_value = ( byte ) 0xFF ; private IntegerField _bat_count ; private IntegerField _property_start ; private IntegerField _sbat_start ; private IntegerField _sbat_block_count ; private IntegerField _xbat_start ; private IntegerField _xbat_count ; private byte [ ] _data ; public HeaderBlockWriter ( ) { _data = new byte [ POIFSConstants . BIG_BLOCK_SIZE ] ; Arrays . fill ( _data , _default_value ) ; new LongField ( _signature_offset , _signature , _data ) ; new IntegerField ( 0x08 , 0 , _data ) ; new IntegerField ( 0x0c , 0 , _data ) ; new IntegerField ( 0x10 , 0 , _data ) ; new IntegerField ( 0x14 , 0 , _data ) ; new ShortField ( 0x18 , ( short ) 0x3b , _data ) ; new ShortField ( 0x1a , ( short ) 0x3 , _data ) ; new ShortField ( 0x1c , ( short ) - 2 , _data ) ; new ShortField ( 0x1e , ( short ) 0x9 , _data ) ; new IntegerField ( 0x20 , 0x6 , _data ) ; new IntegerField ( 0x24 , 0 , _data ) ; new IntegerField ( 0x28 , 0 , _data ) ; _bat_count = new IntegerField ( _bat_count_offset , 0 , _data ) ; _property_start = new IntegerField ( _property_start_offset , POIFSConstants . END_OF_CHAIN , _data ) ; new IntegerField ( 0x34 , 0 , _data ) ; new IntegerField ( 0x38 , 0x1000 , _data ) ; _sbat_start = new IntegerField ( _sbat_start_offset , POIFSConstants . END_OF_CHAIN , _data ) ; _sbat_block_count = new IntegerField ( _sbat_block_count_offset , 0 , _data ) ; _xbat_start = new IntegerField ( _xbat_start_offset , POIFSConstants . END_OF_CHAIN , _data ) ; _xbat_count = new IntegerField ( _xbat_count_offset , 0 , _data ) ; } public BATBlock [ ] setBATBlocks ( final int blockCount , final int startBlock ) { BATBlock [ ] rvalue ; _bat_count . set ( blockCount , _data ) ; int limit = Math . min ( blockCount , _max_bats_in_header ) ; int offset = _bat_array_offset ; for ( int j = 0 ; j < limit ; j ++ ) { new IntegerField ( offset , startBlock + j , _data ) ; offset += LittleEndianConsts . INT_SIZE ; } if ( blockCount > _max_bats_in_header ) { int excess_blocks = blockCount - _max_bats_in_header ; int [ ] excess_block_array = new int [ excess_blocks ] ; for ( int j = 0 ; j < excess_blocks ; j ++ ) { excess_block_array [ j ] = startBlock + j + _max_bats_in_header ; } rvalue = BATBlock . createXBATBlocks ( excess_block_array , startBlock + blockCount ) ; _xbat_start . set ( startBlock + blockCount , _data ) ; } else { rvalue = BATBlock . createXBATBlocks ( new int [ 0 ] , 0 ) ; _xbat_start . set ( POIFSConstants . END_OF_CHAIN , _data ) ; } _xbat_count . set ( rvalue . length , _data ) ; return rvalue ; } public void setPropertyStart ( final int startBlock ) { _property_start . set ( startBlock , _data ) ; } public void setSBATStart ( final int startBlock ) { _sbat_start . set ( startBlock , _data ) ; } public void setSBATBlockCount ( final int count ) { _sbat_block_count . set ( count , _data ) ; } static int calculateXBATStorageRequirements ( final int blockCount ) { return ( blockCount > _max_bats_in_header ) ? BATBlock . calculateXBATStorageRequirements ( blockCount - _max_bats_in_header ) : 0 ; } void writeData ( final OutputStream stream ) throws IOException { doWriteData ( stream , _data ) ; } } 	0	['8', '2', '0', '8', '19', '0', '2', '6', '6', '0.821428571', '324', '1', '6', '0.3', '0.583333333', '1', '2', '38.5', '4', '1.375', '0']
package org . apache . poi . util ; import org . apache . poi . util . LittleEndian . BufferUnderrunException ; import java . io . * ; public interface FixedField { public void readFromBytes ( byte [ ] data ) throws ArrayIndexOutOfBoundsException ; public void readFromStream ( InputStream stream ) throws IOException , BufferUnderrunException ; public void writeToBytes ( byte [ ] data ) throws ArrayIndexOutOfBoundsException ; public String toString ( ) ; } 	0	['4', '1', '0', '5', '4', '6', '4', '1', '4', '2', '4', '0', '0', '0', '0.583333333', '0', '0', '0', '1', '1', '0']
package org . apache . poi . poifs . storage ; import java . io . * ; import java . util . * ; class BlockListImpl implements BlockList { private ListManagedBlock [ ] _blocks ; private BlockAllocationTableReader _bat ; protected BlockListImpl ( ) { _blocks = new ListManagedBlock [ 0 ] ; _bat = null ; } protected void setBlocks ( final ListManagedBlock [ ] blocks ) { _blocks = blocks ; } public void zap ( final int index ) { if ( ( index >= 0 ) && ( index < _blocks . length ) ) { _blocks [ index ] = null ; } } public ListManagedBlock remove ( final int index ) throws IOException { ListManagedBlock result = null ; try { result = _blocks [ index ] ; if ( result == null ) { throw new IOException ( "block[ " + index + " ] already removed" ) ; } _blocks [ index ] = null ; } catch ( ArrayIndexOutOfBoundsException ignored ) { throw new IOException ( "Cannot remove block[ " + index + " ]; out of range" ) ; } return result ; } public ListManagedBlock [ ] fetchBlocks ( final int startBlock ) throws IOException { if ( _bat == null ) { throw new IOException ( "Improperly initialized list: no block allocation table provided" ) ; } return _bat . fetchBlocks ( startBlock , this ) ; } public void setBAT ( final BlockAllocationTableReader bat ) throws IOException { if ( _bat != null ) { throw new IOException ( "Attempt to replace existing BlockAllocationTable" ) ; } _bat = bat ; } } 	0	['6', '1', '2', '5', '13', '0', '2', '3', '4', '0.5', '107', '1', '2', '0', '0.458333333', '0', '0', '16.5', '3', '1.1667', '0']
package org . apache . poi . hssf . usermodel ; import java . util . Calendar ; import java . util . Date ; import java . util . GregorianCalendar ; public class HSSFDateUtil { private HSSFDateUtil ( ) { } private static final int BAD_DATE = - 1 ; private static final long DAY_MILLISECONDS = 24 * 60 * 60 * 1000 ; private static final double CAL_1900_ABSOLUTE = ( double ) absoluteDay ( new GregorianCalendar ( 1900 , Calendar . JANUARY , 1 ) ) - 2.0 ; public static double getExcelDate ( Date date ) { Calendar calStart = new GregorianCalendar ( ) ; calStart . setTime ( date ) ; if ( calStart . get ( Calendar . YEAR ) < 1900 ) { return BAD_DATE ; } else { double fraction = ( ( ( calStart . get ( Calendar . HOUR_OF_DAY ) * 60 + calStart . get ( Calendar . MINUTE ) ) * 60 + calStart . get ( Calendar . SECOND ) ) * 1000 + calStart . get ( Calendar . MILLISECOND ) ) / ( double ) DAY_MILLISECONDS ; calStart = dayStart ( calStart ) ; return fraction + ( double ) absoluteDay ( calStart ) - CAL_1900_ABSOLUTE ; } } public static Date getJavaDate ( double date ) { return getJavaDate ( date , false ) ; } public static Date getJavaDate ( double date , boolean use1904windowing ) { if ( isValidExcelDate ( date ) ) { int startYear = 1900 ; int dayAdjust = - 1 ; int wholeDays = ( int ) Math . floor ( date ) ; if ( use1904windowing ) { startYear = 1904 ; dayAdjust = 1 ; } else if ( wholeDays < 61 ) { dayAdjust = 0 ; } GregorianCalendar calendar = new GregorianCalendar ( startYear , 0 , wholeDays + dayAdjust ) ; int millisecondsInDay = ( int ) ( ( date - Math . floor ( date ) ) * ( double ) DAY_MILLISECONDS + 0.5 ) ; calendar . set ( GregorianCalendar . MILLISECOND , millisecondsInDay ) ; return calendar . getTime ( ) ; } else { return null ; } } public static boolean isInternalDateFormat ( int format ) { boolean retval = false ; switch ( format ) { case 0x0e : case 0x0f : case 0x10 : case 0x11 : case 0x12 : case 0x13 : case 0x14 : case 0x15 : case 0x16 : case 0x2d : case 0x2e : case 0x2f : retval = true ; break ; default : retval = false ; break ; } return retval ; } public static boolean isCellDateFormatted ( HSSFCell cell ) { if ( cell == null ) return false ; boolean bDate = false ; double d = cell . getNumericCellValue ( ) ; if ( HSSFDateUtil . isValidExcelDate ( d ) ) { HSSFCellStyle style = cell . getCellStyle ( ) ; int i = style . getDataFormat ( ) ; bDate = isInternalDateFormat ( i ) ; } return bDate ; } public static boolean isValidExcelDate ( double value ) { return ( value > - Double . MIN_VALUE ) ; } private static int absoluteDay ( Calendar cal ) { return cal . get ( Calendar . DAY_OF_YEAR ) + daysInPriorYears ( cal . get ( Calendar . YEAR ) ) ; } private static int daysInPriorYears ( int yr ) { if ( yr < 1601 ) { throw new IllegalArgumentException ( "'year' must be 1601 or greater" ) ; } int y = yr - 1601 ; int days = 365 * y + y / 4 - y / 100 + y / 400 ; return days ; } private static Calendar dayStart ( final Calendar cal ) { cal . get ( Calendar . HOUR_OF_DAY ) ; cal . set ( Calendar . HOUR_OF_DAY , 0 ) ; cal . set ( Calendar . MINUTE , 0 ) ; cal . set ( Calendar . SECOND , 0 ) ; cal . set ( Calendar . MILLISECOND , 0 ) ; cal . get ( Calendar . HOUR_OF_DAY ) ; return cal ; } } 	0	['11', '1', '0', '2', '24', '53', '1', '2', '6', '1.033333333', '241', '1', '0', '0', '0.157142857', '0', '0', '20.63636364', '4', '1.6364', '0']
package org . apache . poi . hssf . usermodel ; public abstract class HSSFAnchor { int dx1 ; int dy1 ; int dx2 ; int dy2 ; public HSSFAnchor ( ) { } public HSSFAnchor ( int dx1 , int dy1 , int dx2 , int dy2 ) { this . dx1 = dx1 ; this . dy1 = dy1 ; this . dx2 = dx2 ; this . dy2 = dy2 ; } public int getDx1 ( ) { return dx1 ; } public void setDx1 ( int dx1 ) { this . dx1 = dx1 ; } public int getDy1 ( ) { return dy1 ; } public void setDy1 ( int dy1 ) { this . dy1 = dy1 ; } public int getDy2 ( ) { return dy2 ; } public void setDy2 ( int dy2 ) { this . dy2 = dy2 ; } public int getDx2 ( ) { return dx2 ; } public void setDx2 ( int dx2 ) { this . dx2 = dx2 ; } public abstract boolean isHorizontallyFlipped ( ) ; public abstract boolean isVerticallyFlipped ( ) ; } 	0	['12', '1', '2', '15', '13', '42', '15', '0', '12', '0.818181818', '62', '0', '0', '0', '0.708333333', '0', '0', '3.833333333', '1', '0.8333', '0']
package org . apache . poi . poifs . dev ; import java . util . Iterator ; public interface POIFSViewable { public Object [ ] getViewableArray ( ) ; public Iterator getViewableIterator ( ) ; public boolean preferArray ( ) ; public String getShortDescription ( ) ; } 	0	['4', '1', '0', '6', '4', '6', '6', '0', '4', '2', '4', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . poi . ddf ; public class EscherShapePathProperty extends EscherSimpleProperty { public static final int LINE_OF_STRAIGHT_SEGMENTS = 0 ; public static final int CLOSED_POLYGON = 1 ; public static final int CURVES = 2 ; public static final int CLOSED_CURVES = 3 ; public static final int COMPLEX = 4 ; public EscherShapePathProperty ( short propertyNumber , int shapePath ) { super ( propertyNumber , false , false , shapePath ) ; } } 	0	['1', '3', '0', '4', '2', '0', '3', '1', '1', '2', '13', '0', '0', '1', '1', '0', '0', '7', '0', '0', '0']
package org . apache . poi . poifs . filesystem ; public class DocumentDescriptor { private POIFSDocumentPath path ; private String name ; private int hashcode = 0 ; public DocumentDescriptor ( final POIFSDocumentPath path , final String name ) { if ( path == null ) { throw new NullPointerException ( "path must not be null" ) ; } if ( name == null ) { throw new NullPointerException ( "name must not be null" ) ; } if ( name . length ( ) == 0 ) { throw new IllegalArgumentException ( "name cannot be empty" ) ; } this . path = path ; this . name = name ; } public boolean equals ( final Object o ) { boolean rval = false ; if ( ( o != null ) && ( o . getClass ( ) == this . getClass ( ) ) ) { if ( this == o ) { rval = true ; } else { DocumentDescriptor descriptor = ( DocumentDescriptor ) o ; rval = this . path . equals ( descriptor . path ) && this . name . equals ( descriptor . name ) ; } } return rval ; } public int hashCode ( ) { if ( hashcode == 0 ) { hashcode = path . hashCode ( ) ^ name . hashCode ( ) ; } return hashcode ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( 40 * ( path . length ( ) + 1 ) ) ; for ( int j = 0 ; j < path . length ( ) ; j ++ ) { buffer . append ( path . getComponent ( j ) ) . append ( "/" ) ; } buffer . append ( name ) ; return buffer . toString ( ) ; } } 	0	['4', '1', '0', '2', '18', '0', '1', '1', '4', '0.222222222', '129', '1', '1', '0', '0.4375', '1', '1', '30.5', '6', '2.5', '0']
package org . apache . poi . util ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . * ; public class CommonsLogger extends POILogger { private static LogFactory _creator = LogFactory . getFactory ( ) ; private Log log = null ; public void initialize ( final String cat ) { this . log = _creator . getInstance ( cat ) ; } public void log ( final int level , final Object obj1 ) { if ( level == FATAL ) { if ( log . isFatalEnabled ( ) ) { log . fatal ( obj1 ) ; } } else if ( level == ERROR ) { if ( log . isErrorEnabled ( ) ) { log . error ( obj1 ) ; } } else if ( level == WARN ) { if ( log . isWarnEnabled ( ) ) { log . warn ( obj1 ) ; } } else if ( level == INFO ) { if ( log . isInfoEnabled ( ) ) { log . info ( obj1 ) ; } } else if ( level == DEBUG ) { if ( log . isDebugEnabled ( ) ) { log . debug ( obj1 ) ; } } else { if ( log . isTraceEnabled ( ) ) { log . trace ( obj1 ) ; } } } public boolean check ( final int level ) { if ( level == FATAL ) { if ( log . isFatalEnabled ( ) ) { return true ; } } else if ( level == ERROR ) { if ( log . isErrorEnabled ( ) ) { return true ; } } else if ( level == WARN ) { if ( log . isWarnEnabled ( ) ) { return true ; } } else if ( level == INFO ) { if ( log . isInfoEnabled ( ) ) { return true ; } } else if ( level == DEBUG ) { if ( log . isDebugEnabled ( ) ) { return true ; } } return false ; } } 	0	['5', '2', '0', '3', '20', '0', '0', '3', '4', '0.5', '138', '1', '0', '0.888888889', '0.5', '1', '1', '26.2', '12', '4.8', '0']
package org . apache . poi . ddf ; import org . apache . poi . util . HexDump ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . record . RecordFormatException ; public class EscherSplitMenuColorsRecord extends EscherRecord { public static final short RECORD_ID = ( short ) 0xF11E ; public static final String RECORD_DESCRIPTION = "MsofbtSplitMenuColors" ; private int field_1_color1 ; private int field_2_color2 ; private int field_3_color3 ; private int field_4_color4 ; public int fillFields ( byte [ ] data , int offset , EscherRecordFactory recordFactory ) { int bytesRemaining = readHeader ( data , offset ) ; int pos = offset + 8 ; int size = 0 ; field_1_color1 = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; field_2_color2 = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; field_3_color3 = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; field_4_color4 = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; bytesRemaining -= size ; if ( bytesRemaining != 0 ) throw new RecordFormatException ( "Expecting no remaining data but got " + bytesRemaining + " byte(s)." ) ; return 8 + size + bytesRemaining ; } public int serialize ( int offset , byte [ ] data , EscherSerializationListener listener ) { listener . beforeRecordSerialize ( offset , getRecordId ( ) , this ) ; int pos = offset ; LittleEndian . putShort ( data , pos , getOptions ( ) ) ; pos += 2 ; LittleEndian . putShort ( data , pos , getRecordId ( ) ) ; pos += 2 ; int remainingBytes = getRecordSize ( ) - 8 ; LittleEndian . putInt ( data , pos , remainingBytes ) ; pos += 4 ; LittleEndian . putInt ( data , pos , field_1_color1 ) ; pos += 4 ; LittleEndian . putInt ( data , pos , field_2_color2 ) ; pos += 4 ; LittleEndian . putInt ( data , pos , field_3_color3 ) ; pos += 4 ; LittleEndian . putInt ( data , pos , field_4_color4 ) ; pos += 4 ; listener . afterRecordSerialize ( pos , getRecordId ( ) , pos - offset , this ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 8 + 4 * 4 ; } public short getRecordId ( ) { return RECORD_ID ; } public String getRecordName ( ) { return "SplitMenuColors" ; } public String toString ( ) { String nl = System . getProperty ( "line.separator" ) ; return getClass ( ) . getName ( ) + ":" + nl + "  RecordId: 0x" + HexDump . toHex ( RECORD_ID ) + nl + "  Options: 0x" + HexDump . toHex ( getOptions ( ) ) + nl + "  Color1: 0x" + HexDump . toHex ( field_1_color1 ) + nl + "  Color2: 0x" + HexDump . toHex ( field_2_color2 ) + nl + "  Color3: 0x" + HexDump . toHex ( field_3_color3 ) + nl + "  Color4: 0x" + HexDump . toHex ( field_4_color4 ) + nl + "" ; } public int getColor1 ( ) { return field_1_color1 ; } public void setColor1 ( int field_1_color1 ) { this . field_1_color1 = field_1_color1 ; } public int getColor2 ( ) { return field_2_color2 ; } public void setColor2 ( int field_2_color2 ) { this . field_2_color2 = field_2_color2 ; } public int getColor3 ( ) { return field_3_color3 ; } public void setColor3 ( int field_3_color3 ) { this . field_3_color3 = field_3_color3 ; } public int getColor4 ( ) { return field_4_color4 ; } public void setColor4 ( int field_4_color4 ) { this . field_4_color4 = field_4_color4 ; } } 	0	['15', '2', '0', '7', '33', '43', '1', '6', '15', '0.833333333', '258', '0.666666667', '0', '0.575757576', '0.333333333', '1', '5', '15.8', '2', '1', '0']
package org . apache . poi . util ; import java . io . * ; import java . util . List ; import java . util . ArrayList ; public class HexRead { public static byte [ ] readData ( String filename ) throws IOException { File file = new File ( filename ) ; FileInputStream stream = new FileInputStream ( file ) ; try { return readData ( stream , - 1 ) ; } finally { stream . close ( ) ; } } public static byte [ ] readData ( String filename , String section ) throws IOException { File file = new File ( filename ) ; FileInputStream stream = new FileInputStream ( file ) ; try { StringBuffer sectionText = new StringBuffer ( ) ; boolean inSection = false ; int c = stream . read ( ) ; while ( c != - 1 ) { switch ( c ) { case '[' : inSection = true ; break ; case '\n' : case '\r' : inSection = false ; sectionText = new StringBuffer ( ) ; break ; case ']' : inSection = false ; if ( sectionText . toString ( ) . equals ( section ) ) return readData ( stream , '[' ) ; sectionText = new StringBuffer ( ) ; break ; default : if ( inSection ) sectionText . append ( ( char ) c ) ; } c = stream . read ( ) ; } } finally { stream . close ( ) ; } throw new IOException ( "Section '" + section + "' not found" ) ; } static public byte [ ] readData ( InputStream stream , int eofChar ) throws IOException { int characterCount = 0 ; byte b = ( byte ) 0 ; List bytes = new ArrayList ( ) ; boolean done = false ; while ( ! done ) { int count = stream . read ( ) ; char baseChar = 'a' ; if ( count == eofChar ) break ; switch ( count ) { case '#' : readToEOL ( stream ) ; break ; case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : b <<= 4 ; b += ( byte ) ( count - '0' ) ; characterCount ++ ; if ( characterCount == 2 ) { bytes . add ( new Byte ( b ) ) ; characterCount = 0 ; b = ( byte ) 0 ; } break ; case 'A' : case 'B' : case 'C' : case 'D' : case 'E' : case 'F' : baseChar = 'A' ; case 'a' : case 'b' : case 'c' : case 'd' : case 'e' : case 'f' : b <<= 4 ; b += ( byte ) ( count + 10 - baseChar ) ; characterCount ++ ; if ( characterCount == 2 ) { bytes . add ( new Byte ( b ) ) ; characterCount = 0 ; b = ( byte ) 0 ; } break ; case - 1 : done = true ; break ; default : break ; } } Byte [ ] polished = ( Byte [ ] ) bytes . toArray ( new Byte [ 0 ] ) ; byte [ ] rval = new byte [ polished . length ] ; for ( int j = 0 ; j < polished . length ; j ++ ) { rval [ j ] = polished [ j ] . byteValue ( ) ; } return rval ; } static public byte [ ] readFromString ( String data ) throws IOException { return readData ( new ByteArrayInputStream ( data . getBytes ( ) ) , - 1 ) ; } static private void readToEOL ( InputStream stream ) throws IOException { int c = stream . read ( ) ; while ( c != - 1 && c != '\n' && c != '\r' ) { c = stream . read ( ) ; } } } 	0	['6', '1', '0', '1', '27', '15', '1', '0', '5', '2', '264', '0', '0', '0', '0.291666667', '0', '0', '43', '1', '0.8333', '0']
package org . apache . poi . hssf . model ; import org . apache . poi . ddf . EscherDggRecord ; import org . apache . poi . ddf . EscherDgRecord ; import java . util . Map ; import java . util . HashMap ; public class DrawingManager { EscherDggRecord dgg ; Map dgMap = new HashMap ( ) ; public DrawingManager ( EscherDggRecord dgg ) { this . dgg = dgg ; } public EscherDgRecord createDgRecord ( ) { EscherDgRecord dg = new EscherDgRecord ( ) ; dg . setRecordId ( EscherDgRecord . RECORD_ID ) ; short dgId = findNewDrawingGroupId ( ) ; dg . setOptions ( ( short ) ( dgId << 4 ) ) ; dg . setNumShapes ( 0 ) ; dg . setLastMSOSPID ( - 1 ) ; dgg . addCluster ( dgId , 0 ) ; dgg . setDrawingsSaved ( dgg . getDrawingsSaved ( ) + 1 ) ; dgMap . put ( new Short ( dgId ) , dg ) ; return dg ; } public int allocateShapeId ( short drawingGroupId ) { EscherDgRecord dg = ( EscherDgRecord ) dgMap . get ( new Short ( drawingGroupId ) ) ; int lastShapeId = dg . getLastMSOSPID ( ) ; int newShapeId = 0 ; if ( lastShapeId % 1024 == 1023 ) { newShapeId = findFreeSPIDBlock ( ) ; dgg . addCluster ( drawingGroupId , 1 ) ; } else { for ( int i = 0 ; i < dgg . getFileIdClusters ( ) . length ; i ++ ) { EscherDggRecord . FileIdCluster c = dgg . getFileIdClusters ( ) [ i ] ; if ( c . getDrawingGroupId ( ) == drawingGroupId ) { if ( c . getNumShapeIdsUsed ( ) != 1024 ) { c . incrementShapeId ( ) ; } } if ( dg . getLastMSOSPID ( ) == - 1 ) { newShapeId = findFreeSPIDBlock ( ) ; } else { newShapeId = dg . getLastMSOSPID ( ) + 1 ; } } } dgg . setNumShapesSaved ( dgg . getNumShapesSaved ( ) + 1 ) ; if ( newShapeId >= dgg . getShapeIdMax ( ) ) { dgg . setShapeIdMax ( newShapeId + 1 ) ; } dg . setLastMSOSPID ( newShapeId ) ; dg . incrementShapeCount ( ) ; return newShapeId ; } short findNewDrawingGroupId ( ) { short dgId = 1 ; while ( drawingGroupExists ( dgId ) ) dgId ++ ; return dgId ; } boolean drawingGroupExists ( short dgId ) { for ( int i = 0 ; i < dgg . getFileIdClusters ( ) . length ; i ++ ) { if ( dgg . getFileIdClusters ( ) [ i ] . getDrawingGroupId ( ) == dgId ) return true ; } return false ; } int findFreeSPIDBlock ( ) { int max = dgg . getShapeIdMax ( ) ; int next = ( ( max / 1024 ) + 1 ) * 1024 ; return next ; } public EscherDggRecord getDgg ( ) { return dgg ; } } 	0	['7', '1', '0', '7', '30', '0', '4', '3', '4', '0.333333333', '212', '0', '1', '0', '0.476190476', '0', '0', '29', '7', '2.1429', '0']
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . record . FooterRecord ; public class HSSFFooter extends Object { FooterRecord footerRecord ; String left ; String center ; String right ; protected HSSFFooter ( FooterRecord footerRecord ) { this . footerRecord = footerRecord ; String foot = footerRecord . getFooter ( ) ; while ( foot != null && foot . length ( ) > 1 ) { int pos = foot . length ( ) ; switch ( foot . substring ( 1 , 2 ) . charAt ( 0 ) ) { case 'L' : if ( foot . indexOf ( "&C" ) >= 0 ) { pos = Math . min ( pos , foot . indexOf ( "&C" ) ) ; } if ( foot . indexOf ( "&R" ) >= 0 ) { pos = Math . min ( pos , foot . indexOf ( "&R" ) ) ; } left = foot . substring ( 2 , pos ) ; foot = foot . substring ( pos ) ; break ; case 'C' : if ( foot . indexOf ( "&L" ) >= 0 ) { pos = Math . min ( pos , foot . indexOf ( "&L" ) ) ; } if ( foot . indexOf ( "&R" ) >= 0 ) { pos = Math . min ( pos , foot . indexOf ( "&R" ) ) ; } center = foot . substring ( 2 , pos ) ; foot = foot . substring ( pos ) ; break ; case 'R' : if ( foot . indexOf ( "&C" ) >= 0 ) { pos = Math . min ( pos , foot . indexOf ( "&C" ) ) ; } if ( foot . indexOf ( "&L" ) >= 0 ) { pos = Math . min ( pos , foot . indexOf ( "&L" ) ) ; } right = foot . substring ( 2 , pos ) ; foot = foot . substring ( pos ) ; break ; default : foot = null ; } } } public String getLeft ( ) { return left ; } public void setLeft ( String newLeft ) { left = newLeft ; createFooterString ( ) ; } public String getCenter ( ) { return center ; } public void setCenter ( String newCenter ) { center = newCenter ; createFooterString ( ) ; } public String getRight ( ) { return right ; } public void setRight ( String newRight ) { right = newRight ; createFooterString ( ) ; } private void createFooterString ( ) { footerRecord . setFooter ( "&C" + ( center == null ? "" : center ) + "&L" + ( left == null ? "" : left ) + "&R" + ( right == null ? "" : right ) ) ; footerRecord . setFooterLength ( ( byte ) footerRecord . getFooter ( ) . length ( ) ) ; } public static String fontSize ( short size ) { return "&" + size ; } public static String font ( String font , String style ) { return "&\"" + font + "," + style + "\"" ; } public static String page ( ) { return "&P" ; } public static String numPages ( ) { return "&N" ; } public static String date ( ) { return "&D" ; } public static String time ( ) { return "&T" ; } public static String file ( ) { return "&F" ; } public static String tab ( ) { return "&A" ; } } 	0	['16', '1', '0', '2', '30', '88', '1', '1', '14', '0.683333333', '250', '0', '1', '0', '0.21875', '0', '0', '14.375', '4', '1.125', '0']
package org . apache . poi . ddf ; abstract public class EscherProperty { private short id ; public EscherProperty ( short id ) { this . id = id ; } public EscherProperty ( short propertyNumber , boolean isComplex , boolean isBlipId ) { this . id = ( short ) ( propertyNumber + ( isComplex ? 0x8000 : 0x0 ) + ( isBlipId ? 0x4000 : 0x0 ) ) ; } public short getId ( ) { return id ; } public short getPropertyNumber ( ) { return ( short ) ( id & ( short ) 0x3FFF ) ; } public boolean isComplex ( ) { return ( id & ( short ) 0x8000 ) != 0 ; } public boolean isBlipId ( ) { return ( id & ( short ) 0x4000 ) != 0 ; } public String getName ( ) { return EscherProperties . getPropertyName ( id ) ; } public int getPropertySize ( ) { return 6 ; } abstract public int serializeSimplePart ( byte [ ] data , int pos ) ; abstract public int serializeComplexPart ( byte [ ] data , int pos ) ; } 	0	['10', '1', '2', '12', '12', '3', '11', '1', '10', '0.333333333', '69', '1', '0', '0', '0.34', '0', '0', '5.8', '2', '1', '0']
package org . apache . poi . hssf . util ; import org . apache . poi . hssf . record . MergeCellsRecord . MergedRegion ; public class Region implements Comparable { private int rowFrom ; private short colFrom ; private int rowTo ; private short colTo ; public Region ( ) { } public Region ( int rowFrom , short colFrom , int rowTo , short colTo ) { this . rowFrom = rowFrom ; this . rowTo = rowTo ; this . colFrom = colFrom ; this . colTo = colTo ; } public Region ( MergedRegion region ) { this ( region . row_from , region . col_from , region . row_to , region . col_to ) ; } public short getColumnFrom ( ) { return colFrom ; } public int getRowFrom ( ) { return rowFrom ; } public short getColumnTo ( ) { return colTo ; } public int getRowTo ( ) { return rowTo ; } public void setColumnFrom ( short colFrom ) { this . colFrom = colFrom ; } public void setRowFrom ( int rowFrom ) { this . rowFrom = rowFrom ; } public void setColumnTo ( short colTo ) { this . colTo = colTo ; } public void setRowTo ( int rowTo ) { this . rowTo = rowTo ; } public boolean contains ( int row , short col ) { if ( ( this . rowFrom <= row ) && ( this . rowTo >= row ) && ( this . colFrom <= col ) && ( this . colTo >= col ) ) { return true ; } return false ; } public boolean equals ( Region r ) { return ( compareTo ( r ) == 0 ) ; } public int compareTo ( Region r ) { if ( ( this . getRowFrom ( ) == r . getRowFrom ( ) ) && ( this . getColumnFrom ( ) == r . getColumnFrom ( ) ) && ( this . getRowTo ( ) == r . getRowTo ( ) ) && ( this . getColumnTo ( ) == r . getColumnTo ( ) ) ) { return 0 ; } if ( ( this . getRowFrom ( ) < r . getRowFrom ( ) ) || ( this . getColumnFrom ( ) < r . getColumnFrom ( ) ) || ( this . getRowTo ( ) < r . getRowTo ( ) ) || ( this . getColumnTo ( ) < r . getColumnTo ( ) ) ) { return 1 ; } return - 1 ; } public int compareTo ( Object o ) { return compareTo ( ( Region ) o ) ; } public int getArea ( ) { return ( ( 1 + ( getRowTo ( ) - getRowFrom ( ) ) ) * ( 1 + ( getColumnTo ( ) - getColumnFrom ( ) ) ) ) ; } } 	0	['16', '1', '0', '3', '17', '78', '2', '1', '16', '0.533333333', '172', '1', '0', '0', '0.291666667', '0', '0', '9.5', '9', '1.625', '0']
package org . apache . poi . poifs . storage ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . Arrays ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . util . IOUtils ; import org . apache . poi . util . IntegerField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; public class DocumentBlock extends BigBlock { private static final byte _default_value = ( byte ) 0xFF ; private byte [ ] _data ; private int _bytes_read ; public DocumentBlock ( final RawDataBlock block ) throws IOException { _data = block . getData ( ) ; _bytes_read = _data . length ; } public DocumentBlock ( final InputStream stream ) throws IOException { this ( ) ; int count = IOUtils . readFully ( stream , _data ) ; _bytes_read = ( count == - 1 ) ? 0 : count ; } private DocumentBlock ( ) { _data = new byte [ POIFSConstants . BIG_BLOCK_SIZE ] ; Arrays . fill ( _data , _default_value ) ; } public int size ( ) { return _bytes_read ; } public boolean partiallyRead ( ) { return _bytes_read != POIFSConstants . BIG_BLOCK_SIZE ; } public static byte getFillByte ( ) { return _default_value ; } public static DocumentBlock [ ] convert ( final byte [ ] array , final int size ) { DocumentBlock [ ] rval = new DocumentBlock [ ( size + POIFSConstants . BIG_BLOCK_SIZE - 1 ) / POIFSConstants . BIG_BLOCK_SIZE ] ; int offset = 0 ; for ( int k = 0 ; k < rval . length ; k ++ ) { rval [ k ] = new DocumentBlock ( ) ; if ( offset < array . length ) { int length = Math . min ( POIFSConstants . BIG_BLOCK_SIZE , array . length - offset ) ; System . arraycopy ( array , offset , rval [ k ] . _data , 0 , length ) ; if ( length != POIFSConstants . BIG_BLOCK_SIZE ) { Arrays . fill ( rval [ k ] . _data , length , POIFSConstants . BIG_BLOCK_SIZE , _default_value ) ; } } else { Arrays . fill ( rval [ k ] . _data , _default_value ) ; } offset += POIFSConstants . BIG_BLOCK_SIZE ; } return rval ; } public static void read ( final DocumentBlock [ ] blocks , final byte [ ] buffer , final int offset ) { int firstBlockIndex = offset / POIFSConstants . BIG_BLOCK_SIZE ; int firstBlockOffset = offset % POIFSConstants . BIG_BLOCK_SIZE ; int lastBlockIndex = ( offset + buffer . length - 1 ) / POIFSConstants . BIG_BLOCK_SIZE ; if ( firstBlockIndex == lastBlockIndex ) { System . arraycopy ( blocks [ firstBlockIndex ] . _data , firstBlockOffset , buffer , 0 , buffer . length ) ; } else { int buffer_offset = 0 ; System . arraycopy ( blocks [ firstBlockIndex ] . _data , firstBlockOffset , buffer , buffer_offset , POIFSConstants . BIG_BLOCK_SIZE - firstBlockOffset ) ; buffer_offset += POIFSConstants . BIG_BLOCK_SIZE - firstBlockOffset ; for ( int j = firstBlockIndex + 1 ; j < lastBlockIndex ; j ++ ) { System . arraycopy ( blocks [ j ] . _data , 0 , buffer , buffer_offset , POIFSConstants . BIG_BLOCK_SIZE ) ; buffer_offset += POIFSConstants . BIG_BLOCK_SIZE ; } System . arraycopy ( blocks [ lastBlockIndex ] . _data , 0 , buffer , buffer_offset , buffer . length - buffer_offset ) ; } } void writeData ( final OutputStream stream ) throws IOException { doWriteData ( stream , _data ) ; } } 	0	['10', '2', '0', '5', '19', '5', '2', '3', '8', '0.740740741', '223', '1', '0', '0.3', '0.228571429', '1', '2', '21', '3', '1.2', '0']
package org . apache . poi . ddf ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . record . RecordFormatException ; import java . util . List ; import java . util . ArrayList ; import java . util . Iterator ; public class EscherPropertyFactory { public List createProperties ( byte [ ] data , int offset , short numProperties ) { List results = new ArrayList ( ) ; int pos = offset ; int complexBytes = 0 ; for ( int i = 0 ; i < numProperties ; i ++ ) { short propId ; int propData ; propId = LittleEndian . getShort ( data , pos ) ; propData = LittleEndian . getInt ( data , pos + 2 ) ; short propNumber = ( short ) ( propId & ( short ) 0x3FFF ) ; boolean isComplex = ( propId & ( short ) 0x8000 ) != 0 ; boolean isBlipId = ( propId & ( short ) 0x4000 ) != 0 ; if ( isComplex ) complexBytes = propData ; else complexBytes = 0 ; byte propertyType = EscherProperties . getPropertyType ( ( short ) propNumber ) ; if ( propertyType == EscherPropertyMetaData . TYPE_BOOLEAN ) results . add ( new EscherBoolProperty ( propNumber , propData ) ) ; else if ( propertyType == EscherPropertyMetaData . TYPE_RGB ) results . add ( new EscherRGBProperty ( propNumber , propData ) ) ; else if ( propertyType == EscherPropertyMetaData . TYPE_SHAPEPATH ) results . add ( new EscherShapePathProperty ( propNumber , propData ) ) ; else { if ( ! isComplex ) results . add ( new EscherSimpleProperty ( propNumber , propData ) ) ; else { if ( propertyType == EscherPropertyMetaData . TYPE_ARRAY ) results . add ( new EscherArrayProperty ( propId , new byte [ propData ] ) ) ; else results . add ( new EscherComplexProperty ( propId , new byte [ propData ] ) ) ; } } pos += 6 ; } for ( Iterator iterator = results . iterator ( ) ; iterator . hasNext ( ) ; ) { EscherProperty p = ( EscherProperty ) iterator . next ( ) ; if ( p instanceof EscherComplexProperty ) { if ( p instanceof EscherArrayProperty ) { pos += ( ( EscherArrayProperty ) p ) . setArrayData ( data , pos ) ; } else { byte [ ] complexData = ( ( EscherComplexProperty ) p ) . getComplexData ( ) ; System . arraycopy ( data , pos , complexData , 0 , complexData . length ) ; pos += complexData . length ; } } } return results ; } } 	0	['2', '1', '0', '10', '20', '1', '1', '9', '2', '2', '175', '0', '0', '0', '0.625', '0', '0', '86.5', '12', '6', '0']
package org . apache . poi . poifs . storage ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . util . IntegerField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; import org . apache . poi . util . LongField ; import org . apache . poi . util . ShortField ; public interface HeaderBlockConstants { public static final long _signature = 0xE11AB1A1E011CFD0L ; public static final int _bat_array_offset = 0x4c ; public static final int _max_bats_in_header = ( POIFSConstants . BIG_BLOCK_SIZE - _bat_array_offset ) / LittleEndianConsts . INT_SIZE ; public static final int _signature_offset = 0 ; public static final int _bat_count_offset = 0x2C ; public static final int _property_start_offset = 0x30 ; public static final int _sbat_start_offset = 0x3C ; public static final int _sbat_block_count_offset = 0x40 ; public static final int _xbat_start_offset = 0x44 ; public static final int _xbat_count_offset = 0x48 ; } 	0	['0', '1', '0', '2', '0', '0', '2', '0', '0', '2', '10', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . poi . poifs . property ; import org . apache . poi . poifs . filesystem . POIFSDocument ; public class DocumentProperty extends Property { private POIFSDocument _document ; public DocumentProperty ( final String name , final int size ) { super ( ) ; _document = null ; setName ( name ) ; setSize ( size ) ; setNodeColor ( _NODE_BLACK ) ; setPropertyType ( PropertyConstants . DOCUMENT_TYPE ) ; } protected DocumentProperty ( final int index , final byte [ ] array , final int offset ) { super ( index , array , offset ) ; _document = null ; } public void setDocument ( POIFSDocument doc ) { _document = doc ; } public POIFSDocument getDocument ( ) { return _document ; } public boolean shouldUseSmallBlocks ( ) { return super . shouldUseSmallBlocks ( ) ; } public boolean isDirectory ( ) { return false ; } protected void preWrite ( ) { } } 	0	['7', '2', '0', '6', '14', '9', '5', '2', '5', '0.5', '48', '1', '1', '0.848484848', '0.342857143', '0', '0', '5.714285714', '1', '0.7143', '0']
package org . apache . poi . hssf . usermodel ; import org . apache . poi . hssf . record . PrintSetupRecord ; public class HSSFPrintSetup extends Object { public static final short LETTER_PAPERSIZE = 1 ; public static final short LEGAL_PAPERSIZE = 5 ; public static final short EXECUTIVE_PAPERSIZE = 7 ; public static final short A4_PAPERSIZE = 9 ; public static final short A5_PAPERSIZE = 11 ; public static final short ENVELOPE_10_PAPERSIZE = 20 ; public static final short ENVELOPE_DL_PAPERSIZE = 27 ; public static final short ENVELOPE_CS_PAPERSIZE = 28 ; public static final short ENVELOPE_MONARCH_PAPERSIZE = 37 ; PrintSetupRecord printSetupRecord ; protected HSSFPrintSetup ( PrintSetupRecord printSetupRecord ) { this . printSetupRecord = printSetupRecord ; } public void setPaperSize ( short size ) { printSetupRecord . setPaperSize ( size ) ; } public void setScale ( short scale ) { printSetupRecord . setScale ( scale ) ; } public void setPageStart ( short start ) { printSetupRecord . setPageStart ( start ) ; } public void setFitWidth ( short width ) { printSetupRecord . setFitWidth ( width ) ; } public void setFitHeight ( short height ) { printSetupRecord . setFitHeight ( height ) ; } public void setOptions ( short options ) { printSetupRecord . setOptions ( options ) ; } public void setLeftToRight ( boolean ltor ) { printSetupRecord . setLeftToRight ( ltor ) ; } public void setLandscape ( boolean ls ) { printSetupRecord . setLandscape ( ! ls ) ; } public void setValidSettings ( boolean valid ) { printSetupRecord . setValidSettings ( valid ) ; } public void setNoColor ( boolean mono ) { printSetupRecord . setNoColor ( mono ) ; } public void setDraft ( boolean d ) { printSetupRecord . setDraft ( d ) ; } public void setNotes ( boolean printnotes ) { printSetupRecord . setNotes ( printnotes ) ; } public void setNoOrientation ( boolean orientation ) { printSetupRecord . setNoOrientation ( orientation ) ; } public void setUsePage ( boolean page ) { printSetupRecord . setUsePage ( page ) ; } public void setHResolution ( short resolution ) { printSetupRecord . setHResolution ( resolution ) ; } public void setVResolution ( short resolution ) { printSetupRecord . setVResolution ( resolution ) ; } public void setHeaderMargin ( double headermargin ) { printSetupRecord . setHeaderMargin ( headermargin ) ; } public void setFooterMargin ( double footermargin ) { printSetupRecord . setFooterMargin ( footermargin ) ; } public void setCopies ( short copies ) { printSetupRecord . setCopies ( copies ) ; } public short getPaperSize ( ) { return printSetupRecord . getPaperSize ( ) ; } public short getScale ( ) { return printSetupRecord . getScale ( ) ; } public short getPageStart ( ) { return printSetupRecord . getPageStart ( ) ; } public short getFitWidth ( ) { return printSetupRecord . getFitWidth ( ) ; } public short getFitHeight ( ) { return printSetupRecord . getFitHeight ( ) ; } public short getOptions ( ) { return printSetupRecord . getOptions ( ) ; } public boolean getLeftToRight ( ) { return printSetupRecord . getLeftToRight ( ) ; } public boolean getLandscape ( ) { return ! printSetupRecord . getLandscape ( ) ; } public boolean getValidSettings ( ) { return printSetupRecord . getValidSettings ( ) ; } public boolean getNoColor ( ) { return printSetupRecord . getNoColor ( ) ; } public boolean getDraft ( ) { return printSetupRecord . getDraft ( ) ; } public boolean getNotes ( ) { return printSetupRecord . getNotes ( ) ; } public boolean getNoOrientation ( ) { return printSetupRecord . getNoOrientation ( ) ; } public boolean getUsePage ( ) { return printSetupRecord . getUsePage ( ) ; } public short getHResolution ( ) { return printSetupRecord . getHResolution ( ) ; } public short getVResolution ( ) { return printSetupRecord . getVResolution ( ) ; } public double getHeaderMargin ( ) { return printSetupRecord . getHeaderMargin ( ) ; } public double getFooterMargin ( ) { return printSetupRecord . getFooterMargin ( ) ; } public short getCopies ( ) { return printSetupRecord . getCopies ( ) ; } } 	0	['39', '1', '0', '3', '78', '0', '2', '1', '38', '0.923684211', '234', '0', '1', '0', '0.302564103', '0', '0', '4.743589744', '2', '1.0256', '0']
package org . apache . poi . hssf . model ; import org . apache . poi . ddf . EscherRecord ; import org . apache . poi . ddf . EscherClientAnchorRecord ; import org . apache . poi . ddf . EscherChildAnchorRecord ; import org . apache . poi . hssf . usermodel . HSSFAnchor ; import org . apache . poi . hssf . usermodel . HSSFClientAnchor ; import org . apache . poi . hssf . usermodel . HSSFChildAnchor ; public class ConvertAnchor { public static EscherRecord createAnchor ( HSSFAnchor userAnchor ) { if ( userAnchor instanceof HSSFClientAnchor ) { HSSFClientAnchor a = ( HSSFClientAnchor ) userAnchor ; EscherClientAnchorRecord anchor = new EscherClientAnchorRecord ( ) ; anchor . setRecordId ( EscherClientAnchorRecord . RECORD_ID ) ; anchor . setOptions ( ( short ) 0x0000 ) ; anchor . setFlag ( ( short ) 0 ) ; anchor . setCol1 ( ( short ) Math . min ( a . getCol1 ( ) , a . getCol2 ( ) ) ) ; anchor . setDx1 ( ( short ) Math . min ( a . getDx1 ( ) , a . getDx2 ( ) ) ) ; anchor . setRow1 ( ( short ) Math . min ( a . getRow1 ( ) , a . getRow2 ( ) ) ) ; anchor . setDy1 ( ( short ) Math . min ( a . getDy1 ( ) , a . getDy2 ( ) ) ) ; anchor . setCol2 ( ( short ) Math . max ( a . getCol1 ( ) , a . getCol2 ( ) ) ) ; anchor . setDx2 ( ( short ) Math . max ( a . getDx1 ( ) , a . getDx2 ( ) ) ) ; anchor . setRow2 ( ( short ) Math . max ( a . getRow1 ( ) , a . getRow2 ( ) ) ) ; anchor . setDy2 ( ( short ) Math . max ( a . getDy1 ( ) , a . getDy2 ( ) ) ) ; return anchor ; } else { HSSFChildAnchor a = ( HSSFChildAnchor ) userAnchor ; EscherChildAnchorRecord anchor = new EscherChildAnchorRecord ( ) ; anchor . setRecordId ( EscherChildAnchorRecord . RECORD_ID ) ; anchor . setOptions ( ( short ) 0x0000 ) ; anchor . setDx1 ( ( short ) Math . min ( a . getDx1 ( ) , a . getDx2 ( ) ) ) ; anchor . setDy1 ( ( short ) Math . min ( a . getDy1 ( ) , a . getDy2 ( ) ) ) ; anchor . setDx2 ( ( short ) Math . max ( a . getDx2 ( ) , a . getDx1 ( ) ) ) ; anchor . setDy2 ( ( short ) Math . max ( a . getDy2 ( ) , a . getDy1 ( ) ) ) ; return anchor ; } } } 	0	['2', '1', '0', '8', '36', '1', '2', '6', '2', '2', '137', '0', '0', '0', '0.5', '0', '0', '67.5', '2', '1', '0']
package org . apache . poi . poifs . storage ; import java . io . IOException ; import java . io . OutputStream ; import java . util . Arrays ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . util . IntegerField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; public class BATBlock extends BigBlock { private static final int _entries_per_block = POIFSConstants . BIG_BLOCK_SIZE / LittleEndianConsts . INT_SIZE ; private static final int _entries_per_xbat_block = _entries_per_block - 1 ; private static final int _xbat_chain_offset = _entries_per_xbat_block * LittleEndianConsts . INT_SIZE ; private static final byte _default_value = ( byte ) 0xFF ; private IntegerField [ ] _fields ; private byte [ ] _data ; private BATBlock ( ) { _data = new byte [ POIFSConstants . BIG_BLOCK_SIZE ] ; Arrays . fill ( _data , _default_value ) ; _fields = new IntegerField [ _entries_per_block ] ; int offset = 0 ; for ( int j = 0 ; j < _entries_per_block ; j ++ ) { _fields [ j ] = new IntegerField ( offset ) ; offset += LittleEndianConsts . INT_SIZE ; } } public static BATBlock [ ] createBATBlocks ( final int [ ] entries ) { int block_count = calculateStorageRequirements ( entries . length ) ; BATBlock [ ] blocks = new BATBlock [ block_count ] ; int index = 0 ; int remaining = entries . length ; for ( int j = 0 ; j < entries . length ; j += _entries_per_block ) { blocks [ index ++ ] = new BATBlock ( entries , j , ( remaining > _entries_per_block ) ? j + _entries_per_block : entries . length ) ; remaining -= _entries_per_block ; } return blocks ; } public static BATBlock [ ] createXBATBlocks ( final int [ ] entries , final int startBlock ) { int block_count = calculateXBATStorageRequirements ( entries . length ) ; BATBlock [ ] blocks = new BATBlock [ block_count ] ; int index = 0 ; int remaining = entries . length ; if ( block_count != 0 ) { for ( int j = 0 ; j < entries . length ; j += _entries_per_xbat_block ) { blocks [ index ++ ] = new BATBlock ( entries , j , ( remaining > _entries_per_xbat_block ) ? j + _entries_per_xbat_block : entries . length ) ; remaining -= _entries_per_xbat_block ; } for ( index = 0 ; index < blocks . length - 1 ; index ++ ) { blocks [ index ] . setXBATChain ( startBlock + index + 1 ) ; } blocks [ index ] . setXBATChain ( POIFSConstants . END_OF_CHAIN ) ; } return blocks ; } public static int calculateStorageRequirements ( final int entryCount ) { return ( entryCount + _entries_per_block - 1 ) / _entries_per_block ; } public static int calculateXBATStorageRequirements ( final int entryCount ) { return ( entryCount + _entries_per_xbat_block - 1 ) / _entries_per_xbat_block ; } public static final int entriesPerBlock ( ) { return _entries_per_block ; } public static final int entriesPerXBATBlock ( ) { return _entries_per_xbat_block ; } public static final int getXBATChainOffset ( ) { return _xbat_chain_offset ; } private void setXBATChain ( int chainIndex ) { _fields [ _entries_per_xbat_block ] . set ( chainIndex , _data ) ; } private BATBlock ( final int [ ] entries , final int start_index , final int end_index ) { this ( ) ; for ( int k = start_index ; k < end_index ; k ++ ) { _fields [ k - start_index ] . set ( entries [ k ] , _data ) ; } } void writeData ( final OutputStream stream ) throws IOException { doWriteData ( stream , _data ) ; } } 	0	['12', '2', '0', '6', '18', '54', '4', '2', '8', '0.924242424', '222', '1', '1', '0.230769231', '0.3125', '1', '2', '17', '5', '1.3333', '0']
package org . apache . poi . ddf ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . HexDump ; import java . io . ByteArrayOutputStream ; import java . io . PrintWriter ; public class EscherBSERecord extends EscherRecord { public static final short RECORD_ID = ( short ) 0xF007 ; public static final String RECORD_DESCRIPTION = "MsofbtBSE" ; public static final byte BT_ERROR = 0 ; public static final byte BT_UNKNOWN = 1 ; public static final byte BT_EMF = 2 ; public static final byte BT_WMF = 3 ; public static final byte BT_PICT = 4 ; public static final byte BT_JPEG = 5 ; public static final byte BT_PNG = 6 ; public static final byte BT_DIB = 7 ; private byte field_1_blipTypeWin32 ; private byte field_2_blipTypeMacOS ; private byte [ ] field_3_uid ; private short field_4_tag ; private int field_5_size ; private int field_6_ref ; private int field_7_offset ; private byte field_8_usage ; private byte field_9_name ; private byte field_10_unused2 ; private byte field_11_unused3 ; private byte [ ] remainingData ; public int fillFields ( byte [ ] data , int offset , EscherRecordFactory recordFactory ) { int bytesRemaining = readHeader ( data , offset ) ; int pos = offset + 8 ; field_1_blipTypeWin32 = data [ pos ] ; field_2_blipTypeMacOS = data [ pos + 1 ] ; System . arraycopy ( data , pos + 2 , field_3_uid = new byte [ 16 ] , 0 , 16 ) ; field_4_tag = LittleEndian . getShort ( data , pos + 18 ) ; field_5_size = LittleEndian . getInt ( data , pos + 20 ) ; field_6_ref = LittleEndian . getInt ( data , pos + 24 ) ; field_7_offset = LittleEndian . getInt ( data , pos + 28 ) ; field_8_usage = data [ pos + 32 ] ; field_9_name = data [ pos + 33 ] ; field_10_unused2 = data [ pos + 34 ] ; field_11_unused3 = data [ pos + 35 ] ; bytesRemaining -= 36 ; remainingData = new byte [ bytesRemaining ] ; System . arraycopy ( data , pos + 36 , remainingData , 0 , bytesRemaining ) ; return bytesRemaining + 8 + 36 ; } public int serialize ( int offset , byte [ ] data , EscherSerializationListener listener ) { listener . beforeRecordSerialize ( offset , getRecordId ( ) , this ) ; LittleEndian . putShort ( data , offset , getOptions ( ) ) ; LittleEndian . putShort ( data , offset + 2 , getRecordId ( ) ) ; int remainingBytes = remainingData . length + 36 ; LittleEndian . putInt ( data , offset + 4 , remainingBytes ) ; data [ offset + 8 ] = field_1_blipTypeWin32 ; data [ offset + 9 ] = field_2_blipTypeMacOS ; for ( int i = 0 ; i < 16 ; i ++ ) data [ offset + 10 + i ] = field_3_uid [ i ] ; LittleEndian . putShort ( data , offset + 26 , field_4_tag ) ; LittleEndian . putInt ( data , offset + 28 , field_5_size ) ; LittleEndian . putInt ( data , offset + 32 , field_6_ref ) ; LittleEndian . putInt ( data , offset + 36 , field_7_offset ) ; data [ offset + 40 ] = field_8_usage ; data [ offset + 41 ] = field_9_name ; data [ offset + 42 ] = field_10_unused2 ; data [ offset + 43 ] = field_11_unused3 ; System . arraycopy ( remainingData , 0 , data , offset + 44 , remainingData . length ) ; int pos = offset + 8 + 36 + remainingData . length ; listener . afterRecordSerialize ( pos , getRecordId ( ) , pos - offset , this ) ; return pos - offset ; } public int getRecordSize ( ) { return 8 + 1 + 1 + 16 + 2 + 4 + 4 + 4 + 1 + 1 + 1 + 1 + remainingData . length ; } public String getRecordName ( ) { return "BSE" ; } public byte getBlipTypeWin32 ( ) { return field_1_blipTypeWin32 ; } public void setBlipTypeWin32 ( byte blipTypeWin32 ) { this . field_1_blipTypeWin32 = blipTypeWin32 ; } public byte getBlipTypeMacOS ( ) { return field_2_blipTypeMacOS ; } public void setBlipTypeMacOS ( byte blipTypeMacOS ) { this . field_2_blipTypeMacOS = blipTypeMacOS ; } public byte [ ] getUid ( ) { return field_3_uid ; } public void setUid ( byte [ ] uid ) { this . field_3_uid = uid ; } public short getTag ( ) { return field_4_tag ; } public void setTag ( short tag ) { this . field_4_tag = tag ; } public int getSize ( ) { return field_5_size ; } public void setSize ( int size ) { this . field_5_size = size ; } public int getRef ( ) { return field_6_ref ; } public void setRef ( int ref ) { this . field_6_ref = ref ; } public int getOffset ( ) { return field_7_offset ; } public void setOffset ( int offset ) { this . field_7_offset = offset ; } public byte getUsage ( ) { return field_8_usage ; } public void setUsage ( byte usage ) { this . field_8_usage = usage ; } public byte getName ( ) { return field_9_name ; } public void setName ( byte name ) { this . field_9_name = name ; } public byte getUnused2 ( ) { return field_10_unused2 ; } public void setUnused2 ( byte unused2 ) { this . field_10_unused2 = unused2 ; } public byte getUnused3 ( ) { return field_11_unused3 ; } public void setUnused3 ( byte unused3 ) { this . field_11_unused3 = unused3 ; } public byte [ ] getRemainingData ( ) { return remainingData ; } public void setRemainingData ( byte [ ] remainingData ) { this . remainingData = remainingData ; } public String toString ( ) { String nl = System . getProperty ( "line.separator" ) ; String extraData ; ByteArrayOutputStream b = new ByteArrayOutputStream ( ) ; try { HexDump . dump ( this . remainingData , 0 , b , 0 ) ; extraData = b . toString ( ) ; } catch ( Exception e ) { extraData = e . toString ( ) ; } return getClass ( ) . getName ( ) + ":" + nl + "  RecordId: 0x" + HexDump . toHex ( RECORD_ID ) + nl + "  Options: 0x" + HexDump . toHex ( getOptions ( ) ) + nl + "  BlipTypeWin32: " + field_1_blipTypeWin32 + nl + "  BlipTypeMacOS: " + field_2_blipTypeMacOS + nl + "  SUID: " + HexDump . toHex ( field_3_uid ) + nl + "  Tag: " + field_4_tag + nl + "  Size: " + field_5_size + nl + "  Ref: " + field_6_ref + nl + "  Offset: " + field_7_offset + nl + "  Usage: " + field_8_usage + nl + "  Name: " + field_9_name + nl + "  Unused2: " + field_10_unused2 + nl + "  Unused3: " + field_11_unused3 + nl + "  Extra Data:" + nl + extraData ; } public String getBlipType ( byte b ) { switch ( b ) { case BT_ERROR : return " ERROR" ; case BT_UNKNOWN : return " UNKNOWN" ; case BT_EMF : return " EMF" ; case BT_WMF : return " WMF" ; case BT_PICT : return " PICT" ; case BT_JPEG : return " JPEG" ; case BT_PNG : return " PNG" ; case BT_DIB : return " DIB" ; default : if ( b < 32 ) return " NotKnown" ; else return " Client" ; } } } 	0	['31', '2', '0', '5', '55', '281', '0', '5', '31', '0.940909091', '567', '0.545454545', '0', '0.387755102', '0.230414747', '1', '5', '16.58064516', '3', '1.0645', '0']
package org . apache . poi . util ; public interface LittleEndianConsts { public static final int BYTE_SIZE = 1 ; public static final int SHORT_SIZE = 2 ; public static final int INT_SIZE = 4 ; public static final int LONG_SIZE = 8 ; public static final int DOUBLE_SIZE = 8 ; } 	0	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '5', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . poi . poifs . eventfilesystem ; import java . util . * ; import org . apache . poi . poifs . filesystem . DocumentDescriptor ; import org . apache . poi . poifs . filesystem . POIFSDocumentPath ; class POIFSReaderRegistry { private Set omnivorousListeners ; private Map selectiveListeners ; private Map chosenDocumentDescriptors ; POIFSReaderRegistry ( ) { omnivorousListeners = new HashSet ( ) ; selectiveListeners = new HashMap ( ) ; chosenDocumentDescriptors = new HashMap ( ) ; } void registerListener ( final POIFSReaderListener listener , final POIFSDocumentPath path , final String documentName ) { if ( ! omnivorousListeners . contains ( listener ) ) { Set descriptors = ( Set ) selectiveListeners . get ( listener ) ; if ( descriptors == null ) { descriptors = new HashSet ( ) ; selectiveListeners . put ( listener , descriptors ) ; } DocumentDescriptor descriptor = new DocumentDescriptor ( path , documentName ) ; if ( descriptors . add ( descriptor ) ) { Set listeners = ( Set ) chosenDocumentDescriptors . get ( descriptor ) ; if ( listeners == null ) { listeners = new HashSet ( ) ; chosenDocumentDescriptors . put ( descriptor , listeners ) ; } listeners . add ( listener ) ; } } } void registerListener ( final POIFSReaderListener listener ) { if ( ! omnivorousListeners . contains ( listener ) ) { removeSelectiveListener ( listener ) ; omnivorousListeners . add ( listener ) ; } } Iterator getListeners ( final POIFSDocumentPath path , final String name ) { Set rval = new HashSet ( omnivorousListeners ) ; Set selectiveListeners = ( Set ) chosenDocumentDescriptors . get ( new DocumentDescriptor ( path , name ) ) ; if ( selectiveListeners != null ) { rval . addAll ( selectiveListeners ) ; } return rval . iterator ( ) ; } private void removeSelectiveListener ( final POIFSReaderListener listener ) { Set selectedDescriptors = ( Set ) selectiveListeners . remove ( listener ) ; if ( selectedDescriptors != null ) { Iterator iter = selectedDescriptors . iterator ( ) ; while ( iter . hasNext ( ) ) { dropDocument ( listener , ( DocumentDescriptor ) iter . next ( ) ) ; } } } private void dropDocument ( final POIFSReaderListener listener , final DocumentDescriptor descriptor ) { Set listeners = ( Set ) chosenDocumentDescriptors . get ( descriptor ) ; listeners . remove ( listener ) ; if ( listeners . size ( ) == 0 ) { chosenDocumentDescriptors . remove ( descriptor ) ; } } } 	0	['6', '1', '0', '4', '22', '0', '1', '3', '0', '0.333333333', '163', '1', '0', '0', '0.5', '0', '0', '25.66666667', '5', '2.3333', '0']
package org . apache . poi . util ; import org . apache . poi . util . LittleEndian . BufferUnderrunException ; import java . io . * ; public class LongField implements FixedField { private long _value ; private final int _offset ; public LongField ( final int offset ) throws ArrayIndexOutOfBoundsException { if ( offset < 0 ) { throw new ArrayIndexOutOfBoundsException ( "Illegal offset: " + offset ) ; } _offset = offset ; } public LongField ( final int offset , final long value ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; set ( value ) ; } public LongField ( final int offset , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; readFromBytes ( data ) ; } public LongField ( final int offset , final long value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; set ( value , data ) ; } public long get ( ) { return _value ; } public void set ( final long value ) { _value = value ; } public void set ( final long value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = value ; writeToBytes ( data ) ; } public void readFromBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = LittleEndian . getLong ( data , _offset ) ; } public void readFromStream ( final InputStream stream ) throws IOException , BufferUnderrunException { _value = LittleEndian . readLong ( stream ) ; } public void writeToBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { LittleEndian . putLong ( data , _offset , _value ) ; } public String toString ( ) { return String . valueOf ( _value ) ; } } 	0	['11', '1', '0', '5', '21', '9', '2', '3', '11', '0.25', '92', '1', '0', '0', '0.454545455', '0', '0', '7.181818182', '1', '0.6364', '0']
package org . apache . poi . poifs . storage ; import java . io . IOException ; import java . io . OutputStream ; abstract class BigBlock implements BlockWritable { protected void doWriteData ( final OutputStream stream , final byte [ ] data ) throws IOException { stream . write ( data ) ; } abstract void writeData ( final OutputStream stream ) throws IOException ; public void writeBlocks ( final OutputStream stream ) throws IOException { writeData ( stream ) ; } } 	0	['4', '1', '4', '5', '6', '6', '4', '1', '1', '2', '15', '0', '0', '0', '0.666666667', '0', '0', '2.75', '1', '0.75', '0']
package org . apache . poi . poifs . storage ; import java . io . IOException ; import java . io . OutputStream ; public interface BlockWritable { public void writeBlocks ( final OutputStream stream ) throws IOException ; } 	0	['1', '1', '0', '9', '1', '0', '9', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . poi . ddf ; import org . apache . poi . util . HexDump ; import org . apache . poi . util . LittleEndian ; import java . io . ByteArrayOutputStream ; public class EscherClientDataRecord extends EscherRecord { public static final short RECORD_ID = ( short ) 0xF011 ; public static final String RECORD_DESCRIPTION = "MsofbtClientData" ; private byte [ ] remainingData ; public int fillFields ( byte [ ] data , int offset , EscherRecordFactory recordFactory ) { int bytesRemaining = readHeader ( data , offset ) ; int pos = offset + 8 ; remainingData = new byte [ bytesRemaining ] ; System . arraycopy ( data , pos , remainingData , 0 , bytesRemaining ) ; return 8 + bytesRemaining ; } public int serialize ( int offset , byte [ ] data , EscherSerializationListener listener ) { listener . beforeRecordSerialize ( offset , getRecordId ( ) , this ) ; if ( remainingData == null ) remainingData = new byte [ 0 ] ; LittleEndian . putShort ( data , offset , getOptions ( ) ) ; LittleEndian . putShort ( data , offset + 2 , getRecordId ( ) ) ; LittleEndian . putInt ( data , offset + 4 , remainingData . length ) ; System . arraycopy ( remainingData , 0 , data , offset + 8 , remainingData . length ) ; int pos = offset + 8 + remainingData . length ; listener . afterRecordSerialize ( pos , getRecordId ( ) , pos - offset , this ) ; return pos - offset ; } public int getRecordSize ( ) { return 8 + ( remainingData == null ? 0 : remainingData . length ) ; } public short getRecordId ( ) { return RECORD_ID ; } public String getRecordName ( ) { return "ClientData" ; } public String toString ( ) { String nl = System . getProperty ( "line.separator" ) ; String extraData ; ByteArrayOutputStream b = new ByteArrayOutputStream ( ) ; try { HexDump . dump ( this . remainingData , 0 , b , 0 ) ; extraData = b . toString ( ) ; } catch ( Exception e ) { extraData = "error" ; } return getClass ( ) . getName ( ) + ":" + nl + "  RecordId: 0x" + HexDump . toHex ( RECORD_ID ) + nl + "  Options: 0x" + HexDump . toHex ( getOptions ( ) ) + nl + "  Extra Data:" + nl + extraData ; } public byte [ ] getRemainingData ( ) { return remainingData ; } public void setRemainingData ( byte [ ] remainingData ) { this . remainingData = remainingData ; } } 	0	['9', '2', '0', '10', '27', '6', '5', '5', '9', '0.875', '180', '0.333333333', '0', '0.703703704', '0.355555556', '1', '5', '18.66666667', '2', '1.1111', '0']
package org . apache . poi . hssf . usermodel ; public interface HSSFErrorConstants { public static final byte ERROR_NULL = 0x00 ; public static final byte ERROR_DIV_0 = 0x07 ; public static final byte ERROR_VALUE = 0x0f ; public static final byte ERROR_REF = 0x17 ; public static final byte ERROR_NAME = 0x1d ; public static final byte ERROR_NUM = 0x24 ; public static final byte ERROR_NA = 0x2a ; } 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '7', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . poi . ddf ; import org . apache . poi . util . HexDump ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . record . RecordFormatException ; import java . lang . reflect . Array ; import java . util . * ; public class EscherDggRecord extends EscherRecord { public static final short RECORD_ID = ( short ) 0xF006 ; public static final String RECORD_DESCRIPTION = "MsofbtDgg" ; private int field_1_shapeIdMax ; private int field_3_numShapesSaved ; private int field_4_drawingsSaved ; private FileIdCluster [ ] field_5_fileIdClusters ; public static class FileIdCluster { public FileIdCluster ( int drawingGroupId , int numShapeIdsUsed ) { this . field_1_drawingGroupId = drawingGroupId ; this . field_2_numShapeIdsUsed = numShapeIdsUsed ; } private int field_1_drawingGroupId ; private int field_2_numShapeIdsUsed ; public int getDrawingGroupId ( ) { return field_1_drawingGroupId ; } public int getNumShapeIdsUsed ( ) { return field_2_numShapeIdsUsed ; } public void incrementShapeId ( ) { this . field_2_numShapeIdsUsed ++ ; } } public int fillFields ( byte [ ] data , int offset , EscherRecordFactory recordFactory ) { int bytesRemaining = readHeader ( data , offset ) ; int pos = offset + 8 ; int size = 0 ; field_1_shapeIdMax = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; int field_2_numIdClusters = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; field_3_numShapesSaved = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; field_4_drawingsSaved = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; field_5_fileIdClusters = new FileIdCluster [ field_2_numIdClusters - 1 ] ; for ( int i = 0 ; i < field_2_numIdClusters - 1 ; i ++ ) { field_5_fileIdClusters [ i ] = new FileIdCluster ( LittleEndian . getInt ( data , pos + size ) , LittleEndian . getInt ( data , pos + size + 4 ) ) ; size += 8 ; } bytesRemaining -= size ; if ( bytesRemaining != 0 ) throw new RecordFormatException ( "Expecting no remaining data but got " + bytesRemaining + " byte(s)." ) ; return 8 + size + bytesRemaining ; } public int serialize ( int offset , byte [ ] data , EscherSerializationListener listener ) { listener . beforeRecordSerialize ( offset , getRecordId ( ) , this ) ; int pos = offset ; LittleEndian . putShort ( data , pos , getOptions ( ) ) ; pos += 2 ; LittleEndian . putShort ( data , pos , getRecordId ( ) ) ; pos += 2 ; int remainingBytes = getRecordSize ( ) - 8 ; LittleEndian . putInt ( data , pos , remainingBytes ) ; pos += 4 ; LittleEndian . putInt ( data , pos , field_1_shapeIdMax ) ; pos += 4 ; LittleEndian . putInt ( data , pos , getNumIdClusters ( ) ) ; pos += 4 ; LittleEndian . putInt ( data , pos , field_3_numShapesSaved ) ; pos += 4 ; LittleEndian . putInt ( data , pos , field_4_drawingsSaved ) ; pos += 4 ; for ( int i = 0 ; i < field_5_fileIdClusters . length ; i ++ ) { LittleEndian . putInt ( data , pos , field_5_fileIdClusters [ i ] . field_1_drawingGroupId ) ; pos += 4 ; LittleEndian . putInt ( data , pos , field_5_fileIdClusters [ i ] . field_2_numShapeIdsUsed ) ; pos += 4 ; } listener . afterRecordSerialize ( pos , getRecordId ( ) , getRecordSize ( ) , this ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 8 + 16 + ( 8 * field_5_fileIdClusters . length ) ; } public short getRecordId ( ) { return RECORD_ID ; } public String getRecordName ( ) { return "Dgg" ; } public String toString ( ) { String nl = System . getProperty ( "line.separator" ) ; StringBuffer field_5_string = new StringBuffer ( ) ; for ( int i = 0 ; i < field_5_fileIdClusters . length ; i ++ ) { field_5_string . append ( "  DrawingGroupId" ) . append ( i + 1 ) . append ( ": " ) ; field_5_string . append ( field_5_fileIdClusters [ i ] . field_1_drawingGroupId ) ; field_5_string . append ( nl ) ; field_5_string . append ( "  NumShapeIdsUsed" ) . append ( i + 1 ) . append ( ": " ) ; field_5_string . append ( field_5_fileIdClusters [ i ] . field_2_numShapeIdsUsed ) ; field_5_string . append ( nl ) ; } return getClass ( ) . getName ( ) + ":" + nl + "  RecordId: 0x" + HexDump . toHex ( RECORD_ID ) + nl + "  Options: 0x" + HexDump . toHex ( getOptions ( ) ) + nl + "  ShapeIdMax: " + field_1_shapeIdMax + nl + "  NumIdClusters: " + getNumIdClusters ( ) + nl + "  NumShapesSaved: " + field_3_numShapesSaved + nl + "  DrawingsSaved: " + field_4_drawingsSaved + nl + "" + field_5_string . toString ( ) ; } public int getShapeIdMax ( ) { return field_1_shapeIdMax ; } public void setShapeIdMax ( int field_1_shapeIdMax ) { this . field_1_shapeIdMax = field_1_shapeIdMax ; } public int getNumIdClusters ( ) { return field_5_fileIdClusters . length + 1 ; } public int getNumShapesSaved ( ) { return field_3_numShapesSaved ; } public void setNumShapesSaved ( int field_3_numShapesSaved ) { this . field_3_numShapesSaved = field_3_numShapesSaved ; } public int getDrawingsSaved ( ) { return field_4_drawingsSaved ; } public void setDrawingsSaved ( int field_4_drawingsSaved ) { this . field_4_drawingsSaved = field_4_drawingsSaved ; } public FileIdCluster [ ] getFileIdClusters ( ) { return field_5_fileIdClusters ; } public void setFileIdClusters ( FileIdCluster [ ] field_5_fileIdClusters ) { this . field_5_fileIdClusters = field_5_fileIdClusters ; } public void addCluster ( int dgId , int numShapedUsed ) { List clusters = new ArrayList ( Arrays . asList ( field_5_fileIdClusters ) ) ; clusters . add ( new FileIdCluster ( dgId , numShapedUsed ) ) ; Collections . sort ( clusters , new Comparator ( ) { public int compare ( Object o1 , Object o2 ) { FileIdCluster f1 = ( FileIdCluster ) o1 ; FileIdCluster f2 = ( FileIdCluster ) o2 ; if ( f1 . getDrawingGroupId ( ) == f2 . getDrawingGroupId ( ) ) return 0 ; if ( f1 . getDrawingGroupId ( ) < f2 . getDrawingGroupId ( ) ) return - 1 ; else return + 1 ; } } ) ; field_5_fileIdClusters = ( FileIdCluster [ ] ) clusters . toArray ( new FileIdCluster [ clusters . size ( ) ] ) ; } } 	0	['17', '2', '0', '10', '48', '38', '3', '8', '17', '0.822916667', '419', '0.666666667', '1', '0.542857143', '0.274509804', '1', '5', '23.29411765', '3', '1.1765', '0']
package org . apache . poi . poifs . filesystem ; import java . io . File ; public class POIFSDocumentPath { private String [ ] components ; private int hashcode = 0 ; public POIFSDocumentPath ( final String [ ] components ) throws IllegalArgumentException { if ( components == null ) { this . components = new String [ 0 ] ; } else { this . components = new String [ components . length ] ; for ( int j = 0 ; j < components . length ; j ++ ) { if ( ( components [ j ] == null ) || ( components [ j ] . length ( ) == 0 ) ) { throw new IllegalArgumentException ( "components cannot contain null or empty strings" ) ; } this . components [ j ] = components [ j ] ; } } } public POIFSDocumentPath ( ) { this . components = new String [ 0 ] ; } public POIFSDocumentPath ( final POIFSDocumentPath path , final String [ ] components ) throws IllegalArgumentException { if ( components == null ) { this . components = new String [ path . components . length ] ; } else { this . components = new String [ path . components . length + components . length ] ; } for ( int j = 0 ; j < path . components . length ; j ++ ) { this . components [ j ] = path . components [ j ] ; } if ( components != null ) { for ( int j = 0 ; j < components . length ; j ++ ) { if ( ( components [ j ] == null ) || ( components [ j ] . length ( ) == 0 ) ) { throw new IllegalArgumentException ( "components cannot contain null or empty strings" ) ; } this . components [ j + path . components . length ] = components [ j ] ; } } } public boolean equals ( final Object o ) { boolean rval = false ; if ( ( o != null ) && ( o . getClass ( ) == this . getClass ( ) ) ) { if ( this == o ) { rval = true ; } else { POIFSDocumentPath path = ( POIFSDocumentPath ) o ; if ( path . components . length == this . components . length ) { rval = true ; for ( int j = 0 ; j < this . components . length ; j ++ ) { if ( ! path . components [ j ] . equals ( this . components [ j ] ) ) { rval = false ; break ; } } } } } return rval ; } public int hashCode ( ) { if ( hashcode == 0 ) { for ( int j = 0 ; j < components . length ; j ++ ) { hashcode += components [ j ] . hashCode ( ) ; } } return hashcode ; } public int length ( ) { return components . length ; } public String getComponent ( int n ) throws ArrayIndexOutOfBoundsException { return components [ n ] ; } public POIFSDocumentPath getParent ( ) { final int length = components . length - 1 ; if ( length < 0 ) { return null ; } POIFSDocumentPath parent = new POIFSDocumentPath ( null ) ; parent . components = new String [ length ] ; System . arraycopy ( components , 0 , parent . components , 0 , length ) ; return parent ; } public String toString ( ) { final StringBuffer b = new StringBuffer ( ) ; final int l = length ( ) ; b . append ( File . separatorChar ) ; for ( int i = 0 ; i < l ; i ++ ) { b . append ( getComponent ( i ) ) ; if ( i < l - 1 ) { b . append ( File . separatorChar ) ; } } return b . toString ( ) ; } } 	0	['9', '1', '0', '10', '20', '0', '10', '0', '9', '0.25', '294', '1', '0', '0', '0.311111111', '1', '1', '31.44444444', '7', '1.8889', '0']
package org . apache . poi . poifs . storage ; import org . apache . poi . poifs . filesystem . BATManaged ; import org . apache . poi . poifs . filesystem . POIFSDocument ; import org . apache . poi . poifs . property . RootProperty ; import java . util . * ; import java . io . * ; public class SmallBlockTableWriter implements BlockWritable , BATManaged { private BlockAllocationTableWriter _sbat ; private List _small_blocks ; private int _big_block_count ; private RootProperty _root ; public SmallBlockTableWriter ( final List documents , final RootProperty root ) { _sbat = new BlockAllocationTableWriter ( ) ; _small_blocks = new ArrayList ( ) ; _root = root ; Iterator iter = documents . iterator ( ) ; while ( iter . hasNext ( ) ) { POIFSDocument doc = ( POIFSDocument ) iter . next ( ) ; BlockWritable [ ] blocks = doc . getSmallBlocks ( ) ; if ( blocks . length != 0 ) { doc . setStartBlock ( _sbat . allocateSpace ( blocks . length ) ) ; for ( int j = 0 ; j < blocks . length ; j ++ ) { _small_blocks . add ( blocks [ j ] ) ; } } } _sbat . simpleCreateBlocks ( ) ; _root . setSize ( _small_blocks . size ( ) ) ; _big_block_count = SmallDocumentBlock . fill ( _small_blocks ) ; } public int getSBATBlockCount ( ) { return ( _big_block_count + 15 ) / 16 ; } public BlockAllocationTableWriter getSBAT ( ) { return _sbat ; } public int countBlocks ( ) { return _big_block_count ; } public void setStartBlock ( int start_block ) { _root . setStartBlock ( start_block ) ; } public void writeBlocks ( final OutputStream stream ) throws IOException { Iterator iter = _small_blocks . iterator ( ) ; while ( iter . hasNext ( ) ) { ( ( BlockWritable ) iter . next ( ) ) . writeBlocks ( stream ) ; } } } 	0	['6', '1', '0', '7', '22', '3', '1', '6', '6', '0.75', '111', '1', '2', '0', '0.333333333', '0', '0', '16.83333333', '1', '0.8333', '0']
package org . apache . poi . util ; import java . util . * ; public abstract class POILogger { public static final int DEBUG = 1 ; public static final int INFO = 3 ; public static final int WARN = 5 ; public static final int ERROR = 7 ; public static final int FATAL = 9 ; POILogger ( ) { } abstract public void initialize ( final String cat ) ; abstract public void log ( final int level , final Object obj1 ) ; abstract public boolean check ( final int level ) ; public void log ( final int level , final Object obj1 , final Object obj2 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 32 ) . append ( obj1 ) . append ( obj2 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 48 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 64 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 80 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 96 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 112 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 128 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) . append ( obj8 ) ) ; } } public void log ( final int level , final Object obj1 , final Throwable exception ) { log ( level , obj1 , exception ) ; } public void log ( final int level , final Object obj1 , final Object obj2 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 32 ) . append ( obj1 ) . append ( obj2 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 48 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 64 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 80 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 96 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 112 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) , exception ) ; } } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 , final Throwable exception ) { if ( check ( level ) ) { log ( level , new StringBuffer ( 128 ) . append ( obj1 ) . append ( obj2 ) . append ( obj3 ) . append ( obj4 ) . append ( obj5 ) . append ( obj6 ) . append ( obj7 ) . append ( obj8 ) , exception ) ; } } public void logFormatted ( final int level , final String message , final Object obj1 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 , obj3 } ) ; } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { commonLogFormatted ( level , message , new Object [ ] { obj1 , obj2 , obj3 , obj4 } ) ; } private void commonLogFormatted ( final int level , final String message , final Object [ ] unflatParams ) { if ( check ( level ) ) { Object [ ] params = flattenArrays ( unflatParams ) ; if ( params [ params . length - 1 ] instanceof Throwable ) { log ( level , StringUtil . format ( message , params ) , ( Throwable ) params [ params . length - 1 ] ) ; } else { log ( level , StringUtil . format ( message , params ) ) ; } } } private Object [ ] flattenArrays ( final Object [ ] objects ) { List results = new ArrayList ( ) ; for ( int i = 0 ; i < objects . length ; i ++ ) { results . addAll ( objectToObjectArray ( objects [ i ] ) ) ; } return ( Object [ ] ) results . toArray ( new Object [ results . size ( ) ] ) ; } private List objectToObjectArray ( Object object ) { List results = new ArrayList ( ) ; if ( object instanceof byte [ ] ) { byte [ ] array = ( byte [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Byte ( array [ j ] ) ) ; } } if ( object instanceof char [ ] ) { char [ ] array = ( char [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Character ( array [ j ] ) ) ; } } else if ( object instanceof short [ ] ) { short [ ] array = ( short [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Short ( array [ j ] ) ) ; } } else if ( object instanceof int [ ] ) { int [ ] array = ( int [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Integer ( array [ j ] ) ) ; } } else if ( object instanceof long [ ] ) { long [ ] array = ( long [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Long ( array [ j ] ) ) ; } } else if ( object instanceof float [ ] ) { float [ ] array = ( float [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Float ( array [ j ] ) ) ; } } else if ( object instanceof double [ ] ) { double [ ] array = ( double [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( new Double ( array [ j ] ) ) ; } } else if ( object instanceof Object [ ] ) { Object [ ] array = ( Object [ ] ) object ; for ( int j = 0 ; j < array . length ; j ++ ) { results . add ( array [ j ] ) ; } } else { results . add ( object ) ; } return results ; } } 	0	['26', '1', '3', '11', '42', '325', '10', '1', '22', '1.04', '693', '0', '0', '0', '0.544871795', '0', '0', '25.46153846', '10', '1.9615', '0']
package org . apache . poi . ddf ; public class EscherRGBProperty extends EscherSimpleProperty { public EscherRGBProperty ( short propertyNumber , int rgbColor ) { super ( propertyNumber , false , false , rgbColor ) ; } public int getRgbColor ( ) { return propertyValue ; } public byte getRed ( ) { return ( byte ) ( propertyValue & 0xFF ) ; } public byte getGreen ( ) { return ( byte ) ( ( propertyValue > > 8 ) & 0xFF ) ; } public byte getBlue ( ) { return ( byte ) ( ( propertyValue > > 16 ) & 0xFF ) ; } } 	0	['5', '3', '0', '4', '6', '0', '3', '1', '5', '2', '37', '0', '0', '0.777777778', '0.466666667', '0', '0', '6.4', '1', '0.8', '0']
package org . apache . poi . util ; import java . io . IOException ; import java . io . InputStream ; public class IOUtils { private IOUtils ( ) { } public static int readFully ( InputStream in , byte [ ] b ) throws IOException { return readFully ( in , b , 0 , b . length ) ; } public static int readFully ( InputStream in , byte [ ] b , int off , int len ) throws IOException { int total = 0 ; for ( ; ; ) { int got = in . read ( b , off + total , len - total ) ; if ( got < 0 ) { return ( total == 0 ) ? - 1 : total ; } else { total += got ; if ( total == len ) return total ; } } } } 	0	['3', '1', '0', '3', '5', '3', '3', '0', '2', '2', '43', '0', '0', '0', '0.5', '0', '0', '13.33333333', '1', '0.6667', '0']
package org . apache . poi . util ; import org . apache . poi . util . LittleEndian . BufferUnderrunException ; import java . io . * ; public class ShortField implements FixedField { private short _value ; private final int _offset ; public ShortField ( final int offset ) throws ArrayIndexOutOfBoundsException { if ( offset < 0 ) { throw new ArrayIndexOutOfBoundsException ( "Illegal offset: " + offset ) ; } _offset = offset ; } public ShortField ( final int offset , final short value ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; set ( value ) ; } public ShortField ( final int offset , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; readFromBytes ( data ) ; } public ShortField ( final int offset , final short value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; set ( value , data ) ; } public short get ( ) { return _value ; } public void set ( final short value ) { _value = value ; } public void set ( final short value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = value ; writeToBytes ( data ) ; } public void readFromBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = LittleEndian . getShort ( data , _offset ) ; } public void readFromStream ( final InputStream stream ) throws IOException , BufferUnderrunException { _value = LittleEndian . readShort ( stream ) ; } public void writeToBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { LittleEndian . putShort ( data , _offset , _value ) ; } public String toString ( ) { return String . valueOf ( _value ) ; } } 	0	['11', '1', '0', '5', '21', '9', '2', '3', '11', '0.25', '92', '1', '0', '0', '0.454545455', '0', '0', '7.181818182', '1', '0.6364', '0']
package org . apache . poi . poifs . common ; public interface POIFSConstants { public static final int BIG_BLOCK_SIZE = 0x0200 ; public static final int END_OF_CHAIN = - 2 ; public static final int PROPERTY_SIZE = 0x0080 ; public static final int UNUSED_BLOCK = - 1 ; } 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '4', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . poi . util ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . hssf . usermodel . HSSFSheet ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; public class DrawingDump { public static void main ( String [ ] args ) throws IOException { POIFSFileSystem fs = new POIFSFileSystem ( new FileInputStream ( args [ 0 ] ) ) ; HSSFWorkbook wb = new HSSFWorkbook ( fs ) ; HSSFSheet sheet = wb . getSheetAt ( 0 ) ; sheet . dumpDrawingRecords ( ) ; } } 	0	['2', '1', '0', '3', '8', '1', '0', '3', '2', '2', '27', '0', '0', '0', '0.5', '0', '0', '12.5', '1', '0.5', '0']
package org . apache . poi . poifs . storage ; import java . io . * ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . property . Property ; import org . apache . poi . util . IntegerField ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; public class PropertyBlock extends BigBlock { private static final int _properties_per_block = POIFSConstants . BIG_BLOCK_SIZE / POIFSConstants . PROPERTY_SIZE ; private Property [ ] _properties ; private PropertyBlock ( final Property [ ] properties , final int offset ) { _properties = new Property [ _properties_per_block ] ; for ( int j = 0 ; j < _properties_per_block ; j ++ ) { _properties [ j ] = properties [ j + offset ] ; } } public static BlockWritable [ ] createPropertyBlockArray ( final List properties ) { int block_count = ( properties . size ( ) + _properties_per_block - 1 ) / _properties_per_block ; Property [ ] to_be_written = new Property [ block_count * _properties_per_block ] ; System . arraycopy ( properties . toArray ( new Property [ 0 ] ) , 0 , to_be_written , 0 , properties . size ( ) ) ; for ( int j = properties . size ( ) ; j < to_be_written . length ; j ++ ) { to_be_written [ j ] = new Property ( ) { protected void preWrite ( ) { } public boolean isDirectory ( ) { return false ; } } ; } BlockWritable [ ] rvalue = new BlockWritable [ block_count ] ; for ( int j = 0 ; j < block_count ; j ++ ) { rvalue [ j ] = new PropertyBlock ( to_be_written , j * _properties_per_block ) ; } return rvalue ; } void writeData ( final OutputStream stream ) throws IOException { for ( int j = 0 ; j < _properties_per_block ; j ++ ) { _properties [ j ] . writeData ( stream ) ; } } } 	0	['4', '2', '0', '5', '11', '4', '1', '4', '2', '0.833333333', '108', '1', '1', '0.5', '0.4', '1', '1', '25.5', '3', '1.25', '0']
package org . apache . poi . hssf . eventusermodel ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . eventusermodel . HSSFUserException ; public abstract class AbortableHSSFListener implements HSSFListener { public void processRecord ( Record record ) { } public abstract short abortableProcessRecord ( Record record ) throws HSSFUserException ; } 	0	['3', '1', '0', '4', '4', '3', '1', '3', '3', '2', '7', '0', '0', '0', '0.833333333', '0', '0', '1.333333333', '1', '0.6667', '0']
package org . apache . poi . hssf . model ; import org . apache . poi . ddf . * ; import org . apache . poi . hssf . record . ObjRecord ; import org . apache . poi . hssf . record . EscherAggregate ; import org . apache . poi . hssf . record . CommonObjectDataSubRecord ; import org . apache . poi . hssf . record . EndSubRecord ; import org . apache . poi . hssf . usermodel . HSSFSimpleShape ; import org . apache . poi . hssf . usermodel . HSSFShape ; public class SimpleFilledShape extends AbstractShape { private EscherContainerRecord spContainer ; private ObjRecord objRecord ; SimpleFilledShape ( HSSFSimpleShape hssfShape , int shapeId ) { spContainer = createSpContainer ( hssfShape , shapeId ) ; objRecord = createObjRecord ( hssfShape , shapeId ) ; } private EscherContainerRecord createSpContainer ( HSSFSimpleShape hssfShape , int shapeId ) { HSSFShape shape = hssfShape ; EscherContainerRecord spContainer = new EscherContainerRecord ( ) ; EscherSpRecord sp = new EscherSpRecord ( ) ; EscherOptRecord opt = new EscherOptRecord ( ) ; EscherClientDataRecord clientData = new EscherClientDataRecord ( ) ; spContainer . setRecordId ( EscherContainerRecord . SP_CONTAINER ) ; spContainer . setOptions ( ( short ) 0x000F ) ; sp . setRecordId ( EscherSpRecord . RECORD_ID ) ; short shapeType = objTypeToShapeType ( hssfShape . getShapeType ( ) ) ; sp . setOptions ( ( short ) ( ( shapeType << 4 ) | 0x2 ) ) ; sp . setShapeId ( shapeId ) ; sp . setFlags ( EscherSpRecord . FLAG_HAVEANCHOR | EscherSpRecord . FLAG_HASSHAPETYPE ) ; opt . setRecordId ( EscherOptRecord . RECORD_ID ) ; addStandardOptions ( shape , opt ) ; EscherRecord anchor = createAnchor ( shape . getAnchor ( ) ) ; clientData . setRecordId ( EscherClientDataRecord . RECORD_ID ) ; clientData . setOptions ( ( short ) 0x0000 ) ; spContainer . addChildRecord ( sp ) ; spContainer . addChildRecord ( opt ) ; spContainer . addChildRecord ( anchor ) ; spContainer . addChildRecord ( clientData ) ; return spContainer ; } private short objTypeToShapeType ( int objType ) { short shapeType ; if ( objType == HSSFSimpleShape . OBJECT_TYPE_OVAL ) shapeType = EscherAggregate . ST_ELLIPSE ; else if ( objType == HSSFSimpleShape . OBJECT_TYPE_RECTANGLE ) shapeType = EscherAggregate . ST_RECTANGLE ; else throw new IllegalArgumentException ( "Unable to handle an object of this type" ) ; return shapeType ; } private ObjRecord createObjRecord ( HSSFShape hssfShape , int shapeId ) { HSSFShape shape = hssfShape ; ObjRecord obj = new ObjRecord ( ) ; CommonObjectDataSubRecord c = new CommonObjectDataSubRecord ( ) ; c . setObjectType ( ( short ) ( ( HSSFSimpleShape ) shape ) . getShapeType ( ) ) ; c . setObjectId ( ( short ) ( shapeId ) ) ; c . setLocked ( true ) ; c . setPrintable ( true ) ; c . setAutofill ( true ) ; c . setAutoline ( true ) ; EndSubRecord e = new EndSubRecord ( ) ; obj . addSubRecord ( c ) ; obj . addSubRecord ( e ) ; return obj ; } public EscherContainerRecord getSpContainer ( ) { return spContainer ; } public ObjRecord getObjRecord ( ) { return objRecord ; } } 	0	['6', '2', '0', '12', '36', '11', '1', '12', '2', '0.8', '173', '1', '2', '0.5', '0.541666667', '1', '1', '27.5', '3', '1.1667', '0']
package org . apache . poi . util ; import java . util . * ; public class POILogFactory { private static Map _loggers = new HashMap ( ) ; ; private POILogFactory ( ) { } public static POILogger getLogger ( final Class theclass ) { return getLogger ( theclass . getName ( ) ) ; } public static POILogger getLogger ( final String cat ) { POILogger logger = null ; if ( _loggers . containsKey ( cat ) ) { logger = ( POILogger ) _loggers . get ( cat ) ; } else { try { String loggerClassName = System . getProperty ( "org.apache.poi.util.POILogger" ) ; Class loggerClass = Class . forName ( loggerClassName ) ; logger = ( POILogger ) loggerClass . newInstance ( ) ; } catch ( Exception e ) { logger = new NullLogger ( ) ; } logger . initialize ( cat ) ; _loggers . put ( cat , logger ) ; } return logger ; } } 	0	['4', '1', '0', '8', '15', '4', '6', '2', '2', '0.333333333', '55', '1', '0', '0', '0.333333333', '0', '0', '12.5', '2', '0.75', '0']
package org . apache . poi . ddf ; import org . apache . poi . util . HexDump ; import org . apache . poi . util . HexRead ; import org . apache . poi . util . LittleEndian ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintStream ; import java . util . zip . InflaterInputStream ; public class EscherDump { public EscherDump ( ) { } public void dump ( byte [ ] data , int offset , int size , PrintStream out ) throws IOException , LittleEndian . BufferUnderrunException { EscherRecordFactory recordFactory = new DefaultEscherRecordFactory ( ) ; int pos = offset ; while ( pos < offset + size ) { EscherRecord r = recordFactory . createRecord ( data , pos ) ; int bytesRead = r . fillFields ( data , pos , recordFactory ) ; System . out . println ( r . toString ( ) ) ; pos += bytesRead ; } } public void dumpOld ( long maxLength , InputStream in , PrintStream out ) throws IOException , LittleEndian . BufferUnderrunException { long remainingBytes = maxLength ; short options ; short recordId ; int recordBytesRemaining ; StringBuffer stringBuf = new StringBuffer ( ) ; short nDumpSize ; String recordName ; boolean atEOF = false ; while ( ! atEOF && ( remainingBytes > 0 ) ) { stringBuf = new StringBuffer ( ) ; options = LittleEndian . readShort ( in ) ; recordId = LittleEndian . readShort ( in ) ; recordBytesRemaining = LittleEndian . readInt ( in ) ; remainingBytes -= 2 + 2 + 4 ; switch ( recordId ) { case ( short ) 0xF000 : recordName = "MsofbtDggContainer" ; break ; case ( short ) 0xF006 : recordName = "MsofbtDgg" ; break ; case ( short ) 0xF016 : recordName = "MsofbtCLSID" ; break ; case ( short ) 0xF00B : recordName = "MsofbtOPT" ; break ; case ( short ) 0xF11A : recordName = "MsofbtColorMRU" ; break ; case ( short ) 0xF11E : recordName = "MsofbtSplitMenuColors" ; break ; case ( short ) 0xF001 : recordName = "MsofbtBstoreContainer" ; break ; case ( short ) 0xF007 : recordName = "MsofbtBSE" ; break ; case ( short ) 0xF002 : recordName = "MsofbtDgContainer" ; break ; case ( short ) 0xF008 : recordName = "MsofbtDg" ; break ; case ( short ) 0xF118 : recordName = "MsofbtRegroupItem" ; break ; case ( short ) 0xF120 : recordName = "MsofbtColorScheme" ; break ; case ( short ) 0xF003 : recordName = "MsofbtSpgrContainer" ; break ; case ( short ) 0xF004 : recordName = "MsofbtSpContainer" ; break ; case ( short ) 0xF009 : recordName = "MsofbtSpgr" ; break ; case ( short ) 0xF00A : recordName = "MsofbtSp" ; break ; case ( short ) 0xF00C : recordName = "MsofbtTextbox" ; break ; case ( short ) 0xF00D : recordName = "MsofbtClientTextbox" ; break ; case ( short ) 0xF00E : recordName = "MsofbtAnchor" ; break ; case ( short ) 0xF00F : recordName = "MsofbtChildAnchor" ; break ; case ( short ) 0xF010 : recordName = "MsofbtClientAnchor" ; break ; case ( short ) 0xF011 : recordName = "MsofbtClientData" ; break ; case ( short ) 0xF11F : recordName = "MsofbtOleObject" ; break ; case ( short ) 0xF11D : recordName = "MsofbtDeletedPspl" ; break ; case ( short ) 0xF005 : recordName = "MsofbtSolverContainer" ; break ; case ( short ) 0xF012 : recordName = "MsofbtConnectorRule" ; break ; case ( short ) 0xF013 : recordName = "MsofbtAlignRule" ; break ; case ( short ) 0xF014 : recordName = "MsofbtArcRule" ; break ; case ( short ) 0xF015 : recordName = "MsofbtClientRule" ; break ; case ( short ) 0xF017 : recordName = "MsofbtCalloutRule" ; break ; case ( short ) 0xF119 : recordName = "MsofbtSelection" ; break ; case ( short ) 0xF122 : recordName = "MsofbtUDefProp" ; break ; default : if ( recordId >= ( short ) 0xF018 && recordId <= ( short ) 0xF117 ) recordName = "MsofbtBLIP" ; else if ( ( options & ( short ) 0x000F ) == ( short ) 0x000F ) recordName = "UNKNOWN container" ; else recordName = "UNKNOWN ID" ; } stringBuf . append ( "  " ) ; stringBuf . append ( HexDump . toHex ( recordId ) ) ; stringBuf . append ( "  " ) . append ( recordName ) . append ( " [" ) ; stringBuf . append ( HexDump . toHex ( options ) ) ; stringBuf . append ( ',' ) ; stringBuf . append ( HexDump . toHex ( recordBytesRemaining ) ) ; stringBuf . append ( "]  instance: " ) ; stringBuf . append ( HexDump . toHex ( ( ( short ) ( options > > 4 ) ) ) ) ; out . println ( stringBuf . toString ( ) ) ; if ( recordId == ( short ) 0xF007 && 36 <= remainingBytes && 36 <= recordBytesRemaining ) { byte n8 ; stringBuf = new StringBuffer ( "    btWin32: " ) ; n8 = ( byte ) in . read ( ) ; stringBuf . append ( HexDump . toHex ( n8 ) ) ; stringBuf . append ( getBlipType ( n8 ) ) ; stringBuf . append ( "  btMacOS: " ) ; n8 = ( byte ) in . read ( ) ; stringBuf . append ( HexDump . toHex ( n8 ) ) ; stringBuf . append ( getBlipType ( n8 ) ) ; out . println ( stringBuf . toString ( ) ) ; out . println ( "    rgbUid:" ) ; HexDump . dump ( in , out , 0 , 16 ) ; out . print ( "    tag: " ) ; outHex ( 2 , in , out ) ; out . println ( ) ; out . print ( "    size: " ) ; outHex ( 4 , in , out ) ; out . println ( ) ; out . print ( "    cRef: " ) ; outHex ( 4 , in , out ) ; out . println ( ) ; out . print ( "    offs: " ) ; outHex ( 4 , in , out ) ; out . println ( ) ; out . print ( "    usage: " ) ; outHex ( 1 , in , out ) ; out . println ( ) ; out . print ( "    cbName: " ) ; outHex ( 1 , in , out ) ; out . println ( ) ; out . print ( "    unused2: " ) ; outHex ( 1 , in , out ) ; out . println ( ) ; out . print ( "    unused3: " ) ; outHex ( 1 , in , out ) ; out . println ( ) ; remainingBytes -= 36 ; recordBytesRemaining = 0 ; } else if ( recordId == ( short ) 0xF010 && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining ) { out . print ( "    Flag: " ) ; outHex ( 2 , in , out ) ; out . println ( ) ; out . print ( "    Col1: " ) ; outHex ( 2 , in , out ) ; out . print ( "    dX1: " ) ; outHex ( 2 , in , out ) ; out . print ( "    Row1: " ) ; outHex ( 2 , in , out ) ; out . print ( "    dY1: " ) ; outHex ( 2 , in , out ) ; out . println ( ) ; out . print ( "    Col2: " ) ; outHex ( 2 , in , out ) ; out . print ( "    dX2: " ) ; outHex ( 2 , in , out ) ; out . print ( "    Row2: " ) ; outHex ( 2 , in , out ) ; out . print ( "    dY2: " ) ; outHex ( 2 , in , out ) ; out . println ( ) ; remainingBytes -= 18 ; recordBytesRemaining -= 18 ; } else if ( recordId == ( short ) 0xF00B || recordId == ( short ) 0xF122 ) { int nComplex = 0 ; out . println ( "    PROPID        VALUE" ) ; while ( recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex ) { short n16 ; int n32 ; n16 = LittleEndian . readShort ( in ) ; n32 = LittleEndian . readInt ( in ) ; recordBytesRemaining -= 6 ; remainingBytes -= 6 ; out . print ( "    " ) ; out . print ( HexDump . toHex ( n16 ) ) ; out . print ( " (" ) ; int propertyId = n16 & ( short ) 0x3FFF ; out . print ( " " + propertyId ) ; if ( ( n16 & ( short ) 0x8000 ) == 0 ) { if ( ( n16 & ( short ) 0x4000 ) != 0 ) out . print ( ", fBlipID" ) ; out . print ( ")  " ) ; out . print ( HexDump . toHex ( n32 ) ) ; if ( ( n16 & ( short ) 0x4000 ) == 0 ) { out . print ( " (" ) ; out . print ( dec1616 ( n32 ) ) ; out . print ( ')' ) ; out . print ( " {" + propName ( ( short ) propertyId ) + "}" ) ; } out . println ( ) ; } else { out . print ( ", fComplex)  " ) ; out . print ( HexDump . toHex ( n32 ) ) ; out . print ( " - Complex prop len" ) ; out . println ( " {" + propName ( ( short ) propertyId ) + "}" ) ; nComplex += n32 ; } } while ( ( nComplex & remainingBytes ) > 0 ) { nDumpSize = ( nComplex > ( int ) remainingBytes ) ? ( short ) remainingBytes : ( short ) nComplex ; HexDump . dump ( in , out , 0 , nDumpSize ) ; nComplex -= nDumpSize ; recordBytesRemaining -= nDumpSize ; remainingBytes -= nDumpSize ; } } else if ( recordId == ( short ) 0xF012 ) { out . print ( "    Connector rule: " ) ; out . print ( LittleEndian . readInt ( in ) ) ; out . print ( "    ShapeID A: " ) ; out . print ( LittleEndian . readInt ( in ) ) ; out . print ( "   ShapeID B: " ) ; out . print ( LittleEndian . readInt ( in ) ) ; out . print ( "    ShapeID connector: " ) ; out . print ( LittleEndian . readInt ( in ) ) ; out . print ( "   Connect pt A: " ) ; out . print ( LittleEndian . readInt ( in ) ) ; out . print ( "   Connect pt B: " ) ; out . println ( LittleEndian . readInt ( in ) ) ; recordBytesRemaining -= 24 ; remainingBytes -= 24 ; } else if ( recordId >= ( short ) 0xF018 && recordId < ( short ) 0xF117 ) { out . println ( "    Secondary UID: " ) ; HexDump . dump ( in , out , 0 , 16 ) ; out . println ( "    Cache of size: " + HexDump . toHex ( LittleEndian . readInt ( in ) ) ) ; out . println ( "    Boundary top: " + HexDump . toHex ( LittleEndian . readInt ( in ) ) ) ; out . println ( "    Boundary left: " + HexDump . toHex ( LittleEndian . readInt ( in ) ) ) ; out . println ( "    Boundary width: " + HexDump . toHex ( LittleEndian . readInt ( in ) ) ) ; out . println ( "    Boundary height: " + HexDump . toHex ( LittleEndian . readInt ( in ) ) ) ; out . println ( "    X: " + HexDump . toHex ( LittleEndian . readInt ( in ) ) ) ; out . println ( "    Y: " + HexDump . toHex ( LittleEndian . readInt ( in ) ) ) ; out . println ( "    Cache of saved size: " + HexDump . toHex ( LittleEndian . readInt ( in ) ) ) ; out . println ( "    Compression Flag: " + HexDump . toHex ( ( byte ) in . read ( ) ) ) ; out . println ( "    Filter: " + HexDump . toHex ( ( byte ) in . read ( ) ) ) ; out . println ( "    Data (after decompression): " ) ; recordBytesRemaining -= 34 + 16 ; remainingBytes -= 34 + 16 ; nDumpSize = ( recordBytesRemaining > ( int ) remainingBytes ) ? ( short ) remainingBytes : ( short ) recordBytesRemaining ; byte [ ] buf = new byte [ nDumpSize ] ; int read = in . read ( buf ) ; while ( read != - 1 && read < nDumpSize ) read += in . read ( buf , read , buf . length ) ; ByteArrayInputStream bin = new ByteArrayInputStream ( buf ) ; InputStream in1 = new InflaterInputStream ( bin ) ; int bytesToDump = - 1 ; HexDump . dump ( in1 , out , 0 , bytesToDump ) ; recordBytesRemaining -= nDumpSize ; remainingBytes -= nDumpSize ; } boolean isContainer = ( options & ( short ) 0x000F ) == ( short ) 0x000F ; if ( isContainer && remainingBytes >= 0 ) { if ( recordBytesRemaining <= ( int ) remainingBytes ) out . println ( "            completed within" ) ; else out . println ( "            continued elsewhere" ) ; } else if ( remainingBytes >= 0 ) { nDumpSize = ( recordBytesRemaining > ( int ) remainingBytes ) ? ( short ) remainingBytes : ( short ) recordBytesRemaining ; if ( nDumpSize != 0 ) { HexDump . dump ( in , out , 0 , nDumpSize ) ; remainingBytes -= nDumpSize ; } } else out . println ( " >> OVERRUN <<" ) ; } } private String propName ( short propertyId ) { class PropName { public PropName ( int id , String name ) { this . id = id ; this . name = name ; } int id ; String name ; } final PropName [ ] props = new PropName [ ] { new PropName ( 4 , "transform.rotation" ) , new PropName ( 119 , "protection.lockrotation" ) , new PropName ( 120 , "protection.lockaspectratio" ) , new PropName ( 121 , "protection.lockposition" ) , new PropName ( 122 , "protection.lockagainstselect" ) , new PropName ( 123 , "protection.lockcropping" ) , new PropName ( 124 , "protection.lockvertices" ) , new PropName ( 125 , "protection.locktext" ) , new PropName ( 126 , "protection.lockadjusthandles" ) , new PropName ( 127 , "protection.lockagainstgrouping" ) , new PropName ( 128 , "text.textid" ) , new PropName ( 129 , "text.textleft" ) , new PropName ( 130 , "text.texttop" ) , new PropName ( 131 , "text.textright" ) , new PropName ( 132 , "text.textbottom" ) , new PropName ( 133 , "text.wraptext" ) , new PropName ( 134 , "text.scaletext" ) , new PropName ( 135 , "text.anchortext" ) , new PropName ( 136 , "text.textflow" ) , new PropName ( 137 , "text.fontrotation" ) , new PropName ( 138 , "text.idofnextshape" ) , new PropName ( 139 , "text.bidir" ) , new PropName ( 187 , "text.singleclickselects" ) , new PropName ( 188 , "text.usehostmargins" ) , new PropName ( 189 , "text.rotatetextwithshape" ) , new PropName ( 190 , "text.sizeshapetofittext" ) , new PropName ( 191 , "text.sizetexttofitshape" ) , new PropName ( 192 , "geotext.unicode" ) , new PropName ( 193 , "geotext.rtftext" ) , new PropName ( 194 , "geotext.alignmentoncurve" ) , new PropName ( 195 , "geotext.defaultpointsize" ) , new PropName ( 196 , "geotext.textspacing" ) , new PropName ( 197 , "geotext.fontfamilyname" ) , new PropName ( 240 , "geotext.reverseroworder" ) , new PropName ( 241 , "geotext.hastexteffect" ) , new PropName ( 242 , "geotext.rotatecharacters" ) , new PropName ( 243 , "geotext.kerncharacters" ) , new PropName ( 244 , "geotext.tightortrack" ) , new PropName ( 245 , "geotext.stretchtofitshape" ) , new PropName ( 246 , "geotext.charboundingbox" ) , new PropName ( 247 , "geotext.scaletextonpath" ) , new PropName ( 248 , "geotext.stretchcharheight" ) , new PropName ( 249 , "geotext.nomeasurealongpath" ) , new PropName ( 250 , "geotext.boldfont" ) , new PropName ( 251 , "geotext.italicfont" ) , new PropName ( 252 , "geotext.underlinefont" ) , new PropName ( 253 , "geotext.shadowfont" ) , new PropName ( 254 , "geotext.smallcapsfont" ) , new PropName ( 255 , "geotext.strikethroughfont" ) , new PropName ( 256 , "blip.cropfromtop" ) , new PropName ( 257 , "blip.cropfrombottom" ) , new PropName ( 258 , "blip.cropfromleft" ) , new PropName ( 259 , "blip.cropfromright" ) , new PropName ( 260 , "blip.bliptodisplay" ) , new PropName ( 261 , "blip.blipfilename" ) , new PropName ( 262 , "blip.blipflags" ) , new PropName ( 263 , "blip.transparentcolor" ) , new PropName ( 264 , "blip.contrastsetting" ) , new PropName ( 265 , "blip.brightnesssetting" ) , new PropName ( 266 , "blip.gamma" ) , new PropName ( 267 , "blip.pictureid" ) , new PropName ( 268 , "blip.doublemod" ) , new PropName ( 269 , "blip.picturefillmod" ) , new PropName ( 270 , "blip.pictureline" ) , new PropName ( 271 , "blip.printblip" ) , new PropName ( 272 , "blip.printblipfilename" ) , new PropName ( 273 , "blip.printflags" ) , new PropName ( 316 , "blip.nohittestpicture" ) , new PropName ( 317 , "blip.picturegray" ) , new PropName ( 318 , "blip.picturebilevel" ) , new PropName ( 319 , "blip.pictureactive" ) , new PropName ( 320 , "geometry.left" ) , new PropName ( 321 , "geometry.top" ) , new PropName ( 322 , "geometry.right" ) , new PropName ( 323 , "geometry.bottom" ) , new PropName ( 324 , "geometry.shapepath" ) , new PropName ( 325 , "geometry.vertices" ) , new PropName ( 326 , "geometry.segmentinfo" ) , new PropName ( 327 , "geometry.adjustvalue" ) , new PropName ( 328 , "geometry.adjust2value" ) , new PropName ( 329 , "geometry.adjust3value" ) , new PropName ( 330 , "geometry.adjust4value" ) , new PropName ( 331 , "geometry.adjust5value" ) , new PropName ( 332 , "geometry.adjust6value" ) , new PropName ( 333 , "geometry.adjust7value" ) , new PropName ( 334 , "geometry.adjust8value" ) , new PropName ( 335 , "geometry.adjust9value" ) , new PropName ( 336 , "geometry.adjust10value" ) , new PropName ( 378 , "geometry.shadowOK" ) , new PropName ( 379 , "geometry.3dok" ) , new PropName ( 380 , "geometry.lineok" ) , new PropName ( 381 , "geometry.geotextok" ) , new PropName ( 382 , "geometry.fillshadeshapeok" ) , new PropName ( 383 , "geometry.fillok" ) , new PropName ( 384 , "fill.filltype" ) , new PropName ( 385 , "fill.fillcolor" ) , new PropName ( 386 , "fill.fillopacity" ) , new PropName ( 387 , "fill.fillbackcolor" ) , new PropName ( 388 , "fill.backopacity" ) , new PropName ( 389 , "fill.crmod" ) , new PropName ( 390 , "fill.patterntexture" ) , new PropName ( 391 , "fill.blipfilename" ) , new PropName ( 392 , "fill.blipflags" ) , new PropName ( 393 , "fill.width" ) , new PropName ( 394 , "fill.height" ) , new PropName ( 395 , "fill.angle" ) , new PropName ( 396 , "fill.focus" ) , new PropName ( 397 , "fill.toleft" ) , new PropName ( 398 , "fill.totop" ) , new PropName ( 399 , "fill.toright" ) , new PropName ( 400 , "fill.tobottom" ) , new PropName ( 401 , "fill.rectleft" ) , new PropName ( 402 , "fill.recttop" ) , new PropName ( 403 , "fill.rectright" ) , new PropName ( 404 , "fill.rectbottom" ) , new PropName ( 405 , "fill.dztype" ) , new PropName ( 406 , "fill.shadepreset" ) , new PropName ( 407 , "fill.shadecolors" ) , new PropName ( 408 , "fill.originx" ) , new PropName ( 409 , "fill.originy" ) , new PropName ( 410 , "fill.shapeoriginx" ) , new PropName ( 411 , "fill.shapeoriginy" ) , new PropName ( 412 , "fill.shadetype" ) , new PropName ( 443 , "fill.filled" ) , new PropName ( 444 , "fill.hittestfill" ) , new PropName ( 445 , "fill.shape" ) , new PropName ( 446 , "fill.userect" ) , new PropName ( 447 , "fill.nofillhittest" ) , new PropName ( 448 , "linestyle.color" ) , new PropName ( 449 , "linestyle.opacity" ) , new PropName ( 450 , "linestyle.backcolor" ) , new PropName ( 451 , "linestyle.crmod" ) , new PropName ( 452 , "linestyle.linetype" ) , new PropName ( 453 , "linestyle.fillblip" ) , new PropName ( 454 , "linestyle.fillblipname" ) , new PropName ( 455 , "linestyle.fillblipflags" ) , new PropName ( 456 , "linestyle.fillwidth" ) , new PropName ( 457 , "linestyle.fillheight" ) , new PropName ( 458 , "linestyle.filldztype" ) , new PropName ( 459 , "linestyle.linewidth" ) , new PropName ( 460 , "linestyle.linemiterlimit" ) , new PropName ( 461 , "linestyle.linestyle" ) , new PropName ( 462 , "linestyle.linedashing" ) , new PropName ( 463 , "linestyle.linedashstyle" ) , new PropName ( 464 , "linestyle.linestartarrowhead" ) , new PropName ( 465 , "linestyle.lineendarrowhead" ) , new PropName ( 466 , "linestyle.linestartarrowwidth" ) , new PropName ( 467 , "linestyle.lineestartarrowlength" ) , new PropName ( 468 , "linestyle.lineendarrowwidth" ) , new PropName ( 469 , "linestyle.lineendarrowlength" ) , new PropName ( 470 , "linestyle.linejoinstyle" ) , new PropName ( 471 , "linestyle.lineendcapstyle" ) , new PropName ( 507 , "linestyle.arrowheadsok" ) , new PropName ( 508 , "linestyle.anyline" ) , new PropName ( 509 , "linestyle.hitlinetest" ) , new PropName ( 510 , "linestyle.linefillshape" ) , new PropName ( 511 , "linestyle.nolinedrawdash" ) , new PropName ( 512 , "shadowstyle.type" ) , new PropName ( 513 , "shadowstyle.color" ) , new PropName ( 514 , "shadowstyle.highlight" ) , new PropName ( 515 , "shadowstyle.crmod" ) , new PropName ( 516 , "shadowstyle.opacity" ) , new PropName ( 517 , "shadowstyle.offsetx" ) , new PropName ( 518 , "shadowstyle.offsety" ) , new PropName ( 519 , "shadowstyle.secondoffsetx" ) , new PropName ( 520 , "shadowstyle.secondoffsety" ) , new PropName ( 521 , "shadowstyle.scalextox" ) , new PropName ( 522 , "shadowstyle.scaleytox" ) , new PropName ( 523 , "shadowstyle.scalextoy" ) , new PropName ( 524 , "shadowstyle.scaleytoy" ) , new PropName ( 525 , "shadowstyle.perspectivex" ) , new PropName ( 526 , "shadowstyle.perspectivey" ) , new PropName ( 527 , "shadowstyle.weight" ) , new PropName ( 528 , "shadowstyle.originx" ) , new PropName ( 529 , "shadowstyle.originy" ) , new PropName ( 574 , "shadowstyle.shadow" ) , new PropName ( 575 , "shadowstyle.shadowobsured" ) , new PropName ( 576 , "perspective.type" ) , new PropName ( 577 , "perspective.offsetx" ) , new PropName ( 578 , "perspective.offsety" ) , new PropName ( 579 , "perspective.scalextox" ) , new PropName ( 580 , "perspective.scaleytox" ) , new PropName ( 581 , "perspective.scalextoy" ) , new PropName ( 582 , "perspective.scaleytox" ) , new PropName ( 583 , "perspective.perspectivex" ) , new PropName ( 584 , "perspective.perspectivey" ) , new PropName ( 585 , "perspective.weight" ) , new PropName ( 586 , "perspective.originx" ) , new PropName ( 587 , "perspective.originy" ) , new PropName ( 639 , "perspective.perspectiveon" ) , new PropName ( 640 , "3d.specularamount" ) , new PropName ( 661 , "3d.diffuseamount" ) , new PropName ( 662 , "3d.shininess" ) , new PropName ( 663 , "3d.edgethickness" ) , new PropName ( 664 , "3d.extrudeforward" ) , new PropName ( 665 , "3d.extrudebackward" ) , new PropName ( 666 , "3d.extrudeplane" ) , new PropName ( 667 , "3d.extrusioncolor" ) , new PropName ( 648 , "3d.crmod" ) , new PropName ( 700 , "3d.3deffect" ) , new PropName ( 701 , "3d.metallic" ) , new PropName ( 702 , "3d.useextrusioncolor" ) , new PropName ( 703 , "3d.lightface" ) , new PropName ( 704 , "3dstyle.yrotationangle" ) , new PropName ( 705 , "3dstyle.xrotationangle" ) , new PropName ( 706 , "3dstyle.rotationaxisx" ) , new PropName ( 707 , "3dstyle.rotationaxisy" ) , new PropName ( 708 , "3dstyle.rotationaxisz" ) , new PropName ( 709 , "3dstyle.rotationangle" ) , new PropName ( 710 , "3dstyle.rotationcenterx" ) , new PropName ( 711 , "3dstyle.rotationcentery" ) , new PropName ( 712 , "3dstyle.rotationcenterz" ) , new PropName ( 713 , "3dstyle.rendermode" ) , new PropName ( 714 , "3dstyle.tolerance" ) , new PropName ( 715 , "3dstyle.xviewpoint" ) , new PropName ( 716 , "3dstyle.yviewpoint" ) , new PropName ( 717 , "3dstyle.zviewpoint" ) , new PropName ( 718 , "3dstyle.originx" ) , new PropName ( 719 , "3dstyle.originy" ) , new PropName ( 720 , "3dstyle.skewangle" ) , new PropName ( 721 , "3dstyle.skewamount" ) , new PropName ( 722 , "3dstyle.ambientintensity" ) , new PropName ( 723 , "3dstyle.keyx" ) , new PropName ( 724 , "3dstyle.keyy" ) , new PropName ( 725 , "3dstyle.keyz" ) , new PropName ( 726 , "3dstyle.keyintensity" ) , new PropName ( 727 , "3dstyle.fillx" ) , new PropName ( 728 , "3dstyle.filly" ) , new PropName ( 729 , "3dstyle.fillz" ) , new PropName ( 730 , "3dstyle.fillintensity" ) , new PropName ( 763 , "3dstyle.constrainrotation" ) , new PropName ( 764 , "3dstyle.rotationcenterauto" ) , new PropName ( 765 , "3dstyle.parallel" ) , new PropName ( 766 , "3dstyle.keyharsh" ) , new PropName ( 767 , "3dstyle.fillharsh" ) , new PropName ( 769 , "shape.master" ) , new PropName ( 771 , "shape.connectorstyle" ) , new PropName ( 772 , "shape.blackandwhitesettings" ) , new PropName ( 773 , "shape.wmodepurebw" ) , new PropName ( 774 , "shape.wmodebw" ) , new PropName ( 826 , "shape.oleicon" ) , new PropName ( 827 , "shape.preferrelativeresize" ) , new PropName ( 828 , "shape.lockshapetype" ) , new PropName ( 830 , "shape.deleteattachedobject" ) , new PropName ( 831 , "shape.backgroundshape" ) , new PropName ( 832 , "callout.callouttype" ) , new PropName ( 833 , "callout.xycalloutgap" ) , new PropName ( 834 , "callout.calloutangle" ) , new PropName ( 835 , "callout.calloutdroptype" ) , new PropName ( 836 , "callout.calloutdropspecified" ) , new PropName ( 837 , "callout.calloutlengthspecified" ) , new PropName ( 889 , "callout.iscallout" ) , new PropName ( 890 , "callout.calloutaccentbar" ) , new PropName ( 891 , "callout.callouttextborder" ) , new PropName ( 892 , "callout.calloutminusx" ) , new PropName ( 893 , "callout.calloutminusy" ) , new PropName ( 894 , "callout.dropauto" ) , new PropName ( 895 , "callout.lengthspecified" ) , new PropName ( 896 , "groupshape.shapename" ) , new PropName ( 897 , "groupshape.description" ) , new PropName ( 898 , "groupshape.hyperlink" ) , new PropName ( 899 , "groupshape.wrappolygonvertices" ) , new PropName ( 900 , "groupshape.wrapdistleft" ) , new PropName ( 901 , "groupshape.wrapdisttop" ) , new PropName ( 902 , "groupshape.wrapdistright" ) , new PropName ( 903 , "groupshape.wrapdistbottom" ) , new PropName ( 904 , "groupshape.regroupid" ) , new PropName ( 953 , "groupshape.editedwrap" ) , new PropName ( 954 , "groupshape.behinddocument" ) , new PropName ( 955 , "groupshape.ondblclicknotify" ) , new PropName ( 956 , "groupshape.isbutton" ) , new PropName ( 957 , "groupshape.1dadjustment" ) , new PropName ( 958 , "groupshape.hidden" ) , new PropName ( 959 , "groupshape.print" ) , } ; for ( int i = 0 ; i < props . length ; i ++ ) { if ( props [ i ] . id == propertyId ) { return props [ i ] . name ; } } return "unknown property" ; } private String getBlipType ( byte b ) { switch ( b ) { case 0 : return " ERROR" ; case 1 : return " UNKNOWN" ; case 2 : return " EMF" ; case 3 : return " WMF" ; case 4 : return " PICT" ; case 5 : return " JPEG" ; case 6 : return " PNG" ; case 7 : return " DIB" ; default : if ( b < 32 ) return " NotKnown" ; else return " Client" ; } } private String dec1616 ( int n32 ) { String result = "" ; result += ( short ) ( n32 > > 16 ) ; result += '.' ; result += ( short ) ( n32 & ( short ) 0xFFFF ) ; return result ; } private void outHex ( int bytes , InputStream in , PrintStream out ) throws IOException , LittleEndian . BufferUnderrunException { switch ( bytes ) { case 1 : out . print ( HexDump . toHex ( ( byte ) in . read ( ) ) ) ; break ; case 2 : out . print ( HexDump . toHex ( LittleEndian . readShort ( in ) ) ) ; break ; case 4 : out . print ( HexDump . toHex ( LittleEndian . readInt ( in ) ) ) ; break ; default : throw new IOException ( "Unable to output variable of that width" ) ; } } public static void main ( String [ ] args ) throws IOException { String dump = "0F 00 00 F0 89 07 00 00 00 00 06 F0 18 00 00 00 " + "05 04 00 00 02 00 00 00 05 00 00 00 01 00 00 00 " + "01 00 00 00 05 00 00 00 4F 00 01 F0 2F 07 00 00 " + "42 00 07 F0 B7 01 00 00 03 04 3F 14 AE 6B 0F 65 " + "B0 48 BF 5E 94 63 80 E8 91 73 FF 00 93 01 00 00 " + "01 00 00 00 00 00 00 00 00 00 FF FF 20 54 1C F0 " + "8B 01 00 00 3F 14 AE 6B 0F 65 B0 48 BF 5E 94 63 " + "80 E8 91 73 92 0E 00 00 00 00 00 00 00 00 00 00 " + "D1 07 00 00 DD 05 00 00 4A AD 6F 00 8A C5 53 00 " + "59 01 00 00 00 FE 78 9C E3 9B C4 00 04 AC 77 D9 " + "2F 32 08 32 FD E7 61 F8 FF 0F C8 FD 05 C5 30 19 " + "10 90 63 90 FA 0F 06 0C 8C 0C 5C 70 19 43 30 EB " + "0E FB 05 86 85 0C DB 18 58 80 72 8C 70 16 0B 83 " + "05 56 51 29 88 C9 60 D9 69 0C 6C 20 26 23 03 C8 " + "74 B0 A8 0E 03 07 FB 45 56 C7 A2 CC C4 1C 06 66 " + "A0 0D 2C 40 39 5E 86 4C 06 3D A0 4E 10 D0 60 D9 " + "C8 58 CC E8 CF B0 80 61 3A 8A 7E 0D C6 23 AC 4F " + "E0 E2 98 B6 12 2B 06 73 9D 12 E3 52 56 59 F6 08 " + "8A CC 52 66 A3 50 FF 96 2B 94 E9 DF 4C A1 FE 2D " + "3A 03 AB 9F 81 C2 F0 A3 54 BF 0F 85 EE A7 54 FF " + "40 FB 7F A0 E3 9F D2 F4 4F 71 FE 19 58 FF 2B 31 " + "7F 67 36 3B 25 4F 99 1B 4E 53 A6 5F 89 25 95 E9 " + "C4 00 C7 83 12 F3 1F 26 35 4A D3 D2 47 0E 0A C3 " + "41 8E C9 8A 52 37 DC 15 A1 D0 0D BC 4C 06 0C 2B " + "28 2C 13 28 D4 EF 43 61 5A A0 58 3F 85 71 E0 4B " + "69 9E 64 65 FE 39 C0 E5 22 30 1D 30 27 0E 74 3A " + "18 60 FD 4A CC B1 2C 13 7D 07 36 2D 2A 31 85 B2 " + "6A 0D 74 1D 1D 22 4D 99 FE 60 0A F5 9B EC 1C 58 " + "FD 67 06 56 3F 38 0D 84 3C A5 30 0E 28 D3 AF C4 " + "A4 CA FA 44 7A 0D 65 6E 60 7F 4D A1 1B 24 58 F7 " + "49 AF A5 CC 0D CC DF 19 FE 03 00 F0 B1 25 4D 42 " + "00 07 F0 E1 01 00 00 03 04 39 50 BE 98 B0 6F 57 " + "24 31 70 5D 23 2F 9F 10 66 FF 00 BD 01 00 00 01 " + "00 00 00 00 00 00 00 00 00 FF FF 20 54 1C F0 B5 " + "01 00 00 39 50 BE 98 B0 6F 57 24 31 70 5D 23 2F " + "9F 10 66 DA 03 00 00 00 00 00 00 00 00 00 00 D1 " + "07 00 00 DD 05 00 00 4A AD 6F 00 8A C5 53 00 83 " + "01 00 00 00 FE 78 9C A5 52 BF 4B 42 51 14 3E F7 " + "DC 77 7A 16 45 48 8B 3C 48 A8 16 15 0D 6C 88 D0 " + "04 C3 40 A3 32 1C 84 96 08 21 04 A1 C5 5C A2 35 " + "82 C0 35 6A AB 1C 6A 6B A8 24 5A 83 68 08 84 84 " + "96 A2 86 A0 7F C2 86 5E E7 5E F5 41 E4 10 BC 03 " + "1F E7 FB F1 CE B9 F7 F1 9E 7C 05 2E 7A 37 9B E0 " + "45 7B 10 EC 6F 96 5F 1D 74 13 55 7E B0 6C 5D 20 " + "60 C0 49 A2 9A BD 99 4F 50 83 1B 30 38 13 0E 33 " + "60 A6 A7 6B B5 37 EB F4 10 FA 14 15 A0 B6 6B 37 " + "0C 1E B3 49 73 5B A5 C2 26 48 3E C1 E0 6C 08 4A " + "30 C9 93 AA 02 B8 20 13 62 05 4E E1 E8 D7 7C C0 " + "B8 14 95 5E BE B8 A7 CF 1E BE 55 2C 56 B9 78 DF " + "08 7E 88 4C 27 FF 7B DB FF 7A DD B7 1A 17 67 34 " + "6A AE BA DA 35 D1 E7 72 BE FE EC 6E FE DA E5 7C " + "3D EC 7A DE 03 FD 50 06 0B 23 F2 0E F3 B2 A5 11 " + "91 0D 4C B5 B5 F3 BF 94 C1 8F 24 F7 D9 6F 60 94 " + "3B C9 9A F3 1C 6B E7 BB F0 2E 49 B2 25 2B C6 B1 " + "EE 69 EE 15 63 4F 71 7D CE 85 CC C8 35 B9 C3 28 " + "28 CE D0 5C 67 79 F2 4A A2 14 23 A4 38 43 73 9D " + "2D 69 2F C1 08 31 9F C5 5C 9B EB 7B C5 69 19 B3 " + "B4 81 F3 DC E3 B4 8E 8B CC B3 94 53 5A E7 41 2A " + "63 9A AA 38 C5 3D 48 BB EC 57 59 6F 2B AD 73 1F " + "1D 60 92 AE 70 8C BB 8F CE 31 C1 3C 49 27 4A EB " + "DC A4 5B 8C D1 0B 0E 73 37 E9 11 A7 99 C7 E8 41 " + "69 B0 7F 00 96 F2 A7 E8 42 00 07 F0 B4 01 00 00 " + "03 04 1A BA F9 D6 A9 B9 3A 03 08 61 E9 90 FF 7B " + "9E E6 FF 00 90 01 00 00 01 00 00 00 00 00 00 00 " + "00 00 FF FF 20 54 1C F0 88 01 00 00 1A BA F9 D6 " + "A9 B9 3A 03 08 61 E9 90 FF 7B 9E E6 12 0E 00 00 " + "00 00 00 00 00 00 00 00 D1 07 00 00 DD 05 00 00 " + "4A AD 6F 00 8A C5 53 00 56 01 00 00 00 FE 78 9C " + "E3 13 62 00 02 D6 BB EC 17 19 04 99 FE F3 30 FC " + "FF 07 E4 FE 82 62 98 0C 08 C8 31 48 FD 07 03 06 " + "46 06 2E B8 8C 21 98 75 87 FD 02 C3 42 86 6D 0C " + "2C 40 39 46 38 8B 85 C1 02 AB A8 14 C4 64 B0 EC " + "34 06 36 10 93 91 01 64 3A 58 54 87 81 83 FD 22 " + "AB 63 51 66 62 0E 03 33 D0 06 16 A0 1C 2F 43 26 " + "83 1E 50 27 08 68 B0 6C 64 2C 66 F4 67 58 C0 30 " + "1D 45 BF 06 E3 11 D6 27 70 71 4C 5B 89 15 83 B9 " + "4E 89 71 29 AB 2C 7B 04 45 66 29 B3 51 A8 7F CB " + "15 CA F4 6F A6 50 FF 16 9D 81 D5 CF 40 61 F8 51 " + "AA DF 87 42 F7 53 AA 7F A0 FD 3F D0 F1 4F 69 FA " + "A7 38 FF 0C AC FF 95 98 BF 33 9B 9D 92 A7 CC 0D " + "A7 29 D3 AF C4 92 CA 74 62 80 E3 41 89 F9 0F 93 " + "1A A5 69 E9 23 07 85 E1 20 C7 64 45 A9 1B EE 8A " + "50 E8 06 5E 26 03 86 15 14 96 09 14 EA F7 A1 30 " + "2D 50 AC 9F C2 38 F0 A5 34 4F B2 32 FF 1C E0 72 " + "11 98 0E 98 13 07 38 1D 28 31 C7 B2 4C F4 1D D8 " + "B4 A0 C4 14 CA AA 35 D0 75 64 88 34 65 FA 83 29 " + "D4 6F B2 73 60 F5 9F A1 54 FF 0E CA D3 40 C8 53 " + "0A E3 E0 09 85 6E 50 65 7D 22 BD 86 32 37 B0 BF " + "A6 D0 0D 12 AC FB A4 D7 52 E6 06 E6 EF 0C FF 01 " + "97 1D 12 C7 42 00 07 F0 C3 01 00 00 03 04 BA 4C " + "B6 23 BA 8B 27 BE C8 55 59 86 24 9F 89 D4 FF 00 " + "9F 01 00 00 01 00 00 00 00 00 00 00 00 00 FF FF " + "20 54 1C F0 97 01 00 00 BA 4C B6 23 BA 8B 27 BE " + "C8 55 59 86 24 9F 89 D4 AE 0E 00 00 00 00 00 00 " + "00 00 00 00 D1 07 00 00 DD 05 00 00 4A AD 6F 00 " + "8A C5 53 00 65 01 00 00 00 FE 78 9C E3 5B C7 00 " + "04 AC 77 D9 2F 32 08 32 FD E7 61 F8 FF 0F C8 FD " + "05 C5 30 19 10 90 63 90 FA 0F 06 0C 8C 0C 5C 70 " + "19 43 30 EB 0E FB 05 86 85 0C DB 18 58 80 72 8C " + "70 16 0B 83 05 56 51 29 88 C9 60 D9 69 0C 6C 20 " + "26 23 03 C8 74 B0 A8 0E 03 07 FB 45 56 C7 A2 CC " + "C4 1C 06 66 A0 0D 2C 40 39 5E 86 4C 06 3D A0 4E " + "10 D0 60 99 C6 B8 98 D1 9F 61 01 C3 74 14 FD 1A " + "8C 2B D8 84 B1 88 4B A5 A5 75 03 01 50 DF 59 46 " + "77 46 0F A8 3C A6 AB 88 15 83 B9 5E 89 B1 8B D5 " + "97 2D 82 22 B3 94 29 D5 BF E5 CA C0 EA DF AC 43 " + "A1 FD 14 EA 67 A0 30 FC 28 D5 EF 43 A1 FB 7D 87 " + "B8 FF 07 3A FE 07 3A FD 53 EA 7E 0A C3 4F 89 F9 " + "0E 73 EA 69 79 CA DC 70 8A 32 FD 4A 2C 5E 4C DF " + "87 7A 3C BC E0 A5 30 1E 3E 31 C5 33 AC A0 30 2F " + "52 A8 DF 87 C2 30 A4 54 3F A5 65 19 85 65 A9 12 " + "D3 2B 16 0D 8A CB 13 4A F3 E3 27 E6 09 03 9D 0E " + "06 58 BF 12 B3 13 CB C1 01 4E 8B 4A 4C 56 AC 91 " + "03 5D 37 86 48 53 A6 3F 98 42 FD 26 3B 07 56 FF " + "99 1D 14 EA A7 CC 7E 70 1A 08 79 42 61 1C 3C A5 " + "D0 0D 9C 6C C2 32 6B 29 73 03 DB 6B CA DC C0 F8 " + "97 F5 AD CC 1A CA DC C0 F4 83 32 37 B0 A4 30 CE " + "FC C7 48 99 1B FE 33 32 FC 07 00 6C CC 2E 23 33 " + "00 0B F0 12 00 00 00 BF 00 08 00 08 00 81 01 09 " + "00 00 08 C0 01 40 00 00 08 40 00 1E F1 10 00 00 " + "00 0D 00 00 08 0C 00 00 08 17 00 00 08 F7 00 00 " + "10                                              " ; byte [ ] bytes = HexRead . readData ( new ByteArrayInputStream ( dump . getBytes ( ) ) , - 1 ) ; EscherDump dumper = new EscherDump ( ) ; dumper . dump ( bytes , 0 , bytes . length , System . out ) ; } public void dump ( int recordSize , byte [ ] data , PrintStream out ) throws IOException , LittleEndian . BufferUnderrunException { dump ( data , 0 , recordSize , System . out ) ; } } 	0	['9', '1', '0', '8', '45', '36', '1', '8', '5', '2', '3581', '0', '0', '0', '0.296296296', '0', '0', '396.8888889', '3', '1.3333', '0']
package org . apache . poi . poifs . storage ; import java . io . * ; import java . util . * ; public class RawDataBlockList extends BlockListImpl { public RawDataBlockList ( final InputStream stream ) throws IOException { List blocks = new ArrayList ( ) ; while ( true ) { RawDataBlock block = new RawDataBlock ( stream ) ; if ( block . eof ( ) ) { break ; } blocks . add ( block ) ; } setBlocks ( ( RawDataBlock [ ] ) blocks . toArray ( new RawDataBlock [ 0 ] ) ) ; } } 	0	['5', '2', '0', '8', '16', '10', '4', '4', '5', '2', '50', '0', '0', '0.555555556', '0.5', '0', '0', '9', '1', '0.8', '0']
package org . apache . poi . hssf . usermodel ; public abstract class HSSFShape { public static final int LINEWIDTH_ONE_PT = 12700 ; public static final int LINEWIDTH_DEFAULT = 9525 ; public static final int LINESTYLE_SOLID = 0 ; public static final int LINESTYLE_DASHSYS = 1 ; public static final int LINESTYLE_DOTSYS = 2 ; public static final int LINESTYLE_DASHDOTSYS = 3 ; public static final int LINESTYLE_DASHDOTDOTSYS = 4 ; public static final int LINESTYLE_DOTGEL = 5 ; public static final int LINESTYLE_DASHGEL = 6 ; public static final int LINESTYLE_LONGDASHGEL = 7 ; public static final int LINESTYLE_DASHDOTGEL = 8 ; public static final int LINESTYLE_LONGDASHDOTGEL = 9 ; public static final int LINESTYLE_LONGDASHDOTDOTGEL = 10 ; public static final int LINESTYLE_NONE = - 1 ; HSSFShape parent ; HSSFAnchor anchor ; int lineStyleColor = 0x08000040 ; int fillColor = 0x08000009 ; int lineWidth = LINEWIDTH_DEFAULT ; int lineStyle = LINESTYLE_SOLID ; boolean noFill = false ; HSSFShape ( HSSFShape parent , HSSFAnchor anchor ) { this . parent = parent ; this . anchor = anchor ; } public HSSFShape getParent ( ) { return parent ; } public HSSFAnchor getAnchor ( ) { return anchor ; } public void setAnchor ( HSSFAnchor anchor ) { if ( parent == null ) { if ( anchor instanceof HSSFChildAnchor ) throw new IllegalArgumentException ( "Must use client anchors for shapes directly attached to sheet." ) ; } else { if ( anchor instanceof HSSFClientAnchor ) throw new IllegalArgumentException ( "Must use child anchors for shapes attached to groups." ) ; } this . anchor = anchor ; } public int getLineStyleColor ( ) { return lineStyleColor ; } public void setLineStyleColor ( int lineStyleColor ) { this . lineStyleColor = lineStyleColor ; } public void setLineStyleColor ( int red , int green , int blue ) { this . lineStyleColor = ( ( blue ) << 16 ) | ( ( green ) << 8 ) | red ; } public int getFillColor ( ) { return fillColor ; } public void setFillColor ( int fillColor ) { this . fillColor = fillColor ; } public void setFillColor ( int red , int green , int blue ) { this . fillColor = ( ( blue ) << 16 ) | ( ( green ) << 8 ) | red ; } public int getLineWidth ( ) { return lineWidth ; } public void setLineWidth ( int lineWidth ) { this . lineWidth = lineWidth ; } public int getLineStyle ( ) { return lineStyle ; } public void setLineStyle ( int lineStyle ) { this . lineStyle = lineStyle ; } public boolean isNoFill ( ) { return noFill ; } public void setNoFill ( boolean noFill ) { this . noFill = noFill ; } public int countOfAllChildren ( ) { return 1 ; } } 	0	['17', '1', '3', '14', '19', '84', '11', '3', '16', '0.994047619', '152', '0', '2', '0', '0.317647059', '0', '0', '6.705882353', '4', '1.1176', '0']
package org . apache . poi . util ; import java . io . * ; public class HexDump { public static final String EOL = System . getProperty ( "line.separator" ) ; private static final char _hexcodes [ ] = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } ; private static final int _shifts [ ] = { 28 , 24 , 20 , 16 , 12 , 8 , 4 , 0 } ; private HexDump ( ) { } public synchronized static void dump ( final byte [ ] data , final long offset , final OutputStream stream , final int index , final int length ) throws IOException , ArrayIndexOutOfBoundsException , IllegalArgumentException { if ( ( index < 0 ) || ( data . length != 0 && index >= data . length ) ) { throw new ArrayIndexOutOfBoundsException ( "illegal index: " + index + " into array of length " + data . length ) ; } if ( data . length == 0 ) return ; if ( stream == null ) { throw new IllegalArgumentException ( "cannot write to nullstream" ) ; } long display_offset = offset + index ; StringBuffer buffer = new StringBuffer ( 74 ) ; int data_length = Math . min ( data . length , index + length ) ; for ( int j = index ; j < data_length ; j += 16 ) { int chars_read = data_length - j ; if ( chars_read > 16 ) { chars_read = 16 ; } buffer . append ( dump ( display_offset ) ) . append ( ' ' ) ; for ( int k = 0 ; k < 16 ; k ++ ) { if ( k < chars_read ) { buffer . append ( dump ( data [ k + j ] ) ) ; } else { buffer . append ( "  " ) ; } buffer . append ( ' ' ) ; } for ( int k = 0 ; k < chars_read ; k ++ ) { if ( ( data [ k + j ] >= ' ' ) && ( data [ k + j ] < 127 ) ) { buffer . append ( ( char ) data [ k + j ] ) ; } else { buffer . append ( '.' ) ; } } buffer . append ( EOL ) ; stream . write ( buffer . toString ( ) . getBytes ( ) ) ; stream . flush ( ) ; buffer . setLength ( 0 ) ; display_offset += chars_read ; } } public synchronized static void dump ( final byte [ ] data , final long offset , final OutputStream stream , final int index ) throws IOException , ArrayIndexOutOfBoundsException , IllegalArgumentException { dump ( data , offset , stream , index , data . length - index ) ; } public static String dump ( final byte [ ] data , final long offset , final int index ) { StringBuffer buffer ; if ( ( index < 0 ) || ( index >= data . length ) ) { throw new ArrayIndexOutOfBoundsException ( "illegal index: " + index + " into array of length " + data . length ) ; } long display_offset = offset + index ; buffer = new StringBuffer ( 74 ) ; for ( int j = index ; j < data . length ; j += 16 ) { int chars_read = data . length - j ; if ( chars_read > 16 ) { chars_read = 16 ; } buffer . append ( dump ( display_offset ) ) . append ( ' ' ) ; for ( int k = 0 ; k < 16 ; k ++ ) { if ( k < chars_read ) { buffer . append ( dump ( data [ k + j ] ) ) ; } else { buffer . append ( "  " ) ; } buffer . append ( ' ' ) ; } for ( int k = 0 ; k < chars_read ; k ++ ) { if ( ( data [ k + j ] >= ' ' ) && ( data [ k + j ] < 127 ) ) { buffer . append ( ( char ) data [ k + j ] ) ; } else { buffer . append ( '.' ) ; } } buffer . append ( EOL ) ; display_offset += chars_read ; } return buffer . toString ( ) ; } private static String dump ( final long value ) { StringBuffer buf = new StringBuffer ( ) ; buf . setLength ( 0 ) ; for ( int j = 0 ; j < 8 ; j ++ ) { buf . append ( _hexcodes [ ( ( int ) ( value > > _shifts [ j ] ) ) & 15 ] ) ; } return buf . toString ( ) ; } private static String dump ( final byte value ) { StringBuffer buf = new StringBuffer ( ) ; buf . setLength ( 0 ) ; for ( int j = 0 ; j < 2 ; j ++ ) { buf . append ( _hexcodes [ ( value > > _shifts [ j + 6 ] ) & 15 ] ) ; } return buf . toString ( ) ; } public static String toHex ( final byte [ ] value ) { StringBuffer retVal = new StringBuffer ( ) ; retVal . append ( '[' ) ; for ( int x = 0 ; x < value . length ; x ++ ) { retVal . append ( toHex ( value [ x ] ) ) ; retVal . append ( ", " ) ; } retVal . append ( ']' ) ; return retVal . toString ( ) ; } public static String toHex ( final short value ) { return toHex ( value , 4 ) ; } public static String toHex ( final byte value ) { return toHex ( value , 2 ) ; } public static String toHex ( final int value ) { return toHex ( value , 8 ) ; } private static String toHex ( final long value , final int digits ) { StringBuffer result = new StringBuffer ( digits ) ; for ( int j = 0 ; j < digits ; j ++ ) { result . append ( _hexcodes [ ( int ) ( ( value > > _shifts [ j + ( 8 - digits ) ] ) & 15 ) ] ) ; } return result . toString ( ) ; } public static void dump ( InputStream in , PrintStream out , int start , int bytesToDump ) throws IOException { ByteArrayOutputStream buf = new ByteArrayOutputStream ( ) ; if ( bytesToDump == - 1 ) { int c = in . read ( ) ; while ( c != - 1 ) { buf . write ( c ) ; c = in . read ( ) ; } } else { int bytesRemaining = bytesToDump ; while ( bytesRemaining -- > 0 ) { int c = in . read ( ) ; if ( c == - 1 ) break ; else buf . write ( c ) ; } } byte [ ] data = buf . toByteArray ( ) ; dump ( data , 0 , out , start , data . length ) ; } } 	0	['13', '1', '0', '63', '35', '60', '63', '0', '8', '0.333333333', '618', '0.666666667', '0', '0', '0.212962963', '0', '0', '46.30769231', '10', '1.8462', '0']
package org . apache . poi . hssf . usermodel ; public class HSSFTextbox extends HSSFSimpleShape { public final static short OBJECT_TYPE_TEXT = 6 ; int marginLeft , marginRight , marginTop , marginBottom ; HSSFRichTextString string = new HSSFRichTextString ( "" ) ; public HSSFTextbox ( HSSFShape parent , HSSFAnchor anchor ) { super ( parent , anchor ) ; setShapeType ( OBJECT_TYPE_TEXT ) ; } public HSSFRichTextString getString ( ) { return string ; } public void setString ( HSSFRichTextString string ) { this . string = string ; } public int getMarginLeft ( ) { return marginLeft ; } public void setMarginLeft ( int marginLeft ) { this . marginLeft = marginLeft ; } public int getMarginRight ( ) { return marginRight ; } public void setMarginRight ( int marginRight ) { this . marginRight = marginRight ; } public int getMarginTop ( ) { return marginTop ; } public void setMarginTop ( int marginTop ) { this . marginTop = marginTop ; } public int getMarginBottom ( ) { return marginBottom ; } public void setMarginBottom ( int marginBottom ) { this . marginBottom = marginBottom ; } } 	0	['11', '3', '0', '9', '14', '41', '5', '4', '11', '0.916666667', '66', '0', '1', '0.642857143', '0.327272727', '0', '0', '4.454545455', '1', '0.9091', '0']
package org . apache . poi . hssf . usermodel ; import org . apache . poi . ddf . EscherClientAnchorRecord ; import org . apache . poi . ddf . EscherRecord ; public class HSSFClientAnchor extends HSSFAnchor { short col1 ; int row1 ; short col2 ; int row2 ; public HSSFClientAnchor ( ) { } public HSSFClientAnchor ( int dx1 , int dy1 , int dx2 , int dy2 , short col1 , int row1 , short col2 , int row2 ) { super ( dx1 , dy1 , dx2 , dy2 ) ; checkRange ( dx1 , 0 , 1023 , "dx1" ) ; checkRange ( dx2 , 0 , 1023 , "dx2" ) ; checkRange ( dy1 , 0 , 255 , "dy1" ) ; checkRange ( dy2 , 0 , 255 , "dy2" ) ; checkRange ( col1 , 0 , 255 , "col1" ) ; checkRange ( col2 , 0 , 255 , "col2" ) ; checkRange ( row1 , 0 , 255 * 256 , "row1" ) ; checkRange ( row2 , 0 , 255 * 256 , "row2" ) ; this . col1 = col1 ; this . row1 = row1 ; this . col2 = col2 ; this . row2 = row2 ; } public float getAnchorHeightInPoints ( HSSFSheet sheet ) { int y1 = Math . min ( getDy1 ( ) , getDy2 ( ) ) ; int y2 = Math . max ( getDy1 ( ) , getDy2 ( ) ) ; int row1 = Math . min ( getRow1 ( ) , getRow2 ( ) ) ; int row2 = Math . max ( getRow1 ( ) , getRow2 ( ) ) ; float points = 0 ; if ( row1 == row2 ) { points = ( ( y2 - y1 ) / 256.0f ) * getRowHeightInPoints ( sheet , row2 ) ; } else { points += ( ( 256.0f - y1 ) / 256.0f ) * getRowHeightInPoints ( sheet , row1 ) ; for ( int i = row1 + 1 ; i < row2 ; i ++ ) { points += getRowHeightInPoints ( sheet , i ) ; } points += ( y2 / 256.0f ) * getRowHeightInPoints ( sheet , row2 ) ; } return points ; } private float getRowHeightInPoints ( HSSFSheet sheet , int rowNum ) { HSSFRow row = sheet . getRow ( rowNum ) ; if ( row == null ) return sheet . getDefaultRowHeightInPoints ( ) ; else return row . getHeightInPoints ( ) ; } public short getCol1 ( ) { return col1 ; } public void setCol1 ( short col1 ) { checkRange ( col1 , 0 , 255 , "col1" ) ; this . col1 = col1 ; } public short getCol2 ( ) { return col2 ; } public void setCol2 ( short col2 ) { checkRange ( col2 , 0 , 255 , "col2" ) ; this . col2 = col2 ; } public int getRow1 ( ) { return row1 ; } public void setRow1 ( int row1 ) { checkRange ( row1 , 0 , 256 * 256 , "row1" ) ; this . row1 = row1 ; } public int getRow2 ( ) { return row2 ; } public void setRow2 ( int row2 ) { checkRange ( row2 , 0 , 256 * 256 , "row2" ) ; this . row2 = row2 ; } public void setAnchor ( short col1 , int row1 , int x1 , int y1 , short col2 , int row2 , int x2 , int y2 ) { checkRange ( dx1 , 0 , 1023 , "dx1" ) ; checkRange ( dx2 , 0 , 1023 , "dx2" ) ; checkRange ( dy1 , 0 , 255 , "dy1" ) ; checkRange ( dy2 , 0 , 255 , "dy2" ) ; checkRange ( col1 , 0 , 255 , "col1" ) ; checkRange ( col2 , 0 , 255 , "col2" ) ; checkRange ( row1 , 0 , 255 * 256 , "row1" ) ; checkRange ( row2 , 0 , 255 * 256 , "row2" ) ; this . col1 = col1 ; this . row1 = row1 ; this . dx1 = x1 ; this . dy1 = y1 ; this . col2 = col2 ; this . row2 = row2 ; this . dx2 = x2 ; this . dy2 = y2 ; } public boolean isHorizontallyFlipped ( ) { if ( col1 == col2 ) return dx1 > dx2 ; else return col1 > col2 ; } public boolean isVerticallyFlipped ( ) { if ( row1 == row2 ) return dy1 > dy2 ; else return row1 > row2 ; } private void checkRange ( int value , int minRange , int maxRange , String varName ) { if ( value < minRange || value > maxRange ) throw new IllegalArgumentException ( varName + " must be between " + minRange + " and " + maxRange ) ; } } 	0	['16', '2', '0', '7', '30', '54', '4', '3', '14', '0.7', '388', '0', '0', '0.416666667', '0.3625', '1', '1', '23', '4', '1.5625', '0']
package org . apache . poi . hssf . record . formula ; public abstract class ControlPtg extends Ptg { } 	0	['1', '2', '1', '2', '2', '0', '1', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . poi . poifs . property ; import java . util . * ; import java . io . IOException ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . storage . SmallDocumentBlock ; public class RootProperty extends DirectoryProperty { RootProperty ( ) { super ( "Root Entry" ) ; setNodeColor ( _NODE_BLACK ) ; setPropertyType ( PropertyConstants . ROOT_TYPE ) ; setStartBlock ( POIFSConstants . END_OF_CHAIN ) ; } protected RootProperty ( final int index , final byte [ ] array , final int offset ) { super ( index , array , offset ) ; } public void setSize ( int size ) { super . setSize ( SmallDocumentBlock . calcSize ( size ) ) ; } } 	0	['3', '3', '0', '8', '10', '3', '6', '2', '1', '2', '27', '0', '0', '0.971428571', '0.666666667', '1', '1', '8', '1', '0.3333', '0']
package org . apache . poi . poifs . storage ; import java . util . * ; public class SmallDocumentBlockList extends BlockListImpl { public SmallDocumentBlockList ( final List blocks ) { setBlocks ( ( SmallDocumentBlock [ ] ) blocks . toArray ( new SmallDocumentBlock [ 0 ] ) ) ; } } 	0	['5', '2', '0', '5', '12', '10', '1', '4', '5', '2', '32', '0', '0', '0.555555556', '0.5', '0', '0', '5.4', '1', '0.8', '0']
package org . apache . poi . hpsf ; import org . apache . poi . util . LittleEndian ; public class TypeReader { public static Object read ( final byte [ ] src , int offset , int length , final int type ) { Object value ; length = length - LittleEndian . INT_SIZE ; switch ( type ) { case Variant . VT_EMPTY : { value = null ; break ; } case Variant . VT_I2 : { value = new Integer ( LittleEndian . getUShort ( src , offset ) ) ; break ; } case Variant . VT_I4 : { value = new Long ( LittleEndian . getUInt ( src , offset ) ) ; break ; } case Variant . VT_FILETIME : { final long low = LittleEndian . getUInt ( src , offset ) ; offset += LittleEndian . INT_SIZE ; final long high = LittleEndian . getUInt ( src , offset ) ; value = Util . filetimeToDate ( ( int ) high , ( int ) low ) ; break ; } case Variant . VT_LPSTR : { final int first = offset + LittleEndian . INT_SIZE ; long last = first + LittleEndian . getUInt ( src , offset ) - 1 ; offset += LittleEndian . INT_SIZE ; while ( src [ ( int ) last ] == 0 && first <= last ) last -- ; value = new String ( src , ( int ) first , ( int ) ( last - first + 1 ) ) ; break ; } case Variant . VT_LPWSTR : { final int first = offset + LittleEndian . INT_SIZE ; long last = first + LittleEndian . getUInt ( src , offset ) - 1 ; long l = last - first ; offset += LittleEndian . INT_SIZE ; StringBuffer b = new StringBuffer ( ( int ) ( last - first ) ) ; for ( int i = 0 ; i <= l ; i ++ ) { final int i1 = offset + ( i * 2 ) ; final int i2 = i1 + 1 ; b . append ( ( char ) ( ( src [ i2 ] << 8 ) + src [ i1 ] ) ) ; } while ( b . charAt ( b . length ( ) - 1 ) == 0x00 ) b . setLength ( b . length ( ) - 1 ) ; value = b . toString ( ) ; break ; } case Variant . VT_CF : { final byte [ ] v = new byte [ length ] ; for ( int i = 0 ; i < length ; i ++ ) v [ i ] = src [ ( int ) ( offset + i ) ] ; value = v ; break ; } case Variant . VT_BOOL : { long bool = LittleEndian . getUInt ( src , offset ) ; if ( bool != 0 ) value = new Boolean ( true ) ; else value = new Boolean ( false ) ; break ; } default : { final byte [ ] v = new byte [ length ] ; for ( int i = 0 ; i < length ; i ++ ) v [ i ] = src [ ( int ) ( offset + i ) ] ; value = v ; break ; } } return value ; } } 	0	['2', '1', '0', '3', '16', '1', '1', '2', '2', '2', '231', '0', '0', '0', '0.5', '0', '0', '114.5', '17', '8.5', '0']
package org . apache . poi . hssf . util ; public class AreaReference { private CellReference [ ] cells ; private int dim ; public AreaReference ( String reference ) { String [ ] refs = seperateAreaRefs ( reference ) ; dim = refs . length ; cells = new CellReference [ dim ] ; for ( int i = 0 ; i < dim ; i ++ ) { cells [ i ] = new CellReference ( refs [ i ] ) ; } } public int getDim ( ) { return dim ; } public CellReference [ ] getCells ( ) { return cells ; } public String toString ( ) { StringBuffer retval = new StringBuffer ( ) ; for ( int i = 0 ; i < dim ; i ++ ) { retval . append ( ':' ) ; retval . append ( cells [ i ] . toString ( ) ) ; } retval . deleteCharAt ( 0 ) ; return retval . toString ( ) ; } private String [ ] seperateAreaRefs ( String reference ) { String [ ] retval = null ; int length = reference . length ( ) ; int loc = reference . indexOf ( ':' , 0 ) ; if ( loc == - 1 ) { retval = new String [ 1 ] ; retval [ 0 ] = reference ; } else { retval = new String [ 2 ] ; int sheetStart = reference . indexOf ( "!" ) ; retval [ 0 ] = reference . substring ( 0 , sheetStart + 1 ) + reference . substring ( sheetStart + 1 , loc ) ; retval [ 1 ] = reference . substring ( 0 , sheetStart + 1 ) + reference . substring ( loc + 1 ) ; } return retval ; } } 	0	['5', '1', '0', '3', '21', '0', '2', '1', '4', '0.5', '149', '1', '1', '0', '0.7', '0', '0', '28.4', '2', '1.2', '0']
package org . apache . poi . hssf . usermodel ; import java . util . List ; public interface HSSFShapeContainer { List getChildren ( ) ; } 	0	['1', '1', '0', '3', '1', '0', '3', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . poi . ddf ; public interface EscherRecordFactory { EscherRecord createRecord ( byte [ ] data , int offset ) ; } 	0	['1', '1', '0', '19', '1', '0', '19', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . poi . poifs . filesystem ; import java . io . * ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . dev . POIFSViewable ; import org . apache . poi . poifs . property . DirectoryProperty ; import org . apache . poi . poifs . property . DocumentProperty ; import org . apache . poi . poifs . property . Property ; import org . apache . poi . poifs . property . PropertyTable ; import org . apache . poi . poifs . storage . BATBlock ; import org . apache . poi . poifs . storage . BlockAllocationTableReader ; import org . apache . poi . poifs . storage . BlockAllocationTableWriter ; import org . apache . poi . poifs . storage . BlockList ; import org . apache . poi . poifs . storage . BlockWritable ; import org . apache . poi . poifs . storage . HeaderBlockReader ; import org . apache . poi . poifs . storage . HeaderBlockWriter ; import org . apache . poi . poifs . storage . RawDataBlock ; import org . apache . poi . poifs . storage . RawDataBlockList ; import org . apache . poi . poifs . storage . SmallBlockTableReader ; import org . apache . poi . poifs . storage . SmallBlockTableWriter ; import org . apache . poi . poifs . storage . SmallDocumentBlock ; public class POIFSFileSystem implements POIFSViewable { private PropertyTable _property_table ; private List _documents ; private DirectoryNode _root ; public POIFSFileSystem ( ) { _property_table = new PropertyTable ( ) ; _documents = new ArrayList ( ) ; _root = null ; } public POIFSFileSystem ( final InputStream stream ) throws IOException { this ( ) ; HeaderBlockReader header_block_reader = new HeaderBlockReader ( stream ) ; RawDataBlockList data_blocks = new RawDataBlockList ( stream ) ; new BlockAllocationTableReader ( header_block_reader . getBATCount ( ) , header_block_reader . getBATArray ( ) , header_block_reader . getXBATCount ( ) , header_block_reader . getXBATIndex ( ) , data_blocks ) ; PropertyTable properties = new PropertyTable ( header_block_reader . getPropertyStart ( ) , data_blocks ) ; processProperties ( SmallBlockTableReader . getSmallDocumentBlocks ( data_blocks , properties . getRoot ( ) , header_block_reader . getSBATStart ( ) ) , data_blocks , properties . getRoot ( ) . getChildren ( ) , null ) ; } public DocumentEntry createDocument ( final InputStream stream , final String name ) throws IOException { return getRoot ( ) . createDocument ( name , stream ) ; } public DocumentEntry createDocument ( final String name , final int size , final POIFSWriterListener writer ) throws IOException { return getRoot ( ) . createDocument ( name , size , writer ) ; } public DirectoryEntry createDirectory ( final String name ) throws IOException { return getRoot ( ) . createDirectory ( name ) ; } public void writeFilesystem ( final OutputStream stream ) throws IOException { _property_table . preWrite ( ) ; SmallBlockTableWriter sbtw = new SmallBlockTableWriter ( _documents , _property_table . getRoot ( ) ) ; BlockAllocationTableWriter bat = new BlockAllocationTableWriter ( ) ; List bm_objects = new ArrayList ( ) ; bm_objects . addAll ( _documents ) ; bm_objects . add ( _property_table ) ; bm_objects . add ( sbtw ) ; bm_objects . add ( sbtw . getSBAT ( ) ) ; Iterator iter = bm_objects . iterator ( ) ; while ( iter . hasNext ( ) ) { BATManaged bmo = ( BATManaged ) iter . next ( ) ; int block_count = bmo . countBlocks ( ) ; if ( block_count != 0 ) { bmo . setStartBlock ( bat . allocateSpace ( block_count ) ) ; } else { } } int batStartBlock = bat . createBlocks ( ) ; HeaderBlockWriter header_block_writer = new HeaderBlockWriter ( ) ; BATBlock [ ] xbat_blocks = header_block_writer . setBATBlocks ( bat . countBlocks ( ) , batStartBlock ) ; header_block_writer . setPropertyStart ( _property_table . getStartBlock ( ) ) ; header_block_writer . setSBATStart ( sbtw . getSBAT ( ) . getStartBlock ( ) ) ; header_block_writer . setSBATBlockCount ( sbtw . getSBATBlockCount ( ) ) ; List writers = new ArrayList ( ) ; writers . add ( header_block_writer ) ; writers . addAll ( _documents ) ; writers . add ( _property_table ) ; writers . add ( sbtw ) ; writers . add ( sbtw . getSBAT ( ) ) ; writers . add ( bat ) ; for ( int j = 0 ; j < xbat_blocks . length ; j ++ ) { writers . add ( xbat_blocks [ j ] ) ; } iter = writers . iterator ( ) ; while ( iter . hasNext ( ) ) { BlockWritable writer = ( BlockWritable ) iter . next ( ) ; writer . writeBlocks ( stream ) ; } } public static void main ( String args [ ] ) throws IOException { if ( args . length != 2 ) { System . err . println ( "two arguments required: input filename and output filename" ) ; System . exit ( 1 ) ; } FileInputStream istream = new FileInputStream ( args [ 0 ] ) ; FileOutputStream ostream = new FileOutputStream ( args [ 1 ] ) ; new POIFSFileSystem ( istream ) . writeFilesystem ( ostream ) ; istream . close ( ) ; ostream . close ( ) ; } public DirectoryEntry getRoot ( ) { if ( _root == null ) { _root = new DirectoryNode ( _property_table . getRoot ( ) , this , null ) ; } return _root ; } public DocumentInputStream createDocumentInputStream ( final String documentName ) throws IOException { Entry document = getRoot ( ) . getEntry ( documentName ) ; if ( ! document . isDocumentEntry ( ) ) { throw new IOException ( "Entry '" + documentName + "' is not a DocumentEntry" ) ; } return new DocumentInputStream ( ( DocumentEntry ) document ) ; } void addDocument ( final POIFSDocument document ) { _documents . add ( document ) ; _property_table . addProperty ( document . getDocumentProperty ( ) ) ; } void addDirectory ( final DirectoryProperty directory ) { _property_table . addProperty ( directory ) ; } void remove ( EntryNode entry ) { _property_table . removeProperty ( entry . getProperty ( ) ) ; if ( entry . isDocumentEntry ( ) ) { _documents . remove ( ( ( DocumentNode ) entry ) . getDocument ( ) ) ; } } private void processProperties ( final BlockList small_blocks , final BlockList big_blocks , final Iterator properties , final DirectoryNode dir ) throws IOException { while ( properties . hasNext ( ) ) { Property property = ( Property ) properties . next ( ) ; String name = property . getName ( ) ; DirectoryNode parent = ( dir == null ) ? ( ( DirectoryNode ) getRoot ( ) ) : dir ; if ( property . isDirectory ( ) ) { DirectoryNode new_dir = ( DirectoryNode ) parent . createDirectory ( name ) ; new_dir . setStorageClsid ( property . getStorageClsid ( ) ) ; processProperties ( small_blocks , big_blocks , ( ( DirectoryProperty ) property ) . getChildren ( ) , new_dir ) ; } else { int startBlock = property . getStartBlock ( ) ; int size = property . getSize ( ) ; POIFSDocument document = null ; if ( property . shouldUseSmallBlocks ( ) ) { document = new POIFSDocument ( name , small_blocks . fetchBlocks ( startBlock ) , size ) ; } else { document = new POIFSDocument ( name , big_blocks . fetchBlocks ( startBlock ) , size ) ; } parent . createDocument ( document ) ; } } } public Object [ ] getViewableArray ( ) { if ( preferArray ( ) ) { return ( ( POIFSViewable ) getRoot ( ) ) . getViewableArray ( ) ; } else { return new Object [ 0 ] ; } } public Iterator getViewableIterator ( ) { if ( ! preferArray ( ) ) { return ( ( POIFSViewable ) getRoot ( ) ) . getViewableIterator ( ) ; } else { return Collections . EMPTY_LIST . iterator ( ) ; } } public boolean preferArray ( ) { return ( ( POIFSViewable ) getRoot ( ) ) . preferArray ( ) ; } public String getShortDescription ( ) { return "POIFS FileSystem" ; } } 	0	['17', '1', '0', '37', '95', '106', '10', '28', '13', '0.354166667', '461', '1', '2', '0', '0.14479638', '0', '0', '25.94117647', '2', '1.1176', '0']
package org . apache . poi . poifs . filesystem ; import java . io . * ; import java . util . * ; import org . apache . poi . hpsf . ClassID ; import org . apache . poi . poifs . dev . POIFSViewable ; import org . apache . poi . poifs . property . DirectoryProperty ; import org . apache . poi . poifs . property . DocumentProperty ; import org . apache . poi . poifs . property . Property ; public class DirectoryNode extends EntryNode implements DirectoryEntry , POIFSViewable { private Map _entries ; private POIFSFileSystem _filesystem ; private POIFSDocumentPath _path ; DirectoryNode ( final DirectoryProperty property , final POIFSFileSystem filesystem , final DirectoryNode parent ) { super ( property , parent ) ; if ( parent == null ) { _path = new POIFSDocumentPath ( ) ; } else { _path = new POIFSDocumentPath ( parent . _path , new String [ ] { property . getName ( ) } ) ; } _filesystem = filesystem ; _entries = new HashMap ( ) ; Iterator iter = property . getChildren ( ) ; while ( iter . hasNext ( ) ) { Property child = ( Property ) iter . next ( ) ; Entry childNode = null ; if ( child . isDirectory ( ) ) { childNode = new DirectoryNode ( ( DirectoryProperty ) child , _filesystem , this ) ; } else { childNode = new DocumentNode ( ( DocumentProperty ) child , this ) ; } _entries . put ( childNode . getName ( ) , childNode ) ; } } public POIFSDocumentPath getPath ( ) { return _path ; } DocumentEntry createDocument ( final POIFSDocument document ) throws IOException { DocumentProperty property = document . getDocumentProperty ( ) ; DocumentNode rval = new DocumentNode ( property , this ) ; ( ( DirectoryProperty ) getProperty ( ) ) . addChild ( property ) ; _filesystem . addDocument ( document ) ; _entries . put ( property . getName ( ) , rval ) ; return rval ; } boolean changeName ( final String oldName , final String newName ) { boolean rval = false ; EntryNode child = ( EntryNode ) _entries . get ( oldName ) ; if ( child != null ) { rval = ( ( DirectoryProperty ) getProperty ( ) ) . changeName ( child . getProperty ( ) , newName ) ; if ( rval ) { _entries . remove ( oldName ) ; _entries . put ( child . getProperty ( ) . getName ( ) , child ) ; } } return rval ; } boolean deleteEntry ( final EntryNode entry ) { boolean rval = ( ( DirectoryProperty ) getProperty ( ) ) . deleteChild ( entry . getProperty ( ) ) ; if ( rval ) { _entries . remove ( entry . getName ( ) ) ; _filesystem . remove ( entry ) ; } return rval ; } public Iterator getEntries ( ) { return _entries . values ( ) . iterator ( ) ; } public boolean isEmpty ( ) { return _entries . isEmpty ( ) ; } public int getEntryCount ( ) { return _entries . size ( ) ; } public Entry getEntry ( final String name ) throws FileNotFoundException { Entry rval = null ; if ( name != null ) { rval = ( Entry ) _entries . get ( name ) ; } if ( rval == null ) { throw new FileNotFoundException ( "no such entry: \"" + name + "\"" ) ; } return rval ; } public DocumentEntry createDocument ( final String name , final InputStream stream ) throws IOException { return createDocument ( new POIFSDocument ( name , stream ) ) ; } public DocumentEntry createDocument ( final String name , final int size , final POIFSWriterListener writer ) throws IOException { return createDocument ( new POIFSDocument ( name , size , _path , writer ) ) ; } public DirectoryEntry createDirectory ( final String name ) throws IOException { DirectoryProperty property = new DirectoryProperty ( name ) ; DirectoryNode rval = new DirectoryNode ( property , _filesystem , this ) ; ( ( DirectoryProperty ) getProperty ( ) ) . addChild ( property ) ; _filesystem . addDirectory ( property ) ; _entries . put ( name , rval ) ; return rval ; } public ClassID getStorageClsid ( ) { return getProperty ( ) . getStorageClsid ( ) ; } public void setStorageClsid ( ClassID clsidStorage ) { getProperty ( ) . setStorageClsid ( clsidStorage ) ; } public boolean isDirectoryEntry ( ) { return true ; } protected boolean isDeleteOK ( ) { return isEmpty ( ) ; } public Object [ ] getViewableArray ( ) { return new Object [ 0 ] ; } public Iterator getViewableIterator ( ) { List components = new ArrayList ( ) ; components . add ( getProperty ( ) ) ; SortedMap sortedEntries = new TreeMap ( _entries ) ; Iterator iter = sortedEntries . values ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { components . add ( iter . next ( ) ) ; } return components . iterator ( ) ; } public boolean preferArray ( ) { return false ; } public String getShortDescription ( ) { return getName ( ) ; } } 	0	['20', '2', '0', '14', '65', '94', '3', '14', '15', '0.649122807', '327', '1', '2', '0.321428571', '0.154545455', '1', '1', '15.2', '3', '1.15', '0']
package org . apache . poi . hssf . usermodel ; import org . apache . poi . ddf . EscherRecord ; import org . apache . poi . ddf . EscherClientAnchorRecord ; import org . apache . poi . ddf . EscherChildAnchorRecord ; public class HSSFChildAnchor extends HSSFAnchor { public HSSFChildAnchor ( ) { } public HSSFChildAnchor ( int dx1 , int dy1 , int dx2 , int dy2 ) { super ( dx1 , dy1 , dx2 , dy2 ) ; } public void setAnchor ( int dx1 , int dy1 , int dx2 , int dy2 ) { this . dx1 = dx1 ; this . dy1 = dy1 ; this . dx2 = dx2 ; this . dy2 = dy2 ; } public boolean isHorizontallyFlipped ( ) { return dx1 > dx2 ; } public boolean isVerticallyFlipped ( ) { return dy1 > dy2 ; } } 	0	['5', '2', '0', '5', '7', '6', '4', '1', '5', '2', '46', '0', '0', '0.769230769', '0.7', '1', '1', '8.2', '2', '1', '0']
package org . apache . poi . ddf ; public class NullEscherSerializationListener implements EscherSerializationListener { public void beforeRecordSerialize ( int offset , short recordId , EscherRecord record ) { } public void afterRecordSerialize ( int offset , short recordId , int size , EscherRecord record ) { } } 	0	['3', '1', '0', '3', '4', '3', '2', '2', '3', '2', '8', '0', '0', '0', '0.75', '0', '0', '1.666666667', '1', '0.6667', '0']
package org . apache . poi . poifs . filesystem ; import java . io . * ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . dev . POIFSViewable ; import org . apache . poi . poifs . property . DocumentProperty ; import org . apache . poi . poifs . property . Property ; import org . apache . poi . poifs . storage . BlockWritable ; import org . apache . poi . poifs . storage . ListManagedBlock ; import org . apache . poi . poifs . storage . DocumentBlock ; import org . apache . poi . poifs . storage . RawDataBlock ; import org . apache . poi . poifs . storage . SmallDocumentBlock ; import org . apache . poi . util . HexDump ; public class POIFSDocument implements BATManaged , BlockWritable , POIFSViewable { private DocumentProperty _property ; private int _size ; private SmallBlockStore _small_store ; private BigBlockStore _big_store ; public POIFSDocument ( final String name , final RawDataBlock [ ] blocks , final int length ) throws IOException { _size = length ; _big_store = new BigBlockStore ( blocks ) ; _property = new DocumentProperty ( name , _size ) ; _small_store = new SmallBlockStore ( new BlockWritable [ 0 ] ) ; _property . setDocument ( this ) ; } public POIFSDocument ( final String name , final SmallDocumentBlock [ ] blocks , final int length ) { _size = length ; try { _big_store = new BigBlockStore ( new RawDataBlock [ 0 ] ) ; } catch ( IOException ignored ) { } _property = new DocumentProperty ( name , _size ) ; _small_store = new SmallBlockStore ( blocks ) ; _property . setDocument ( this ) ; } public POIFSDocument ( final String name , final ListManagedBlock [ ] blocks , final int length ) throws IOException { _size = length ; _property = new DocumentProperty ( name , _size ) ; _property . setDocument ( this ) ; if ( Property . isSmall ( _size ) ) { _big_store = new BigBlockStore ( new RawDataBlock [ 0 ] ) ; _small_store = new SmallBlockStore ( blocks ) ; } else { _big_store = new BigBlockStore ( blocks ) ; _small_store = new SmallBlockStore ( new BlockWritable [ 0 ] ) ; } } public POIFSDocument ( final String name , final InputStream stream ) throws IOException { List blocks = new ArrayList ( ) ; _size = 0 ; while ( true ) { DocumentBlock block = new DocumentBlock ( stream ) ; int blockSize = block . size ( ) ; if ( blockSize > 0 ) { blocks . add ( block ) ; _size += blockSize ; } if ( block . partiallyRead ( ) ) { break ; } } DocumentBlock [ ] bigBlocks = ( DocumentBlock [ ] ) blocks . toArray ( new DocumentBlock [ 0 ] ) ; _big_store = new BigBlockStore ( bigBlocks ) ; _property = new DocumentProperty ( name , _size ) ; _property . setDocument ( this ) ; if ( _property . shouldUseSmallBlocks ( ) ) { _small_store = new SmallBlockStore ( SmallDocumentBlock . convert ( bigBlocks , _size ) ) ; _big_store = new BigBlockStore ( new DocumentBlock [ 0 ] ) ; } else { _small_store = new SmallBlockStore ( new BlockWritable [ 0 ] ) ; } } public POIFSDocument ( final String name , final int size , final POIFSDocumentPath path , final POIFSWriterListener writer ) throws IOException { _size = size ; _property = new DocumentProperty ( name , _size ) ; _property . setDocument ( this ) ; if ( _property . shouldUseSmallBlocks ( ) ) { _small_store = new SmallBlockStore ( path , name , size , writer ) ; _big_store = new BigBlockStore ( new Object [ 0 ] ) ; } else { _small_store = new SmallBlockStore ( new BlockWritable [ 0 ] ) ; _big_store = new BigBlockStore ( path , name , size , writer ) ; } } public BlockWritable [ ] getSmallBlocks ( ) { return _small_store . getBlocks ( ) ; } public int getSize ( ) { return _size ; } void read ( final byte [ ] buffer , final int offset ) { if ( _property . shouldUseSmallBlocks ( ) ) { SmallDocumentBlock . read ( _small_store . getBlocks ( ) , buffer , offset ) ; } else { DocumentBlock . read ( _big_store . getBlocks ( ) , buffer , offset ) ; } } DocumentProperty getDocumentProperty ( ) { return _property ; } public void writeBlocks ( final OutputStream stream ) throws IOException { _big_store . writeBlocks ( stream ) ; } public int countBlocks ( ) { return _big_store . countBlocks ( ) ; } public void setStartBlock ( final int index ) { _property . setStartBlock ( index ) ; } public Object [ ] getViewableArray ( ) { Object [ ] results = new Object [ 1 ] ; String result ; try { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; BlockWritable [ ] blocks = null ; if ( _big_store . isValid ( ) ) { blocks = _big_store . getBlocks ( ) ; } else if ( _small_store . isValid ( ) ) { blocks = _small_store . getBlocks ( ) ; } if ( blocks != null ) { for ( int k = 0 ; k < blocks . length ; k ++ ) { blocks [ k ] . writeBlocks ( output ) ; } byte [ ] data = output . toByteArray ( ) ; if ( data . length > _property . getSize ( ) ) { byte [ ] tmp = new byte [ _property . getSize ( ) ] ; System . arraycopy ( data , 0 , tmp , 0 , tmp . length ) ; data = tmp ; } output = new ByteArrayOutputStream ( ) ; HexDump . dump ( data , 0 , output , 0 ) ; result = output . toString ( ) ; } else { result = "<NO DATA>" ; } } catch ( IOException e ) { result = e . getMessage ( ) ; } results [ 0 ] = result ; return results ; } public Iterator getViewableIterator ( ) { return Collections . EMPTY_LIST . iterator ( ) ; } public boolean preferArray ( ) { return true ; } public String getShortDescription ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "Document: \"" ) . append ( _property . getName ( ) ) . append ( "\"" ) ; buffer . append ( " size = " ) . append ( getSize ( ) ) ; return buffer . toString ( ) ; } private class SmallBlockStore { private SmallDocumentBlock [ ] smallBlocks ; private POIFSDocumentPath path ; private String name ; private int size ; private POIFSWriterListener writer ; SmallBlockStore ( final Object [ ] blocks ) { smallBlocks = new SmallDocumentBlock [ blocks . length ] ; for ( int j = 0 ; j < blocks . length ; j ++ ) { smallBlocks [ j ] = ( SmallDocumentBlock ) blocks [ j ] ; } this . path = null ; this . name = null ; this . size = - 1 ; this . writer = null ; } SmallBlockStore ( final POIFSDocumentPath path , final String name , final int size , final POIFSWriterListener writer ) { smallBlocks = new SmallDocumentBlock [ 0 ] ; this . path = path ; this . name = name ; this . size = size ; this . writer = writer ; } boolean isValid ( ) { return ( ( smallBlocks . length > 0 ) || ( writer != null ) ) ; } BlockWritable [ ] getBlocks ( ) { if ( isValid ( ) && ( writer != null ) ) { ByteArrayOutputStream stream = new ByteArrayOutputStream ( size ) ; DocumentOutputStream dstream = new DocumentOutputStream ( stream , size ) ; writer . processPOIFSWriterEvent ( new POIFSWriterEvent ( dstream , path , name , size ) ) ; smallBlocks = SmallDocumentBlock . convert ( stream . toByteArray ( ) , size ) ; } return smallBlocks ; } } private class BigBlockStore { private DocumentBlock [ ] bigBlocks ; private POIFSDocumentPath path ; private String name ; private int size ; private POIFSWriterListener writer ; BigBlockStore ( final Object [ ] blocks ) throws IOException { bigBlocks = new DocumentBlock [ blocks . length ] ; for ( int j = 0 ; j < blocks . length ; j ++ ) { if ( blocks [ j ] instanceof DocumentBlock ) { bigBlocks [ j ] = ( DocumentBlock ) blocks [ j ] ; } else { bigBlocks [ j ] = new DocumentBlock ( ( RawDataBlock ) blocks [ j ] ) ; } } this . path = null ; this . name = null ; this . size = - 1 ; this . writer = null ; } BigBlockStore ( final POIFSDocumentPath path , final String name , final int size , final POIFSWriterListener writer ) { bigBlocks = new DocumentBlock [ 0 ] ; this . path = path ; this . name = name ; this . size = size ; this . writer = writer ; } boolean isValid ( ) { return ( ( bigBlocks . length > 0 ) || ( writer != null ) ) ; } DocumentBlock [ ] getBlocks ( ) { if ( isValid ( ) && ( writer != null ) ) { ByteArrayOutputStream stream = new ByteArrayOutputStream ( size ) ; DocumentOutputStream dstream = new DocumentOutputStream ( stream , size ) ; writer . processPOIFSWriterEvent ( new POIFSWriterEvent ( dstream , path , name , size ) ) ; bigBlocks = DocumentBlock . convert ( stream . toByteArray ( ) , size ) ; } return bigBlocks ; } void writeBlocks ( OutputStream stream ) throws IOException { if ( isValid ( ) ) { if ( writer != null ) { DocumentOutputStream dstream = new DocumentOutputStream ( stream , size ) ; writer . processPOIFSWriterEvent ( new POIFSWriterEvent ( dstream , path , name , size ) ) ; dstream . writeFiller ( countBlocks ( ) * POIFSConstants . BIG_BLOCK_SIZE , DocumentBlock . getFillByte ( ) ) ; } else { for ( int k = 0 ; k < bigBlocks . length ; k ++ ) { bigBlocks [ k ] . writeBlocks ( stream ) ; } } } } int countBlocks ( ) { int rval = 0 ; if ( isValid ( ) ) { if ( writer != null ) { rval = ( size + POIFSConstants . BIG_BLOCK_SIZE - 1 ) / POIFSConstants . BIG_BLOCK_SIZE ; } else { rval = bigBlocks . length ; } } return rval ; } } } 	0	['16', '1', '0', '20', '55', '0', '9', '14', '14', '0.5', '453', '1', '3', '0', '0.198863636', '0', '0', '27.0625', '6', '1.0625', '0']
package org . apache . poi . hssf . record ; public interface CellValueRecordInterface { public int getRow ( ) ; public short getColumn ( ) ; public void setRow ( int row ) ; public void setColumn ( short col ) ; public void setXFIndex ( short xf ) ; public short getXFIndex ( ) ; public boolean isBefore ( CellValueRecordInterface i ) ; public boolean isAfter ( CellValueRecordInterface i ) ; public boolean isEqual ( CellValueRecordInterface i ) ; public Object clone ( ) ; } 	0	['10', '1', '0', '13', '10', '45', '13', '0', '10', '2', '10', '0', '0', '0', '0.4', '0', '0', '0', '1', '1', '0']
package org . apache . poi . hssf . eventmodel ; import org . apache . poi . hssf . model . Model ; public interface ModelFactoryListener { public boolean process ( Model model ) ; } 	0	['1', '1', '0', '2', '1', '0', '1', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . poi . poifs . storage ; import java . io . IOException ; public interface ListManagedBlock { public byte [ ] getData ( ) throws IOException ; } 	0	['1', '1', '0', '13', '1', '0', '13', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . poi . ddf ; public interface EscherSerializationListener { void beforeRecordSerialize ( int offset , short recordId , EscherRecord record ) ; void afterRecordSerialize ( int offset , short recordId , int size , EscherRecord record ) ; } 	0	['2', '1', '0', '19', '2', '1', '19', '1', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . poi . poifs . eventfilesystem ; public interface POIFSReaderListener { public void processPOIFSReaderEvent ( POIFSReaderEvent event ) ; } 	0	['1', '1', '0', '4', '1', '0', '3', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . poi . ddf ; import org . apache . poi . util . HexDump ; import org . apache . poi . util . LittleEndian ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . io . PrintWriter ; public class EscherContainerRecord extends EscherRecord { public static final short DGG_CONTAINER = ( short ) 0xF000 ; public static final short BSTORE_CONTAINER = ( short ) 0xF001 ; public static final short DG_CONTAINER = ( short ) 0xF002 ; public static final short SPGR_CONTAINER = ( short ) 0xF003 ; public static final short SP_CONTAINER = ( short ) 0xF004 ; public static final short SOLVER_CONTAINER = ( short ) 0xF005 ; private List childRecords = new ArrayList ( ) ; public int fillFields ( byte [ ] data , int offset , EscherRecordFactory recordFactory ) { int bytesRemaining = readHeader ( data , offset ) ; int bytesWritten = 8 ; offset += 8 ; while ( bytesRemaining > 0 && offset < data . length ) { EscherRecord child = recordFactory . createRecord ( data , offset ) ; int childBytesWritten = child . fillFields ( data , offset , recordFactory ) ; bytesWritten += childBytesWritten ; offset += childBytesWritten ; bytesRemaining -= childBytesWritten ; getChildRecords ( ) . add ( child ) ; if ( offset >= data . length && bytesRemaining > 0 ) { System . out . println ( "WARNING: " + bytesRemaining + " bytes remaining but no space left" ) ; } } return bytesWritten ; } public int serialize ( int offset , byte [ ] data , EscherSerializationListener listener ) { listener . beforeRecordSerialize ( offset , getRecordId ( ) , this ) ; LittleEndian . putShort ( data , offset , getOptions ( ) ) ; LittleEndian . putShort ( data , offset + 2 , getRecordId ( ) ) ; int remainingBytes = 0 ; for ( Iterator iterator = getChildRecords ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { EscherRecord r = ( EscherRecord ) iterator . next ( ) ; remainingBytes += r . getRecordSize ( ) ; } LittleEndian . putInt ( data , offset + 4 , remainingBytes ) ; int pos = offset + 8 ; for ( Iterator iterator = getChildRecords ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { EscherRecord r = ( EscherRecord ) iterator . next ( ) ; pos += r . serialize ( pos , data , listener ) ; } listener . afterRecordSerialize ( pos , getRecordId ( ) , pos - offset , this ) ; return pos - offset ; } public int getRecordSize ( ) { int childRecordsSize = 0 ; for ( Iterator iterator = getChildRecords ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { EscherRecord r = ( EscherRecord ) iterator . next ( ) ; childRecordsSize += r . getRecordSize ( ) ; } return 8 + childRecordsSize ; } public List getChildRecords ( ) { return childRecords ; } public void setChildRecords ( List childRecords ) { this . childRecords = childRecords ; } public String getRecordName ( ) { switch ( ( short ) getRecordId ( ) ) { case DGG_CONTAINER : return "DggContainer" ; case BSTORE_CONTAINER : return "BStoreContainer" ; case DG_CONTAINER : return "DgContainer" ; case SPGR_CONTAINER : return "SpgrContainer" ; case SP_CONTAINER : return "SpContainer" ; case SOLVER_CONTAINER : return "SolverContainer" ; default : return "Container 0x" + HexDump . toHex ( getRecordId ( ) ) ; } } public void display ( PrintWriter w , int indent ) { super . display ( w , indent ) ; for ( Iterator iterator = childRecords . iterator ( ) ; iterator . hasNext ( ) ; ) { EscherRecord escherRecord = ( EscherRecord ) iterator . next ( ) ; escherRecord . display ( w , indent + 1 ) ; } } public void addChildRecord ( EscherRecord record ) { this . childRecords . add ( record ) ; } public String toString ( ) { String nl = System . getProperty ( "line.separator" ) ; StringBuffer children = new StringBuffer ( ) ; if ( getChildRecords ( ) . size ( ) > 0 ) { children . append ( "  children: " + nl ) ; for ( Iterator iterator = getChildRecords ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { EscherRecord record = ( EscherRecord ) iterator . next ( ) ; children . append ( record . toString ( ) ) ; } } return getClass ( ) . getName ( ) + " (" + getRecordName ( ) + "):" + nl + "  isContainer: " + isContainerRecord ( ) + nl + "  options: 0x" + HexDump . toHex ( getOptions ( ) ) + nl + "  recordId: 0x" + HexDump . toHex ( getRecordId ( ) ) + nl + "  numchildren: " + getChildRecords ( ) . size ( ) + nl + children . toString ( ) ; } public EscherSpRecord getChildById ( short recordId ) { for ( Iterator iterator = childRecords . iterator ( ) ; iterator . hasNext ( ) ; ) { EscherRecord escherRecord = ( EscherRecord ) iterator . next ( ) ; if ( escherRecord . getRecordId ( ) == recordId ) return ( EscherSpRecord ) escherRecord ; } return null ; } } 	0	['11', '2', '0', '14', '46', '25', '8', '6', '11', '0.957142857', '366', '0.142857143', '0', '0.655172414', '0.222222222', '1', '6', '31.63636364', '3', '1.8182', '0']
package org . apache . poi . util ; public class BitField { private final int _mask ; private final int _shift_count ; public BitField ( final int mask ) { _mask = mask ; int count = 0 ; int bit_pattern = mask ; if ( bit_pattern != 0 ) { while ( ( bit_pattern & 1 ) == 0 ) { count ++ ; bit_pattern >>= 1 ; } } _shift_count = count ; } public int getValue ( final int holder ) { return getRawValue ( holder ) > > _shift_count ; } public short getShortValue ( final short holder ) { return ( short ) getValue ( holder ) ; } public int getRawValue ( final int holder ) { return ( holder & _mask ) ; } public short getShortRawValue ( final short holder ) { return ( short ) getRawValue ( holder ) ; } public boolean isSet ( final int holder ) { return ( holder & _mask ) != 0 ; } public boolean isAllSet ( final int holder ) { return ( holder & _mask ) == _mask ; } public int setValue ( final int holder , final int value ) { return ( holder & ~ _mask ) | ( ( value << _shift_count ) & _mask ) ; } public short setShortValue ( final short holder , final short value ) { return ( short ) setValue ( holder , value ) ; } public int clear ( final int holder ) { return holder & ~ _mask ; } public short clearShort ( final short holder ) { return ( short ) clear ( holder ) ; } public byte clearByte ( final byte holder ) { return ( byte ) clear ( holder ) ; } public int set ( final int holder ) { return holder | _mask ; } public short setShort ( final short holder ) { return ( short ) set ( holder ) ; } public byte setByte ( final byte holder ) { return ( byte ) set ( holder ) ; } public int setBoolean ( final int holder , final boolean flag ) { return flag ? set ( holder ) : clear ( holder ) ; } public short setShortBoolean ( final short holder , final boolean flag ) { return flag ? setShort ( holder ) : clearShort ( holder ) ; } public byte setByteBoolean ( final byte holder , final boolean flag ) { return flag ? setByte ( holder ) : clearByte ( holder ) ; } } 	0	['18', '1', '0', '34', '19', '107', '34', '0', '18', '0.382352941', '170', '1', '0', '0', '0.433333333', '0', '0', '8.333333333', '2', '1.2222', '0']
package org . apache . poi . util ; import java . io . InputStream ; import java . io . IOException ; public class BlockingInputStream extends InputStream { protected InputStream is ; public BlockingInputStream ( InputStream is ) { this . is = is ; } public int available ( ) throws IOException { return is . available ( ) ; } public void close ( ) throws IOException { is . close ( ) ; } public void mark ( int readLimit ) { is . mark ( readLimit ) ; } public boolean markSupported ( ) { return is . markSupported ( ) ; } public int read ( ) throws IOException { return is . read ( ) ; } public int read ( byte [ ] bf ) throws IOException { int i = 0 ; int b = 4611 ; while ( i < bf . length ) { b = is . read ( ) ; if ( b == - 1 ) break ; bf [ i ++ ] = ( byte ) b ; } if ( i == 0 && b == - 1 ) return - 1 ; return i ; } public int read ( byte [ ] bf , int s , int l ) throws IOException { return is . read ( bf , s , l ) ; } public void reset ( ) throws IOException { is . reset ( ) ; } public long skip ( long n ) throws IOException { return is . skip ( n ) ; } } 	0	['10', '2', '0', '0', '19', '0', '0', '0', '10', '0', '86', '1', '0', '0.5', '0.32', '1', '2', '7.5', '1', '0.9', '0']
package org . apache . poi . util ; import java . util . * ; public class NullLogger extends POILogger { public void initialize ( final String cat ) { } public void log ( final int level , final Object obj1 ) { } public boolean check ( final int level ) { return false ; } public void log ( final int level , final Object obj1 , final Object obj2 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 ) { } public void log ( final int level , final Object obj1 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Throwable exception ) { } public void log ( final int level , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 , final Object obj5 , final Object obj6 , final Object obj7 , final Object obj8 , final Throwable exception ) { } public void logFormatted ( final int level , final String message , final Object obj1 ) { } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 ) { } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 ) { } public void logFormatted ( final int level , final String message , final Object obj1 , final Object obj2 , final Object obj3 , final Object obj4 ) { } } 	0	['23', '2', '0', '2', '24', '253', '1', '1', '23', '2', '49', '0', '0', '0.52173913', '0.669565217', '1', '2', '1.130434783', '1', '0.9565', '0']
package org . apache . poi . hpsf ; public class NoPropertySetStreamException extends HPSFException { public NoPropertySetStreamException ( ) { super ( ) ; } public NoPropertySetStreamException ( final String msg ) { super ( msg ) ; } public NoPropertySetStreamException ( final Throwable reason ) { super ( reason ) ; } public NoPropertySetStreamException ( final String msg , final Throwable reason ) { super ( msg , reason ) ; } } 	0	['4', '4', '0', '3', '8', '6', '2', '1', '4', '2', '20', '0', '0', '1', '0.666666667', '0', '0', '4', '0', '0', '0']
package org . apache . poi . ddf ; import org . apache . poi . hssf . record . RecordFormatException ; import org . apache . poi . util . HexDump ; import org . apache . poi . util . LittleEndian ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . InputStream ; import java . io . IOException ; import java . util . zip . InflaterInputStream ; import java . util . zip . DeflaterOutputStream ; public class EscherBlipRecord extends EscherRecord { public static final short RECORD_ID_START = ( short ) 0xF018 ; public static final short RECORD_ID_END = ( short ) 0xF117 ; public static final String RECORD_DESCRIPTION = "msofbtBlip" ; private static final int HEADER_SIZE = 8 ; private byte [ ] field_1_secondaryUID ; private int field_2_cacheOfSize ; private int field_3_boundaryTop ; private int field_4_boundaryLeft ; private int field_5_boundaryWidth ; private int field_6_boundaryHeight ; private int field_7_width ; private int field_8_height ; private int field_9_cacheOfSavedSize ; private byte field_10_compressionFlag ; private byte field_11_filter ; private byte [ ] field_12_data ; public int fillFields ( byte [ ] data , int offset , EscherRecordFactory recordFactory ) { int bytesAfterHeader = readHeader ( data , offset ) ; int pos = offset + HEADER_SIZE ; int size = 0 ; field_1_secondaryUID = new byte [ 16 ] ; System . arraycopy ( data , pos + size , field_1_secondaryUID , 0 , 16 ) ; size += 16 ; field_2_cacheOfSize = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; field_3_boundaryTop = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; field_4_boundaryLeft = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; field_5_boundaryWidth = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; field_6_boundaryHeight = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; field_7_width = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; field_8_height = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; field_9_cacheOfSavedSize = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; field_10_compressionFlag = data [ pos + size ] ; size ++ ; field_11_filter = data [ pos + size ] ; size ++ ; int bytesRemaining = bytesAfterHeader - size ; field_12_data = new byte [ bytesRemaining ] ; System . arraycopy ( data , pos + size , field_12_data , 0 , bytesRemaining ) ; return bytesRemaining + HEADER_SIZE + bytesAfterHeader ; } public int serialize ( int offset , byte [ ] data , EscherSerializationListener listener ) { listener . beforeRecordSerialize ( offset , getRecordId ( ) , this ) ; LittleEndian . putShort ( data , offset , getOptions ( ) ) ; LittleEndian . putShort ( data , offset + 2 , getRecordId ( ) ) ; int remainingBytes = field_12_data . length + 36 ; LittleEndian . putInt ( data , offset + 4 , remainingBytes ) ; int pos = offset + HEADER_SIZE ; System . arraycopy ( field_1_secondaryUID , 0 , data , pos , 16 ) ; pos += 16 ; LittleEndian . putInt ( data , pos , field_2_cacheOfSize ) ; pos += 4 ; LittleEndian . putInt ( data , pos , field_3_boundaryTop ) ; pos += 4 ; LittleEndian . putInt ( data , pos , field_4_boundaryLeft ) ; pos += 4 ; LittleEndian . putInt ( data , pos , field_5_boundaryWidth ) ; pos += 4 ; LittleEndian . putInt ( data , pos , field_6_boundaryHeight ) ; pos += 4 ; LittleEndian . putInt ( data , pos , field_7_width ) ; pos += 4 ; LittleEndian . putInt ( data , pos , field_8_height ) ; pos += 4 ; LittleEndian . putInt ( data , pos , field_9_cacheOfSavedSize ) ; pos += 4 ; data [ pos ++ ] = field_10_compressionFlag ; data [ pos ++ ] = field_11_filter ; System . arraycopy ( field_12_data , 0 , data , pos , field_12_data . length ) ; pos += field_12_data . length ; listener . afterRecordSerialize ( pos , getRecordId ( ) , pos - offset , this ) ; return pos - offset ; } public int getRecordSize ( ) { return 58 + field_12_data . length ; } public String getRecordName ( ) { return "Blip" ; } public byte [ ] getSecondaryUID ( ) { return field_1_secondaryUID ; } public void setSecondaryUID ( byte [ ] field_1_secondaryUID ) { this . field_1_secondaryUID = field_1_secondaryUID ; } public int getCacheOfSize ( ) { return field_2_cacheOfSize ; } public void setCacheOfSize ( int field_2_cacheOfSize ) { this . field_2_cacheOfSize = field_2_cacheOfSize ; } public int getBoundaryTop ( ) { return field_3_boundaryTop ; } public void setBoundaryTop ( int field_3_boundaryTop ) { this . field_3_boundaryTop = field_3_boundaryTop ; } public int getBoundaryLeft ( ) { return field_4_boundaryLeft ; } public void setBoundaryLeft ( int field_4_boundaryLeft ) { this . field_4_boundaryLeft = field_4_boundaryLeft ; } public int getBoundaryWidth ( ) { return field_5_boundaryWidth ; } public void setBoundaryWidth ( int field_5_boundaryWidth ) { this . field_5_boundaryWidth = field_5_boundaryWidth ; } public int getBoundaryHeight ( ) { return field_6_boundaryHeight ; } public void setBoundaryHeight ( int field_6_boundaryHeight ) { this . field_6_boundaryHeight = field_6_boundaryHeight ; } public int getWidth ( ) { return field_7_width ; } public void setWidth ( int width ) { this . field_7_width = width ; } public int getHeight ( ) { return field_8_height ; } public void setHeight ( int height ) { this . field_8_height = height ; } public int getCacheOfSavedSize ( ) { return field_9_cacheOfSavedSize ; } public void setCacheOfSavedSize ( int field_9_cacheOfSavedSize ) { this . field_9_cacheOfSavedSize = field_9_cacheOfSavedSize ; } public byte getCompressionFlag ( ) { return field_10_compressionFlag ; } public void setCompressionFlag ( byte field_10_compressionFlag ) { this . field_10_compressionFlag = field_10_compressionFlag ; } public byte getFilter ( ) { return field_11_filter ; } public void setFilter ( byte field_11_filter ) { this . field_11_filter = field_11_filter ; } public byte [ ] getData ( ) { return field_12_data ; } public void setData ( byte [ ] field_12_data ) { this . field_12_data = field_12_data ; } public String toString ( ) { String nl = System . getProperty ( "line.separator" ) ; String extraData ; ByteArrayOutputStream b = new ByteArrayOutputStream ( ) ; try { HexDump . dump ( this . field_12_data , 0 , b , 0 ) ; extraData = b . toString ( ) ; } catch ( Exception e ) { extraData = e . toString ( ) ; } return getClass ( ) . getName ( ) + ":" + nl + "  RecordId: 0x" + HexDump . toHex ( getRecordId ( ) ) + nl + "  Options: 0x" + HexDump . toHex ( getOptions ( ) ) + nl + "  Secondary UID: " + HexDump . toHex ( field_1_secondaryUID ) + nl + "  CacheOfSize: " + field_2_cacheOfSize + nl + "  BoundaryTop: " + field_3_boundaryTop + nl + "  BoundaryLeft: " + field_4_boundaryLeft + nl + "  BoundaryWidth: " + field_5_boundaryWidth + nl + "  BoundaryHeight: " + field_6_boundaryHeight + nl + "  X: " + field_7_width + nl + "  Y: " + field_8_height + nl + "  CacheOfSavedSize: " + field_9_cacheOfSavedSize + nl + "  CompressionFlag: " + field_10_compressionFlag + nl + "  Filter: " + field_11_filter + nl + "  Data:" + nl + extraData ; } public static byte [ ] compress ( byte [ ] data ) { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; DeflaterOutputStream deflaterOutputStream = new DeflaterOutputStream ( out ) ; try { for ( int i = 0 ; i < data . length ; i ++ ) deflaterOutputStream . write ( data [ i ] ) ; } catch ( IOException e ) { throw new RecordFormatException ( e . toString ( ) ) ; } return out . toByteArray ( ) ; } public static byte [ ] decompress ( byte [ ] data , int pos , int length ) { byte [ ] compressedData = new byte [ length ] ; System . arraycopy ( data , pos + 50 , compressedData , 0 , length ) ; InputStream compressedInputStream = new ByteArrayInputStream ( compressedData ) ; InflaterInputStream inflaterInputStream = new InflaterInputStream ( compressedInputStream ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; int c ; try { while ( ( c = inflaterInputStream . read ( ) ) != - 1 ) out . write ( c ) ; } catch ( IOException e ) { throw new RecordFormatException ( e . toString ( ) ) ; } return out . toByteArray ( ) ; } } 	0	['32', '2', '0', '7', '64', '312', '1', '6', '32', '0.909274194', '614', '0.8125', '0', '0.38', '0.265625', '1', '5', '17.6875', '1', '0.9688', '0']
package org . apache . poi . poifs . filesystem ; import org . apache . poi . poifs . property . Property ; public abstract class EntryNode implements Entry { private Property _property ; private DirectoryNode _parent ; protected EntryNode ( final Property property , final DirectoryNode parent ) { _property = property ; _parent = parent ; } protected Property getProperty ( ) { return _property ; } protected boolean isRoot ( ) { return ( _parent == null ) ; } protected abstract boolean isDeleteOK ( ) ; public String getName ( ) { return _property . getName ( ) ; } public boolean isDirectoryEntry ( ) { return false ; } public boolean isDocumentEntry ( ) { return false ; } public DirectoryEntry getParent ( ) { return _parent ; } public boolean delete ( ) { boolean rval = false ; if ( ( ! isRoot ( ) ) && isDeleteOK ( ) ) { rval = _parent . deleteEntry ( this ) ; } return rval ; } public boolean renameTo ( final String newName ) { boolean rval = false ; if ( ! isRoot ( ) ) { rval = _parent . changeName ( getName ( ) , newName ) ; } return rval ; } } 	0	['10', '1', '2', '6', '14', '19', '3', '4', '6', '0.611111111', '71', '1', '2', '0', '0.325', '0', '0', '5.9', '3', '1.3', '0']
package org . apache . poi . hssf . util ; import java . util . HashMap ; import java . util . Map ; public class SheetReferences { Map map ; public SheetReferences ( ) { map = new HashMap ( 5 ) ; } public void addSheetReference ( String sheetName , int number ) { map . put ( new Integer ( number ) , sheetName ) ; } public String getSheetName ( int number ) { return ( String ) map . get ( new Integer ( number ) ) ; } } 	0	['3', '1', '0', '3', '8', '0', '3', '0', '3', '0', '32', '0', '0', '0', '0.666666667', '0', '0', '9.333333333', '1', '0.6667', '0']
package org . apache . poi . util ; import org . apache . poi . util . LittleEndian . BufferUnderrunException ; import java . io . * ; public class ByteField implements FixedField { private static final byte _default_value = 0 ; private byte _value ; private final int _offset ; public ByteField ( final int offset ) throws ArrayIndexOutOfBoundsException { this ( offset , _default_value ) ; } public ByteField ( final int offset , final byte value ) throws ArrayIndexOutOfBoundsException { if ( offset < 0 ) { throw new ArrayIndexOutOfBoundsException ( "offset cannot be negative" ) ; } _offset = offset ; set ( value ) ; } public ByteField ( final int offset , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; readFromBytes ( data ) ; } public ByteField ( final int offset , final byte value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset , value ) ; writeToBytes ( data ) ; } public byte get ( ) { return _value ; } public void set ( final byte value ) { _value = value ; } public void set ( final byte value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { set ( value ) ; writeToBytes ( data ) ; } public void readFromBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = data [ _offset ] ; } public void readFromStream ( final InputStream stream ) throws IOException , BufferUnderrunException { _value = ( LittleEndian . readFromStream ( stream , LittleEndianConsts . BYTE_SIZE ) ) [ 0 ] ; } public void writeToBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { data [ _offset ] = _value ; } public String toString ( ) { return String . valueOf ( _value ) ; } } 	0	['11', '1', '0', '4', '15', '21', '1', '3', '11', '0.533333333', '90', '1', '0', '0', '0.454545455', '0', '0', '6.909090909', '1', '0.6364', '0']
package org . apache . poi . hssf . usermodel ; import org . apache . poi . util . POILogFactory ; import org . apache . poi . util . POILogger ; import java . awt . * ; import java . awt . font . FontRenderContext ; import java . awt . font . GlyphVector ; import java . awt . font . TextLayout ; import java . awt . geom . AffineTransform ; import java . awt . geom . Area ; import java . awt . geom . GeneralPath ; import java . awt . image . BufferedImage ; import java . awt . image . BufferedImageOp ; import java . awt . image . ImageObserver ; import java . awt . image . RenderedImage ; import java . awt . image . renderable . RenderableImage ; import java . text . AttributedCharacterIterator ; import java . util . Map ; public class EscherGraphics2d extends Graphics2D { private EscherGraphics escherGraphics ; private BufferedImage img ; private AffineTransform trans ; private Stroke stroke ; private Paint paint ; private Shape deviceclip ; private POILogger logger = POILogFactory . getLogger ( getClass ( ) ) ; public EscherGraphics2d ( EscherGraphics escherGraphics ) { this . escherGraphics = escherGraphics ; setImg ( new BufferedImage ( 1 , 1 , 2 ) ) ; setColor ( Color . black ) ; } public void addRenderingHints ( Map map ) { getG2D ( ) . addRenderingHints ( map ) ; } public void clearRect ( int i , int j , int k , int l ) { Paint paint1 = getPaint ( ) ; setColor ( getBackground ( ) ) ; fillRect ( i , j , k , l ) ; setPaint ( paint1 ) ; } public void clip ( Shape shape ) { if ( getDeviceclip ( ) != null ) { Area area = new Area ( getClip ( ) ) ; if ( shape != null ) area . intersect ( new Area ( shape ) ) ; shape = area ; } setClip ( shape ) ; } public void clipRect ( int x , int y , int width , int height ) { clip ( new Rectangle ( x , y , width , height ) ) ; } public void copyArea ( int x , int y , int width , int height , int dx , int dy ) { getG2D ( ) . copyArea ( x , y , width , height , dx , dy ) ; } public Graphics create ( ) { EscherGraphics2d g2d = new EscherGraphics2d ( escherGraphics ) ; return g2d ; } public void dispose ( ) { getEscherGraphics ( ) . dispose ( ) ; getG2D ( ) . dispose ( ) ; getImg ( ) . flush ( ) ; } public void draw ( Shape shape ) { if ( logger . check ( POILogger . WARN ) ) logger . log ( POILogger . WARN , "copyArea not supported" ) ; } public void drawArc ( int x , int y , int width , int height , int startAngle , int arcAngle ) { draw ( new java . awt . geom . Arc2D . Float ( x , y , width , height , startAngle , arcAngle , 0 ) ) ; } public void drawGlyphVector ( GlyphVector g , float x , float y ) { fill ( g . getOutline ( x , y ) ) ; } public boolean drawImage ( Image image , int dx1 , int dy1 , int dx2 , int dy2 , int sx1 , int sy1 , int sx2 , int sy2 , Color bgColor , ImageObserver imageobserver ) { if ( logger . check ( POILogger . WARN ) ) logger . log ( POILogger . WARN , "drawImage() not supported" ) ; return true ; } public boolean drawImage ( Image image , int dx1 , int dy1 , int dx2 , int dy2 , int sx1 , int sy1 , int sx2 , int sy2 , ImageObserver imageobserver ) { if ( logger . check ( POILogger . WARN ) ) logger . log ( POILogger . WARN , "drawImage() not supported" ) ; return drawImage ( image , dx1 , dy1 , dx2 , dy2 , sx1 , sy1 , sx2 , sy2 , null , imageobserver ) ; } public boolean drawImage ( Image image , int dx1 , int dy1 , int dx2 , int dy2 , Color bgColor , ImageObserver imageobserver ) { if ( logger . check ( POILogger . WARN ) ) logger . log ( POILogger . WARN , "drawImage() not supported" ) ; return true ; } public boolean drawImage ( Image img , int x , int y , int width , int height , ImageObserver observer ) { return drawImage ( img , x , y , width , height , null , observer ) ; } public boolean drawImage ( Image image , int x , int y , Color bgColor , ImageObserver imageobserver ) { return drawImage ( image , x , y , image . getWidth ( imageobserver ) , image . getHeight ( imageobserver ) , bgColor , imageobserver ) ; } public boolean drawImage ( Image image , int x , int y , ImageObserver imageobserver ) { return drawImage ( image , x , y , image . getWidth ( imageobserver ) , image . getHeight ( imageobserver ) , imageobserver ) ; } public boolean drawImage ( Image image , AffineTransform affinetransform , ImageObserver imageobserver ) { AffineTransform affinetransform1 = ( AffineTransform ) getTrans ( ) . clone ( ) ; getTrans ( ) . concatenate ( affinetransform ) ; drawImage ( image , 0 , 0 , imageobserver ) ; setTrans ( affinetransform1 ) ; return true ; } public void drawImage ( BufferedImage bufferedimage , BufferedImageOp op , int x , int y ) { BufferedImage img = op . filter ( bufferedimage , null ) ; drawImage ( ( ( Image ) ( img ) ) , new AffineTransform ( 1.0F , 0.0F , 0.0F , 1.0F , x , y ) , null ) ; } public void drawLine ( int x1 , int y1 , int x2 , int y2 ) { getEscherGraphics ( ) . drawLine ( x1 , y1 , x2 , y2 ) ; } public void drawOval ( int x , int y , int width , int height ) { getEscherGraphics ( ) . drawOval ( x , y , width , height ) ; } public void drawPolygon ( int xPoints [ ] , int yPoints [ ] , int nPoints ) { getEscherGraphics ( ) . drawPolygon ( xPoints , yPoints , nPoints ) ; } public void drawPolyline ( int xPoints [ ] , int yPoints [ ] , int nPoints ) { if ( nPoints > 0 ) { GeneralPath generalpath = new GeneralPath ( ) ; generalpath . moveTo ( xPoints [ 0 ] , yPoints [ 0 ] ) ; for ( int j = 1 ; j < nPoints ; j ++ ) generalpath . lineTo ( xPoints [ j ] , yPoints [ j ] ) ; draw ( generalpath ) ; } } public void drawRect ( int x , int y , int width , int height ) { escherGraphics . drawRect ( x , y , width , height ) ; } public void drawRenderableImage ( RenderableImage renderableimage , AffineTransform affinetransform ) { drawRenderedImage ( renderableimage . createDefaultRendering ( ) , affinetransform ) ; } public void drawRenderedImage ( RenderedImage renderedimage , AffineTransform affinetransform ) { BufferedImage bufferedimage = new BufferedImage ( renderedimage . getColorModel ( ) , renderedimage . getData ( ) . createCompatibleWritableRaster ( ) , false , null ) ; bufferedimage . setData ( renderedimage . getData ( ) ) ; drawImage ( bufferedimage , affinetransform , null ) ; } public void drawRoundRect ( int i , int j , int k , int l , int i1 , int j1 ) { draw ( new java . awt . geom . RoundRectangle2D . Float ( i , j , k , l , i1 , j1 ) ) ; } public void drawString ( String string , float x , float y ) { getEscherGraphics ( ) . drawString ( string , ( int ) x , ( int ) y ) ; } public void drawString ( String string , int x , int y ) { getEscherGraphics ( ) . drawString ( string , x , y ) ; } public void drawString ( AttributedCharacterIterator attributedcharacteriterator , float x , float y ) { TextLayout textlayout = new TextLayout ( attributedcharacteriterator , getFontRenderContext ( ) ) ; Paint paint1 = getPaint ( ) ; setColor ( getColor ( ) ) ; fill ( textlayout . getOutline ( AffineTransform . getTranslateInstance ( x , y ) ) ) ; setPaint ( paint1 ) ; } public void drawString ( AttributedCharacterIterator attributedcharacteriterator , int x , int y ) { drawString ( attributedcharacteriterator , x , y ) ; } public void fill ( Shape shape ) { if ( logger . check ( POILogger . WARN ) ) logger . log ( POILogger . WARN , "fill(Shape) not supported" ) ; } public void fillArc ( int i , int j , int k , int l , int i1 , int j1 ) { fill ( new java . awt . geom . Arc2D . Float ( i , j , k , l , i1 , j1 , 2 ) ) ; } public void fillOval ( int x , int y , int width , int height ) { escherGraphics . fillOval ( x , y , width , height ) ; } public void fillPolygon ( int xPoints [ ] , int yPoints [ ] , int nPoints ) { escherGraphics . fillPolygon ( xPoints , yPoints , nPoints ) ; } public void fillRect ( int x , int y , int width , int height ) { getEscherGraphics ( ) . fillRect ( x , y , width , height ) ; } public void fillRoundRect ( int x , int y , int width , int height , int arcWidth , int arcHeight ) { fill ( new java . awt . geom . RoundRectangle2D . Float ( x , y , width , height , arcWidth , arcHeight ) ) ; } public Color getBackground ( ) { return getEscherGraphics ( ) . getBackground ( ) ; } public Shape getClip ( ) { try { return getTrans ( ) . createInverse ( ) . createTransformedShape ( getDeviceclip ( ) ) ; } catch ( Exception _ex ) { return null ; } } public Rectangle getClipBounds ( ) { if ( getDeviceclip ( ) != null ) return getClip ( ) . getBounds ( ) ; else return null ; } public Color getColor ( ) { return escherGraphics . getColor ( ) ; } public Composite getComposite ( ) { return getG2D ( ) . getComposite ( ) ; } public GraphicsConfiguration getDeviceConfiguration ( ) { return getG2D ( ) . getDeviceConfiguration ( ) ; } public Font getFont ( ) { return getEscherGraphics ( ) . getFont ( ) ; } public FontMetrics getFontMetrics ( Font font ) { return getEscherGraphics ( ) . getFontMetrics ( font ) ; } public FontRenderContext getFontRenderContext ( ) { getG2D ( ) . setTransform ( getTrans ( ) ) ; return getG2D ( ) . getFontRenderContext ( ) ; } public Paint getPaint ( ) { return paint ; } public Object getRenderingHint ( java . awt . RenderingHints . Key key ) { return getG2D ( ) . getRenderingHint ( key ) ; } public RenderingHints getRenderingHints ( ) { return getG2D ( ) . getRenderingHints ( ) ; } public Stroke getStroke ( ) { return stroke ; } public AffineTransform getTransform ( ) { return ( AffineTransform ) getTrans ( ) . clone ( ) ; } public boolean hit ( Rectangle rectangle , Shape shape , boolean flag ) { getG2D ( ) . setTransform ( getTrans ( ) ) ; getG2D ( ) . setStroke ( getStroke ( ) ) ; getG2D ( ) . setClip ( getClip ( ) ) ; return getG2D ( ) . hit ( rectangle , shape , flag ) ; } public void rotate ( double d ) { getTrans ( ) . rotate ( d ) ; } public void rotate ( double d , double d1 , double d2 ) { getTrans ( ) . rotate ( d , d1 , d2 ) ; } public void scale ( double d , double d1 ) { getTrans ( ) . scale ( d , d1 ) ; } public void setBackground ( Color c ) { getEscherGraphics ( ) . setBackground ( c ) ; } public void setClip ( int i , int j , int k , int l ) { setClip ( ( ( Shape ) ( new Rectangle ( i , j , k , l ) ) ) ) ; } public void setClip ( Shape shape ) { setDeviceclip ( getTrans ( ) . createTransformedShape ( shape ) ) ; } public void setColor ( Color c ) { escherGraphics . setColor ( c ) ; } public void setComposite ( Composite composite ) { getG2D ( ) . setComposite ( composite ) ; } public void setFont ( Font font ) { getEscherGraphics ( ) . setFont ( font ) ; } public void setPaint ( Paint paint1 ) { if ( paint1 != null ) { paint = paint1 ; if ( paint1 instanceof Color ) setColor ( ( Color ) paint1 ) ; } } public void setPaintMode ( ) { getEscherGraphics ( ) . setPaintMode ( ) ; } public void setRenderingHint ( java . awt . RenderingHints . Key key , Object obj ) { getG2D ( ) . setRenderingHint ( key , obj ) ; } public void setRenderingHints ( Map map ) { getG2D ( ) . setRenderingHints ( map ) ; } public void setStroke ( Stroke s ) { stroke = s ; } public void setTransform ( AffineTransform affinetransform ) { setTrans ( ( AffineTransform ) affinetransform . clone ( ) ) ; } public void setXORMode ( Color color1 ) { getEscherGraphics ( ) . setXORMode ( color1 ) ; } public void shear ( double d , double d1 ) { getTrans ( ) . shear ( d , d1 ) ; } public void transform ( AffineTransform affinetransform ) { getTrans ( ) . concatenate ( affinetransform ) ; } public void translate ( double d , double d1 ) { getTrans ( ) . translate ( d , d1 ) ; } public void translate ( int i , int j ) { getTrans ( ) . translate ( i , j ) ; } private EscherGraphics getEscherGraphics ( ) { return escherGraphics ; } private BufferedImage getImg ( ) { return img ; } private void setImg ( BufferedImage img ) { this . img = img ; } private Graphics2D getG2D ( ) { return ( Graphics2D ) img . getGraphics ( ) ; } private AffineTransform getTrans ( ) { return trans ; } private void setTrans ( AffineTransform trans ) { this . trans = trans ; } private Shape getDeviceclip ( ) { return deviceclip ; } private void setDeviceclip ( Shape deviceclip ) { this . deviceclip = deviceclip ; } } 	0	['80', '3', '0', '3', '153', '3060', '0', '3', '72', '0.839059675', '838', '1', '2', '0.529761905', '0.07962963', '2', '20', '9.3875', '3', '1.1375', '0']
package org . apache . poi . poifs . storage ; import java . io . IOException ; public interface BlockList { public void zap ( final int index ) ; public ListManagedBlock remove ( final int index ) throws IOException ; public ListManagedBlock [ ] fetchBlocks ( final int startBlock ) throws IOException ; public void setBAT ( final BlockAllocationTableReader bat ) throws IOException ; } 	0	['4', '1', '0', '6', '4', '6', '5', '2', '4', '2', '4', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . poi . poifs . property ; import java . io . IOException ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . storage . ListManagedBlock ; class PropertyFactory { private PropertyFactory ( ) { } static List convertToProperties ( ListManagedBlock [ ] blocks ) throws IOException { List properties = new ArrayList ( ) ; for ( int j = 0 ; j < blocks . length ; j ++ ) { byte [ ] data = blocks [ j ] . getData ( ) ; int property_count = data . length / POIFSConstants . PROPERTY_SIZE ; int offset = 0 ; for ( int k = 0 ; k < property_count ; k ++ ) { switch ( data [ offset + PropertyConstants . PROPERTY_TYPE_OFFSET ] ) { case PropertyConstants . DIRECTORY_TYPE : properties . add ( new DirectoryProperty ( properties . size ( ) , data , offset ) ) ; break ; case PropertyConstants . DOCUMENT_TYPE : properties . add ( new DocumentProperty ( properties . size ( ) , data , offset ) ) ; break ; case PropertyConstants . ROOT_TYPE : properties . add ( new RootProperty ( properties . size ( ) , data , offset ) ) ; break ; default : properties . add ( null ) ; break ; } offset += POIFSConstants . PROPERTY_SIZE ; } } return properties ; } } 	0	['2', '1', '0', '5', '10', '1', '1', '4', '0', '2', '82', '0', '0', '0', '0.5', '0', '0', '40', '1', '0.5', '0']
package org . apache . poi . hssf . usermodel ; public class HSSFPolygon extends HSSFShape { int [ ] xPoints ; int [ ] yPoints ; int drawAreaWidth = 100 ; int drawAreaHeight = 100 ; HSSFPolygon ( HSSFShape parent , HSSFAnchor anchor ) { super ( parent , anchor ) ; } public int [ ] getXPoints ( ) { return xPoints ; } public int [ ] getYPoints ( ) { return yPoints ; } public void setPoints ( int [ ] xPoints , int [ ] yPoints ) { this . xPoints = cloneArray ( xPoints ) ; this . yPoints = cloneArray ( yPoints ) ; } private int [ ] cloneArray ( int [ ] a ) { int [ ] result = new int [ a . length ] ; for ( int i = 0 ; i < a . length ; i ++ ) result [ i ] = a [ i ] ; return result ; } public void setPolygonDrawArea ( int width , int height ) { this . drawAreaWidth = width ; this . drawAreaHeight = height ; } public int getDrawAreaWidth ( ) { return drawAreaWidth ; } public int getDrawAreaHeight ( ) { return drawAreaHeight ; } } 	0	['8', '2', '0', '7', '9', '14', '5', '2', '6', '0.785714286', '73', '0', '0', '0.695652174', '0.325', '0', '0', '7.625', '2', '1', '0']
package org . apache . poi . poifs . filesystem ; public interface POIFSWriterListener { public void processPOIFSWriterEvent ( POIFSWriterEvent event ) ; } 	0	['1', '1', '0', '7', '1', '0', '6', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . poi . hssf . usermodel ; import org . apache . poi . util . POILogFactory ; import org . apache . poi . util . POILogger ; import org . apache . poi . hssf . util . HSSFColor ; import java . awt . * ; import java . awt . image . ImageObserver ; import java . text . AttributedCharacterIterator ; public class EscherGraphics extends Graphics { private HSSFShapeGroup escherGroup ; private HSSFWorkbook workbook ; private float verticalPointsPerPixel = 1.0f ; private float verticalPixelsPerPoint ; private Color foreground ; private Color background = Color . white ; private Font font ; private static POILogger logger = POILogFactory . getLogger ( EscherGraphics . class ) ; public EscherGraphics ( HSSFShapeGroup escherGroup , HSSFWorkbook workbook , Color forecolor , float verticalPointsPerPixel ) { this . escherGroup = escherGroup ; this . workbook = workbook ; this . verticalPointsPerPixel = verticalPointsPerPixel ; this . verticalPixelsPerPoint = 1 / verticalPointsPerPixel ; this . font = new Font ( "Arial" , 0 , 10 ) ; this . foreground = forecolor ; } EscherGraphics ( HSSFShapeGroup escherGroup , HSSFWorkbook workbook , Color foreground , Font font , float verticalPointsPerPixel ) { this . escherGroup = escherGroup ; this . workbook = workbook ; this . foreground = foreground ; this . font = font ; this . verticalPointsPerPixel = verticalPointsPerPixel ; this . verticalPixelsPerPoint = 1 / verticalPointsPerPixel ; } public void clearRect ( int x , int y , int width , int height ) { Color color = foreground ; setColor ( background ) ; fillRect ( x , y , width , height ) ; setColor ( color ) ; } public void clipRect ( int x , int y , int width , int height ) { if ( logger . check ( POILogger . WARN ) ) logger . log ( POILogger . WARN , "clipRect not supported" ) ; } public void copyArea ( int x , int y , int width , int height , int dx , int dy ) { if ( logger . check ( POILogger . WARN ) ) logger . log ( POILogger . WARN , "copyArea not supported" ) ; } public Graphics create ( ) { EscherGraphics g = new EscherGraphics ( escherGroup , workbook , foreground , font , verticalPointsPerPixel ) ; return g ; } public void dispose ( ) { } public void drawArc ( int x , int y , int width , int height , int startAngle , int arcAngle ) { if ( logger . check ( POILogger . WARN ) ) logger . log ( POILogger . WARN , "drawArc not supported" ) ; } public boolean drawImage ( Image img , int dx1 , int dy1 , int dx2 , int dy2 , int sx1 , int sy1 , int sx2 , int sy2 , Color bgcolor , ImageObserver observer ) { if ( logger . check ( POILogger . WARN ) ) logger . log ( POILogger . WARN , "drawImage not supported" ) ; return true ; } public boolean drawImage ( Image img , int dx1 , int dy1 , int dx2 , int dy2 , int sx1 , int sy1 , int sx2 , int sy2 , ImageObserver observer ) { if ( logger . check ( POILogger . WARN ) ) logger . log ( POILogger . WARN , "drawImage not supported" ) ; return true ; } public boolean drawImage ( Image image , int i , int j , int k , int l , Color color , ImageObserver imageobserver ) { return drawImage ( image , i , j , i + k , j + l , 0 , 0 , image . getWidth ( imageobserver ) , image . getHeight ( imageobserver ) , color , imageobserver ) ; } public boolean drawImage ( Image image , int i , int j , int k , int l , ImageObserver imageobserver ) { return drawImage ( image , i , j , i + k , j + l , 0 , 0 , image . getWidth ( imageobserver ) , image . getHeight ( imageobserver ) , imageobserver ) ; } public boolean drawImage ( Image image , int i , int j , Color color , ImageObserver imageobserver ) { return drawImage ( image , i , j , image . getWidth ( imageobserver ) , image . getHeight ( imageobserver ) , color , imageobserver ) ; } public boolean drawImage ( Image image , int i , int j , ImageObserver imageobserver ) { return drawImage ( image , i , j , image . getWidth ( imageobserver ) , image . getHeight ( imageobserver ) , imageobserver ) ; } public void drawLine ( int x1 , int y1 , int x2 , int y2 ) { HSSFSimpleShape shape = escherGroup . createShape ( new HSSFChildAnchor ( x1 , y1 , x2 , y2 ) ) ; shape . setShapeType ( HSSFSimpleShape . OBJECT_TYPE_LINE ) ; shape . setLineWidth ( 0 ) ; shape . setLineStyleColor ( foreground . getRed ( ) , foreground . getGreen ( ) , foreground . getBlue ( ) ) ; } public void drawOval ( int x , int y , int width , int height ) { HSSFSimpleShape shape = escherGroup . createShape ( new HSSFChildAnchor ( x , y , x + width , y + height ) ) ; shape . setShapeType ( HSSFSimpleShape . OBJECT_TYPE_OVAL ) ; shape . setLineWidth ( 0 ) ; shape . setLineStyleColor ( foreground . getRed ( ) , foreground . getGreen ( ) , foreground . getBlue ( ) ) ; shape . setNoFill ( true ) ; } public void drawPolygon ( int xPoints [ ] , int yPoints [ ] , int nPoints ) { int right = findBiggest ( xPoints ) ; int bottom = findBiggest ( yPoints ) ; int left = findSmallest ( xPoints ) ; int top = findSmallest ( yPoints ) ; HSSFPolygon shape = escherGroup . createPolygon ( new HSSFChildAnchor ( left , top , right , bottom ) ) ; shape . setPolygonDrawArea ( right - left , bottom - top ) ; shape . setPoints ( addToAll ( xPoints , - left ) , addToAll ( yPoints , - top ) ) ; shape . setLineStyleColor ( foreground . getRed ( ) , foreground . getGreen ( ) , foreground . getBlue ( ) ) ; shape . setLineWidth ( 0 ) ; shape . setNoFill ( true ) ; } private int [ ] addToAll ( int [ ] values , int amount ) { int [ ] result = new int [ values . length ] ; for ( int i = 0 ; i < values . length ; i ++ ) result [ i ] = values [ i ] + amount ; return result ; } public void drawPolyline ( int xPoints [ ] , int yPoints [ ] , int nPoints ) { if ( logger . check ( POILogger . WARN ) ) logger . log ( POILogger . WARN , "drawPolyline not supported" ) ; } public void drawRect ( int x , int y , int width , int height ) { if ( logger . check ( POILogger . WARN ) ) logger . log ( POILogger . WARN , "drawRect not supported" ) ; } public void drawRoundRect ( int x , int y , int width , int height , int arcWidth , int arcHeight ) { if ( logger . check ( POILogger . WARN ) ) logger . log ( POILogger . WARN , "drawRoundRect not supported" ) ; } public void drawString ( String str , int x , int y ) { if ( str == null || str . equals ( "" ) ) return ; Font excelFont = font ; if ( font . getName ( ) . equals ( "SansSerif" ) ) { excelFont = new Font ( "Arial" , font . getStyle ( ) , ( int ) ( font . getSize ( ) / verticalPixelsPerPoint ) ) ; } else { excelFont = new Font ( font . getName ( ) , font . getStyle ( ) , ( int ) ( font . getSize ( ) / verticalPixelsPerPoint ) ) ; } FontDetails d = StaticFontMetrics . getFontDetails ( excelFont ) ; int width = ( int ) ( ( d . getStringWidth ( str ) * 8 ) + 12 ) ; int height = ( int ) ( ( font . getSize ( ) / verticalPixelsPerPoint ) + 6 ) * 2 ; y -= ( font . getSize ( ) / verticalPixelsPerPoint ) + 2 * verticalPixelsPerPoint ; HSSFTextbox textbox = escherGroup . createTextbox ( new HSSFChildAnchor ( x , y , x + width , y + height ) ) ; textbox . setNoFill ( true ) ; textbox . setLineStyle ( HSSFShape . LINESTYLE_NONE ) ; HSSFRichTextString s = new HSSFRichTextString ( str ) ; HSSFFont hssfFont = matchFont ( excelFont ) ; s . applyFont ( hssfFont ) ; textbox . setString ( s ) ; } private HSSFFont matchFont ( Font font ) { HSSFColor hssfColor = workbook . getCustomPalette ( ) . findColor ( ( byte ) foreground . getRed ( ) , ( byte ) foreground . getGreen ( ) , ( byte ) foreground . getBlue ( ) ) ; if ( hssfColor == null ) hssfColor = workbook . getCustomPalette ( ) . findSimilarColor ( ( byte ) foreground . getRed ( ) , ( byte ) foreground . getGreen ( ) , ( byte ) foreground . getBlue ( ) ) ; boolean bold = ( font . getStyle ( ) & Font . BOLD ) != 0 ; boolean italic = ( font . getStyle ( ) & Font . ITALIC ) != 0 ; HSSFFont hssfFont = workbook . findFont ( bold ? HSSFFont . BOLDWEIGHT_BOLD : 0 , hssfColor . getIndex ( ) , ( short ) ( font . getSize ( ) * 20 ) , font . getName ( ) , italic , false , ( short ) 0 , ( byte ) 0 ) ; if ( hssfFont == null ) { hssfFont = workbook . createFont ( ) ; hssfFont . setBoldweight ( bold ? HSSFFont . BOLDWEIGHT_BOLD : 0 ) ; hssfFont . setColor ( hssfColor . getIndex ( ) ) ; hssfFont . setFontHeight ( ( short ) ( font . getSize ( ) * 20 ) ) ; hssfFont . setFontName ( font . getName ( ) ) ; hssfFont . setItalic ( italic ) ; hssfFont . setStrikeout ( false ) ; hssfFont . setTypeOffset ( ( short ) 0 ) ; hssfFont . setUnderline ( ( byte ) 0 ) ; } return hssfFont ; } public void drawString ( AttributedCharacterIterator iterator , int x , int y ) { if ( logger . check ( POILogger . WARN ) ) logger . log ( POILogger . WARN , "drawString not supported" ) ; } public void fillArc ( int x , int y , int width , int height , int startAngle , int arcAngle ) { if ( logger . check ( POILogger . WARN ) ) logger . log ( POILogger . WARN , "fillArc not supported" ) ; } public void fillOval ( int x , int y , int width , int height ) { HSSFSimpleShape shape = escherGroup . createShape ( new HSSFChildAnchor ( x , y , x + width , y + height ) ) ; shape . setShapeType ( HSSFSimpleShape . OBJECT_TYPE_OVAL ) ; shape . setLineStyle ( HSSFShape . LINESTYLE_NONE ) ; shape . setFillColor ( foreground . getRed ( ) , foreground . getGreen ( ) , foreground . getBlue ( ) ) ; shape . setLineStyleColor ( foreground . getRed ( ) , foreground . getGreen ( ) , foreground . getBlue ( ) ) ; } public void fillPolygon ( int xPoints [ ] , int yPoints [ ] , int nPoints ) { int right = findBiggest ( xPoints ) ; int bottom = findBiggest ( yPoints ) ; int left = findSmallest ( xPoints ) ; int top = findSmallest ( yPoints ) ; HSSFPolygon shape = escherGroup . createPolygon ( new HSSFChildAnchor ( left , top , right , bottom ) ) ; shape . setPolygonDrawArea ( right - left , bottom - top ) ; shape . setPoints ( addToAll ( xPoints , - left ) , addToAll ( yPoints , - top ) ) ; shape . setLineStyleColor ( foreground . getRed ( ) , foreground . getGreen ( ) , foreground . getBlue ( ) ) ; shape . setFillColor ( foreground . getRed ( ) , foreground . getGreen ( ) , foreground . getBlue ( ) ) ; } private int findBiggest ( int [ ] values ) { int result = Integer . MIN_VALUE ; for ( int i = 0 ; i < values . length ; i ++ ) { if ( values [ i ] > result ) result = values [ i ] ; } return result ; } private int findSmallest ( int [ ] values ) { int result = Integer . MAX_VALUE ; for ( int i = 0 ; i < values . length ; i ++ ) { if ( values [ i ] < result ) result = values [ i ] ; } return result ; } public void fillRect ( int x , int y , int width , int height ) { HSSFSimpleShape shape = escherGroup . createShape ( new HSSFChildAnchor ( x , y , x + width , y + height ) ) ; shape . setShapeType ( HSSFSimpleShape . OBJECT_TYPE_RECTANGLE ) ; shape . setLineStyle ( HSSFShape . LINESTYLE_NONE ) ; shape . setFillColor ( foreground . getRed ( ) , foreground . getGreen ( ) , foreground . getBlue ( ) ) ; shape . setLineStyleColor ( foreground . getRed ( ) , foreground . getGreen ( ) , foreground . getBlue ( ) ) ; } public void fillRoundRect ( int x , int y , int width , int height , int arcWidth , int arcHeight ) { if ( logger . check ( POILogger . WARN ) ) logger . log ( POILogger . WARN , "fillRoundRect not supported" ) ; } public Shape getClip ( ) { return getClipBounds ( ) ; } public Rectangle getClipBounds ( ) { return null ; } public Rectangle getClipRect ( ) { return getClipBounds ( ) ; } public Color getColor ( ) { return foreground ; } public Font getFont ( ) { return font ; } public FontMetrics getFontMetrics ( Font f ) { return Toolkit . getDefaultToolkit ( ) . getFontMetrics ( f ) ; } public void setClip ( int x , int y , int width , int height ) { setClip ( ( ( Shape ) ( new Rectangle ( x , y , width , height ) ) ) ) ; } public void setClip ( Shape shape ) { } public void setColor ( Color color ) { foreground = color ; } public void setFont ( Font f ) { font = f ; } public void setPaintMode ( ) { if ( logger . check ( POILogger . WARN ) ) logger . log ( POILogger . WARN , "setPaintMode not supported" ) ; } public void setXORMode ( Color color ) { if ( logger . check ( POILogger . WARN ) ) logger . log ( POILogger . WARN , "setXORMode not supported" ) ; } public void translate ( int x , int y ) { if ( logger . check ( POILogger . WARN ) ) logger . log ( POILogger . WARN , "translate not supported" ) ; } public Color getBackground ( ) { return background ; } public void setBackground ( Color background ) { this . background = background ; } } 	0	['47', '2', '0', '15', '101', '665', '1', '14', '41', '0.836956522', '997', '1', '3', '0.531914894', '0.185618729', '2', '18', '20.04255319', '7', '1.5319', '0']
package org . apache . poi . util ; import java . util . * ; public class ShortList { private short [ ] _array ; private int _limit ; private static final int _default_size = 128 ; public ShortList ( ) { this ( _default_size ) ; } public ShortList ( final ShortList list ) { this ( list . _array . length ) ; System . arraycopy ( list . _array , 0 , _array , 0 , _array . length ) ; _limit = list . _limit ; } public ShortList ( final int initialCapacity ) { _array = new short [ initialCapacity ] ; _limit = 0 ; } public void add ( final int index , final short value ) { if ( index > _limit ) { throw new IndexOutOfBoundsException ( ) ; } else if ( index == _limit ) { add ( value ) ; } else { if ( _limit == _array . length ) { growArray ( _limit * 2 ) ; } System . arraycopy ( _array , index , _array , index + 1 , _limit - index ) ; _array [ index ] = value ; _limit ++ ; } } public boolean add ( final short value ) { if ( _limit == _array . length ) { growArray ( _limit * 2 ) ; } _array [ _limit ++ ] = value ; return true ; } public boolean addAll ( final ShortList c ) { if ( c . _limit != 0 ) { if ( ( _limit + c . _limit ) > _array . length ) { growArray ( _limit + c . _limit ) ; } System . arraycopy ( c . _array , 0 , _array , _limit , c . _limit ) ; _limit += c . _limit ; } return true ; } public boolean addAll ( final int index , final ShortList c ) { if ( index > _limit ) { throw new IndexOutOfBoundsException ( ) ; } if ( c . _limit != 0 ) { if ( ( _limit + c . _limit ) > _array . length ) { growArray ( _limit + c . _limit ) ; } System . arraycopy ( _array , index , _array , index + c . _limit , _limit - index ) ; System . arraycopy ( c . _array , 0 , _array , index , c . _limit ) ; _limit += c . _limit ; } return true ; } public void clear ( ) { _limit = 0 ; } public boolean contains ( final short o ) { boolean rval = false ; for ( int j = 0 ; ! rval && ( j < _limit ) ; j ++ ) { if ( _array [ j ] == o ) { rval = true ; } } return rval ; } public boolean containsAll ( final ShortList c ) { boolean rval = true ; if ( this != c ) { for ( int j = 0 ; rval && ( j < c . _limit ) ; j ++ ) { if ( ! contains ( c . _array [ j ] ) ) { rval = false ; } } } return rval ; } public boolean equals ( final Object o ) { boolean rval = this == o ; if ( ! rval && ( o != null ) && ( o . getClass ( ) == this . getClass ( ) ) ) { ShortList other = ( ShortList ) o ; if ( other . _limit == _limit ) { rval = true ; for ( int j = 0 ; rval && ( j < _limit ) ; j ++ ) { rval = _array [ j ] == other . _array [ j ] ; } } } return rval ; } public short get ( final int index ) { if ( index >= _limit ) { throw new IndexOutOfBoundsException ( ) ; } return _array [ index ] ; } public int hashCode ( ) { int hash = 0 ; for ( int j = 0 ; j < _limit ; j ++ ) { hash = ( 31 * hash ) + _array [ j ] ; } return hash ; } public int indexOf ( final short o ) { int rval = 0 ; for ( ; rval < _limit ; rval ++ ) { if ( o == _array [ rval ] ) { break ; } } if ( rval == _limit ) { rval = - 1 ; } return rval ; } public boolean isEmpty ( ) { return _limit == 0 ; } public int lastIndexOf ( final short o ) { int rval = _limit - 1 ; for ( ; rval >= 0 ; rval -- ) { if ( o == _array [ rval ] ) { break ; } } return rval ; } public short remove ( final int index ) { if ( index >= _limit ) { throw new IndexOutOfBoundsException ( ) ; } short rval = _array [ index ] ; System . arraycopy ( _array , index + 1 , _array , index , _limit - index ) ; _limit -- ; return rval ; } public boolean removeValue ( final short o ) { boolean rval = false ; for ( int j = 0 ; ! rval && ( j < _limit ) ; j ++ ) { if ( o == _array [ j ] ) { System . arraycopy ( _array , j + 1 , _array , j , _limit - j ) ; _limit -- ; rval = true ; } } return rval ; } public boolean removeAll ( final ShortList c ) { boolean rval = false ; for ( int j = 0 ; j < c . _limit ; j ++ ) { if ( removeValue ( c . _array [ j ] ) ) { rval = true ; } } return rval ; } public boolean retainAll ( final ShortList c ) { boolean rval = false ; for ( int j = 0 ; j < _limit ; ) { if ( ! c . contains ( _array [ j ] ) ) { remove ( j ) ; rval = true ; } else { j ++ ; } } return rval ; } public short set ( final int index , final short element ) { if ( index >= _limit ) { throw new IndexOutOfBoundsException ( ) ; } short rval = _array [ index ] ; _array [ index ] = element ; return rval ; } public int size ( ) { return _limit ; } public short [ ] toArray ( ) { short [ ] rval = new short [ _limit ] ; System . arraycopy ( _array , 0 , rval , 0 , _limit ) ; return rval ; } public short [ ] toArray ( final short [ ] a ) { short [ ] rval ; if ( a . length == _limit ) { System . arraycopy ( _array , 0 , a , 0 , _limit ) ; rval = a ; } else { rval = toArray ( ) ; } return rval ; } private void growArray ( final int new_size ) { int size = ( new_size == _array . length ) ? new_size + 1 : new_size ; short [ ] new_array = new short [ size ] ; System . arraycopy ( _array , 0 , new_array , 0 , _limit ) ; _array = new_array ; } } 	0	['25', '1', '0', '0', '29', '0', '0', '0', '24', '0.388888889', '629', '1', '0', '0', '0.313333333', '1', '1', '24.04', '9', '2.6', '0']
package org . apache . poi . poifs . storage ; import org . apache . poi . poifs . property . RootProperty ; import java . util . * ; import java . io . * ; public class SmallBlockTableReader { public static BlockList getSmallDocumentBlocks ( final RawDataBlockList blockList , final RootProperty root , final int sbatStart ) throws IOException { BlockList list = new SmallDocumentBlockList ( SmallDocumentBlock . extract ( blockList . fetchBlocks ( root . getStartBlock ( ) ) ) ) ; new BlockAllocationTableReader ( blockList . fetchBlocks ( sbatStart ) , list ) ; return list ; } } 	0	['2', '1', '0', '9', '8', '1', '2', '7', '2', '2', '24', '0', '0', '0', '0.5', '0', '0', '11', '1', '0.5', '0']
package org . apache . poi . util ; import java . util . * ; public class IntList { private int [ ] _array ; private int _limit ; private static final int _default_size = 128 ; public IntList ( ) { this ( _default_size ) ; } public IntList ( final IntList list ) { this ( list . _array . length ) ; System . arraycopy ( list . _array , 0 , _array , 0 , _array . length ) ; _limit = list . _limit ; } public IntList ( final int initialCapacity ) { _array = new int [ initialCapacity ] ; _limit = 0 ; } public void add ( final int index , final int value ) { if ( index > _limit ) { throw new IndexOutOfBoundsException ( ) ; } else if ( index == _limit ) { add ( value ) ; } else { if ( _limit == _array . length ) { growArray ( _limit * 2 ) ; } System . arraycopy ( _array , index , _array , index + 1 , _limit - index ) ; _array [ index ] = value ; _limit ++ ; } } public boolean add ( final int value ) { if ( _limit == _array . length ) { growArray ( _limit * 2 ) ; } _array [ _limit ++ ] = value ; return true ; } public boolean addAll ( final IntList c ) { if ( c . _limit != 0 ) { if ( ( _limit + c . _limit ) > _array . length ) { growArray ( _limit + c . _limit ) ; } System . arraycopy ( c . _array , 0 , _array , _limit , c . _limit ) ; _limit += c . _limit ; } return true ; } public boolean addAll ( final int index , final IntList c ) { if ( index > _limit ) { throw new IndexOutOfBoundsException ( ) ; } if ( c . _limit != 0 ) { if ( ( _limit + c . _limit ) > _array . length ) { growArray ( _limit + c . _limit ) ; } System . arraycopy ( _array , index , _array , index + c . _limit , _limit - index ) ; System . arraycopy ( c . _array , 0 , _array , index , c . _limit ) ; _limit += c . _limit ; } return true ; } public void clear ( ) { _limit = 0 ; } public boolean contains ( final int o ) { boolean rval = false ; for ( int j = 0 ; ! rval && ( j < _limit ) ; j ++ ) { if ( _array [ j ] == o ) { rval = true ; } } return rval ; } public boolean containsAll ( final IntList c ) { boolean rval = true ; if ( this != c ) { for ( int j = 0 ; rval && ( j < c . _limit ) ; j ++ ) { if ( ! contains ( c . _array [ j ] ) ) { rval = false ; } } } return rval ; } public boolean equals ( final Object o ) { boolean rval = this == o ; if ( ! rval && ( o != null ) && ( o . getClass ( ) == this . getClass ( ) ) ) { IntList other = ( IntList ) o ; if ( other . _limit == _limit ) { rval = true ; for ( int j = 0 ; rval && ( j < _limit ) ; j ++ ) { rval = _array [ j ] == other . _array [ j ] ; } } } return rval ; } public int get ( final int index ) { if ( index >= _limit ) { throw new IndexOutOfBoundsException ( ) ; } return _array [ index ] ; } public int hashCode ( ) { int hash = 0 ; for ( int j = 0 ; j < _limit ; j ++ ) { hash = ( 31 * hash ) + _array [ j ] ; } return hash ; } public int indexOf ( final int o ) { int rval = 0 ; for ( ; rval < _limit ; rval ++ ) { if ( o == _array [ rval ] ) { break ; } } if ( rval == _limit ) { rval = - 1 ; } return rval ; } public boolean isEmpty ( ) { return _limit == 0 ; } public int lastIndexOf ( final int o ) { int rval = _limit - 1 ; for ( ; rval >= 0 ; rval -- ) { if ( o == _array [ rval ] ) { break ; } } return rval ; } public int remove ( final int index ) { if ( index >= _limit ) { throw new IndexOutOfBoundsException ( ) ; } int rval = _array [ index ] ; System . arraycopy ( _array , index + 1 , _array , index , _limit - index ) ; _limit -- ; return rval ; } public boolean removeValue ( final int o ) { boolean rval = false ; for ( int j = 0 ; ! rval && ( j < _limit ) ; j ++ ) { if ( o == _array [ j ] ) { System . arraycopy ( _array , j + 1 , _array , j , _limit - j ) ; _limit -- ; rval = true ; } } return rval ; } public boolean removeAll ( final IntList c ) { boolean rval = false ; for ( int j = 0 ; j < c . _limit ; j ++ ) { if ( removeValue ( c . _array [ j ] ) ) { rval = true ; } } return rval ; } public boolean retainAll ( final IntList c ) { boolean rval = false ; for ( int j = 0 ; j < _limit ; ) { if ( ! c . contains ( _array [ j ] ) ) { remove ( j ) ; rval = true ; } else { j ++ ; } } return rval ; } public int set ( final int index , final int element ) { if ( index >= _limit ) { throw new IndexOutOfBoundsException ( ) ; } int rval = _array [ index ] ; _array [ index ] = element ; return rval ; } public int size ( ) { return _limit ; } public int [ ] toArray ( ) { int [ ] rval = new int [ _limit ] ; System . arraycopy ( _array , 0 , rval , 0 , _limit ) ; return rval ; } public int [ ] toArray ( final int [ ] a ) { int [ ] rval ; if ( a . length == _limit ) { System . arraycopy ( _array , 0 , a , 0 , _limit ) ; rval = a ; } else { rval = toArray ( ) ; } return rval ; } private void growArray ( final int new_size ) { int size = ( new_size == _array . length ) ? new_size + 1 : new_size ; int [ ] new_array = new int [ size ] ; System . arraycopy ( _array , 0 , new_array , 0 , _limit ) ; _array = new_array ; } } 	0	['25', '1', '0', '4', '29', '0', '4', '0', '24', '0.388888889', '629', '1', '0', '0', '0.36', '1', '1', '24.04', '9', '2.6', '0']
package org . apache . poi . poifs . filesystem ; import java . io . * ; import java . util . * ; import org . apache . poi . hpsf . ClassID ; public interface DirectoryEntry extends Entry { public Iterator getEntries ( ) ; public boolean isEmpty ( ) ; public int getEntryCount ( ) ; public Entry getEntry ( final String name ) throws FileNotFoundException ; public DocumentEntry createDocument ( final String name , final InputStream stream ) throws IOException ; public DocumentEntry createDocument ( final String name , final int size , final POIFSWriterListener writer ) throws IOException ; public DirectoryEntry createDirectory ( final String name ) throws IOException ; public ClassID getStorageClsid ( ) ; public void setStorageClsid ( ClassID clsidStorage ) ; } 	0	['9', '1', '0', '8', '9', '36', '5', '4', '9', '2', '9', '0', '0', '0', '0.314814815', '0', '0', '0', '1', '1', '0']
package org . apache . poi . hssf . eventmodel ; import org . apache . poi . hssf . record . Record ; public interface ERFListener { public boolean processRecord ( Record rec ) ; } 	0	['1', '1', '0', '4', '1', '0', '3', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . poi . hssf . usermodel ; import java . util . HashMap ; import java . util . Map ; import java . util . Properties ; import java . util . StringTokenizer ; public class FontDetails { private String fontName ; private int height ; private Map charWidths = new HashMap ( ) ; public FontDetails ( String fontName , int height ) { this . fontName = fontName ; this . height = height ; } public String getFontName ( ) { return fontName ; } public int getHeight ( ) { return height ; } public void addChar ( char c , int width ) { charWidths . put ( new Character ( c ) , new Integer ( width ) ) ; } public int getCharWidth ( char c ) { Integer widthInteger = ( Integer ) ( charWidths . get ( new Character ( c ) ) ) ; if ( widthInteger == null && c != 'W' ) return getCharWidth ( 'W' ) ; else return widthInteger . intValue ( ) ; } public void addChars ( char [ ] characters , int [ ] widths ) { for ( int i = 0 ; i < characters . length ; i ++ ) { charWidths . put ( new Character ( characters [ i ] ) , new Integer ( widths [ i ] ) ) ; } } public static FontDetails create ( String fontName , Properties fontMetricsProps ) { String heightStr = fontMetricsProps . getProperty ( "font." + fontName + ".height" ) ; String widthsStr = fontMetricsProps . getProperty ( "font." + fontName + ".widths" ) ; String charactersStr = fontMetricsProps . getProperty ( "font." + fontName + ".characters" ) ; int height = Integer . parseInt ( heightStr ) ; FontDetails d = new FontDetails ( fontName , height ) ; String [ ] charactersStrArray = split ( charactersStr , "," , - 1 ) ; String [ ] widthsStrArray = split ( widthsStr , "," , - 1 ) ; if ( charactersStrArray . length != widthsStrArray . length ) throw new RuntimeException ( "Number of characters does not number of widths for font " + fontName ) ; for ( int i = 0 ; i < widthsStrArray . length ; i ++ ) { if ( charactersStrArray [ i ] . length ( ) != 0 ) d . addChar ( charactersStrArray [ i ] . charAt ( 0 ) , Integer . parseInt ( widthsStrArray [ i ] ) ) ; } return d ; } public int getStringWidth ( String str ) { int width = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { width += getCharWidth ( str . charAt ( i ) ) ; } return width ; } private static String [ ] split ( String text , String separator , int max ) { StringTokenizer tok = new StringTokenizer ( text , separator ) ; int listSize = tok . countTokens ( ) ; if ( max != - 1 && listSize > max ) listSize = max ; String list [ ] = new String [ listSize ] ; for ( int i = 0 ; tok . hasMoreTokens ( ) ; i ++ ) { if ( max != - 1 && i == listSize - 1 ) { StringBuffer buf = new StringBuffer ( ( text . length ( ) * ( listSize - i ) ) / listSize ) ; while ( tok . hasMoreTokens ( ) ) { buf . append ( tok . nextToken ( ) ) ; if ( tok . hasMoreTokens ( ) ) buf . append ( separator ) ; } list [ i ] = buf . toString ( ) . trim ( ) ; break ; } list [ i ] = tok . nextToken ( ) . trim ( ) ; } return list ; } } 	0	['9', '1', '0', '2', '32', '20', '2', '0', '8', '0.625', '291', '1', '0', '0', '0.301587302', '0', '0', '31', '8', '2.4444', '0']
package org . apache . poi . ddf ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . HexDump ; import java . util . * ; import java . io . IOException ; public class EscherOptRecord extends EscherRecord { public static final short RECORD_ID = ( short ) 0xF00B ; public static final String RECORD_DESCRIPTION = "msofbtOPT" ; private List properties = new ArrayList ( ) ; public int fillFields ( byte [ ] data , int offset , EscherRecordFactory recordFactory ) { int bytesRemaining = readHeader ( data , offset ) ; int pos = offset + 8 ; EscherPropertyFactory f = new EscherPropertyFactory ( ) ; properties = f . createProperties ( data , pos , getInstance ( ) ) ; return bytesRemaining + 8 ; } public int serialize ( int offset , byte [ ] data , EscherSerializationListener listener ) { listener . beforeRecordSerialize ( offset , getRecordId ( ) , this ) ; LittleEndian . putShort ( data , offset , getOptions ( ) ) ; LittleEndian . putShort ( data , offset + 2 , getRecordId ( ) ) ; LittleEndian . putInt ( data , offset + 4 , getPropertiesSize ( ) ) ; int pos = offset + 8 ; for ( Iterator iterator = properties . iterator ( ) ; iterator . hasNext ( ) ; ) { EscherProperty escherProperty = ( EscherProperty ) iterator . next ( ) ; pos += escherProperty . serializeSimplePart ( data , pos ) ; } for ( Iterator iterator = properties . iterator ( ) ; iterator . hasNext ( ) ; ) { EscherProperty escherProperty = ( EscherProperty ) iterator . next ( ) ; pos += escherProperty . serializeComplexPart ( data , pos ) ; } listener . afterRecordSerialize ( pos , getRecordId ( ) , pos - offset , this ) ; return pos - offset ; } public int getRecordSize ( ) { return 8 + getPropertiesSize ( ) ; } public short getOptions ( ) { setOptions ( ( short ) ( ( properties . size ( ) << 4 ) | 0x3 ) ) ; return super . getOptions ( ) ; } public String getRecordName ( ) { return "Opt" ; } private int getPropertiesSize ( ) { int totalSize = 0 ; for ( Iterator iterator = properties . iterator ( ) ; iterator . hasNext ( ) ; ) { EscherProperty escherProperty = ( EscherProperty ) iterator . next ( ) ; totalSize += escherProperty . getPropertySize ( ) ; } return totalSize ; } public String toString ( ) { String nl = System . getProperty ( "line.separator" ) ; StringBuffer propertiesBuf = new StringBuffer ( ) ; for ( Iterator iterator = properties . iterator ( ) ; iterator . hasNext ( ) ; ) propertiesBuf . append ( "    " + iterator . next ( ) . toString ( ) + nl ) ; return "org.apache.poi.ddf.EscherOptRecord:" + nl + "  isContainer: " + isContainerRecord ( ) + nl + "  options: 0x" + HexDump . toHex ( getOptions ( ) ) + nl + "  recordId: 0x" + HexDump . toHex ( getRecordId ( ) ) + nl + "  numchildren: " + getChildRecords ( ) . size ( ) + nl + "  properties:" + nl + propertiesBuf . toString ( ) ; } public List getEscherProperties ( ) { return properties ; } public EscherProperty getEscherProperty ( int index ) { return ( EscherProperty ) properties . get ( index ) ; } public void addEscherProperty ( EscherProperty prop ) { properties . add ( prop ) ; } public void sortProperties ( ) { Collections . sort ( properties , new Comparator ( ) { public int compare ( Object o1 , Object o2 ) { EscherProperty p1 = ( EscherProperty ) o1 ; EscherProperty p2 = ( EscherProperty ) o2 ; return new Short ( p1 . getPropertyNumber ( ) ) . compareTo ( new Short ( p2 . getPropertyNumber ( ) ) ) ; } } ) ; } } 	0	['12', '2', '0', '15', '49', '0', '8', '8', '11', '0.757575758', '269', '0.333333333', '0', '0.633333333', '0.277777778', '1', '5', '21.16666667', '3', '1.25', '0']
package org . apache . poi . poifs . eventfilesystem ; import java . io . * ; import java . util . * ; import org . apache . poi . poifs . filesystem . DocumentInputStream ; import org . apache . poi . poifs . filesystem . POIFSDocument ; import org . apache . poi . poifs . filesystem . POIFSDocumentPath ; import org . apache . poi . poifs . property . DirectoryProperty ; import org . apache . poi . poifs . property . Property ; import org . apache . poi . poifs . property . PropertyTable ; import org . apache . poi . poifs . storage . BlockAllocationTableReader ; import org . apache . poi . poifs . storage . BlockList ; import org . apache . poi . poifs . storage . HeaderBlockReader ; import org . apache . poi . poifs . storage . RawDataBlockList ; import org . apache . poi . poifs . storage . SmallBlockTableReader ; public class POIFSReader { private POIFSReaderRegistry registry ; private boolean registryClosed ; public POIFSReader ( ) { registry = new POIFSReaderRegistry ( ) ; registryClosed = false ; } public void read ( final InputStream stream ) throws IOException { registryClosed = true ; HeaderBlockReader header_block_reader = new HeaderBlockReader ( stream ) ; RawDataBlockList data_blocks = new RawDataBlockList ( stream ) ; new BlockAllocationTableReader ( header_block_reader . getBATCount ( ) , header_block_reader . getBATArray ( ) , header_block_reader . getXBATCount ( ) , header_block_reader . getXBATIndex ( ) , data_blocks ) ; PropertyTable properties = new PropertyTable ( header_block_reader . getPropertyStart ( ) , data_blocks ) ; processProperties ( SmallBlockTableReader . getSmallDocumentBlocks ( data_blocks , properties . getRoot ( ) , header_block_reader . getSBATStart ( ) ) , data_blocks , properties . getRoot ( ) . getChildren ( ) , new POIFSDocumentPath ( ) ) ; } public void registerListener ( final POIFSReaderListener listener ) { if ( listener == null ) { throw new NullPointerException ( ) ; } if ( registryClosed ) { throw new IllegalStateException ( ) ; } registry . registerListener ( listener ) ; } public void registerListener ( final POIFSReaderListener listener , final String name ) { registerListener ( listener , null , name ) ; } public void registerListener ( final POIFSReaderListener listener , final POIFSDocumentPath path , final String name ) { if ( ( listener == null ) || ( name == null ) || ( name . length ( ) == 0 ) ) { throw new NullPointerException ( ) ; } if ( registryClosed ) { throw new IllegalStateException ( ) ; } registry . registerListener ( listener , ( path == null ) ? new POIFSDocumentPath ( ) : path , name ) ; } public static void main ( String args [ ] ) throws IOException { if ( args . length == 0 ) { System . err . println ( "at least one argument required: input filename(s)" ) ; System . exit ( 1 ) ; } for ( int j = 0 ; j < args . length ; j ++ ) { POIFSReader reader = new POIFSReader ( ) ; POIFSReaderListener listener = new SampleListener ( ) ; reader . registerListener ( listener ) ; System . out . println ( "reading " + args [ j ] ) ; FileInputStream istream = new FileInputStream ( args [ j ] ) ; reader . read ( istream ) ; istream . close ( ) ; } } private void processProperties ( final BlockList small_blocks , final BlockList big_blocks , final Iterator properties , final POIFSDocumentPath path ) throws IOException { while ( properties . hasNext ( ) ) { Property property = ( Property ) properties . next ( ) ; String name = property . getName ( ) ; if ( property . isDirectory ( ) ) { POIFSDocumentPath new_path = new POIFSDocumentPath ( path , new String [ ] { name } ) ; processProperties ( small_blocks , big_blocks , ( ( DirectoryProperty ) property ) . getChildren ( ) , new_path ) ; } else { int startBlock = property . getStartBlock ( ) ; Iterator listeners = registry . getListeners ( path , name ) ; if ( listeners . hasNext ( ) ) { int size = property . getSize ( ) ; POIFSDocument document = null ; if ( property . shouldUseSmallBlocks ( ) ) { document = new POIFSDocument ( name , small_blocks . fetchBlocks ( startBlock ) , size ) ; } else { document = new POIFSDocument ( name , big_blocks . fetchBlocks ( startBlock ) , size ) ; } while ( listeners . hasNext ( ) ) { POIFSReaderListener listener = ( POIFSReaderListener ) listeners . next ( ) ; listener . processPOIFSReaderEvent ( new POIFSReaderEvent ( new DocumentInputStream ( document ) , path , name ) ) ; } } else { if ( property . shouldUseSmallBlocks ( ) ) { small_blocks . fetchBlocks ( startBlock ) ; } else { big_blocks . fetchBlocks ( startBlock ) ; } } } } } private static class SampleListener implements POIFSReaderListener { SampleListener ( ) { } public void processPOIFSReaderEvent ( final POIFSReaderEvent event ) { DocumentInputStream istream = event . getStream ( ) ; POIFSDocumentPath path = event . getPath ( ) ; String name = event . getName ( ) ; try { byte [ ] data = new byte [ istream . available ( ) ] ; istream . read ( data ) ; int pathLength = path . length ( ) ; for ( int k = 0 ; k < pathLength ; k ++ ) { System . out . print ( "/" + path . getComponent ( k ) ) ; } System . out . println ( "/" + name + ": " + data . length + " bytes read" ) ; } catch ( IOException ignored ) { } } } } 	0	['7', '1', '0', '17', '51', '3', '0', '17', '6', '0.083333333', '282', '1', '1', '0', '0.303571429', '0', '0', '39', '6', '1.8571', '0']
package org . apache . poi . poifs . dev ; import java . io . * ; import java . util . * ; public class POIFSViewEngine { private static final String _EOL = System . getProperty ( "line.separator" ) ; public static List inspectViewable ( final Object viewable , final boolean drilldown , final int indentLevel , final String indentString ) { List objects = new ArrayList ( ) ; if ( viewable instanceof POIFSViewable ) { POIFSViewable inspected = ( POIFSViewable ) viewable ; objects . add ( indent ( indentLevel , indentString , inspected . getShortDescription ( ) ) ) ; if ( drilldown ) { if ( inspected . preferArray ( ) ) { Object [ ] data = inspected . getViewableArray ( ) ; for ( int j = 0 ; j < data . length ; j ++ ) { objects . addAll ( inspectViewable ( data [ j ] , drilldown , indentLevel + 1 , indentString ) ) ; } } else { Iterator iter = inspected . getViewableIterator ( ) ; while ( iter . hasNext ( ) ) { objects . addAll ( inspectViewable ( iter . next ( ) , drilldown , indentLevel + 1 , indentString ) ) ; } } } } else { objects . add ( indent ( indentLevel , indentString , viewable . toString ( ) ) ) ; } return objects ; } private static String indent ( final int indentLevel , final String indentString , final String data ) { StringBuffer finalBuffer = new StringBuffer ( ) ; StringBuffer indentPrefix = new StringBuffer ( ) ; for ( int j = 0 ; j < indentLevel ; j ++ ) { indentPrefix . append ( indentString ) ; } LineNumberReader reader = new LineNumberReader ( new StringReader ( data ) ) ; try { String line = reader . readLine ( ) ; while ( line != null ) { finalBuffer . append ( indentPrefix ) . append ( line ) . append ( _EOL ) ; line = reader . readLine ( ) ; } } catch ( IOException e ) { finalBuffer . append ( indentPrefix ) . append ( e . getMessage ( ) ) . append ( _EOL ) ; } return finalBuffer . toString ( ) ; } } 	0	['4', '1', '0', '2', '24', '4', '1', '1', '2', '0.333333333', '146', '1', '0', '0', '0.466666667', '0', '0', '35.25', '3', '1.25', '0']
package org . apache . poi . util ; public class SystemOutLogger extends POILogger { private String cat ; public void initialize ( final String cat ) { this . cat = cat ; } public void log ( final int level , final Object obj1 ) { if ( check ( level ) ) System . out . println ( "[" + cat + "] " + obj1 ) ; } public boolean check ( final int level ) { int currentLevel = Integer . parseInt ( System . getProperty ( "poi.log.level" , WARN + "" ) ) ; if ( level >= currentLevel ) return true ; else return false ; } } 	0	['4', '2', '0', '1', '12', '4', '0', '1', '4', '0.666666667', '44', '1', '0', '0.888888889', '0.5', '1', '1', '9.75', '2', '1.25', '0']
package org . apache . poi . poifs . filesystem ; import java . io . * ; import java . util . * ; public class DocumentOutputStream extends OutputStream { private OutputStream stream ; private int limit ; private int written ; DocumentOutputStream ( final OutputStream stream , final int limit ) { this . stream = stream ; this . limit = limit ; this . written = 0 ; } public void write ( final int b ) throws IOException { limitCheck ( 1 ) ; stream . write ( b ) ; } public void write ( final byte b [ ] ) throws IOException { write ( b , 0 , b . length ) ; } public void write ( final byte b [ ] , final int off , final int len ) throws IOException { limitCheck ( len ) ; stream . write ( b , off , len ) ; } public void flush ( ) throws IOException { stream . flush ( ) ; } public void close ( ) throws IOException { } void writeFiller ( final int totalLimit , final byte fill ) throws IOException { if ( totalLimit > written ) { byte [ ] filler = new byte [ totalLimit - written ] ; Arrays . fill ( filler , fill ) ; stream . write ( filler ) ; } } private void limitCheck ( final int toBeWritten ) throws IOException { if ( ( written + toBeWritten ) > limit ) { throw new IOException ( "tried to write too much data" ) ; } written += toBeWritten ; } } 	0	['8', '2', '0', '3', '15', '4', '3', '0', '5', '0.428571429', '90', '1', '0', '0.416666667', '0.425', '1', '1', '9.875', '1', '0.875', '0']
package org . apache . poi . hssf . model ; import org . apache . poi . ddf . * ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . usermodel . * ; public class LineShape extends AbstractShape { private EscherContainerRecord spContainer ; private ObjRecord objRecord ; LineShape ( HSSFSimpleShape hssfShape , int shapeId ) { spContainer = createSpContainer ( hssfShape , shapeId ) ; objRecord = createObjRecord ( hssfShape , shapeId ) ; } private EscherContainerRecord createSpContainer ( HSSFSimpleShape hssfShape , int shapeId ) { HSSFShape shape = hssfShape ; EscherContainerRecord spContainer = new EscherContainerRecord ( ) ; EscherSpRecord sp = new EscherSpRecord ( ) ; EscherOptRecord opt = new EscherOptRecord ( ) ; EscherRecord anchor = new EscherClientAnchorRecord ( ) ; EscherClientDataRecord clientData = new EscherClientDataRecord ( ) ; spContainer . setRecordId ( EscherContainerRecord . SP_CONTAINER ) ; spContainer . setOptions ( ( short ) 0x000F ) ; sp . setRecordId ( EscherSpRecord . RECORD_ID ) ; sp . setOptions ( ( short ) ( ( EscherAggregate . ST_LINE << 4 ) | 0x2 ) ) ; sp . setShapeId ( shapeId ) ; sp . setFlags ( EscherSpRecord . FLAG_HAVEANCHOR | EscherSpRecord . FLAG_HASSHAPETYPE ) ; opt . setRecordId ( EscherOptRecord . RECORD_ID ) ; opt . addEscherProperty ( new EscherShapePathProperty ( EscherProperties . GEOMETRY__SHAPEPATH , EscherShapePathProperty . COMPLEX ) ) ; opt . addEscherProperty ( new EscherBoolProperty ( EscherProperties . LINESTYLE__NOLINEDRAWDASH , 1048592 ) ) ; addStandardOptions ( shape , opt ) ; HSSFAnchor userAnchor = shape . getAnchor ( ) ; if ( userAnchor . isHorizontallyFlipped ( ) ) sp . setFlags ( sp . getFlags ( ) | EscherSpRecord . FLAG_FLIPHORIZ ) ; if ( userAnchor . isVerticallyFlipped ( ) ) sp . setFlags ( sp . getFlags ( ) | EscherSpRecord . FLAG_FLIPVERT ) ; anchor = createAnchor ( userAnchor ) ; clientData . setRecordId ( EscherClientDataRecord . RECORD_ID ) ; clientData . setOptions ( ( short ) 0x0000 ) ; spContainer . addChildRecord ( sp ) ; spContainer . addChildRecord ( opt ) ; spContainer . addChildRecord ( anchor ) ; spContainer . addChildRecord ( clientData ) ; return spContainer ; } private ObjRecord createObjRecord ( HSSFShape hssfShape , int shapeId ) { HSSFShape shape = hssfShape ; ObjRecord obj = new ObjRecord ( ) ; CommonObjectDataSubRecord c = new CommonObjectDataSubRecord ( ) ; c . setObjectType ( ( short ) ( ( HSSFSimpleShape ) shape ) . getShapeType ( ) ) ; c . setObjectId ( ( short ) ( shapeId ) ) ; c . setLocked ( true ) ; c . setPrintable ( true ) ; c . setAutofill ( true ) ; c . setAutoline ( true ) ; EndSubRecord e = new EndSubRecord ( ) ; obj . addSubRecord ( c ) ; obj . addSubRecord ( e ) ; return obj ; } public EscherContainerRecord getSpContainer ( ) { return spContainer ; } public ObjRecord getObjRecord ( ) { return objRecord ; } } 	0	['5', '2', '0', '16', '41', '6', '1', '16', '2', '0.75', '181', '1', '2', '0.555555556', '0.55', '1', '1', '34.8', '3', '1.2', '0']
package org . apache . poi . poifs . storage ; import java . io . IOException ; import java . io . OutputStream ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . util . IntList ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; public class BlockAllocationTableReader { private IntList _entries ; public BlockAllocationTableReader ( final int block_count , final int [ ] block_array , final int xbat_count , final int xbat_index , final BlockList raw_block_list ) throws IOException { this ( ) ; if ( block_count <= 0 ) { throw new IOException ( "Illegal block count; minimum count is 1, got " + block_count + " instead" ) ; } RawDataBlock blocks [ ] = new RawDataBlock [ block_count ] ; int limit = Math . min ( block_count , block_array . length ) ; int block_index ; for ( block_index = 0 ; block_index < limit ; block_index ++ ) { blocks [ block_index ] = ( RawDataBlock ) raw_block_list . remove ( block_array [ block_index ] ) ; } if ( block_index < block_count ) { if ( xbat_index < 0 ) { throw new IOException ( "BAT count exceeds limit, yet XBAT index indicates no valid entries" ) ; } int chain_index = xbat_index ; int max_entries_per_block = BATBlock . entriesPerXBATBlock ( ) ; int chain_index_offset = BATBlock . getXBATChainOffset ( ) ; for ( int j = 0 ; j < xbat_count ; j ++ ) { limit = Math . min ( block_count - block_index , max_entries_per_block ) ; byte [ ] data = raw_block_list . remove ( chain_index ) . getData ( ) ; int offset = 0 ; for ( int k = 0 ; k < limit ; k ++ ) { blocks [ block_index ++ ] = ( RawDataBlock ) raw_block_list . remove ( LittleEndian . getInt ( data , offset ) ) ; offset += LittleEndianConsts . INT_SIZE ; } chain_index = LittleEndian . getInt ( data , chain_index_offset ) ; if ( chain_index == POIFSConstants . END_OF_CHAIN ) { break ; } } } if ( block_index != block_count ) { throw new IOException ( "Could not find all blocks" ) ; } setEntries ( blocks , raw_block_list ) ; } BlockAllocationTableReader ( final ListManagedBlock [ ] blocks , final BlockList raw_block_list ) throws IOException { this ( ) ; setEntries ( blocks , raw_block_list ) ; } BlockAllocationTableReader ( ) { _entries = new IntList ( ) ; } ListManagedBlock [ ] fetchBlocks ( final int startBlock , final BlockList blockList ) throws IOException { List blocks = new ArrayList ( ) ; int currentBlock = startBlock ; while ( currentBlock != POIFSConstants . END_OF_CHAIN ) { blocks . add ( blockList . remove ( currentBlock ) ) ; currentBlock = _entries . get ( currentBlock ) ; } return ( ListManagedBlock [ ] ) blocks . toArray ( new ListManagedBlock [ 0 ] ) ; } boolean isUsed ( final int index ) { boolean rval = false ; try { rval = _entries . get ( index ) != - 1 ; } catch ( IndexOutOfBoundsException ignored ) { } return rval ; } int getNextBlockIndex ( final int index ) throws IOException { if ( isUsed ( index ) ) { return _entries . get ( index ) ; } else { throw new IOException ( "index " + index + " is unused" ) ; } } private void setEntries ( final ListManagedBlock [ ] blocks , final BlockList raw_blocks ) throws IOException { int limit = BATBlock . entriesPerBlock ( ) ; for ( int block_index = 0 ; block_index < blocks . length ; block_index ++ ) { byte [ ] data = blocks [ block_index ] . getData ( ) ; int offset = 0 ; for ( int k = 0 ; k < limit ; k ++ ) { int entry = LittleEndian . getInt ( data , offset ) ; if ( entry == POIFSConstants . UNUSED_BLOCK ) { raw_blocks . zap ( _entries . size ( ) ) ; } _entries . add ( entry ) ; offset += LittleEndianConsts . INT_SIZE ; } blocks [ block_index ] = null ; } raw_blocks . setBAT ( this ) ; } } 	0	['7', '1', '0', '12', '29', '1', '7', '6', '1', '0', '257', '1', '1', '0', '0.514285714', '0', '0', '35.57142857', '2', '0.7143', '0']
package org . apache . poi . util ; import java . util . * ; public final class BinaryTree extends AbstractMap { private Node [ ] _root = new Node [ ] { null , null } ; private int _size = 0 ; private int _modifications = 0 ; private Set [ ] _key_set = new Set [ ] { null , null } ; private Set [ ] _entry_set = new Set [ ] { null , null } ; private Collection [ ] _value_collection = new Collection [ ] { null , null } ; private static final int _KEY = 0 ; private static final int _VALUE = 1 ; private static final int _INDEX_SUM = _KEY + _VALUE ; private static final int _MINIMUM_INDEX = 0 ; private static final int _INDEX_COUNT = 2 ; private static final String [ ] _data_name = new String [ ] { "key" , "value" } ; public BinaryTree ( ) { } public BinaryTree ( final Map map ) throws ClassCastException , NullPointerException , IllegalArgumentException { putAll ( map ) ; } public Object getKeyForValue ( final Object value ) throws ClassCastException , NullPointerException { return doGet ( ( Comparable ) value , _VALUE ) ; } public Object removeValue ( final Object value ) { return doRemove ( ( Comparable ) value , _VALUE ) ; } public Set entrySetByValue ( ) { if ( _entry_set [ _VALUE ] == null ) { _entry_set [ _VALUE ] = new AbstractSet ( ) { public Iterator iterator ( ) { return new BinaryTreeIterator ( _VALUE ) { protected Object doGetNext ( ) { return _last_returned_node ; } } ; } public boolean contains ( Object o ) { if ( ! ( o instanceof Map . Entry ) ) { return false ; } Map . Entry entry = ( Map . Entry ) o ; Object key = entry . getKey ( ) ; Node node = lookup ( ( Comparable ) entry . getValue ( ) , _VALUE ) ; return ( node != null ) && node . getData ( _KEY ) . equals ( key ) ; } public boolean remove ( Object o ) { if ( ! ( o instanceof Map . Entry ) ) { return false ; } Map . Entry entry = ( Map . Entry ) o ; Object key = entry . getKey ( ) ; Node node = lookup ( ( Comparable ) entry . getValue ( ) , _VALUE ) ; if ( ( node != null ) && node . getData ( _KEY ) . equals ( key ) ) { doRedBlackDelete ( node ) ; return true ; } return false ; } public int size ( ) { return BinaryTree . this . size ( ) ; } public void clear ( ) { BinaryTree . this . clear ( ) ; } } ; } return _entry_set [ _VALUE ] ; } public Set keySetByValue ( ) { if ( _key_set [ _VALUE ] == null ) { _key_set [ _VALUE ] = new AbstractSet ( ) { public Iterator iterator ( ) { return new BinaryTreeIterator ( _VALUE ) { protected Object doGetNext ( ) { return _last_returned_node . getData ( _KEY ) ; } } ; } public int size ( ) { return BinaryTree . this . size ( ) ; } public boolean contains ( Object o ) { return containsKey ( o ) ; } public boolean remove ( Object o ) { int old_size = _size ; BinaryTree . this . remove ( o ) ; return _size != old_size ; } public void clear ( ) { BinaryTree . this . clear ( ) ; } } ; } return _key_set [ _VALUE ] ; } public Collection valuesByValue ( ) { if ( _value_collection [ _VALUE ] == null ) { _value_collection [ _VALUE ] = new AbstractCollection ( ) { public Iterator iterator ( ) { return new BinaryTreeIterator ( _VALUE ) { protected Object doGetNext ( ) { return _last_returned_node . getData ( _VALUE ) ; } } ; } public int size ( ) { return BinaryTree . this . size ( ) ; } public boolean contains ( Object o ) { return containsValue ( o ) ; } public boolean remove ( Object o ) { int old_size = _size ; removeValue ( o ) ; return _size != old_size ; } public boolean removeAll ( Collection c ) { boolean modified = false ; Iterator iter = c . iterator ( ) ; while ( iter . hasNext ( ) ) { if ( removeValue ( iter . next ( ) ) != null ) { modified = true ; } } return modified ; } public void clear ( ) { BinaryTree . this . clear ( ) ; } } ; } return _value_collection [ _VALUE ] ; } private Object doRemove ( final Comparable o , final int index ) { Node node = lookup ( o , index ) ; Object rval = null ; if ( node != null ) { rval = node . getData ( oppositeIndex ( index ) ) ; doRedBlackDelete ( node ) ; } return rval ; } private Object doGet ( final Comparable o , final int index ) { checkNonNullComparable ( o , index ) ; Node node = lookup ( o , index ) ; return ( ( node == null ) ? null : node . getData ( oppositeIndex ( index ) ) ) ; } private int oppositeIndex ( final int index ) { return _INDEX_SUM - index ; } private Node lookup ( final Comparable data , final int index ) { Node rval = null ; Node node = _root [ index ] ; while ( node != null ) { int cmp = compare ( data , node . getData ( index ) ) ; if ( cmp == 0 ) { rval = node ; break ; } else { node = ( cmp < 0 ) ? node . getLeft ( index ) : node . getRight ( index ) ; } } return rval ; } private static int compare ( final Comparable o1 , final Comparable o2 ) { return ( ( Comparable ) o1 ) . compareTo ( o2 ) ; } private static Node leastNode ( final Node node , final int index ) { Node rval = node ; if ( rval != null ) { while ( rval . getLeft ( index ) != null ) { rval = rval . getLeft ( index ) ; } } return rval ; } private Node nextGreater ( final Node node , final int index ) { Node rval = null ; if ( node == null ) { rval = null ; } else if ( node . getRight ( index ) != null ) { rval = leastNode ( node . getRight ( index ) , index ) ; } else { Node parent = node . getParent ( index ) ; Node child = node ; while ( ( parent != null ) && ( child == parent . getRight ( index ) ) ) { child = parent ; parent = parent . getParent ( index ) ; } rval = parent ; } return rval ; } private static void copyColor ( final Node from , final Node to , final int index ) { if ( to != null ) { if ( from == null ) { to . setBlack ( index ) ; } else { to . copyColor ( from , index ) ; } } } private static boolean isRed ( final Node node , final int index ) { return ( ( node == null ) ? false : node . isRed ( index ) ) ; } private static boolean isBlack ( final Node node , final int index ) { return ( ( node == null ) ? true : node . isBlack ( index ) ) ; } private static void makeRed ( final Node node , final int index ) { if ( node != null ) { node . setRed ( index ) ; } } private static void makeBlack ( final Node node , final int index ) { if ( node != null ) { node . setBlack ( index ) ; } } private static Node getGrandParent ( final Node node , final int index ) { return getParent ( getParent ( node , index ) , index ) ; } private static Node getParent ( final Node node , final int index ) { return ( ( node == null ) ? null : node . getParent ( index ) ) ; } private static Node getRightChild ( final Node node , final int index ) { return ( node == null ) ? null : node . getRight ( index ) ; } private static Node getLeftChild ( final Node node , final int index ) { return ( node == null ) ? null : node . getLeft ( index ) ; } private static boolean isLeftChild ( final Node node , final int index ) { return ( node == null ) ? true : ( ( node . getParent ( index ) == null ) ? false : ( node == node . getParent ( index ) . getLeft ( index ) ) ) ; } private static boolean isRightChild ( final Node node , final int index ) { return ( node == null ) ? true : ( ( node . getParent ( index ) == null ) ? false : ( node == node . getParent ( index ) . getRight ( index ) ) ) ; } private void rotateLeft ( final Node node , final int index ) { Node right_child = node . getRight ( index ) ; node . setRight ( right_child . getLeft ( index ) , index ) ; if ( right_child . getLeft ( index ) != null ) { right_child . getLeft ( index ) . setParent ( node , index ) ; } right_child . setParent ( node . getParent ( index ) , index ) ; if ( node . getParent ( index ) == null ) { _root [ index ] = right_child ; } else if ( node . getParent ( index ) . getLeft ( index ) == node ) { node . getParent ( index ) . setLeft ( right_child , index ) ; } else { node . getParent ( index ) . setRight ( right_child , index ) ; } right_child . setLeft ( node , index ) ; node . setParent ( right_child , index ) ; } private void rotateRight ( final Node node , final int index ) { Node left_child = node . getLeft ( index ) ; node . setLeft ( left_child . getRight ( index ) , index ) ; if ( left_child . getRight ( index ) != null ) { left_child . getRight ( index ) . setParent ( node , index ) ; } left_child . setParent ( node . getParent ( index ) , index ) ; if ( node . getParent ( index ) == null ) { _root [ index ] = left_child ; } else if ( node . getParent ( index ) . getRight ( index ) == node ) { node . getParent ( index ) . setRight ( left_child , index ) ; } else { node . getParent ( index ) . setLeft ( left_child , index ) ; } left_child . setRight ( node , index ) ; node . setParent ( left_child , index ) ; } private void doRedBlackInsert ( final Node inserted_node , final int index ) { Node current_node = inserted_node ; makeRed ( current_node , index ) ; while ( ( current_node != null ) && ( current_node != _root [ index ] ) && ( isRed ( current_node . getParent ( index ) , index ) ) ) { if ( isLeftChild ( getParent ( current_node , index ) , index ) ) { Node y = getRightChild ( getGrandParent ( current_node , index ) , index ) ; if ( isRed ( y , index ) ) { makeBlack ( getParent ( current_node , index ) , index ) ; makeBlack ( y , index ) ; makeRed ( getGrandParent ( current_node , index ) , index ) ; current_node = getGrandParent ( current_node , index ) ; } else { if ( isRightChild ( current_node , index ) ) { current_node = getParent ( current_node , index ) ; rotateLeft ( current_node , index ) ; } makeBlack ( getParent ( current_node , index ) , index ) ; makeRed ( getGrandParent ( current_node , index ) , index ) ; if ( getGrandParent ( current_node , index ) != null ) { rotateRight ( getGrandParent ( current_node , index ) , index ) ; } } } else { Node y = getLeftChild ( getGrandParent ( current_node , index ) , index ) ; if ( isRed ( y , index ) ) { makeBlack ( getParent ( current_node , index ) , index ) ; makeBlack ( y , index ) ; makeRed ( getGrandParent ( current_node , index ) , index ) ; current_node = getGrandParent ( current_node , index ) ; } else { if ( isLeftChild ( current_node , index ) ) { current_node = getParent ( current_node , index ) ; rotateRight ( current_node , index ) ; } makeBlack ( getParent ( current_node , index ) , index ) ; makeRed ( getGrandParent ( current_node , index ) , index ) ; if ( getGrandParent ( current_node , index ) != null ) { rotateLeft ( getGrandParent ( current_node , index ) , index ) ; } } } } makeBlack ( _root [ index ] , index ) ; } private void doRedBlackDelete ( final Node deleted_node ) { for ( int index = _MINIMUM_INDEX ; index < _INDEX_COUNT ; index ++ ) { if ( ( deleted_node . getLeft ( index ) != null ) && ( deleted_node . getRight ( index ) != null ) ) { swapPosition ( nextGreater ( deleted_node , index ) , deleted_node , index ) ; } Node replacement = ( ( deleted_node . getLeft ( index ) != null ) ? deleted_node . getLeft ( index ) : deleted_node . getRight ( index ) ) ; if ( replacement != null ) { replacement . setParent ( deleted_node . getParent ( index ) , index ) ; if ( deleted_node . getParent ( index ) == null ) { _root [ index ] = replacement ; } else if ( deleted_node == deleted_node . getParent ( index ) . getLeft ( index ) ) { deleted_node . getParent ( index ) . setLeft ( replacement , index ) ; } else { deleted_node . getParent ( index ) . setRight ( replacement , index ) ; } deleted_node . setLeft ( null , index ) ; deleted_node . setRight ( null , index ) ; deleted_node . setParent ( null , index ) ; if ( isBlack ( deleted_node , index ) ) { doRedBlackDeleteFixup ( replacement , index ) ; } } else { if ( deleted_node . getParent ( index ) == null ) { _root [ index ] = null ; } else { if ( isBlack ( deleted_node , index ) ) { doRedBlackDeleteFixup ( deleted_node , index ) ; } if ( deleted_node . getParent ( index ) != null ) { if ( deleted_node == deleted_node . getParent ( index ) . getLeft ( index ) ) { deleted_node . getParent ( index ) . setLeft ( null , index ) ; } else { deleted_node . getParent ( index ) . setRight ( null , index ) ; } deleted_node . setParent ( null , index ) ; } } } } shrink ( ) ; } private void doRedBlackDeleteFixup ( final Node replacement_node , final int index ) { Node current_node = replacement_node ; while ( ( current_node != _root [ index ] ) && ( isBlack ( current_node , index ) ) ) { if ( isLeftChild ( current_node , index ) ) { Node sibling_node = getRightChild ( getParent ( current_node , index ) , index ) ; if ( isRed ( sibling_node , index ) ) { makeBlack ( sibling_node , index ) ; makeRed ( getParent ( current_node , index ) , index ) ; rotateLeft ( getParent ( current_node , index ) , index ) ; sibling_node = getRightChild ( getParent ( current_node , index ) , index ) ; } if ( isBlack ( getLeftChild ( sibling_node , index ) , index ) && isBlack ( getRightChild ( sibling_node , index ) , index ) ) { makeRed ( sibling_node , index ) ; current_node = getParent ( current_node , index ) ; } else { if ( isBlack ( getRightChild ( sibling_node , index ) , index ) ) { makeBlack ( getLeftChild ( sibling_node , index ) , index ) ; makeRed ( sibling_node , index ) ; rotateRight ( sibling_node , index ) ; sibling_node = getRightChild ( getParent ( current_node , index ) , index ) ; } copyColor ( getParent ( current_node , index ) , sibling_node , index ) ; makeBlack ( getParent ( current_node , index ) , index ) ; makeBlack ( getRightChild ( sibling_node , index ) , index ) ; rotateLeft ( getParent ( current_node , index ) , index ) ; current_node = _root [ index ] ; } } else { Node sibling_node = getLeftChild ( getParent ( current_node , index ) , index ) ; if ( isRed ( sibling_node , index ) ) { makeBlack ( sibling_node , index ) ; makeRed ( getParent ( current_node , index ) , index ) ; rotateRight ( getParent ( current_node , index ) , index ) ; sibling_node = getLeftChild ( getParent ( current_node , index ) , index ) ; } if ( isBlack ( getRightChild ( sibling_node , index ) , index ) && isBlack ( getLeftChild ( sibling_node , index ) , index ) ) { makeRed ( sibling_node , index ) ; current_node = getParent ( current_node , index ) ; } else { if ( isBlack ( getLeftChild ( sibling_node , index ) , index ) ) { makeBlack ( getRightChild ( sibling_node , index ) , index ) ; makeRed ( sibling_node , index ) ; rotateLeft ( sibling_node , index ) ; sibling_node = getLeftChild ( getParent ( current_node , index ) , index ) ; } copyColor ( getParent ( current_node , index ) , sibling_node , index ) ; makeBlack ( getParent ( current_node , index ) , index ) ; makeBlack ( getLeftChild ( sibling_node , index ) , index ) ; rotateRight ( getParent ( current_node , index ) , index ) ; current_node = _root [ index ] ; } } } makeBlack ( current_node , index ) ; } private void swapPosition ( final Node x , final Node y , final int index ) { Node x_old_parent = x . getParent ( index ) ; Node x_old_left_child = x . getLeft ( index ) ; Node x_old_right_child = x . getRight ( index ) ; Node y_old_parent = y . getParent ( index ) ; Node y_old_left_child = y . getLeft ( index ) ; Node y_old_right_child = y . getRight ( index ) ; boolean x_was_left_child = ( x . getParent ( index ) != null ) && ( x == x . getParent ( index ) . getLeft ( index ) ) ; boolean y_was_left_child = ( y . getParent ( index ) != null ) && ( y == y . getParent ( index ) . getLeft ( index ) ) ; if ( x == y_old_parent ) { x . setParent ( y , index ) ; if ( y_was_left_child ) { y . setLeft ( x , index ) ; y . setRight ( x_old_right_child , index ) ; } else { y . setRight ( x , index ) ; y . setLeft ( x_old_left_child , index ) ; } } else { x . setParent ( y_old_parent , index ) ; if ( y_old_parent != null ) { if ( y_was_left_child ) { y_old_parent . setLeft ( x , index ) ; } else { y_old_parent . setRight ( x , index ) ; } } y . setLeft ( x_old_left_child , index ) ; y . setRight ( x_old_right_child , index ) ; } if ( y == x_old_parent ) { y . setParent ( x , index ) ; if ( x_was_left_child ) { x . setLeft ( y , index ) ; x . setRight ( y_old_right_child , index ) ; } else { x . setRight ( y , index ) ; x . setLeft ( y_old_left_child , index ) ; } } else { y . setParent ( x_old_parent , index ) ; if ( x_old_parent != null ) { if ( x_was_left_child ) { x_old_parent . setLeft ( y , index ) ; } else { x_old_parent . setRight ( y , index ) ; } } x . setLeft ( y_old_left_child , index ) ; x . setRight ( y_old_right_child , index ) ; } if ( x . getLeft ( index ) != null ) { x . getLeft ( index ) . setParent ( x , index ) ; } if ( x . getRight ( index ) != null ) { x . getRight ( index ) . setParent ( x , index ) ; } if ( y . getLeft ( index ) != null ) { y . getLeft ( index ) . setParent ( y , index ) ; } if ( y . getRight ( index ) != null ) { y . getRight ( index ) . setParent ( y , index ) ; } x . swapColors ( y , index ) ; if ( _root [ index ] == x ) { _root [ index ] = y ; } else if ( _root [ index ] == y ) { _root [ index ] = x ; } } private static void checkNonNullComparable ( final Object o , final int index ) { if ( o == null ) { throw new NullPointerException ( _data_name [ index ] + " cannot be null" ) ; } if ( ! ( o instanceof Comparable ) ) { throw new ClassCastException ( _data_name [ index ] + " must be Comparable" ) ; } } private static void checkKey ( final Object key ) { checkNonNullComparable ( key , _KEY ) ; } private static void checkValue ( final Object value ) { checkNonNullComparable ( value , _VALUE ) ; } private static void checkKeyAndValue ( final Object key , final Object value ) { checkKey ( key ) ; checkValue ( value ) ; } private void modify ( ) { _modifications ++ ; } private void grow ( ) { modify ( ) ; _size ++ ; } private void shrink ( ) { modify ( ) ; _size -- ; } private void insertValue ( final Node newNode ) throws IllegalArgumentException { Node node = _root [ _VALUE ] ; while ( true ) { int cmp = compare ( newNode . getData ( _VALUE ) , node . getData ( _VALUE ) ) ; if ( cmp == 0 ) { throw new IllegalArgumentException ( "Cannot store a duplicate value (\"" + newNode . getData ( _VALUE ) + "\") in this Map" ) ; } else if ( cmp < 0 ) { if ( node . getLeft ( _VALUE ) != null ) { node = node . getLeft ( _VALUE ) ; } else { node . setLeft ( newNode , _VALUE ) ; newNode . setParent ( node , _VALUE ) ; doRedBlackInsert ( newNode , _VALUE ) ; break ; } } else { if ( node . getRight ( _VALUE ) != null ) { node = node . getRight ( _VALUE ) ; } else { node . setRight ( newNode , _VALUE ) ; newNode . setParent ( node , _VALUE ) ; doRedBlackInsert ( newNode , _VALUE ) ; break ; } } } } public int size ( ) { return _size ; } public boolean containsKey ( final Object key ) throws ClassCastException , NullPointerException { checkKey ( key ) ; return lookup ( ( Comparable ) key , _KEY ) != null ; } public boolean containsValue ( final Object value ) { checkValue ( value ) ; return lookup ( ( Comparable ) value , _VALUE ) != null ; } public Object get ( final Object key ) throws ClassCastException , NullPointerException { return doGet ( ( Comparable ) key , _KEY ) ; } public Object put ( final Object key , final Object value ) throws ClassCastException , NullPointerException , IllegalArgumentException { checkKeyAndValue ( key , value ) ; Node node = _root [ _KEY ] ; if ( node == null ) { Node root = new Node ( ( Comparable ) key , ( Comparable ) value ) ; _root [ _KEY ] = root ; _root [ _VALUE ] = root ; grow ( ) ; } else { while ( true ) { int cmp = compare ( ( Comparable ) key , node . getData ( _KEY ) ) ; if ( cmp == 0 ) { throw new IllegalArgumentException ( "Cannot store a duplicate key (\"" + key + "\") in this Map" ) ; } else if ( cmp < 0 ) { if ( node . getLeft ( _KEY ) != null ) { node = node . getLeft ( _KEY ) ; } else { Node newNode = new Node ( ( Comparable ) key , ( Comparable ) value ) ; insertValue ( newNode ) ; node . setLeft ( newNode , _KEY ) ; newNode . setParent ( node , _KEY ) ; doRedBlackInsert ( newNode , _KEY ) ; grow ( ) ; break ; } } else { if ( node . getRight ( _KEY ) != null ) { node = node . getRight ( _KEY ) ; } else { Node newNode = new Node ( ( Comparable ) key , ( Comparable ) value ) ; insertValue ( newNode ) ; node . setRight ( newNode , _KEY ) ; newNode . setParent ( node , _KEY ) ; doRedBlackInsert ( newNode , _KEY ) ; grow ( ) ; break ; } } } } return null ; } public Object remove ( final Object key ) { return doRemove ( ( Comparable ) key , _KEY ) ; } public void clear ( ) { modify ( ) ; _size = 0 ; _root [ _KEY ] = null ; _root [ _VALUE ] = null ; } public Set keySet ( ) { if ( _key_set [ _KEY ] == null ) { _key_set [ _KEY ] = new AbstractSet ( ) { public Iterator iterator ( ) { return new BinaryTreeIterator ( _KEY ) { protected Object doGetNext ( ) { return _last_returned_node . getData ( _KEY ) ; } } ; } public int size ( ) { return BinaryTree . this . size ( ) ; } public boolean contains ( Object o ) { return containsKey ( o ) ; } public boolean remove ( Object o ) { int old_size = _size ; BinaryTree . this . remove ( o ) ; return _size != old_size ; } public void clear ( ) { BinaryTree . this . clear ( ) ; } } ; } return _key_set [ _KEY ] ; } public Collection values ( ) { if ( _value_collection [ _KEY ] == null ) { _value_collection [ _KEY ] = new AbstractCollection ( ) { public Iterator iterator ( ) { return new BinaryTreeIterator ( _KEY ) { protected Object doGetNext ( ) { return _last_returned_node . getData ( _VALUE ) ; } } ; } public int size ( ) { return BinaryTree . this . size ( ) ; } public boolean contains ( Object o ) { return containsValue ( o ) ; } public boolean remove ( Object o ) { int old_size = _size ; removeValue ( o ) ; return _size != old_size ; } public boolean removeAll ( Collection c ) { boolean modified = false ; Iterator iter = c . iterator ( ) ; while ( iter . hasNext ( ) ) { if ( removeValue ( iter . next ( ) ) != null ) { modified = true ; } } return modified ; } public void clear ( ) { BinaryTree . this . clear ( ) ; } } ; } return _value_collection [ _KEY ] ; } public Set entrySet ( ) { if ( _entry_set [ _KEY ] == null ) { _entry_set [ _KEY ] = new AbstractSet ( ) { public Iterator iterator ( ) { return new BinaryTreeIterator ( _KEY ) { protected Object doGetNext ( ) { return _last_returned_node ; } } ; } public boolean contains ( Object o ) { if ( ! ( o instanceof Map . Entry ) ) { return false ; } Map . Entry entry = ( Map . Entry ) o ; Object value = entry . getValue ( ) ; Node node = lookup ( ( Comparable ) entry . getKey ( ) , _KEY ) ; return ( node != null ) && node . getData ( _VALUE ) . equals ( value ) ; } public boolean remove ( Object o ) { if ( ! ( o instanceof Map . Entry ) ) { return false ; } Map . Entry entry = ( Map . Entry ) o ; Object value = entry . getValue ( ) ; Node node = lookup ( ( Comparable ) entry . getKey ( ) , _KEY ) ; if ( ( node != null ) && node . getData ( _VALUE ) . equals ( value ) ) { doRedBlackDelete ( node ) ; return true ; } return false ; } public int size ( ) { return BinaryTree . this . size ( ) ; } public void clear ( ) { BinaryTree . this . clear ( ) ; } } ; } return _entry_set [ _KEY ] ; } private abstract class BinaryTreeIterator implements Iterator { private int _expected_modifications ; protected Node _last_returned_node ; private Node _next_node ; private int _type ; BinaryTreeIterator ( final int type ) { _type = type ; _expected_modifications = BinaryTree . this . _modifications ; _last_returned_node = null ; _next_node = leastNode ( _root [ _type ] , _type ) ; } protected abstract Object doGetNext ( ) ; public final boolean hasNext ( ) { return _next_node != null ; } public final Object next ( ) throws NoSuchElementException , ConcurrentModificationException { if ( _next_node == null ) { throw new NoSuchElementException ( ) ; } if ( _modifications != _expected_modifications ) { throw new ConcurrentModificationException ( ) ; } _last_returned_node = _next_node ; _next_node = nextGreater ( _next_node , _type ) ; return doGetNext ( ) ; } public final void remove ( ) throws IllegalStateException , ConcurrentModificationException { if ( _last_returned_node == null ) { throw new IllegalStateException ( ) ; } if ( _modifications != _expected_modifications ) { throw new ConcurrentModificationException ( ) ; } doRedBlackDelete ( _last_returned_node ) ; _expected_modifications ++ ; _last_returned_node = null ; } } private static final class Node implements Map . Entry { private Comparable [ ] _data ; private Node [ ] _left ; private Node [ ] _right ; private Node [ ] _parent ; private boolean [ ] _black ; private int _hashcode ; private boolean _calculated_hashcode ; Node ( final Comparable key , final Comparable value ) { _data = new Comparable [ ] { key , value } ; _left = new Node [ ] { null , null } ; _right = new Node [ ] { null , null } ; _parent = new Node [ ] { null , null } ; _black = new boolean [ ] { true , true } ; _calculated_hashcode = false ; } private Comparable getData ( final int index ) { return _data [ index ] ; } private void setLeft ( final Node node , final int index ) { _left [ index ] = node ; } private Node getLeft ( final int index ) { return _left [ index ] ; } private void setRight ( final Node node , final int index ) { _right [ index ] = node ; } private Node getRight ( final int index ) { return _right [ index ] ; } private void setParent ( final Node node , final int index ) { _parent [ index ] = node ; } private Node getParent ( final int index ) { return _parent [ index ] ; } private void swapColors ( final Node node , final int index ) { _black [ index ] ^= node . _black [ index ] ; node . _black [ index ] ^= _black [ index ] ; _black [ index ] ^= node . _black [ index ] ; } private boolean isBlack ( final int index ) { return _black [ index ] ; } private boolean isRed ( final int index ) { return ! _black [ index ] ; } private void setBlack ( final int index ) { _black [ index ] = true ; } private void setRed ( final int index ) { _black [ index ] = false ; } private void copyColor ( final Node node , final int index ) { _black [ index ] = node . _black [ index ] ; } public Object getKey ( ) { return _data [ _KEY ] ; } public Object getValue ( ) { return _data [ _VALUE ] ; } public Object setValue ( Object ignored ) throws UnsupportedOperationException { throw new UnsupportedOperationException ( "Map.Entry.setValue is not supported" ) ; } public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof Map . Entry ) ) { return false ; } Map . Entry e = ( Map . Entry ) o ; return _data [ _KEY ] . equals ( e . getKey ( ) ) && _data [ _VALUE ] . equals ( e . getValue ( ) ) ; } public int hashCode ( ) { if ( ! _calculated_hashcode ) { _hashcode = _data [ _KEY ] . hashCode ( ) ^ _data [ _VALUE ] . hashCode ( ) ; _calculated_hashcode = true ; } return _hashcode ; } } } 	0	['57', '2', '0', '18', '87', '1362', '17', '7', '17', '0.927083333', '1806', '1', '1', '0.25', '0.265306122', '1', '7', '30.47368421', '19', '2.5263', '0']
package org . apache . poi . hssf . record . formula ; public abstract class OperationPtg extends Ptg { public final static int TYPE_UNARY = 0 ; public final static int TYPE_BINARY = 1 ; public final static int TYPE_FUNCTION = 2 ; public abstract int getType ( ) ; public abstract String toFormulaString ( String [ ] operands ) ; public abstract int getNumberOfOperands ( ) ; public byte getDefaultOperandClass ( ) { return Ptg . CLASS_VALUE ; } } 	0	['5', '2', '18', '21', '6', '10', '20', '1', '5', '1.25', '13', '0', '0', '0.636363636', '0.6', '0', '0', '1', '1', '0.8', '0']
package org . apache . poi . util ; import org . apache . poi . util . LittleEndian . BufferUnderrunException ; import java . io . * ; public class IntegerField implements FixedField { private int _value ; private final int _offset ; public IntegerField ( final int offset ) throws ArrayIndexOutOfBoundsException { if ( offset < 0 ) { throw new ArrayIndexOutOfBoundsException ( "negative offset" ) ; } _offset = offset ; } public IntegerField ( final int offset , final int value ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; set ( value ) ; } public IntegerField ( final int offset , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; readFromBytes ( data ) ; } public IntegerField ( final int offset , final int value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { this ( offset ) ; set ( value , data ) ; } public int get ( ) { return _value ; } public void set ( final int value ) { _value = value ; } public void set ( final int value , final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = value ; writeToBytes ( data ) ; } public void readFromBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { _value = LittleEndian . getInt ( data , _offset ) ; } public void readFromStream ( final InputStream stream ) throws IOException , BufferUnderrunException { _value = LittleEndian . readInt ( stream ) ; } public void writeToBytes ( final byte [ ] data ) throws ArrayIndexOutOfBoundsException { LittleEndian . putInt ( data , _offset , _value ) ; } public String toString ( ) { return String . valueOf ( _value ) ; } } 	0	['11', '1', '0', '7', '17', '9', '4', '3', '11', '0.25', '85', '1', '0', '0', '0.522727273', '0', '0', '6.545454545', '1', '0.6364', '0']
package org . apache . poi . poifs . dev ; import java . io . * ; import java . util . * ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; public class POIFSViewer { public static void main ( final String args [ ] ) { if ( args . length < 0 ) { System . err . println ( "Must specify at least one file to view" ) ; System . exit ( 1 ) ; } boolean printNames = ( args . length > 1 ) ; for ( int j = 0 ; j < args . length ; j ++ ) { viewFile ( args [ j ] , printNames ) ; } } private static void viewFile ( final String filename , final boolean printName ) { if ( printName ) { StringBuffer flowerbox = new StringBuffer ( ) ; flowerbox . append ( "." ) ; for ( int j = 0 ; j < filename . length ( ) ; j ++ ) { flowerbox . append ( "-" ) ; } flowerbox . append ( "." ) ; System . out . println ( flowerbox ) ; System . out . println ( "|" + filename + "|" ) ; System . out . println ( flowerbox ) ; } try { POIFSViewable fs = new POIFSFileSystem ( new FileInputStream ( filename ) ) ; List strings = POIFSViewEngine . inspectViewable ( fs , true , 0 , "  " ) ; Iterator iter = strings . iterator ( ) ; while ( iter . hasNext ( ) ) { System . out . print ( iter . next ( ) ) ; } } catch ( IOException e ) { System . out . println ( e . getMessage ( ) ) ; } } } 	0	['3', '1', '0', '2', '21', '3', '0', '2', '2', '2', '112', '0', '0', '0', '0.333333333', '0', '0', '36.33333333', '4', '2.3333', '0']
package org . apache . poi . hssf . usermodel ; import java . util . * ; import java . awt . * ; import java . io . * ; class StaticFontMetrics { private static Properties fontMetricsProps ; private static Map fontDetailsMap = new HashMap ( ) ; public static FontDetails getFontDetails ( Font font ) { if ( fontMetricsProps == null ) { InputStream metricsIn = null ; try { fontMetricsProps = new Properties ( ) ; if ( System . getProperty ( "font.metrics.filename" ) != null ) { String filename = System . getProperty ( "font.metrics.filename" ) ; File file = new File ( filename ) ; if ( ! file . exists ( ) ) throw new FileNotFoundException ( "font_metrics.properties not found at path " + file . getAbsolutePath ( ) ) ; metricsIn = new FileInputStream ( file ) ; } else { metricsIn = FontDetails . class . getResourceAsStream ( "/font_metrics.properties" ) ; if ( metricsIn == null ) throw new FileNotFoundException ( "font_metrics.properties not found in classpath" ) ; } fontMetricsProps . load ( metricsIn ) ; } catch ( IOException e ) { throw new RuntimeException ( "Could not load font metrics: " + e . getMessage ( ) ) ; } finally { if ( metricsIn != null ) { try { metricsIn . close ( ) ; } catch ( IOException ignore ) { } } } } String fontName = font . getName ( ) ; if ( fontDetailsMap . get ( fontName ) == null ) { FontDetails fontDetails = FontDetails . create ( fontName , fontMetricsProps ) ; fontDetailsMap . put ( fontName , fontDetails ) ; return fontDetails ; } else { return ( FontDetails ) fontDetailsMap . get ( fontName ) ; } } } 	0	['3', '1', '0', '2', '24', '1', '1', '1', '1', '0.75', '121', '1', '0', '0', '0.5', '0', '0', '38.66666667', '8', '2.6667', '0']
package org . apache . poi . poifs . property ; import java . util . Iterator ; import java . io . IOException ; public interface Parent extends Child { public Iterator getChildren ( ) ; public void addChild ( final Property property ) throws IOException ; public void setPreviousChild ( final Child child ) ; public void setNextChild ( final Child child ) ; } 	0	['4', '1', '0', '3', '4', '6', '1', '2', '4', '2', '4', '0', '0', '0', '0.583333333', '0', '0', '0', '1', '1', '0']
package org . apache . poi . poifs . eventfilesystem ; import org . apache . poi . poifs . filesystem . DocumentInputStream ; import org . apache . poi . poifs . filesystem . POIFSDocumentPath ; public class POIFSReaderEvent { private DocumentInputStream stream ; private POIFSDocumentPath path ; private String documentName ; POIFSReaderEvent ( final DocumentInputStream stream , final POIFSDocumentPath path , final String documentName ) { this . stream = stream ; this . path = path ; this . documentName = documentName ; } public DocumentInputStream getStream ( ) { return stream ; } public POIFSDocumentPath getPath ( ) { return path ; } public String getName ( ) { return documentName ; } } 	0	['4', '1', '0', '5', '5', '0', '3', '2', '3', '0.666666667', '28', '1', '2', '0', '0.4375', '0', '0', '5.25', '1', '0.75', '0']
package org . apache . poi . poifs . property ; import java . io . IOException ; import java . io . OutputStream ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . filesystem . BATManaged ; import org . apache . poi . poifs . storage . BlockWritable ; import org . apache . poi . poifs . storage . PropertyBlock ; import org . apache . poi . poifs . storage . RawDataBlock ; import org . apache . poi . poifs . storage . RawDataBlockList ; public class PropertyTable implements BATManaged , BlockWritable { private int _start_block ; private List _properties ; private BlockWritable [ ] _blocks ; public PropertyTable ( ) { _start_block = POIFSConstants . END_OF_CHAIN ; _properties = new ArrayList ( ) ; addProperty ( new RootProperty ( ) ) ; _blocks = null ; } public PropertyTable ( final int startBlock , final RawDataBlockList blockList ) throws IOException { _start_block = POIFSConstants . END_OF_CHAIN ; _blocks = null ; _properties = PropertyFactory . convertToProperties ( blockList . fetchBlocks ( startBlock ) ) ; populatePropertyTree ( ( DirectoryProperty ) _properties . get ( 0 ) ) ; } public void addProperty ( final Property property ) { _properties . add ( property ) ; } public void removeProperty ( final Property property ) { _properties . remove ( property ) ; } public RootProperty getRoot ( ) { return ( RootProperty ) _properties . get ( 0 ) ; } public void preWrite ( ) { Property [ ] properties = ( Property [ ] ) _properties . toArray ( new Property [ 0 ] ) ; for ( int k = 0 ; k < properties . length ; k ++ ) { properties [ k ] . setIndex ( k ) ; } _blocks = PropertyBlock . createPropertyBlockArray ( _properties ) ; for ( int k = 0 ; k < properties . length ; k ++ ) { properties [ k ] . preWrite ( ) ; } } public int getStartBlock ( ) { return _start_block ; } private void populatePropertyTree ( DirectoryProperty root ) throws IOException { int index = root . getChildIndex ( ) ; if ( ! Property . isValidIndex ( index ) ) { return ; } Stack children = new Stack ( ) ; children . push ( _properties . get ( index ) ) ; while ( ! children . empty ( ) ) { Property property = ( Property ) children . pop ( ) ; root . addChild ( property ) ; if ( property . isDirectory ( ) ) { populatePropertyTree ( ( DirectoryProperty ) property ) ; } index = property . getPreviousChildIndex ( ) ; if ( Property . isValidIndex ( index ) ) { children . push ( _properties . get ( index ) ) ; } index = property . getNextChildIndex ( ) ; if ( Property . isValidIndex ( index ) ) { children . push ( _properties . get ( index ) ) ; } } } public int countBlocks ( ) { return ( _blocks == null ) ? 0 : _blocks . length ; } public void setStartBlock ( final int index ) { _start_block = index ; } public void writeBlocks ( final OutputStream stream ) throws IOException { if ( _blocks != null ) { for ( int j = 0 ; j < _blocks . length ; j ++ ) { _blocks [ j ] . writeBlocks ( stream ) ; } } } } 	0	['11', '1', '0', '11', '34', '0', '2', '9', '10', '0.566666667', '210', '1', '1', '0', '0.272727273', '0', '0', '17.81818182', '3', '1.0909', '0']
package org . apache . poi . ddf ; import java . util . HashMap ; import java . util . Map ; public class EscherProperties { public static final short TRANSFORM__ROTATION = 4 ; public static final short PROTECTION__LOCKROTATION = 119 ; public static final short PROTECTION__LOCKASPECTRATIO = 120 ; public static final short PROTECTION__LOCKPOSITION = 121 ; public static final short PROTECTION__LOCKAGAINSTSELECT = 122 ; public static final short PROTECTION__LOCKCROPPING = 123 ; public static final short PROTECTION__LOCKVERTICES = 124 ; public static final short PROTECTION__LOCKTEXT = 125 ; public static final short PROTECTION__LOCKADJUSTHANDLES = 126 ; public static final short PROTECTION__LOCKAGAINSTGROUPING = 127 ; public static final short TEXT__TEXTID = 128 ; public static final short TEXT__TEXTLEFT = 129 ; public static final short TEXT__TEXTTOP = 130 ; public static final short TEXT__TEXTRIGHT = 131 ; public static final short TEXT__TEXTBOTTOM = 132 ; public static final short TEXT__WRAPTEXT = 133 ; public static final short TEXT__SCALETEXT = 134 ; public static final short TEXT__ANCHORTEXT = 135 ; public static final short TEXT__TEXTFLOW = 136 ; public static final short TEXT__FONTROTATION = 137 ; public static final short TEXT__IDOFNEXTSHAPE = 138 ; public static final short TEXT__BIDIR = 139 ; public static final short TEXT__SINGLECLICKSELECTS = 187 ; public static final short TEXT__USEHOSTMARGINS = 188 ; public static final short TEXT__ROTATETEXTWITHSHAPE = 189 ; public static final short TEXT__SIZESHAPETOFITTEXT = 190 ; public static final short TEXT__SIZE_TEXT_TO_FIT_SHAPE = 191 ; public static final short GEOTEXT__UNICODE = 192 ; public static final short GEOTEXT__RTFTEXT = 193 ; public static final short GEOTEXT__ALIGNMENTONCURVE = 194 ; public static final short GEOTEXT__DEFAULTPOINTSIZE = 195 ; public static final short GEOTEXT__TEXTSPACING = 196 ; public static final short GEOTEXT__FONTFAMILYNAME = 197 ; public static final short GEOTEXT__REVERSEROWORDER = 240 ; public static final short GEOTEXT__HASTEXTEFFECT = 241 ; public static final short GEOTEXT__ROTATECHARACTERS = 242 ; public static final short GEOTEXT__KERNCHARACTERS = 243 ; public static final short GEOTEXT__TIGHTORTRACK = 244 ; public static final short GEOTEXT__STRETCHTOFITSHAPE = 245 ; public static final short GEOTEXT__CHARBOUNDINGBOX = 246 ; public static final short GEOTEXT__SCALETEXTONPATH = 247 ; public static final short GEOTEXT__STRETCHCHARHEIGHT = 248 ; public static final short GEOTEXT__NOMEASUREALONGPATH = 249 ; public static final short GEOTEXT__BOLDFONT = 250 ; public static final short GEOTEXT__ITALICFONT = 251 ; public static final short GEOTEXT__UNDERLINEFONT = 252 ; public static final short GEOTEXT__SHADOWFONT = 253 ; public static final short GEOTEXT__SMALLCAPSFONT = 254 ; public static final short GEOTEXT__STRIKETHROUGHFONT = 255 ; public static final short BLIP__CROPFROMTOP = 256 ; public static final short BLIP__CROPFROMBOTTOM = 257 ; public static final short BLIP__CROPFROMLEFT = 258 ; public static final short BLIP__CROPFROMRIGHT = 259 ; public static final short BLIP__BLIPTODISPLAY = 260 ; public static final short BLIP__BLIPFILENAME = 261 ; public static final short BLIP__BLIPFLAGS = 262 ; public static final short BLIP__TRANSPARENTCOLOR = 263 ; public static final short BLIP__CONTRASTSETTING = 264 ; public static final short BLIP__BRIGHTNESSSETTING = 265 ; public static final short BLIP__GAMMA = 266 ; public static final short BLIP__PICTUREID = 267 ; public static final short BLIP__DOUBLEMOD = 268 ; public static final short BLIP__PICTUREFILLMOD = 269 ; public static final short BLIP__PICTURELINE = 270 ; public static final short BLIP__PRINTBLIP = 271 ; public static final short BLIP__PRINTBLIPFILENAME = 272 ; public static final short BLIP__PRINTFLAGS = 273 ; public static final short BLIP__NOHITTESTPICTURE = 316 ; public static final short BLIP__PICTUREGRAY = 317 ; public static final short BLIP__PICTUREBILEVEL = 318 ; public static final short BLIP__PICTUREACTIVE = 319 ; public static final short GEOMETRY__LEFT = 320 ; public static final short GEOMETRY__TOP = 321 ; public static final short GEOMETRY__RIGHT = 322 ; public static final short GEOMETRY__BOTTOM = 323 ; public static final short GEOMETRY__SHAPEPATH = 324 ; public static final short GEOMETRY__VERTICES = 325 ; public static final short GEOMETRY__SEGMENTINFO = 326 ; public static final short GEOMETRY__ADJUSTVALUE = 327 ; public static final short GEOMETRY__ADJUST2VALUE = 328 ; public static final short GEOMETRY__ADJUST3VALUE = 329 ; public static final short GEOMETRY__ADJUST4VALUE = 330 ; public static final short GEOMETRY__ADJUST5VALUE = 331 ; public static final short GEOMETRY__ADJUST6VALUE = 332 ; public static final short GEOMETRY__ADJUST7VALUE = 333 ; public static final short GEOMETRY__ADJUST8VALUE = 334 ; public static final short GEOMETRY__ADJUST9VALUE = 335 ; public static final short GEOMETRY__ADJUST10VALUE = 336 ; public static final short GEOMETRY__SHADOWok = 378 ; public static final short GEOMETRY__3DOK = 379 ; public static final short GEOMETRY__LINEOK = 380 ; public static final short GEOMETRY__GEOTEXTOK = 381 ; public static final short GEOMETRY__FILLSHADESHAPEOK = 382 ; public static final short GEOMETRY__FILLOK = 383 ; public static final short FILL__FILLTYPE = 384 ; public static final short FILL__FILLCOLOR = 385 ; public static final short FILL__FILLOPACITY = 386 ; public static final short FILL__FILLBACKCOLOR = 387 ; public static final short FILL__BACKOPACITY = 388 ; public static final short FILL__CRMOD = 389 ; public static final short FILL__PATTERNTEXTURE = 390 ; public static final short FILL__BLIPFILENAME = 391 ; public static final short FILL__BLIPFLAGS = 392 ; public static final short FILL__WIDTH = 393 ; public static final short FILL__HEIGHT = 394 ; public static final short FILL__ANGLE = 395 ; public static final short FILL__FOCUS = 396 ; public static final short FILL__TOLEFT = 397 ; public static final short FILL__TOTOP = 398 ; public static final short FILL__TORIGHT = 399 ; public static final short FILL__TOBOTTOM = 400 ; public static final short FILL__RECTLEFT = 401 ; public static final short FILL__RECTTOP = 402 ; public static final short FILL__RECTRIGHT = 403 ; public static final short FILL__RECTBOTTOM = 404 ; public static final short FILL__DZTYPE = 405 ; public static final short FILL__SHADEPRESET = 406 ; public static final short FILL__SHADECOLORS = 407 ; public static final short FILL__ORIGINX = 408 ; public static final short FILL__ORIGINY = 409 ; public static final short FILL__SHAPEORIGINX = 410 ; public static final short FILL__SHAPEORIGINY = 411 ; public static final short FILL__SHADETYPE = 412 ; public static final short FILL__FILLED = 443 ; public static final short FILL__HITTESTFILL = 444 ; public static final short FILL__SHAPE = 445 ; public static final short FILL__USERECT = 446 ; public static final short FILL__NOFILLHITTEST = 447 ; public static final short LINESTYLE__COLOR = 448 ; public static final short LINESTYLE__OPACITY = 449 ; public static final short LINESTYLE__BACKCOLOR = 450 ; public static final short LINESTYLE__CRMOD = 451 ; public static final short LINESTYLE__LINETYPE = 452 ; public static final short LINESTYLE__FILLBLIP = 453 ; public static final short LINESTYLE__FILLBLIPNAME = 454 ; public static final short LINESTYLE__FILLBLIPFLAGS = 455 ; public static final short LINESTYLE__FILLWIDTH = 456 ; public static final short LINESTYLE__FILLHEIGHT = 457 ; public static final short LINESTYLE__FILLDZTYPE = 458 ; public static final short LINESTYLE__LINEWIDTH = 459 ; public static final short LINESTYLE__LINEMITERLIMIT = 460 ; public static final short LINESTYLE__LINESTYLE = 461 ; public static final short LINESTYLE__LINEDASHING = 462 ; public static final short LINESTYLE__LINEDASHSTYLE = 463 ; public static final short LINESTYLE__LINESTARTARROWHEAD = 464 ; public static final short LINESTYLE__LINEENDARROWHEAD = 465 ; public static final short LINESTYLE__LINESTARTARROWWIDTH = 466 ; public static final short LINESTYLE__LINEESTARTARROWLENGTH = 467 ; public static final short LINESTYLE__LINEENDARROWWIDTH = 468 ; public static final short LINESTYLE__LINEENDARROWLENGTH = 469 ; public static final short LINESTYLE__LINEJOINSTYLE = 470 ; public static final short LINESTYLE__LINEENDCAPSTYLE = 471 ; public static final short LINESTYLE__ARROWHEADSOK = 507 ; public static final short LINESTYLE__ANYLINE = 508 ; public static final short LINESTYLE__HITLINETEST = 509 ; public static final short LINESTYLE__LINEFILLSHAPE = 510 ; public static final short LINESTYLE__NOLINEDRAWDASH = 511 ; public static final short SHADOWSTYLE__TYPE = 512 ; public static final short SHADOWSTYLE__COLOR = 513 ; public static final short SHADOWSTYLE__HIGHLIGHT = 514 ; public static final short SHADOWSTYLE__CRMOD = 515 ; public static final short SHADOWSTYLE__OPACITY = 516 ; public static final short SHADOWSTYLE__OFFSETX = 517 ; public static final short SHADOWSTYLE__OFFSETY = 518 ; public static final short SHADOWSTYLE__SECONDOFFSETX = 519 ; public static final short SHADOWSTYLE__SECONDOFFSETY = 520 ; public static final short SHADOWSTYLE__SCALEXTOX = 521 ; public static final short SHADOWSTYLE__SCALEYTOX = 522 ; public static final short SHADOWSTYLE__SCALEXTOY = 523 ; public static final short SHADOWSTYLE__SCALEYTOY = 524 ; public static final short SHADOWSTYLE__PERSPECTIVEX = 525 ; public static final short SHADOWSTYLE__PERSPECTIVEY = 526 ; public static final short SHADOWSTYLE__WEIGHT = 527 ; public static final short SHADOWSTYLE__ORIGINX = 528 ; public static final short SHADOWSTYLE__ORIGINY = 529 ; public static final short SHADOWSTYLE__SHADOW = 574 ; public static final short SHADOWSTYLE__SHADOWOBSURED = 575 ; public static final short PERSPECTIVE__TYPE = 576 ; public static final short PERSPECTIVE__OFFSETX = 577 ; public static final short PERSPECTIVE__OFFSETY = 578 ; public static final short PERSPECTIVE__SCALEXTOX = 579 ; public static final short PERSPECTIVE__SCALEYTOX = 580 ; public static final short PERSPECTIVE__SCALEXTOY = 581 ; public static final short PERSPECTIVE__SCALEYTOY = 582 ; public static final short PERSPECTIVE__PERSPECTIVEX = 583 ; public static final short PERSPECTIVE__PERSPECTIVEY = 584 ; public static final short PERSPECTIVE__WEIGHT = 585 ; public static final short PERSPECTIVE__ORIGINX = 586 ; public static final short PERSPECTIVE__ORIGINY = 587 ; public static final short PERSPECTIVE__PERSPECTIVEON = 639 ; public static final short THREED__SPECULARAMOUNT = 640 ; public static final short THREED__DIFFUSEAMOUNT = 661 ; public static final short THREED__SHININESS = 662 ; public static final short THREED__EDGETHICKNESS = 663 ; public static final short THREED__EXTRUDEFORWARD = 664 ; public static final short THREED__EXTRUDEBACKWARD = 665 ; public static final short THREED__EXTRUDEPLANE = 666 ; public static final short THREED__EXTRUSIONCOLOR = 667 ; public static final short THREED__CRMOD = 648 ; public static final short THREED__3DEFFECT = 700 ; public static final short THREED__METALLIC = 701 ; public static final short THREED__USEEXTRUSIONCOLOR = 702 ; public static final short THREED__LIGHTFACE = 703 ; public static final short THREEDSTYLE__YROTATIONANGLE = 704 ; public static final short THREEDSTYLE__XROTATIONANGLE = 705 ; public static final short THREEDSTYLE__ROTATIONAXISX = 706 ; public static final short THREEDSTYLE__ROTATIONAXISY = 707 ; public static final short THREEDSTYLE__ROTATIONAXISZ = 708 ; public static final short THREEDSTYLE__ROTATIONANGLE = 709 ; public static final short THREEDSTYLE__ROTATIONCENTERX = 710 ; public static final short THREEDSTYLE__ROTATIONCENTERY = 711 ; public static final short THREEDSTYLE__ROTATIONCENTERZ = 712 ; public static final short THREEDSTYLE__RENDERMODE = 713 ; public static final short THREEDSTYLE__TOLERANCE = 714 ; public static final short THREEDSTYLE__XVIEWPOINT = 715 ; public static final short THREEDSTYLE__YVIEWPOINT = 716 ; public static final short THREEDSTYLE__ZVIEWPOINT = 717 ; public static final short THREEDSTYLE__ORIGINX = 718 ; public static final short THREEDSTYLE__ORIGINY = 719 ; public static final short THREEDSTYLE__SKEWANGLE = 720 ; public static final short THREEDSTYLE__SKEWAMOUNT = 721 ; public static final short THREEDSTYLE__AMBIENTINTENSITY = 722 ; public static final short THREEDSTYLE__KEYX = 723 ; public static final short THREEDSTYLE__KEYY = 724 ; public static final short THREEDSTYLE__KEYZ = 725 ; public static final short THREEDSTYLE__KEYINTENSITY = 726 ; public static final short THREEDSTYLE__FILLX = 727 ; public static final short THREEDSTYLE__FILLY = 728 ; public static final short THREEDSTYLE__FILLZ = 729 ; public static final short THREEDSTYLE__FILLINTENSITY = 730 ; public static final short THREEDSTYLE__CONSTRAINROTATION = 763 ; public static final short THREEDSTYLE__ROTATIONCENTERAUTO = 764 ; public static final short THREEDSTYLE__PARALLEL = 765 ; public static final short THREEDSTYLE__KEYHARSH = 766 ; public static final short THREEDSTYLE__FILLHARSH = 767 ; public static final short SHAPE__MASTER = 769 ; public static final short SHAPE__CONNECTORSTYLE = 771 ; public static final short SHAPE__BLACKANDWHITESETTINGS = 772 ; public static final short SHAPE__WMODEPUREBW = 773 ; public static final short SHAPE__WMODEBW = 774 ; public static final short SHAPE__OLEICON = 826 ; public static final short SHAPE__PREFERRELATIVERESIZE = 827 ; public static final short SHAPE__LOCKSHAPETYPE = 828 ; public static final short SHAPE__DELETEATTACHEDOBJECT = 830 ; public static final short SHAPE__BACKGROUNDSHAPE = 831 ; public static final short CALLOUT__CALLOUTTYPE = 832 ; public static final short CALLOUT__XYCALLOUTGAP = 833 ; public static final short CALLOUT__CALLOUTANGLE = 834 ; public static final short CALLOUT__CALLOUTDROPTYPE = 835 ; public static final short CALLOUT__CALLOUTDROPSPECIFIED = 836 ; public static final short CALLOUT__CALLOUTLENGTHSPECIFIED = 837 ; public static final short CALLOUT__ISCALLOUT = 889 ; public static final short CALLOUT__CALLOUTACCENTBAR = 890 ; public static final short CALLOUT__CALLOUTTEXTBORDER = 891 ; public static final short CALLOUT__CALLOUTMINUSX = 892 ; public static final short CALLOUT__CALLOUTMINUSY = 893 ; public static final short CALLOUT__DROPAUTO = 894 ; public static final short CALLOUT__LENGTHSPECIFIED = 895 ; public static final short GROUPSHAPE__SHAPENAME = 896 ; public static final short GROUPSHAPE__DESCRIPTION = 897 ; public static final short GROUPSHAPE__HYPERLINK = 898 ; public static final short GROUPSHAPE__WRAPPOLYGONVERTICES = 899 ; public static final short GROUPSHAPE__WRAPDISTLEFT = 900 ; public static final short GROUPSHAPE__WRAPDISTTOP = 901 ; public static final short GROUPSHAPE__WRAPDISTRIGHT = 902 ; public static final short GROUPSHAPE__WRAPDISTBOTTOM = 903 ; public static final short GROUPSHAPE__REGROUPID = 904 ; public static final short GROUPSHAPE__EDITEDWRAP = 953 ; public static final short GROUPSHAPE__BEHINDDOCUMENT = 954 ; public static final short GROUPSHAPE__ONDBLCLICKNOTIFY = 955 ; public static final short GROUPSHAPE__ISBUTTON = 956 ; public static final short GROUPSHAPE__1DADJUSTMENT = 957 ; public static final short GROUPSHAPE__HIDDEN = 958 ; public static final short GROUPSHAPE__PRINT = 959 ; private static Map properties ; private static void initProps ( ) { if ( properties == null ) { properties = new HashMap ( ) ; addProp ( TRANSFORM__ROTATION , data ( "transform.rotation" ) ) ; addProp ( PROTECTION__LOCKROTATION , data ( "protection.lockrotation" ) ) ; addProp ( PROTECTION__LOCKASPECTRATIO , data ( "protection.lockaspectratio" ) ) ; addProp ( PROTECTION__LOCKPOSITION , data ( "protection.lockposition" ) ) ; addProp ( PROTECTION__LOCKAGAINSTSELECT , data ( "protection.lockagainstselect" ) ) ; addProp ( PROTECTION__LOCKCROPPING , data ( "protection.lockcropping" ) ) ; addProp ( PROTECTION__LOCKVERTICES , data ( "protection.lockvertices" ) ) ; addProp ( PROTECTION__LOCKTEXT , data ( "protection.locktext" ) ) ; addProp ( PROTECTION__LOCKADJUSTHANDLES , data ( "protection.lockadjusthandles" ) ) ; addProp ( PROTECTION__LOCKAGAINSTGROUPING , data ( "protection.lockagainstgrouping" , EscherPropertyMetaData . TYPE_BOOLEAN ) ) ; addProp ( TEXT__TEXTID , data ( "text.textid" ) ) ; addProp ( TEXT__TEXTLEFT , data ( "text.textleft" ) ) ; addProp ( TEXT__TEXTTOP , data ( "text.texttop" ) ) ; addProp ( TEXT__TEXTRIGHT , data ( "text.textright" ) ) ; addProp ( TEXT__TEXTBOTTOM , data ( "text.textbottom" ) ) ; addProp ( TEXT__WRAPTEXT , data ( "text.wraptext" ) ) ; addProp ( TEXT__SCALETEXT , data ( "text.scaletext" ) ) ; addProp ( TEXT__ANCHORTEXT , data ( "text.anchortext" ) ) ; addProp ( TEXT__TEXTFLOW , data ( "text.textflow" ) ) ; addProp ( TEXT__FONTROTATION , data ( "text.fontrotation" ) ) ; addProp ( TEXT__IDOFNEXTSHAPE , data ( "text.idofnextshape" ) ) ; addProp ( TEXT__BIDIR , data ( "text.bidir" ) ) ; addProp ( TEXT__SINGLECLICKSELECTS , data ( "text.singleclickselects" ) ) ; addProp ( TEXT__USEHOSTMARGINS , data ( "text.usehostmargins" ) ) ; addProp ( TEXT__ROTATETEXTWITHSHAPE , data ( "text.rotatetextwithshape" ) ) ; addProp ( TEXT__SIZESHAPETOFITTEXT , data ( "text.sizeshapetofittext" ) ) ; addProp ( TEXT__SIZE_TEXT_TO_FIT_SHAPE , data ( "text.sizetexttofitshape" , EscherPropertyMetaData . TYPE_BOOLEAN ) ) ; addProp ( GEOTEXT__UNICODE , data ( "geotext.unicode" ) ) ; addProp ( GEOTEXT__RTFTEXT , data ( "geotext.rtftext" ) ) ; addProp ( GEOTEXT__ALIGNMENTONCURVE , data ( "geotext.alignmentoncurve" ) ) ; addProp ( GEOTEXT__DEFAULTPOINTSIZE , data ( "geotext.defaultpointsize" ) ) ; addProp ( GEOTEXT__TEXTSPACING , data ( "geotext.textspacing" ) ) ; addProp ( GEOTEXT__FONTFAMILYNAME , data ( "geotext.fontfamilyname" ) ) ; addProp ( GEOTEXT__REVERSEROWORDER , data ( "geotext.reverseroworder" ) ) ; addProp ( GEOTEXT__HASTEXTEFFECT , data ( "geotext.hastexteffect" ) ) ; addProp ( GEOTEXT__ROTATECHARACTERS , data ( "geotext.rotatecharacters" ) ) ; addProp ( GEOTEXT__KERNCHARACTERS , data ( "geotext.kerncharacters" ) ) ; addProp ( GEOTEXT__TIGHTORTRACK , data ( "geotext.tightortrack" ) ) ; addProp ( GEOTEXT__STRETCHTOFITSHAPE , data ( "geotext.stretchtofitshape" ) ) ; addProp ( GEOTEXT__CHARBOUNDINGBOX , data ( "geotext.charboundingbox" ) ) ; addProp ( GEOTEXT__SCALETEXTONPATH , data ( "geotext.scaletextonpath" ) ) ; addProp ( GEOTEXT__STRETCHCHARHEIGHT , data ( "geotext.stretchcharheight" ) ) ; addProp ( GEOTEXT__NOMEASUREALONGPATH , data ( "geotext.nomeasurealongpath" ) ) ; addProp ( GEOTEXT__BOLDFONT , data ( "geotext.boldfont" ) ) ; addProp ( GEOTEXT__ITALICFONT , data ( "geotext.italicfont" ) ) ; addProp ( GEOTEXT__UNDERLINEFONT , data ( "geotext.underlinefont" ) ) ; addProp ( GEOTEXT__SHADOWFONT , data ( "geotext.shadowfont" ) ) ; addProp ( GEOTEXT__SMALLCAPSFONT , data ( "geotext.smallcapsfont" ) ) ; addProp ( GEOTEXT__STRIKETHROUGHFONT , data ( "geotext.strikethroughfont" ) ) ; addProp ( BLIP__CROPFROMTOP , data ( "blip.cropfromtop" ) ) ; addProp ( BLIP__CROPFROMBOTTOM , data ( "blip.cropfrombottom" ) ) ; addProp ( BLIP__CROPFROMLEFT , data ( "blip.cropfromleft" ) ) ; addProp ( BLIP__CROPFROMRIGHT , data ( "blip.cropfromright" ) ) ; addProp ( BLIP__BLIPTODISPLAY , data ( "blip.bliptodisplay" ) ) ; addProp ( BLIP__BLIPFILENAME , data ( "blip.blipfilename" ) ) ; addProp ( BLIP__BLIPFLAGS , data ( "blip.blipflags" ) ) ; addProp ( BLIP__TRANSPARENTCOLOR , data ( "blip.transparentcolor" ) ) ; addProp ( BLIP__CONTRASTSETTING , data ( "blip.contrastsetting" ) ) ; addProp ( BLIP__BRIGHTNESSSETTING , data ( "blip.brightnesssetting" ) ) ; addProp ( BLIP__GAMMA , data ( "blip.gamma" ) ) ; addProp ( BLIP__PICTUREID , data ( "blip.pictureid" ) ) ; addProp ( BLIP__DOUBLEMOD , data ( "blip.doublemod" ) ) ; addProp ( BLIP__PICTUREFILLMOD , data ( "blip.picturefillmod" ) ) ; addProp ( BLIP__PICTURELINE , data ( "blip.pictureline" ) ) ; addProp ( BLIP__PRINTBLIP , data ( "blip.printblip" ) ) ; addProp ( BLIP__PRINTBLIPFILENAME , data ( "blip.printblipfilename" ) ) ; addProp ( BLIP__PRINTFLAGS , data ( "blip.printflags" ) ) ; addProp ( BLIP__NOHITTESTPICTURE , data ( "blip.nohittestpicture" ) ) ; addProp ( BLIP__PICTUREGRAY , data ( "blip.picturegray" ) ) ; addProp ( BLIP__PICTUREBILEVEL , data ( "blip.picturebilevel" ) ) ; addProp ( BLIP__PICTUREACTIVE , data ( "blip.pictureactive" ) ) ; addProp ( GEOMETRY__LEFT , data ( "geometry.left" ) ) ; addProp ( GEOMETRY__TOP , data ( "geometry.top" ) ) ; addProp ( GEOMETRY__RIGHT , data ( "geometry.right" ) ) ; addProp ( GEOMETRY__BOTTOM , data ( "geometry.bottom" ) ) ; addProp ( GEOMETRY__SHAPEPATH , data ( "geometry.shapepath" , EscherPropertyMetaData . TYPE_SHAPEPATH ) ) ; addProp ( GEOMETRY__VERTICES , data ( "geometry.vertices" , EscherPropertyMetaData . TYPE_ARRAY ) ) ; addProp ( GEOMETRY__SEGMENTINFO , data ( "geometry.segmentinfo" , EscherPropertyMetaData . TYPE_ARRAY ) ) ; addProp ( GEOMETRY__ADJUSTVALUE , data ( "geometry.adjustvalue" ) ) ; addProp ( GEOMETRY__ADJUST2VALUE , data ( "geometry.adjust2value" ) ) ; addProp ( GEOMETRY__ADJUST3VALUE , data ( "geometry.adjust3value" ) ) ; addProp ( GEOMETRY__ADJUST4VALUE , data ( "geometry.adjust4value" ) ) ; addProp ( GEOMETRY__ADJUST5VALUE , data ( "geometry.adjust5value" ) ) ; addProp ( GEOMETRY__ADJUST6VALUE , data ( "geometry.adjust6value" ) ) ; addProp ( GEOMETRY__ADJUST7VALUE , data ( "geometry.adjust7value" ) ) ; addProp ( GEOMETRY__ADJUST8VALUE , data ( "geometry.adjust8value" ) ) ; addProp ( GEOMETRY__ADJUST9VALUE , data ( "geometry.adjust9value" ) ) ; addProp ( GEOMETRY__ADJUST10VALUE , data ( "geometry.adjust10value" ) ) ; addProp ( GEOMETRY__SHADOWok , data ( "geometry.shadowOK" ) ) ; addProp ( GEOMETRY__3DOK , data ( "geometry.3dok" ) ) ; addProp ( GEOMETRY__LINEOK , data ( "geometry.lineok" ) ) ; addProp ( GEOMETRY__GEOTEXTOK , data ( "geometry.geotextok" ) ) ; addProp ( GEOMETRY__FILLSHADESHAPEOK , data ( "geometry.fillshadeshapeok" ) ) ; addProp ( GEOMETRY__FILLOK , data ( "geometry.fillok" , EscherPropertyMetaData . TYPE_BOOLEAN ) ) ; addProp ( FILL__FILLTYPE , data ( "fill.filltype" ) ) ; addProp ( FILL__FILLCOLOR , data ( "fill.fillcolor" , EscherPropertyMetaData . TYPE_RGB ) ) ; addProp ( FILL__FILLOPACITY , data ( "fill.fillopacity" ) ) ; addProp ( FILL__FILLBACKCOLOR , data ( "fill.fillbackcolor" , EscherPropertyMetaData . TYPE_RGB ) ) ; addProp ( FILL__BACKOPACITY , data ( "fill.backopacity" ) ) ; addProp ( FILL__CRMOD , data ( "fill.crmod" ) ) ; addProp ( FILL__PATTERNTEXTURE , data ( "fill.patterntexture" ) ) ; addProp ( FILL__BLIPFILENAME , data ( "fill.blipfilename" ) ) ; addProp ( FILL__BLIPFLAGS , data ( "fill.blipflags" ) ) ; addProp ( FILL__WIDTH , data ( "fill.width" ) ) ; addProp ( FILL__HEIGHT , data ( "fill.height" ) ) ; addProp ( FILL__ANGLE , data ( "fill.angle" ) ) ; addProp ( FILL__FOCUS , data ( "fill.focus" ) ) ; addProp ( FILL__TOLEFT , data ( "fill.toleft" ) ) ; addProp ( FILL__TOTOP , data ( "fill.totop" ) ) ; addProp ( FILL__TORIGHT , data ( "fill.toright" ) ) ; addProp ( FILL__TOBOTTOM , data ( "fill.tobottom" ) ) ; addProp ( FILL__RECTLEFT , data ( "fill.rectleft" ) ) ; addProp ( FILL__RECTTOP , data ( "fill.recttop" ) ) ; addProp ( FILL__RECTRIGHT , data ( "fill.rectright" ) ) ; addProp ( FILL__RECTBOTTOM , data ( "fill.rectbottom" ) ) ; addProp ( FILL__DZTYPE , data ( "fill.dztype" ) ) ; addProp ( FILL__SHADEPRESET , data ( "fill.shadepreset" ) ) ; addProp ( FILL__SHADECOLORS , data ( "fill.shadecolors" , EscherPropertyMetaData . TYPE_ARRAY ) ) ; addProp ( FILL__ORIGINX , data ( "fill.originx" ) ) ; addProp ( FILL__ORIGINY , data ( "fill.originy" ) ) ; addProp ( FILL__SHAPEORIGINX , data ( "fill.shapeoriginx" ) ) ; addProp ( FILL__SHAPEORIGINY , data ( "fill.shapeoriginy" ) ) ; addProp ( FILL__SHADETYPE , data ( "fill.shadetype" ) ) ; addProp ( FILL__FILLED , data ( "fill.filled" ) ) ; addProp ( FILL__HITTESTFILL , data ( "fill.hittestfill" ) ) ; addProp ( FILL__SHAPE , data ( "fill.shape" ) ) ; addProp ( FILL__USERECT , data ( "fill.userect" ) ) ; addProp ( FILL__NOFILLHITTEST , data ( "fill.nofillhittest" , EscherPropertyMetaData . TYPE_BOOLEAN ) ) ; addProp ( LINESTYLE__COLOR , data ( "linestyle.color" , EscherPropertyMetaData . TYPE_RGB ) ) ; addProp ( LINESTYLE__OPACITY , data ( "linestyle.opacity" ) ) ; addProp ( LINESTYLE__BACKCOLOR , data ( "linestyle.backcolor" , EscherPropertyMetaData . TYPE_RGB ) ) ; addProp ( LINESTYLE__CRMOD , data ( "linestyle.crmod" ) ) ; addProp ( LINESTYLE__LINETYPE , data ( "linestyle.linetype" ) ) ; addProp ( LINESTYLE__FILLBLIP , data ( "linestyle.fillblip" ) ) ; addProp ( LINESTYLE__FILLBLIPNAME , data ( "linestyle.fillblipname" ) ) ; addProp ( LINESTYLE__FILLBLIPFLAGS , data ( "linestyle.fillblipflags" ) ) ; addProp ( LINESTYLE__FILLWIDTH , data ( "linestyle.fillwidth" ) ) ; addProp ( LINESTYLE__FILLHEIGHT , data ( "linestyle.fillheight" ) ) ; addProp ( LINESTYLE__FILLDZTYPE , data ( "linestyle.filldztype" ) ) ; addProp ( LINESTYLE__LINEWIDTH , data ( "linestyle.linewidth" ) ) ; addProp ( LINESTYLE__LINEMITERLIMIT , data ( "linestyle.linemiterlimit" ) ) ; addProp ( LINESTYLE__LINESTYLE , data ( "linestyle.linestyle" ) ) ; addProp ( LINESTYLE__LINEDASHING , data ( "linestyle.linedashing" ) ) ; addProp ( LINESTYLE__LINEDASHSTYLE , data ( "linestyle.linedashstyle" , EscherPropertyMetaData . TYPE_ARRAY ) ) ; addProp ( LINESTYLE__LINESTARTARROWHEAD , data ( "linestyle.linestartarrowhead" ) ) ; addProp ( LINESTYLE__LINEENDARROWHEAD , data ( "linestyle.lineendarrowhead" ) ) ; addProp ( LINESTYLE__LINESTARTARROWWIDTH , data ( "linestyle.linestartarrowwidth" ) ) ; addProp ( LINESTYLE__LINEESTARTARROWLENGTH , data ( "linestyle.lineestartarrowlength" ) ) ; addProp ( LINESTYLE__LINEENDARROWWIDTH , data ( "linestyle.lineendarrowwidth" ) ) ; addProp ( LINESTYLE__LINEENDARROWLENGTH , data ( "linestyle.lineendarrowlength" ) ) ; addProp ( LINESTYLE__LINEJOINSTYLE , data ( "linestyle.linejoinstyle" ) ) ; addProp ( LINESTYLE__LINEENDCAPSTYLE , data ( "linestyle.lineendcapstyle" ) ) ; addProp ( LINESTYLE__ARROWHEADSOK , data ( "linestyle.arrowheadsok" ) ) ; addProp ( LINESTYLE__ANYLINE , data ( "linestyle.anyline" ) ) ; addProp ( LINESTYLE__HITLINETEST , data ( "linestyle.hitlinetest" ) ) ; addProp ( LINESTYLE__LINEFILLSHAPE , data ( "linestyle.linefillshape" ) ) ; addProp ( LINESTYLE__NOLINEDRAWDASH , data ( "linestyle.nolinedrawdash" , EscherPropertyMetaData . TYPE_BOOLEAN ) ) ; addProp ( SHADOWSTYLE__TYPE , data ( "shadowstyle.type" ) ) ; addProp ( SHADOWSTYLE__COLOR , data ( "shadowstyle.color" , EscherPropertyMetaData . TYPE_RGB ) ) ; addProp ( SHADOWSTYLE__HIGHLIGHT , data ( "shadowstyle.highlight" ) ) ; addProp ( SHADOWSTYLE__CRMOD , data ( "shadowstyle.crmod" ) ) ; addProp ( SHADOWSTYLE__OPACITY , data ( "shadowstyle.opacity" ) ) ; addProp ( SHADOWSTYLE__OFFSETX , data ( "shadowstyle.offsetx" ) ) ; addProp ( SHADOWSTYLE__OFFSETY , data ( "shadowstyle.offsety" ) ) ; addProp ( SHADOWSTYLE__SECONDOFFSETX , data ( "shadowstyle.secondoffsetx" ) ) ; addProp ( SHADOWSTYLE__SECONDOFFSETY , data ( "shadowstyle.secondoffsety" ) ) ; addProp ( SHADOWSTYLE__SCALEXTOX , data ( "shadowstyle.scalextox" ) ) ; addProp ( SHADOWSTYLE__SCALEYTOX , data ( "shadowstyle.scaleytox" ) ) ; addProp ( SHADOWSTYLE__SCALEXTOY , data ( "shadowstyle.scalextoy" ) ) ; addProp ( SHADOWSTYLE__SCALEYTOY , data ( "shadowstyle.scaleytoy" ) ) ; addProp ( SHADOWSTYLE__PERSPECTIVEX , data ( "shadowstyle.perspectivex" ) ) ; addProp ( SHADOWSTYLE__PERSPECTIVEY , data ( "shadowstyle.perspectivey" ) ) ; addProp ( SHADOWSTYLE__WEIGHT , data ( "shadowstyle.weight" ) ) ; addProp ( SHADOWSTYLE__ORIGINX , data ( "shadowstyle.originx" ) ) ; addProp ( SHADOWSTYLE__ORIGINY , data ( "shadowstyle.originy" ) ) ; addProp ( SHADOWSTYLE__SHADOW , data ( "shadowstyle.shadow" ) ) ; addProp ( SHADOWSTYLE__SHADOWOBSURED , data ( "shadowstyle.shadowobsured" ) ) ; addProp ( PERSPECTIVE__TYPE , data ( "perspective.type" ) ) ; addProp ( PERSPECTIVE__OFFSETX , data ( "perspective.offsetx" ) ) ; addProp ( PERSPECTIVE__OFFSETY , data ( "perspective.offsety" ) ) ; addProp ( PERSPECTIVE__SCALEXTOX , data ( "perspective.scalextox" ) ) ; addProp ( PERSPECTIVE__SCALEYTOX , data ( "perspective.scaleytox" ) ) ; addProp ( PERSPECTIVE__SCALEXTOY , data ( "perspective.scalextoy" ) ) ; addProp ( PERSPECTIVE__SCALEYTOY , data ( "perspective.scaleytoy" ) ) ; addProp ( PERSPECTIVE__PERSPECTIVEX , data ( "perspective.perspectivex" ) ) ; addProp ( PERSPECTIVE__PERSPECTIVEY , data ( "perspective.perspectivey" ) ) ; addProp ( PERSPECTIVE__WEIGHT , data ( "perspective.weight" ) ) ; addProp ( PERSPECTIVE__ORIGINX , data ( "perspective.originx" ) ) ; addProp ( PERSPECTIVE__ORIGINY , data ( "perspective.originy" ) ) ; addProp ( PERSPECTIVE__PERSPECTIVEON , data ( "perspective.perspectiveon" ) ) ; addProp ( THREED__SPECULARAMOUNT , data ( "3d.specularamount" ) ) ; addProp ( THREED__DIFFUSEAMOUNT , data ( "3d.diffuseamount" ) ) ; addProp ( THREED__SHININESS , data ( "3d.shininess" ) ) ; addProp ( THREED__EDGETHICKNESS , data ( "3d.edgethickness" ) ) ; addProp ( THREED__EXTRUDEFORWARD , data ( "3d.extrudeforward" ) ) ; addProp ( THREED__EXTRUDEBACKWARD , data ( "3d.extrudebackward" ) ) ; addProp ( THREED__EXTRUDEPLANE , data ( "3d.extrudeplane" ) ) ; addProp ( THREED__EXTRUSIONCOLOR , data ( "3d.extrusioncolor" , EscherPropertyMetaData . TYPE_RGB ) ) ; addProp ( THREED__CRMOD , data ( "3d.crmod" ) ) ; addProp ( THREED__3DEFFECT , data ( "3d.3deffect" ) ) ; addProp ( THREED__METALLIC , data ( "3d.metallic" ) ) ; addProp ( THREED__USEEXTRUSIONCOLOR , data ( "3d.useextrusioncolor" , EscherPropertyMetaData . TYPE_RGB ) ) ; addProp ( THREED__LIGHTFACE , data ( "3d.lightface" ) ) ; addProp ( THREEDSTYLE__YROTATIONANGLE , data ( "3dstyle.yrotationangle" ) ) ; addProp ( THREEDSTYLE__XROTATIONANGLE , data ( "3dstyle.xrotationangle" ) ) ; addProp ( THREEDSTYLE__ROTATIONAXISX , data ( "3dstyle.rotationaxisx" ) ) ; addProp ( THREEDSTYLE__ROTATIONAXISY , data ( "3dstyle.rotationaxisy" ) ) ; addProp ( THREEDSTYLE__ROTATIONAXISZ , data ( "3dstyle.rotationaxisz" ) ) ; addProp ( THREEDSTYLE__ROTATIONANGLE , data ( "3dstyle.rotationangle" ) ) ; addProp ( THREEDSTYLE__ROTATIONCENTERX , data ( "3dstyle.rotationcenterx" ) ) ; addProp ( THREEDSTYLE__ROTATIONCENTERY , data ( "3dstyle.rotationcentery" ) ) ; addProp ( THREEDSTYLE__ROTATIONCENTERZ , data ( "3dstyle.rotationcenterz" ) ) ; addProp ( THREEDSTYLE__RENDERMODE , data ( "3dstyle.rendermode" ) ) ; addProp ( THREEDSTYLE__TOLERANCE , data ( "3dstyle.tolerance" ) ) ; addProp ( THREEDSTYLE__XVIEWPOINT , data ( "3dstyle.xviewpoint" ) ) ; addProp ( THREEDSTYLE__YVIEWPOINT , data ( "3dstyle.yviewpoint" ) ) ; addProp ( THREEDSTYLE__ZVIEWPOINT , data ( "3dstyle.zviewpoint" ) ) ; addProp ( THREEDSTYLE__ORIGINX , data ( "3dstyle.originx" ) ) ; addProp ( THREEDSTYLE__ORIGINY , data ( "3dstyle.originy" ) ) ; addProp ( THREEDSTYLE__SKEWANGLE , data ( "3dstyle.skewangle" ) ) ; addProp ( THREEDSTYLE__SKEWAMOUNT , data ( "3dstyle.skewamount" ) ) ; addProp ( THREEDSTYLE__AMBIENTINTENSITY , data ( "3dstyle.ambientintensity" ) ) ; addProp ( THREEDSTYLE__KEYX , data ( "3dstyle.keyx" ) ) ; addProp ( THREEDSTYLE__KEYY , data ( "3dstyle.keyy" ) ) ; addProp ( THREEDSTYLE__KEYZ , data ( "3dstyle.keyz" ) ) ; addProp ( THREEDSTYLE__KEYINTENSITY , data ( "3dstyle.keyintensity" ) ) ; addProp ( THREEDSTYLE__FILLX , data ( "3dstyle.fillx" ) ) ; addProp ( THREEDSTYLE__FILLY , data ( "3dstyle.filly" ) ) ; addProp ( THREEDSTYLE__FILLZ , data ( "3dstyle.fillz" ) ) ; addProp ( THREEDSTYLE__FILLINTENSITY , data ( "3dstyle.fillintensity" ) ) ; addProp ( THREEDSTYLE__CONSTRAINROTATION , data ( "3dstyle.constrainrotation" ) ) ; addProp ( THREEDSTYLE__ROTATIONCENTERAUTO , data ( "3dstyle.rotationcenterauto" ) ) ; addProp ( THREEDSTYLE__PARALLEL , data ( "3dstyle.parallel" ) ) ; addProp ( THREEDSTYLE__KEYHARSH , data ( "3dstyle.keyharsh" ) ) ; addProp ( THREEDSTYLE__FILLHARSH , data ( "3dstyle.fillharsh" ) ) ; addProp ( SHAPE__MASTER , data ( "shape.master" ) ) ; addProp ( SHAPE__CONNECTORSTYLE , data ( "shape.connectorstyle" ) ) ; addProp ( SHAPE__BLACKANDWHITESETTINGS , data ( "shape.blackandwhitesettings" ) ) ; addProp ( SHAPE__WMODEPUREBW , data ( "shape.wmodepurebw" ) ) ; addProp ( SHAPE__WMODEBW , data ( "shape.wmodebw" ) ) ; addProp ( SHAPE__OLEICON , data ( "shape.oleicon" ) ) ; addProp ( SHAPE__PREFERRELATIVERESIZE , data ( "shape.preferrelativeresize" ) ) ; addProp ( SHAPE__LOCKSHAPETYPE , data ( "shape.lockshapetype" ) ) ; addProp ( SHAPE__DELETEATTACHEDOBJECT , data ( "shape.deleteattachedobject" ) ) ; addProp ( SHAPE__BACKGROUNDSHAPE , data ( "shape.backgroundshape" ) ) ; addProp ( CALLOUT__CALLOUTTYPE , data ( "callout.callouttype" ) ) ; addProp ( CALLOUT__XYCALLOUTGAP , data ( "callout.xycalloutgap" ) ) ; addProp ( CALLOUT__CALLOUTANGLE , data ( "callout.calloutangle" ) ) ; addProp ( CALLOUT__CALLOUTDROPTYPE , data ( "callout.calloutdroptype" ) ) ; addProp ( CALLOUT__CALLOUTDROPSPECIFIED , data ( "callout.calloutdropspecified" ) ) ; addProp ( CALLOUT__CALLOUTLENGTHSPECIFIED , data ( "callout.calloutlengthspecified" ) ) ; addProp ( CALLOUT__ISCALLOUT , data ( "callout.iscallout" ) ) ; addProp ( CALLOUT__CALLOUTACCENTBAR , data ( "callout.calloutaccentbar" ) ) ; addProp ( CALLOUT__CALLOUTTEXTBORDER , data ( "callout.callouttextborder" ) ) ; addProp ( CALLOUT__CALLOUTMINUSX , data ( "callout.calloutminusx" ) ) ; addProp ( CALLOUT__CALLOUTMINUSY , data ( "callout.calloutminusy" ) ) ; addProp ( CALLOUT__DROPAUTO , data ( "callout.dropauto" ) ) ; addProp ( CALLOUT__LENGTHSPECIFIED , data ( "callout.lengthspecified" ) ) ; addProp ( GROUPSHAPE__SHAPENAME , data ( "groupshape.shapename" ) ) ; addProp ( GROUPSHAPE__DESCRIPTION , data ( "groupshape.description" ) ) ; addProp ( GROUPSHAPE__HYPERLINK , data ( "groupshape.hyperlink" ) ) ; addProp ( GROUPSHAPE__WRAPPOLYGONVERTICES , data ( "groupshape.wrappolygonvertices" , EscherPropertyMetaData . TYPE_ARRAY ) ) ; addProp ( GROUPSHAPE__WRAPDISTLEFT , data ( "groupshape.wrapdistleft" ) ) ; addProp ( GROUPSHAPE__WRAPDISTTOP , data ( "groupshape.wrapdisttop" ) ) ; addProp ( GROUPSHAPE__WRAPDISTRIGHT , data ( "groupshape.wrapdistright" ) ) ; addProp ( GROUPSHAPE__WRAPDISTBOTTOM , data ( "groupshape.wrapdistbottom" ) ) ; addProp ( GROUPSHAPE__REGROUPID , data ( "groupshape.regroupid" ) ) ; addProp ( GROUPSHAPE__EDITEDWRAP , data ( "groupshape.editedwrap" ) ) ; addProp ( GROUPSHAPE__BEHINDDOCUMENT , data ( "groupshape.behinddocument" ) ) ; addProp ( GROUPSHAPE__ONDBLCLICKNOTIFY , data ( "groupshape.ondblclicknotify" ) ) ; addProp ( GROUPSHAPE__ISBUTTON , data ( "groupshape.isbutton" ) ) ; addProp ( GROUPSHAPE__1DADJUSTMENT , data ( "groupshape.1dadjustment" ) ) ; addProp ( GROUPSHAPE__HIDDEN , data ( "groupshape.hidden" ) ) ; addProp ( GROUPSHAPE__PRINT , data ( "groupshape.print" , EscherPropertyMetaData . TYPE_BOOLEAN ) ) ; } } private static void addProp ( int s , EscherPropertyMetaData data ) { properties . put ( new Short ( ( short ) s ) , data ) ; } private static EscherPropertyMetaData data ( String propName , byte type ) { return new EscherPropertyMetaData ( propName , type ) ; } private static EscherPropertyMetaData data ( String propName ) { return new EscherPropertyMetaData ( propName ) ; } public static String getPropertyName ( short propertyId ) { initProps ( ) ; EscherPropertyMetaData o = ( EscherPropertyMetaData ) properties . get ( new Short ( propertyId ) ) ; return o == null ? "unknown" : o . getDescription ( ) ; } public static byte getPropertyType ( short propertyId ) { initProps ( ) ; EscherPropertyMetaData escherPropertyMetaData = ( EscherPropertyMetaData ) properties . get ( new Short ( propertyId ) ) ; return escherPropertyMetaData == null ? 0 : escherPropertyMetaData . getType ( ) ; } } 	0	['7', '1', '0', '6', '16', '9', '5', '1', '3', '1.164242424', '1460', '0.003636364', '0', '0', '0.19047619', '0', '0', '168.2857143', '2', '1.2857', '0']
package org . apache . poi . ddf ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . HexDump ; import java . util . Arrays ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; public class EscherComplexProperty extends EscherProperty { byte [ ] complexData = new byte [ 0 ] ; public EscherComplexProperty ( short id , byte [ ] complexData ) { super ( id ) ; this . complexData = complexData ; } public EscherComplexProperty ( short propertyNumber , boolean isBlipId , byte [ ] complexData ) { super ( propertyNumber , true , isBlipId ) ; this . complexData = complexData ; } public int serializeSimplePart ( byte [ ] data , int pos ) { LittleEndian . putShort ( data , pos , getId ( ) ) ; LittleEndian . putInt ( data , pos + 2 , complexData . length ) ; return 6 ; } public int serializeComplexPart ( byte [ ] data , int pos ) { System . arraycopy ( complexData , 0 , data , pos , complexData . length ) ; return complexData . length ; } public byte [ ] getComplexData ( ) { return complexData ; } public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof EscherComplexProperty ) ) return false ; final EscherComplexProperty escherComplexProperty = ( EscherComplexProperty ) o ; if ( ! Arrays . equals ( complexData , escherComplexProperty . complexData ) ) return false ; return true ; } public int getPropertySize ( ) { return 6 + complexData . length ; } public int hashCode ( ) { return getId ( ) * 11 ; } public String toString ( ) { String dataStr ; ByteArrayOutputStream b = new ByteArrayOutputStream ( ) ; try { HexDump . dump ( this . complexData , 0 , b , 0 ) ; dataStr = b . toString ( ) ; } catch ( Exception e ) { dataStr = e . toString ( ) ; } finally { try { b . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return "propNum: " + getPropertyNumber ( ) + ", propName: " + EscherProperties . getPropertyName ( getPropertyNumber ( ) ) + ", complex: " + isComplex ( ) + ", blipId: " + isBlipId ( ) + ", data: " + System . getProperty ( "line.separator" ) + dataStr ; } } 	0	['9', '2', '1', '6', '32', '0', '2', '4', '9', '0.125', '172', '0', '0', '0.533333333', '0.351851852', '1', '1', '18', '4', '1.1111', '0']
package org . apache . poi . poifs . property ; import java . io . * ; import java . util . * ; import org . apache . poi . hpsf . ClassID ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . dev . POIFSViewable ; import org . apache . poi . util . ByteField ; import org . apache . poi . util . IntegerField ; import org . apache . poi . util . LittleEndianConsts ; import org . apache . poi . util . ShortField ; public abstract class Property implements Child , POIFSViewable { static final private byte _default_fill = ( byte ) 0x00 ; static final private int _name_size_offset = 0x40 ; static final private int _max_name_length = ( _name_size_offset / LittleEndianConsts . SHORT_SIZE ) - 1 ; static final protected int _NO_INDEX = - 1 ; static final private int _node_color_offset = 0x43 ; static final private int _previous_property_offset = 0x44 ; static final private int _next_property_offset = 0x48 ; static final private int _child_property_offset = 0x4C ; static final private int _storage_clsid_offset = 0x50 ; static final private int _user_flags_offset = 0x60 ; static final private int _seconds_1_offset = 0x64 ; static final private int _days_1_offset = 0x68 ; static final private int _seconds_2_offset = 0x6C ; static final private int _days_2_offset = 0x70 ; static final private int _start_block_offset = 0x74 ; static final private int _size_offset = 0x78 ; static final protected byte _NODE_BLACK = 1 ; static final protected byte _NODE_RED = 0 ; static final private int _big_block_minimum_bytes = 4096 ; private String _name ; private ShortField _name_size ; private ByteField _property_type ; private ByteField _node_color ; private IntegerField _previous_property ; private IntegerField _next_property ; private IntegerField _child_property ; private ClassID _storage_clsid ; private IntegerField _user_flags ; private IntegerField _seconds_1 ; private IntegerField _days_1 ; private IntegerField _seconds_2 ; private IntegerField _days_2 ; private IntegerField _start_block ; private IntegerField _size ; private byte [ ] _raw_data ; private int _index ; private Child _next_child ; private Child _previous_child ; protected Property ( ) { _raw_data = new byte [ POIFSConstants . PROPERTY_SIZE ] ; Arrays . fill ( _raw_data , _default_fill ) ; _name_size = new ShortField ( _name_size_offset ) ; _property_type = new ByteField ( PropertyConstants . PROPERTY_TYPE_OFFSET ) ; _node_color = new ByteField ( _node_color_offset ) ; _previous_property = new IntegerField ( _previous_property_offset , _NO_INDEX , _raw_data ) ; _next_property = new IntegerField ( _next_property_offset , _NO_INDEX , _raw_data ) ; _child_property = new IntegerField ( _child_property_offset , _NO_INDEX , _raw_data ) ; _storage_clsid = new ClassID ( _raw_data , _storage_clsid_offset ) ; _user_flags = new IntegerField ( _user_flags_offset , 0 , _raw_data ) ; _seconds_1 = new IntegerField ( _seconds_1_offset , 0 , _raw_data ) ; _days_1 = new IntegerField ( _days_1_offset , 0 , _raw_data ) ; _seconds_2 = new IntegerField ( _seconds_2_offset , 0 , _raw_data ) ; _days_2 = new IntegerField ( _days_2_offset , 0 , _raw_data ) ; _start_block = new IntegerField ( _start_block_offset ) ; _size = new IntegerField ( _size_offset , 0 , _raw_data ) ; _index = _NO_INDEX ; setName ( "" ) ; setNextChild ( null ) ; setPreviousChild ( null ) ; } protected Property ( final int index , final byte [ ] array , final int offset ) { _raw_data = new byte [ POIFSConstants . PROPERTY_SIZE ] ; System . arraycopy ( array , offset , _raw_data , 0 , POIFSConstants . PROPERTY_SIZE ) ; _name_size = new ShortField ( _name_size_offset , _raw_data ) ; _property_type = new ByteField ( PropertyConstants . PROPERTY_TYPE_OFFSET , _raw_data ) ; _node_color = new ByteField ( _node_color_offset , _raw_data ) ; _previous_property = new IntegerField ( _previous_property_offset , _raw_data ) ; _next_property = new IntegerField ( _next_property_offset , _raw_data ) ; _child_property = new IntegerField ( _child_property_offset , _raw_data ) ; _storage_clsid = new ClassID ( _raw_data , _storage_clsid_offset ) ; _user_flags = new IntegerField ( _user_flags_offset , 0 , _raw_data ) ; _seconds_1 = new IntegerField ( _seconds_1_offset , _raw_data ) ; _days_1 = new IntegerField ( _days_1_offset , _raw_data ) ; _seconds_2 = new IntegerField ( _seconds_2_offset , _raw_data ) ; _days_2 = new IntegerField ( _days_2_offset , _raw_data ) ; _start_block = new IntegerField ( _start_block_offset , _raw_data ) ; _size = new IntegerField ( _size_offset , _raw_data ) ; _index = index ; int name_length = ( _name_size . get ( ) / LittleEndianConsts . SHORT_SIZE ) - 1 ; if ( name_length < 1 ) { _name = "" ; } else { char [ ] char_array = new char [ name_length ] ; int name_offset = 0 ; for ( int j = 0 ; j < name_length ; j ++ ) { char_array [ j ] = ( char ) new ShortField ( name_offset , _raw_data ) . get ( ) ; name_offset += LittleEndianConsts . SHORT_SIZE ; } _name = new String ( char_array , 0 , name_length ) ; } _next_child = null ; _previous_child = null ; } public void writeData ( final OutputStream stream ) throws IOException { stream . write ( _raw_data ) ; } public void setStartBlock ( final int startBlock ) { _start_block . set ( startBlock , _raw_data ) ; } public int getStartBlock ( ) { return _start_block . get ( ) ; } public int getSize ( ) { return _size . get ( ) ; } public boolean shouldUseSmallBlocks ( ) { return Property . isSmall ( _size . get ( ) ) ; } public static boolean isSmall ( final int length ) { return length < _big_block_minimum_bytes ; } public String getName ( ) { return _name ; } abstract public boolean isDirectory ( ) ; public ClassID getStorageClsid ( ) { return _storage_clsid ; } protected final void setName ( final String name ) { char [ ] char_array = name . toCharArray ( ) ; int limit = Math . min ( char_array . length , _max_name_length ) ; _name = new String ( char_array , 0 , limit ) ; short offset = 0 ; int j = 0 ; for ( ; j < limit ; j ++ ) { new ShortField ( offset , ( short ) char_array [ j ] , _raw_data ) ; offset += LittleEndianConsts . SHORT_SIZE ; } for ( ; j < _max_name_length + 1 ; j ++ ) { new ShortField ( offset , ( short ) 0 , _raw_data ) ; offset += LittleEndianConsts . SHORT_SIZE ; } _name_size . set ( ( short ) ( ( limit + 1 ) * LittleEndianConsts . SHORT_SIZE ) , _raw_data ) ; } public void setStorageClsid ( ClassID clsidStorage ) { _storage_clsid = clsidStorage ; if ( clsidStorage == null ) { Arrays . fill ( _raw_data , _storage_clsid_offset , _storage_clsid_offset + ClassID . LENGTH , ( byte ) 0 ) ; } else { clsidStorage . write ( _raw_data , _storage_clsid_offset ) ; } } protected void setPropertyType ( final byte propertyType ) { _property_type . set ( propertyType , _raw_data ) ; } protected void setNodeColor ( final byte nodeColor ) { _node_color . set ( nodeColor , _raw_data ) ; } protected void setChildProperty ( final int child ) { _child_property . set ( child , _raw_data ) ; } protected int getChildIndex ( ) { return _child_property . get ( ) ; } protected void setSize ( final int size ) { _size . set ( size , _raw_data ) ; } protected void setIndex ( final int index ) { _index = index ; } protected int getIndex ( ) { return _index ; } abstract protected void preWrite ( ) ; int getNextChildIndex ( ) { return _next_property . get ( ) ; } int getPreviousChildIndex ( ) { return _previous_property . get ( ) ; } static boolean isValidIndex ( int index ) { return index != _NO_INDEX ; } public Child getNextChild ( ) { return _next_child ; } public Child getPreviousChild ( ) { return _previous_child ; } public void setNextChild ( final Child child ) { _next_child = child ; _next_property . set ( ( child == null ) ? _NO_INDEX : ( ( Property ) child ) . getIndex ( ) , _raw_data ) ; } public void setPreviousChild ( final Child child ) { _previous_child = child ; _previous_property . set ( ( child == null ) ? _NO_INDEX : ( ( Property ) child ) . getIndex ( ) , _raw_data ) ; } public Object [ ] getViewableArray ( ) { Object [ ] results = new Object [ 5 ] ; results [ 0 ] = "Name          = \"" + getName ( ) + "\"" ; results [ 1 ] = "Property Type = " + _property_type . get ( ) ; results [ 2 ] = "Node Color    = " + _node_color . get ( ) ; long time = _days_1 . get ( ) ; time <<= 32 ; time += ( ( long ) _seconds_1 . get ( ) ) & 0x0000FFFFL ; results [ 3 ] = "Time 1        = " + time ; time = _days_2 . get ( ) ; time <<= 32 ; time += ( ( long ) _seconds_2 . get ( ) ) & 0x0000FFFFL ; results [ 4 ] = "Time 2        = " + time ; return results ; } public Iterator getViewableIterator ( ) { return Collections . EMPTY_LIST . iterator ( ) ; } public boolean preferArray ( ) { return true ; } public String getShortDescription ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "Property: \"" ) . append ( getName ( ) ) . append ( "\"" ) ; return buffer . toString ( ) ; } } 	0	['32', '1', '3', '19', '65', '290', '13', '6', '18', '0.962648557', '732', '1', '16', '0', '0.17578125', '0', '0', '20.6875', '3', '1.1563', '0']
package org . apache . poi . ddf ; import org . apache . poi . util . HexDump ; import org . apache . poi . util . LittleEndian ; import java . util . Iterator ; import java . util . List ; import java . util . ArrayList ; public class UnknownEscherRecord extends EscherRecord { private static final byte [ ] NO_BYTES = new byte [ 0 ] ; private byte [ ] thedata = NO_BYTES ; private List childRecords = new ArrayList ( ) ; public UnknownEscherRecord ( ) { } public int fillFields ( byte [ ] data , int offset , EscherRecordFactory recordFactory ) { int bytesRemaining = readHeader ( data , offset ) ; if ( isContainerRecord ( ) ) { int bytesWritten = 0 ; thedata = new byte [ 0 ] ; offset += 8 ; bytesWritten += 8 ; while ( bytesRemaining > 0 ) { EscherRecord child = recordFactory . createRecord ( data , offset ) ; int childBytesWritten = child . fillFields ( data , offset , recordFactory ) ; bytesWritten += childBytesWritten ; offset += childBytesWritten ; bytesRemaining -= childBytesWritten ; getChildRecords ( ) . add ( child ) ; } return bytesWritten ; } else { thedata = new byte [ bytesRemaining ] ; System . arraycopy ( data , offset + 8 , thedata , 0 , bytesRemaining ) ; return bytesRemaining + 8 ; } } public int serialize ( int offset , byte [ ] data , EscherSerializationListener listener ) { listener . beforeRecordSerialize ( offset , getRecordId ( ) , this ) ; LittleEndian . putShort ( data , offset , getOptions ( ) ) ; LittleEndian . putShort ( data , offset + 2 , getRecordId ( ) ) ; int remainingBytes = thedata . length ; for ( Iterator iterator = getChildRecords ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { EscherRecord r = ( EscherRecord ) iterator . next ( ) ; remainingBytes += r . getRecordSize ( ) ; } LittleEndian . putInt ( data , offset + 4 , remainingBytes ) ; System . arraycopy ( thedata , 0 , data , offset + 8 , thedata . length ) ; int pos = offset + 8 + thedata . length ; for ( Iterator iterator = getChildRecords ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { EscherRecord r = ( EscherRecord ) iterator . next ( ) ; pos += r . serialize ( pos , data , listener ) ; } listener . afterRecordSerialize ( pos , getRecordId ( ) , pos - offset , this ) ; return pos - offset ; } public byte [ ] getData ( ) { return thedata ; } public int getRecordSize ( ) { return 8 + thedata . length ; } public List getChildRecords ( ) { return childRecords ; } public void setChildRecords ( List childRecords ) { this . childRecords = childRecords ; } public Object clone ( ) { return super . clone ( ) ; } public String getRecordName ( ) { return "Unknown 0x" + HexDump . toHex ( getRecordId ( ) ) ; } public String toString ( ) { String nl = System . getProperty ( "line.separator" ) ; StringBuffer children = new StringBuffer ( ) ; if ( getChildRecords ( ) . size ( ) > 0 ) { children . append ( "  children: " + nl ) ; for ( Iterator iterator = getChildRecords ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { EscherRecord record = ( EscherRecord ) iterator . next ( ) ; children . append ( record . toString ( ) ) ; children . append ( nl ) ; } } String theDumpHex = "" ; try { if ( thedata . length != 0 ) { theDumpHex = "  Extra Data:" + nl ; theDumpHex += HexDump . dump ( thedata , 0 , 0 ) ; } } catch ( Exception e ) { theDumpHex = "Error!!" ; } return getClass ( ) . getName ( ) + ":" + nl + "  isContainer: " + isContainerRecord ( ) + nl + "  options: 0x" + HexDump . toHex ( getOptions ( ) ) + nl + "  recordId: 0x" + HexDump . toHex ( getRecordId ( ) ) + nl + "  numchildren: " + getChildRecords ( ) . size ( ) + nl + theDumpHex + children . toString ( ) ; } public void addChildRecord ( EscherRecord childRecord ) { getChildRecords ( ) . add ( childRecord ) ; } } 	0	['12', '2', '0', '6', '47', '28', '1', '5', '11', '0.636363636', '353', '1', '0', '0.655172414', '0.246753247', '1', '6', '28.16666667', '3', '1.3333', '0']
package org . apache . poi . ddf ; public class EscherPropertyMetaData { public final static byte TYPE_UNKNOWN = ( byte ) 0 ; public final static byte TYPE_BOOLEAN = ( byte ) 1 ; public final static byte TYPE_RGB = ( byte ) 2 ; public final static byte TYPE_SHAPEPATH = ( byte ) 3 ; public final static byte TYPE_SIMPLE = ( byte ) 4 ; public final static byte TYPE_ARRAY = ( byte ) 5 ; ; private String description ; private byte type ; public EscherPropertyMetaData ( String description ) { this . description = description ; } public EscherPropertyMetaData ( String description , byte type ) { this . description = description ; this . type = type ; } public String getDescription ( ) { return description ; } public byte getType ( ) { return type ; } } 	0	['4', '1', '0', '1', '5', '0', '1', '0', '4', '1.125', '33', '0.25', '0', '0', '0.583333333', '0', '0', '5.25', '1', '0.5', '0']
package org . apache . poi . poifs . filesystem ; public interface Entry { public String getName ( ) ; public boolean isDirectoryEntry ( ) ; public boolean isDocumentEntry ( ) ; public DirectoryEntry getParent ( ) ; public boolean delete ( ) ; public boolean renameTo ( final String newName ) ; } 	0	['6', '1', '0', '6', '6', '15', '6', '1', '6', '2', '6', '0', '0', '0', '0.583333333', '0', '0', '0', '1', '1', '0']
package org . apache . poi . hssf . model ; public interface Model { } 	0	['0', '1', '0', '4', '0', '0', '4', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . poi . ddf ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . HexDump ; public class EscherSimpleProperty extends EscherProperty { protected int propertyValue ; public EscherSimpleProperty ( short id , int propertyValue ) { super ( id ) ; this . propertyValue = propertyValue ; } public EscherSimpleProperty ( short propertyNumber , boolean isComplex , boolean isBlipId , int propertyValue ) { super ( propertyNumber , isComplex , isBlipId ) ; this . propertyValue = propertyValue ; } public int serializeSimplePart ( byte [ ] data , int offset ) { LittleEndian . putShort ( data , offset , getId ( ) ) ; LittleEndian . putInt ( data , offset + 2 , propertyValue ) ; return 6 ; } public int serializeComplexPart ( byte [ ] data , int pos ) { return 0 ; } public int getPropertyValue ( ) { return propertyValue ; } public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof EscherSimpleProperty ) ) return false ; final EscherSimpleProperty escherSimpleProperty = ( EscherSimpleProperty ) o ; if ( propertyValue != escherSimpleProperty . propertyValue ) return false ; if ( getId ( ) != escherSimpleProperty . getId ( ) ) return false ; return true ; } public int hashCode ( ) { return propertyValue ; } public String toString ( ) { return "propNum: " + getPropertyNumber ( ) + ", propName: " + EscherProperties . getPropertyName ( getPropertyNumber ( ) ) + ", complex: " + isComplex ( ) + ", blipId: " + isBlipId ( ) + ", value: " + propertyValue + " (0x" + HexDump . toHex ( propertyValue ) + ")" ; } } 	0	['8', '2', '3', '11', '23', '0', '7', '4', '8', '0.142857143', '115', '1', '0', '0.571428571', '0.375', '1', '1', '13.25', '5', '1.25', '0']
package org . apache . poi . poifs . filesystem ; public class POIFSWriterEvent { private DocumentOutputStream stream ; private POIFSDocumentPath path ; private String documentName ; private int limit ; POIFSWriterEvent ( final DocumentOutputStream stream , final POIFSDocumentPath path , final String documentName , final int limit ) { this . stream = stream ; this . path = path ; this . documentName = documentName ; this . limit = limit ; } public DocumentOutputStream getStream ( ) { return stream ; } public POIFSDocumentPath getPath ( ) { return path ; } public String getName ( ) { return documentName ; } public int getLimit ( ) { return limit ; } } 	0	['5', '1', '0', '5', '6', '2', '3', '2', '4', '0.75', '36', '1', '2', '0', '0.36', '0', '0', '5.4', '1', '0.8', '0']
package org . apache . poi . hssf . eventusermodel ; public class HSSFUserException extends Exception { private Throwable reason ; public HSSFUserException ( ) { super ( ) ; } public HSSFUserException ( final String msg ) { super ( msg ) ; } public HSSFUserException ( final Throwable reason ) { super ( ) ; this . reason = reason ; } public HSSFUserException ( final String msg , final Throwable reason ) { super ( msg ) ; this . reason = reason ; } public Throwable getReason ( ) { return reason ; } } 	0	['5', '3', '0', '3', '7', '4', '3', '0', '5', '0.5', '29', '1', '0', '0.944444444', '0.6', '0', '0', '4.6', '1', '0.2', '0']
package org . apache . poi . hssf . eventusermodel ; import java . util . HashMap ; import java . util . List ; import java . util . ArrayList ; import org . apache . poi . hssf . record . Record ; import org . apache . poi . hssf . record . RecordFactory ; public class HSSFRequest { private HashMap records ; public HSSFRequest ( ) { records = new HashMap ( 50 ) ; } public void addListener ( HSSFListener lsnr , short sid ) { List list = null ; Object obj = records . get ( new Short ( sid ) ) ; if ( obj != null ) { list = ( List ) obj ; } else { list = new ArrayList ( 1 ) ; list . add ( lsnr ) ; records . put ( new Short ( sid ) , list ) ; } } public void addListenerForAllRecords ( HSSFListener lsnr ) { short [ ] rectypes = RecordFactory . getAllKnownRecordSIDs ( ) ; for ( int k = 0 ; k < rectypes . length ; k ++ ) { addListener ( lsnr , rectypes [ k ] ) ; } } protected short processRecord ( Record rec ) throws HSSFUserException { Object obj = records . get ( new Short ( rec . getSid ( ) ) ) ; short userCode = 0 ; if ( obj != null ) { List listeners = ( List ) obj ; for ( int k = 0 ; k < listeners . size ( ) ; k ++ ) { Object listenObj = listeners . get ( k ) ; if ( listenObj instanceof AbortableHSSFListener ) { AbortableHSSFListener listener = ( AbortableHSSFListener ) listenObj ; userCode = listener . abortableProcessRecord ( rec ) ; if ( userCode != 0 ) break ; } else { HSSFListener listener = ( HSSFListener ) listenObj ; listener . processRecord ( rec ) ; } } } return userCode ; } } 	0	['4', '1', '0', '8', '17', '0', '3', '5', '3', '0', '116', '1', '0', '0', '0.5', '0', '0', '27.75', '2', '1.25', '0']
package org . apache . poi . poifs . storage ; import java . io . * ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; public class SmallDocumentBlock implements BlockWritable , ListManagedBlock { private byte [ ] _data ; private static final byte _default_fill = ( byte ) 0xff ; private static final int _block_size = 64 ; private static final int _blocks_per_big_block = POIFSConstants . BIG_BLOCK_SIZE / _block_size ; private SmallDocumentBlock ( final byte [ ] data , final int index ) { this ( ) ; System . arraycopy ( data , index * _block_size , _data , 0 , _block_size ) ; } private SmallDocumentBlock ( ) { _data = new byte [ _block_size ] ; } public static SmallDocumentBlock [ ] convert ( final byte [ ] array , final int size ) { SmallDocumentBlock [ ] rval = new SmallDocumentBlock [ ( size + _block_size - 1 ) / _block_size ] ; int offset = 0 ; for ( int k = 0 ; k < rval . length ; k ++ ) { rval [ k ] = new SmallDocumentBlock ( ) ; if ( offset < array . length ) { int length = Math . min ( _block_size , array . length - offset ) ; System . arraycopy ( array , offset , rval [ k ] . _data , 0 , length ) ; if ( length != _block_size ) { Arrays . fill ( rval [ k ] . _data , length , _block_size , _default_fill ) ; } } else { Arrays . fill ( rval [ k ] . _data , _default_fill ) ; } offset += _block_size ; } return rval ; } public static int fill ( final List blocks ) { int count = blocks . size ( ) ; int big_block_count = ( count + _blocks_per_big_block - 1 ) / _blocks_per_big_block ; int full_count = big_block_count * _blocks_per_big_block ; for ( ; count < full_count ; count ++ ) { blocks . add ( makeEmptySmallDocumentBlock ( ) ) ; } return big_block_count ; } public static SmallDocumentBlock [ ] convert ( final BlockWritable [ ] store , final int size ) throws IOException , ArrayIndexOutOfBoundsException { ByteArrayOutputStream stream = new ByteArrayOutputStream ( ) ; for ( int j = 0 ; j < store . length ; j ++ ) { store [ j ] . writeBlocks ( stream ) ; } byte [ ] data = stream . toByteArray ( ) ; SmallDocumentBlock [ ] rval = new SmallDocumentBlock [ convertToBlockCount ( size ) ] ; for ( int index = 0 ; index < rval . length ; index ++ ) { rval [ index ] = new SmallDocumentBlock ( data , index ) ; } return rval ; } public static List extract ( ListManagedBlock [ ] blocks ) throws IOException { List sdbs = new ArrayList ( ) ; for ( int j = 0 ; j < blocks . length ; j ++ ) { byte [ ] data = blocks [ j ] . getData ( ) ; for ( int k = 0 ; k < _blocks_per_big_block ; k ++ ) { sdbs . add ( new SmallDocumentBlock ( data , k ) ) ; } } return sdbs ; } public static void read ( final BlockWritable [ ] blocks , final byte [ ] buffer , final int offset ) { int firstBlockIndex = offset / _block_size ; int firstBlockOffset = offset % _block_size ; int lastBlockIndex = ( offset + buffer . length - 1 ) / _block_size ; if ( firstBlockIndex == lastBlockIndex ) { System . arraycopy ( ( ( SmallDocumentBlock ) blocks [ firstBlockIndex ] ) . _data , firstBlockOffset , buffer , 0 , buffer . length ) ; } else { int buffer_offset = 0 ; System . arraycopy ( ( ( SmallDocumentBlock ) blocks [ firstBlockIndex ] ) . _data , firstBlockOffset , buffer , buffer_offset , _block_size - firstBlockOffset ) ; buffer_offset += _block_size - firstBlockOffset ; for ( int j = firstBlockIndex + 1 ; j < lastBlockIndex ; j ++ ) { System . arraycopy ( ( ( SmallDocumentBlock ) blocks [ j ] ) . _data , 0 , buffer , buffer_offset , _block_size ) ; buffer_offset += _block_size ; } System . arraycopy ( ( ( SmallDocumentBlock ) blocks [ lastBlockIndex ] ) . _data , 0 , buffer , buffer_offset , buffer . length - buffer_offset ) ; } } public static int calcSize ( int size ) { return size * _block_size ; } private static SmallDocumentBlock makeEmptySmallDocumentBlock ( ) { SmallDocumentBlock block = new SmallDocumentBlock ( ) ; Arrays . fill ( block . _data , _default_fill ) ; return block ; } private static int convertToBlockCount ( final int size ) { return ( size + _block_size - 1 ) / _block_size ; } public void writeBlocks ( final OutputStream stream ) throws IOException { stream . write ( _data ) ; } public byte [ ] getData ( ) throws IOException { return _data ; } } 	0	['12', '1', '0', '8', '25', '24', '6', '2', '8', '0.863636364', '319', '1', '0', '0', '0.214285714', '0', '0', '25.25', '3', '1.25', '0']
package org . apache . poi . hssf . eventmodel ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import org . apache . poi . hssf . model . Model ; import org . apache . poi . hssf . model . Sheet ; import org . apache . poi . hssf . model . Workbook ; import org . apache . poi . hssf . record . BOFRecord ; import org . apache . poi . hssf . record . EOFRecord ; import org . apache . poi . hssf . record . Record ; public class ModelFactory implements ERFListener { List listeners ; Model currentmodel ; boolean lastEOF ; public ModelFactory ( ) { super ( ) ; listeners = new ArrayList ( 1 ) ; } public void registerListener ( ModelFactoryListener listener ) { listeners . add ( listener ) ; } public void run ( InputStream stream ) { EventRecordFactory factory = new EventRecordFactory ( true ) ; factory . registerListener ( this , null ) ; lastEOF = true ; factory . processRecords ( stream ) ; } public boolean processRecord ( Record rec ) { if ( rec . getSid ( ) == BOFRecord . sid ) { if ( lastEOF != true ) { throw new RuntimeException ( "Not yet handled embedded models" ) ; } else { BOFRecord bof = ( BOFRecord ) rec ; switch ( bof . getType ( ) ) { case BOFRecord . TYPE_WORKBOOK : currentmodel = new Workbook ( ) ; break ; case BOFRecord . TYPE_WORKSHEET : currentmodel = new Sheet ( ) ; break ; default : throw new RuntimeException ( "Unsupported model type " + bof . getType ( ) ) ; } } } if ( rec . getSid ( ) == EOFRecord . sid ) { lastEOF = true ; throwEvent ( currentmodel ) ; } else { lastEOF = false ; } return true ; } private void throwEvent ( Model model ) { Iterator i = listeners . iterator ( ) ; while ( i . hasNext ( ) ) { ModelFactoryListener mfl = ( ModelFactoryListener ) i . next ( ) ; mfl . process ( model ) ; } } } 	0	['5', '1', '0', '8', '24', '2', '0', '8', '4', '0.666666667', '117', '0', '1', '0', '0.36', '0', '0', '21.8', '7', '2.2', '0']
package org . apache . poi . poifs . storage ; import java . io . IOException ; import java . io . OutputStream ; import java . util . * ; import org . apache . poi . poifs . common . POIFSConstants ; import org . apache . poi . poifs . filesystem . BATManaged ; import org . apache . poi . util . IntList ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . util . LittleEndianConsts ; public class BlockAllocationTableWriter implements BlockWritable , BATManaged { private IntList _entries ; private BATBlock [ ] _blocks ; private int _start_block ; public BlockAllocationTableWriter ( ) { _start_block = POIFSConstants . END_OF_CHAIN ; _entries = new IntList ( ) ; _blocks = new BATBlock [ 0 ] ; } public int createBlocks ( ) { int xbat_blocks = 0 ; int bat_blocks = 0 ; while ( true ) { int calculated_bat_blocks = BATBlock . calculateStorageRequirements ( bat_blocks + xbat_blocks + _entries . size ( ) ) ; int calculated_xbat_blocks = HeaderBlockWriter . calculateXBATStorageRequirements ( calculated_bat_blocks ) ; if ( ( bat_blocks == calculated_bat_blocks ) && ( xbat_blocks == calculated_xbat_blocks ) ) { break ; } else { bat_blocks = calculated_bat_blocks ; xbat_blocks = calculated_xbat_blocks ; } } int startBlock = allocateSpace ( bat_blocks ) ; allocateSpace ( xbat_blocks ) ; simpleCreateBlocks ( ) ; return startBlock ; } public int allocateSpace ( final int blockCount ) { int startBlock = _entries . size ( ) ; if ( blockCount > 0 ) { int limit = blockCount - 1 ; int index = startBlock + 1 ; for ( int k = 0 ; k < limit ; k ++ ) { _entries . add ( index ++ ) ; } _entries . add ( POIFSConstants . END_OF_CHAIN ) ; } return startBlock ; } public int getStartBlock ( ) { return _start_block ; } void simpleCreateBlocks ( ) { _blocks = BATBlock . createBATBlocks ( _entries . toArray ( ) ) ; } public void writeBlocks ( final OutputStream stream ) throws IOException { for ( int j = 0 ; j < _blocks . length ; j ++ ) { _blocks [ j ] . writeBlocks ( stream ) ; } } public int countBlocks ( ) { return _blocks . length ; } public void setStartBlock ( int start_block ) { _start_block = start_block ; } } 	0	['8', '1', '0', '7', '17', '0', '2', '5', '7', '0.571428571', '134', '1', '2', '0', '0.458333333', '0', '0', '15.375', '3', '1.375', '0']
package org . apache . poi . poifs . filesystem ; public interface BATManaged { public int countBlocks ( ) ; public void setStartBlock ( final int index ) ; } 	0	['2', '1', '0', '5', '2', '1', '5', '0', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . poi . poifs . filesystem ; public interface DocumentEntry extends Entry { public int getSize ( ) ; } 	0	['1', '1', '0', '7', '1', '0', '6', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . poi . hssf . record ; public interface Margin { public double getMargin ( ) ; public void setMargin ( double field_1_margin ) ; } 	0	['2', '1', '0', '5', '2', '1', '5', '0', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . poi . ddf ; import org . apache . poi . util . HexDump ; import org . apache . poi . util . LittleEndian ; public class EscherChildAnchorRecord extends EscherRecord { public static final short RECORD_ID = ( short ) 0xF00F ; public static final String RECORD_DESCRIPTION = "MsofbtChildAnchor" ; private int field_1_dx1 ; private int field_2_dy1 ; private int field_3_dx2 ; private int field_4_dy2 ; public int fillFields ( byte [ ] data , int offset , EscherRecordFactory recordFactory ) { int bytesRemaining = readHeader ( data , offset ) ; int pos = offset + 8 ; int size = 0 ; field_1_dx1 = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; field_2_dy1 = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; field_3_dx2 = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; field_4_dy2 = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; return 8 + size ; } public int serialize ( int offset , byte [ ] data , EscherSerializationListener listener ) { listener . beforeRecordSerialize ( offset , getRecordId ( ) , this ) ; int pos = offset ; LittleEndian . putShort ( data , pos , getOptions ( ) ) ; pos += 2 ; LittleEndian . putShort ( data , pos , getRecordId ( ) ) ; pos += 2 ; LittleEndian . putInt ( data , pos , getRecordSize ( ) - 8 ) ; pos += 4 ; LittleEndian . putInt ( data , pos , field_1_dx1 ) ; pos += 4 ; LittleEndian . putInt ( data , pos , field_2_dy1 ) ; pos += 4 ; LittleEndian . putInt ( data , pos , field_3_dx2 ) ; pos += 4 ; LittleEndian . putInt ( data , pos , field_4_dy2 ) ; pos += 4 ; listener . afterRecordSerialize ( pos , getRecordId ( ) , pos - offset , this ) ; return pos - offset ; } public int getRecordSize ( ) { return 8 + 4 * 4 ; } public short getRecordId ( ) { return RECORD_ID ; } public String getRecordName ( ) { return "ChildAnchor" ; } public String toString ( ) { String nl = System . getProperty ( "line.separator" ) ; return getClass ( ) . getName ( ) + ":" + nl + "  RecordId: 0x" + HexDump . toHex ( RECORD_ID ) + nl + "  Options: 0x" + HexDump . toHex ( getOptions ( ) ) + nl + "  X1: " + field_1_dx1 + nl + "  Y1: " + field_2_dy1 + nl + "  X2: " + field_3_dx2 + nl + "  Y2: " + field_4_dy2 + nl ; } public int getDx1 ( ) { return field_1_dx1 ; } public void setDx1 ( int field_1_dx1 ) { this . field_1_dx1 = field_1_dx1 ; } public int getDy1 ( ) { return field_2_dy1 ; } public void setDy1 ( int field_2_dy1 ) { this . field_2_dy1 = field_2_dy1 ; } public int getDx2 ( ) { return field_3_dx2 ; } public void setDx2 ( int field_3_dx2 ) { this . field_3_dx2 = field_3_dx2 ; } public int getDy2 ( ) { return field_4_dy2 ; } public void setDy2 ( int field_4_dy2 ) { this . field_4_dy2 = field_4_dy2 ; } } 	0	['15', '2', '0', '6', '31', '43', '1', '5', '15', '0.833333333', '229', '0.666666667', '0', '0.575757576', '0.333333333', '1', '5', '13.86666667', '1', '0.9333', '0']
package org . apache . poi . poifs . filesystem ; import java . io . * ; public class DocumentInputStream extends InputStream { private int _current_offset ; private int _marked_offset ; private int _document_size ; private boolean _closed ; private POIFSDocument _document ; private byte [ ] _tiny_buffer ; static private final int EOD = - 1 ; public DocumentInputStream ( final DocumentEntry document ) throws IOException { _current_offset = 0 ; _marked_offset = 0 ; _document_size = document . getSize ( ) ; _closed = false ; _tiny_buffer = null ; if ( document instanceof DocumentNode ) { _document = ( ( DocumentNode ) document ) . getDocument ( ) ; } else { throw new IOException ( "Cannot open internal document storage" ) ; } } public DocumentInputStream ( final POIFSDocument document ) throws IOException { _current_offset = 0 ; _marked_offset = 0 ; _document_size = document . getSize ( ) ; _closed = false ; _tiny_buffer = null ; _document = document ; } public int available ( ) throws IOException { dieIfClosed ( ) ; return _document_size - _current_offset ; } public void close ( ) throws IOException { _closed = true ; } public void mark ( int ignoredReadlimit ) { _marked_offset = _current_offset ; } public boolean markSupported ( ) { return true ; } public int read ( ) throws IOException { dieIfClosed ( ) ; if ( atEOD ( ) ) { return EOD ; } if ( _tiny_buffer == null ) { _tiny_buffer = new byte [ 1 ] ; } _document . read ( _tiny_buffer , _current_offset ++ ) ; return ( ( int ) _tiny_buffer [ 0 ] ) & 0x000000FF ; } public int read ( final byte [ ] b ) throws IOException , NullPointerException { return read ( b , 0 , b . length ) ; } public int read ( final byte [ ] b , final int off , final int len ) throws IOException , NullPointerException , IndexOutOfBoundsException { dieIfClosed ( ) ; if ( b == null ) { throw new NullPointerException ( "buffer is null" ) ; } if ( ( off < 0 ) || ( len < 0 ) || ( b . length < ( off + len ) ) ) { throw new IndexOutOfBoundsException ( "can't read past buffer boundaries" ) ; } if ( len == 0 ) { return 0 ; } if ( atEOD ( ) ) { return EOD ; } int limit = Math . min ( available ( ) , len ) ; if ( ( off == 0 ) && ( limit == b . length ) ) { _document . read ( b , _current_offset ) ; } else { byte [ ] buffer = new byte [ limit ] ; _document . read ( buffer , _current_offset ) ; System . arraycopy ( buffer , 0 , b , off , limit ) ; } _current_offset += limit ; return limit ; } public void reset ( ) { _current_offset = _marked_offset ; } public long skip ( final long n ) throws IOException { dieIfClosed ( ) ; if ( n < 0 ) { return 0 ; } int new_offset = _current_offset + ( int ) n ; if ( new_offset < _current_offset ) { new_offset = _document_size ; } else if ( new_offset > _document_size ) { new_offset = _document_size ; } long rval = new_offset - _current_offset ; _current_offset = new_offset ; return rval ; } private void dieIfClosed ( ) throws IOException { if ( _closed ) { throw new IOException ( "cannot perform requested operation on a closed stream" ) ; } } private boolean atEOD ( ) { return _current_offset == _document_size ; } } 	0	['13', '2', '0', '13', '23', '0', '10', '3', '11', '0.642857143', '271', '1', '1', '0.45', '0.256410256', '1', '2', '19.30769231', '2', '0.9231', '0']
package org . apache . poi . ddf ; import org . apache . poi . util . HexDump ; import org . apache . poi . util . LittleEndian ; public class EscherDgRecord extends EscherRecord { public static final short RECORD_ID = ( short ) 0xF008 ; public static final String RECORD_DESCRIPTION = "MsofbtDg" ; private int field_1_numShapes ; private int field_2_lastMSOSPID ; public int fillFields ( byte [ ] data , int offset , EscherRecordFactory recordFactory ) { int bytesRemaining = readHeader ( data , offset ) ; int pos = offset + 8 ; int size = 0 ; field_1_numShapes = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; field_2_lastMSOSPID = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; return getRecordSize ( ) ; } public int serialize ( int offset , byte [ ] data , EscherSerializationListener listener ) { listener . beforeRecordSerialize ( offset , getRecordId ( ) , this ) ; LittleEndian . putShort ( data , offset , getOptions ( ) ) ; LittleEndian . putShort ( data , offset + 2 , getRecordId ( ) ) ; LittleEndian . putInt ( data , offset + 4 , 8 ) ; LittleEndian . putInt ( data , offset + 8 , field_1_numShapes ) ; LittleEndian . putInt ( data , offset + 12 , field_2_lastMSOSPID ) ; listener . afterRecordSerialize ( offset + 16 , getRecordId ( ) , getRecordSize ( ) , this ) ; return getRecordSize ( ) ; } public int getRecordSize ( ) { return 8 + 8 ; } public short getRecordId ( ) { return RECORD_ID ; } public String getRecordName ( ) { return "Dg" ; } public String toString ( ) { String nl = System . getProperty ( "line.separator" ) ; return getClass ( ) . getName ( ) + ":" + nl + "  RecordId: 0x" + HexDump . toHex ( RECORD_ID ) + nl + "  Options: 0x" + HexDump . toHex ( getOptions ( ) ) + nl + "  NumShapes: " + field_1_numShapes + nl + "  LastMSOSPID: " + field_2_lastMSOSPID + nl ; } public int getNumShapes ( ) { return field_1_numShapes ; } public void setNumShapes ( int field_1_numShapes ) { this . field_1_numShapes = field_1_numShapes ; } public int getLastMSOSPID ( ) { return field_2_lastMSOSPID ; } public void setLastMSOSPID ( int field_2_lastMSOSPID ) { this . field_2_lastMSOSPID = field_2_lastMSOSPID ; } public short getDrawingGroupId ( ) { return ( short ) ( getOptions ( ) > > 4 ) ; } public void incrementShapeCount ( ) { this . field_1_numShapes ++ ; } } 	0	['13', '2', '0', '7', '29', '34', '2', '5', '13', '0.854166667', '179', '0.5', '0', '0.612903226', '0.323076923', '1', '5', '12.46153846', '1', '0.9231', '0']
package org . apache . poi . poifs . property ; public interface Child { public Child getNextChild ( ) ; public Child getPreviousChild ( ) ; public void setNextChild ( final Child child ) ; public void setPreviousChild ( final Child child ) ; } 	0	['4', '1', '0', '3', '4', '6', '3', '0', '4', '2', '4', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . poi . poifs . filesystem ; import java . util . * ; import org . apache . poi . poifs . dev . POIFSViewable ; import org . apache . poi . poifs . property . DocumentProperty ; public class DocumentNode extends EntryNode implements DocumentEntry , POIFSViewable { private POIFSDocument _document ; DocumentNode ( final DocumentProperty property , final DirectoryNode parent ) { super ( property , parent ) ; _document = property . getDocument ( ) ; } POIFSDocument getDocument ( ) { return _document ; } public int getSize ( ) { return getProperty ( ) . getSize ( ) ; } public boolean isDocumentEntry ( ) { return true ; } protected boolean isDeleteOK ( ) { return true ; } public Object [ ] getViewableArray ( ) { return new Object [ 0 ] ; } public Iterator getViewableIterator ( ) { List components = new ArrayList ( ) ; components . add ( getProperty ( ) ) ; components . add ( _document ) ; return components . iterator ( ) ; } public boolean preferArray ( ) { return false ; } public String getShortDescription ( ) { return getName ( ) ; } } 	0	['9', '2', '0', '9', '17', '30', '3', '7', '6', '0.75', '55', '1', '1', '0.529411765', '0.407407407', '1', '1', '5', '1', '0.8889', '0']
package org . apache . poi . hssf . record ; public class RecordFormatException extends RuntimeException { public RecordFormatException ( String exception ) { super ( exception ) ; } } 	0	['1', '4', '0', '140', '2', '0', '140', '0', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . apache . poi . ddf ; import org . apache . poi . util . HexDump ; import org . apache . poi . util . LittleEndian ; import org . apache . poi . hssf . record . RecordFormatException ; public class EscherSpgrRecord extends EscherRecord { public static final short RECORD_ID = ( short ) 0xF009 ; public static final String RECORD_DESCRIPTION = "MsofbtSpgr" ; private int field_1_rectX1 ; private int field_2_rectY1 ; private int field_3_rectX2 ; private int field_4_rectY2 ; public int fillFields ( byte [ ] data , int offset , EscherRecordFactory recordFactory ) { int bytesRemaining = readHeader ( data , offset ) ; int pos = offset + 8 ; int size = 0 ; field_1_rectX1 = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; field_2_rectY1 = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; field_3_rectX2 = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; field_4_rectY2 = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; bytesRemaining -= size ; if ( bytesRemaining != 0 ) throw new RecordFormatException ( "Expected no remaining bytes but got " + bytesRemaining ) ; return 8 + size + bytesRemaining ; } public int serialize ( int offset , byte [ ] data , EscherSerializationListener listener ) { listener . beforeRecordSerialize ( offset , getRecordId ( ) , this ) ; LittleEndian . putShort ( data , offset , getOptions ( ) ) ; LittleEndian . putShort ( data , offset + 2 , getRecordId ( ) ) ; int remainingBytes = 16 ; LittleEndian . putInt ( data , offset + 4 , remainingBytes ) ; LittleEndian . putInt ( data , offset + 8 , field_1_rectX1 ) ; LittleEndian . putInt ( data , offset + 12 , field_2_rectY1 ) ; LittleEndian . putInt ( data , offset + 16 , field_3_rectX2 ) ; LittleEndian . putInt ( data , offset + 20 , field_4_rectY2 ) ; listener . afterRecordSerialize ( offset + getRecordSize ( ) , getRecordId ( ) , offset + getRecordSize ( ) , this ) ; return 8 + 16 ; } public int getRecordSize ( ) { return 8 + 16 ; } public short getRecordId ( ) { return RECORD_ID ; } public String getRecordName ( ) { return "Spgr" ; } public String toString ( ) { String nl = System . getProperty ( "line.separator" ) ; return getClass ( ) . getName ( ) + ":" + nl + "  RecordId: 0x" + HexDump . toHex ( RECORD_ID ) + nl + "  Options: 0x" + HexDump . toHex ( getOptions ( ) ) + nl + "  RectX: " + field_1_rectX1 + nl + "  RectY: " + field_2_rectY1 + nl + "  RectWidth: " + field_3_rectX2 + nl + "  RectHeight: " + field_4_rectY2 + nl ; } public int getRectX1 ( ) { return field_1_rectX1 ; } public void setRectX1 ( int x1 ) { this . field_1_rectX1 = x1 ; } public int getRectY1 ( ) { return field_2_rectY1 ; } public void setRectY1 ( int y1 ) { this . field_2_rectY1 = y1 ; } public int getRectX2 ( ) { return field_3_rectX2 ; } public void setRectX2 ( int x2 ) { this . field_3_rectX2 = x2 ; } public int getRectY2 ( ) { return field_4_rectY2 ; } public void setRectY2 ( int field_4_rectY2 ) { this . field_4_rectY2 = field_4_rectY2 ; } } 	0	['15', '2', '0', '7', '32', '43', '1', '6', '15', '0.833333333', '253', '0.666666667', '0', '0.575757576', '0.333333333', '1', '5', '15.46666667', '2', '1', '0']
