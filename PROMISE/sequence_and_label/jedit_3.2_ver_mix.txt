package org . gjt . sp . jedit ; import javax . swing . text . * ; import java . lang . reflect . * ; import java . awt . datatransfer . * ; import java . awt . Toolkit ; import java . io . * ; import java . util . Vector ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . textarea . JEditTextArea ; import org . gjt . sp . util . Log ; public class Registers { public static void copy ( JEditTextArea textArea , char register ) { String selection = textArea . getSelectedText ( ) ; if ( selection == null ) return ; setRegister ( register , selection ) ; HistoryModel . getModel ( "clipboard" ) . addItem ( selection ) ; } public static void append ( JEditTextArea textArea , char register ) { append ( textArea , register , "\n" , false ) ; } public static void append ( JEditTextArea textArea , char register , String separator ) { append ( textArea , register , separator , false ) ; } public static void append ( JEditTextArea textArea , char register , String separator , boolean cut ) { if ( cut && ! textArea . isEditable ( ) ) { textArea . getToolkit ( ) . beep ( ) ; return ; } String selection = textArea . getSelectedText ( ) ; if ( selection == null ) return ; Register reg = getRegister ( register ) ; String registerContents = reg . toString ( ) ; if ( reg != null && registerContents != null ) { if ( registerContents . endsWith ( separator ) ) selection = registerContents + selection ; else selection = registerContents + separator + selection ; } setRegister ( register , selection ) ; HistoryModel . getModel ( "clipboard" ) . addItem ( selection ) ; if ( cut ) textArea . setSelectedText ( "" ) ; } public static void cut ( JEditTextArea textArea , char register ) { if ( textArea . isEditable ( ) ) { String selection = textArea . getSelectedText ( ) ; if ( selection == null ) return ; setRegister ( register , selection ) ; HistoryModel . getModel ( "clipboard" ) . addItem ( selection ) ; textArea . setSelectedText ( "" ) ; } else textArea . getToolkit ( ) . beep ( ) ; } public static void paste ( JEditTextArea textArea , char register ) { if ( ! textArea . isEditable ( ) ) { textArea . getToolkit ( ) . beep ( ) ; return ; } Register reg = getRegister ( register ) ; if ( reg == null ) { textArea . getToolkit ( ) . beep ( ) ; return ; } else { String selection = reg . toString ( ) ; if ( selection == null ) { textArea . getToolkit ( ) . beep ( ) ; return ; } int magic = textArea . getMagicCaretPosition ( ) ; textArea . setSelectedText ( selection ) ; if ( textArea . getCaretPosition ( ) != textArea . getLineEndOffset ( textArea . getCaretLine ( ) ) - 1 ) { textArea . setMagicCaretPosition ( magic ) ; } else { } HistoryModel . getModel ( "clipboard" ) . addItem ( selection ) ; } } public static Register getRegister ( char name ) { if ( registers == null || name >= registers . length ) return null ; else return registers [ name ] ; } public static void setRegister ( char name , Register newRegister ) { if ( name >= registers . length ) { Register [ ] newRegisters = new Register [ Math . min ( 1 << 16 , name * 2 ) ] ; System . arraycopy ( registers , 0 , newRegisters , 0 , registers . length ) ; registers = newRegisters ; } registers [ name ] = newRegister ; } public static void setRegister ( char name , String value ) { if ( name >= registers . length ) { Register [ ] newRegisters = new Register [ Math . min ( 1 << 16 , name * 2 ) ] ; System . arraycopy ( registers , 0 , newRegisters , 0 , registers . length ) ; registers = newRegisters ; registers [ name ] = new StringRegister ( value ) ; } else { Register register = registers [ name ] ; if ( register != null ) register . setValue ( value ) ; else registers [ name ] = new StringRegister ( value ) ; } } public static void clearRegister ( char name ) { if ( name >= registers . length ) return ; Register register = registers [ name ] ; if ( name == '$' || name == '%' ) register . setValue ( "" ) ; else registers [ name ] = null ; } public static Register [ ] getRegisters ( ) { return registers ; } public interface Register { String toString ( ) ; void setValue ( String value ) ; } public static class ClipboardRegister implements Register { Clipboard clipboard ; public ClipboardRegister ( Clipboard clipboard ) { this . clipboard = clipboard ; } public void setValue ( String value ) { StringSelection selection = new StringSelection ( value ) ; clipboard . setContents ( selection , null ) ; } public String toString ( ) { try { String selection = ( String ) ( clipboard . getContents ( this ) . getTransferData ( DataFlavor . stringFlavor ) ) ; boolean trailingEOL = ( selection . endsWith ( "\n" ) || selection . endsWith ( System . getProperty ( "line.separator" ) ) ) ; BufferedReader in = new BufferedReader ( new StringReader ( selection ) ) ; StringBuffer buf = new StringBuffer ( ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) { buf . append ( line ) ; buf . append ( '\n' ) ; } if ( ! trailingEOL ) buf . setLength ( buf . length ( ) - 1 ) ; return buf . toString ( ) ; } catch ( Exception e ) { Log . log ( Log . NOTICE , this , e ) ; return null ; } } } public static class StringRegister implements Register { private String value ; public StringRegister ( String value ) { this . value = value ; } public void setValue ( String value ) { this . value = value ; } public String toString ( ) { return value ; } public void dispose ( ) { } } private static Register [ ] registers ; private Registers ( ) { } static { registers = new Register [ 256 ] ; registers [ '$' ] = new ClipboardRegister ( Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ) ; try { Method method = Toolkit . class . getMethod ( "getSystemSelection" , new Class [ 0 ] ) ; Clipboard selection = ( Clipboard ) method . invoke ( Toolkit . getDefaultToolkit ( ) , new Object [ 0 ] ) ; if ( selection != null ) { Log . log ( Log . DEBUG , Registers . class , "Toolkit.getSystemSelection() detected" ) ; Log . log ( Log . DEBUG , Registers . class , "% register is system selection" ) ; registers [ '%' ] = new ClipboardRegister ( selection ) ; } else { Log . log ( Log . DEBUG , Registers . class , "Toolkit.getSystemSelection() " + "detected, but returns null" ) ; Log . log ( Log . DEBUG , Registers . class , "% register is jEdit-specific" ) ; registers [ '%' ] = new StringRegister ( "" ) ; } } catch ( Exception e ) { Log . log ( Log . DEBUG , Registers . class , "Toolkit.getSystemSelection() not detected" ) ; Log . log ( Log . DEBUG , Registers . class , "% register is jEdit-specific" ) ; registers [ '%' ] = new StringRegister ( "" ) ; } } } 	0	['14', '1', '0', '9', '45', '61', '3', '6', '11', '0.769230769', '425', '1', '1', '0', '0.294871795', '0', '0', '29.14285714', '8', '2.4286', '0']
package org . gjt . sp . jedit ; import java . util . Vector ; import org . gjt . sp . jedit . gui . OptionsDialog ; public abstract class EditPlugin { public String getClassName ( ) { return getClass ( ) . getName ( ) ; } public void start ( ) { } public void stop ( ) { } public void createMenuItems ( Vector menuItems ) { } public void createMenuItems ( View view , Vector menus , Vector menuItems ) { } public void createOptionPanes ( OptionsDialog optionsDialog ) { } public EditPlugin . JAR getJAR ( ) { return jar ; } public static class Broken extends EditPlugin { public String getClassName ( ) { return clazz ; } Broken ( String clazz ) { this . clazz = clazz ; } private String clazz ; } public static class JAR { public String getPath ( ) { return path ; } public JARClassLoader getClassLoader ( ) { return classLoader ; } public void addPlugin ( EditPlugin plugin ) { plugin . jar = JAR . this ; plugins . addElement ( plugin ) ; plugin . start ( ) ; } public EditPlugin [ ] getPlugins ( ) { EditPlugin [ ] array = new EditPlugin [ plugins . size ( ) ] ; plugins . copyInto ( array ) ; return array ; } public JAR ( String path , JARClassLoader classLoader ) { this . path = path ; this . classLoader = classLoader ; plugins = new Vector ( ) ; } void getPlugins ( Vector vector ) { for ( int i = 0 ; i < plugins . size ( ) ; i ++ ) { vector . addElement ( plugins . elementAt ( i ) ) ; } } private String path ; private JARClassLoader classLoader ; private Vector plugins ; } private EditPlugin . JAR jar ; } 	1	['10', '1', '2', '11', '13', '39', '10', '3', '8', '0.777777778', '33', '1', '1', '0', '0.25', '0', '0', '2.2', '1', '0.9', '1']
package gnu . regexp ; import java . util . Vector ; final class RETokenRepeated extends REToken { private REToken token ; private int min , max ; private boolean stingy ; RETokenRepeated ( int subIndex , REToken token , int min , int max ) { super ( subIndex ) ; this . token = token ; this . min = min ; this . max = max ; } void makeStingy ( ) { stingy = true ; } boolean isStingy ( ) { return stingy ; } int getMinimumLength ( ) { return ( min * token . getMinimumLength ( ) ) ; } boolean match ( CharIndexed input , REMatch mymatch ) { int numRepeats = 0 ; REMatch newMatch = mymatch ; REMatch last = null ; REMatch current ; Vector positions = new Vector ( ) ; positions . addElement ( newMatch ) ; REMatch doables ; REMatch doablesLast ; REMatch recurrent ; do { if ( stingy && ( numRepeats >= min ) ) { REMatch result = matchRest ( input , newMatch ) ; if ( result != null ) { mymatch . assignFrom ( result ) ; return true ; } } doables = null ; doablesLast = null ; for ( current = newMatch ; current != null ; current = current . next ) { recurrent = ( REMatch ) current . clone ( ) ; if ( token . match ( input , recurrent ) ) { if ( doables == null ) { doables = recurrent ; doablesLast = recurrent ; } else { doablesLast . next = recurrent ; } while ( doablesLast . next != null ) { doablesLast = doablesLast . next ; } } } if ( doables == null ) break ; newMatch = doables ; ++ numRepeats ; positions . addElement ( newMatch ) ; } while ( numRepeats < max ) ; if ( numRepeats < min ) return false ; int posIndex = positions . size ( ) ; REMatch allResults = null ; REMatch allResultsLast = null ; REMatch results = null ; while ( -- posIndex >= min ) { newMatch = ( REMatch ) positions . elementAt ( posIndex ) ; results = matchRest ( input , newMatch ) ; if ( results != null ) { if ( allResults == null ) { allResults = results ; allResultsLast = results ; } else { allResultsLast . next = results ; } while ( allResultsLast . next != null ) { allResultsLast = allResultsLast . next ; } } } if ( allResults != null ) { mymatch . assignFrom ( allResults ) ; return true ; } return false ; } private REMatch matchRest ( CharIndexed input , final REMatch newMatch ) { REMatch current , single ; REMatch doneIndex = null ; REMatch doneIndexLast = null ; for ( current = newMatch ; current != null ; current = current . next ) { single = ( REMatch ) current . clone ( ) ; if ( next ( input , single ) ) { if ( doneIndex == null ) { doneIndex = single ; doneIndexLast = single ; } else { doneIndexLast . next = single ; } while ( doneIndexLast . next != null ) { doneIndexLast = doneIndexLast . next ; } } } return doneIndex ; } void dump ( StringBuffer os ) { os . append ( "(?:" ) ; token . dumpAll ( os ) ; os . append ( ')' ) ; if ( ( max == Integer . MAX_VALUE ) && ( min <= 1 ) ) os . append ( ( min == 0 ) ? '*' : '+' ) ; else if ( ( min == 0 ) && ( max == 1 ) ) os . append ( '?' ) ; else { os . append ( '{' ) . append ( min ) ; if ( max > min ) { os . append ( ',' ) ; if ( max != Integer . MAX_VALUE ) os . append ( max ) ; } os . append ( '}' ) ; } if ( stingy ) os . append ( '?' ) ; } } 	0	['7', '2', '0', '4', '21', '0', '1', '3', '0', '0.541666667', '300', '1', '1', '0.538461538', '0.333333333', '1', '3', '41.28571429', '16', '4.7143', '0']
package org . gjt . sp . jedit . browser ; import gnu . regexp . * ; import javax . swing . border . EmptyBorder ; import javax . swing . event . EventListenerList ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . gjt . sp . jedit . io . * ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . msg . * ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class VFSBrowser extends JPanel implements EBComponent , DockableWindow { public static final String NAME = "vfs.browser" ; public static final int OPEN_DIALOG = 0 ; public static final int SAVE_DIALOG = 1 ; public static final int BROWSER = 2 ; public VFSBrowser ( View view , String path ) { this ( view , path , BROWSER , false ) ; } public VFSBrowser ( View view , String path , int mode , boolean multipleSelection ) { super ( new BorderLayout ( ) ) ; listenerList = new EventListenerList ( ) ; this . mode = mode ; this . multipleSelection = multipleSelection ; this . view = view ; ActionHandler actionHandler = new ActionHandler ( ) ; Box topBox = new Box ( BoxLayout . Y_AXIS ) ; topBox . add ( createToolBar ( ) ) ; GridBagLayout layout = new GridBagLayout ( ) ; JPanel pathAndFilterPanel = new JPanel ( layout ) ; GridBagConstraints cons = new GridBagConstraints ( ) ; cons . gridwidth = cons . gridheight = 1 ; cons . gridx = cons . gridy = 0 ; cons . fill = GridBagConstraints . BOTH ; cons . anchor = GridBagConstraints . EAST ; JLabel label = new JLabel ( jEdit . getProperty ( "vfs.browser.path" ) , SwingConstants . RIGHT ) ; label . setBorder ( new EmptyBorder ( 0 , 0 , 0 , 12 ) ) ; layout . setConstraints ( label , cons ) ; pathAndFilterPanel . add ( label ) ; pathField = new HistoryTextField ( "vfs.browser.path" , true , false ) ; Dimension prefSize = pathField . getPreferredSize ( ) ; prefSize . width = 0 ; pathField . setPreferredSize ( prefSize ) ; pathField . addActionListener ( actionHandler ) ; cons . gridx = 1 ; cons . weightx = 1.0f ; layout . setConstraints ( pathField , cons ) ; pathAndFilterPanel . add ( pathField ) ; filterCheckbox = new JCheckBox ( jEdit . getProperty ( "vfs.browser.filter" ) ) ; filterCheckbox . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; filterCheckbox . setRequestFocusEnabled ( false ) ; filterCheckbox . setBorder ( new EmptyBorder ( 0 , 0 , 0 , 12 ) ) ; filterCheckbox . setSelected ( mode != BROWSER || jEdit . getBooleanProperty ( "vfs.browser.filter-enabled" ) ) ; filterCheckbox . setForeground ( new Color ( UIManager . getColor ( "Label.foreground" ) . getRGB ( ) ) ) ; filterCheckbox . addActionListener ( actionHandler ) ; cons . gridx = 0 ; cons . weightx = 0.0f ; cons . gridy = 1 ; layout . setConstraints ( filterCheckbox , cons ) ; pathAndFilterPanel . add ( filterCheckbox ) ; filterField = new HistoryTextField ( "vfs.browser.filter" , true ) ; filterField . addActionListener ( actionHandler ) ; cons . gridx = 1 ; cons . weightx = 1.0f ; layout . setConstraints ( filterField , cons ) ; pathAndFilterPanel . add ( filterField ) ; topBox . add ( pathAndFilterPanel ) ; add ( BorderLayout . NORTH , topBox ) ; add ( BorderLayout . CENTER , browserView = new BrowserView ( this ) ) ; propertiesChanged ( ) ; HistoryModel filterModel = HistoryModel . getModel ( "vfs.browser.filter" ) ; String filter ; if ( mode == BROWSER || view == null || ! jEdit . getBooleanProperty ( "vfs.browser.currentBufferFilter" ) ) { filter = jEdit . getProperty ( "vfs.browser.last-filter" ) ; if ( filter == null ) filter = jEdit . getProperty ( "vfs.browser.default-filter" ) ; } else { String name = view . getBuffer ( ) . getName ( ) ; int index = name . lastIndexOf ( '.' ) ; if ( index == - 1 ) filter = jEdit . getProperty ( "vfs.browser.default-filter" ) ; else { String ext = name . substring ( index ) ; filter = "*" + ext ; } } filterField . setText ( filter ) ; filterField . addCurrentToHistory ( ) ; updateFilterEnabled ( ) ; if ( path == null ) { String defaultPath = jEdit . getProperty ( "vfs.browser.defaultPath" ) ; String userHome = System . getProperty ( "user.home" ) ; if ( defaultPath . equals ( "home" ) ) path = userHome ; else if ( defaultPath . equals ( "buffer" ) ) { if ( view != null ) { Buffer buffer = view . getBuffer ( ) ; path = buffer . getVFS ( ) . getParentOfPath ( buffer . getPath ( ) ) ; } else path = userHome ; } else if ( defaultPath . equals ( "last" ) ) { HistoryModel pathModel = HistoryModel . getModel ( "vfs.browser.path" ) ; if ( pathModel . getSize ( ) == 0 ) path = userHome ; else path = pathModel . getItem ( 0 ) ; } else if ( defaultPath . equals ( "favorites" ) ) path = "favorites:" ; else { path = userHome ; } } setDirectory ( path ) ; } public void addNotify ( ) { super . addNotify ( ) ; EditBus . addToBus ( this ) ; } public void removeNotify ( ) { super . removeNotify ( ) ; jEdit . setBooleanProperty ( "vfs.browser.filter-enabled" , filterCheckbox . isSelected ( ) ) ; if ( mode == BROWSER || ! jEdit . getBooleanProperty ( "vfs.browser.currentBufferFilter" ) ) { jEdit . setProperty ( "vfs.browser.last-filter" , filterField . getText ( ) ) ; } EditBus . removeFromBus ( this ) ; } public String getName ( ) { return NAME ; } public Component getComponent ( ) { return this ; } public void handleMessage ( EBMessage msg ) { if ( msg instanceof ViewUpdate ) handleViewUpdate ( ( ViewUpdate ) msg ) ; else if ( msg instanceof BufferUpdate ) handleBufferUpdate ( ( BufferUpdate ) msg ) ; else if ( msg instanceof PropertiesChanged ) propertiesChanged ( ) ; else if ( msg instanceof VFSUpdate ) { if ( requestRunning ) return ; browserView . reloadDirectory ( ( ( VFSUpdate ) msg ) . getPath ( ) ) ; } } public String getDirectory ( ) { return path ; } public void setDirectory ( String path ) { if ( path . length ( ) != 1 && ( path . endsWith ( "/" ) || path . endsWith ( java . io . File . separator ) ) ) path = path . substring ( 0 , path . length ( ) - 1 ) ; if ( path . startsWith ( "file:" ) ) path = path . substring ( 5 ) ; this . path = path ; pathField . setText ( path ) ; pathField . addCurrentToHistory ( ) ; reloadDirectory ( ) ; } public void reloadDirectory ( ) { try { String filter = filterField . getText ( ) ; if ( filter . length ( ) == 0 ) filter = "*" ; filenameFilter = new RE ( MiscUtilities . globToRE ( filter ) , RE . REG_ICASE ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , VFSBrowser . this , e ) ; String [ ] args = { filterField . getText ( ) , e . getMessage ( ) } ; GUIUtilities . error ( VFSBrowser . this , "vfs.browser.bad-filter" , args ) ; } loadDirectory ( path ) ; } public void loadDirectory ( String path ) { VFS vfs = VFSManager . getVFSForPath ( path ) ; Object session = vfs . createVFSSession ( path , this ) ; if ( session == null ) return ; if ( ! startRequest ( ) ) return ; VFSManager . runInWorkThread ( new BrowserIORequest ( BrowserIORequest . LIST_DIRECTORY , this , session , vfs , path , null ) ) ; } public void delete ( String path ) { if ( MiscUtilities . isURL ( path ) && FavoritesVFS . PROTOCOL . equals ( MiscUtilities . getProtocolOfURL ( path ) ) ) { Object [ ] args = { path . substring ( FavoritesVFS . PROTOCOL . length ( ) + 1 ) } ; int result = GUIUtilities . confirm ( this , "vfs.browser.delete-favorites" , args , JOptionPane . YES_NO_OPTION , JOptionPane . WARNING_MESSAGE ) ; if ( result != JOptionPane . YES_OPTION ) return ; } else { Object [ ] args = { path } ; int result = GUIUtilities . confirm ( this , "vfs.browser.delete-confirm" , args , JOptionPane . YES_NO_OPTION , JOptionPane . WARNING_MESSAGE ) ; if ( result != JOptionPane . YES_OPTION ) return ; } VFS vfs = VFSManager . getVFSForPath ( path ) ; Object session = vfs . createVFSSession ( path , this ) ; if ( session == null ) return ; if ( ! startRequest ( ) ) return ; VFSManager . runInWorkThread ( new BrowserIORequest ( BrowserIORequest . DELETE , this , session , vfs , path , null ) ) ; } public void rename ( String from ) { VFS vfs = VFSManager . getVFSForPath ( from ) ; String filename = vfs . getFileName ( from ) ; String [ ] args = { filename } ; String to = GUIUtilities . input ( this , "vfs.browser.rename" , args , filename ) ; if ( to == null ) return ; to = vfs . constructPath ( vfs . getParentOfPath ( from ) , to ) ; Object session = vfs . createVFSSession ( from , this ) ; if ( session == null ) return ; if ( ! startRequest ( ) ) return ; VFSManager . runInWorkThread ( new BrowserIORequest ( BrowserIORequest . RENAME , this , session , vfs , from , to ) ) ; } public void mkdir ( ) { String newDirectory = GUIUtilities . input ( this , "vfs.browser.mkdir" , null ) ; if ( newDirectory == null ) return ; VFS . DirectoryEntry [ ] selected = getSelectedFiles ( ) ; String parent ; if ( selected . length == 0 ) parent = path ; else if ( selected [ 0 ] . type == VFS . DirectoryEntry . FILE ) { parent = selected [ 0 ] . path ; parent = VFSManager . getVFSForPath ( parent ) . getParentOfPath ( parent ) ; } else parent = selected [ 0 ] . path ; VFS vfs = VFSManager . getVFSForPath ( parent ) ; newDirectory = vfs . constructPath ( parent , newDirectory ) ; Object session = vfs . createVFSSession ( newDirectory , this ) ; if ( session == null ) return ; if ( ! startRequest ( ) ) return ; VFSManager . runInWorkThread ( new BrowserIORequest ( BrowserIORequest . MKDIR , this , session , vfs , newDirectory , null ) ) ; } public View getView ( ) { return view ; } public int getMode ( ) { return mode ; } public boolean isMultipleSelectionEnabled ( ) { return multipleSelection ; } public boolean getShowHiddenFiles ( ) { return showHiddenFiles ; } public void setShowHiddenFiles ( boolean showHiddenFiles ) { this . showHiddenFiles = showHiddenFiles ; } public String getFilenameFilter ( ) { if ( filterCheckbox . isSelected ( ) ) { String filter = filterField . getText ( ) ; if ( filter . length ( ) == 0 ) return "*" ; else return filter ; } else return "*" ; } public void setFilenameFilter ( String filter ) { if ( filter == null || filter . length ( ) == 0 || filter . equals ( "*" ) ) filterCheckbox . setSelected ( false ) ; else { filterCheckbox . setSelected ( true ) ; filterField . setText ( filter ) ; } } public BrowserView getBrowserView ( ) { return browserView ; } public VFS . DirectoryEntry [ ] getSelectedFiles ( ) { return browserView . getSelectedFiles ( ) ; } public void addBrowserListener ( BrowserListener l ) { listenerList . add ( BrowserListener . class , l ) ; } public void removeBrowserListener ( BrowserListener l ) { listenerList . remove ( BrowserListener . class , l ) ; } void directoryLoaded ( final VFS . DirectoryEntry [ ] list ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { boolean filterEnabled = filterCheckbox . isSelected ( ) ; Vector directoryVector = new Vector ( ) ; if ( list == null ) { browserView . directoryLoaded ( directoryVector ) ; return ; } for ( int i = 0 ; i < list . length ; i ++ ) { VFS . DirectoryEntry file = list [ i ] ; if ( file . hidden && ! showHiddenFiles ) continue ; if ( file . type == VFS . DirectoryEntry . FILE && filterEnabled && filenameFilter != null && ! filenameFilter . isMatch ( file . name ) ) continue ; directoryVector . addElement ( file ) ; } if ( sortFiles ) { MiscUtilities . quicksort ( directoryVector , new FileCompare ( ) ) ; } browserView . directoryLoaded ( directoryVector ) ; } } ) ; } class FileCompare implements MiscUtilities . Compare { public int compare ( Object obj1 , Object obj2 ) { VFS . DirectoryEntry file1 = ( VFS . DirectoryEntry ) obj1 ; VFS . DirectoryEntry file2 = ( VFS . DirectoryEntry ) obj2 ; if ( ! sortMixFilesAndDirs ) { if ( file1 . type != file2 . type ) return file2 . type - file1 . type ; } if ( sortIgnoreCase ) { return file1 . name . toLowerCase ( ) . compareTo ( file2 . name . toLowerCase ( ) ) ; } else { return file1 . name . compareTo ( file2 . name ) ; } } } void filesSelected ( ) { VFS . DirectoryEntry [ ] selectedFiles = browserView . getSelectedFiles ( ) ; if ( mode == BROWSER ) { for ( int i = 0 ; i < selectedFiles . length ; i ++ ) { VFS . DirectoryEntry file = selectedFiles [ i ] ; Buffer buffer = jEdit . getBuffer ( file . path ) ; if ( buffer != null && view != null ) view . setBuffer ( buffer ) ; } } Object [ ] listeners = listenerList . getListenerList ( ) ; for ( int i = 0 ; i < listeners . length ; i ++ ) { if ( listeners [ i ] == BrowserListener . class ) { BrowserListener l = ( BrowserListener ) listeners [ i + 1 ] ; l . filesSelected ( this , selectedFiles ) ; } } } void filesActivated ( ) { VFS . DirectoryEntry [ ] selectedFiles = browserView . getSelectedFiles ( ) ; for ( int i = 0 ; i < selectedFiles . length ; i ++ ) { VFS . DirectoryEntry file = selectedFiles [ i ] ; if ( file . type == VFS . DirectoryEntry . DIRECTORY || file . type == VFS . DirectoryEntry . FILESYSTEM ) setDirectory ( file . path ) ; else if ( mode == BROWSER ) { Buffer buffer = jEdit . getBuffer ( file . path ) ; if ( buffer == null ) buffer = jEdit . openFile ( null , file . path ) ; else if ( doubleClickClose ) { jEdit . closeBuffer ( view , buffer ) ; break ; } if ( buffer != null ) { if ( view == null ) view = jEdit . newView ( null , buffer ) ; else view . setBuffer ( buffer ) ; } } else { } } Object [ ] listeners = listenerList . getListenerList ( ) ; for ( int i = 0 ; i < listeners . length ; i ++ ) { if ( listeners [ i ] == BrowserListener . class ) { BrowserListener l = ( BrowserListener ) listeners [ i + 1 ] ; l . filesActivated ( this , selectedFiles ) ; } } } void endRequest ( ) { requestRunning = false ; } private EventListenerList listenerList ; private View view ; private String path ; private HistoryTextField pathField ; private JCheckBox filterCheckbox ; private HistoryTextField filterField ; private JButton up , reload , roots , home , synchronize ; private BrowserView browserView ; private RE filenameFilter ; private int mode ; private boolean multipleSelection ; private boolean showHiddenFiles ; private boolean sortFiles ; private boolean sortMixFilesAndDirs ; private boolean sortIgnoreCase ; private boolean doubleClickClose ; private boolean requestRunning ; private JToolBar createToolBar ( ) { JToolBar toolBar = new JToolBar ( ) ; toolBar . setFloatable ( false ) ; toolBar . putClientProperty ( "JToolBar.isRollover" , Boolean . TRUE ) ; toolBar . add ( up = createToolButton ( "up" ) ) ; toolBar . add ( new UpMenuButton ( up ) ) ; toolBar . add ( reload = createToolButton ( "reload" ) ) ; toolBar . addSeparator ( ) ; toolBar . add ( roots = createToolButton ( "roots" ) ) ; toolBar . add ( home = createToolButton ( "home" ) ) ; toolBar . add ( synchronize = createToolButton ( "synchronize" ) ) ; toolBar . addSeparator ( ) ; toolBar . add ( new MoreMenuButton ( ) ) ; toolBar . add ( Box . createGlue ( ) ) ; return toolBar ; } private JButton createToolButton ( String name ) { JButton button = new JButton ( ) ; String prefix = "vfs.browser." ; button . setIcon ( GUIUtilities . loadIcon ( jEdit . getProperty ( prefix + name + ".icon" ) ) ) ; button . setToolTipText ( jEdit . getProperty ( prefix + name + ".label" ) ) ; button . setRequestFocusEnabled ( false ) ; button . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; button . addActionListener ( new ActionHandler ( ) ) ; return button ; } private void handleViewUpdate ( ViewUpdate vmsg ) { if ( vmsg . getWhat ( ) == ViewUpdate . CLOSED && vmsg . getView ( ) == view ) view = null ; } private void handleBufferUpdate ( BufferUpdate bmsg ) { if ( bmsg . getWhat ( ) == BufferUpdate . CREATED || bmsg . getWhat ( ) == BufferUpdate . CLOSED ) browserView . updateFileView ( ) ; else if ( bmsg . getWhat ( ) == BufferUpdate . DIRTY_CHANGED ) { if ( ! bmsg . getBuffer ( ) . isDirty ( ) ) browserView . updateFileView ( ) ; } } private void propertiesChanged ( ) { showHiddenFiles = jEdit . getBooleanProperty ( "vfs.browser.showHiddenFiles" ) ; sortFiles = jEdit . getBooleanProperty ( "vfs.browser.sortFiles" ) ; sortMixFilesAndDirs = jEdit . getBooleanProperty ( "vfs.browser.sortMixFilesAndDirs" ) ; sortIgnoreCase = jEdit . getBooleanProperty ( "vfs.browser.sortIgnoreCase" ) ; doubleClickClose = jEdit . getBooleanProperty ( "vfs.browser.doubleClickClose" ) ; browserView . propertiesChanged ( ) ; if ( path != null ) reloadDirectory ( ) ; } private boolean startRequest ( ) { if ( requestRunning ) { Log . log ( Log . DEBUG , this , new Throwable ( "For debugging purposes" ) ) ; GUIUtilities . error ( this , "browser-multiple-io" , null ) ; return false ; } else { requestRunning = true ; return true ; } } private void updateFilterEnabled ( ) { filterField . setEnabled ( filterCheckbox . isSelected ( ) ) ; } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == pathField || source == filterField || source == filterCheckbox ) { updateFilterEnabled ( ) ; String path = pathField . getText ( ) ; if ( path != null ) setDirectory ( path ) ; } else if ( source == up ) { VFS vfs = VFSManager . getVFSForPath ( path ) ; setDirectory ( vfs . getParentOfPath ( path ) ) ; } else if ( source == reload ) reloadDirectory ( ) ; else if ( source == roots ) setDirectory ( FileRootsVFS . PROTOCOL + ":" ) ; else if ( source == home ) setDirectory ( System . getProperty ( "user.home" ) ) ; else if ( source == synchronize ) { if ( view != null ) { Buffer buffer = view . getBuffer ( ) ; setDirectory ( buffer . getVFS ( ) . getParentOfPath ( buffer . getPath ( ) ) ) ; } else getToolkit ( ) . beep ( ) ; } } } class UpMenuButton extends JButton { UpMenuButton ( JButton upButton ) { this . upButton = upButton ; setIcon ( GUIUtilities . loadIcon ( jEdit . getProperty ( "vfs.browser.up-menu.icon" ) ) ) ; UpMenuButton . this . setToolTipText ( jEdit . getProperty ( "vfs.browser.up-menu.label" ) ) ; UpMenuButton . this . setRequestFocusEnabled ( false ) ; setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; UpMenuButton . this . addMouseListener ( new MouseHandler ( ) ) ; } private JButton upButton ; private JPopupMenu popup ; private void createPopup ( ) { popup = new JPopupMenu ( ) ; ActionHandler actionHandler = new ActionHandler ( ) ; VFS vfs = VFSManager . getVFSForPath ( path ) ; String dir = vfs . getParentOfPath ( path ) ; for ( ; ; ) { JMenuItem menuItem = new JMenuItem ( dir ) ; menuItem . addActionListener ( actionHandler ) ; popup . add ( menuItem ) ; String parentDir = vfs . getParentOfPath ( dir ) ; if ( parentDir . equals ( dir ) ) break ; else dir = parentDir ; } } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { setDirectory ( evt . getActionCommand ( ) ) ; } } class MouseHandler extends MouseAdapter { public void mousePressed ( MouseEvent evt ) { if ( popup == null || ! popup . isVisible ( ) ) { createPopup ( ) ; popup . show ( upButton , 0 , upButton . getHeight ( ) ) ; } else { popup . setVisible ( false ) ; popup = null ; } } } } class MoreMenuButton extends JButton { MoreMenuButton ( ) { setText ( jEdit . getProperty ( "vfs.browser.more.label" ) ) ; setIcon ( GUIUtilities . loadIcon ( jEdit . getProperty ( "vfs.browser.more.icon" ) ) ) ; setHorizontalTextPosition ( SwingConstants . LEFT ) ; MoreMenuButton . this . setRequestFocusEnabled ( false ) ; setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; MoreMenuButton . this . addMouseListener ( new MouseHandler ( ) ) ; } JPopupMenu popup ; class MouseHandler extends MouseAdapter { public void mousePressed ( MouseEvent evt ) { if ( popup == null || ! popup . isVisible ( ) ) { popup = new BrowserPopupMenu ( VFSBrowser . this , null ) ; popup . show ( MoreMenuButton . this , 0 , MoreMenuButton . this . getHeight ( ) ) ; } else { popup . setVisible ( false ) ; popup = null ; } } } } } 	1	['54', '5', '0', '41', '175', '1183', '21', '27', '25', '0.930333817', '1425', '0.846153846', '5', '0.926241135', '0.122895623', '3', '12', '24.90740741', '11', '2.1296', '18']
package gnu . regexp ; import java . io . Serializable ; import java . util . Enumeration ; import java . util . NoSuchElementException ; public class REMatchEnumeration implements Enumeration , Serializable { private static final int YES = 1 ; private static final int MAYBE = 0 ; private static final int NO = - 1 ; private int more ; private REMatch match ; private RE expr ; private CharIndexed input ; private int eflags ; private StringBuffer buffer ; REMatchEnumeration ( RE expr , CharIndexed input , int index , int eflags ) { more = MAYBE ; this . expr = expr ; this . input = input ; input . move ( index ) ; this . eflags = eflags ; } public boolean hasMoreElements ( ) { return hasMoreMatches ( null ) ; } public boolean hasMoreMatches ( ) { return hasMoreMatches ( null ) ; } public boolean hasMoreMatches ( StringBuffer buffer ) { if ( more == MAYBE ) { match = expr . getMatchImpl ( input , 0 , eflags , buffer ) ; if ( match != null ) { input . move ( ( match . end [ 0 ] > 0 ) ? match . end [ 0 ] : 1 ) ; more = YES ; } else more = NO ; } return ( more == YES ) ; } public Object nextElement ( ) throws NoSuchElementException { return nextMatch ( ) ; } public REMatch nextMatch ( ) throws NoSuchElementException { if ( hasMoreElements ( ) ) { more = ( input . isValid ( ) ) ? MAYBE : NO ; return match ; } throw new NoSuchElementException ( ) ; } } 	0	['6', '1', '0', '3', '11', '9', '1', '3', '5', '0.6', '113', '1', '3', '0', '0.333333333', '0', '0', '16.33333333', '5', '1.5', '0']
package org . gjt . sp . jedit . options ; import javax . swing . table . * ; import javax . swing . * ; import java . awt . * ; import java . util . Vector ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . * ; public class DockingOptionPane extends AbstractOptionPane { public DockingOptionPane ( ) { super ( "docking" ) ; } public void _init ( ) { Box box = new Box ( BoxLayout . X_AXIS ) ; ButtonGroup grp = new ButtonGroup ( ) ; layout1 = new JToggleButton ( GUIUtilities . loadIcon ( "dock_layout1.gif" ) ) ; grp . add ( layout1 ) ; box . add ( layout1 ) ; box . add ( Box . createHorizontalStrut ( 6 ) ) ; layout2 = new JToggleButton ( GUIUtilities . loadIcon ( "dock_layout2.gif" ) ) ; grp . add ( layout2 ) ; box . add ( layout2 ) ; if ( jEdit . getBooleanProperty ( "view.docking.alternateLayout" ) ) layout2 . setSelected ( true ) ; else layout1 . setSelected ( true ) ; addComponent ( jEdit . getProperty ( "options.docking.layout" ) , box ) ; String [ ] positions = { jEdit . getProperty ( "options.docking.top" ) , jEdit . getProperty ( "options.docking.bottom" ) , } ; tabsPos = new JComboBox ( positions ) ; tabsPos . setSelectedIndex ( Integer . parseInt ( jEdit . getProperty ( "view.docking.tabsPos" ) ) ) ; addComponent ( jEdit . getProperty ( "options.docking.tabsPos" ) , tabsPos ) ; addComponent ( Box . createVerticalStrut ( 6 ) ) ; GridBagConstraints cons = new GridBagConstraints ( ) ; cons . gridy = 3 ; cons . gridwidth = cons . gridheight = GridBagConstraints . REMAINDER ; cons . fill = GridBagConstraints . BOTH ; cons . weightx = cons . weighty = 1.0f ; JScrollPane windowScroller = createWindowTableScroller ( ) ; gridBag . setConstraints ( windowScroller , cons ) ; add ( windowScroller ) ; } public void _save ( ) { jEdit . setBooleanProperty ( "view.docking.alternateLayout" , layout2 . isSelected ( ) ) ; jEdit . setProperty ( "view.docking.tabsPos" , String . valueOf ( tabsPos . getSelectedIndex ( ) ) ) ; windowModel . save ( ) ; } private JToggleButton layout1 ; private JToggleButton layout2 ; private JComboBox tabsPos ; private JTable windowTable ; private WindowTableModel windowModel ; private JScrollPane createWindowTableScroller ( ) { windowModel = createWindowModel ( ) ; windowTable = new JTable ( windowModel ) ; windowTable . getTableHeader ( ) . setReorderingAllowed ( false ) ; windowTable . setColumnSelectionAllowed ( false ) ; windowTable . setRowSelectionAllowed ( false ) ; windowTable . setCellSelectionEnabled ( false ) ; DockPositionCellRenderer comboBox = new DockPositionCellRenderer ( ) ; comboBox . setRequestFocusEnabled ( false ) ; windowTable . setRowHeight ( comboBox . getPreferredSize ( ) . height ) ; TableColumn column = windowTable . getColumnModel ( ) . getColumn ( 1 ) ; column . setCellRenderer ( comboBox ) ; comboBox = new DockPositionCellRenderer ( ) ; comboBox . setRequestFocusEnabled ( false ) ; column . setCellEditor ( new DefaultCellEditor ( comboBox ) ) ; Dimension d = windowTable . getPreferredSize ( ) ; d . height = Math . min ( d . height , 200 ) ; JScrollPane scroller = new JScrollPane ( windowTable ) ; scroller . setPreferredSize ( d ) ; return scroller ; } private WindowTableModel createWindowModel ( ) { return new WindowTableModel ( ) ; } class DockPositionCellRenderer extends JComboBox implements TableCellRenderer { DockPositionCellRenderer ( ) { super ( new String [ ] { DockableWindowManager . FLOATING , DockableWindowManager . TOP , DockableWindowManager . LEFT , DockableWindowManager . BOTTOM , DockableWindowManager . RIGHT } ) ; } public Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean hasFocus , int row , int column ) { setSelectedItem ( value ) ; return this ; } } } class WindowTableModel extends AbstractTableModel { private Vector windows ; WindowTableModel ( ) { Object [ ] list = EditBus . getNamedList ( DockableWindow . DOCKABLE_WINDOW_LIST ) ; windows = new Vector ( list . length ) ; for ( int i = 0 ; i < list . length ; i ++ ) { windows . addElement ( new Entry ( ( String ) list [ i ] ) ) ; } sort ( ) ; } public void sort ( ) { MiscUtilities . quicksort ( windows , new WindowCompare ( ) ) ; fireTableDataChanged ( ) ; } public int getColumnCount ( ) { return 3 ; } public int getRowCount ( ) { return windows . size ( ) ; } public Class getColumnClass ( int col ) { switch ( col ) { case 0 : case 1 : return String . class ; case 2 : return Boolean . class ; default : throw new InternalError ( ) ; } } public Object getValueAt ( int row , int col ) { Entry window = ( Entry ) windows . elementAt ( row ) ; switch ( col ) { case 0 : return window . title ; case 1 : return window . dockPosition ; case 2 : return new Boolean ( window . autoOpen ) ; default : throw new InternalError ( ) ; } } public boolean isCellEditable ( int row , int col ) { return ( col != 0 ) ; } public void setValueAt ( Object value , int row , int col ) { if ( col == 0 ) return ; Entry window = ( Entry ) windows . elementAt ( row ) ; switch ( col ) { case 1 : window . dockPosition = ( String ) value ; break ; case 2 : window . autoOpen = ( ( Boolean ) value ) . booleanValue ( ) ; break ; default : throw new InternalError ( ) ; } fireTableRowsUpdated ( row , row ) ; } public String getColumnName ( int index ) { switch ( index ) { case 0 : return jEdit . getProperty ( "options.docking.title" ) ; case 1 : return jEdit . getProperty ( "options.docking.dockPosition" ) ; case 2 : return jEdit . getProperty ( "options.docking.autoOpen" ) ; default : throw new InternalError ( ) ; } } public void save ( ) { for ( int i = 0 ; i < windows . size ( ) ; i ++ ) { ( ( Entry ) windows . elementAt ( i ) ) . save ( ) ; } } class Entry { String name ; String title ; String dockPosition ; boolean autoOpen ; Entry ( String name ) { this . name = name ; title = jEdit . getProperty ( name + ".title" ) ; if ( title == null ) title = name ; dockPosition = jEdit . getProperty ( name + ".dock-position" ) ; if ( dockPosition == null ) dockPosition = DockableWindowManager . FLOATING ; autoOpen = jEdit . getBooleanProperty ( name + ".auto-open" ) ; } void save ( ) { jEdit . setProperty ( name + ".dock-position" , dockPosition ) ; jEdit . setBooleanProperty ( name + ".auto-open" , autoOpen ) ; } } class WindowCompare implements MiscUtilities . Compare { public int compare ( Object obj1 , Object obj2 ) { Entry e1 = ( Entry ) obj1 ; Entry e2 = ( Entry ) obj2 ; return e1 . title . compareTo ( e2 . title ) ; } } } 	1	['5', '6', '0', '6', '51', '6', '2', '5', '3', '0.75', '260', '1', '1', '0.993993994', '1', '2', '4', '50', '3', '1.4', '1']
package bsh ; import java . lang . reflect . Array ; class BSHType extends SimpleNode implements BshClassManager . Listener { private Class baseType ; private int arrayDims ; private Class type ; BSHType ( int id ) { super ( id ) ; BshClassManager . addCMListener ( this ) ; } public void addArrayDimension ( ) { arrayDims ++ ; } public Class getType ( NameSpace namespace ) throws EvalError { if ( type != null ) return type ; SimpleNode node = ( SimpleNode ) jjtGetChild ( 0 ) ; if ( node instanceof BSHPrimitiveType ) baseType = ( ( BSHPrimitiveType ) node ) . getType ( ) ; else baseType = ( ( BSHAmbiguousName ) node ) . toClass ( namespace ) ; if ( arrayDims > 0 ) { try { int [ ] dims = new int [ arrayDims ] ; Object obj = Array . newInstance ( baseType , dims ) ; type = obj . getClass ( ) ; } catch ( Exception e ) { throw new EvalError ( "Couldn't construct array type" , this ) ; } } else type = baseType ; return type ; } public Class getBaseType ( ) { return baseType ; } public int getArrayDims ( ) { return arrayDims ; } public void classLoaderChanged ( ) { type = null ; baseType = null ; } } 	0	['6', '2', '0', '16', '14', '3', '8', '8', '5', '0.666666667', '92', '1', '0', '0.782608696', '0.444444444', '0', '0', '13.83333333', '1', '0.8333', '0']
package org . gjt . sp . jedit . gui ; import com . microstar . xml . * ; import javax . swing . * ; import javax . swing . border . * ; import javax . swing . event . * ; import javax . swing . text . html . * ; import javax . swing . text . Document ; import javax . swing . tree . * ; import java . awt . * ; import java . awt . event . * ; import java . io . * ; import java . net . * ; import java . util . * ; import org . gjt . sp . jedit . msg . PropertiesChanged ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class HelpViewer extends JFrame implements EBComponent { public static void gotoURL ( URL url ) { new HelpViewer ( url . toString ( ) ) ; } public HelpViewer ( URL url ) { this ( url . toString ( ) ) ; } public HelpViewer ( String url ) { super ( jEdit . getProperty ( "helpviewer.title" ) ) ; setIconImage ( GUIUtilities . getEditorIcon ( ) ) ; history = new String [ 25 ] ; nodes = new Hashtable ( ) ; ActionHandler actionListener = new ActionHandler ( ) ; JToolBar toolBar = new JToolBar ( ) ; toolBar . setFloatable ( false ) ; toolBar . putClientProperty ( "JToolBar.isRollover" , Boolean . TRUE ) ; JLabel label = new JLabel ( jEdit . getProperty ( "helpviewer.url" ) ) ; label . setBorder ( new EmptyBorder ( 0 , 12 , 0 , 12 ) ) ; toolBar . add ( label ) ; Box box = new Box ( BoxLayout . Y_AXIS ) ; box . add ( Box . createGlue ( ) ) ; urlField = new JTextField ( ) ; urlField . addKeyListener ( new KeyHandler ( ) ) ; Dimension dim = urlField . getPreferredSize ( ) ; dim . width = Integer . MAX_VALUE ; urlField . setMaximumSize ( dim ) ; box . add ( urlField ) ; box . add ( Box . createGlue ( ) ) ; toolBar . add ( box ) ; toolBar . add ( Box . createHorizontalStrut ( 6 ) ) ; JPanel buttons = new JPanel ( ) ; buttons . setLayout ( new BoxLayout ( buttons , BoxLayout . X_AXIS ) ) ; buttons . setBorder ( new EmptyBorder ( 0 , 12 , 0 , 0 ) ) ; back = new JButton ( GUIUtilities . loadIcon ( "Back24.gif" ) ) ; back . setToolTipText ( jEdit . getProperty ( "helpviewer.back" ) ) ; back . addActionListener ( actionListener ) ; back . setRequestFocusEnabled ( false ) ; toolBar . add ( back ) ; forward = new JButton ( GUIUtilities . loadIcon ( "Forward24.gif" ) ) ; forward . addActionListener ( actionListener ) ; forward . setToolTipText ( jEdit . getProperty ( "helpviewer.forward" ) ) ; forward . setRequestFocusEnabled ( false ) ; toolBar . add ( forward ) ; back . setPreferredSize ( forward . getPreferredSize ( ) ) ; getContentPane ( ) . add ( BorderLayout . NORTH , toolBar ) ; createTOC ( ) ; toc = new TOCTree ( tocModel ) ; toc . putClientProperty ( "JTree.lineStyle" , "Angled" ) ; toc . setCellRenderer ( new TOCCellRenderer ( ) ) ; toc . setEditable ( false ) ; toc . setRootVisible ( false ) ; toc . setShowsRootHandles ( true ) ; viewer = new JEditorPane ( ) ; viewer . setEditable ( false ) ; viewer . addHyperlinkListener ( new LinkHandler ( ) ) ; viewer . setFont ( new Font ( "Monospaced" , Font . PLAIN , 12 ) ) ; JSplitPane splitter = new JSplitPane ( JSplitPane . HORIZONTAL_SPLIT , new JScrollPane ( toc ) , new JScrollPane ( viewer ) ) ; splitter . setBorder ( null ) ; getContentPane ( ) . add ( BorderLayout . CENTER , splitter ) ; gotoURL ( url , true ) ; setDefaultCloseOperation ( DISPOSE_ON_CLOSE ) ; setSize ( 800 , 400 ) ; GUIUtilities . loadGeometry ( this , "helpviewer" ) ; EditBus . addToBus ( this ) ; show ( ) ; } public void gotoURL ( String url , boolean addToHistory ) { viewer . setCursor ( Cursor . getDefaultCursor ( ) ) ; int index = url . indexOf ( '#' ) ; URL _url = null ; try { _url = new URL ( url ) ; urlField . setText ( _url . toString ( ) ) ; viewer . setPage ( _url ) ; if ( addToHistory ) { history [ historyPos ] = url ; if ( historyPos + 1 == history . length ) { System . arraycopy ( history , 1 , history , 0 , history . length - 1 ) ; history [ historyPos ] = null ; } else historyPos ++ ; } } catch ( MalformedURLException mf ) { Log . log ( Log . ERROR , this , mf ) ; String [ ] args = { url , mf . getMessage ( ) } ; GUIUtilities . error ( this , "badurl" , args ) ; return ; } catch ( IOException io ) { Log . log ( Log . ERROR , this , io ) ; String [ ] args = { url , io . toString ( ) } ; GUIUtilities . error ( this , "read-error" , args ) ; return ; } index = url . lastIndexOf ( "/doc/" ) ; if ( index != - 1 ) url = url . substring ( index + 5 ) ; DefaultMutableTreeNode node = ( DefaultMutableTreeNode ) nodes . get ( url ) ; if ( node == null ) return ; TreePath path = new TreePath ( tocModel . getPathToRoot ( node ) ) ; toc . expandPath ( path ) ; toc . setSelectionPath ( path ) ; toc . scrollPathToVisible ( path ) ; } public void dispose ( ) { EditBus . removeFromBus ( this ) ; GUIUtilities . saveGeometry ( this , "helpviewer" ) ; super . dispose ( ) ; } public void handleMessage ( EBMessage msg ) { if ( msg instanceof PropertiesChanged ) SwingUtilities . updateComponentTreeUI ( getRootPane ( ) ) ; } private JButton back ; private JButton forward ; private DefaultTreeModel tocModel ; private JTree toc ; private Hashtable nodes ; private JEditorPane viewer ; private JTextField urlField ; private String [ ] history ; private int historyPos ; private void createTOC ( ) { DefaultMutableTreeNode root = new DefaultMutableTreeNode ( ) ; root . add ( createNode ( "welcome.html" , jEdit . getProperty ( "helpviewer.toc.welcome" ) ) ) ; root . add ( createNode ( "jeditresource:/doc/README.txt" , jEdit . getProperty ( "helpviewer.toc.readme" ) ) ) ; root . add ( createNode ( "jeditresource:/doc/NEWS.txt" , jEdit . getProperty ( "helpviewer.toc.news" ) ) ) ; root . add ( createNode ( "jeditresource:/doc/TODO.txt" , jEdit . getProperty ( "helpviewer.toc.todo" ) ) ) ; root . add ( createNode ( "jeditresource:/doc/CHANGES.txt" , jEdit . getProperty ( "helpviewer.toc.changes" ) ) ) ; root . add ( createNode ( "jeditresource:/doc/COPYING.txt" , jEdit . getProperty ( "helpviewer.toc.copying" ) ) ) ; root . add ( createNode ( "jeditresource:/doc/COPYING.DOC.txt" , jEdit . getProperty ( "helpviewer.toc.copying-doc" ) ) ) ; loadUserGuideTOC ( root ) ; DefaultMutableTreeNode pluginDocs = new DefaultMutableTreeNode ( jEdit . getProperty ( "helpviewer.toc.plugins" ) , true ) ; EditPlugin [ ] plugins = jEdit . getPlugins ( ) ; for ( int i = 0 ; i < plugins . length ; i ++ ) { EditPlugin plugin = plugins [ i ] ; EditPlugin . JAR jar = plugin . getJAR ( ) ; if ( jar == null ) continue ; String name = plugin . getClassName ( ) ; String docs = jEdit . getProperty ( "plugin." + name + ".docs" ) ; String label = jEdit . getProperty ( "plugin." + name + ".name" ) ; if ( docs != null ) { if ( label != null && docs != null ) { URL url = jar . getClassLoader ( ) . getResource ( docs ) ; if ( url != null ) { pluginDocs . add ( createNode ( url . toString ( ) , label ) ) ; } } } } root . add ( pluginDocs ) ; tocModel = new DefaultTreeModel ( root ) ; } private void loadUserGuideTOC ( DefaultMutableTreeNode root ) { URL resource = getClass ( ) . getResource ( "/doc/users-guide/toc.xml" ) ; if ( resource == null ) return ; TOCHandler h = new TOCHandler ( root ) ; XmlParser parser = new XmlParser ( ) ; parser . setHandler ( h ) ; try { parser . parse ( null , null , new InputStreamReader ( resource . openStream ( ) ) ) ; } catch ( XmlException xe ) { int line = xe . getLine ( ) ; String message = xe . getMessage ( ) ; Log . log ( Log . ERROR , this , "toc.xml:" + line + ": " + message ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , this , e ) ; } } private DefaultMutableTreeNode createNode ( String href , String title ) { DefaultMutableTreeNode node = new DefaultMutableTreeNode ( new HelpNode ( href , title ) , true ) ; nodes . put ( href , node ) ; return node ; } static class HelpNode { String href , title ; HelpNode ( String href , String title ) { this . href = href ; this . title = title ; } public String toString ( ) { return title ; } } class TOCHandler extends HandlerBase { TOCHandler ( DefaultMutableTreeNode root ) { nodes = new Stack ( ) ; node = root ; } public void attribute ( String aname , String value , boolean isSpecified ) { if ( aname . equals ( "HREF" ) ) href = value ; } public void charData ( char [ ] c , int off , int len ) { if ( tag . equals ( "TITLE" ) ) title = new String ( c , off , len ) ; } public void startElement ( String name ) { tag = name ; } public void endElement ( String name ) { if ( name == null ) return ; if ( name . equals ( "TITLE" ) ) { DefaultMutableTreeNode newNode = createNode ( "users-guide/" + href , title ) ; node . add ( newNode ) ; nodes . push ( node ) ; node = newNode ; } else if ( name . equals ( "ENTRY" ) ) node = ( DefaultMutableTreeNode ) nodes . pop ( ) ; } private String tag ; private String title ; private String href ; private DefaultMutableTreeNode node ; private Stack nodes ; } class TOCTree extends JTree { TOCTree ( TreeModel model ) { super ( model ) ; ToolTipManager . sharedInstance ( ) . registerComponent ( this ) ; } public final String getToolTipText ( MouseEvent evt ) { TreePath path = getPathForLocation ( evt . getX ( ) , evt . getY ( ) ) ; if ( path != null ) { Rectangle cellRect = getPathBounds ( path ) ; if ( cellRect != null && ! cellRectIsVisible ( cellRect ) ) return path . getLastPathComponent ( ) . toString ( ) ; } return null ; } public final Point getToolTipLocation ( MouseEvent evt ) { TreePath path = getPathForLocation ( evt . getX ( ) , evt . getY ( ) ) ; if ( path != null ) { Rectangle cellRect = getPathBounds ( path ) ; if ( cellRect != null && ! cellRectIsVisible ( cellRect ) ) { return new Point ( cellRect . x , cellRect . y - 1 ) ; } } return null ; } protected void processMouseEvent ( MouseEvent evt ) { ToolTipManager ttm = ToolTipManager . sharedInstance ( ) ; switch ( evt . getID ( ) ) { case MouseEvent . MOUSE_ENTERED : toolTipInitialDelay = ttm . getInitialDelay ( ) ; toolTipReshowDelay = ttm . getReshowDelay ( ) ; ttm . setInitialDelay ( 200 ) ; ttm . setReshowDelay ( 0 ) ; super . processMouseEvent ( evt ) ; break ; case MouseEvent . MOUSE_EXITED : ttm . setInitialDelay ( toolTipInitialDelay ) ; ttm . setReshowDelay ( toolTipReshowDelay ) ; super . processMouseEvent ( evt ) ; break ; case MouseEvent . MOUSE_CLICKED : TreePath path = getPathForLocation ( evt . getX ( ) , evt . getY ( ) ) ; if ( path != null ) { if ( ! isPathSelected ( path ) ) setSelectionPath ( path ) ; Object obj = ( ( DefaultMutableTreeNode ) path . getLastPathComponent ( ) ) . getUserObject ( ) ; if ( ! ( obj instanceof HelpNode ) ) { toc . expandPath ( path ) ; return ; } HelpNode node = ( HelpNode ) obj ; gotoURL ( node . href , true ) ; } super . processMouseEvent ( evt ) ; break ; default : super . processMouseEvent ( evt ) ; break ; } } private int toolTipInitialDelay = - 1 ; private int toolTipReshowDelay = - 1 ; private boolean cellRectIsVisible ( Rectangle cellRect ) { Rectangle vr = TOCTree . this . getVisibleRect ( ) ; return vr . contains ( cellRect . x , cellRect . y ) && vr . contains ( cellRect . x + cellRect . width , cellRect . y + cellRect . height ) ; } } class TOCCellRenderer extends DefaultTreeCellRenderer { EmptyBorder border = new EmptyBorder ( 1 , 0 , 1 , 1 ) ; public Component getTreeCellRendererComponent ( JTree tree , Object value , boolean sel , boolean expanded , boolean leaf , int row , boolean focus ) { super . getTreeCellRendererComponent ( tree , value , sel , expanded , leaf , row , focus ) ; setIcon ( null ) ; setBorder ( border ) ; return this ; } } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == back ) { if ( historyPos <= 1 ) getToolkit ( ) . beep ( ) ; else { String url = history [ -- historyPos - 1 ] ; gotoURL ( url , false ) ; } } else if ( source == forward ) { if ( history . length - historyPos <= 1 ) getToolkit ( ) . beep ( ) ; else { String url = history [ historyPos ] ; if ( url == null ) getToolkit ( ) . beep ( ) ; else { historyPos ++ ; gotoURL ( url , false ) ; } } } } } class LinkHandler implements HyperlinkListener { public void hyperlinkUpdate ( HyperlinkEvent evt ) { if ( evt . getEventType ( ) == HyperlinkEvent . EventType . ACTIVATED ) { if ( evt instanceof HTMLFrameHyperlinkEvent ) { ( ( HTMLDocument ) viewer . getDocument ( ) ) . processHTMLFrameHyperlinkEvent ( ( HTMLFrameHyperlinkEvent ) evt ) ; } else { URL url = evt . getURL ( ) ; if ( url != null ) gotoURL ( url . toString ( ) , true ) ; } } else if ( evt . getEventType ( ) == HyperlinkEvent . EventType . ENTERED ) { viewer . setCursor ( Cursor . getPredefinedCursor ( Cursor . HAND_CURSOR ) ) ; } else if ( evt . getEventType ( ) == HyperlinkEvent . EventType . EXITED ) { viewer . setCursor ( Cursor . getDefaultCursor ( ) ) ; } } } class KeyHandler extends KeyAdapter { public void keyPressed ( KeyEvent evt ) { if ( evt . getKeyCode ( ) == KeyEvent . VK_ENTER ) { gotoURL ( urlField . getText ( ) , true ) ; } } } } 	1	['18', '6', '0', '21', '124', '117', '7', '20', '6', '0.77124183', '762', '1', '0', '0.975794251', '0.1875', '3', '6', '40.83333333', '7', '1.5556', '5']
package gnu . regexp ; import java . util . Vector ; final class RETokenOneOf extends REToken { private Vector options ; private boolean negative ; RETokenOneOf ( int subIndex , String optionsStr , boolean negative , boolean insens ) { super ( subIndex ) ; options = new Vector ( ) ; this . negative = negative ; for ( int i = 0 ; i < optionsStr . length ( ) ; i ++ ) options . addElement ( new RETokenChar ( subIndex , optionsStr . charAt ( i ) , insens ) ) ; } RETokenOneOf ( int subIndex , Vector options , boolean negative ) { super ( subIndex ) ; this . options = options ; this . negative = negative ; } int getMinimumLength ( ) { int min = Integer . MAX_VALUE ; int x ; for ( int i = 0 ; i < options . size ( ) ; i ++ ) { if ( ( x = ( ( REToken ) options . elementAt ( i ) ) . getMinimumLength ( ) ) < min ) min = x ; } return min ; } boolean match ( CharIndexed input , REMatch mymatch ) { if ( negative && ( input . charAt ( mymatch . index ) == CharIndexed . OUT_OF_BOUNDS ) ) return false ; REMatch newMatch = null ; REMatch last = null ; REToken tk ; boolean isMatch ; for ( int i = 0 ; i < options . size ( ) ; i ++ ) { tk = ( REToken ) options . elementAt ( i ) ; REMatch tryMatch = ( REMatch ) mymatch . clone ( ) ; if ( tk . match ( input , tryMatch ) ) { if ( negative ) return false ; if ( next ( input , tryMatch ) ) { if ( last == null ) { newMatch = tryMatch ; last = tryMatch ; } else { last . next = tryMatch ; last = tryMatch ; } } } } if ( newMatch != null ) { if ( negative ) { return false ; } else { mymatch . assignFrom ( newMatch ) ; return true ; } } else { if ( negative ) { ++ mymatch . index ; return next ( input , mymatch ) ; } else { return false ; } } } void dump ( StringBuffer os ) { os . append ( negative ? "[^" : "(?:" ) ; for ( int i = 0 ; i < options . size ( ) ; i ++ ) { if ( ! negative && ( i > 0 ) ) os . append ( '|' ) ; ( ( REToken ) options . elementAt ( i ) ) . dumpAll ( os ) ; } os . append ( negative ? ']' : ')' ) ; } } 	0	['5', '2', '0', '5', '22', '0', '1', '4', '0', '0.125', '206', '1', '0', '0.7', '0.35', '1', '3', '39.8', '11', '4', '0']
package org . gjt . sp . jedit . options ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . * ; public class EditingOptionPane extends AbstractOptionPane { public EditingOptionPane ( ) { super ( "editing" ) ; } protected void _init ( ) { Mode [ ] modes = jEdit . getModes ( ) ; String defaultModeString = jEdit . getProperty ( "buffer.defaultMode" ) ; String [ ] modeNames = new String [ modes . length ] ; int index = 0 ; for ( int i = 0 ; i < modes . length ; i ++ ) { Mode _mode = modes [ i ] ; modeNames [ i ] = _mode . getName ( ) ; if ( defaultModeString . equals ( _mode . getName ( ) ) ) index = i ; } defaultMode = new JComboBox ( modeNames ) ; defaultMode . setSelectedIndex ( index ) ; addComponent ( jEdit . getProperty ( "options.editing.defaultMode" ) , defaultMode ) ; String [ ] tabSizes = { "2" , "4" , "8" } ; defaultTabSize = new JComboBox ( tabSizes ) ; defaultTabSize . setEditable ( true ) ; defaultTabSize . setSelectedItem ( jEdit . getProperty ( "buffer.tabSize" ) ) ; addComponent ( jEdit . getProperty ( "options.editing.tabSize" ) , defaultTabSize ) ; defaultIndentSize = new JComboBox ( tabSizes ) ; defaultIndentSize . setEditable ( true ) ; defaultIndentSize . setSelectedItem ( jEdit . getProperty ( "buffer.indentSize" ) ) ; addComponent ( jEdit . getProperty ( "options.editing.indentSize" ) , defaultIndentSize ) ; String [ ] lineLens = { "0" , "72" , "76" , "80" } ; defaultMaxLineLen = new JComboBox ( lineLens ) ; defaultMaxLineLen . setEditable ( true ) ; defaultMaxLineLen . setSelectedItem ( jEdit . getProperty ( "buffer.maxLineLen" ) ) ; addComponent ( jEdit . getProperty ( "options.editing.maxLineLen" ) , defaultMaxLineLen ) ; defaultWordBreakChars = new JTextField ( jEdit . getProperty ( "buffer.wordBreakChars" ) ) ; addComponent ( jEdit . getProperty ( "options.editing.wordBreakChars" ) , defaultWordBreakChars ) ; defaultCollapseFolds = new JTextField ( jEdit . getProperty ( "buffer.collapseFolds" ) ) ; addComponent ( jEdit . getProperty ( "options.editing.collapseFolds" ) , defaultCollapseFolds ) ; undoCount = new JTextField ( jEdit . getProperty ( "buffer.undoCount" ) ) ; addComponent ( jEdit . getProperty ( "options.editing.undoCount" ) , undoCount ) ; defaultSyntax = new JCheckBox ( jEdit . getProperty ( "options.editing" + ".syntax" ) ) ; defaultSyntax . setSelected ( jEdit . getBooleanProperty ( "buffer.syntax" ) ) ; addComponent ( defaultSyntax ) ; defaultIndentOnTab = new JCheckBox ( jEdit . getProperty ( "options.editing" + ".indentOnTab" ) ) ; defaultIndentOnTab . setSelected ( jEdit . getBooleanProperty ( "buffer.indentOnTab" ) ) ; addComponent ( defaultIndentOnTab ) ; defaultIndentOnEnter = new JCheckBox ( jEdit . getProperty ( "options.editing" + ".indentOnEnter" ) ) ; defaultIndentOnEnter . setSelected ( jEdit . getBooleanProperty ( "buffer.indentOnEnter" ) ) ; addComponent ( defaultIndentOnEnter ) ; defaultNoTabs = new JCheckBox ( jEdit . getProperty ( "options.editing" + ".noTabs" ) ) ; defaultNoTabs . setSelected ( jEdit . getBooleanProperty ( "buffer.noTabs" ) ) ; addComponent ( defaultNoTabs ) ; } protected void _save ( ) { jEdit . setProperty ( "buffer.defaultMode" , ( String ) defaultMode . getSelectedItem ( ) ) ; jEdit . setProperty ( "buffer.tabSize" , ( String ) defaultTabSize . getSelectedItem ( ) ) ; jEdit . setProperty ( "buffer.indentSize" , ( String ) defaultIndentSize . getSelectedItem ( ) ) ; jEdit . setProperty ( "buffer.maxLineLen" , ( String ) defaultMaxLineLen . getSelectedItem ( ) ) ; jEdit . setProperty ( "buffer.wordBreakChars" , defaultWordBreakChars . getText ( ) ) ; jEdit . setProperty ( "buffer.collapseFolds" , defaultCollapseFolds . getText ( ) ) ; jEdit . setProperty ( "buffer.undoCount" , undoCount . getText ( ) ) ; jEdit . setBooleanProperty ( "buffer.syntax" , defaultSyntax . isSelected ( ) ) ; jEdit . setBooleanProperty ( "buffer.indentOnTab" , defaultIndentOnTab . isSelected ( ) ) ; jEdit . setBooleanProperty ( "buffer.indentOnEnter" , defaultIndentOnEnter . isSelected ( ) ) ; jEdit . setBooleanProperty ( "buffer.noTabs" , defaultNoTabs . isSelected ( ) ) ; } private JComboBox defaultMode ; private JComboBox defaultTabSize ; private JComboBox defaultIndentSize ; private JComboBox defaultMaxLineLen ; private JTextField defaultWordBreakChars ; private JTextField defaultCollapseFolds ; private JTextField undoCount ; private JCheckBox defaultSyntax ; private JCheckBox defaultIndentOnTab ; private JCheckBox defaultIndentOnEnter ; private JCheckBox defaultNoTabs ; } 	1	['3', '6', '0', '4', '23', '1', '1', '3', '1', '0.5', '330', '1', '0', '0.996987952', '1', '2', '4', '105.3333333', '3', '1.3333', '3']
package bsh ; import java . lang . reflect . Array ; class BSHArrayDimensions extends SimpleNode { public Class baseType ; private int arrayDims ; public int [ ] dimensions ; BSHArrayDimensions ( int id ) { super ( id ) ; } public void addArrayDimension ( ) { arrayDims ++ ; } public Object eval ( Class type , CallStack callstack , Interpreter interpreter ) throws EvalError { Interpreter . debug ( "array base type = " + type ) ; baseType = type ; return eval ( callstack , interpreter ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { SimpleNode child = ( SimpleNode ) jjtGetChild ( 0 ) ; if ( child instanceof BSHArrayInitializer ) { if ( baseType == null ) throw new EvalError ( "Internal Array Eval err:  unknown base type" , this ) ; Object initValue = ( ( BSHArrayInitializer ) child ) . eval ( baseType , arrayDims , callstack , interpreter ) ; Class arrayClass = initValue . getClass ( ) ; dimensions = new int [ Reflect . getArrayDimensions ( arrayClass ) ] ; if ( dimensions . length != arrayDims ) throw new EvalError ( "Incompatible initializer. Allocation calls for a " + arrayDims + " dimensional array, but initializer is a " + dimensions . length + " dimensional array" , this ) ; Object arraySlice = initValue ; for ( int i = 0 ; i < dimensions . length ; i ++ ) { dimensions [ i ] = Array . getLength ( arraySlice ) ; if ( dimensions [ i ] > 0 ) arraySlice = Array . get ( arraySlice , 0 ) ; } return initValue ; } else { dimensions = new int [ jjtGetNumChildren ( ) ] ; for ( int i = 0 ; i < dimensions . length ; i ++ ) { try { Object length = ( ( SimpleNode ) jjtGetChild ( i ) ) . eval ( callstack , interpreter ) ; dimensions [ i ] = ( ( Primitive ) length ) . intValue ( ) ; } catch ( Exception e ) { throw new EvalError ( "Array index: " + i + " does not evaluate to an integer" , this ) ; } } } return Primitive . VOID ; } } 	0	['4', '2', '0', '10', '21', '2', '2', '8', '3', '0.555555556', '174', '0.333333333', '0', '0.857142857', '0.5', '1', '1', '41.75', '1', '0.75', '0']
package org . gjt . sp . jedit . textarea ; import javax . swing . border . * ; import javax . swing . event . * ; import javax . swing . plaf . metal . MetalLookAndFeel ; import javax . swing . text . BadLocationException ; import javax . swing . text . Element ; import javax . swing . text . Segment ; import javax . swing . text . Utilities ; import javax . swing . undo . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . syntax . * ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class JEditTextArea extends JComponent { public JEditTextArea ( View view ) { enableEvents ( AWTEvent . FOCUS_EVENT_MASK | AWTEvent . KEY_EVENT_MASK ) ; this . view = view ; selection = new Vector ( ) ; renderer = TextRenderer . createTextRenderer ( ) ; painter = new TextAreaPainter ( this ) ; gutter = new Gutter ( view , this ) ; documentHandler = new DocumentHandler ( ) ; foldHandler = new FoldHandler ( ) ; listenerList = new EventListenerList ( ) ; caretEvent = new MutableCaretEvent ( ) ; bracketLine = bracketPosition = - 1 ; blink = true ; lineSegment = new Segment ( ) ; setLayout ( new ScrollLayout ( ) ) ; add ( LEFT , gutter ) ; add ( CENTER , painter ) ; add ( RIGHT , vertical = new JScrollBar ( JScrollBar . VERTICAL ) ) ; add ( BOTTOM , horizontal = new JScrollBar ( JScrollBar . HORIZONTAL ) ) ; horizontal . setValues ( 0 , 0 , 0 , 0 ) ; if ( UIManager . getLookAndFeel ( ) instanceof MetalLookAndFeel ) { setBorder ( new TextAreaBorder ( ) ) ; vertical . putClientProperty ( "JScrollBar.isFreeStanding" , Boolean . FALSE ) ; horizontal . putClientProperty ( "JScrollBar.isFreeStanding" , Boolean . FALSE ) ; } vertical . addAdjustmentListener ( new AdjustHandler ( ) ) ; horizontal . addAdjustmentListener ( new AdjustHandler ( ) ) ; painter . addComponentListener ( new ComponentHandler ( ) ) ; mouseHandler = new MouseHandler ( ) ; painter . addMouseListener ( mouseHandler ) ; painter . addMouseMotionListener ( mouseHandler ) ; addFocusListener ( new FocusHandler ( ) ) ; focusedComponent = this ; } public final TextAreaPainter getPainter ( ) { return painter ; } public final Gutter getGutter ( ) { return gutter ; } public final boolean isCaretBlinkEnabled ( ) { return caretBlinks ; } public void setCaretBlinkEnabled ( boolean caretBlinks ) { this . caretBlinks = caretBlinks ; if ( ! caretBlinks ) blink = false ; if ( buffer != null ) invalidateLine ( caretLine ) ; } public final void blinkCaret ( ) { if ( caretBlinks ) { blink = ! blink ; invalidateLine ( caretLine ) ; } else blink = true ; } public final int getElectricScroll ( ) { return electricScroll ; } public final void setElectricScroll ( int electricScroll ) { this . electricScroll = electricScroll ; } public final boolean isMiddleMousePasteEnabled ( ) { return middleMousePaste ; } public final void setMiddleMousePasteEnabled ( boolean middleMousePaste ) { this . middleMousePaste = middleMousePaste ; } public void updateScrollBars ( ) { if ( vertical != null && visibleLines != 0 ) { int lineCount = getVirtualLineCount ( ) ; if ( lineCount < firstLine + visibleLines ) { int newFirstLine = Math . max ( 0 , lineCount - visibleLines ) ; if ( newFirstLine != firstLine ) { setFirstLine ( newFirstLine ) ; return ; } } vertical . setValues ( firstLine , visibleLines , 0 , lineCount ) ; vertical . setUnitIncrement ( 2 ) ; vertical . setBlockIncrement ( visibleLines ) ; } int width = painter . getWidth ( ) ; if ( horizontal != null && width != 0 ) { maxHorizontalScrollWidth = 0 ; painter . repaint ( ) ; horizontal . setUnitIncrement ( painter . getFontMetrics ( ) . charWidth ( 'w' ) ) ; horizontal . setBlockIncrement ( width / 2 ) ; } } public final int getFirstLine ( ) { return firstLine ; } public void setFirstLine ( int firstLine ) { if ( firstLine == this . firstLine ) return ; _setFirstLine ( firstLine ) ; view . synchroScrollVertical ( this , firstLine ) ; } public void _setFirstLine ( int firstLine ) { this . firstLine = Math . max ( 0 , firstLine ) ; physFirstLine = buffer . virtualToPhysical ( this . firstLine ) ; maxHorizontalScrollWidth = 0 ; if ( this . firstLine != vertical . getValue ( ) ) updateScrollBars ( ) ; painter . repaint ( ) ; gutter . repaint ( ) ; fireScrollEvent ( true ) ; } public final int getVisibleLines ( ) { return visibleLines ; } public final int getHorizontalOffset ( ) { return horizontalOffset ; } public void setHorizontalOffset ( int horizontalOffset ) { if ( horizontalOffset == this . horizontalOffset ) return ; _setHorizontalOffset ( horizontalOffset ) ; view . synchroScrollHorizontal ( this , horizontalOffset ) ; } public void _setHorizontalOffset ( int horizontalOffset ) { this . horizontalOffset = horizontalOffset ; if ( horizontalOffset != horizontal . getValue ( ) ) updateScrollBars ( ) ; painter . repaint ( ) ; fireScrollEvent ( false ) ; } public boolean setOrigin ( int firstLine , int horizontalOffset ) { setFirstLine ( firstLine ) ; setHorizontalOffset ( horizontalOffset ) ; return true ; } public void centerCaret ( ) { Element map = buffer . getDefaultRootElement ( ) ; int gotoLine = buffer . virtualToPhysical ( firstLine + visibleLines / 2 ) ; if ( gotoLine < 0 || gotoLine >= map . getElementCount ( ) ) { getToolkit ( ) . beep ( ) ; return ; } Element element = map . getElement ( gotoLine ) ; setCaretPosition ( element . getStartOffset ( ) ) ; } public void scrollUpLine ( ) { if ( firstLine > 0 ) setFirstLine ( firstLine - 1 ) ; else getToolkit ( ) . beep ( ) ; } public void scrollUpPage ( ) { if ( firstLine > 0 ) { int newFirstLine = firstLine - visibleLines ; setFirstLine ( newFirstLine ) ; } else { getToolkit ( ) . beep ( ) ; } } public void scrollDownLine ( ) { int numLines = getVirtualLineCount ( ) ; if ( firstLine + visibleLines < numLines ) setFirstLine ( firstLine + 1 ) ; else getToolkit ( ) . beep ( ) ; } public void scrollDownPage ( ) { int numLines = getVirtualLineCount ( ) ; if ( firstLine + visibleLines < numLines ) { int newFirstLine = firstLine + visibleLines ; setFirstLine ( newFirstLine + visibleLines < numLines ? newFirstLine : numLines - visibleLines ) ; } else { getToolkit ( ) . beep ( ) ; } } public void scrollToCaret ( boolean doElectricScroll ) { if ( ! buffer . isLineVisible ( caretLine ) ) buffer . expandFoldAt ( caretLine , true , this ) ; int offset = caret - getLineStartOffset ( caretLine ) ; int virtualCaretLine = buffer . physicalToVirtual ( caretLine ) ; if ( visibleLines == 0 ) { setFirstLine ( caretLine - electricScroll ) ; return ; } int electricScroll ; if ( doElectricScroll && visibleLines > this . electricScroll * 2 ) electricScroll = this . electricScroll ; else electricScroll = 0 ; boolean changed = false ; int _firstLine = firstLine + electricScroll ; int _lastLine = firstLine + visibleLines - electricScroll ; if ( virtualCaretLine > _firstLine && virtualCaretLine < _lastLine ) { } else if ( _firstLine - virtualCaretLine > visibleLines || virtualCaretLine - _lastLine > visibleLines ) { int startLine , endLine ; Selection s = getSelectionAtOffset ( caret ) ; if ( s == null ) { startLine = endLine = virtualCaretLine ; } else { startLine = buffer . physicalToVirtual ( s . startLine ) ; endLine = buffer . physicalToVirtual ( s . endLine ) ; } if ( endLine - startLine <= visibleLines ) firstLine = ( startLine + endLine - visibleLines ) / 2 ; else firstLine = buffer . physicalToVirtual ( caretLine ) - visibleLines / 2 ; firstLine = Math . min ( firstLine , buffer . getVirtualLineCount ( ) - visibleLines ) ; firstLine = Math . max ( firstLine , 0 ) ; changed = true ; } else if ( virtualCaretLine < _firstLine ) { firstLine = Math . max ( 0 , virtualCaretLine - electricScroll ) ; changed = true ; } else if ( virtualCaretLine >= _lastLine ) { firstLine = ( virtualCaretLine - visibleLines ) + electricScroll + 1 ; if ( firstLine >= getVirtualLineCount ( ) - visibleLines ) firstLine = getVirtualLineCount ( ) - visibleLines ; changed = true ; } int x = offsetToX ( caretLine , offset ) ; int width = painter . getFontMetrics ( ) . charWidth ( 'w' ) ; if ( x < 0 ) { horizontalOffset = Math . min ( 0 , horizontalOffset - x + width + 5 ) ; changed = true ; } else if ( x >= painter . getWidth ( ) - width - 5 ) { horizontalOffset = horizontalOffset + ( painter . getWidth ( ) - x ) - width - 5 ; changed = true ; } if ( changed ) { if ( firstLine < 0 ) firstLine = 0 ; physFirstLine = buffer . virtualToPhysical ( firstLine ) ; updateScrollBars ( ) ; painter . repaint ( ) ; gutter . repaint ( ) ; view . synchroScrollVertical ( this , firstLine ) ; view . synchroScrollHorizontal ( this , horizontalOffset ) ; fireScrollEvent ( true ) ; fireScrollEvent ( false ) ; } } public int lineToY ( int line ) { FontMetrics fm = painter . getFontMetrics ( ) ; return ( line - firstLine ) * fm . getHeight ( ) - ( fm . getLeading ( ) + fm . getDescent ( ) ) ; } public int yToLine ( int y ) { FontMetrics fm = painter . getFontMetrics ( ) ; int height = fm . getHeight ( ) ; return Math . max ( 0 , Math . min ( getVirtualLineCount ( ) - 1 , y / height + firstLine ) ) ; } public TextRenderer getTextRenderer ( ) { return renderer ; } public int offsetToX ( int line , int offset ) { Token tokens = buffer . markTokens ( line ) . getFirstToken ( ) ; getLineText ( line , lineSegment ) ; char [ ] text = lineSegment . array ; int off = lineSegment . offset ; float x = ( float ) horizontalOffset ; Toolkit toolkit = painter . getToolkit ( ) ; Font defaultFont = painter . getFont ( ) ; SyntaxStyle [ ] styles = painter . getStyles ( ) ; for ( ; ; ) { byte id = tokens . id ; if ( id == Token . END ) return ( int ) x ; Font font ; if ( id == Token . NULL ) font = defaultFont ; else font = styles [ id ] . getFont ( ) ; int len = tokens . length ; if ( offset < len ) { return ( int ) ( x + renderer . charsWidth ( text , off , offset , font , x , painter ) ) ; } else { x += renderer . charsWidth ( text , off , len , font , x , painter ) ; off += len ; offset -= len ; } tokens = tokens . next ; } } public int xToOffset ( int line , int x ) { return xToOffset ( line , x , true ) ; } public int xToOffset ( int line , int x , boolean round ) { Token tokens = buffer . markTokens ( line ) . getFirstToken ( ) ; getLineText ( line , lineSegment ) ; char [ ] text = lineSegment . array ; int off = lineSegment . offset ; Toolkit toolkit = painter . getToolkit ( ) ; Font defaultFont = painter . getFont ( ) ; SyntaxStyle [ ] styles = painter . getStyles ( ) ; float [ ] widthArray = new float [ ] { horizontalOffset } ; for ( ; ; ) { byte id = tokens . id ; if ( id == Token . END ) return lineSegment . count ; Font font ; if ( id == Token . NULL ) font = defaultFont ; else font = styles [ id ] . getFont ( ) ; int len = tokens . length ; int offset = renderer . xToOffset ( text , off , len , font , x , painter , round , widthArray ) ; if ( offset != - 1 ) return offset - lineSegment . offset ; off += len ; tokens = tokens . next ; } } public int xyToOffset ( int x , int y ) { return xyToOffset ( x , y , true ) ; } public int xyToOffset ( int x , int y , boolean round ) { FontMetrics fm = painter . getFontMetrics ( ) ; int height = fm . getHeight ( ) ; int line = y / height + firstLine ; if ( line < 0 ) return 0 ; else if ( line >= getVirtualLineCount ( ) ) { return getLineEndOffset ( buffer . virtualToPhysical ( buffer . getVirtualLineCount ( ) - 1 ) ) - 1 ; } else { line = buffer . virtualToPhysical ( line ) ; return getLineStartOffset ( line ) + xToOffset ( line , x ) ; } } public final void invalidateLine ( int line ) { line = buffer . physicalToVirtual ( line ) ; FontMetrics fm = painter . getFontMetrics ( ) ; int y = lineToY ( line ) + fm . getDescent ( ) + fm . getLeading ( ) ; painter . repaint ( 0 , y , painter . getWidth ( ) , fm . getHeight ( ) ) ; gutter . repaint ( 0 , y , gutter . getWidth ( ) , fm . getHeight ( ) ) ; } public final void invalidateLineRange ( int firstLine , int lastLine ) { firstLine = buffer . physicalToVirtual ( firstLine ) ; if ( lastLine > buffer . virtualToPhysical ( buffer . getVirtualLineCount ( ) - 1 ) ) { lastLine = ( lastLine - buffer . getLineCount ( ) ) + buffer . getVirtualLineCount ( ) ; } else lastLine = buffer . physicalToVirtual ( lastLine ) ; FontMetrics fm = painter . getFontMetrics ( ) ; int y = lineToY ( firstLine ) + fm . getDescent ( ) + fm . getLeading ( ) ; int height = ( lastLine - firstLine + 1 ) * fm . getHeight ( ) ; painter . repaint ( 0 , y , painter . getWidth ( ) , height ) ; gutter . repaint ( 0 , y , gutter . getWidth ( ) , height ) ; } public final void invalidateSelectedLines ( ) { for ( int i = 0 ; i < selection . size ( ) ; i ++ ) { Selection s = ( Selection ) selection . elementAt ( i ) ; invalidateLineRange ( s . startLine , s . endLine ) ; } } public final Buffer getBuffer ( ) { return buffer ; } public void setBuffer ( Buffer buffer ) { if ( this . buffer == buffer ) return ; if ( this . buffer != null ) { this . buffer . removeDocumentListener ( documentHandler ) ; this . buffer . removeFoldListener ( foldHandler ) ; } this . buffer = buffer ; buffer . addDocumentListener ( documentHandler ) ; buffer . addFoldListener ( foldHandler ) ; documentHandlerInstalled = true ; maxHorizontalScrollWidth = 0 ; painter . updateTabSize ( ) ; setCaretPosition ( 0 ) ; updateScrollBars ( ) ; painter . repaint ( ) ; gutter . repaint ( ) ; } public final int getBufferLength ( ) { return buffer . getLength ( ) ; } public final int getLineCount ( ) { return buffer . getLineCount ( ) ; } public final int getVirtualLineCount ( ) { return buffer . getVirtualLineCount ( ) ; } public final int getLineOfOffset ( int offset ) { return buffer . getDefaultRootElement ( ) . getElementIndex ( offset ) ; } public int getLineStartOffset ( int line ) { Element lineElement = buffer . getDefaultRootElement ( ) . getElement ( line ) ; if ( lineElement == null ) return - 1 ; else return lineElement . getStartOffset ( ) ; } public int getLineEndOffset ( int line ) { Element lineElement = buffer . getDefaultRootElement ( ) . getElement ( line ) ; if ( lineElement == null ) return - 1 ; else return lineElement . getEndOffset ( ) ; } public int getLineLength ( int line ) { Element lineElement = buffer . getDefaultRootElement ( ) . getElement ( line ) ; if ( lineElement == null ) return - 1 ; else return lineElement . getEndOffset ( ) - lineElement . getStartOffset ( ) - 1 ; } public String getText ( ) { try { return buffer . getText ( 0 , buffer . getLength ( ) ) ; } catch ( BadLocationException bl ) { bl . printStackTrace ( ) ; return null ; } } public void setText ( String text ) { try { buffer . beginCompoundEdit ( ) ; buffer . remove ( 0 , buffer . getLength ( ) ) ; buffer . insertString ( 0 , text , null ) ; } catch ( BadLocationException bl ) { bl . printStackTrace ( ) ; } finally { buffer . endCompoundEdit ( ) ; } } public final String getText ( int start , int len ) { try { return buffer . getText ( start , len ) ; } catch ( BadLocationException bl ) { bl . printStackTrace ( ) ; return null ; } } public final void getText ( int start , int len , Segment segment ) { try { buffer . getText ( start , len , segment ) ; } catch ( BadLocationException bl ) { bl . printStackTrace ( ) ; segment . offset = segment . count = 0 ; } } public final String getLineText ( int lineIndex ) { int start = getLineStartOffset ( lineIndex ) ; return getText ( start , getLineEndOffset ( lineIndex ) - start - 1 ) ; } public final void getLineText ( int lineIndex , Segment segment ) { Element lineElement = buffer . getDefaultRootElement ( ) . getElement ( lineIndex ) ; int start = lineElement . getStartOffset ( ) ; getText ( start , lineElement . getEndOffset ( ) - start - 1 , segment ) ; } public final void selectAll ( ) { setSelection ( new Selection . Range ( 0 , buffer . getLength ( ) ) ) ; moveCaretPosition ( buffer . getLength ( ) , true ) ; } public void selectLine ( ) { int caretLine = getCaretLine ( ) ; int start = getLineStartOffset ( caretLine ) ; int end = getLineEndOffset ( caretLine ) - 1 ; setSelection ( new Selection . Range ( start , end ) ) ; moveCaretPosition ( end ) ; } public void selectParagraph ( ) { int caretLine = getCaretLine ( ) ; if ( getLineLength ( caretLine ) == 0 ) { view . getToolkit ( ) . beep ( ) ; return ; } int start = caretLine ; int end = caretLine ; while ( start >= 0 ) { if ( getLineLength ( start ) == 0 ) break ; else start -- ; } while ( end < getLineCount ( ) ) { if ( getLineLength ( end ) == 0 ) break ; else end ++ ; } int selectionStart = getLineStartOffset ( start + 1 ) ; int selectionEnd = getLineEndOffset ( end - 1 ) - 1 ; setSelection ( new Selection . Range ( selectionStart , selectionEnd ) ) ; moveCaretPosition ( selectionEnd ) ; } public void selectWord ( ) { int line = getCaretLine ( ) ; int lineStart = getLineStartOffset ( line ) ; int offset = getCaretPosition ( ) - lineStart ; if ( getLineLength ( line ) == 0 ) return ; String lineText = getLineText ( line ) ; String noWordSep = ( String ) buffer . getProperty ( "noWordSep" ) ; if ( offset == getLineLength ( line ) ) offset -- ; int wordStart = TextUtilities . findWordStart ( lineText , offset , noWordSep ) ; int wordEnd = TextUtilities . findWordEnd ( lineText , offset + 1 , noWordSep ) ; setSelection ( new Selection . Range ( lineStart + wordStart , lineStart + wordEnd ) ) ; moveCaretPosition ( lineStart + wordEnd ) ; } public final int getSelectionStart ( ) { if ( selection . size ( ) != 1 ) return caret ; return ( ( Selection ) selection . elementAt ( 0 ) ) . getStart ( ) ; } public int getSelectionStart ( int line ) { if ( selection . size ( ) != 1 ) return caret ; return ( ( Selection ) selection . elementAt ( 0 ) ) . getStart ( buffer , line ) ; } public final int getSelectionStartLine ( ) { if ( selection . size ( ) != 1 ) return caret ; return ( ( Selection ) selection . elementAt ( 0 ) ) . getStartLine ( ) ; } public final void setSelectionStart ( int selectionStart ) { select ( selectionStart , getSelectionEnd ( ) , true ) ; } public final int getSelectionEnd ( ) { if ( selection . size ( ) != 1 ) return caret ; return ( ( Selection ) selection . elementAt ( 0 ) ) . getEnd ( ) ; } public int getSelectionEnd ( int line ) { if ( selection . size ( ) != 1 ) return caret ; return ( ( Selection ) selection . elementAt ( 0 ) ) . getEnd ( buffer , line ) ; } public final int getSelectionEndLine ( ) { if ( selection . size ( ) != 1 ) return caret ; return ( ( Selection ) selection . elementAt ( 0 ) ) . getEndLine ( ) ; } public final void setSelectionEnd ( int selectionEnd ) { select ( getSelectionStart ( ) , selectionEnd , true ) ; } public final int getMarkPosition ( ) { Selection s = getSelectionAtOffset ( caret ) ; if ( s == null ) return caret ; if ( s . start == caret ) return s . end ; else if ( s . end == caret ) return s . start ; else return caret ; } public final int getMarkLine ( ) { if ( selection . size ( ) != 1 ) return caretLine ; Selection s = ( Selection ) selection . elementAt ( 0 ) ; if ( s . start == caret ) return s . endLine ; else if ( s . end == caret ) return s . startLine ; else return caretLine ; } public void select ( int start , int end ) { select ( start , end , true ) ; } public void select ( int start , int end , boolean doElectricScroll ) { selectNone ( ) ; int newStart , newEnd ; if ( start < end ) { newStart = start ; newEnd = end ; } else { newStart = end ; newEnd = start ; } setSelection ( new Selection . Range ( newStart , newEnd ) ) ; moveCaretPosition ( end , doElectricScroll ) ; } public boolean isSelectionRectangular ( ) { Selection s = getSelectionAtOffset ( caret ) ; if ( s == null ) return false ; else return ( s instanceof Selection . Rect ) ; } public void setCaretPosition ( int newCaret ) { invalidateSelectedLines ( ) ; selection . removeAllElements ( ) ; moveCaretPosition ( newCaret , true ) ; } public void setCaretPosition ( int newCaret , boolean doElectricScroll ) { invalidateSelectedLines ( ) ; selection . removeAllElements ( ) ; moveCaretPosition ( newCaret , doElectricScroll ) ; } public void moveCaretPosition ( int newCaret ) { moveCaretPosition ( newCaret , true ) ; } public void moveCaretPosition ( int newCaret , boolean doElectricScroll ) { if ( newCaret < 0 || newCaret > buffer . getLength ( ) ) { throw new IllegalArgumentException ( "caret out of bounds: " + newCaret ) ; } blink = true ; caretTimer . restart ( ) ; if ( caret == newCaret ) { scrollToCaret ( doElectricScroll ) ; return ; } int newCaretLine = getLineOfOffset ( newCaret ) ; magicCaret = offsetToX ( newCaretLine , newCaret - getLineStartOffset ( newCaretLine ) ) ; invalidateLine ( caretLine ) ; invalidateLine ( newCaretLine ) ; buffer . addUndoableEdit ( new CaretUndo ( caret ) ) ; caret = newCaret ; caretLine = newCaretLine ; if ( focusedComponent == this ) scrollToCaret ( doElectricScroll ) ; updateBracketHighlight ( ) ; fireCaretEvent ( ) ; } public int getCaretPosition ( ) { return caret ; } public int getCaretLine ( ) { return caretLine ; } public int getSelectionCount ( ) { return selection . size ( ) ; } public Selection [ ] getSelection ( ) { Selection [ ] sel = new Selection [ selection . size ( ) ] ; selection . copyInto ( sel ) ; return sel ; } public void selectNone ( ) { setSelection ( ( Selection ) null ) ; } public void setSelection ( Selection [ ] selection ) { invalidateSelectedLines ( ) ; this . selection . removeAllElements ( ) ; if ( selection != null ) { for ( int i = 0 ; i < selection . length ; i ++ ) _addToSelection ( selection [ i ] ) ; } fireCaretEvent ( ) ; } public void setSelection ( Selection selection ) { invalidateSelectedLines ( ) ; this . selection . removeAllElements ( ) ; if ( selection != null ) _addToSelection ( selection ) ; fireCaretEvent ( ) ; } public void addToSelection ( Selection [ ] selection ) { if ( selection != null ) { for ( int i = 0 ; i < selection . length ; i ++ ) _addToSelection ( selection [ i ] ) ; } fireCaretEvent ( ) ; } public void addToSelection ( Selection selection ) { _addToSelection ( selection ) ; fireCaretEvent ( ) ; } public Selection getSelectionAtOffset ( int offset ) { if ( selection != null ) { for ( int i = 0 ; i < selection . size ( ) ; i ++ ) { Selection s = ( Selection ) selection . elementAt ( i ) ; if ( offset >= s . start && offset <= s . end ) return s ; } } return null ; } public void removeFromSelection ( Selection sel ) { selection . removeElement ( sel ) ; invalidateLineRange ( sel . startLine , sel . endLine ) ; fireCaretEvent ( ) ; } public void removeFromSelection ( int offset ) { Selection sel = getSelectionAtOffset ( offset ) ; if ( sel == null ) return ; selection . removeElement ( sel ) ; invalidateLineRange ( sel . startLine , sel . endLine ) ; fireCaretEvent ( ) ; } public void resizeSelection ( int offset , int end , boolean rect ) { Selection s = getSelectionAtOffset ( offset ) ; if ( s != null ) { invalidateLineRange ( s . startLine , s . endLine ) ; selection . removeElement ( s ) ; } if ( end < offset ) { int tmp = offset ; offset = end ; end = tmp ; } Selection newSel ; if ( rect ) newSel = new Selection . Rect ( offset , end ) ; else newSel = new Selection . Range ( offset , end ) ; _addToSelection ( newSel ) ; fireCaretEvent ( ) ; } public void extendSelection ( int offset , int end ) { Selection s = getSelectionAtOffset ( offset ) ; if ( s != null ) { invalidateLineRange ( s . startLine , s . endLine ) ; selection . removeElement ( s ) ; if ( offset == s . start ) { offset = end ; end = s . end ; } else if ( offset == s . end ) { offset = s . start ; } } if ( end < offset ) { int tmp = end ; end = offset ; offset = tmp ; } _addToSelection ( new Selection . Range ( offset , end ) ) ; fireCaretEvent ( ) ; } public String getSelectedText ( Selection s ) { StringBuffer buf = new StringBuffer ( ) ; getSelectedText ( s , buf ) ; return buf . toString ( ) ; } public String getSelectedText ( String separator ) { if ( selection . size ( ) == 0 ) return null ; StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < selection . size ( ) ; i ++ ) { if ( i != 0 ) buf . append ( separator ) ; getSelectedText ( ( Selection ) selection . elementAt ( i ) , buf ) ; } return buf . toString ( ) ; } public String getSelectedText ( ) { return getSelectedText ( "\n" ) ; } public void setSelectedText ( Selection s , String selectedText ) { if ( ! isEditable ( ) ) { throw new InternalError ( "Text component" + " read only" ) ; } try { buffer . beginCompoundEdit ( ) ; if ( s instanceof Selection . Rect ) { Element map = buffer . getDefaultRootElement ( ) ; int start = s . start - map . getElement ( s . startLine ) . getStartOffset ( ) ; int end = s . end - map . getElement ( s . endLine ) . getStartOffset ( ) ; if ( end < start ) { int tmp = end ; end = start ; start = tmp ; } int lastNewline = 0 ; int currNewline = 0 ; for ( int i = s . startLine ; i <= s . endLine ; i ++ ) { Element lineElement = map . getElement ( i ) ; int lineStart = lineElement . getStartOffset ( ) ; int lineEnd = lineElement . getEndOffset ( ) - 1 ; int rectStart = Math . min ( lineEnd , lineStart + start ) ; buffer . remove ( rectStart , Math . min ( lineEnd - rectStart , end - start ) ) ; if ( selectedText == null ) continue ; currNewline = selectedText . indexOf ( '\n' , lastNewline ) ; if ( currNewline == - 1 ) currNewline = selectedText . length ( ) ; buffer . insertString ( rectStart , selectedText . substring ( lastNewline , currNewline ) , null ) ; lastNewline = Math . min ( selectedText . length ( ) , currNewline + 1 ) ; } if ( selectedText != null && currNewline != selectedText . length ( ) ) { int offset = map . getElement ( s . endLine ) . getEndOffset ( ) - 1 ; buffer . insertString ( offset , "\n" , null ) ; buffer . insertString ( offset + 1 , selectedText . substring ( currNewline + 1 ) , null ) ; } } else { buffer . remove ( s . start , s . end - s . start ) ; if ( selectedText != null && selectedText . length ( ) != 0 ) { buffer . insertString ( s . start , selectedText , null ) ; } } } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } finally { buffer . endCompoundEdit ( ) ; } } public void setSelectedText ( String selectedText ) { if ( ! isEditable ( ) ) { throw new InternalError ( "Text component" + " read only" ) ; } Selection [ ] selection = getSelection ( ) ; if ( selection . length == 0 ) { try { buffer . insertString ( caret , selectedText , null ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } } else { try { buffer . beginCompoundEdit ( ) ; for ( int i = 0 ; i < selection . length ; i ++ ) { setSelectedText ( selection [ i ] , selectedText ) ; } } finally { buffer . endCompoundEdit ( ) ; } } selectNone ( ) ; } public int [ ] getSelectedLines ( ) { Integer line ; Hashtable hash = new Hashtable ( ) ; for ( int i = 0 ; i < selection . size ( ) ; i ++ ) { Selection s = ( Selection ) selection . elementAt ( i ) ; for ( int j = s . startLine ; j <= s . endLine ; j ++ ) { line = new Integer ( j ) ; hash . put ( line , line ) ; } } line = new Integer ( caretLine ) ; hash . put ( line , line ) ; int [ ] returnValue = new int [ hash . size ( ) ] ; int i = 0 ; Enumeration keys = hash . keys ( ) ; while ( keys . hasMoreElements ( ) ) { line = ( Integer ) keys . nextElement ( ) ; returnValue [ i ++ ] = line . intValue ( ) ; } quicksort ( returnValue , 0 , returnValue . length - 1 ) ; return returnValue ; } public final boolean isEditable ( ) { return buffer . isEditable ( ) ; } public final JPopupMenu getRightClickPopup ( ) { return popup ; } public final void setRightClickPopup ( JPopupMenu popup ) { this . popup = popup ; } public final int getMagicCaretPosition ( ) { return ( magicCaret == - 1 ? offsetToX ( caretLine , caret - getLineStartOffset ( caretLine ) ) : magicCaret ) ; } public final void setMagicCaretPosition ( int magicCaret ) { this . magicCaret = magicCaret ; } public void userInput ( char ch ) { if ( ! isEditable ( ) ) { getToolkit ( ) . beep ( ) ; return ; } if ( ch == ' ' && Abbrevs . getExpandOnInput ( ) && Abbrevs . expandAbbrev ( view , false ) ) return ; else if ( ch == '\t' ) { if ( buffer . getBooleanProperty ( "indentOnTab" ) && selection . size ( ) == 0 && buffer . indentLine ( caretLine , true , false ) ) return ; else if ( buffer . getBooleanProperty ( "noTabs" ) ) { int lineStart = getLineStartOffset ( caretLine ) ; String line = getText ( lineStart , caret - lineStart ) ; setSelectedText ( createSoftTab ( line , buffer . getTabSize ( ) ) ) ; } else setSelectedText ( "\t" ) ; return ; } else if ( ch == '\n' ) { try { buffer . beginCompoundEdit ( ) ; setSelectedText ( "\n" ) ; if ( buffer . getBooleanProperty ( "indentOnEnter" ) ) buffer . indentLine ( caretLine , true , false ) ; } finally { buffer . endCompoundEdit ( ) ; } return ; } else { String str = String . valueOf ( ch ) ; if ( selection . size ( ) != 0 ) { setSelectedText ( str ) ; return ; } try { if ( ch == ' ' ) { if ( doWordWrap ( caretLine , true ) ) return ; } else doWordWrap ( caretLine , false ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } try { buffer . beginCompoundEdit ( ) ; if ( overwrite ) { int caretLineEnd = getLineEndOffset ( caretLine ) ; if ( caretLineEnd - caret > 1 ) buffer . remove ( caret , 1 ) ; } buffer . insertString ( caret , str , null ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } finally { buffer . endCompoundEdit ( ) ; } } String indentOpenBrackets = ( String ) buffer . getProperty ( "indentOpenBrackets" ) ; String indentCloseBrackets = ( String ) buffer . getProperty ( "indentCloseBrackets" ) ; if ( ( indentCloseBrackets != null && indentCloseBrackets . indexOf ( ch ) != - 1 ) || ( indentOpenBrackets != null && indentOpenBrackets . indexOf ( ch ) != - 1 ) ) { buffer . indentLine ( caretLine , false , true ) ; } } public final boolean isOverwriteEnabled ( ) { return overwrite ; } public final void setOverwriteEnabled ( boolean overwrite ) { this . overwrite = overwrite ; invalidateLine ( caretLine ) ; if ( view . getStatus ( ) != null ) view . getStatus ( ) . updateMiscStatus ( ) ; } public final void toggleOverwriteEnabled ( ) { overwrite = ! overwrite ; invalidateLine ( caretLine ) ; if ( view . getStatus ( ) != null ) view . getStatus ( ) . updateMiscStatus ( ) ; } public final int getBracketPosition ( ) { return bracketPosition ; } public final int getBracketLine ( ) { return bracketLine ; } public final void addCaretListener ( CaretListener listener ) { listenerList . add ( CaretListener . class , listener ) ; } public final void removeCaretListener ( CaretListener listener ) { listenerList . remove ( CaretListener . class , listener ) ; } public final void addScrollListener ( ScrollListener listener ) { listenerList . add ( ScrollListener . class , listener ) ; } public final void removeScrollListener ( ScrollListener listener ) { listenerList . remove ( ScrollListener . class , listener ) ; } public void backspace ( ) { if ( ! buffer . isEditable ( ) ) { getToolkit ( ) . beep ( ) ; return ; } if ( selection . size ( ) != 0 ) setSelectedText ( "" ) ; else { if ( caret == 0 ) { getToolkit ( ) . beep ( ) ; return ; } try { buffer . remove ( caret - 1 , 1 ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } } } public void backspaceWord ( ) { if ( ! buffer . isEditable ( ) ) { getToolkit ( ) . beep ( ) ; return ; } if ( selection . size ( ) != 0 ) { setSelectedText ( "" ) ; return ; } int lineStart = getLineStartOffset ( caretLine ) ; int _caret = caret - lineStart ; String lineText = getLineText ( caretLine ) ; if ( _caret == 0 ) { if ( lineStart == 0 ) { getToolkit ( ) . beep ( ) ; return ; } _caret -- ; } else { String noWordSep = ( String ) buffer . getProperty ( "noWordSep" ) ; _caret = TextUtilities . findWordStart ( lineText , _caret - 1 , noWordSep ) ; } try { buffer . remove ( _caret + lineStart , caret - ( _caret + lineStart ) ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } } public void delete ( ) { if ( ! buffer . isEditable ( ) ) { getToolkit ( ) . beep ( ) ; return ; } if ( selection . size ( ) != 0 ) setSelectedText ( null ) ; else { if ( caret == buffer . getLength ( ) ) { getToolkit ( ) . beep ( ) ; return ; } try { buffer . remove ( caret , 1 ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } } } public void deleteToEndOfLine ( ) { if ( ! buffer . isEditable ( ) ) { getToolkit ( ) . beep ( ) ; return ; } try { buffer . remove ( caret , getLineEndOffset ( caretLine ) - caret - 1 ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } } public void deleteLine ( ) { if ( ! buffer . isEditable ( ) ) { getToolkit ( ) . beep ( ) ; return ; } Element map = buffer . getDefaultRootElement ( ) ; Element lineElement = map . getElement ( caretLine ) ; try { int start = lineElement . getStartOffset ( ) ; int end = lineElement . getEndOffset ( ) ; if ( end > buffer . getLength ( ) ) { if ( start != 0 ) start -- ; end -- ; } buffer . remove ( start , end - start ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } } public void deleteParagraph ( ) { if ( ! buffer . isEditable ( ) ) { getToolkit ( ) . beep ( ) ; return ; } int start = 0 , end = buffer . getLength ( ) ; loop : for ( int i = caretLine - 1 ; i >= 0 ; i -- ) { getLineText ( i , lineSegment ) ; for ( int j = 0 ; j < lineSegment . count ; j ++ ) { switch ( lineSegment . array [ lineSegment . offset + j ] ) { case ' ' : case '\t' : break ; default : continue loop ; } } start = getLineStartOffset ( i ) ; break loop ; } loop : for ( int i = caretLine + 1 ; i < getLineCount ( ) ; i ++ ) { getLineText ( i , lineSegment ) ; for ( int j = 0 ; j < lineSegment . count ; j ++ ) { switch ( lineSegment . array [ lineSegment . offset + j ] ) { case ' ' : case '\t' : break ; default : continue loop ; } } end = getLineEndOffset ( i ) - 1 ; break loop ; } try { buffer . remove ( start , end - start ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } } public void deleteToStartOfLine ( ) { if ( ! buffer . isEditable ( ) ) { getToolkit ( ) . beep ( ) ; return ; } Element map = buffer . getDefaultRootElement ( ) ; Element lineElement = map . getElement ( caretLine ) ; try { buffer . remove ( lineElement . getStartOffset ( ) , caret - lineElement . getStartOffset ( ) ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } } public void deleteWord ( ) { if ( ! buffer . isEditable ( ) ) { getToolkit ( ) . beep ( ) ; return ; } if ( selection . size ( ) != 0 ) { setSelectedText ( "" ) ; return ; } int lineStart = getLineStartOffset ( caretLine ) ; int _caret = caret - lineStart ; String lineText = getLineText ( caretLine ) ; if ( _caret == lineText . length ( ) ) { if ( lineStart + _caret == buffer . getLength ( ) ) { getToolkit ( ) . beep ( ) ; return ; } _caret ++ ; } else { String noWordSep = ( String ) buffer . getProperty ( "noWordSep" ) ; _caret = TextUtilities . findWordEnd ( lineText , _caret + 1 , noWordSep ) ; } try { buffer . remove ( caret , ( _caret + lineStart ) - caret ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } } public void goToNextBracket ( boolean select ) { String text = getText ( caret , buffer . getLength ( ) - caret - 1 ) ; int newCaret = - 1 ; loop : for ( int i = 0 ; i < text . length ( ) ; i ++ ) { switch ( text . charAt ( i ) ) { case ')' : case ']' : case '}' : newCaret = caret + i + 1 ; break loop ; } } if ( newCaret == - 1 ) getToolkit ( ) . beep ( ) ; else { if ( select ) extendSelection ( caret , newCaret ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( newCaret ) ; } } public void goToNextCharacter ( boolean select ) { if ( ! select && selection . size ( ) != 0 ) { Selection s = getSelectionAtOffset ( caret ) ; if ( s != null ) { if ( multi ) { if ( caret != s . end ) { moveCaretPosition ( s . end ) ; return ; } } else { setCaretPosition ( s . end ) ; return ; } } } if ( caret == buffer . getLength ( ) ) getToolkit ( ) . beep ( ) ; int newCaret ; if ( caret == getLineEndOffset ( caretLine ) - 1 ) { int line = buffer . getNextVisibleLine ( caretLine ) ; if ( line == - 1 ) { getToolkit ( ) . beep ( ) ; return ; } newCaret = getLineStartOffset ( line ) ; } else newCaret = caret + 1 ; if ( select ) extendSelection ( caret , newCaret ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( newCaret ) ; } public void goToNextLine ( boolean select ) { int caret = getCaretPosition ( ) ; int line = getCaretLine ( ) ; int magic = getMagicCaretPosition ( ) ; int nextLine = buffer . getNextVisibleLine ( line ) ; if ( nextLine == - 1 ) { getToolkit ( ) . beep ( ) ; return ; } int newCaret = getLineStartOffset ( nextLine ) + xToOffset ( nextLine , magic + 1 ) ; if ( select ) extendSelection ( caret , newCaret ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( newCaret ) ; setMagicCaretPosition ( magic ) ; } public void goToNextMarker ( boolean select ) { Vector markers = buffer . getMarkers ( ) ; Marker marker = null ; for ( int i = 0 ; i < markers . size ( ) ; i ++ ) { Marker _marker = ( Marker ) markers . elementAt ( i ) ; if ( _marker . getPosition ( ) > caret ) { marker = _marker ; break ; } } if ( marker == null ) getToolkit ( ) . beep ( ) ; else { if ( select ) extendSelection ( caret , marker . getPosition ( ) ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( marker . getPosition ( ) ) ; } } public void goToNextPage ( boolean select ) { int lineCount = buffer . getVirtualLineCount ( ) ; int magic = getMagicCaretPosition ( ) ; if ( firstLine + visibleLines * 2 >= lineCount - 1 ) setFirstLine ( lineCount - visibleLines ) ; else setFirstLine ( firstLine + visibleLines ) ; int newLine = buffer . virtualToPhysical ( Math . min ( lineCount - 1 , buffer . physicalToVirtual ( caretLine ) + visibleLines ) ) ; int newCaret = getLineStartOffset ( newLine ) + xToOffset ( newLine , magic + 1 ) ; if ( select ) extendSelection ( caret , newCaret ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( newCaret ) ; setMagicCaretPosition ( magic ) ; } public void goToNextParagraph ( boolean select ) { int lineNo = getCaretLine ( ) ; int newCaret = getBufferLength ( ) ; boolean foundBlank = false ; loop : for ( int i = lineNo + 1 ; i < getLineCount ( ) ; i ++ ) { if ( ! buffer . isLineVisible ( i ) ) continue ; getLineText ( i , lineSegment ) ; for ( int j = 0 ; j < lineSegment . count ; j ++ ) { switch ( lineSegment . array [ lineSegment . offset + j ] ) { case ' ' : case '\t' : break ; default : if ( foundBlank ) { newCaret = getLineStartOffset ( i ) ; break loop ; } else continue loop ; } } foundBlank = true ; } if ( select ) extendSelection ( caret , newCaret ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( newCaret ) ; } public void goToNextWord ( boolean select ) { int lineStart = getLineStartOffset ( caretLine ) ; int newCaret = caret - lineStart ; String lineText = getLineText ( caretLine ) ; if ( newCaret == lineText . length ( ) ) { int nextLine = buffer . getNextVisibleLine ( caretLine ) ; if ( nextLine == - 1 ) { getToolkit ( ) . beep ( ) ; return ; } newCaret = getLineStartOffset ( nextLine ) ; } else { String noWordSep = ( String ) buffer . getProperty ( "noWordSep" ) ; newCaret = TextUtilities . findWordEnd ( lineText , newCaret + 1 , noWordSep ) + lineStart ; } if ( select ) extendSelection ( caret , newCaret ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( newCaret ) ; } public void goToPrevBracket ( boolean select ) { String text = getText ( 0 , caret ) ; int newCaret = - 1 ; loop : for ( int i = getCaretPosition ( ) - 1 ; i >= 0 ; i -- ) { switch ( text . charAt ( i ) ) { case '(' : case '[' : case '{' : newCaret = i ; break loop ; } } if ( newCaret == - 1 ) getToolkit ( ) . beep ( ) ; else { if ( select ) extendSelection ( caret , newCaret ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( newCaret ) ; } } public void goToPrevCharacter ( boolean select ) { if ( ! select && selection . size ( ) != 0 ) { Selection s = getSelectionAtOffset ( caret ) ; if ( s != null ) { if ( multi ) { if ( caret != s . start ) { moveCaretPosition ( s . start ) ; return ; } } else { setCaretPosition ( s . start ) ; return ; } } } int newCaret ; if ( caret == getLineStartOffset ( caretLine ) ) { int line = buffer . getPrevVisibleLine ( caretLine ) ; if ( line == - 1 ) { getToolkit ( ) . beep ( ) ; return ; } newCaret = getLineEndOffset ( line ) - 1 ; } else newCaret = caret - 1 ; if ( select ) extendSelection ( caret , newCaret ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( newCaret ) ; } public void goToPrevLine ( boolean select ) { int magic = getMagicCaretPosition ( ) ; int prevLine = buffer . getPrevVisibleLine ( caretLine ) ; if ( prevLine == - 1 ) { getToolkit ( ) . beep ( ) ; return ; } int newCaret = getLineStartOffset ( prevLine ) + xToOffset ( prevLine , magic + 1 ) ; if ( select ) extendSelection ( caret , newCaret ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( newCaret ) ; setMagicCaretPosition ( magic ) ; } public void goToPrevMarker ( boolean select ) { Vector markers = buffer . getMarkers ( ) ; Marker marker = null ; for ( int i = markers . size ( ) - 1 ; i >= 0 ; i -- ) { Marker _marker = ( Marker ) markers . elementAt ( i ) ; if ( _marker . getPosition ( ) < caret ) { marker = _marker ; break ; } } if ( marker == null ) getToolkit ( ) . beep ( ) ; else { if ( select ) extendSelection ( caret , marker . getPosition ( ) ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( marker . getPosition ( ) ) ; } } public void goToPrevPage ( boolean select ) { if ( firstLine < visibleLines ) setFirstLine ( 0 ) ; else setFirstLine ( firstLine - visibleLines ) ; int magic = getMagicCaretPosition ( ) ; int newLine = buffer . virtualToPhysical ( Math . max ( 0 , buffer . physicalToVirtual ( caretLine ) - visibleLines ) ) ; int newCaret = getLineStartOffset ( newLine ) + xToOffset ( newLine , magic + 1 ) ; if ( select ) extendSelection ( caret , newCaret ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( newCaret ) ; setMagicCaretPosition ( magic ) ; } public void goToPrevParagraph ( boolean select ) { int lineNo = caretLine ; int newCaret = 0 ; boolean foundBlank = false ; loop : for ( int i = lineNo - 1 ; i >= 0 ; i -- ) { if ( ! buffer . isLineVisible ( i ) ) continue ; getLineText ( i , lineSegment ) ; for ( int j = 0 ; j < lineSegment . count ; j ++ ) { switch ( lineSegment . array [ lineSegment . offset + j ] ) { case ' ' : case '\t' : break ; default : if ( foundBlank ) { newCaret = getLineEndOffset ( i ) - 1 ; break loop ; } else continue loop ; } } foundBlank = true ; } if ( select ) extendSelection ( caret , newCaret ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( newCaret ) ; } public void goToPrevWord ( boolean select ) { int lineStart = getLineStartOffset ( caretLine ) ; int newCaret = caret - lineStart ; String lineText = getLineText ( caretLine ) ; if ( newCaret == 0 ) { if ( lineStart == 0 ) { view . getToolkit ( ) . beep ( ) ; return ; } else { int prevLine = buffer . getPrevVisibleLine ( caretLine ) ; if ( prevLine == - 1 ) { getToolkit ( ) . beep ( ) ; return ; } newCaret = getLineEndOffset ( prevLine ) - 1 ; } } else { String noWordSep = ( String ) buffer . getProperty ( "noWordSep" ) ; newCaret = TextUtilities . findWordStart ( lineText , newCaret - 1 , noWordSep ) + lineStart ; } if ( select ) extendSelection ( caret , newCaret ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( newCaret ) ; } public void smartHome ( boolean select ) { if ( ! jEdit . getBooleanProperty ( "view.homeEnd" ) ) goToStartOfLine ( select ) ; else { switch ( view . getInputHandler ( ) . getLastActionCount ( ) ) { case 1 : goToStartOfWhiteSpace ( select ) ; break ; case 2 : goToStartOfLine ( select ) ; break ; default : goToFirstVisibleLine ( select ) ; break ; } } } public void smartEnd ( boolean select ) { if ( ! jEdit . getBooleanProperty ( "view.homeEnd" ) ) goToEndOfLine ( select ) ; else { switch ( view . getInputHandler ( ) . getLastActionCount ( ) ) { case 1 : goToEndOfWhiteSpace ( select ) ; break ; case 2 : goToEndOfLine ( select ) ; break ; default : goToLastVisibleLine ( select ) ; break ; } } } public void goToStartOfLine ( boolean select ) { Macros . Recorder recorder = view . getMacroRecorder ( ) ; if ( recorder != null ) recorder . record ( "textArea.goToStartOfLine(" + select + ");" ) ; int newCaret = getLineStartOffset ( getCaretLine ( ) ) ; if ( select ) extendSelection ( caret , newCaret ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( newCaret ) ; } public void goToEndOfLine ( boolean select ) { Macros . Recorder recorder = view . getMacroRecorder ( ) ; if ( recorder != null ) recorder . record ( "textArea.goToEndOfLine(" + select + ");" ) ; int newCaret = getLineEndOffset ( getCaretLine ( ) ) - 1 ; if ( select ) extendSelection ( caret , newCaret ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( newCaret ) ; setMagicCaretPosition ( Integer . MAX_VALUE ) ; } public void goToStartOfWhiteSpace ( boolean select ) { Macros . Recorder recorder = view . getMacroRecorder ( ) ; if ( recorder != null ) recorder . record ( "textArea.goToStartOfWhiteSpace(" + select + ");" ) ; int firstIndent = MiscUtilities . getLeadingWhiteSpace ( getLineText ( caretLine ) ) ; int firstOfLine = getLineStartOffset ( caretLine ) ; firstIndent = firstOfLine + firstIndent ; if ( firstIndent == getLineEndOffset ( caretLine ) - 1 ) firstIndent = firstOfLine ; if ( select ) extendSelection ( caret , firstIndent ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( firstIndent ) ; } public void goToEndOfWhiteSpace ( boolean select ) { Macros . Recorder recorder = view . getMacroRecorder ( ) ; if ( recorder != null ) recorder . record ( "textArea.goToEndOfWhiteSpace(" + select + ");" ) ; int lastIndent = MiscUtilities . getTrailingWhiteSpace ( getLineText ( caretLine ) ) ; int lastOfLine = getLineEndOffset ( caretLine ) - 1 ; lastIndent = lastOfLine - lastIndent ; if ( lastIndent == getLineStartOffset ( caretLine ) ) lastIndent = lastOfLine ; if ( select ) extendSelection ( caret , lastIndent ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( lastIndent ) ; } public void goToFirstVisibleLine ( boolean select ) { Macros . Recorder recorder = view . getMacroRecorder ( ) ; if ( recorder != null ) recorder . record ( "textArea.goToFirstVisibleLine(" + select + ");" ) ; int firstVisibleLine = ( firstLine <= electricScroll ) ? 0 : firstLine + electricScroll ; if ( firstVisibleLine >= getVirtualLineCount ( ) ) firstVisibleLine = getVirtualLineCount ( ) - 1 ; firstVisibleLine = buffer . virtualToPhysical ( firstVisibleLine ) ; int firstVisible = getLineEndOffset ( firstVisibleLine ) - 1 ; if ( select ) extendSelection ( caret , firstVisible ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( firstVisible ) ; } public void goToLastVisibleLine ( boolean select ) { Macros . Recorder recorder = view . getMacroRecorder ( ) ; if ( recorder != null ) recorder . record ( "textArea.goToLastVisibleLine(" + select + ");" ) ; int lastVisibleLine = firstLine + visibleLines ; if ( lastVisibleLine >= getVirtualLineCount ( ) ) lastVisibleLine = getVirtualLineCount ( ) - 1 ; else if ( lastVisibleLine <= electricScroll ) lastVisibleLine = 0 ; else lastVisibleLine -= ( electricScroll + 1 ) ; lastVisibleLine = buffer . virtualToPhysical ( lastVisibleLine ) ; int lastVisible = getLineEndOffset ( lastVisibleLine ) - 1 ; if ( select ) extendSelection ( caret , lastVisible ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( lastVisible ) ; } public void goToMarker ( char shortcut , boolean select ) { Marker marker = buffer . getMarker ( shortcut ) ; if ( marker == null ) { getToolkit ( ) . beep ( ) ; return ; } int pos = marker . getPosition ( ) ; if ( select ) extendSelection ( caret , pos ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( pos ) ; } public void addMarker ( ) { Selection [ ] selection = getSelection ( ) ; for ( int i = 0 ; i < selection . length ; i ++ ) { Selection s = selection [ i ] ; if ( s . startLine != s . endLine ) { if ( s . startLine != caretLine ) buffer . addMarker ( '\0' , s . start ) ; } if ( s . endLine != caretLine ) buffer . addMarker ( '\0' , s . end ) ; } buffer . addOrRemoveMarker ( '\0' , caret ) ; } public void swapMarkerAndCaret ( char shortcut ) { Marker marker = buffer . getMarker ( shortcut ) ; if ( marker == null ) { getToolkit ( ) . beep ( ) ; return ; } int caret = getCaretPosition ( ) ; setCaretPosition ( marker . getPosition ( ) ) ; buffer . addMarker ( shortcut , caret ) ; } public void lineComment ( ) { String comment = ( String ) buffer . getProperty ( "lineComment" ) ; if ( ! buffer . isEditable ( ) || comment == null || comment . length ( ) == 0 ) { getToolkit ( ) . beep ( ) ; return ; } comment = comment + ' ' ; buffer . beginCompoundEdit ( ) ; int [ ] lines = getSelectedLines ( ) ; try { for ( int i = 0 ; i < lines . length ; i ++ ) { buffer . insertString ( getLineStartOffset ( lines [ i ] ) , comment , null ) ; } } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } finally { buffer . endCompoundEdit ( ) ; } selectNone ( ) ; } public void rangeComment ( ) { String commentStart = ( String ) buffer . getProperty ( "commentStart" ) ; String commentEnd = ( String ) buffer . getProperty ( "commentEnd" ) ; if ( ! buffer . isEditable ( ) || commentStart == null || commentEnd == null || commentStart . length ( ) == 0 || commentEnd . length ( ) == 0 ) { getToolkit ( ) . beep ( ) ; return ; } commentStart = commentStart + ' ' ; commentEnd = ' ' + commentEnd ; try { buffer . beginCompoundEdit ( ) ; Selection [ ] selection = getSelection ( ) ; if ( selection . length == 0 ) { int oldCaret = caret ; buffer . insertString ( caret , commentStart , null ) ; buffer . insertString ( caret , commentEnd , null ) ; setCaretPosition ( oldCaret + commentStart . length ( ) ) ; } for ( int i = 0 ; i < selection . length ; i ++ ) { Selection s = selection [ i ] ; if ( s instanceof Selection . Range ) { buffer . insertString ( s . start , commentStart , null ) ; buffer . insertString ( s . end , commentEnd , null ) ; } else if ( s instanceof Selection . Rect ) { for ( int j = s . startLine ; j <= s . endLine ; j ++ ) { buffer . insertString ( s . getStart ( buffer , j ) , commentStart , null ) ; int end = s . getEnd ( buffer , j ) + ( j == s . endLine ? 0 : commentStart . length ( ) ) ; buffer . insertString ( end , commentEnd , null ) ; } } } selectNone ( ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } finally { buffer . endCompoundEdit ( ) ; } } public void formatParagraph ( ) { if ( ! buffer . isEditable ( ) ) { getToolkit ( ) . beep ( ) ; return ; } int maxLineLength = ( ( Integer ) buffer . getProperty ( "maxLineLen" ) ) . intValue ( ) ; if ( maxLineLength <= 0 ) { getToolkit ( ) . beep ( ) ; return ; } Selection [ ] selection = getSelection ( ) ; if ( selection . length != 0 ) { buffer . beginCompoundEdit ( ) ; for ( int i = 0 ; i < selection . length ; i ++ ) { Selection s = selection [ i ] ; setSelectedText ( s , TextUtilities . format ( getSelectedText ( s ) , maxLineLength ) ) ; } buffer . endCompoundEdit ( ) ; } else { int lineNo = getCaretLine ( ) ; int start = 0 , end = buffer . getLength ( ) ; loop : for ( int i = lineNo - 1 ; i >= 0 ; i -- ) { getLineText ( i , lineSegment ) ; for ( int j = 0 ; j < lineSegment . count ; j ++ ) { switch ( lineSegment . array [ lineSegment . offset + j ] ) { case ' ' : case '\t' : break ; default : continue loop ; } } start = getLineStartOffset ( i ) ; break loop ; } loop : for ( int i = lineNo + 1 ; i < getLineCount ( ) ; i ++ ) { getLineText ( i , lineSegment ) ; for ( int j = 0 ; j < lineSegment . count ; j ++ ) { switch ( lineSegment . array [ lineSegment . offset + j ] ) { case ' ' : case '\t' : break ; default : continue loop ; } } end = getLineEndOffset ( i ) - 1 ; break loop ; } try { buffer . beginCompoundEdit ( ) ; String text = buffer . getText ( start , end - start ) ; buffer . remove ( start , end - start ) ; buffer . insertString ( start , TextUtilities . format ( text , maxLineLength ) , null ) ; } catch ( BadLocationException bl ) { return ; } finally { buffer . endCompoundEdit ( ) ; } } } public void spacesToTabs ( ) { Selection [ ] selection = getSelection ( ) ; if ( ! buffer . isEditable ( ) || selection . length == 0 ) { getToolkit ( ) . beep ( ) ; return ; } buffer . beginCompoundEdit ( ) ; for ( int i = 0 ; i < selection . length ; i ++ ) { Selection s = selection [ i ] ; setSelectedText ( s , TextUtilities . spacesToTabs ( getSelectedText ( s ) , buffer . getTabSize ( ) ) ) ; } buffer . endCompoundEdit ( ) ; } public void tabsToSpaces ( ) { Selection [ ] selection = getSelection ( ) ; if ( ! buffer . isEditable ( ) || selection . length == 0 ) { getToolkit ( ) . beep ( ) ; return ; } buffer . beginCompoundEdit ( ) ; for ( int i = 0 ; i < selection . length ; i ++ ) { Selection s = selection [ i ] ; setSelectedText ( s , TextUtilities . tabsToSpaces ( getSelectedText ( s ) , buffer . getTabSize ( ) ) ) ; } buffer . endCompoundEdit ( ) ; } public void toUpperCase ( ) { Selection [ ] selection = getSelection ( ) ; if ( ! buffer . isEditable ( ) || selection . length == 0 ) { getToolkit ( ) . beep ( ) ; return ; } buffer . beginCompoundEdit ( ) ; for ( int i = 0 ; i < selection . length ; i ++ ) { Selection s = selection [ i ] ; setSelectedText ( s , getSelectedText ( s ) . toUpperCase ( ) ) ; } buffer . endCompoundEdit ( ) ; } public void toLowerCase ( ) { Selection [ ] selection = getSelection ( ) ; if ( ! buffer . isEditable ( ) || selection . length == 0 ) { getToolkit ( ) . beep ( ) ; return ; } buffer . beginCompoundEdit ( ) ; for ( int i = 0 ; i < selection . length ; i ++ ) { Selection s = selection [ i ] ; setSelectedText ( s , getSelectedText ( s ) . toLowerCase ( ) ) ; } buffer . endCompoundEdit ( ) ; } public void removeTrailingWhiteSpace ( ) { if ( ! buffer . isEditable ( ) ) getToolkit ( ) . beep ( ) ; else { buffer . removeTrailingWhiteSpace ( getSelectedLines ( ) ) ; } } public void indentSelectedLines ( ) { if ( ! buffer . isEditable ( ) ) getToolkit ( ) . beep ( ) ; else { buffer . indentLines ( getSelectedLines ( ) ) ; selectNone ( ) ; } } public void shiftIndentLeft ( ) { if ( ! buffer . isEditable ( ) ) getToolkit ( ) . beep ( ) ; else { buffer . shiftIndentLeft ( getSelectedLines ( ) ) ; } } public void shiftIndentRight ( ) { if ( ! buffer . isEditable ( ) ) getToolkit ( ) . beep ( ) ; else { buffer . shiftIndentRight ( getSelectedLines ( ) ) ; } } public void joinLines ( ) { Element map = buffer . getDefaultRootElement ( ) ; Element lineElement = map . getElement ( caretLine ) ; int start = lineElement . getStartOffset ( ) ; int end = lineElement . getEndOffset ( ) ; if ( end > buffer . getLength ( ) ) { getToolkit ( ) . beep ( ) ; return ; } Element nextLineElement = map . getElement ( caretLine + 1 ) ; int nextStart = nextLineElement . getStartOffset ( ) ; int nextEnd = nextLineElement . getEndOffset ( ) ; try { buffer . remove ( end - 1 , MiscUtilities . getLeadingWhiteSpace ( buffer . getText ( nextStart , nextEnd - nextStart ) ) + 1 ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } } public void goToMatchingBracket ( ) { int dot = caret - getLineStartOffset ( caretLine ) ; try { int bracket = TextUtilities . findMatchingBracket ( buffer , caretLine , Math . max ( 0 , dot - 1 ) ) ; if ( bracket != - 1 ) { setCaretPosition ( bracket + 1 ) ; return ; } } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } getToolkit ( ) . beep ( ) ; } private final String openBrackets = "([{" ; private final String closeBrackets = ")]}" ; public void selectBlock ( ) { Selection s = getSelectionAtOffset ( caret ) ; int start , end ; if ( s == null ) start = end = caret ; else { start = s . start ; end = s . end ; } String text = getText ( 0 , buffer . getLength ( ) ) ; int count = 1 ; char openBracket = '\0' ; char closeBracket = '\0' ; if ( start == 0 ) { view . getToolkit ( ) . beep ( ) ; return ; } backward_scan : while ( -- start > 0 ) { char c = text . charAt ( start ) ; int index = openBrackets . indexOf ( c ) ; if ( index != - 1 ) { if ( -- count == 0 ) { openBracket = c ; closeBracket = closeBrackets . charAt ( index ) ; break backward_scan ; } } else if ( closeBrackets . indexOf ( c ) != - 1 ) count ++ ; } count = 1 ; if ( openBracket == '\0' ) { getToolkit ( ) . beep ( ) ; return ; } else { forward_scan : do { char c = text . charAt ( end ) ; if ( c == closeBracket ) { if ( -- count == 0 ) { end ++ ; break forward_scan ; } } else if ( c == openBracket ) count ++ ; } while ( ++ end < buffer . getLength ( ) ) ; } setSelection ( new Selection . Range ( start , end ) ) ; moveCaretPosition ( end ) ; } public void showGoToLineDialog ( ) { String line = GUIUtilities . input ( view , "goto-line" , null ) ; if ( line == null ) return ; try { int lineNumber = Integer . parseInt ( line ) - 1 ; setCaretPosition ( getLineStartOffset ( lineNumber ) ) ; } catch ( Exception e ) { getToolkit ( ) . beep ( ) ; } } public void showSelectLineRangeDialog ( ) { new SelectLineRange ( view ) ; } public void showWordCountDialog ( ) { String selection = getSelectedText ( ) ; if ( selection != null ) { doWordCount ( view , selection ) ; return ; } try { doWordCount ( view , buffer . getText ( 0 , buffer . getLength ( ) ) ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } } public void completeWord ( ) { String noWordSep = ( String ) buffer . getProperty ( "noWordSep" ) ; if ( noWordSep == null ) noWordSep = "" ; if ( ! buffer . isEditable ( ) ) { getToolkit ( ) . beep ( ) ; return ; } String line = getLineText ( caretLine ) ; int dot = caret - getLineStartOffset ( caretLine ) ; if ( dot == 0 ) { getToolkit ( ) . beep ( ) ; return ; } char ch = line . charAt ( dot - 1 ) ; if ( ! Character . isLetterOrDigit ( ch ) && noWordSep . indexOf ( ch ) == - 1 ) { getToolkit ( ) . beep ( ) ; return ; } int wordStart = TextUtilities . findWordStart ( line , dot - 1 , noWordSep ) ; String word = line . substring ( wordStart , dot ) ; if ( word . length ( ) == 0 ) { getToolkit ( ) . beep ( ) ; return ; } Vector completions = new Vector ( ) ; int wordLen = word . length ( ) ; for ( int i = 0 ; i < getLineCount ( ) ; i ++ ) { line = getLineText ( i ) ; if ( line . startsWith ( word ) ) { if ( i == caretLine && wordStart == 0 ) continue ; String _word = completeWord ( line , 0 , noWordSep ) ; if ( _word . length ( ) != wordLen ) { if ( completions . indexOf ( _word ) == - 1 ) completions . addElement ( _word ) ; } } int len = line . length ( ) - word . length ( ) ; for ( int j = 0 ; j < len ; j ++ ) { char c = line . charAt ( j ) ; if ( ! Character . isLetterOrDigit ( c ) && noWordSep . indexOf ( c ) == - 1 ) { if ( i == caretLine && wordStart == ( j + 1 ) ) continue ; if ( line . regionMatches ( j + 1 , word , 0 , wordLen ) ) { String _word = completeWord ( line , j + 1 , noWordSep ) ; if ( _word . length ( ) != wordLen ) { if ( completions . indexOf ( _word ) == - 1 ) completions . addElement ( _word ) ; } } } } } MiscUtilities . quicksort ( completions , new MiscUtilities . StringICaseCompare ( ) ) ; if ( completions . size ( ) == 0 ) getToolkit ( ) . beep ( ) ; else if ( completions . size ( ) == 1 ) { setSelectedText ( ( ( String ) completions . elementAt ( 0 ) ) . substring ( wordLen ) ) ; } else { Point location = new Point ( offsetToX ( caretLine , wordStart ) , painter . getFontMetrics ( ) . getHeight ( ) * ( buffer . physicalToVirtual ( caretLine ) - firstLine + 1 ) ) ; SwingUtilities . convertPointToScreen ( location , painter ) ; new CompleteWord ( view , word , completions , location ) ; } } public void selectFold ( ) { selectFoldAt ( caretLine ) ; } public void selectFoldAt ( int line ) { int start ; int end ; if ( buffer . isFoldStart ( line ) ) { start = line ; int foldLevel = buffer . getFoldLevel ( line ) ; line ++ ; while ( line < buffer . getLineCount ( ) && buffer . getFoldLevel ( line ) > foldLevel ) line ++ ; end = line ; } else { start = line ; int foldLevel = buffer . getFoldLevel ( line ) ; while ( start >= 0 && buffer . getFoldLevel ( start ) >= foldLevel ) start -- ; end = line ; while ( end < buffer . getLineCount ( ) && buffer . getFoldLevel ( end ) >= foldLevel ) end ++ ; } int newCaret = getLineEndOffset ( end ) - 1 ; extendSelection ( getLineStartOffset ( start ) , newCaret ) ; moveCaretPosition ( newCaret ) ; } public void addNotify ( ) { super . addNotify ( ) ; ToolTipManager . sharedInstance ( ) . registerComponent ( painter ) ; ToolTipManager . sharedInstance ( ) . registerComponent ( gutter ) ; if ( ! documentHandlerInstalled ) { documentHandlerInstalled = true ; buffer . addDocumentListener ( documentHandler ) ; buffer . addFoldListener ( foldHandler ) ; } recalculateVisibleLines ( ) ; } public void removeNotify ( ) { super . removeNotify ( ) ; ToolTipManager . sharedInstance ( ) . unregisterComponent ( painter ) ; ToolTipManager . sharedInstance ( ) . unregisterComponent ( gutter ) ; if ( focusedComponent == this ) focusedComponent = null ; if ( documentHandlerInstalled ) { buffer . removeDocumentListener ( documentHandler ) ; buffer . removeFoldListener ( foldHandler ) ; documentHandlerInstalled = false ; } } public boolean hasFocus ( ) { Component c = this ; while ( ! ( c instanceof Window ) ) { if ( c == null ) return false ; c = c . getParent ( ) ; } Component focusOwner = ( ( Window ) c ) . getFocusOwner ( ) ; boolean hasFocus = ( focusOwner == this ) ; if ( hasFocus && focusedComponent != this ) focusedComponent = this ; return hasFocus ; } public void grabFocus ( ) { super . grabFocus ( ) ; hasFocus ( ) ; } public boolean getFocusTraversalKeysEnabled ( ) { return false ; } public final boolean isMultipleSelectionEnabled ( ) { return multi ; } public final void toggleMultipleSelectionEnabled ( ) { multi = ! multi ; if ( view . getStatus ( ) != null ) view . getStatus ( ) . updateMiscStatus ( ) ; } public final void setMultipleSelectionEnabled ( boolean multi ) { JEditTextArea . multi = multi ; if ( view . getStatus ( ) != null ) view . getStatus ( ) . updateMiscStatus ( ) ; } public void processKeyEvent ( KeyEvent evt ) { evt = KeyEventWorkaround . processKeyEvent ( evt ) ; if ( evt == null ) return ; if ( view . isClosed ( ) ) return ; InputHandler inputHandler = view . getInputHandler ( ) ; KeyListener keyEventInterceptor = view . getKeyEventInterceptor ( ) ; switch ( evt . getID ( ) ) { case KeyEvent . KEY_TYPED : if ( keyEventInterceptor != null ) keyEventInterceptor . keyTyped ( evt ) ; else inputHandler . keyTyped ( evt ) ; break ; case KeyEvent . KEY_PRESSED : if ( keyEventInterceptor != null ) keyEventInterceptor . keyPressed ( evt ) ; else inputHandler . keyPressed ( evt ) ; break ; case KeyEvent . KEY_RELEASED : if ( keyEventInterceptor != null ) keyEventInterceptor . keyReleased ( evt ) ; else inputHandler . keyReleased ( evt ) ; break ; } if ( ! evt . isConsumed ( ) ) super . processKeyEvent ( evt ) ; } Segment lineSegment ; MouseHandler mouseHandler ; int maxHorizontalScrollWidth ; Vector selection ; final boolean isCaretVisible ( ) { return blink && hasFocus ( ) ; } final boolean isHighlightVisible ( ) { return hasFocus ( ) ; } void recalculateVisibleLines ( ) { if ( painter == null ) return ; int height = painter . getHeight ( ) ; int lineHeight = painter . getFontMetrics ( ) . getHeight ( ) ; visibleLines = height / lineHeight ; updateScrollBars ( ) ; } void updateMaxHorizontalScrollWidth ( ) { int _maxHorizontalScrollWidth = buffer . getMaxLineWidth ( physFirstLine , visibleLines ) ; if ( _maxHorizontalScrollWidth != maxHorizontalScrollWidth ) { maxHorizontalScrollWidth = _maxHorizontalScrollWidth ; horizontal . setValues ( - horizontalOffset , painter . getWidth ( ) , 0 , maxHorizontalScrollWidth + painter . getFontMetrics ( ) . charWidth ( 'w' ) ) ; } } private static String CENTER = "center" ; private static String RIGHT = "right" ; private static String LEFT = "left" ; private static String BOTTOM = "bottom" ; private static Timer caretTimer ; private static JEditTextArea focusedComponent ; private View view ; private Gutter gutter ; private TextAreaPainter painter ; private JPopupMenu popup ; private EventListenerList listenerList ; private MutableCaretEvent caretEvent ; private boolean caretBlinks ; private boolean blink ; private int firstLine ; private int physFirstLine ; private int visibleLines ; private int electricScroll ; private int horizontalOffset ; private boolean middleMousePaste ; private JScrollBar vertical ; private JScrollBar horizontal ; private boolean scrollBarsInitialized ; private Buffer buffer ; private DocumentHandler documentHandler ; private FoldHandler foldHandler ; private boolean documentHandlerInstalled ; private int caret ; private int caretLine ; private int bracketPosition ; private int bracketLine ; private int magicCaret ; private static boolean multi ; private boolean overwrite ; private TextRenderer renderer ; private static void quicksort ( int [ ] obj , int _start , int _end ) { int start = _start ; int end = _end ; int mid = obj [ ( _start + _end ) / 2 ] ; if ( _start > _end ) return ; while ( start <= end ) { while ( start < _end && obj [ start ] < mid ) start ++ ; while ( end > _start && obj [ end ] > mid ) end -- ; if ( start <= end ) { int tmp = obj [ start ] ; obj [ start ] = obj [ end ] ; obj [ end ] = tmp ; start ++ ; end -- ; } } if ( _start < end ) quicksort ( obj , _start , end ) ; if ( start < _end ) quicksort ( obj , start , _end ) ; } private void _addToSelection ( Selection addMe ) { if ( addMe . start < 0 ) addMe . start = 0 ; else if ( addMe . end > buffer . getLength ( ) ) addMe . end = buffer . getLength ( ) ; if ( addMe . start > addMe . end ) { throw new IllegalArgumentException ( addMe . start + " > " + addMe . end ) ; } else if ( addMe . start == addMe . end ) return ; for ( int i = 0 ; i < selection . size ( ) ; i ++ ) { Selection s = ( Selection ) selection . elementAt ( i ) ; if ( _selectionsOverlap ( s , addMe ) ) { addMe . start = Math . min ( s . start , addMe . start ) ; addMe . end = Math . max ( s . end , addMe . end ) ; selection . removeElement ( s ) ; i -- ; } } addMe . startLine = getLineOfOffset ( addMe . start ) ; addMe . endLine = getLineOfOffset ( addMe . end ) ; selection . addElement ( addMe ) ; invalidateLineRange ( addMe . startLine , addMe . endLine ) ; } private boolean _selectionsOverlap ( Selection s1 , Selection s2 ) { if ( ( s1 . start >= s2 . start && s1 . start <= s2 . end ) || ( s1 . end >= s2 . start && s1 . end <= s2 . end ) ) return true ; else return false ; } private void getSelectedText ( Selection s , StringBuffer buf ) { if ( s instanceof Selection . Rect ) { Element map = buffer . getDefaultRootElement ( ) ; int start = s . start - map . getElement ( s . startLine ) . getStartOffset ( ) ; int end = s . end - map . getElement ( s . endLine ) . getStartOffset ( ) ; if ( end < start ) { int tmp = end ; end = start ; start = tmp ; } for ( int i = s . startLine ; i <= s . endLine ; i ++ ) { Element lineElement = map . getElement ( i ) ; int lineStart = lineElement . getStartOffset ( ) ; int lineEnd = lineElement . getEndOffset ( ) - 1 ; int lineLen = lineEnd - lineStart ; lineStart = Math . min ( lineStart + start , lineEnd ) ; lineLen = Math . min ( end - start , lineEnd - lineStart ) ; getText ( lineStart , lineLen , lineSegment ) ; buf . append ( lineSegment . array , lineSegment . offset , lineSegment . count ) ; if ( i != s . endLine ) buf . append ( '\n' ) ; } } else { getText ( s . start , s . end - s . start , lineSegment ) ; buf . append ( lineSegment . array , lineSegment . offset , lineSegment . count ) ; } } private void fireCaretEvent ( ) { Object [ ] listeners = listenerList . getListenerList ( ) ; for ( int i = listeners . length - 2 ; i >= 0 ; i -- ) { if ( listeners [ i ] == CaretListener . class ) { ( ( CaretListener ) listeners [ i + 1 ] ) . caretUpdate ( caretEvent ) ; } } } private void fireScrollEvent ( boolean vertical ) { Object [ ] listeners = listenerList . getListenerList ( ) ; for ( int i = listeners . length - 2 ; i >= 0 ; i -- ) { if ( listeners [ i ] == ScrollListener . class ) { if ( vertical ) ( ( ScrollListener ) listeners [ i + 1 ] ) . scrolledVertically ( this ) ; else ( ( ScrollListener ) listeners [ i + 1 ] ) . scrolledHorizontally ( this ) ; } } } private String createSoftTab ( String line , int tabSize ) { int pos = 0 ; for ( int i = 0 ; i < line . length ( ) ; i ++ ) { switch ( line . charAt ( pos ) ) { case '\t' : pos = 0 ; break ; default : if ( ++ pos >= tabSize ) pos = 0 ; break ; } } return MiscUtilities . createWhiteSpace ( tabSize - pos , 0 ) ; } private boolean doWordWrap ( int line , boolean spaceInserted ) throws BadLocationException { int maxLineLen = ( ( Integer ) buffer . getProperty ( "maxLineLen" ) ) . intValue ( ) ; if ( maxLineLen <= 0 ) return false ; Element lineElement = buffer . getDefaultRootElement ( ) . getElement ( line ) ; int start = lineElement . getStartOffset ( ) ; int end = lineElement . getEndOffset ( ) ; int len = end - start - 1 ; if ( getCaretPosition ( ) != end - 1 ) return false ; boolean returnValue = false ; int tabSize = buffer . getTabSize ( ) ; String wordBreakChars = ( String ) buffer . getProperty ( "wordBreakChars" ) ; buffer . getText ( start , len , lineSegment ) ; int lineStart = lineSegment . offset ; int logicalLength = 0 ; int lastWordOffset = - 1 ; boolean lastWasSpace = true ; boolean initialWhiteSpace = true ; int initialWhiteSpaceLength = 0 ; for ( int i = 0 ; i < len ; i ++ ) { char ch = lineSegment . array [ lineStart + i ] ; if ( ch == '\t' ) { if ( initialWhiteSpace ) initialWhiteSpaceLength = i + 1 ; logicalLength += tabSize - ( logicalLength % tabSize ) ; if ( ! lastWasSpace && logicalLength <= maxLineLen ) { lastWordOffset = i ; lastWasSpace = true ; } } else if ( ch == ' ' ) { if ( initialWhiteSpace ) initialWhiteSpaceLength = i + 1 ; logicalLength ++ ; if ( ! lastWasSpace && logicalLength <= maxLineLen ) { lastWordOffset = i ; lastWasSpace = true ; } } else if ( wordBreakChars != null && wordBreakChars . indexOf ( ch ) != - 1 ) { initialWhiteSpace = false ; logicalLength ++ ; if ( ! lastWasSpace && logicalLength <= maxLineLen ) { lastWordOffset = i ; lastWasSpace = true ; } } else { initialWhiteSpace = false ; logicalLength ++ ; lastWasSpace = false ; } int insertNewLineAt ; if ( spaceInserted && logicalLength == maxLineLen && i == len - 1 ) { insertNewLineAt = end - 1 ; returnValue = true ; } else if ( logicalLength >= maxLineLen && lastWordOffset != - 1 ) insertNewLineAt = lastWordOffset + start ; else continue ; try { buffer . beginCompoundEdit ( ) ; buffer . insertString ( insertNewLineAt , "\n" , null ) ; buffer . indentLine ( line + 1 , true , true ) ; } finally { buffer . endCompoundEdit ( ) ; } return returnValue ; } return false ; } private void doWordCount ( View view , String text ) { char [ ] chars = text . toCharArray ( ) ; int characters = chars . length ; int words ; if ( characters == 0 ) words = 0 ; else words = 1 ; int lines = 1 ; boolean word = false ; for ( int i = 0 ; i < chars . length ; i ++ ) { switch ( chars [ i ] ) { case '\r' : case '\n' : lines ++ ; case ' ' : case '\t' : if ( word ) { words ++ ; word = false ; } break ; default : word = true ; break ; } } Object [ ] args = { new Integer ( characters ) , new Integer ( words ) , new Integer ( lines ) } ; GUIUtilities . message ( view , "wordcount" , args ) ; } private String completeWord ( String line , int offset , String noWordSep ) { int wordEnd = TextUtilities . findWordEnd ( line , offset + 1 , noWordSep ) ; return line . substring ( offset , wordEnd ) ; } private void updateBracketHighlight ( ) { if ( ! painter . isBracketHighlightEnabled ( ) ) return ; if ( bracketLine != - 1 ) invalidateLine ( bracketLine ) ; int line = getCaretLine ( ) ; int offset = getCaretPosition ( ) - getLineStartOffset ( line ) ; if ( offset == 0 ) { bracketPosition = bracketLine = - 1 ; return ; } int endLine ; if ( visibleLines == 0 ) endLine = buffer . getLineCount ( ) ; else { endLine = Math . min ( buffer . getLineCount ( ) , buffer . virtualToPhysical ( firstLine + visibleLines ) ) ; } int beginLine = Math . min ( line , physFirstLine ) ; try { int bracketOffset = TextUtilities . findMatchingBracket ( buffer , line , offset - 1 , beginLine , endLine ) ; if ( bracketOffset != - 1 ) { bracketLine = getLineOfOffset ( bracketOffset ) ; bracketPosition = bracketOffset - getLineStartOffset ( bracketLine ) ; invalidateLine ( bracketLine ) ; return ; } } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } bracketLine = bracketPosition = - 1 ; } private void documentChanged ( DocumentEvent evt ) { DocumentEvent . ElementChange ch = evt . getChange ( buffer . getDefaultRootElement ( ) ) ; int count ; if ( ch == null ) count = 0 ; else count = ch . getChildrenAdded ( ) . length - ch . getChildrenRemoved ( ) . length ; int line = getLineOfOffset ( evt . getOffset ( ) ) ; if ( count == 0 ) invalidateLine ( line ) ; else if ( line < firstLine ) { setFirstLine ( firstLine + count ) ; } else { updateScrollBars ( ) ; invalidateLineRange ( line , buffer . virtualToPhysical ( firstLine + visibleLines ) ) ; } } static class TextAreaBorder extends AbstractBorder { private static final Insets insets = new Insets ( 1 , 1 , 2 , 2 ) ; public void paintBorder ( Component c , Graphics g , int x , int y , int width , int height ) { g . translate ( x , y ) ; g . setColor ( MetalLookAndFeel . getControlDarkShadow ( ) ) ; g . drawRect ( 0 , 0 , width - 2 , height - 2 ) ; g . setColor ( MetalLookAndFeel . getControlHighlight ( ) ) ; g . drawLine ( width - 1 , 1 , width - 1 , height - 1 ) ; g . drawLine ( 1 , height - 1 , width - 1 , height - 1 ) ; g . setColor ( MetalLookAndFeel . getControl ( ) ) ; g . drawLine ( width - 2 , 2 , width - 2 , 2 ) ; g . drawLine ( 1 , height - 2 , 1 , height - 2 ) ; g . translate ( - x , - y ) ; } public Insets getBorderInsets ( Component c ) { return new Insets ( 1 , 1 , 2 , 2 ) ; } } class ScrollLayout implements LayoutManager { public void addLayoutComponent ( String name , Component comp ) { if ( name . equals ( CENTER ) ) center = comp ; else if ( name . equals ( RIGHT ) ) right = comp ; else if ( name . equals ( LEFT ) ) left = comp ; else if ( name . equals ( BOTTOM ) ) bottom = comp ; } public void removeLayoutComponent ( Component comp ) { if ( center == comp ) center = null ; else if ( right == comp ) right = null ; else if ( left == comp ) left = null ; else if ( bottom == comp ) bottom = null ; } public Dimension preferredLayoutSize ( Container parent ) { Dimension dim = new Dimension ( ) ; Border border = getBorder ( ) ; Insets insets ; if ( border == null ) insets = new Insets ( 0 , 0 , 0 , 0 ) ; else { insets = getBorder ( ) . getBorderInsets ( JEditTextArea . this ) ; } dim . width = insets . left + insets . right ; dim . height = insets . top + insets . bottom ; Dimension leftPref = left . getPreferredSize ( ) ; dim . width += leftPref . width ; Dimension centerPref = center . getPreferredSize ( ) ; dim . width += centerPref . width ; dim . height += centerPref . height ; Dimension rightPref = right . getPreferredSize ( ) ; dim . width += rightPref . width ; Dimension bottomPref = bottom . getPreferredSize ( ) ; dim . height += bottomPref . height ; return dim ; } public Dimension minimumLayoutSize ( Container parent ) { Dimension dim = new Dimension ( ) ; Border border = getBorder ( ) ; Insets insets ; if ( border == null ) insets = new Insets ( 0 , 0 , 0 , 0 ) ; else { insets = getBorder ( ) . getBorderInsets ( JEditTextArea . this ) ; } dim . width = insets . left + insets . right ; dim . height = insets . top + insets . bottom ; Dimension leftPref = left . getMinimumSize ( ) ; dim . width += leftPref . width ; Dimension centerPref = center . getMinimumSize ( ) ; dim . width += centerPref . width ; dim . height += centerPref . height ; Dimension rightPref = right . getMinimumSize ( ) ; dim . width += rightPref . width ; Dimension bottomPref = bottom . getMinimumSize ( ) ; dim . height += bottomPref . height ; return dim ; } public void layoutContainer ( Container parent ) { Dimension size = parent . getSize ( ) ; Border border = getBorder ( ) ; Insets insets ; if ( border == null ) insets = new Insets ( 0 , 0 , 0 , 0 ) ; else { insets = getBorder ( ) . getBorderInsets ( JEditTextArea . this ) ; } int itop = insets . top ; int ileft = insets . left ; int ibottom = insets . bottom ; int iright = insets . right ; int rightWidth = right . getPreferredSize ( ) . width ; int leftWidth = left . getPreferredSize ( ) . width ; int bottomHeight = bottom . getPreferredSize ( ) . height ; int centerWidth = Math . max ( 0 , size . width - leftWidth - rightWidth - ileft - iright ) ; int centerHeight = Math . max ( 0 , size . height - bottomHeight - itop - ibottom ) ; left . setBounds ( ileft , itop , leftWidth , centerHeight ) ; center . setBounds ( ileft + leftWidth , itop , centerWidth , centerHeight ) ; right . setBounds ( ileft + leftWidth + centerWidth , itop , rightWidth , centerHeight ) ; bottom . setBounds ( ileft , itop + centerHeight , Math . max ( 0 , size . width - rightWidth - ileft - iright ) , bottomHeight ) ; } Component center ; Component left ; Component right ; Component bottom ; } static class CaretBlinker implements ActionListener { public void actionPerformed ( ActionEvent evt ) { if ( focusedComponent != null && focusedComponent . hasFocus ( ) ) focusedComponent . blinkCaret ( ) ; } } class MutableCaretEvent extends CaretEvent { MutableCaretEvent ( ) { super ( JEditTextArea . this ) ; } public int getDot ( ) { return getCaretPosition ( ) ; } public int getMark ( ) { return getMarkPosition ( ) ; } } class AdjustHandler implements AdjustmentListener { public void adjustmentValueChanged ( final AdjustmentEvent evt ) { if ( ! scrollBarsInitialized ) return ; if ( evt . getAdjustable ( ) == vertical ) setFirstLine ( vertical . getValue ( ) ) ; else setHorizontalOffset ( - horizontal . getValue ( ) ) ; } } class ComponentHandler extends ComponentAdapter { public void componentResized ( ComponentEvent evt ) { recalculateVisibleLines ( ) ; scrollBarsInitialized = true ; } } class DocumentHandler implements DocumentListener { public void insertUpdate ( DocumentEvent evt ) { if ( ! buffer . isLoaded ( ) ) return ; documentChanged ( evt ) ; int offset = evt . getOffset ( ) ; int length = evt . getLength ( ) ; if ( caret >= offset ) moveCaretPosition ( caret + length , true ) ; else updateBracketHighlight ( ) ; for ( int i = 0 ; i < selection . size ( ) ; i ++ ) { Selection s = ( Selection ) selection . elementAt ( i ) ; boolean changed = false ; if ( s . start >= offset ) { s . start += length ; s . startLine = getLineOfOffset ( s . start ) ; changed = true ; } if ( s . end >= offset ) { s . end += length ; s . endLine = getLineOfOffset ( s . end ) ; changed = true ; } if ( changed ) invalidateLineRange ( s . startLine , s . endLine ) ; } } public void removeUpdate ( DocumentEvent evt ) { if ( ! buffer . isLoaded ( ) ) return ; documentChanged ( evt ) ; int offset = evt . getOffset ( ) ; int length = evt . getLength ( ) ; int end = offset + length ; boolean caretEvent = false ; for ( int i = 0 ; i < selection . size ( ) ; i ++ ) { Selection s = ( Selection ) selection . elementAt ( i ) ; boolean changed = false ; if ( s . start > offset && s . start <= end ) { s . start = offset ; changed = caretEvent = true ; } else if ( s . start > end ) { s . start -= length ; changed = caretEvent = true ; } if ( s . end > offset && s . end <= end ) { s . end = offset ; changed = caretEvent = true ; } else if ( s . end > end ) { s . end -= length ; changed = caretEvent = true ; } if ( s . start == s . end ) { selection . removeElement ( s ) ; invalidateLineRange ( s . startLine , s . endLine ) ; i -- ; } else if ( changed ) { s . startLine = getLineOfOffset ( s . start ) ; s . endLine = getLineOfOffset ( s . end ) ; invalidateLineRange ( s . startLine , s . endLine ) ; } } if ( caret > offset && caret <= end ) moveCaretPosition ( offset , false ) ; else if ( caret > end ) moveCaretPosition ( caret - length , false ) ; else { updateBracketHighlight ( ) ; if ( caretEvent ) fireCaretEvent ( ) ; } } public void changedUpdate ( DocumentEvent evt ) { } } class FoldHandler implements Buffer . FoldListener { public void foldLevelsChanged ( int firstLine , int lastLine ) { invalidateLineRange ( firstLine , lastLine ) ; } public void foldStructureChanged ( ) { setFirstLine ( buffer . physicalToVirtual ( physFirstLine ) ) ; updateScrollBars ( ) ; gutter . repaint ( ) ; if ( view . getTextArea ( ) == JEditTextArea . this ) view . getStatus ( ) . updateFoldStatus ( ) ; } } class FocusHandler implements FocusListener { public void focusGained ( FocusEvent evt ) { invalidateLine ( caretLine ) ; view . updateGutterBorders ( ) ; } public void focusLost ( FocusEvent evt ) { invalidateLine ( caretLine ) ; } } class MouseHandler extends MouseAdapter implements MouseMotionListener { private int dragStartLine ; private int dragStartOffset ; private int dragStart ; private int clickCount ; public void mousePressed ( MouseEvent evt ) { buffer . endCompoundEdit ( ) ; grabFocus ( ) ; if ( GUIUtilities . isPopupTrigger ( evt ) && popup != null ) { if ( popup . isVisible ( ) ) popup . setVisible ( false ) ; else popup . show ( painter , evt . getX ( ) + 1 , evt . getY ( ) + 1 ) ; return ; } blink = true ; invalidateLine ( caretLine ) ; int x = evt . getX ( ) ; int y = evt . getY ( ) ; dragStartLine = buffer . virtualToPhysical ( yToLine ( y ) ) ; dragStartOffset = xToOffset ( dragStartLine , x ) ; dragStart = xyToOffset ( x , y , ! painter . isBlockCaretEnabled ( ) ) ; clickCount = evt . getClickCount ( ) ; switch ( clickCount ) { case 1 : doSingleClick ( evt ) ; break ; case 2 : try { doDoubleClick ( evt ) ; } catch ( BadLocationException bl ) { bl . printStackTrace ( ) ; } break ; default : doTripleClick ( evt ) ; break ; } } public void mouseReleased ( MouseEvent evt ) { if ( getSelectionCount ( ) != 0 ) Registers . setRegister ( '%' , getSelectedText ( ) ) ; } private void doSingleClick ( MouseEvent evt ) { if ( evt . isShiftDown ( ) ) { resizeSelection ( getMarkPosition ( ) , dragStart , evt . isControlDown ( ) ) ; moveCaretPosition ( dragStart , false ) ; dragStartLine = getMarkLine ( ) ; dragStart = getMarkPosition ( ) ; dragStartOffset = dragStart - getLineStartOffset ( dragStartLine ) ; } else { if ( ! multi ) selectNone ( ) ; moveCaretPosition ( dragStart , false ) ; if ( middleMousePaste && ( evt . getModifiers ( ) & InputEvent . BUTTON2_MASK ) != 0 ) { if ( ! isEditable ( ) ) getToolkit ( ) . beep ( ) ; else Registers . paste ( JEditTextArea . this , '%' ) ; } } } private void doDoubleClick ( MouseEvent evt ) throws BadLocationException { if ( getLineLength ( dragStartLine ) == 0 ) return ; try { int bracket = TextUtilities . findMatchingBracket ( buffer , dragStartLine , Math . max ( 0 , dragStartOffset - 1 ) ) ; if ( bracket != - 1 ) { if ( bracket < caret ) { addToSelection ( new Selection . Range ( bracket , caret ) ) ; } else { addToSelection ( new Selection . Range ( caret - 1 , ++ bracket ) ) ; } moveCaretPosition ( bracket , false ) ; return ; } } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } String lineText = getLineText ( dragStartLine ) ; String noWordSep = ( String ) buffer . getProperty ( "noWordSep" ) ; if ( dragStartOffset == getLineLength ( dragStartLine ) ) dragStartOffset -- ; int wordStart = TextUtilities . findWordStart ( lineText , dragStartOffset , noWordSep ) ; int wordEnd = TextUtilities . findWordEnd ( lineText , dragStartOffset + 1 , noWordSep ) ; int lineStart = getLineStartOffset ( dragStartLine ) ; addToSelection ( new Selection . Range ( lineStart + wordStart , lineStart + wordEnd ) ) ; moveCaretPosition ( lineStart + wordEnd , false ) ; } private void doTripleClick ( MouseEvent evt ) { int newCaret = getLineEndOffset ( dragStartLine ) ; addToSelection ( new Selection . Range ( getLineStartOffset ( dragStartLine ) , newCaret ) ) ; moveCaretPosition ( newCaret ) ; } public void mouseDragged ( MouseEvent evt ) { if ( GUIUtilities . isPopupTrigger ( evt ) || ( popup != null && popup . isVisible ( ) ) ) return ; boolean rect = evt . isControlDown ( ) ; switch ( clickCount ) { case 1 : doSingleDrag ( evt , rect ) ; break ; case 2 : doDoubleDrag ( evt , rect ) ; break ; default : doTripleDrag ( evt , rect ) ; break ; } } public void mouseMoved ( MouseEvent evt ) { } private void doSingleDrag ( MouseEvent evt , boolean rect ) { int dot = xyToOffset ( evt . getX ( ) , evt . getY ( ) , ! painter . isBlockCaretEnabled ( ) ) ; if ( dot == caret ) return ; resizeSelection ( dragStart , dot , rect ) ; moveCaretPosition ( dot , false ) ; } private void doDoubleDrag ( MouseEvent evt , boolean rect ) { int markLineStart = getLineStartOffset ( dragStartLine ) ; int markLineLength = getLineLength ( dragStartLine ) ; int mark = dragStartOffset ; int line = buffer . virtualToPhysical ( yToLine ( evt . getY ( ) ) ) ; int lineStart = getLineStartOffset ( line ) ; int lineLength = getLineLength ( line ) ; int offset = xToOffset ( line , evt . getX ( ) ) ; String lineText = getLineText ( line ) ; String markLineText = getLineText ( dragStartLine ) ; String noWordSep = ( String ) buffer . getProperty ( "noWordSep" ) ; if ( markLineStart + dragStartOffset > lineStart + offset ) { if ( offset != 0 && offset != lineLength ) { offset = TextUtilities . findWordStart ( lineText , offset , noWordSep ) ; } if ( markLineLength != 0 ) { mark = TextUtilities . findWordEnd ( markLineText , mark , noWordSep ) ; } } else { if ( offset != 0 && lineLength != 0 ) { offset = TextUtilities . findWordEnd ( lineText , offset , noWordSep ) ; } if ( mark != 0 && mark != markLineLength ) { mark = TextUtilities . findWordStart ( markLineText , mark , noWordSep ) ; } } if ( lineStart + offset == caret ) return ; resizeSelection ( markLineStart + mark , lineStart + offset , rect ) ; moveCaretPosition ( lineStart + offset , false ) ; } private void doTripleDrag ( MouseEvent evt , boolean rect ) { int mouseLine = buffer . virtualToPhysical ( yToLine ( evt . getY ( ) ) ) ; int offset = xToOffset ( mouseLine , evt . getX ( ) ) ; int mark ; int mouse ; if ( dragStartLine > mouseLine ) { mark = getLineEndOffset ( dragStartLine ) - 1 ; if ( offset == getLineLength ( mouseLine ) ) mouse = getLineEndOffset ( mouseLine ) - 1 ; else mouse = getLineStartOffset ( mouseLine ) ; } else { mark = getLineStartOffset ( dragStartLine ) ; if ( offset == 0 ) mouse = getLineStartOffset ( mouseLine ) ; else mouse = getLineEndOffset ( mouseLine ) - 1 ; } if ( mouse == caret ) return ; resizeSelection ( mark , mouse , rect ) ; moveCaretPosition ( mouse , false ) ; } } static class CaretUndo extends AbstractUndoableEdit { private int caret ; CaretUndo ( int caret ) { this . caret = caret ; } public boolean isSignificant ( ) { return false ; } public String getPresentationName ( ) { return "caret move" ; } public void undo ( ) throws CannotUndoException { super . undo ( ) ; if ( focusedComponent != null ) { int length = focusedComponent . getBuffer ( ) . getLength ( ) ; if ( caret <= length ) { focusedComponent . selectNone ( ) ; focusedComponent . setCaretPosition ( caret ) ; } else Log . log ( Log . WARNING , this , caret + " > " + length + "??!!" ) ; } } public boolean addEdit ( UndoableEdit edit ) { if ( edit instanceof CaretUndo ) { edit . die ( ) ; return true ; } else return false ; } public String toString ( ) { return getPresentationName ( ) + "[caret=" + caret + "]" ; } } static { caretTimer = new Timer ( 500 , new CaretBlinker ( ) ) ; caretTimer . setInitialDelay ( 500 ) ; caretTimer . start ( ) ; } } 	1	['211', '4', '0', '59', '430', '11469', '40', '39', '169', '0.883277962', '7612', '0.906976744', '10', '0.755555556', '0.084391534', '3', '9', '34.87203791', '25', '3.0521', '45']
package gnu . regexp ; import java . io . Serializable ; class CharIndexedString implements CharIndexed , Serializable { private String s ; private int anchor ; private int len ; CharIndexedString ( String str , int index ) { s = str ; len = s . length ( ) ; anchor = index ; } public char charAt ( int index ) { int pos = anchor + index ; return ( ( pos < len ) && ( pos >= 0 ) ) ? s . charAt ( pos ) : OUT_OF_BOUNDS ; } public boolean isValid ( ) { return ( anchor < len ) ; } public boolean move ( int index ) { return ( ( anchor += index ) < len ) ; } } 	0	['4', '1', '0', '2', '7', '0', '1', '1', '3', '0.222222222', '62', '1', '0', '0', '0.666666667', '0', '0', '13.75', '3', '1.75', '0']
package org . gjt . sp . jedit ; import gnu . regexp . REException ; import javax . swing . * ; import java . awt . * ; import java . awt . event . * ; import java . io . File ; import java . net . * ; import java . util . Hashtable ; import java . util . StringTokenizer ; import org . gjt . sp . jedit . browser . * ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . io . VFS ; import org . gjt . sp . jedit . msg . PropertiesChanged ; import org . gjt . sp . jedit . syntax . SyntaxStyle ; import org . gjt . sp . jedit . syntax . Token ; import org . gjt . sp . util . Log ; public class GUIUtilities { public static final Icon NEW_BUFFER_ICON ; public static final Icon DIRTY_BUFFER_ICON ; public static final Icon READ_ONLY_BUFFER_ICON ; public static final Icon NORMAL_BUFFER_ICON ; public static final Icon EDITOR_WINDOW_ICON ; public static final Icon PLUGIN_WINDOW_ICON ; public static JMenuBar loadMenuBar ( String name ) { String menus = jEdit . getProperty ( name ) ; StringTokenizer st = new StringTokenizer ( menus ) ; JMenuBar mbar = new JMenuBar ( ) ; while ( st . hasMoreTokens ( ) ) mbar . add ( GUIUtilities . loadMenu ( st . nextToken ( ) ) ) ; return mbar ; } public static JMenu loadMenu ( String name ) { if ( name . equals ( "open-encoding" ) ) return new OpenWithEncodingMenu ( ) ; else if ( name . equals ( "recent-files" ) ) return new RecentFilesMenu ( ) ; else if ( name . equals ( "current-directory" ) ) return new CurrentDirectoryMenu ( ) ; else if ( name . equals ( "markers" ) ) return new MarkersMenu ( ) ; else if ( name . equals ( "macros" ) ) return new MacrosMenu ( ) ; else if ( name . equals ( "plugins" ) ) return new PluginsMenu ( ) ; else return new EnhancedMenu ( name ) ; } public static JPopupMenu loadPopupMenu ( String name ) { JPopupMenu menu = new JPopupMenu ( ) ; String menuItems = jEdit . getProperty ( name ) ; if ( menuItems != null ) { StringTokenizer st = new StringTokenizer ( menuItems ) ; while ( st . hasMoreTokens ( ) ) { String menuItemName = st . nextToken ( ) ; if ( menuItemName . equals ( "-" ) ) menu . addSeparator ( ) ; else { if ( menuItemName . startsWith ( "%" ) ) menu . add ( loadMenu ( menuItemName . substring ( 1 ) ) ) ; else menu . add ( loadMenuItem ( menuItemName , false ) ) ; } } } return menu ; } public static JMenuItem loadMenuItem ( String name ) { return loadMenuItem ( name , true ) ; } public static JMenuItem loadMenuItem ( String name , boolean setMnemonic ) { String label ; EditAction action ; if ( name . startsWith ( "play-macro@" ) ) { Macros . Macro macro = Macros . getMacro ( name . substring ( 11 ) ) ; if ( macro != null ) { label = macro . name ; int index = label . lastIndexOf ( '/' ) ; label = label . substring ( index + 1 ) . replace ( '_' , ' ' ) ; action = macro . action ; } else { label = name . substring ( 11 ) ; action = null ; } } else { action = jEdit . getAction ( name ) ; label = jEdit . getProperty ( name . concat ( ".label" ) ) ; if ( label == null ) label = name ; } char mnemonic ; int index = label . indexOf ( '$' ) ; if ( index != - 1 && label . length ( ) - index > 1 ) { mnemonic = Character . toLowerCase ( label . charAt ( index + 1 ) ) ; label = label . substring ( 0 , index ) . concat ( label . substring ( ++ index ) ) ; } else mnemonic = '\0' ; JMenuItem mi ; if ( action != null && action . isToggle ( ) ) mi = new EnhancedCheckBoxMenuItem ( label , action ) ; else mi = new EnhancedMenuItem ( label , action ) ; if ( setMnemonic && mnemonic != '\0' ) mi . setMnemonic ( mnemonic ) ; return mi ; } public static JToolBar loadToolBar ( String name ) { JToolBar toolBar = new JToolBar ( ) ; toolBar . setFloatable ( false ) ; toolBar . putClientProperty ( "JToolBar.isRollover" , Boolean . TRUE ) ; String buttons = jEdit . getProperty ( name ) ; if ( buttons != null ) { StringTokenizer st = new StringTokenizer ( buttons ) ; while ( st . hasMoreTokens ( ) ) { String button = st . nextToken ( ) ; if ( button . equals ( "-" ) ) toolBar . addSeparator ( ) ; else { JButton b = loadToolButton ( button ) ; if ( b != null ) toolBar . add ( b ) ; } } } return toolBar ; } public static EnhancedButton loadToolButton ( String name ) { String label ; EditAction action ; if ( name . startsWith ( "play-macro@" ) ) { Macros . Macro macro = Macros . getMacro ( name . substring ( 11 ) ) ; if ( macro != null ) { label = macro . name ; int index = label . lastIndexOf ( '/' ) ; label = label . substring ( index + 1 ) . replace ( '_' , ' ' ) ; action = macro . action ; } else { label = name . substring ( 11 ) ; action = null ; } } else { action = jEdit . getAction ( name ) ; label = jEdit . getProperty ( name . concat ( ".label" ) ) ; if ( label == null ) label = name ; else label = prettifyMenuLabel ( label ) ; } Icon icon ; String iconName = jEdit . getProperty ( name + ".icon" ) ; if ( iconName != null ) { icon = loadIcon ( iconName ) ; if ( icon == null ) return null ; } else return null ; String toolTip = label ; String shortcut = jEdit . getProperty ( name + ".shortcut" ) ; if ( shortcut != null ) toolTip = toolTip + " (" + shortcut + ")" ; return new EnhancedButton ( icon , toolTip , action ) ; } public static Icon loadIcon ( String iconName ) { Icon icon = ( Icon ) icons . get ( iconName ) ; if ( icon != null ) return icon ; if ( iconName . startsWith ( "file:" ) ) { icon = new ImageIcon ( iconName . substring ( 5 ) ) ; } else { URL url = GUIUtilities . class . getResource ( "/org/gjt/sp/jedit/icons/" + iconName ) ; if ( url == null ) { Log . log ( Log . ERROR , GUIUtilities . class , "Icon not found: " + iconName ) ; return null ; } icon = new ImageIcon ( url ) ; } icons . put ( iconName , icon ) ; return icon ; } public static String prettifyMenuLabel ( String label ) { int index = label . indexOf ( '$' ) ; if ( index != - 1 ) { label = label . substring ( 0 , index ) . concat ( label . substring ( index + 1 ) ) ; } return label ; } public static void message ( Component comp , String name , Object [ ] args ) { hideSplashScreen ( ) ; JOptionPane . showMessageDialog ( comp , jEdit . getProperty ( name . concat ( ".message" ) , args ) , jEdit . getProperty ( name . concat ( ".title" ) , args ) , JOptionPane . INFORMATION_MESSAGE ) ; } public static void error ( Component comp , String name , Object [ ] args ) { hideSplashScreen ( ) ; JOptionPane . showMessageDialog ( comp , jEdit . getProperty ( name . concat ( ".message" ) , args ) , jEdit . getProperty ( name . concat ( ".title" ) , args ) , JOptionPane . ERROR_MESSAGE ) ; } public static String input ( Component comp , String name , Object def ) { return input ( comp , name , null , def ) ; } public static String inputProperty ( Component comp , String name , String def ) { return inputProperty ( comp , name , null , def ) ; } public static String input ( Component comp , String name , Object [ ] args , Object def ) { hideSplashScreen ( ) ; String retVal = ( String ) JOptionPane . showInputDialog ( comp , jEdit . getProperty ( name . concat ( ".message" ) , args ) , jEdit . getProperty ( name . concat ( ".title" ) ) , JOptionPane . QUESTION_MESSAGE , null , null , def ) ; return retVal ; } public static String inputProperty ( Component comp , String name , Object [ ] args , String def ) { hideSplashScreen ( ) ; String retVal = ( String ) JOptionPane . showInputDialog ( comp , jEdit . getProperty ( name . concat ( ".message" ) , args ) , jEdit . getProperty ( name . concat ( ".title" ) ) , JOptionPane . QUESTION_MESSAGE , null , null , jEdit . getProperty ( def ) ) ; if ( retVal != null ) jEdit . setProperty ( def , retVal ) ; return retVal ; } public static int confirm ( Component comp , String name , Object [ ] args , int buttons , int type ) { hideSplashScreen ( ) ; return JOptionPane . showConfirmDialog ( comp , jEdit . getProperty ( name + ".message" , args ) , jEdit . getProperty ( name + ".title" ) , buttons , type ) ; } public static String [ ] showVFSFileDialog ( View view , String path , int type , boolean multipleSelection ) { VFSFileChooserDialog fileChooser = new VFSFileChooserDialog ( view , path , type , multipleSelection ) ; String [ ] selectedFiles = fileChooser . getSelectedFiles ( ) ; if ( selectedFiles == null ) return null ; return selectedFiles ; } public static Color parseColor ( String name ) { return parseColor ( name , Color . black ) ; } public static Color parseColor ( String name , Color defaultColor ) { if ( name == null ) return defaultColor ; else if ( name . startsWith ( "#" ) ) { try { return Color . decode ( name ) ; } catch ( NumberFormatException nf ) { return defaultColor ; } } else if ( "red" . equals ( name ) ) return Color . red ; else if ( "green" . equals ( name ) ) return Color . green ; else if ( "blue" . equals ( name ) ) return Color . blue ; else if ( "yellow" . equals ( name ) ) return Color . yellow ; else if ( "orange" . equals ( name ) ) return Color . orange ; else if ( "white" . equals ( name ) ) return Color . white ; else if ( "lightGray" . equals ( name ) ) return Color . lightGray ; else if ( "gray" . equals ( name ) ) return Color . gray ; else if ( "darkGray" . equals ( name ) ) return Color . darkGray ; else if ( "black" . equals ( name ) ) return Color . black ; else if ( "cyan" . equals ( name ) ) return Color . cyan ; else if ( "magenta" . equals ( name ) ) return Color . magenta ; else if ( "pink" . equals ( name ) ) return Color . pink ; else return defaultColor ; } public static String getColorHexString ( Color c ) { String colString = Integer . toHexString ( c . getRGB ( ) & 0xffffff ) ; return "#000000" . substring ( 0 , 7 - colString . length ( ) ) . concat ( colString ) ; } public static SyntaxStyle parseStyle ( String str , String family , int size ) throws IllegalArgumentException { Color fgColor = Color . black ; Color bgColor = null ; boolean italic = false ; boolean bold = false ; StringTokenizer st = new StringTokenizer ( str ) ; while ( st . hasMoreTokens ( ) ) { String s = st . nextToken ( ) ; if ( s . startsWith ( "color:" ) ) { fgColor = GUIUtilities . parseColor ( s . substring ( 6 ) , Color . black ) ; } else if ( s . startsWith ( "bgColor:" ) ) { bgColor = GUIUtilities . parseColor ( s . substring ( 8 ) , null ) ; } else if ( s . startsWith ( "style:" ) ) { for ( int i = 6 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == 'i' ) italic = true ; else if ( s . charAt ( i ) == 'b' ) bold = true ; else throw new IllegalArgumentException ( "Invalid style: " + s ) ; } } else throw new IllegalArgumentException ( "Invalid directive: " + s ) ; } return new SyntaxStyle ( fgColor , bgColor , new Font ( family , ( italic ? Font . ITALIC : 0 ) | ( bold ? Font . BOLD : 0 ) , size ) ) ; } public static String getStyleString ( SyntaxStyle style ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "color:" + getColorHexString ( style . getForegroundColor ( ) ) ) ; if ( style . getBackgroundColor ( ) != null ) { buf . append ( " bgColor:" + getColorHexString ( style . getBackgroundColor ( ) ) ) ; } if ( ! style . getFont ( ) . isPlain ( ) ) { buf . append ( " style:" + ( style . getFont ( ) . isItalic ( ) ? "i" : "" ) + ( style . getFont ( ) . isBold ( ) ? "b" : "" ) ) ; } return buf . toString ( ) ; } public static SyntaxStyle [ ] loadStyles ( String family , int size ) { SyntaxStyle [ ] styles = new SyntaxStyle [ Token . ID_COUNT ] ; try { styles [ Token . COMMENT1 ] = GUIUtilities . parseStyle ( jEdit . getProperty ( "view.style.comment1" ) , family , size ) ; styles [ Token . COMMENT2 ] = GUIUtilities . parseStyle ( jEdit . getProperty ( "view.style.comment2" ) , family , size ) ; styles [ Token . LITERAL1 ] = GUIUtilities . parseStyle ( jEdit . getProperty ( "view.style.literal1" ) , family , size ) ; styles [ Token . LITERAL2 ] = GUIUtilities . parseStyle ( jEdit . getProperty ( "view.style.literal2" ) , family , size ) ; styles [ Token . LABEL ] = GUIUtilities . parseStyle ( jEdit . getProperty ( "view.style.label" ) , family , size ) ; styles [ Token . KEYWORD1 ] = GUIUtilities . parseStyle ( jEdit . getProperty ( "view.style.keyword1" ) , family , size ) ; styles [ Token . KEYWORD2 ] = GUIUtilities . parseStyle ( jEdit . getProperty ( "view.style.keyword2" ) , family , size ) ; styles [ Token . KEYWORD3 ] = GUIUtilities . parseStyle ( jEdit . getProperty ( "view.style.keyword3" ) , family , size ) ; styles [ Token . FUNCTION ] = GUIUtilities . parseStyle ( jEdit . getProperty ( "view.style.function" ) , family , size ) ; styles [ Token . MARKUP ] = GUIUtilities . parseStyle ( jEdit . getProperty ( "view.style.markup" ) , family , size ) ; styles [ Token . OPERATOR ] = GUIUtilities . parseStyle ( jEdit . getProperty ( "view.style.operator" ) , family , size ) ; styles [ Token . DIGIT ] = GUIUtilities . parseStyle ( jEdit . getProperty ( "view.style.digit" ) , family , size ) ; styles [ Token . INVALID ] = GUIUtilities . parseStyle ( jEdit . getProperty ( "view.style.invalid" ) , family , size ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , GUIUtilities . class , e ) ; } return styles ; } public static void loadGeometry ( Window win , String name ) { int x , y , width , height , adjust_x , adjust_y , adjust_width , adjust_height ; try { width = Integer . parseInt ( jEdit . getProperty ( name + ".width" ) ) ; height = Integer . parseInt ( jEdit . getProperty ( name + ".height" ) ) ; } catch ( NumberFormatException nf ) { Dimension size = win . getSize ( ) ; width = size . width ; height = size . height ; } try { x = Integer . parseInt ( jEdit . getProperty ( name + ".x" ) ) ; y = Integer . parseInt ( jEdit . getProperty ( name + ".y" ) ) ; } catch ( NumberFormatException nf ) { Component parent = win . getParent ( ) ; if ( parent == null ) { Dimension screen = win . getToolkit ( ) . getScreenSize ( ) ; x = ( screen . width - width ) / 2 ; y = ( screen . height - height ) / 2 ; } else { Rectangle bounds = parent . getBounds ( ) ; x = bounds . x + ( bounds . width - width ) / 2 ; y = bounds . y + ( bounds . height - height ) / 2 ; } } try { adjust_x = Integer . parseInt ( jEdit . getProperty ( name + ".dx" ) ) ; adjust_y = Integer . parseInt ( jEdit . getProperty ( name + ".dy" ) ) ; adjust_width = Integer . parseInt ( jEdit . getProperty ( name + ".d-width" ) ) ; adjust_height = Integer . parseInt ( jEdit . getProperty ( name + ".d-height" ) ) ; } catch ( NumberFormatException nf ) { adjust_x = adjust_y = 0 ; adjust_width = adjust_height = 0 ; } Rectangle desired = new Rectangle ( x , y , width , height ) ; Rectangle required = new Rectangle ( x - adjust_x , y - adjust_y , width - adjust_width , height - adjust_height ) ; win . setBounds ( required ) ; if ( File . separatorChar == '/' && System . getProperty ( "java.version" ) . compareTo ( "1.2" ) < 0 ) { win . setBounds ( required ) ; new UnixWorkaround ( win , name , desired , required ) ; } else win . setBounds ( desired ) ; } static class UnixWorkaround { Window win ; String name ; Rectangle desired ; Rectangle required ; long start ; boolean windowOpened ; UnixWorkaround ( Window win , String name , Rectangle desired , Rectangle required ) { this . win = win ; this . name = name ; this . desired = desired ; this . required = required ; start = System . currentTimeMillis ( ) ; win . addComponentListener ( new ComponentHandler ( ) ) ; win . addWindowListener ( new WindowHandler ( ) ) ; } class ComponentHandler extends ComponentAdapter { public void componentMoved ( ComponentEvent evt ) { if ( System . currentTimeMillis ( ) - start < 1000 ) { Rectangle r = win . getBounds ( ) ; if ( ! windowOpened && r . equals ( required ) ) return ; if ( ! r . equals ( desired ) ) { win . setBounds ( desired ) ; } } else win . removeComponentListener ( this ) ; } public void componentResized ( ComponentEvent evt ) { if ( System . currentTimeMillis ( ) - start < 1000 ) { Rectangle r = win . getBounds ( ) ; if ( ! windowOpened && r . equals ( required ) ) return ; if ( ! r . equals ( desired ) ) { win . setBounds ( desired ) ; } } else win . removeComponentListener ( this ) ; } } class WindowHandler extends WindowAdapter { public void windowOpened ( WindowEvent evt ) { windowOpened = true ; Rectangle r = win . getBounds ( ) ; if ( r . x != desired . x || r . y != desired . y || r . width != desired . width || r . height != desired . height ) { jEdit . setProperty ( name + ".dx" , String . valueOf ( r . x - required . x ) ) ; jEdit . setProperty ( name + ".dy" , String . valueOf ( r . y - required . y ) ) ; jEdit . setProperty ( name + ".d-width" , String . valueOf ( r . width - required . width ) ) ; jEdit . setProperty ( name + ".d-height" , String . valueOf ( r . height - required . height ) ) ; } win . removeWindowListener ( this ) ; } } } public static void saveGeometry ( Window win , String name ) { Rectangle bounds = win . getBounds ( ) ; jEdit . setProperty ( name + ".x" , String . valueOf ( bounds . x ) ) ; jEdit . setProperty ( name + ".y" , String . valueOf ( bounds . y ) ) ; jEdit . setProperty ( name + ".width" , String . valueOf ( bounds . width ) ) ; jEdit . setProperty ( name + ".height" , String . valueOf ( bounds . height ) ) ; } public static void hideSplashScreen ( ) { if ( splash != null ) { splash . dispose ( ) ; splash = null ; } } public static Image getEditorIcon ( ) { return ( ( ImageIcon ) EDITOR_WINDOW_ICON ) . getImage ( ) ; } public static Image getPluginIcon ( ) { return ( ( ImageIcon ) PLUGIN_WINDOW_ICON ) . getImage ( ) ; } public static void requestFocus ( final Window win , final Component comp ) { win . addWindowListener ( new WindowAdapter ( ) { public void windowActivated ( WindowEvent evt ) { comp . requestFocus ( ) ; win . removeWindowListener ( this ) ; } } ) ; } public static boolean isPopupTrigger ( MouseEvent evt ) { if ( macOS ) return evt . isControlDown ( ) ; else return ( ( evt . getModifiers ( ) & InputEvent . BUTTON3_MASK ) != 0 ) ; } public static JMenu loadMenu ( View view , String name ) { return loadMenu ( name ) ; } public static JMenuItem loadMenuItem ( View view , String name ) { return loadMenuItem ( name , true ) ; } public static Icon loadToolBarIcon ( String iconName ) { return loadIcon ( iconName ) ; } public static String showFileDialog ( View view , String file , int type ) { if ( file == null ) file = System . getProperty ( "user.dir" ) ; File _file = new File ( file ) ; JFileChooser chooser = new JFileChooser ( ) ; chooser . setCurrentDirectory ( _file ) ; if ( _file . isDirectory ( ) ) chooser . setSelectedFile ( null ) ; else chooser . setSelectedFile ( _file ) ; chooser . setDialogType ( type ) ; chooser . setFileSelectionMode ( JFileChooser . FILES_ONLY ) ; int retVal = chooser . showDialog ( view , null ) ; if ( retVal == JFileChooser . APPROVE_OPTION ) { File selectedFile = chooser . getSelectedFile ( ) ; if ( selectedFile != null ) return selectedFile . getAbsolutePath ( ) ; } return null ; } static void showSplashScreen ( ) { splash = new SplashScreen ( ) ; } static void advanceSplashProgress ( ) { if ( splash != null ) splash . advance ( ) ; } private static SplashScreen splash ; private static boolean macOS ; private static Hashtable icons ; private GUIUtilities ( ) { } static { macOS = ( System . getProperty ( "os.name" ) . indexOf ( "MacOS" ) != - 1 ) ; icons = new Hashtable ( ) ; NEW_BUFFER_ICON = loadIcon ( "new.gif" ) ; DIRTY_BUFFER_ICON = loadIcon ( "dirty.gif" ) ; READ_ONLY_BUFFER_ICON = loadIcon ( "readonly.gif" ) ; NORMAL_BUFFER_ICON = loadIcon ( "normal.gif" ) ; EDITOR_WINDOW_ICON = loadIcon ( "jedit_icon1.gif" ) ; PLUGIN_WINDOW_ICON = loadIcon ( "jedit_icon2.gif" ) ; } } 	1	['39', '1', '0', '70', '144', '725', '58', '21', '34', '0.955263158', '1492', '0.4', '1', '0', '0.135964912', '0', '0', '37', '16', '2.6923', '8']
package org . gjt . sp . jedit . gui ; import javax . swing . border . * ; import javax . swing . plaf . metal . MetalLookAndFeel ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . * ; public interface DockableWindowContainer { void addDockableWindow ( DockableWindow win ) ; void saveDockableWindow ( DockableWindow win ) ; void removeDockableWindow ( DockableWindow win ) ; void showDockableWindow ( DockableWindow win ) ; boolean isDockableWindowVisible ( DockableWindow win ) ; public class TabbedPane extends JTabbedPane implements DockableWindowContainer { public static final int SPLITTER_WIDTH = 10 ; String position ; int dimension ; boolean collapsed ; public TabbedPane ( String position ) { this . position = position ; try { dimension = Integer . parseInt ( jEdit . getProperty ( "view.dock." + position + ".dimension" ) ) ; } catch ( NumberFormatException nf ) { dimension = - 1 ; } if ( dimension <= SPLITTER_WIDTH ) collapsed = true ; collapsed = jEdit . getBooleanProperty ( "view.dock." + position + ".collapsed" ) ; MouseHandler mouseHandler = new MouseHandler ( ) ; addMouseListener ( mouseHandler ) ; addMouseMotionListener ( mouseHandler ) ; propertiesChanged ( ) ; } public boolean isCollapsed ( ) { return getComponentCount ( ) == 0 || collapsed ; } public void setCollapsed ( boolean collapsed ) { if ( getComponentCount ( ) == 0 ) return ; if ( dimension <= SPLITTER_WIDTH ) dimension = - 1 ; this . collapsed = collapsed ; revalidate ( ) ; } public void toggleCollapsed ( ) { setCollapsed ( ! collapsed ) ; } public void saveDimension ( ) { jEdit . setProperty ( "view.dock." + position + ".dimension" , String . valueOf ( dimension ) ) ; jEdit . setBooleanProperty ( "view.dock." + position + ".collapsed" , collapsed ) ; } public void propertiesChanged ( ) { setBorder ( new DockBorder ( position ) ) ; int tabsPos = Integer . parseInt ( jEdit . getProperty ( "view.docking.tabsPos" ) ) ; if ( tabsPos == 0 ) setTabPlacement ( JTabbedPane . TOP ) ; else if ( tabsPos == 1 ) setTabPlacement ( JTabbedPane . BOTTOM ) ; } public Dimension getMinimumSize ( ) { return new Dimension ( 0 , 0 ) ; } public Dimension getPreferredSize ( ) { if ( getComponentCount ( ) == 0 ) return new Dimension ( 0 , 0 ) ; Dimension prefSize = super . getPreferredSize ( ) ; if ( collapsed ) { if ( position . equals ( DockableWindowManager . LEFT ) || position . equals ( DockableWindowManager . RIGHT ) ) prefSize . width = SPLITTER_WIDTH ; else if ( position . equals ( DockableWindowManager . TOP ) || position . equals ( DockableWindowManager . BOTTOM ) ) prefSize . height = SPLITTER_WIDTH ; } else if ( dimension <= SPLITTER_WIDTH ) { if ( position . equals ( DockableWindowManager . LEFT ) || position . equals ( DockableWindowManager . RIGHT ) ) dimension = prefSize . width ; else if ( position . equals ( DockableWindowManager . TOP ) || position . equals ( DockableWindowManager . BOTTOM ) ) dimension = prefSize . height ; } else { if ( position . equals ( DockableWindowManager . LEFT ) || position . equals ( DockableWindowManager . RIGHT ) ) prefSize . width = dimension ; else if ( position . equals ( DockableWindowManager . TOP ) || position . equals ( DockableWindowManager . BOTTOM ) ) prefSize . height = dimension ; } return prefSize ; } public void addDockableWindow ( DockableWindow win ) { addTab ( jEdit . getProperty ( win . getName ( ) + ".title" ) , win . getComponent ( ) ) ; setSelectedComponent ( win . getComponent ( ) ) ; collapsed = false ; revalidate ( ) ; } public void saveDockableWindow ( DockableWindow win ) { } public void removeDockableWindow ( DockableWindow win ) { remove ( win . getComponent ( ) ) ; revalidate ( ) ; } public void showDockableWindow ( DockableWindow win ) { setSelectedComponent ( win . getComponent ( ) ) ; if ( collapsed ) { collapsed = false ; revalidate ( ) ; } win . getComponent ( ) . requestFocus ( ) ; } public boolean isDockableWindowVisible ( DockableWindow win ) { return ! collapsed ; } class MouseHandler extends MouseAdapter implements MouseMotionListener { boolean canDrag ; int dragStartDimension ; Point dragStart ; public void mousePressed ( MouseEvent evt ) { dragStartDimension = dimension ; dragStart = evt . getPoint ( ) ; dragStart . x = ( getWidth ( ) - dragStart . x ) ; dragStart . y = ( getHeight ( ) - dragStart . y ) ; } public void mouseClicked ( MouseEvent evt ) { if ( evt . getClickCount ( ) == 2 ) setCollapsed ( ! isCollapsed ( ) ) ; } public void mouseMoved ( MouseEvent evt ) { Border border = getBorder ( ) ; Insets insets = border . getBorderInsets ( TabbedPane . this ) ; int cursor = Cursor . DEFAULT_CURSOR ; canDrag = false ; if ( position . equals ( DockableWindowManager . TOP ) ) { if ( evt . getY ( ) >= getHeight ( ) - insets . bottom ) { cursor = Cursor . N_RESIZE_CURSOR ; canDrag = true ; } } else if ( position . equals ( DockableWindowManager . LEFT ) ) { if ( evt . getX ( ) >= getWidth ( ) - insets . right ) { cursor = Cursor . W_RESIZE_CURSOR ; canDrag = true ; } } else if ( position . equals ( DockableWindowManager . BOTTOM ) ) { if ( evt . getY ( ) <= insets . top ) { cursor = Cursor . S_RESIZE_CURSOR ; canDrag = true ; } } else if ( position . equals ( DockableWindowManager . RIGHT ) ) { if ( evt . getX ( ) <= insets . left ) { cursor = Cursor . E_RESIZE_CURSOR ; canDrag = true ; } } setCursor ( Cursor . getPredefinedCursor ( cursor ) ) ; } public void mouseDragged ( MouseEvent evt ) { if ( ! canDrag ) return ; if ( dragStart == null ) return ; if ( position . equals ( DockableWindowManager . TOP ) ) dimension = evt . getY ( ) + dragStart . y ; else if ( position . equals ( DockableWindowManager . LEFT ) ) dimension = evt . getX ( ) + dragStart . x ; else if ( position . equals ( DockableWindowManager . BOTTOM ) ) { dimension = getHeight ( ) - ( evt . getY ( ) ) ; } else if ( position . equals ( DockableWindowManager . RIGHT ) ) { dimension = getWidth ( ) - ( evt . getX ( ) ) ; } dimension = Math . max ( SPLITTER_WIDTH , dimension ) ; if ( dimension == SPLITTER_WIDTH ) { dimension = dragStartDimension ; collapsed = true ; } else collapsed = false ; revalidate ( ) ; } public void mouseExited ( MouseEvent evt ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; } } static class DockBorder implements Border { String position ; Insets insets ; Color color1 ; Color color2 ; Color color3 ; DockBorder ( String position ) { if ( UIManager . getLookAndFeel ( ) instanceof MetalLookAndFeel ) { color1 = MetalLookAndFeel . getControlHighlight ( ) ; color2 = MetalLookAndFeel . getControlDarkShadow ( ) ; color3 = MetalLookAndFeel . getControl ( ) ; } else { color1 = color2 = null ; color3 = GUIUtilities . parseColor ( jEdit . getProperty ( "view.docking.borderColor" ) ) ; } this . position = position ; insets = new Insets ( position . equals ( DockableWindowManager . BOTTOM ) ? SPLITTER_WIDTH : 0 , position . equals ( DockableWindowManager . RIGHT ) ? SPLITTER_WIDTH : 0 , position . equals ( DockableWindowManager . TOP ) ? SPLITTER_WIDTH : 0 , position . equals ( DockableWindowManager . LEFT ) ? SPLITTER_WIDTH : 0 ) ; } public void paintBorder ( Component c , Graphics g , int x , int y , int width , int height ) { if ( position . equals ( DockableWindowManager . BOTTOM ) ) paintHorizBorder ( g , x , y , width ) ; else if ( position . equals ( DockableWindowManager . RIGHT ) ) paintVertBorder ( g , x , y , height ) ; else if ( position . equals ( DockableWindowManager . TOP ) ) { paintHorizBorder ( g , x , y + height - SPLITTER_WIDTH , width ) ; } else if ( position . equals ( DockableWindowManager . LEFT ) ) { paintVertBorder ( g , x + width - SPLITTER_WIDTH , y , height ) ; } } public Insets getBorderInsets ( Component c ) { return insets ; } public boolean isBorderOpaque ( ) { return false ; } private void paintHorizBorder ( Graphics g , int x , int y , int width ) { g . setColor ( color3 ) ; g . fillRect ( x , y , width , SPLITTER_WIDTH ) ; if ( color1 == null || color2 == null ) return ; for ( int i = 0 ; i < width / 4 - 1 ; i ++ ) { g . setColor ( color1 ) ; g . drawLine ( x + i * 4 + 2 , y + 3 , x + i * 4 + 2 , y + 3 ) ; g . setColor ( color2 ) ; g . drawLine ( x + i * 4 + 3 , y + 4 , x + i * 4 + 3 , y + 4 ) ; g . setColor ( color1 ) ; g . drawLine ( x + i * 4 + 4 , y + 5 , x + i * 4 + 4 , y + 5 ) ; g . setColor ( color2 ) ; g . drawLine ( x + i * 4 + 5 , y + 6 , x + i * 4 + 5 , y + 6 ) ; } } private void paintVertBorder ( Graphics g , int x , int y , int height ) { g . setColor ( color3 ) ; g . fillRect ( x , y , SPLITTER_WIDTH , height ) ; if ( color1 == null || color2 == null ) return ; for ( int i = 0 ; i < height / 4 - 1 ; i ++ ) { g . setColor ( color1 ) ; g . drawLine ( x + 3 , y + i * 4 + 2 , x + 3 , y + i * 4 + 2 ) ; g . setColor ( color2 ) ; g . drawLine ( x + 4 , y + i * 4 + 3 , x + 4 , y + i * 4 + 3 ) ; g . setColor ( color1 ) ; g . drawLine ( x + 5 , y + i * 4 + 4 , x + 5 , y + i * 4 + 4 ) ; g . setColor ( color2 ) ; g . drawLine ( x + 6 , y + i * 4 + 5 , x + 6 , y + i * 4 + 5 ) ; } } } } public class Floating extends JFrame implements DockableWindowContainer { public Floating ( DockableWindowManager dockableWindowManager ) { this . dockableWindowManager = dockableWindowManager ; setIconImage ( GUIUtilities . getPluginIcon ( ) ) ; setDefaultCloseOperation ( DISPOSE_ON_CLOSE ) ; } public void addDockableWindow ( DockableWindow window ) { this . window = window ; name = window . getName ( ) ; setTitle ( jEdit . getProperty ( name + ".title" ) ) ; getContentPane ( ) . add ( BorderLayout . CENTER , window . getComponent ( ) ) ; pack ( ) ; GUIUtilities . loadGeometry ( this , name ) ; show ( ) ; } public void saveDockableWindow ( DockableWindow window ) { GUIUtilities . saveGeometry ( this , name ) ; } public void removeDockableWindow ( DockableWindow window ) { super . dispose ( ) ; } public void showDockableWindow ( DockableWindow window ) { toFront ( ) ; requestFocus ( ) ; } public boolean isDockableWindowVisible ( DockableWindow win ) { return true ; } public void dispose ( ) { dockableWindowManager . removeDockableWindow ( name ) ; } private DockableWindowManager dockableWindowManager ; private DockableWindow window ; private String name ; } } 	0	['5', '1', '0', '5', '5', '10', '4', '1', '5', '2', '5', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . gjt . sp . jedit . gui ; import java . awt . event . * ; import java . awt . * ; public class KeyEventWorkaround { public static final int ALT_GRAPH_MASK = 1 << 5 ; public static KeyEvent processKeyEvent ( KeyEvent evt ) { int keyCode = evt . getKeyCode ( ) ; char ch = evt . getKeyChar ( ) ; switch ( evt . getID ( ) ) { case KeyEvent . KEY_PRESSED : if ( keyCode == KeyEvent . VK_CONTROL || keyCode == KeyEvent . VK_SHIFT || keyCode == KeyEvent . VK_ALT || keyCode == KeyEvent . VK_META || keyCode == '\0' ) return null ; if ( ! java14 ) handleBrokenKeys ( evt . getModifiers ( ) , keyCode ) ; return evt ; case KeyEvent . KEY_TYPED : if ( ( ch < 0x20 || ch == 0x7f || ch == 0xff ) && ch != '\b' ) return null ; if ( ( evt . isControlDown ( ) ^ evt . isAltDown ( ) ) || evt . isMetaDown ( ) ) return null ; if ( ! java14 ) { if ( last == LAST_BROKEN && System . currentTimeMillis ( ) - lastKeyTime < 750 && ! Character . isLetter ( ch ) ) { last = LAST_NOTHING ; return null ; } else if ( last == LAST_ALT && System . currentTimeMillis ( ) - lastKeyTime < 750 ) { last = LAST_NOTHING ; return null ; } } return evt ; default : return evt ; } } private static boolean java14 ; private static long lastKeyTime ; private static int last ; private static final int LAST_NOTHING = 0 ; private static final int LAST_ALTGR = 1 ; private static final int LAST_ALT = 2 ; private static final int LAST_BROKEN = 3 ; static { java14 = ( System . getProperty ( "java.version" ) . compareTo ( "1.4" ) >= 0 ) ; } private static void handleBrokenKeys ( int modifiers , int keyCode ) { if ( modifiers == ( KeyEvent . ALT_MASK | KeyEvent . CTRL_MASK ) || modifiers == ( KeyEvent . ALT_MASK | KeyEvent . CTRL_MASK | KeyEvent . SHIFT_MASK ) ) { last = LAST_ALTGR ; return ; } else if ( ( modifiers & ( ~ ( ALT_GRAPH_MASK | KeyEvent . SHIFT_MASK ) ) ) == 0 ) { last = LAST_NOTHING ; return ; } if ( ( modifiers & KeyEvent . ALT_MASK ) != 0 ) last = LAST_ALT ; else if ( ( keyCode < KeyEvent . VK_A || keyCode > KeyEvent . VK_Z ) && keyCode != KeyEvent . VK_LEFT && keyCode != KeyEvent . VK_RIGHT && keyCode != KeyEvent . VK_UP && keyCode != KeyEvent . VK_DOWN && keyCode != KeyEvent . VK_DELETE && keyCode != KeyEvent . VK_BACK_SPACE && keyCode != KeyEvent . VK_TAB && keyCode != KeyEvent . VK_ENTER ) last = LAST_BROKEN ; else last = LAST_NOTHING ; lastKeyTime = System . currentTimeMillis ( ) ; } } 	1	['4', '1', '0', '5', '16', '2', '5', '0', '2', '1.083333333', '179', '0.875', '0', '0', '0.333333333', '0', '0', '41.75', '20', '8.75', '5']
package org . gjt . sp . jedit . textarea ; import java . awt . * ; class TextRendererAWT extends TextRenderer { float _drawChars ( char [ ] text , int start , int len , Graphics g , float x , float y ) { g . drawChars ( text , start , len , ( int ) x , ( int ) y ) ; return ( float ) g . getFontMetrics ( ) . charsWidth ( text , start , len ) ; } float _getWidth ( char [ ] text , int start , int len , Font font ) { return ( float ) Toolkit . getDefaultToolkit ( ) . getFontMetrics ( font ) . charsWidth ( text , start , len ) ; } int _xToOffset ( char [ ] text , int start , int len , Font font , float x , boolean round ) { int end = start + len ; FontMetrics fm = Toolkit . getDefaultToolkit ( ) . getFontMetrics ( font ) ; int width = 0 ; for ( int i = start ; i < end ; i ++ ) { int newWidth = fm . charWidth ( text [ i ] ) ; if ( x <= width + newWidth ) { if ( round && ( x - width ) < ( width + newWidth - x ) ) return i - start ; else return i + 1 - start ; } else width += newWidth ; } return - 1 ; } } 	0	['4', '2', '0', '1', '11', '6', '1', '1', '0', '2', '93', '0', '0', '0.785714286', '0.571428571', '1', '2', '22.25', '5', '1.75', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import javax . swing . border . * ; import javax . swing . event . * ; import java . awt . * ; import java . awt . event . * ; import java . util . Vector ; import org . gjt . sp . jedit . * ; public class PastePrevious extends EnhancedDialog implements ActionListener , ListSelectionListener , MouseListener { public PastePrevious ( View view ) { super ( view , jEdit . getProperty ( "pasteprev.title" ) , true ) ; this . view = view ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; clipHistory = HistoryModel . getModel ( "clipboard" ) ; clips = new JList ( new AbstractListModel ( ) { public int getSize ( ) { return clipHistory . getSize ( ) ; } public Object getElementAt ( int index ) { return clipHistory . getItem ( index ) ; } } ) ; clips . setVisibleRowCount ( 16 ) ; clips . addMouseListener ( this ) ; clips . addListSelectionListener ( this ) ; insert = new JButton ( jEdit . getProperty ( "pasteprev.insert" ) ) ; cancel = new JButton ( jEdit . getProperty ( "common.cancel" ) ) ; JLabel label = new JLabel ( jEdit . getProperty ( "pasteprev.caption" ) ) ; label . setBorder ( new EmptyBorder ( 0 , 0 , 6 , 0 ) ) ; content . add ( BorderLayout . NORTH , label ) ; JScrollPane scroller = new JScrollPane ( clips ) ; Dimension dim = scroller . getPreferredSize ( ) ; scroller . setPreferredSize ( new Dimension ( 640 , dim . height ) ) ; content . add ( scroller , BorderLayout . CENTER ) ; JPanel panel = new JPanel ( ) ; panel . setLayout ( new BoxLayout ( panel , BoxLayout . X_AXIS ) ) ; panel . setBorder ( new EmptyBorder ( 12 , 0 , 0 , 0 ) ) ; panel . add ( Box . createGlue ( ) ) ; panel . add ( insert ) ; panel . add ( Box . createHorizontalStrut ( 6 ) ) ; panel . add ( cancel ) ; panel . add ( Box . createGlue ( ) ) ; content . add ( panel , BorderLayout . SOUTH ) ; updateButtons ( ) ; getRootPane ( ) . setDefaultButton ( insert ) ; insert . addActionListener ( this ) ; cancel . addActionListener ( this ) ; GUIUtilities . requestFocus ( this , clips ) ; pack ( ) ; setLocationRelativeTo ( view ) ; show ( ) ; } public void ok ( ) { int selected = clips . getSelectedIndex ( ) ; if ( selected == - 1 ) { view . getToolkit ( ) . beep ( ) ; return ; } String clip = clipHistory . getItem ( selected ) ; view . getTextArea ( ) . setSelectedText ( clip ) ; dispose ( ) ; } public void cancel ( ) { dispose ( ) ; } public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == insert ) ok ( ) ; else if ( source == cancel ) cancel ( ) ; } public void mouseClicked ( MouseEvent evt ) { if ( evt . getClickCount ( ) == 2 ) ok ( ) ; } public void mouseEntered ( MouseEvent evt ) { } public void mouseExited ( MouseEvent evt ) { } public void mousePressed ( MouseEvent evt ) { } public void mouseReleased ( MouseEvent evt ) { } public void valueChanged ( ListSelectionEvent evt ) { updateButtons ( ) ; } private View view ; private JList clips ; private HistoryModel clipHistory ; private JButton insert ; private JButton cancel ; private void updateButtons ( ) { int selected = clips . getSelectedIndex ( ) ; insert . setEnabled ( selected != - 1 ) ; } } 	1	['12', '7', '0', '7', '57', '52', '1', '7', '10', '0.709090909', '279', '1', '2', '0.983433735', '0.277777778', '0', '0', '21.83333333', '3', '1.3333', '1']
package bsh ; import java . util . Hashtable ; import java . lang . reflect . InvocationTargetException ; class BSHLHSPrimarySuffix extends SimpleNode { public static final int INDEX = 1 , NAME = 2 , PROPERTY = 3 ; public int operation ; Object index ; public String field ; public String method ; BSHLHSPrimarySuffix ( int id ) { super ( id ) ; } public LHS doLHSSuffix ( Object obj , CallStack callstack , Interpreter interpreter ) throws EvalError { try { switch ( operation ) { case INDEX : return doIndex ( obj , callstack , interpreter ) ; case NAME : return doName ( obj , callstack , interpreter ) ; case PROPERTY : return doProperty ( obj , callstack , interpreter ) ; default : throw new InterpreterError ( "LHS suffix" ) ; } } catch ( ReflectError e ) { throw new EvalError ( "reflection error: " + e , this ) ; } catch ( InvocationTargetException e ) { throw new TargetError ( e . getTargetException ( ) , this ) ; } } private LHS doName ( Object obj , CallStack callstack , Interpreter interpreter ) throws EvalError , ReflectError , InvocationTargetException { if ( jjtGetNumChildren ( ) == 0 ) return Reflect . getLHSObjectField ( obj , field ) ; else { Object [ ] oa = ( ( BSHArguments ) jjtGetChild ( 0 ) ) . getArguments ( callstack , interpreter ) ; try { obj = Reflect . invokeObjectMethod ( interpreter , obj , method , oa , this ) ; } catch ( EvalError ee ) { throw new EvalError ( ee . getMessage ( ) , this ) ; } return Reflect . getLHSObjectField ( obj , field ) ; } } private LHS doIndex ( Object obj , CallStack callstack , Interpreter interpreter ) throws EvalError , ReflectError { if ( ! obj . getClass ( ) . isArray ( ) ) throw new EvalError ( "Not an array" , this ) ; int index ; try { Primitive val = ( Primitive ) ( ( ( SimpleNode ) jjtGetChild ( 0 ) ) . eval ( callstack , interpreter ) ) ; index = val . intValue ( ) ; } catch ( Exception e ) { throw new EvalError ( "You can only index arrays by integer types" , this ) ; } return new LHS ( obj , index ) ; } private LHS doProperty ( Object obj , CallStack callstack , Interpreter interpreter ) throws EvalError , ReflectError { if ( obj == Primitive . VOID ) throw new EvalError ( "Attempt to access property on a void type" , this ) ; else if ( obj instanceof Primitive ) throw new EvalError ( "Attempt to access property on a primitive" , this ) ; Object value = ( ( SimpleNode ) jjtGetChild ( 0 ) ) . eval ( callstack , interpreter ) ; if ( ! ( value instanceof String ) ) throw new EvalError ( "Property expression must be a String or identifier." , this ) ; Interpreter . debug ( "LHS property access: " ) ; return new LHS ( obj , ( String ) value ) ; } } 	0	['5', '2', '0', '14', '27', '10', '2', '12', '1', '1.071428571', '182', '0', '0', '0.818181818', '0.72', '0', '0', '34', '1', '0.8', '0']
package org . gjt . sp . jedit ; import javax . swing . event . * ; import javax . swing . * ; import java . awt . * ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . io . VFSManager ; import org . gjt . sp . jedit . msg . * ; import org . gjt . sp . jedit . syntax . * ; import org . gjt . sp . jedit . textarea . * ; import org . gjt . sp . util . Log ; public class EditPane extends JPanel implements EBComponent { public View getView ( ) { return view ; } public Buffer getBuffer ( ) { return buffer ; } public void setBuffer ( final Buffer buffer ) { if ( this . buffer == buffer ) return ; if ( buffer . isClosed ( ) ) throw new InternalError ( buffer + " has been closed" ) ; buffer . endCompoundEdit ( ) ; recentBuffer = this . buffer ; if ( recentBuffer != null ) saveCaretInfo ( ) ; this . buffer = buffer ; textArea . setBuffer ( buffer ) ; if ( ! init ) { view . updateTitle ( ) ; if ( bufferSwitcher != null ) { if ( bufferSwitcher . getSelectedItem ( ) != buffer ) bufferSwitcher . setSelectedItem ( buffer ) ; } EditBus . send ( new EditPaneUpdate ( this , EditPaneUpdate . BUFFER_CHANGED ) ) ; } SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { if ( view . getEditPane ( ) == EditPane . this && ( bufferSwitcher == null || ! bufferSwitcher . isPopupVisible ( ) ) ) { focusOnTextArea ( ) ; } } } ) ; Runnable runnable = new Runnable ( ) { public void run ( ) { loadCaretInfo ( ) ; buffer . checkModTime ( view ) ; } } ; if ( buffer . isPerformingIO ( ) ) VFSManager . runInAWTThread ( runnable ) ; else runnable . run ( ) ; } public void prevBuffer ( ) { Buffer buffer = this . buffer . getPrev ( ) ; if ( buffer == null ) setBuffer ( jEdit . getLastBuffer ( ) ) ; else setBuffer ( buffer ) ; } public void nextBuffer ( ) { Buffer buffer = this . buffer . getNext ( ) ; if ( buffer == null ) setBuffer ( jEdit . getFirstBuffer ( ) ) ; else setBuffer ( buffer ) ; } public void recentBuffer ( ) { if ( recentBuffer != null ) setBuffer ( recentBuffer ) ; else getToolkit ( ) . beep ( ) ; } public void focusOnTextArea ( ) { textArea . grabFocus ( ) ; } public JEditTextArea getTextArea ( ) { return textArea ; } public void saveCaretInfo ( ) { buffer . putProperty ( Buffer . CARET , new Integer ( textArea . getCaretPosition ( ) ) ) ; Selection [ ] selection = textArea . getSelection ( ) ; if ( selection != null ) buffer . putProperty ( Buffer . SELECTION , selection ) ; buffer . putProperty ( Buffer . SCROLL_VERT , new Integer ( textArea . getFirstLine ( ) ) ) ; buffer . putProperty ( Buffer . SCROLL_HORIZ , new Integer ( textArea . getHorizontalOffset ( ) ) ) ; } public void loadCaretInfo ( ) { Integer caret = ( Integer ) buffer . getProperty ( Buffer . CARET ) ; Selection [ ] selection = ( Selection [ ] ) buffer . getProperty ( Buffer . SELECTION ) ; Integer firstLine = ( Integer ) buffer . getProperty ( Buffer . SCROLL_VERT ) ; Integer horizontalOffset = ( Integer ) buffer . getProperty ( Buffer . SCROLL_HORIZ ) ; if ( caret != null ) { textArea . setCaretPosition ( Math . min ( caret . intValue ( ) , buffer . getLength ( ) ) ) ; } if ( selection != null ) textArea . setSelection ( selection ) ; if ( firstLine != null ) textArea . setFirstLine ( firstLine . intValue ( ) ) ; if ( horizontalOffset != null ) textArea . setHorizontalOffset ( horizontalOffset . intValue ( ) ) ; } public void handleMessage ( EBMessage msg ) { if ( msg instanceof PropertiesChanged ) { propertiesChanged ( ) ; loadBufferSwitcher ( ) ; } else if ( msg instanceof BufferUpdate ) handleBufferUpdate ( ( BufferUpdate ) msg ) ; } public final Dimension getMinimumSize ( ) { return new Dimension ( 0 , 0 ) ; } EditPane ( View view , Buffer buffer ) { super ( new BorderLayout ( ) ) ; init = true ; this . view = view ; EditBus . addToBus ( this ) ; textArea = new JEditTextArea ( view ) ; add ( BorderLayout . CENTER , textArea ) ; markerHighlight = new MarkerHighlight ( ) ; textArea . getGutter ( ) . addCustomHighlight ( markerHighlight ) ; propertiesChanged ( ) ; if ( buffer == null ) setBuffer ( jEdit . getFirstBuffer ( ) ) ; else setBuffer ( buffer ) ; loadBufferSwitcher ( ) ; init = false ; } void close ( ) { saveCaretInfo ( ) ; EditBus . send ( new EditPaneUpdate ( this , EditPaneUpdate . DESTROYED ) ) ; EditBus . removeFromBus ( this ) ; } private boolean init ; private View view ; private Buffer buffer ; private Buffer recentBuffer ; private BufferSwitcher bufferSwitcher ; private JEditTextArea textArea ; private MarkerHighlight markerHighlight ; private void propertiesChanged ( ) { TextAreaPainter painter = textArea . getPainter ( ) ; painter . setFont ( UIManager . getFont ( "TextArea.font" ) ) ; painter . setBracketHighlightEnabled ( jEdit . getBooleanProperty ( "view.bracketHighlight" ) ) ; painter . setBracketHighlightColor ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.bracketHighlightColor" ) ) ) ; painter . setEOLMarkersPainted ( jEdit . getBooleanProperty ( "view.eolMarkers" ) ) ; painter . setEOLMarkerColor ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.eolMarkerColor" ) ) ) ; painter . setWrapGuidePainted ( jEdit . getBooleanProperty ( "view.wrapGuide" ) ) ; painter . setWrapGuideColor ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.wrapGuideColor" ) ) ) ; painter . setCaretColor ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.caretColor" ) ) ) ; painter . setSelectionColor ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.selectionColor" ) ) ) ; painter . setBackground ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.bgColor" ) ) ) ; painter . setForeground ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.fgColor" ) ) ) ; painter . setBlockCaretEnabled ( jEdit . getBooleanProperty ( "view.blockCaret" ) ) ; painter . setLineHighlightEnabled ( jEdit . getBooleanProperty ( "view.lineHighlight" ) ) ; painter . setLineHighlightColor ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.lineHighlightColor" ) ) ) ; painter . setAntiAliasEnabled ( jEdit . getBooleanProperty ( "view.antiAlias" ) ) ; painter . setFractionalFontMetricsEnabled ( jEdit . getBooleanProperty ( "view.fracFontMetrics" ) ) ; painter . setStyles ( GUIUtilities . loadStyles ( jEdit . getProperty ( "view.font" ) , Integer . parseInt ( jEdit . getProperty ( "view.fontsize" ) ) ) ) ; Gutter gutter = textArea . getGutter ( ) ; gutter . setExpanded ( jEdit . getBooleanProperty ( "view.gutter.lineNumbers" ) ) ; try { int interval = Integer . parseInt ( jEdit . getProperty ( "view.gutter.highlightInterval" ) ) ; gutter . setHighlightInterval ( interval ) ; } catch ( NumberFormatException nf ) { } gutter . setCurrentLineHighlightEnabled ( jEdit . getBooleanProperty ( "view.gutter.highlightCurrentLine" ) ) ; gutter . setBackground ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.gutter.bgColor" ) ) ) ; gutter . setForeground ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.gutter.fgColor" ) ) ) ; gutter . setHighlightedForeground ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.gutter.highlightColor" ) ) ) ; gutter . setFoldColor ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.gutter.foldColor" ) ) ) ; markerHighlight . setMarkerHighlightColor ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.gutter.markerColor" ) ) ) ; markerHighlight . setHighlightEnabled ( jEdit . getBooleanProperty ( "view.gutter.markerHighlight" ) ) ; gutter . setCurrentLineForeground ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.gutter.currentLineColor" ) ) ) ; String alignment = jEdit . getProperty ( "view.gutter.numberAlignment" ) ; if ( "right" . equals ( alignment ) ) { gutter . setLineNumberAlignment ( Gutter . RIGHT ) ; } else if ( "center" . equals ( alignment ) ) { gutter . setLineNumberAlignment ( Gutter . CENTER ) ; } else { gutter . setLineNumberAlignment ( Gutter . LEFT ) ; } try { String fontname = jEdit . getProperty ( "view.gutter.font" ) ; int fontsize = Integer . parseInt ( jEdit . getProperty ( "view.gutter.fontsize" ) ) ; int fontstyle = Integer . parseInt ( jEdit . getProperty ( "view.gutter.fontstyle" ) ) ; gutter . setFont ( new Font ( fontname , fontstyle , fontsize ) ) ; } catch ( NumberFormatException nf ) { } try { int width = Integer . parseInt ( jEdit . getProperty ( "view.gutter.borderWidth" ) ) ; gutter . setBorder ( width , GUIUtilities . parseColor ( jEdit . getProperty ( "view.gutter.focusBorderColor" ) ) , GUIUtilities . parseColor ( jEdit . getProperty ( "view.gutter.noFocusBorderColor" ) ) , textArea . getPainter ( ) . getBackground ( ) ) ; } catch ( NumberFormatException nf ) { } textArea . setCaretBlinkEnabled ( jEdit . getBooleanProperty ( "view.caretBlink" ) ) ; try { textArea . setElectricScroll ( Integer . parseInt ( jEdit . getProperty ( "view.electricBorders" ) ) ) ; } catch ( NumberFormatException nf ) { textArea . setElectricScroll ( 0 ) ; } textArea . setRightClickPopup ( GUIUtilities . loadPopupMenu ( "view.context" ) ) ; textArea . setMiddleMousePasteEnabled ( jEdit . getBooleanProperty ( "view.middleMousePaste" ) ) ; } private void loadBufferSwitcher ( ) { if ( jEdit . getBooleanProperty ( "view.showBufferSwitcher" ) ) { if ( bufferSwitcher == null ) { bufferSwitcher = new BufferSwitcher ( this ) ; add ( BorderLayout . NORTH , bufferSwitcher ) ; bufferSwitcher . updateBufferList ( ) ; revalidate ( ) ; } } else if ( bufferSwitcher != null ) { remove ( bufferSwitcher ) ; revalidate ( ) ; bufferSwitcher = null ; } } private void handleBufferUpdate ( BufferUpdate msg ) { Buffer _buffer = msg . getBuffer ( ) ; if ( msg . getWhat ( ) == BufferUpdate . CREATED ) { if ( bufferSwitcher != null ) bufferSwitcher . updateBufferList ( ) ; if ( buffer . isClosed ( ) ) setBuffer ( jEdit . getFirstBuffer ( ) ) ; } else if ( msg . getWhat ( ) == BufferUpdate . CLOSED ) { if ( bufferSwitcher != null ) bufferSwitcher . updateBufferList ( ) ; if ( _buffer == buffer ) { Buffer newBuffer = ( recentBuffer != null ? recentBuffer : _buffer . getPrev ( ) ) ; if ( newBuffer != null && ! newBuffer . isClosed ( ) ) setBuffer ( newBuffer ) ; else if ( jEdit . getBufferCount ( ) != 0 ) setBuffer ( jEdit . getFirstBuffer ( ) ) ; recentBuffer = null ; } else if ( _buffer == recentBuffer ) recentBuffer = null ; } else if ( msg . getWhat ( ) == BufferUpdate . LOAD_STARTED ) { if ( _buffer == buffer ) { textArea . setCaretPosition ( 0 ) ; textArea . getPainter ( ) . repaint ( ) ; } } else if ( msg . getWhat ( ) == BufferUpdate . DIRTY_CHANGED ) { if ( _buffer == buffer ) { if ( bufferSwitcher != null ) { if ( buffer . isDirty ( ) ) bufferSwitcher . repaint ( ) ; else bufferSwitcher . updateBufferList ( ) ; } } } else if ( msg . getWhat ( ) == BufferUpdate . LOADED ) { if ( _buffer == buffer ) { textArea . repaint ( ) ; textArea . updateScrollBars ( ) ; if ( bufferSwitcher != null ) bufferSwitcher . updateBufferList ( ) ; if ( view . getEditPane ( ) == this ) { StatusBar status = view . getStatus ( ) ; status . repaintCaretStatus ( ) ; status . updateBufferStatus ( ) ; status . updateMiscStatus ( ) ; } loadCaretInfo ( ) ; } } else if ( msg . getWhat ( ) == BufferUpdate . MARKERS_CHANGED ) { if ( _buffer == buffer ) textArea . getGutter ( ) . repaint ( ) ; } else if ( msg . getWhat ( ) == BufferUpdate . MODE_CHANGED ) { if ( _buffer == buffer ) { textArea . getPainter ( ) . repaint ( ) ; if ( view . getEditPane ( ) == this ) view . getStatus ( ) . updateBufferStatus ( ) ; } } else if ( msg . getWhat ( ) == BufferUpdate . ENCODING_CHANGED ) { if ( _buffer == buffer ) { if ( view . getEditPane ( ) == this ) view . getStatus ( ) . updateBufferStatus ( ) ; } } } } 	1	['19', '5', '0', '31', '132', '57', '16', '22', '12', '0.595238095', '828', '1', '6', '0.973174367', '0.210526316', '1', '1', '42.21052632', '21', '3.2105', '5']
package bsh ; import java . util . Vector ; import java . io . * ; public class Interpreter implements Runnable , ConsoleInterface { public static final String VERSION = "1.2b1" ; public static boolean DEBUG , TRACE ; static PrintStream debug ; static { staticInit ( ) ; } static This systemObject ; public static boolean strictJava = false ; Parser parser ; NameSpace globalNameSpace ; Reader in ; PrintStream out ; PrintStream err ; ConsoleInterface console ; Interpreter parent ; String sourceFileInfo ; public boolean noExitOnEOF ; private boolean evalOnly , interactive ; public Interpreter ( Reader in , PrintStream out , PrintStream err , boolean interactive , NameSpace namespace , Interpreter parent , String sourceFileInfo ) { parser = new Parser ( in ) ; long t1 = System . currentTimeMillis ( ) ; this . in = in ; this . out = out ; this . err = err ; this . interactive = interactive ; debug = err ; this . parent = parent ; this . sourceFileInfo = sourceFileInfo ; if ( namespace == null ) this . globalNameSpace = new NameSpace ( "global" ) ; else this . globalNameSpace = namespace ; globalNameSpace . loadDefaultImports ( ) ; if ( ! ( getu ( "bsh" ) instanceof bsh . This ) ) initRootSystemObject ( ) ; if ( interactive ) loadRCFiles ( ) ; long t2 = System . currentTimeMillis ( ) ; Interpreter . debug ( "Time to initialize interpreter: " + ( t2 - t1 ) ) ; } public Interpreter ( Reader in , PrintStream out , PrintStream err , boolean interactive , NameSpace namespace ) { this ( in , out , err , interactive , namespace , null , null ) ; } public Interpreter ( Reader in , PrintStream out , PrintStream err , boolean interactive ) { this ( in , out , err , interactive , null ) ; } public Interpreter ( ConsoleInterface console , NameSpace globalNameSpace ) { this ( console . getIn ( ) , console . getOut ( ) , console . getErr ( ) , true , globalNameSpace ) ; setConsole ( console ) ; } public Interpreter ( ConsoleInterface console ) { this ( console , null ) ; } public Interpreter ( ) { this ( new StringReader ( "" ) , System . out , System . err , false , null ) ; evalOnly = true ; setu ( "bsh.evalOnly" , new Primitive ( true ) ) ; } public void setConsole ( ConsoleInterface console ) { this . console = console ; setu ( "bsh.console" , console ) ; } private void initRootSystemObject ( ) { setu ( "bsh" , new NameSpace ( "Bsh Object" ) . getThis ( this ) ) ; if ( systemObject == null ) systemObject = new NameSpace ( "Bsh System Object" ) . getThis ( this ) ; setu ( "bsh.system" , systemObject ) ; This helpText = new NameSpace ( "Bsh Command Help Text" ) . getThis ( this ) ; setu ( "bsh.help" , helpText ) ; try { setu ( "bsh.cwd" , System . getProperty ( "user.dir" ) ) ; } catch ( SecurityException e ) { setu ( "bsh.cwd" , "." ) ; } setu ( "bsh.interactive" , new Primitive ( interactive ) ) ; setu ( "bsh.evalOnly" , new Primitive ( evalOnly ) ) ; } public void setNameSpace ( NameSpace globalNameSpace ) { this . globalNameSpace = globalNameSpace ; } public NameSpace getNameSpace ( ) { return globalNameSpace ; } public static void main ( String [ ] args ) { if ( args . length > 0 ) { String filename = args [ 0 ] ; String [ ] bshArgs ; if ( args . length > 1 ) { bshArgs = new String [ args . length - 1 ] ; System . arraycopy ( args , 1 , bshArgs , 0 , args . length - 1 ) ; } else bshArgs = new String [ 0 ] ; Interpreter interpreter = new Interpreter ( ) ; interpreter . setu ( "bsh.args" , bshArgs ) ; try { interpreter . source ( filename , interpreter . globalNameSpace ) ; } catch ( FileNotFoundException e ) { System . out . println ( "File not found: " + e ) ; } catch ( EvalError e ) { System . out . println ( "Evaluation Error: " + e ) ; } catch ( IOException e ) { System . out . println ( "I/O Error: " + e ) ; } } else { InputStream src ; if ( System . getProperty ( "os.name" ) . startsWith ( "Windows" ) && System . getProperty ( "java.version" ) . startsWith ( "1.1." ) ) { src = new FilterInputStream ( System . in ) { public int available ( ) throws IOException { return 0 ; } } ; } else src = System . in ; Reader in = new CommandLineReader ( new InputStreamReader ( src ) ) ; Interpreter interpreter = new Interpreter ( in , System . out , System . err , true ) ; interpreter . run ( ) ; } } public void run ( ) { if ( evalOnly ) throw new RuntimeException ( "bsh Interpreter: No stream" ) ; if ( interactive ) try { eval ( "printBanner();" ) ; } catch ( EvalError e ) { println ( "BeanShell " + VERSION + " - by Pat Niemeyer (pat@pat.net)" ) ; } boolean eof = false ; CallStack callstack = new CallStack ( ) ; callstack . push ( globalNameSpace ) ; while ( ! eof ) { try { System . out . flush ( ) ; System . err . flush ( ) ; Thread . yield ( ) ; if ( interactive ) print ( "bsh % " ) ; eof = Line ( ) ; if ( get_jjtree ( ) . nodeArity ( ) > 0 ) { SimpleNode node = ( SimpleNode ) ( get_jjtree ( ) . rootNode ( ) ) ; if ( DEBUG ) node . dump ( ">" ) ; Object ret = node . eval ( callstack , this ) ; if ( callstack . depth ( ) > 1 ) throw new InterpreterError ( "Callstack growing: " + callstack ) ; if ( ret instanceof ReturnControl ) ret = ( ( ReturnControl ) ret ) . value ; if ( ret != Primitive . VOID ) { setVariable ( "$_" , ret ) ; Object show = getu ( "bsh.show" ) ; if ( show instanceof Boolean && ( ( Boolean ) show ) . booleanValue ( ) == true ) println ( "<" + ret + ">" ) ; } } } catch ( ParseException e ) { error ( "Parser Error: " + e . getMessage ( DEBUG ) ) ; if ( DEBUG ) e . printStackTrace ( ) ; if ( ! interactive ) eof = true ; parser . reInitInput ( in ) ; } catch ( InterpreterError e ) { error ( "Internal Error: " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; if ( ! interactive ) eof = true ; } catch ( TargetError e ) { error ( "// Uncaught Exception: " + e ) ; if ( DEBUG ) e . printStackTrace ( ) ; if ( ! interactive ) eof = true ; } catch ( EvalError e ) { if ( interactive ) error ( e . toString ( ) ) ; else error ( e . getMessage ( ) ) ; if ( DEBUG ) e . printStackTrace ( ) ; if ( ! interactive ) eof = true ; } catch ( Exception e ) { error ( "Unknown error: " + e ) ; e . printStackTrace ( ) ; if ( ! interactive ) eof = true ; } catch ( TokenMgrError e ) { error ( "Error parsing input: " + e ) ; parser . reInitTokenInput ( in ) ; if ( ! interactive ) eof = true ; } finally { get_jjtree ( ) . reset ( ) ; if ( callstack . depth ( ) > 1 ) { callstack . clear ( ) ; callstack . push ( globalNameSpace ) ; } } } if ( interactive && ! noExitOnEOF ) System . exit ( 0 ) ; } public Object source ( String filename , NameSpace nameSpace ) throws FileNotFoundException , IOException , EvalError { File file = pathToFile ( filename ) ; debug ( "Sourcing file: " + file ) ; Reader in = new BufferedReader ( new FileReader ( file ) ) ; return eval ( in , nameSpace , filename ) ; } public Object source ( String filename ) throws FileNotFoundException , IOException , EvalError { return source ( filename , globalNameSpace ) ; } public Object eval ( Reader in , NameSpace nameSpace , String sourceFileInfo ) throws EvalError { Object retVal = null ; debug ( "eval: nameSpace = " + nameSpace ) ; Interpreter localInterpreter = new Interpreter ( in , out , err , false , nameSpace , this , sourceFileInfo ) ; CallStack callstack = new CallStack ( ) ; callstack . push ( nameSpace ) ; boolean eof = false ; while ( ! eof ) { SimpleNode node = null ; try { eof = localInterpreter . Line ( ) ; if ( localInterpreter . get_jjtree ( ) . nodeArity ( ) > 0 ) { node = ( SimpleNode ) localInterpreter . get_jjtree ( ) . rootNode ( ) ; node . setSourceFile ( sourceFileInfo ) ; if ( TRACE ) println ( "// " + node . getText ( ) ) ; retVal = node . eval ( callstack , localInterpreter ) ; if ( callstack . depth ( ) > 1 ) throw new InterpreterError ( "Callstack growing: " + callstack ) ; if ( retVal instanceof ReturnControl ) { retVal = ( ( ReturnControl ) retVal ) . value ; break ; } } } catch ( ParseException e ) { throw new EvalError ( "Sourced file: " + sourceFileInfo + " parser Error: " + e . getMessage ( DEBUG ) , node ) ; } catch ( InterpreterError e ) { e . printStackTrace ( ) ; throw new EvalError ( "Sourced file: " + sourceFileInfo + " internal Error: " + e . getMessage ( ) , node ) ; } catch ( TargetError e ) { if ( DEBUG ) e . printStackTrace ( ) ; if ( e . getNode ( ) == null ) e . setNode ( node ) ; e . reThrow ( "Sourced file: " + sourceFileInfo ) ; } catch ( EvalError e ) { if ( DEBUG ) e . printStackTrace ( ) ; if ( e . getNode ( ) == null ) e . setNode ( node ) ; e . reThrow ( "Sourced file: " + sourceFileInfo ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new EvalError ( "Sourced file: " + sourceFileInfo + " unknown error: " + e . getMessage ( ) , node ) ; } catch ( TokenMgrError e ) { throw new EvalError ( "Sourced file: " + sourceFileInfo + " Token Parsing Error: " + e . getMessage ( ) , node ) ; } finally { localInterpreter . get_jjtree ( ) . reset ( ) ; if ( callstack . depth ( ) > 1 ) { callstack . clear ( ) ; callstack . push ( nameSpace ) ; } } } return Primitive . unwrap ( retVal ) ; } public Object eval ( Reader in ) throws EvalError { return eval ( in , globalNameSpace , "eval stream" ) ; } public Object eval ( String statement ) throws EvalError { return eval ( statement , globalNameSpace ) ; } public Object eval ( String statement , NameSpace nameSpace ) throws EvalError { String s = ( statement . endsWith ( ";" ) ? statement : statement + ";" ) ; return eval ( new StringReader ( s ) , nameSpace , "<Inline eval of: " + s + " >" ) ; } public final void error ( String s ) { if ( console != null ) console . error ( "// Error: " + s + "\n" ) ; else { err . println ( "// Error: " + s ) ; err . flush ( ) ; } } public Reader getIn ( ) { return in ; } public PrintStream getOut ( ) { return out ; } public PrintStream getErr ( ) { return err ; } public final void println ( String s ) { print ( s + "\n" ) ; } public final void print ( String s ) { if ( console != null ) { console . print ( s ) ; } else { out . print ( s ) ; out . flush ( ) ; } } public final static void debug ( String s ) { if ( DEBUG ) debug . println ( "// Debug: " + s ) ; } public Object get ( String name ) throws EvalError { Object ret = globalNameSpace . get ( name , this ) ; return Primitive . unwrap ( ret ) ; } Object getu ( String name ) { try { return get ( name ) ; } catch ( EvalError e ) { throw new InterpreterError ( "set: " + e ) ; } } public void set ( String name , Object value ) throws EvalError { if ( value == null ) value = Primitive . NULL ; CallStack callstack = new CallStack ( ) ; LHS lhs = globalNameSpace . getNameResolver ( name ) . toLHS ( callstack , this ) ; lhs . assign ( value ) ; } void setu ( String name , Object value ) { try { set ( name , value ) ; } catch ( EvalError e ) { throw new InterpreterError ( "set: " + e ) ; } } public void set ( String name , long value ) throws EvalError { set ( name , new Primitive ( value ) ) ; } public void set ( String name , int value ) throws EvalError { set ( name , new Primitive ( value ) ) ; } public void set ( String name , double value ) throws EvalError { set ( name , new Primitive ( value ) ) ; } public void set ( String name , float value ) throws EvalError { set ( name , new Primitive ( value ) ) ; } public void set ( String name , boolean value ) throws EvalError { set ( name , new Primitive ( value ) ) ; } public void unset ( String name ) throws EvalError { CallStack callstack = new CallStack ( ) ; LHS lhs = globalNameSpace . getNameResolver ( name ) . toLHS ( callstack , this ) ; if ( lhs . type != LHS . VARIABLE ) throw new EvalError ( "Can't unset, not a variable: " + name ) ; lhs . assign ( null ) ; } public Object getVariable ( String name ) { Object obj = globalNameSpace . getVariable ( name ) ; return Primitive . unwrap ( obj ) ; } public void setVariable ( String name , Object value ) { try { globalNameSpace . setVariable ( name , value ) ; } catch ( EvalError e ) { error ( e . toString ( ) ) ; } } public void setVariable ( String name , int value ) { try { globalNameSpace . setVariable ( name , new Primitive ( value ) ) ; } catch ( EvalError e ) { error ( e . toString ( ) ) ; } } public void setVariable ( String name , float value ) { try { globalNameSpace . setVariable ( name , new Primitive ( value ) ) ; } catch ( EvalError e ) { error ( e . toString ( ) ) ; } } public void setVariable ( String name , boolean value ) { try { globalNameSpace . setVariable ( name , new Primitive ( value ) ) ; } catch ( EvalError e ) { error ( e . toString ( ) ) ; } } private JJTParserState get_jjtree ( ) { return parser . jjtree ; } private ASCII_UCodeESC_CharStream get_jj_input_stream ( ) { return parser . jj_input_stream ; } private boolean Line ( ) throws ParseException { return parser . Line ( ) ; } void loadRCFiles ( ) { try { String rcfile = System . getProperty ( "user.home" ) + File . separator + ".bshrc" ; source ( rcfile , globalNameSpace ) ; } catch ( Exception e ) { debug ( "Could not find rc file: " + e ) ; } } public File pathToFile ( String fileName ) throws IOException { File file = new File ( fileName ) ; if ( ! file . isAbsolute ( ) ) { String cwd = ( String ) getu ( "bsh.cwd" ) ; file = new File ( cwd + File . separator + fileName ) ; } return new File ( file . getCanonicalPath ( ) ) ; } public static void redirectOutputToFile ( String filename ) { try { PrintStream pout = new PrintStream ( new FileOutputStream ( filename ) ) ; System . setOut ( pout ) ; System . setErr ( pout ) ; } catch ( IOException e ) { System . err . println ( "Can't redirect output to file: " + filename ) ; } } public void setClassLoader ( ClassLoader externalCL ) { BshClassManager . setClassLoader ( externalCL ) ; } static void staticInit ( ) { try { debug = System . err ; DEBUG = Boolean . getBoolean ( "debug" ) ; TRACE = Boolean . getBoolean ( "trace" ) ; String outfilename = System . getProperty ( "outfile" ) ; if ( outfilename != null ) redirectOutputToFile ( outfilename ) ; } catch ( SecurityException e ) { System . err . println ( "Could not init static:" + e ) ; } catch ( Exception e ) { System . err . println ( "Could not init static(2):" + e ) ; } catch ( Throwable e ) { System . err . println ( "Could not init static(3):" + e ) ; } } public String getSourceFileInfo ( ) { if ( sourceFileInfo != null ) return sourceFileInfo ; else return "<unknown source>" ; } public Interpreter getParent ( ) { return parent ; } } 	0	['51', '1', '0', '58', '132', '925', '44', '21', '42', '0.776470588', '1458', '0.117647059', '5', '0', '0.144', '0', '0', '27.25490196', '33', '1.6667', '0']
package org . gjt . sp . jedit . options ; import javax . swing . border . EmptyBorder ; import javax . swing . table . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . util . * ; import org . gjt . sp . jedit . gui . EditAbbrevDialog ; import org . gjt . sp . jedit . * ; public class AbbrevsOptionPane extends AbstractOptionPane { public AbbrevsOptionPane ( ) { super ( "abbrevs" ) ; } protected void _init ( ) { setLayout ( new BorderLayout ( ) ) ; JPanel panel = new JPanel ( new BorderLayout ( ) ) ; JPanel panel2 = new JPanel ( ) ; panel2 . setLayout ( new BoxLayout ( panel2 , BoxLayout . X_AXIS ) ) ; panel2 . setBorder ( new EmptyBorder ( 0 , 0 , 6 , 0 ) ) ; panel2 . add ( Box . createGlue ( ) ) ; expandOnInput = new JCheckBox ( jEdit . getProperty ( "options.abbrevs" + ".expandOnInput" ) , Abbrevs . getExpandOnInput ( ) ) ; panel2 . add ( expandOnInput ) ; panel2 . add ( Box . createGlue ( ) ) ; panel . add ( panel2 , BorderLayout . NORTH ) ; JPanel panel3 = new JPanel ( ) ; JLabel label = new JLabel ( jEdit . getProperty ( "options.abbrevs.set" ) ) ; label . setBorder ( new EmptyBorder ( 0 , 0 , 0 , 12 ) ) ; panel3 . add ( label ) ; Hashtable _modeAbbrevs = Abbrevs . getModeAbbrevs ( ) ; modeAbbrevs = new Hashtable ( ) ; Mode [ ] modes = jEdit . getModes ( ) ; String [ ] sets = new String [ modes . length + 1 ] ; sets [ 0 ] = "global" ; for ( int i = 0 ; i < modes . length ; i ++ ) { String name = modes [ i ] . getName ( ) ; sets [ i + 1 ] = name ; modeAbbrevs . put ( name , new AbbrevsModel ( ( Hashtable ) _modeAbbrevs . get ( name ) ) ) ; } setsComboBox = new JComboBox ( sets ) ; setsComboBox . addActionListener ( new ActionHandler ( ) ) ; panel3 . add ( setsComboBox ) ; panel . add ( panel3 , BorderLayout . SOUTH ) ; add ( BorderLayout . NORTH , panel ) ; globalAbbrevs = new AbbrevsModel ( Abbrevs . getGlobalAbbrevs ( ) ) ; abbrevsTable = new JTable ( globalAbbrevs ) ; abbrevsTable . getTableHeader ( ) . setReorderingAllowed ( false ) ; abbrevsTable . getTableHeader ( ) . addMouseListener ( new HeaderMouseHandler ( ) ) ; abbrevsTable . addMouseListener ( new TableMouseHandler ( ) ) ; Dimension d = abbrevsTable . getPreferredSize ( ) ; d . height = Math . min ( d . height , 200 ) ; JScrollPane scroller = new JScrollPane ( abbrevsTable ) ; scroller . setPreferredSize ( d ) ; add ( BorderLayout . CENTER , scroller ) ; } protected void _save ( ) { if ( abbrevsTable . getCellEditor ( ) != null ) abbrevsTable . getCellEditor ( ) . stopCellEditing ( ) ; Abbrevs . setExpandOnInput ( expandOnInput . isSelected ( ) ) ; Abbrevs . setGlobalAbbrevs ( globalAbbrevs . toHashtable ( ) ) ; Hashtable modeHash = new Hashtable ( ) ; Enumeration keys = modeAbbrevs . keys ( ) ; Enumeration values = modeAbbrevs . elements ( ) ; while ( keys . hasMoreElements ( ) ) { modeHash . put ( keys . nextElement ( ) , ( ( AbbrevsModel ) values . nextElement ( ) ) . toHashtable ( ) ) ; } Abbrevs . setModeAbbrevs ( modeHash ) ; } private JComboBox setsComboBox ; private JCheckBox expandOnInput ; private JTable abbrevsTable ; private AbbrevsModel globalAbbrevs ; private Hashtable modeAbbrevs ; class HeaderMouseHandler extends MouseAdapter { public void mouseClicked ( MouseEvent evt ) { switch ( abbrevsTable . getTableHeader ( ) . columnAtPoint ( evt . getPoint ( ) ) ) { case 0 : ( ( AbbrevsModel ) abbrevsTable . getModel ( ) ) . sort ( 0 ) ; break ; case 1 : ( ( AbbrevsModel ) abbrevsTable . getModel ( ) ) . sort ( 1 ) ; break ; } } } class TableMouseHandler extends MouseAdapter { public void mouseClicked ( MouseEvent evt ) { if ( abbrevsTable . getSelectedColumn ( ) == 1 ) { TableModel abbrevsModel = abbrevsTable . getModel ( ) ; int row = abbrevsTable . getSelectedRow ( ) ; String abbrev = ( String ) abbrevsModel . getValueAt ( row , 0 ) ; String expansion = ( String ) abbrevsModel . getValueAt ( row , 1 ) ; expansion = new EditAbbrevDialog ( AbbrevsOptionPane . this , abbrev , expansion ) . getExpansion ( ) ; if ( expansion != null ) abbrevsModel . setValueAt ( expansion , row , 1 ) ; } } } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == setsComboBox ) { String selected = ( String ) setsComboBox . getSelectedItem ( ) ; if ( selected . equals ( "global" ) ) { abbrevsTable . setModel ( globalAbbrevs ) ; } else { abbrevsTable . setModel ( ( AbbrevsModel ) modeAbbrevs . get ( selected ) ) ; } } } } } class AbbrevsModel extends AbstractTableModel { Vector abbrevs ; AbbrevsModel ( ) { abbrevs = new Vector ( ) ; } AbbrevsModel ( Hashtable abbrevHash ) { this ( ) ; if ( abbrevHash != null ) { Enumeration abbrevEnum = abbrevHash . keys ( ) ; Enumeration expandEnum = abbrevHash . elements ( ) ; while ( abbrevEnum . hasMoreElements ( ) ) { abbrevs . addElement ( new Abbrev ( ( String ) abbrevEnum . nextElement ( ) , ( String ) expandEnum . nextElement ( ) ) ) ; } sort ( 0 ) ; } } public void sort ( int col ) { MiscUtilities . quicksort ( abbrevs , new AbbrevCompare ( col ) ) ; fireTableDataChanged ( ) ; } public Hashtable toHashtable ( ) { Hashtable hash = new Hashtable ( ) ; for ( int i = 0 ; i < abbrevs . size ( ) ; i ++ ) { Abbrev abbrev = ( Abbrev ) abbrevs . elementAt ( i ) ; if ( abbrev . abbrev . length ( ) > 0 && abbrev . expand . length ( ) > 0 ) { hash . put ( abbrev . abbrev , abbrev . expand ) ; } } return hash ; } public int getColumnCount ( ) { return 2 ; } public int getRowCount ( ) { return abbrevs . size ( ) + 1 ; } public Object getValueAt ( int row , int col ) { if ( row == abbrevs . size ( ) ) return null ; Abbrev abbrev = ( Abbrev ) abbrevs . elementAt ( row ) ; switch ( col ) { case 0 : return abbrev . abbrev ; case 1 : return abbrev . expand ; default : return null ; } } public boolean isCellEditable ( int row , int col ) { return ( col == 0 ) ; } public void setValueAt ( Object value , int row , int col ) { if ( value == null ) value = "" ; Abbrev abbrev ; if ( row == abbrevs . size ( ) ) { abbrev = new Abbrev ( ) ; abbrevs . addElement ( abbrev ) ; } else abbrev = ( Abbrev ) abbrevs . elementAt ( row ) ; if ( col == 0 ) abbrev . abbrev = ( String ) value ; else abbrev . expand = ( String ) value ; fireTableRowsUpdated ( row , row + 1 ) ; } public String getColumnName ( int index ) { switch ( index ) { case 0 : return jEdit . getProperty ( "options.abbrevs.abbrev" ) ; case 1 : return jEdit . getProperty ( "options.abbrevs.expand" ) ; default : return null ; } } class AbbrevCompare implements MiscUtilities . Compare { int col ; AbbrevCompare ( int col ) { this . col = col ; } public int compare ( Object obj1 , Object obj2 ) { Abbrev a1 = ( Abbrev ) obj1 ; Abbrev a2 = ( Abbrev ) obj2 ; if ( col == 0 ) { String abbrev1 = a1 . abbrev . toLowerCase ( ) ; String abbrev2 = a2 . abbrev . toLowerCase ( ) ; return abbrev1 . compareTo ( abbrev2 ) ; } else { String expand1 = a1 . expand . toLowerCase ( ) ; String expand2 = a2 . expand . toLowerCase ( ) ; return expand1 . compareTo ( expand2 ) ; } } } } class Abbrev { Abbrev ( ) { } Abbrev ( String abbrev , String expand ) { this . abbrev = abbrev ; this . expand = expand ; } String abbrev ; String expand ; } 	1	['7', '6', '0', '9', '58', '5', '4', '8', '1', '0.733333333', '300', '1', '1', '0.991017964', '0.5', '4', '12', '41.14285714', '5', '1.7143', '1']
package org . gjt . sp . jedit . msg ; import org . gjt . sp . jedit . gui . DockableWindow ; import org . gjt . sp . jedit . * ; public class CreateDockableWindow extends EBMessage { public CreateDockableWindow ( View view , String name , String position ) { super ( view ) ; if ( name == null ) throw new NullPointerException ( "Name must be non-null" ) ; this . name = name ; this . position = position ; } public View getView ( ) { return ( View ) getSource ( ) ; } public String getDockableWindowName ( ) { return name ; } public void setDockableWindow ( DockableWindow win ) { this . win = win ; veto ( ) ; } public DockableWindow getDockableWindow ( ) { return win ; } public String getPosition ( ) { return position ; } public String paramString ( ) { return super . paramString ( ) + ",name=" + name + ",position=" + position ; } private String name ; private String position ; private DockableWindow win ; } 	0	['7', '2', '0', '6', '15', '9', '2', '4', '7', '0.722222222', '64', '1', '1', '0.454545455', '0.357142857', '1', '1', '7.714285714', '1', '0.8571', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . border . * ; import javax . swing . event . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . io . VFSManager ; import org . gjt . sp . jedit . * ; public class CloseDialog extends EnhancedDialog { public CloseDialog ( View view ) { super ( view , jEdit . getProperty ( "close.title" ) , true ) ; this . view = view ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; JLabel label = new JLabel ( jEdit . getProperty ( "close.caption" ) ) ; label . setBorder ( new EmptyBorder ( 0 , 0 , 6 , 0 ) ) ; content . add ( BorderLayout . NORTH , label ) ; bufferList = new JList ( bufferModel = new DefaultListModel ( ) ) ; bufferList . setVisibleRowCount ( 10 ) ; bufferList . addListSelectionListener ( new ListHandler ( ) ) ; Buffer [ ] buffers = jEdit . getBuffers ( ) ; for ( int i = 0 ; i < buffers . length ; i ++ ) { Buffer buffer = buffers [ i ] ; if ( buffer . isDirty ( ) ) { bufferModel . addElement ( buffer . getPath ( ) ) ; } } content . add ( BorderLayout . CENTER , new JScrollPane ( bufferList ) ) ; ActionHandler actionListener = new ActionHandler ( ) ; JPanel buttons = new JPanel ( ) ; buttons . setLayout ( new BoxLayout ( buttons , BoxLayout . X_AXIS ) ) ; buttons . setBorder ( new EmptyBorder ( 12 , 0 , 0 , 0 ) ) ; buttons . add ( Box . createGlue ( ) ) ; buttons . add ( save = new JButton ( jEdit . getProperty ( "close.save" ) ) ) ; save . setMnemonic ( jEdit . getProperty ( "close.save.mnemonic" ) . charAt ( 0 ) ) ; save . addActionListener ( actionListener ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; buttons . add ( discard = new JButton ( jEdit . getProperty ( "close.discard" ) ) ) ; discard . setMnemonic ( jEdit . getProperty ( "close.discard.mnemonic" ) . charAt ( 0 ) ) ; discard . addActionListener ( actionListener ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; buttons . add ( cancel = new JButton ( jEdit . getProperty ( "common.cancel" ) ) ) ; cancel . addActionListener ( actionListener ) ; buttons . add ( Box . createGlue ( ) ) ; bufferList . setSelectedIndex ( 0 ) ; content . add ( BorderLayout . SOUTH , buttons ) ; GUIUtilities . requestFocus ( this , bufferList ) ; pack ( ) ; setLocationRelativeTo ( view ) ; show ( ) ; } public boolean isOK ( ) { return ok ; } public void ok ( ) { } public void cancel ( ) { dispose ( ) ; } private View view ; private JList bufferList ; private DefaultListModel bufferModel ; private JButton save ; private JButton discard ; private JButton cancel ; private boolean ok ; private void updateButtons ( ) { int index = bufferList . getSelectedIndex ( ) ; save . getModel ( ) . setEnabled ( index != - 1 ) ; discard . getModel ( ) . setEnabled ( index != - 1 ) ; } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == save ) { Object [ ] paths = bufferList . getSelectedValues ( ) ; for ( int i = 0 ; i < paths . length ; i ++ ) { String path = ( String ) paths [ i ] ; Buffer buffer = jEdit . getBuffer ( path ) ; if ( ! buffer . save ( view , null , true ) ) return ; VFSManager . waitForRequests ( ) ; jEdit . _closeBuffer ( view , buffer ) ; bufferModel . removeElement ( path ) ; } updateButtons ( ) ; if ( bufferModel . getSize ( ) == 0 ) { ok = true ; dispose ( ) ; } } else if ( source == discard ) { Object [ ] paths = bufferList . getSelectedValues ( ) ; for ( int i = 0 ; i < paths . length ; i ++ ) { String path = ( String ) paths [ i ] ; Buffer buffer = jEdit . getBuffer ( path ) ; jEdit . _closeBuffer ( view , buffer ) ; bufferModel . removeElement ( path ) ; } updateButtons ( ) ; if ( bufferModel . getSize ( ) == 0 ) { ok = true ; dispose ( ) ; } } else if ( source == cancel ) cancel ( ) ; } } class ListHandler implements ListSelectionListener { public void valueChanged ( ListSelectionEvent evt ) { int index = bufferList . getSelectedIndex ( ) ; if ( index != - 1 ) view . setBuffer ( jEdit . getBuffer ( ( String ) bufferModel . getElementAt ( index ) ) ) ; updateButtons ( ) ; } } } 	1	['14', '7', '0', '7', '54', '65', '3', '7', '4', '0.846153846', '313', '1', '1', '0.98048048', '0.285714286', '0', '0', '20.85714286', '3', '1.0714', '3']
package org . gjt . sp . jedit ; public interface EBComponent { void handleMessage ( EBMessage message ) ; } 	0	['1', '1', '0', '31', '1', '0', '31', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . gjt . sp . jedit . search ; import javax . swing . border . * ; import javax . swing . event . * ; import javax . swing . text . BadLocationException ; import javax . swing . * ; import java . awt . * ; import java . awt . event . * ; import java . io . File ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . io . FileVFS ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class SearchDialog extends EnhancedDialog { public static final int CURRENT_BUFFER = 0 ; public static final int ALL_BUFFERS = 1 ; public static final int DIRECTORY = 2 ; public SearchDialog ( View view , String searchString ) { this ( view , searchString , CURRENT_BUFFER ) ; } public SearchDialog ( View view , String searchString , int searchIn ) { super ( view , jEdit . getProperty ( "search.title" ) , false ) ; this . view = view ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 0 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; JPanel centerPanel = new JPanel ( new BorderLayout ( ) ) ; centerPanel . add ( BorderLayout . NORTH , createFieldPanel ( ) ) ; centerPanel . add ( BorderLayout . CENTER , createSearchSettingsPanel ( ) ) ; content . add ( BorderLayout . CENTER , centerPanel ) ; content . add ( BorderLayout . SOUTH , createMultiFilePanel ( ) ) ; content . add ( BorderLayout . EAST , createButtonsPanel ( ) ) ; if ( searchString != null && searchString . indexOf ( '\n' ) == - 1 ) { find . setText ( searchString ) ; find . selectAll ( ) ; } else replace . setText ( null ) ; ignoreCase . setSelected ( SearchAndReplace . getIgnoreCase ( ) ) ; regexp . setSelected ( SearchAndReplace . getRegexp ( ) ) ; wrap . setSelected ( SearchAndReplace . getAutoWrapAround ( ) ) ; if ( SearchAndReplace . getReverseSearch ( ) ) searchBack . setSelected ( true ) ; else searchForward . setSelected ( true ) ; if ( SearchAndReplace . getBeanShellReplace ( ) ) beanShellReplace . setSelected ( true ) ; else stringReplace . setSelected ( true ) ; if ( searchIn == CURRENT_BUFFER ) searchCurrentBuffer . setSelected ( true ) ; else if ( searchIn == ALL_BUFFERS ) searchAllBuffers . setSelected ( true ) ; else if ( searchIn == DIRECTORY ) searchDirectory . setSelected ( true ) ; SearchFileSet fileset = SearchAndReplace . getSearchFileSet ( ) ; if ( fileset instanceof DirectoryListSet ) { filter . setText ( ( ( DirectoryListSet ) fileset ) . getFileFilter ( ) ) ; directory . setText ( ( ( DirectoryListSet ) fileset ) . getDirectory ( ) ) ; searchSubDirectories . setSelected ( ( ( DirectoryListSet ) fileset ) . isRecursive ( ) ) ; } else { String path ; if ( view . getBuffer ( ) . getVFS ( ) instanceof FileVFS ) { path = MiscUtilities . getParentOfPath ( view . getBuffer ( ) . getPath ( ) ) ; } else path = System . getProperty ( "user.dir" ) ; directory . setText ( path ) ; if ( fileset instanceof AllBufferSet ) { filter . setText ( ( ( AllBufferSet ) fileset ) . getFileFilter ( ) ) ; } else { filter . setText ( "*" + MiscUtilities . getFileExtension ( view . getBuffer ( ) . getName ( ) ) ) ; } searchSubDirectories . setSelected ( true ) ; } keepDialog . setSelected ( jEdit . getBooleanProperty ( "search.keepDialog.toggle" ) ) ; hyperSearch . setSelected ( jEdit . getBooleanProperty ( "search.hypersearch.toggle" ) ) ; updateEnabled ( ) ; pack ( ) ; jEdit . unsetProperty ( "search.width" ) ; jEdit . unsetProperty ( "search.d-width" ) ; jEdit . unsetProperty ( "search.height" ) ; jEdit . unsetProperty ( "search.d-height" ) ; GUIUtilities . loadGeometry ( this , "search" ) ; show ( ) ; GUIUtilities . requestFocus ( this , find ) ; } public void ok ( ) { try { setCursor ( Cursor . getPredefinedCursor ( Cursor . WAIT_CURSOR ) ) ; if ( ! save ( ) ) return ; if ( hyperSearch . isSelected ( ) ) { if ( SearchAndReplace . hyperSearch ( view ) ) ; closeOrKeepDialog ( ) ; } else { if ( SearchAndReplace . find ( view ) ) closeOrKeepDialog ( ) ; } } finally { setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; } } public void cancel ( ) { save ( ) ; GUIUtilities . saveGeometry ( this , "search" ) ; setVisible ( false ) ; } private View view ; private HistoryTextField find , replace ; private JRadioButton stringReplace , beanShellReplace ; private JCheckBox keepDialog , ignoreCase , regexp , hyperSearch , wrap ; private JRadioButton searchBack , searchForward ; private JRadioButton searchCurrentBuffer , searchAllBuffers , searchDirectory ; private HistoryTextField filter , directory ; private JCheckBox searchSubDirectories ; private JButton choose ; private JButton findBtn , replaceBtn , replaceAndFindBtn , replaceAllBtn , closeBtn ; private JPanel createFieldPanel ( ) { ButtonActionHandler actionHandler = new ButtonActionHandler ( ) ; JPanel fieldPanel = new JPanel ( new VariableGridLayout ( VariableGridLayout . FIXED_NUM_COLUMNS , 1 ) ) ; fieldPanel . setBorder ( new EmptyBorder ( 0 , 0 , 12 , 12 ) ) ; JLabel label = new JLabel ( jEdit . getProperty ( "search.find" ) ) ; label . setDisplayedMnemonic ( jEdit . getProperty ( "search.find.mnemonic" ) . charAt ( 0 ) ) ; find = new HistoryTextField ( "find" ) ; find . addActionListener ( actionHandler ) ; label . setLabelFor ( find ) ; label . setBorder ( new EmptyBorder ( 12 , 0 , 2 , 0 ) ) ; fieldPanel . add ( label ) ; fieldPanel . add ( find ) ; label = new JLabel ( jEdit . getProperty ( "search.replace" ) ) ; label . setDisplayedMnemonic ( jEdit . getProperty ( "search.replace.mnemonic" ) . charAt ( 0 ) ) ; label . setBorder ( new EmptyBorder ( 12 , 0 , 0 , 0 ) ) ; fieldPanel . add ( label ) ; ButtonGroup grp = new ButtonGroup ( ) ; ReplaceActionHandler replaceActionHandler = new ReplaceActionHandler ( ) ; Box replaceModeBox = new Box ( BoxLayout . X_AXIS ) ; stringReplace = new MyJRadioButton ( jEdit . getProperty ( "search.string-replace-btn" ) ) ; stringReplace . addActionListener ( replaceActionHandler ) ; grp . add ( stringReplace ) ; replaceModeBox . add ( stringReplace ) ; replaceModeBox . add ( Box . createHorizontalStrut ( 12 ) ) ; beanShellReplace = new MyJRadioButton ( jEdit . getProperty ( "search.beanshell-replace-btn" ) ) ; beanShellReplace . addActionListener ( replaceActionHandler ) ; grp . add ( beanShellReplace ) ; replaceModeBox . add ( beanShellReplace ) ; fieldPanel . add ( replaceModeBox ) ; fieldPanel . add ( Box . createVerticalStrut ( 3 ) ) ; replace = new HistoryTextField ( "replace" ) ; replace . addActionListener ( actionHandler ) ; label . setLabelFor ( replace ) ; fieldPanel . add ( replace ) ; return fieldPanel ; } private JPanel createSearchSettingsPanel ( ) { JPanel searchSettings = new JPanel ( new VariableGridLayout ( VariableGridLayout . FIXED_NUM_COLUMNS , 3 ) ) ; searchSettings . setBorder ( new EmptyBorder ( 0 , 0 , 12 , 12 ) ) ; SettingsActionHandler actionHandler = new SettingsActionHandler ( ) ; ButtonGroup fileset = new ButtonGroup ( ) ; searchSettings . add ( new JLabel ( jEdit . getProperty ( "search.fileset" ) ) ) ; keepDialog = new JCheckBox ( jEdit . getProperty ( "search.keep" ) ) ; keepDialog . setMnemonic ( jEdit . getProperty ( "search.keep.mnemonic" ) . charAt ( 0 ) ) ; searchSettings . add ( keepDialog ) ; searchSettings . add ( new JLabel ( jEdit . getProperty ( "search.direction" ) ) ) ; ButtonGroup direction = new ButtonGroup ( ) ; searchCurrentBuffer = new JRadioButton ( jEdit . getProperty ( "search.current" ) ) ; searchCurrentBuffer . setMnemonic ( jEdit . getProperty ( "search.current.mnemonic" ) . charAt ( 0 ) ) ; fileset . add ( searchCurrentBuffer ) ; searchSettings . add ( searchCurrentBuffer ) ; searchCurrentBuffer . addActionListener ( actionHandler ) ; ignoreCase = new JCheckBox ( jEdit . getProperty ( "search.case" ) ) ; ignoreCase . setMnemonic ( jEdit . getProperty ( "search.case.mnemonic" ) . charAt ( 0 ) ) ; searchSettings . add ( ignoreCase ) ; ignoreCase . addActionListener ( actionHandler ) ; searchBack = new JRadioButton ( jEdit . getProperty ( "search.back" ) ) ; searchBack . setMnemonic ( jEdit . getProperty ( "search.back.mnemonic" ) . charAt ( 0 ) ) ; direction . add ( searchBack ) ; searchSettings . add ( searchBack ) ; searchBack . addActionListener ( actionHandler ) ; searchAllBuffers = new JRadioButton ( jEdit . getProperty ( "search.all" ) ) ; searchAllBuffers . setMnemonic ( jEdit . getProperty ( "search.all.mnemonic" ) . charAt ( 0 ) ) ; fileset . add ( searchAllBuffers ) ; searchSettings . add ( searchAllBuffers ) ; searchAllBuffers . addActionListener ( actionHandler ) ; regexp = new JCheckBox ( jEdit . getProperty ( "search.regexp" ) ) ; regexp . setMnemonic ( jEdit . getProperty ( "search.regexp.mnemonic" ) . charAt ( 0 ) ) ; searchSettings . add ( regexp ) ; regexp . addActionListener ( actionHandler ) ; searchForward = new JRadioButton ( jEdit . getProperty ( "search.forward" ) ) ; searchForward . setMnemonic ( jEdit . getProperty ( "search.forward.mnemonic" ) . charAt ( 0 ) ) ; direction . add ( searchForward ) ; searchSettings . add ( searchForward ) ; searchForward . addActionListener ( actionHandler ) ; searchDirectory = new JRadioButton ( jEdit . getProperty ( "search.directory" ) ) ; searchDirectory . setMnemonic ( jEdit . getProperty ( "search.directory.mnemonic" ) . charAt ( 0 ) ) ; fileset . add ( searchDirectory ) ; searchSettings . add ( searchDirectory ) ; searchDirectory . addActionListener ( actionHandler ) ; hyperSearch = new JCheckBox ( jEdit . getProperty ( "search.hypersearch" ) ) ; hyperSearch . setMnemonic ( jEdit . getProperty ( "search.hypersearch.mnemonic" ) . charAt ( 0 ) ) ; searchSettings . add ( hyperSearch ) ; hyperSearch . addActionListener ( actionHandler ) ; wrap = new JCheckBox ( jEdit . getProperty ( "search.wrap" ) ) ; wrap . setMnemonic ( jEdit . getProperty ( "search.wrap.mnemonic" ) . charAt ( 0 ) ) ; searchSettings . add ( wrap ) ; wrap . addActionListener ( actionHandler ) ; return searchSettings ; } private JPanel createMultiFilePanel ( ) { JPanel multifile = new JPanel ( ) ; GridBagLayout layout = new GridBagLayout ( ) ; multifile . setLayout ( layout ) ; GridBagConstraints cons = new GridBagConstraints ( ) ; cons . gridy = cons . gridwidth = cons . gridheight = 1 ; cons . anchor = GridBagConstraints . WEST ; cons . fill = GridBagConstraints . HORIZONTAL ; MultiFileActionHandler actionListener = new MultiFileActionHandler ( ) ; filter = new HistoryTextField ( "search.filter" ) ; filter . addActionListener ( actionListener ) ; cons . insets = new Insets ( 0 , 0 , 3 , 0 ) ; JLabel label = new JLabel ( jEdit . getProperty ( "search.filterField" ) , SwingConstants . RIGHT ) ; label . setBorder ( new EmptyBorder ( 0 , 0 , 0 , 12 ) ) ; label . setDisplayedMnemonic ( jEdit . getProperty ( "search.filterField.mnemonic" ) . charAt ( 0 ) ) ; label . setLabelFor ( filter ) ; cons . weightx = 0.0f ; layout . setConstraints ( label , cons ) ; multifile . add ( label ) ; cons . insets = new Insets ( 0 , 0 , 3 , 6 ) ; cons . weightx = 1.0f ; layout . setConstraints ( filter , cons ) ; multifile . add ( filter ) ; cons . gridy ++ ; directory = new HistoryTextField ( "search.directory" ) ; directory . addActionListener ( actionListener ) ; label = new JLabel ( jEdit . getProperty ( "search.directoryField" ) , SwingConstants . RIGHT ) ; label . setBorder ( new EmptyBorder ( 0 , 0 , 0 , 12 ) ) ; label . setDisplayedMnemonic ( jEdit . getProperty ( "search.directoryField.mnemonic" ) . charAt ( 0 ) ) ; label . setLabelFor ( directory ) ; cons . insets = new Insets ( 0 , 0 , 3 , 0 ) ; cons . weightx = 0.0f ; layout . setConstraints ( label , cons ) ; multifile . add ( label ) ; cons . insets = new Insets ( 0 , 0 , 3 , 6 ) ; cons . weightx = 1.0f ; cons . gridwidth = 2 ; layout . setConstraints ( directory , cons ) ; multifile . add ( directory ) ; choose = new JButton ( jEdit . getProperty ( "search.choose" ) ) ; choose . setMnemonic ( jEdit . getProperty ( "search.choose.mnemonic" ) . charAt ( 0 ) ) ; cons . insets = new Insets ( 0 , 0 , 3 , 0 ) ; cons . weightx = 0.0f ; cons . gridwidth = 1 ; layout . setConstraints ( choose , cons ) ; multifile . add ( choose ) ; choose . addActionListener ( actionListener ) ; cons . insets = new Insets ( 0 , 0 , 0 , 0 ) ; cons . gridy ++ ; cons . gridwidth = 4 ; searchSubDirectories = new JCheckBox ( jEdit . getProperty ( "search.subdirs" ) ) ; searchSubDirectories . setMnemonic ( jEdit . getProperty ( "search.subdirs.mnemonic" ) . charAt ( 0 ) ) ; layout . setConstraints ( searchSubDirectories , cons ) ; multifile . add ( searchSubDirectories ) ; return multifile ; } private Box createButtonsPanel ( ) { Box box = new Box ( BoxLayout . Y_AXIS ) ; ButtonActionHandler actionHandler = new ButtonActionHandler ( ) ; box . add ( Box . createVerticalStrut ( 12 ) ) ; JPanel grid = new JPanel ( new GridLayout ( 5 , 1 , 0 , 12 ) ) ; findBtn = new JButton ( jEdit . getProperty ( "search.findBtn" ) ) ; getRootPane ( ) . setDefaultButton ( findBtn ) ; grid . add ( findBtn ) ; findBtn . addActionListener ( actionHandler ) ; replaceBtn = new JButton ( jEdit . getProperty ( "search.replaceBtn" ) ) ; replaceBtn . setMnemonic ( jEdit . getProperty ( "search.replaceBtn.mnemonic" ) . charAt ( 0 ) ) ; grid . add ( replaceBtn ) ; replaceBtn . addActionListener ( actionHandler ) ; replaceAndFindBtn = new JButton ( jEdit . getProperty ( "search.replaceAndFindBtn" ) ) ; replaceAndFindBtn . setMnemonic ( jEdit . getProperty ( "search.replaceAndFindBtn.mnemonic" ) . charAt ( 0 ) ) ; grid . add ( replaceAndFindBtn ) ; replaceAndFindBtn . addActionListener ( actionHandler ) ; replaceAllBtn = new JButton ( jEdit . getProperty ( "search.replaceAllBtn" ) ) ; replaceAllBtn . setMnemonic ( jEdit . getProperty ( "search.replaceAllBtn.mnemonic" ) . charAt ( 0 ) ) ; grid . add ( replaceAllBtn ) ; replaceAllBtn . addActionListener ( actionHandler ) ; closeBtn = new JButton ( jEdit . getProperty ( "common.close" ) ) ; grid . add ( closeBtn ) ; closeBtn . addActionListener ( actionHandler ) ; grid . setMaximumSize ( grid . getPreferredSize ( ) ) ; box . add ( grid ) ; box . add ( Box . createGlue ( ) ) ; return box ; } private void updateEnabled ( ) { boolean replaceEnabled = ! hyperSearch . isSelected ( ) ; stringReplace . setEnabled ( replaceEnabled ) ; beanShellReplace . setEnabled ( replaceEnabled ) ; replace . setEnabled ( replaceEnabled ) ; replaceBtn . setEnabled ( replaceEnabled ) ; replaceAndFindBtn . setEnabled ( replaceEnabled ) ; replaceAllBtn . setEnabled ( replaceEnabled ) ; wrap . setEnabled ( replaceEnabled ) ; boolean reverseEnabled = replaceEnabled && searchCurrentBuffer . isSelected ( ) ; searchBack . setEnabled ( reverseEnabled ) ; searchForward . setEnabled ( reverseEnabled ) ; boolean regexpEnabled = ( hyperSearch . isSelected ( ) || ! ( searchBack . isEnabled ( ) && searchBack . isSelected ( ) ) ) ; regexp . setEnabled ( regexpEnabled ) ; filter . setEnabled ( searchAllBuffers . isSelected ( ) || searchDirectory . isSelected ( ) ) ; boolean directoryEnabled = searchDirectory . isSelected ( ) ; directory . setEnabled ( directoryEnabled ) ; choose . setEnabled ( directoryEnabled ) ; searchSubDirectories . setEnabled ( directoryEnabled ) ; } private boolean save ( ) { String filter = this . filter . getText ( ) ; this . filter . addCurrentToHistory ( ) ; if ( filter . length ( ) == 0 ) filter = "*" ; SearchFileSet fileset = SearchAndReplace . getSearchFileSet ( ) ; if ( searchCurrentBuffer . isSelected ( ) ) fileset = new CurrentBufferSet ( ) ; else if ( searchAllBuffers . isSelected ( ) ) fileset = new AllBufferSet ( filter ) ; else if ( searchDirectory . isSelected ( ) ) { String directory = this . directory . getText ( ) ; this . directory . addCurrentToHistory ( ) ; boolean recurse = searchSubDirectories . isSelected ( ) ; if ( fileset instanceof DirectoryListSet ) { DirectoryListSet dset = ( DirectoryListSet ) fileset ; if ( ! dset . getDirectory ( ) . equals ( directory ) || ! dset . getFileFilter ( ) . equals ( filter ) || ! dset . isRecursive ( ) == recurse ) fileset = new DirectoryListSet ( directory , filter , recurse ) ; } else fileset = new DirectoryListSet ( directory , filter , recurse ) ; } else { fileset = null ; } jEdit . setBooleanProperty ( "search.keepDialog.toggle" , keepDialog . isSelected ( ) ) ; jEdit . setBooleanProperty ( "search.hypersearch.toggle" , hyperSearch . isSelected ( ) ) ; boolean ok = true ; if ( fileset . getBufferCount ( ) == 0 ) { GUIUtilities . error ( this , "empty-fileset" , null ) ; ok = false ; } else SearchAndReplace . setSearchFileSet ( fileset ) ; if ( find . getText ( ) . length ( ) != 0 ) { find . addCurrentToHistory ( ) ; SearchAndReplace . setSearchString ( find . getText ( ) ) ; replace . addCurrentToHistory ( ) ; SearchAndReplace . setReplaceString ( replace . getText ( ) ) ; } else ok = false ; return ok ; } private void closeOrKeepDialog ( ) { if ( keepDialog . isSelected ( ) ) return ; else { GUIUtilities . saveGeometry ( this , "search" ) ; setVisible ( false ) ; } } class MyJRadioButton extends JRadioButton { MyJRadioButton ( String label ) { super ( label ) ; } public boolean isFocusTraversable ( ) { return false ; } } class ReplaceActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { replace . setModel ( beanShellReplace . isSelected ( ) ? "replace.script" : "replace" ) ; SearchAndReplace . setBeanShellReplace ( beanShellReplace . isSelected ( ) ) ; } } class SettingsActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == ignoreCase ) SearchAndReplace . setIgnoreCase ( ignoreCase . isSelected ( ) ) ; else if ( source == regexp ) SearchAndReplace . setRegexp ( regexp . isSelected ( ) ) ; else if ( source == searchBack || source == searchForward ) SearchAndReplace . setReverseSearch ( searchBack . isSelected ( ) ) ; else if ( source == wrap ) SearchAndReplace . setAutoWrapAround ( wrap . isSelected ( ) ) ; updateEnabled ( ) ; } } class MultiFileActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { if ( evt . getSource ( ) == choose ) { File dir = new File ( directory . getText ( ) ) ; JFileChooser chooser = new JFileChooser ( dir . getParent ( ) ) ; chooser . setFileSelectionMode ( JFileChooser . DIRECTORIES_ONLY ) ; chooser . setSelectedFile ( dir ) ; if ( chooser . showOpenDialog ( SearchDialog . this ) == JFileChooser . APPROVE_OPTION ) directory . setText ( chooser . getSelectedFile ( ) . getPath ( ) ) ; } else { ok ( ) ; } } } class ButtonActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == closeBtn ) cancel ( ) ; else if ( source == findBtn || source == find || source == replace ) { ok ( ) ; } else if ( source == replaceBtn ) { save ( ) ; if ( SearchAndReplace . replace ( view ) ) closeOrKeepDialog ( ) ; else getToolkit ( ) . beep ( ) ; } else if ( source == replaceAndFindBtn ) { save ( ) ; if ( SearchAndReplace . replace ( view ) ) ok ( ) ; else getToolkit ( ) . beep ( ) ; } else if ( source == replaceAllBtn ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . WAIT_CURSOR ) ) ; save ( ) ; if ( SearchAndReplace . replaceAll ( view ) ) closeOrKeepDialog ( ) ; else getToolkit ( ) . beep ( ) ; setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; } } } } 	1	['30', '7', '0', '22', '137', '315', '7', '20', '4', '0.830140485', '1603', '0.888888889', '5', '0.958883994', '0.233333333', '2', '2', '51.53333333', '11', '2.0333', '7']
package org . gjt . sp . jedit ; import java . util . Enumeration ; import java . util . Vector ; public abstract class EBMessage { public EBMessage ( EBComponent source ) { this . source = source ; } public EBComponent getSource ( ) { return source ; } public void veto ( ) { vetoed = true ; } public boolean isVetoed ( ) { return vetoed ; } public String toString ( ) { return getClass ( ) . getName ( ) + "[" + paramString ( ) + "]" ; } public String paramString ( ) { return "source=" + source ; } private EBComponent source ; private boolean vetoed ; public static abstract class NonVetoable extends EBMessage { public NonVetoable ( EBComponent source ) { super ( source ) ; } public void veto ( ) { throw new InternalError ( "Can't veto this message" ) ; } } } 	0	['6', '1', '3', '29', '14', '7', '29', '1', '6', '0.6', '49', '1', '1', '0', '0.583333333', '0', '0', '6.833333333', '1', '0.8333', '0']
package org . gjt . sp . jedit . io ; import java . awt . Component ; import java . util . Vector ; import org . gjt . sp . jedit . jEdit ; public class FavoritesVFS extends VFS { public static final String PROTOCOL = "favorites" ; public FavoritesVFS ( ) { super ( "favorites" ) ; instance = this ; } public int getCapabilities ( ) { return DELETE_CAP ; } public String getParentOfPath ( String path ) { return PROTOCOL + ":" ; } public VFS . DirectoryEntry [ ] _listDirectory ( Object session , String url , Component comp ) { synchronized ( lock ) { VFS . DirectoryEntry [ ] retVal = new VFS . DirectoryEntry [ favorites . size ( ) ] ; for ( int i = 0 ; i < retVal . length ; i ++ ) { String favorite = ( String ) favorites . elementAt ( i ) ; retVal [ i ] = _getDirectoryEntry ( session , favorite , comp ) ; } return retVal ; } } public DirectoryEntry _getDirectoryEntry ( Object session , String path , Component comp ) { return new VFS . DirectoryEntry ( path , path , "favorites:" + path , VFS . DirectoryEntry . DIRECTORY , 0L , false ) ; } public boolean _delete ( Object session , String path , Component comp ) { synchronized ( lock ) { path = path . substring ( PROTOCOL . length ( ) + 1 ) ; favorites . removeElement ( path ) ; VFSManager . sendVFSUpdate ( this , PROTOCOL + ":" , false ) ; } return true ; } public static void loadFavorites ( ) { synchronized ( lock ) { String favorite ; int i = 0 ; while ( ( favorite = jEdit . getProperty ( "vfs.favorite." + i ) ) != null ) { favorites . addElement ( favorite ) ; i ++ ; } } } public static void addToFavorites ( String path ) { synchronized ( lock ) { favorites . addElement ( path ) ; VFSManager . sendVFSUpdate ( instance , PROTOCOL + ":" , false ) ; } } public static void saveFavorites ( ) { synchronized ( lock ) { for ( int i = 0 ; i < favorites . size ( ) ; i ++ ) { jEdit . setProperty ( "vfs.favorite." + i , ( String ) favorites . elementAt ( i ) ) ; } jEdit . unsetProperty ( "vfs.favorite." + favorites . size ( ) ) ; } } private static FavoritesVFS instance ; private static Object lock = new Object ( ) ; private static Vector favorites = new Vector ( ) ; } 	1	['10', '2', '0', '5', '28', '13', '3', '4', '9', '0.722222222', '230', '0.75', '1', '0.724137931', '0.472222222', '1', '3', '21.6', '3', '1.2', '2']
package gnu . regexp ; final class RETokenLookAhead extends REToken { RE re ; boolean negative ; RETokenLookAhead ( Object pattern , int cflags , RESyntax syntax , boolean negative ) throws REException { super ( 0 ) ; re = new RE ( pattern , cflags , syntax ) ; this . negative = negative ; } boolean match ( CharIndexed input , REMatch mymatch ) { REMatch trymatch = ( REMatch ) mymatch . clone ( ) ; REMatch trymatch1 = ( REMatch ) mymatch . clone ( ) ; REMatch newMatch = null ; if ( re . match ( input , trymatch ) ) { if ( negative ) return false ; if ( next ( input , trymatch1 ) ) newMatch = trymatch1 ; } if ( newMatch != null ) { if ( negative ) return false ; mymatch . assignFrom ( newMatch ) ; return true ; } else { if ( negative ) return next ( input , mymatch ) ; return false ; } } } 	0	['2', '2', '0', '6', '8', '0', '1', '6', '0', '0', '69', '0', '1', '0.875', '0.571428571', '1', '1', '32.5', '7', '3.5', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import java . awt . event . * ; import java . io . File ; import org . gjt . sp . jedit . * ; public class CurrentDirectoryMenu extends EnhancedMenu { public CurrentDirectoryMenu ( ) { super ( "current-directory" ) ; } public void setPopupMenuVisible ( boolean b ) { if ( b ) { final View view = EditAction . getView ( this ) ; if ( getMenuComponentCount ( ) != 0 ) removeAll ( ) ; File file = view . getBuffer ( ) . getFile ( ) ; if ( file == null ) { JMenuItem mi = new JMenuItem ( jEdit . getProperty ( "current-directory.not-local" ) ) ; mi . setEnabled ( false ) ; add ( mi ) ; super . setPopupMenuVisible ( b ) ; return ; } File dir = new File ( file . getParent ( ) ) ; JMenuItem mi = new JMenuItem ( dir . getPath ( ) ) ; mi . setEnabled ( false ) ; add ( mi ) ; addSeparator ( ) ; JMenu current = this ; ActionListener listener = new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { jEdit . openFile ( view , evt . getActionCommand ( ) ) ; } } ; String backupPrefix = jEdit . getProperty ( "backup.prefix" ) ; String backupSuffix = jEdit . getProperty ( "backup.suffix" ) ; String [ ] list = dir . list ( ) ; if ( list != null ) { MiscUtilities . quicksort ( list , new MiscUtilities . StringICaseCompare ( ) ) ; for ( int i = 0 ; i < list . length ; i ++ ) { String name = list [ i ] ; if ( name . endsWith ( ".marks" ) ) continue ; if ( name . startsWith ( "#" ) && name . endsWith ( "#" ) ) continue ; if ( ( backupPrefix . length ( ) != 0 && name . startsWith ( backupPrefix ) ) || ( backupSuffix . length ( ) != 0 && name . endsWith ( backupSuffix ) ) ) continue ; file = new File ( dir , name ) ; if ( file . isDirectory ( ) ) continue ; mi = new JMenuItem ( name ) ; mi . setActionCommand ( file . getPath ( ) ) ; mi . addActionListener ( listener ) ; if ( current . getItemCount ( ) >= 20 ) { JMenu newCurrent = new JMenu ( jEdit . getProperty ( "common.more" ) ) ; current . add ( newCurrent ) ; current = newCurrent ; } current . add ( mi ) ; } } } super . setPopupMenuVisible ( b ) ; } } 	1	['2', '8', '0', '10', '30', '1', '2', '9', '2', '2', '175', '0', '0', '0.998835856', '0.75', '2', '3', '86.5', '15', '7.5', '3']
package gnu . regexp ; import java . io . Serializable ; import java . util . BitSet ; public final class RESyntax implements Serializable { static final String DEFAULT_LINE_SEPARATOR = System . getProperty ( "line.separator" ) ; private static final String SYNTAX_IS_FINAL = RE . getLocalizedMessage ( "syntax.final" ) ; private BitSet bits ; private boolean isFinal = false ; private String lineSeparator = DEFAULT_LINE_SEPARATOR ; public static final int RE_BACKSLASH_ESCAPE_IN_LISTS = 0 ; public static final int RE_BK_PLUS_QM = 1 ; public static final int RE_CHAR_CLASSES = 2 ; public static final int RE_CONTEXT_INDEP_ANCHORS = 3 ; public static final int RE_CONTEXT_INDEP_OPS = 4 ; public static final int RE_CONTEXT_INVALID_OPS = 5 ; public static final int RE_DOT_NEWLINE = 6 ; public static final int RE_DOT_NOT_NULL = 7 ; public static final int RE_INTERVALS = 8 ; public static final int RE_LIMITED_OPS = 9 ; public static final int RE_NEWLINE_ALT = 10 ; public static final int RE_NO_BK_BRACES = 11 ; public static final int RE_NO_BK_PARENS = 12 ; public static final int RE_NO_BK_REFS = 13 ; public static final int RE_NO_BK_VBAR = 14 ; public static final int RE_NO_EMPTY_RANGES = 15 ; public static final int RE_UNMATCHED_RIGHT_PAREN_ORD = 16 ; public static final int RE_HAT_LISTS_NOT_NEWLINE = 17 ; public static final int RE_STINGY_OPS = 18 ; public static final int RE_CHAR_CLASS_ESCAPES = 19 ; public static final int RE_PURE_GROUPING = 20 ; public static final int RE_LOOKAHEAD = 21 ; public static final int RE_STRING_ANCHORS = 22 ; public static final int RE_COMMENTS = 23 ; public static final int RE_CHAR_CLASS_ESC_IN_LISTS = 24 ; private static final int BIT_TOTAL = 25 ; public static final RESyntax RE_SYNTAX_AWK ; public static final RESyntax RE_SYNTAX_ED ; public static final RESyntax RE_SYNTAX_EGREP ; public static final RESyntax RE_SYNTAX_EMACS ; public static final RESyntax RE_SYNTAX_GREP ; public static final RESyntax RE_SYNTAX_POSIX_AWK ; public static final RESyntax RE_SYNTAX_POSIX_BASIC ; public static final RESyntax RE_SYNTAX_POSIX_EGREP ; public static final RESyntax RE_SYNTAX_POSIX_EXTENDED ; public static final RESyntax RE_SYNTAX_POSIX_MINIMAL_BASIC ; public static final RESyntax RE_SYNTAX_POSIX_MINIMAL_EXTENDED ; public static final RESyntax RE_SYNTAX_SED ; public static final RESyntax RE_SYNTAX_PERL4 ; public static final RESyntax RE_SYNTAX_PERL4_S ; public static final RESyntax RE_SYNTAX_PERL5 ; public static final RESyntax RE_SYNTAX_PERL5_S ; static { RE_SYNTAX_EMACS = new RESyntax ( ) . makeFinal ( ) ; RESyntax RE_SYNTAX_POSIX_COMMON = new RESyntax ( ) . set ( RE_CHAR_CLASSES ) . set ( RE_DOT_NEWLINE ) . set ( RE_DOT_NOT_NULL ) . set ( RE_INTERVALS ) . set ( RE_NO_EMPTY_RANGES ) . makeFinal ( ) ; RE_SYNTAX_POSIX_BASIC = new RESyntax ( RE_SYNTAX_POSIX_COMMON ) . set ( RE_BK_PLUS_QM ) . makeFinal ( ) ; RE_SYNTAX_POSIX_EXTENDED = new RESyntax ( RE_SYNTAX_POSIX_COMMON ) . set ( RE_CONTEXT_INDEP_ANCHORS ) . set ( RE_CONTEXT_INDEP_OPS ) . set ( RE_NO_BK_BRACES ) . set ( RE_NO_BK_PARENS ) . set ( RE_NO_BK_VBAR ) . set ( RE_UNMATCHED_RIGHT_PAREN_ORD ) . makeFinal ( ) ; RE_SYNTAX_AWK = new RESyntax ( ) . set ( RE_BACKSLASH_ESCAPE_IN_LISTS ) . set ( RE_DOT_NOT_NULL ) . set ( RE_NO_BK_PARENS ) . set ( RE_NO_BK_REFS ) . set ( RE_NO_BK_VBAR ) . set ( RE_NO_EMPTY_RANGES ) . set ( RE_UNMATCHED_RIGHT_PAREN_ORD ) . makeFinal ( ) ; RE_SYNTAX_POSIX_AWK = new RESyntax ( RE_SYNTAX_POSIX_EXTENDED ) . set ( RE_BACKSLASH_ESCAPE_IN_LISTS ) . makeFinal ( ) ; RE_SYNTAX_GREP = new RESyntax ( ) . set ( RE_BK_PLUS_QM ) . set ( RE_CHAR_CLASSES ) . set ( RE_HAT_LISTS_NOT_NEWLINE ) . set ( RE_INTERVALS ) . set ( RE_NEWLINE_ALT ) . makeFinal ( ) ; RE_SYNTAX_EGREP = new RESyntax ( ) . set ( RE_CHAR_CLASSES ) . set ( RE_CONTEXT_INDEP_ANCHORS ) . set ( RE_CONTEXT_INDEP_OPS ) . set ( RE_HAT_LISTS_NOT_NEWLINE ) . set ( RE_NEWLINE_ALT ) . set ( RE_NO_BK_PARENS ) . set ( RE_NO_BK_VBAR ) . makeFinal ( ) ; RE_SYNTAX_POSIX_EGREP = new RESyntax ( RE_SYNTAX_EGREP ) . set ( RE_INTERVALS ) . set ( RE_NO_BK_BRACES ) . makeFinal ( ) ; RE_SYNTAX_ED = new RESyntax ( RE_SYNTAX_POSIX_BASIC ) . makeFinal ( ) ; RE_SYNTAX_SED = new RESyntax ( RE_SYNTAX_POSIX_BASIC ) . makeFinal ( ) ; RE_SYNTAX_POSIX_MINIMAL_BASIC = new RESyntax ( RE_SYNTAX_POSIX_COMMON ) . set ( RE_LIMITED_OPS ) . makeFinal ( ) ; RE_SYNTAX_POSIX_MINIMAL_EXTENDED = new RESyntax ( RE_SYNTAX_POSIX_COMMON ) . set ( RE_CONTEXT_INDEP_ANCHORS ) . set ( RE_CONTEXT_INVALID_OPS ) . set ( RE_NO_BK_BRACES ) . set ( RE_NO_BK_PARENS ) . set ( RE_NO_BK_REFS ) . set ( RE_NO_BK_VBAR ) . set ( RE_UNMATCHED_RIGHT_PAREN_ORD ) . makeFinal ( ) ; RE_SYNTAX_PERL4 = new RESyntax ( ) . set ( RE_BACKSLASH_ESCAPE_IN_LISTS ) . set ( RE_CONTEXT_INDEP_ANCHORS ) . set ( RE_CONTEXT_INDEP_OPS ) . set ( RE_INTERVALS ) . set ( RE_NO_BK_BRACES ) . set ( RE_NO_BK_PARENS ) . set ( RE_NO_BK_VBAR ) . set ( RE_NO_EMPTY_RANGES ) . set ( RE_CHAR_CLASS_ESCAPES ) . makeFinal ( ) ; RE_SYNTAX_PERL4_S = new RESyntax ( RE_SYNTAX_PERL4 ) . set ( RE_DOT_NEWLINE ) . makeFinal ( ) ; RE_SYNTAX_PERL5 = new RESyntax ( RE_SYNTAX_PERL4 ) . set ( RE_PURE_GROUPING ) . set ( RE_STINGY_OPS ) . set ( RE_LOOKAHEAD ) . set ( RE_STRING_ANCHORS ) . set ( RE_CHAR_CLASS_ESC_IN_LISTS ) . set ( RE_COMMENTS ) . makeFinal ( ) ; RE_SYNTAX_PERL5_S = new RESyntax ( RE_SYNTAX_PERL5 ) . set ( RE_DOT_NEWLINE ) . makeFinal ( ) ; } public RESyntax ( ) { bits = new BitSet ( BIT_TOTAL ) ; } public RESyntax makeFinal ( ) { isFinal = true ; return this ; } public RESyntax ( RESyntax other ) { bits = ( BitSet ) other . bits . clone ( ) ; } public boolean get ( int index ) { return bits . get ( index ) ; } public RESyntax set ( int index ) { if ( isFinal ) throw new IllegalAccessError ( SYNTAX_IS_FINAL ) ; bits . set ( index ) ; return this ; } public RESyntax clear ( int index ) { if ( isFinal ) throw new IllegalAccessError ( SYNTAX_IS_FINAL ) ; bits . clear ( index ) ; return this ; } public RESyntax setLineSeparator ( String aSeparator ) { if ( isFinal ) throw new IllegalAccessError ( SYNTAX_IS_FINAL ) ; lineSeparator = aSeparator ; return this ; } public String getLineSeparator ( ) { return lineSeparator ; } } 	0	['9', '1', '0', '4', '18', '0', '4', '1', '8', '1.015957447', '361', '0.106382979', '16', '0', '0.40625', '0', '0', '33.88888889', '2', '1', '0']
package org . gjt . sp . jedit . options ; import javax . swing . border . EmptyBorder ; import javax . swing . event . * ; import javax . swing . plaf . metal . MetalLookAndFeel ; import javax . swing . table . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . util . Vector ; import org . gjt . sp . jedit . syntax . SyntaxStyle ; import org . gjt . sp . jedit . gui . EnhancedDialog ; import org . gjt . sp . jedit . * ; public class ColorOptionPane extends AbstractOptionPane { public static final EmptyBorder noFocusBorder = new EmptyBorder ( 1 , 1 , 1 , 1 ) ; public ColorOptionPane ( ) { super ( "color" ) ; } protected void _init ( ) { setLayout ( new BorderLayout ( ) ) ; add ( BorderLayout . CENTER , createColorTableScroller ( ) ) ; } protected void _save ( ) { colorModel . save ( ) ; } private ColorTableModel colorModel ; private JTable colorTable ; private JScrollPane createColorTableScroller ( ) { colorModel = createColorTableModel ( ) ; colorTable = new JTable ( colorModel ) ; colorTable . setRowSelectionAllowed ( false ) ; colorTable . setColumnSelectionAllowed ( false ) ; colorTable . setCellSelectionEnabled ( false ) ; colorTable . getTableHeader ( ) . setReorderingAllowed ( false ) ; colorTable . addMouseListener ( new MouseHandler ( ) ) ; TableColumnModel tcm = colorTable . getColumnModel ( ) ; TableColumn colorColumn = tcm . getColumn ( 1 ) ; colorColumn . setCellRenderer ( new ColorTableModel . ColorRenderer ( ) ) ; Dimension d = colorTable . getPreferredSize ( ) ; d . height = Math . min ( d . height , 100 ) ; JScrollPane scroller = new JScrollPane ( colorTable ) ; scroller . setPreferredSize ( d ) ; return scroller ; } private ColorTableModel createColorTableModel ( ) { return new ColorTableModel ( ) ; } class MouseHandler extends MouseAdapter { public void mouseClicked ( MouseEvent evt ) { int row = colorTable . rowAtPoint ( evt . getPoint ( ) ) ; if ( row == - 1 ) return ; Color color = JColorChooser . showDialog ( ColorOptionPane . this , jEdit . getProperty ( "colorChooser.title" ) , ( Color ) colorModel . getValueAt ( row , 1 ) ) ; if ( color != null ) colorModel . setValueAt ( color , row , 1 ) ; } } } class ColorTableModel extends AbstractTableModel { private Vector colorChoices ; ColorTableModel ( ) { colorChoices = new Vector ( 16 ) ; addColorChoice ( "options.color.bgColor" , "view.bgColor" ) ; addColorChoice ( "options.color.fgColor" , "view.fgColor" ) ; addColorChoice ( "options.color.caretColor" , "view.caretColor" ) ; addColorChoice ( "options.color.selectionColor" , "view.selectionColor" ) ; addColorChoice ( "options.color.lineHighlightColor" , "view.lineHighlightColor" ) ; addColorChoice ( "options.color.bracketHighlightColor" , "view.bracketHighlightColor" ) ; addColorChoice ( "options.color.eolMarkerColor" , "view.eolMarkerColor" ) ; addColorChoice ( "options.color.wrapGuideColor" , "view.wrapGuideColor" ) ; addColorChoice ( "options.color.gutterBgColor" , "view.gutter.bgColor" ) ; addColorChoice ( "options.color.gutterFgColor" , "view.gutter.fgColor" ) ; addColorChoice ( "options.color.gutterHighlightColor" , "view.gutter.highlightColor" ) ; addColorChoice ( "options.color.gutterCurrentLineColor" , "view.gutter.currentLineColor" ) ; addColorChoice ( "options.color.gutterMarkerColor" , "view.gutter.markerColor" ) ; addColorChoice ( "options.color.gutterFoldColor" , "view.gutter.foldColor" ) ; addColorChoice ( "options.color.gutterFocusBorderColor" , "view.gutter.focusBorderColor" ) ; addColorChoice ( "options.color.gutterNoFocusBorderColor" , "view.gutter.noFocusBorderColor" ) ; if ( ! ( UIManager . getLookAndFeel ( ) instanceof MetalLookAndFeel ) ) { addColorChoice ( "options.color.dockingBorderColor" , "view.docking.borderColor" ) ; } } public int getColumnCount ( ) { return 2 ; } public int getRowCount ( ) { return colorChoices . size ( ) ; } public Object getValueAt ( int row , int col ) { ColorChoice ch = ( ColorChoice ) colorChoices . elementAt ( row ) ; switch ( col ) { case 0 : return ch . label ; case 1 : return ch . color ; default : return null ; } } public void setValueAt ( Object value , int row , int col ) { ColorChoice ch = ( ColorChoice ) colorChoices . elementAt ( row ) ; if ( col == 1 ) ch . color = ( Color ) value ; fireTableRowsUpdated ( row , row ) ; } public String getColumnName ( int index ) { switch ( index ) { case 0 : return jEdit . getProperty ( "options.color.object" ) ; case 1 : return jEdit . getProperty ( "options.color.color" ) ; default : return null ; } } public void save ( ) { for ( int i = 0 ; i < colorChoices . size ( ) ; i ++ ) { ColorChoice ch = ( ColorChoice ) colorChoices . elementAt ( i ) ; jEdit . setProperty ( ch . property , GUIUtilities . getColorHexString ( ch . color ) ) ; } } private void addColorChoice ( String label , String property ) { colorChoices . addElement ( new ColorChoice ( jEdit . getProperty ( label ) , property , GUIUtilities . parseColor ( jEdit . getProperty ( property ) ) ) ) ; } static class ColorChoice { String label ; String property ; Color color ; ColorChoice ( String label , String property , Color color ) { this . label = label ; this . property = property ; this . color = color ; } } static class ColorRenderer extends JLabel implements TableCellRenderer { public ColorRenderer ( ) { setOpaque ( true ) ; setBorder ( StyleOptionPane . noFocusBorder ) ; } public Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean cellHasFocus , int row , int col ) { if ( isSelected ) { setBackground ( table . getSelectionBackground ( ) ) ; setForeground ( table . getSelectionForeground ( ) ) ; } else { setBackground ( table . getBackground ( ) ) ; setForeground ( table . getForeground ( ) ) ; } if ( value != null ) setBackground ( ( Color ) value ) ; setBorder ( ( cellHasFocus ) ? UIManager . getBorder ( "Table.focusCellHighlightBorder" ) : StyleOptionPane . noFocusBorder ) ; return this ; } } } 	1	['8', '6', '0', '5', '31', '20', '2', '4', '1', '0.761904762', '123', '0.666666667', '1', '0.991017964', '0.5', '4', '12', '14', '2', '0.875', '2']
package org . gjt . sp . jedit . search ; import gnu . regexp . * ; import java . util . Vector ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class AllBufferSet extends BufferListSet { public AllBufferSet ( String glob ) { super ( listFiles ( glob ) ) ; this . glob = glob ; } public String getFileFilter ( ) { return glob ; } public String getCode ( ) { return "new AllBufferSet(\"" + MiscUtilities . charsToEscapes ( glob ) + "\")" ; } private String glob ; private static Vector listFiles ( String glob ) { Buffer [ ] buffers = jEdit . getBuffers ( ) ; Vector vector = new Vector ( buffers . length ) ; RE filter ; try { filter = new RE ( MiscUtilities . globToRE ( glob ) ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , DirectoryListSet . class , e ) ; return vector ; } for ( int i = 0 ; i < buffers . length ; i ++ ) { Buffer buffer = buffers [ i ] ; if ( filter . isMatch ( buffer . getName ( ) ) ) vector . addElement ( buffer . getPath ( ) ) ; } return vector ; } } 	0	['5', '2', '0', '7', '22', '4', '1', '6', '3', '0.625', '93', '1', '0', '0.636363636', '0.6', '0', '0', '17.2', '4', '1.4', '0']
package org . gjt . sp . jedit . textarea ; import java . awt . * ; import java . awt . event . * ; import javax . swing . * ; import javax . swing . border . * ; import org . gjt . sp . jedit . * ; public class Gutter extends JComponent implements SwingConstants { public Gutter ( View view , JEditTextArea textArea ) { this . view = view ; this . textArea = textArea ; setDoubleBuffered ( true ) ; MouseHandler ml = new MouseHandler ( ) ; addMouseListener ( ml ) ; addMouseMotionListener ( ml ) ; } public void paintComponent ( Graphics gfx ) { Rectangle clip = gfx . getClipBounds ( ) ; gfx . setColor ( getBackground ( ) ) ; gfx . fillRect ( clip . x , clip . y , clip . width , clip . height ) ; if ( ! textArea . getBuffer ( ) . isLoaded ( ) ) return ; int lineHeight = textArea . getPainter ( ) . getFontMetrics ( ) . getHeight ( ) ; int firstLine = clip . y / lineHeight + textArea . getFirstLine ( ) ; int lastLine = ( clip . y + clip . height - 1 ) / lineHeight + textArea . getFirstLine ( ) ; FontMetrics pfm = textArea . getPainter ( ) . getFontMetrics ( ) ; Color fg = getForeground ( ) ; int baseline = ( int ) ( ( this . baseline + lineHeight - pfm . getDescent ( ) ) / 2.0 ) ; boolean highlightCurrentLine = currentLineHighlightEnabled && textArea . selection . size ( ) == 0 ; int y = ( clip . y - clip . y % lineHeight ) ; Buffer buffer = textArea . getBuffer ( ) ; int firstValidLine = firstLine >= 0 ? firstLine : 0 ; int lastValidLine = ( lastLine >= buffer . getVirtualLineCount ( ) ) ? buffer . getVirtualLineCount ( ) - 1 : lastLine ; for ( int line = firstLine ; line <= lastLine ; line ++ , y += lineHeight ) { boolean valid = ( line >= firstValidLine && line <= lastValidLine ) ; if ( highlights != null ) highlights . paintHighlight ( gfx , line , y ) ; if ( ! valid ) return ; int physicalLine = buffer . virtualToPhysical ( line ) ; if ( physicalLine != buffer . getLineCount ( ) - 1 ) { if ( buffer . isFoldStart ( physicalLine ) ) { gfx . setColor ( foldColor ) ; if ( buffer . isLineVisible ( physicalLine + 1 ) ) gfx . drawRect ( 2 , y + ( lineHeight - 6 ) / 2 , 5 , 5 ) ; else gfx . fillRect ( 2 , y + ( lineHeight - 6 ) / 2 , 6 , 6 ) ; } } if ( ! expanded ) continue ; String number = Integer . toString ( physicalLine + 1 ) ; int offset ; switch ( alignment ) { case RIGHT : offset = gutterSize . width - collapsedSize . width - ( fm . stringWidth ( number ) + 1 ) ; break ; case CENTER : offset = ( ( gutterSize . width - collapsedSize . width ) - fm . stringWidth ( number ) ) / 2 ; break ; case LEFT : default : offset = 0 ; break ; } if ( physicalLine == textArea . getCaretLine ( ) && highlightCurrentLine ) { gfx . setColor ( currentLineHighlight ) ; } else if ( interval > 1 && ( line + 1 ) % interval == 0 ) gfx . setColor ( intervalHighlight ) ; else gfx . setColor ( fg ) ; gfx . drawString ( number , FOLD_MARKER_SIZE + offset , baseline + y ) ; } } public void addCustomHighlight ( TextAreaHighlight highlight ) { highlight . init ( textArea , highlights ) ; highlights = highlight ; } public void setBorder ( int width , Color color1 , Color color2 , Color color3 ) { this . borderWidth = width ; focusBorder = new CompoundBorder ( new MatteBorder ( 0 , 0 , 0 , width , color3 ) , new MatteBorder ( 0 , 0 , 0 , width , color1 ) ) ; noFocusBorder = new CompoundBorder ( new MatteBorder ( 0 , 0 , 0 , width , color3 ) , new MatteBorder ( 0 , 0 , 0 , width , color2 ) ) ; updateBorder ( ) ; } public void updateBorder ( ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { if ( view . getEditPane ( ) == null ) return ; if ( view . getEditPane ( ) . getTextArea ( ) == textArea ) setBorder ( focusBorder ) ; else setBorder ( noFocusBorder ) ; } } ) ; } public void setBorder ( Border border ) { super . setBorder ( border ) ; if ( border == null ) { collapsedSize . width = 0 ; collapsedSize . height = 0 ; } else { Insets insets = border . getBorderInsets ( this ) ; collapsedSize . width = FOLD_MARKER_SIZE + insets . right ; collapsedSize . height = gutterSize . height = insets . top + insets . bottom ; gutterSize . width = FOLD_MARKER_SIZE + insets . right + fm . stringWidth ( "12345" ) ; } } public void setFont ( Font font ) { super . setFont ( font ) ; fm = getFontMetrics ( font ) ; baseline = fm . getAscent ( ) ; } public Color getHighlightedForeground ( ) { return intervalHighlight ; } public void setHighlightedForeground ( Color highlight ) { intervalHighlight = highlight ; } public Color getCurrentLineForeground ( ) { return currentLineHighlight ; } public void setCurrentLineForeground ( Color highlight ) { currentLineHighlight = highlight ; } public Color getFoldColor ( ) { return foldColor ; } public void setFoldColor ( Color foldColor ) { this . foldColor = foldColor ; } public Dimension getPreferredSize ( ) { if ( expanded ) return gutterSize ; else return collapsedSize ; } public Dimension getMinimumSize ( ) { return getPreferredSize ( ) ; } public String getToolTipText ( MouseEvent evt ) { return ( highlights == null ) ? null : highlights . getToolTipText ( evt ) ; } public int getLineNumberAlignment ( ) { return alignment ; } public void setLineNumberAlignment ( int alignment ) { if ( this . alignment == alignment ) return ; this . alignment = alignment ; repaint ( ) ; } public boolean isExpanded ( ) { return expanded ; } public void setExpanded ( boolean expanded ) { if ( this . expanded == expanded ) return ; this . expanded = expanded ; textArea . revalidate ( ) ; } public void toggleExpanded ( ) { setExpanded ( ! expanded ) ; } public int getHighlightInterval ( ) { return interval ; } public void setHighlightInterval ( int interval ) { if ( interval <= 1 ) interval = 0 ; this . interval = interval ; repaint ( ) ; } public boolean isCurrentLineHighlightEnabled ( ) { return currentLineHighlightEnabled ; } public void setCurrentLineHighlightEnabled ( boolean enabled ) { if ( currentLineHighlightEnabled == enabled ) return ; currentLineHighlightEnabled = enabled ; repaint ( ) ; } private static final int FOLD_MARKER_SIZE = 10 ; private View view ; private JEditTextArea textArea ; private TextAreaHighlight highlights ; private int baseline ; private Dimension gutterSize = new Dimension ( 0 , 0 ) ; private Dimension collapsedSize = new Dimension ( 0 , 0 ) ; private Color intervalHighlight ; private Color currentLineHighlight ; private Color foldColor ; private FontMetrics fm ; private int alignment ; private int interval ; private boolean currentLineHighlightEnabled ; private boolean expanded ; private int borderWidth ; private Border focusBorder , noFocusBorder ; class MouseHandler implements MouseListener , MouseMotionListener { boolean drag ; int toolTipInitialDelay , toolTipReshowDelay ; public void mouseEntered ( MouseEvent e ) { ToolTipManager ttm = ToolTipManager . sharedInstance ( ) ; toolTipInitialDelay = ttm . getInitialDelay ( ) ; toolTipReshowDelay = ttm . getReshowDelay ( ) ; ttm . setInitialDelay ( 0 ) ; ttm . setReshowDelay ( 0 ) ; } public void mouseExited ( MouseEvent evt ) { ToolTipManager ttm = ToolTipManager . sharedInstance ( ) ; ttm . setInitialDelay ( toolTipInitialDelay ) ; ttm . setReshowDelay ( toolTipReshowDelay ) ; } public void mousePressed ( MouseEvent e ) { if ( e . getX ( ) < getWidth ( ) - borderWidth * 2 ) { Buffer buffer = textArea . getBuffer ( ) ; int line = e . getY ( ) / textArea . getPainter ( ) . getFontMetrics ( ) . getHeight ( ) + textArea . getFirstLine ( ) ; if ( line > buffer . getVirtualLineCount ( ) - 1 ) return ; line = buffer . virtualToPhysical ( line ) ; if ( buffer . isFoldStart ( line ) ) { if ( e . isControlDown ( ) ) { buffer . expandFoldAt ( line , true , textArea ) ; textArea . selectFoldAt ( line ) ; } else if ( buffer . isLineVisible ( line + 1 ) ) buffer . collapseFoldAt ( line ) ; else buffer . expandFoldAt ( line , e . isShiftDown ( ) , textArea ) ; } } else { e . translatePoint ( - getWidth ( ) , 0 ) ; textArea . mouseHandler . mousePressed ( e ) ; drag = true ; } } public void mouseDragged ( MouseEvent e ) { if ( drag && e . getX ( ) >= getWidth ( ) - borderWidth * 2 ) { e . translatePoint ( - getWidth ( ) , 0 ) ; textArea . mouseHandler . mouseDragged ( e ) ; } } public void mouseMoved ( MouseEvent e ) { } public void mouseReleased ( MouseEvent e ) { if ( drag && e . getX ( ) >= getWidth ( ) - borderWidth * 2 ) { e . translatePoint ( - getWidth ( ) , 0 ) ; textArea . mouseHandler . mouseReleased ( e ) ; } drag = false ; } public void mouseClicked ( MouseEvent e ) { } } } 	1	['30', '4', '0', '10', '73', '337', '7', '7', '25', '0.927203065', '628', '1', '3', '0.957037037', '0.127777778', '3', '18', '19.33333333', '20', '1.9', '8']
package bsh ; class ReturnControl implements ParserConstants { public int kind ; public Object value ; public ReturnControl ( int kind , Object value ) { this . kind = kind ; this . value = value ; } } 	0	['1', '1', '0', '10', '2', '0', '9', '1', '1', '2', '12', '0', '0', '0', '1', '0', '0', '9', '0', '0', '0']
package org . gjt . sp . jedit . options ; import javax . swing . table . * ; import javax . swing . * ; import java . awt . * ; import java . util . Vector ; import org . gjt . sp . jedit . * ; public class BrowserOptionPane extends AbstractOptionPane { public BrowserOptionPane ( ) { super ( "browser" ) ; } public void _init ( ) { String [ ] dirs = { jEdit . getProperty ( "options.browser.defaultPath.buffer" ) , jEdit . getProperty ( "options.browser.defaultPath.home" ) , jEdit . getProperty ( "options.browser.defaultPath.favorites" ) , jEdit . getProperty ( "options.browser.defaultPath.last" ) } ; defaultDirectory = new JComboBox ( dirs ) ; String defaultDir = jEdit . getProperty ( "vfs.browser.defaultPath" ) ; if ( "buffer" . equals ( defaultDir ) ) defaultDirectory . setSelectedIndex ( 0 ) ; else if ( "home" . equals ( defaultDir ) ) defaultDirectory . setSelectedIndex ( 1 ) ; else if ( "favorites" . equals ( defaultDir ) ) defaultDirectory . setSelectedIndex ( 2 ) ; else if ( "last" . equals ( defaultDir ) ) defaultDirectory . setSelectedIndex ( 3 ) ; addComponent ( jEdit . getProperty ( "options.browser.defaultPath" ) , defaultDirectory ) ; showIcons = new JCheckBox ( jEdit . getProperty ( "options.browser" + ".showIcons" ) ) ; showIcons . setSelected ( jEdit . getBooleanProperty ( "vfs.browser" + ".showIcons" ) ) ; addComponent ( showIcons ) ; showHiddenFiles = new JCheckBox ( jEdit . getProperty ( "options.browser" + ".showHiddenFiles" ) ) ; showHiddenFiles . setSelected ( jEdit . getBooleanProperty ( "vfs.browser" + ".showHiddenFiles" ) ) ; addComponent ( showHiddenFiles ) ; sortFiles = new JCheckBox ( jEdit . getProperty ( "options.browser" + ".sortFiles" ) ) ; sortFiles . setSelected ( jEdit . getBooleanProperty ( "vfs.browser" + ".sortFiles" ) ) ; addComponent ( sortFiles ) ; sortIgnoreCase = new JCheckBox ( jEdit . getProperty ( "options.browser" + ".sortIgnoreCase" ) ) ; sortIgnoreCase . setSelected ( jEdit . getBooleanProperty ( "vfs.browser" + ".sortIgnoreCase" ) ) ; addComponent ( sortIgnoreCase ) ; sortMixFilesAndDirs = new JCheckBox ( jEdit . getProperty ( "options.browser" + ".sortMixFilesAndDirs" ) ) ; sortMixFilesAndDirs . setSelected ( jEdit . getBooleanProperty ( "vfs.browser" + ".sortMixFilesAndDirs" ) ) ; addComponent ( sortMixFilesAndDirs ) ; doubleClickClose = new JCheckBox ( jEdit . getProperty ( "options.browser" + ".doubleClickClose" ) ) ; doubleClickClose . setSelected ( jEdit . getBooleanProperty ( "vfs.browser" + ".doubleClickClose" ) ) ; addComponent ( doubleClickClose ) ; currentBufferFilter = new JCheckBox ( jEdit . getProperty ( "options.browser" + ".currentBufferFilter" ) ) ; currentBufferFilter . setSelected ( jEdit . getBooleanProperty ( "vfs.browser" + ".currentBufferFilter" ) ) ; addComponent ( currentBufferFilter ) ; } public void _save ( ) { String [ ] dirs = { "buffer" , "home" , "favorites" , "last" } ; jEdit . setProperty ( "vfs.browser.defaultPath" , dirs [ defaultDirectory . getSelectedIndex ( ) ] ) ; jEdit . setBooleanProperty ( "vfs.browser.showIcons" , showIcons . isSelected ( ) ) ; jEdit . setBooleanProperty ( "vfs.browser.showHiddenFiles" , showHiddenFiles . isSelected ( ) ) ; jEdit . setBooleanProperty ( "vfs.browser.sortFiles" , sortFiles . isSelected ( ) ) ; jEdit . setBooleanProperty ( "vfs.browser.sortIgnoreCase" , sortIgnoreCase . isSelected ( ) ) ; jEdit . setBooleanProperty ( "vfs.browser.sortMixFilesAndDirs" , sortMixFilesAndDirs . isSelected ( ) ) ; jEdit . setBooleanProperty ( "vfs.browser.doubleClickClose" , doubleClickClose . isSelected ( ) ) ; jEdit . setBooleanProperty ( "vfs.browser.currentBufferFilter" , currentBufferFilter . isSelected ( ) ) ; } private JComboBox defaultDirectory ; private JCheckBox showIcons ; private JCheckBox showHiddenFiles ; private JCheckBox sortFiles ; private JCheckBox sortIgnoreCase ; private JCheckBox sortMixFilesAndDirs ; private JCheckBox doubleClickClose ; private JCheckBox currentBufferFilter ; } 	1	['3', '6', '0', '3', '17', '1', '1', '2', '3', '0.5', '263', '1', '0', '0.996987952', '1', '2', '4', '84', '5', '2', '2']
package org . gjt . sp . jedit . gui ; import javax . swing . border . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . * ; public class EditAbbrevDialog extends JDialog { public EditAbbrevDialog ( Component comp , String abbrev , String expansion ) { super ( JOptionPane . getFrameForComponent ( comp ) , jEdit . getProperty ( "edit-abbrev.title" ) , true ) ; this . comp = comp ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; content . add ( BorderLayout . NORTH , new JLabel ( jEdit . getProperty ( "edit-abbrev.caption" , new String [ ] { abbrev } ) ) ) ; editor = new AbbrevEditor ( ) ; editor . setExpansion ( expansion ) ; editor . setBorder ( new EmptyBorder ( 0 , 0 , 12 , 0 ) ) ; content . add ( BorderLayout . CENTER , editor ) ; Box box = new Box ( BoxLayout . X_AXIS ) ; box . add ( Box . createGlue ( ) ) ; ok = new JButton ( jEdit . getProperty ( "common.ok" ) ) ; ok . addActionListener ( new ActionHandler ( ) ) ; getRootPane ( ) . setDefaultButton ( ok ) ; box . add ( ok ) ; box . add ( Box . createHorizontalStrut ( 6 ) ) ; cancel = new JButton ( jEdit . getProperty ( "common.cancel" ) ) ; cancel . addActionListener ( new ActionHandler ( ) ) ; box . add ( cancel ) ; box . add ( Box . createGlue ( ) ) ; content . add ( BorderLayout . SOUTH , box ) ; KeyListener listener = new KeyHandler ( ) ; addKeyListener ( listener ) ; editor . getBeforeCaretTextArea ( ) . addKeyListener ( listener ) ; editor . getAfterCaretTextArea ( ) . addKeyListener ( listener ) ; setDefaultCloseOperation ( DISPOSE_ON_CLOSE ) ; GUIUtilities . requestFocus ( this , editor . getBeforeCaretTextArea ( ) ) ; pack ( ) ; setLocationRelativeTo ( comp ) ; show ( ) ; } public String getExpansion ( ) { if ( ! isOK ) return null ; return editor . getExpansion ( ) ; } private Component comp ; private AbbrevEditor editor ; private JButton ok ; private JButton cancel ; private boolean isOK ; class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { if ( evt . getSource ( ) == ok ) isOK = true ; dispose ( ) ; } } class KeyHandler extends KeyAdapter { public void keyPressed ( KeyEvent evt ) { if ( evt . getKeyCode ( ) == KeyEvent . VK_ESCAPE ) dispose ( ) ; } } } 	0	['5', '6', '0', '6', '39', '0', '3', '5', '2', '0.8', '210', '1', '1', '0.99389313', '0.32', '0', '0', '40', '2', '1', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . textarea . JEditTextArea ; import org . gjt . sp . jedit . * ; public class EnhancedMenuItem extends JMenuItem { public EnhancedMenuItem ( String label , EditAction action ) { super ( label ) ; this . action = action ; if ( action != null ) { setEnabled ( true ) ; addActionListener ( new EditAction . Wrapper ( action ) ) ; shortcutProp1 = action . getName ( ) + ".shortcut" ; shortcutProp2 = action . getName ( ) + ".shortcut2" ; } else setEnabled ( false ) ; } public Dimension getPreferredSize ( ) { Dimension d = super . getPreferredSize ( ) ; String shortcut = getShortcut ( ) ; if ( shortcut != null ) { d . width += ( getFontMetrics ( acceleratorFont ) . stringWidth ( shortcut ) + 10 ) ; } return d ; } public void paint ( Graphics g ) { super . paint ( g ) ; String shortcut = getShortcut ( ) ; if ( shortcut != null ) { g . setFont ( acceleratorFont ) ; g . setColor ( getModel ( ) . isArmed ( ) ? acceleratorSelectionForeground : acceleratorForeground ) ; FontMetrics fm = g . getFontMetrics ( ) ; Insets insets = getInsets ( ) ; g . drawString ( shortcut , getWidth ( ) - ( fm . stringWidth ( shortcut ) + insets . right + insets . left ) , getFont ( ) . getSize ( ) + ( insets . top - 1 ) ) ; } } private String shortcutProp1 ; private String shortcutProp2 ; private EditAction action ; private static Font acceleratorFont ; private static Color acceleratorForeground ; private static Color acceleratorSelectionForeground ; private String getShortcut ( ) { if ( action == null ) return null ; else { String shortcut1 = jEdit . getProperty ( shortcutProp1 ) ; String shortcut2 = jEdit . getProperty ( shortcutProp2 ) ; if ( shortcut1 == null || shortcut1 . length ( ) == 0 ) { if ( shortcut2 == null || shortcut2 . length ( ) == 0 ) return null ; else return shortcut2 ; } else { if ( shortcut2 == null || shortcut2 . length ( ) == 0 ) return shortcut1 ; else return shortcut1 + " or " + shortcut2 ; } } } static { acceleratorFont = UIManager . getFont ( "MenuItem.acceleratorFont" ) ; acceleratorFont = new Font ( "Monospaced" , acceleratorFont . getStyle ( ) , acceleratorFont . getSize ( ) ) ; acceleratorForeground = UIManager . getColor ( "MenuItem.acceleratorForeground" ) ; acceleratorSelectionForeground = UIManager . getColor ( "MenuItem.acceleratorSelectionForeground" ) ; } } 	1	['5', '6', '0', '5', '33', '2', '2', '3', '3', '0.458333333', '191', '1', '1', '0.996240602', '0.4375', '2', '11', '36', '8', '2.6', '2']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import javax . swing . border . * ; import javax . swing . text . Element ; import java . awt . * ; import java . awt . event . * ; import org . gjt . sp . jedit . textarea . * ; import org . gjt . sp . jedit . * ; public class SelectLineRange extends EnhancedDialog implements ActionListener { public SelectLineRange ( View view ) { super ( view , jEdit . getProperty ( "selectlinerange.title" ) , true ) ; this . view = view ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 0 ) ) ; setContentPane ( content ) ; JLabel label = new JLabel ( jEdit . getProperty ( "selectlinerange.caption" ) ) ; label . setBorder ( new EmptyBorder ( 0 , 0 , 6 , 12 ) ) ; content . add ( BorderLayout . NORTH , label ) ; JPanel panel = createFieldPanel ( ) ; content . add ( BorderLayout . CENTER , panel ) ; panel = new JPanel ( ) ; panel . setLayout ( new BoxLayout ( panel , BoxLayout . X_AXIS ) ) ; panel . setBorder ( new EmptyBorder ( 6 , 0 , 0 , 12 ) ) ; panel . add ( Box . createGlue ( ) ) ; panel . add ( Box . createGlue ( ) ) ; ok = new JButton ( jEdit . getProperty ( "common.ok" ) ) ; ok . addActionListener ( this ) ; getRootPane ( ) . setDefaultButton ( ok ) ; panel . add ( ok ) ; panel . add ( Box . createHorizontalStrut ( 6 ) ) ; cancel = new JButton ( jEdit . getProperty ( "common.cancel" ) ) ; cancel . addActionListener ( this ) ; panel . add ( cancel ) ; panel . add ( Box . createGlue ( ) ) ; content . add ( panel , BorderLayout . SOUTH ) ; GUIUtilities . requestFocus ( this , startField ) ; pack ( ) ; setLocationRelativeTo ( view ) ; show ( ) ; } public void ok ( ) { int startLine ; int endLine ; try { startLine = Integer . parseInt ( startField . getText ( ) ) - 1 ; endLine = Integer . parseInt ( endField . getText ( ) ) - 1 ; } catch ( NumberFormatException nf ) { getToolkit ( ) . beep ( ) ; return ; } Buffer buffer = view . getBuffer ( ) ; Element map = buffer . getDefaultRootElement ( ) ; if ( startLine < 0 || endLine >= map . getElementCount ( ) ) { getToolkit ( ) . beep ( ) ; return ; } int startOffset = map . getElement ( startLine ) . getStartOffset ( ) ; int endOffset = map . getElement ( endLine ) . getEndOffset ( ) - 1 ; JEditTextArea textArea = view . getTextArea ( ) ; textArea . setSelection ( new Selection . Range ( startOffset , endOffset ) ) ; textArea . moveCaretPosition ( endOffset ) ; dispose ( ) ; } public void cancel ( ) { dispose ( ) ; } public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == ok ) ok ( ) ; else if ( source == cancel ) cancel ( ) ; } private View view ; private JTextField startField ; private JTextField endField ; private JButton ok ; private JButton cancel ; private JPanel createFieldPanel ( ) { GridBagLayout layout = new GridBagLayout ( ) ; JPanel panel = new JPanel ( layout ) ; GridBagConstraints cons = new GridBagConstraints ( ) ; cons . insets = new Insets ( 0 , 0 , 6 , 12 ) ; cons . gridwidth = cons . gridheight = 1 ; cons . gridx = cons . gridy = 0 ; cons . fill = GridBagConstraints . BOTH ; JLabel label = new JLabel ( jEdit . getProperty ( "selectlinerange.start" ) , SwingConstants . RIGHT ) ; layout . setConstraints ( label , cons ) ; panel . add ( label ) ; startField = new JTextField ( 10 ) ; cons . gridx = 1 ; cons . weightx = 1.0f ; layout . setConstraints ( startField , cons ) ; panel . add ( startField ) ; label = new JLabel ( jEdit . getProperty ( "selectlinerange.end" ) , SwingConstants . RIGHT ) ; cons . gridx = 0 ; cons . weightx = 0.0f ; cons . gridy = 1 ; layout . setConstraints ( label , cons ) ; panel . add ( label ) ; endField = new JTextField ( 10 ) ; cons . gridx = 1 ; cons . weightx = 1.0f ; layout . setConstraints ( endField , cons ) ; panel . add ( endField ) ; return panel ; } } 	0	['5', '7', '0', '8', '52', '2', '1', '8', '4', '0.5', '364', '1', '1', '0.99391172', '0.466666667', '0', '0', '70.8', '3', '1.6', '0']
package org . gjt . sp . util ; import javax . swing . event . EventListenerList ; import javax . swing . SwingUtilities ; public class WorkThreadPool { public WorkThreadPool ( String name , int count ) { listenerList = new EventListenerList ( ) ; if ( count != 0 ) { threadGroup = new ThreadGroup ( name ) ; threads = new WorkThread [ count ] ; for ( int i = 0 ; i < threads . length ; i ++ ) { threads [ i ] = new WorkThread ( this , threadGroup , name + " #" + ( i + 1 ) ) ; } } else Log . log ( Log . WARNING , this , "Async I/O disabled" ) ; } public void start ( ) { if ( threads != null ) { for ( int i = 0 ; i < threads . length ; i ++ ) { threads [ i ] . start ( ) ; } } } public void addWorkRequest ( Runnable run , boolean inAWT ) { if ( threads == null ) { run . run ( ) ; return ; } if ( inAWT && requestCount == 0 && awtRequestCount == 0 ) { if ( SwingUtilities . isEventDispatchThread ( ) ) run . run ( ) ; else SwingUtilities . invokeLater ( run ) ; return ; } Request request = new Request ( run ) ; synchronized ( lock ) { if ( inAWT ) { if ( firstAWTRequest == null && lastAWTRequest == null ) firstAWTRequest = lastAWTRequest = request ; else { lastAWTRequest . next = request ; lastAWTRequest = request ; } awtRequestCount ++ ; if ( requestCount == 0 ) queueAWTRunner ( ) ; } else { if ( firstRequest == null && lastRequest == null ) firstRequest = lastRequest = request ; else { lastRequest . next = request ; lastRequest = request ; } requestCount ++ ; } lock . notify ( ) ; } } public void waitForRequests ( ) { if ( threads == null ) return ; synchronized ( waitForAllLock ) { while ( requestCount != 0 ) { try { waitForAllLock . wait ( ) ; } catch ( InterruptedException ie ) { Log . log ( Log . ERROR , this , ie ) ; } } } if ( SwingUtilities . isEventDispatchThread ( ) ) { doAWTRequests ( ) ; } else { try { SwingUtilities . invokeAndWait ( new RunRequestsInAWTThread ( ) ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , this , e ) ; } } } public int getRequestCount ( ) { return requestCount ; } public int getThreadCount ( ) { if ( threads == null ) return 0 ; else return threads . length ; } public WorkThread getThread ( int index ) { return threads [ index ] ; } public final void addProgressListener ( WorkThreadProgressListener listener ) { listenerList . add ( WorkThreadProgressListener . class , listener ) ; } public final void removeProgressListener ( WorkThreadProgressListener listener ) { listenerList . remove ( WorkThreadProgressListener . class , listener ) ; } Object lock = new String ( "Work thread pool request queue lock" ) ; Object waitForAllLock = new String ( "Work thread pool waitForAll() notifier" ) ; void fireProgressChanged ( WorkThread thread ) { final Object [ ] listeners = listenerList . getListenerList ( ) ; if ( listeners . length != 0 ) { int index = 0 ; for ( int i = 0 ; i < threads . length ; i ++ ) { if ( threads [ i ] == thread ) { index = i ; break ; } } final int _index = index ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { for ( int i = listeners . length - 2 ; i >= 0 ; i -- ) { if ( listeners [ i ] == WorkThreadProgressListener . class ) { ( ( WorkThreadProgressListener ) listeners [ i + 1 ] ) . progressUpdate ( WorkThreadPool . this , _index ) ; } } } } ) ; } } void requestDone ( ) { synchronized ( lock ) { requestCount -- ; if ( requestCount == 0 && firstAWTRequest != null ) queueAWTRunner ( ) ; } } Request getNextRequest ( ) { synchronized ( lock ) { Request request = firstRequest ; if ( request == null ) return null ; firstRequest = firstRequest . next ; if ( firstRequest == null ) lastRequest = null ; if ( request . alreadyRun ) throw new InternalError ( "AIEE!!! Request run twice!!! " + request . run ) ; request . alreadyRun = true ; return request ; } } private ThreadGroup threadGroup ; private WorkThread [ ] threads ; private Request firstRequest ; private Request lastRequest ; private int requestCount ; private boolean awtRunnerQueued ; private Request firstAWTRequest ; private Request lastAWTRequest ; private int awtRequestCount ; private EventListenerList listenerList ; private void doAWTRequests ( ) { while ( firstAWTRequest != null ) { doAWTRequest ( getNextAWTRequest ( ) ) ; } } private void doAWTRequest ( Request request ) { try { request . run . run ( ) ; } catch ( Throwable t ) { Log . log ( Log . ERROR , WorkThread . class , "Exception " + "in AWT thread:" ) ; Log . log ( Log . ERROR , WorkThread . class , t ) ; } awtRequestCount -- ; } private void queueAWTRunner ( ) { if ( ! awtRunnerQueued ) { awtRunnerQueued = true ; SwingUtilities . invokeLater ( new RunRequestsInAWTThread ( ) ) ; } } private Request getNextAWTRequest ( ) { synchronized ( lock ) { Request request = firstAWTRequest ; firstAWTRequest = firstAWTRequest . next ; if ( firstAWTRequest == null ) lastAWTRequest = null ; if ( request . alreadyRun ) throw new InternalError ( "AIEE!!! Request run twice!!! " + request . run ) ; request . alreadyRun = true ; return request ; } } static int ID ; static class Request { int id = ++ ID ; Runnable run ; boolean alreadyRun ; Request next ; Request ( Runnable run ) { this . run = run ; } public String toString ( ) { return "[id=" + id + ",run=" + run + "]" ; } } class RunRequestsInAWTThread implements Runnable { public void run ( ) { awtRunnerQueued = false ; doAWTRequests ( ) ; } } } 	1	['22', '1', '0', '12', '51', '129', '11', '6', '9', '0.873015873', '593', '0.8', '5', '0', '0.140909091', '0', '0', '25.27272727', '11', '2.6818', '1']
package bsh ; class BSHSwitchStatement extends SimpleNode implements ParserConstants { public BSHSwitchStatement ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { int numchild = jjtGetNumChildren ( ) ; int child = 0 ; SimpleNode switchExp = ( ( SimpleNode ) jjtGetChild ( child ++ ) ) ; Object switchVal = switchExp . eval ( callstack , interpreter ) ; BSHSwitchLabel label ; Object node ; ReturnControl returnControl = null ; if ( child >= numchild ) throw new EvalError ( "Empty switch statement..." ) ; label = ( ( BSHSwitchLabel ) jjtGetChild ( child ++ ) ) ; while ( child < numchild && returnControl == null ) { if ( label . isDefault || label . eval ( callstack , interpreter ) . equals ( switchVal ) ) { while ( child < numchild ) { node = jjtGetChild ( child ++ ) ; if ( node instanceof BSHSwitchLabel ) continue ; Object value = ( ( SimpleNode ) node ) . eval ( callstack , interpreter ) ; if ( value instanceof ReturnControl ) { returnControl = ( ReturnControl ) value ; break ; } } } else { while ( child < numchild ) { node = jjtGetChild ( child ++ ) ; if ( node instanceof BSHSwitchLabel ) { label = ( BSHSwitchLabel ) node ; break ; } } } } if ( returnControl != null && returnControl . kind == RETURN ) return returnControl ; else return Primitive . VOID ; } } 	0	['2', '2', '0', '10', '9', '1', '1', '9', '2', '2', '106', '0', '0', '0.947368421', '0.625', '2', '2', '52', '1', '0.5', '0']
package org . gjt . sp . jedit . browser ; import javax . swing . event . * ; import javax . swing . tree . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . util . Enumeration ; import java . util . Vector ; import org . gjt . sp . jedit . io . * ; import org . gjt . sp . jedit . * ; public class BrowserView extends JPanel { public BrowserView ( VFSBrowser browser ) { this . browser = browser ; currentlyLoadingTreeNode = rootNode = new DefaultMutableTreeNode ( null , true ) ; model = new DefaultTreeModel ( rootNode , true ) ; tree = new BrowserJTree ( model ) ; tree . setCellRenderer ( renderer ) ; tree . setEditable ( false ) ; tree . addTreeExpansionListener ( new TreeHandler ( ) ) ; tree . putClientProperty ( "JTree.lineStyle" , "Angled" ) ; if ( browser . isMultipleSelectionEnabled ( ) ) tree . getSelectionModel ( ) . setSelectionMode ( TreeSelectionModel . DISCONTIGUOUS_TREE_SELECTION ) ; else tree . getSelectionModel ( ) . setSelectionMode ( TreeSelectionModel . SINGLE_TREE_SELECTION ) ; setLayout ( new BorderLayout ( ) ) ; scroller = new JScrollPane ( tree ) ; scroller . setPreferredSize ( new Dimension ( 0 , 200 ) ) ; add ( BorderLayout . CENTER , scroller ) ; propertiesChanged ( ) ; } public VFS . DirectoryEntry [ ] getSelectedFiles ( ) { Vector selected = new Vector ( tree . getSelectionCount ( ) ) ; TreePath [ ] paths = tree . getSelectionPaths ( ) ; if ( paths == null ) return new VFS . DirectoryEntry [ 0 ] ; for ( int i = 0 ; i < paths . length ; i ++ ) { DefaultMutableTreeNode treeNode = ( DefaultMutableTreeNode ) paths [ i ] . getLastPathComponent ( ) ; Object obj = treeNode . getUserObject ( ) ; if ( obj instanceof VFS . DirectoryEntry ) selected . addElement ( obj ) ; } VFS . DirectoryEntry [ ] retVal = new VFS . DirectoryEntry [ selected . size ( ) ] ; selected . copyInto ( retVal ) ; return retVal ; } public void selectNone ( ) { tree . setSelectionPaths ( new TreePath [ 0 ] ) ; } public void directoryLoaded ( Vector directory ) { if ( currentlyLoadingTreeNode == rootNode ) rootNode . setUserObject ( browser . getDirectory ( ) ) ; currentlyLoadingTreeNode . removeAllChildren ( ) ; if ( directory != null ) { for ( int i = 0 ; i < directory . size ( ) ; i ++ ) { VFS . DirectoryEntry file = ( VFS . DirectoryEntry ) directory . elementAt ( i ) ; boolean allowsChildren = ( file . type != VFS . DirectoryEntry . FILE ) ; currentlyLoadingTreeNode . add ( new DefaultMutableTreeNode ( file , allowsChildren ) ) ; } } model . reload ( currentlyLoadingTreeNode ) ; tree . expandPath ( new TreePath ( currentlyLoadingTreeNode . getPath ( ) ) ) ; currentlyLoadingTreeNode = rootNode ; timer . stop ( ) ; typeSelectBuffer . setLength ( 0 ) ; } public void updateFileView ( ) { tree . repaint ( ) ; } public void reloadDirectory ( String path ) { String browserDir = browser . getDirectory ( ) ; if ( browserDir . startsWith ( FavoritesVFS . PROTOCOL ) ) reloadDirectory ( rootNode , path ) ; else if ( browserDir . startsWith ( FileRootsVFS . PROTOCOL ) ) { if ( ! MiscUtilities . isURL ( path ) || MiscUtilities . getProtocolOfURL ( path ) . equals ( "file" ) ) reloadDirectory ( rootNode , path ) ; } else if ( path . startsWith ( browserDir ) ) reloadDirectory ( rootNode , path ) ; } public Component getDefaultFocusComponent ( ) { return tree ; } public void propertiesChanged ( ) { showIcons = jEdit . getBooleanProperty ( "vfs.browser.showIcons" ) ; renderer . propertiesChanged ( ) ; } private VFSBrowser browser ; private JTree tree ; private JScrollPane scroller ; private DefaultTreeModel model ; private DefaultMutableTreeNode rootNode ; private DefaultMutableTreeNode currentlyLoadingTreeNode ; private BrowserPopupMenu popup ; private boolean showIcons ; private FileCellRenderer renderer = new FileCellRenderer ( ) ; private StringBuffer typeSelectBuffer = new StringBuffer ( ) ; private Timer timer = new Timer ( 0 , new ClearTypeSelect ( ) ) ; class ClearTypeSelect implements ActionListener { public void actionPerformed ( ActionEvent evt ) { typeSelectBuffer . setLength ( 0 ) ; browser . filesSelected ( ) ; } } private boolean reloadDirectory ( DefaultMutableTreeNode node , String path ) { if ( ! tree . isExpanded ( new TreePath ( node . getPath ( ) ) ) ) return false ; Object userObject = node . getUserObject ( ) ; if ( userObject instanceof String ) { if ( path . equals ( userObject ) ) { loadDirectoryNode ( node , path , false ) ; return true ; } } else if ( userObject instanceof VFS . DirectoryEntry ) { VFS . DirectoryEntry file = ( VFS . DirectoryEntry ) userObject ; if ( file . type == VFS . DirectoryEntry . FILE ) return false ; if ( path . equals ( file . path ) ) { loadDirectoryNode ( node , path , false ) ; return true ; } } if ( node . getChildCount ( ) != 0 ) { Enumeration children = node . children ( ) ; while ( children . hasMoreElements ( ) ) { DefaultMutableTreeNode child = ( DefaultMutableTreeNode ) children . nextElement ( ) ; if ( reloadDirectory ( child , path ) ) return true ; } } return false ; } private void loadDirectoryNode ( DefaultMutableTreeNode node , String path , boolean showLoading ) { currentlyLoadingTreeNode = node ; if ( showLoading ) { node . removeAllChildren ( ) ; node . add ( new DefaultMutableTreeNode ( new LoadingPlaceholder ( ) , false ) ) ; } model . reload ( currentlyLoadingTreeNode ) ; browser . loadDirectory ( path ) ; } private void showFilePopup ( VFS . DirectoryEntry file , Point point ) { popup = new BrowserPopupMenu ( browser , file ) ; popup . show ( tree , point . x + 1 , point . y + 1 ) ; } class BrowserJTree extends JTree { BrowserJTree ( TreeModel model ) { super ( model ) ; ToolTipManager . sharedInstance ( ) . registerComponent ( this ) ; } public final String getToolTipText ( MouseEvent evt ) { TreePath path = getPathForLocation ( evt . getX ( ) , evt . getY ( ) ) ; if ( path != null ) { Rectangle cellRect = getPathBounds ( path ) ; if ( cellRect != null && ! cellRectIsVisible ( cellRect ) ) return path . getLastPathComponent ( ) . toString ( ) ; } return null ; } public final Point getToolTipLocation ( MouseEvent evt ) { TreePath path = getPathForLocation ( evt . getX ( ) , evt . getY ( ) ) ; if ( path != null ) { Rectangle cellRect = getPathBounds ( path ) ; if ( cellRect != null && ! cellRectIsVisible ( cellRect ) ) { return new Point ( cellRect . x + ( showIcons ? 20 : 1 ) , cellRect . y + ( showIcons ? 1 : - 1 ) ) ; } } return null ; } protected void processKeyEvent ( KeyEvent evt ) { if ( evt . getID ( ) == KeyEvent . KEY_PRESSED ) { switch ( evt . getKeyCode ( ) ) { case KeyEvent . VK_ENTER : browser . filesActivated ( ) ; evt . consume ( ) ; break ; case KeyEvent . VK_LEFT : if ( getMinSelectionRow ( ) == - 1 || getMinSelectionRow ( ) == 0 ) { String directory = browser . getDirectory ( ) ; browser . setDirectory ( VFSManager . getVFSForPath ( directory ) . getParentOfPath ( directory ) ) ; evt . consume ( ) ; } break ; } } else if ( evt . getID ( ) == KeyEvent . KEY_TYPED ) { typeSelectBuffer . append ( evt . getKeyChar ( ) ) ; doTypeSelect ( typeSelectBuffer . toString ( ) ) ; timer . stop ( ) ; timer . setInitialDelay ( 500 ) ; timer . setRepeats ( false ) ; timer . start ( ) ; } if ( ! evt . isConsumed ( ) ) super . processKeyEvent ( evt ) ; } protected void processMouseEvent ( MouseEvent evt ) { ToolTipManager ttm = ToolTipManager . sharedInstance ( ) ; switch ( evt . getID ( ) ) { case MouseEvent . MOUSE_ENTERED : toolTipInitialDelay = ttm . getInitialDelay ( ) ; toolTipReshowDelay = ttm . getReshowDelay ( ) ; ttm . setInitialDelay ( 200 ) ; ttm . setReshowDelay ( 0 ) ; super . processMouseEvent ( evt ) ; break ; case MouseEvent . MOUSE_EXITED : ttm . setInitialDelay ( toolTipInitialDelay ) ; ttm . setReshowDelay ( toolTipReshowDelay ) ; super . processMouseEvent ( evt ) ; break ; case MouseEvent . MOUSE_CLICKED : if ( ( evt . getModifiers ( ) & MouseEvent . BUTTON1_MASK ) != 0 ) { TreePath path = getPathForLocation ( evt . getX ( ) , evt . getY ( ) ) ; if ( path == null ) { super . processMouseEvent ( evt ) ; break ; } if ( ! isPathSelected ( path ) ) setSelectionPath ( path ) ; if ( evt . getClickCount ( ) == 1 ) { browser . filesSelected ( ) ; super . processMouseEvent ( evt ) ; } if ( evt . getClickCount ( ) == 2 ) { browser . filesActivated ( ) ; break ; } } else if ( GUIUtilities . isPopupTrigger ( evt ) ) ; super . processMouseEvent ( evt ) ; break ; case MouseEvent . MOUSE_PRESSED : if ( ( evt . getModifiers ( ) & MouseEvent . BUTTON1_MASK ) != 0 ) { if ( popup != null && popup . isVisible ( ) ) popup . setVisible ( false ) ; if ( evt . getClickCount ( ) == 2 ) break ; } else if ( GUIUtilities . isPopupTrigger ( evt ) ) { if ( popup != null && popup . isVisible ( ) ) { popup . setVisible ( false ) ; break ; } TreePath path = getPathForLocation ( evt . getX ( ) , evt . getY ( ) ) ; if ( path == null ) showFilePopup ( null , evt . getPoint ( ) ) ; else { setSelectionPath ( path ) ; browser . filesSelected ( ) ; Object userObject = ( ( DefaultMutableTreeNode ) path . getLastPathComponent ( ) ) . getUserObject ( ) ; if ( userObject instanceof VFS . DirectoryEntry ) { VFS . DirectoryEntry file = ( VFS . DirectoryEntry ) userObject ; showFilePopup ( file , evt . getPoint ( ) ) ; } else showFilePopup ( null , evt . getPoint ( ) ) ; } break ; } super . processMouseEvent ( evt ) ; break ; default : super . processMouseEvent ( evt ) ; break ; } } private int toolTipInitialDelay = - 1 ; private int toolTipReshowDelay = - 1 ; private boolean cellRectIsVisible ( Rectangle cellRect ) { Rectangle vr = BrowserJTree . this . getVisibleRect ( ) ; return vr . contains ( cellRect . x , cellRect . y ) && vr . contains ( cellRect . x + cellRect . width , cellRect . y + cellRect . height ) ; } private void doTypeSelect ( String str ) { if ( getSelectionCount ( ) == 0 ) doTypeSelect ( str , 0 , getRowCount ( ) ) ; else { int start = getMaxSelectionRow ( ) ; boolean retVal = doTypeSelect ( str , start , getRowCount ( ) ) ; if ( ! retVal ) { doTypeSelect ( str , 0 , start ) ; } } } private boolean doTypeSelect ( String str , int start , int end ) { for ( int i = start ; i < end ; i ++ ) { DefaultMutableTreeNode treeNode = ( DefaultMutableTreeNode ) getPathForRow ( i ) . getLastPathComponent ( ) ; Object obj = treeNode . getUserObject ( ) ; if ( obj instanceof VFS . DirectoryEntry ) { VFS . DirectoryEntry file = ( VFS . DirectoryEntry ) obj ; if ( file . name . regionMatches ( true , 0 , str , 0 , str . length ( ) ) ) { clearSelection ( ) ; setSelectionRow ( i ) ; scrollRowToVisible ( i ) ; return true ; } } } return false ; } } class TreeHandler implements TreeExpansionListener { public void treeExpanded ( TreeExpansionEvent evt ) { TreePath path = evt . getPath ( ) ; DefaultMutableTreeNode treeNode = ( DefaultMutableTreeNode ) path . getLastPathComponent ( ) ; Object userObject = treeNode . getUserObject ( ) ; if ( userObject instanceof VFS . DirectoryEntry ) { loadDirectoryNode ( treeNode , ( ( VFS . DirectoryEntry ) userObject ) . path , true ) ; } } public void treeCollapsed ( TreeExpansionEvent evt ) { TreePath path = evt . getPath ( ) ; DefaultMutableTreeNode treeNode = ( DefaultMutableTreeNode ) path . getLastPathComponent ( ) ; if ( treeNode . getUserObject ( ) instanceof VFS . DirectoryEntry ) { treeNode . removeAllChildren ( ) ; treeNode . add ( new DefaultMutableTreeNode ( new LoadingPlaceholder ( ) , false ) ) ; model . reload ( treeNode ) ; } } } class LoadingPlaceholder { } } 	1	['19', '5', '0', '13', '77', '71', '8', '10', '8', '0.813131313', '498', '1', '3', '0.973174367', '0.198830409', '0', '0', '24.63157895', '9', '2.0526', '17']
package org . gjt . sp . jedit . options ; import javax . swing . * ; import java . awt . * ; import java . io . * ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class GeneralOptionPane extends AbstractOptionPane { public GeneralOptionPane ( ) { super ( "general" ) ; } protected void _init ( ) { addComponent ( new JLabel ( jEdit . getProperty ( "options.general.lf.note" ) ) ) ; lfs = UIManager . getInstalledLookAndFeels ( ) ; String [ ] names = new String [ lfs . length ] ; String lf = UIManager . getLookAndFeel ( ) . getClass ( ) . getName ( ) ; int index = 0 ; for ( int i = 0 ; i < names . length ; i ++ ) { names [ i ] = lfs [ i ] . getName ( ) ; if ( lf . equals ( lfs [ i ] . getClassName ( ) ) ) index = i ; } lookAndFeel = new JComboBox ( names ) ; lookAndFeel . setSelectedIndex ( index ) ; addComponent ( jEdit . getProperty ( "options.general.lf" ) , lookAndFeel ) ; history = new JTextField ( jEdit . getProperty ( "history" ) ) ; addComponent ( jEdit . getProperty ( "options.general.history" ) , history ) ; saveCaret = new JCheckBox ( jEdit . getProperty ( "options.general.saveCaret" ) ) ; saveCaret . setSelected ( jEdit . getBooleanProperty ( "saveCaret" ) ) ; addComponent ( saveCaret ) ; sortBuffers = new JCheckBox ( jEdit . getProperty ( "options.general.sortBuffers" ) ) ; sortBuffers . setSelected ( jEdit . getBooleanProperty ( "sortBuffers" ) ) ; addComponent ( sortBuffers ) ; sortByName = new JCheckBox ( jEdit . getProperty ( "options.general.sortByName" ) ) ; sortByName . setSelected ( jEdit . getBooleanProperty ( "sortByName" ) ) ; addComponent ( sortByName ) ; checkModStatus = new JCheckBox ( jEdit . getProperty ( "options.general.checkModStatus" ) ) ; checkModStatus . setSelected ( jEdit . getBooleanProperty ( "view.checkModStatus" ) ) ; addComponent ( checkModStatus ) ; showFullPath = new JCheckBox ( jEdit . getProperty ( "options.general.showFullPath" ) ) ; showFullPath . setSelected ( jEdit . getBooleanProperty ( "view.showFullPath" ) ) ; addComponent ( showFullPath ) ; showSearchbar = new JCheckBox ( jEdit . getProperty ( "options.general.showSearchbar" ) ) ; showSearchbar . setSelected ( jEdit . getBooleanProperty ( "view.showSearchbar" ) ) ; addComponent ( showSearchbar ) ; showBufferSwitcher = new JCheckBox ( jEdit . getProperty ( "options.general.showBufferSwitcher" ) ) ; showBufferSwitcher . setSelected ( jEdit . getBooleanProperty ( "view.showBufferSwitcher" ) ) ; addComponent ( showBufferSwitcher ) ; showTips = new JCheckBox ( jEdit . getProperty ( "options.general.showTips" ) ) ; showTips . setSelected ( jEdit . getBooleanProperty ( "tip.show" ) ) ; addComponent ( showTips ) ; showSplash = new JCheckBox ( jEdit . getProperty ( "options.general.showSplash" ) ) ; String settingsDirectory = jEdit . getSettingsDirectory ( ) ; if ( settingsDirectory == null ) showSplash . setSelected ( true ) ; else showSplash . setSelected ( ! new File ( settingsDirectory , "nosplash" ) . exists ( ) ) ; addComponent ( showSplash ) ; globalColors = new JCheckBox ( jEdit . getProperty ( "options.general.globalColors" ) ) ; globalColors . setSelected ( jEdit . getBooleanProperty ( "globalColors" ) ) ; addComponent ( globalColors ) ; } protected void _save ( ) { String lf = lfs [ lookAndFeel . getSelectedIndex ( ) ] . getClassName ( ) ; jEdit . setProperty ( "lookAndFeel" , lf ) ; jEdit . setProperty ( "history" , history . getText ( ) ) ; jEdit . setBooleanProperty ( "saveCaret" , saveCaret . isSelected ( ) ) ; jEdit . setBooleanProperty ( "sortBuffers" , sortBuffers . isSelected ( ) ) ; jEdit . setBooleanProperty ( "sortByName" , sortByName . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.checkModStatus" , checkModStatus . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.showFullPath" , showFullPath . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.showSearchbar" , showSearchbar . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.showBufferSwitcher" , showBufferSwitcher . isSelected ( ) ) ; jEdit . setBooleanProperty ( "tip.show" , showTips . isSelected ( ) ) ; String settingsDirectory = jEdit . getSettingsDirectory ( ) ; if ( settingsDirectory != null ) { File file = new File ( settingsDirectory , "nosplash" ) ; if ( showSplash . isSelected ( ) ) file . delete ( ) ; else { try { FileOutputStream out = new FileOutputStream ( file ) ; out . write ( '\n' ) ; out . close ( ) ; } catch ( IOException io ) { Log . log ( Log . ERROR , this , io ) ; } } } jEdit . setBooleanProperty ( "globalColors" , globalColors . isSelected ( ) ) ; } private UIManager . LookAndFeelInfo [ ] lfs ; private JComboBox lookAndFeel ; private JTextField history ; private JCheckBox saveCaret ; private JCheckBox sortBuffers ; private JCheckBox sortByName ; private JCheckBox checkModStatus ; private JCheckBox showFullPath ; private JCheckBox showSearchbar ; private JCheckBox showBufferSwitcher ; private JCheckBox showTips ; private JCheckBox showSplash ; private JCheckBox globalColors ; } 	0	['3', '6', '0', '4', '34', '1', '1', '3', '1', '0.5', '370', '1', '0', '0.996987952', '1', '2', '4', '118', '5', '2.6667', '0']
package org . gjt . sp . jedit . options ; import javax . swing . * ; import java . awt . * ; import org . gjt . sp . jedit . gui . FontSelector ; import org . gjt . sp . jedit . * ; public class PrintOptionPane extends AbstractOptionPane { public PrintOptionPane ( ) { super ( "print" ) ; } protected void _init ( ) { String _fontFamily = jEdit . getProperty ( "print.font" ) ; int _fontStyle ; try { _fontStyle = Integer . parseInt ( jEdit . getProperty ( "print.fontstyle" ) ) ; } catch ( NumberFormatException nf ) { _fontStyle = Font . PLAIN ; } int _fontSize ; try { _fontSize = Integer . parseInt ( jEdit . getProperty ( "print.fontsize" ) ) ; } catch ( NumberFormatException nf ) { _fontSize = 14 ; } font = new FontSelector ( new Font ( _fontFamily , _fontStyle , _fontSize ) ) ; addComponent ( jEdit . getProperty ( "options.print.font" ) , font ) ; printHeader = new JCheckBox ( jEdit . getProperty ( "options.print" + ".header" ) ) ; printHeader . setSelected ( jEdit . getBooleanProperty ( "print.header" ) ) ; addComponent ( printHeader ) ; printFooter = new JCheckBox ( jEdit . getProperty ( "options.print" + ".footer" ) ) ; printFooter . setSelected ( jEdit . getBooleanProperty ( "print.footer" ) ) ; addComponent ( printFooter ) ; printLineNumbers = new JCheckBox ( jEdit . getProperty ( "options.print" + ".lineNumbers" ) ) ; printLineNumbers . setSelected ( jEdit . getBooleanProperty ( "print.lineNumbers" ) ) ; addComponent ( printLineNumbers ) ; style = new JCheckBox ( jEdit . getProperty ( "options.print" + ".style" ) ) ; style . setSelected ( jEdit . getBooleanProperty ( "print.style" ) ) ; addComponent ( style ) ; color = new JCheckBox ( jEdit . getProperty ( "options.print" + ".color" ) ) ; color . setSelected ( jEdit . getBooleanProperty ( "print.color" ) ) ; addComponent ( color ) ; addSeparator ( "options.print.margins" ) ; topMargin = new JTextField ( jEdit . getProperty ( "print.margin.top" ) ) ; addComponent ( jEdit . getProperty ( "options.print.margin.top" ) , topMargin ) ; leftMargin = new JTextField ( jEdit . getProperty ( "print.margin.left" ) ) ; addComponent ( jEdit . getProperty ( "options.print.margin.left" ) , leftMargin ) ; bottomMargin = new JTextField ( jEdit . getProperty ( "print.margin.bottom" ) ) ; addComponent ( jEdit . getProperty ( "options.print.margin.bottom" ) , bottomMargin ) ; rightMargin = new JTextField ( jEdit . getProperty ( "print.margin.right" ) ) ; addComponent ( jEdit . getProperty ( "options.print.margin.right" ) , rightMargin ) ; } protected void _save ( ) { Font _font = font . getFont ( ) ; jEdit . setProperty ( "print.font" , _font . getFamily ( ) ) ; jEdit . setProperty ( "print.fontsize" , String . valueOf ( _font . getSize ( ) ) ) ; jEdit . setProperty ( "print.fontstyle" , String . valueOf ( _font . getStyle ( ) ) ) ; jEdit . setBooleanProperty ( "print.header" , printHeader . isSelected ( ) ) ; jEdit . setBooleanProperty ( "print.footer" , printFooter . isSelected ( ) ) ; jEdit . setBooleanProperty ( "print.lineNumbers" , printLineNumbers . isSelected ( ) ) ; jEdit . setBooleanProperty ( "print.style" , style . isSelected ( ) ) ; jEdit . setBooleanProperty ( "print.color" , color . isSelected ( ) ) ; jEdit . setProperty ( "print.margin.top" , topMargin . getText ( ) ) ; jEdit . setProperty ( "print.margin.left" , leftMargin . getText ( ) ) ; jEdit . setProperty ( "print.margin.bottom" , bottomMargin . getText ( ) ) ; jEdit . setProperty ( "print.margin.right" , rightMargin . getText ( ) ) ; } private FontSelector font ; private JCheckBox printHeader ; private JCheckBox printFooter ; private JCheckBox printLineNumbers ; private JCheckBox style ; private JCheckBox color ; private JTextField topMargin ; private JTextField leftMargin ; private JTextField bottomMargin ; private JTextField rightMargin ; } 	1	['3', '6', '0', '4', '24', '1', '1', '3', '1', '0.5', '253', '1', '1', '0.996987952', '1', '1', '3', '80', '1', '0.6667', '1']
package org . gjt . sp . jedit . gui ; import javax . swing . table . * ; import javax . swing . * ; import java . util . Vector ; public class JCheckBoxList extends JTable { public JCheckBoxList ( Object [ ] items ) { setModel ( items ) ; } public JCheckBoxList ( Vector items ) { setModel ( items ) ; } public void setModel ( Object [ ] items ) { setModel ( new CheckBoxListModel ( items ) ) ; init ( ) ; } public void setModel ( Vector items ) { setModel ( new CheckBoxListModel ( items ) ) ; init ( ) ; } public Object [ ] getCheckedValues ( ) { Vector values = new Vector ( ) ; CheckBoxListModel model = ( CheckBoxListModel ) getModel ( ) ; for ( int i = 0 ; i < model . items . size ( ) ; i ++ ) { Entry entry = ( Entry ) model . items . elementAt ( i ) ; if ( entry . checked ) values . addElement ( entry . value ) ; } Object [ ] retVal = new Object [ values . size ( ) ] ; values . copyInto ( retVal ) ; return retVal ; } public Entry [ ] getValues ( ) { CheckBoxListModel model = ( CheckBoxListModel ) getModel ( ) ; Entry [ ] retVal = new Entry [ model . items . size ( ) ] ; model . items . copyInto ( retVal ) ; return retVal ; } public Object getSelectedValue ( ) { int row = getSelectedRow ( ) ; if ( row == - 1 ) return null ; else return getModel ( ) . getValueAt ( row , 1 ) ; } private void init ( ) { getSelectionModel ( ) . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; setShowGrid ( false ) ; setAutoResizeMode ( JTable . AUTO_RESIZE_LAST_COLUMN ) ; TableColumn column = getColumnModel ( ) . getColumn ( 0 ) ; int checkBoxWidth = new JCheckBox ( ) . getPreferredSize ( ) . width ; column . setPreferredWidth ( checkBoxWidth ) ; column . setMinWidth ( checkBoxWidth ) ; column . setWidth ( checkBoxWidth ) ; column . setMaxWidth ( checkBoxWidth ) ; column . setResizable ( false ) ; } public static class Entry { boolean checked ; Object value ; public Entry ( boolean checked , Object value ) { this . checked = checked ; this . value = value ; } public boolean isChecked ( ) { return checked ; } public Object getValue ( ) { return value ; } } } class CheckBoxListModel extends AbstractTableModel { Vector items ; CheckBoxListModel ( Vector _items ) { items = new Vector ( _items . size ( ) ) ; for ( int i = 0 ; i < _items . size ( ) ; i ++ ) { items . addElement ( createEntry ( _items . elementAt ( i ) ) ) ; } } CheckBoxListModel ( Object [ ] _items ) { items = new Vector ( _items . length ) ; for ( int i = 0 ; i < _items . length ; i ++ ) { items . addElement ( createEntry ( _items [ i ] ) ) ; } } private JCheckBoxList . Entry createEntry ( Object obj ) { if ( obj instanceof JCheckBoxList . Entry ) return ( JCheckBoxList . Entry ) obj ; else return new JCheckBoxList . Entry ( false , obj ) ; } public int getRowCount ( ) { return items . size ( ) ; } public int getColumnCount ( ) { return 2 ; } public String getColumnName ( int col ) { return null ; } public Object getValueAt ( int row , int col ) { JCheckBoxList . Entry entry = ( JCheckBoxList . Entry ) items . elementAt ( row ) ; switch ( col ) { case 0 : return new Boolean ( entry . checked ) ; case 1 : return entry . value ; default : throw new InternalError ( ) ; } } public Class getColumnClass ( int col ) { switch ( col ) { case 0 : return Boolean . class ; case 1 : return String . class ; default : throw new InternalError ( ) ; } } public boolean isCellEditable ( int row , int col ) { return ( col == 0 && ! ( ( ( JCheckBoxList . Entry ) items . elementAt ( row ) ) . value instanceof String ) ) ; } public void setValueAt ( Object value , int row , int col ) { if ( col == 0 ) { ( ( JCheckBoxList . Entry ) items . elementAt ( row ) ) . checked = ( value . equals ( Boolean . TRUE ) ) ; } } } 	0	['8', '5', '0', '4', '33', '28', '2', '2', '7', '2', '143', '0', '0', '0.992974239', '0.5', '1', '1', '16.875', '3', '1.125', '0']
package org . gjt . sp . jedit ; import javax . swing . border . EmptyBorder ; import javax . swing . * ; import java . awt . * ; public abstract class AbstractOptionPane extends JPanel implements OptionPane { public AbstractOptionPane ( String name ) { this . name = name ; setLayout ( gridBag = new GridBagLayout ( ) ) ; } public String getName ( ) { return name ; } public Component getComponent ( ) { return this ; } public void init ( ) { if ( ! initialized ) { initialized = true ; _init ( ) ; } } public void save ( ) { if ( initialized ) _save ( ) ; } protected boolean initialized ; protected GridBagLayout gridBag ; protected int y ; protected void _init ( ) { } protected void _save ( ) { } protected void addComponent ( String label , Component comp ) { GridBagConstraints cons = new GridBagConstraints ( ) ; cons . gridy = y ++ ; cons . gridheight = 1 ; cons . gridwidth = 1 ; cons . weightx = 0.0f ; cons . fill = GridBagConstraints . BOTH ; JLabel l = new JLabel ( label , SwingConstants . RIGHT ) ; l . setBorder ( new EmptyBorder ( 0 , 0 , 0 , 12 ) ) ; gridBag . setConstraints ( l , cons ) ; add ( l ) ; cons . gridx = 1 ; cons . weightx = 1.0f ; gridBag . setConstraints ( comp , cons ) ; add ( comp ) ; } protected void addComponent ( Component comp ) { GridBagConstraints cons = new GridBagConstraints ( ) ; cons . gridy = y ++ ; cons . gridheight = 1 ; cons . gridwidth = cons . REMAINDER ; cons . fill = GridBagConstraints . NONE ; cons . anchor = GridBagConstraints . WEST ; cons . weightx = 1.0f ; gridBag . setConstraints ( comp , cons ) ; add ( comp ) ; } protected void addSeparator ( String label ) { Box box = new Box ( BoxLayout . X_AXIS ) ; Box box2 = new Box ( BoxLayout . Y_AXIS ) ; box2 . add ( Box . createGlue ( ) ) ; box2 . add ( new JSeparator ( JSeparator . HORIZONTAL ) ) ; box2 . add ( Box . createGlue ( ) ) ; box . add ( box2 ) ; JLabel l = new JLabel ( jEdit . getProperty ( label ) ) ; l . setMaximumSize ( l . getPreferredSize ( ) ) ; box . add ( l ) ; Box box3 = new Box ( BoxLayout . Y_AXIS ) ; box3 . add ( Box . createGlue ( ) ) ; box3 . add ( new JSeparator ( JSeparator . HORIZONTAL ) ) ; box3 . add ( Box . createGlue ( ) ) ; box . add ( box3 ) ; GridBagConstraints cons = new GridBagConstraints ( ) ; cons . gridy = y ++ ; cons . gridheight = 1 ; cons . gridwidth = cons . REMAINDER ; cons . fill = GridBagConstraints . BOTH ; cons . anchor = GridBagConstraints . WEST ; cons . weightx = 1.0f ; gridBag . setConstraints ( box , cons ) ; add ( box ) ; } private String name ; } 	1	['10', '5', '15', '17', '27', '29', '15', '2', '5', '0.805555556', '258', '1', '0', '0.986404834', '0.5', '0', '0', '24.4', '2', '1.1', '1']
package bsh ; interface Node extends java . io . Serializable { public void jjtOpen ( ) ; public void jjtClose ( ) ; public void jjtSetParent ( Node n ) ; public Node jjtGetParent ( ) ; public void jjtAddChild ( Node n , int i ) ; public Node jjtGetChild ( int i ) ; public int jjtGetNumChildren ( ) ; } 	0	['7', '1', '0', '36', '7', '21', '36', '0', '7', '2', '7', '0', '0', '0', '0.523809524', '0', '0', '0', '1', '1', '0']
package org . gjt . sp . jedit . syntax ; import com . microstar . xml . * ; import java . io . * ; import java . net . URL ; import java . util . Enumeration ; import java . util . Stack ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class XModeHandler extends HandlerBase { public XModeHandler ( XmlParser parser , String modeName , String path ) { this . modeName = modeName ; this . parser = parser ; this . path = path ; stateStack = new Stack ( ) ; } public Object resolveEntity ( String publicId , String systemId ) { if ( "xmode.dtd" . equals ( systemId ) ) { try { return new BufferedReader ( new InputStreamReader ( getClass ( ) . getResourceAsStream ( "/org/gjt/sp/jedit/xmode.dtd" ) ) ) ; } catch ( Exception e ) { error ( "dtd" , e ) ; } } return null ; } public void attribute ( String aname , String value , boolean isSpecified ) { String tag = peekElement ( ) ; aname = ( aname == null ) ? null : aname . intern ( ) ; value = ( value == null ) ? null : value . intern ( ) ; if ( aname == "NAME" ) { propName = value ; } else if ( aname == "VALUE" ) { propValue = value ; } else if ( aname == "TYPE" ) { lastTokenID = stringToToken ( value ) ; } else if ( aname == "AT_LINE_START" ) { lastAtLineStart = ( isSpecified ) ? ( value == "TRUE" ) : false ; } else if ( aname == "NO_LINE_BREAK" ) { lastNoLineBreak = ( isSpecified ) ? ( value == "TRUE" ) : false ; } else if ( aname == "NO_WORD_BREAK" ) { lastNoWordBreak = ( isSpecified ) ? ( value == "TRUE" ) : false ; } else if ( aname == "EXCLUDE_MATCH" ) { lastExcludeMatch = ( isSpecified ) ? ( value == "TRUE" ) : false ; } else if ( aname == "IGNORE_CASE" ) { lastIgnoreCase = ( isSpecified ) ? ( value != "FALSE" ) : true ; } else if ( aname == "HIGHLIGHT_DIGITS" ) { lastHighlightDigits = ( isSpecified ) ? ( value != "FALSE" ) : false ; } else if ( aname == "AT_CHAR" ) { try { if ( isSpecified ) termChar = Integer . parseInt ( value ) ; } catch ( NumberFormatException e ) { error ( "termchar-invalid" , value ) ; termChar = - 1 ; } } else if ( aname == "ESCAPE" ) { lastEscape = value ; } else if ( aname == "SET" ) { lastSetName = value ; } else if ( aname == "DELEGATE" ) { lastDelegateSet = value ; } else if ( aname == "DEFAULT" ) { lastDefaultID = stringToToken ( value ) ; } } public void doctypeDecl ( String name , String publicId , String systemId ) throws Exception { if ( "MODE" . equalsIgnoreCase ( name ) ) return ; error ( "doctype-invalid" , name ) ; } public void charData ( char [ ] c , int off , int len ) { String tag = peekElement ( ) ; String text = new String ( c , off , len ) ; if ( tag == "WHITESPACE" || tag == "EOL_SPAN" || tag == "MARK_PREVIOUS" || tag == "MARK_FOLLOWING" || tag == "SEQ" || tag == "BEGIN" ) { lastStart = text ; } else if ( tag == "END" ) { lastEnd = text ; } else { lastKeyword = text ; } } public void startElement ( String tag ) { tag = pushElement ( tag ) ; if ( tag == "MODE" ) { mode = jEdit . getMode ( modeName ) ; if ( mode == null ) { mode = new Mode ( modeName ) ; jEdit . addMode ( mode ) ; } } else if ( tag == "KEYWORDS" ) { keywords = new KeywordMap ( true ) ; } else if ( tag == "RULES" ) { rules = new ParserRuleSet ( ) ; rules . setIgnoreCase ( lastIgnoreCase ) ; rules . setHighlightDigits ( lastHighlightDigits ) ; rules . setEscape ( lastEscape ) ; rules . setDefault ( lastDefaultID ) ; } } public void endElement ( String name ) { if ( name == null ) return ; String tag = popElement ( ) ; if ( name . equalsIgnoreCase ( tag ) ) { if ( tag == "MODE" ) { mode . init ( ) ; mode . setTokenMarker ( marker ) ; } else if ( tag == "PROPERTY" ) { try { mode . setProperty ( propName , new Integer ( propValue ) ) ; } catch ( NumberFormatException nf ) { mode . setProperty ( propName , propValue ) ; } } else if ( tag == "KEYWORDS" ) { keywords . setIgnoreCase ( lastIgnoreCase ) ; lastIgnoreCase = true ; } else if ( tag == "RULES" ) { rules . setKeywords ( keywords ) ; marker . addRuleSet ( lastSetName , rules ) ; keywords = null ; lastSetName = null ; lastEscape = null ; lastIgnoreCase = true ; lastHighlightDigits = false ; lastDefaultID = Token . NULL ; rules = null ; } else if ( tag == "TERMINATE" ) { setTerminateChar ( termChar ) ; termChar = - 1 ; } else if ( tag == "WHITESPACE" ) { if ( lastStart == null ) { error ( "empty-tag" , "WHITESPACE" ) ; return ; } addRule ( ParserRuleFactory . createWhitespaceRule ( lastStart ) ) ; lastStart = null ; lastEnd = null ; } else if ( tag == "EOL_SPAN" ) { if ( lastStart == null ) { error ( "empty-tag" , "EOL_SPAN" ) ; return ; } addRule ( ParserRuleFactory . createEOLSpanRule ( lastStart , lastTokenID , lastAtLineStart , lastExcludeMatch ) ) ; lastStart = null ; lastEnd = null ; lastTokenID = Token . NULL ; lastAtLineStart = false ; lastExcludeMatch = false ; } else if ( tag == "MARK_PREVIOUS" ) { if ( lastStart == null ) { error ( "empty-tag" , "MARK_PREVIOUS" ) ; return ; } addRule ( ParserRuleFactory . createMarkPreviousRule ( lastStart , lastTokenID , lastAtLineStart , lastExcludeMatch ) ) ; lastStart = null ; lastEnd = null ; lastTokenID = Token . NULL ; lastAtLineStart = false ; lastExcludeMatch = false ; } else if ( tag == "MARK_FOLLOWING" ) { if ( lastStart == null ) { error ( "empty-tag" , "MARK_FOLLOWING" ) ; return ; } addRule ( ParserRuleFactory . createMarkFollowingRule ( lastStart , lastTokenID , lastAtLineStart , lastExcludeMatch ) ) ; lastStart = null ; lastEnd = null ; lastTokenID = Token . NULL ; lastAtLineStart = false ; lastExcludeMatch = false ; } else if ( tag == "SEQ" ) { if ( lastStart == null ) { error ( "empty-tag" , "SEQ" ) ; return ; } addRule ( ParserRuleFactory . createSequenceRule ( lastStart , lastTokenID , lastAtLineStart ) ) ; lastStart = null ; lastEnd = null ; lastTokenID = Token . NULL ; lastAtLineStart = false ; } else if ( tag == "END" ) { if ( lastDelegateSet == null ) { addRule ( ParserRuleFactory . createSpanRule ( lastStart , lastEnd , lastTokenID , lastNoLineBreak , lastAtLineStart , lastExcludeMatch , lastNoWordBreak ) ) ; } else { if ( lastDelegateSet . indexOf ( "::" ) == - 1 ) { lastDelegateSet = modeName + "::" + lastDelegateSet ; } addRule ( ParserRuleFactory . createDelegateSpanRule ( lastStart , lastEnd , lastDelegateSet , lastTokenID , lastNoLineBreak , lastAtLineStart , lastExcludeMatch , lastNoWordBreak ) ) ; } lastStart = null ; lastEnd = null ; lastTokenID = Token . NULL ; lastAtLineStart = false ; lastNoLineBreak = false ; lastExcludeMatch = false ; lastNoWordBreak = false ; lastDelegateSet = null ; } else if ( tag == "NULL" ) { addKeyword ( lastKeyword , Token . NULL ) ; } else if ( tag == "COMMENT1" ) { addKeyword ( lastKeyword , Token . COMMENT1 ) ; } else if ( tag == "COMMENT2" ) { addKeyword ( lastKeyword , Token . COMMENT2 ) ; } else if ( tag == "LITERAL1" ) { addKeyword ( lastKeyword , Token . LITERAL1 ) ; } else if ( tag == "LITERAL2" ) { addKeyword ( lastKeyword , Token . LITERAL2 ) ; } else if ( tag == "LABEL" ) { addKeyword ( lastKeyword , Token . LABEL ) ; } else if ( tag == "KEYWORD1" ) { addKeyword ( lastKeyword , Token . KEYWORD1 ) ; } else if ( tag == "KEYWORD2" ) { addKeyword ( lastKeyword , Token . KEYWORD2 ) ; } else if ( tag == "KEYWORD3" ) { addKeyword ( lastKeyword , Token . KEYWORD3 ) ; } else if ( tag == "FUNCTION" ) { addKeyword ( lastKeyword , Token . FUNCTION ) ; } else if ( tag == "MARKUP" ) { addKeyword ( lastKeyword , Token . MARKUP ) ; } else if ( tag == "OPERATOR" ) { addKeyword ( lastKeyword , Token . OPERATOR ) ; } else if ( tag == "DIGIT" ) { addKeyword ( lastKeyword , Token . DIGIT ) ; } } else { throw new InternalError ( ) ; } } public void startDocument ( ) { marker = new TokenMarker ( ) ; marker . setName ( modeName ) ; pushElement ( null ) ; } private XmlParser parser ; private String modeName ; private String path ; private TokenMarker marker ; private KeywordMap keywords ; private Mode mode ; private Stack stateStack ; private String propName ; private String propValue ; private String lastStart ; private String lastEnd ; private String lastKeyword ; private String lastSetName ; private String lastEscape ; private String lastDelegateSet ; private ParserRuleSet rules ; private byte lastDefaultID = Token . NULL ; private byte lastTokenID ; private int termChar = - 1 ; private boolean lastNoLineBreak ; private boolean lastNoWordBreak ; private boolean lastAtLineStart ; private boolean lastExcludeMatch ; private boolean lastIgnoreCase = true ; private boolean lastHighlightDigits ; private byte stringToToken ( String value ) { if ( value == "NULL" ) { return Token . NULL ; } else if ( value == "COMMENT1" ) { return Token . COMMENT1 ; } else if ( value == "COMMENT2" ) { return Token . COMMENT2 ; } else if ( value == "LITERAL1" ) { return Token . LITERAL1 ; } else if ( value == "LITERAL2" ) { return Token . LITERAL2 ; } else if ( value == "LABEL" ) { return Token . LABEL ; } else if ( value == "KEYWORD1" ) { return Token . KEYWORD1 ; } else if ( value == "KEYWORD2" ) { return Token . KEYWORD2 ; } else if ( value == "KEYWORD3" ) { return Token . KEYWORD3 ; } else if ( value == "FUNCTION" ) { return Token . FUNCTION ; } else if ( value == "MARKUP" ) { return Token . MARKUP ; } else if ( value == "OPERATOR" ) { return Token . OPERATOR ; } else if ( value == "DIGIT" ) { return Token . DIGIT ; } else if ( value == "INVALID" ) { return Token . INVALID ; } else { error ( "token-invalid" , value ) ; return Token . NULL ; } } private void addKeyword ( String k , byte id ) { if ( k == null ) { error ( "empty-keyword" ) ; return ; } if ( keywords == null ) return ; keywords . add ( k , id ) ; } private void addRule ( ParserRule r ) { rules . addRule ( r ) ; } private void setTerminateChar ( int atChar ) { rules . setTerminateChar ( atChar ) ; } private String pushElement ( String name ) { name = ( name == null ) ? null : name . intern ( ) ; stateStack . push ( name ) ; return name ; } private String peekElement ( ) { return ( String ) stateStack . peek ( ) ; } private String popElement ( ) { return ( String ) stateStack . pop ( ) ; } private void error ( String msg ) { _error ( jEdit . getProperty ( "xmode-error." + msg ) ) ; } private void error ( String msg , String subst ) { _error ( jEdit . getProperty ( "xmode-error." + msg , new String [ ] { subst } ) ) ; } private void error ( String msg , Throwable t ) { _error ( jEdit . getProperty ( "xmode-error." + msg , new String [ ] { t . toString ( ) } ) ) ; Log . log ( Log . ERROR , this , t ) ; } private void _error ( String msg ) { Object [ ] args = { path , new Integer ( parser . getLineNumber ( ) ) , new Integer ( parser . getColumnNumber ( ) ) , msg } ; GUIUtilities . error ( null , "xmode-error" , args ) ; } } 	1	['19', '2', '0', '11', '75', '123', '1', '11', '8', '0.888888889', '1106', '1', '5', '0.419354839', '0.233918129', '1', '1', '55.89473684', '33', '5.5789', '2']
package bsh ; class BSHBinaryExpression extends SimpleNode implements ParserConstants { public int kind ; BSHBinaryExpression ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { Object lhs = ( ( SimpleNode ) jjtGetChild ( 0 ) ) . eval ( callstack , interpreter ) ; if ( kind == INSTANCEOF ) { if ( lhs == Primitive . NULL ) return new Primitive ( false ) ; if ( lhs instanceof Primitive ) return new Primitive ( false ) ; NameSpace namespace = callstack . top ( ) ; Class rhs = ( ( BSHType ) jjtGetChild ( 1 ) ) . getType ( namespace ) ; boolean ret = ( Reflect . isAssignableFrom ( rhs , lhs . getClass ( ) ) ) ; return new Primitive ( ret ) ; } if ( kind == BOOL_AND || kind == BOOL_ANDX ) { Object obj = lhs ; if ( isPrimitiveValue ( lhs ) ) obj = ( ( Primitive ) lhs ) . getValue ( ) ; if ( obj instanceof Boolean && ( ( ( Boolean ) obj ) . booleanValue ( ) == false ) ) return new Primitive ( false ) ; } if ( kind == BOOL_OR || kind == BOOL_ORX ) { Object obj = lhs ; if ( isPrimitiveValue ( lhs ) ) obj = ( ( Primitive ) lhs ) . getValue ( ) ; if ( obj instanceof Boolean && ( ( ( Boolean ) obj ) . booleanValue ( ) == true ) ) return new Primitive ( true ) ; } boolean isLhsWrapper = isWrapper ( lhs ) ; Object rhs = ( ( SimpleNode ) jjtGetChild ( 1 ) ) . eval ( callstack , interpreter ) ; boolean isRhsWrapper = isWrapper ( rhs ) ; if ( ( isLhsWrapper || isPrimitiveValue ( lhs ) ) && ( isRhsWrapper || isPrimitiveValue ( rhs ) ) ) { if ( ( isLhsWrapper && isRhsWrapper && kind == EQ ) ) { } else try { return Primitive . binaryOperation ( lhs , rhs , kind ) ; } catch ( TargetError e ) { e . reThrow ( this ) ; } } switch ( kind ) { case EQ : return new Primitive ( ( lhs == rhs ) ) ; case NE : return new Primitive ( ( lhs != rhs ) ) ; case PLUS : if ( lhs instanceof String || rhs instanceof String ) return lhs . toString ( ) + rhs . toString ( ) ; default : if ( lhs instanceof Primitive || rhs instanceof Primitive ) if ( lhs == Primitive . VOID || rhs == Primitive . VOID ) throw new EvalError ( "illegal use of undefined variable, class, or 'void' literal" , this ) ; else if ( lhs == Primitive . NULL || rhs == Primitive . NULL ) throw new EvalError ( "illegal use of null value or 'null' literal" , this ) ; throw new EvalError ( "Operator: '" + tokenImage [ kind ] + "' inappropriate for objects" , this ) ; } } private boolean isPrimitiveValue ( Object obj ) { return ( ( obj instanceof Primitive ) && ( obj != Primitive . VOID ) && ( obj != Primitive . NULL ) ) ; } private boolean isWrapper ( Object obj ) { return ( obj instanceof Boolean || obj instanceof Character || obj instanceof Number ) ; } } 	0	['4', '2', '0', '12', '21', '6', '1', '11', '1', '1', '279', '0', '0', '0.857142857', '0.45', '1', '1', '68.5', '4', '2.25', '0']
package org . gjt . sp . jedit ; import javax . swing . text . BadLocationException ; import javax . swing . text . Element ; import javax . swing . JOptionPane ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import java . io . BufferedReader ; import java . io . FileReader ; import java . io . File ; import java . io . IOException ; import java . util . * ; import org . gjt . sp . jedit . browser . * ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . io . VFSManager ; import org . gjt . sp . jedit . msg . * ; import org . gjt . sp . util . Log ; public class Macros { public static void message ( View view , String message ) { JOptionPane . showMessageDialog ( view , message , jEdit . getProperty ( "macro-message.title" ) , JOptionPane . INFORMATION_MESSAGE ) ; } public static void error ( View view , String message ) { JOptionPane . showMessageDialog ( view , message , jEdit . getProperty ( "macro-message.title" ) , JOptionPane . ERROR_MESSAGE ) ; } public static String input ( View view , String prompt ) { return input ( view , prompt , null ) ; } public static String input ( View view , String prompt , String defaultValue ) { return ( String ) JOptionPane . showInputDialog ( view , prompt , jEdit . getProperty ( "macro-input.title" ) , JOptionPane . QUESTION_MESSAGE , null , null , defaultValue ) ; } public static void browseSystemMacros ( View view ) { if ( userMacroPath == null ) { GUIUtilities . error ( view , "no-webstart" , null ) ; return ; } DockableWindowManager dockableWindowManager = view . getDockableWindowManager ( ) ; dockableWindowManager . addDockableWindow ( VFSBrowser . NAME ) ; final VFSBrowser browser = ( VFSBrowser ) dockableWindowManager . getDockableWindow ( VFSBrowser . NAME ) ; VFSManager . runInAWTThread ( new Runnable ( ) { public void run ( ) { browser . setDirectory ( systemMacroPath ) ; } } ) ; } public static void browseUserMacros ( View view ) { if ( userMacroPath == null ) { GUIUtilities . error ( view , "no-settings" , null ) ; return ; } DockableWindowManager dockableWindowManager = view . getDockableWindowManager ( ) ; dockableWindowManager . addDockableWindow ( VFSBrowser . NAME ) ; final VFSBrowser browser = ( VFSBrowser ) dockableWindowManager . getDockableWindow ( VFSBrowser . NAME ) ; VFSManager . runInAWTThread ( new Runnable ( ) { public void run ( ) { browser . setDirectory ( userMacroPath ) ; } } ) ; } public static void loadMacros ( ) { macroList = new Vector ( ) ; macroHierarchy = new Vector ( ) ; macroHash = new Hashtable ( ) ; if ( jEdit . getJEditHome ( ) != null ) { systemMacroPath = MiscUtilities . constructPath ( jEdit . getJEditHome ( ) , "macros" ) ; loadMacros ( macroHierarchy , "" , new File ( systemMacroPath ) ) ; } String settings = jEdit . getSettingsDirectory ( ) ; if ( settings != null ) { userMacroPath = MiscUtilities . constructPath ( settings , "macros" ) ; loadMacros ( macroHierarchy , "" , new File ( userMacroPath ) ) ; } MiscUtilities . quicksort ( macroList , new MiscUtilities . StringICaseCompare ( ) ) ; EditBus . send ( new MacrosChanged ( null ) ) ; } public static Vector getMacroHierarchy ( ) { return macroHierarchy ; } public static Vector getMacroList ( ) { return macroList ; } public static Macro getMacro ( String macro ) { return ( Macro ) macroHash . get ( macro ) ; } public static class Macro { public String name ; public String path ; public EditAction action ; public Macro ( String name , final String path ) { this . name = name ; this . path = path ; action = new EditAction ( name , false ) { public void invoke ( View view ) { lastMacro = path ; Buffer buffer = view . getBuffer ( ) ; try { buffer . beginCompoundEdit ( ) ; BeanShell . runScript ( view , path , true , false ) ; } finally { buffer . endCompoundEdit ( ) ; } } } ; } public String toString ( ) { return name ; } } public static void recordTemporaryMacro ( View view ) { String settings = jEdit . getSettingsDirectory ( ) ; if ( settings == null ) { GUIUtilities . error ( view , "no-settings" , new String [ 0 ] ) ; return ; } if ( view . getMacroRecorder ( ) != null ) { GUIUtilities . error ( view , "already-recording" , new String [ 0 ] ) ; return ; } Buffer buffer = jEdit . openFile ( null , settings + File . separator + "macros" , "Temporary_Macro.bsh" , true , null ) ; if ( buffer == null ) return ; try { buffer . remove ( 0 , buffer . getLength ( ) ) ; buffer . insertString ( 0 , jEdit . getProperty ( "macro.temp.header" ) , null ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , Macros . class , bl ) ; } recordMacro ( view , buffer , true ) ; } public static void recordMacro ( View view ) { String settings = jEdit . getSettingsDirectory ( ) ; if ( settings == null ) { GUIUtilities . error ( view , "no-settings" , new String [ 0 ] ) ; return ; } if ( view . getMacroRecorder ( ) != null ) { GUIUtilities . error ( view , "already-recording" , new String [ 0 ] ) ; return ; } String name = GUIUtilities . input ( view , "record" , null ) ; if ( name == null ) return ; name = name . replace ( ' ' , '_' ) ; Buffer buffer = jEdit . openFile ( null , null , MiscUtilities . constructPath ( settings , "macros" , name + ".bsh" ) , true , null ) ; if ( buffer == null ) return ; try { buffer . remove ( 0 , buffer . getLength ( ) ) ; buffer . insertString ( 0 , jEdit . getProperty ( "macro.header" ) , null ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , Macros . class , bl ) ; } recordMacro ( view , buffer , false ) ; } public static void stopRecording ( View view ) { InputHandler inputHandler = view . getInputHandler ( ) ; Recorder recorder = view . getMacroRecorder ( ) ; if ( recorder == null ) GUIUtilities . error ( view , "macro-not-recording" , null ) ; else { view . setMacroRecorder ( null ) ; if ( ! recorder . temporary ) view . setBuffer ( recorder . buffer ) ; recorder . dispose ( ) ; } } public static void runTemporaryMacro ( View view ) { String settings = jEdit . getSettingsDirectory ( ) ; if ( settings == null ) { GUIUtilities . error ( view , "no-settings" , new String [ 0 ] ) ; return ; } lastMacro = MiscUtilities . constructPath ( jEdit . getSettingsDirectory ( ) , "macros" , "Temporary_Macro.bsh" ) ; Buffer buffer = view . getBuffer ( ) ; try { buffer . beginCompoundEdit ( ) ; BeanShell . runScript ( view , lastMacro , true , false ) ; } finally { buffer . endCompoundEdit ( ) ; } } public static void runLastMacro ( View view ) { if ( lastMacro == null ) view . getToolkit ( ) . beep ( ) ; else BeanShell . runScript ( view , lastMacro , true , false ) ; } private static String systemMacroPath ; private static String userMacroPath ; private static Vector macroList ; private static Vector macroHierarchy ; private static Hashtable macroHash ; private static String lastMacro ; static { EditBus . addToBus ( new MacrosEBComponent ( ) ) ; } private static void loadMacros ( Vector vector , String path , File directory ) { String [ ] macroFiles = directory . list ( ) ; if ( macroFiles == null ) return ; MiscUtilities . quicksort ( macroFiles , new MiscUtilities . StringICaseCompare ( ) ) ; for ( int i = 0 ; i < macroFiles . length ; i ++ ) { String fileName = macroFiles [ i ] ; File file = new File ( directory , fileName ) ; if ( fileName . toLowerCase ( ) . endsWith ( ".bsh" ) ) { String label = fileName . substring ( 0 , fileName . length ( ) - 4 ) ; String name = path + label ; Macro newMacro = new Macro ( name , file . getPath ( ) ) ; vector . addElement ( newMacro ) ; macroList . addElement ( newMacro ) ; macroHash . put ( name , newMacro ) ; } else if ( file . isDirectory ( ) ) { Vector submenu = new Vector ( ) ; submenu . addElement ( fileName . replace ( '_' , ' ' ) ) ; loadMacros ( submenu , path + fileName + '/' , file ) ; vector . addElement ( submenu ) ; } } } private static void recordMacro ( View view , Buffer buffer , boolean temporary ) { lastMacro = buffer . getPath ( ) ; view . setMacroRecorder ( new Recorder ( view , buffer , temporary ) ) ; view . getStatus ( ) . setMessage ( null ) ; } static class MacrosEBComponent implements EBComponent { public void handleMessage ( EBMessage msg ) { if ( msg instanceof BufferUpdate ) { BufferUpdate bmsg = ( BufferUpdate ) msg ; if ( bmsg . getWhat ( ) == BufferUpdate . DIRTY_CHANGED && ! bmsg . getBuffer ( ) . isDirty ( ) ) maybeReloadMacros ( bmsg . getBuffer ( ) . getPath ( ) ) ; } else if ( msg instanceof VFSUpdate ) { maybeReloadMacros ( ( ( VFSUpdate ) msg ) . getPath ( ) ) ; } } private void maybeReloadMacros ( String path ) { if ( File . separatorChar == '\\' || File . separatorChar == ':' ) { path = path . toLowerCase ( ) ; if ( systemMacroPath != null && path . startsWith ( systemMacroPath . toLowerCase ( ) ) ) loadMacros ( ) ; if ( userMacroPath != null && path . startsWith ( userMacroPath . toLowerCase ( ) ) ) loadMacros ( ) ; } else { if ( systemMacroPath != null && path . startsWith ( systemMacroPath ) ) loadMacros ( ) ; if ( userMacroPath != null && path . startsWith ( userMacroPath ) ) loadMacros ( ) ; } } } public static class Recorder implements EBComponent { View view ; Buffer buffer ; boolean temporary ; boolean lastWasInput ; public Recorder ( View view , Buffer buffer , boolean temporary ) { this . view = view ; this . buffer = buffer ; this . temporary = temporary ; EditBus . addToBus ( this ) ; } public void record ( String code ) { if ( lastWasInput ) { lastWasInput = false ; append ( "\");" ) ; } append ( "\n" ) ; append ( code ) ; } public void record ( int repeat , String code ) { if ( repeat == 1 ) record ( code ) ; else { record ( "for(int i = 1; i <= " + repeat + "; i++)\n" + "{\n" + code + "\n" + "}" ) ; } } public void record ( int repeat , char ch ) { if ( ch == '\n' ) record ( repeat , "textArea.userInput(\'\\n\');" ) ; else if ( ch == '\t' ) record ( repeat , "textArea.userInput(\'\\t\');" ) ; else { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < repeat ; i ++ ) buf . append ( ch ) ; String charStr = MiscUtilities . charsToEscapes ( buf . toString ( ) ) ; if ( lastWasInput ) append ( charStr ) ; else { append ( "\ntextArea.setSelectedText(\"" + charStr ) ; lastWasInput = true ; } } } public void handleMessage ( EBMessage msg ) { if ( msg instanceof BufferUpdate ) { BufferUpdate bmsg = ( BufferUpdate ) msg ; if ( bmsg . getWhat ( ) == BufferUpdate . CLOSED ) { if ( bmsg . getBuffer ( ) == buffer ) stopRecording ( view ) ; } } } private void append ( String str ) { try { buffer . insertString ( buffer . getLength ( ) , str , null ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } } private void dispose ( ) { if ( lastWasInput ) { lastWasInput = false ; append ( "\");" ) ; } int lineCount = buffer . getDefaultRootElement ( ) . getElementCount ( ) ; for ( int i = 0 ; i < lineCount ; i ++ ) { buffer . indentLine ( i , true , true ) ; } EditBus . removeFromBus ( this ) ; view . getStatus ( ) . setMessage ( null ) ; } } } 	1	['24', '1', '0', '29', '89', '228', '11', '24', '16', '0.900621118', '534', '1', '0', '0', '0.155279503', '0', '0', '20.95833333', '6', '1.875', '6']
package bsh ; import java . io . IOException ; public class This implements java . io . Serializable , Runnable { NameSpace namespace ; transient Interpreter declaringInterpreter ; transient CallStack callstack ; static This getThis ( NameSpace namespace , Interpreter declaringInterpreter ) { try { if ( Capabilities . canGenerateInterfaces ( ) ) return ( This ) Reflect . constructObject ( "bsh.XThis" , new Object [ ] { namespace , declaringInterpreter } ) ; else if ( Capabilities . haveSwing ( ) ) return ( This ) Reflect . constructObject ( "bsh.JThis" , new Object [ ] { namespace , declaringInterpreter } ) ; else return new This ( namespace , declaringInterpreter ) ; } catch ( Exception e ) { throw new InterpreterError ( "internal error 1 in This: " + e ) ; } } public Object getInterface ( Class clas ) throws EvalError { if ( clas . isInstance ( this ) ) return this ; else throw new EvalError ( "Dynamic proxy mechanism not available. " + "Cannot construct interface type: " + clas ) ; } protected This ( NameSpace namespace , Interpreter declaringInterpreter ) { this . namespace = namespace ; this . declaringInterpreter = declaringInterpreter ; initCallStack ( namespace ) ; } public NameSpace getNameSpace ( ) { return namespace ; } public String toString ( ) { return "'this' reference to Bsh object: " + namespace . name ; } public void run ( ) { try { invokeMethod ( "run" , new Object [ 0 ] ) ; } catch ( EvalError e ) { declaringInterpreter . error ( "Exception in runnable:" + e ) ; } } public Object invokeMethod ( String name , Object [ ] args ) throws EvalError { return invokeMethod ( name , args , declaringInterpreter , null , null ) ; } public Object invokeMethod ( String name , Object [ ] args , Interpreter interpreter , CallStack callstack , SimpleNode callerInfo ) throws EvalError { return namespace . invokeMethod ( name , args , interpreter , callstack , callerInfo ) ; } public static void bind ( This ths , NameSpace namespace , Interpreter declaringInterpreter ) { ths . namespace . setParent ( namespace ) ; ths . declaringInterpreter = declaringInterpreter ; ths . initCallStack ( namespace ) ; } private synchronized void writeObject ( java . io . ObjectOutputStream s ) throws IOException { NameSpace parent = namespace . getParent ( ) ; namespace . prune ( ) ; s . defaultWriteObject ( ) ; namespace . setParent ( parent ) ; } private final void initCallStack ( NameSpace namespace ) { callstack = new CallStack ( ) ; callstack . push ( namespace ) ; } } 	0	['11', '1', '2', '14', '30', '15', '9', '8', '7', '0.566666667', '182', '0', '3', '0', '0.236363636', '0', '0', '15.27272727', '3', '1.0909', '0']
package org . gjt . sp . jedit . syntax ; import javax . swing . text . * ; import java . util . * ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class TokenMarker { public static final int MAJOR_ACTIONS = 0x000000FF ; public static final int WHITESPACE = 1 << 0 ; public static final int SPAN = 1 << 1 ; public static final int MARK_PREVIOUS = 1 << 2 ; public static final int MARK_FOLLOWING = 1 << 3 ; public static final int EOL_SPAN = 1 << 4 ; public static final int ACTION_HINTS = 0x0000FF00 ; public static final int EXCLUDE_MATCH = 1 << 8 ; public static final int AT_LINE_START = 1 << 9 ; public static final int NO_LINE_BREAK = 1 << 10 ; public static final int NO_WORD_BREAK = 1 << 11 ; public static final int IS_ESCAPE = 1 << 12 ; public static final int DELEGATE = 1 << 13 ; public TokenMarker ( ) { ruleSets = new Hashtable ( 64 ) ; } public void addRuleSet ( String setName , ParserRuleSet rules ) { if ( rules == null ) return ; if ( setName == null ) setName = "MAIN" ; ruleSets . put ( rulePfx . concat ( setName ) , rules ) ; } public ParserRuleSet getMainRuleSet ( ) { return getRuleSet ( rulePfx + "MAIN" ) ; } public ParserRuleSet getRuleSet ( String setName ) { ParserRuleSet rules ; rules = ( ParserRuleSet ) ruleSets . get ( setName ) ; if ( rules == null && ! setName . startsWith ( rulePfx ) ) { int delim = setName . indexOf ( "::" ) ; String modeName = setName . substring ( 0 , delim ) ; Mode mode = jEdit . getMode ( modeName ) ; if ( mode == null ) { Log . log ( Log . ERROR , TokenMarker . class , "Unknown edit mode: " + modeName ) ; rules = null ; } else { TokenMarker marker = mode . getTokenMarker ( ) ; rules = marker . getRuleSet ( setName ) ; } ruleSets . put ( setName , rules ) ; } if ( rules == null ) { Log . log ( Log . ERROR , this , "Unresolved delegate target: " + setName ) ; } return rules ; } public String getName ( ) { return name ; } public void setName ( String name ) { if ( name == null ) throw new NullPointerException ( ) ; this . name = name ; rulePfx = name . concat ( "::" ) ; } public void markTokens ( Buffer . LineInfo prevInfo , Buffer . LineInfo info , Segment line ) { LineContext lastContext = ( prevInfo == null ? null : prevInfo . context ) ; if ( lastContext == null ) { lastContext = new LineContext ( null , getRuleSet ( rulePfx . concat ( "MAIN" ) ) ) ; } context = info . context ; context . parent = ( lastContext . parent == null ? null : ( LineContext ) lastContext . parent . clone ( ) ) ; context . inRule = lastContext . inRule ; context . rules = lastContext . rules ; lastOffset = lastKeyword = line . offset ; lineLength = line . count + line . offset ; int terminateChar = context . rules . getTerminateChar ( ) ; int searchLimit = ( terminateChar >= 0 && terminateChar < line . count ) ? line . offset + terminateChar : lineLength ; escaped = false ; boolean b ; boolean tempEscaped ; Segment tempPattern ; ParserRule rule ; LineContext tempContext ; for ( pos = line . offset ; pos < searchLimit ; pos ++ ) { if ( context . parent != null ) { tempContext = context ; context = context . parent ; pattern . array = context . inRule . searchChars ; pattern . count = context . inRule . sequenceLengths [ 1 ] ; pattern . offset = context . inRule . sequenceLengths [ 0 ] ; b = handleRule ( info , line , context . inRule ) ; context = tempContext ; if ( ! b ) { if ( escaped ) { escaped = false ; } else { if ( pos != lastOffset ) { if ( context . inRule == null ) { markKeyword ( info , line , lastKeyword , pos ) ; info . addToken ( pos - lastOffset , context . rules . getDefault ( ) ) ; } else if ( ( context . inRule . action & ( NO_LINE_BREAK | NO_WORD_BREAK ) ) == 0 ) { info . addToken ( pos - lastOffset , context . inRule . token ) ; } else { info . addToken ( pos - lastOffset , Token . INVALID ) ; } } context = ( LineContext ) context . parent ; if ( ( context . inRule . action & EXCLUDE_MATCH ) == EXCLUDE_MATCH ) { info . addToken ( pattern . count , context . rules . getDefault ( ) ) ; } else { info . addToken ( pattern . count , context . inRule . token ) ; } context . inRule = null ; lastKeyword = lastOffset = pos + pattern . count ; } pos += ( pattern . count - 1 ) ; continue ; } } if ( ( rule = context . rules . getEscapeRule ( ) ) != null ) { tempPattern = pattern ; pattern = context . rules . getEscapePattern ( ) ; tempEscaped = escaped ; b = handleRule ( info , line , rule ) ; pattern = tempPattern ; if ( ! b ) { if ( tempEscaped ) escaped = false ; continue ; } } rule = context . inRule ; if ( rule != null && ( rule . action & SPAN ) == SPAN ) { pattern . array = rule . searchChars ; pattern . count = rule . sequenceLengths [ 1 ] ; pattern . offset = rule . sequenceLengths [ 0 ] ; if ( ! handleRule ( info , line , rule ) || ( rule . action & SOFT_SPAN ) == 0 ) { escaped = false ; continue ; } } rule = context . rules . getRules ( line . array [ pos ] ) ; while ( rule != null ) { pattern . array = rule . searchChars ; if ( context . inRule == rule && ( rule . action & SPAN ) == SPAN ) { pattern . count = rule . sequenceLengths [ 1 ] ; pattern . offset = rule . sequenceLengths [ 0 ] ; } else { pattern . count = rule . sequenceLengths [ 0 ] ; pattern . offset = 0 ; } if ( ! handleRule ( info , line , rule ) ) break ; rule = rule . next ; } escaped = false ; } if ( context . inRule == null ) markKeyword ( info , line , lastKeyword , lineLength ) ; if ( lastOffset != lineLength ) { if ( context . inRule == null ) { info . addToken ( lineLength - lastOffset , context . rules . getDefault ( ) ) ; } else if ( ( context . inRule . action & SPAN ) == SPAN && ( context . inRule . action & ( NO_LINE_BREAK | NO_WORD_BREAK ) ) != 0 ) { info . addToken ( lineLength - lastOffset , Token . INVALID ) ; context . inRule = null ; } else { info . addToken ( lineLength - lastOffset , context . inRule . token ) ; if ( ( context . inRule . action & MARK_FOLLOWING ) == MARK_FOLLOWING ) { context . inRule = null ; } } } info . context = context ; } private static final int SOFT_SPAN = MARK_FOLLOWING | NO_WORD_BREAK ; private String name ; private String rulePfx ; private Hashtable ruleSets ; private LineContext context ; private Segment pattern = new Segment ( new char [ 0 ] , 0 , 0 ) ; private int lastOffset ; private int lastKeyword ; private int lineLength ; private int pos ; private boolean escaped ; private boolean handleRule ( Buffer . LineInfo info , Segment line , ParserRule checkRule ) { if ( pattern . count == 0 ) return true ; if ( lineLength - pos < pattern . count ) return true ; char a , b ; for ( int k = 0 ; k < pattern . count ; k ++ ) { a = pattern . array [ pattern . offset + k ] ; b = line . array [ pos + k ] ; if ( ! ( a == b || context . rules . getIgnoreCase ( ) && ( Character . toLowerCase ( a ) == b || a == Character . toLowerCase ( b ) ) ) ) return true ; } if ( escaped ) { pos += pattern . count - 1 ; return false ; } else if ( ( checkRule . action & IS_ESCAPE ) == IS_ESCAPE ) { escaped = true ; pos += pattern . count - 1 ; return false ; } if ( context . inRule != checkRule && context . inRule != null && ( context . inRule . action & SOFT_SPAN ) != 0 ) { if ( ( context . inRule . action & NO_WORD_BREAK ) == NO_WORD_BREAK ) { info . addToken ( pos - lastOffset , Token . INVALID ) ; } else { info . addToken ( pos - lastOffset , context . inRule . token ) ; } lastOffset = lastKeyword = pos ; context . inRule = null ; } if ( context . inRule == null ) { if ( ( checkRule . action & AT_LINE_START ) == AT_LINE_START ) { if ( ( ( ( checkRule . action & MARK_PREVIOUS ) != 0 ) ? lastKeyword : pos ) != line . offset ) { return true ; } } markKeyword ( info , line , lastKeyword , pos ) ; if ( ( checkRule . action & MARK_PREVIOUS ) != MARK_PREVIOUS ) { lastKeyword = pos + pattern . count ; if ( ( checkRule . action & WHITESPACE ) == WHITESPACE ) { return false ; } if ( lastOffset < pos ) { info . addToken ( pos - lastOffset , context . rules . getDefault ( ) ) ; } } switch ( checkRule . action & MAJOR_ACTIONS ) { case 0 : info . addToken ( pattern . count , checkRule . token ) ; lastOffset = pos + pattern . count ; break ; case SPAN : context . inRule = checkRule ; if ( ( checkRule . action & DELEGATE ) != DELEGATE ) { if ( ( checkRule . action & EXCLUDE_MATCH ) == EXCLUDE_MATCH ) { info . addToken ( pattern . count , context . rules . getDefault ( ) ) ; lastOffset = pos + pattern . count ; } else { lastOffset = pos ; } } else { String setName = new String ( checkRule . searchChars , checkRule . sequenceLengths [ 0 ] + checkRule . sequenceLengths [ 1 ] , checkRule . sequenceLengths [ 2 ] ) ; ParserRuleSet delegateSet = getRuleSet ( setName ) ; if ( delegateSet != null ) { if ( ( checkRule . action & EXCLUDE_MATCH ) == EXCLUDE_MATCH ) { info . addToken ( pattern . count , context . rules . getDefault ( ) ) ; } else { info . addToken ( pattern . count , checkRule . token ) ; } lastOffset = pos + pattern . count ; context = new LineContext ( delegateSet , context ) ; } } break ; case EOL_SPAN : if ( ( checkRule . action & EXCLUDE_MATCH ) == EXCLUDE_MATCH ) { info . addToken ( pattern . count , context . rules . getDefault ( ) ) ; info . addToken ( lineLength - ( pos + pattern . count ) , checkRule . token ) ; } else { info . addToken ( lineLength - pos , checkRule . token ) ; } lastOffset = lineLength ; lastKeyword = lineLength ; pos = lineLength ; return false ; case MARK_PREVIOUS : if ( lastKeyword > lastOffset ) { info . addToken ( lastKeyword - lastOffset , context . rules . getDefault ( ) ) ; lastOffset = lastKeyword ; } if ( ( checkRule . action & EXCLUDE_MATCH ) == EXCLUDE_MATCH ) { info . addToken ( pos - lastOffset , checkRule . token ) ; info . addToken ( pattern . count , context . rules . getDefault ( ) ) ; } else { info . addToken ( pos - lastOffset + pattern . count , checkRule . token ) ; } lastOffset = pos + pattern . count ; break ; case MARK_FOLLOWING : context . inRule = checkRule ; if ( ( checkRule . action & EXCLUDE_MATCH ) == EXCLUDE_MATCH ) { info . addToken ( pattern . count , context . rules . getDefault ( ) ) ; lastOffset = pos + pattern . count ; } else { lastOffset = pos ; } break ; default : throw new InternalError ( "Unhandled major action" ) ; } lastKeyword = lastOffset ; pos += ( pattern . count - 1 ) ; return false ; } else if ( ( checkRule . action & SPAN ) == SPAN ) { if ( ( checkRule . action & DELEGATE ) != DELEGATE ) { context . inRule = null ; if ( ( checkRule . action & EXCLUDE_MATCH ) == EXCLUDE_MATCH ) { info . addToken ( pos - lastOffset , checkRule . token ) ; info . addToken ( pattern . count , context . rules . getDefault ( ) ) ; } else { info . addToken ( ( pos + pattern . count ) - lastOffset , checkRule . token ) ; } lastKeyword = lastOffset = pos + pattern . count ; pos += ( pattern . count - 1 ) ; } return false ; } return true ; } private void markKeyword ( Buffer . LineInfo info , Segment line , int start , int end ) { KeywordMap keywords = context . rules . getKeywords ( ) ; int len = end - start ; if ( context . rules . getHighlightDigits ( ) ) { boolean digit = true ; char [ ] array = line . array ; boolean octal = false ; boolean hex = false ; boolean seenSomeDigits = false ; loop : for ( int i = 0 ; i < len ; i ++ ) { char ch = array [ start + i ] ; switch ( ch ) { case '0' : if ( i == 0 ) octal = true ; seenSomeDigits = true ; continue loop ; case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : seenSomeDigits = true ; continue loop ; case 'x' : case 'X' : if ( octal && i == 1 ) { hex = true ; continue loop ; } else break ; case 'd' : case 'D' : if ( hex ) continue loop ; else break ; case 'f' : case 'F' : if ( hex || seenSomeDigits ) continue loop ; else break ; case 'l' : case 'L' : if ( seenSomeDigits ) continue loop ; else break ; case 'e' : case 'E' : if ( seenSomeDigits ) continue loop ; else break ; case 'a' : case 'A' : case 'b' : case 'B' : case 'c' : case 'C' : if ( hex ) continue loop ; else break ; case '.' : case '-' : continue loop ; default : break ; } digit = false ; break loop ; } if ( digit ) { if ( start != lastOffset ) { info . addToken ( start - lastOffset , context . rules . getDefault ( ) ) ; } info . addToken ( len , Token . DIGIT ) ; lastKeyword = lastOffset = end ; return ; } } if ( keywords != null ) { byte id = keywords . lookup ( line , start , len ) ; if ( id != Token . NULL ) { if ( start != lastOffset ) { info . addToken ( start - lastOffset , context . rules . getDefault ( ) ) ; } info . addToken ( len , id ) ; lastKeyword = lastOffset = end ; } } } public static class LineContext { public LineContext parent ; public ParserRule inRule ; public ParserRuleSet rules ; public LineContext ( ParserRule r , ParserRuleSet rs ) { inRule = r ; rules = rs ; } public LineContext ( ParserRuleSet rs , LineContext lc ) { rules = rs ; parent = ( lc == null ? null : ( LineContext ) lc . clone ( ) ) ; } public LineContext ( ParserRule r ) { inRule = r ; } public LineContext ( ) { } public Object clone ( ) { LineContext lc = new LineContext ( ) ; lc . inRule = inRule ; lc . rules = rules ; lc . parent = ( parent == null ) ? null : ( LineContext ) parent . clone ( ) ; return lc ; } } } 	1	['10', '1', '0', '10', '46', '9', '4', '8', '7', '0.951111111', '1441', '0.48', '1', '0', '0.314285714', '0', '0', '140.6', '32', '8.5', '1']
package bsh ; import java . util . Vector ; class BSHTryStatement extends SimpleNode { BSHTryStatement ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { BSHBlock tryBlock = ( ( BSHBlock ) jjtGetChild ( 0 ) ) ; Vector catchParams = new Vector ( ) ; Vector catchBlocks = new Vector ( ) ; int nchild = jjtGetNumChildren ( ) ; Node node = null ; int i = 1 ; while ( ( i < nchild ) && ( ( node = jjtGetChild ( i ++ ) ) instanceof BSHFormalParameter ) ) { catchParams . addElement ( node ) ; catchBlocks . addElement ( jjtGetChild ( i ++ ) ) ; node = null ; } BSHBlock finallyBlock = null ; if ( node != null ) finallyBlock = ( BSHBlock ) node ; TargetError target = null ; Throwable thrown = null ; Object ret = null ; int callstackDepth = callstack . depth ( ) ; try { ret = tryBlock . eval ( callstack , interpreter ) ; } catch ( TargetError e ) { target = e ; String stackInfo = "Bsh Stack: " ; while ( callstack . depth ( ) > callstackDepth ) stackInfo += "\t" + callstack . pop ( ) + "\n" ; } if ( target != null ) thrown = target . getTarget ( ) ; if ( thrown != null ) { int n = catchParams . size ( ) ; for ( i = 0 ; i < n ; i ++ ) { NameSpace namespace = callstack . top ( ) ; BSHFormalParameter fp = ( BSHFormalParameter ) catchParams . elementAt ( i ) ; fp . eval ( namespace ) ; if ( fp . type != null ) try { thrown = ( Throwable ) NameSpace . getAssignableForm ( thrown , fp . type ) ; } catch ( EvalError e ) { continue ; } BSHBlock cb = ( BSHBlock ) ( catchBlocks . elementAt ( i ) ) ; if ( fp . type == BSHFormalParameter . UNTYPED ) namespace . setVariable ( fp . name , thrown ) ; else namespace . setTypedVariable ( fp . name , fp . type , thrown , false ) ; ret = cb . eval ( callstack , interpreter ) ; target = null ; break ; } } if ( finallyBlock != null ) ret = finallyBlock . eval ( callstack , interpreter ) ; if ( target != null ) throw target ; if ( ret instanceof ReturnControl ) return ret ; else return Primitive . VOID ; } } 	0	['2', '2', '0', '12', '22', '1', '1', '11', '1', '2', '185', '0', '0', '0.947368421', '0.625', '1', '2', '91.5', '1', '0.5', '0']
package org . gjt . sp . jedit . search ; import javax . swing . text . BadLocationException ; import javax . swing . text . Segment ; import javax . swing . JOptionPane ; import java . awt . Component ; import org . gjt . sp . jedit . io . VFSManager ; import org . gjt . sp . jedit . msg . SearchSettingsChanged ; import org . gjt . sp . jedit . textarea . * ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class SearchAndReplace { public static void setSearchString ( String search ) { if ( search . equals ( SearchAndReplace . search ) ) return ; SearchAndReplace . search = search ; matcher = null ; EditBus . send ( new SearchSettingsChanged ( null ) ) ; } public static String getSearchString ( ) { return search ; } public static void setReplaceString ( String replace ) { if ( replace . equals ( SearchAndReplace . replace ) ) return ; SearchAndReplace . replace = replace ; matcher = null ; EditBus . send ( new SearchSettingsChanged ( null ) ) ; } public static String getReplaceString ( ) { return replace ; } public static void setIgnoreCase ( boolean ignoreCase ) { if ( ignoreCase == SearchAndReplace . ignoreCase ) return ; SearchAndReplace . ignoreCase = ignoreCase ; matcher = null ; EditBus . send ( new SearchSettingsChanged ( null ) ) ; } public static boolean getIgnoreCase ( ) { return ignoreCase ; } public static void setRegexp ( boolean regexp ) { if ( regexp == SearchAndReplace . regexp ) return ; SearchAndReplace . regexp = regexp ; matcher = null ; EditBus . send ( new SearchSettingsChanged ( null ) ) ; } public static boolean getRegexp ( ) { return regexp ; } public static void setReverseSearch ( boolean reverse ) { if ( reverse == SearchAndReplace . reverse ) return ; SearchAndReplace . reverse = reverse ; matcher = null ; EditBus . send ( new SearchSettingsChanged ( null ) ) ; } public static boolean getReverseSearch ( ) { return reverse ; } public static void setBeanShellReplace ( boolean beanshell ) { if ( beanshell == SearchAndReplace . beanshell ) return ; SearchAndReplace . beanshell = beanshell ; matcher = null ; EditBus . send ( new SearchSettingsChanged ( null ) ) ; } public static boolean getBeanShellReplace ( ) { return beanshell ; } public static void setAutoWrapAround ( boolean wrap ) { if ( wrap == SearchAndReplace . wrap ) return ; SearchAndReplace . wrap = wrap ; EditBus . send ( new SearchSettingsChanged ( null ) ) ; } public static boolean getAutoWrapAround ( ) { return wrap ; } public static void setSearchMatcher ( SearchMatcher matcher ) { SearchAndReplace . matcher = matcher ; EditBus . send ( new SearchSettingsChanged ( null ) ) ; } public static SearchMatcher getSearchMatcher ( ) throws Exception { return getSearchMatcher ( true ) ; } public static SearchMatcher getSearchMatcher ( boolean reverseOK ) throws Exception { reverseOK &= ( fileset instanceof CurrentBufferSet ) ; if ( matcher != null && ( reverseOK || ! reverse ) ) return matcher ; if ( search == null || "" . equals ( search ) ) return null ; String replace = ( SearchAndReplace . replace == null ? "" : SearchAndReplace . replace ) ; String replaceMethod ; if ( beanshell && replace . length ( ) != 0 ) { replaceMethod = BeanShell . cacheBlock ( "replace" , "return (" + replace + ");" , false ) ; } else replaceMethod = null ; if ( regexp ) matcher = new RESearchMatcher ( search , replace , ignoreCase , beanshell , replaceMethod ) ; else { matcher = new BoyerMooreSearchMatcher ( search , replace , ignoreCase , reverse && reverseOK , beanshell , replaceMethod ) ; } return matcher ; } public static void setSearchFileSet ( SearchFileSet fileset ) { SearchAndReplace . fileset = fileset ; EditBus . send ( new SearchSettingsChanged ( null ) ) ; } public static SearchFileSet getSearchFileSet ( ) { return fileset ; } public static boolean hyperSearch ( View view ) { record ( view , "hyperSearch(view)" , false , true ) ; view . getDockableWindowManager ( ) . addDockableWindow ( HyperSearchResults . NAME ) ; final HyperSearchResults results = ( HyperSearchResults ) view . getDockableWindowManager ( ) . getDockableWindow ( HyperSearchResults . NAME ) ; results . searchStarted ( ) ; try { VFSManager . runInWorkThread ( new HyperSearchRequest ( view , getSearchMatcher ( false ) , results ) ) ; return true ; } catch ( Exception e ) { Log . log ( Log . ERROR , SearchAndReplace . class , e ) ; Object [ ] args = { e . getMessage ( ) } ; if ( args [ 0 ] == null ) args [ 0 ] = e . toString ( ) ; GUIUtilities . error ( view , "searcherror" , args ) ; return false ; } } public static boolean find ( View view ) { boolean repeat = false ; Buffer buffer = fileset . getNextBuffer ( view , null ) ; try { SearchMatcher matcher = getSearchMatcher ( true ) ; if ( matcher == null ) { view . getToolkit ( ) . beep ( ) ; return false ; } record ( view , "find(view)" , false , true ) ; view . showWaitCursor ( ) ; loop : for ( ; ; ) { while ( buffer != null ) { if ( ! buffer . isLoaded ( ) ) VFSManager . waitForRequests ( ) ; int start ; if ( view . getBuffer ( ) == buffer && ! repeat ) { JEditTextArea textArea = view . getTextArea ( ) ; Selection s = textArea . getSelectionAtOffset ( textArea . getCaretPosition ( ) ) ; if ( s == null ) start = textArea . getCaretPosition ( ) ; else if ( reverse ) start = s . getStart ( ) ; else start = s . getEnd ( ) ; } else if ( reverse ) start = buffer . getLength ( ) ; else start = 0 ; if ( find ( view , buffer , start ) ) return true ; buffer = fileset . getNextBuffer ( view , buffer ) ; } if ( repeat ) { view . getToolkit ( ) . beep ( ) ; return false ; } if ( BeanShell . isScriptRunning ( ) ) break loop ; boolean restart ; if ( wrap ) { view . getStatus ( ) . setMessageAndClear ( jEdit . getProperty ( "view.status.auto-wrap" ) ) ; restart = true ; } else { Integer [ ] args = { new Integer ( reverse ? 1 : 0 ) } ; int result = GUIUtilities . confirm ( view , "keepsearching" , args , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE ) ; restart = ( result == JOptionPane . YES_OPTION ) ; } if ( restart ) { buffer = fileset . getFirstBuffer ( view ) ; repeat = true ; } else break loop ; } } catch ( Exception e ) { Log . log ( Log . ERROR , SearchAndReplace . class , e ) ; Object [ ] args = { e . getMessage ( ) } ; if ( args [ 0 ] == null ) args [ 0 ] = e . toString ( ) ; GUIUtilities . error ( view , "searcherror" , args ) ; } finally { view . hideWaitCursor ( ) ; } return false ; } public static boolean find ( final View view , final Buffer buffer , final int start ) throws Exception { SearchMatcher matcher = getSearchMatcher ( true ) ; Segment text = new Segment ( ) ; if ( reverse ) buffer . getText ( 0 , start , text ) ; else buffer . getText ( start , buffer . getLength ( ) - start , text ) ; int [ ] match = matcher . nextMatch ( text ) ; if ( match != null ) { fileset . matchFound ( buffer ) ; view . setBuffer ( buffer ) ; JEditTextArea textArea = view . getTextArea ( ) ; int matchStart = ( reverse ? 0 : start ) ; textArea . setSelection ( new Selection . Range ( matchStart + match [ 0 ] , matchStart + match [ 1 ] ) ) ; textArea . moveCaretPosition ( matchStart + match [ 1 ] ) ; return true ; } else return false ; } public static boolean replace ( View view ) { JEditTextArea textArea = view . getTextArea ( ) ; Selection [ ] selection = textArea . getSelection ( ) ; if ( selection . length == 0 ) { view . getToolkit ( ) . beep ( ) ; return false ; } record ( view , "replace(view)" , true , false ) ; Buffer buffer = view . getBuffer ( ) ; try { buffer . beginCompoundEdit ( ) ; int retVal = 0 ; for ( int i = 0 ; i < selection . length ; i ++ ) { Selection s = selection [ i ] ; int start = s . getStart ( ) ; retVal += _replace ( view , buffer , s . getStart ( ) , s . getEnd ( ) ) ; textArea . removeFromSelection ( s ) ; if ( s instanceof Selection . Range ) { textArea . addToSelection ( new Selection . Range ( start , s . getEnd ( ) ) ) ; } else if ( s instanceof Selection . Rect ) { textArea . addToSelection ( new Selection . Rect ( start , s . getEnd ( ) ) ) ; } } if ( retVal == 0 ) { view . getToolkit ( ) . beep ( ) ; return false ; } return true ; } catch ( Exception e ) { Log . log ( Log . ERROR , SearchAndReplace . class , e ) ; Object [ ] args = { e . getMessage ( ) } ; if ( args [ 0 ] == null ) args [ 0 ] = e . toString ( ) ; GUIUtilities . error ( view , "searcherror" , args ) ; } finally { buffer . endCompoundEdit ( ) ; } return false ; } public static boolean replace ( View view , Buffer buffer , int start , int end ) { JEditTextArea textArea = view . getTextArea ( ) ; try { int retVal = 0 ; buffer . beginCompoundEdit ( ) ; retVal += _replace ( view , buffer , start , end ) ; if ( retVal != 0 ) return true ; } catch ( Exception e ) { Log . log ( Log . ERROR , SearchAndReplace . class , e ) ; Object [ ] args = { e . getMessage ( ) } ; if ( args [ 0 ] == null ) args [ 0 ] = e . toString ( ) ; GUIUtilities . error ( view , "searcherror" , args ) ; } finally { buffer . endCompoundEdit ( ) ; } return false ; } public static boolean replaceAll ( View view ) { int fileCount = 0 ; int occurCount = 0 ; record ( view , "replaceAll(view)" , true , true ) ; view . showWaitCursor ( ) ; try { Buffer buffer = fileset . getFirstBuffer ( view ) ; do { if ( buffer . isPerformingIO ( ) ) VFSManager . waitForRequests ( ) ; try { buffer . beginCompoundEdit ( ) ; int retVal = _replace ( view , buffer , 0 , buffer . getLength ( ) ) ; if ( retVal != 0 ) { fileCount ++ ; occurCount += retVal ; fileset . matchFound ( buffer ) ; } } finally { buffer . endCompoundEdit ( ) ; } } while ( ( buffer = fileset . getNextBuffer ( view , buffer ) ) != null ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , SearchAndReplace . class , e ) ; Object [ ] args = { e . getMessage ( ) } ; if ( args [ 0 ] == null ) args [ 0 ] = e . toString ( ) ; GUIUtilities . error ( view , "searcherror" , args ) ; } finally { view . hideWaitCursor ( ) ; } if ( ! BeanShell . isScriptRunning ( ) ) { Object [ ] args = { new Integer ( occurCount ) , new Integer ( fileCount ) } ; view . getStatus ( ) . setMessageAndClear ( jEdit . getProperty ( "view.status.replace-all" , args ) ) ; } return ( fileCount != 0 ) ; } public static void load ( ) { search = jEdit . getProperty ( "search.find.value" ) ; replace = jEdit . getProperty ( "search.replace.value" ) ; ignoreCase = jEdit . getBooleanProperty ( "search.ignoreCase.toggle" ) ; regexp = jEdit . getBooleanProperty ( "search.regexp.toggle" ) ; reverse = jEdit . getBooleanProperty ( "search.reverse.toggle" ) ; beanshell = jEdit . getBooleanProperty ( "search.beanshell.toggle" ) ; wrap = jEdit . getBooleanProperty ( "search.wrap.toggle" ) ; String filesetCode = jEdit . getProperty ( "search.fileset.value" ) ; if ( filesetCode != null ) { fileset = ( SearchFileSet ) BeanShell . eval ( null , filesetCode , true ) ; } if ( fileset == null ) fileset = new CurrentBufferSet ( ) ; } public static void save ( ) { jEdit . setProperty ( "search.find.value" , search ) ; jEdit . setProperty ( "search.replace.value" , replace ) ; jEdit . setBooleanProperty ( "search.ignoreCase.toggle" , ignoreCase ) ; jEdit . setBooleanProperty ( "search.regexp.toggle" , regexp ) ; jEdit . setBooleanProperty ( "search.reverse.toggle" , reverse ) ; jEdit . setBooleanProperty ( "search.beanshell.toggle" , beanshell ) ; jEdit . setBooleanProperty ( "search.wrap.toggle" , wrap ) ; String code = fileset . getCode ( ) ; if ( code != null ) jEdit . setProperty ( "search.fileset.value" , code ) ; else jEdit . unsetProperty ( "search.fileset.value" ) ; } private static String search ; private static String replace ; private static boolean regexp ; private static boolean ignoreCase ; private static boolean reverse ; private static boolean beanshell ; private static boolean wrap ; private static SearchMatcher matcher ; private static SearchFileSet fileset ; private static void record ( View view , String action , boolean replaceAction , boolean recordFileSet ) { Macros . Recorder recorder = view . getMacroRecorder ( ) ; if ( recorder != null ) { recorder . record ( "SearchAndReplace.setSearchString(\"" + MiscUtilities . charsToEscapes ( search ) + "\");" ) ; if ( replaceAction ) { recorder . record ( "SearchAndReplace.setReplaceString(\"" + MiscUtilities . charsToEscapes ( replace ) + "\");" ) ; recorder . record ( "SearchAndReplace.setBeanShellReplace(" + beanshell + ");" ) ; } else { recorder . record ( "SearchAndReplace.setAutoWrapAround(" + wrap + ");" ) ; recorder . record ( "SearchAndReplace.setReverseSearch(" + reverse + ");" ) ; } recorder . record ( "SearchAndReplace.setIgnoreCase(" + ignoreCase + ");" ) ; recorder . record ( "SearchAndReplace.setRegexp(" + regexp + ");" ) ; if ( recordFileSet ) { recorder . record ( "SearchAndReplace.setSearchFileSet(" + fileset . getCode ( ) + ");" ) ; } recorder . record ( "SearchAndReplace." + action + ";" ) ; } } private static int _replace ( View view , Buffer buffer , int start , int end ) throws Exception { if ( ! buffer . isEditable ( ) ) return 0 ; SearchMatcher matcher = getSearchMatcher ( false ) ; if ( matcher == null ) return 0 ; int occurCount = 0 ; Segment text = new Segment ( ) ; int offset = start ; loop : for ( ; ; ) { buffer . getText ( offset , end - offset , text ) ; int [ ] occur = matcher . nextMatch ( text ) ; if ( occur == null ) break loop ; int _start = occur [ 0 ] ; int _length = occur [ 1 ] - occur [ 0 ] ; String found = new String ( text . array , text . offset + _start , _length ) ; String subst = matcher . substitute ( found ) ; if ( subst != null ) { buffer . remove ( offset + _start , _length ) ; buffer . insertString ( offset + _start , subst , null ) ; occurCount ++ ; offset += _start + subst . length ( ) ; end += ( subst . length ( ) - found . length ( ) ) ; } else offset += _start + _length ; } return occurCount ; } } 	1	['31', '1', '0', '34', '108', '197', '9', '27', '28', '0.64', '1228', '1', '2', '0', '0.112903226', '0', '0', '38.29032258', '23', '3.129', '9']
package bsh ; class BSHWhileStatement extends SimpleNode implements ParserConstants { public boolean isDoStatement ; BSHWhileStatement ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { int numChild = jjtGetNumChildren ( ) ; SimpleNode condExp , body = null ; if ( isDoStatement ) { condExp = ( SimpleNode ) jjtGetChild ( 1 ) ; body = ( SimpleNode ) jjtGetChild ( 0 ) ; } else { condExp = ( SimpleNode ) jjtGetChild ( 0 ) ; if ( numChild > 1 ) body = ( SimpleNode ) jjtGetChild ( 1 ) ; } boolean doOnceFlag = isDoStatement ; while ( doOnceFlag || BSHIfStatement . evaluateCondition ( condExp , callstack , interpreter ) ) { if ( body == null ) continue ; Object ret = body . eval ( callstack , interpreter ) ; boolean breakout = false ; if ( ret instanceof ReturnControl ) { switch ( ( ( ReturnControl ) ret ) . kind ) { case RETURN : return ret ; case CONTINUE : continue ; case BREAK : breakout = true ; break ; } } if ( breakout ) break ; doOnceFlag = false ; } return Primitive . VOID ; } } 	0	['2', '2', '0', '10', '7', '1', '1', '9', '1', '1', '79', '0', '0', '0.947368421', '0.625', '1', '1', '38', '1', '0.5', '0']
package org . gjt . sp . jedit . options ; import javax . swing . border . EmptyBorder ; import javax . swing . event . * ; import javax . swing . table . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . util . Vector ; import org . gjt . sp . jedit . syntax . SyntaxStyle ; import org . gjt . sp . jedit . gui . EnhancedDialog ; import org . gjt . sp . jedit . * ; public class StyleOptionPane extends AbstractOptionPane { public static final EmptyBorder noFocusBorder = new EmptyBorder ( 1 , 1 , 1 , 1 ) ; public StyleOptionPane ( ) { super ( "style" ) ; } protected void _init ( ) { setLayout ( new BorderLayout ( ) ) ; add ( BorderLayout . CENTER , createStyleTableScroller ( ) ) ; } protected void _save ( ) { styleModel . save ( ) ; } private StyleTableModel styleModel ; private JTable styleTable ; private JScrollPane createStyleTableScroller ( ) { styleModel = createStyleTableModel ( ) ; styleTable = new JTable ( styleModel ) ; styleTable . setRowSelectionAllowed ( false ) ; styleTable . setColumnSelectionAllowed ( false ) ; styleTable . setCellSelectionEnabled ( false ) ; styleTable . getTableHeader ( ) . setReorderingAllowed ( false ) ; styleTable . addMouseListener ( new MouseHandler ( ) ) ; TableColumnModel tcm = styleTable . getColumnModel ( ) ; TableColumn styleColumn = tcm . getColumn ( 1 ) ; styleColumn . setCellRenderer ( new StyleTableModel . StyleRenderer ( ) ) ; Dimension d = styleTable . getPreferredSize ( ) ; d . height = Math . min ( d . height , 100 ) ; JScrollPane scroller = new JScrollPane ( styleTable ) ; scroller . setPreferredSize ( d ) ; return scroller ; } private StyleTableModel createStyleTableModel ( ) { return new StyleTableModel ( ) ; } class MouseHandler extends MouseAdapter { public void mouseClicked ( MouseEvent evt ) { int row = styleTable . rowAtPoint ( evt . getPoint ( ) ) ; if ( row == - 1 ) return ; SyntaxStyle style = new StyleEditor ( StyleOptionPane . this , ( SyntaxStyle ) styleModel . getValueAt ( row , 1 ) ) . getStyle ( ) ; if ( style != null ) styleModel . setValueAt ( style , row , 1 ) ; } } } class StyleTableModel extends AbstractTableModel { private Vector styleChoices ; StyleTableModel ( ) { styleChoices = new Vector ( 13 ) ; addStyleChoice ( "options.style.comment1Style" , "view.style.comment1" ) ; addStyleChoice ( "options.style.comment2Style" , "view.style.comment2" ) ; addStyleChoice ( "options.style.literal1Style" , "view.style.literal1" ) ; addStyleChoice ( "options.style.literal2Style" , "view.style.literal2" ) ; addStyleChoice ( "options.style.labelStyle" , "view.style.label" ) ; addStyleChoice ( "options.style.keyword1Style" , "view.style.keyword1" ) ; addStyleChoice ( "options.style.keyword2Style" , "view.style.keyword2" ) ; addStyleChoice ( "options.style.keyword3Style" , "view.style.keyword3" ) ; addStyleChoice ( "options.style.functionStyle" , "view.style.function" ) ; addStyleChoice ( "options.style.markupStyle" , "view.style.markup" ) ; addStyleChoice ( "options.style.operatorStyle" , "view.style.operator" ) ; addStyleChoice ( "options.style.digitStyle" , "view.style.digit" ) ; addStyleChoice ( "options.style.invalidStyle" , "view.style.invalid" ) ; } public int getColumnCount ( ) { return 2 ; } public int getRowCount ( ) { return styleChoices . size ( ) ; } public Object getValueAt ( int row , int col ) { StyleChoice ch = ( StyleChoice ) styleChoices . elementAt ( row ) ; switch ( col ) { case 0 : return ch . label ; case 1 : return ch . style ; default : return null ; } } public void setValueAt ( Object value , int row , int col ) { StyleChoice ch = ( StyleChoice ) styleChoices . elementAt ( row ) ; if ( col == 1 ) ch . style = ( SyntaxStyle ) value ; fireTableRowsUpdated ( row , row ) ; } public String getColumnName ( int index ) { switch ( index ) { case 0 : return jEdit . getProperty ( "options.style.object" ) ; case 1 : return jEdit . getProperty ( "options.style.style" ) ; default : return null ; } } public void save ( ) { for ( int i = 0 ; i < styleChoices . size ( ) ; i ++ ) { StyleChoice ch = ( StyleChoice ) styleChoices . elementAt ( i ) ; jEdit . setProperty ( ch . property , GUIUtilities . getStyleString ( ch . style ) ) ; } } private void addStyleChoice ( String label , String property ) { styleChoices . addElement ( new StyleChoice ( jEdit . getProperty ( label ) , property , GUIUtilities . parseStyle ( jEdit . getProperty ( property ) , "Dialog" , 12 ) ) ) ; } static class StyleChoice { String label ; String property ; SyntaxStyle style ; StyleChoice ( String label , String property , SyntaxStyle style ) { this . label = label ; this . property = property ; this . style = style ; } } static class StyleRenderer extends JLabel implements TableCellRenderer { public StyleRenderer ( ) { setOpaque ( true ) ; setBorder ( StyleOptionPane . noFocusBorder ) ; setText ( "Hello World" ) ; } public Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean cellHasFocus , int row , int col ) { if ( value != null ) { SyntaxStyle style = ( SyntaxStyle ) value ; setForeground ( style . getForegroundColor ( ) ) ; if ( style . getBackgroundColor ( ) != null ) setBackground ( style . getBackgroundColor ( ) ) ; else { setBackground ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.bgColor" ) ) ) ; } setFont ( style . getFont ( ) ) ; } setBorder ( ( cellHasFocus ) ? UIManager . getBorder ( "Table.focusCellHighlightBorder" ) : StyleOptionPane . noFocusBorder ) ; return this ; } } } class StyleEditor extends EnhancedDialog implements ActionListener { StyleEditor ( Component comp , SyntaxStyle style ) { super ( JOptionPane . getFrameForComponent ( comp ) , jEdit . getProperty ( "style-editor.title" ) , true ) ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; JPanel panel = new JPanel ( ) ; panel . setLayout ( new BoxLayout ( panel , BoxLayout . X_AXIS ) ) ; panel . setBorder ( new EmptyBorder ( 0 , 0 , 12 , 0 ) ) ; panel . add ( italics = new JCheckBox ( jEdit . getProperty ( "style-editor.italics" ) ) ) ; italics . setSelected ( style . getFont ( ) . isItalic ( ) ) ; panel . add ( Box . createHorizontalStrut ( 2 ) ) ; panel . add ( bold = new JCheckBox ( jEdit . getProperty ( "style-editor.bold" ) ) ) ; bold . setSelected ( style . getFont ( ) . isBold ( ) ) ; panel . add ( Box . createHorizontalStrut ( 12 ) ) ; panel . add ( new JLabel ( jEdit . getProperty ( "style-editor.fgColor" ) ) ) ; panel . add ( Box . createHorizontalStrut ( 12 ) ) ; panel . add ( fgColor = new JButton ( "    " ) ) ; fgColor . setBackground ( style . getForegroundColor ( ) ) ; fgColor . setRequestFocusEnabled ( false ) ; fgColor . addActionListener ( this ) ; fgColor . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; panel . add ( Box . createHorizontalStrut ( 12 ) ) ; panel . add ( new JLabel ( jEdit . getProperty ( "style-editor.bgColor" ) ) ) ; panel . add ( Box . createHorizontalStrut ( 12 ) ) ; panel . add ( bgColor = new JButton ( "    " ) ) ; if ( style . getBackgroundColor ( ) == null ) bgColor . setBackground ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.bgColor" ) ) ) ; else bgColor . setBackground ( style . getBackgroundColor ( ) ) ; bgColor . setRequestFocusEnabled ( false ) ; bgColor . addActionListener ( this ) ; bgColor . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; content . add ( BorderLayout . CENTER , panel ) ; Box box = new Box ( BoxLayout . X_AXIS ) ; box . add ( Box . createGlue ( ) ) ; box . add ( ok = new JButton ( jEdit . getProperty ( "common.ok" ) ) ) ; getRootPane ( ) . setDefaultButton ( ok ) ; ok . addActionListener ( this ) ; box . add ( Box . createHorizontalStrut ( 6 ) ) ; box . add ( cancel = new JButton ( jEdit . getProperty ( "common.cancel" ) ) ) ; cancel . addActionListener ( this ) ; box . add ( Box . createGlue ( ) ) ; content . add ( BorderLayout . SOUTH , box ) ; Dimension screen = getToolkit ( ) . getScreenSize ( ) ; pack ( ) ; setLocationRelativeTo ( JOptionPane . getFrameForComponent ( comp ) ) ; show ( ) ; } public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == ok ) ok ( ) ; else if ( source == cancel ) cancel ( ) ; else if ( source == fgColor || source == bgColor ) { JButton b = ( JButton ) source ; Color c = JColorChooser . showDialog ( this , jEdit . getProperty ( "colorChooser.title" ) , b . getBackground ( ) ) ; if ( c != null ) b . setBackground ( c ) ; } } public void ok ( ) { okClicked = true ; dispose ( ) ; } public void cancel ( ) { dispose ( ) ; } public SyntaxStyle getStyle ( ) { if ( ! okClicked ) return null ; Color background = bgColor . getBackground ( ) ; if ( background . equals ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.bgColor" ) ) ) ) background = null ; return new SyntaxStyle ( fgColor . getBackground ( ) , background , new Font ( "Dialog" , ( italics . isSelected ( ) ? Font . ITALIC : 0 ) | ( bold . isSelected ( ) ? Font . BOLD : 0 ) , 12 ) ) ; } private JCheckBox italics ; private JCheckBox bold ; private JButton fgColor ; private JButton bgColor ; private JButton ok ; private JButton cancel ; private boolean okClicked ; } 	1	['8', '6', '0', '6', '31', '20', '4', '4', '1', '0.761904762', '123', '0.666666667', '1', '0.991017964', '0.5', '4', '12', '14', '2', '0.875', '1']
package org . gjt . sp . jedit . proto . jeditresource ; import java . io . IOException ; import java . net . * ; public class Handler extends URLStreamHandler { public URLConnection openConnection ( URL url ) throws IOException { PluginResURLConnection c = new PluginResURLConnection ( url ) ; c . connect ( ) ; return c ; } } 	0	['2', '2', '0', '1', '5', '1', '0', '1', '2', '2', '14', '0', '0', '0.923076923', '0.75', '0', '0', '6', '1', '0.5', '0']
package org . gjt . sp . jedit . pluginmgr ; import com . microstar . xml . * ; import java . io . * ; import java . util . Stack ; import org . gjt . sp . util . Log ; class PluginListHandler extends HandlerBase { PluginListHandler ( PluginList pluginList , String path ) { this . pluginList = pluginList ; this . path = path ; stateStack = new Stack ( ) ; } public Object resolveEntity ( String publicId , String systemId ) { if ( "plugins.dtd" . equals ( systemId ) ) { try { return new BufferedReader ( new InputStreamReader ( getClass ( ) . getResourceAsStream ( "/org/gjt/sp/jedit/pluginmgr/plugins.dtd" ) ) ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , this , "Error while opening" + " plugins.dtd:" ) ; Log . log ( Log . ERROR , this , e ) ; } } return null ; } public void attribute ( String aname , String value , boolean isSpecified ) { aname = ( aname == null ) ? null : aname . intern ( ) ; value = ( value == null ) ? null : value . intern ( ) ; if ( aname == "NAME" ) name = value ; else if ( aname == "JAR" ) jar = value ; else if ( aname == "VERSION" ) version = value ; else if ( aname == "DATE" ) date = value ; else if ( aname == "OBSOLETE" ) obsolete = ( "TRUE" . equals ( value ) ) ; else if ( aname == "WHAT" ) depWhat = value ; else if ( aname == "FROM" ) depFrom = value ; else if ( aname == "TO" ) depTo = value ; else if ( aname == "PLUGIN" ) depPlugin = value ; } public void doctypeDecl ( String name , String publicId , String systemId ) throws Exception { if ( "PLUGINS" . equals ( name ) ) return ; Log . log ( Log . ERROR , this , path + ": DOCTYPE must be PLUGINS" ) ; } public void charData ( char [ ] c , int off , int len ) { String tag = peekElement ( ) ; String text = new String ( c , off , len ) ; if ( tag == "DESCRIPTION" ) { description = text ; } else if ( tag == "PLUGIN_SET_ENTRY" ) pluginSetEntry = text ; else if ( tag == "AUTHOR" ) { if ( author != null && author . length ( ) != 0 ) author = author + ", " + text ; else author = text ; } else if ( tag == "DOWNLOAD" ) download = text ; else if ( tag == "DOWNLOAD_SOURCE" ) downloadSource = text ; } public void startElement ( String tag ) { tag = pushElement ( tag ) ; if ( tag == "PLUGIN_SET" ) { description = null ; pluginSet = new PluginList . PluginSet ( ) ; } else if ( tag == "PLUGIN" ) { description = null ; author = null ; branch = null ; plugin = new PluginList . Plugin ( ) ; } else if ( tag == "BRANCH" ) { download = null ; branch = new PluginList . Branch ( ) ; } } public void endElement ( String tag ) { if ( tag == null ) return ; else tag = tag . intern ( ) ; popElement ( ) ; if ( tag == "PLUGIN_SET" ) { pluginList . addPluginSet ( pluginSet ) ; pluginSet = null ; pluginSetEntry = null ; } else if ( tag == "PLUGIN_SET_ENTRY" ) { pluginSet . plugins . addElement ( pluginSetEntry ) ; pluginSetEntry = null ; } else if ( tag == "PLUGIN" ) { plugin . jar = jar ; plugin . name = name ; plugin . author = author ; plugin . description = description ; pluginList . addPlugin ( plugin ) ; jar = null ; name = null ; author = null ; } else if ( tag == "BRANCH" ) { branch . version = version ; branch . date = date ; branch . download = download ; branch . downloadSource = downloadSource ; branch . obsolete = obsolete ; plugin . branches . addElement ( branch ) ; version = null ; download = null ; obsolete = false ; } else if ( tag == "DEPEND" ) { PluginList . Dependency dep = new PluginList . Dependency ( depWhat , depFrom , depTo , depPlugin ) ; branch . deps . addElement ( dep ) ; depWhat = null ; depFrom = null ; depTo = null ; depPlugin = null ; } } public void startDocument ( ) { try { pushElement ( null ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public void endDocument ( ) { pluginList . finished ( ) ; } private String path ; private PluginList pluginList ; private PluginList . PluginSet pluginSet ; private String pluginSetEntry ; private PluginList . Plugin plugin ; private String jar ; private String author ; private PluginList . Branch branch ; private boolean obsolete ; private String version ; private String date ; private String download ; private String downloadSource ; private String depWhat ; private String depFrom ; private String depTo ; private String depPlugin ; private String name ; private String description ; private Stack stateStack ; private String pushElement ( String name ) { name = ( name == null ) ? null : name . intern ( ) ; stateStack . push ( name ) ; return name ; } private String peekElement ( ) { return ( String ) stateStack . peek ( ) ; } private String popElement ( ) { return ( String ) stateStack . pop ( ) ; } } 	1	['12', '2', '0', '7', '38', '38', '1', '7', '8', '0.863636364', '470', '1', '4', '0.541666667', '0.319444444', '1', '3', '36.5', '12', '3.3333', '1']
package org . gjt . sp . jedit . textarea ; import javax . swing . text . TabExpander ; import java . awt . * ; import org . gjt . sp . util . Log ; public abstract class TextRenderer { static final String JAVA2D_RENDER_CLASS = "org.gjt.sp.jedit.textarea.TextRenderer2D" ; public static TextRenderer createTextRenderer ( ) { if ( java2d ) { try { ClassLoader loader = TextRenderer . class . getClassLoader ( ) ; Class clazz ; if ( loader == null ) clazz = Class . forName ( JAVA2D_RENDER_CLASS ) ; else clazz = loader . loadClass ( JAVA2D_RENDER_CLASS ) ; return ( TextRenderer ) clazz . newInstance ( ) ; } catch ( Exception e ) { throw new NoClassDefFoundError ( JAVA2D_RENDER_CLASS ) ; } } else return new TextRendererAWT ( ) ; } public static TextRenderer createPrintTextRenderer ( ) { return new TextRendererAWT ( ) ; } public void setupGraphics ( Graphics g ) { } public void configure ( boolean antiAlias , boolean fracFontMetrics ) { } public float drawChars ( char [ ] text , int off , int len , Graphics g , float x , float y , TabExpander e , Color foreground , Color tokenBackground , Color componentBackground ) { if ( tokenBackground != null ) { float width = charsWidth ( text , off , len , g . getFont ( ) , x , e ) ; FontMetrics fm = g . getFontMetrics ( ) ; float height = fm . getHeight ( ) ; float descent = fm . getDescent ( ) ; float leading = fm . getLeading ( ) ; g . setXORMode ( componentBackground ) ; g . setColor ( tokenBackground ) ; g . fillRect ( ( int ) x , ( int ) ( y - height + descent + leading ) , ( int ) width , ( int ) height ) ; g . setPaintMode ( ) ; } g . setColor ( foreground ) ; int flushLen = 0 ; int flushIndex = off ; int end = off + len ; for ( int i = off ; i < end ; i ++ ) { if ( text [ i ] == '\t' ) { if ( flushLen > 0 ) { x += _drawChars ( text , flushIndex , flushLen , g , x , y ) ; flushLen = 0 ; } flushIndex = i + 1 ; x = e . nextTabStop ( x , i - off ) ; } else flushLen ++ ; } if ( flushLen > 0 ) x += _drawChars ( text , flushIndex , flushLen , g , x , y ) ; return x ; } public float charsWidth ( char [ ] text , int off , int len , Font font , float x , TabExpander e ) { float newX = x ; int flushLen = 0 ; int flushIndex = off ; int end = off + len ; for ( int i = off ; i < end ; i ++ ) { if ( text [ i ] == '\t' ) { if ( flushLen > 0 ) { newX += _getWidth ( text , flushIndex , flushLen , font ) ; flushLen = 0 ; } flushIndex = i + 1 ; newX = e . nextTabStop ( newX , i - off ) ; } else flushLen ++ ; } if ( flushLen > 0 ) newX += _getWidth ( text , flushIndex , flushLen , font ) ; return newX - x ; } public int xToOffset ( char [ ] text , int off , int len , Font font , float x , TabExpander e , boolean round , float [ ] widthArray ) { int flushLen = 0 ; int flushIndex = off ; int end = off + len ; float width = widthArray [ 0 ] ; for ( int i = off ; i < end ; i ++ ) { if ( text [ i ] == '\t' ) { if ( flushLen > 0 ) { float newWidth = _getWidth ( text , flushIndex , flushLen , font ) ; if ( x <= width + newWidth ) { return _xToOffset ( text , flushIndex , flushLen , font , x - width , round ) + flushIndex ; } else width += newWidth ; flushLen = 0 ; } flushIndex = i + 1 ; float newWidth = e . nextTabStop ( width , i - off ) - width ; if ( x <= width + newWidth ) { if ( round && ( x - width ) < ( width + newWidth - x ) ) return i ; else return i + 1 ; } else width += newWidth ; } else flushLen ++ ; } if ( flushLen > 0 ) { float newWidth = _getWidth ( text , flushIndex , flushLen , font ) ; if ( x <= width + newWidth ) { return _xToOffset ( text , flushIndex , flushLen , font , x - width , round ) + flushIndex ; } else width += newWidth ; } widthArray [ 0 ] = width ; return - 1 ; } abstract float _drawChars ( char [ ] text , int start , int len , Graphics g , float x , float y ) ; abstract float _getWidth ( char [ ] text , int start , int len , Font font ) ; abstract int _xToOffset ( char [ ] text , int start , int len , Font font , float x , boolean round ) ; static boolean java2d ; static { try { ClassLoader loader = TextRenderer . class . getClassLoader ( ) ; if ( loader == null ) Class . forName ( "java.awt.Graphics2D" ) ; else loader . loadClass ( "java.awt.Graphics2D" ) ; Log . log ( Log . DEBUG , TextRenderer . class , "Java2D detected; will use new text rendering code" ) ; java2d = true ; } catch ( ClassNotFoundException cnf ) { Log . log ( Log . DEBUG , TextRenderer . class , "Java2D not detected; will use old text rendering code" ) ; java2d = false ; } } } 	0	['13', '1', '2', '6', '32', '76', '5', '2', '8', '0.972222222', '439', '0.333333333', '0', '0', '0.318181818', '0', '0', '32.53846154', '10', '2.4615', '0']
package org . gjt . sp . jedit ; import java . awt . event . ActionEvent ; import java . awt . * ; public class BeanShellAction extends EditAction { public BeanShellAction ( String name , boolean plugin , String code , String isSelected , boolean noRepeat , boolean noRecord ) { super ( name , plugin ) ; this . code = code ; this . isSelected = isSelected ; this . noRepeat = noRepeat ; this . noRecord = noRecord ; sanitizedName = name . replace ( '.' , '_' ) . replace ( '-' , '_' ) ; } public void invoke ( View view ) { if ( cachedCode == null ) { String cachedCodeName = "action_" + sanitizedName ; cachedCode = BeanShell . cacheBlock ( cachedCodeName , code , true ) ; } BeanShell . runCachedBlock ( cachedCode , view , null ) ; } public boolean isToggle ( ) { return isSelected != null ; } public boolean isSelected ( View view ) { if ( isSelected == null ) return false ; if ( cachedIsSelected == null ) { String cachedIsSelectedName = "selected_" + sanitizedName ; cachedIsSelected = BeanShell . cacheBlock ( cachedIsSelectedName , isSelected , true ) ; } return Boolean . TRUE . equals ( BeanShell . runCachedBlock ( cachedIsSelected , view , null ) ) ; } public boolean noRepeat ( ) { return noRepeat ; } public boolean noRecord ( ) { return noRecord ; } public String getCode ( ) { return code . trim ( ) ; } private boolean noRepeat ; private boolean noRecord ; private String code ; private String isSelected ; private String cachedCode ; private String cachedIsSelected ; private String sanitizedName ; } 	1	['7', '2', '0', '5', '16', '3', '1', '4', '7', '0.80952381', '115', '1', '0', '0.7', '0.392857143', '1', '1', '14.42857143', '3', '1.4286', '1']
package org . gjt . sp . jedit . browser ; import java . util . EventListener ; import org . gjt . sp . jedit . io . VFS ; public interface BrowserListener extends EventListener { void filesSelected ( VFSBrowser browser , VFS . DirectoryEntry [ ] files ) ; void filesActivated ( VFSBrowser browser , VFS . DirectoryEntry [ ] files ) ; } 	0	['2', '1', '0', '4', '2', '1', '3', '2', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . gjt . sp . jedit ; import javax . swing . border . EmptyBorder ; import javax . swing . event . * ; import javax . swing . text . * ; import javax . swing . * ; import java . awt . * ; import java . awt . event . * ; import java . util . * ; import org . gjt . sp . jedit . msg . * ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . search . SearchBar ; import org . gjt . sp . jedit . textarea . * ; import org . gjt . sp . util . Log ; public class View extends JFrame implements EBComponent { public DockableWindowManager getDockableWindowManager ( ) { return dockableWindowManager ; } public void quickIncrementalSearch ( ) { if ( searchBar == null ) { getToolkit ( ) . beep ( ) ; return ; } String text = getTextArea ( ) . getSelectedText ( ) ; if ( text != null && text . indexOf ( '\n' ) != - 1 ) text = null ; searchBar . setHyperSearch ( false ) ; searchBar . getField ( ) . setText ( text ) ; searchBar . getField ( ) . selectAll ( ) ; searchBar . getField ( ) . requestFocus ( ) ; } public void quickHyperSearch ( ) { if ( searchBar == null ) { getToolkit ( ) . beep ( ) ; return ; } String text = getTextArea ( ) . getSelectedText ( ) ; if ( text != null && text . indexOf ( '\n' ) != - 1 ) text = null ; searchBar . setHyperSearch ( true ) ; searchBar . getField ( ) . setText ( text ) ; searchBar . getField ( ) . selectAll ( ) ; searchBar . getField ( ) . requestFocus ( ) ; } public final SearchBar getSearchBar ( ) { return searchBar ; } public KeyListener getKeyEventInterceptor ( ) { return keyEventInterceptor ; } public void setKeyEventInterceptor ( KeyListener listener ) { this . keyEventInterceptor = listener ; } public InputHandler getInputHandler ( ) { return inputHandler ; } public void setInputHandler ( InputHandler inputHandler ) { this . inputHandler = inputHandler ; } public Macros . Recorder getMacroRecorder ( ) { return recorder ; } public void setMacroRecorder ( Macros . Recorder recorder ) { this . recorder = recorder ; } public StatusBar getStatus ( ) { return status ; } public void splitHorizontally ( ) { split ( JSplitPane . VERTICAL_SPLIT ) ; } public void splitVertically ( ) { split ( JSplitPane . HORIZONTAL_SPLIT ) ; } public void split ( int orientation ) { editPane . saveCaretInfo ( ) ; EditPane oldEditPane = editPane ; setEditPane ( createEditPane ( oldEditPane . getBuffer ( ) ) ) ; editPane . loadCaretInfo ( ) ; JComponent oldParent = ( JComponent ) oldEditPane . getParent ( ) ; if ( oldParent instanceof JSplitPane ) { JSplitPane oldSplitPane = ( JSplitPane ) oldParent ; int dividerPos = oldSplitPane . getDividerLocation ( ) ; Component left = oldSplitPane . getLeftComponent ( ) ; final JSplitPane newSplitPane = new JSplitPane ( orientation , oldEditPane , editPane ) ; newSplitPane . setBorder ( null ) ; if ( left == oldEditPane ) oldSplitPane . setLeftComponent ( newSplitPane ) ; else oldSplitPane . setRightComponent ( newSplitPane ) ; oldSplitPane . setDividerLocation ( dividerPos ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { newSplitPane . setDividerLocation ( 0.5 ) ; editPane . focusOnTextArea ( ) ; } } ) ; } else { JSplitPane newSplitPane = splitPane = new JSplitPane ( orientation , oldEditPane , editPane ) ; newSplitPane . setBorder ( null ) ; oldParent . add ( splitPane ) ; oldParent . revalidate ( ) ; Dimension size ; if ( oldParent instanceof JSplitPane ) size = oldParent . getSize ( ) ; else size = oldEditPane . getSize ( ) ; newSplitPane . setDividerLocation ( ( ( orientation == JSplitPane . VERTICAL_SPLIT ) ? size . height : size . width ) / 2 ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { editPane . focusOnTextArea ( ) ; } } ) ; } } public void unsplit ( ) { if ( splitPane != null ) { EditPane [ ] editPanes = getEditPanes ( ) ; for ( int i = 0 ; i < editPanes . length ; i ++ ) { EditPane _editPane = editPanes [ i ] ; if ( editPane != _editPane ) _editPane . close ( ) ; } JComponent parent = ( JComponent ) splitPane . getParent ( ) ; parent . remove ( splitPane ) ; parent . add ( editPane ) ; parent . revalidate ( ) ; splitPane = null ; updateTitle ( ) ; } SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { editPane . focusOnTextArea ( ) ; } } ) ; } public void nextTextArea ( ) { EditPane [ ] editPanes = getEditPanes ( ) ; for ( int i = 0 ; i < editPanes . length ; i ++ ) { if ( editPane == editPanes [ i ] ) { if ( i == editPanes . length - 1 ) editPanes [ 0 ] . focusOnTextArea ( ) ; else editPanes [ i + 1 ] . focusOnTextArea ( ) ; break ; } } } public void prevTextArea ( ) { EditPane [ ] editPanes = getEditPanes ( ) ; for ( int i = 0 ; i < editPanes . length ; i ++ ) { if ( editPane == editPanes [ i ] ) { if ( i == 0 ) editPanes [ editPanes . length - 1 ] . focusOnTextArea ( ) ; else editPanes [ i - 1 ] . focusOnTextArea ( ) ; break ; } } } public JSplitPane getSplitPane ( ) { return splitPane ; } public Buffer getBuffer ( ) { return editPane . getBuffer ( ) ; } public void setBuffer ( Buffer buffer ) { editPane . setBuffer ( buffer ) ; } public JEditTextArea getTextArea ( ) { return editPane . getTextArea ( ) ; } public EditPane getEditPane ( ) { return editPane ; } public EditPane [ ] getEditPanes ( ) { if ( splitPane == null ) { EditPane [ ] ep = { editPane } ; return ep ; } else { Vector vec = new Vector ( ) ; getEditPanes ( vec , splitPane ) ; EditPane [ ] ep = new EditPane [ vec . size ( ) ] ; vec . copyInto ( ep ) ; return ep ; } } public String getSplitConfig ( ) { StringBuffer splitConfig = new StringBuffer ( ) ; splitConfig . append ( getBuffer ( ) . getPath ( ) ) ; return splitConfig . toString ( ) ; } public void updateGutterBorders ( ) { EditPane [ ] editPanes = getEditPanes ( ) ; for ( int i = 0 ; i < editPanes . length ; i ++ ) editPanes [ i ] . getTextArea ( ) . getGutter ( ) . updateBorder ( ) ; } public void addToolBar ( Component toolBar ) { toolBars . add ( toolBar ) ; getRootPane ( ) . revalidate ( ) ; } public void removeToolBar ( Component toolBar ) { toolBars . remove ( toolBar ) ; getRootPane ( ) . revalidate ( ) ; } public boolean isClosed ( ) { return closed ; } public synchronized void showWaitCursor ( ) { if ( waitCount ++ == 0 ) { Cursor cursor = Cursor . getPredefinedCursor ( Cursor . WAIT_CURSOR ) ; setCursor ( cursor ) ; EditPane [ ] editPanes = getEditPanes ( ) ; for ( int i = 0 ; i < editPanes . length ; i ++ ) { EditPane editPane = editPanes [ i ] ; editPane . getTextArea ( ) . getPainter ( ) . setCursor ( cursor ) ; } } } public synchronized void hideWaitCursor ( ) { if ( waitCount > 0 ) waitCount -- ; if ( waitCount == 0 ) { Cursor cursor = Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ; setCursor ( cursor ) ; cursor = Cursor . getPredefinedCursor ( Cursor . TEXT_CURSOR ) ; EditPane [ ] editPanes = getEditPanes ( ) ; for ( int i = 0 ; i < editPanes . length ; i ++ ) { EditPane editPane = editPanes [ i ] ; editPane . getTextArea ( ) . getPainter ( ) . setCursor ( cursor ) ; } } } public boolean isSynchroScrollEnabled ( ) { return synchroScroll ; } public void toggleSynchroScrollEnabled ( ) { setSynchroScrollEnabled ( ! synchroScroll ) ; } public void setSynchroScrollEnabled ( boolean synchroScroll ) { this . synchroScroll = synchroScroll ; JEditTextArea textArea = getTextArea ( ) ; int firstLine = textArea . getFirstLine ( ) ; int horizontalOffset = textArea . getHorizontalOffset ( ) ; synchroScrollVertical ( textArea , firstLine ) ; synchroScrollHorizontal ( textArea , horizontalOffset ) ; } public void synchroScrollVertical ( JEditTextArea textArea , int firstLine ) { if ( ! synchroScroll ) return ; EditPane [ ] editPanes = getEditPanes ( ) ; for ( int i = 0 ; i < editPanes . length ; i ++ ) { if ( editPanes [ i ] . getTextArea ( ) != textArea ) editPanes [ i ] . getTextArea ( ) . _setFirstLine ( firstLine ) ; } } public void synchroScrollHorizontal ( JEditTextArea textArea , int horizontalOffset ) { if ( ! synchroScroll ) return ; EditPane [ ] editPanes = getEditPanes ( ) ; for ( int i = 0 ; i < editPanes . length ; i ++ ) { if ( editPanes [ i ] . getTextArea ( ) != textArea ) editPanes [ i ] . getTextArea ( ) . _setHorizontalOffset ( horizontalOffset ) ; } } public View getNext ( ) { return next ; } public View getPrev ( ) { return prev ; } public void handleMessage ( EBMessage msg ) { if ( msg instanceof PropertiesChanged ) propertiesChanged ( ) ; else if ( msg instanceof SearchSettingsChanged ) { if ( searchBar != null ) searchBar . update ( ) ; } else if ( msg instanceof BufferUpdate ) handleBufferUpdate ( ( BufferUpdate ) msg ) ; else if ( msg instanceof EditPaneUpdate ) handleEditPaneUpdate ( ( EditPaneUpdate ) msg ) ; } public void processKeyEvent ( KeyEvent evt ) { if ( isClosed ( ) ) return ; if ( getFocusOwner ( ) instanceof JTextComponent ) { if ( evt . getID ( ) == KeyEvent . KEY_PRESSED ) { switch ( evt . getKeyCode ( ) ) { case KeyEvent . VK_BACK_SPACE : case KeyEvent . VK_TAB : case KeyEvent . VK_ENTER : return ; } } Keymap keymap = ( ( JTextComponent ) getFocusOwner ( ) ) . getKeymap ( ) ; if ( keymap . getAction ( KeyStroke . getKeyStrokeForEvent ( evt ) ) != null ) return ; } if ( evt . isConsumed ( ) ) return ; evt = KeyEventWorkaround . processKeyEvent ( evt ) ; if ( evt == null ) return ; switch ( evt . getID ( ) ) { case KeyEvent . KEY_TYPED : if ( keyEventInterceptor != null ) keyEventInterceptor . keyTyped ( evt ) ; else if ( inputHandler . isPrefixActive ( ) ) inputHandler . keyTyped ( evt ) ; break ; case KeyEvent . KEY_PRESSED : if ( keyEventInterceptor != null ) keyEventInterceptor . keyPressed ( evt ) ; else inputHandler . keyPressed ( evt ) ; break ; case KeyEvent . KEY_RELEASED : if ( keyEventInterceptor != null ) keyEventInterceptor . keyReleased ( evt ) ; else inputHandler . keyReleased ( evt ) ; break ; } if ( ! evt . isConsumed ( ) ) super . processKeyEvent ( evt ) ; } View prev ; View next ; View ( Buffer buffer , String splitConfig ) { setIconImage ( GUIUtilities . getEditorIcon ( ) ) ; dockableWindowManager = new DockableWindowManager ( this ) ; Component comp = restoreSplitConfig ( buffer , splitConfig ) ; dockableWindowManager . add ( comp ) ; EditBus . addToBus ( this ) ; setJMenuBar ( GUIUtilities . loadMenuBar ( "view.mbar" ) ) ; toolBars = new Box ( BoxLayout . Y_AXIS ) ; inputHandler = new DefaultInputHandler ( this , ( DefaultInputHandler ) jEdit . getInputHandler ( ) ) ; propertiesChanged ( ) ; getContentPane ( ) . add ( BorderLayout . NORTH , toolBars ) ; getContentPane ( ) . add ( BorderLayout . CENTER , dockableWindowManager ) ; getContentPane ( ) . add ( BorderLayout . SOUTH , status = new StatusBar ( this ) ) ; setDefaultCloseOperation ( DO_NOTHING_ON_CLOSE ) ; addWindowListener ( new WindowHandler ( ) ) ; dockableWindowManager . init ( ) ; } void close ( ) { closed = true ; dockableWindowManager . close ( ) ; GUIUtilities . saveGeometry ( this , "view" ) ; EditBus . removeFromBus ( this ) ; dispose ( ) ; EditPane [ ] editPanes = getEditPanes ( ) ; for ( int i = 0 ; i < editPanes . length ; i ++ ) editPanes [ i ] . close ( ) ; toolBars = null ; toolBar = null ; searchBar = null ; splitPane = null ; inputHandler = null ; recorder = null ; setContentPane ( new JPanel ( ) ) ; } void updateTitle ( ) { Vector buffers = new Vector ( ) ; EditPane [ ] editPanes = getEditPanes ( ) ; for ( int i = 0 ; i < editPanes . length ; i ++ ) { Buffer buffer = editPanes [ i ] . getBuffer ( ) ; if ( buffers . indexOf ( buffer ) == - 1 ) buffers . addElement ( buffer ) ; } StringBuffer title = new StringBuffer ( jEdit . getProperty ( "view.title" ) ) ; for ( int i = 0 ; i < buffers . size ( ) ; i ++ ) { if ( i != 0 ) title . append ( ", " ) ; Buffer buffer = ( Buffer ) buffers . elementAt ( i ) ; title . append ( ( showFullPath && ! buffer . isNewFile ( ) ) ? buffer . getPath ( ) : buffer . getName ( ) ) ; } setTitle ( title . toString ( ) ) ; } private boolean closed ; private DockableWindowManager dockableWindowManager ; private Box toolBars ; private JToolBar toolBar ; private SearchBar searchBar ; private boolean synchroScroll ; private EditPane editPane ; private JSplitPane splitPane ; private StatusBar status ; private KeyListener keyEventInterceptor ; private InputHandler inputHandler ; private Macros . Recorder recorder ; private int waitCount ; private boolean showFullPath ; private void getEditPanes ( Vector vec , Component comp ) { if ( comp instanceof EditPane ) vec . addElement ( comp ) ; else if ( comp instanceof JSplitPane ) { JSplitPane split = ( JSplitPane ) comp ; getEditPanes ( vec , split . getLeftComponent ( ) ) ; getEditPanes ( vec , split . getRightComponent ( ) ) ; } } private void getSplitConfig ( JSplitPane splitPane , StringBuffer splitConfig ) { Component left = splitPane . getLeftComponent ( ) ; if ( left instanceof JSplitPane ) getSplitConfig ( ( JSplitPane ) left , splitConfig ) ; else { splitConfig . append ( '\t' ) ; splitConfig . append ( ( ( EditPane ) left ) . getBuffer ( ) . getPath ( ) ) ; } Component right = splitPane . getRightComponent ( ) ; if ( right instanceof JSplitPane ) getSplitConfig ( ( JSplitPane ) right , splitConfig ) ; else { splitConfig . append ( '\t' ) ; splitConfig . append ( ( ( EditPane ) right ) . getBuffer ( ) . getPath ( ) ) ; } splitConfig . append ( splitPane . getOrientation ( ) == JSplitPane . VERTICAL_SPLIT ? "\tvertical" : "\thorizontal" ) ; } private Component restoreSplitConfig ( Buffer buffer , String splitConfig ) { if ( buffer != null ) return ( editPane = createEditPane ( buffer ) ) ; else if ( splitConfig == null ) return ( editPane = createEditPane ( jEdit . getFirstBuffer ( ) ) ) ; Stack stack = new Stack ( ) ; StringTokenizer st = new StringTokenizer ( splitConfig , "\t" ) ; while ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) ; if ( token . equals ( "vertical" ) ) { stack . push ( splitPane = new JSplitPane ( JSplitPane . VERTICAL_SPLIT , ( Component ) stack . pop ( ) , ( Component ) stack . pop ( ) ) ) ; splitPane . setBorder ( null ) ; splitPane . setDividerLocation ( 0.5 ) ; } else if ( token . equals ( "horizontal" ) ) { stack . push ( splitPane = new JSplitPane ( JSplitPane . HORIZONTAL_SPLIT , ( Component ) stack . pop ( ) , ( Component ) stack . pop ( ) ) ) ; splitPane . setBorder ( null ) ; splitPane . setDividerLocation ( 0.5 ) ; } else { buffer = jEdit . getBuffer ( token ) ; if ( buffer == null ) buffer = jEdit . getFirstBuffer ( ) ; stack . push ( editPane = createEditPane ( buffer ) ) ; } } return ( Component ) stack . peek ( ) ; } private void propertiesChanged ( ) { loadToolBars ( ) ; showFullPath = jEdit . getBooleanProperty ( "view.showFullPath" ) ; updateTitle ( ) ; dockableWindowManager . propertiesChanged ( ) ; SwingUtilities . updateComponentTreeUI ( getRootPane ( ) ) ; } private void loadToolBars ( ) { if ( jEdit . getBooleanProperty ( "view.showToolbar" ) ) { if ( toolBar != null ) toolBars . remove ( toolBar ) ; toolBar = GUIUtilities . loadToolBar ( "view.toolbar" ) ; toolBar . add ( Box . createGlue ( ) ) ; toolBars . add ( toolBar , 0 ) ; getRootPane ( ) . revalidate ( ) ; } else if ( toolBar != null ) { removeToolBar ( toolBar ) ; toolBar = null ; } if ( jEdit . getBooleanProperty ( "view.showSearchbar" ) ) { if ( searchBar == null ) { searchBar = new SearchBar ( this ) ; addToolBar ( searchBar ) ; } } else if ( searchBar != null ) { removeToolBar ( searchBar ) ; searchBar = null ; } } private EditPane createEditPane ( Buffer buffer ) { EditPane editPane = new EditPane ( this , buffer ) ; JEditTextArea textArea = editPane . getTextArea ( ) ; textArea . addFocusListener ( new FocusHandler ( ) ) ; textArea . addCaretListener ( new CaretHandler ( ) ) ; textArea . addScrollListener ( new ScrollHandler ( ) ) ; EditBus . send ( new EditPaneUpdate ( editPane , EditPaneUpdate . CREATED ) ) ; return editPane ; } private void setEditPane ( EditPane editPane ) { this . editPane = editPane ; status . repaintCaretStatus ( ) ; status . updateBufferStatus ( ) ; status . updateMiscStatus ( ) ; } private void handleBufferUpdate ( BufferUpdate msg ) { Buffer buffer = msg . getBuffer ( ) ; if ( msg . getWhat ( ) == BufferUpdate . DIRTY_CHANGED ) { if ( ! buffer . isDirty ( ) ) { EditPane [ ] editPanes = getEditPanes ( ) ; for ( int i = 0 ; i < editPanes . length ; i ++ ) { if ( editPanes [ i ] . getBuffer ( ) == buffer ) { updateTitle ( ) ; break ; } } } } } private void handleEditPaneUpdate ( EditPaneUpdate msg ) { if ( msg . getEditPane ( ) . getView ( ) == this && msg . getWhat ( ) == EditPaneUpdate . BUFFER_CHANGED ) { status . repaintCaretStatus ( ) ; status . updateBufferStatus ( ) ; status . updateMiscStatus ( ) ; status . updateFoldStatus ( ) ; } } class CaretHandler implements CaretListener { public void caretUpdate ( CaretEvent evt ) { status . repaintCaretStatus ( ) ; status . updateMiscStatus ( ) ; } } class FocusHandler extends FocusAdapter { public void focusGained ( FocusEvent evt ) { Component comp = ( Component ) evt . getSource ( ) ; while ( ! ( comp instanceof EditPane ) ) { if ( comp == null ) return ; comp = comp . getParent ( ) ; } setEditPane ( ( EditPane ) comp ) ; } } class ScrollHandler implements ScrollListener { public void scrolledVertically ( JEditTextArea textArea ) { if ( getTextArea ( ) == textArea ) status . repaintCaretStatus ( ) ; } public void scrolledHorizontally ( JEditTextArea textArea ) { } } class WindowHandler extends WindowAdapter { boolean gotFocus ; public void windowActivated ( WindowEvent evt ) { if ( ! gotFocus ) { editPane . focusOnTextArea ( ) ; gotFocus = true ; } final Vector buffers = new Vector ( ) ; EditPane [ ] editPanes = getEditPanes ( ) ; for ( int i = 0 ; i < editPanes . length ; i ++ ) { Buffer buffer = ( ( EditPane ) editPanes [ i ] ) . getBuffer ( ) ; if ( buffers . contains ( buffer ) ) continue ; else buffers . addElement ( buffer ) ; } SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { for ( int i = 0 ; i < buffers . size ( ) ; i ++ ) { ( ( Buffer ) buffers . elementAt ( i ) ) . checkModTime ( View . this ) ; } } } ) ; } public void windowClosing ( WindowEvent evt ) { jEdit . closeView ( View . this ) ; } } } 	1	['55', '6', '0', '109', '200', '1197', '99', '30', '40', '0.892361111', '1437', '0.875', '8', '0.922746781', '0.0784689', '1', '1', '24.83636364', '13', '2.5091', '5']
package bsh ; public class Primitive implements ParserConstants , java . io . Serializable { private Object value ; private static class Special implements java . io . Serializable { private Special ( ) { } public static final Special NULL_VALUE = new Special ( ) ; public static final Special VOID_TYPE = new Special ( ) ; } public static final Primitive NULL = new Primitive ( Special . NULL_VALUE ) ; public static final Primitive VOID = new Primitive ( Special . VOID_TYPE ) ; private Primitive ( Object value ) { if ( value == null ) throw new InterpreterError ( "Use Primitve.NULL instead of Primitive(null)" ) ; this . value = value ; } public Primitive ( Number number ) { this ( ( Object ) number ) ; } public Primitive ( Boolean value ) { this ( ( Object ) value ) ; } public Primitive ( Byte value ) { this ( ( Object ) value ) ; } public Primitive ( Short value ) { this ( ( Object ) value ) ; } public Primitive ( Character value ) { this ( ( Object ) value ) ; } public Primitive ( Integer value ) { this ( ( Object ) value ) ; } public Primitive ( Long value ) { this ( ( Object ) value ) ; } public Primitive ( Float value ) { this ( ( Object ) value ) ; } public Primitive ( Double value ) { this ( ( Object ) value ) ; } public Primitive ( boolean value ) { this ( new Boolean ( value ) ) ; } public Primitive ( byte value ) { this ( new Byte ( value ) ) ; } public Primitive ( short value ) { this ( new Short ( value ) ) ; } public Primitive ( char value ) { this ( new Character ( value ) ) ; } public Primitive ( int value ) { this ( new Integer ( value ) ) ; } public Primitive ( long value ) { this ( new Long ( value ) ) ; } public Primitive ( float value ) { this ( new Float ( value ) ) ; } public Primitive ( double value ) { this ( new Double ( value ) ) ; } public Object getValue ( ) { if ( value == Special . NULL_VALUE ) return null ; else if ( value == Special . VOID_TYPE ) throw new InterpreterError ( "attempt to unwrap void type" ) ; else return value ; } public String toString ( ) { if ( value == Special . NULL_VALUE ) return "null" ; else if ( value == Special . VOID_TYPE ) return "void" ; else return value . toString ( ) ; } public Class getType ( ) { return getType ( value ) ; } private Class getType ( Object o ) { if ( o instanceof Boolean ) return Boolean . TYPE ; else if ( o instanceof Byte ) return Byte . TYPE ; else if ( o instanceof Short ) return Short . TYPE ; else if ( o instanceof Character ) return Character . TYPE ; else if ( o instanceof Integer ) return Integer . TYPE ; else if ( o instanceof Long ) return Long . TYPE ; else if ( o instanceof Float ) return Float . TYPE ; else if ( o instanceof Double ) return Double . TYPE ; return null ; } public static Object binaryOperation ( Object obj1 , Object obj2 , int kind ) throws EvalError { if ( obj1 == NULL || obj2 == NULL ) throw new EvalError ( "Null value or 'null' literal in binary operation" ) ; if ( obj1 == VOID || obj2 == VOID ) throw new EvalError ( "Undefined variable, class, or 'void' literal in binary operation" ) ; Class lhsOrgType = obj1 . getClass ( ) ; Class rhsOrgType = obj2 . getClass ( ) ; if ( obj1 instanceof Primitive ) obj1 = ( ( Primitive ) obj1 ) . getValue ( ) ; if ( obj2 instanceof Primitive ) obj2 = ( ( Primitive ) obj2 ) . getValue ( ) ; Object [ ] operands = promotePrimitives ( obj1 , obj2 ) ; Object lhs = operands [ 0 ] ; Object rhs = operands [ 1 ] ; if ( lhs . getClass ( ) != rhs . getClass ( ) ) throw new EvalError ( "type mismatch in operator.  " + lhs . getClass ( ) + " cannot be used with " + rhs . getClass ( ) ) ; Object result ; try { result = binaryOperationImpl ( lhs , rhs , kind ) ; } catch ( ArithmeticException e ) { throw new TargetError ( "Arithemetic Exception in binary op" , e ) ; } if ( lhsOrgType == Primitive . class && rhsOrgType == Primitive . class ) return new Primitive ( result ) ; else return result ; } static Object binaryOperationImpl ( Object lhs , Object rhs , int kind ) throws EvalError { if ( lhs instanceof Boolean ) return booleanBinaryOperation ( ( Boolean ) lhs , ( Boolean ) rhs , kind ) ; else if ( lhs instanceof Integer ) return intBinaryOperation ( ( Integer ) lhs , ( Integer ) rhs , kind ) ; else if ( lhs instanceof Long ) return longBinaryOperation ( ( Long ) lhs , ( Long ) rhs , kind ) ; else if ( lhs instanceof Float ) return floatBinaryOperation ( ( Float ) lhs , ( Float ) rhs , kind ) ; else if ( lhs instanceof Double ) return doubleBinaryOperation ( ( Double ) lhs , ( Double ) rhs , kind ) ; else throw new EvalError ( "Invalid types in binary operator" ) ; } static Boolean booleanBinaryOperation ( Boolean B1 , Boolean B2 , int kind ) throws EvalError { boolean lhs = B1 . booleanValue ( ) ; boolean rhs = B2 . booleanValue ( ) ; switch ( kind ) { case EQ : return new Boolean ( lhs == rhs ) ; case NE : return new Boolean ( lhs != rhs ) ; case BOOL_OR : case BOOL_ORX : return new Boolean ( lhs || rhs ) ; case BOOL_AND : case BOOL_ANDX : return new Boolean ( lhs && rhs ) ; default : throw new InterpreterError ( "unimplemented binary operator" ) ; } } static Object longBinaryOperation ( Long L1 , Long L2 , int kind ) { long lhs = L1 . longValue ( ) ; long rhs = L2 . longValue ( ) ; switch ( kind ) { case LT : case LTX : return new Boolean ( lhs < rhs ) ; case GT : case GTX : return new Boolean ( lhs > rhs ) ; case EQ : return new Boolean ( lhs == rhs ) ; case LE : case LEX : return new Boolean ( lhs <= rhs ) ; case GE : case GEX : return new Boolean ( lhs >= rhs ) ; case NE : return new Boolean ( lhs != rhs ) ; case PLUS : return new Long ( lhs + rhs ) ; case MINUS : return new Long ( lhs - rhs ) ; case STAR : return new Long ( lhs * rhs ) ; case SLASH : return new Long ( lhs / rhs ) ; case MOD : return new Long ( lhs % rhs ) ; case LSHIFT : case LSHIFTX : return new Long ( lhs << rhs ) ; case RSIGNEDSHIFT : case RSIGNEDSHIFTX : return new Long ( lhs > > rhs ) ; case RUNSIGNEDSHIFT : case RUNSIGNEDSHIFTX : return new Long ( lhs > > > rhs ) ; case BIT_AND : case BIT_ANDX : return new Long ( lhs & rhs ) ; case BIT_OR : case BIT_ORX : return new Long ( lhs | rhs ) ; case XOR : return new Long ( lhs ^ rhs ) ; default : throw new InterpreterError ( "Unimplemented binary long operator" ) ; } } static Object intBinaryOperation ( Integer I1 , Integer I2 , int kind ) { int lhs = I1 . intValue ( ) ; int rhs = I2 . intValue ( ) ; switch ( kind ) { case LT : case LTX : return new Boolean ( lhs < rhs ) ; case GT : case GTX : return new Boolean ( lhs > rhs ) ; case EQ : return new Boolean ( lhs == rhs ) ; case LE : case LEX : return new Boolean ( lhs <= rhs ) ; case GE : case GEX : return new Boolean ( lhs >= rhs ) ; case NE : return new Boolean ( lhs != rhs ) ; case PLUS : return new Integer ( lhs + rhs ) ; case MINUS : return new Integer ( lhs - rhs ) ; case STAR : return new Integer ( lhs * rhs ) ; case SLASH : return new Integer ( lhs / rhs ) ; case MOD : return new Integer ( lhs % rhs ) ; case LSHIFT : case LSHIFTX : return new Integer ( lhs << rhs ) ; case RSIGNEDSHIFT : case RSIGNEDSHIFTX : return new Integer ( lhs > > rhs ) ; case RUNSIGNEDSHIFT : case RUNSIGNEDSHIFTX : return new Integer ( lhs > > > rhs ) ; case BIT_AND : case BIT_ANDX : return new Integer ( lhs & rhs ) ; case BIT_OR : case BIT_ORX : return new Integer ( lhs | rhs ) ; case XOR : return new Integer ( lhs ^ rhs ) ; default : throw new InterpreterError ( "Unimplemented binary integer operator" ) ; } } static Object doubleBinaryOperation ( Double D1 , Double D2 , int kind ) throws EvalError { double lhs = D1 . doubleValue ( ) ; double rhs = D2 . doubleValue ( ) ; switch ( kind ) { case LT : case LTX : return new Boolean ( lhs < rhs ) ; case GT : case GTX : return new Boolean ( lhs > rhs ) ; case EQ : return new Boolean ( lhs == rhs ) ; case LE : case LEX : return new Boolean ( lhs <= rhs ) ; case GE : case GEX : return new Boolean ( lhs >= rhs ) ; case NE : return new Boolean ( lhs != rhs ) ; case PLUS : return new Double ( lhs + rhs ) ; case MINUS : return new Double ( lhs - rhs ) ; case STAR : return new Double ( lhs * rhs ) ; case SLASH : return new Double ( lhs / rhs ) ; case MOD : return new Double ( lhs % rhs ) ; case LSHIFT : case LSHIFTX : case RSIGNEDSHIFT : case RSIGNEDSHIFTX : case RUNSIGNEDSHIFT : case RUNSIGNEDSHIFTX : throw new EvalError ( "Can't shift doubles" ) ; default : throw new InterpreterError ( "Unimplemented binary double operator" ) ; } } static Object floatBinaryOperation ( Float F1 , Float F2 , int kind ) throws EvalError { float lhs = F1 . floatValue ( ) ; float rhs = F2 . floatValue ( ) ; switch ( kind ) { case LT : case LTX : return new Boolean ( lhs < rhs ) ; case GT : case GTX : return new Boolean ( lhs > rhs ) ; case EQ : return new Boolean ( lhs == rhs ) ; case LE : case LEX : return new Boolean ( lhs <= rhs ) ; case GE : case GEX : return new Boolean ( lhs >= rhs ) ; case NE : return new Boolean ( lhs != rhs ) ; case PLUS : return new Float ( lhs + rhs ) ; case MINUS : return new Float ( lhs - rhs ) ; case STAR : return new Float ( lhs * rhs ) ; case SLASH : return new Float ( lhs / rhs ) ; case MOD : return new Float ( lhs % rhs ) ; case LSHIFT : case LSHIFTX : case RSIGNEDSHIFT : case RSIGNEDSHIFTX : case RUNSIGNEDSHIFT : case RUNSIGNEDSHIFTX : throw new EvalError ( "Can't shift floats " ) ; default : throw new InterpreterError ( "Unimplemented binary float operator" ) ; } } static Object promoteToInteger ( Object primitive ) { if ( primitive instanceof Character ) return new Integer ( ( ( Character ) primitive ) . charValue ( ) ) ; else if ( ( primitive instanceof Byte ) || ( primitive instanceof Short ) ) return new Integer ( ( ( Number ) primitive ) . intValue ( ) ) ; return primitive ; } static Object [ ] promotePrimitives ( Object lhs , Object rhs ) { lhs = promoteToInteger ( lhs ) ; rhs = promoteToInteger ( rhs ) ; if ( ( lhs instanceof Number ) && ( rhs instanceof Number ) ) { Number lnum = ( Number ) lhs ; Number rnum = ( Number ) rhs ; boolean b ; if ( ( b = ( lnum instanceof Double ) ) || ( rnum instanceof Double ) ) { if ( b ) rhs = new Double ( rnum . doubleValue ( ) ) ; else lhs = new Double ( lnum . doubleValue ( ) ) ; } else if ( ( b = ( lnum instanceof Float ) ) || ( rnum instanceof Float ) ) { if ( b ) rhs = new Float ( rnum . floatValue ( ) ) ; else lhs = new Float ( lnum . floatValue ( ) ) ; } else if ( ( b = ( lnum instanceof Long ) ) || ( rnum instanceof Long ) ) { if ( b ) rhs = new Long ( rnum . longValue ( ) ) ; else lhs = new Long ( lnum . longValue ( ) ) ; } } return new Object [ ] { lhs , rhs } ; } public static Primitive unaryOperation ( Primitive val , int kind ) throws EvalError { if ( val == NULL ) throw new EvalError ( "illegal use of null object or 'null' literal" ) ; if ( val == VOID ) throw new EvalError ( "illegal use of undefined object or 'void' literal" ) ; Class operandType = val . getType ( ) ; Object operand = promoteToInteger ( val . getValue ( ) ) ; if ( operand instanceof Boolean ) return new Primitive ( booleanUnaryOperation ( ( Boolean ) operand , kind ) ) ; else if ( operand instanceof Integer ) { int result = intUnaryOperation ( ( Integer ) operand , kind ) ; if ( kind == INCR || kind == DECR ) { if ( operandType == Byte . TYPE ) return new Primitive ( ( byte ) result ) ; if ( operandType == Short . TYPE ) return new Primitive ( ( short ) result ) ; if ( operandType == Character . TYPE ) return new Primitive ( ( char ) result ) ; } return new Primitive ( result ) ; } else if ( operand instanceof Long ) return new Primitive ( longUnaryOperation ( ( Long ) operand , kind ) ) ; else if ( operand instanceof Float ) return new Primitive ( floatUnaryOperation ( ( Float ) operand , kind ) ) ; else if ( operand instanceof Double ) return new Primitive ( doubleUnaryOperation ( ( Double ) operand , kind ) ) ; else throw new InterpreterError ( "An error occurred.  Please call technical support." ) ; } static boolean booleanUnaryOperation ( Boolean B , int kind ) throws EvalError { boolean operand = B . booleanValue ( ) ; switch ( kind ) { case BANG : return ! operand ; default : throw new EvalError ( "Operator inappropriate for boolean" ) ; } } static int intUnaryOperation ( Integer I , int kind ) { int operand = I . intValue ( ) ; switch ( kind ) { case PLUS : return operand ; case MINUS : return - operand ; case TILDE : return ~ operand ; case INCR : return operand + 1 ; case DECR : return operand - 1 ; default : throw new InterpreterError ( "bad integer unaryOperation" ) ; } } static long longUnaryOperation ( Long L , int kind ) { long operand = L . longValue ( ) ; switch ( kind ) { case PLUS : return operand ; case MINUS : return - operand ; case TILDE : return ~ operand ; case INCR : return operand + 1 ; case DECR : return operand - 1 ; default : throw new InterpreterError ( "bad long unaryOperation" ) ; } } static float floatUnaryOperation ( Float F , int kind ) { float operand = F . floatValue ( ) ; switch ( kind ) { case PLUS : return operand ; case MINUS : return - operand ; default : throw new InterpreterError ( "bad float unaryOperation" ) ; } } static double doubleUnaryOperation ( Double D , int kind ) { double operand = D . doubleValue ( ) ; switch ( kind ) { case PLUS : return operand ; case MINUS : return - operand ; default : throw new InterpreterError ( "bad double unaryOperation" ) ; } } public int intValue ( ) throws EvalError { if ( value instanceof Number ) return ( ( Number ) value ) . intValue ( ) ; else throw new EvalError ( "Primitive not a number" ) ; } public boolean booleanValue ( ) throws EvalError { if ( value instanceof Boolean ) return ( ( Boolean ) value ) . booleanValue ( ) ; else throw new EvalError ( "Primitive not a boolean" ) ; } public boolean isNumber ( ) { return ( ! ( value instanceof Boolean ) && ! ( this == NULL ) && ! ( this == VOID ) ) ; } public Number numberValue ( ) throws EvalError { Object value = this . value ; if ( value instanceof Character ) value = new Integer ( ( ( Character ) value ) . charValue ( ) ) ; if ( value instanceof Number ) return ( Number ) value ; else throw new EvalError ( "Primitive not a number" ) ; } public boolean equals ( Object obj ) { if ( obj instanceof Primitive ) return ( ( Primitive ) obj ) . value . equals ( this . value ) ; else return obj . equals ( this . value ) ; } public static Object unwrap ( Object obj ) { if ( obj == null ) return null ; if ( obj == Primitive . VOID ) return null ; if ( obj instanceof Primitive ) return ( ( Primitive ) obj ) . getValue ( ) ; else return obj ; } } 	0	['45', '1', '0', '41', '77', '898', '36', '5', '28', '0.795454545', '1472', '0.25', '2', '0', '0.083333333', '0', '0', '31.62222222', '12', '2.0222', '0']
package org . gjt . sp . jedit . io ; import java . awt . Component ; import java . io . * ; import org . gjt . sp . jedit . * ; public abstract class VFS { public static final int READ_CAP = 1 << 0 ; public static final int WRITE_CAP = 1 << 1 ; public static final int BROWSE_CAP = 1 << 2 ; public static final int DELETE_CAP = 1 << 3 ; public static final int RENAME_CAP = 1 << 4 ; public static final int MKDIR_CAP = 1 << 5 ; public VFS ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public abstract int getCapabilities ( ) ; public String showBrowseDialog ( Object [ ] session , Component comp ) { return null ; } public String getFileName ( String path ) { return MiscUtilities . getFileName ( path ) ; } public String getParentOfPath ( String path ) { return null ; } public String constructPath ( String parent , String path ) { return parent + path ; } public char getFileSeparator ( ) { return '/' ; } public Object createVFSSession ( String path , Component comp ) { return new Object ( ) ; } public boolean load ( View view , Buffer buffer , String path ) { if ( ( getCapabilities ( ) & READ_CAP ) == 0 ) { VFSManager . error ( view , "vfs.not-supported.load" , new String [ ] { name } ) ; return false ; } Object session = createVFSSession ( path , view ) ; if ( session == null ) return false ; BufferIORequest request = new BufferIORequest ( BufferIORequest . LOAD , view , buffer , session , this , path ) ; if ( buffer . isTemporary ( ) ) request . run ( ) ; else VFSManager . runInWorkThread ( request ) ; return true ; } public boolean save ( View view , Buffer buffer , String path ) { if ( ( getCapabilities ( ) & WRITE_CAP ) == 0 ) { VFSManager . error ( view , "vfs.not-supported.save" , new String [ ] { name } ) ; return false ; } Object session = createVFSSession ( path , view ) ; if ( session == null ) return false ; if ( ! path . equals ( buffer . getPath ( ) ) ) buffer . getDocumentProperties ( ) . remove ( Buffer . BACKED_UP ) ; VFSManager . runInWorkThread ( new BufferIORequest ( BufferIORequest . SAVE , view , buffer , session , this , path ) ) ; return true ; } public boolean insert ( View view , Buffer buffer , String path ) { if ( ( getCapabilities ( ) & READ_CAP ) == 0 ) { VFSManager . error ( view , "vfs.not-supported.load" , new String [ ] { name } ) ; return false ; } Object session = createVFSSession ( path , view ) ; if ( session == null ) return false ; VFSManager . runInWorkThread ( new BufferIORequest ( BufferIORequest . INSERT , view , buffer , session , this , path ) ) ; return true ; } public DirectoryEntry [ ] _listDirectory ( Object session , String directory , Component comp ) throws IOException { VFSManager . error ( comp , "vfs.not-supported.list" , new String [ ] { name } ) ; return null ; } public DirectoryEntry _getDirectoryEntry ( Object session , String path , Component comp ) throws IOException { return null ; } public static class DirectoryEntry implements Serializable { public static final int FILE = 0 ; public static final int DIRECTORY = 1 ; public static final int FILESYSTEM = 2 ; public String name ; public String path ; public String deletePath ; public int type ; public long length ; public boolean hidden ; public DirectoryEntry ( String name , String path , String deletePath , int type , long length , boolean hidden ) { this . name = name ; this . path = path ; this . deletePath = deletePath ; this . type = type ; this . length = length ; this . hidden = hidden ; } public String toString ( ) { return name ; } } public boolean _delete ( Object session , String path , Component comp ) throws IOException { return false ; } public boolean _rename ( Object session , String from , String to , Component comp ) throws IOException { return false ; } public boolean _mkdir ( Object session , String directory , Component comp ) throws IOException { return false ; } public void _backup ( Object session , String path , Component comp ) throws IOException { } public InputStream _createInputStream ( Object session , String path , boolean ignoreErrors , Component comp ) throws IOException { VFSManager . error ( comp , "vfs.not-supported.load" , new String [ ] { name } ) ; return null ; } public OutputStream _createOutputStream ( Object session , String path , Component comp ) throws IOException { VFSManager . error ( comp , "vfs.not-supported.save" , new String [ ] { name } ) ; return null ; } public void _saveComplete ( Object session , Buffer buffer , Component comp ) throws IOException { } public void _endVFSSession ( Object session , Component comp ) throws IOException { } private String name ; } 	1	['22', '1', '4', '23', '36', '175', '20', '6', '22', '0.993197279', '239', '0.142857143', '0', '0', '0.392045455', '0', '0', '9.545454545', '4', '1.3182', '4']
package bsh ; import java . lang . reflect . * ; import java . io . * ; import java . util . Vector ; class Reflect { public static Object invokeObjectMethod ( Interpreter interpreter , Object object , String methodName , Object [ ] args , SimpleNode callerInfo ) throws ReflectError , InvocationTargetException , EvalError { if ( object instanceof This ) return ( ( This ) object ) . invokeMethod ( methodName , args , interpreter , null , callerInfo ) ; else return invokeMethod ( object . getClass ( ) , object , methodName , args , false ) ; } public static Object invokeStaticMethod ( Class clas , String methodName , Object [ ] args ) throws ReflectError , InvocationTargetException , EvalError { Interpreter . debug ( "invoke static Method" ) ; return invokeMethod ( clas , null , methodName , args , true ) ; } public static Object getIndex ( Object array , int index ) throws ReflectError , TargetError { try { Object val = Array . get ( array , index ) ; return wrapPrimitive ( val , array . getClass ( ) . getComponentType ( ) ) ; } catch ( ArrayIndexOutOfBoundsException e1 ) { throw new TargetError ( "Array Index" , e1 ) ; } catch ( Exception e ) { throw new ReflectError ( "Array access:" + e ) ; } } public static void setIndex ( Object array , int index , Object val ) throws ReflectError , TargetError { try { val = unwrapPrimitive ( val ) ; Array . set ( array , index , val ) ; } catch ( ArrayStoreException e2 ) { throw new TargetError ( "Array store exception" , e2 ) ; } catch ( IllegalArgumentException e1 ) { throw new TargetError ( "Illegal Argument" , new ArrayStoreException ( e1 . toString ( ) ) ) ; } catch ( Exception e ) { throw new ReflectError ( "Array access:" + e ) ; } } public static Object getStaticField ( Class clas , String fieldName ) throws ReflectError { return getFieldValue ( clas , null , fieldName ) ; } public static Object getObjectField ( Object object , String fieldName ) throws ReflectError { if ( object instanceof This ) return ( ( This ) object ) . namespace . getVariable ( fieldName ) ; else { try { return getFieldValue ( object . getClass ( ) , object , fieldName ) ; } catch ( ReflectError e ) { if ( hasObjectPropertyGetter ( object . getClass ( ) , fieldName ) ) return getObjectProperty ( object , fieldName ) ; else throw e ; } } } static LHS getLHSStaticField ( Class clas , String fieldName ) throws ReflectError { Field f = getField ( clas , fieldName ) ; return new LHS ( f ) ; } static LHS getLHSObjectField ( Object object , String fieldName ) throws ReflectError { if ( object instanceof This ) return new LHS ( ( ( This ) object ) . namespace , fieldName ) ; try { Field f = getField ( object . getClass ( ) , fieldName ) ; return new LHS ( object , f ) ; } catch ( ReflectError e ) { if ( hasObjectPropertySetter ( object . getClass ( ) , fieldName ) ) return new LHS ( object , fieldName ) ; else throw e ; } } private static Object getFieldValue ( Class clas , Object object , String fieldName ) throws ReflectError { try { Field f = getField ( clas , fieldName ) ; if ( f == null ) throw new ReflectError ( "internal: field not found:" + fieldName ) ; Object value = f . get ( object ) ; Class returnType = f . getType ( ) ; return wrapPrimitive ( value , returnType ) ; } catch ( NullPointerException e ) { throw new ReflectError ( "???" + fieldName + " is not a static field." ) ; } catch ( IllegalAccessException e ) { throw new ReflectError ( "Can't access field: " + fieldName ) ; } } private static Field getField ( Class clas , String fieldName ) throws ReflectError { try { if ( Capabilities . haveAccessibility ( ) ) return findAccessibleField ( clas , fieldName ) ; else return clas . getField ( fieldName ) ; } catch ( NoSuchFieldException e ) { throw new ReflectError ( "No such field: " + fieldName ) ; } } private static Field findAccessibleField ( Class clas , String fieldName ) throws NoSuchFieldException { while ( clas != null ) { try { Field field = clas . getDeclaredField ( fieldName ) ; if ( ReflectManager . RMSetAccessible ( field ) ) return field ; } catch ( NoSuchFieldException e ) { } clas = clas . getSuperclass ( ) ; } throw new NoSuchFieldException ( fieldName ) ; } private static Object invokeMethod ( Class clas , Object object , String name , Object [ ] args , boolean onlyStatic ) throws ReflectError , InvocationTargetException , EvalError { if ( object == Primitive . NULL ) throw new TargetError ( "Attempt to invoke method " + name + " on null value" , new NullPointerException ( ) ) ; if ( object == Primitive . VOID ) throw new EvalError ( "Attempt to invoke method " + name + " on undefined variable or class name" ) ; if ( args == null ) args = new Object [ ] { } ; for ( int i = 0 ; i < args . length ; i ++ ) if ( args [ i ] == Primitive . VOID ) throw new ReflectError ( "Attempt to pass void argument " + "(position " + i + ") to method: " + name ) ; Class returnType = null ; Object returnValue = null ; Class [ ] types = getTypes ( args ) ; unwrapPrimitives ( args ) ; try { Method m = null ; try { m = findAccessibleMethod ( clas , name , types , onlyStatic ) ; } catch ( SecurityException e ) { } if ( m == null ) Interpreter . debug ( "Exact method " + StringUtil . methodString ( name , types ) + " not found in '" + clas . getName ( ) + "'" ) ; if ( m == null ) { if ( types . length == 0 ) throw new ReflectError ( "No args " + ( onlyStatic ? "static " : "" ) + "method " + StringUtil . methodString ( name , types ) + " not found in class'" + clas . getName ( ) + "'" ) ; Method [ ] methods = clas . getMethods ( ) ; if ( onlyStatic ) methods = retainStaticMethods ( methods ) ; m = findMostSpecificMethod ( name , types , methods ) ; methods = clas . getMethods ( ) ; if ( m == null ) m = findExtendedMethod ( name , args , methods ) ; if ( m != null ) { try { m = findAccessibleMethod ( clas , m . getName ( ) , m . getParameterTypes ( ) , onlyStatic ) ; } catch ( SecurityException e ) { } } } if ( m == null ) throw new ReflectError ( ( onlyStatic ? "Static method " : "Method " ) + StringUtil . methodString ( name , types ) + " not found in class'" + clas . getName ( ) + "'" ) ; returnValue = m . invoke ( object , args ) ; if ( returnValue == null ) returnValue = Primitive . NULL ; returnType = m . getReturnType ( ) ; } catch ( IllegalAccessException e ) { throw new ReflectError ( "Cannot access method " + StringUtil . methodString ( name , types ) + " in '" + clas . getName ( ) + "' :" + e ) ; } return wrapPrimitive ( returnValue , returnType ) ; } private static Method [ ] retainStaticMethods ( Method [ ] methods ) { Vector v = new Vector ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) if ( Modifier . isStatic ( methods [ i ] . getModifiers ( ) ) ) v . addElement ( methods [ i ] ) ; Method [ ] ma = new Method [ v . size ( ) ] ; v . copyInto ( ma ) ; return ma ; } static Method findAccessibleMethod ( Class clas , String name , Class [ ] types , boolean onlyStatic ) { Method meth = null ; Vector classQ = new Vector ( ) ; classQ . addElement ( clas ) ; Method found = null ; while ( classQ . size ( ) > 0 ) { Class c = ( Class ) classQ . firstElement ( ) ; classQ . removeElementAt ( 0 ) ; if ( Modifier . isPublic ( c . getModifiers ( ) ) || ( Capabilities . haveAccessibility ( ) && ReflectManager . RMSetAccessible ( c ) ) ) { try { meth = c . getDeclaredMethod ( name , types ) ; if ( Modifier . isPublic ( meth . getModifiers ( ) ) || ( Capabilities . haveAccessibility ( ) && ReflectManager . RMSetAccessible ( meth ) ) ) { found = meth ; break ; } } catch ( NoSuchMethodException e ) { } } if ( ! c . isInterface ( ) ) { Class superclass = c . getSuperclass ( ) ; if ( superclass != null ) classQ . addElement ( ( Object ) superclass ) ; } Class [ ] intfs = c . getInterfaces ( ) ; for ( int i = 0 ; i < intfs . length ; i ++ ) classQ . addElement ( ( Object ) intfs [ i ] ) ; } if ( found != null && ( ! onlyStatic || Modifier . isStatic ( found . getModifiers ( ) ) ) ) return found ; return null ; } private static Object wrapPrimitive ( Object value , Class returnType ) throws ReflectError { if ( value == null ) return Primitive . NULL ; if ( returnType == Void . TYPE ) return Primitive . VOID ; else if ( returnType . isPrimitive ( ) ) { if ( value instanceof Number ) return new Primitive ( ( Number ) value ) ; if ( value instanceof Boolean ) return new Primitive ( ( Boolean ) value ) ; if ( value instanceof Character ) return new Primitive ( ( Character ) value ) ; throw new ReflectError ( "Something bad happened" ) ; } else return value ; } public static Class [ ] getTypes ( Object [ ] args ) { if ( args == null ) return new Class [ 0 ] ; Class [ ] types = new Class [ args . length ] ; for ( int i = 0 ; i < args . length ; i ++ ) { if ( args [ i ] instanceof Primitive ) types [ i ] = ( ( Primitive ) args [ i ] ) . getType ( ) ; else types [ i ] = args [ i ] . getClass ( ) ; } return types ; } private static void unwrapPrimitives ( Object [ ] args ) { for ( int i = 0 ; i < args . length ; i ++ ) args [ i ] = unwrapPrimitive ( args [ i ] ) ; } private static Object unwrapPrimitive ( Object arg ) { if ( arg instanceof Primitive ) return ( ( Primitive ) arg ) . getValue ( ) ; else return arg ; } static Object constructObject ( String clas , Object [ ] args ) throws ReflectError , InvocationTargetException { Class c = BshClassManager . classForName ( clas ) ; if ( c == null ) throw new ReflectError ( "Class not found: " + clas ) ; return constructObject ( c , args ) ; } static Object constructObject ( Class clas , Object [ ] args ) throws ReflectError , InvocationTargetException { for ( int i = 0 ; i < args . length ; i ++ ) if ( args [ i ] == Primitive . VOID ) throw new ReflectError ( "Attempt to pass void argument " + "(position " + i + ") to constructor for: " + clas ) ; if ( clas . isInterface ( ) ) throw new ReflectError ( "Can't create instance of an interface: " + clas ) ; Object obj = null ; Class [ ] types = getTypes ( args ) ; unwrapPrimitives ( args ) ; Constructor con = null ; Constructor [ ] constructors = clas . getDeclaredConstructors ( ) ; Interpreter . debug ( "Looking for most specific constructor: " + clas ) ; con = findMostSpecificConstructor ( types , constructors ) ; if ( con == null ) if ( types . length == 0 ) throw new ReflectError ( "Can't find default constructor for: " + clas ) ; else con = findExtendedConstructor ( args , constructors ) ; if ( con == null ) throw new ReflectError ( "Can't find constructor: " + clas ) ; try { obj = con . newInstance ( args ) ; } catch ( InstantiationException e ) { throw new ReflectError ( "the class is abstract " ) ; } catch ( IllegalAccessException e ) { throw new ReflectError ( "we don't have permission to create an instance" ) ; } catch ( IllegalArgumentException e ) { throw new ReflectError ( "the number of arguments was wrong" ) ; } if ( obj == null ) throw new ReflectError ( "couldn't construct the object" ) ; return obj ; } static Method findMostSpecificMethod ( String name , Class [ ] idealMatch , Method [ ] methods ) { Vector sigs = new Vector ( ) ; Vector meths = new Vector ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) if ( methods [ i ] . getName ( ) . equals ( name ) ) { meths . addElement ( methods [ i ] ) ; sigs . addElement ( methods [ i ] . getParameterTypes ( ) ) ; } Class [ ] [ ] candidates = new Class [ sigs . size ( ) ] [ ] ; sigs . copyInto ( candidates ) ; Interpreter . debug ( "Looking for most specific method: " + name ) ; int match = findMostSpecificSignature ( idealMatch , candidates ) ; if ( match == - 1 ) return null ; else return ( Method ) meths . elementAt ( match ) ; } static Method findExtendedMethod ( String name , Object [ ] args , Method [ ] methods ) { Method bestMatch = null ; Object [ ] tempArgs = new Object [ args . length ] ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method currentMethod = methods [ i ] ; if ( name . equals ( currentMethod . getName ( ) ) ) { Class [ ] parameters = currentMethod . getParameterTypes ( ) ; if ( parameters . length != args . length ) continue ; try { for ( int j = 0 ; j < parameters . length ; j ++ ) tempArgs [ j ] = NameSpace . getAssignableForm ( args [ j ] , parameters [ j ] ) ; System . arraycopy ( tempArgs , 0 , args , 0 , args . length ) ; return currentMethod ; } catch ( EvalError e ) { } } } return null ; } static Constructor findMostSpecificConstructor ( Class [ ] idealMatch , Constructor [ ] constructors ) { Class [ ] [ ] candidates = new Class [ constructors . length ] [ ] ; for ( int i = 0 ; i < candidates . length ; i ++ ) candidates [ i ] = constructors [ i ] . getParameterTypes ( ) ; int match = findMostSpecificSignature ( idealMatch , candidates ) ; if ( match == - 1 ) return null ; else return constructors [ match ] ; } static Constructor findExtendedConstructor ( Object [ ] args , Constructor [ ] constructors ) { Constructor bestMatch = null ; Object [ ] tempArgs = new Object [ args . length ] ; for ( int i = 0 ; i < constructors . length ; i ++ ) { Constructor currentConstructor = constructors [ i ] ; Class [ ] parameters = currentConstructor . getParameterTypes ( ) ; if ( parameters . length != args . length ) continue ; try { for ( int j = 0 ; j < parameters . length ; j ++ ) tempArgs [ j ] = NameSpace . getAssignableForm ( args [ j ] , parameters [ j ] ) ; System . arraycopy ( tempArgs , 0 , args , 0 , args . length ) ; return currentConstructor ; } catch ( EvalError e ) { } } return null ; } static int findMostSpecificSignature ( Class [ ] idealMatch , Class [ ] [ ] candidates ) { Class [ ] bestMatch = null ; int bestMatchIndex = - 1 ; for ( int i = 0 ; i < candidates . length ; i ++ ) { Class [ ] targetMatch = candidates [ i ] ; if ( isAssignable ( idealMatch , targetMatch ) && ( ( bestMatch == null ) || isAssignable ( targetMatch , bestMatch ) ) ) { bestMatch = targetMatch ; bestMatchIndex = i ; } } if ( bestMatch != null ) { return bestMatchIndex ; } else { Interpreter . debug ( "no match found" ) ; return - 1 ; } } static boolean isAssignable ( Class [ ] from , Class [ ] to ) { if ( from == null ) from = new Class [ 0 ] ; if ( to == null ) to = new Class [ 0 ] ; if ( from . length != to . length ) return false ; for ( int i = 0 ; i < from . length ; i ++ ) { if ( to [ i ] == null ) continue ; if ( from [ i ] == null ) { if ( ! ( to [ i ] . isPrimitive ( ) ) ) continue ; else return false ; } if ( ! isAssignableFrom ( to [ i ] , from [ i ] ) ) return false ; } return true ; } static boolean isAssignableFrom ( Class lhs , Class rhs ) { if ( lhs . isPrimitive ( ) && rhs . isPrimitive ( ) ) { if ( lhs == rhs ) return true ; if ( ( rhs == Byte . TYPE ) && ( lhs == Short . TYPE || lhs == Integer . TYPE || lhs == Long . TYPE || lhs == Float . TYPE || lhs == Double . TYPE ) ) return true ; if ( ( rhs == Short . TYPE ) && ( lhs == Integer . TYPE || lhs == Long . TYPE || lhs == Float . TYPE || lhs == Double . TYPE ) ) return true ; if ( ( rhs == Character . TYPE ) && ( lhs == Integer . TYPE || lhs == Long . TYPE || lhs == Float . TYPE || lhs == Double . TYPE ) ) return true ; if ( ( rhs == Integer . TYPE ) && ( lhs == Long . TYPE || lhs == Float . TYPE || lhs == Double . TYPE ) ) return true ; if ( ( rhs == Long . TYPE ) && ( lhs == Float . TYPE || lhs == Double . TYPE ) ) return true ; if ( ( rhs == Float . TYPE ) && ( lhs == Double . TYPE ) ) return true ; } else if ( lhs . isAssignableFrom ( rhs ) ) return true ; return false ; } private static String accessorName ( String getorset , String propName ) { return getorset + String . valueOf ( Character . toUpperCase ( propName . charAt ( 0 ) ) ) + propName . substring ( 1 ) ; } public static boolean hasObjectPropertyGetter ( Class clas , String propName ) { String getterName = accessorName ( "get" , propName ) ; try { clas . getMethod ( getterName , new Class [ 0 ] ) ; return true ; } catch ( NoSuchMethodException e ) { return false ; } } public static boolean hasObjectPropertySetter ( Class clas , String propName ) { String setterName = accessorName ( "set" , propName ) ; Class [ ] sig = new Class [ ] { clas } ; Method [ ] methods = clas . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) if ( methods [ i ] . getName ( ) . equals ( setterName ) ) return true ; return false ; } public static Object getObjectProperty ( Object obj , String propName ) throws ReflectError { String accessorName = accessorName ( "get" , propName ) ; Object [ ] args = new Object [ ] { } ; Interpreter . debug ( "property access: " ) ; try { try { return invokeObjectMethod ( null , obj , accessorName , args , null ) ; } catch ( EvalError e ) { throw new ReflectError ( "getter: " + e ) ; } } catch ( InvocationTargetException e ) { throw new ReflectError ( "Property accessor threw exception:" + e ) ; } } public static void setObjectProperty ( Object obj , String propName , Object value ) throws ReflectError , EvalError { String accessorName = accessorName ( "set" , propName ) ; Object [ ] args = new Object [ ] { value } ; Interpreter . debug ( "property access: " ) ; try { invokeObjectMethod ( null , obj , accessorName , args , null ) ; } catch ( InvocationTargetException e ) { throw new EvalError ( "Property accessor threw exception!" ) ; } } public static String normalizeClassName ( Class type ) { if ( ! type . isArray ( ) ) return type . getName ( ) ; StringBuffer className = new StringBuffer ( ) ; try { className . append ( getArrayBaseType ( type ) . getName ( ) ) ; for ( int i = 0 ; i < getArrayDimensions ( type ) ; i ++ ) className . append ( "[]" ) ; } catch ( Exception e ) { } return className . toString ( ) ; } public static int getArrayDimensions ( Class arrayClass ) { if ( ! arrayClass . isArray ( ) ) return 0 ; return arrayClass . getName ( ) . lastIndexOf ( '[' ) + 1 ; } public static Class getArrayBaseType ( Class arrayClass ) throws ReflectError { if ( ! arrayClass . isArray ( ) ) throw new ReflectError ( "The class is not an array." ) ; return arrayClass . getComponentType ( ) ; } } 	0	['36', '1', '0', '23', '109', '630', '12', '14', '14', '2', '1557', '0', '0', '0', '0.155982906', '0', '0', '42.25', '30', '3.1111', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import java . awt . event . * ; import java . util . Vector ; import org . gjt . sp . jedit . io . VFSManager ; import org . gjt . sp . jedit . io . VFS ; import org . gjt . sp . jedit . * ; public class RecentFilesMenu extends EnhancedMenu { public RecentFilesMenu ( ) { super ( "recent-files" ) ; } public void setPopupMenuVisible ( boolean b ) { if ( b ) { final View view = EditAction . getView ( this ) ; if ( getMenuComponentCount ( ) != 0 ) removeAll ( ) ; ActionListener actionListener = new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { jEdit . openFile ( view , evt . getActionCommand ( ) ) ; view . getStatus ( ) . setMessage ( null ) ; } } ; MouseListener mouseListener = new MouseAdapter ( ) { public void mouseEntered ( MouseEvent evt ) { view . getStatus ( ) . setMessage ( ( ( JMenuItem ) evt . getSource ( ) ) . getActionCommand ( ) ) ; } public void mouseExited ( MouseEvent evt ) { view . getStatus ( ) . setMessage ( null ) ; } } ; Vector recentVector = BufferHistory . getBufferHistory ( ) ; if ( recentVector . size ( ) == 0 ) { add ( GUIUtilities . loadMenuItem ( "no-recent" ) ) ; return ; } int recentFileCount = Math . min ( recentVector . size ( ) , Integer . parseInt ( jEdit . getProperty ( "history" ) ) ) ; for ( int i = recentVector . size ( ) - 1 ; i >= recentVector . size ( ) - recentFileCount ; i -- ) { String path = ( ( BufferHistory . Entry ) recentVector . elementAt ( i ) ) . path ; VFS vfs = VFSManager . getVFSForPath ( path ) ; JMenuItem menuItem = new JMenuItem ( vfs . getFileName ( path ) ) ; menuItem . setActionCommand ( path ) ; menuItem . addActionListener ( actionListener ) ; menuItem . addMouseListener ( mouseListener ) ; add ( menuItem ) ; } } super . setPopupMenuVisible ( b ) ; } } 	1	['2', '8', '0', '11', '23', '1', '3', '11', '2', '2', '100', '0', '0', '0.998835856', '0.75', '1', '2', '49', '7', '3.5', '1']
package bsh ; import java . util . Hashtable ; public class Capabilities { private static boolean accessibility = false ; public static boolean haveSwing ( ) { return classExists ( "javax.swing.JButton" ) ; } public static boolean canGenerateInterfaces ( ) { return classExists ( "java.lang.reflect.Proxy" ) ; } public static boolean haveAccessibility ( ) { return ( accessibility && classExists ( "java.lang.reflect.AccessibleObject" ) && classExists ( "bsh.reflect.ReflectManagerImpl" ) ) ; } public static void setAccessibility ( boolean b ) { accessibility = b ; } private static Hashtable classes = new Hashtable ( ) ; public static boolean classExists ( String name ) { Object c = classes . get ( name ) ; if ( c == null ) { try { c = Class . forName ( name ) ; } catch ( ClassNotFoundException e ) { } if ( c != null ) classes . put ( c , "unused" ) ; } return c != null ; } public static class Unavailable extends RuntimeException { public Unavailable ( String s ) { super ( s ) ; } } } 	0	['7', '1', '0', '5', '12', '13', '5', '0', '6', '0.5', '64', '1', '0', '0', '0.166666667', '0', '0', '7.857142857', '4', '1.5714', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import java . awt . event . * ; import java . awt . Component ; import java . util . Hashtable ; import java . util . StringTokenizer ; import org . gjt . sp . jedit . * ; public class OpenWithEncodingMenu extends EnhancedMenu { public OpenWithEncodingMenu ( ) { super ( "open-encoding" ) ; ActionListener listener = new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { Hashtable props = new Hashtable ( ) ; props . put ( "encoding" , evt . getActionCommand ( ) ) ; jEdit . showOpenFileDialog ( EditAction . getView ( ( Component ) evt . getSource ( ) ) , props ) ; } } ; String systemEncoding = System . getProperty ( "file.encoding" ) ; JMenuItem mi = new JMenuItem ( jEdit . getProperty ( "os-encoding" ) ) ; mi . setActionCommand ( systemEncoding ) ; mi . addActionListener ( listener ) ; add ( mi ) ; mi = new JMenuItem ( jEdit . getProperty ( "jedit-encoding" ) ) ; mi . setActionCommand ( jEdit . getProperty ( "buffer.encoding" , systemEncoding ) ) ; mi . addActionListener ( listener ) ; add ( mi ) ; addSeparator ( ) ; StringTokenizer st = new StringTokenizer ( jEdit . getProperty ( "encodings" ) ) ; while ( st . hasMoreTokens ( ) ) { mi = new JMenuItem ( st . nextToken ( ) ) ; mi . addActionListener ( listener ) ; add ( mi ) ; } addSeparator ( ) ; add ( GUIUtilities . loadMenuItem ( "other-encoding" ) ) ; } } 	1	['1', '8', '0', '4', '15', '0', '2', '4', '1', '2', '83', '0', '0', '1', '1', '0', '0', '82', '0', '0', '1']
package bsh ; public class ClassPathException extends EvalError { public ClassPathException ( String msg ) { super ( msg ) ; } } 	0	['1', '4', '0', '3', '2', '0', '2', '1', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . gjt . sp . jedit . search ; import javax . swing . text . Segment ; public interface SearchMatcher { int [ ] nextMatch ( Segment text ) ; String substitute ( String text ) throws Exception ; } 	1	['2', '1', '0', '4', '2', '1', '4', '0', '2', '2', '2', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '2']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; public abstract class EnhancedDialog extends JDialog { public EnhancedDialog ( Frame parent , String title , boolean modal ) { super ( parent , title , modal ) ; ( ( Container ) getLayeredPane ( ) ) . addContainerListener ( new ContainerHandler ( ) ) ; getContentPane ( ) . addContainerListener ( new ContainerHandler ( ) ) ; keyHandler = new KeyHandler ( ) ; addKeyListener ( keyHandler ) ; addWindowListener ( new WindowHandler ( ) ) ; setDefaultCloseOperation ( DO_NOTHING_ON_CLOSE ) ; } public abstract void ok ( ) ; public abstract void cancel ( ) ; protected KeyHandler keyHandler ; class ContainerHandler extends ContainerAdapter { public void componentAdded ( ContainerEvent evt ) { componentAdded ( evt . getChild ( ) ) ; } public void componentRemoved ( ContainerEvent evt ) { componentRemoved ( evt . getChild ( ) ) ; } private void componentAdded ( Component comp ) { comp . addKeyListener ( keyHandler ) ; if ( comp instanceof Container ) { Container cont = ( Container ) comp ; cont . addContainerListener ( this ) ; Component [ ] comps = cont . getComponents ( ) ; for ( int i = 0 ; i < comps . length ; i ++ ) { componentAdded ( comps [ i ] ) ; } } } private void componentRemoved ( Component comp ) { comp . removeKeyListener ( keyHandler ) ; if ( comp instanceof Container ) { Container cont = ( Container ) comp ; cont . removeContainerListener ( this ) ; Component [ ] comps = cont . getComponents ( ) ; for ( int i = 0 ; i < comps . length ; i ++ ) { componentRemoved ( comps [ i ] ) ; } } } } class KeyHandler extends KeyAdapter { public void keyPressed ( KeyEvent evt ) { if ( evt . isConsumed ( ) ) return ; if ( evt . getKeyCode ( ) == KeyEvent . VK_ENTER ) { Component comp = getFocusOwner ( ) ; while ( comp != null ) { if ( comp instanceof JComboBox ) { JComboBox combo = ( JComboBox ) comp ; if ( combo . isEditable ( ) ) { Object selected = combo . getEditor ( ) . getItem ( ) ; if ( selected != null ) combo . setSelectedItem ( selected ) ; } break ; } comp = comp . getParent ( ) ; } ok ( ) ; evt . consume ( ) ; } else if ( evt . getKeyCode ( ) == KeyEvent . VK_ESCAPE ) { cancel ( ) ; evt . consume ( ) ; } } } class WindowHandler extends WindowAdapter { public void windowClosing ( WindowEvent evt ) { cancel ( ) ; } } } 	0	['3', '6', '16', '19', '13', '3', '19', '3', '3', '1', '59', '1', '1', '0.996937213', '0.5', '0', '0', '18.33333333', '1', '0.6667', '0']
package org . gjt . sp . jedit . browser ; import java . io . * ; import org . gjt . sp . jedit . io . * ; import org . gjt . sp . jedit . jEdit ; import org . gjt . sp . jedit . MiscUtilities ; import org . gjt . sp . util . WorkRequest ; import org . gjt . sp . util . WorkThread ; public class BrowserIORequest extends WorkRequest { public static final int LIST_DIRECTORY = 0 ; public static final int DELETE = 1 ; public static final int RENAME = 2 ; public static final int MKDIR = 3 ; public BrowserIORequest ( int type , VFSBrowser browser , Object session , VFS vfs , String path1 , String path2 ) { this . type = type ; this . browser = browser ; this . session = session ; this . vfs = vfs ; this . path1 = path1 ; this . path2 = path2 ; } public void run ( ) { switch ( type ) { case LIST_DIRECTORY : listDirectory ( ) ; break ; case DELETE : delete ( ) ; break ; case RENAME : rename ( ) ; break ; case MKDIR : mkdir ( ) ; break ; } browser . endRequest ( ) ; } public String toString ( ) { String typeString ; switch ( type ) { case LIST_DIRECTORY : typeString = "LIST_DIRECTORY" ; break ; case DELETE : typeString = "DELETE" ; break ; case RENAME : typeString = "RENAME" ; break ; case MKDIR : typeString = "MKDIR" ; break ; default : typeString = "UNKNOWN!!!" ; break ; } return getClass ( ) . getName ( ) + "[type=" + typeString + ",vfs=" + vfs + ",path1=" + path1 + ",path2=" + path2 + "]" ; } private int type ; private VFSBrowser browser ; private Object session ; private VFS vfs ; private String path1 ; private String path2 ; private void listDirectory ( ) { VFS . DirectoryEntry [ ] directory = null ; String [ ] args = { path1 } ; setStatus ( jEdit . getProperty ( "vfs.status.listing-directory" , args ) ) ; try { setAbortable ( true ) ; directory = vfs . _listDirectory ( session , path1 , browser ) ; } catch ( IOException io ) { setAbortable ( false ) ; String [ ] pp = { path1 , io . toString ( ) } ; VFSManager . error ( browser , "directory-error" , pp ) ; } catch ( WorkThread . Abort a ) { } finally { try { vfs . _endVFSSession ( session , browser ) ; } catch ( IOException io ) { setAbortable ( false ) ; String [ ] pp = { path1 , io . toString ( ) } ; VFSManager . error ( browser , "directory-error" , pp ) ; } } setAbortable ( false ) ; browser . directoryLoaded ( directory ) ; } private void delete ( ) { try { setAbortable ( true ) ; String [ ] args = { path1 } ; setStatus ( jEdit . getProperty ( "vfs.status.deleting" , args ) ) ; try { if ( ! vfs . _delete ( session , path1 , browser ) ) VFSManager . error ( browser , "vfs.browser.delete-error" , args ) ; } catch ( IOException io ) { String [ ] pp = { path1 , io . toString ( ) } ; VFSManager . error ( browser , "directory-error" , pp ) ; } } catch ( WorkThread . Abort a ) { } finally { try { vfs . _endVFSSession ( session , browser ) ; } catch ( IOException io ) { String [ ] pp = { path1 , io . toString ( ) } ; VFSManager . error ( browser , "directory-error" , pp ) ; } } } private void rename ( ) { try { setAbortable ( true ) ; String [ ] args = { path1 , path2 } ; setStatus ( jEdit . getProperty ( "vfs.status.renaming" , args ) ) ; try { VFS . DirectoryEntry file = vfs . _getDirectoryEntry ( session , path2 , browser ) ; if ( file != null ) VFSManager . error ( browser , "vfs.browser.rename-exists" , new String [ ] { path2 } ) ; else { if ( ! vfs . _rename ( session , path1 , path2 , browser ) ) VFSManager . error ( browser , "vfs.browser.rename-error" , new String [ ] { path1 } ) ; } } catch ( IOException io ) { String [ ] pp = { path1 , io . toString ( ) } ; VFSManager . error ( browser , "directory-error" , pp ) ; } } catch ( WorkThread . Abort a ) { } finally { try { vfs . _endVFSSession ( session , browser ) ; } catch ( IOException io ) { String [ ] pp = { path1 , io . toString ( ) } ; VFSManager . error ( browser , "directory-error" , pp ) ; } } } private void mkdir ( ) { try { setAbortable ( true ) ; String [ ] args = { path1 } ; setStatus ( jEdit . getProperty ( "vfs.status.mkdir" , args ) ) ; try { if ( ! vfs . _mkdir ( session , path1 , browser ) ) VFSManager . error ( browser , "vfs.browser.mkdir-error" , args ) ; } catch ( IOException io ) { args [ 0 ] = io . toString ( ) ; VFSManager . error ( browser , "ioerror" , args ) ; } } catch ( WorkThread . Abort a ) { } finally { try { vfs . _endVFSSession ( session , browser ) ; } catch ( IOException io ) { String [ ] args = { io . toString ( ) } ; VFSManager . error ( browser , "ioerror" , args ) ; } } } } 	1	['7', '2', '0', '7', '27', '0', '1', '7', '3', '0.616666667', '500', '0.6', '2', '0.454545455', '0.285714286', '0', '0', '69', '5', '3.1429', '5']
package com . microstar . xml ; public class XmlException extends Exception { private String message ; private String systemId ; private int line ; private int column ; public XmlException ( String message , String systemId , int line , int column ) { this . message = message ; this . systemId = systemId ; this . line = line ; this . column = column ; } public String getMessage ( ) { return message ; } public String getSystemId ( ) { return systemId ; } public int getLine ( ) { return line ; } public int getColumn ( ) { return column ; } } 	0	['5', '3', '0', '5', '6', '2', '5', '0', '5', '0.75', '36', '1', '0', '0.80952381', '0.466666667', '1', '1', '5.4', '1', '0.8', '0']
package org . gjt . sp . jedit . gui ; import org . gjt . sp . jedit . browser . VFSBrowser ; import org . gjt . sp . jedit . msg . CreateDockableWindow ; import org . gjt . sp . jedit . search . HyperSearchResults ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . util . * ; public class DockableWindowManager extends JPanel { public static final String FLOATING = "floating" ; public static final String TOP = "top" ; public static final String LEFT = "left" ; public static final String BOTTOM = "bottom" ; public static final String RIGHT = "right" ; public DockableWindowManager ( View view ) { setLayout ( new DockableLayout ( ) ) ; this . view = view ; windows = new Hashtable ( ) ; top = new DockableWindowContainer . TabbedPane ( TOP ) ; left = new DockableWindowContainer . TabbedPane ( LEFT ) ; bottom = new DockableWindowContainer . TabbedPane ( BOTTOM ) ; right = new DockableWindowContainer . TabbedPane ( RIGHT ) ; add ( BorderLayout . NORTH , top ) ; add ( BorderLayout . WEST , left ) ; add ( BorderLayout . SOUTH , bottom ) ; add ( BorderLayout . EAST , right ) ; } public void init ( ) { Object [ ] dockables = EditBus . getNamedList ( DockableWindow . DOCKABLE_WINDOW_LIST ) ; if ( dockables != null ) { for ( int i = 0 ; i < dockables . length ; i ++ ) { String name = ( String ) dockables [ i ] ; if ( jEdit . getBooleanProperty ( name + ".auto-open" ) ) addDockableWindow ( name ) ; } } top . setCollapsed ( jEdit . getBooleanProperty ( "view.dock.top.collapsed" ) ) ; left . setCollapsed ( jEdit . getBooleanProperty ( "view.dock.left.collapsed" ) ) ; bottom . setCollapsed ( jEdit . getBooleanProperty ( "view.dock.bottom.collapsed" ) ) ; right . setCollapsed ( jEdit . getBooleanProperty ( "view.dock.right.collapsed" ) ) ; } public void showDockableWindow ( String name ) { Entry entry = ( Entry ) windows . get ( name ) ; if ( entry == null ) { Log . log ( Log . ERROR , this , "Unknown dockable window: " + name ) ; return ; } entry . container . showDockableWindow ( entry . win ) ; } public void addDockableWindow ( String name ) { Entry entry = ( Entry ) windows . get ( name ) ; if ( entry != null ) { entry . container . showDockableWindow ( entry . win ) ; return ; } String position = jEdit . getProperty ( name + ".dock-position" , FLOATING ) ; CreateDockableWindow msg = new CreateDockableWindow ( view , name , position ) ; EditBus . send ( msg ) ; DockableWindow win = msg . getDockableWindow ( ) ; if ( win == null ) { Log . log ( Log . ERROR , this , "Unknown dockable window: " + name ) ; return ; } addDockableWindow ( win , position ) ; } public void addDockableWindow ( DockableWindow win ) { String name = win . getName ( ) ; String position = jEdit . getProperty ( name + ".dock-position" , FLOATING ) ; addDockableWindow ( win , position ) ; } public void addDockableWindow ( DockableWindow win , String position ) { String name = win . getName ( ) ; if ( windows . get ( name ) != null ) { throw new IllegalArgumentException ( "This DockableWindowManager" + " already has a window named " + name ) ; } DockableWindowContainer container ; if ( position . equals ( FLOATING ) ) container = new DockableWindowContainer . Floating ( this ) ; else { if ( position . equals ( TOP ) ) container = top ; else if ( position . equals ( LEFT ) ) container = left ; else if ( position . equals ( BOTTOM ) ) container = bottom ; else if ( position . equals ( RIGHT ) ) container = right ; else throw new InternalError ( "Unknown position: " + position ) ; } Log . log ( Log . DEBUG , this , "Adding " + name + " with position " + position ) ; container . addDockableWindow ( win ) ; Entry entry = new Entry ( win , position , container ) ; windows . put ( name , entry ) ; } public void removeDockableWindow ( String name ) { Entry entry = ( Entry ) windows . get ( name ) ; if ( entry == null ) { Log . log ( Log . ERROR , this , "This DockableWindowManager" + " does not have a window named " + name ) ; return ; } Log . log ( Log . DEBUG , this , "Removing " + name + " from " + entry . container ) ; entry . container . saveDockableWindow ( entry . win ) ; entry . container . removeDockableWindow ( entry . win ) ; windows . remove ( name ) ; } public void toggleDockableWindow ( String name ) { if ( isDockableWindowVisible ( name ) ) removeDockableWindow ( name ) ; else addDockableWindow ( name ) ; } public DockableWindow getDockableWindow ( String name ) { Entry entry = ( Entry ) windows . get ( name ) ; if ( entry == null ) return null ; else return entry . win ; } public boolean isDockableWindowVisible ( String name ) { Entry entry = ( Entry ) windows . get ( name ) ; if ( entry == null ) return false ; else return entry . container . isDockableWindowVisible ( entry . win ) ; } public void close ( ) { Enumeration enum = windows . elements ( ) ; while ( enum . hasMoreElements ( ) ) { Entry entry = ( Entry ) enum . nextElement ( ) ; entry . container . saveDockableWindow ( entry . win ) ; entry . container . removeDockableWindow ( entry . win ) ; } top . saveDimension ( ) ; left . saveDimension ( ) ; bottom . saveDimension ( ) ; right . saveDimension ( ) ; } public DockableWindowContainer . TabbedPane getTopDockingArea ( ) { return top ; } public DockableWindowContainer . TabbedPane getLeftDockingArea ( ) { return left ; } public DockableWindowContainer . TabbedPane getBottomDockingArea ( ) { return bottom ; } public DockableWindowContainer . TabbedPane getRightDockingArea ( ) { return right ; } public void propertiesChanged ( ) { alternateLayout = jEdit . getBooleanProperty ( "view.docking.alternateLayout" ) ; left . propertiesChanged ( ) ; right . propertiesChanged ( ) ; top . propertiesChanged ( ) ; bottom . propertiesChanged ( ) ; Enumeration enum = windows . elements ( ) ; while ( enum . hasMoreElements ( ) ) { Entry entry = ( Entry ) enum . nextElement ( ) ; if ( entry . container instanceof DockableWindowContainer . Floating ) { SwingUtilities . updateComponentTreeUI ( ( ( JFrame ) entry . container ) . getRootPane ( ) ) ; } } revalidate ( ) ; } private View view ; private Hashtable windows ; private boolean alternateLayout ; private DockableWindowContainer . TabbedPane left ; private DockableWindowContainer . TabbedPane right ; private DockableWindowContainer . TabbedPane top ; private DockableWindowContainer . TabbedPane bottom ; static { EditBus . addToBus ( new DefaultFactory ( ) ) ; EditBus . addToNamedList ( DockableWindow . DOCKABLE_WINDOW_LIST , "vfs.browser" ) ; EditBus . addToNamedList ( DockableWindow . DOCKABLE_WINDOW_LIST , "hypersearch-results" ) ; EditBus . addToNamedList ( DockableWindow . DOCKABLE_WINDOW_LIST , "log-viewer" ) ; } class DockableLayout implements LayoutManager2 { Container top , left , bottom , right ; Component center ; public void addLayoutComponent ( String name , Component comp ) { addLayoutComponent ( comp , name ) ; } public void addLayoutComponent ( Component comp , Object cons ) { if ( BorderLayout . NORTH . equals ( cons ) ) top = ( Container ) comp ; else if ( BorderLayout . WEST . equals ( cons ) ) left = ( Container ) comp ; else if ( BorderLayout . SOUTH . equals ( cons ) ) bottom = ( Container ) comp ; else if ( BorderLayout . EAST . equals ( cons ) ) right = ( Container ) comp ; else center = comp ; } public void removeLayoutComponent ( Component comp ) { if ( top == comp ) top = null ; else if ( left == comp ) left = null ; else if ( bottom == comp ) bottom = null ; else if ( right == comp ) right = null ; else if ( center == comp ) center = null ; } public Dimension preferredLayoutSize ( Container parent ) { Dimension prefSize = new Dimension ( 0 , 0 ) ; Dimension _top = top . getPreferredSize ( ) ; Dimension _left = left . getPreferredSize ( ) ; Dimension _bottom = bottom . getPreferredSize ( ) ; Dimension _right = right . getPreferredSize ( ) ; Dimension _center = ( center == null ? new Dimension ( 0 , 0 ) : center . getPreferredSize ( ) ) ; prefSize . height = _top . height + _bottom . height + _center . height ; prefSize . width = _left . width + _right . width + _center . width ; return prefSize ; } public Dimension minimumLayoutSize ( Container parent ) { return preferredLayoutSize ( parent ) ; } public Dimension maximumLayoutSize ( Container parent ) { return new Dimension ( Integer . MAX_VALUE , Integer . MAX_VALUE ) ; } public void layoutContainer ( Container parent ) { Dimension size = parent . getSize ( ) ; Dimension prefSize = new Dimension ( 0 , 0 ) ; Dimension _top = top . getPreferredSize ( ) ; Dimension _left = left . getPreferredSize ( ) ; Dimension _bottom = bottom . getPreferredSize ( ) ; Dimension _right = right . getPreferredSize ( ) ; Dimension _center = ( center == null ? new Dimension ( 0 , 0 ) : center . getPreferredSize ( ) ) ; if ( _left . width + _right . width > size . width ) { if ( left . getComponentCount ( ) == 0 ) _left . width = 0 ; else { _left . width = DockableWindowContainer . TabbedPane . SPLITTER_WIDTH ; } if ( right . getComponentCount ( ) == 0 ) _right . width = 0 ; else { _right . width = DockableWindowContainer . TabbedPane . SPLITTER_WIDTH ; } } if ( _top . height + _bottom . height > size . height ) { if ( top . getComponentCount ( ) == 0 ) _top . height = 0 ; else { _top . height = DockableWindowContainer . TabbedPane . SPLITTER_WIDTH ; } if ( bottom . getComponentCount ( ) == 0 ) _bottom . height = 0 ; else { _bottom . height = DockableWindowContainer . TabbedPane . SPLITTER_WIDTH ; } } int _width = size . width - _left . width - _right . width ; int _height = size . height - _top . height - _bottom . height ; if ( alternateLayout ) { top . setBounds ( 0 , 0 , size . width , _top . height ) ; bottom . setBounds ( 0 , size . height - _bottom . height , size . width , _bottom . height ) ; left . setBounds ( 0 , _top . height , _left . width , _height ) ; right . setBounds ( size . width - _right . width , _top . height , _right . width , _height ) ; } else { left . setBounds ( 0 , 0 , _left . width , size . height ) ; right . setBounds ( size . width - _right . width , 0 , _right . width , size . height ) ; top . setBounds ( _left . width , 0 , _width , _top . height ) ; bottom . setBounds ( _left . width , size . height - _bottom . height , _width , _bottom . height ) ; } if ( center != null ) center . setBounds ( _left . width , _top . height , _width , _height ) ; } public float getLayoutAlignmentX ( Container target ) { return 0.5f ; } public float getLayoutAlignmentY ( Container target ) { return 0.5f ; } public void invalidateLayout ( Container target ) { } } static class Entry { DockableWindow win ; String position ; DockableWindowContainer container ; Entry ( DockableWindow win , String position , DockableWindowContainer container ) { this . win = win ; this . position = position ; this . container = container ; } } static class DefaultFactory implements EBComponent { public void handleMessage ( EBMessage msg ) { if ( msg instanceof CreateDockableWindow ) { CreateDockableWindow cmsg = ( CreateDockableWindow ) msg ; String name = cmsg . getDockableWindowName ( ) ; if ( name . equals ( "vfs.browser" ) ) { cmsg . setDockableWindow ( new VFSBrowser ( cmsg . getView ( ) , null ) ) ; } else if ( name . equals ( "hypersearch-results" ) ) { cmsg . setDockableWindow ( new HyperSearchResults ( cmsg . getView ( ) ) ) ; } else if ( name . equals ( "log-viewer" ) ) { cmsg . setDockableWindow ( new LogViewer ( ) ) ; } } } } } 	1	['18', '5', '0', '16', '62', '31', '5', '14', '16', '0.794117647', '551', '0.583333333', '5', '0.976083707', '0.317647059', '0', '0', '28.94444444', '7', '1.9444', '8']
package org . gjt . sp . jedit . msg ; import org . gjt . sp . jedit . EBComponent ; import org . gjt . sp . jedit . EBMessage ; public class PropertiesChanged extends EBMessage . NonVetoable { public PropertiesChanged ( EBComponent source ) { super ( source ) ; } } 	0	['1', '3', '0', '8', '2', '0', '6', '2', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . gjt . sp . jedit . options ; import javax . swing . border . * ; import javax . swing . event . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . io . File ; import java . net . * ; import java . util . * ; import org . gjt . sp . jedit . browser . VFSBrowser ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class ToolBarOptionPane extends AbstractOptionPane { public ToolBarOptionPane ( ) { super ( "toolbar" ) ; } protected void _init ( ) { setLayout ( new BorderLayout ( ) ) ; JPanel panel = new JPanel ( new GridLayout ( 2 , 1 ) ) ; showToolbar = new JCheckBox ( jEdit . getProperty ( "options.toolbar.showToolbar" ) ) ; showToolbar . setSelected ( jEdit . getBooleanProperty ( "view.showToolbar" ) ) ; panel . add ( showToolbar ) ; panel . add ( new JLabel ( jEdit . getProperty ( "options.toolbar.caption" ) ) ) ; add ( BorderLayout . NORTH , panel ) ; String toolbar = jEdit . getProperty ( "view.toolbar" ) ; StringTokenizer st = new StringTokenizer ( toolbar ) ; listModel = new DefaultListModel ( ) ; while ( st . hasMoreTokens ( ) ) { String actionName = ( String ) st . nextToken ( ) ; String label = ContextOptionPane . getActionLabel ( actionName ) ; if ( label == null ) continue ; Icon icon ; String iconName ; if ( actionName . equals ( "-" ) ) { iconName = null ; icon = null ; } else { iconName = jEdit . getProperty ( actionName + ".icon" ) ; if ( iconName == null ) continue ; icon = GUIUtilities . loadIcon ( iconName ) ; } listModel . addElement ( new Button ( actionName , iconName , icon , label ) ) ; } list = new JList ( listModel ) ; list . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; list . addListSelectionListener ( new ListHandler ( ) ) ; list . setCellRenderer ( new ButtonCellRenderer ( ) ) ; add ( BorderLayout . CENTER , new JScrollPane ( list ) ) ; JPanel buttons = new JPanel ( ) ; buttons . setBorder ( new EmptyBorder ( 3 , 0 , 0 , 0 ) ) ; buttons . setLayout ( new BoxLayout ( buttons , BoxLayout . X_AXIS ) ) ; buttons . add ( Box . createGlue ( ) ) ; ActionHandler actionHandler = new ActionHandler ( ) ; add = new JButton ( jEdit . getProperty ( "options.toolbar.add" ) ) ; add . addActionListener ( actionHandler ) ; buttons . add ( add ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; remove = new JButton ( jEdit . getProperty ( "options.toolbar.remove" ) ) ; remove . addActionListener ( actionHandler ) ; buttons . add ( remove ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; moveUp = new JButton ( jEdit . getProperty ( "options.toolbar.moveUp" ) ) ; moveUp . addActionListener ( actionHandler ) ; buttons . add ( moveUp ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; moveDown = new JButton ( jEdit . getProperty ( "options.toolbar.moveDown" ) ) ; moveDown . addActionListener ( actionHandler ) ; buttons . add ( moveDown ) ; buttons . add ( Box . createGlue ( ) ) ; updateButtons ( ) ; add ( BorderLayout . SOUTH , buttons ) ; EditAction [ ] actions = jEdit . getActions ( ) ; Vector vector = new Vector ( actions . length ) ; for ( int i = 0 ; i < actions . length ; i ++ ) { String actionName = actions [ i ] . getName ( ) ; String label = jEdit . getProperty ( actionName + ".label" ) ; if ( label == null ) continue ; vector . addElement ( new Button ( actionName , null , null , label ) ) ; } MiscUtilities . quicksort ( vector , new ButtonCompare ( ) ) ; actionsList = new DefaultListModel ( ) ; actionsList . ensureCapacity ( vector . size ( ) ) ; for ( int i = 0 ; i < vector . size ( ) ; i ++ ) { actionsList . addElement ( vector . elementAt ( i ) ) ; } iconList = new DefaultComboBoxModel ( ) ; st = new StringTokenizer ( jEdit . getProperty ( "icons" ) ) ; while ( st . hasMoreElements ( ) ) { String icon = st . nextToken ( ) ; iconList . addElement ( new IconListEntry ( GUIUtilities . loadIcon ( icon ) , icon ) ) ; } } class ButtonCompare implements MiscUtilities . Compare { public int compare ( Object obj1 , Object obj2 ) { return ( ( Button ) obj1 ) . label . toLowerCase ( ) . compareTo ( ( ( Button ) obj2 ) . label . toLowerCase ( ) ) ; } } protected void _save ( ) { jEdit . setBooleanProperty ( "view.showToolbar" , showToolbar . isSelected ( ) ) ; StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < listModel . getSize ( ) ; i ++ ) { if ( i != 0 ) buf . append ( ' ' ) ; Button button = ( Button ) listModel . elementAt ( i ) ; buf . append ( button . actionName ) ; jEdit . setProperty ( button . actionName + ".icon" , button . iconName ) ; } jEdit . setProperty ( "view.toolbar" , buf . toString ( ) ) ; } private JCheckBox showToolbar ; private DefaultListModel listModel ; private JList list ; private JButton add ; private JButton remove ; private JButton moveUp , moveDown ; private DefaultListModel actionsList ; private DefaultComboBoxModel iconList ; private void updateButtons ( ) { int index = list . getSelectedIndex ( ) ; remove . setEnabled ( index != - 1 && listModel . getSize ( ) != 0 ) ; moveUp . setEnabled ( index > 0 ) ; moveDown . setEnabled ( index != - 1 && index != listModel . getSize ( ) - 1 ) ; } static class Button { String actionName ; String iconName ; Icon icon ; String label ; Button ( String actionName , String iconName , Icon icon , String label ) { this . actionName = actionName ; this . iconName = iconName ; this . icon = icon ; if ( label . equals ( "-" ) ) this . label = label ; else this . label = GUIUtilities . prettifyMenuLabel ( label ) ; } public String toString ( ) { return label ; } } static class IconListEntry { Icon icon ; String name ; IconListEntry ( Icon icon , String name ) { this . icon = icon ; this . name = name ; } } static class ButtonCellRenderer extends DefaultListCellRenderer { public Component getListCellRendererComponent ( JList list , Object value , int index , boolean isSelected , boolean cellHasFocus ) { super . getListCellRendererComponent ( list , value , index , isSelected , cellHasFocus ) ; Button button = ( Button ) value ; setText ( button . label ) ; setIcon ( button . icon ) ; return this ; } } static class IconCellRenderer extends DefaultListCellRenderer { public Component getListCellRendererComponent ( JList list , Object value , int index , boolean isSelected , boolean cellHasFocus ) { super . getListCellRendererComponent ( list , value , index , isSelected , cellHasFocus ) ; IconListEntry icon = ( IconListEntry ) value ; setText ( icon . name ) ; setIcon ( icon . icon ) ; return this ; } } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == add ) { ToolBarAddDialog dialog = new ToolBarAddDialog ( ToolBarOptionPane . this , actionsList , iconList ) ; Button selection = dialog . getSelection ( ) ; if ( selection == null ) return ; int index = list . getSelectedIndex ( ) ; if ( index == - 1 ) index = listModel . getSize ( ) ; else index ++ ; listModel . insertElementAt ( selection , index ) ; list . setSelectedIndex ( index ) ; } else if ( source == remove ) { int index = list . getSelectedIndex ( ) ; listModel . removeElementAt ( index ) ; updateButtons ( ) ; } else if ( source == moveUp ) { int index = list . getSelectedIndex ( ) ; Object selected = list . getSelectedValue ( ) ; listModel . removeElementAt ( index ) ; listModel . insertElementAt ( selected , index - 1 ) ; list . setSelectedIndex ( index - 1 ) ; } else if ( source == moveDown ) { int index = list . getSelectedIndex ( ) ; Object selected = list . getSelectedValue ( ) ; listModel . removeElementAt ( index ) ; listModel . insertElementAt ( selected , index + 1 ) ; list . setSelectedIndex ( index + 1 ) ; } } } class ListHandler implements ListSelectionListener { public void valueChanged ( ListSelectionEvent evt ) { updateButtons ( ) ; } } } class ToolBarAddDialog extends EnhancedDialog { public ToolBarAddDialog ( Component comp , ListModel actionsListModel , ComboBoxModel iconListModel ) { super ( JOptionPane . getFrameForComponent ( comp ) , jEdit . getProperty ( "options.toolbar.add.title" ) , true ) ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; content . add ( BorderLayout . NORTH , new JLabel ( jEdit . getProperty ( "options.toolbar.add.caption" ) ) ) ; JPanel mainPanel = new JPanel ( new BorderLayout ( 0 , 6 ) ) ; JPanel radioPanel = new JPanel ( new GridLayout ( 2 , 1 ) ) ; ActionHandler actionHandler = new ActionHandler ( ) ; ButtonGroup grp = new ButtonGroup ( ) ; separator = new JRadioButton ( jEdit . getProperty ( "options.toolbar" + ".add.separator" ) ) ; separator . setSelected ( true ) ; separator . addActionListener ( actionHandler ) ; grp . add ( separator ) ; radioPanel . add ( separator ) ; action = new JRadioButton ( jEdit . getProperty ( "options.toolbar" + ".add.action" ) ) ; action . addActionListener ( actionHandler ) ; grp . add ( action ) ; radioPanel . add ( action ) ; mainPanel . add ( BorderLayout . NORTH , radioPanel ) ; actionsList = new JList ( actionsListModel ) ; actionsList . setVisibleRowCount ( 8 ) ; JPanel centerPanel = new JPanel ( new BorderLayout ( 0 , 3 ) ) ; centerPanel . add ( BorderLayout . NORTH , new JScrollPane ( actionsList ) ) ; macro = new JRadioButton ( jEdit . getProperty ( "options.toolbar" + ".add.macro" ) ) ; macro . addActionListener ( actionHandler ) ; grp . add ( macro ) ; centerPanel . add ( BorderLayout . CENTER , macro ) ; macrosList = new JList ( Macros . getMacroList ( ) ) ; macrosList . setVisibleRowCount ( 8 ) ; centerPanel . add ( BorderLayout . SOUTH , new JScrollPane ( macrosList ) ) ; mainPanel . add ( BorderLayout . CENTER , centerPanel ) ; JPanel iconPanel = new JPanel ( new BorderLayout ( 0 , 3 ) ) ; JPanel labelPanel = new JPanel ( new GridLayout ( 2 , 1 ) ) ; labelPanel . setBorder ( new EmptyBorder ( 0 , 0 , 0 , 12 ) ) ; JPanel compPanel = new JPanel ( new GridLayout ( 2 , 1 ) ) ; grp = new ButtonGroup ( ) ; labelPanel . add ( builtin = new JRadioButton ( jEdit . getProperty ( "options.toolbar.add.builtin" ) ) ) ; builtin . addActionListener ( actionHandler ) ; builtin . setSelected ( true ) ; grp . add ( builtin ) ; labelPanel . add ( file = new JRadioButton ( jEdit . getProperty ( "options.toolbar.add.file" ) ) ) ; grp . add ( file ) ; file . addActionListener ( actionHandler ) ; iconPanel . add ( BorderLayout . WEST , labelPanel ) ; builtinCombo = new JComboBox ( iconListModel ) ; builtinCombo . setRenderer ( new ToolBarOptionPane . IconCellRenderer ( ) ) ; compPanel . add ( builtinCombo ) ; fileButton = new JButton ( jEdit . getProperty ( "options.toolbar.add.no-icon" ) ) ; fileButton . setMargin ( new Insets ( 1 , 1 , 1 , 1 ) ) ; fileButton . setIcon ( GUIUtilities . loadIcon ( "Blank24.gif" ) ) ; fileButton . setHorizontalAlignment ( SwingConstants . LEFT ) ; fileButton . addActionListener ( actionHandler ) ; compPanel . add ( fileButton ) ; iconPanel . add ( BorderLayout . CENTER , compPanel ) ; mainPanel . add ( BorderLayout . SOUTH , iconPanel ) ; content . add ( BorderLayout . CENTER , mainPanel ) ; JPanel southPanel = new JPanel ( ) ; southPanel . setLayout ( new BoxLayout ( southPanel , BoxLayout . X_AXIS ) ) ; southPanel . setBorder ( new EmptyBorder ( 12 , 0 , 0 , 0 ) ) ; southPanel . add ( Box . createGlue ( ) ) ; ok = new JButton ( jEdit . getProperty ( "common.ok" ) ) ; ok . addActionListener ( actionHandler ) ; getRootPane ( ) . setDefaultButton ( ok ) ; southPanel . add ( ok ) ; southPanel . add ( Box . createHorizontalStrut ( 6 ) ) ; cancel = new JButton ( jEdit . getProperty ( "common.cancel" ) ) ; cancel . addActionListener ( actionHandler ) ; southPanel . add ( cancel ) ; southPanel . add ( Box . createGlue ( ) ) ; content . add ( BorderLayout . SOUTH , southPanel ) ; updateEnabled ( ) ; pack ( ) ; setLocationRelativeTo ( JOptionPane . getFrameForComponent ( comp ) ) ; show ( ) ; } public void ok ( ) { isOK = true ; dispose ( ) ; } public void cancel ( ) { dispose ( ) ; } public ToolBarOptionPane . Button getSelection ( ) { if ( ! isOK ) return null ; if ( separator . isSelected ( ) ) return new ToolBarOptionPane . Button ( "-" , null , null , "-" ) ; else { Icon icon ; String iconName ; if ( builtin . isSelected ( ) ) { ToolBarOptionPane . IconListEntry selectedIcon = ( ToolBarOptionPane . IconListEntry ) builtinCombo . getSelectedItem ( ) ; icon = selectedIcon . icon ; iconName = selectedIcon . name ; } else { icon = fileButton . getIcon ( ) ; iconName = fileIcon ; if ( iconName == null ) iconName = "Blank24.gif" ; } String label ; String actionName ; if ( action . isSelected ( ) ) { ToolBarOptionPane . Button button = ( ToolBarOptionPane . Button ) actionsList . getSelectedValue ( ) ; label = button . label ; actionName = button . actionName ; } else if ( macro . isSelected ( ) ) { actionName = "play-macro@" + macrosList . getSelectedValue ( ) ; label = ContextOptionPane . getActionLabel ( actionName ) ; } else throw new InternalError ( ) ; return new ToolBarOptionPane . Button ( actionName , iconName , icon , label ) ; } } private boolean isOK ; private JRadioButton separator , action , macro ; private JList actionsList , macrosList ; private JRadioButton builtin ; private JComboBox builtinCombo ; private JRadioButton file ; private JButton fileButton ; private String fileIcon ; private JButton ok , cancel ; private void updateEnabled ( ) { actionsList . setEnabled ( action . isSelected ( ) ) ; macrosList . setEnabled ( macro . isSelected ( ) ) ; boolean iconControlsEnabled = ! separator . isSelected ( ) ; builtin . setEnabled ( iconControlsEnabled ) ; file . setEnabled ( iconControlsEnabled ) ; builtinCombo . setEnabled ( iconControlsEnabled && builtin . isSelected ( ) ) ; fileButton . setEnabled ( iconControlsEnabled && file . isSelected ( ) ) ; } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source instanceof JRadioButton ) updateEnabled ( ) ; else if ( source == ok ) ok ( ) ; else if ( source == cancel ) cancel ( ) ; else if ( source == builtin || source == file ) updateEnabled ( ) ; else if ( source == fileButton ) { String directory ; if ( fileIcon == null ) directory = null ; else directory = MiscUtilities . getParentOfPath ( fileIcon ) ; String paths [ ] = GUIUtilities . showVFSFileDialog ( null , directory , VFSBrowser . OPEN_DIALOG , false ) ; if ( paths == null ) return ; fileIcon = "file:" + paths [ 0 ] ; try { fileButton . setIcon ( new ImageIcon ( new URL ( fileIcon ) ) ) ; } catch ( MalformedURLException mf ) { Log . log ( Log . ERROR , this , mf ) ; } fileButton . setText ( MiscUtilities . getFileName ( fileIcon ) ) ; } } } } 	1	['13', '6', '0', '14', '75', '44', '4', '13', '1', '0.814814815', '517', '1', '0', '0.982195846', '0.5', '3', '5', '38.07692308', '12', '2.3077', '1']
package gnu . regexp ; import java . io . Serializable ; abstract class REToken implements Serializable { protected REToken next = null ; protected REToken uncle = null ; protected int subIndex ; protected REToken ( int aSubIndex ) { subIndex = aSubIndex ; } int getMinimumLength ( ) { return 0 ; } void setUncle ( REToken anUncle ) { uncle = anUncle ; } abstract boolean match ( CharIndexed input , REMatch mymatch ) ; protected boolean next ( CharIndexed input , REMatch mymatch ) { if ( next == null ) { if ( uncle == null ) { return true ; } else { return uncle . match ( input , mymatch ) ; } } else { return next . match ( input , mymatch ) ; } } boolean chain ( REToken token ) { next = token ; return true ; } void dump ( StringBuffer os ) { } void dumpAll ( StringBuffer os ) { dump ( os ) ; if ( next != null ) next . dumpAll ( os ) ; } } 	0	['8', '1', '13', '15', '9', '12', '13', '2', '0', '0.761904762', '66', '1', '2', '0', '0.354166667', '0', '0', '6.875', '3', '1.25', '0']
package org . gjt . sp . jedit ; import com . microstar . xml . * ; import java . io . * ; import java . util . Stack ; import org . gjt . sp . util . Log ; class ActionListHandler extends HandlerBase { ActionListHandler ( String path , boolean plugin ) { this . path = path ; this . plugin = plugin ; stateStack = new Stack ( ) ; } public Object resolveEntity ( String publicId , String systemId ) { if ( "actions.dtd" . equals ( systemId ) ) { try { return new BufferedReader ( new InputStreamReader ( getClass ( ) . getResourceAsStream ( "actions.dtd" ) ) ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , this , "Error while opening" + " actions.dtd:" ) ; Log . log ( Log . ERROR , this , e ) ; } } return null ; } public void attribute ( String aname , String value , boolean isSpecified ) { aname = ( aname == null ) ? null : aname . intern ( ) ; value = ( value == null ) ? null : value . intern ( ) ; if ( aname == "NAME" ) actionName = value ; else if ( aname == "NO_REPEAT" ) noRepeat = ( value == "TRUE" ) ; else if ( aname == "NO_RECORD" ) noRecord = ( value == "TRUE" ) ; } public void doctypeDecl ( String name , String publicId , String systemId ) throws Exception { if ( "ACTIONS" . equals ( name ) ) return ; Log . log ( Log . ERROR , this , path + ": DOCTYPE must be ACTIONS" ) ; } public void charData ( char [ ] c , int off , int len ) { String tag = peekElement ( ) ; String text = new String ( c , off , len ) ; if ( tag == "CODE" ) { code = text ; } else if ( tag == "IS_SELECTED" ) { isSelected = text ; } } public void startElement ( String tag ) { tag = pushElement ( tag ) ; if ( tag == "ACTION" ) { code = null ; isSelected = null ; } } public void endElement ( String name ) { if ( name == null ) return ; String tag = peekElement ( ) ; if ( name . equals ( tag ) ) { if ( tag == "ACTION" ) { jEdit . addAction ( new BeanShellAction ( actionName , plugin , code , isSelected , noRepeat , noRecord ) ) ; } popElement ( ) ; } else { throw new InternalError ( ) ; } } public void startDocument ( ) { try { pushElement ( null ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } private String path ; private boolean plugin ; private String actionName ; private String code ; private String isSelected ; private boolean noRepeat ; private boolean noRecord ; private Stack stateStack ; private String pushElement ( String name ) { name = ( name == null ) ? null : name . intern ( ) ; stateStack . push ( name ) ; return name ; } private String peekElement ( ) { return ( String ) stateStack . peek ( ) ; } private String popElement ( ) { return ( String ) stateStack . pop ( ) ; } } 	1	['11', '2', '0', '5', '31', '31', '1', '5', '7', '0.8', '231', '1', '0', '0.565217391', '0.4', '1', '3', '19.27272727', '8', '2.2727', '2']
package bsh ; public interface ParserTreeConstants { public int JJTVOID = 0 ; public int JJTMETHODDECLARATION = 1 ; public int JJTIMPORTDECLARATION = 2 ; public int JJTVARIABLEDECLARATOR = 3 ; public int JJTARRAYINITIALIZER = 4 ; public int JJTFORMALPARAMETERS = 5 ; public int JJTFORMALPARAMETER = 6 ; public int JJTTYPE = 7 ; public int JJTRETURNTYPE = 8 ; public int JJTPRIMITIVETYPE = 9 ; public int JJTAMBIGUOUSNAME = 10 ; public int JJTASSIGNMENT = 11 ; public int JJTTERNARYEXPRESSION = 12 ; public int JJTBINARYEXPRESSION = 13 ; public int JJTUNARYEXPRESSION = 14 ; public int JJTCASTEXPRESSION = 15 ; public int JJTPRIMARYEXPRESSION = 16 ; public int JJTMETHODINVOCATION = 17 ; public int JJTPRIMARYSUFFIX = 18 ; public int JJTLHSPRIMARYEXPRESSION = 19 ; public int JJTLHSPRIMARYSUFFIX = 20 ; public int JJTLITERAL = 21 ; public int JJTARGUMENTS = 22 ; public int JJTALLOCATIONEXPRESSION = 23 ; public int JJTARRAYDIMENSIONS = 24 ; public int JJTBLOCK = 25 ; public int JJTSWITCHSTATEMENT = 26 ; public int JJTSWITCHLABEL = 27 ; public int JJTIFSTATEMENT = 28 ; public int JJTWHILESTATEMENT = 29 ; public int JJTFORSTATEMENT = 30 ; public int JJTTYPEDVARIABLEDECLARATION = 31 ; public int JJTSTATEMENTEXPRESSIONLIST = 32 ; public int JJTRETURNSTATEMENT = 33 ; public int JJTTHROWSTATEMENT = 34 ; public int JJTTRYSTATEMENT = 35 ; public String [ ] jjtNodeName = { "void" , "MethodDeclaration" , "ImportDeclaration" , "VariableDeclarator" , "ArrayInitializer" , "FormalParameters" , "FormalParameter" , "Type" , "ReturnType" , "PrimitiveType" , "AmbiguousName" , "Assignment" , "TernaryExpression" , "BinaryExpression" , "UnaryExpression" , "CastExpression" , "PrimaryExpression" , "MethodInvocation" , "PrimarySuffix" , "LHSPrimaryExpression" , "LHSPrimarySuffix" , "Literal" , "Arguments" , "AllocationExpression" , "ArrayDimensions" , "Block" , "SwitchStatement" , "SwitchLabel" , "IfStatement" , "WhileStatement" , "ForStatement" , "TypedVariableDeclaration" , "StatementExpressionList" , "ReturnStatement" , "ThrowStatement" , "TryStatement" , } ; } 	0	['1', '1', '0', '2', '1', '0', '2', '0', '0', '2', '186', '0', '0', '0', '0', '0', '0', '148', '0', '0', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . text . BadLocationException ; import javax . swing . text . Element ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . util . * ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class MarkersMenu extends EnhancedMenu { public MarkersMenu ( ) { super ( "markers" ) ; } public void setPopupMenuVisible ( boolean b ) { if ( b ) { final View view = EditAction . getView ( this ) ; if ( getMenuComponentCount ( ) != 0 ) { for ( int i = getMenuComponentCount ( ) - 1 ; i >= 0 ; i -- ) { Component comp = getMenuComponent ( i ) ; if ( comp instanceof JSeparator ) break ; else remove ( comp ) ; } } Buffer buffer = view . getBuffer ( ) ; Element map = buffer . getDefaultRootElement ( ) ; Vector markers = buffer . getMarkers ( ) ; if ( markers . size ( ) == 0 ) { JMenuItem mi = new JMenuItem ( jEdit . getProperty ( "no-markers.label" ) ) ; mi . setEnabled ( false ) ; add ( mi ) ; super . setPopupMenuVisible ( b ) ; return ; } JMenu current = this ; for ( int i = 0 ; i < markers . size ( ) ; i ++ ) { final Marker marker = ( Marker ) markers . elementAt ( i ) ; int lineNo = map . getElementIndex ( marker . getPosition ( ) ) ; if ( current . getItemCount ( ) >= 20 ) { JMenu newCurrent = new JMenu ( jEdit . getProperty ( "common.more" ) ) ; current . add ( newCurrent ) ; current = newCurrent ; } JMenuItem mi = new MarkersMenuItem ( buffer , lineNo , marker . getShortcut ( ) ) ; mi . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { view . getTextArea ( ) . setCaretPosition ( marker . getPosition ( ) ) ; } } ) ; current . add ( mi ) ; } } super . setPopupMenuVisible ( b ) ; } static class MarkersMenuItem extends JMenuItem { MarkersMenuItem ( Buffer buffer , int lineNo , char shortcut ) { Element line = buffer . getDefaultRootElement ( ) . getElement ( lineNo ) ; try { int start = line . getStartOffset ( ) ; String text = buffer . getText ( start , line . getEndOffset ( ) - start - 1 ) ; text = text . trim ( ) ; if ( text . length ( ) == 0 ) text = jEdit . getProperty ( "markers.blank-line" ) ; setText ( lineNo + ": " + text ) ; } catch ( BadLocationException ble ) { Log . log ( Log . ERROR , this , ble ) ; } shortcutProp = "goto-marker.shortcut" ; MarkersMenuItem . this . shortcut = shortcut ; } public Dimension getPreferredSize ( ) { Dimension d = super . getPreferredSize ( ) ; String shortcut = getShortcut ( ) ; if ( shortcut != null ) { d . width += ( getFontMetrics ( acceleratorFont ) . stringWidth ( shortcut ) + 10 ) ; } return d ; } public void paint ( Graphics g ) { super . paint ( g ) ; String shortcut = getShortcut ( ) ; if ( shortcut != null ) { g . setFont ( acceleratorFont ) ; g . setColor ( getModel ( ) . isArmed ( ) ? acceleratorSelectionForeground : acceleratorForeground ) ; FontMetrics fm = g . getFontMetrics ( ) ; Insets insets = getInsets ( ) ; g . drawString ( shortcut , getWidth ( ) - ( fm . stringWidth ( shortcut ) + insets . right + insets . left ) , getFont ( ) . getSize ( ) + ( insets . top - 1 ) ) ; } } private String shortcutProp ; private char shortcut ; private static Font acceleratorFont ; private static Color acceleratorForeground ; private static Color acceleratorSelectionForeground ; private String getShortcut ( ) { if ( shortcut == '\0' ) return null ; else { String shortcutPrefix = jEdit . getProperty ( shortcutProp ) ; if ( shortcutPrefix == null ) return null ; else { return shortcutPrefix + " " + shortcut ; } } } static { acceleratorFont = UIManager . getFont ( "MenuItem.acceleratorFont" ) ; acceleratorFont = new Font ( "Monospaced" , acceleratorFont . getStyle ( ) , acceleratorFont . getSize ( ) ) ; acceleratorForeground = UIManager . getColor ( "MenuItem.acceleratorForeground" ) ; acceleratorSelectionForeground = UIManager . getColor ( "MenuItem.acceleratorSelectionForeground" ) ; } } } 	1	['2', '8', '0', '9', '25', '1', '2', '8', '2', '2', '127', '0', '0', '0.998835856', '0.75', '3', '4', '62.5', '9', '4.5', '2']
package bsh ; import java . io . Reader ; class ParserTokenManager implements ParserConstants { private final int jjStopStringLiteralDfa_0 ( int pos , long active0 , long active1 ) { switch ( pos ) { case 0 : if ( ( active0 & 0x3eL ) != 0L ) return 0 ; if ( ( active1 & 0x400040000000L ) != 0L ) return 56 ; if ( ( active1 & 0x20L ) != 0L ) return 11 ; if ( ( active0 & 0x3fffffffff800L ) != 0L ) { jjmatchedKind = 58 ; return 35 ; } return - 1 ; case 1 : if ( ( active0 & 0x3ffffbf9ff800L ) != 0L ) { if ( jjmatchedPos != 1 ) { jjmatchedKind = 58 ; jjmatchedPos = 1 ; } return 35 ; } if ( ( active0 & 0x40600000L ) != 0L ) return 35 ; return - 1 ; case 2 : if ( ( active0 & 0x37fe9afdff800L ) != 0L ) { if ( jjmatchedPos != 2 ) { jjmatchedKind = 58 ; jjmatchedPos = 2 ; } return 35 ; } if ( ( active0 & 0x801610000000L ) != 0L ) return 35 ; return - 1 ; case 3 : if ( ( active0 & 0x140282082c000L ) != 0L ) return 35 ; if ( ( active0 & 0x23fc58f5d3800L ) != 0L ) { if ( jjmatchedPos != 3 ) { jjmatchedKind = 58 ; jjmatchedPos = 3 ; } return 35 ; } return - 1 ; case 4 : if ( ( active0 & 0x1bc580580800L ) != 0L ) { if ( jjmatchedPos != 4 ) { jjmatchedKind = 58 ; jjmatchedPos = 4 ; } return 35 ; } if ( ( active0 & 0x224000f053000L ) != 0L ) return 35 ; return - 1 ; case 5 : if ( ( active0 & 0xc504180800L ) != 0L ) { jjmatchedKind = 58 ; jjmatchedPos = 5 ; return 35 ; } if ( ( active0 & 0x1b0080400000L ) != 0L ) return 35 ; return - 1 ; case 6 : if ( ( active0 & 0x4004100800L ) != 0L ) return 35 ; if ( ( active0 & 0x8500080000L ) != 0L ) { jjmatchedKind = 58 ; jjmatchedPos = 6 ; return 35 ; } return - 1 ; case 7 : if ( ( active0 & 0x8500000000L ) != 0L ) { jjmatchedKind = 58 ; jjmatchedPos = 7 ; return 35 ; } if ( ( active0 & 0x80000L ) != 0L ) return 35 ; return - 1 ; case 8 : if ( ( active0 & 0x100000000L ) != 0L ) { jjmatchedKind = 58 ; jjmatchedPos = 8 ; return 35 ; } if ( ( active0 & 0x8400000000L ) != 0L ) return 35 ; return - 1 ; case 9 : if ( ( active0 & 0x100000000L ) != 0L ) return 35 ; return - 1 ; default : return - 1 ; } } private final int jjStartNfa_0 ( int pos , long active0 , long active1 ) { return jjMoveNfa_0 ( jjStopStringLiteralDfa_0 ( pos , active0 , active1 ) , pos + 1 ) ; } private final int jjStopAtPos ( int pos , int kind ) { jjmatchedKind = kind ; jjmatchedPos = pos ; return pos + 1 ; } private final int jjStartNfaWithStates_0 ( int pos , int kind , int state ) { jjmatchedKind = kind ; jjmatchedPos = pos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return pos + 1 ; } return jjMoveNfa_0 ( state , pos + 1 ) ; } private final int jjMoveStringLiteralDfa0_0 ( ) { switch ( curChar ) { case 9 : return jjStartNfaWithStates_0 ( 0 , 2 , 0 ) ; case 10 : return jjStartNfaWithStates_0 ( 0 , 5 , 0 ) ; case 12 : return jjStartNfaWithStates_0 ( 0 , 4 , 0 ) ; case 13 : return jjStartNfaWithStates_0 ( 0 , 3 , 0 ) ; case 32 : return jjStartNfaWithStates_0 ( 0 , 1 , 0 ) ; case 33 : jjmatchedKind = 75 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x100000L ) ; case 37 : jjmatchedKind = 100 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x10000000000000L ) ; case 38 : jjmatchedKind = 95 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x800000800000L ) ; case 40 : return jjStopAtPos ( 0 , 61 ) ; case 41 : return jjStopAtPos ( 0 , 62 ) ; case 42 : jjmatchedKind = 93 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x200000000000L ) ; case 43 : jjmatchedKind = 91 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x80002000000L ) ; case 44 : return jjStopAtPos ( 0 , 68 ) ; case 45 : jjmatchedKind = 92 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x100004000000L ) ; case 46 : return jjStartNfaWithStates_0 ( 0 , 69 , 11 ) ; case 47 : jjmatchedKind = 94 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x400000000000L ) ; case 58 : return jjStopAtPos ( 0 , 78 ) ; case 59 : return jjStopAtPos ( 0 , 67 ) ; case 60 : jjmatchedKind = 73 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x20002000010000L ) ; case 61 : jjmatchedKind = 70 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x8000L ) ; case 62 : jjmatchedKind = 71 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x280028000040000L ) ; case 63 : return jjStopAtPos ( 0 , 77 ) ; case 64 : return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x5450545014a0500L ) ; case 91 : return jjStopAtPos ( 0 , 65 ) ; case 93 : return jjStopAtPos ( 0 , 66 ) ; case 94 : jjmatchedKind = 99 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x8000000000000L ) ; case 98 : return jjMoveStringLiteralDfa1_0 ( 0x5800L , 0x0L ) ; case 99 : return jjMoveStringLiteralDfa1_0 ( 0xfa000L , 0x0L ) ; case 100 : return jjMoveStringLiteralDfa1_0 ( 0x700000L , 0x0L ) ; case 101 : return jjMoveStringLiteralDfa1_0 ( 0x800000L , 0x0L ) ; case 102 : return jjMoveStringLiteralDfa1_0 ( 0x1f000000L , 0x0L ) ; case 103 : return jjMoveStringLiteralDfa1_0 ( 0x20000000L , 0x0L ) ; case 105 : return jjMoveStringLiteralDfa1_0 ( 0x7c0000000L , 0x0L ) ; case 108 : return jjMoveStringLiteralDfa1_0 ( 0x800000000L , 0x0L ) ; case 110 : return jjMoveStringLiteralDfa1_0 ( 0x3000000000L , 0x0L ) ; case 112 : return jjMoveStringLiteralDfa1_0 ( 0x1c000000000L , 0x0L ) ; case 114 : return jjMoveStringLiteralDfa1_0 ( 0x20000000000L , 0x0L ) ; case 115 : return jjMoveStringLiteralDfa1_0 ( 0x1c0000000000L , 0x0L ) ; case 116 : return jjMoveStringLiteralDfa1_0 ( 0xe00000000000L , 0x0L ) ; case 118 : return jjMoveStringLiteralDfa1_0 ( 0x1000000000000L , 0x0L ) ; case 119 : return jjMoveStringLiteralDfa1_0 ( 0x2000000000000L , 0x0L ) ; case 123 : return jjStopAtPos ( 0 , 63 ) ; case 124 : jjmatchedKind = 97 ; return jjMoveStringLiteralDfa1_0 ( 0x0L , 0x2000000200000L ) ; case 125 : return jjStopAtPos ( 0 , 64 ) ; case 126 : return jjStopAtPos ( 0 , 76 ) ; default : return jjMoveNfa_0 ( 6 , 0 ) ; } } private final int jjMoveStringLiteralDfa1_0 ( long active0 , long active1 ) { try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 0 , active0 , active1 ) ; return 1 ; } switch ( curChar ) { case 38 : if ( ( active1 & 0x800000L ) != 0L ) return jjStopAtPos ( 1 , 87 ) ; break ; case 43 : if ( ( active1 & 0x2000000L ) != 0L ) return jjStopAtPos ( 1 , 89 ) ; break ; case 45 : if ( ( active1 & 0x4000000L ) != 0L ) return jjStopAtPos ( 1 , 90 ) ; break ; case 60 : if ( ( active1 & 0x2000000000L ) != 0L ) { jjmatchedKind = 101 ; jjmatchedPos = 1 ; } return jjMoveStringLiteralDfa2_0 ( active0 , 0L , active1 , 0x20000000000000L ) ; case 61 : if ( ( active1 & 0x8000L ) != 0L ) return jjStopAtPos ( 1 , 79 ) ; else if ( ( active1 & 0x10000L ) != 0L ) return jjStopAtPos ( 1 , 80 ) ; else if ( ( active1 & 0x40000L ) != 0L ) return jjStopAtPos ( 1 , 82 ) ; else if ( ( active1 & 0x100000L ) != 0L ) return jjStopAtPos ( 1 , 84 ) ; else if ( ( active1 & 0x80000000000L ) != 0L ) return jjStopAtPos ( 1 , 107 ) ; else if ( ( active1 & 0x100000000000L ) != 0L ) return jjStopAtPos ( 1 , 108 ) ; else if ( ( active1 & 0x200000000000L ) != 0L ) return jjStopAtPos ( 1 , 109 ) ; else if ( ( active1 & 0x400000000000L ) != 0L ) return jjStopAtPos ( 1 , 110 ) ; else if ( ( active1 & 0x800000000000L ) != 0L ) return jjStopAtPos ( 1 , 111 ) ; else if ( ( active1 & 0x2000000000000L ) != 0L ) return jjStopAtPos ( 1 , 113 ) ; else if ( ( active1 & 0x8000000000000L ) != 0L ) return jjStopAtPos ( 1 , 115 ) ; else if ( ( active1 & 0x10000000000000L ) != 0L ) return jjStopAtPos ( 1 , 116 ) ; break ; case 62 : if ( ( active1 & 0x8000000000L ) != 0L ) { jjmatchedKind = 103 ; jjmatchedPos = 1 ; } return jjMoveStringLiteralDfa2_0 ( active0 , 0L , active1 , 0x280020000000000L ) ; case 97 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x1018000L , active1 , 0x1000001000000L ) ; case 98 : return jjMoveStringLiteralDfa2_0 ( active0 , 0L , active1 , 0x500000000L ) ; case 101 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x21000100000L , active1 , 0L ) ; case 102 : if ( ( active0 & 0x40000000L ) != 0L ) return jjStartNfaWithStates_0 ( 1 , 30 , 35 ) ; break ; case 103 : return jjMoveStringLiteralDfa2_0 ( active0 , 0L , active1 , 0x80100L ) ; case 104 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x2240000020000L , active1 , 0L ) ; case 105 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x6000000L , active1 , 0L ) ; case 108 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x8802000L , active1 , 0x40004000020400L ) ; case 109 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x80000000L , active1 , 0L ) ; case 110 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x700000000L , active1 , 0L ) ; case 111 : if ( ( active0 & 0x200000L ) != 0L ) { jjmatchedKind = 21 ; jjmatchedPos = 1 ; } return jjMoveStringLiteralDfa2_0 ( active0 , 0x10008304c0800L , active1 , 0x4000000400000L ) ; case 114 : return jjMoveStringLiteralDfa2_0 ( active0 , 0xc0c000001000L , active1 , 0x500050000000000L ) ; case 116 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x80000000000L , active1 , 0L ) ; case 117 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x12000000000L , active1 , 0L ) ; case 119 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x100000000000L , active1 , 0L ) ; case 121 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x4000L , active1 , 0L ) ; case 124 : if ( ( active1 & 0x200000L ) != 0L ) return jjStopAtPos ( 1 , 85 ) ; break ; default : break ; } return jjStartNfa_0 ( 0 , active0 , active1 ) ; } private final int jjMoveStringLiteralDfa2_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 0 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 1 , active0 , active1 ) ; return 2 ; } switch ( curChar ) { case 61 : if ( ( active1 & 0x20000000000000L ) != 0L ) return jjStopAtPos ( 2 , 117 ) ; else if ( ( active1 & 0x80000000000000L ) != 0L ) return jjStopAtPos ( 2 , 119 ) ; break ; case 62 : if ( ( active1 & 0x20000000000L ) != 0L ) { jjmatchedKind = 105 ; jjmatchedPos = 2 ; } return jjMoveStringLiteralDfa3_0 ( active0 , 0L , active1 , 0x200000000000000L ) ; case 97 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x80000022000L , active1 , 0L ) ; case 98 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x10000000000L , active1 , 0L ) ; case 101 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x1000L , active1 , 0x40004000000000L ) ; case 102 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x100000L , active1 , 0L ) ; case 105 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x3104000000000L , active1 , 0x500050500000000L ) ; case 108 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x2001000000L , active1 , 0L ) ; case 110 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x8060c0000L , active1 , 0x1000001000000L ) ; case 111 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x48008000800L , active1 , 0L ) ; case 112 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x80000000L , active1 , 0L ) ; case 114 : if ( ( active0 & 0x10000000L ) != 0L ) return jjStartNfaWithStates_0 ( 2 , 28 , 35 ) ; else if ( ( active1 & 0x400000L ) != 0L ) { jjmatchedKind = 86 ; jjmatchedPos = 2 ; } return jjMoveStringLiteralDfa3_0 ( active0 , 0x200000000000L , active1 , 0x4000000000000L ) ; case 115 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x100808000L , active1 , 0L ) ; case 116 : if ( ( active0 & 0x200000000L ) != 0L ) { jjmatchedKind = 33 ; jjmatchedPos = 2 ; } else if ( ( active1 & 0x100L ) != 0L ) { jjmatchedKind = 72 ; jjmatchedPos = 2 ; } else if ( ( active1 & 0x400L ) != 0L ) { jjmatchedKind = 74 ; jjmatchedPos = 2 ; } return jjMoveStringLiteralDfa3_0 ( active0 , 0x20420014000L , active1 , 0xa0000L ) ; case 117 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x400000400000L , active1 , 0L ) ; case 119 : if ( ( active0 & 0x1000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 2 , 36 , 35 ) ; break ; case 121 : if ( ( active0 & 0x800000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 2 , 47 , 35 ) ; break ; default : break ; } return jjStartNfa_0 ( 1 , active0 , active1 ) ; } private final int jjMoveStringLiteralDfa3_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 1 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 2 , active0 , active1 ) ; return 3 ; } switch ( curChar ) { case 61 : if ( ( active1 & 0x200000000000000L ) != 0L ) return jjStopAtPos ( 3 , 121 ) ; break ; case 95 : return jjMoveStringLiteralDfa4_0 ( active0 , 0L , active1 , 0x4000000000000L ) ; case 97 : return jjMoveStringLiteralDfa4_0 ( active0 , 0xe101000L , active1 , 0L ) ; case 98 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x400000L , active1 , 0L ) ; case 99 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x10000L , active1 , 0L ) ; case 100 : if ( ( active0 & 0x1000000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 48 , 35 ) ; else if ( ( active1 & 0x1000000L ) != 0L ) { jjmatchedKind = 88 ; jjmatchedPos = 3 ; } return jjMoveStringLiteralDfa4_0 ( active0 , 0L , active1 , 0x1000000000000L ) ; case 101 : if ( ( active0 & 0x4000L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 14 , 35 ) ; else if ( ( active0 & 0x8000L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 15 , 35 ) ; else if ( ( active0 & 0x800000L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 23 , 35 ) ; else if ( ( active0 & 0x400000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 46 , 35 ) ; return jjMoveStringLiteralDfa4_0 ( active0 , 0x400000000L , active1 , 0xa0000L ) ; case 102 : return jjMoveStringLiteralDfa4_0 ( active0 , 0L , active1 , 0x40004000000000L ) ; case 103 : if ( ( active0 & 0x800000000L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 35 , 35 ) ; return jjMoveStringLiteralDfa4_0 ( active0 , 0L , active1 , 0x500050000000000L ) ; case 108 : if ( ( active0 & 0x2000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 37 , 35 ) ; return jjMoveStringLiteralDfa4_0 ( active0 , 0x2010000000800L , active1 , 0L ) ; case 111 : if ( ( active0 & 0x20000000L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 29 , 35 ) ; return jjMoveStringLiteralDfa4_0 ( active0 , 0x200080000000L , active1 , 0L ) ; case 114 : if ( ( active0 & 0x20000L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 17 , 35 ) ; return jjMoveStringLiteralDfa4_0 ( active0 , 0x40000000000L , active1 , 0L ) ; case 115 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x1042000L , active1 , 0L ) ; case 116 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x188100080000L , active1 , 0x500000000L ) ; case 117 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x20000000000L , active1 , 0L ) ; case 118 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x4000000000L , active1 , 0L ) ; default : break ; } return jjStartNfa_0 ( 2 , active0 , active1 ) ; } private final int jjMoveStringLiteralDfa4_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 2 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 3 , active0 , active1 ) ; return 4 ; } switch ( curChar ) { case 95 : return jjMoveStringLiteralDfa5_0 ( active0 , 0L , active1 , 0x1000000000000L ) ; case 97 : return jjMoveStringLiteralDfa5_0 ( active0 , 0x4100000000L , active1 , 0x4000000000000L ) ; case 99 : return jjMoveStringLiteralDfa5_0 ( active0 , 0x100000000000L , active1 , 0L ) ; case 101 : if ( ( active0 & 0x1000000L ) != 0L ) return jjStartNfaWithStates_0 ( 4 , 24 , 35 ) ; else if ( ( active0 & 0x2000000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 4 , 49 , 35 ) ; return jjMoveStringLiteralDfa5_0 ( active0 , 0x8000000800L , active1 , 0L ) ; case 104 : if ( ( active0 & 0x10000L ) != 0L ) return jjStartNfaWithStates_0 ( 4 , 16 , 35 ) ; return jjMoveStringLiteralDfa5_0 ( active0 , 0L , active1 , 0x500050000000000L ) ; case 105 : return jjMoveStringLiteralDfa5_0 ( active0 , 0x90000080000L , active1 , 0L ) ; case 107 : if ( ( active0 & 0x1000L ) != 0L ) return jjStartNfaWithStates_0 ( 4 , 12 , 35 ) ; break ; case 108 : if ( ( active0 & 0x2000000L ) != 0L ) { jjmatchedKind = 25 ; jjmatchedPos = 4 ; } return jjMoveStringLiteralDfa5_0 ( active0 , 0x4400000L , active1 , 0L ) ; case 113 : if ( ( active1 & 0x20000L ) != 0L ) return jjStopAtPos ( 4 , 81 ) ; else if ( ( active1 & 0x80000L ) != 0L ) return jjStopAtPos ( 4 , 83 ) ; break ; case 114 : return jjMoveStringLiteralDfa5_0 ( active0 , 0x20480000000L , active1 , 0L ) ; case 115 : if ( ( active0 & 0x2000L ) != 0L ) return jjStartNfaWithStates_0 ( 4 , 13 , 35 ) ; break ; case 116 : if ( ( active0 & 0x40000L ) != 0L ) return jjStartNfaWithStates_0 ( 4 , 18 , 35 ) ; else if ( ( active0 & 0x8000000L ) != 0L ) return jjStartNfaWithStates_0 ( 4 , 27 , 35 ) ; else if ( ( active0 & 0x40000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 4 , 42 , 35 ) ; return jjMoveStringLiteralDfa5_0 ( active0 , 0L , active1 , 0x40004000000000L ) ; case 117 : return jjMoveStringLiteralDfa5_0 ( active0 , 0x100000L , active1 , 0L ) ; case 119 : if ( ( active0 & 0x200000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 4 , 45 , 35 ) ; return jjMoveStringLiteralDfa5_0 ( active0 , 0L , active1 , 0x500000000L ) ; default : break ; } return jjStartNfa_0 ( 3 , active0 , active1 ) ; } private final int jjMoveStringLiteralDfa5_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 3 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 4 , active0 , active1 ) ; return 5 ; } switch ( curChar ) { case 95 : return jjMoveStringLiteralDfa6_0 ( active0 , 0L , active1 , 0x40004000000000L ) ; case 97 : return jjMoveStringLiteralDfa6_0 ( active0 , 0x800L , active1 , 0x1000000000000L ) ; case 99 : if ( ( active0 & 0x10000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 5 , 40 , 35 ) ; else if ( ( active0 & 0x80000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 5 , 43 , 35 ) ; return jjMoveStringLiteralDfa6_0 ( active0 , 0x8000000000L , active1 , 0L ) ; case 101 : if ( ( active0 & 0x400000L ) != 0L ) return jjStartNfaWithStates_0 ( 5 , 22 , 35 ) ; break ; case 102 : return jjMoveStringLiteralDfa6_0 ( active0 , 0x400000000L , active1 , 0L ) ; case 104 : if ( ( active0 & 0x100000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 5 , 44 , 35 ) ; break ; case 105 : return jjMoveStringLiteralDfa6_0 ( active0 , 0L , active1 , 0x500000000L ) ; case 108 : return jjMoveStringLiteralDfa6_0 ( active0 , 0x4100000L , active1 , 0L ) ; case 110 : if ( ( active0 & 0x20000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 5 , 41 , 35 ) ; return jjMoveStringLiteralDfa6_0 ( active0 , 0x100080000L , active1 , 0L ) ; case 115 : return jjMoveStringLiteralDfa6_0 ( active0 , 0L , active1 , 0x4000000000000L ) ; case 116 : if ( ( active0 & 0x80000000L ) != 0L ) return jjStartNfaWithStates_0 ( 5 , 31 , 35 ) ; return jjMoveStringLiteralDfa6_0 ( active0 , 0x4000000000L , active1 , 0x500050000000000L ) ; default : break ; } return jjStartNfa_0 ( 4 , active0 , active1 ) ; } private final int jjMoveStringLiteralDfa6_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 4 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 5 , active0 , active1 ) ; return 6 ; } switch ( curChar ) { case 95 : return jjMoveStringLiteralDfa7_0 ( active0 , 0L , active1 , 0x500050000000000L ) ; case 97 : return jjMoveStringLiteralDfa7_0 ( active0 , 0x400000000L , active1 , 0L ) ; case 99 : return jjMoveStringLiteralDfa7_0 ( active0 , 0x100000000L , active1 , 0L ) ; case 101 : if ( ( active0 & 0x4000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 6 , 38 , 35 ) ; break ; case 110 : if ( ( active0 & 0x800L ) != 0L ) return jjStartNfaWithStates_0 ( 6 , 11 , 35 ) ; break ; case 115 : return jjMoveStringLiteralDfa7_0 ( active0 , 0L , active1 , 0x45004500000000L ) ; case 116 : if ( ( active0 & 0x100000L ) != 0L ) return jjStartNfaWithStates_0 ( 6 , 20 , 35 ) ; return jjMoveStringLiteralDfa7_0 ( active0 , 0x8000000000L , active1 , 0L ) ; case 117 : return jjMoveStringLiteralDfa7_0 ( active0 , 0x80000L , active1 , 0L ) ; case 121 : if ( ( active0 & 0x4000000L ) != 0L ) return jjStartNfaWithStates_0 ( 6 , 26 , 35 ) ; break ; default : break ; } return jjStartNfa_0 ( 5 , active0 , active1 ) ; } private final int jjMoveStringLiteralDfa7_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 5 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 6 , active0 , active1 ) ; return 7 ; } switch ( curChar ) { case 99 : return jjMoveStringLiteralDfa8_0 ( active0 , 0x400000000L , active1 , 0L ) ; case 101 : if ( ( active0 & 0x80000L ) != 0L ) return jjStartNfaWithStates_0 ( 7 , 19 , 35 ) ; return jjMoveStringLiteralDfa8_0 ( active0 , 0x8100000000L , active1 , 0x500000000L ) ; case 104 : return jjMoveStringLiteralDfa8_0 ( active0 , 0L , active1 , 0x40004000000000L ) ; case 105 : return jjMoveStringLiteralDfa8_0 ( active0 , 0L , active1 , 0x4000000000000L ) ; case 115 : return jjMoveStringLiteralDfa8_0 ( active0 , 0L , active1 , 0x101010000000000L ) ; case 117 : return jjMoveStringLiteralDfa8_0 ( active0 , 0L , active1 , 0x400040000000000L ) ; default : break ; } return jjStartNfa_0 ( 6 , active0 , active1 ) ; } private final int jjMoveStringLiteralDfa8_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 6 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 7 , active0 , active1 ) ; return 8 ; } switch ( curChar ) { case 95 : return jjMoveStringLiteralDfa9_0 ( active0 , 0L , active1 , 0x500000000L ) ; case 100 : if ( ( active0 & 0x8000000000L ) != 0L ) return jjStartNfaWithStates_0 ( 8 , 39 , 35 ) ; break ; case 101 : if ( ( active0 & 0x400000000L ) != 0L ) return jjStartNfaWithStates_0 ( 8 , 34 , 35 ) ; break ; case 103 : return jjMoveStringLiteralDfa9_0 ( active0 , 0L , active1 , 0x4000000000000L ) ; case 104 : return jjMoveStringLiteralDfa9_0 ( active0 , 0L , active1 , 0x100010000000000L ) ; case 105 : return jjMoveStringLiteralDfa9_0 ( active0 , 0L , active1 , 0x41004000000000L ) ; case 110 : return jjMoveStringLiteralDfa9_0 ( active0 , 0L , active1 , 0x400040000000000L ) ; case 111 : return jjMoveStringLiteralDfa9_0 ( active0 , 0x100000000L , active1 , 0L ) ; default : break ; } return jjStartNfa_0 ( 7 , active0 , active1 ) ; } private final int jjMoveStringLiteralDfa9_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 7 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 8 , active0 , active1 ) ; return 9 ; } switch ( curChar ) { case 97 : return jjMoveStringLiteralDfa10_0 ( active0 , 0L , active1 , 0x100000000L ) ; case 102 : if ( ( active0 & 0x100000000L ) != 0L ) return jjStartNfaWithStates_0 ( 9 , 32 , 35 ) ; return jjMoveStringLiteralDfa10_0 ( active0 , 0L , active1 , 0x40004000000000L ) ; case 103 : return jjMoveStringLiteralDfa10_0 ( active0 , 0L , active1 , 0x1000000000000L ) ; case 105 : return jjMoveStringLiteralDfa10_0 ( active0 , 0L , active1 , 0x100010000000000L ) ; case 110 : if ( ( active1 & 0x4000000000000L ) != 0L ) return jjStopAtPos ( 9 , 114 ) ; break ; case 111 : return jjMoveStringLiteralDfa10_0 ( active0 , 0L , active1 , 0x400000000L ) ; case 115 : return jjMoveStringLiteralDfa10_0 ( active0 , 0L , active1 , 0x400040000000000L ) ; default : break ; } return jjStartNfa_0 ( 8 , active0 , active1 ) ; } private final int jjMoveStringLiteralDfa10_0 ( long old0 , long active0 , long old1 , long active1 ) { if ( ( ( active0 &= old0 ) | ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 8 , old0 , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 9 , 0L , active1 ) ; return 10 ; } switch ( curChar ) { case 102 : return jjMoveStringLiteralDfa11_0 ( active1 , 0x100010000000000L ) ; case 105 : return jjMoveStringLiteralDfa11_0 ( active1 , 0x400040000000000L ) ; case 110 : if ( ( active1 & 0x1000000000000L ) != 0L ) return jjStopAtPos ( 10 , 112 ) ; return jjMoveStringLiteralDfa11_0 ( active1 , 0x100000000L ) ; case 114 : if ( ( active1 & 0x400000000L ) != 0L ) return jjStopAtPos ( 10 , 98 ) ; break ; case 116 : if ( ( active1 & 0x4000000000L ) != 0L ) { jjmatchedKind = 102 ; jjmatchedPos = 10 ; } return jjMoveStringLiteralDfa11_0 ( active1 , 0x40000000000000L ) ; default : break ; } return jjStartNfa_0 ( 9 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa11_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 9 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 10 , 0L , active1 ) ; return 11 ; } switch ( curChar ) { case 95 : return jjMoveStringLiteralDfa12_0 ( active1 , 0x40000000000000L ) ; case 100 : if ( ( active1 & 0x100000000L ) != 0L ) return jjStopAtPos ( 11 , 96 ) ; break ; case 103 : return jjMoveStringLiteralDfa12_0 ( active1 , 0x400040000000000L ) ; case 116 : if ( ( active1 & 0x10000000000L ) != 0L ) { jjmatchedKind = 104 ; jjmatchedPos = 11 ; } return jjMoveStringLiteralDfa12_0 ( active1 , 0x100000000000000L ) ; default : break ; } return jjStartNfa_0 ( 10 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa12_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 10 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 11 , 0L , active1 ) ; return 12 ; } switch ( curChar ) { case 95 : return jjMoveStringLiteralDfa13_0 ( active1 , 0x100000000000000L ) ; case 97 : return jjMoveStringLiteralDfa13_0 ( active1 , 0x40000000000000L ) ; case 110 : return jjMoveStringLiteralDfa13_0 ( active1 , 0x400040000000000L ) ; default : break ; } return jjStartNfa_0 ( 11 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa13_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 11 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 12 , 0L , active1 ) ; return 13 ; } switch ( curChar ) { case 97 : return jjMoveStringLiteralDfa14_0 ( active1 , 0x100000000000000L ) ; case 101 : return jjMoveStringLiteralDfa14_0 ( active1 , 0x400040000000000L ) ; case 115 : return jjMoveStringLiteralDfa14_0 ( active1 , 0x40000000000000L ) ; default : break ; } return jjStartNfa_0 ( 12 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa14_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 12 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 13 , 0L , active1 ) ; return 14 ; } switch ( curChar ) { case 100 : return jjMoveStringLiteralDfa15_0 ( active1 , 0x400040000000000L ) ; case 115 : return jjMoveStringLiteralDfa15_0 ( active1 , 0x140000000000000L ) ; default : break ; } return jjStartNfa_0 ( 13 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa15_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 13 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 14 , 0L , active1 ) ; return 15 ; } switch ( curChar ) { case 95 : return jjMoveStringLiteralDfa16_0 ( active1 , 0x400040000000000L ) ; case 105 : return jjMoveStringLiteralDfa16_0 ( active1 , 0x40000000000000L ) ; case 115 : return jjMoveStringLiteralDfa16_0 ( active1 , 0x100000000000000L ) ; default : break ; } return jjStartNfa_0 ( 14 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa16_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 14 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 15 , 0L , active1 ) ; return 16 ; } switch ( curChar ) { case 103 : return jjMoveStringLiteralDfa17_0 ( active1 , 0x40000000000000L ) ; case 105 : return jjMoveStringLiteralDfa17_0 ( active1 , 0x100000000000000L ) ; case 115 : return jjMoveStringLiteralDfa17_0 ( active1 , 0x400040000000000L ) ; default : break ; } return jjStartNfa_0 ( 15 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa17_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 15 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 16 , 0L , active1 ) ; return 17 ; } switch ( curChar ) { case 103 : return jjMoveStringLiteralDfa18_0 ( active1 , 0x100000000000000L ) ; case 104 : return jjMoveStringLiteralDfa18_0 ( active1 , 0x400040000000000L ) ; case 110 : if ( ( active1 & 0x40000000000000L ) != 0L ) return jjStopAtPos ( 17 , 118 ) ; break ; default : break ; } return jjStartNfa_0 ( 16 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa18_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 16 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 17 , 0L , active1 ) ; return 18 ; } switch ( curChar ) { case 105 : return jjMoveStringLiteralDfa19_0 ( active1 , 0x400040000000000L ) ; case 110 : if ( ( active1 & 0x100000000000000L ) != 0L ) return jjStopAtPos ( 18 , 120 ) ; break ; default : break ; } return jjStartNfa_0 ( 17 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa19_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 17 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 18 , 0L , active1 ) ; return 19 ; } switch ( curChar ) { case 102 : return jjMoveStringLiteralDfa20_0 ( active1 , 0x400040000000000L ) ; default : break ; } return jjStartNfa_0 ( 18 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa20_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 18 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 19 , 0L , active1 ) ; return 20 ; } switch ( curChar ) { case 116 : if ( ( active1 & 0x40000000000L ) != 0L ) { jjmatchedKind = 106 ; jjmatchedPos = 20 ; } return jjMoveStringLiteralDfa21_0 ( active1 , 0x400000000000000L ) ; default : break ; } return jjStartNfa_0 ( 19 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa21_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 19 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 20 , 0L , active1 ) ; return 21 ; } switch ( curChar ) { case 95 : return jjMoveStringLiteralDfa22_0 ( active1 , 0x400000000000000L ) ; default : break ; } return jjStartNfa_0 ( 20 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa22_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 20 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 21 , 0L , active1 ) ; return 22 ; } switch ( curChar ) { case 97 : return jjMoveStringLiteralDfa23_0 ( active1 , 0x400000000000000L ) ; default : break ; } return jjStartNfa_0 ( 21 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa23_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 21 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 22 , 0L , active1 ) ; return 23 ; } switch ( curChar ) { case 115 : return jjMoveStringLiteralDfa24_0 ( active1 , 0x400000000000000L ) ; default : break ; } return jjStartNfa_0 ( 22 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa24_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 22 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 23 , 0L , active1 ) ; return 24 ; } switch ( curChar ) { case 115 : return jjMoveStringLiteralDfa25_0 ( active1 , 0x400000000000000L ) ; default : break ; } return jjStartNfa_0 ( 23 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa25_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 23 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 24 , 0L , active1 ) ; return 25 ; } switch ( curChar ) { case 105 : return jjMoveStringLiteralDfa26_0 ( active1 , 0x400000000000000L ) ; default : break ; } return jjStartNfa_0 ( 24 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa26_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 24 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 25 , 0L , active1 ) ; return 26 ; } switch ( curChar ) { case 103 : return jjMoveStringLiteralDfa27_0 ( active1 , 0x400000000000000L ) ; default : break ; } return jjStartNfa_0 ( 25 , 0L , active1 ) ; } private final int jjMoveStringLiteralDfa27_0 ( long old1 , long active1 ) { if ( ( ( active1 &= old1 ) ) == 0L ) return jjStartNfa_0 ( 25 , 0L , old1 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 26 , 0L , active1 ) ; return 27 ; } switch ( curChar ) { case 110 : if ( ( active1 & 0x400000000000000L ) != 0L ) return jjStopAtPos ( 27 , 122 ) ; break ; default : break ; } return jjStartNfa_0 ( 26 , 0L , active1 ) ; } private final void jjCheckNAdd ( int state ) { if ( jjrounds [ state ] != jjround ) { jjstateSet [ jjnewStateCnt ++ ] = state ; jjrounds [ state ] = jjround ; } } private final void jjAddStates ( int start , int end ) { do { jjstateSet [ jjnewStateCnt ++ ] = jjnextStates [ start ] ; } while ( start ++ != end ) ; } private final void jjCheckNAddTwoStates ( int state1 , int state2 ) { jjCheckNAdd ( state1 ) ; jjCheckNAdd ( state2 ) ; } private final void jjCheckNAddStates ( int start , int end ) { do { jjCheckNAdd ( jjnextStates [ start ] ) ; } while ( start ++ != end ) ; } private final void jjCheckNAddStates ( int start ) { jjCheckNAdd ( jjnextStates [ start ] ) ; jjCheckNAdd ( jjnextStates [ start + 1 ] ) ; } static final long [ ] jjbitVec0 = { 0x0L , 0x0L , 0xffffffffffffffffL , 0xffffffffffffffffL } ; static final long [ ] jjbitVec1 = { 0xfffffffffffffffeL , 0xffffffffffffffffL , 0xffffffffffffffffL , 0xffffffffffffffffL } ; static final long [ ] jjbitVec3 = { 0x1ff00000fffffffeL , 0xffffffffffffc000L , 0xffffffffL , 0x600000000000000L } ; static final long [ ] jjbitVec4 = { 0x0L , 0x0L , 0x0L , 0xff7fffffff7fffffL } ; static final long [ ] jjbitVec5 = { 0x0L , 0xffffffffffffffffL , 0xffffffffffffffffL , 0xffffffffffffffffL } ; static final long [ ] jjbitVec6 = { 0xffffffffffffffffL , 0xffffffffffffffffL , 0xffffL , 0x0L } ; static final long [ ] jjbitVec7 = { 0xffffffffffffffffL , 0xffffffffffffffffL , 0x0L , 0x0L } ; static final long [ ] jjbitVec8 = { 0x3fffffffffffL , 0x0L , 0x0L , 0x0L } ; private final int jjMoveNfa_0 ( int startState , int curPos ) { int [ ] nextStates ; int startsAt = 0 ; jjnewStateCnt = 74 ; int i = 1 ; jjstateSet [ 0 ] = startState ; int j , kind = 0x7fffffff ; for ( ; ; ) { if ( ++ jjround == 0x7fffffff ) ReInitRounds ( ) ; if ( curChar < 64 ) { long l = 1L << curChar ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 6 : if ( ( 0x1ffffffffL & l ) != 0L ) { if ( kind > 6 ) kind = 6 ; jjCheckNAdd ( 0 ) ; } else if ( ( 0x3ff000000000000L & l ) != 0L ) jjCheckNAddStates ( 0 , 6 ) ; else if ( curChar == 47 ) jjAddStates ( 7 , 9 ) ; else if ( curChar == 36 ) { if ( kind > 58 ) kind = 58 ; jjCheckNAdd ( 35 ) ; } else if ( curChar == 34 ) jjCheckNAddStates ( 10 , 12 ) ; else if ( curChar == 39 ) jjAddStates ( 13 , 14 ) ; else if ( curChar == 46 ) jjCheckNAdd ( 11 ) ; else if ( curChar == 35 ) jjstateSet [ jjnewStateCnt ++ ] = 1 ; if ( ( 0x3fe000000000000L & l ) != 0L ) { if ( kind > 50 ) kind = 50 ; jjCheckNAddTwoStates ( 8 , 9 ) ; } else if ( curChar == 48 ) { if ( kind > 50 ) kind = 50 ; jjCheckNAddStates ( 15 , 17 ) ; } break ; case 56 : if ( curChar == 42 ) jjCheckNAddTwoStates ( 69 , 70 ) ; else if ( curChar == 47 ) jjCheckNAddStates ( 18 , 20 ) ; if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 61 ; break ; case 0 : if ( ( 0x1ffffffffL & l ) == 0L ) break ; if ( kind > 6 ) kind = 6 ; jjCheckNAdd ( 0 ) ; break ; case 1 : if ( curChar == 33 ) jjCheckNAddStates ( 21 , 23 ) ; break ; case 2 : if ( ( 0xffffffffffffdbffL & l ) != 0L ) jjCheckNAddStates ( 21 , 23 ) ; break ; case 3 : if ( ( 0x2400L & l ) != 0L && kind > 8 ) kind = 8 ; break ; case 4 : if ( curChar == 10 && kind > 8 ) kind = 8 ; break ; case 5 : if ( curChar == 13 ) jjstateSet [ jjnewStateCnt ++ ] = 4 ; break ; case 7 : if ( ( 0x3fe000000000000L & l ) == 0L ) break ; if ( kind > 50 ) kind = 50 ; jjCheckNAddTwoStates ( 8 , 9 ) ; break ; case 8 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 50 ) kind = 50 ; jjCheckNAddTwoStates ( 8 , 9 ) ; break ; case 10 : if ( curChar == 46 ) jjCheckNAdd ( 11 ) ; break ; case 11 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 54 ) kind = 54 ; jjCheckNAddStates ( 24 , 26 ) ; break ; case 13 : if ( ( 0x280000000000L & l ) != 0L ) jjCheckNAdd ( 14 ) ; break ; case 14 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 54 ) kind = 54 ; jjCheckNAddTwoStates ( 14 , 15 ) ; break ; case 16 : if ( curChar == 39 ) jjAddStates ( 13 , 14 ) ; break ; case 17 : if ( ( 0xffffff7fffffdbffL & l ) != 0L ) jjCheckNAdd ( 18 ) ; break ; case 18 : if ( curChar == 39 && kind > 56 ) kind = 56 ; break ; case 20 : if ( ( 0x8400000000L & l ) != 0L ) jjCheckNAdd ( 18 ) ; break ; case 21 : if ( ( 0xff000000000000L & l ) != 0L ) jjCheckNAddTwoStates ( 22 , 18 ) ; break ; case 22 : if ( ( 0xff000000000000L & l ) != 0L ) jjCheckNAdd ( 18 ) ; break ; case 23 : if ( ( 0xf000000000000L & l ) != 0L ) jjstateSet [ jjnewStateCnt ++ ] = 24 ; break ; case 24 : if ( ( 0xff000000000000L & l ) != 0L ) jjCheckNAdd ( 22 ) ; break ; case 25 : if ( curChar == 34 ) jjCheckNAddStates ( 10 , 12 ) ; break ; case 26 : if ( ( 0xfffffffbffffdbffL & l ) != 0L ) jjCheckNAddStates ( 10 , 12 ) ; break ; case 28 : if ( ( 0x8400000000L & l ) != 0L ) jjCheckNAddStates ( 10 , 12 ) ; break ; case 29 : if ( curChar == 34 && kind > 57 ) kind = 57 ; break ; case 30 : if ( ( 0xff000000000000L & l ) != 0L ) jjCheckNAddStates ( 27 , 30 ) ; break ; case 31 : if ( ( 0xff000000000000L & l ) != 0L ) jjCheckNAddStates ( 10 , 12 ) ; break ; case 32 : if ( ( 0xf000000000000L & l ) != 0L ) jjstateSet [ jjnewStateCnt ++ ] = 33 ; break ; case 33 : if ( ( 0xff000000000000L & l ) != 0L ) jjCheckNAdd ( 31 ) ; break ; case 34 : if ( curChar != 36 ) break ; if ( kind > 58 ) kind = 58 ; jjCheckNAdd ( 35 ) ; break ; case 35 : if ( ( 0x3ff001000000000L & l ) == 0L ) break ; if ( kind > 58 ) kind = 58 ; jjCheckNAdd ( 35 ) ; break ; case 36 : if ( ( 0x3ff000000000000L & l ) != 0L ) jjCheckNAddStates ( 0 , 6 ) ; break ; case 37 : if ( ( 0x3ff000000000000L & l ) != 0L ) jjCheckNAddTwoStates ( 37 , 38 ) ; break ; case 38 : if ( curChar != 46 ) break ; if ( kind > 54 ) kind = 54 ; jjCheckNAddStates ( 31 , 33 ) ; break ; case 39 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 54 ) kind = 54 ; jjCheckNAddStates ( 31 , 33 ) ; break ; case 41 : if ( ( 0x280000000000L & l ) != 0L ) jjCheckNAdd ( 42 ) ; break ; case 42 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 54 ) kind = 54 ; jjCheckNAddTwoStates ( 42 , 15 ) ; break ; case 43 : if ( ( 0x3ff000000000000L & l ) != 0L ) jjCheckNAddTwoStates ( 43 , 44 ) ; break ; case 45 : if ( ( 0x280000000000L & l ) != 0L ) jjCheckNAdd ( 46 ) ; break ; case 46 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 54 ) kind = 54 ; jjCheckNAddTwoStates ( 46 , 15 ) ; break ; case 47 : if ( ( 0x3ff000000000000L & l ) != 0L ) jjCheckNAddStates ( 34 , 36 ) ; break ; case 49 : if ( ( 0x280000000000L & l ) != 0L ) jjCheckNAdd ( 50 ) ; break ; case 50 : if ( ( 0x3ff000000000000L & l ) != 0L ) jjCheckNAddTwoStates ( 50 , 15 ) ; break ; case 51 : if ( curChar != 48 ) break ; if ( kind > 50 ) kind = 50 ; jjCheckNAddStates ( 15 , 17 ) ; break ; case 53 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 50 ) kind = 50 ; jjCheckNAddTwoStates ( 53 , 9 ) ; break ; case 54 : if ( ( 0xff000000000000L & l ) == 0L ) break ; if ( kind > 50 ) kind = 50 ; jjCheckNAddTwoStates ( 54 , 9 ) ; break ; case 55 : if ( curChar == 47 ) jjAddStates ( 7 , 9 ) ; break ; case 57 : if ( ( 0xffffffffffffdbffL & l ) != 0L ) jjCheckNAddStates ( 18 , 20 ) ; break ; case 58 : if ( ( 0x2400L & l ) != 0L && kind > 7 ) kind = 7 ; break ; case 59 : if ( curChar == 10 && kind > 7 ) kind = 7 ; break ; case 60 : if ( curChar == 13 ) jjstateSet [ jjnewStateCnt ++ ] = 59 ; break ; case 61 : if ( curChar == 42 ) jjCheckNAddTwoStates ( 62 , 63 ) ; break ; case 62 : if ( ( 0xfffffbffffffffffL & l ) != 0L ) jjCheckNAddTwoStates ( 62 , 63 ) ; break ; case 63 : if ( curChar == 42 ) jjCheckNAddStates ( 37 , 39 ) ; break ; case 64 : if ( ( 0xffff7bffffffffffL & l ) != 0L ) jjCheckNAddTwoStates ( 65 , 63 ) ; break ; case 65 : if ( ( 0xfffffbffffffffffL & l ) != 0L ) jjCheckNAddTwoStates ( 65 , 63 ) ; break ; case 66 : if ( curChar == 47 && kind > 9 ) kind = 9 ; break ; case 67 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 61 ; break ; case 68 : if ( curChar == 42 ) jjCheckNAddTwoStates ( 69 , 70 ) ; break ; case 69 : if ( ( 0xfffffbffffffffffL & l ) != 0L ) jjCheckNAddTwoStates ( 69 , 70 ) ; break ; case 70 : if ( curChar == 42 ) jjCheckNAddStates ( 40 , 42 ) ; break ; case 71 : if ( ( 0xffff7bffffffffffL & l ) != 0L ) jjCheckNAddTwoStates ( 72 , 70 ) ; break ; case 72 : if ( ( 0xfffffbffffffffffL & l ) != 0L ) jjCheckNAddTwoStates ( 72 , 70 ) ; break ; case 73 : if ( curChar == 47 && kind > 10 ) kind = 10 ; break ; default : break ; } } while ( i != startsAt ) ; } else if ( curChar < 128 ) { long l = 1L << ( curChar & 077 ) ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 6 : case 35 : if ( ( 0x7fffffe87fffffeL & l ) == 0L ) break ; if ( kind > 58 ) kind = 58 ; jjCheckNAdd ( 35 ) ; break ; case 2 : jjAddStates ( 21 , 23 ) ; break ; case 9 : if ( ( 0x100000001000L & l ) != 0L && kind > 50 ) kind = 50 ; break ; case 12 : if ( ( 0x2000000020L & l ) != 0L ) jjAddStates ( 43 , 44 ) ; break ; case 15 : if ( ( 0x5000000050L & l ) != 0L && kind > 54 ) kind = 54 ; break ; case 17 : if ( ( 0xffffffffefffffffL & l ) != 0L ) jjCheckNAdd ( 18 ) ; break ; case 19 : if ( curChar == 92 ) jjAddStates ( 45 , 47 ) ; break ; case 20 : if ( ( 0x14404410000000L & l ) != 0L ) jjCheckNAdd ( 18 ) ; break ; case 26 : if ( ( 0xffffffffefffffffL & l ) != 0L ) jjCheckNAddStates ( 10 , 12 ) ; break ; case 27 : if ( curChar == 92 ) jjAddStates ( 48 , 50 ) ; break ; case 28 : if ( ( 0x14404410000000L & l ) != 0L ) jjCheckNAddStates ( 10 , 12 ) ; break ; case 40 : if ( ( 0x2000000020L & l ) != 0L ) jjAddStates ( 51 , 52 ) ; break ; case 44 : if ( ( 0x2000000020L & l ) != 0L ) jjAddStates ( 53 , 54 ) ; break ; case 48 : if ( ( 0x2000000020L & l ) != 0L ) jjAddStates ( 55 , 56 ) ; break ; case 52 : if ( ( 0x100000001000000L & l ) != 0L ) jjCheckNAdd ( 53 ) ; break ; case 53 : if ( ( 0x7e0000007eL & l ) == 0L ) break ; if ( kind > 50 ) kind = 50 ; jjCheckNAddTwoStates ( 53 , 9 ) ; break ; case 57 : jjAddStates ( 18 , 20 ) ; break ; case 62 : jjCheckNAddTwoStates ( 62 , 63 ) ; break ; case 64 : case 65 : jjCheckNAddTwoStates ( 65 , 63 ) ; break ; case 69 : jjCheckNAddTwoStates ( 69 , 70 ) ; break ; case 71 : case 72 : jjCheckNAddTwoStates ( 72 , 70 ) ; break ; default : break ; } } while ( i != startsAt ) ; } else { int hiByte = ( int ) ( curChar > > 8 ) ; int i1 = hiByte > > 6 ; long l1 = 1L << ( hiByte & 077 ) ; int i2 = ( curChar & 0xff ) > > 6 ; long l2 = 1L << ( curChar & 077 ) ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 6 : if ( jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) ) { if ( kind > 6 ) kind = 6 ; jjCheckNAdd ( 0 ) ; } if ( jjCanMove_2 ( hiByte , i1 , i2 , l1 , l2 ) ) { if ( kind > 58 ) kind = 58 ; jjCheckNAdd ( 35 ) ; } break ; case 0 : if ( ! jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) ) break ; if ( kind > 6 ) kind = 6 ; jjCheckNAdd ( 0 ) ; break ; case 2 : if ( jjCanMove_1 ( hiByte , i1 , i2 , l1 , l2 ) ) jjAddStates ( 21 , 23 ) ; break ; case 17 : if ( jjCanMove_1 ( hiByte , i1 , i2 , l1 , l2 ) ) jjstateSet [ jjnewStateCnt ++ ] = 18 ; break ; case 26 : if ( jjCanMove_1 ( hiByte , i1 , i2 , l1 , l2 ) ) jjAddStates ( 10 , 12 ) ; break ; case 34 : case 35 : if ( ! jjCanMove_2 ( hiByte , i1 , i2 , l1 , l2 ) ) break ; if ( kind > 58 ) kind = 58 ; jjCheckNAdd ( 35 ) ; break ; case 57 : if ( jjCanMove_1 ( hiByte , i1 , i2 , l1 , l2 ) ) jjAddStates ( 18 , 20 ) ; break ; case 62 : if ( jjCanMove_1 ( hiByte , i1 , i2 , l1 , l2 ) ) jjCheckNAddTwoStates ( 62 , 63 ) ; break ; case 64 : case 65 : if ( jjCanMove_1 ( hiByte , i1 , i2 , l1 , l2 ) ) jjCheckNAddTwoStates ( 65 , 63 ) ; break ; case 69 : if ( jjCanMove_1 ( hiByte , i1 , i2 , l1 , l2 ) ) jjCheckNAddTwoStates ( 69 , 70 ) ; break ; case 71 : case 72 : if ( jjCanMove_1 ( hiByte , i1 , i2 , l1 , l2 ) ) jjCheckNAddTwoStates ( 72 , 70 ) ; break ; default : break ; } } while ( i != startsAt ) ; } if ( kind != 0x7fffffff ) { jjmatchedKind = kind ; jjmatchedPos = curPos ; kind = 0x7fffffff ; } ++ curPos ; if ( ( i = jjnewStateCnt ) == ( startsAt = 74 - ( jjnewStateCnt = startsAt ) ) ) return curPos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return curPos ; } } } static final int [ ] jjnextStates = { 37 , 38 , 43 , 44 , 47 , 48 , 15 , 56 , 67 , 68 , 26 , 27 , 29 , 17 , 19 , 52 , 54 , 9 , 57 , 58 , 60 , 2 , 3 , 5 , 11 , 12 , 15 , 26 , 27 , 31 , 29 , 39 , 40 , 15 , 47 , 48 , 15 , 63 , 64 , 66 , 70 , 71 , 73 , 13 , 14 , 20 , 21 , 23 , 28 , 30 , 32 , 41 , 42 , 45 , 46 , 49 , 50 , } ; private static final boolean jjCanMove_0 ( int hiByte , int i1 , int i2 , long l1 , long l2 ) { switch ( hiByte ) { case 0 : return ( ( jjbitVec0 [ i2 ] & l2 ) != 0L ) ; default : return false ; } } private static final boolean jjCanMove_1 ( int hiByte , int i1 , int i2 , long l1 , long l2 ) { switch ( hiByte ) { case 0 : return ( ( jjbitVec0 [ i2 ] & l2 ) != 0L ) ; default : if ( ( jjbitVec1 [ i1 ] & l1 ) != 0L ) return true ; return false ; } } private static final boolean jjCanMove_2 ( int hiByte , int i1 , int i2 , long l1 , long l2 ) { switch ( hiByte ) { case 0 : return ( ( jjbitVec4 [ i2 ] & l2 ) != 0L ) ; case 48 : return ( ( jjbitVec5 [ i2 ] & l2 ) != 0L ) ; case 49 : return ( ( jjbitVec6 [ i2 ] & l2 ) != 0L ) ; case 51 : return ( ( jjbitVec7 [ i2 ] & l2 ) != 0L ) ; case 61 : return ( ( jjbitVec8 [ i2 ] & l2 ) != 0L ) ; default : if ( ( jjbitVec3 [ i1 ] & l1 ) != 0L ) return true ; return false ; } } public static final String [ ] jjstrLiteralImages = { "" , null , null , null , null , null , null , null , null , null , null , "\142\157\157\154\145\141\156" , "\142\162\145\141\153" , "\143\154\141\163\163" , "\142\171\164\145" , "\143\141\163\145" , "\143\141\164\143\150" , "\143\150\141\162" , "\143\157\156\163\164" , "\143\157\156\164\151\156\165\145" , "\144\145\146\141\165\154\164" , "\144\157" , "\144\157\165\142\154\145" , "\145\154\163\145" , "\146\141\154\163\145" , "\146\151\156\141\154" , "\146\151\156\141\154\154\171" , "\146\154\157\141\164" , "\146\157\162" , "\147\157\164\157" , "\151\146" , "\151\155\160\157\162\164" , "\151\156\163\164\141\156\143\145\157\146" , "\151\156\164" , "\151\156\164\145\162\146\141\143\145" , "\154\157\156\147" , "\156\145\167" , "\156\165\154\154" , "\160\162\151\166\141\164\145" , "\160\162\157\164\145\143\164\145\144" , "\160\165\142\154\151\143" , "\162\145\164\165\162\156" , "\163\150\157\162\164" , "\163\164\141\164\151\143" , "\163\167\151\164\143\150" , "\164\150\162\157\167" , "\164\162\165\145" , "\164\162\171" , "\166\157\151\144" , "\167\150\151\154\145" , null , null , null , null , null , null , null , null , null , null , null , "\50" , "\51" , "\173" , "\175" , "\133" , "\135" , "\73" , "\54" , "\56" , "\75" , "\76" , "\100\147\164" , "\74" , "\100\154\164" , "\41" , "\176" , "\77" , "\72" , "\75\75" , "\74\75" , "\100\154\164\145\161" , "\76\75" , "\100\147\164\145\161" , "\41\75" , "\174\174" , "\100\157\162" , "\46\46" , "\100\141\156\144" , "\53\53" , "\55\55" , "\53" , "\55" , "\52" , "\57" , "\46" , "\100\142\151\164\167\151\163\145\137\141\156\144" , "\174" , "\100\142\151\164\167\151\163\145\137\157\162" , "\136" , "\45" , "\74\74" , "\100\154\145\146\164\137\163\150\151\146\164" , "\76\76" , "\100\162\151\147\150\164\137\163\150\151\146\164" , "\76\76\76" , "\100\162\151\147\150\164\137\165\156\163\151\147\156\145\144\137\163\150\151\146\164" , "\53\75" , "\55\75" , "\52\75" , "\57\75" , "\46\75" , "\100\141\156\144\137\141\163\163\151\147\156" , "\174\75" , "\100\157\162\137\141\163\163\151\147\156" , "\136\75" , "\45\75" , "\74\74\75" , "\100\154\145\146\164\137\163\150\151\146\164\137\141\163\163\151\147\156" , "\76\76\75" , "\100\162\151\147\150\164\137\163\150\151\146\164\137\141\163\163\151\147\156" , "\76\76\76\75" , "\100\162\151\147\150\164\137\165\156\163\151\147\156\145\144\137\163\150\151\146\164\137\141\163\163\151\147\156" , } ; public static final String [ ] lexStateNames = { "DEFAULT" , } ; static final long [ ] jjtoToken = { 0xe747fffffffff801L , 0x7ffffffffffffffL , } ; static final long [ ] jjtoSkip = { 0x7feL , 0x0L , } ; static final long [ ] jjtoSpecial = { 0x780L , 0x0L , } ; private ASCII_UCodeESC_CharStream input_stream ; private final int [ ] jjrounds = new int [ 74 ] ; private final int [ ] jjstateSet = new int [ 148 ] ; protected char curChar ; public ParserTokenManager ( ASCII_UCodeESC_CharStream stream ) { if ( ASCII_UCodeESC_CharStream . staticFlag ) throw new Error ( "ERROR: Cannot use a static CharStream class with a non-static lexical analyzer." ) ; input_stream = stream ; } public ParserTokenManager ( ASCII_UCodeESC_CharStream stream , int lexState ) { this ( stream ) ; SwitchTo ( lexState ) ; } public void ReInit ( ASCII_UCodeESC_CharStream stream ) { jjmatchedPos = jjnewStateCnt = 0 ; curLexState = defaultLexState ; input_stream = stream ; ReInitRounds ( ) ; } private final void ReInitRounds ( ) { int i ; jjround = 0x80000001 ; for ( i = 74 ; i -- > 0 ; ) jjrounds [ i ] = 0x80000000 ; } public void ReInit ( ASCII_UCodeESC_CharStream stream , int lexState ) { ReInit ( stream ) ; SwitchTo ( lexState ) ; } public void SwitchTo ( int lexState ) { if ( lexState >= 1 || lexState < 0 ) throw new TokenMgrError ( "Error: Ignoring invalid lexical state : " + lexState + ". State unchanged." , TokenMgrError . INVALID_LEXICAL_STATE ) ; else curLexState = lexState ; } private final Token jjFillToken ( ) { Token t = Token . newToken ( jjmatchedKind ) ; t . kind = jjmatchedKind ; String im = jjstrLiteralImages [ jjmatchedKind ] ; t . image = ( im == null ) ? input_stream . GetImage ( ) : im ; t . beginLine = input_stream . getBeginLine ( ) ; t . beginColumn = input_stream . getBeginColumn ( ) ; t . endLine = input_stream . getEndLine ( ) ; t . endColumn = input_stream . getEndColumn ( ) ; return t ; } int curLexState = 0 ; int defaultLexState = 0 ; int jjnewStateCnt ; int jjround ; int jjmatchedPos ; int jjmatchedKind ; public final Token getNextToken ( ) { int kind ; Token specialToken = null ; Token matchedToken ; int curPos = 0 ; EOFLoop : for ( ; ; ) { try { curChar = input_stream . BeginToken ( ) ; } catch ( java . io . IOException e ) { jjmatchedKind = 0 ; matchedToken = jjFillToken ( ) ; matchedToken . specialToken = specialToken ; return matchedToken ; } jjmatchedKind = 0x7fffffff ; jjmatchedPos = 0 ; curPos = jjMoveStringLiteralDfa0_0 ( ) ; if ( jjmatchedKind != 0x7fffffff ) { if ( jjmatchedPos + 1 < curPos ) input_stream . backup ( curPos - jjmatchedPos - 1 ) ; if ( ( jjtoToken [ jjmatchedKind > > 6 ] & ( 1L << ( jjmatchedKind & 077 ) ) ) != 0L ) { matchedToken = jjFillToken ( ) ; matchedToken . specialToken = specialToken ; return matchedToken ; } else { if ( ( jjtoSpecial [ jjmatchedKind > > 6 ] & ( 1L << ( jjmatchedKind & 077 ) ) ) != 0L ) { matchedToken = jjFillToken ( ) ; if ( specialToken == null ) specialToken = matchedToken ; else { matchedToken . specialToken = specialToken ; specialToken = ( specialToken . next = matchedToken ) ; } } continue EOFLoop ; } } int error_line = input_stream . getEndLine ( ) ; int error_column = input_stream . getEndColumn ( ) ; String error_after = null ; boolean EOFSeen = false ; try { input_stream . readChar ( ) ; input_stream . backup ( 1 ) ; } catch ( java . io . IOException e1 ) { EOFSeen = true ; error_after = curPos <= 1 ? "" : input_stream . GetImage ( ) ; if ( curChar == '\n' || curChar == '\r' ) { error_line ++ ; error_column = 0 ; } else error_column ++ ; } if ( ! EOFSeen ) { input_stream . backup ( 1 ) ; error_after = curPos <= 1 ? "" : input_stream . GetImage ( ) ; } throw new TokenMgrError ( EOFSeen , curLexState , error_line , error_column , error_after , curChar , TokenMgrError . LEXICAL_ERROR ) ; } } } 	0	['50', '1', '0', '5', '66', '3', '1', '4', '6', '0.75170068', '6259', '0.166666667', '1', '0', '0.5', '0', '0', '123.7', '163', '8.68', '0']
package org . gjt . sp . jedit . browser ; import javax . swing . border . EmptyBorder ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . io . File ; import java . util . Vector ; import org . gjt . sp . jedit . gui . EnhancedDialog ; import org . gjt . sp . jedit . io . * ; import org . gjt . sp . jedit . * ; public class VFSFileChooserDialog extends EnhancedDialog { public VFSFileChooserDialog ( View view , String path , int mode , boolean multipleSelection ) { super ( view , jEdit . getProperty ( "vfs.browser.title" ) , true ) ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; String name ; if ( path == null || path . endsWith ( File . separator ) || path . endsWith ( "/" ) ) name = null ; else { VFS vfs = VFSManager . getVFSForPath ( path ) ; name = vfs . getFileName ( path ) ; path = vfs . getParentOfPath ( path ) ; } browser = new VFSBrowser ( view , path , mode , multipleSelection ) ; browser . addBrowserListener ( new BrowserHandler ( ) ) ; content . add ( BorderLayout . CENTER , browser ) ; JPanel panel = new JPanel ( ) ; panel . setLayout ( new BoxLayout ( panel , BoxLayout . X_AXIS ) ) ; panel . setBorder ( new EmptyBorder ( 12 , 0 , 0 , 0 ) ) ; panel . add ( new JLabel ( jEdit . getProperty ( "vfs.browser.dialog.filename" ) ) ) ; panel . add ( Box . createHorizontalStrut ( 12 ) ) ; filenameField = new JTextField ( 20 ) ; filenameField . setText ( name ) ; filenameField . addKeyListener ( new KeyHandler ( ) ) ; filenameField . selectAll ( ) ; Dimension dim = filenameField . getPreferredSize ( ) ; dim . width = Integer . MAX_VALUE ; filenameField . setMaximumSize ( dim ) ; Box box = new Box ( BoxLayout . Y_AXIS ) ; box . add ( Box . createGlue ( ) ) ; box . add ( filenameField ) ; box . add ( Box . createGlue ( ) ) ; panel . add ( box ) ; panel . add ( Box . createHorizontalStrut ( 12 ) ) ; if ( mode == VFSBrowser . SAVE_DIALOG ) { GUIUtilities . requestFocus ( this , filenameField ) ; } else { GUIUtilities . requestFocus ( this , browser . getBrowserView ( ) . getDefaultFocusComponent ( ) ) ; } ok = new JButton ( jEdit . getProperty ( "vfs.browser.dialog." + ( mode == VFSBrowser . OPEN_DIALOG ? "open" : "save" ) ) ) ; ok . addActionListener ( new ActionHandler ( ) ) ; getRootPane ( ) . setDefaultButton ( ok ) ; panel . add ( ok ) ; panel . add ( Box . createHorizontalStrut ( 6 ) ) ; cancel = new JButton ( jEdit . getProperty ( "common.cancel" ) ) ; cancel . addActionListener ( new ActionHandler ( ) ) ; panel . add ( cancel ) ; if ( mode != VFSBrowser . SAVE_DIALOG ) panel . add ( Box . createGlue ( ) ) ; content . add ( BorderLayout . SOUTH , panel ) ; pack ( ) ; GUIUtilities . loadGeometry ( this , "vfs.browser.dialog" ) ; show ( ) ; } public void dispose ( ) { GUIUtilities . saveGeometry ( this , "vfs.browser.dialog" ) ; super . dispose ( ) ; } public void ok ( ) { VFS . DirectoryEntry [ ] files = browser . getSelectedFiles ( ) ; String directory = browser . getDirectory ( ) ; if ( files . length == 0 ) { filename = filenameField . getText ( ) ; if ( filename . length ( ) == 0 ) { getToolkit ( ) . beep ( ) ; return ; } } else { for ( int i = 0 ; i < files . length ; i ++ ) { VFS . DirectoryEntry file = files [ i ] ; if ( file . type == VFS . DirectoryEntry . FILESYSTEM || file . type == VFS . DirectoryEntry . DIRECTORY ) { browser . setDirectory ( file . path ) ; return ; } else if ( browser . getMode ( ) == VFSBrowser . SAVE_DIALOG ) filename = file . path ; } } if ( browser . getMode ( ) == VFSBrowser . SAVE_DIALOG ) { VFS vfs = VFSManager . getVFSForPath ( directory ) ; filename = vfs . constructPath ( directory , filename ) ; if ( vfs instanceof FileVFS && doFileExistsWarning ( filename ) ) return ; } isOK = true ; dispose ( ) ; } public void cancel ( ) { dispose ( ) ; } public String [ ] getSelectedFiles ( ) { if ( ! isOK ) return null ; if ( filename != null ) return new String [ ] { filename } ; else { Vector vector = new Vector ( ) ; VFS . DirectoryEntry [ ] selectedFiles = browser . getSelectedFiles ( ) ; for ( int i = 0 ; i < selectedFiles . length ; i ++ ) { VFS . DirectoryEntry file = selectedFiles [ i ] ; if ( file . type == VFS . DirectoryEntry . FILE ) vector . addElement ( file . path ) ; } String [ ] retVal = new String [ vector . size ( ) ] ; vector . copyInto ( retVal ) ; return retVal ; } } private VFSBrowser browser ; private JTextField filenameField ; private String filename ; private JButton ok ; private JButton cancel ; private boolean isOK ; private boolean doFileExistsWarning ( String filename ) { if ( new File ( filename ) . exists ( ) ) { String [ ] args = { MiscUtilities . getFileName ( filename ) } ; int result = GUIUtilities . confirm ( browser , "fileexists" , args , JOptionPane . YES_NO_OPTION , JOptionPane . WARNING_MESSAGE ) ; if ( result != JOptionPane . YES_OPTION ) return true ; } return false ; } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { if ( evt . getSource ( ) == ok ) ok ( ) ; else if ( evt . getSource ( ) == cancel ) cancel ( ) ; } } class BrowserHandler implements BrowserListener { public void filesSelected ( VFSBrowser browser , VFS . DirectoryEntry [ ] files ) { if ( files . length == 0 ) return ; else if ( files . length == 1 ) { VFS . DirectoryEntry file = files [ 0 ] ; if ( file . type == VFS . DirectoryEntry . FILE ) { String path = file . path ; String directory = browser . getDirectory ( ) ; VFS vfs = VFSManager . getVFSForPath ( directory ) ; String parent = vfs . getParentOfPath ( path ) ; if ( parent . endsWith ( "/" ) || parent . endsWith ( File . separator ) ) parent = parent . substring ( 0 , parent . length ( ) - 1 ) ; if ( parent . equals ( directory ) ) path = file . name ; filenameField . setText ( path ) ; } } else { filenameField . setText ( null ) ; } } public void filesActivated ( VFSBrowser browser , VFS . DirectoryEntry [ ] files ) { for ( int i = 0 ; i < files . length ; i ++ ) { VFS . DirectoryEntry file = files [ i ] ; if ( file . type == VFS . DirectoryEntry . FILESYSTEM || file . type == VFS . DirectoryEntry . DIRECTORY ) { return ; } } ok ( ) ; } } class KeyHandler extends KeyAdapter { public void keyPressed ( KeyEvent evt ) { browser . getBrowserView ( ) . selectNone ( ) ; } } } 	1	['10', '7', '0', '15', '74', '17', '4', '15', '5', '0.814814815', '477', '1', '1', '0.986404834', '0.25', '4', '7', '46.1', '9', '2.3', '4']
package gnu . regexp ; import java . io . Serializable ; class CharIndexedStringBuffer implements CharIndexed , Serializable { private StringBuffer s ; private int anchor ; CharIndexedStringBuffer ( StringBuffer str , int index ) { s = str ; anchor = index ; } public char charAt ( int index ) { int pos = anchor + index ; return ( ( pos < s . length ( ) ) && ( pos >= 0 ) ) ? s . charAt ( pos ) : OUT_OF_BOUNDS ; } public boolean isValid ( ) { return ( anchor < s . length ( ) ) ; } public boolean move ( int index ) { return ( ( anchor += index ) < s . length ( ) ) ; } } 	0	['4', '1', '0', '2', '7', '0', '1', '1', '3', '0', '59', '1', '0', '0', '0.666666667', '0', '0', '13.25', '3', '1.75', '0']
package org . gjt . sp . jedit . search ; import javax . swing . text . * ; import org . gjt . sp . jedit . jEdit ; import org . gjt . sp . jedit . Buffer ; import org . gjt . sp . util . Log ; public class HyperSearchResult { public String path ; public Buffer buffer ; public int line ; public Position linePos ; public String str ; public HyperSearchResult ( Buffer buffer , int line ) { path = buffer . getPath ( ) ; this . line = line ; if ( ! buffer . isTemporary ( ) ) bufferOpened ( buffer ) ; str = ( line + 1 ) + ": " + getLine ( buffer , buffer . getDefaultRootElement ( ) . getElement ( line ) ) ; } String getLine ( Buffer buffer , Element elem ) { if ( elem == null ) return "" ; try { return buffer . getText ( elem . getStartOffset ( ) , elem . getEndOffset ( ) - elem . getStartOffset ( ) - 1 ) . replace ( '\t' , ' ' ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; return "" ; } } public void bufferOpened ( Buffer buffer ) { this . buffer = buffer ; Element map = buffer . getDefaultRootElement ( ) ; Element elem = map . getElement ( line ) ; if ( elem == null ) elem = map . getElement ( map . getElementCount ( ) - 1 ) ; try { linePos = buffer . createPosition ( elem . getStartOffset ( ) ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } } public void bufferClosed ( ) { buffer = null ; linePos = null ; } public Buffer getBuffer ( ) { if ( buffer == null ) buffer = jEdit . openFile ( null , path ) ; return buffer ; } public String toString ( ) { return str ; } } 	1	['6', '1', '0', '8', '23', '3', '4', '4', '5', '0.68', '128', '0', '1', '0', '0.458333333', '0', '0', '19.5', '2', '1.3333', '1']
package org . gjt . sp . jedit ; import java . util . * ; import org . gjt . sp . util . Log ; public class EditBus { public static void addToBus ( EBComponent comp ) { synchronized ( components ) { components . addElement ( comp ) ; copyComponents = null ; } } public static void removeFromBus ( EBComponent comp ) { synchronized ( components ) { components . removeElement ( comp ) ; copyComponents = null ; } } public static EBComponent [ ] getComponents ( ) { synchronized ( components ) { if ( copyComponents == null ) { copyComponents = new EBComponent [ components . size ( ) ] ; components . copyInto ( copyComponents ) ; } return copyComponents ; } } public static void send ( EBMessage message ) { Log . log ( Log . DEBUG , EditBus . class , message . toString ( ) ) ; EBComponent [ ] comps = getComponents ( ) ; for ( int i = 0 ; i < comps . length ; i ++ ) { try { comps [ i ] . handleMessage ( message ) ; if ( message . isVetoed ( ) ) break ; } catch ( Throwable t ) { Log . log ( Log . ERROR , EditBus . class , "Exception" + " while sending message on EditBus:" ) ; Log . log ( Log . ERROR , EditBus . class , t ) ; } } } public static Object [ ] getNamedList ( Object tag ) { Object [ ] list = ( Object [ ] ) listArrays . get ( tag ) ; if ( list != null ) return list ; Vector listVector = ( Vector ) listVectors . get ( tag ) ; if ( listVector != null ) { list = new Object [ listVector . size ( ) ] ; listVector . copyInto ( list ) ; listArrays . put ( tag , list ) ; return list ; } return null ; } public static Enumeration getNamedLists ( ) { return listVectors . keys ( ) ; } public static void addToNamedList ( Object tag , Object entry ) { Vector listVector = ( Vector ) listVectors . get ( tag ) ; if ( listVector == null ) { listVector = new Vector ( ) ; listVectors . put ( tag , listVector ) ; } listVector . addElement ( entry ) ; listArrays . remove ( tag ) ; } public static void removeFromNamedList ( Object tag , Object entry ) { Vector listVector = ( Vector ) listVectors . get ( tag ) ; if ( listVector == null ) return ; listVector . removeElement ( entry ) ; listArrays . remove ( tag ) ; } private static Vector components = new Vector ( ) ; private static EBComponent [ ] copyComponents ; private static Hashtable listVectors = new Hashtable ( ) ; private static Hashtable listArrays = new Hashtable ( ) ; private EditBus ( ) { } } 	0	['11', '1', '0', '22', '29', '23', '19', '3', '8', '0.72', '244', '1', '1', '0', '0.16', '0', '0', '20.72727273', '5', '1.7273', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import javax . swing . border . Border ; import javax . swing . border . AbstractBorder ; import javax . swing . border . CompoundBorder ; import java . awt . * ; import java . awt . event . * ; import org . gjt . sp . jedit . * ; public class HistoryTextField extends JTextField { public HistoryTextField ( ) { this ( null ) ; } public HistoryTextField ( String name ) { this ( name , false , true ) ; } public HistoryTextField ( String name , boolean instantPopups ) { this ( name , instantPopups , true ) ; } public HistoryTextField ( String name , boolean instantPopups , boolean enterAddsToHistory ) { setBorder ( new CompoundBorder ( getBorder ( ) , new HistoryBorder ( ) ) ) ; if ( name != null ) historyModel = HistoryModel . getModel ( name ) ; addMouseMotionListener ( new MouseHandler ( ) ) ; this . instantPopups = instantPopups ; this . enterAddsToHistory = enterAddsToHistory ; index = - 1 ; } public void setModel ( String name ) { if ( name == null ) historyModel = null ; else historyModel = HistoryModel . getModel ( name ) ; index = - 1 ; } public void addCurrentToHistory ( ) { if ( historyModel != null ) historyModel . addItem ( getText ( ) ) ; index = 0 ; } public void setText ( String text ) { super . setText ( text ) ; index = - 1 ; } public HistoryModel getModel ( ) { return historyModel ; } public void fireActionPerformed ( ) { super . fireActionPerformed ( ) ; } protected void processKeyEvent ( KeyEvent evt ) { if ( ! isEnabled ( ) ) return ; evt = KeyEventWorkaround . processKeyEvent ( evt ) ; if ( evt == null ) return ; if ( evt . getID ( ) == KeyEvent . KEY_PRESSED ) { if ( evt . getKeyCode ( ) == KeyEvent . VK_ENTER ) { if ( enterAddsToHistory ) addCurrentToHistory ( ) ; if ( evt . getModifiers ( ) == 0 ) { fireActionPerformed ( ) ; evt . consume ( ) ; } } else if ( evt . getKeyCode ( ) == KeyEvent . VK_UP ) { if ( evt . isShiftDown ( ) ) doBackwardSearch ( ) ; else historyPrevious ( ) ; evt . consume ( ) ; } else if ( evt . getKeyCode ( ) == KeyEvent . VK_DOWN ) { if ( evt . isShiftDown ( ) ) doForwardSearch ( ) ; else historyNext ( ) ; evt . consume ( ) ; } else if ( evt . getKeyCode ( ) == KeyEvent . VK_TAB && evt . isControlDown ( ) ) { doBackwardSearch ( ) ; evt . consume ( ) ; } } if ( ! evt . isConsumed ( ) ) super . processKeyEvent ( evt ) ; } protected void processMouseEvent ( MouseEvent evt ) { if ( ! isEnabled ( ) ) return ; switch ( evt . getID ( ) ) { case MouseEvent . MOUSE_PRESSED : Border border = getBorder ( ) ; Insets insets = border . getBorderInsets ( HistoryTextField . this ) ; if ( evt . getX ( ) >= getWidth ( ) - insets . right || GUIUtilities . isPopupTrigger ( evt ) ) { if ( evt . isShiftDown ( ) ) showPopupMenu ( getText ( ) . substring ( 0 , getSelectionStart ( ) ) , 0 , getHeight ( ) ) ; else showPopupMenu ( "" , 0 , getHeight ( ) ) ; } else super . processMouseEvent ( evt ) ; break ; case MouseEvent . MOUSE_EXITED : setCursor ( Cursor . getDefaultCursor ( ) ) ; super . processMouseEvent ( evt ) ; break ; default : super . processMouseEvent ( evt ) ; break ; } } private HistoryModel historyModel ; private JPopupMenu popup ; private boolean instantPopups ; private boolean enterAddsToHistory ; private String current ; private int index ; private void doBackwardSearch ( ) { if ( historyModel == null ) return ; if ( getSelectionEnd ( ) != getDocument ( ) . getLength ( ) ) { setCaretPosition ( getDocument ( ) . getLength ( ) ) ; } String text = getText ( ) . substring ( 0 , getSelectionStart ( ) ) ; if ( text == null ) { historyPrevious ( ) ; return ; } for ( int i = index + 1 ; i < historyModel . getSize ( ) ; i ++ ) { String item = historyModel . getItem ( i ) ; if ( item . startsWith ( text ) ) { replaceSelection ( item . substring ( text . length ( ) ) ) ; select ( text . length ( ) , getDocument ( ) . getLength ( ) ) ; index = i ; return ; } } getToolkit ( ) . beep ( ) ; } private void doForwardSearch ( ) { if ( historyModel == null ) return ; if ( getSelectionEnd ( ) != getDocument ( ) . getLength ( ) ) { setCaretPosition ( getDocument ( ) . getLength ( ) ) ; } String text = getText ( ) . substring ( 0 , getSelectionStart ( ) ) ; if ( text == null ) { historyNext ( ) ; return ; } for ( int i = index - 1 ; i >= 0 ; i -- ) { String item = historyModel . getItem ( i ) ; if ( item . startsWith ( text ) ) { replaceSelection ( item . substring ( text . length ( ) ) ) ; select ( text . length ( ) , getDocument ( ) . getLength ( ) ) ; index = i ; return ; } } getToolkit ( ) . beep ( ) ; } private void historyPrevious ( ) { if ( historyModel == null ) return ; if ( index == historyModel . getSize ( ) - 1 ) getToolkit ( ) . beep ( ) ; else if ( index == - 1 ) { current = getText ( ) ; setText ( historyModel . getItem ( 0 ) ) ; index = 0 ; } else { int newIndex = index + 1 ; setText ( historyModel . getItem ( newIndex ) ) ; index = newIndex ; } } private void historyNext ( ) { if ( historyModel == null ) return ; if ( index == - 1 ) getToolkit ( ) . beep ( ) ; else if ( index == 0 ) setText ( current ) ; else { int newIndex = index - 1 ; setText ( historyModel . getItem ( newIndex ) ) ; index = newIndex ; } } private void showPopupMenu ( String text , int x , int y ) { if ( historyModel == null ) return ; requestFocus ( ) ; if ( popup != null && popup . isVisible ( ) ) { popup . setVisible ( false ) ; return ; } ActionHandler actionListener = new ActionHandler ( ) ; popup = new JPopupMenu ( ) ; JMenuItem caption = new JMenuItem ( jEdit . getProperty ( "history.caption" ) ) ; caption . getModel ( ) . setEnabled ( false ) ; popup . add ( caption ) ; popup . addSeparator ( ) ; for ( int i = 0 ; i < historyModel . getSize ( ) ; i ++ ) { String item = historyModel . getItem ( i ) ; if ( item . startsWith ( text ) ) { JMenuItem menuItem = new JMenuItem ( item ) ; menuItem . setActionCommand ( String . valueOf ( i ) ) ; menuItem . addActionListener ( actionListener ) ; popup . add ( menuItem ) ; } } popup . show ( this , x , y ) ; } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { int ind = Integer . parseInt ( evt . getActionCommand ( ) ) ; if ( ind == - 1 ) { if ( index != - 1 ) setText ( current ) ; } else { setText ( historyModel . getItem ( ind ) ) ; index = ind ; } if ( instantPopups ) { addCurrentToHistory ( ) ; fireActionPerformed ( ) ; } } } class MouseHandler extends MouseMotionAdapter { public void mouseMoved ( MouseEvent evt ) { Border border = getBorder ( ) ; Insets insets = border . getBorderInsets ( HistoryTextField . this ) ; if ( evt . getX ( ) >= getWidth ( ) - insets . right ) setCursor ( Cursor . getDefaultCursor ( ) ) ; else setCursor ( Cursor . getPredefinedCursor ( Cursor . TEXT_CURSOR ) ) ; } } static class HistoryBorder extends AbstractBorder { static final int WIDTH = 16 ; public void paintBorder ( Component c , Graphics g , int x , int y , int w , int h ) { g . translate ( x + w - WIDTH , y - 1 ) ; int w2 = WIDTH / 2 ; int h2 = h / 2 ; g . setColor ( UIManager . getColor ( c . isEnabled ( ) && ( ( HistoryTextField ) c ) . getModel ( ) != null ? "Menu.foreground" : "Menu.disabledForeground" ) ) ; g . drawLine ( w2 - 5 , h2 - 2 , w2 + 4 , h2 - 2 ) ; g . drawLine ( w2 - 4 , h2 - 1 , w2 + 3 , h2 - 1 ) ; g . drawLine ( w2 - 3 , h2 , w2 + 2 , h2 ) ; g . drawLine ( w2 - 2 , h2 + 1 , w2 + 1 , h2 + 1 ) ; g . drawLine ( w2 - 1 , h2 + 2 , w2 , h2 + 2 ) ; g . translate ( - ( x + w - WIDTH ) , - ( y - 1 ) ) ; } public Insets getBorderInsets ( Component c ) { return new Insets ( 0 , 0 , 0 , WIDTH ) ; } } } 	1	['21', '6', '0', '17', '83', '64', '13', '7', '9', '0.691666667', '589', '1', '1', '0.978986403', '0.224489796', '3', '7', '26.76190476', '13', '2.7619', '2']
package org . gjt . sp . jedit . gui ; import java . awt . * ; public class VariableGridLayout implements LayoutManager2 , java . io . Serializable { public static final int FIXED_NUM_ROWS = 1 ; public static final int FIXED_NUM_COLUMNS = 2 ; public VariableGridLayout ( int mode , int size , int hgap , int vgap ) { if ( mode != FIXED_NUM_ROWS && mode != FIXED_NUM_COLUMNS ) { throw new IllegalArgumentException ( "illegal mode; value is " + mode ) ; } if ( size <= 0 ) { throw new IllegalArgumentException ( "size cannot be zero or less; value is " + size ) ; } if ( hgap < 0 ) { throw new IllegalArgumentException ( "hgap cannot be negative; value is " + hgap ) ; } if ( vgap < 0 ) { throw new IllegalArgumentException ( "vgap cannot be negative; value is " + vgap ) ; } this . mode = mode ; this . size = size ; this . hgap = hgap ; this . vgap = vgap ; } public VariableGridLayout ( int mode , int size ) { this ( mode , size , 0 , 0 ) ; } public VariableGridLayout ( ) { this ( FIXED_NUM_ROWS , 1 , 0 , 0 ) ; } public void addLayoutComponent ( String name , Component component ) { } public void addLayoutComponent ( Component component , Object constraints ) { } public void removeLayoutComponent ( Component component ) { } public float getLayoutAlignmentX ( Container container ) { return 0.5f ; } public float getLayoutAlignmentY ( Container container ) { return 0.5f ; } public Dimension preferredLayoutSize ( Container parent ) { return getLayoutSize ( parent , 2 ) ; } public Dimension minimumLayoutSize ( Container parent ) { return getLayoutSize ( parent , 0 ) ; } public Dimension maximumLayoutSize ( Container parent ) { return getLayoutSize ( parent , 1 ) ; } public void layoutContainer ( Container parent ) { synchronized ( parent . getTreeLock ( ) ) { int ncomponents = parent . getComponentCount ( ) ; if ( ncomponents == 0 ) { return ; } int total_height = 0 ; for ( int r = 0 , i = 0 ; r < nrows ; r ++ ) { for ( int c = 0 ; c < ncols ; c ++ , i ++ ) { if ( i < ncomponents ) { Dimension d = parent . getComponent ( i ) . getPreferredSize ( ) ; row_heights [ r ] = Math . max ( row_heights [ r ] , d . height ) ; col_widths [ c ] = Math . max ( col_widths [ c ] , d . width ) ; } else { break ; } } total_height += row_heights [ r ] ; } int total_width = 0 ; for ( int c = 0 ; c < ncols ; c ++ ) { total_width += col_widths [ c ] ; } Dimension parent_size = parent . getSize ( ) ; Insets insets = parent . getInsets ( ) ; int free_height = parent_size . height - insets . top - insets . bottom - ( nrows - 1 ) * vgap ; int free_width = parent_size . width - insets . left - insets . right - ( ncols - 1 ) * hgap ; if ( total_height != free_height ) { double dy = ( double ) free_height / ( double ) total_height ; for ( int r = 0 ; r < nrows ; r ++ ) { row_heights [ r ] = ( int ) ( ( double ) row_heights [ r ] * dy ) ; } } if ( total_width != free_width ) { double dx = ( ( double ) free_width ) / ( ( double ) total_width ) ; for ( int c = 0 ; c < ncols ; c ++ ) { col_widths [ c ] = ( int ) ( ( double ) col_widths [ c ] * dx ) ; } } for ( int r = 0 , y = insets . top , i = 0 ; r < nrows ; y += row_heights [ r ] + vgap , r ++ ) { for ( int c = 0 , x = insets . left ; c < ncols ; x += col_widths [ c ] + hgap , c ++ , i ++ ) { if ( i < ncomponents ) { parent . getComponent ( i ) . setBounds ( x , y , col_widths [ c ] , row_heights [ r ] ) ; } } } } } public void invalidateLayout ( Container container ) { int ncomponents = container . getComponentCount ( ) ; int old_nrows = nrows ; int old_ncols = ncols ; if ( this . mode == FIXED_NUM_ROWS ) { nrows = this . size ; ncols = ( ncomponents + nrows - 1 ) / nrows ; } else { ncols = this . size ; nrows = ( ncomponents + ncols - 1 ) / ncols ; } if ( old_nrows != nrows ) { row_heights = new int [ nrows ] ; } if ( old_ncols != ncols ) { col_widths = new int [ ncols ] ; } } public int getRows ( ) { return nrows ; } public int getColumns ( ) { return ncols ; } public String toString ( ) { return getClass ( ) . getName ( ) + "[mode=" + mode + ",size=" + size + ",hgap=" + hgap + ",vgap=" + vgap + "]" ; } private Dimension getLayoutSize ( Container parent , int which ) { synchronized ( parent . getTreeLock ( ) ) { int ncomponents = parent . getComponentCount ( ) ; int h = 0 ; int w = 0 ; for ( int r = 0 , i = 0 ; r < nrows ; r ++ ) { int row_height = 0 ; for ( int c = 0 ; c < ncols ; c ++ , i ++ ) { if ( i < ncomponents ) { switch ( which ) { case 0 : row_height = Math . max ( row_height , parent . getComponent ( i ) . getMinimumSize ( ) . height ) ; break ; case 1 : row_height = Math . max ( row_height , parent . getComponent ( i ) . getMaximumSize ( ) . height ) ; break ; default : row_height = Math . max ( row_height , parent . getComponent ( i ) . getPreferredSize ( ) . height ) ; break ; } } else { break ; } } h += row_height ; } for ( int c = 0 ; c < ncols ; c ++ ) { int col_width = 0 ; for ( int r = 0 ; r < nrows ; r ++ ) { int i = r * ncols + c ; if ( i < ncomponents ) { switch ( which ) { case 0 : col_width = Math . max ( col_width , parent . getComponent ( i ) . getMinimumSize ( ) . width ) ; break ; case 1 : col_width = Math . max ( col_width , parent . getComponent ( i ) . getMaximumSize ( ) . width ) ; break ; default : col_width = Math . max ( col_width , parent . getComponent ( i ) . getPreferredSize ( ) . width ) ; break ; } } else { break ; } } w += col_width ; } Insets insets = parent . getInsets ( ) ; return new Dimension ( w + insets . left + insets . right + ( ( ncols - 1 ) * hgap ) , h + insets . top + insets . bottom + ( ( nrows - 1 ) * vgap ) ) ; } } private int mode ; private int size ; private int hgap ; private int vgap ; private transient int nrows = - 1 ; private transient int ncols = - 1 ; private transient int [ ] row_heights = null ; private transient int [ ] col_widths = null ; } 	0	['17', '1', '0', '1', '37', '100', '1', '0', '16', '0.7', '691', '0.8', '0', '0', '0.323529412', '0', '0', '39.05882353', '13', '2.1176', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import javax . swing . border . * ; import java . awt . * ; import java . awt . event . * ; import org . gjt . sp . jedit . * ; public class BeanShellErrorDialog extends EnhancedDialog { public BeanShellErrorDialog ( View view , String message ) { super ( view , jEdit . getProperty ( "beanshell-error.title" ) , true ) ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; JPanel caption = new JPanel ( new GridLayout ( 2 , 1 , 3 , 3 ) ) ; caption . setBorder ( new EmptyBorder ( 0 , 0 , 3 , 0 ) ) ; caption . add ( new JLabel ( jEdit . getProperty ( "beanshell-error.message.1" ) ) ) ; caption . add ( new JLabel ( jEdit . getProperty ( "beanshell-error.message.2" ) ) ) ; content . add ( BorderLayout . NORTH , caption ) ; JTextArea textArea = new JTextArea ( 10 , 60 ) ; textArea . setText ( message ) ; textArea . setLineWrap ( true ) ; textArea . setWrapStyleWord ( true ) ; content . add ( BorderLayout . CENTER , new JScrollPane ( textArea ) ) ; JPanel panel = new JPanel ( ) ; panel . setLayout ( new BoxLayout ( panel , BoxLayout . X_AXIS ) ) ; panel . setBorder ( new EmptyBorder ( 12 , 0 , 0 , 0 ) ) ; panel . add ( Box . createGlue ( ) ) ; JButton ok = new JButton ( jEdit . getProperty ( "common.ok" ) ) ; ok . addActionListener ( new ActionHandler ( ) ) ; panel . add ( ok ) ; panel . add ( Box . createGlue ( ) ) ; content . add ( panel , BorderLayout . SOUTH ) ; getRootPane ( ) . setDefaultButton ( ok ) ; pack ( ) ; setLocationRelativeTo ( view ) ; show ( ) ; } public void ok ( ) { dispose ( ) ; } public void cancel ( ) { dispose ( ) ; } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { dispose ( ) ; } } } 	1	['3', '7', '0', '5', '33', '3', '2', '4', '3', '2', '162', '0', '0', '0.996946565', '0.555555556', '0', '0', '53', '1', '0.6667', '1']
package org . gjt . sp . jedit . options ; import javax . swing . * ; import java . awt . * ; import org . gjt . sp . jedit . gui . FontSelector ; import org . gjt . sp . jedit . * ; public class GutterOptionPane extends AbstractOptionPane { public GutterOptionPane ( ) { super ( "gutter" ) ; } public void _init ( ) { lineNumbersEnabled = new JCheckBox ( jEdit . getProperty ( "options.gutter.lineNumbers" ) ) ; lineNumbersEnabled . setSelected ( jEdit . getBooleanProperty ( "view.gutter.lineNumbers" ) ) ; addComponent ( lineNumbersEnabled ) ; String _fontFamily = jEdit . getProperty ( "view.gutter.font" ) ; int _fontStyle ; try { _fontStyle = Integer . parseInt ( jEdit . getProperty ( "view.gutter.fontstyle" ) ) ; } catch ( NumberFormatException nf ) { _fontStyle = Font . PLAIN ; } int _fontSize ; try { _fontSize = Integer . parseInt ( jEdit . getProperty ( "view.gutter.fontsize" ) ) ; } catch ( NumberFormatException nf ) { _fontSize = 14 ; } gutterFont = new FontSelector ( new Font ( _fontFamily , _fontStyle , _fontSize ) ) ; addComponent ( jEdit . getProperty ( "options.gutter.font" ) , gutterFont ) ; gutterBorderWidth = new JTextField ( jEdit . getProperty ( "view.gutter.borderWidth" ) ) ; addComponent ( jEdit . getProperty ( "options.gutter.borderWidth" ) , gutterBorderWidth ) ; gutterHighlightInterval = new JTextField ( jEdit . getProperty ( "view.gutter.highlightInterval" ) ) ; addComponent ( jEdit . getProperty ( "options.gutter.interval" ) , gutterHighlightInterval ) ; String [ ] alignments = new String [ ] { "Left" , "Center" , "Right" } ; gutterNumberAlignment = new JComboBox ( alignments ) ; String alignment = jEdit . getProperty ( "view.gutter.numberAlignment" ) ; if ( "right" . equals ( alignment ) ) gutterNumberAlignment . setSelectedIndex ( 2 ) ; else if ( "center" . equals ( alignment ) ) gutterNumberAlignment . setSelectedIndex ( 1 ) ; else gutterNumberAlignment . setSelectedIndex ( 0 ) ; addComponent ( jEdit . getProperty ( "options.gutter.numberAlignment" ) , gutterNumberAlignment ) ; gutterCurrentLineHighlightEnabled = new JCheckBox ( jEdit . getProperty ( "options.gutter.currentLineHighlight" ) ) ; gutterCurrentLineHighlightEnabled . setSelected ( jEdit . getBooleanProperty ( "view.gutter.highlightCurrentLine" ) ) ; addComponent ( gutterCurrentLineHighlightEnabled ) ; gutterMarkerHighlightEnabled = new JCheckBox ( jEdit . getProperty ( "options.gutter.markerHighlight" ) ) ; gutterMarkerHighlightEnabled . setSelected ( jEdit . getBooleanProperty ( "view.gutter.markerHighlight" ) ) ; addComponent ( gutterMarkerHighlightEnabled ) ; } public void _save ( ) { Font _font = gutterFont . getFont ( ) ; jEdit . setProperty ( "view.gutter.font" , _font . getFamily ( ) ) ; jEdit . setProperty ( "view.gutter.fontsize" , String . valueOf ( _font . getSize ( ) ) ) ; jEdit . setProperty ( "view.gutter.fontstyle" , String . valueOf ( _font . getStyle ( ) ) ) ; jEdit . setProperty ( "view.gutter.borderWidth" , gutterBorderWidth . getText ( ) ) ; jEdit . setProperty ( "view.gutter.highlightInterval" , gutterHighlightInterval . getText ( ) ) ; String alignment = null ; switch ( gutterNumberAlignment . getSelectedIndex ( ) ) { case 2 : alignment = "right" ; break ; case 1 : alignment = "center" ; break ; case 0 : default : alignment = "left" ; } jEdit . setProperty ( "view.gutter.numberAlignment" , alignment ) ; jEdit . setBooleanProperty ( "view.gutter.lineNumbers" , lineNumbersEnabled . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.gutter.highlightCurrentLine" , gutterCurrentLineHighlightEnabled . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.gutter.markerHighlight" , gutterMarkerHighlightEnabled . isSelected ( ) ) ; } private FontSelector gutterFont ; private JTextField gutterBorderWidth ; private JTextField gutterHighlightInterval ; private JComboBox gutterNumberAlignment ; private JCheckBox lineNumbersEnabled ; private JCheckBox gutterCurrentLineHighlightEnabled ; private JCheckBox gutterMarkerHighlightEnabled ; } 	0	['3', '6', '0', '4', '27', '1', '1', '3', '3', '0.5', '238', '1', '1', '0.996987952', '1', '2', '4', '76', '3', '1.6667', '0']
package org . gjt . sp . jedit . options ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . util . StringTokenizer ; import org . gjt . sp . jedit . * ; public class LoadSaveOptionPane extends AbstractOptionPane { public LoadSaveOptionPane ( ) { super ( "loadsave" ) ; } public void _init ( ) { autosave = new JTextField ( jEdit . getProperty ( "autosave" ) ) ; addComponent ( jEdit . getProperty ( "options.loadsave.autosave" ) , autosave ) ; backups = new JTextField ( jEdit . getProperty ( "backups" ) ) ; addComponent ( jEdit . getProperty ( "options.loadsave.backups" ) , backups ) ; backupDirectory = new JTextField ( jEdit . getProperty ( "backup.directory" ) ) ; addComponent ( jEdit . getProperty ( "options.loadsave.backupDirectory" ) , backupDirectory ) ; backupPrefix = new JTextField ( jEdit . getProperty ( "backup.prefix" ) ) ; addComponent ( jEdit . getProperty ( "options.loadsave.backupPrefix" ) , backupPrefix ) ; backupSuffix = new JTextField ( jEdit . getProperty ( "backup.suffix" ) ) ; addComponent ( jEdit . getProperty ( "options.loadsave.backupSuffix" ) , backupSuffix ) ; String [ ] lineSeps = { jEdit . getProperty ( "lineSep.unix" ) , jEdit . getProperty ( "lineSep.windows" ) , jEdit . getProperty ( "lineSep.mac" ) } ; lineSeparator = new JComboBox ( lineSeps ) ; String lineSep = jEdit . getProperty ( "buffer.lineSeparator" , System . getProperty ( "line.separator" ) ) ; if ( "\n" . equals ( lineSep ) ) lineSeparator . setSelectedIndex ( 0 ) ; else if ( "\r\n" . equals ( lineSep ) ) lineSeparator . setSelectedIndex ( 1 ) ; else if ( "\r" . equals ( lineSep ) ) lineSeparator . setSelectedIndex ( 2 ) ; addComponent ( jEdit . getProperty ( "options.loadsave.lineSeparator" ) , lineSeparator ) ; DefaultComboBoxModel encodings = new DefaultComboBoxModel ( ) ; StringTokenizer st = new StringTokenizer ( jEdit . getProperty ( "encodings" ) ) ; while ( st . hasMoreTokens ( ) ) { encodings . addElement ( st . nextToken ( ) ) ; } encoding = new JComboBox ( encodings ) ; encoding . setEditable ( true ) ; encoding . setSelectedItem ( jEdit . getProperty ( "buffer.encoding" , System . getProperty ( "file.encoding" ) ) ) ; addComponent ( jEdit . getProperty ( "options.loadsave.encoding" ) , encoding ) ; ioThreadCount = new JTextField ( jEdit . getProperty ( "ioThreadCount" ) ) ; addComponent ( jEdit . getProperty ( "options.loadsave.ioThreadCount" ) , ioThreadCount ) ; restore = new JCheckBox ( jEdit . getProperty ( "options.loadsave.restore" ) ) ; restore . setSelected ( jEdit . getBooleanProperty ( "restore" ) ) ; restore . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { restoreCLI . setEnabled ( restore . isSelected ( ) ) ; } } ) ; addComponent ( restore ) ; restoreCLI = new JCheckBox ( jEdit . getProperty ( "options.loadsave.restore.cli" ) ) ; restoreCLI . setSelected ( jEdit . getBooleanProperty ( "restore.cli" ) ) ; restoreCLI . setEnabled ( restore . isSelected ( ) ) ; addComponent ( restoreCLI ) ; newView = new JCheckBox ( jEdit . getProperty ( "options.loadsave.newView" ) ) ; newView . setSelected ( jEdit . getBooleanProperty ( "client.newView" ) ) ; addComponent ( newView ) ; persistentMarkers = new JCheckBox ( jEdit . getProperty ( "options.loadsave.persistentMarkers" ) ) ; persistentMarkers . setSelected ( jEdit . getBooleanProperty ( "persistentMarkers" ) ) ; addComponent ( persistentMarkers ) ; parseFully = new JCheckBox ( jEdit . getProperty ( "options.loadsave.parseFully" ) ) ; parseFully . setSelected ( jEdit . getBooleanProperty ( "parseFully" ) ) ; addComponent ( parseFully ) ; } public void _save ( ) { jEdit . setProperty ( "autosave" , autosave . getText ( ) ) ; jEdit . setProperty ( "backups" , backups . getText ( ) ) ; jEdit . setProperty ( "backup.directory" , backupDirectory . getText ( ) ) ; jEdit . setProperty ( "backup.prefix" , backupPrefix . getText ( ) ) ; jEdit . setProperty ( "backup.suffix" , backupSuffix . getText ( ) ) ; String lineSep = null ; switch ( lineSeparator . getSelectedIndex ( ) ) { case 0 : lineSep = "\n" ; break ; case 1 : lineSep = "\r\n" ; break ; case 2 : lineSep = "\r" ; break ; } jEdit . setProperty ( "buffer.lineSeparator" , lineSep ) ; jEdit . setProperty ( "buffer.encoding" , ( String ) encoding . getSelectedItem ( ) ) ; jEdit . setProperty ( "ioThreadCount" , ioThreadCount . getText ( ) ) ; jEdit . setBooleanProperty ( "restore" , restore . isSelected ( ) ) ; jEdit . setBooleanProperty ( "restore.cli" , restoreCLI . isSelected ( ) ) ; jEdit . setBooleanProperty ( "client.newView" , newView . isSelected ( ) ) ; jEdit . setBooleanProperty ( "persistentMarkers" , persistentMarkers . isSelected ( ) ) ; jEdit . setBooleanProperty ( "parseFully" , parseFully . isSelected ( ) ) ; } private JTextField autosave ; private JTextField backups ; private JTextField backupDirectory ; private JTextField backupPrefix ; private JTextField backupSuffix ; private JComboBox lineSeparator ; private JComboBox encoding ; private JTextField ioThreadCount ; private JCheckBox restore ; private JCheckBox restoreCLI ; private JCheckBox newView ; private JCheckBox persistentMarkers ; private JCheckBox parseFully ; } 	1	['5', '6', '0', '4', '35', '0', '2', '3', '3', '0.711538462', '386', '1', '0', '0.993993994', '0.5', '3', '5', '73.6', '6', '2', '1']
package bsh ; import java . lang . reflect . Array ; class BSHArrayInitializer extends SimpleNode { BSHArrayInitializer ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { throw new EvalError ( "Array initializer has no base type." ) ; } public Object eval ( Class baseType , int dimensions , CallStack callstack , Interpreter interpreter ) throws EvalError { int numInitializers = jjtGetNumChildren ( ) ; int [ ] dima = new int [ dimensions ] ; dima [ 0 ] = numInitializers ; Object initializers = Array . newInstance ( baseType , dima ) ; for ( int i = 0 ; i < numInitializers ; i ++ ) { SimpleNode node = ( SimpleNode ) jjtGetChild ( i ) ; Object currentInitializer ; if ( node instanceof BSHArrayInitializer ) { if ( dimensions < 2 ) throw new EvalError ( "Invalid Location for Intializer, position: " + i , this ) ; currentInitializer = ( ( BSHArrayInitializer ) node ) . eval ( baseType , dimensions - 1 , callstack , interpreter ) ; } else currentInitializer = node . eval ( callstack , interpreter ) ; if ( currentInitializer == Primitive . VOID ) throw new EvalError ( "Void in array initializer, position" + i , this ) ; Object value ; if ( currentInitializer instanceof Primitive ) value = ( ( Primitive ) currentInitializer ) . getValue ( ) ; else value = currentInitializer ; try { Array . set ( initializers , i , value ) ; } catch ( IllegalArgumentException e ) { Interpreter . debug ( "illegal arg" + e ) ; throwTypeError ( baseType , currentInitializer , i ) ; } catch ( ArrayStoreException e ) { Interpreter . debug ( "arraystore" + e ) ; throwTypeError ( baseType , currentInitializer , i ) ; } } return initializers ; } private void throwTypeError ( Class baseType , Object initializer , int argNum ) throws EvalError { String lhsType = Reflect . normalizeClassName ( baseType ) ; String rhsType ; if ( initializer instanceof Primitive ) rhsType = ( ( Primitive ) initializer ) . getType ( ) . getName ( ) ; else rhsType = Reflect . normalizeClassName ( initializer . getClass ( ) ) ; throw new EvalError ( "Incompatible type: " + rhsType + " in initializer of array type: " + baseType + " at position: " + argNum , this ) ; } } 	0	['4', '2', '0', '10', '23', '6', '3', '7', '2', '2', '175', '0', '0', '0.857142857', '0.583333333', '1', '1', '42.75', '1', '0.75', '0']
package org . gjt . sp . jedit . syntax ; import java . util . Enumeration ; import java . util . Vector ; import javax . swing . text . Segment ; public class ParserRuleSet { public ParserRuleSet ( ) { ruleMapFirst = new ParserRule [ RULE_BUCKET_COUNT ] ; ruleMapLast = new ParserRule [ RULE_BUCKET_COUNT ] ; } public void addRule ( ParserRule r ) { int key = Character . toUpperCase ( r . searchChars [ 0 ] ) % RULE_BUCKET_COUNT ; ParserRule last = ruleMapLast [ key ] ; if ( last == null ) ruleMapFirst [ key ] = ruleMapLast [ key ] = r ; else { last . next = r ; ruleMapLast [ key ] = r ; } } public void dump ( ) { for ( int i = 0 ; i < RULE_BUCKET_COUNT ; i ++ ) { ParserRule first = ruleMapFirst [ i ] ; if ( first == null ) System . err . println ( 0 ) ; else { int j = 0 ; while ( first != null ) { j ++ ; first = first . next ; } System . err . println ( j ) ; } } } public ParserRule getRules ( char ch ) { int key = Character . toUpperCase ( ch ) % RULE_BUCKET_COUNT ; return ruleMapFirst [ key ] ; } public int getTerminateChar ( ) { return terminateChar ; } public void setTerminateChar ( int atChar ) { terminateChar = ( atChar >= 0 ) ? atChar : - 1 ; } public boolean getIgnoreCase ( ) { return ignoreCase ; } public void setIgnoreCase ( boolean b ) { ignoreCase = b ; } public KeywordMap getKeywords ( ) { return keywords ; } public void setKeywords ( KeywordMap km ) { keywords = km ; } public boolean getHighlightDigits ( ) { return highlightDigits ; } public void setHighlightDigits ( boolean highlightDigits ) { this . highlightDigits = highlightDigits ; } public ParserRule getEscapeRule ( ) { return escapeRule ; } public Segment getEscapePattern ( ) { if ( escapePattern == null && escapeRule != null ) { escapePattern = new Segment ( escapeRule . searchChars , 0 , escapeRule . sequenceLengths [ 0 ] ) ; } return escapePattern ; } public void setEscape ( String esc ) { if ( esc == null ) { escapeRule = null ; } else { escapeRule = ParserRuleFactory . createEscapeRule ( esc ) ; } escapePattern = null ; } public byte getDefault ( ) { return defaultToken ; } public void setDefault ( byte def ) { defaultToken = def ; } private static final int RULE_BUCKET_COUNT = 32 ; private KeywordMap keywords ; private ParserRule [ ] ruleMapFirst ; private ParserRule [ ] ruleMapLast ; private ParserRule escapeRule ; private Segment escapePattern ; private int terminateChar = - 1 ; private boolean ignoreCase = true ; private boolean highlightDigits ; private byte defaultToken ; } 	1	['17', '1', '0', '8', '22', '100', '5', '3', '17', '0.91875', '199', '1', '4', '0', '0.183823529', '0', '0', '10.11764706', '4', '1.4118', '1']
package bsh ; final class ASCII_UCodeESC_CharStream { public static final boolean staticFlag = false ; static final int hexval ( char c ) throws java . io . IOException { switch ( c ) { case '0' : return 0 ; case '1' : return 1 ; case '2' : return 2 ; case '3' : return 3 ; case '4' : return 4 ; case '5' : return 5 ; case '6' : return 6 ; case '7' : return 7 ; case '8' : return 8 ; case '9' : return 9 ; case 'a' : case 'A' : return 10 ; case 'b' : case 'B' : return 11 ; case 'c' : case 'C' : return 12 ; case 'd' : case 'D' : return 13 ; case 'e' : case 'E' : return 14 ; case 'f' : case 'F' : return 15 ; } throw new java . io . IOException ( ) ; } public int bufpos = - 1 ; int bufsize ; int available ; int tokenBegin ; private int bufline [ ] ; private int bufcolumn [ ] ; private int column = 0 ; private int line = 1 ; private java . io . Reader inputStream ; private boolean prevCharIsCR = false ; private boolean prevCharIsLF = false ; private char [ ] nextCharBuf ; private char [ ] buffer ; private int maxNextCharInd = 0 ; private int nextCharInd = - 1 ; private int inBuf = 0 ; private final void ExpandBuff ( boolean wrapAround ) { char [ ] newbuffer = new char [ bufsize + 2048 ] ; int newbufline [ ] = new int [ bufsize + 2048 ] ; int newbufcolumn [ ] = new int [ bufsize + 2048 ] ; try { if ( wrapAround ) { System . arraycopy ( buffer , tokenBegin , newbuffer , 0 , bufsize - tokenBegin ) ; System . arraycopy ( buffer , 0 , newbuffer , bufsize - tokenBegin , bufpos ) ; buffer = newbuffer ; System . arraycopy ( bufline , tokenBegin , newbufline , 0 , bufsize - tokenBegin ) ; System . arraycopy ( bufline , 0 , newbufline , bufsize - tokenBegin , bufpos ) ; bufline = newbufline ; System . arraycopy ( bufcolumn , tokenBegin , newbufcolumn , 0 , bufsize - tokenBegin ) ; System . arraycopy ( bufcolumn , 0 , newbufcolumn , bufsize - tokenBegin , bufpos ) ; bufcolumn = newbufcolumn ; bufpos += ( bufsize - tokenBegin ) ; } else { System . arraycopy ( buffer , tokenBegin , newbuffer , 0 , bufsize - tokenBegin ) ; buffer = newbuffer ; System . arraycopy ( bufline , tokenBegin , newbufline , 0 , bufsize - tokenBegin ) ; bufline = newbufline ; System . arraycopy ( bufcolumn , tokenBegin , newbufcolumn , 0 , bufsize - tokenBegin ) ; bufcolumn = newbufcolumn ; bufpos -= tokenBegin ; } } catch ( Throwable t ) { throw new Error ( t . getMessage ( ) ) ; } available = ( bufsize += 2048 ) ; tokenBegin = 0 ; } private final void FillBuff ( ) throws java . io . IOException { int i ; if ( maxNextCharInd == 4096 ) maxNextCharInd = nextCharInd = 0 ; try { if ( ( i = inputStream . read ( nextCharBuf , maxNextCharInd , 4096 - maxNextCharInd ) ) == - 1 ) { inputStream . close ( ) ; throw new java . io . IOException ( ) ; } else maxNextCharInd += i ; return ; } catch ( java . io . IOException e ) { if ( bufpos != 0 ) { -- bufpos ; backup ( 0 ) ; } else { bufline [ bufpos ] = line ; bufcolumn [ bufpos ] = column ; } throw e ; } } private final char ReadByte ( ) throws java . io . IOException { if ( ++ nextCharInd >= maxNextCharInd ) FillBuff ( ) ; return nextCharBuf [ nextCharInd ] ; } public final char BeginToken ( ) throws java . io . IOException { if ( inBuf > 0 ) { -- inBuf ; return buffer [ tokenBegin = ( bufpos == bufsize - 1 ) ? ( bufpos = 0 ) : ++ bufpos ] ; } tokenBegin = 0 ; bufpos = - 1 ; return readChar ( ) ; } private final void AdjustBuffSize ( ) { if ( available == bufsize ) { if ( tokenBegin > 2048 ) { bufpos = 0 ; available = tokenBegin ; } else ExpandBuff ( false ) ; } else if ( available > tokenBegin ) available = bufsize ; else if ( ( tokenBegin - available ) < 2048 ) ExpandBuff ( true ) ; else available = tokenBegin ; } private final void UpdateLineColumn ( char c ) { column ++ ; if ( prevCharIsLF ) { prevCharIsLF = false ; line += ( column = 1 ) ; } else if ( prevCharIsCR ) { prevCharIsCR = false ; if ( c == '\n' ) { prevCharIsLF = true ; } else line += ( column = 1 ) ; } switch ( c ) { case '\r' : prevCharIsCR = true ; break ; case '\n' : prevCharIsLF = true ; break ; case '\t' : column -- ; column += ( 8 - ( column & 07 ) ) ; break ; default : break ; } bufline [ bufpos ] = line ; bufcolumn [ bufpos ] = column ; } public final char readChar ( ) throws java . io . IOException { if ( inBuf > 0 ) { -- inBuf ; return buffer [ ( bufpos == bufsize - 1 ) ? ( bufpos = 0 ) : ++ bufpos ] ; } char c ; if ( ++ bufpos == available ) AdjustBuffSize ( ) ; if ( ( ( buffer [ bufpos ] = c = ( char ) ( ( char ) 0xff & ReadByte ( ) ) ) == '\\' ) ) { UpdateLineColumn ( c ) ; int backSlashCnt = 1 ; for ( ; ; ) { if ( ++ bufpos == available ) AdjustBuffSize ( ) ; try { if ( ( buffer [ bufpos ] = c = ( char ) ( ( char ) 0xff & ReadByte ( ) ) ) != '\\' ) { UpdateLineColumn ( c ) ; if ( ( c == 'u' ) && ( ( backSlashCnt & 1 ) == 1 ) ) { if ( -- bufpos < 0 ) bufpos = bufsize - 1 ; break ; } backup ( backSlashCnt ) ; return '\\' ; } } catch ( java . io . IOException e ) { if ( backSlashCnt > 1 ) backup ( backSlashCnt ) ; return '\\' ; } UpdateLineColumn ( c ) ; backSlashCnt ++ ; } try { while ( ( c = ( char ) ( ( char ) 0xff & ReadByte ( ) ) ) == 'u' ) ++ column ; buffer [ bufpos ] = c = ( char ) ( hexval ( c ) << 12 | hexval ( ( char ) ( ( char ) 0xff & ReadByte ( ) ) ) << 8 | hexval ( ( char ) ( ( char ) 0xff & ReadByte ( ) ) ) << 4 | hexval ( ( char ) ( ( char ) 0xff & ReadByte ( ) ) ) ) ; column += 4 ; } catch ( java . io . IOException e ) { throw new Error ( "Invalid escape character at line " + line + " column " + column + "." ) ; } if ( backSlashCnt == 1 ) return c ; else { backup ( backSlashCnt - 1 ) ; return '\\' ; } } else { UpdateLineColumn ( c ) ; return ( c ) ; } } public final int getColumn ( ) { return bufcolumn [ bufpos ] ; } public final int getLine ( ) { return bufline [ bufpos ] ; } public final int getEndColumn ( ) { return bufcolumn [ bufpos ] ; } public final int getEndLine ( ) { return bufline [ bufpos ] ; } public final int getBeginColumn ( ) { return bufcolumn [ tokenBegin ] ; } public final int getBeginLine ( ) { return bufline [ tokenBegin ] ; } public final void backup ( int amount ) { inBuf += amount ; if ( ( bufpos -= amount ) < 0 ) bufpos += bufsize ; } public ASCII_UCodeESC_CharStream ( java . io . Reader dstream , int startline , int startcolumn , int buffersize ) { inputStream = dstream ; line = startline ; column = startcolumn - 1 ; available = bufsize = buffersize ; buffer = new char [ buffersize ] ; bufline = new int [ buffersize ] ; bufcolumn = new int [ buffersize ] ; nextCharBuf = new char [ 4096 ] ; } public ASCII_UCodeESC_CharStream ( java . io . Reader dstream , int startline , int startcolumn ) { this ( dstream , startline , startcolumn , 4096 ) ; } public void ReInit ( java . io . Reader dstream , int startline , int startcolumn , int buffersize ) { inputStream = dstream ; line = startline ; column = startcolumn - 1 ; if ( buffer == null || buffersize != buffer . length ) { available = bufsize = buffersize ; buffer = new char [ buffersize ] ; bufline = new int [ buffersize ] ; bufcolumn = new int [ buffersize ] ; nextCharBuf = new char [ 4096 ] ; } prevCharIsLF = prevCharIsCR = false ; tokenBegin = inBuf = maxNextCharInd = 0 ; nextCharInd = bufpos = - 1 ; } public void ReInit ( java . io . Reader dstream , int startline , int startcolumn ) { ReInit ( dstream , startline , startcolumn , 4096 ) ; } public ASCII_UCodeESC_CharStream ( java . io . InputStream dstream , int startline , int startcolumn , int buffersize ) { this ( new java . io . InputStreamReader ( dstream ) , startline , startcolumn , 4096 ) ; } public ASCII_UCodeESC_CharStream ( java . io . InputStream dstream , int startline , int startcolumn ) { this ( dstream , startline , startcolumn , 4096 ) ; } public void ReInit ( java . io . InputStream dstream , int startline , int startcolumn , int buffersize ) { ReInit ( new java . io . InputStreamReader ( dstream ) , startline , startcolumn , 4096 ) ; } public void ReInit ( java . io . InputStream dstream , int startline , int startcolumn ) { ReInit ( dstream , startline , startcolumn , 4096 ) ; } public final String GetImage ( ) { if ( bufpos >= tokenBegin ) return new String ( buffer , tokenBegin , bufpos - tokenBegin + 1 ) ; else return new String ( buffer , tokenBegin , bufsize - tokenBegin ) + new String ( buffer , 0 , bufpos + 1 ) ; } public final char [ ] GetSuffix ( int len ) { char [ ] ret = new char [ len ] ; if ( ( bufpos + 1 ) >= len ) System . arraycopy ( buffer , bufpos - len + 1 , ret , 0 , len ) ; else { System . arraycopy ( buffer , bufsize - ( len - bufpos - 1 ) , ret , 0 , len - bufpos - 1 ) ; System . arraycopy ( buffer , 0 , ret , len - bufpos - 1 , bufpos + 1 ) ; } return ret ; } public void Done ( ) { nextCharBuf = null ; buffer = null ; bufline = null ; bufcolumn = null ; } public void adjustBeginLineColumn ( int newLine , int newCol ) { int start = tokenBegin ; int len ; if ( bufpos >= tokenBegin ) { len = bufpos - tokenBegin + inBuf + 1 ; } else { len = bufsize - tokenBegin + bufpos + 1 + inBuf ; } int i = 0 , j = 0 , k = 0 ; int nextColDiff = 0 , columnDiff = 0 ; while ( i < len && bufline [ j = start % bufsize ] == bufline [ k = ++ start % bufsize ] ) { bufline [ j ] = newLine ; nextColDiff = columnDiff + bufcolumn [ k ] - bufcolumn [ j ] ; bufcolumn [ j ] = newCol + columnDiff ; columnDiff = nextColDiff ; i ++ ; } if ( i < len ) { bufline [ j ] = newLine ++ ; bufcolumn [ j ] = newCol + columnDiff ; while ( i ++ < len ) { if ( bufline [ j = start % bufsize ] != bufline [ ++ start % bufsize ] ) bufline [ j ] = newLine ++ ; else bufline [ j ] = newLine ; } } line = bufline [ j ] ; column = bufcolumn [ j ] ; } } 	0	['27', '1', '0', '3', '40', '25', '3', '0', '21', '0.529411765', '1277', '0.705882353', '0', '0', '0.296296296', '0', '0', '45.66666667', '7', '1.5926', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . border . * ; import javax . swing . event . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . io . VFSManager ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . * ; public class IOProgressMonitor extends JDialog { public IOProgressMonitor ( View view ) { super ( view , jEdit . getProperty ( "io-progress-monitor.title" ) , false ) ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; caption = new JLabel ( ) ; updateCaption ( ) ; content . add ( BorderLayout . NORTH , caption ) ; Box threadBox = new Box ( BoxLayout . Y_AXIS ) ; threads = new ThreadProgress [ VFSManager . getIOThreadPool ( ) . getThreadCount ( ) ] ; for ( int i = 0 ; i < threads . length ; i ++ ) { threadBox . add ( Box . createVerticalStrut ( 6 ) ) ; threads [ i ] = new ThreadProgress ( i ) ; threadBox . add ( threads [ i ] ) ; } content . add ( BorderLayout . CENTER , threadBox ) ; workThreadHandler = new WorkThreadHandler ( ) ; VFSManager . getIOThreadPool ( ) . addProgressListener ( workThreadHandler ) ; setDefaultCloseOperation ( DISPOSE_ON_CLOSE ) ; pack ( ) ; GUIUtilities . loadGeometry ( this , "io-progress-monitor" ) ; show ( ) ; } public void dispose ( ) { GUIUtilities . saveGeometry ( this , "io-progress-monitor" ) ; VFSManager . getIOThreadPool ( ) . removeProgressListener ( workThreadHandler ) ; super . dispose ( ) ; } private JLabel caption ; private ThreadProgress [ ] threads ; private WorkThreadHandler workThreadHandler ; private void updateCaption ( ) { String [ ] args = { String . valueOf ( VFSManager . getIOThreadPool ( ) . getRequestCount ( ) ) } ; caption . setText ( jEdit . getProperty ( "io-progress-monitor.caption" , args ) ) ; } class WorkThreadHandler implements WorkThreadProgressListener { public void progressUpdate ( WorkThreadPool pool , int index ) { updateCaption ( ) ; threads [ index ] . update ( ) ; } } class ThreadProgress extends JPanel { public ThreadProgress ( int index ) { super ( new BorderLayout ( ) ) ; this . index = index ; JPanel box = new JPanel ( ) ; box . setBorder ( new EmptyBorder ( 0 , 0 , 0 , 12 ) ) ; box . setLayout ( new BoxLayout ( box , BoxLayout . Y_AXIS ) ) ; box . add ( Box . createGlue ( ) ) ; box . add ( progress = new JProgressBar ( ) ) ; progress . setStringPainted ( true ) ; box . add ( Box . createGlue ( ) ) ; ThreadProgress . this . add ( BorderLayout . CENTER , box ) ; abort = new JButton ( jEdit . getProperty ( "io-progress-monitor.abort" ) ) ; abort . addActionListener ( new ActionHandler ( ) ) ; ThreadProgress . this . add ( BorderLayout . EAST , abort ) ; update ( ) ; } public void update ( ) { WorkThread thread = VFSManager . getIOThreadPool ( ) . getThread ( index ) ; if ( thread . isRequestRunning ( ) ) { abort . setEnabled ( true ) ; progress . setString ( thread . getStatus ( ) ) ; progress . setMaximum ( thread . getProgressMaximum ( ) ) ; progress . setValue ( thread . getProgressValue ( ) ) ; } else { abort . setEnabled ( false ) ; progress . setString ( jEdit . getProperty ( "io-progress-monitor" + ".idle" ) ) ; progress . setValue ( 0 ) ; } } private int index ; private JProgressBar progress ; private JButton abort ; class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { if ( evt . getSource ( ) == abort ) { int result = GUIUtilities . confirm ( IOProgressMonitor . this , "abort" , null , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE ) ; if ( result == JOptionPane . YES_OPTION ) { VFSManager . getIOThreadPool ( ) . getThread ( index ) . abortCurrentRequest ( ) ; } } } } } } 	1	['5', '6', '0', '10', '33', '4', '4', '8', '2', '0.666666667', '152', '1', '2', '0.99389313', '0.4', '1', '1', '28.8', '1', '0.8', '1']
package org . gjt . sp . jedit . gui ; import javax . swing . border . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . textarea . JEditTextArea ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . * ; public class BufferSwitcher extends JComboBox { public BufferSwitcher ( EditPane editPane ) { this . editPane = editPane ; setRenderer ( new BufferCellRenderer ( ) ) ; setMaximumRowCount ( 10 ) ; addActionListener ( new ActionHandler ( ) ) ; } public void updateBufferList ( ) { if ( jEdit . getBufferCount ( ) == 0 ) return ; updating = true ; setModel ( new DefaultComboBoxModel ( jEdit . getBuffers ( ) ) ) ; setSelectedItem ( editPane . getBuffer ( ) ) ; updating = false ; } private EditPane editPane ; private boolean updating ; class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { if ( ! updating ) { Buffer buffer = ( Buffer ) getSelectedItem ( ) ; if ( buffer != null ) editPane . setBuffer ( buffer ) ; } } } class BufferCellRenderer extends DefaultListCellRenderer { public Component getListCellRendererComponent ( JList list , Object value , int index , boolean isSelected , boolean cellHasFocus ) { super . getListCellRendererComponent ( list , value , index , isSelected , cellHasFocus ) ; Buffer buffer = ( Buffer ) value ; if ( buffer == null ) setIcon ( null ) ; else setIcon ( buffer . getIcon ( ) ) ; return this ; } } } 	0	['4', '5', '0', '6', '16', '0', '4', '5', '2', '0.5', '62', '1', '1', '0.995856354', '0.416666667', '0', '0', '14', '2', '1', '0']
package org . gjt . sp . jedit . pluginmgr ; import com . microstar . xml . XmlException ; import javax . swing . border . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . io . InterruptedIOException ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; class PluginListDownloadProgress extends JDialog { PluginListDownloadProgress ( PluginManager window ) { super ( JOptionPane . getFrameForComponent ( window ) , jEdit . getProperty ( "plugin-list.progress.title" ) , true ) ; this . window = window ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; JLabel caption = new JLabel ( jEdit . getProperty ( "plugin-list.progress.caption" ) ) ; caption . setBorder ( new EmptyBorder ( 0 , 0 , 12 , 0 ) ) ; content . add ( BorderLayout . NORTH , caption ) ; Box box = new Box ( BoxLayout . X_AXIS ) ; box . add ( Box . createGlue ( ) ) ; JButton stop = new JButton ( jEdit . getProperty ( "plugin-list.progress.stop" ) ) ; stop . addActionListener ( new ActionHandler ( ) ) ; stop . setMaximumSize ( stop . getPreferredSize ( ) ) ; box . add ( stop ) ; box . add ( Box . createGlue ( ) ) ; content . add ( BorderLayout . CENTER , box ) ; addWindowListener ( new WindowHandler ( ) ) ; setDefaultCloseOperation ( DO_NOTHING_ON_CLOSE ) ; pack ( ) ; setLocationRelativeTo ( window ) ; setResizable ( false ) ; show ( ) ; } PluginList getPluginList ( ) { return list ; } private PluginManager window ; private PluginList list ; private DownloadThread thread ; class DownloadThread extends Thread { public void run ( ) { try { list = new PluginList ( ) ; dispose ( ) ; } catch ( InterruptedIOException iio ) { dispose ( ) ; } catch ( XmlException xe ) { dispose ( ) ; int line = xe . getLine ( ) ; String path = jEdit . getProperty ( "plugin-manager.url" ) ; String message = xe . getMessage ( ) ; Log . log ( Log . ERROR , this , path + ":" + line + ": " + message ) ; String [ ] pp = { path , String . valueOf ( line ) , message } ; GUIUtilities . error ( window , "plugin-list.xmlerror" , pp ) ; } catch ( Exception e ) { dispose ( ) ; Log . log ( Log . ERROR , this , e ) ; String [ ] pp = { e . toString ( ) } ; GUIUtilities . error ( window , "plugin-list.ioerror" , pp ) ; } } } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { thread . interrupt ( ) ; } } class WindowHandler extends WindowAdapter { boolean done ; public void windowActivated ( WindowEvent evt ) { if ( done ) return ; done = true ; thread = new DownloadThread ( ) ; thread . start ( ) ; } public void windowClosing ( WindowEvent evt ) { thread . interrupt ( ) ; } } } 	1	['7', '6', '0', '7', '33', '11', '4', '6', '0', '0.777777778', '145', '1', '3', '0.99086758', '0.285714286', '0', '0', '19.28571429', '1', '0.8571', '1']
package gnu . regexp ; final class RETokenEnd extends REToken { private String newline ; RETokenEnd ( int subIndex , String newline ) { super ( subIndex ) ; this . newline = newline ; } boolean match ( CharIndexed input , REMatch mymatch ) { char ch = input . charAt ( mymatch . index ) ; if ( ch == CharIndexed . OUT_OF_BOUNDS ) return ( ( mymatch . eflags & RE . REG_NOTEOL ) > 0 ) ? false : next ( input , mymatch ) ; if ( newline != null ) { char z ; int i = 0 ; do { z = newline . charAt ( i ) ; if ( ch != z ) return false ; ++ i ; ch = input . charAt ( mymatch . index + i ) ; } while ( i < newline . length ( ) ) ; return next ( input , mymatch ) ; } return false ; } void dump ( StringBuffer os ) { os . append ( '$' ) ; } } 	0	['3', '2', '0', '4', '9', '1', '1', '3', '0', '0.5', '71', '1', '0', '0.777777778', '0.444444444', '1', '2', '22.33333333', '6', '2.3333', '0']
package org . gjt . sp . jedit ; import com . microstar . xml . * ; import java . io . * ; import java . util . * ; import org . gjt . sp . jedit . textarea . * ; import org . gjt . sp . util . Log ; public class BufferHistory { public static Entry getEntry ( String path ) { Enumeration enum = history . elements ( ) ; while ( enum . hasMoreElements ( ) ) { Entry entry = ( Entry ) enum . nextElement ( ) ; if ( pathsCaseInsensitive ) { if ( entry . path . equalsIgnoreCase ( path ) ) return entry ; } else { if ( entry . path . equals ( path ) ) return entry ; } } return null ; } public static void setEntry ( String path , int caret , Selection [ ] selection , String encoding ) { removeEntry ( path ) ; addEntry ( new Entry ( path , caret , selectionToString ( selection ) , encoding ) ) ; } public static Vector getBufferHistory ( ) { return history ; } public static void load ( File file ) { try { max = Integer . parseInt ( jEdit . getProperty ( "recentFiles" ) ) ; } catch ( NumberFormatException e ) { max = 50 ; } Log . log ( Log . MESSAGE , jEdit . class , "Loading recent file list " + file ) ; RecentHandler handler = new RecentHandler ( ) ; XmlParser parser = new XmlParser ( ) ; parser . setHandler ( handler ) ; try { BufferedReader in = new BufferedReader ( new FileReader ( file ) ) ; parser . parse ( null , null , in ) ; } catch ( XmlException xe ) { int line = xe . getLine ( ) ; String message = xe . getMessage ( ) ; Log . log ( Log . ERROR , BufferHistory . class , file + ":" + line + ": " + message ) ; } catch ( FileNotFoundException fnf ) { Log . log ( Log . DEBUG , BufferHistory . class , fnf ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , BufferHistory . class , e ) ; } } public static void save ( File file ) { String lineSep = System . getProperty ( "line.separator" ) ; try { BufferedWriter out = new BufferedWriter ( new FileWriter ( file ) ) ; out . write ( "<?xml version=\"1.0\"?>" ) ; out . write ( lineSep ) ; out . write ( "<!DOCTYPE RECENT SYSTEM \"recent.dtd\">" ) ; out . write ( lineSep ) ; out . write ( "<RECENT>" ) ; out . write ( lineSep ) ; Enumeration enum = history . elements ( ) ; while ( enum . hasMoreElements ( ) ) { out . write ( "<ENTRY>" ) ; out . write ( lineSep ) ; Entry entry = ( Entry ) enum . nextElement ( ) ; out . write ( "<PATH><![CDATA[" ) ; out . write ( entry . path ) ; out . write ( "]]></PATH>" ) ; out . write ( lineSep ) ; out . write ( "<CARET>" ) ; out . write ( String . valueOf ( entry . caret ) ) ; out . write ( "</CARET>" ) ; out . write ( lineSep ) ; if ( entry . selection != null && entry . selection . length ( ) > 0 ) { out . write ( "<SELECTION>" ) ; out . write ( entry . selection ) ; out . write ( "</SELECTION>" ) ; out . write ( lineSep ) ; } if ( entry . encoding != null ) { out . write ( "<ENCODING>" ) ; out . write ( entry . encoding ) ; out . write ( "</ENCODING>" ) ; out . write ( lineSep ) ; } out . write ( "</ENTRY>" ) ; out . write ( lineSep ) ; } out . write ( "</RECENT>" ) ; out . write ( lineSep ) ; out . close ( ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , BufferHistory . class , e ) ; } } private static Vector history ; private static boolean pathsCaseInsensitive ; private static int max ; static { history = new Vector ( ) ; pathsCaseInsensitive = ( File . separatorChar == '\\' || File . separatorChar == ':' ) ; } static void addEntry ( Entry entry ) { history . addElement ( entry ) ; while ( history . size ( ) > max ) history . removeElementAt ( 0 ) ; } static void removeEntry ( String path ) { Enumeration enum = history . elements ( ) ; for ( int i = 0 ; i < history . size ( ) ; i ++ ) { Entry entry = ( Entry ) history . elementAt ( i ) ; if ( entry . path . equals ( path ) ) { history . removeElementAt ( i ) ; return ; } } } private static String selectionToString ( Selection [ ] s ) { if ( s == null ) return null ; StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < s . length ; i ++ ) { if ( i != 0 ) buf . append ( ' ' ) ; Selection sel = s [ i ] ; if ( sel instanceof Selection . Range ) buf . append ( "range " ) ; else buf . append ( "rect " ) ; buf . append ( sel . getStart ( ) ) ; buf . append ( ' ' ) ; buf . append ( sel . getEnd ( ) ) ; } return buf . toString ( ) ; } private static Selection [ ] stringToSelection ( String s ) { if ( s == null ) return null ; Vector selection = new Vector ( ) ; StringTokenizer st = new StringTokenizer ( s ) ; while ( st . hasMoreTokens ( ) ) { String type = st . nextToken ( ) ; int start = Integer . parseInt ( st . nextToken ( ) ) ; int end = Integer . parseInt ( st . nextToken ( ) ) ; Selection sel ; if ( type . equals ( "range" ) ) sel = new Selection . Range ( start , end ) ; else sel = new Selection . Rect ( start , end ) ; selection . addElement ( sel ) ; } Selection [ ] returnValue = new Selection [ selection . size ( ) ] ; selection . copyInto ( returnValue ) ; return returnValue ; } public static class Entry { public String path ; public int caret ; public String selection ; public String encoding ; public Selection [ ] getSelection ( ) { return stringToSelection ( selection ) ; } public Entry ( String path , int caret , String selection , String encoding ) { this . path = path ; this . caret = caret ; this . selection = selection ; this . encoding = encoding ; } } static class RecentHandler extends HandlerBase { public Object resolveEntity ( String publicId , String systemId ) { if ( "recent.dtd" . equals ( systemId ) ) { try { return new BufferedReader ( new InputStreamReader ( getClass ( ) . getResourceAsStream ( "recent.dtd" ) ) ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , this , "Error while opening" + " recent.dtd:" ) ; Log . log ( Log . ERROR , this , e ) ; } } return null ; } public void doctypeDecl ( String name , String publicId , String systemId ) throws Exception { if ( "RECENT" . equals ( name ) ) return ; Log . log ( Log . ERROR , this , "recent.xml: DOCTYPE must be RECENT" ) ; } public void endElement ( String name ) { if ( name . equals ( "ENTRY" ) ) { addEntry ( new Entry ( path , caret , selection , encoding ) ) ; path = null ; caret = 0 ; selection = null ; encoding = null ; } else if ( name . equals ( "PATH" ) ) path = charData ; else if ( name . equals ( "CARET" ) ) caret = Integer . parseInt ( charData ) ; else if ( name . equals ( "SELECTION" ) ) selection = charData ; else if ( name . equals ( "ENCODING" ) ) encoding = charData ; } public void charData ( char [ ] ch , int start , int length ) { charData = new String ( ch , start , length ) ; } private String path ; private int caret ; private String selection ; private String encoding ; private String charData ; } } 	1	['13', '1', '0', '11', '61', '44', '4', '10', '6', '0.833333333', '488', '1', '0', '0', '0.180555556', '0', '0', '36.15384615', '6', '2.5385', '1']
package bsh ; import java . lang . reflect . Field ; import java . util . Hashtable ; class LHS implements ParserConstants , java . io . Serializable { NameSpace nameSpace ; static final int VARIABLE = 0 , FIELD = 1 , PROPERTY = 2 , INDEX = 3 ; int type ; String varName ; String propName ; Field field ; Object object ; int index ; LHS ( NameSpace nameSpace , String varName ) { type = VARIABLE ; this . varName = varName ; this . nameSpace = nameSpace ; } LHS ( Field field ) { type = FIELD ; this . object = null ; this . field = field ; } LHS ( Object object , Field field ) { if ( object == null ) throw new NullPointerException ( "constructed empty LHS" ) ; type = FIELD ; this . object = object ; this . field = field ; } LHS ( Object object , String propName ) { if ( object == null ) throw new NullPointerException ( "constructed empty LHS" ) ; type = PROPERTY ; this . object = object ; this . propName = propName ; } LHS ( Object array , int index ) { if ( array == null ) throw new NullPointerException ( "constructed empty LHS" ) ; type = INDEX ; this . object = array ; this . index = index ; } public Object getValue ( ) throws EvalError { if ( type == VARIABLE ) return nameSpace . getVariable ( varName ) ; else if ( type == FIELD ) try { return field . get ( object ) ; } catch ( IllegalAccessException e2 ) { throw new EvalError ( "Can't read field: " + field ) ; } else if ( type == PROPERTY ) try { return Reflect . getObjectProperty ( object , propName ) ; } catch ( ReflectError e ) { Interpreter . debug ( e . getMessage ( ) ) ; throw new EvalError ( "No such property: " + propName ) ; } else if ( type == INDEX ) try { return Reflect . getIndex ( object , index ) ; } catch ( Exception e ) { throw new EvalError ( "Array access: " + e ) ; } throw new InterpreterError ( "LHS type" ) ; } public Object assign ( Object val ) throws EvalError { if ( type == VARIABLE ) nameSpace . setVariable ( varName , val ) ; else if ( type == FIELD ) try { if ( val instanceof Primitive ) val = ( ( Primitive ) val ) . getValue ( ) ; field . set ( object , val ) ; return val ; } catch ( NullPointerException e ) { throw new EvalError ( "LHS (" + field . getName ( ) + ") not a static field." ) ; } catch ( IllegalAccessException e2 ) { throw new EvalError ( "LHS (" + field . getName ( ) + ") can't access field." ) ; } catch ( IllegalArgumentException e3 ) { throw new EvalError ( "Argument type mismatch. " + ( val == null ? "null" : val . getClass ( ) . getName ( ) ) + " not assignable to field " + field . getName ( ) ) ; } else if ( type == PROPERTY ) if ( object instanceof Hashtable ) ( ( Hashtable ) object ) . put ( propName , val ) ; else try { Reflect . setObjectProperty ( object , propName , val ) ; } catch ( ReflectError e ) { Interpreter . debug ( "Assignment: " + e . getMessage ( ) ) ; throw new EvalError ( "No such property: " + propName ) ; } else if ( type == INDEX ) try { Reflect . setIndex ( object , index , val ) ; } catch ( TargetError e1 ) { throw e1 ; } catch ( Exception e ) { throw new EvalError ( "Assignment: " + e . getMessage ( ) ) ; } return val ; } public String toString ( ) { return "LHS" ; } } 	0	['8', '1', '0', '15', '31', '0', '8', '9', '3', '0.766233766', '356', '0', '1', '0', '0.375', '0', '0', '42.125', '1', '0.375', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . border . * ; import javax . swing . text . Segment ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . io . * ; import org . gjt . sp . jedit . textarea . * ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . * ; public class StatusBar extends JPanel { public StatusBar ( View view ) { super ( new BorderLayout ( 3 , 3 ) ) ; setBorder ( new EmptyBorder ( 3 , 0 , 0 , 0 ) ) ; this . view = view ; Border border = new BevelBorder ( BevelBorder . LOWERED ) ; caretStatus = new VICaretStatus ( ) ; caretStatus . setBorder ( border ) ; add ( BorderLayout . WEST , caretStatus ) ; message = new JLabel ( ) ; message . setForeground ( Color . black ) ; message . setBorder ( border ) ; add ( BorderLayout . CENTER , message ) ; MouseHandler mouseHandler = new MouseHandler ( ) ; Box box = new Box ( BoxLayout . X_AXIS ) ; mode = new JLabel ( ) ; mode . setForeground ( Color . black ) ; mode . setBorder ( border ) ; mode . setToolTipText ( jEdit . getProperty ( "view.status.mode-tooltip" ) ) ; mode . addMouseListener ( mouseHandler ) ; box . add ( mode ) ; box . add ( Box . createHorizontalStrut ( 3 ) ) ; encoding = new JLabel ( ) ; encoding . setForeground ( Color . black ) ; encoding . setBorder ( border ) ; encoding . setToolTipText ( jEdit . getProperty ( "view.status.encoding-tooltip" ) ) ; encoding . addMouseListener ( mouseHandler ) ; box . add ( encoding ) ; box . add ( Box . createHorizontalStrut ( 3 ) ) ; multiSelect = new JLabel ( "multi" ) ; multiSelect . setBorder ( border ) ; multiSelect . addMouseListener ( mouseHandler ) ; box . add ( multiSelect ) ; box . add ( Box . createHorizontalStrut ( 3 ) ) ; overwrite = new JLabel ( "over" ) ; overwrite . setBorder ( border ) ; overwrite . addMouseListener ( mouseHandler ) ; box . add ( overwrite ) ; box . add ( Box . createHorizontalStrut ( 3 ) ) ; fold = new JLabel ( "fold" ) ; fold . setBorder ( border ) ; box . add ( fold ) ; updateBufferStatus ( ) ; updateMiscStatus ( ) ; updateFoldStatus ( ) ; box . add ( Box . createHorizontalStrut ( 3 ) ) ; ioProgress = new MiniIOProgress ( ) ; ioProgress . setBorder ( border ) ; ioProgress . addMouseListener ( mouseHandler ) ; box . add ( ioProgress ) ; Dimension dim = multiSelect . getPreferredSize ( ) ; dim . width = 40 ; ioProgress . setPreferredSize ( dim ) ; add ( BorderLayout . EAST , box ) ; } public void setMessageAndClear ( String message ) { setMessage ( message ) ; tempTimer = new Timer ( 0 , new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { setMessage ( null ) ; } } ) ; tempTimer . setInitialDelay ( 10000 ) ; tempTimer . setRepeats ( false ) ; tempTimer . start ( ) ; } public void setMessage ( String message ) { if ( tempTimer != null ) { tempTimer . stop ( ) ; tempTimer = null ; } if ( message == null ) { InputHandler inputHandler = view . getInputHandler ( ) ; if ( inputHandler . isRepeatEnabled ( ) ) { int repeatCount = inputHandler . getRepeatCount ( ) ; this . message . setText ( jEdit . getProperty ( "view.status.repeat" , new Object [ ] { repeatCount == 1 ? "" : String . valueOf ( repeatCount ) } ) ) ; } else if ( view . getMacroRecorder ( ) != null ) this . message . setText ( jEdit . getProperty ( "view.status.recording" ) ) ; else this . message . setText ( null ) ; } else this . message . setText ( message ) ; } public void repaintCaretStatus ( ) { caretStatus . repaint ( ) ; } public void updateBufferStatus ( ) { Buffer buffer = view . getBuffer ( ) ; mode . setText ( buffer . getMode ( ) . getName ( ) ) ; encoding . setText ( buffer . getProperty ( "encoding" ) . toString ( ) ) ; } public void updateMiscStatus ( ) { JEditTextArea textArea = view . getTextArea ( ) ; if ( textArea . isMultipleSelectionEnabled ( ) ) multiSelect . setForeground ( Color . black ) ; else { if ( textArea . getSelectionCount ( ) > 1 ) { multiSelect . setForeground ( UIManager . getColor ( "Label.foreground" ) ) ; } else multiSelect . setForeground ( gray ) ; } if ( textArea . isOverwriteEnabled ( ) ) overwrite . setForeground ( Color . black ) ; else overwrite . setForeground ( gray ) ; } public void updateFoldStatus ( ) { Buffer buffer = view . getBuffer ( ) ; if ( buffer . getLineCount ( ) != buffer . getVirtualLineCount ( ) ) fold . setForeground ( Color . black ) ; else fold . setForeground ( gray ) ; } private View view ; private VICaretStatus caretStatus ; private JLabel message ; private JLabel mode ; private JLabel encoding ; private JLabel multiSelect ; private JLabel overwrite ; private JLabel fold ; private MiniIOProgress ioProgress ; private Color gray = new Color ( 142 , 142 , 142 ) ; StringBuffer buf = new StringBuffer ( ) ; private Timer tempTimer ; class MouseHandler extends MouseAdapter { public void mouseClicked ( MouseEvent evt ) { Object source = evt . getSource ( ) ; if ( source == mode || source == encoding ) new BufferOptions ( view , view . getBuffer ( ) ) ; else if ( source == multiSelect ) view . getTextArea ( ) . toggleMultipleSelectionEnabled ( ) ; else if ( source == overwrite ) view . getTextArea ( ) . toggleOverwriteEnabled ( ) ; else if ( source == ioProgress ) new IOProgressMonitor ( view ) ; } } class VICaretStatus extends JComponent { public VICaretStatus ( ) { VICaretStatus . this . setForeground ( UIManager . getColor ( "Button.foreground" ) ) ; VICaretStatus . this . setBackground ( UIManager . getColor ( "Label.background" ) ) ; VICaretStatus . this . setFont ( UIManager . getFont ( "Label.font" ) ) ; Dimension size = new Dimension ( VICaretStatus . this . getFontMetrics ( VICaretStatus . this . getFont ( ) ) . stringWidth ( testStr ) , 0 ) ; VICaretStatus . this . setPreferredSize ( size ) ; } public void paintComponent ( Graphics g ) { Buffer buffer = view . getBuffer ( ) ; if ( ! buffer . isLoaded ( ) ) return ; FontMetrics fm = g . getFontMetrics ( ) ; JEditTextArea textArea = view . getTextArea ( ) ; int currLine = textArea . getCaretLine ( ) ; int dot = textArea . getCaretPosition ( ) - textArea . getLineStartOffset ( currLine ) ; int virtualPosition = getVirtualPosition ( dot , buffer , textArea ) ; buf . setLength ( 0 ) ; buf . append ( Integer . toString ( currLine + 1 ) ) ; buf . append ( ',' ) ; buf . append ( Integer . toString ( dot + 1 ) ) ; if ( virtualPosition != dot ) { buf . append ( '-' ) ; buf . append ( Integer . toString ( virtualPosition + 1 ) ) ; } buf . append ( ' ' ) ; int firstLine = textArea . getFirstLine ( ) ; int visible = textArea . getVisibleLines ( ) ; int lineCount = textArea . getVirtualLineCount ( ) ; if ( visible >= lineCount ) { buf . append ( "All" ) ; } else if ( firstLine == 0 ) { buf . append ( "Top" ) ; } else if ( firstLine + visible >= lineCount ) { buf . append ( "Bot" ) ; } else { float percent = ( float ) firstLine / ( float ) lineCount * 100.0f ; buf . append ( Integer . toString ( ( int ) percent ) ) ; buf . append ( '%' ) ; } g . drawString ( buf . toString ( ) , VICaretStatus . this . getBorder ( ) . getBorderInsets ( this ) . left + 1 , ( VICaretStatus . this . getHeight ( ) + fm . getAscent ( ) ) / 2 - 1 ) ; } private static final String testStr = "9999,999-999 99%" ; private Segment seg = new Segment ( ) ; private int getVirtualPosition ( int dot , Buffer buffer , JEditTextArea textArea ) { int line = textArea . getCaretLine ( ) ; textArea . getLineText ( line , seg ) ; int virtualPosition = 0 ; int tabSize = buffer . getTabSize ( ) ; for ( int i = 0 ; i < seg . count && i < dot ; ++ i ) { char ch = seg . array [ seg . offset + i ] ; if ( ch == '\t' ) { virtualPosition += tabSize - ( virtualPosition % tabSize ) ; } else { ++ virtualPosition ; } } return virtualPosition ; } } class MiniIOProgress extends JComponent implements WorkThreadProgressListener { public MiniIOProgress ( ) { MiniIOProgress . this . setDoubleBuffered ( true ) ; MiniIOProgress . this . setForeground ( UIManager . getColor ( "Button.foreground" ) ) ; MiniIOProgress . this . setBackground ( UIManager . getColor ( "Button.background" ) ) ; icon = GUIUtilities . loadIcon ( "io.gif" ) ; } public void addNotify ( ) { super . addNotify ( ) ; VFSManager . getIOThreadPool ( ) . addProgressListener ( this ) ; } public void removeNotify ( ) { super . removeNotify ( ) ; VFSManager . getIOThreadPool ( ) . removeProgressListener ( this ) ; } public void progressUpdate ( WorkThreadPool threadPool , int threadIndex ) { MiniIOProgress . this . repaint ( ) ; } public void paintComponent ( Graphics g ) { WorkThreadPool ioThreadPool = VFSManager . getIOThreadPool ( ) ; if ( ioThreadPool . getThreadCount ( ) == 0 ) return ; FontMetrics fm = g . getFontMetrics ( ) ; if ( ioThreadPool . getRequestCount ( ) == 0 ) return ; else { icon . paintIcon ( this , g , MiniIOProgress . this . getWidth ( ) - icon . getIconWidth ( ) - 3 , ( MiniIOProgress . this . getHeight ( ) - icon . getIconHeight ( ) ) / 2 ) ; } Insets insets = MiniIOProgress . this . getBorder ( ) . getBorderInsets ( this ) ; int progressHeight = ( MiniIOProgress . this . getHeight ( ) - insets . top - insets . bottom ) / ioThreadPool . getThreadCount ( ) ; int progressWidth = MiniIOProgress . this . getWidth ( ) - icon . getIconWidth ( ) - insets . left - insets . right - 2 ; for ( int i = 0 ; i < ioThreadPool . getThreadCount ( ) ; i ++ ) { WorkThread thread = ioThreadPool . getThread ( i ) ; int max = thread . getProgressMaximum ( ) ; if ( ! thread . isRequestRunning ( ) || max == 0 ) continue ; int value = thread . getProgressValue ( ) ; double progressRatio = ( ( double ) value / max ) ; progressRatio = Math . min ( progressRatio , 1.0 ) ; g . fillRect ( insets . left , insets . top + i * progressHeight , ( int ) ( progressRatio * progressWidth ) , progressHeight ) ; } } public Dimension getPreferredSize ( ) { return new Dimension ( 40 , icon . getIconHeight ( ) ) ; } private Icon icon ; } } 	1	['14', '5', '0', '20', '72', '37', '17', '11', '8', '0.857142857', '533', '0.928571429', '3', '0.98048048', '0.257142857', '2', '5', '36.07142857', '6', '1.7857', '4']
package gnu . regexp ; final class RETokenEndSub extends REToken { RETokenEndSub ( int subIndex ) { super ( subIndex ) ; } boolean match ( CharIndexed input , REMatch mymatch ) { mymatch . end [ subIndex ] = mymatch . index ; return next ( input , mymatch ) ; } void dump ( StringBuffer os ) { } } 	0	['3', '2', '0', '4', '5', '3', '1', '3', '0', '2', '20', '0', '0', '0.777777778', '0.466666667', '1', '2', '5.666666667', '1', '0.6667', '0']
package org . gjt . sp . jedit ; import gnu . regexp . * ; import java . util . Hashtable ; import org . gjt . sp . jedit . syntax . TokenMarker ; import org . gjt . sp . util . Log ; public class Mode { public Mode ( String name ) { this . name = name ; props = new Hashtable ( ) ; } public void init ( ) { try { String filenameGlob = ( String ) getProperty ( "filenameGlob" ) ; if ( filenameGlob != null && filenameGlob . length ( ) != 0 ) { filenameRE = new RE ( MiscUtilities . globToRE ( filenameGlob ) , RE . REG_ICASE ) ; } String firstlineGlob = ( String ) getProperty ( "firstlineGlob" ) ; if ( firstlineGlob != null && firstlineGlob . length ( ) != 0 ) { firstlineRE = new RE ( MiscUtilities . globToRE ( firstlineGlob ) , RE . REG_ICASE ) ; } } catch ( REException re ) { Log . log ( Log . ERROR , this , "Invalid filename/firstline" + " globs in mode " + name ) ; Log . log ( Log . ERROR , this , re ) ; } } public TokenMarker getTokenMarker ( ) { loadIfNecessary ( ) ; return marker ; } public void setTokenMarker ( TokenMarker marker ) { this . marker = marker ; } public void loadIfNecessary ( ) { if ( marker == null ) jEdit . loadMode ( this ) ; } public Object getProperty ( String key ) { String prefix = "mode." + name + "." ; String property = jEdit . getProperty ( prefix + key ) ; if ( property != null ) { Object value ; try { value = new Integer ( property ) ; } catch ( NumberFormatException nf ) { value = property ; } return value ; } Object value = props . get ( key ) ; if ( value != null ) return value ; String global = jEdit . getProperty ( "buffer." + key ) ; if ( global != null ) { try { return new Integer ( global ) ; } catch ( NumberFormatException nf ) { return global ; } } else return null ; } public boolean getBooleanProperty ( String key ) { Object value = getProperty ( key ) ; if ( "true" . equals ( value ) || "on" . equals ( value ) || "yes" . equals ( value ) ) return true ; else return false ; } public void setProperty ( String key , Object value ) { props . put ( key , value ) ; } public void unsetProperty ( String key ) { props . remove ( key ) ; } public boolean accept ( String fileName , String firstLine ) { if ( filenameRE != null && filenameRE . isMatch ( fileName ) ) return true ; if ( firstlineRE != null && firstlineRE . isMatch ( firstLine ) ) return true ; return false ; } public String getName ( ) { return name ; } public String toString ( ) { return getClass ( ) . getName ( ) + "[" + getName ( ) + "]" ; } private String name ; private Hashtable props ; private RE firstlineRE ; private RE filenameRE ; private TokenMarker marker ; } 	1	['12', '1', '0', '19', '32', '36', '15', '6', '12', '0.745454545', '236', '1', '3', '0', '0.416666667', '0', '0', '18.25', '5', '2', '1']
package gnu . regexp ; final class RETokenRange extends REToken { private char lo , hi ; private boolean insens ; RETokenRange ( int subIndex , char lo , char hi , boolean ins ) { super ( subIndex ) ; this . lo = ( insens = ins ) ? Character . toLowerCase ( lo ) : lo ; this . hi = ins ? Character . toLowerCase ( hi ) : hi ; } int getMinimumLength ( ) { return 1 ; } boolean match ( CharIndexed input , REMatch mymatch ) { char c = input . charAt ( mymatch . index ) ; if ( c == CharIndexed . OUT_OF_BOUNDS ) return false ; if ( insens ) c = Character . toLowerCase ( c ) ; if ( ( c >= lo ) && ( c <= hi ) ) { ++ mymatch . index ; return next ( input , mymatch ) ; } return false ; } void dump ( StringBuffer os ) { os . append ( lo ) . append ( '-' ) . append ( hi ) ; } } 	0	['4', '2', '0', '4', '9', '0', '1', '3', '0', '0.444444444', '80', '1', '0', '0.7', '0.357142857', '1', '2', '18.25', '5', '1.75', '0']
package org . gjt . sp . jedit . browser ; import java . awt . * ; import javax . swing . * ; import javax . swing . tree . * ; import javax . swing . border . * ; import org . gjt . sp . jedit . io . VFS ; import org . gjt . sp . jedit . * ; public final class FileCellRenderer extends JLabel implements TreeCellRenderer { public FileCellRenderer ( ) { Font font = UIManager . getFont ( "Tree.font" ) ; setFont ( new Font ( font . getFamily ( ) , font . getStyle ( ) , font . getSize ( ) ) ) ; UIDefaults metalDefaults = new javax . swing . plaf . metal . MetalLookAndFeel ( ) . getDefaults ( ) ; fileIcon = metalDefaults . getIcon ( "FileView.fileIcon" ) ; dirIcon = metalDefaults . getIcon ( "FileView.directoryIcon" ) ; filesystemIcon = metalDefaults . getIcon ( "FileView.hardDriveIcon" ) ; loadingIcon = metalDefaults . getIcon ( "FileView.hardDriveIcon" ) ; setOpaque ( true ) ; } public Component getTreeCellRendererComponent ( JTree tree , Object value , boolean sel , boolean expanded , boolean leaf , int row , boolean focus ) { if ( sel ) { setBackground ( treeSelectionBackground ) ; setForeground ( treeSelectionForeground ) ; } else { setBackground ( treeNoSelectionBackground ) ; setForeground ( treeNoSelectionForeground ) ; } DefaultMutableTreeNode treeNode = ( DefaultMutableTreeNode ) value ; Object userObject = treeNode . getUserObject ( ) ; if ( userObject instanceof VFS . DirectoryEntry ) { VFS . DirectoryEntry file = ( VFS . DirectoryEntry ) userObject ; boolean opened = ( jEdit . getBuffer ( file . path ) != null ) ; setBorder ( opened ? openBorder : closedBorder ) ; if ( showIcons ) { setIcon ( getIconForFile ( file ) ) ; setText ( file . name ) ; } else { setIcon ( null ) ; setText ( file . type == VFS . DirectoryEntry . DIRECTORY ? file . name + "/" : file . name ) ; } } else if ( userObject instanceof BrowserView . LoadingPlaceholder ) { if ( showIcons ) setIcon ( loadingIcon ) ; else setIcon ( null ) ; setText ( jEdit . getProperty ( "vfs.browser.tree.loading" ) ) ; setBorder ( closedBorder ) ; } else if ( userObject instanceof String ) { if ( showIcons ) { setIcon ( dirIcon ) ; setText ( ( String ) userObject ) ; } else { setIcon ( null ) ; setText ( userObject + "/" ) ; } setBorder ( closedBorder ) ; } else { setIcon ( null ) ; setText ( null ) ; } return this ; } protected Icon getIconForFile ( VFS . DirectoryEntry file ) { if ( file . type == VFS . DirectoryEntry . DIRECTORY ) return dirIcon ; else if ( file . type == VFS . DirectoryEntry . FILESYSTEM ) return filesystemIcon ; else return fileIcon ; } boolean showIcons ; void propertiesChanged ( ) { setBackground ( UIManager . getColor ( "Tree.textBackground" ) ) ; showIcons = jEdit . getBooleanProperty ( "vfs.browser.showIcons" ) ; if ( showIcons ) { closedBorder = new EmptyBorder ( 0 , 3 , 0 , 0 ) ; openBorder = new CompoundBorder ( new MatteBorder ( 0 , 2 , 0 , 0 , UIManager . getColor ( "Tree.textForeground" ) ) , new EmptyBorder ( 0 , 1 , 0 , 0 ) ) ; } else { closedBorder = new EmptyBorder ( 1 , 4 , 1 , 1 ) ; openBorder = new CompoundBorder ( new MatteBorder ( 0 , 2 , 0 , 0 , UIManager . getColor ( "Tree.textForeground" ) ) , new EmptyBorder ( 1 , 2 , 1 , 1 ) ) ; } treeSelectionForeground = UIManager . getColor ( "Tree.selectionForeground" ) ; treeNoSelectionForeground = UIManager . getColor ( "Tree.textForeground" ) ; treeSelectionBackground = UIManager . getColor ( "Tree.selectionBackground" ) ; treeNoSelectionBackground = UIManager . getColor ( "Tree.textBackground" ) ; } private Icon fileIcon ; private Icon dirIcon ; private Icon filesystemIcon ; private Icon loadingIcon ; private Border closedBorder ; private Border openBorder ; private Color treeSelectionForeground ; private Color treeNoSelectionForeground ; private Color treeSelectionBackground ; private Color treeNoSelectionBackground ; } 	1	['4', '5', '0', '5', '32', '0', '1', '4', '2', '0.575757576', '313', '0.909090909', '0', '0.995601173', '0.375', '0', '0', '74.5', '11', '4', '4']
package bsh . commands ; import java . io . * ; import bsh . * ; import java . util . Date ; import java . util . Vector ; import java . util . GregorianCalendar ; import java . util . Calendar ; public class dir { static final String [ ] months = { "Jan" , "Feb" , "Mar" , "Apr" , "May" , "Jun" , "Jul" , "Aug" , "Sep" , "Oct" , "Nov" , "Dec" } ; public static String usage ( ) { return "usage: dir( String dir )\n       dir()" ; } public static void invoke ( Interpreter env , NameSpace namespace ) { String dir = "." ; invoke ( env , namespace , dir ) ; } public static void invoke ( Interpreter env , NameSpace namespace , String dir ) { File file ; try { file = env . pathToFile ( dir ) ; } catch ( IOException e ) { env . println ( "error reading path: " + e ) ; return ; } if ( ! file . exists ( ) || ! file . canRead ( ) ) { env . println ( "Can't read " + file ) ; return ; } if ( ! file . isDirectory ( ) ) { env . println ( "'" + dir + "' is not a directory" ) ; } String [ ] files = file . list ( ) ; files = bubbleSort ( files ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File f = new File ( dir + File . separator + files [ i ] ) ; StringBuffer sb = new StringBuffer ( ) ; sb . append ( f . canRead ( ) ? "r" : "-" ) ; sb . append ( f . canWrite ( ) ? "w" : "-" ) ; sb . append ( "_" ) ; sb . append ( " " ) ; Date d = new Date ( f . lastModified ( ) ) ; GregorianCalendar c = new GregorianCalendar ( ) ; c . setTime ( d ) ; int day = c . get ( Calendar . DAY_OF_MONTH ) ; sb . append ( months [ c . get ( Calendar . MONTH ) ] + " " + day ) ; if ( day < 10 ) sb . append ( " " ) ; sb . append ( " " ) ; int fieldlen = 8 ; StringBuffer len = new StringBuffer ( ) ; for ( int j = 0 ; j < fieldlen ; j ++ ) len . append ( " " ) ; len . insert ( 0 , f . length ( ) ) ; len . setLength ( fieldlen ) ; int si = len . toString ( ) . indexOf ( " " ) ; if ( si != - 1 ) { String pad = len . toString ( ) . substring ( si ) ; len . setLength ( si ) ; len . insert ( 0 , pad ) ; } sb . append ( len ) ; sb . append ( " " + f . getName ( ) ) ; if ( f . isDirectory ( ) ) sb . append ( "/" ) ; env . println ( sb . toString ( ) ) ; } } public static String [ ] bubbleSort ( String [ ] in ) { Vector v = new Vector ( ) ; for ( int i = 0 ; i < in . length ; i ++ ) v . addElement ( in [ i ] ) ; int n = v . size ( ) ; boolean swap = true ; while ( swap ) { swap = false ; for ( int i = 0 ; i < ( n - 1 ) ; i ++ ) if ( ( ( String ) v . elementAt ( i ) ) . compareTo ( ( ( String ) v . elementAt ( i + 1 ) ) ) > 0 ) { String tmp = ( String ) v . elementAt ( i + 1 ) ; v . removeElementAt ( i + 1 ) ; v . insertElementAt ( tmp , i ) ; swap = true ; } } String [ ] out = new String [ n ] ; v . copyInto ( out ) ; return out ; } } 	0	['6', '1', '0', '2', '40', '13', '0', '2', '5', '0.6', '374', '0', '0', '0', '0.28', '0', '0', '61.16666667', '11', '3', '0']
package org . gjt . sp . jedit ; import javax . swing . text . * ; import org . gjt . sp . jedit . syntax . * ; public class TextUtilities { public static int findMatchingBracket ( Buffer buffer , int line , int offset ) throws BadLocationException { return findMatchingBracket ( buffer , line , offset , 0 , buffer . getDefaultRootElement ( ) . getElementCount ( ) ) ; } public static int findMatchingBracket ( Buffer buffer , int line , int offset , int startLine , int endLine ) throws BadLocationException { if ( buffer . getLength ( ) == 0 ) return - 1 ; Element map = buffer . getDefaultRootElement ( ) ; Element lineElement = map . getElement ( line ) ; Segment lineText = new Segment ( ) ; int lineStart = lineElement . getStartOffset ( ) ; buffer . getText ( lineStart , lineElement . getEndOffset ( ) - lineStart - 1 , lineText ) ; char c = lineText . array [ lineText . offset + offset ] ; char cprime ; boolean direction ; switch ( c ) { case '(' : cprime = ')' ; direction = false ; break ; case ')' : cprime = '(' ; direction = true ; break ; case '[' : cprime = ']' ; direction = false ; break ; case ']' : cprime = '[' ; direction = true ; break ; case '{' : cprime = '}' ; direction = false ; break ; case '}' : cprime = '{' ; direction = true ; break ; default : return - 1 ; } int count ; byte idOfBracket = Token . NULL ; Buffer . LineInfo lineInfo = buffer . markTokens ( line ) ; Token lineTokens = lineInfo . getFirstToken ( ) ; int tokenListOffset = 0 ; for ( ; ; ) { if ( lineTokens . id == Token . END ) throw new InternalError ( "offset > line length" ) ; if ( tokenListOffset + lineTokens . length > offset ) { idOfBracket = lineTokens . id ; break ; } else { tokenListOffset += lineTokens . length ; lineTokens = lineTokens . next ; } } if ( direction ) { count = 0 ; for ( int i = line ; i >= startLine ; i -- ) { lineElement = map . getElement ( i ) ; lineStart = lineElement . getStartOffset ( ) ; int lineLength = lineElement . getEndOffset ( ) - lineStart - 1 ; buffer . getText ( lineStart , lineLength , lineText ) ; int scanStartOffset ; if ( i != line ) { lineTokens = buffer . markTokens ( i ) . getLastToken ( ) ; tokenListOffset = scanStartOffset = lineLength - 1 ; } else { if ( tokenListOffset != lineLength ) tokenListOffset += lineTokens . length ; scanStartOffset = offset ; } while ( lineTokens != null ) { byte id = lineTokens . id ; if ( id == Token . END ) { lineTokens = lineTokens . prev ; continue ; } int len = lineTokens . length ; if ( id == idOfBracket ) { for ( int j = scanStartOffset ; j >= Math . max ( 0 , tokenListOffset - len ) ; j -- ) { if ( j >= lineText . count ) System . err . println ( "WARNING: " + j + " >= " + lineText . count ) ; else if ( j < 0 ) { System . err . println ( "sso=" + scanStartOffset + ", tlo=" + tokenListOffset + ",len=" + len ) ; System . err . println ( "WARNING: " + j + " < 0" ) ; } char ch = lineText . array [ lineText . offset + j ] ; if ( ch == c ) count ++ ; else if ( ch == cprime ) { if ( -- count == 0 ) return lineStart + j ; } } } scanStartOffset = tokenListOffset = tokenListOffset - len ; lineTokens = lineTokens . prev ; } } } else { count = 0 ; for ( int i = line ; i < endLine ; i ++ ) { lineElement = map . getElement ( i ) ; lineStart = lineElement . getStartOffset ( ) ; buffer . getText ( lineStart , lineElement . getEndOffset ( ) - lineStart - 1 , lineText ) ; int scanStartOffset ; if ( i != line ) { lineTokens = buffer . markTokens ( i ) . getFirstToken ( ) ; tokenListOffset = 0 ; scanStartOffset = 0 ; } else scanStartOffset = offset + 1 ; for ( ; ; ) { byte id = lineTokens . id ; if ( id == Token . END ) break ; int len = lineTokens . length ; if ( id == idOfBracket ) { for ( int j = scanStartOffset ; j < tokenListOffset + len ; j ++ ) { char ch = lineText . array [ lineText . offset + j ] ; if ( ch == c ) count ++ ; else if ( ch == cprime ) { if ( count -- == 0 ) return lineStart + j ; } } } scanStartOffset = tokenListOffset = tokenListOffset + len ; lineTokens = lineTokens . next ; } } } return - 1 ; } public static int findWordStart ( String line , int pos , String noWordSep ) { char ch = line . charAt ( pos ) ; if ( noWordSep == null ) noWordSep = "" ; boolean selectNoLetter = ( ! Character . isLetterOrDigit ( ch ) && noWordSep . indexOf ( ch ) == - 1 ) ; int wordStart = 0 ; for ( int i = pos ; i >= 0 ; i -- ) { ch = line . charAt ( i ) ; if ( selectNoLetter ^ ( ! Character . isLetterOrDigit ( ch ) && noWordSep . indexOf ( ch ) == - 1 ) ) { wordStart = i + 1 ; break ; } } return wordStart ; } public static int findWordEnd ( String line , int pos , String noWordSep ) { if ( pos != 0 ) pos -- ; char ch = line . charAt ( pos ) ; if ( noWordSep == null ) noWordSep = "" ; boolean selectNoLetter = ( ! Character . isLetterOrDigit ( ch ) && noWordSep . indexOf ( ch ) == - 1 ) ; int wordEnd = line . length ( ) ; for ( int i = pos ; i < line . length ( ) ; i ++ ) { ch = line . charAt ( i ) ; if ( selectNoLetter ^ ( ! Character . isLetterOrDigit ( ch ) && noWordSep . indexOf ( ch ) == - 1 ) ) { wordEnd = i ; break ; } } return wordEnd ; } public static boolean regionMatches ( boolean ignoreCase , Segment text , int offset , char [ ] match ) { int length = offset + match . length ; char [ ] textArray = text . array ; if ( length > text . offset + text . count ) return false ; for ( int i = offset , j = 0 ; i < length ; i ++ , j ++ ) { char c1 = textArray [ i ] ; char c2 = match [ j ] ; if ( ignoreCase ) { c1 = Character . toUpperCase ( c1 ) ; c2 = Character . toUpperCase ( c2 ) ; } if ( c1 != c2 ) return false ; } return true ; } public static String spacesToTabs ( String in , int tabSize ) { StringBuffer buf = new StringBuffer ( ) ; int width = 0 ; int whitespace = 0 ; for ( int i = 0 ; i < in . length ( ) ; i ++ ) { switch ( in . charAt ( i ) ) { case ' ' : whitespace ++ ; width ++ ; break ; case '\t' : int tab = tabSize - ( width % tabSize ) ; width += tab ; whitespace += tab ; break ; case '\n' : if ( whitespace != 0 ) { buf . append ( MiscUtilities . createWhiteSpace ( whitespace , tabSize ) ) ; } whitespace = 0 ; width = 0 ; buf . append ( '\n' ) ; break ; default : if ( whitespace != 0 ) { buf . append ( MiscUtilities . createWhiteSpace ( whitespace , tabSize ) ) ; whitespace = 0 ; } buf . append ( in . charAt ( i ) ) ; width ++ ; break ; } } if ( whitespace != 0 ) { buf . append ( MiscUtilities . createWhiteSpace ( whitespace , tabSize ) ) ; } return buf . toString ( ) ; } public static String tabsToSpaces ( String in , int tabSize ) { StringBuffer buf = new StringBuffer ( ) ; int width = 0 ; for ( int i = 0 ; i < in . length ( ) ; i ++ ) { switch ( in . charAt ( i ) ) { case '\t' : int count = tabSize - ( width % tabSize ) ; width += count ; while ( -- count >= 0 ) buf . append ( ' ' ) ; break ; case '\n' : width = 0 ; buf . append ( in . charAt ( i ) ) ; break ; default : width ++ ; buf . append ( in . charAt ( i ) ) ; break ; } } return buf . toString ( ) ; } public static String format ( String text , int maxLineLength ) { StringBuffer buf = new StringBuffer ( ) ; StringBuffer word = new StringBuffer ( ) ; int lineLength = 0 ; boolean newline = true ; boolean space = false ; char [ ] chars = text . toCharArray ( ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { char c = chars [ i ] ; switch ( c ) { case '\n' : if ( i == 0 || chars . length - i <= 2 ) { if ( lineLength + word . length ( ) >= maxLineLength ) buf . append ( '\n' ) ; else if ( space && word . length ( ) != 0 ) buf . append ( ' ' ) ; buf . append ( word ) ; word . setLength ( 0 ) ; buf . append ( '\n' ) ; newline = true ; space = false ; break ; } else if ( newline ) { if ( lineLength + word . length ( ) >= maxLineLength ) buf . append ( '\n' ) ; else if ( space && word . length ( ) != 0 ) buf . append ( ' ' ) ; buf . append ( word ) ; word . setLength ( 0 ) ; buf . append ( "\n\n" ) ; newline = space = false ; lineLength = 0 ; break ; } else newline = true ; case ' ' : if ( lineLength + word . length ( ) >= maxLineLength ) { buf . append ( '\n' ) ; lineLength = 0 ; newline = true ; } else if ( space && lineLength != 0 && word . length ( ) != 0 ) { buf . append ( ' ' ) ; lineLength ++ ; space = false ; } else space = true ; buf . append ( word ) ; lineLength += word . length ( ) ; word . setLength ( 0 ) ; break ; default : newline = false ; if ( lineLength != 0 ) space = true ; word . append ( c ) ; break ; } } if ( lineLength + word . length ( ) >= maxLineLength ) buf . append ( '\n' ) ; else if ( space && word . length ( ) != 0 ) buf . append ( ' ' ) ; buf . append ( word ) ; return buf . toString ( ) ; } } 	1	['9', '1', '0', '8', '39', '36', '5', '4', '9', '2', '904', '0', '0', '0', '0.301587302', '0', '0', '99.44444444', '20', '6', '5']
package gnu . regexp ; import java . text . MessageFormat ; public class REException extends Exception { private int type ; private int pos ; public static final int REG_BADRPT = 1 ; public static final int REG_BADBR = 2 ; public static final int REG_EBRACE = 3 ; public static final int REG_EBRACK = 4 ; public static final int REG_ERANGE = 5 ; public static final int REG_ECTYPE = 6 ; public static final int REG_EPAREN = 7 ; public static final int REG_ESUBREG = 8 ; public static final int REG_EEND = 9 ; public static final int REG_ESCAPE = 10 ; public static final int REG_BADPAT = 11 ; public static final int REG_ESIZE = 12 ; public static final int REG_ESPACE = 13 ; REException ( String msg , int type , int position ) { super ( msg ) ; this . type = type ; this . pos = position ; } public int getType ( ) { return type ; } public int getPosition ( ) { return pos ; } public String getMessage ( ) { Object [ ] args = { new Integer ( pos ) } ; StringBuffer sb = new StringBuffer ( ) ; String prefix = RE . getLocalizedMessage ( "error.prefix" ) ; sb . append ( MessageFormat . format ( prefix , args ) ) ; sb . append ( '\n' ) ; sb . append ( super . getMessage ( ) ) ; return sb . toString ( ) ; } } 	0	['4', '3', '0', '4', '13', '0', '4', '1', '3', '1.222222222', '71', '0.133333333', '0', '0.85', '0.5', '1', '1', '13', '1', '0.75', '0']
package org . gjt . sp . jedit ; import java . io . * ; import java . lang . reflect . Modifier ; import java . net . * ; import java . util . * ; import java . util . zip . * ; import org . gjt . sp . util . Log ; public class JARClassLoader extends ClassLoader { public JARClassLoader ( ) { } public JARClassLoader ( String path ) throws IOException { zipFile = new ZipFile ( path ) ; Enumeration entires = zipFile . entries ( ) ; while ( entires . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) entires . nextElement ( ) ; String name = entry . getName ( ) ; String lname = name . toLowerCase ( ) ; if ( lname . equals ( "actions.xml" ) ) { jEdit . loadActions ( path + "!actions.xml" , new BufferedReader ( new InputStreamReader ( zipFile . getInputStream ( entry ) ) ) , true ) ; } else if ( lname . endsWith ( ".props" ) ) jEdit . loadProps ( zipFile . getInputStream ( entry ) , true ) ; else if ( name . endsWith ( "Plugin.class" ) ) pluginClasses . addElement ( name ) ; } jar = new EditPlugin . JAR ( path , this ) ; jEdit . addPluginJAR ( jar ) ; } public Class loadClass ( String clazz , boolean resolveIt ) throws ClassNotFoundException { return loadClass ( clazz , resolveIt , true ) ; } public InputStream getResourceAsStream ( String name ) { if ( zipFile == null ) return null ; try { ZipEntry entry = zipFile . getEntry ( name ) ; if ( entry == null ) return getSystemResourceAsStream ( name ) ; else return zipFile . getInputStream ( entry ) ; } catch ( IOException io ) { Log . log ( Log . ERROR , this , io ) ; return null ; } } public URL getResource ( String name ) { if ( zipFile == null ) return null ; ZipEntry entry = zipFile . getEntry ( name ) ; if ( entry == null ) return getSystemResource ( name ) ; try { return new URL ( getResourceAsPath ( name ) ) ; } catch ( MalformedURLException mu ) { Log . log ( Log . ERROR , this , mu ) ; return null ; } } public String getResourceAsPath ( String name ) { if ( zipFile == null ) return null ; if ( ! name . startsWith ( "/" ) ) name = "/" + name ; return "jeditresource:/" + MiscUtilities . getFileName ( jar . getPath ( ) ) + "!" + name ; } public void closeZipFile ( ) { if ( zipFile == null ) return ; try { zipFile . close ( ) ; } catch ( IOException io ) { Log . log ( Log . ERROR , this , io ) ; } zipFile = null ; } public ZipFile getZipFile ( ) { return zipFile ; } void startAllPlugins ( ) { for ( int i = 0 ; i < pluginClasses . size ( ) ; i ++ ) { String name = ( String ) pluginClasses . elementAt ( i ) ; name = MiscUtilities . fileToClass ( name ) ; try { loadPluginClass ( name ) ; } catch ( Throwable t ) { Log . log ( Log . ERROR , this , "Error while starting plugin " + name ) ; Log . log ( Log . ERROR , this , t ) ; jar . addPlugin ( new EditPlugin . Broken ( name ) ) ; String [ ] args = { name , t . toString ( ) } ; GUIUtilities . error ( null , "plugin.start-error" , args ) ; } } } private EditPlugin . JAR jar ; private Vector pluginClasses = new Vector ( ) ; private ZipFile zipFile ; private void loadPluginClass ( String name ) throws Exception { EditPlugin [ ] plugins = jEdit . getPlugins ( ) ; for ( int i = 0 ; i < plugins . length ; i ++ ) { if ( plugins [ i ] . getClass ( ) . getName ( ) . equals ( name ) ) { String [ ] args = { name } ; GUIUtilities . error ( null , "plugin.already-loaded" , args ) ; return ; } } if ( ! checkDependencies ( name ) ) { jar . addPlugin ( new EditPlugin . Broken ( name ) ) ; return ; } Class clazz = loadClass ( name , true ) ; int modifiers = clazz . getModifiers ( ) ; if ( ! Modifier . isInterface ( modifiers ) && ! Modifier . isAbstract ( modifiers ) && EditPlugin . class . isAssignableFrom ( clazz ) ) { String version = jEdit . getProperty ( "plugin." + name + ".version" ) ; if ( version == null ) { Log . log ( Log . WARNING , this , "Plugin " + name + " doesn't" + " have a 'version' property." ) ; version = "" ; } else version = " (version " + version + ")" ; Log . log ( Log . NOTICE , this , "Starting plugin " + name + version ) ; jar . addPlugin ( ( EditPlugin ) clazz . newInstance ( ) ) ; } } private boolean checkDependencies ( String name ) { int i = 0 ; String dep ; while ( ( dep = jEdit . getProperty ( "plugin." + name + ".depend." + i ++ ) ) != null ) { int index = dep . indexOf ( ' ' ) ; if ( index == - 1 ) { Log . log ( Log . ERROR , this , name + " has an invalid" + " dependency: " + dep ) ; return false ; } String what = dep . substring ( 0 , index ) ; String arg = dep . substring ( index + 1 ) ; if ( what . equals ( "jdk" ) ) { if ( System . getProperty ( "java.version" ) . compareTo ( arg ) < 0 ) { String [ ] args = { name , arg , System . getProperty ( "java.version" ) } ; GUIUtilities . error ( null , "plugin.dep-jdk" , args ) ; return false ; } } else if ( what . equals ( "jedit" ) ) { if ( jEdit . getBuild ( ) . compareTo ( arg ) < 0 ) { String needs = MiscUtilities . buildToVersion ( arg ) ; String [ ] args = { name , needs , jEdit . getVersion ( ) } ; GUIUtilities . error ( null , "plugin.dep-jedit" , args ) ; return false ; } } else if ( what . equals ( "plugin" ) ) { int index2 = arg . indexOf ( ' ' ) ; if ( index2 == - 1 ) { Log . log ( Log . ERROR , this , name + " has an invalid dependency: " + dep + " (version is missing)" ) ; return false ; } String plugin = arg . substring ( 0 , index2 ) ; String needVersion = arg . substring ( index2 + 1 ) ; String currVersion = jEdit . getProperty ( "plugin." + plugin + ".version" ) ; if ( currVersion == null ) { String [ ] args = { name , needVersion , plugin } ; GUIUtilities . error ( null , "plugin.dep-plugin.no-version" , args ) ; return false ; } if ( MiscUtilities . compareVersions ( currVersion , needVersion ) < 0 ) { String [ ] args = { name , needVersion , plugin , currVersion } ; GUIUtilities . error ( null , "plugin.dep-plugin" , args ) ; return false ; } if ( jEdit . getPlugin ( plugin ) instanceof EditPlugin . Broken ) { String [ ] args = { name , plugin } ; GUIUtilities . error ( null , "plugin.dep-plugin.broken" , args ) ; return false ; } } else if ( what . equals ( "class" ) ) { try { loadClass ( arg , false ) ; } catch ( Exception e ) { String [ ] args = { name , arg } ; GUIUtilities . error ( null , "plugin.dep-class" , args ) ; return false ; } } else { Log . log ( Log . ERROR , this , name + " has unknown" + " dependency: " + dep ) ; return false ; } } return true ; } private Class findOtherClass ( String clazz , boolean resolveIt ) throws ClassNotFoundException { EditPlugin . JAR [ ] jars = jEdit . getPluginJARs ( ) ; for ( int i = 0 ; i < jars . length ; i ++ ) { JARClassLoader loader = jars [ i ] . getClassLoader ( ) ; Class cls = loader . loadClass ( clazz , resolveIt , false ) ; if ( cls != null ) return cls ; } ClassLoader loader = getClass ( ) . getClassLoader ( ) ; if ( loader != null ) return loader . loadClass ( clazz ) ; return findSystemClass ( clazz ) ; } private Class loadClass ( String clazz , boolean resolveIt , boolean doDepencies ) throws ClassNotFoundException { Class cls = findLoadedClass ( clazz ) ; if ( cls != null ) { if ( resolveIt ) resolveClass ( cls ) ; return cls ; } if ( zipFile == null ) { if ( doDepencies ) return findOtherClass ( clazz , resolveIt ) ; else return null ; } String name = MiscUtilities . classToFile ( clazz ) ; try { ZipEntry entry = zipFile . getEntry ( name ) ; if ( entry == null ) { if ( doDepencies ) return findOtherClass ( clazz , resolveIt ) ; else return null ; } InputStream in = zipFile . getInputStream ( entry ) ; int len = ( int ) entry . getSize ( ) ; byte [ ] data = new byte [ len ] ; int success = 0 ; int offset = 0 ; while ( success < len ) { len -= success ; offset += success ; success = in . read ( data , offset , len ) ; if ( success == - 1 ) { Log . log ( Log . ERROR , this , "Failed to load class " + clazz + " from " + zipFile . getName ( ) ) ; throw new ClassNotFoundException ( clazz ) ; } } cls = defineClass ( clazz , data , 0 , data . length ) ; if ( resolveIt ) resolveClass ( cls ) ; return cls ; } catch ( IOException io ) { Log . log ( Log . ERROR , this , io ) ; throw new ClassNotFoundException ( clazz ) ; } } } 	1	['14', '2', '0', '11', '88', '35', '6', '7', '8', '0.673076923', '889', '1', '1', '0.842105263', '0.619047619', '1', '7', '62.21428571', '10', '2.0714', '4']
package bsh ; class BSHLHSPrimaryExpression extends SimpleNode { BSHLHSPrimaryExpression ( int id ) { super ( id ) ; } public LHS toLHS ( CallStack callstack , Interpreter interpreter ) throws EvalError { int childNum = 0 ; SimpleNode prefixNode = ( SimpleNode ) jjtGetChild ( childNum ++ ) ; Object prefixValue = null ; LHS lhs = null ; if ( prefixNode instanceof BSHAmbiguousName ) { lhs = ( ( BSHAmbiguousName ) prefixNode ) . toLHS ( callstack , interpreter ) ; } else prefixValue = ( ( SimpleNode ) prefixNode ) . eval ( callstack , interpreter ) ; if ( prefixValue != null ) lhs = ( ( BSHLHSPrimarySuffix ) jjtGetChild ( childNum ++ ) ) . doLHSSuffix ( prefixValue , callstack , interpreter ) ; int numChildren = jjtGetNumChildren ( ) ; while ( childNum < numChildren ) lhs = ( ( BSHLHSPrimarySuffix ) jjtGetChild ( childNum ++ ) ) . doLHSSuffix ( lhs . getValue ( ) , callstack , interpreter ) ; return lhs ; } } 	0	['2', '2', '0', '11', '9', '1', '3', '8', '1', '2', '65', '0', '0', '0.947368421', '0.625', '0', '0', '31.5', '1', '0.5', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . KeyStroke ; import java . awt . event . * ; import java . awt . Toolkit ; import java . util . Hashtable ; import java . util . StringTokenizer ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class DefaultInputHandler extends InputHandler { public DefaultInputHandler ( View view ) { super ( view ) ; bindings = currentBindings = new Hashtable ( ) ; } public DefaultInputHandler ( View view , DefaultInputHandler copy ) { super ( view ) ; bindings = currentBindings = copy . bindings ; } public void addKeyBinding ( String keyBinding , EditAction action ) { Hashtable current = bindings ; StringTokenizer st = new StringTokenizer ( keyBinding ) ; while ( st . hasMoreTokens ( ) ) { KeyStroke keyStroke = parseKeyStroke ( st . nextToken ( ) ) ; if ( keyStroke == null ) return ; if ( st . hasMoreTokens ( ) ) { Object o = current . get ( keyStroke ) ; if ( o instanceof Hashtable ) current = ( Hashtable ) o ; else { o = new Hashtable ( ) ; current . put ( keyStroke , o ) ; current = ( Hashtable ) o ; } } else current . put ( keyStroke , action ) ; } } public void removeKeyBinding ( String keyBinding ) { throw new InternalError ( "Not yet implemented" ) ; } public void removeAllKeyBindings ( ) { bindings . clear ( ) ; } public Object getKeyBinding ( String keyBinding ) { Hashtable current = bindings ; StringTokenizer st = new StringTokenizer ( keyBinding ) ; while ( st . hasMoreTokens ( ) ) { KeyStroke keyStroke = parseKeyStroke ( st . nextToken ( ) ) ; if ( keyStroke == null ) return null ; if ( st . hasMoreTokens ( ) ) { Object o = current . get ( keyStroke ) ; if ( o instanceof Hashtable ) current = ( Hashtable ) o ; else return o ; } else { return current . get ( keyStroke ) ; } } return null ; } public boolean isPrefixActive ( ) { return bindings != currentBindings ; } public void keyPressed ( KeyEvent evt ) { int keyCode = evt . getKeyCode ( ) ; int modifiers = evt . getModifiers ( ) ; if ( modifiers == 0 && bindings == currentBindings && ( keyCode == KeyEvent . VK_ENTER || keyCode == KeyEvent . VK_TAB ) ) { userInput ( ( char ) keyCode ) ; evt . consume ( ) ; return ; } if ( ( modifiers & ~ KeyEvent . SHIFT_MASK ) == 0 ) { switch ( keyCode ) { case KeyEvent . VK_BACK_SPACE : case KeyEvent . VK_DELETE : case KeyEvent . VK_ESCAPE : case KeyEvent . VK_ENTER : case KeyEvent . VK_TAB : break ; default : if ( ! evt . isActionKey ( ) ) return ; else break ; } } if ( readNextChar != null ) { readNextChar = null ; view . getStatus ( ) . setMessage ( null ) ; } KeyStroke keyStroke = KeyStroke . getKeyStroke ( keyCode , modifiers ) ; Object o = currentBindings . get ( keyStroke ) ; if ( o == null ) { if ( currentBindings != bindings ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; repeatCount = 0 ; repeat = false ; evt . consume ( ) ; } currentBindings = bindings ; return ; } else if ( o instanceof EditAction ) { currentBindings = bindings ; invokeAction ( ( EditAction ) o ) ; evt . consume ( ) ; return ; } else if ( o instanceof Hashtable ) { currentBindings = ( Hashtable ) o ; evt . consume ( ) ; return ; } } public void keyTyped ( KeyEvent evt ) { char c = evt . getKeyChar ( ) ; if ( c == '\b' ) return ; KeyStroke keyStroke ; if ( c == ' ' ) keyStroke = KeyStroke . getKeyStroke ( KeyEvent . VK_SPACE , 0 ) ; else keyStroke = KeyStroke . getKeyStroke ( c ) ; Object o = currentBindings . get ( keyStroke ) ; if ( o instanceof Hashtable ) { currentBindings = ( Hashtable ) o ; return ; } else if ( o instanceof EditAction ) { currentBindings = bindings ; invokeAction ( ( EditAction ) o ) ; return ; } currentBindings = bindings ; if ( repeat && Character . isDigit ( c ) ) { repeatCount *= 10 ; repeatCount += ( c - '0' ) ; view . getStatus ( ) . setMessage ( null ) ; } else userInput ( c ) ; } public static KeyStroke parseKeyStroke ( String keyStroke ) { if ( keyStroke == null ) return null ; int modifiers = 0 ; int index = keyStroke . indexOf ( '+' ) ; if ( index != - 1 ) { for ( int i = 0 ; i < index ; i ++ ) { switch ( Character . toUpperCase ( keyStroke . charAt ( i ) ) ) { case 'A' : modifiers |= InputEvent . ALT_MASK ; break ; case 'C' : if ( macOS ) modifiers |= InputEvent . META_MASK ; else modifiers |= InputEvent . CTRL_MASK ; break ; case 'M' : if ( macOS ) modifiers |= InputEvent . CTRL_MASK ; else modifiers |= InputEvent . META_MASK ; break ; case 'S' : modifiers |= InputEvent . SHIFT_MASK ; break ; } } } String key = keyStroke . substring ( index + 1 ) ; if ( key . length ( ) == 1 ) { char ch = key . charAt ( 0 ) ; if ( modifiers == 0 ) return KeyStroke . getKeyStroke ( ch ) ; else { return KeyStroke . getKeyStroke ( Character . toUpperCase ( ch ) , modifiers ) ; } } else if ( key . length ( ) == 0 ) { Log . log ( Log . ERROR , DefaultInputHandler . class , "Invalid key stroke: " + keyStroke ) ; return null ; } else { int ch ; try { ch = KeyEvent . class . getField ( "VK_" . concat ( key ) ) . getInt ( null ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , DefaultInputHandler . class , "Invalid key stroke: " + keyStroke ) ; return null ; } return KeyStroke . getKeyStroke ( ch , modifiers ) ; } } private Hashtable bindings ; private Hashtable currentBindings ; private static boolean macOS ; static { macOS = ( System . getProperty ( "os.name" ) . indexOf ( "MacOS" ) != - 1 ) ; } } 	1	['12', '3', '0', '6', '52', '8', '2', '5', '10', '0.672727273', '501', '1', '0', '0.666666667', '0.303030303', '1', '4', '40.33333333', '17', '4.3333', '5']
package bsh ; import java . net . * ; import java . util . * ; import java . io . IOException ; import java . io . * ; public abstract class BshClassManager { private static BshClassManager manager ; private static boolean checkedForManager ; private static Object NOVALUE = new Object ( ) ; private static ClassLoader externalClassLoader ; protected transient static Hashtable absoluteClassCache = new Hashtable ( ) ; protected transient static Hashtable absoluteNonClasses = new Hashtable ( ) ; public static BshClassManager getClassManager ( ) { if ( ! checkedForManager && manager == null ) try { if ( plainClassForName ( "java.lang.ref.WeakReference" ) != null && plainClassForName ( "java.util.HashMap" ) != null ) { Class bcm = plainClassForName ( "bsh.classpath.ClassManagerImpl" ) ; manager = ( BshClassManager ) bcm . newInstance ( ) ; } } catch ( ClassNotFoundException e ) { } catch ( Exception e ) { System . err . println ( "Error loading classmanager: " + e ) ; } checkedForManager = true ; return manager ; } public static boolean classExists ( String name ) { return ( classForName ( name ) != null ) ; } public static Class classForName ( String name ) { BshClassManager manager = getClassManager ( ) ; if ( manager != null ) return manager . getClassForName ( name ) ; else try { return plainClassForName ( name ) ; } catch ( ClassNotFoundException e ) { return null ; } } public static Class plainClassForName ( String name ) throws ClassNotFoundException { try { Class c ; if ( externalClassLoader != null ) { c = externalClassLoader . loadClass ( name ) ; } else c = Class . forName ( name ) ; cacheClassInfo ( name , c ) ; return c ; } catch ( NoClassDefFoundError e ) { cacheClassInfo ( name , null ) ; throw new ClassNotFoundException ( e . toString ( ) ) ; } } public static void cacheClassInfo ( String name , Class value ) { if ( value != null ) absoluteClassCache . put ( name , value ) ; else absoluteNonClasses . put ( name , NOVALUE ) ; } protected void clearCaches ( ) { absoluteNonClasses = new Hashtable ( ) ; absoluteClassCache = new Hashtable ( ) ; } public static void addCMListener ( Listener l ) { getClassManager ( ) ; if ( manager != null ) manager . addListener ( l ) ; } public static void setClassLoader ( ClassLoader externalCL ) { externalClassLoader = externalCL ; } public static interface Listener { public void classLoaderChanged ( ) ; } public abstract Class getClassForName ( String name ) ; public abstract ClassLoader getBaseLoader ( ) ; public abstract ClassLoader getLoaderForClass ( String name ) ; public abstract void addClassPath ( URL path ) throws IOException ; public abstract void reset ( ) ; public abstract void setClassPath ( URL [ ] cp ) ; public abstract void reloadAllClasses ( ) throws ClassPathException ; public abstract void reloadClasses ( String [ ] classNames ) throws ClassPathException ; public abstract void reloadPackage ( String pack ) throws ClassPathException ; public abstract void doSuperImport ( ) throws EvalError ; public abstract String getClassNameByUnqName ( String name ) throws ClassPathException ; public abstract void addListener ( Listener l ) ; public abstract void removeListener ( Listener l ) ; public abstract void dump ( PrintWriter pw ) ; protected abstract void classLoaderChanged ( ) ; } 	0	['25', '1', '0', '10', '37', '290', '7', '3', '22', '0.888888889', '161', '1', '1', '0', '0.157407407', '0', '0', '5.2', '3', '1.16', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . border . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . lang . reflect . Field ; import java . util . * ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class GrabKeyDialog extends JDialog { public GrabKeyDialog ( Component comp , KeyBinding binding , Vector allBindings ) { super ( JOptionPane . getFrameForComponent ( comp ) , jEdit . getProperty ( "grab-key.title" ) , true ) ; this . binding = binding ; this . allBindings = allBindings ; enableEvents ( AWTEvent . KEY_EVENT_MASK ) ; JPanel content = new JPanel ( new GridLayout ( 0 , 1 , 0 , 6 ) ) { public boolean isManagingFocus ( ) { return false ; } public boolean getFocusTraversalKeysEnabled ( ) { return false ; } } ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; JLabel label = new JLabel ( jEdit . getProperty ( "grab-key.caption" , new String [ ] { binding . label } ) ) ; Box input = Box . createHorizontalBox ( ) ; shortcut = new InputPane ( ) ; input . add ( shortcut ) ; input . add ( Box . createHorizontalStrut ( 12 ) ) ; clear = new JButton ( jEdit . getProperty ( "grab-key.clear" ) ) ; clear . addActionListener ( new ActionHandler ( ) ) ; input . add ( clear ) ; assignedTo = new JLabel ( ) ; updateAssignedTo ( null ) ; Box buttons = Box . createHorizontalBox ( ) ; buttons . add ( Box . createGlue ( ) ) ; ok = new JButton ( jEdit . getProperty ( "common.ok" ) ) ; ok . addActionListener ( new ActionHandler ( ) ) ; buttons . add ( ok ) ; buttons . add ( Box . createHorizontalStrut ( 12 ) ) ; if ( binding . isAssigned ( ) ) { remove = new JButton ( jEdit . getProperty ( "grab-key.remove" ) ) ; remove . addActionListener ( new ActionHandler ( ) ) ; buttons . add ( remove ) ; buttons . add ( Box . createHorizontalStrut ( 12 ) ) ; } cancel = new JButton ( jEdit . getProperty ( "common.cancel" ) ) ; cancel . addActionListener ( new ActionHandler ( ) ) ; buttons . add ( cancel ) ; buttons . add ( Box . createGlue ( ) ) ; content . add ( label ) ; content . add ( input ) ; content . add ( assignedTo ) ; content . add ( buttons ) ; setDefaultCloseOperation ( DISPOSE_ON_CLOSE ) ; pack ( ) ; setLocationRelativeTo ( comp ) ; setResizable ( false ) ; show ( ) ; } public String getShortcut ( ) { if ( isOK ) return shortcut . getText ( ) ; else return null ; } public boolean isOK ( ) { return isOK ; } public boolean isManagingFocus ( ) { return false ; } public boolean getFocusTraversalKeysEnabled ( ) { return false ; } protected void processKeyEvent ( KeyEvent evt ) { shortcut . processKeyEvent ( evt ) ; } private InputPane shortcut ; private JLabel assignedTo ; private JButton ok ; private JButton remove ; private JButton cancel ; private JButton clear ; private boolean isOK ; private KeyBinding binding ; private Vector allBindings ; private String getSymbolicName ( int keyCode ) { if ( keyCode == KeyEvent . VK_UNDEFINED ) return null ; if ( keyCode >= KeyEvent . VK_A && keyCode <= KeyEvent . VK_Z ) return String . valueOf ( Character . toLowerCase ( ( char ) keyCode ) ) ; try { Field [ ] fields = KeyEvent . class . getFields ( ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { Field field = fields [ i ] ; String name = field . getName ( ) ; if ( name . startsWith ( "VK_" ) && field . getInt ( null ) == keyCode ) { return name . substring ( 3 ) ; } } } catch ( Exception e ) { Log . log ( Log . ERROR , this , e ) ; } return null ; } private void updateAssignedTo ( String shortcut ) { String text = jEdit . getProperty ( "grab-key.assigned-to.none" ) ; KeyBinding kb = getKeyBinding ( shortcut ) ; if ( kb != null ) if ( kb . isPrefix ) text = jEdit . getProperty ( "grab-key.assigned-to.prefix" , new String [ ] { shortcut } ) ; else text = kb . label ; if ( ok != null ) ok . setEnabled ( kb == null || ! kb . isPrefix ) ; assignedTo . setText ( jEdit . getProperty ( "grab-key.assigned-to" , new String [ ] { text } ) ) ; } private KeyBinding getKeyBinding ( String shortcut ) { if ( shortcut == null || shortcut . length ( ) == 0 ) return null ; String spacedShortcut = shortcut + " " ; Enumeration enum = allBindings . elements ( ) ; while ( enum . hasMoreElements ( ) ) { KeyBinding kb = ( KeyBinding ) enum . nextElement ( ) ; if ( ! kb . isAssigned ( ) ) continue ; String spacedKbShortcut = kb . shortcut + " " ; if ( spacedShortcut . startsWith ( spacedKbShortcut ) ) return kb ; if ( spacedKbShortcut . startsWith ( spacedShortcut ) ) { return new KeyBinding ( kb . name , kb . label , shortcut , true ) ; } } return null ; } public static class KeyBinding { public KeyBinding ( String name , String label , String shortcut , boolean isPrefix ) { this . name = name ; this . label = label ; this . shortcut = shortcut ; this . isPrefix = isPrefix ; } public String name ; public String label ; public String shortcut ; public boolean isPrefix ; public boolean isAssigned ( ) { return shortcut != null && shortcut . length ( ) > 0 ; } } class InputPane extends JTextField { public boolean getFocusTraversalKeysEnabled ( ) { return false ; } protected void processKeyEvent ( KeyEvent _evt ) { if ( _evt . getID ( ) != KeyEvent . KEY_PRESSED ) return ; KeyEvent evt = KeyEventWorkaround . processKeyEvent ( _evt ) ; if ( evt == null ) { Log . log ( Log . DEBUG , this , "Event " + _evt + " filtered" ) ; return ; } else Log . log ( Log . DEBUG , this , "Event " + _evt + " passed" ) ; evt . consume ( ) ; StringBuffer keyString = new StringBuffer ( getText ( ) ) ; if ( getDocument ( ) . getLength ( ) != 0 ) keyString . append ( ' ' ) ; boolean appendPlus = false ; if ( evt . isControlDown ( ) ) { keyString . append ( macOS ? 'M' : 'C' ) ; appendPlus = true ; } if ( evt . isAltDown ( ) ) { keyString . append ( 'A' ) ; appendPlus = true ; } if ( evt . isMetaDown ( ) ) { keyString . append ( macOS ? 'C' : 'M' ) ; appendPlus = true ; } if ( evt . getID ( ) != KeyEvent . KEY_TYPED && evt . isShiftDown ( ) ) { keyString . append ( 'S' ) ; appendPlus = true ; } if ( appendPlus ) keyString . append ( '+' ) ; int keyCode = evt . getKeyCode ( ) ; String symbolicName = getSymbolicName ( keyCode ) ; if ( symbolicName == null ) return ; keyString . append ( symbolicName ) ; setText ( keyString . toString ( ) ) ; updateAssignedTo ( keyString . toString ( ) ) ; } private boolean macOS = ( System . getProperty ( "os.name" ) . indexOf ( "MacOS" ) != - 1 ) ; } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { if ( evt . getSource ( ) == ok ) { if ( canClose ( ) ) dispose ( ) ; } else if ( evt . getSource ( ) == remove ) { shortcut . setText ( null ) ; isOK = true ; dispose ( ) ; } else if ( evt . getSource ( ) == cancel ) dispose ( ) ; else if ( evt . getSource ( ) == clear ) { shortcut . setText ( null ) ; updateAssignedTo ( null ) ; } } private boolean canClose ( ) { String shortcutString = shortcut . getText ( ) ; if ( shortcutString . length ( ) == 0 && binding . isAssigned ( ) ) { int answer = GUIUtilities . confirm ( GrabKeyDialog . this , "grab-key.remove-ask" , null , JOptionPane . YES_NO_CANCEL_OPTION , JOptionPane . QUESTION_MESSAGE ) ; if ( answer == JOptionPane . YES_OPTION ) { shortcut . setText ( null ) ; isOK = true ; } else if ( answer == JOptionPane . CANCEL_OPTION ) return false ; return true ; } KeyBinding other = getKeyBinding ( shortcutString ) ; if ( other == null || other == binding ) { isOK = true ; return true ; } if ( other . name == binding . name ) { GUIUtilities . error ( GrabKeyDialog . this , "grab-key.duplicate-alt-shortcut" , null ) ; return false ; } if ( other . isPrefix ) { GUIUtilities . error ( GrabKeyDialog . this , "grab-key.prefix-shortcut" , null ) ; return false ; } int answer = GUIUtilities . confirm ( GrabKeyDialog . this , "grab-key.duplicate-shortcut" , new Object [ ] { other . label } , JOptionPane . YES_NO_CANCEL_OPTION , JOptionPane . QUESTION_MESSAGE ) ; if ( answer == JOptionPane . YES_OPTION ) { if ( other . shortcut != null && shortcutString . startsWith ( other . shortcut ) ) { other . shortcut = null ; } isOK = true ; return true ; } else if ( answer == JOptionPane . CANCEL_OPTION ) return false ; return true ; } } } 	1	['21', '6', '0', '7', '71', '170', '4', '6', '5', '0.9', '508', '1', '2', '0.970193741', '0.169312169', '1', '1', '22.71428571', '8', '1.8571', '1']
package bsh ; import java . lang . reflect . Array ; import java . util . Hashtable ; import java . io . * ; import java . lang . reflect . InvocationTargetException ; class Name implements java . io . Serializable { public NameSpace namespace ; String value = null ; private String evalName ; private Object evalBaseObject ; private int callstackDepth ; private boolean literalThisReference ; private boolean literalCallerReference ; private void reset ( ) { evalName = value ; evalBaseObject = null ; callstackDepth = 0 ; literalThisReference = false ; literalCallerReference = false ; } public Name ( NameSpace namespace , String s ) { this . namespace = namespace ; value = s ; } public Object toObject ( CallStack callstack , Interpreter interpreter ) throws EvalError { return toObject ( callstack , interpreter , false ) ; } synchronized public Object toObject ( CallStack callstack , Interpreter interpreter , boolean forceClass ) throws EvalError { reset ( ) ; Object obj = null ; while ( evalName != null ) obj = consumeNextObjectField ( callstack , interpreter , forceClass ) ; if ( obj == null ) throw new InterpreterError ( "null value in toObject()" ) ; return obj ; } private Object consumeNextObjectField ( CallStack callstack , Interpreter interpreter , boolean forceClass ) throws EvalError { if ( ( evalBaseObject == null && ! isCompound ( evalName ) ) && ! forceClass ) { Object obj = resolveThisFieldReference ( callstack , namespace , interpreter , evalName , false ) ; if ( obj != Primitive . VOID ) { evalName = null ; return evalBaseObject = obj ; } } if ( ( evalBaseObject == null || evalBaseObject instanceof This ) && ! forceClass ) { String varName = prefix ( evalName , 1 ) ; Interpreter . debug ( "trying to resolve variable: " + varName ) ; Object obj ; if ( evalBaseObject == null ) { obj = resolveThisFieldReference ( callstack , namespace , interpreter , varName , false ) ; } else { obj = resolveThisFieldReference ( callstack , ( ( This ) evalBaseObject ) . namespace , interpreter , varName , true ) ; } if ( obj != Primitive . VOID ) { Interpreter . debug ( "resolved variable: " + varName + " in namespace: " + namespace ) ; evalName = suffix ( evalName ) ; return evalBaseObject = obj ; } } if ( evalBaseObject == null ) { Interpreter . debug ( "trying class: " + evalName ) ; Class clas = null ; int i = 1 ; for ( ; i <= countParts ( evalName ) ; i ++ ) if ( ( clas = namespace . getClass ( prefix ( evalName , i ) ) ) != null ) break ; if ( clas != null ) { evalName = suffix ( evalName , countParts ( evalName ) - i ) ; return ( evalBaseObject = new ClassIdentifier ( clas ) ) ; } Interpreter . debug ( "not a class, trying var prefix " + evalName ) ; } if ( evalBaseObject == null ) { if ( ! isCompound ( evalName ) ) { evalName = null ; return evalBaseObject = Primitive . VOID ; } else throw new EvalError ( "Class or variable not found:" + evalName ) ; } if ( evalBaseObject == Primitive . NULL ) throw new TargetError ( "Null Pointer while evaluating: " + value , new NullPointerException ( ) ) ; if ( evalBaseObject == Primitive . VOID ) throw new EvalError ( "Undefined variable or class name while evaluating: " + value ) ; if ( evalBaseObject instanceof Primitive ) throw new EvalError ( "Can't treat primitive like an object. " + "Error while evaluating: " + value ) ; if ( evalBaseObject instanceof ClassIdentifier ) { Class clas = ( ( ClassIdentifier ) evalBaseObject ) . getTargetClass ( ) ; String field = prefix ( evalName , 1 ) ; Object obj = null ; try { obj = Reflect . getStaticField ( clas , field ) ; } catch ( ReflectError e ) { } if ( obj == null ) { String iclass = clas . getName ( ) + "$" + field ; Class c = namespace . getClass ( iclass ) ; if ( c != null ) obj = new ClassIdentifier ( c ) ; } if ( obj == null ) throw new EvalError ( "No static field or inner class: " + field + " of " + clas ) ; evalName = suffix ( evalName ) ; return ( evalBaseObject = obj ) ; } if ( forceClass ) throw new EvalError ( value + " does not resolve to a class name." ) ; String field = prefix ( evalName , 1 ) ; if ( field . equals ( "length" ) && evalBaseObject . getClass ( ) . isArray ( ) ) { Object obj = new Primitive ( Array . getLength ( evalBaseObject ) ) ; evalName = suffix ( evalName ) ; return ( evalBaseObject = obj ) ; } try { Object obj = Reflect . getObjectField ( evalBaseObject , field ) ; evalName = suffix ( evalName ) ; return ( evalBaseObject = obj ) ; } catch ( ReflectError e ) { } throw new EvalError ( "Cannot access field: " + field + ", on object: " + evalBaseObject ) ; } Object resolveThisFieldReference ( CallStack callstack , NameSpace thisNamespace , Interpreter interpreter , String varName , boolean specialFieldsVisible ) throws EvalError { Object obj = null ; boolean wasThis = false , wasCaller = false ; if ( varName . equals ( "this" ) ) { if ( specialFieldsVisible ) throw new EvalError ( "Redundant to call .this on This type" ) ; obj = thisNamespace . getThis ( interpreter ) ; wasThis = true ; } if ( obj == null ) { if ( varName . equals ( "super" ) ) obj = thisNamespace . getSuper ( ) . getThis ( interpreter ) ; else if ( varName . equals ( "global" ) ) obj = thisNamespace . getGlobal ( ) . getThis ( interpreter ) ; } if ( obj == null && specialFieldsVisible ) { if ( varName . equals ( "namespace" ) ) obj = thisNamespace ; else if ( varName . equals ( "variables" ) ) obj = thisNamespace . getVariableNames ( ) ; else if ( varName . equals ( "methods" ) ) obj = thisNamespace . getMethodNames ( ) ; else if ( varName . equals ( "interpreter" ) ) if ( literalThisReference ) obj = interpreter ; else throw new EvalError ( "Can only call .interpreter on literal 'this'" ) ; } if ( obj == null && specialFieldsVisible && varName . equals ( "caller" ) ) { if ( literalThisReference || literalCallerReference ) { if ( callstack == null ) throw new InterpreterError ( "no callstack" ) ; obj = callstack . get ( ++ callstackDepth ) . getThis ( interpreter ) ; } else throw new EvalError ( "Can only call .caller on literal 'this' or literal '.caller'" ) ; wasCaller = true ; } if ( obj == null && specialFieldsVisible && varName . equals ( "callstack" ) ) { if ( literalThisReference ) { if ( callstack == null ) throw new InterpreterError ( "no callstack" ) ; obj = callstack ; } else throw new EvalError ( "Can only call .callstack on literal 'this'" ) ; } if ( obj == null ) obj = thisNamespace . getVariable ( varName ) ; literalThisReference = wasThis ; literalCallerReference = wasCaller ; return obj ; } synchronized public Class toClass ( ) throws EvalError { reset ( ) ; Class clas = namespace . getClass ( evalName ) ; if ( clas == null ) { Object obj = null ; try { obj = toObject ( null , null , true ) ; } catch ( EvalError e ) { } ; if ( obj instanceof ClassIdentifier ) clas = ( ( ClassIdentifier ) obj ) . getTargetClass ( ) ; } if ( clas == null ) throw new EvalError ( "Class: " + value + " not found in namespace" ) ; return clas ; } synchronized public LHS toLHS ( CallStack callstack , Interpreter interpreter ) throws EvalError { reset ( ) ; if ( ! isCompound ( evalName ) ) { return new LHS ( namespace , evalName ) ; } Object obj = null ; try { while ( isCompound ( evalName ) ) obj = consumeNextObjectField ( callstack , interpreter , false ) ; } catch ( EvalError e ) { throw new EvalError ( "LHS evaluation: " + e ) ; } if ( obj == null ) throw new InterpreterError ( "internal error 2893749283" ) ; if ( obj instanceof This ) { Interpreter . debug ( "found This reference evaluating LHS" ) ; return new LHS ( ( ( This ) obj ) . namespace , evalName ) ; } if ( evalName != null ) { try { if ( obj instanceof ClassIdentifier ) { Class clas = ( ( ClassIdentifier ) obj ) . getTargetClass ( ) ; return Reflect . getLHSStaticField ( clas , evalName ) ; } else return Reflect . getLHSObjectField ( obj , evalName ) ; } catch ( ReflectError e ) { throw new EvalError ( "Field access: " + e ) ; } } throw new InterpreterError ( "Internal error in lhs..." ) ; } private BshMethod toLocalMethod ( Object [ ] args ) { Class [ ] sig = Reflect . getTypes ( args ) ; return namespace . getMethod ( value , sig ) ; } public Object invokeMethod ( Interpreter interpreter , Object [ ] args , CallStack callstack , SimpleNode callerInfo ) throws EvalError , ReflectError , InvocationTargetException { if ( ! Name . isCompound ( value ) ) return invokeLocalMethod ( interpreter , args , callstack , callerInfo ) ; Name targetName = namespace . getNameResolver ( Name . prefix ( value ) ) ; String methodName = Name . suffix ( value , 1 ) ; Object obj = targetName . toObject ( callstack , interpreter ) ; if ( obj == Primitive . VOID ) throw new EvalError ( "Attempt to invoke method: " + methodName + "() on undefined variable or class name: " + targetName ) ; if ( ! ( obj instanceof Name . ClassIdentifier ) ) { if ( obj instanceof Primitive ) { if ( obj == Primitive . NULL ) throw new TargetError ( "Null Pointer in Method Invocation" , new NullPointerException ( ) ) ; interpreter . error ( "Attempt to access method on primitive..." + " allowing bsh.Primitive to peek through for debugging" ) ; } return Reflect . invokeObjectMethod ( interpreter , obj , methodName , args , callerInfo ) ; } Interpreter . debug ( "invokeMethod: trying static - " + targetName ) ; Class clas = ( ( Name . ClassIdentifier ) obj ) . getTargetClass ( ) ; if ( clas != null ) return Reflect . invokeStaticMethod ( clas , methodName , args ) ; throw new EvalError ( "unknown target: " + targetName ) ; } public Object invokeLocalMethod ( Interpreter interpreter , Object [ ] args , CallStack callstack , SimpleNode callerInfo ) throws EvalError , ReflectError , InvocationTargetException { Interpreter . debug ( "invoke local method: " + value ) ; BshMethod meth = toLocalMethod ( args ) ; if ( meth != null ) return meth . invokeDeclaredMethod ( args , interpreter , callstack , callerInfo ) ; else Interpreter . debug ( "no locally declared method: " + value ) ; String commandName = "commands/" + value + ".bsh" ; InputStream in = Interpreter . class . getResourceAsStream ( commandName ) ; if ( in != null ) { Interpreter . debug ( "loading resource: " + commandName ) ; if ( interpreter == null ) throw new InterpreterError ( "2234432 interpreter = null" ) ; interpreter . eval ( new InputStreamReader ( in ) , namespace , commandName ) ; meth = toLocalMethod ( args ) ; if ( meth != null ) return meth . invokeDeclaredMethod ( args , interpreter , callstack , callerInfo ) ; else throw new EvalError ( "Loaded resource: " + commandName + "had an error or did not contain the correct method" ) ; } commandName = "bsh.commands." + value ; Class c = BshClassManager . classForName ( commandName ) ; if ( c == null ) throw new EvalError ( "Command not found: " + value ) ; Object [ ] invokeArgs = new Object [ args . length + 2 ] ; invokeArgs [ 0 ] = interpreter ; invokeArgs [ 1 ] = namespace ; System . arraycopy ( args , 0 , invokeArgs , 2 , args . length ) ; try { return Reflect . invokeStaticMethod ( c , "invoke" , invokeArgs ) ; } catch ( ReflectError e ) { Interpreter . debug ( "invoke command args error:" + e ) ; } try { String s = ( String ) Reflect . invokeStaticMethod ( c , "usage" , null ) ; interpreter . println ( s ) ; return Primitive . VOID ; } catch ( ReflectError e ) { Interpreter . debug ( "usage threw: " + e ) ; throw new EvalError ( "Wrong number or type of args for command" ) ; } } static boolean isCompound ( String value ) { return countParts ( value ) > 1 ; } static int countParts ( String value ) { if ( value == null ) return 0 ; int count = 0 ; int index = - 1 ; while ( ( index = value . indexOf ( '.' , index + 1 ) ) != - 1 ) count ++ ; return count + 1 ; } static String prefix ( String value ) { if ( ! isCompound ( value ) ) return null ; return prefix ( value , countParts ( value ) - 1 ) ; } static String prefix ( String value , int parts ) { if ( parts < 1 ) return null ; int count = 0 ; int index = - 1 ; while ( ( ( index = value . indexOf ( '.' , index + 1 ) ) != - 1 ) && ( ++ count < parts ) ) { ; } return ( index == - 1 ) ? value : value . substring ( 0 , index ) ; } static String suffix ( String name ) { if ( ! isCompound ( name ) ) return null ; return suffix ( name , countParts ( name ) - 1 ) ; } public static String suffix ( String value , int parts ) { if ( parts < 1 ) return null ; int count = 0 ; int index = value . length ( ) + 1 ; while ( ( ( index = value . lastIndexOf ( '.' , index - 1 ) ) != - 1 ) && ( ++ count < parts ) ) { ; } return ( index == - 1 ) ? value : value . substring ( index + 1 ) ; } public String toString ( ) { return value ; } static class ClassIdentifier { Class clas ; public ClassIdentifier ( Class clas ) { this . clas = clas ; } public Class getTargetClass ( ) { return clas ; } public String toString ( ) { return "Class Identifier: " + clas . getName ( ) ; } } } 	0	['19', '1', '0', '19', '71', '91', '6', '15', '9', '0.708333333', '1263', '0.625', '1', '0', '0.274853801', '0', '0', '65.05263158', '5', '1.6316', '0']
package org . gjt . sp . jedit . pluginmgr ; import javax . swing . border . * ; import javax . swing . event . * ; import javax . swing . tree . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . io . File ; import java . util . * ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class PluginManager extends JDialog { public PluginManager ( View view ) { super ( view , jEdit . getProperty ( "plugin-manager.title" ) , true ) ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; JLabel caption = new JLabel ( jEdit . getProperty ( "plugin-manager.caption" ) ) ; caption . setBorder ( new EmptyBorder ( 0 , 0 , 6 , 0 ) ) ; content . add ( BorderLayout . NORTH , caption ) ; tree = new JTree ( ) ; tree . setCellRenderer ( new Renderer ( ) ) ; tree . setRootVisible ( false ) ; tree . setVisibleRowCount ( 16 ) ; tree . addTreeSelectionListener ( new TreeHandler ( ) ) ; JPanel panel = new JPanel ( new BorderLayout ( ) ) ; panel . add ( BorderLayout . CENTER , new JScrollPane ( tree ) ) ; JPanel panel2 = new JPanel ( new BorderLayout ( ) ) ; panel2 . setBorder ( new EmptyBorder ( 6 , 0 , 0 , 0 ) ) ; JPanel labelBox = new JPanel ( new GridLayout ( 3 , 1 , 0 , 3 ) ) ; labelBox . setBorder ( new EmptyBorder ( 0 , 0 , 0 , 12 ) ) ; labelBox . add ( new JLabel ( jEdit . getProperty ( "plugin-manager" + ".info.name" ) , SwingConstants . RIGHT ) ) ; labelBox . add ( new JLabel ( jEdit . getProperty ( "plugin-manager" + ".info.author" ) , SwingConstants . RIGHT ) ) ; labelBox . add ( new JLabel ( jEdit . getProperty ( "plugin-manager" + ".info.version" ) , SwingConstants . RIGHT ) ) ; panel2 . add ( BorderLayout . WEST , labelBox ) ; JPanel valueBox = new JPanel ( new GridLayout ( 3 , 1 , 0 , 3 ) ) ; valueBox . add ( name = new JLabel ( ) ) ; valueBox . add ( author = new JLabel ( ) ) ; valueBox . add ( version = new JLabel ( ) ) ; panel2 . add ( BorderLayout . CENTER , valueBox ) ; panel . add ( BorderLayout . SOUTH , panel2 ) ; content . add ( BorderLayout . CENTER , panel ) ; JPanel buttons = new JPanel ( ) ; buttons . setLayout ( new BoxLayout ( buttons , BoxLayout . X_AXIS ) ) ; buttons . setBorder ( new EmptyBorder ( 12 , 0 , 0 , 0 ) ) ; buttons . add ( Box . createGlue ( ) ) ; remove = new JButton ( jEdit . getProperty ( "plugin-manager" + ".remove" ) ) ; remove . addActionListener ( new ActionHandler ( ) ) ; buttons . add ( remove ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; update = new JButton ( jEdit . getProperty ( "plugin-manager" + ".update" ) ) ; update . addActionListener ( new ActionHandler ( ) ) ; buttons . add ( update ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; install = new JButton ( jEdit . getProperty ( "plugin-manager" + ".install" ) ) ; install . addActionListener ( new ActionHandler ( ) ) ; buttons . add ( install ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; close = new JButton ( jEdit . getProperty ( "common.close" ) ) ; close . addActionListener ( new ActionHandler ( ) ) ; buttons . add ( close ) ; buttons . add ( Box . createGlue ( ) ) ; content . add ( BorderLayout . SOUTH , buttons ) ; updateTree ( ) ; setDefaultCloseOperation ( DISPOSE_ON_CLOSE ) ; pack ( ) ; setLocationRelativeTo ( view ) ; show ( ) ; } private JTree tree ; private JLabel name ; private JLabel author ; private JLabel version ; private JButton remove ; private JButton update ; private JButton install ; private JButton close ; private void updateTree ( ) { DefaultMutableTreeNode treeRoot = new DefaultMutableTreeNode ( ) ; DefaultTreeModel treeModel = new DefaultTreeModel ( treeRoot ) ; DefaultMutableTreeNode loadedTree = new DefaultMutableTreeNode ( jEdit . getProperty ( "plugin-manager.loaded" ) , true ) ; DefaultMutableTreeNode notLoadedTree = new DefaultMutableTreeNode ( jEdit . getProperty ( "plugin-manager.not-loaded" ) , true ) ; DefaultMutableTreeNode newTree = new DefaultMutableTreeNode ( jEdit . getProperty ( "plugin-manager.new" ) , true ) ; EditPlugin [ ] plugins = jEdit . getPlugins ( ) ; for ( int i = 0 ; i < plugins . length ; i ++ ) { EditPlugin plugin = plugins [ i ] ; String path = plugin . getJAR ( ) . getPath ( ) ; if ( ! new File ( path ) . exists ( ) ) { continue ; } if ( plugin instanceof EditPlugin . Broken ) { Entry entry = new Entry ( path , plugin . getClassName ( ) , true ) ; notLoadedTree . add ( new DefaultMutableTreeNode ( entry ) ) ; } else { Entry entry = new Entry ( path , plugin . getClassName ( ) , false ) ; loadedTree . add ( new DefaultMutableTreeNode ( entry ) ) ; } } if ( notLoadedTree . getChildCount ( ) != 0 ) treeRoot . add ( notLoadedTree ) ; if ( loadedTree . getChildCount ( ) != 0 ) treeRoot . add ( loadedTree ) ; String [ ] newPlugins = jEdit . getNotLoadedPluginJARs ( ) ; for ( int i = 0 ; i < newPlugins . length ; i ++ ) { Entry entry = new Entry ( newPlugins [ i ] , null , false ) ; newTree . add ( new DefaultMutableTreeNode ( entry ) ) ; } if ( newTree . getChildCount ( ) != 0 ) treeRoot . add ( newTree ) ; tree . setModel ( treeModel ) ; for ( int i = 0 ; i < tree . getRowCount ( ) ; i ++ ) tree . expandRow ( i ) ; remove . setEnabled ( false ) ; name . setText ( null ) ; author . setText ( null ) ; version . setText ( null ) ; } class Entry { String clazz ; String name , version , author ; Vector jars ; boolean broken ; Entry ( String path , String clazz , boolean broken ) { Entry . this . clazz = clazz ; Entry . this . broken = broken ; jars = new Vector ( ) ; jars . addElement ( path ) ; if ( clazz == null ) Entry . this . name = path ; else { Entry . this . name = jEdit . getProperty ( "plugin." + clazz + ".name" ) ; if ( name == null ) name = clazz ; Entry . this . version = jEdit . getProperty ( "plugin." + clazz + ".version" ) ; Entry . this . author = jEdit . getProperty ( "plugin." + clazz + ".author" ) ; String jarsProp = jEdit . getProperty ( "plugin." + clazz + ".jars" ) ; if ( jarsProp != null ) { String directory = MiscUtilities . getParentOfPath ( path ) ; StringTokenizer st = new StringTokenizer ( jarsProp ) ; while ( st . hasMoreElements ( ) ) { jars . addElement ( MiscUtilities . constructPath ( directory , st . nextToken ( ) ) ) ; } } } } public String toString ( ) { return Entry . this . name ; } } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == close ) dispose ( ) ; else if ( source == remove ) { TreePath [ ] selected = tree . getSelectionModel ( ) . getSelectionPaths ( ) ; StringBuffer buf = new StringBuffer ( ) ; Roster roster = new Roster ( ) ; for ( int i = 0 ; i < selected . length ; i ++ ) { Object last = ( ( DefaultMutableTreeNode ) selected [ i ] . getLastPathComponent ( ) ) . getUserObject ( ) ; if ( last instanceof Entry ) { Entry entry = ( Entry ) last ; for ( int j = 0 ; j < entry . jars . size ( ) ; j ++ ) { String jar = ( String ) entry . jars . elementAt ( j ) ; if ( buf . length ( ) != 0 ) buf . append ( '\n' ) ; buf . append ( jar ) ; roster . addOperation ( new Roster . Remove ( jar ) ) ; } } } String [ ] args = { buf . toString ( ) } ; if ( GUIUtilities . confirm ( PluginManager . this , "plugin-manager.remove-confirm" , args , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE ) == JOptionPane . YES_OPTION ) { new PluginManagerProgress ( PluginManager . this , jEdit . getProperty ( "plugin-manager.progress" + ".removing-task" ) , roster ) ; updateTree ( ) ; } } else if ( source == update ) { PluginList list = new PluginListDownloadProgress ( PluginManager . this ) . getPluginList ( ) ; if ( list == null ) return ; if ( jEdit . getSettingsDirectory ( ) == null ) { GUIUtilities . error ( PluginManager . this , "no-settings" , null ) ; return ; } Vector plugins = new Vector ( ) ; for ( int i = 0 ; i < list . plugins . size ( ) ; i ++ ) { PluginList . Plugin plugin = ( PluginList . Plugin ) list . plugins . elementAt ( i ) ; PluginList . Branch branch = plugin . getCompatibleBranch ( ) ; if ( branch != null && plugin . installedVersion != null && MiscUtilities . compareVersions ( branch . version , plugin . installedVersion ) > 0 ) plugins . addElement ( plugin ) ; } if ( plugins . size ( ) == 0 ) { GUIUtilities . message ( PluginManager . this , "plugin-manager.up-to-date" , null ) ; return ; } Roster roster = new Roster ( ) ; new InstallPluginsDialog ( PluginManager . this , plugins , InstallPluginsDialog . UPDATE ) . installPlugins ( roster ) ; if ( roster . isEmpty ( ) ) return ; new PluginManagerProgress ( PluginManager . this , jEdit . getProperty ( "plugin-manager.progress" + ".updating-task" ) , roster ) ; updateTree ( ) ; } else if ( source == install ) { PluginList list = new PluginListDownloadProgress ( PluginManager . this ) . getPluginList ( ) ; if ( list == null ) return ; if ( jEdit . getSettingsDirectory ( ) == null && jEdit . getJEditHome ( ) == null ) { GUIUtilities . error ( PluginManager . this , "no-settings" , null ) ; return ; } Vector plugins = new Vector ( ) ; for ( int i = 0 ; i < list . plugins . size ( ) ; i ++ ) { PluginList . Plugin plugin = ( PluginList . Plugin ) list . plugins . elementAt ( i ) ; if ( plugin . installed == null && plugin . canBeInstalled ( ) ) plugins . addElement ( plugin ) ; } Roster roster = new Roster ( ) ; new InstallPluginsDialog ( PluginManager . this , plugins , InstallPluginsDialog . INSTALL ) . installPlugins ( roster ) ; if ( roster . isEmpty ( ) ) return ; new PluginManagerProgress ( PluginManager . this , jEdit . getProperty ( "plugin-manager.progress" + ".installing-task" ) , roster ) ; updateTree ( ) ; } } } class TreeHandler implements TreeSelectionListener { public void valueChanged ( TreeSelectionEvent evt ) { TreePath selection = evt . getPath ( ) ; DefaultMutableTreeNode node ; if ( selection == null ) { node = null ; } else { node = ( DefaultMutableTreeNode ) selection . getLastPathComponent ( ) ; } name . setText ( null ) ; author . setText ( null ) ; version . setText ( null ) ; if ( node != null && node . isLeaf ( ) && node . getUserObject ( ) instanceof Entry ) { remove . setEnabled ( true ) ; Entry entry = ( Entry ) node . getUserObject ( ) ; if ( entry . clazz != null ) { name . setText ( entry . name ) ; author . setText ( entry . author ) ; version . setText ( entry . version ) ; } } else remove . setEnabled ( false ) ; } } class Renderer extends DefaultTreeCellRenderer { public Component getTreeCellRendererComponent ( JTree tree , Object value , boolean selected , boolean expanded , boolean leaf , int row , boolean hasFocus ) { super . getTreeCellRendererComponent ( tree , value , selected , expanded , leaf , row , hasFocus ) ; setIcon ( null ) ; return this ; } } } 	1	['11', '6', '0', '11', '64', '27', '6', '9', '1', '0.775', '595', '1', '0', '0.984871407', '0.363636364', '0', '0', '52.36363636', '12', '1.9091', '3']
package gnu . regexp ; import java . io . Serializable ; public final class REMatch implements Serializable , Cloneable { private String matchedText ; int eflags ; int offset ; int anchor ; int [ ] start ; int [ ] end ; int index ; REMatch next ; public Object clone ( ) { try { REMatch copy = ( REMatch ) super . clone ( ) ; copy . next = null ; copy . start = ( int [ ] ) start . clone ( ) ; copy . end = ( int [ ] ) end . clone ( ) ; return copy ; } catch ( CloneNotSupportedException e ) { throw new Error ( ) ; } } void assignFrom ( REMatch other ) { start = other . start ; end = other . end ; index = other . index ; next = other . next ; } REMatch ( int subs , int index , int eflags ) { start = new int [ subs + 1 ] ; end = new int [ subs + 1 ] ; anchor = index ; this . eflags = eflags ; clear ( index ) ; } void finish ( CharIndexed text ) { start [ 0 ] = 0 ; StringBuffer sb = new StringBuffer ( ) ; int i ; for ( i = 0 ; i < end [ 0 ] ; i ++ ) sb . append ( text . charAt ( i ) ) ; matchedText = sb . toString ( ) ; for ( i = 0 ; i < start . length ; i ++ ) { if ( ( start [ i ] == - 1 ) ^ ( end [ i ] == - 1 ) ) { start [ i ] = - 1 ; end [ i ] = - 1 ; } } next = null ; } void clear ( int index ) { offset = index ; this . index = 0 ; for ( int i = 0 ; i < start . length ; i ++ ) { start [ i ] = end [ i ] = - 1 ; } next = null ; } public String toString ( ) { return matchedText ; } public int getStartIndex ( ) { return offset + start [ 0 ] ; } public int getEndIndex ( ) { return offset + end [ 0 ] ; } public String toString ( int sub ) { if ( ( sub >= start . length ) || ( start [ sub ] == - 1 ) ) return "" ; return ( matchedText . substring ( start [ sub ] , end [ sub ] ) ) ; } public int getSubStartIndex ( int sub ) { if ( sub >= start . length ) return - 1 ; int x = start [ sub ] ; return ( x == - 1 ) ? x : offset + x ; } public int getStartIndex ( int sub ) { if ( sub >= start . length ) return - 1 ; int x = start [ sub ] ; return ( x == - 1 ) ? x : offset + x ; } public int getSubEndIndex ( int sub ) { if ( sub >= start . length ) return - 1 ; int x = end [ sub ] ; return ( x == - 1 ) ? x : offset + x ; } public int getEndIndex ( int sub ) { if ( sub >= start . length ) return - 1 ; int x = end [ sub ] ; return ( x == - 1 ) ? x : offset + x ; } public int getSubCount ( ) { return start . length ; } public String substituteInto ( String input ) { StringBuffer output = new StringBuffer ( ) ; int pos ; for ( pos = 0 ; pos < input . length ( ) - 1 ; pos ++ ) { if ( ( input . charAt ( pos ) == '$' ) && ( Character . isDigit ( input . charAt ( pos + 1 ) ) ) ) { int val = Character . digit ( input . charAt ( ++ pos ) , 10 ) ; if ( val < start . length ) { output . append ( toString ( val ) ) ; } } else output . append ( input . charAt ( pos ) ) ; } if ( pos < input . length ( ) ) output . append ( input . charAt ( pos ) ) ; return output . toString ( ) ; } } 	0	['15', '1', '0', '19', '28', '0', '18', '1', '11', '0.669642857', '391', '0.125', '1', '0', '0.333333333', '0', '0', '24.53333333', '6', '2.2667', '0']
package org . gjt . sp . jedit . search ; import java . awt . event . * ; import java . awt . * ; import javax . swing . border . * ; import javax . swing . event . * ; import javax . swing . text . BadLocationException ; import javax . swing . * ; import org . gjt . sp . jedit . * ; import org . gjt . sp . jedit . gui . HistoryTextField ; import org . gjt . sp . jedit . textarea . * ; import org . gjt . sp . util . Log ; public class SearchBar extends JPanel { public SearchBar ( View view ) { super ( new BorderLayout ( ) ) ; this . view = view ; JLabel label = new JLabel ( jEdit . getProperty ( "view.search.find" ) ) ; label . setBorder ( new EmptyBorder ( 0 , 2 , 0 , 12 ) ) ; add ( label , BorderLayout . WEST ) ; Box box = new Box ( BoxLayout . Y_AXIS ) ; box . add ( Box . createGlue ( ) ) ; box . add ( find = new HistoryTextField ( "find" ) ) ; Dimension min = find . getPreferredSize ( ) ; min . width = Integer . MAX_VALUE ; find . setMaximumSize ( min ) ; ActionHandler actionHandler = new ActionHandler ( ) ; find . addKeyListener ( new KeyHandler ( ) ) ; find . addActionListener ( actionHandler ) ; find . getDocument ( ) . addDocumentListener ( new DocumentHandler ( ) ) ; box . add ( Box . createGlue ( ) ) ; add ( box , BorderLayout . CENTER ) ; Insets margin = new Insets ( 1 , 1 , 1 , 1 ) ; Box buttons = new Box ( BoxLayout . X_AXIS ) ; buttons . add ( Box . createHorizontalStrut ( 12 ) ) ; buttons . add ( ignoreCase = new JCheckBox ( jEdit . getProperty ( "search.case" ) ) ) ; ignoreCase . addActionListener ( actionHandler ) ; ignoreCase . setMargin ( margin ) ; buttons . add ( Box . createHorizontalStrut ( 2 ) ) ; buttons . add ( regexp = new JCheckBox ( jEdit . getProperty ( "search.regexp" ) ) ) ; regexp . addActionListener ( actionHandler ) ; regexp . setMargin ( margin ) ; buttons . add ( Box . createHorizontalStrut ( 2 ) ) ; buttons . add ( hyperSearch = new JCheckBox ( jEdit . getProperty ( "search.hypersearch" ) ) ) ; hyperSearch . addActionListener ( actionHandler ) ; hyperSearch . setMargin ( margin ) ; update ( ) ; add ( buttons , BorderLayout . EAST ) ; } public HistoryTextField getField ( ) { return find ; } public void setHyperSearch ( boolean hyperSearch ) { jEdit . setBooleanProperty ( "view.search.hypersearch.toggle" , hyperSearch ) ; this . hyperSearch . setSelected ( hyperSearch ) ; find . setModel ( this . hyperSearch . isSelected ( ) ? "find" : null ) ; } public void update ( ) { ignoreCase . setSelected ( SearchAndReplace . getIgnoreCase ( ) ) ; regexp . setSelected ( SearchAndReplace . getRegexp ( ) ) ; hyperSearch . setSelected ( jEdit . getBooleanProperty ( "view.search.hypersearch.toggle" ) ) ; find . setModel ( hyperSearch . isSelected ( ) ? "find" : null ) ; } private View view ; private HistoryTextField find ; private JCheckBox ignoreCase , regexp , hyperSearch ; private void find ( boolean reverse ) { String text = find . getText ( ) ; if ( text . length ( ) == 0 ) { jEdit . setBooleanProperty ( "search.hypersearch.toggle" , hyperSearch . isSelected ( ) ) ; new SearchDialog ( view , null ) ; } else if ( hyperSearch . isSelected ( ) ) { find . setText ( null ) ; SearchAndReplace . setSearchString ( text ) ; SearchAndReplace . setSearchFileSet ( new CurrentBufferSet ( ) ) ; SearchAndReplace . hyperSearch ( view ) ; } else { int start ; JEditTextArea textArea = view . getTextArea ( ) ; Selection s = textArea . getSelectionAtOffset ( textArea . getCaretPosition ( ) ) ; if ( s == null ) start = textArea . getCaretPosition ( ) ; else if ( reverse ) start = s . getStart ( ) ; else start = s . getEnd ( ) ; if ( ! incrementalSearch ( start , reverse ) ) { if ( ! incrementalSearch ( reverse ? view . getBuffer ( ) . getLength ( ) : 0 , reverse ) ) { getToolkit ( ) . beep ( ) ; } } } } private boolean incrementalSearch ( int start , boolean reverse ) { SearchAndReplace . setSearchFileSet ( new CurrentBufferSet ( ) ) ; SearchAndReplace . setSearchString ( find . getText ( ) ) ; SearchAndReplace . setReverseSearch ( reverse ) ; try { if ( SearchAndReplace . find ( view , view . getBuffer ( ) , start ) ) return true ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } catch ( Exception e ) { Log . log ( Log . DEBUG , this , e ) ; return true ; } return false ; } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( evt . getSource ( ) == find ) find ( false ) ; else if ( evt . getSource ( ) == hyperSearch ) { jEdit . setBooleanProperty ( "view.search.hypersearch.toggle" , hyperSearch . isSelected ( ) ) ; update ( ) ; } else if ( evt . getSource ( ) == ignoreCase ) { SearchAndReplace . setIgnoreCase ( ignoreCase . isSelected ( ) ) ; } else if ( evt . getSource ( ) == regexp ) { SearchAndReplace . setRegexp ( regexp . isSelected ( ) ) ; } } } class DocumentHandler implements DocumentListener { public void insertUpdate ( DocumentEvent evt ) { if ( ! hyperSearch . isSelected ( ) ) { int start ; JEditTextArea textArea = view . getTextArea ( ) ; Selection s = textArea . getSelectionAtOffset ( textArea . getCaretPosition ( ) ) ; if ( s == null ) start = textArea . getCaretPosition ( ) ; else start = s . getStart ( ) ; if ( ! incrementalSearch ( start , false ) ) { if ( ! incrementalSearch ( 0 , false ) ) { getToolkit ( ) . beep ( ) ; } } } } public void removeUpdate ( DocumentEvent evt ) { if ( ! hyperSearch . isSelected ( ) ) { String text = find . getText ( ) ; if ( text . length ( ) != 0 ) { if ( regexp . isSelected ( ) ) { incrementalSearch ( 0 , false ) ; } else { int start ; JEditTextArea textArea = view . getTextArea ( ) ; Selection s = textArea . getSelectionAtOffset ( textArea . getCaretPosition ( ) ) ; if ( s == null ) start = textArea . getCaretPosition ( ) ; else start = s . getStart ( ) ; incrementalSearch ( start , true ) ; } } } } public void changedUpdate ( DocumentEvent evt ) { } } class KeyHandler extends KeyAdapter { public void keyPressed ( KeyEvent evt ) { switch ( evt . getKeyCode ( ) ) { case KeyEvent . VK_LEFT : case KeyEvent . VK_RIGHT : case KeyEvent . VK_UP : case KeyEvent . VK_DOWN : if ( ! hyperSearch . isSelected ( ) ) { evt . consume ( ) ; view . getEditPane ( ) . focusOnTextArea ( ) ; view . getEditPane ( ) . getTextArea ( ) . processKeyEvent ( evt ) ; } break ; case KeyEvent . VK_ESCAPE : evt . consume ( ) ; view . getEditPane ( ) . focusOnTextArea ( ) ; break ; case KeyEvent . VK_ENTER : if ( evt . isShiftDown ( ) ) { evt . consume ( ) ; find ( true ) ; } break ; } } } } 	1	['13', '5', '0', '14', '65', '14', '4', '14', '4', '0.633333333', '398', '1', '2', '0.981954887', '0.323076923', '2', '5', '29.23076923', '8', '1.6154', '3']
package gnu . regexp ; import java . io . FilterReader ; import java . io . Reader ; public class REFilterReader extends FilterReader { private RE expr ; private String replace ; private String buffer ; private int bufpos ; private int offset ; private CharIndexedReader stream ; public REFilterReader ( Reader stream , RE expr , String replace ) { super ( stream ) ; this . stream = new CharIndexedReader ( stream , 0 ) ; this . expr = expr ; this . replace = replace ; } public int read ( ) { if ( ( buffer != null ) && ( bufpos < buffer . length ( ) ) ) { return ( int ) buffer . charAt ( bufpos ++ ) ; } if ( ! stream . isValid ( ) ) return - 1 ; REMatch mymatch = new REMatch ( expr . getNumSubs ( ) , offset , 0 ) ; if ( expr . match ( stream , mymatch ) ) { mymatch . end [ 0 ] = mymatch . index ; mymatch . finish ( stream ) ; stream . move ( mymatch . toString ( ) . length ( ) ) ; offset += mymatch . toString ( ) . length ( ) ; buffer = mymatch . substituteInto ( replace ) ; bufpos = 1 ; if ( buffer . length ( ) > 0 ) { return buffer . charAt ( 0 ) ; } } char ch = stream . charAt ( 0 ) ; if ( ch == CharIndexed . OUT_OF_BOUNDS ) return - 1 ; stream . move ( 1 ) ; offset ++ ; return ch ; } public boolean markSupported ( ) { return false ; } public int read ( char [ ] b , int off , int len ) { int i ; int ok = 0 ; while ( len -- > 0 ) { i = read ( ) ; if ( i == - 1 ) return ( ok == 0 ) ? - 1 : ok ; b [ off ++ ] = ( char ) i ; ok ++ ; } return ok ; } public int read ( char [ ] b ) { return read ( b , 0 , b . length ) ; } } 	0	['5', '3', '0', '4', '18', '8', '0', '4', '5', '0.375', '173', '1', '2', '0.818181818', '0.366666667', '2', '3', '32.4', '7', '2.6', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . border . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . * ; public class AboutDialog extends EnhancedDialog { public AboutDialog ( View view ) { super ( view , jEdit . getProperty ( "about.title" ) , true ) ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBackground ( Color . white ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; JPanel panel = new JPanel ( new BorderLayout ( ) ) ; panel . setBackground ( Color . white ) ; String [ ] args = { jEdit . getVersion ( ) } ; JLabel label = new JLabel ( jEdit . getProperty ( "about.version" , args ) , SwingConstants . CENTER ) ; label . setBorder ( new EmptyBorder ( 0 , 0 , 12 , 0 ) ) ; panel . add ( BorderLayout . NORTH , label ) ; JLabel splash = new JLabel ( new ImageIcon ( getClass ( ) . getResource ( "/org/gjt/sp/jedit/jedit_logo.gif" ) ) ) ; panel . add ( BorderLayout . CENTER , splash ) ; label = new JLabel ( jEdit . getProperty ( "about.caption" ) , SwingConstants . CENTER ) ; label . setBorder ( new EmptyBorder ( 12 , 0 , 12 , 0 ) ) ; panel . add ( BorderLayout . SOUTH , label ) ; content . add ( BorderLayout . CENTER , panel ) ; Box box = new Box ( BoxLayout . X_AXIS ) ; box . add ( Box . createGlue ( ) ) ; close = new JButton ( jEdit . getProperty ( "common.close" ) ) ; close . addActionListener ( new ActionHandler ( ) ) ; getRootPane ( ) . setDefaultButton ( close ) ; box . add ( close ) ; box . add ( Box . createGlue ( ) ) ; content . add ( BorderLayout . SOUTH , box ) ; pack ( ) ; setResizable ( false ) ; setLocationRelativeTo ( view ) ; show ( ) ; } public void ok ( ) { dispose ( ) ; } public void cancel ( ) { dispose ( ) ; } private JButton close ; class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { dispose ( ) ; } } } 	1	['3', '7', '0', '4', '33', '3', '1', '4', '3', '1', '176', '1', '0', '0.996946565', '0.666666667', '0', '0', '57.33333333', '1', '0.6667', '2']
package bsh ; class ParseException extends Exception { public ParseException ( Token currentTokenVal , int [ ] [ ] expectedTokenSequencesVal , String [ ] tokenImageVal ) { super ( "" ) ; specialConstructor = true ; currentToken = currentTokenVal ; expectedTokenSequences = expectedTokenSequencesVal ; tokenImage = tokenImageVal ; } public ParseException ( ) { super ( ) ; specialConstructor = false ; } public ParseException ( String message ) { super ( message ) ; specialConstructor = false ; } protected boolean specialConstructor ; public Token currentToken ; public int [ ] [ ] expectedTokenSequences ; public String [ ] tokenImage ; public String getMessage ( ) { return getMessage ( true ) ; } public String getMessage ( boolean debug ) { if ( ! specialConstructor ) { return super . getMessage ( ) ; } String expected = "" ; int maxSize = 0 ; for ( int i = 0 ; i < expectedTokenSequences . length ; i ++ ) { if ( maxSize < expectedTokenSequences [ i ] . length ) { maxSize = expectedTokenSequences [ i ] . length ; } for ( int j = 0 ; j < expectedTokenSequences [ i ] . length ; j ++ ) { expected += tokenImage [ expectedTokenSequences [ i ] [ j ] ] + " " ; } if ( expectedTokenSequences [ i ] [ expectedTokenSequences [ i ] . length - 1 ] != 0 ) { expected += "..." ; } expected += eol + "    " ; } String retval = "Encountered \"" ; Token tok = currentToken . next ; for ( int i = 0 ; i < maxSize ; i ++ ) { if ( i != 0 ) retval += " " ; if ( tok . kind == 0 ) { retval += tokenImage [ 0 ] ; break ; } retval += add_escapes ( tok . image ) ; tok = tok . next ; } retval += "\" at line " + currentToken . next . beginLine + ", column " + currentToken . next . beginColumn + "." + eol ; if ( debug ) { if ( expectedTokenSequences . length == 1 ) { retval += "Was expecting:" + eol + "    " ; } else { retval += "Was expecting one of:" + eol + "    " ; } retval += expected ; } return retval ; } protected String eol = System . getProperty ( "line.separator" , "\n" ) ; protected String add_escapes ( String str ) { StringBuffer retval = new StringBuffer ( ) ; char ch ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { switch ( str . charAt ( i ) ) { case 0 : continue ; case '\b' : retval . append ( "\\b" ) ; continue ; case '\t' : retval . append ( "\\t" ) ; continue ; case '\n' : retval . append ( "\\n" ) ; continue ; case '\f' : retval . append ( "\\f" ) ; continue ; case '\r' : retval . append ( "\\r" ) ; continue ; case '\"' : retval . append ( "\\\"" ) ; continue ; case '\'' : retval . append ( "\\\'" ) ; continue ; case '\\' : retval . append ( "\\\\" ) ; continue ; default : if ( ( ch = str . charAt ( i ) ) < 0x20 || ch > 0x7e ) { String s = "0000" + Integer . toString ( ch , 16 ) ; retval . append ( "\\u" + s . substring ( s . length ( ) - 4 , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . toString ( ) ; } } 	0	['6', '3', '0', '3', '19', '3', '2', '1', '5', '0.44', '387', '0.4', '1', '0.85', '0.333333333', '1', '1', '62.66666667', '14', '4.3333', '0']
package org . gjt . sp . jedit ; import bsh . * ; import javax . swing . text . BadLocationException ; import javax . swing . text . Segment ; import javax . swing . JFileChooser ; import java . lang . reflect . InvocationTargetException ; import java . io . * ; import org . gjt . sp . jedit . io . * ; import org . gjt . sp . jedit . gui . BeanShellErrorDialog ; import org . gjt . sp . jedit . textarea . JEditTextArea ; import org . gjt . sp . util . Log ; public class BeanShell { public static void evalSelection ( View view , JEditTextArea textArea ) { String command = textArea . getSelectedText ( ) ; if ( command == null ) { view . getToolkit ( ) . beep ( ) ; return ; } Object returnValue = eval ( view , command , false ) ; if ( returnValue != null ) textArea . setSelectedText ( returnValue . toString ( ) ) ; } public static void showEvaluateDialog ( View view ) { String command = GUIUtilities . input ( view , "beanshell-eval-input" , null ) ; if ( command != null ) { if ( ! command . endsWith ( ";" ) ) command = command + ";" ; int repeat = view . getInputHandler ( ) . getRepeatCount ( ) ; if ( view . getMacroRecorder ( ) != null ) { view . getMacroRecorder ( ) . record ( repeat , command ) ; } Object returnValue = null ; try { for ( int i = 0 ; i < repeat ; i ++ ) { returnValue = eval ( view , command , true ) ; } } catch ( Error t ) { } if ( returnValue != null ) { String [ ] args = { returnValue . toString ( ) } ; GUIUtilities . message ( view , "beanshell-eval" , args ) ; } } } public static void showRunScriptDialog ( View view ) { String [ ] paths = GUIUtilities . showVFSFileDialog ( view , null , JFileChooser . OPEN_DIALOG , true ) ; if ( paths != null ) { Buffer buffer = view . getBuffer ( ) ; try { buffer . beginCompoundEdit ( ) ; for ( int i = 0 ; i < paths . length ; i ++ ) runScript ( view , paths [ i ] , true , false ) ; } finally { buffer . endCompoundEdit ( ) ; } } } public static void runScript ( View view , String path , boolean ownNamespace , boolean rethrowBshErrors ) { Reader in ; Buffer buffer = jEdit . getBuffer ( path ) ; VFS vfs = VFSManager . getVFSForPath ( path ) ; Object session = vfs . createVFSSession ( path , view ) ; if ( session == null ) { return ; } try { if ( buffer != null && buffer . isLoaded ( ) ) { StringBuffer buf = new StringBuffer ( ) ; try { buf . append ( buffer . getText ( 0 , buffer . getLength ( ) ) ) ; } catch ( BadLocationException e ) { throw new InternalError ( ) ; } buf . append ( "\n" ) ; in = new StringReader ( buf . toString ( ) ) ; } else { in = new BufferedReader ( new InputStreamReader ( vfs . _createInputStream ( session , path , true , view ) ) ) ; } runScript ( view , path , in , ownNamespace , rethrowBshErrors ) ; } catch ( IOException e ) { Log . log ( Log . ERROR , BeanShell . class , e ) ; GUIUtilities . error ( view , "read-error" , new String [ ] { path , e . toString ( ) } ) ; return ; } finally { try { vfs . _endVFSSession ( session , view ) ; } catch ( IOException io ) { Log . log ( Log . ERROR , BeanShell . class , io ) ; GUIUtilities . error ( view , "read-error" , new String [ ] { path , io . toString ( ) } ) ; } } } public static void runScript ( View view , String path , Reader in , boolean ownNamespace , boolean rethrowBshErrors ) { Log . log ( Log . MESSAGE , BeanShell . class , "Running script " + path ) ; NameSpace namespace ; if ( ownNamespace ) namespace = new NameSpace ( global , "script namespace" ) ; else namespace = global ; Interpreter interp = createInterpreter ( namespace ) ; try { if ( view != null ) { EditPane editPane = view . getEditPane ( ) ; interp . set ( "view" , view ) ; interp . set ( "editPane" , editPane ) ; interp . set ( "buffer" , editPane . getBuffer ( ) ) ; interp . set ( "textArea" , editPane . getTextArea ( ) ) ; } running = true ; interp . eval ( in , namespace , path ) ; } catch ( Throwable e ) { if ( e instanceof TargetError ) e = ( ( TargetError ) e ) . getTarget ( ) ; if ( e instanceof InvocationTargetException ) e = ( ( InvocationTargetException ) e ) . getTargetException ( ) ; Log . log ( Log . ERROR , BeanShell . class , e ) ; new BeanShellErrorDialog ( view , e . toString ( ) ) ; if ( e instanceof Error && rethrowBshErrors ) throw ( Error ) e ; } finally { running = false ; } } public static Object eval ( View view , String command , boolean rethrowBshErrors ) { return eval ( view , global , command , rethrowBshErrors ) ; } public static Object eval ( View view , NameSpace namespace , String command , boolean rethrowBshErrors ) { Interpreter interp = createInterpreter ( namespace ) ; try { if ( view != null ) { EditPane editPane = view . getEditPane ( ) ; interp . set ( "view" , view ) ; interp . set ( "editPane" , editPane ) ; interp . set ( "buffer" , editPane . getBuffer ( ) ) ; interp . set ( "textArea" , editPane . getTextArea ( ) ) ; } return interp . eval ( command ) ; } catch ( Throwable e ) { if ( e instanceof TargetError ) e = ( ( TargetError ) e ) . getTarget ( ) ; if ( e instanceof InvocationTargetException ) e = ( ( InvocationTargetException ) e ) . getTargetException ( ) ; Log . log ( Log . ERROR , BeanShell . class , e ) ; new BeanShellErrorDialog ( view , e . toString ( ) ) ; if ( e instanceof Error && rethrowBshErrors ) throw ( Error ) e ; } return null ; } public static String cacheBlock ( String id , String code , boolean childNamespace ) { String name ; if ( id == null ) name = "b_" + ( cachedBlockCounter ++ ) ; else name = "b_" + id ; code = "setNameSpace(__cruft.namespace);\n" + name + "(ns) {\n" + "setNameSpace(ns);" + code + "\n}" ; eval ( null , code , false ) ; return name ; } public static Object runCachedBlock ( String id , View view , NameSpace namespace ) { if ( namespace == null ) namespace = internal ; Object [ ] args = { namespace } ; try { if ( view != null ) { namespace . setVariable ( "view" , view ) ; EditPane editPane = view . getEditPane ( ) ; namespace . setVariable ( "editPane" , editPane ) ; namespace . setVariable ( "buffer" , editPane . getBuffer ( ) ) ; namespace . setVariable ( "textArea" , editPane . getTextArea ( ) ) ; } Object retVal = internal . invokeMethod ( id , args , interpForMethods ) ; if ( retVal instanceof Primitive ) { if ( retVal == Primitive . VOID ) return null ; else return ( ( Primitive ) retVal ) . getValue ( ) ; } else return retVal ; } catch ( Throwable e ) { if ( e instanceof TargetError ) e = ( ( TargetError ) e ) . getTarget ( ) ; if ( e instanceof InvocationTargetException ) e = ( ( InvocationTargetException ) e ) . getTargetException ( ) ; Log . log ( Log . ERROR , BeanShell . class , e ) ; new BeanShellErrorDialog ( view , e . toString ( ) ) ; } finally { try { namespace . setVariable ( "view" , null ) ; namespace . setVariable ( "editPane" , null ) ; namespace . setVariable ( "buffer" , null ) ; namespace . setVariable ( "textArea" , null ) ; } catch ( EvalError e ) { } } return null ; } public static boolean isScriptRunning ( ) { return running ; } public static NameSpace getNameSpace ( ) { return global ; } static void init ( ) { Log . log ( Log . DEBUG , BeanShell . class , "Initializing BeanShell" + " interpreter" ) ; BshClassManager . setClassLoader ( new JARClassLoader ( ) ) ; global = new NameSpace ( "jEdit embedded BeanShell Interpreter" ) ; interpForMethods = createInterpreter ( global ) ; try { Interpreter interp = createInterpreter ( global ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( BeanShell . class . getResourceAsStream ( "jedit.bsh" ) ) ) ; interp . eval ( in , global , "jedit.bsh" ) ; } catch ( Throwable t ) { Log . log ( Log . ERROR , BeanShell . class , t ) ; System . exit ( 1 ) ; } internal = ( NameSpace ) eval ( null , "__cruft.namespace;" , false ) ; } private static Interpreter interpForMethods ; private static NameSpace global ; private static NameSpace internal ; private static boolean running ; private static int cachedBlockCounter ; private static Interpreter createInterpreter ( NameSpace nameSpace ) { return new Interpreter ( null , System . out , System . err , false , nameSpace ) ; } } 	1	['15', '1', '0', '26', '75', '73', '9', '19', '12', '0.785714286', '736', '1', '3', '0', '0.247619048', '0', '0', '47.66666667', '13', '4.4', '4']
package bsh ; class Token implements java . io . Serializable { public int kind ; public int beginLine , beginColumn , endLine , endColumn ; public String image ; public Token next ; public Token specialToken ; public final String toString ( ) { return image ; } public static final Token newToken ( int ofKind ) { switch ( ofKind ) { default : return new Token ( ) ; } } } 	0	['3', '1', '0', '5', '4', '3', '5', '0', '2', '1.4375', '23', '0', '2', '0', '0.5', '0', '0', '4', '2', '1', '0']
package org . gjt . sp . jedit ; import javax . swing . SwingUtilities ; import java . io . * ; import java . net . * ; import java . util . Random ; import org . gjt . sp . util . Log ; public class EditServer extends Thread { EditServer ( String portFile ) { super ( "jEdit server daemon [" + portFile + "]" ) ; setDaemon ( true ) ; this . portFile = portFile ; try { socket = new ServerSocket ( 0 , 2 , InetAddress . getByName ( "127.0.0.1" ) ) ; authKey = Math . abs ( new Random ( ) . nextInt ( ) ) ; int port = socket . getLocalPort ( ) ; FileWriter out = new FileWriter ( portFile ) ; out . write ( String . valueOf ( port ) ) ; out . write ( "\n" ) ; out . write ( String . valueOf ( authKey ) ) ; out . write ( "\n" ) ; out . close ( ) ; Log . log ( Log . DEBUG , this , "jEdit server started on port " + socket . getLocalPort ( ) ) ; Log . log ( Log . DEBUG , this , "Authorization key is " + authKey ) ; ok = true ; } catch ( IOException io ) { Log . log ( Log . NOTICE , this , io ) ; } } public boolean isOK ( ) { return ok ; } public void run ( ) { try { for ( ; ; ) { Socket client = socket . accept ( ) ; Log . log ( Log . MESSAGE , this , client + ": connected" ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( client . getInputStream ( ) , "UTF8" ) ) ; try { int key = Integer . parseInt ( in . readLine ( ) ) ; if ( key != authKey ) { Log . log ( Log . ERROR , this , client + ": wrong" + " authorization key" ) ; in . close ( ) ; client . close ( ) ; return ; } } catch ( Exception e ) { Log . log ( Log . ERROR , this , client + ": invalid" + " authorization key" ) ; in . close ( ) ; client . close ( ) ; return ; } Log . log ( Log . DEBUG , this , client + ": authenticated" + " successfully" ) ; handleClient ( client , in ) ; client . close ( ) ; } } catch ( IOException io ) { Log . log ( Log . ERROR , this , io ) ; } } public static void handleClient ( boolean restore , String parent , String [ ] args ) { String splitConfig = null ; boolean newView = jEdit . getBooleanProperty ( "client.newView" ) ; if ( jEdit . getFirstView ( ) == null || newView ) { Buffer buffer = jEdit . openFiles ( null , parent , args ) ; if ( restore ) { if ( jEdit . getFirstBuffer ( ) == null ) splitConfig = jEdit . restoreOpenFiles ( ) ; else if ( jEdit . getBooleanProperty ( "restore.cli" ) ) { jEdit . restoreOpenFiles ( ) ; } } if ( jEdit . getFirstBuffer ( ) == null ) buffer = jEdit . newFile ( null ) ; if ( splitConfig != null ) jEdit . newView ( null , splitConfig ) ; else jEdit . newView ( null , buffer ) ; } else { View view = jEdit . getFirstView ( ) ; jEdit . openFiles ( view , parent , args ) ; view . requestFocus ( ) ; view . toFront ( ) ; return ; } } void stopServer ( ) { stop ( ) ; new File ( portFile ) . delete ( ) ; } private String portFile ; private ServerSocket socket ; private int authKey ; private boolean ok ; private void handleClient ( Socket client , Reader in ) throws IOException { final StringBuffer script = new StringBuffer ( ) ; char [ ] buf = new char [ 1024 ] ; int count ; while ( ( count = in . read ( buf , 0 , buf . length ) ) != - 1 ) { script . append ( buf , 0 , count ) ; } SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { String scriptString = script . toString ( ) ; Log . log ( Log . DEBUG , this , scriptString ) ; BeanShell . eval ( null , scriptString , false ) ; } } ) ; } } 	1	['6', '2', '0', '6', '50', '9', '3', '5', '3', '0.8', '305', '1', '0', '0.924242424', '0.305555556', '0', '0', '49.16666667', '8', '2', '4']
package bsh ; import java . awt . event . * ; import javax . swing . * ; import javax . swing . event . * ; import java . io . * ; import java . beans . * ; class JThis extends This implements ActionListener , AdjustmentListener , ComponentListener , ContainerListener , FocusListener , ItemListener , KeyListener , MouseListener , MouseMotionListener , TextListener , WindowListener , PropertyChangeListener , AncestorListener , CaretListener , CellEditorListener , ChangeListener , DocumentListener , HyperlinkListener , InternalFrameListener , ListDataListener , ListSelectionListener , MenuDragMouseListener , MenuKeyListener , MenuListener , MouseInputListener , PopupMenuListener , TableColumnModelListener , TableModelListener , TreeExpansionListener , TreeModelListener , TreeSelectionListener , TreeWillExpandListener , UndoableEditListener { JThis ( NameSpace namespace , Interpreter declaringInterp ) { super ( namespace , declaringInterp ) ; } public String toString ( ) { return "'this' reference (JThis) to Bsh object: " + namespace . name ; } void event ( String name , Object event ) { BshMethod method ; method = namespace . getMethod ( "handleEvent" , new Class [ ] { null } ) ; if ( method != null ) try { method . invokeDeclaredMethod ( new Object [ ] { event } , declaringInterpreter , callstack , null ) ; } catch ( EvalError e ) { declaringInterpreter . error ( "local event hander method invocation error:" + e ) ; } method = namespace . getMethod ( name , new Class [ ] { null } ) ; if ( method != null ) try { method . invokeDeclaredMethod ( new Object [ ] { event } , declaringInterpreter , callstack , null ) ; } catch ( EvalError e ) { declaringInterpreter . error ( "local event hander method invocation error:" + e ) ; } } public void ancestorAdded ( AncestorEvent e ) { event ( "ancestorAdded" , e ) ; } public void ancestorRemoved ( AncestorEvent e ) { event ( "ancestorRemoved" , e ) ; } public void ancestorMoved ( AncestorEvent e ) { event ( "ancestorMoved" , e ) ; } public void caretUpdate ( CaretEvent e ) { event ( "caretUpdate" , e ) ; } public void editingStopped ( ChangeEvent e ) { event ( "editingStopped" , e ) ; } public void editingCanceled ( ChangeEvent e ) { event ( "editingCanceled" , e ) ; } public void stateChanged ( ChangeEvent e ) { event ( "stateChanged" , e ) ; } public void insertUpdate ( DocumentEvent e ) { event ( "insertUpdate" , e ) ; } public void removeUpdate ( DocumentEvent e ) { event ( "removeUpdate" , e ) ; } public void changedUpdate ( DocumentEvent e ) { event ( "changedUpdate" , e ) ; } public void hyperlinkUpdate ( HyperlinkEvent e ) { event ( "internalFrameOpened" , e ) ; } public void internalFrameOpened ( InternalFrameEvent e ) { event ( "internalFrameOpened" , e ) ; } public void internalFrameClosing ( InternalFrameEvent e ) { event ( "internalFrameClosing" , e ) ; } public void internalFrameClosed ( InternalFrameEvent e ) { event ( "internalFrameClosed" , e ) ; } public void internalFrameIconified ( InternalFrameEvent e ) { event ( "internalFrameIconified" , e ) ; } public void internalFrameDeiconified ( InternalFrameEvent e ) { event ( "internalFrameDeiconified" , e ) ; } public void internalFrameActivated ( InternalFrameEvent e ) { event ( "internalFrameActivated" , e ) ; } public void internalFrameDeactivated ( InternalFrameEvent e ) { event ( "internalFrameDeactivated" , e ) ; } public void intervalAdded ( ListDataEvent e ) { event ( "intervalAdded" , e ) ; } public void intervalRemoved ( ListDataEvent e ) { event ( "intervalRemoved" , e ) ; } public void contentsChanged ( ListDataEvent e ) { event ( "contentsChanged" , e ) ; } public void valueChanged ( ListSelectionEvent e ) { event ( "valueChanged" , e ) ; } public void menuDragMouseEntered ( MenuDragMouseEvent e ) { event ( "menuDragMouseEntered" , e ) ; } public void menuDragMouseExited ( MenuDragMouseEvent e ) { event ( "menuDragMouseExited" , e ) ; } public void menuDragMouseDragged ( MenuDragMouseEvent e ) { event ( "menuDragMouseDragged" , e ) ; } public void menuDragMouseReleased ( MenuDragMouseEvent e ) { event ( "menuDragMouseReleased" , e ) ; } public void menuKeyTyped ( MenuKeyEvent e ) { event ( "menuKeyTyped" , e ) ; } public void menuKeyPressed ( MenuKeyEvent e ) { event ( "menuKeyPressed" , e ) ; } public void menuKeyReleased ( MenuKeyEvent e ) { event ( "menuKeyReleased" , e ) ; } public void menuSelected ( MenuEvent e ) { event ( "menuSelected" , e ) ; } public void menuDeselected ( MenuEvent e ) { event ( "menuDeselected" , e ) ; } public void menuCanceled ( MenuEvent e ) { event ( "menuCanceled" , e ) ; } public void popupMenuWillBecomeVisible ( PopupMenuEvent e ) { event ( "popupMenuWillBecomeVisible" , e ) ; } public void popupMenuWillBecomeInvisible ( PopupMenuEvent e ) { event ( "popupMenuWillBecomeInvisible" , e ) ; } public void popupMenuCanceled ( PopupMenuEvent e ) { event ( "popupMenuCanceled" , e ) ; } public void columnAdded ( TableColumnModelEvent e ) { event ( "columnAdded" , e ) ; } public void columnRemoved ( TableColumnModelEvent e ) { event ( "columnRemoved" , e ) ; } public void columnMoved ( TableColumnModelEvent e ) { event ( "columnMoved" , e ) ; } public void columnMarginChanged ( ChangeEvent e ) { event ( "columnMarginChanged" , e ) ; } public void columnSelectionChanged ( ListSelectionEvent e ) { event ( "columnSelectionChanged" , e ) ; } public void tableChanged ( TableModelEvent e ) { event ( "tableChanged" , e ) ; } public void treeExpanded ( TreeExpansionEvent e ) { event ( "treeExpanded" , e ) ; } public void treeCollapsed ( TreeExpansionEvent e ) { event ( "treeCollapsed" , e ) ; } public void treeNodesChanged ( TreeModelEvent e ) { event ( "treeNodesChanged" , e ) ; } public void treeNodesInserted ( TreeModelEvent e ) { event ( "treeNodesInserted" , e ) ; } public void treeNodesRemoved ( TreeModelEvent e ) { event ( "treeNodesRemoved" , e ) ; } public void treeStructureChanged ( TreeModelEvent e ) { event ( "treeStructureChanged" , e ) ; } public void valueChanged ( TreeSelectionEvent e ) { event ( "valueChanged" , e ) ; } public void treeWillExpand ( TreeExpansionEvent e ) { event ( "treeWillExpand" , e ) ; } public void treeWillCollapse ( TreeExpansionEvent e ) { event ( "treeWillCollapse" , e ) ; } public void undoableEditHappened ( UndoableEditEvent e ) { event ( "undoableEditHappened" , e ) ; } public void actionPerformed ( ActionEvent e ) { event ( "actionPerformed" , e ) ; } public void adjustmentValueChanged ( AdjustmentEvent e ) { event ( "adjustmentValueChanged" , e ) ; } public void componentResized ( ComponentEvent e ) { event ( "componentResized" , e ) ; } public void componentMoved ( ComponentEvent e ) { event ( "componentMoved" , e ) ; } public void componentShown ( ComponentEvent e ) { event ( "componentShown" , e ) ; } public void componentHidden ( ComponentEvent e ) { event ( "componentHidden" , e ) ; } public void componentAdded ( ContainerEvent e ) { event ( "componentAdded" , e ) ; } public void componentRemoved ( ContainerEvent e ) { event ( "componentRemoved" , e ) ; } public void focusGained ( FocusEvent e ) { event ( "focusGained" , e ) ; } public void focusLost ( FocusEvent e ) { event ( "focusLost" , e ) ; } public void itemStateChanged ( ItemEvent e ) { event ( "itemStateChanged" , e ) ; } public void keyTyped ( KeyEvent e ) { event ( "keyTyped" , e ) ; } public void keyPressed ( KeyEvent e ) { event ( "keyPressed" , e ) ; } public void keyReleased ( KeyEvent e ) { event ( "keyReleased" , e ) ; } public void mouseClicked ( MouseEvent e ) { event ( "mouseClicked" , e ) ; } public void mousePressed ( MouseEvent e ) { event ( "mousePressed" , e ) ; } public void mouseReleased ( MouseEvent e ) { event ( "mouseReleased" , e ) ; } public void mouseEntered ( MouseEvent e ) { event ( "mouseEntered" , e ) ; } public void mouseExited ( MouseEvent e ) { event ( "mouseExited" , e ) ; } public void mouseDragged ( MouseEvent e ) { event ( "mouseDragged" , e ) ; } public void mouseMoved ( MouseEvent e ) { event ( "mouseMoved" , e ) ; } public void textValueChanged ( TextEvent e ) { event ( "textValueChanged" , e ) ; } public void windowOpened ( WindowEvent e ) { event ( "windowOpened" , e ) ; } public void windowClosing ( WindowEvent e ) { event ( "windowClosing" , e ) ; } public void windowClosed ( WindowEvent e ) { event ( "windowClosed" , e ) ; } public void windowIconified ( WindowEvent e ) { event ( "windowIconified" , e ) ; } public void windowDeiconified ( WindowEvent e ) { event ( "windowDeiconified" , e ) ; } public void windowActivated ( WindowEvent e ) { event ( "windowActivated" , e ) ; } public void windowDeactivated ( WindowEvent e ) { event ( "windowDeactivated" , e ) ; } public void propertyChange ( PropertyChangeEvent e ) { event ( "propertyChange" , e ) ; } public void vetoableChange ( PropertyChangeEvent e ) { event ( "vetoableChange" , e ) ; } public boolean imageUpdate ( java . awt . Image img , int infoflags , int x , int y , int width , int height ) { BshMethod method = namespace . getMethod ( "imageUpdate" , new Class [ ] { null , null , null , null , null , null } ) ; if ( method != null ) try { method . invokeDeclaredMethod ( new Object [ ] { img , new Primitive ( infoflags ) , new Primitive ( x ) , new Primitive ( y ) , new Primitive ( width ) , new Primitive ( height ) } , declaringInterpreter , callstack , null ) ; } catch ( EvalError e ) { declaringInterpreter . error ( "local event handler imageUpdate: method invocation error:" + e ) ; } return true ; } private synchronized void writeObject ( java . io . ObjectOutputStream s ) throws IOException { NameSpace parent = namespace . getParent ( ) ; Interpreter interpreter = declaringInterpreter ; namespace . prune ( ) ; s . defaultWriteObject ( ) ; namespace . setParent ( parent ) ; declaringInterpreter = interpreter ; } } 	0	['87', '2', '0', '8', '100', '3741', '0', '8', '84', '2', '711', '0', '0', '0.104166667', '0.054675365', '1', '2', '7.172413793', '3', '1.023', '0']
package org . gjt . sp . jedit . options ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . * ; public class ModeOptionPane extends AbstractOptionPane { public ModeOptionPane ( ) { super ( "mode" ) ; } protected void _init ( ) { Mode [ ] modes = jEdit . getModes ( ) ; String [ ] modeNames = new String [ modes . length ] ; modeProps = new ModeProperties [ modes . length ] ; for ( int i = 0 ; i < modes . length ; i ++ ) { modeProps [ i ] = new ModeProperties ( modes [ i ] ) ; modeNames [ i ] = modes [ i ] . getName ( ) ; } mode = new JComboBox ( modeNames ) ; mode . addActionListener ( new ActionHandler ( ) ) ; addComponent ( jEdit . getProperty ( "options.mode.mode" ) , mode ) ; useDefaults = new JCheckBox ( jEdit . getProperty ( "options.mode.useDefaults" ) ) ; useDefaults . addActionListener ( new ActionHandler ( ) ) ; addComponent ( useDefaults ) ; addComponent ( jEdit . getProperty ( "options.mode.filenameGlob" ) , filenameGlob = new JTextField ( ) ) ; addComponent ( jEdit . getProperty ( "options.mode.firstlineGlob" ) , firstlineGlob = new JTextField ( ) ) ; String [ ] tabSizes = { "2" , "4" , "8" } ; addComponent ( jEdit . getProperty ( "options.editing.tabSize" ) , tabSize = new JComboBox ( tabSizes ) ) ; tabSize . setEditable ( true ) ; addComponent ( jEdit . getProperty ( "options.editing.indentSize" ) , indentSize = new JComboBox ( tabSizes ) ) ; indentSize . setEditable ( true ) ; String [ ] lineLens = { "0" , "72" , "76" , "80" } ; addComponent ( jEdit . getProperty ( "options.editing.maxLineLen" ) , maxLineLen = new JComboBox ( lineLens ) ) ; maxLineLen . setEditable ( true ) ; addComponent ( jEdit . getProperty ( "options.editing.wordBreakChars" ) , wordBreakChars = new JTextField ( ) ) ; addComponent ( jEdit . getProperty ( "options.mode.commentStart" ) , commentStart = new JTextField ( ) ) ; addComponent ( jEdit . getProperty ( "options.mode.commentEnd" ) , commentEnd = new JTextField ( ) ) ; addComponent ( jEdit . getProperty ( "options.mode.lineComment" ) , lineComment = new JTextField ( ) ) ; addComponent ( jEdit . getProperty ( "options.mode.noWordSep" ) , noWordSep = new JTextField ( ) ) ; addComponent ( jEdit . getProperty ( "options.editing.collapseFolds" ) , collapseFolds = new JTextField ( ) ) ; addComponent ( syntax = new JCheckBox ( jEdit . getProperty ( "options.editing.syntax" ) ) ) ; addComponent ( indentOnTab = new JCheckBox ( jEdit . getProperty ( "options.editing.indentOnTab" ) ) ) ; addComponent ( indentOnEnter = new JCheckBox ( jEdit . getProperty ( "options.editing.indentOnEnter" ) ) ) ; addComponent ( noTabs = new JCheckBox ( jEdit . getProperty ( "options.editing.noTabs" ) ) ) ; selectMode ( ) ; } protected void _save ( ) { saveMode ( ) ; for ( int i = 0 ; i < modeProps . length ; i ++ ) { modeProps [ i ] . save ( ) ; } } private ModeProperties [ ] modeProps ; private ModeProperties current ; private JComboBox mode ; private JCheckBox useDefaults ; private JTextField filenameGlob ; private JTextField firstlineGlob ; private JComboBox tabSize ; private JComboBox indentSize ; private JComboBox maxLineLen ; private JTextField wordBreakChars ; private JTextField commentStart ; private JTextField commentEnd ; private JTextField lineComment ; private JTextField noWordSep ; private JTextField collapseFolds ; private JCheckBox noTabs ; private JCheckBox indentOnTab ; private JCheckBox indentOnEnter ; private JCheckBox syntax ; private void saveMode ( ) { current . useDefaults = useDefaults . isSelected ( ) ; current . filenameGlob = filenameGlob . getText ( ) ; current . firstlineGlob = firstlineGlob . getText ( ) ; current . tabSize = ( String ) tabSize . getSelectedItem ( ) ; current . indentSize = ( String ) indentSize . getSelectedItem ( ) ; current . maxLineLen = ( String ) maxLineLen . getSelectedItem ( ) ; current . wordBreakChars = wordBreakChars . getText ( ) ; current . commentStart = commentStart . getText ( ) ; current . commentEnd = commentEnd . getText ( ) ; current . lineComment = lineComment . getText ( ) ; current . noWordSep = noWordSep . getText ( ) ; current . collapseFolds = collapseFolds . getText ( ) ; current . noTabs = noTabs . isSelected ( ) ; current . indentOnEnter = indentOnEnter . isSelected ( ) ; current . indentOnTab = indentOnTab . isSelected ( ) ; current . syntax = syntax . isSelected ( ) ; } private void selectMode ( ) { current = modeProps [ mode . getSelectedIndex ( ) ] ; current . edited = true ; current . load ( ) ; useDefaults . setSelected ( current . useDefaults ) ; filenameGlob . setText ( current . filenameGlob ) ; firstlineGlob . setText ( current . firstlineGlob ) ; tabSize . setSelectedItem ( current . tabSize ) ; indentSize . setSelectedItem ( current . indentSize ) ; maxLineLen . setSelectedItem ( current . maxLineLen ) ; wordBreakChars . setText ( current . wordBreakChars ) ; commentStart . setText ( current . commentStart ) ; commentEnd . setText ( current . commentEnd ) ; lineComment . setText ( current . lineComment ) ; noWordSep . setText ( current . noWordSep ) ; collapseFolds . setText ( current . collapseFolds ) ; noTabs . setSelected ( current . noTabs ) ; indentOnTab . setSelected ( current . indentOnTab ) ; indentOnEnter . setSelected ( current . indentOnEnter ) ; syntax . setSelected ( current . syntax ) ; updateEnabled ( ) ; } private void updateEnabled ( ) { boolean enabled = ! modeProps [ mode . getSelectedIndex ( ) ] . useDefaults ; filenameGlob . setEnabled ( enabled ) ; firstlineGlob . setEnabled ( enabled ) ; tabSize . setEnabled ( enabled ) ; indentSize . setEnabled ( enabled ) ; maxLineLen . setEnabled ( enabled ) ; wordBreakChars . setEnabled ( enabled ) ; commentStart . setEnabled ( enabled ) ; commentEnd . setEnabled ( enabled ) ; lineComment . setEnabled ( enabled ) ; noWordSep . setEnabled ( enabled ) ; collapseFolds . setEnabled ( enabled ) ; noTabs . setEnabled ( enabled ) ; indentOnTab . setEnabled ( enabled ) ; indentOnEnter . setEnabled ( enabled ) ; syntax . setEnabled ( enabled ) ; } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { if ( evt . getSource ( ) == mode ) { saveMode ( ) ; selectMode ( ) ; } else if ( evt . getSource ( ) == useDefaults ) { modeProps [ mode . getSelectedIndex ( ) ] . useDefaults = useDefaults . isSelected ( ) ; updateEnabled ( ) ; } } } class ModeProperties { Mode mode ; boolean edited ; boolean loaded ; boolean useDefaults ; String filenameGlob ; String firstlineGlob ; String tabSize ; String indentSize ; String maxLineLen ; String wordBreakChars ; String commentStart ; String commentEnd ; String lineComment ; String noWordSep ; String collapseFolds ; boolean noTabs ; boolean indentOnTab ; boolean indentOnEnter ; boolean syntax ; ModeProperties ( Mode mode ) { this . mode = mode ; } void load ( ) { if ( loaded ) return ; loaded = true ; mode . loadIfNecessary ( ) ; useDefaults = ! jEdit . getBooleanProperty ( "mode." + mode . getName ( ) + ".customSettings" ) ; filenameGlob = ( String ) mode . getProperty ( "filenameGlob" ) ; firstlineGlob = ( String ) mode . getProperty ( "firstlineGlob" ) ; tabSize = mode . getProperty ( "tabSize" ) . toString ( ) ; indentSize = mode . getProperty ( "indentSize" ) . toString ( ) ; maxLineLen = mode . getProperty ( "maxLineLen" ) . toString ( ) ; wordBreakChars = ( String ) mode . getProperty ( "wordBreakChars" ) ; commentStart = ( String ) mode . getProperty ( "commentStart" ) ; commentEnd = ( String ) mode . getProperty ( "commentEnd" ) ; lineComment = ( String ) mode . getProperty ( "lineComment" ) ; noWordSep = ( String ) mode . getProperty ( "noWordSep" ) ; collapseFolds = mode . getProperty ( "collapseFolds" ) . toString ( ) ; noTabs = mode . getBooleanProperty ( "noTabs" ) ; indentOnTab = mode . getBooleanProperty ( "indentOnTab" ) ; indentOnEnter = mode . getBooleanProperty ( "indentOnEnter" ) ; syntax = mode . getBooleanProperty ( "syntax" ) ; } void save ( ) { if ( ! edited ) return ; String prefix = "mode." + mode . getName ( ) + "." ; jEdit . setBooleanProperty ( prefix + "customSettings" , ! useDefaults ) ; if ( useDefaults ) { jEdit . resetProperty ( prefix + "filenameGlob" ) ; jEdit . resetProperty ( prefix + "firstlineGlob" ) ; jEdit . resetProperty ( prefix + "tabSize" ) ; jEdit . resetProperty ( prefix + "indentSize" ) ; jEdit . resetProperty ( prefix + "maxLineLen" ) ; jEdit . resetProperty ( prefix + "wordBreakChars" ) ; jEdit . resetProperty ( prefix + "commentStart" ) ; jEdit . resetProperty ( prefix + "commentEnd" ) ; jEdit . resetProperty ( prefix + "lineComment" ) ; jEdit . resetProperty ( prefix + "noWordSep" ) ; jEdit . resetProperty ( prefix + "collapseFolds" ) ; jEdit . resetProperty ( prefix + "noTabs" ) ; jEdit . resetProperty ( prefix + "indentOnTab" ) ; jEdit . resetProperty ( prefix + "indentOnEnter" ) ; jEdit . resetProperty ( prefix + "syntax" ) ; } else { jEdit . setProperty ( prefix + "filenameGlob" , filenameGlob ) ; jEdit . setProperty ( prefix + "firstlineGlob" , firstlineGlob ) ; jEdit . setProperty ( prefix + "tabSize" , tabSize ) ; jEdit . setProperty ( prefix + "indentSize" , indentSize ) ; jEdit . setProperty ( prefix + "maxLineLen" , maxLineLen ) ; jEdit . setProperty ( prefix + "wordBreakChars" , wordBreakChars ) ; jEdit . setProperty ( prefix + "commentStart" , commentStart ) ; jEdit . setProperty ( prefix + "commentEnd" , commentEnd ) ; jEdit . setProperty ( prefix + "lineComment" , lineComment ) ; jEdit . setProperty ( prefix + "noWordSep" , noWordSep ) ; jEdit . setProperty ( prefix + "collapseFolds" , collapseFolds ) ; jEdit . setBooleanProperty ( prefix + "noTabs" , noTabs ) ; jEdit . setBooleanProperty ( prefix + "indentOnTab" , indentOnTab ) ; jEdit . setBooleanProperty ( prefix + "indentOnEnter" , indentOnEnter ) ; jEdit . setBooleanProperty ( prefix + "syntax" , syntax ) ; } } } } 	1	['12', '6', '0', '6', '38', '28', '3', '5', '1', '0.392344498', '645', '1', '2', '0.983655275', '0.5', '1', '3', '51.16666667', '5', '1.4167', '3']
package org . gjt . sp . jedit . msg ; import org . gjt . sp . jedit . EBMessage ; import org . gjt . sp . jedit . View ; public class EditorExitRequested extends EBMessage . NonVetoable { public EditorExitRequested ( View view ) { super ( view ) ; } public View getView ( ) { return ( View ) getSource ( ) ; } } 	0	['2', '3', '0', '5', '4', '1', '1', '4', '2', '2', '10', '0', '0', '0.857142857', '0.75', '0', '0', '4', '1', '0.5', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import javax . swing . border . * ; import javax . swing . event . * ; import javax . swing . tree . * ; import java . awt . * ; import java . awt . event . * ; import java . util . * ; import org . gjt . sp . jedit . * ; import org . gjt . sp . jedit . options . * ; import org . gjt . sp . util . Log ; public class OptionsDialog extends EnhancedDialog implements ActionListener , TreeSelectionListener { public OptionsDialog ( View view ) { super ( view , jEdit . getProperty ( "options.title" ) , true ) ; view . showWaitCursor ( ) ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; content . setLayout ( new BorderLayout ( ) ) ; JPanel stage = new JPanel ( new BorderLayout ( ) ) ; stage . setBorder ( new EmptyBorder ( 0 , 6 , 0 , 0 ) ) ; content . add ( stage , BorderLayout . CENTER ) ; currentLabel = new JLabel ( ) ; currentLabel . setHorizontalAlignment ( JLabel . LEFT ) ; currentLabel . setBorder ( BorderFactory . createMatteBorder ( 0 , 0 , 1 , 0 , Color . black ) ) ; stage . add ( currentLabel , BorderLayout . NORTH ) ; cardPanel = new JPanel ( new CardLayout ( ) ) ; cardPanel . setBorder ( new EmptyBorder ( 5 , 0 , 0 , 0 ) ) ; stage . add ( cardPanel , BorderLayout . CENTER ) ; paneTree = new JTree ( createOptionTreeModel ( ) ) ; paneTree . setCellRenderer ( new PaneNameRenderer ( ) ) ; paneTree . putClientProperty ( "JTree.lineStyle" , "Angled" ) ; paneTree . setShowsRootHandles ( true ) ; paneTree . setRootVisible ( false ) ; content . add ( new JScrollPane ( paneTree , JScrollPane . VERTICAL_SCROLLBAR_ALWAYS , JScrollPane . HORIZONTAL_SCROLLBAR_AS_NEEDED ) , BorderLayout . WEST ) ; JPanel buttons = new JPanel ( ) ; buttons . setBorder ( new EmptyBorder ( 12 , 0 , 0 , 0 ) ) ; buttons . setLayout ( new BoxLayout ( buttons , BoxLayout . X_AXIS ) ) ; buttons . add ( Box . createGlue ( ) ) ; ok = new JButton ( jEdit . getProperty ( "common.ok" ) ) ; ok . addActionListener ( this ) ; buttons . add ( ok ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; getRootPane ( ) . setDefaultButton ( ok ) ; cancel = new JButton ( jEdit . getProperty ( "common.cancel" ) ) ; cancel . addActionListener ( this ) ; buttons . add ( cancel ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; apply = new JButton ( jEdit . getProperty ( "common.apply" ) ) ; apply . addActionListener ( this ) ; buttons . add ( apply ) ; buttons . add ( Box . createGlue ( ) ) ; content . add ( buttons , BorderLayout . SOUTH ) ; TreePath jEditPath = new TreePath ( new Object [ ] { paneTree . getModel ( ) . getRoot ( ) , jEditGroup } ) ; paneTree . getSelectionModel ( ) . addTreeSelectionListener ( this ) ; paneTree . setSelectionPath ( jEditPath . pathByAddingChild ( jEditGroup . getMember ( 0 ) ) ) ; view . hideWaitCursor ( ) ; pack ( ) ; setLocationRelativeTo ( view ) ; show ( ) ; } public void addOptionGroup ( OptionGroup group ) { addOptionGroup ( group , pluginsGroup ) ; } public void addOptionPane ( OptionPane pane ) { addOptionPane ( pane , pluginsGroup ) ; } public void ok ( ) { ok ( true ) ; } public void cancel ( ) { dispose ( ) ; } public void ok ( boolean dispose ) { OptionTreeModel m = ( OptionTreeModel ) paneTree . getModel ( ) ; ( ( OptionGroup ) m . getRoot ( ) ) . save ( ) ; jEdit . propertiesChanged ( ) ; jEdit . saveSettings ( ) ; if ( dispose ) dispose ( ) ; } public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == ok ) { ok ( ) ; } else if ( source == cancel ) { cancel ( ) ; } else if ( source == apply ) { ok ( false ) ; } } public void valueChanged ( TreeSelectionEvent evt ) { TreePath path = evt . getPath ( ) ; if ( path == null || ! ( path . getLastPathComponent ( ) instanceof OptionPane ) ) return ; Object [ ] nodes = path . getPath ( ) ; StringBuffer buf = new StringBuffer ( ) ; OptionPane optionPane = null ; String name = null ; int lastIdx = nodes . length - 1 ; for ( int i = paneTree . isRootVisible ( ) ? 0 : 1 ; i <= lastIdx ; i ++ ) { if ( nodes [ i ] instanceof OptionPane ) { optionPane = ( OptionPane ) nodes [ i ] ; name = optionPane . getName ( ) ; } else if ( nodes [ i ] instanceof OptionGroup ) { name = ( ( OptionGroup ) nodes [ i ] ) . getName ( ) ; } else { continue ; } if ( name != null ) { String label = jEdit . getProperty ( "options." + name + ".label" ) ; if ( label == null ) { buf . append ( name ) ; } else { buf . append ( label ) ; } } if ( i != lastIdx ) buf . append ( ": " ) ; } currentLabel . setText ( buf . toString ( ) ) ; optionPane . init ( ) ; pack ( ) ; ( ( CardLayout ) cardPanel . getLayout ( ) ) . show ( cardPanel , name ) ; } private Hashtable panes ; private JTree paneTree ; private JPanel cardPanel ; private JLabel currentLabel ; private JButton ok ; private JButton cancel ; private JButton apply ; private OptionGroup jEditGroup ; private OptionGroup pluginsGroup ; private OptionTreeModel createOptionTreeModel ( ) { OptionTreeModel paneTreeModel = new OptionTreeModel ( ) ; OptionGroup rootGroup = ( OptionGroup ) paneTreeModel . getRoot ( ) ; jEditGroup = new OptionGroup ( "jedit" ) ; addOptionPane ( new GeneralOptionPane ( ) , jEditGroup ) ; addOptionPane ( new LoadSaveOptionPane ( ) , jEditGroup ) ; addOptionPane ( new EditingOptionPane ( ) , jEditGroup ) ; addOptionPane ( new ModeOptionPane ( ) , jEditGroup ) ; addOptionPane ( new TextAreaOptionPane ( ) , jEditGroup ) ; addOptionPane ( new GutterOptionPane ( ) , jEditGroup ) ; addOptionPane ( new ColorOptionPane ( ) , jEditGroup ) ; addOptionPane ( new StyleOptionPane ( ) , jEditGroup ) ; addOptionPane ( new ShortcutsOptionPane ( ) , jEditGroup ) ; addOptionPane ( new DockingOptionPane ( ) , jEditGroup ) ; addOptionPane ( new ContextOptionPane ( ) , jEditGroup ) ; addOptionPane ( new ToolBarOptionPane ( ) , jEditGroup ) ; addOptionPane ( new AbbrevsOptionPane ( ) , jEditGroup ) ; addOptionPane ( new PrintOptionPane ( ) , jEditGroup ) ; addOptionPane ( new BrowserOptionPane ( ) , jEditGroup ) ; addOptionGroup ( jEditGroup , rootGroup ) ; pluginsGroup = new OptionGroup ( "plugins" ) ; EditPlugin [ ] plugins = jEdit . getPlugins ( ) ; for ( int i = 0 ; i < plugins . length ; i ++ ) { EditPlugin ep = plugins [ i ] ; try { ep . createOptionPanes ( this ) ; } catch ( Throwable t ) { Log . log ( Log . ERROR , ep , "Error creating option pane" ) ; Log . log ( Log . ERROR , ep , t ) ; } } if ( pluginsGroup . getMemberCount ( ) > 0 ) { addOptionGroup ( pluginsGroup , rootGroup ) ; } return paneTreeModel ; } private void addOptionGroup ( OptionGroup child , OptionGroup parent ) { Enumeration enum = child . getMembers ( ) ; while ( enum . hasMoreElements ( ) ) { Object elem = enum . nextElement ( ) ; if ( elem instanceof OptionPane ) { addOptionPane ( ( OptionPane ) elem , child ) ; } else if ( elem instanceof OptionGroup ) { addOptionGroup ( ( OptionGroup ) elem , child ) ; } } parent . addOptionGroup ( child ) ; } private void addOptionPane ( OptionPane pane , OptionGroup parent ) { String name = pane . getName ( ) ; cardPanel . add ( pane . getComponent ( ) , name ) ; parent . addOptionPane ( pane ) ; } class PaneNameRenderer extends JLabel implements TreeCellRenderer { public PaneNameRenderer ( ) { setOpaque ( true ) ; paneFont = UIManager . getFont ( "Tree.font" ) ; groupFont = new Font ( paneFont . getName ( ) , paneFont . getStyle ( ) | Font . BOLD , paneFont . getSize ( ) ) ; } public Component getTreeCellRendererComponent ( JTree tree , Object value , boolean selected , boolean expanded , boolean leaf , int row , boolean hasFocus ) { if ( selected ) { this . setBackground ( UIManager . getColor ( "Tree.selectionBackground" ) ) ; this . setForeground ( UIManager . getColor ( "Tree.selectionForeground" ) ) ; } else { this . setBackground ( UIManager . getColor ( "Tree.background" ) ) ; this . setForeground ( UIManager . getColor ( "Tree.foreground" ) ) ; } String name = null ; if ( value instanceof OptionGroup ) { name = ( ( OptionGroup ) value ) . getName ( ) ; this . setFont ( groupFont ) ; } else if ( value instanceof OptionPane ) { name = ( ( OptionPane ) value ) . getName ( ) ; this . setFont ( paneFont ) ; } if ( name == null ) { setText ( null ) ; } else { String label = jEdit . getProperty ( "options." + name + ".label" ) ; if ( label == null ) { setText ( name ) ; } else { setText ( label ) ; } } setIcon ( null ) ; return this ; } private Border noFocusBorder = BorderFactory . createEmptyBorder ( 1 , 1 , 1 , 1 ) ; private Border focusBorder = BorderFactory . createLineBorder ( UIManager . getColor ( "Tree.selectionBorderColor" ) ) ; private Font paneFont ; private Font groupFont ; } class OptionTreeModel implements TreeModel { public void addTreeModelListener ( TreeModelListener l ) { listenerList . add ( TreeModelListener . class , l ) ; } public void removeTreeModelListener ( TreeModelListener l ) { listenerList . remove ( TreeModelListener . class , l ) ; } public Object getChild ( Object parent , int index ) { if ( parent instanceof OptionGroup ) { return ( ( OptionGroup ) parent ) . getMember ( index ) ; } else { return null ; } } public int getChildCount ( Object parent ) { if ( parent instanceof OptionGroup ) { return ( ( OptionGroup ) parent ) . getMemberCount ( ) ; } else { return 0 ; } } public int getIndexOfChild ( Object parent , Object child ) { if ( parent instanceof OptionGroup ) { return ( ( OptionGroup ) parent ) . getMemberIndex ( child ) ; } else { return - 1 ; } } public Object getRoot ( ) { return root ; } public boolean isLeaf ( Object node ) { return node instanceof OptionPane ; } public void valueForPathChanged ( TreePath path , Object newValue ) { } protected void fireNodesChanged ( Object source , Object [ ] path , int [ ] childIndices , Object [ ] children ) { Object [ ] listeners = listenerList . getListenerList ( ) ; TreeModelEvent modelEvent = null ; for ( int i = listeners . length - 2 ; i >= 0 ; i -= 2 ) { if ( listeners [ i ] != TreeModelListener . class ) continue ; if ( modelEvent == null ) { modelEvent = new TreeModelEvent ( source , path , childIndices , children ) ; } ( ( TreeModelListener ) listeners [ i + 1 ] ) . treeNodesChanged ( modelEvent ) ; } } protected void fireNodesInserted ( Object source , Object [ ] path , int [ ] childIndices , Object [ ] children ) { Object [ ] listeners = listenerList . getListenerList ( ) ; TreeModelEvent modelEvent = null ; for ( int i = listeners . length - 2 ; i >= 0 ; i -= 2 ) { if ( listeners [ i ] != TreeModelListener . class ) continue ; if ( modelEvent == null ) { modelEvent = new TreeModelEvent ( source , path , childIndices , children ) ; } ( ( TreeModelListener ) listeners [ i + 1 ] ) . treeNodesInserted ( modelEvent ) ; } } protected void fireNodesRemoved ( Object source , Object [ ] path , int [ ] childIndices , Object [ ] children ) { Object [ ] listeners = listenerList . getListenerList ( ) ; TreeModelEvent modelEvent = null ; for ( int i = listeners . length - 2 ; i >= 0 ; i -= 2 ) { if ( listeners [ i ] != TreeModelListener . class ) continue ; if ( modelEvent == null ) { modelEvent = new TreeModelEvent ( source , path , childIndices , children ) ; } ( ( TreeModelListener ) listeners [ i + 1 ] ) . treeNodesRemoved ( modelEvent ) ; } } protected void fireTreeStructureChanged ( Object source , Object [ ] path , int [ ] childIndices , Object [ ] children ) { Object [ ] listeners = listenerList . getListenerList ( ) ; TreeModelEvent modelEvent = null ; for ( int i = listeners . length - 2 ; i >= 0 ; i -= 2 ) { if ( listeners [ i ] != TreeModelListener . class ) continue ; if ( modelEvent == null ) { modelEvent = new TreeModelEvent ( source , path , childIndices , children ) ; } ( ( TreeModelListener ) listeners [ i + 1 ] ) . treeStructureChanged ( modelEvent ) ; } } private OptionGroup root = new OptionGroup ( "root" ) ; private EventListenerList listenerList = new EventListenerList ( ) ; } } 	1	['14', '7', '0', '24', '106', '69', '3', '24', '8', '0.869230769', '708', '1', '2', '0.98048048', '0.174603175', '0', '0', '48.85714286', '9', '2.2143', '2']
package bsh ; class BSHArguments extends SimpleNode { BSHArguments ( int id ) { super ( id ) ; } public Object [ ] getArguments ( CallStack callstack , Interpreter interpreter ) throws EvalError { Object [ ] args = new Object [ jjtGetNumChildren ( ) ] ; for ( int i = 0 ; i < args . length ; i ++ ) args [ i ] = ( ( SimpleNode ) jjtGetChild ( i ) ) . eval ( callstack , interpreter ) ; return args ; } } 	0	['2', '2', '0', '10', '6', '1', '5', '5', '1', '2', '30', '0', '0', '0.947368421', '0.625', '0', '0', '14', '1', '0.5', '0']
package org . gjt . sp . jedit ; import com . microstar . xml . * ; import java . io . * ; import java . util . Stack ; import org . gjt . sp . util . Log ; class ModeCatalogHandler extends HandlerBase { ModeCatalogHandler ( String directory , boolean resource ) { this . directory = directory ; this . resource = resource ; } public Object resolveEntity ( String publicId , String systemId ) { if ( "catalog.dtd" . equals ( systemId ) ) { try { return new BufferedReader ( new InputStreamReader ( getClass ( ) . getResourceAsStream ( "catalog.dtd" ) ) ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , this , "Error while opening" + " catalog.dtd:" ) ; Log . log ( Log . ERROR , this , e ) ; } } return null ; } public void attribute ( String aname , String value , boolean isSpecified ) { aname = ( aname == null ) ? null : aname . intern ( ) ; if ( aname == "NAME" ) modeName = value ; else if ( aname == "FILE" ) { if ( value == null ) { Log . log ( Log . ERROR , this , directory + "catalog:" + " mode " + modeName + " doesn't have" + " a FILE attribute" ) ; } else file = value ; } else if ( aname == "FILE_NAME_GLOB" ) filenameGlob = value ; else if ( aname == "FIRST_LINE_GLOB" ) firstlineGlob = value ; } public void doctypeDecl ( String name , String publicId , String systemId ) throws Exception { if ( "CATALOG" . equals ( name ) || "MODES" . equals ( name ) ) return ; Log . log ( Log . ERROR , this , directory + "catalog: DOCTYPE must be CATALOG" ) ; } public void endElement ( String name ) { if ( name . equals ( "MODE" ) ) { Mode mode = jEdit . getMode ( modeName ) ; if ( mode == null ) { mode = new Mode ( modeName ) ; jEdit . addMode ( mode ) ; } Object path ; if ( resource ) path = jEdit . class . getResource ( directory + file ) ; else path = MiscUtilities . constructPath ( directory , file ) ; mode . setProperty ( "file" , path ) ; if ( filenameGlob != null ) mode . setProperty ( "filenameGlob" , filenameGlob ) ; else mode . unsetProperty ( "filenameGlob" ) ; if ( firstlineGlob != null ) mode . setProperty ( "firstlineGlob" , firstlineGlob ) ; else mode . unsetProperty ( "firstlineGlob" ) ; mode . init ( ) ; modeName = file = filenameGlob = firstlineGlob = null ; } } private String directory ; private boolean resource ; private String modeName ; private String file ; private String filenameGlob ; private String firstlineGlob ; } 	1	['6', '2', '0', '5', '28', '3', '1', '5', '4', '0.771428571', '230', '1', '0', '0.722222222', '0.722222222', '1', '3', '36.16666667', '7', '3', '1']
package org . gjt . sp . jedit . textarea ; public interface ScrollListener extends java . util . EventListener { void scrolledVertically ( JEditTextArea textArea ) ; void scrolledHorizontally ( JEditTextArea textArea ) ; } 	0	['2', '1', '0', '3', '2', '1', '3', '1', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . gjt . sp . jedit ; import javax . swing . JMenuItem ; import java . io . * ; import java . util . Vector ; import java . util . StringTokenizer ; public class MiscUtilities { public static String fileToClass ( String name ) { char [ ] clsName = name . toCharArray ( ) ; for ( int i = clsName . length - 6 ; i >= 0 ; i -- ) if ( clsName [ i ] == '/' ) clsName [ i ] = '.' ; return new String ( clsName , 0 , clsName . length - 6 ) ; } public static String classToFile ( String name ) { return name . replace ( '.' , '/' ) . concat ( ".class" ) ; } public static String constructPath ( String parent , String path ) { if ( new File ( path ) . isAbsolute ( ) ) return canonPath ( path ) ; if ( parent == null ) parent = System . getProperty ( "user.dir" ) ; if ( File . separatorChar == '\\' ) { if ( path . length ( ) == 2 && path . charAt ( 1 ) == ':' ) return path ; if ( path . startsWith ( "/" ) || path . startsWith ( "\\" ) ) parent = parent . substring ( 0 , 2 ) ; } if ( parent . endsWith ( File . separator ) || path . endsWith ( "/" ) ) return canonPath ( parent + path ) ; else return canonPath ( parent + File . separator + path ) ; } public static String constructPath ( String parent , String path1 , String path2 ) { return constructPath ( constructPath ( parent , path1 ) , path2 ) ; } public static String concatPath ( String parent , String path ) { if ( path . startsWith ( File . separator ) ) path = path . substring ( 1 ) ; else if ( ( path . length ( ) >= 3 ) && ( path . charAt ( 1 ) == ':' ) ) path = path . replace ( ':' , File . separatorChar ) ; if ( parent == null ) parent = System . getProperty ( "user.dir" ) ; if ( parent . endsWith ( File . separator ) ) return parent + path ; else return parent + File . separator + path ; } public static String getFileExtension ( String name ) { int index = name . indexOf ( '.' ) ; if ( index == - 1 ) return "" ; else return name . substring ( index ) ; } public static String getFileName ( String path ) { int count = Math . max ( 0 , path . length ( ) - 2 ) ; int index1 = path . lastIndexOf ( File . separatorChar , count ) ; int index2 = path . lastIndexOf ( '/' , count ) ; return path . substring ( Math . max ( index1 , index2 ) + 1 ) ; } public static String getFileParent ( String path ) { return getParentOfPath ( path ) ; } public static String getParentOfPath ( String path ) { int count = Math . max ( 0 , path . length ( ) - 2 ) ; int index = path . lastIndexOf ( File . separatorChar , count ) ; if ( index == - 1 ) index = path . lastIndexOf ( '/' , count ) ; if ( index == - 1 ) { index = path . lastIndexOf ( ':' ) ; } return path . substring ( 0 , index + 1 ) ; } public static String getFileProtocol ( String url ) { return getProtocolOfURL ( url ) ; } public static String getProtocolOfURL ( String url ) { return url . substring ( 0 , url . indexOf ( ':' ) ) ; } public static boolean isURL ( String str ) { int fsIndex = Math . max ( str . indexOf ( File . separatorChar ) , str . indexOf ( '/' ) ) ; if ( fsIndex == 0 ) return false ; else if ( fsIndex == 2 ) return false ; int cIndex = str . indexOf ( ':' ) ; if ( cIndex <= 1 ) return false ; else if ( fsIndex != - 1 && cIndex > fsIndex ) return false ; return true ; } public static int getLeadingWhiteSpace ( String str ) { int whitespace = 0 ; loop : for ( ; whitespace < str . length ( ) ; ) { switch ( str . charAt ( whitespace ) ) { case ' ' : case '\t' : whitespace ++ ; break ; default : break loop ; } } return whitespace ; } public static int getTrailingWhiteSpace ( String str ) { int whitespace = 0 ; loop : for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { switch ( str . charAt ( i ) ) { case ' ' : case '\t' : whitespace ++ ; break ; default : break loop ; } } return whitespace ; } public static int getLeadingWhiteSpaceWidth ( String str , int tabSize ) { int whitespace = 0 ; loop : for ( int i = 0 ; i < str . length ( ) ; i ++ ) { switch ( str . charAt ( i ) ) { case ' ' : whitespace ++ ; break ; case '\t' : whitespace += ( tabSize - whitespace % tabSize ) ; break ; default : break loop ; } } return whitespace ; } public static String createWhiteSpace ( int len , int tabSize ) { StringBuffer buf = new StringBuffer ( ) ; if ( tabSize == 0 ) { while ( len -- > 0 ) buf . append ( ' ' ) ; } else { int count = len / tabSize ; while ( count -- > 0 ) buf . append ( '\t' ) ; count = len % tabSize ; while ( count -- > 0 ) buf . append ( ' ' ) ; } return buf . toString ( ) ; } public static String globToRE ( String glob ) { StringBuffer buf = new StringBuffer ( ) ; boolean backslash = false ; boolean insideGroup = false ; for ( int i = 0 ; i < glob . length ( ) ; i ++ ) { char c = glob . charAt ( i ) ; if ( backslash ) { buf . append ( '\\' ) ; buf . append ( c ) ; backslash = false ; continue ; } switch ( c ) { case '\\' : backslash = true ; break ; case '?' : buf . append ( '.' ) ; break ; case '.' : buf . append ( "\\." ) ; break ; case '*' : buf . append ( ".*" ) ; break ; case '{' : buf . append ( '(' ) ; insideGroup = true ; break ; case ',' : if ( insideGroup ) buf . append ( '|' ) ; else buf . append ( ',' ) ; break ; case '}' : buf . append ( ')' ) ; insideGroup = false ; break ; default : buf . append ( c ) ; } } return buf . toString ( ) ; } public static String escapesToChars ( String str ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char c = str . charAt ( i ) ; switch ( c ) { case '\\' : if ( i == str . length ( ) - 1 ) { buf . append ( '\\' ) ; break ; } c = str . charAt ( ++ i ) ; switch ( c ) { case 'n' : buf . append ( '\n' ) ; break ; case 't' : buf . append ( '\t' ) ; break ; default : buf . append ( c ) ; break ; } break ; default : buf . append ( c ) ; } } return buf . toString ( ) ; } public static String charsToEscapes ( String str ) { return charsToEscapes ( str , false ) ; } public static String charsToEscapes ( String str , boolean history ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char c = str . charAt ( i ) ; switch ( c ) { case '\n' : buf . append ( "\\n" ) ; break ; case '\t' : buf . append ( "\\t" ) ; break ; case '[' : if ( history ) buf . append ( "\\[" ) ; else buf . append ( c ) ; break ; case ']' : if ( history ) buf . append ( "\\]" ) ; else buf . append ( c ) ; break ; case '"' : if ( history ) buf . append ( c ) ; else buf . append ( "\\\"" ) ; break ; case '\'' : if ( history ) buf . append ( c ) ; else buf . append ( "\\\'" ) ; break ; case '\\' : buf . append ( "\\\\" ) ; break ; default : buf . append ( c ) ; break ; } } return buf . toString ( ) ; } public static void quicksort ( Object [ ] obj , Compare compare ) { if ( obj . length == 0 ) return ; quicksort ( obj , 0 , obj . length - 1 , compare ) ; } public static void quicksort ( Vector vector , Compare compare ) { if ( vector . size ( ) == 0 ) return ; quicksort ( vector , 0 , vector . size ( ) - 1 , compare ) ; } public interface Compare { int compare ( Object obj1 , Object obj2 ) ; } public static class StringCompare implements Compare { public int compare ( Object obj1 , Object obj2 ) { return obj1 . toString ( ) . compareTo ( obj2 . toString ( ) ) ; } } public static class StringICaseCompare implements Compare { public int compare ( Object obj1 , Object obj2 ) { return obj1 . toString ( ) . toLowerCase ( ) . compareTo ( obj2 . toString ( ) . toLowerCase ( ) ) ; } } public static class MenuItemCompare implements Compare { public int compare ( Object obj1 , Object obj2 ) { return ( ( JMenuItem ) obj1 ) . getText ( ) . compareTo ( ( ( JMenuItem ) obj2 ) . getText ( ) ) ; } } public static class VersionCompare implements Compare { public int compare ( Object obj1 , Object obj2 ) { String v1 = obj1 . toString ( ) ; String v2 = obj2 . toString ( ) ; StringTokenizer vt1 = new StringTokenizer ( v1 , "." ) ; StringTokenizer vt2 = new StringTokenizer ( v2 , "." ) ; int comp = 0 ; while ( vt1 . hasMoreTokens ( ) && vt2 . hasMoreTokens ( ) ) { String vt1tok = vt1 . nextToken ( ) ; String vt2tok = vt2 . nextToken ( ) ; try { int i1 = Integer . parseInt ( vt1tok ) ; int i2 = Integer . parseInt ( vt2tok ) ; comp = i1 < i2 ? - 1 : i1 > i2 ? 1 : 0 ; } catch ( NumberFormatException e ) { comp = vt1tok . compareTo ( vt2tok ) ; } if ( comp != 0 ) return comp ; } return vt1 . hasMoreTokens ( ) ? 1 : vt2 . hasMoreTokens ( ) ? - 1 : 0 ; } } public static int compareVersions ( String version1 , String version2 ) { VersionCompare comparator = new VersionCompare ( ) ; return comparator . compare ( version1 , version2 ) ; } public static String buildToVersion ( String build ) { if ( build . length ( ) != 11 ) return "<unknown version: " + build + ">" ; int major = Integer . parseInt ( build . substring ( 0 , 2 ) ) ; int minor = Integer . parseInt ( build . substring ( 3 , 5 ) ) ; int beta = Integer . parseInt ( build . substring ( 6 , 8 ) ) ; int bugfix = Integer . parseInt ( build . substring ( 9 , 11 ) ) ; return "" + major + "." + minor + ( beta != 99 ? "pre" + beta : ( bugfix != 0 ? "." + bugfix : "final" ) ) ; } private MiscUtilities ( ) { } private static String canonPath ( String path ) { if ( File . separatorChar == '\\' ) { path = path . replace ( '/' , '\\' ) ; } try { return new File ( path ) . getCanonicalPath ( ) ; } catch ( Exception e ) { return path ; } } private static void quicksort ( Object [ ] obj , int _start , int _end , Compare compare ) { int start = _start ; int end = _end ; Object mid = obj [ ( _start + _end ) / 2 ] ; if ( _start > _end ) return ; while ( start <= end ) { while ( ( start < _end ) && ( compare . compare ( obj [ start ] , mid ) < 0 ) ) start ++ ; while ( ( end > _start ) && ( compare . compare ( obj [ end ] , mid ) > 0 ) ) end -- ; if ( start <= end ) { Object o = obj [ start ] ; obj [ start ] = obj [ end ] ; obj [ end ] = o ; start ++ ; end -- ; } } if ( _start < end ) quicksort ( obj , _start , end , compare ) ; if ( start < _end ) quicksort ( obj , start , _end , compare ) ; } private static void quicksort ( Vector obj , int _start , int _end , Compare compare ) { int start = _start ; int end = _end ; Object mid = obj . elementAt ( ( _start + _end ) / 2 ) ; if ( _start > _end ) return ; while ( start <= end ) { while ( ( start < _end ) && ( compare . compare ( obj . elementAt ( start ) , mid ) < 0 ) ) start ++ ; while ( ( end > _start ) && ( compare . compare ( obj . elementAt ( end ) , mid ) > 0 ) ) end -- ; if ( start <= end ) { Object o = obj . elementAt ( start ) ; obj . setElementAt ( obj . elementAt ( end ) , start ) ; obj . setElementAt ( o , end ) ; start ++ ; end -- ; } } if ( _start < end ) quicksort ( obj , _start , end , compare ) ; if ( start < _end ) quicksort ( obj , start , _end , compare ) ; } } 	1	['28', '1', '0', '45', '60', '378', '43', '2', '24', '2', '950', '0', '0', '0', '0.183673469', '0', '0', '32.92857143', '14', '3.7143', '4']
package org . gjt . sp . jedit . gui ; import javax . swing . border . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . * ; public class AbbrevEditor extends JPanel { public AbbrevEditor ( ) { GridBagLayout layout = new GridBagLayout ( ) ; setLayout ( layout ) ; GridBagConstraints cons = new GridBagConstraints ( ) ; cons . anchor = cons . WEST ; cons . fill = cons . BOTH ; cons . weightx = 1.0f ; cons . gridx = 1 ; cons . gridy = 1 ; JLabel label = new JLabel ( jEdit . getProperty ( "abbrev-editor.before" ) ) ; label . setBorder ( new EmptyBorder ( 6 , 0 , 3 , 0 ) ) ; layout . setConstraints ( label , cons ) ; add ( label ) ; cons . gridy ++ ; cons . weighty = 1.0f ; beforeCaret = new JTextArea ( 4 , 40 ) ; JScrollPane scroller = new JScrollPane ( beforeCaret ) ; layout . setConstraints ( scroller , cons ) ; add ( scroller ) ; cons . gridy ++ ; cons . weighty = 0.0f ; label = new JLabel ( jEdit . getProperty ( "abbrev-editor.after" ) ) ; label . setBorder ( new EmptyBorder ( 6 , 0 , 3 , 0 ) ) ; layout . setConstraints ( label , cons ) ; add ( label ) ; cons . gridy ++ ; cons . weighty = 1.0f ; afterCaret = new JTextArea ( 4 , 40 ) ; scroller = new JScrollPane ( afterCaret ) ; layout . setConstraints ( scroller , cons ) ; add ( scroller ) ; } public String getExpansion ( ) { StringBuffer buf = new StringBuffer ( ) ; String beforeCaretText = beforeCaret . getText ( ) ; String afterCaretText = afterCaret . getText ( ) ; for ( int i = 0 ; i < beforeCaretText . length ( ) ; i ++ ) { char ch = beforeCaretText . charAt ( i ) ; switch ( ch ) { case '\n' : buf . append ( "\\n" ) ; break ; case '\t' : buf . append ( "\\t" ) ; break ; case '\\' : buf . append ( "\\\\" ) ; break ; default : buf . append ( ch ) ; break ; } } if ( afterCaretText . length ( ) != 0 ) { buf . append ( "\\|" ) ; for ( int i = 0 ; i < afterCaretText . length ( ) ; i ++ ) { char ch = afterCaretText . charAt ( i ) ; switch ( ch ) { case '\n' : buf . append ( "\\n" ) ; break ; case '\t' : buf . append ( "\\t" ) ; break ; case '\\' : buf . append ( "\\\\" ) ; break ; default : buf . append ( ch ) ; break ; } } } return buf . toString ( ) ; } public void setExpansion ( String expansion ) { if ( expansion == null ) { beforeCaret . setText ( null ) ; afterCaret . setText ( null ) ; return ; } String beforeCaretText = null ; String afterCaretText = null ; StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < expansion . length ( ) ; i ++ ) { char ch = expansion . charAt ( i ) ; if ( ch == '\\' && i != expansion . length ( ) - 1 ) { ch = expansion . charAt ( ++ i ) ; switch ( ch ) { case 't' : buf . append ( '\t' ) ; break ; case 'n' : buf . append ( '\n' ) ; break ; case '|' : beforeCaretText = buf . toString ( ) ; buf . setLength ( 0 ) ; break ; default : buf . append ( ch ) ; break ; } } else buf . append ( ch ) ; } if ( beforeCaretText == null ) beforeCaretText = buf . toString ( ) ; else afterCaretText = buf . toString ( ) ; beforeCaret . setText ( beforeCaretText ) ; afterCaret . setText ( afterCaretText ) ; } public JTextArea getBeforeCaretTextArea ( ) { return beforeCaret ; } public JTextArea getAfterCaretTextArea ( ) { return afterCaret ; } private JTextArea beforeCaret , afterCaret ; } 	0	['5', '5', '0', '4', '26', '0', '3', '1', '5', '0.25', '339', '1', '0', '0.99391172', '0.6', '0', '0', '66.4', '12', '4.2', '0']
package org . gjt . sp . jedit . search ; import bsh . NameSpace ; import javax . swing . text . Segment ; import org . gjt . sp . jedit . BeanShell ; import org . gjt . sp . util . Log ; public class BoyerMooreSearchMatcher implements SearchMatcher { public BoyerMooreSearchMatcher ( String pattern , String replace , boolean ignoreCase , boolean reverseSearch , boolean beanshell , String replaceMethod ) { if ( ignoreCase ) { this . pattern = pattern . toUpperCase ( ) . toCharArray ( ) ; } else { this . pattern = pattern . toCharArray ( ) ; } if ( reverseSearch ) { char [ ] tmp = new char [ this . pattern . length ] ; for ( int i = 0 ; i < tmp . length ; i ++ ) { tmp [ i ] = this . pattern [ this . pattern . length - ( i + 1 ) ] ; } this . pattern = tmp ; } this . replace = replace ; this . ignoreCase = ignoreCase ; this . reverseSearch = reverseSearch ; this . beanshell = beanshell ; if ( beanshell ) { this . replaceMethod = replaceMethod ; replaceNS = new NameSpace ( BeanShell . getNameSpace ( ) , "search and replace" ) ; } generateSkipArray ( ) ; generateSuffixArray ( ) ; } public int [ ] nextMatch ( Segment text ) { int pos = match ( text . array , text . offset , text . offset + text . count ) ; if ( pos == - 1 ) { return null ; } else { return new int [ ] { pos - text . offset , pos + pattern . length - text . offset } ; } } public String substitute ( String text ) throws Exception { if ( beanshell ) { replaceNS . setVariable ( "_0" , text ) ; Object obj = BeanShell . runCachedBlock ( replaceMethod , null , replaceNS ) ; if ( obj == null ) return null ; else return obj . toString ( ) ; } else return replace ; } public int match ( char [ ] text , int offset , int length ) { int anchor = reverseSearch ? length - 1 : offset ; int pos ; int last_anchor = reverseSearch ? offset + pattern . length - 1 : length - pattern . length ; int pattern_end = pattern . length - 1 ; char ch = 0 ; int bad_char ; int good_suffix ; SEARCH : while ( reverseSearch ? anchor >= last_anchor : anchor <= last_anchor ) { for ( pos = pattern_end ; pos >= 0 ; -- pos ) { int idx = reverseSearch ? anchor - pos : anchor + pos ; ch = ignoreCase ? Character . toUpperCase ( text [ idx ] ) : text [ idx ] ; if ( ch != pattern [ pos ] ) { bad_char = pos - skip [ getSkipIndex ( ch ) ] ; good_suffix = suffix [ pos ] ; int skip = ( bad_char > good_suffix ) ? bad_char : good_suffix ; anchor += reverseSearch ? - skip : skip ; continue SEARCH ; } } return ( reverseSearch ? anchor - pattern_end : anchor ) ; } return - 1 ; } private char [ ] pattern ; private String replace ; private boolean ignoreCase ; private boolean reverseSearch ; private boolean beanshell ; private String replaceMethod ; private NameSpace replaceNS ; private int [ ] skip ; private int [ ] suffix ; private void generateSkipArray ( ) { skip = new int [ 256 ] ; if ( pattern . length == 0 ) return ; int pos = 0 ; do { skip [ getSkipIndex ( pattern [ pos ] ) ] = pos ; } while ( ++ pos < pattern . length ) ; } private static final int getSkipIndex ( char ch ) { return ( ( int ) ch ) & 0x000000FF ; } private void generateSuffixArray ( ) { int m = pattern . length ; int j = m + 1 ; suffix = new int [ j ] ; int [ ] tmp = new int [ j ] ; tmp [ m ] = j ; for ( int i = m ; i > 0 ; -- i ) { while ( j <= m && pattern [ i - 1 ] != pattern [ j - 1 ] ) { if ( suffix [ j ] == 0 ) { suffix [ j ] = j - i ; } j = tmp [ j ] ; } tmp [ i - 1 ] = -- j ; } int k = tmp [ 0 ] ; for ( j = 0 ; j <= m ; j ++ ) { if ( j > 0 ) { suffix [ j - 1 ] = ( suffix [ j ] == 0 ) ? k : suffix [ j ] ; } if ( j == k ) { k = tmp [ k ] ; } } } } 	1	['7', '1', '0', '5', '16', '0', '1', '4', '4', '0.666666667', '416', '1', '1', '0', '0.265306122', '0', '0', '57.14285714', '14', '4.1429', '3']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . textarea . JEditTextArea ; import org . gjt . sp . jedit . EditAction ; import org . gjt . sp . jedit . GUIUtilities ; public class EnhancedButton extends JButton { public EnhancedButton ( Icon icon , String toolTip , EditAction action ) { super ( icon ) ; if ( action != null ) { setEnabled ( true ) ; addActionListener ( new EditAction . Wrapper ( action ) ) ; } else setEnabled ( false ) ; setToolTipText ( toolTip ) ; Insets zeroInsets = new Insets ( 0 , 0 , 0 , 0 ) ; setMargin ( zeroInsets ) ; setRequestFocusEnabled ( false ) ; } public boolean isFocusTraversable ( ) { return false ; } public String getActionCommand ( ) { return getModel ( ) . getActionCommand ( ) ; } } 	0	['3', '6', '0', '3', '13', '3', '1', '2', '3', '2', '45', '0', '0', '0.997382199', '0.5', '2', '2', '14', '1', '0.6667', '0']
package org . gjt . sp . jedit . proto . jeditresource ; import java . io . * ; import java . net . * ; import org . gjt . sp . jedit . * ; public class PluginResURLConnection extends URLConnection { public PluginResURLConnection ( URL url ) throws IOException { super ( url ) ; String file = url . getFile ( ) ; int index = file . indexOf ( '!' , 0 ) ; if ( index == - 1 ) { plugin = null ; resource = file ; } else { int start ; if ( file . charAt ( 0 ) == '/' ) start = 1 ; else start = 0 ; plugin = file . substring ( start , index ) ; resource = file . substring ( index + 1 ) ; } if ( plugin != null && resource . startsWith ( "/" ) ) resource = resource . substring ( 1 ) ; } public void connect ( ) throws IOException { if ( ! connected ) { if ( plugin == null ) { in = jEdit . class . getResourceAsStream ( resource ) ; } else { EditPlugin . JAR [ ] plugins = jEdit . getPluginJARs ( ) ; for ( int i = 0 ; i < plugins . length ; i ++ ) { EditPlugin . JAR jar = plugins [ i ] ; if ( MiscUtilities . getFileName ( jar . getPath ( ) ) . equalsIgnoreCase ( plugin ) ) { in = jar . getClassLoader ( ) . getResourceAsStream ( resource ) ; break ; } } } if ( in == null ) { throw new IOException ( "Resource not found: " + resource ) ; } connected = true ; } } public InputStream getInputStream ( ) throws IOException { connect ( ) ; return in ; } public String getHeaderField ( String name ) { if ( name . equals ( "content-type" ) ) { if ( resource . endsWith ( ".html" ) ) return "text/html" ; else if ( resource . endsWith ( ".txt" ) ) return "text/plain" ; else if ( resource . endsWith ( ".rtf" ) ) return "text/rtf" ; else if ( resource . endsWith ( ".gif" ) ) return "image/gif" ; else if ( resource . endsWith ( ".jpg" ) || resource . endsWith ( ".jpeg" ) ) return "image/jpeg" ; else return null ; } else return null ; } private InputStream in ; private String plugin ; private String resource ; } 	1	['5', '2', '0', '5', '28', '2', '1', '4', '4', '0.5625', '199', '1', '0', '0.935483871', '0.466666667', '1', '7', '38', '8', '2.2', '1']
package bsh ; class ReflectError extends Exception { public ReflectError ( ) { super ( ) ; } public ReflectError ( String s ) { super ( s ) ; } } 	0	['2', '3', '0', '7', '4', '1', '7', '0', '2', '2', '9', '0', '0', '1', '0.75', '0', '0', '3.5', '0', '0', '0']
package org . gjt . sp . jedit ; import gnu . regexp . * ; import javax . swing . * ; import javax . swing . event . * ; import javax . swing . text . * ; import javax . swing . undo . * ; import java . awt . * ; import java . io . File ; import java . util . * ; import org . gjt . sp . jedit . browser . VFSBrowser ; import org . gjt . sp . jedit . io . * ; import org . gjt . sp . jedit . msg . * ; import org . gjt . sp . jedit . search . RESearchMatcher ; import org . gjt . sp . jedit . syntax . * ; import org . gjt . sp . jedit . textarea . * ; import org . gjt . sp . util . Log ; public class Buffer extends PlainDocument implements EBComponent { public static final String LINESEP = "lineSeparator" ; public static final String BACKED_UP = "Buffer__backedUp" ; public static final String CARET = "Buffer__caret" ; public static final String SELECTION = "Buffer__selection" ; public static final String SCROLL_VERT = "Buffer__scrollVert" ; public static final String SCROLL_HORIZ = "Buffer__scrollHoriz" ; public static final String ENCODING = "encoding" ; public void propertiesChanged ( ) { if ( getBooleanProperty ( "syntax" ) ) setTokenMarker ( mode . getTokenMarker ( ) ) ; else setTokenMarker ( jEdit . getMode ( "text" ) . getTokenMarker ( ) ) ; if ( undo != null ) { try { undo . setLimit ( Integer . parseInt ( jEdit . getProperty ( "buffer.undoCount" ) ) ) ; } catch ( NumberFormatException nf ) { undo . setLimit ( 100 ) ; } } putProperty ( "tabSize" , getProperty ( "tabSize" ) ) ; putProperty ( "maxLineLen" , getProperty ( "maxLineLen" ) ) ; } public void showInsertFileDialog ( View view ) { String [ ] files = GUIUtilities . showVFSFileDialog ( view , null , VFSBrowser . OPEN_DIALOG , false ) ; if ( files != null ) insert ( view , files [ 0 ] ) ; } public void print ( View view ) { PrintJob job = view . getToolkit ( ) . getPrintJob ( view , name , null ) ; if ( job == null ) return ; view . showWaitCursor ( ) ; int topMargin ; int leftMargin ; int bottomMargin ; int rightMargin ; int ppi = job . getPageResolution ( ) ; try { topMargin = ( int ) ( Float . valueOf ( jEdit . getProperty ( "print.margin.top" ) ) . floatValue ( ) * ppi ) ; } catch ( NumberFormatException nf ) { topMargin = ppi / 2 ; } try { leftMargin = ( int ) ( Float . valueOf ( jEdit . getProperty ( "print.margin.left" ) ) . floatValue ( ) * ppi ) ; } catch ( NumberFormatException nf ) { leftMargin = ppi / 2 ; } try { bottomMargin = ( int ) ( Float . valueOf ( jEdit . getProperty ( "print.margin.bottom" ) ) . floatValue ( ) * ppi ) ; } catch ( NumberFormatException nf ) { bottomMargin = topMargin ; } try { rightMargin = ( int ) ( Float . valueOf ( jEdit . getProperty ( "print.margin.right" ) ) . floatValue ( ) * ppi ) ; } catch ( NumberFormatException nf ) { rightMargin = leftMargin ; } boolean printHeader = jEdit . getBooleanProperty ( "print.header" ) ; boolean printFooter = jEdit . getBooleanProperty ( "print.footer" ) ; boolean printLineNumbers = jEdit . getBooleanProperty ( "print.lineNumbers" ) ; boolean syntax = jEdit . getBooleanProperty ( "print.syntax" ) ; String header = path ; String footer = new Date ( ) . toString ( ) ; int lineCount = getDefaultRootElement ( ) . getElementCount ( ) ; TabExpander expander = null ; Graphics gfx = null ; String fontFamily = jEdit . getProperty ( "print.font" ) ; int fontSize ; try { fontSize = Integer . parseInt ( jEdit . getProperty ( "print.fontsize" ) ) ; } catch ( NumberFormatException nf ) { fontSize = 10 ; } int fontStyle ; try { fontStyle = Integer . parseInt ( jEdit . getProperty ( "print.fontstyle" ) ) ; } catch ( NumberFormatException nf ) { fontStyle = Font . PLAIN ; } SyntaxStyle [ ] styles = GUIUtilities . loadStyles ( fontFamily , fontSize ) ; boolean style = jEdit . getBooleanProperty ( "print.style" ) ; boolean color = jEdit . getBooleanProperty ( "print.color" ) ; Font font = new Font ( fontFamily , fontStyle , fontSize ) ; FontMetrics fm = null ; Dimension pageDimension = job . getPageDimension ( ) ; int pageWidth = pageDimension . width ; int pageHeight = pageDimension . height ; int y = 0 ; int tabSize = 0 ; int lineHeight = 0 ; int page = 0 ; int lineNumberDigits = ( int ) Math . ceil ( Math . log ( lineCount ) / Math . log ( 10 ) ) ; int lineNumberWidth = 0 ; TextRenderer renderer = TextRenderer . createPrintTextRenderer ( ) ; renderer . configure ( false , false ) ; for ( int i = 0 ; i < lineCount ; i ++ ) { if ( gfx == null ) { page ++ ; gfx = job . getGraphics ( ) ; renderer . setupGraphics ( gfx ) ; gfx . setFont ( font ) ; fm = gfx . getFontMetrics ( ) ; if ( printLineNumbers ) { lineNumberWidth = fm . charWidth ( '0' ) * lineNumberDigits ; } else lineNumberWidth = 0 ; lineHeight = fm . getHeight ( ) ; tabSize = getTabSize ( ) * fm . charWidth ( ' ' ) ; expander = new PrintTabExpander ( leftMargin + lineNumberWidth , tabSize ) ; y = topMargin + lineHeight - fm . getDescent ( ) - fm . getLeading ( ) ; if ( printHeader ) { gfx . setColor ( Color . lightGray ) ; gfx . fillRect ( leftMargin , topMargin , pageWidth - leftMargin - rightMargin , lineHeight ) ; gfx . setColor ( Color . black ) ; gfx . drawString ( header , leftMargin , y ) ; y += lineHeight ; } } y += lineHeight ; gfx . setColor ( Color . black ) ; gfx . setFont ( font ) ; int x = leftMargin ; if ( printLineNumbers ) { String lineNumber = String . valueOf ( i + 1 ) ; gfx . drawString ( lineNumber , ( leftMargin + lineNumberWidth ) - fm . stringWidth ( lineNumber ) , y ) ; x += lineNumberWidth + fm . charWidth ( '0' ) ; } paintSyntaxLine ( i , gfx , x , y , expander , style , color , font , Color . black , Color . white , styles , renderer ) ; int bottomOfPage = pageHeight - bottomMargin - lineHeight ; if ( printFooter ) bottomOfPage -= lineHeight * 2 ; if ( y >= bottomOfPage || i == lineCount - 1 ) { if ( printFooter ) { y = pageHeight - bottomMargin ; gfx . setColor ( Color . lightGray ) ; gfx . setFont ( font ) ; gfx . fillRect ( leftMargin , y - lineHeight , pageWidth - leftMargin - rightMargin , lineHeight ) ; gfx . setColor ( Color . black ) ; y -= ( lineHeight - fm . getAscent ( ) ) ; gfx . drawString ( footer , leftMargin , y ) ; Integer [ ] args = { new Integer ( page ) } ; String pageStr = jEdit . getProperty ( "print.page" , args ) ; int width = fm . stringWidth ( pageStr ) ; gfx . drawString ( pageStr , pageWidth - rightMargin - width , y ) ; } gfx . dispose ( ) ; gfx = null ; } } job . end ( ) ; view . hideWaitCursor ( ) ; } public void reload ( View view ) { if ( getFlag ( DIRTY ) ) { String [ ] args = { name } ; int result = GUIUtilities . confirm ( view , "changedreload" , args , JOptionPane . YES_NO_OPTION , JOptionPane . WARNING_MESSAGE ) ; if ( result != JOptionPane . YES_OPTION ) return ; } view . getEditPane ( ) . saveCaretInfo ( ) ; load ( view , true ) ; } public boolean load ( final View view , final boolean reload ) { if ( isPerformingIO ( ) ) { GUIUtilities . error ( view , "buffer-multiple-io" , null ) ; return false ; } setFlag ( LOADING , true ) ; EditBus . send ( new BufferUpdate ( this , view , BufferUpdate . LOAD_STARTED ) ) ; undo = null ; final boolean loadAutosave ; if ( reload || ! getFlag ( NEW_FILE ) ) { if ( file != null ) modTime = file . lastModified ( ) ; if ( ! reload && autosaveFile != null && autosaveFile . exists ( ) ) loadAutosave = recoverAutosave ( view ) ; else { if ( autosaveFile != null ) autosaveFile . delete ( ) ; loadAutosave = false ; } if ( ! loadAutosave ) { if ( ! vfs . load ( view , this , path ) ) { setFlag ( LOADING , false ) ; return false ; } } } else loadAutosave = false ; Runnable runnable = new Runnable ( ) { public void run ( ) { StringBuffer sbuf = ( StringBuffer ) getProperty ( BufferIORequest . LOAD_DATA ) ; if ( sbuf != null ) { try { remove ( 0 , getLength ( ) ) ; insertString ( 0 , sbuf . toString ( ) , null ) ; } catch ( BadLocationException bl ) { bl . printStackTrace ( ) ; } } getDocumentProperties ( ) . remove ( "tabSize" ) ; getDocumentProperties ( ) . remove ( "indentSize" ) ; getDocumentProperties ( ) . remove ( "maxLineLen" ) ; getDocumentProperties ( ) . remove ( BufferIORequest . LOAD_DATA ) ; undo = new MyUndoManager ( ) ; try { undo . setLimit ( Integer . parseInt ( jEdit . getProperty ( "buffer.undoCount" ) ) ) ; } catch ( NumberFormatException nf ) { undo . setLimit ( 100 ) ; } setMode ( ) ; setFlag ( LOADING , false ) ; if ( reload ) setDirty ( false ) ; if ( loadAutosave ) setFlag ( DIRTY , true ) ; if ( jEdit . getBooleanProperty ( "parseFully" ) ) { for ( int i = 0 ; i < lineCount ; i ++ ) markTokens ( i ) ; } try { int collapseFolds = ( ( Integer ) getProperty ( "collapseFolds" ) ) . intValue ( ) ; if ( collapseFolds != 0 ) expandFolds ( collapseFolds ) ; } catch ( Exception e ) { } if ( ! getFlag ( TEMPORARY ) ) { EditBus . send ( new BufferUpdate ( Buffer . this , view , BufferUpdate . LOADED ) ) ; EditBus . send ( new BufferUpdate ( Buffer . this , view , BufferUpdate . MARKERS_CHANGED ) ) ; } } } ; if ( getFlag ( TEMPORARY ) ) runnable . run ( ) ; else VFSManager . runInAWTThread ( runnable ) ; return true ; } public boolean insert ( final View view , String path ) { if ( isPerformingIO ( ) ) { GUIUtilities . error ( view , "buffer-multiple-io" , null ) ; return false ; } if ( ! MiscUtilities . isURL ( path ) ) path = MiscUtilities . constructPath ( this . path , path ) ; Buffer buffer = jEdit . getBuffer ( path ) ; if ( buffer != null ) { try { view . getTextArea ( ) . setSelectedText ( buffer . getText ( 0 , buffer . getLength ( ) ) ) ; } catch ( BadLocationException bl ) { bl . printStackTrace ( ) ; } return true ; } VFS vfs = VFSManager . getVFSForPath ( path ) ; setFlag ( IO , true ) ; if ( ! vfs . insert ( view , this , path ) ) { setFlag ( IO , false ) ; return false ; } VFSManager . runInAWTThread ( new Runnable ( ) { public void run ( ) { setFlag ( IO , false ) ; StringBuffer sbuf = ( StringBuffer ) getProperty ( BufferIORequest . LOAD_DATA ) ; if ( sbuf != null ) { getDocumentProperties ( ) . remove ( BufferIORequest . LOAD_DATA ) ; view . getTextArea ( ) . setSelectedText ( sbuf . toString ( ) ) ; } } } ) ; return true ; } public void autosave ( ) { if ( autosaveFile == null || ! getFlag ( AUTOSAVE_DIRTY ) || ! getFlag ( DIRTY ) || getFlag ( LOADING ) || getFlag ( IO ) ) return ; setFlag ( AUTOSAVE_DIRTY , false ) ; VFSManager . runInWorkThread ( new BufferIORequest ( BufferIORequest . AUTOSAVE , null , this , null , VFSManager . getFileVFS ( ) , autosaveFile . getPath ( ) ) ) ; } public boolean saveAs ( View view , boolean rename ) { String [ ] files = GUIUtilities . showVFSFileDialog ( view , path , VFSBrowser . SAVE_DIALOG , false ) ; if ( files == null ) return false ; return save ( view , files [ 0 ] , rename ) ; } public boolean save ( View view , String path ) { return save ( view , path , true ) ; } public boolean save ( final View view , String path , final boolean rename ) { if ( isPerformingIO ( ) ) { GUIUtilities . error ( view , "buffer-multiple-io" , null ) ; return false ; } if ( path == null && getFlag ( NEW_FILE ) ) return saveAs ( view , rename ) ; if ( path == null && file != null ) { long newModTime = file . lastModified ( ) ; if ( newModTime != modTime ) { Object [ ] args = { this . path } ; int result = GUIUtilities . confirm ( view , "filechanged-save" , args , JOptionPane . YES_NO_OPTION , JOptionPane . WARNING_MESSAGE ) ; if ( result != JOptionPane . YES_OPTION ) return false ; } } setFlag ( IO , true ) ; EditBus . send ( new BufferUpdate ( this , view , BufferUpdate . SAVING ) ) ; if ( path == null ) path = this . path ; VFS vfs = VFSManager . getVFSForPath ( path ) ; if ( ! vfs . save ( view , this , path ) ) { setFlag ( IO , false ) ; return false ; } final String oldPath = this . path ; if ( rename ) setPath ( path ) ; VFSManager . runInAWTThread ( new Runnable ( ) { public void run ( ) { if ( getFlag ( NEW_FILE ) || ! getPath ( ) . equals ( oldPath ) ) VFSManager . sendVFSUpdate ( getVFS ( ) , getPath ( ) , true ) ; setFlag ( IO , false ) ; if ( rename ) { try { Buffer . this . _writeLock ( ) ; if ( autosaveFile != null ) autosaveFile . delete ( ) ; setFlag ( AUTOSAVE_DIRTY , false ) ; setFlag ( READ_ONLY , false ) ; setFlag ( NEW_FILE , false ) ; setFlag ( UNTITLED , false ) ; setFlag ( DIRTY , false ) ; } finally { Buffer . this . _writeUnlock ( ) ; } if ( ! getPath ( ) . equals ( oldPath ) ) { jEdit . updatePosition ( Buffer . this ) ; setMode ( ) ; } if ( file != null ) modTime = file . lastModified ( ) ; EditBus . send ( new BufferUpdate ( Buffer . this , view , BufferUpdate . DIRTY_CHANGED ) ) ; } } } ) ; return true ; } public void _writeLock ( ) { writeLock ( ) ; } public void _writeUnlock ( ) { writeUnlock ( ) ; } public long getLastModified ( ) { return modTime ; } public void setLastModified ( long modTime ) { this . modTime = modTime ; } public void checkModTime ( View view ) { if ( file == null || getFlag ( NEW_FILE ) || getFlag ( IO ) ) return ; boolean newReadOnly = ( file . exists ( ) && ! file . canWrite ( ) ) ; if ( newReadOnly != getFlag ( READ_ONLY ) ) { setFlag ( READ_ONLY , newReadOnly ) ; EditBus . send ( new BufferUpdate ( this , view , BufferUpdate . DIRTY_CHANGED ) ) ; } if ( ! jEdit . getBooleanProperty ( "view.checkModStatus" ) ) return ; long oldModTime = modTime ; long newModTime = file . lastModified ( ) ; if ( newModTime != oldModTime ) { modTime = newModTime ; if ( ! file . exists ( ) ) { setFlag ( NEW_FILE , true ) ; EditBus . send ( new BufferUpdate ( this , view , BufferUpdate . DIRTY_CHANGED ) ) ; Object [ ] args = { path } ; GUIUtilities . message ( view , "filedeleted" , args ) ; return ; } String prop = ( isDirty ( ) ? "filechanged-dirty" : "filechanged-focus" ) ; Object [ ] args = { path } ; int result = GUIUtilities . confirm ( view , prop , args , JOptionPane . YES_NO_OPTION , JOptionPane . WARNING_MESSAGE ) ; if ( result == JOptionPane . YES_OPTION ) { view . getEditPane ( ) . saveCaretInfo ( ) ; load ( view , true ) ; } } } public VFS getVFS ( ) { return vfs ; } public final File getFile ( ) { return file ; } public final File getAutosaveFile ( ) { return autosaveFile ; } public final String getName ( ) { return name ; } public final String getPath ( ) { return path ; } public final boolean isClosed ( ) { return getFlag ( CLOSED ) ; } public final boolean isLoaded ( ) { return ! getFlag ( LOADING ) ; } public final boolean isPerformingIO ( ) { return getFlag ( LOADING ) || getFlag ( IO ) ; } public final boolean isSaving ( ) { return getFlag ( IO ) ; } public final boolean isNewFile ( ) { return getFlag ( NEW_FILE ) ; } public final void setNewFile ( boolean newFile ) { setFlag ( NEW_FILE , newFile ) ; } public final boolean isUntitled ( ) { return getFlag ( UNTITLED ) ; } public final boolean isDirty ( ) { return getFlag ( DIRTY ) ; } public final boolean isReadOnly ( ) { return getFlag ( READ_ONLY ) ; } public final boolean isEditable ( ) { return ! ( getFlag ( READ_ONLY ) || getFlag ( IO ) || getFlag ( LOADING ) ) ; } public final void setReadOnly ( boolean readOnly ) { setFlag ( READ_ONLY , readOnly ) ; } public void setDirty ( boolean d ) { boolean old_d = getFlag ( DIRTY ) ; if ( d ) { if ( getFlag ( LOADING ) || getFlag ( READ_ONLY ) ) return ; if ( getFlag ( DIRTY ) && getFlag ( AUTOSAVE_DIRTY ) ) return ; setFlag ( DIRTY , true ) ; setFlag ( AUTOSAVE_DIRTY , true ) ; } else { setFlag ( DIRTY , false ) ; setFlag ( AUTOSAVE_DIRTY , false ) ; } if ( d != old_d ) { EditBus . send ( new BufferUpdate ( this , null , BufferUpdate . DIRTY_CHANGED ) ) ; } } public boolean isTemporary ( ) { return getFlag ( TEMPORARY ) ; } public Icon getIcon ( ) { if ( getFlag ( DIRTY ) ) return GUIUtilities . DIRTY_BUFFER_ICON ; else if ( getFlag ( READ_ONLY ) ) return GUIUtilities . READ_ONLY_BUFFER_ICON ; else if ( getFlag ( NEW_FILE ) ) return GUIUtilities . NEW_BUFFER_ICON ; else return GUIUtilities . NORMAL_BUFFER_ICON ; } public void undo ( ) { if ( undo == null ) return ; if ( ! isEditable ( ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; return ; } try { setFlag ( UNDO_IN_PROGRESS , true ) ; undo . undo ( ) ; } catch ( CannotUndoException cu ) { Log . log ( Log . DEBUG , this , cu ) ; Toolkit . getDefaultToolkit ( ) . beep ( ) ; return ; } finally { setFlag ( UNDO_IN_PROGRESS , false ) ; } } public void redo ( ) { if ( undo == null ) return ; if ( ! isEditable ( ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; return ; } try { setFlag ( UNDO_IN_PROGRESS , true ) ; undo . redo ( ) ; } catch ( CannotRedoException cr ) { Log . log ( Log . DEBUG , this , cr ) ; Toolkit . getDefaultToolkit ( ) . beep ( ) ; return ; } finally { setFlag ( UNDO_IN_PROGRESS , false ) ; } } public void addUndoableEdit ( UndoableEdit edit ) { if ( undo == null || getFlag ( UNDO_IN_PROGRESS ) || getFlag ( LOADING ) ) return ; if ( undo . canRedo ( ) && ! edit . isSignificant ( ) ) return ; if ( compoundEdit != null ) { compoundEditNonEmpty = true ; compoundEdit . addEdit ( edit ) ; } else undo . addEdit ( edit ) ; } public void beginCompoundEdit ( ) { if ( getFlag ( TEMPORARY ) ) return ; compoundEditCount ++ ; if ( compoundEdit == null ) { compoundEditNonEmpty = false ; compoundEdit = new CompoundEdit ( ) ; } } public void endCompoundEdit ( ) { if ( getFlag ( TEMPORARY ) ) return ; if ( compoundEditCount == 0 ) return ; compoundEditCount -- ; if ( compoundEditCount == 0 ) { compoundEdit . end ( ) ; if ( compoundEditNonEmpty && compoundEdit . canUndo ( ) ) undo . addEdit ( compoundEdit ) ; compoundEdit = null ; } } public boolean insideCompoundEdit ( ) { return compoundEdit != null ; } public void removeTrailingWhiteSpace ( int [ ] lines ) { Element map = getDefaultRootElement ( ) ; try { beginCompoundEdit ( ) ; for ( int i = 0 ; i < lines . length ; i ++ ) { int pos , lineStart , lineEnd , tail ; Element lineElement = map . getElement ( lines [ i ] ) ; getText ( lineElement . getStartOffset ( ) , lineElement . getEndOffset ( ) - lineElement . getStartOffset ( ) - 1 , seg ) ; if ( seg . count == 0 ) continue ; lineStart = seg . offset ; lineEnd = seg . offset + seg . count - 1 ; for ( pos = lineEnd ; pos >= lineStart ; pos -- ) { if ( ! Character . isWhitespace ( seg . array [ pos ] ) ) break ; } tail = lineEnd - pos ; if ( tail == 0 ) continue ; remove ( lineElement . getEndOffset ( ) - 1 - tail , tail ) ; } } catch ( BadLocationException ble ) { Log . log ( Log . ERROR , this , ble ) ; } finally { endCompoundEdit ( ) ; } } public void shiftIndentLeft ( int [ ] lines ) { int tabSize = getTabSize ( ) ; int indentSize = getIndentSize ( ) ; boolean noTabs = getBooleanProperty ( "noTabs" ) ; Element map = getDefaultRootElement ( ) ; try { beginCompoundEdit ( ) ; for ( int i = 0 ; i < lines . length ; i ++ ) { Element lineElement = map . getElement ( lines [ i ] ) ; int lineStart = lineElement . getStartOffset ( ) ; String line = getText ( lineStart , lineElement . getEndOffset ( ) - lineStart - 1 ) ; int whiteSpace = MiscUtilities . getLeadingWhiteSpace ( line ) ; if ( whiteSpace == 0 ) continue ; int whiteSpaceWidth = Math . max ( 0 , MiscUtilities . getLeadingWhiteSpaceWidth ( line , tabSize ) - indentSize ) ; remove ( lineStart , whiteSpace ) ; insertString ( lineStart , MiscUtilities . createWhiteSpace ( whiteSpaceWidth , ( noTabs ? 0 : tabSize ) ) , null ) ; } } catch ( BadLocationException ble ) { Log . log ( Log . ERROR , this , ble ) ; } finally { endCompoundEdit ( ) ; } } public void shiftIndentRight ( int [ ] lines ) { try { beginCompoundEdit ( ) ; int tabSize = getTabSize ( ) ; int indentSize = getIndentSize ( ) ; boolean noTabs = getBooleanProperty ( "noTabs" ) ; Element map = getDefaultRootElement ( ) ; for ( int i = 0 ; i < lines . length ; i ++ ) { Element lineElement = map . getElement ( lines [ i ] ) ; int lineStart = lineElement . getStartOffset ( ) ; String line = getText ( lineStart , lineElement . getEndOffset ( ) - lineStart - 1 ) ; int whiteSpace = MiscUtilities . getLeadingWhiteSpace ( line ) ; int whiteSpaceWidth = MiscUtilities . getLeadingWhiteSpaceWidth ( line , tabSize ) + indentSize ; remove ( lineStart , whiteSpace ) ; insertString ( lineStart , MiscUtilities . createWhiteSpace ( whiteSpaceWidth , ( noTabs ? 0 : tabSize ) ) , null ) ; } } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } finally { endCompoundEdit ( ) ; } } public int getTabSize ( ) { return ( ( Integer ) getProperty ( "tabSize" ) ) . intValue ( ) ; } public int getIndentSize ( ) { return ( ( Integer ) getProperty ( "indentSize" ) ) . intValue ( ) ; } public boolean getBooleanProperty ( String name ) { Object obj = getProperty ( name ) ; if ( obj instanceof Boolean ) return ( ( Boolean ) obj ) . booleanValue ( ) ; else if ( "true" . equals ( obj ) || "on" . equals ( obj ) || "yes" . equals ( obj ) ) return true ; else return false ; } public void putBooleanProperty ( String name , boolean value ) { putProperty ( name , value ? Boolean . TRUE : Boolean . FALSE ) ; } public final Mode getMode ( ) { return mode ; } public void setMode ( Mode mode ) { if ( mode == null ) throw new NullPointerException ( "Mode must be non-null" ) ; if ( this . mode == mode ) return ; Mode oldMode = this . mode ; this . mode = mode ; propertiesChanged ( ) ; if ( oldMode != null ) { EditBus . send ( new BufferUpdate ( this , null , BufferUpdate . MODE_CHANGED ) ) ; } } public void setMode ( ) { if ( ! getFlag ( LOADING ) ) clearProperties ( ) ; parseBufferLocalProperties ( ) ; String userMode = ( String ) getProperty ( "mode" ) ; if ( userMode != null ) { Mode m = jEdit . getMode ( userMode ) ; if ( m != null ) { setMode ( m ) ; return ; } } String nogzName = name . substring ( 0 , name . length ( ) - ( name . endsWith ( ".gz" ) ? 3 : 0 ) ) ; Element lineElement = getDefaultRootElement ( ) . getElement ( 0 ) ; try { String line = getText ( 0 , ( lineElement == null ? 0 : lineElement . getEndOffset ( ) - 1 ) ) ; Mode [ ] modes = jEdit . getModes ( ) ; for ( int i = 0 ; i < modes . length ; i ++ ) { if ( modes [ i ] . accept ( nogzName , line ) ) { setMode ( modes [ i ] ) ; return ; } } } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } Mode defaultMode = jEdit . getMode ( jEdit . getProperty ( "buffer.defaultMode" ) ) ; if ( defaultMode == null ) defaultMode = jEdit . getMode ( "text" ) ; setMode ( defaultMode ) ; } public boolean indentLine ( int lineIndex , boolean canIncreaseIndent , boolean canDecreaseIndent ) { if ( lineIndex == 0 ) return false ; String openBrackets = ( String ) getProperty ( "indentOpenBrackets" ) ; String closeBrackets = ( String ) getProperty ( "indentCloseBrackets" ) ; String _indentPrevLine = ( String ) getProperty ( "indentPrevLine" ) ; boolean doubleBracketIndent = getBooleanProperty ( "doubleBracketIndent" ) ; RE indentPrevLineRE = null ; if ( openBrackets == null ) openBrackets = "" ; if ( closeBrackets == null ) closeBrackets = "" ; if ( _indentPrevLine != null ) { try { indentPrevLineRE = new RE ( _indentPrevLine , RE . REG_ICASE , RESearchMatcher . RE_SYNTAX_JEDIT ) ; } catch ( REException re ) { Log . log ( Log . ERROR , this , "Invalid 'indentPrevLine'" + " regexp: " + _indentPrevLine ) ; Log . log ( Log . ERROR , this , re ) ; } } int tabSize = getTabSize ( ) ; int indentSize = getIndentSize ( ) ; boolean noTabs = getBooleanProperty ( "noTabs" ) ; Element map = getDefaultRootElement ( ) ; String prevLine = null ; String line = null ; Element lineElement = map . getElement ( lineIndex ) ; int start = lineElement . getStartOffset ( ) ; try { line = getText ( start , lineElement . getEndOffset ( ) - start - 1 ) ; for ( int i = lineIndex - 1 ; i >= 0 ; i -- ) { lineElement = map . getElement ( i ) ; int lineStart = lineElement . getStartOffset ( ) ; int len = lineElement . getEndOffset ( ) - lineStart - 1 ; if ( len != 0 ) { prevLine = getText ( lineStart , len ) ; break ; } } if ( prevLine == null ) return false ; } catch ( BadLocationException e ) { Log . log ( Log . ERROR , this , e ) ; return false ; } boolean prevLineMatches = ( indentPrevLineRE == null ? false : indentPrevLineRE . isMatch ( prevLine ) ) ; boolean prevLineStart = true ; int prevLineIndent = 0 ; int prevLineBrackets = 0 ; for ( int i = 0 ; i < prevLine . length ( ) ; i ++ ) { char c = prevLine . charAt ( i ) ; switch ( c ) { case ' ' : if ( prevLineStart ) prevLineIndent ++ ; break ; case '\t' : if ( prevLineStart ) { prevLineIndent += ( tabSize - ( prevLineIndent % tabSize ) ) ; } break ; default : prevLineStart = false ; if ( closeBrackets . indexOf ( c ) != - 1 ) prevLineBrackets = Math . max ( prevLineBrackets - 1 , 0 ) ; else if ( openBrackets . indexOf ( c ) != - 1 ) { if ( ! doubleBracketIndent ) prevLineMatches = false ; prevLineBrackets ++ ; } break ; } } boolean lineStart = true ; int lineIndent = 0 ; int lineWidth = 0 ; int lineBrackets = 0 ; int closeBracketIndex = - 1 ; for ( int i = 0 ; i < line . length ( ) ; i ++ ) { char c = line . charAt ( i ) ; switch ( c ) { case ' ' : if ( lineStart ) { lineIndent ++ ; lineWidth ++ ; } break ; case '\t' : if ( lineStart ) { lineIndent += ( tabSize - ( lineIndent % tabSize ) ) ; lineWidth ++ ; } break ; default : lineStart = false ; if ( closeBrackets . indexOf ( c ) != - 1 ) { if ( lineBrackets == 0 ) closeBracketIndex = i ; else lineBrackets -- ; } else if ( openBrackets . indexOf ( c ) != - 1 ) { if ( ! doubleBracketIndent ) prevLineMatches = false ; lineBrackets ++ ; } break ; } } try { if ( closeBracketIndex != - 1 ) { int offset = TextUtilities . findMatchingBracket ( this , lineIndex , closeBracketIndex ) ; if ( offset != - 1 ) { lineElement = map . getElement ( map . getElementIndex ( offset ) ) ; int startOffset = lineElement . getStartOffset ( ) ; String closeLine = getText ( startOffset , lineElement . getEndOffset ( ) - startOffset - 1 ) ; prevLineIndent = MiscUtilities . getLeadingWhiteSpaceWidth ( closeLine , tabSize ) ; } else return false ; } else { prevLineIndent += ( prevLineBrackets * indentSize ) ; } if ( prevLineMatches ) prevLineIndent += indentSize ; if ( ! canDecreaseIndent && prevLineIndent <= lineIndent ) return false ; if ( ! canIncreaseIndent && prevLineIndent >= lineIndent ) return false ; remove ( start , lineWidth ) ; insertString ( start , MiscUtilities . createWhiteSpace ( prevLineIndent , ( noTabs ? 0 : tabSize ) ) , null ) ; return true ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } return false ; } public void indentLines ( int start , int end ) { beginCompoundEdit ( ) ; for ( int i = start ; i <= end ; i ++ ) indentLine ( i , true , true ) ; endCompoundEdit ( ) ; } public void indentLines ( int [ ] lines ) { beginCompoundEdit ( ) ; for ( int i = 0 ; i < lines . length ; i ++ ) indentLine ( lines [ i ] , true , true ) ; endCompoundEdit ( ) ; } public void tokenizeLines ( ) { } public void tokenizeLines ( int start , int len ) { linesChanged ( start , len ) ; for ( int i = 0 ; i < len ; i ++ ) markTokens ( start + i ) ; } public int paintSyntaxLine ( int lineIndex , Graphics gfx , int _x , int _y , TabExpander expander , boolean style , boolean color , Font defaultFont , Color foreground , Color background , SyntaxStyle [ ] styles , TextRenderer renderer ) { float x = ( float ) _x ; float y = ( float ) _y ; LineInfo info = lineInfo [ lineIndex ] ; if ( info . tokensValid ) { Element lineElement = getDefaultRootElement ( ) . getElement ( lineIndex ) ; int lineStart = lineElement . getStartOffset ( ) ; try { getText ( lineStart , lineElement . getEndOffset ( ) - lineStart - 1 , seg ) ; } catch ( BadLocationException e ) { Log . log ( Log . ERROR , this , e ) ; } } else markTokens ( lineIndex ) ; Token tokens = info . firstToken ; char [ ] text = seg . array ; int off = seg . offset ; for ( ; ; ) { byte id = tokens . id ; if ( id == Token . END ) break ; Color tokenForeground ; Color tokenBackground = null ; if ( id == Token . NULL ) { gfx . setFont ( defaultFont ) ; tokenForeground = foreground ; } else { if ( style ) gfx . setFont ( styles [ id ] . getFont ( ) ) ; else gfx . setFont ( defaultFont ) ; if ( color ) { tokenBackground = styles [ id ] . getBackgroundColor ( ) ; tokenForeground = styles [ id ] . getForegroundColor ( ) ; } else tokenForeground = foreground ; } int len = tokens . length ; x = renderer . drawChars ( text , off , len , gfx , x , y , expander , tokenForeground , tokenBackground , background ) ; off += len ; tokens = tokens . next ; } return ( int ) x ; } public LineInfo markTokens ( int lineIndex ) { LineInfo info = lineInfo [ lineIndex ] ; if ( info . tokensValid ) return info ; int start = Math . max ( 0 , lineIndex - 100 ) - 1 ; int end = Math . max ( 0 , lineIndex - 100 ) ; for ( int i = lineIndex - 1 ; i > end ; i -- ) { if ( lineInfo [ i ] . tokensValid ) { start = i ; break ; } } LineInfo prev ; if ( start == - 1 ) prev = null ; else prev = lineInfo [ start ] ; Element map = getDefaultRootElement ( ) ; for ( int i = start + 1 ; i <= lineIndex ; i ++ ) { info = lineInfo [ i ] ; if ( info . tokensValid ) { prev = info ; continue ; } Element lineElement = map . getElement ( i ) ; int lineStart = lineElement . getStartOffset ( ) ; try { getText ( lineStart , lineElement . getEndOffset ( ) - lineStart - 1 , seg ) ; } catch ( BadLocationException e ) { Log . log ( Log . ERROR , this , e ) ; } info . lastToken = null ; ParserRule oldRule = info . context . inRule ; TokenMarker . LineContext oldParent = info . context . parent ; tokenMarker . markTokens ( prev , info , seg ) ; ParserRule newRule = info . context . inRule ; TokenMarker . LineContext newParent = info . context . parent ; info . tokensValid = true ; if ( i != lastTokenizedLine ) { nextLineRequested = false ; lastTokenizedLine = i ; } nextLineRequested |= ( oldRule != newRule || oldParent != newParent ) ; info . addToken ( 0 , Token . END ) ; prev = info ; } if ( nextLineRequested && lineCount - lineIndex > 1 ) { linesChanged ( lineIndex + 1 , lineCount - lineIndex - 1 ) ; } return info ; } public boolean setLineWidth ( int lineIndex , int width ) { LineInfo info = lineInfo [ lineIndex ] ; int oldWidth = info . width ; info . width = width ; return width != oldWidth ; } public int getMaxLineWidth ( int start , int len ) { int retVal = 0 ; int lines = 0 ; for ( int i = start ; ; i ++ ) { if ( i >= lineCount || lines >= len ) break ; LineInfo info = lineInfo [ i ] ; if ( info . visible ) { retVal = Math . max ( lineInfo [ i ] . width , retVal ) ; lines ++ ; } } return retVal ; } public boolean isNextLineRequested ( ) { return nextLineRequested ; } public LineInfo getLineInfo ( int line ) { return lineInfo [ line ] ; } public boolean isLineVisible ( int line ) { return lineInfo [ line ] . visible ; } public boolean isFoldStart ( int line ) { if ( line == lineCount - 1 ) return false ; return getFoldLevel ( line ) < getFoldLevel ( line + 1 ) ; } public int getFoldLevel ( int line ) { LineInfo info = lineInfo [ line ] ; if ( info . foldLevelValid ) return info . foldLevel ; else { boolean changed = false ; int tabSize = getTabSize ( ) ; Element lineElement = getDefaultRootElement ( ) . getElement ( line ) ; int start = lineElement . getStartOffset ( ) ; try { getText ( start , lineElement . getEndOffset ( ) - start - 1 , seg ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } int offset = seg . offset ; int count = seg . count ; int whitespace = 0 ; if ( count == 0 ) { if ( line != 0 ) whitespace = getFoldLevel ( line - 1 ) ; else whitespace = 0 ; } else { boolean seenNonWhitespace = false ; loop : for ( int i = 0 ; i < count ; i ++ ) { switch ( seg . array [ offset + i ] ) { case ' ' : whitespace ++ ; break ; case '\t' : whitespace += ( tabSize - whitespace % tabSize ) ; break ; default : seenNonWhitespace = true ; break loop ; } } if ( ! seenNonWhitespace ) { if ( line != 0 ) whitespace = getFoldLevel ( line - 1 ) ; else whitespace = 0 ; } } if ( info . foldLevel != whitespace ) { info . foldLevel = whitespace ; fireFoldLevelsChanged ( line - 1 , line - 1 ) ; } info . foldLevelValid = true ; return whitespace ; } } public int getPrevVisibleLine ( int lineNo ) { for ( int i = lineNo - 1 ; i >= 0 ; i -- ) { if ( lineInfo [ i ] . visible ) return i ; } return - 1 ; } public int getNextVisibleLine ( int lineNo ) { for ( int i = lineNo + 1 ; i < lineCount ; i ++ ) { if ( lineInfo [ i ] . visible ) return i ; } return - 1 ; } public int virtualToPhysical ( int lineNo ) { if ( ( lineNo < virtualLineCount && lineNo >= virtualLines . length ) || lineNo < 0 ) throw new RuntimeException ( "lineNo = " + lineNo ) ; if ( lineNo >= virtualLineCount ) return lineCount + ( lineNo - virtualLineCount ) ; return virtualLines [ lineNo ] ; } public int physicalToVirtual ( int lineNo ) { int start = 0 ; int end = virtualLineCount - 1 ; if ( lineNo < virtualLines [ start ] ) return start ; else if ( lineNo > virtualLines [ end ] ) return end ; for ( ; ; ) { switch ( end - start ) { case 0 : if ( virtualLines [ start ] < lineNo ) return start + 1 ; else return start ; case 1 : if ( virtualLines [ start ] < lineNo ) { if ( virtualLines [ end ] < lineNo ) return end + 1 ; else return end ; } else return start ; default : int pivot = start + ( end - start ) / 2 ; int value = virtualLines [ pivot ] ; if ( value == lineNo ) return pivot ; else if ( value < lineNo ) start = pivot + 1 ; else end = pivot - 1 ; break ; } } } public boolean collapseFoldAt ( int line ) { int initialFoldLevel = getFoldLevel ( line ) ; int start = 0 ; int end = lineCount - 1 ; if ( line != lineCount - 1 && getFoldLevel ( line + 1 ) > initialFoldLevel ) { start = line + 1 ; for ( int i = line + 1 ; i < lineCount ; i ++ ) { if ( getFoldLevel ( i ) <= initialFoldLevel ) { end = i - 1 ; break ; } } } else { boolean ok = false ; for ( int i = line - 1 ; i >= 0 ; i -- ) { if ( getFoldLevel ( i ) < initialFoldLevel ) { start = i + 1 ; ok = true ; break ; } } if ( ! ok ) { return false ; } for ( int i = line + 1 ; i < lineCount ; i ++ ) { if ( getFoldLevel ( i ) < initialFoldLevel ) { end = i - 1 ; break ; } } } int delta = ( end - start + 1 ) ; for ( int i = start ; i <= end ; i ++ ) { LineInfo info = lineInfo [ i ] ; if ( info . visible ) info . visible = false ; else delta -- ; } if ( delta == 0 ) { return false ; } start = physicalToVirtual ( start ) ; virtualLineCount -= delta ; System . arraycopy ( virtualLines , start + delta , virtualLines , start , virtualLines . length - start - delta ) ; fireFoldStructureChanged ( ) ; return true ; } public boolean expandFoldAt ( int line , boolean fully , JEditTextArea textArea ) { int initialFoldLevel = getFoldLevel ( line ) ; int start = 0 ; int end = lineCount - 1 ; if ( line != lineCount - 1 && lineInfo [ line ] . visible && ! lineInfo [ line + 1 ] . visible && getFoldLevel ( line + 1 ) > initialFoldLevel ) { start = line + 1 ; for ( int i = line + 1 ; i < lineCount ; i ++ ) { if ( lineInfo [ i ] . visible && getFoldLevel ( i ) <= initialFoldLevel ) { end = i - 1 ; break ; } } } else { boolean ok = false ; for ( int i = line - 1 ; i >= 0 ; i -- ) { if ( lineInfo [ i ] . visible && getFoldLevel ( i ) < initialFoldLevel ) { start = i + 1 ; ok = true ; break ; } } if ( ! ok ) { return false ; } for ( int i = line + 1 ; i < lineCount ; i ++ ) { if ( lineInfo [ i ] . visible && getFoldLevel ( i ) < initialFoldLevel ) { end = i - 1 ; break ; } } } int delta = 0 ; int tmpMapLen = 0 ; int [ ] tmpVirtualMap = new int [ end - start + 1 ] ; initialFoldLevel = getFoldLevel ( start ) ; for ( int i = start ; i <= end ; i ++ ) { LineInfo info = lineInfo [ i ] ; if ( info . visible ) { tmpVirtualMap [ tmpMapLen ++ ] = i ; } else if ( ! fully && getFoldLevel ( i ) > initialFoldLevel ) { } else { tmpVirtualMap [ tmpMapLen ++ ] = i ; delta ++ ; info . visible = true ; } } int virtualLine ; if ( start > virtualLines [ virtualLineCount - 1 ] ) virtualLine = virtualLineCount ; else virtualLine = physicalToVirtual ( start ) ; virtualLineCount += delta ; if ( virtualLines . length <= virtualLineCount ) { int [ ] virtualLinesN = new int [ ( virtualLineCount + 1 ) * 2 ] ; System . arraycopy ( virtualLines , 0 , virtualLinesN , 0 , virtualLines . length ) ; virtualLines = virtualLinesN ; } System . arraycopy ( virtualLines , virtualLine , virtualLines , virtualLine + delta , virtualLines . length - virtualLine - delta ) ; for ( int j = 0 ; j < tmpMapLen ; j ++ ) { virtualLines [ virtualLine + j ] = tmpVirtualMap [ j ] ; } fireFoldStructureChanged ( ) ; if ( textArea != null ) { int firstLine = textArea . getFirstLine ( ) ; int visibleLines = textArea . getVisibleLines ( ) ; if ( virtualLine + delta >= firstLine + visibleLines && delta < visibleLines - 1 ) { textArea . setFirstLine ( virtualLine + delta - visibleLines + 1 ) ; } } return true ; } public void expandFolds ( char digit ) { if ( digit < '1' || digit > '9' ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; return ; } else expandFolds ( ( int ) ( digit - '1' ) + 1 ) ; } public void expandFolds ( int level ) { if ( virtualLines . length <= lineCount ) { int [ ] virtualLinesN = new int [ ( lineCount + 1 ) * 2 ] ; System . arraycopy ( virtualLines , 0 , virtualLinesN , 0 , virtualLines . length ) ; virtualLines = virtualLinesN ; } level = ( level - 1 ) * getIndentSize ( ) + 1 ; boolean seenVisibleLine = false ; virtualLineCount = 0 ; for ( int i = 0 ; i < lineCount ; i ++ ) { if ( ! seenVisibleLine || getFoldLevel ( i ) < level ) { seenVisibleLine = true ; lineInfo [ i ] . visible = true ; virtualLines [ virtualLineCount ++ ] = i ; } else lineInfo [ i ] . visible = false ; } fireFoldStructureChanged ( ) ; } public void expandAllFolds ( ) { if ( virtualLines . length <= lineCount ) { int [ ] virtualLinesN = new int [ ( lineCount + 1 ) * 2 ] ; System . arraycopy ( virtualLines , 0 , virtualLinesN , 0 , virtualLines . length ) ; virtualLines = virtualLinesN ; } virtualLineCount = lineCount ; for ( int i = 0 ; i < lineCount ; i ++ ) { virtualLines [ i ] = i ; lineInfo [ i ] . visible = true ; } fireFoldStructureChanged ( ) ; } public void narrow ( int start , int end ) { virtualLineCount = end - start + 1 ; virtualLines = new int [ virtualLineCount ] ; for ( int i = 0 ; i < start ; i ++ ) lineInfo [ i ] . visible = false ; for ( int i = start ; i <= end ; i ++ ) { LineInfo info = lineInfo [ i ] ; info . visible = true ; virtualLines [ i - start ] = i ; } for ( int i = end + 1 ; i < lineCount ; i ++ ) lineInfo [ i ] . visible = false ; fireFoldStructureChanged ( ) ; } public void addFoldListener ( FoldListener l ) { foldListeners . addElement ( l ) ; } public void removeFoldListener ( FoldListener l ) { foldListeners . removeElement ( l ) ; } public int getLineCount ( ) { return lineCount ; } public int getVirtualLineCount ( ) { return virtualLineCount ; } public final Vector getMarkers ( ) { return markers ; } public void addOrRemoveMarker ( char shortcut , int pos ) { Element map = getDefaultRootElement ( ) ; int line = map . getElementIndex ( pos ) ; if ( getMarkerAtLine ( line ) != null ) removeMarker ( line ) ; else addMarker ( shortcut , pos ) ; } public void addMarker ( char shortcut , int pos ) { if ( ! getFlag ( READ_ONLY ) && jEdit . getBooleanProperty ( "persistentMarkers" ) ) setDirty ( true ) ; Marker markerN = new Marker ( this , shortcut , pos ) ; boolean added = false ; Element map = getDefaultRootElement ( ) ; int line = map . getElementIndex ( pos ) ; if ( ! getFlag ( LOADING ) ) { markerN . createPosition ( ) ; for ( int i = 0 ; i < markers . size ( ) ; i ++ ) { Marker marker = ( Marker ) markers . elementAt ( i ) ; if ( shortcut != '\0' && marker . getShortcut ( ) == shortcut ) marker . setShortcut ( '\0' ) ; if ( map . getElementIndex ( marker . getPosition ( ) ) == line ) { markers . removeElementAt ( i ) ; i -- ; } } for ( int i = 0 ; i < markers . size ( ) ; i ++ ) { Marker marker = ( Marker ) markers . elementAt ( i ) ; if ( marker . getPosition ( ) > pos ) { markers . insertElementAt ( markerN , i ) ; added = true ; break ; } } } if ( ! added ) markers . addElement ( markerN ) ; if ( ! getFlag ( LOADING ) ) { EditBus . send ( new BufferUpdate ( this , null , BufferUpdate . MARKERS_CHANGED ) ) ; } } public Marker getMarkerAtLine ( int line ) { Element map = getDefaultRootElement ( ) ; for ( int i = 0 ; i < markers . size ( ) ; i ++ ) { Marker marker = ( Marker ) markers . elementAt ( i ) ; if ( map . getElementIndex ( marker . getPosition ( ) ) == line ) return marker ; } return null ; } public void removeMarker ( int line ) { Element map = getDefaultRootElement ( ) ; for ( int i = 0 ; i < markers . size ( ) ; i ++ ) { Marker marker = ( Marker ) markers . elementAt ( i ) ; if ( map . getElementIndex ( marker . getPosition ( ) ) == line ) { if ( ! getFlag ( READ_ONLY ) && jEdit . getBooleanProperty ( "persistentMarkers" ) ) setDirty ( true ) ; marker . removePosition ( ) ; markers . removeElementAt ( i ) ; i -- ; } } EditBus . send ( new BufferUpdate ( this , null , BufferUpdate . MARKERS_CHANGED ) ) ; } public void removeAllMarkers ( ) { if ( ! getFlag ( READ_ONLY ) && jEdit . getBooleanProperty ( "persistentMarkers" ) ) setDirty ( true ) ; for ( int i = 0 ; i < markers . size ( ) ; i ++ ) ( ( Marker ) markers . elementAt ( i ) ) . removePosition ( ) ; markers . removeAllElements ( ) ; EditBus . send ( new BufferUpdate ( this , null , BufferUpdate . MARKERS_CHANGED ) ) ; } public Marker getMarker ( char shortcut ) { Enumeration enum = markers . elements ( ) ; while ( enum . hasMoreElements ( ) ) { Marker marker = ( Marker ) enum . nextElement ( ) ; if ( marker . getShortcut ( ) == shortcut ) return marker ; } return null ; } public final Buffer getNext ( ) { return next ; } public final Buffer getPrev ( ) { return prev ; } public final int getIndex ( ) { int count = 0 ; Buffer buffer = prev ; for ( ; ; ) { if ( buffer == null ) break ; count ++ ; buffer = buffer . prev ; } return count ; } public String toString ( ) { return name + " (" + vfs . getParentOfPath ( path ) + ")" ; } public void handleMessage ( EBMessage msg ) { if ( msg instanceof PropertiesChanged ) propertiesChanged ( ) ; } Buffer prev ; Buffer next ; Buffer ( View view , String path , boolean newFile , boolean temp , Hashtable props ) { lineCount = 1 ; lineInfo = new LineInfo [ 1 ] ; lineInfo [ 0 ] = new LineInfo ( ) ; lineInfo [ 0 ] . visible = true ; virtualLineCount = 1 ; virtualLines = new int [ 1 ] ; foldListeners = new Vector ( ) ; seg = new Segment ( ) ; lastTokenizedLine = - 1 ; setDocumentProperties ( new BufferProps ( ) ) ; clearProperties ( ) ; setFlag ( TEMPORARY , temp ) ; markers = new Vector ( ) ; addUndoableEditListener ( new UndoHandler ( ) ) ; Enumeration keys = props . keys ( ) ; Enumeration values = props . elements ( ) ; while ( keys . hasMoreElements ( ) ) { putProperty ( keys . nextElement ( ) , values . nextElement ( ) ) ; } Mode defaultMode = jEdit . getMode ( jEdit . getProperty ( "buffer.defaultMode" ) ) ; if ( defaultMode == null ) defaultMode = jEdit . getMode ( "text" ) ; setMode ( defaultMode ) ; setPath ( path ) ; setFlag ( UNTITLED , newFile ) ; if ( file != null ) newFile |= ! file . exists ( ) ; if ( ! temp ) EditBus . addToBus ( Buffer . this ) ; setFlag ( NEW_FILE , newFile ) ; } void commitTemporary ( ) { setFlag ( TEMPORARY , false ) ; EditBus . addToBus ( this ) ; } void close ( ) { setFlag ( CLOSED , true ) ; if ( autosaveFile != null ) autosaveFile . delete ( ) ; EditBus . removeFromBus ( this ) ; } protected void fireInsertUpdate ( DocumentEvent evt ) { DocumentEvent . ElementChange ch = evt . getChange ( getDefaultRootElement ( ) ) ; if ( ch != null ) { int index = ch . getIndex ( ) ; int len = ch . getChildrenAdded ( ) . length - ch . getChildrenRemoved ( ) . length ; addLinesToMap ( ch . getIndex ( ) + 1 , len ) ; linesChanged ( index , lineCount - index ) ; index += ( len + 1 ) ; } else { linesChanged ( getDefaultRootElement ( ) . getElementIndex ( evt . getOffset ( ) ) , 1 ) ; } super . fireInsertUpdate ( evt ) ; setDirty ( true ) ; } protected void fireRemoveUpdate ( DocumentEvent evt ) { DocumentEvent . ElementChange ch = evt . getChange ( getDefaultRootElement ( ) ) ; if ( ch != null ) { int index = ch . getIndex ( ) ; int len = ch . getChildrenRemoved ( ) . length - ch . getChildrenAdded ( ) . length ; removeLinesFromMap ( index , len ) ; linesChanged ( index , lineCount - index ) ; } else { linesChanged ( getDefaultRootElement ( ) . getElementIndex ( evt . getOffset ( ) ) , 1 ) ; } super . fireRemoveUpdate ( evt ) ; setDirty ( true ) ; } private void setFlag ( int flag , boolean value ) { if ( value ) flags |= ( 1 << flag ) ; else flags &= ~ ( 1 << flag ) ; } private boolean getFlag ( int flag ) { int mask = ( 1 << flag ) ; return ( flags & mask ) == mask ; } private static final int CLOSED = 0 ; private static final int LOADING = 1 ; private static final int IO = 2 ; private static final int NEW_FILE = 3 ; private static final int UNTITLED = 4 ; private static final int AUTOSAVE_DIRTY = 5 ; private static final int DIRTY = 6 ; private static final int READ_ONLY = 7 ; private static final int UNDO_IN_PROGRESS = 8 ; private static final int TEMPORARY = 9 ; private int flags ; private long modTime ; private File file ; private VFS vfs ; private File autosaveFile ; private String path ; private String name ; private Mode mode ; private MyUndoManager undo ; private CompoundEdit compoundEdit ; private boolean compoundEditNonEmpty ; private int compoundEditCount ; private Vector markers ; private int savedSelStart ; private int savedSelEnd ; private TokenMarker tokenMarker ; private Segment seg ; private LineInfo [ ] lineInfo ; private int lineCount ; private int lastTokenizedLine ; private boolean nextLineRequested ; private int [ ] virtualLines ; private int virtualLineCount ; private Vector foldListeners ; private void setPath ( String path ) { this . path = path ; vfs = VFSManager . getVFSForPath ( path ) ; if ( ( vfs . getCapabilities ( ) & VFS . WRITE_CAP ) == 0 ) setReadOnly ( true ) ; name = vfs . getFileName ( path ) ; if ( vfs instanceof FileVFS ) { file = new File ( path ) ; if ( autosaveFile != null ) autosaveFile . delete ( ) ; autosaveFile = new File ( file . getParent ( ) , '#' + name + '#' ) ; } } private boolean recoverAutosave ( final View view ) { if ( ! autosaveFile . canRead ( ) ) return false ; GUIUtilities . hideSplashScreen ( ) ; final Object [ ] args = { autosaveFile . getPath ( ) } ; int result = GUIUtilities . confirm ( view , "autosave-found" , args , JOptionPane . YES_NO_OPTION , JOptionPane . WARNING_MESSAGE ) ; if ( result == JOptionPane . YES_OPTION ) { vfs . load ( view , this , autosaveFile . getPath ( ) ) ; VFSManager . runInAWTThread ( new Runnable ( ) { public void run ( ) { GUIUtilities . message ( view , "autosave-loaded" , args ) ; } } ) ; return true ; } else return false ; } private void clearProperties ( ) { Object lineSeparator = getProperty ( LINESEP ) ; Object encoding = getProperty ( ENCODING ) ; ( ( BufferProps ) getDocumentProperties ( ) ) . clear ( ) ; putProperty ( "i18n" , Boolean . FALSE ) ; if ( lineSeparator != null ) putProperty ( LINESEP , lineSeparator ) ; if ( encoding != null ) putProperty ( ENCODING , encoding ) ; else putProperty ( ENCODING , System . getProperty ( "file.encoding" ) ) ; } private void parseBufferLocalProperties ( ) { try { Element map = getDefaultRootElement ( ) ; for ( int i = 0 ; i < Math . min ( 10 , map . getElementCount ( ) ) ; i ++ ) { Element line = map . getElement ( i ) ; String text = getText ( line . getStartOffset ( ) , line . getEndOffset ( ) - line . getStartOffset ( ) - 1 ) ; parseBufferLocalProperty ( text ) ; } for ( int i = 0 ; i < markers . size ( ) ; i ++ ) { ( ( Marker ) markers . elementAt ( i ) ) . createPosition ( ) ; } } catch ( BadLocationException bl ) { bl . printStackTrace ( ) ; } } private void parseBufferLocalProperty ( String prop ) { StringBuffer buf = new StringBuffer ( ) ; String name = null ; boolean escape = false ; for ( int i = 0 ; i < prop . length ( ) ; i ++ ) { char c = prop . charAt ( i ) ; switch ( c ) { case ':' : if ( escape ) { escape = false ; buf . append ( ':' ) ; break ; } if ( name != null ) { String value = buf . toString ( ) ; try { putProperty ( name , new Integer ( value ) ) ; } catch ( NumberFormatException nf ) { putProperty ( name , value ) ; } } buf . setLength ( 0 ) ; break ; case '=' : if ( escape ) { escape = false ; buf . append ( '=' ) ; break ; } name = buf . toString ( ) ; buf . setLength ( 0 ) ; break ; case '\\' : if ( escape ) buf . append ( '\\' ) ; escape = ! escape ; break ; case 'n' : if ( escape ) { buf . append ( '\n' ) ; escape = false ; break ; } case 't' : if ( escape ) { buf . append ( '\t' ) ; escape = false ; break ; } default : buf . append ( c ) ; break ; } } } private void setTokenMarker ( TokenMarker tokenMarker ) { this . tokenMarker = tokenMarker ; ParserRuleSet mainSet = tokenMarker . getMainRuleSet ( ) ; for ( int i = 0 ; i < lineCount ; i ++ ) { LineInfo info = lineInfo [ i ] ; info . context = new TokenMarker . LineContext ( null , mainSet ) ; info . tokensValid = false ; } } private void addLinesToMap ( int index , int lines ) { if ( lines <= 0 ) return ; LineInfo prev = lineInfo [ index - 1 ] ; int virtualLine ; if ( index == lineCount ) virtualLine = virtualLineCount ; else virtualLine = physicalToVirtual ( index ) ; int virtualLength ; if ( prev . visible ) { virtualLineCount += lines ; if ( virtualLines . length <= virtualLineCount ) { int [ ] virtualLinesN = new int [ ( virtualLineCount + 1 ) * 2 ] ; System . arraycopy ( virtualLines , 0 , virtualLinesN , 0 , virtualLines . length ) ; virtualLines = virtualLinesN ; } virtualLength = virtualLine + lines ; System . arraycopy ( virtualLines , virtualLine , virtualLines , virtualLength , virtualLines . length - virtualLength ) ; for ( int i = 0 ; i < lines ; i ++ ) virtualLines [ virtualLine + i ] = index + i ; } else virtualLength = virtualLine ; for ( int i = virtualLength ; i < virtualLineCount ; i ++ ) virtualLines [ i ] += lines ; lineCount += lines ; if ( lineInfo . length <= lineCount ) { LineInfo [ ] lineInfoN = new LineInfo [ ( lineCount + 1 ) * 2 ] ; System . arraycopy ( lineInfo , 0 , lineInfoN , 0 , lineInfo . length ) ; lineInfo = lineInfoN ; } int length = index + lines ; System . arraycopy ( lineInfo , index , lineInfo , length , lineInfo . length - length ) ; ParserRuleSet mainSet = tokenMarker . getMainRuleSet ( ) ; for ( int i = 0 ; i < lines ; i ++ ) { LineInfo info = new LineInfo ( ) ; info . context = new TokenMarker . LineContext ( null , mainSet ) ; info . visible = prev . visible ; lineInfo [ index + i ] = info ; } } private void removeLinesFromMap ( int index , int lines ) { if ( lines <= 0 ) return ; int length = index + lines ; int virtualLine = physicalToVirtual ( index ) ; int virtualLength = physicalToVirtual ( length ) ; if ( length <= virtualLines [ virtualLineCount - 1 ] ) { System . arraycopy ( virtualLines , virtualLength , virtualLines , virtualLine , virtualLines . length - virtualLength ) ; for ( int i = virtualLine ; i < virtualLineCount - ( virtualLength - virtualLine ) ; i ++ ) virtualLines [ i ] -= lines ; } virtualLineCount -= ( virtualLength - virtualLine ) ; lineCount -= lines ; System . arraycopy ( lineInfo , length , lineInfo , index , lineInfo . length - length ) ; } private void linesChanged ( int index , int lines ) { for ( int i = 0 ; i < lines ; i ++ ) { LineInfo info = lineInfo [ index + i ] ; info . tokensValid = false ; info . foldLevelValid = false ; } } static class PrintTabExpander implements TabExpander { private int leftMargin ; private int tabSize ; public PrintTabExpander ( int leftMargin , int tabSize ) { this . leftMargin = leftMargin ; this . tabSize = tabSize ; } public float nextTabStop ( float x , int tabOffset ) { int ntabs = ( ( int ) x - leftMargin ) / tabSize ; return ( ntabs + 1 ) * tabSize + leftMargin ; } } private void fireFoldLevelsChanged ( int firstLine , int lastLine ) { for ( int i = 0 ; i < foldListeners . size ( ) ; i ++ ) { ( ( FoldListener ) foldListeners . elementAt ( i ) ) . foldLevelsChanged ( firstLine , lastLine ) ; } } private void fireFoldStructureChanged ( ) { for ( int i = 0 ; i < foldListeners . size ( ) ; i ++ ) { ( ( FoldListener ) foldListeners . elementAt ( i ) ) . foldStructureChanged ( ) ; } } public static interface FoldListener { void foldLevelsChanged ( int firstLine , int lastLine ) ; void foldStructureChanged ( ) ; } public static class LineInfo { public TokenMarker . LineContext context ; public Token getFirstToken ( ) { return firstToken ; } public Token getLastToken ( ) { return lastToken ; } public void addToken ( int length , byte id ) { if ( length == 0 && id != Token . END ) return ; if ( firstToken == null ) { firstToken = new Token ( length , id ) ; lastToken = firstToken ; } else if ( lastToken == null ) { lastToken = firstToken ; firstToken . length = length ; firstToken . id = id ; } else if ( lastToken . id == id ) { lastToken . length += length ; } else if ( lastToken . next == null ) { lastToken . next = new Token ( length , id ) ; lastToken . next . prev = lastToken ; lastToken = lastToken . next ; } else { lastToken = lastToken . next ; lastToken . length = length ; lastToken . id = id ; } } Token firstToken ; Token lastToken ; boolean tokensValid ; int width ; int foldLevel ; boolean foldLevelValid ; boolean visible ; } class BufferProps extends Hashtable { public Object get ( Object key ) { Object o = super . get ( key ) ; if ( o != null ) return o ; if ( ! ( key instanceof String ) ) return null ; if ( mode != null ) return mode . getProperty ( ( String ) key ) ; else { String value = jEdit . getProperty ( "buffer." + key ) ; if ( value == null ) return null ; try { return new Integer ( value ) ; } catch ( NumberFormatException nf ) { return value ; } } } } class MyUndoManager extends UndoManager { public UndoableEdit editToBeUndone ( ) { return super . editToBeUndone ( ) ; } public UndoableEdit editToBeRedone ( ) { return super . editToBeRedone ( ) ; } } class UndoHandler implements UndoableEditListener { public void undoableEditHappened ( UndoableEditEvent evt ) { addUndoableEdit ( evt . getEdit ( ) ) ; } } } 	1	['126', '3', '0', '102', '316', '6941', '79', '40', '90', '0.95255814', '5047', '0.790697674', '7', '0.324324324', '0.068783069', '1', '1', '38.71428571', '25', '3.5317', '25']
package bsh ; class BSHImportDeclaration extends SimpleNode { public boolean importPackage ; public boolean superImport ; BSHImportDeclaration ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { if ( superImport ) NameSpace . doSuperImport ( ) ; else { NameSpace namespace = callstack . top ( ) ; String name = ( ( BSHAmbiguousName ) jjtGetChild ( 0 ) ) . getName ( namespace ) . value ; if ( importPackage ) namespace . importPackage ( name ) ; else namespace . importClass ( name ) ; } return Primitive . VOID ; } } 	0	['2', '2', '0', '10', '9', '1', '1', '9', '1', '1', '36', '0', '0', '0.947368421', '0.625', '1', '1', '16', '1', '0.5', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . border . EmptyBorder ; import javax . swing . * ; import java . awt . * ; import java . awt . event . * ; import java . util . StringTokenizer ; import org . gjt . sp . jedit . msg . BufferUpdate ; import org . gjt . sp . jedit . * ; public class BufferOptions extends EnhancedDialog { public BufferOptions ( View view , Buffer buffer ) { super ( view , jEdit . getProperty ( "buffer-options.title" ) , true ) ; this . view = view ; this . buffer = buffer ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; ActionHandler actionListener = new ActionHandler ( ) ; JPanel panel = new JPanel ( ) ; GridBagLayout layout = new GridBagLayout ( ) ; panel . setLayout ( layout ) ; Insets nullInsets = new Insets ( 0 , 0 , 0 , 0 ) ; Insets labelInsets = new Insets ( 0 , 0 , 0 , 12 ) ; GridBagConstraints cons = new GridBagConstraints ( ) ; cons . gridx = cons . gridy = 0 ; cons . gridwidth = cons . gridheight = 1 ; cons . fill = GridBagConstraints . BOTH ; cons . weightx = 0.0f ; cons . insets = labelInsets ; cons . gridx = 0 ; cons . weightx = 0.0f ; cons . insets = labelInsets ; JLabel label = new JLabel ( jEdit . getProperty ( "buffer-options.mode" ) , SwingConstants . RIGHT ) ; layout . setConstraints ( label , cons ) ; panel . add ( label ) ; cons . gridx = 1 ; cons . weightx = 1.0f ; cons . insets = nullInsets ; modes = jEdit . getModes ( ) ; String bufferMode = buffer . getMode ( ) . getName ( ) ; int index = 0 ; String [ ] modeNames = new String [ modes . length ] ; for ( int i = 0 ; i < modes . length ; i ++ ) { Mode mode = modes [ i ] ; modeNames [ i ] = mode . getName ( ) ; if ( bufferMode . equals ( mode . getName ( ) ) ) index = i ; } mode = new JComboBox ( modeNames ) ; mode . setSelectedIndex ( index ) ; mode . addActionListener ( actionListener ) ; layout . setConstraints ( mode , cons ) ; panel . add ( mode ) ; cons . gridx = 0 ; cons . gridy = 1 ; cons . weightx = 0.0f ; cons . insets = labelInsets ; label = new JLabel ( jEdit . getProperty ( "options.editing.tabSize" ) , SwingConstants . RIGHT ) ; layout . setConstraints ( label , cons ) ; panel . add ( label ) ; cons . gridx = 1 ; cons . weightx = 1.0f ; cons . insets = nullInsets ; String [ ] tabSizes = { "2" , "4" , "8" } ; tabSize = new JComboBox ( tabSizes ) ; tabSize . setEditable ( true ) ; tabSize . setSelectedItem ( buffer . getProperty ( "tabSize" ) ) ; tabSize . addActionListener ( actionListener ) ; layout . setConstraints ( tabSize , cons ) ; panel . add ( tabSize ) ; cons . gridx = 0 ; cons . gridy = 2 ; cons . weightx = 0.0f ; cons . insets = labelInsets ; label = new JLabel ( jEdit . getProperty ( "options.editing.indentSize" ) , SwingConstants . RIGHT ) ; layout . setConstraints ( label , cons ) ; panel . add ( label ) ; cons . gridx = 1 ; cons . weightx = 1.0f ; cons . insets = nullInsets ; indentSize = new JComboBox ( tabSizes ) ; indentSize . setEditable ( true ) ; indentSize . setSelectedItem ( buffer . getProperty ( "indentSize" ) ) ; indentSize . addActionListener ( actionListener ) ; layout . setConstraints ( indentSize , cons ) ; panel . add ( indentSize ) ; cons . gridx = 0 ; cons . gridy = 3 ; cons . weightx = 0.0f ; cons . insets = labelInsets ; label = new JLabel ( jEdit . getProperty ( "options.editing.maxLineLen" ) , SwingConstants . RIGHT ) ; layout . setConstraints ( label , cons ) ; panel . add ( label ) ; String [ ] lineLengths = { "0" , "72" , "76" , "80" } ; cons . gridx = 1 ; cons . weightx = 1.0f ; cons . insets = nullInsets ; maxLineLen = new JComboBox ( lineLengths ) ; maxLineLen . setEditable ( true ) ; maxLineLen . setSelectedItem ( buffer . getProperty ( "maxLineLen" ) ) ; maxLineLen . addActionListener ( actionListener ) ; layout . setConstraints ( maxLineLen , cons ) ; panel . add ( maxLineLen ) ; cons . gridx = 0 ; cons . gridy = 4 ; cons . weightx = 0.0f ; cons . insets = labelInsets ; label = new JLabel ( jEdit . getProperty ( "buffer-options.lineSeparator" ) , SwingConstants . RIGHT ) ; layout . setConstraints ( label , cons ) ; panel . add ( label ) ; cons . gridx = 1 ; cons . weightx = 1.0f ; cons . insets = nullInsets ; String [ ] lineSeps = { jEdit . getProperty ( "lineSep.unix" ) , jEdit . getProperty ( "lineSep.windows" ) , jEdit . getProperty ( "lineSep.mac" ) } ; lineSeparator = new JComboBox ( lineSeps ) ; String lineSep = ( String ) buffer . getProperty ( Buffer . LINESEP ) ; if ( lineSep == null ) lineSep = System . getProperty ( "line.separator" ) ; if ( "\n" . equals ( lineSep ) ) lineSeparator . setSelectedIndex ( 0 ) ; else if ( "\r\n" . equals ( lineSep ) ) lineSeparator . setSelectedIndex ( 1 ) ; else if ( "\r" . equals ( lineSep ) ) lineSeparator . setSelectedIndex ( 2 ) ; lineSeparator . addActionListener ( actionListener ) ; layout . setConstraints ( lineSeparator , cons ) ; panel . add ( lineSeparator ) ; cons . gridx = 0 ; cons . gridy = 5 ; cons . weightx = 0.0f ; cons . insets = labelInsets ; label = new JLabel ( jEdit . getProperty ( "buffer-options.encoding" ) , SwingConstants . RIGHT ) ; layout . setConstraints ( label , cons ) ; panel . add ( label ) ; cons . gridx = 1 ; cons . weightx = 1.0f ; cons . insets = nullInsets ; DefaultComboBoxModel encodings = new DefaultComboBoxModel ( ) ; StringTokenizer st = new StringTokenizer ( jEdit . getProperty ( "encodings" ) ) ; while ( st . hasMoreTokens ( ) ) { encodings . addElement ( st . nextToken ( ) ) ; } encoding = new JComboBox ( encodings ) ; encoding . setEditable ( true ) ; encoding . setSelectedItem ( buffer . getProperty ( Buffer . ENCODING ) ) ; layout . setConstraints ( encoding , cons ) ; panel . add ( encoding ) ; cons . gridx = 0 ; cons . gridy = 6 ; cons . weightx = 0.0f ; cons . gridwidth = cons . REMAINDER ; cons . fill = GridBagConstraints . NONE ; cons . anchor = GridBagConstraints . WEST ; syntax = new JCheckBox ( jEdit . getProperty ( "options.editing.syntax" ) ) ; syntax . setSelected ( buffer . getBooleanProperty ( "syntax" ) ) ; syntax . addActionListener ( actionListener ) ; layout . setConstraints ( syntax , cons ) ; panel . add ( syntax ) ; cons . gridy = 7 ; indentOnTab = new JCheckBox ( jEdit . getProperty ( "options.editing.indentOnTab" ) ) ; indentOnTab . setSelected ( buffer . getBooleanProperty ( "indentOnTab" ) ) ; indentOnTab . addActionListener ( actionListener ) ; layout . setConstraints ( indentOnTab , cons ) ; panel . add ( indentOnTab ) ; cons . gridy = 8 ; indentOnEnter = new JCheckBox ( jEdit . getProperty ( "options.editing.indentOnEnter" ) ) ; indentOnEnter . setSelected ( buffer . getBooleanProperty ( "indentOnEnter" ) ) ; indentOnEnter . addActionListener ( actionListener ) ; layout . setConstraints ( indentOnEnter , cons ) ; panel . add ( indentOnEnter ) ; cons . gridy = 9 ; noTabs = new JCheckBox ( jEdit . getProperty ( "options.editing.noTabs" ) ) ; noTabs . setSelected ( buffer . getBooleanProperty ( "noTabs" ) ) ; noTabs . addActionListener ( actionListener ) ; layout . setConstraints ( noTabs , cons ) ; panel . add ( noTabs ) ; cons . gridy = 10 ; cons . insets = new Insets ( 6 , 0 , 6 , 0 ) ; label = new JLabel ( jEdit . getProperty ( "buffer-options.props" ) ) ; layout . setConstraints ( label , cons ) ; panel . add ( label ) ; content . add ( BorderLayout . NORTH , panel ) ; props = new JTextArea ( 4 , 4 ) ; props . setLineWrap ( true ) ; props . setWrapStyleWord ( false ) ; content . add ( BorderLayout . CENTER , new JScrollPane ( props ) ) ; updatePropsField ( ) ; panel = new JPanel ( ) ; panel . setLayout ( new BoxLayout ( panel , BoxLayout . X_AXIS ) ) ; panel . setBorder ( new EmptyBorder ( 12 , 0 , 0 , 0 ) ) ; panel . add ( Box . createGlue ( ) ) ; ok = new JButton ( jEdit . getProperty ( "common.ok" ) ) ; ok . addActionListener ( actionListener ) ; getRootPane ( ) . setDefaultButton ( ok ) ; panel . add ( ok ) ; panel . add ( Box . createHorizontalStrut ( 6 ) ) ; cancel = new JButton ( jEdit . getProperty ( "common.cancel" ) ) ; cancel . addActionListener ( actionListener ) ; panel . add ( cancel ) ; panel . add ( Box . createGlue ( ) ) ; content . add ( BorderLayout . SOUTH , panel ) ; pack ( ) ; setLocationRelativeTo ( view ) ; show ( ) ; } public void ok ( ) { try { buffer . putProperty ( "tabSize" , new Integer ( tabSize . getSelectedItem ( ) . toString ( ) ) ) ; } catch ( NumberFormatException nf ) { } try { buffer . putProperty ( "indentSize" , new Integer ( indentSize . getSelectedItem ( ) . toString ( ) ) ) ; } catch ( NumberFormatException nf ) { } try { buffer . putProperty ( "maxLineLen" , new Integer ( maxLineLen . getSelectedItem ( ) . toString ( ) ) ) ; } catch ( NumberFormatException nf ) { } int index = mode . getSelectedIndex ( ) ; buffer . setMode ( modes [ index ] ) ; index = lineSeparator . getSelectedIndex ( ) ; String lineSep ; if ( index == 0 ) lineSep = "\n" ; else if ( index == 1 ) lineSep = "\r\n" ; else if ( index == 2 ) lineSep = "\r" ; else throw new InternalError ( ) ; String oldLineSep = ( String ) buffer . getProperty ( Buffer . LINESEP ) ; if ( oldLineSep == null ) oldLineSep = System . getProperty ( "line.separator" ) ; if ( ! oldLineSep . equals ( lineSep ) ) { buffer . putProperty ( "lineSeparator" , lineSep ) ; buffer . setDirty ( true ) ; } String encoding = ( String ) this . encoding . getSelectedItem ( ) ; String oldEncoding = ( String ) buffer . getProperty ( Buffer . ENCODING ) ; if ( ! oldEncoding . equals ( encoding ) ) { buffer . putProperty ( Buffer . ENCODING , encoding ) ; buffer . setDirty ( true ) ; EditBus . send ( new BufferUpdate ( buffer , view , BufferUpdate . ENCODING_CHANGED ) ) ; } buffer . putBooleanProperty ( "syntax" , syntax . isSelected ( ) ) ; buffer . putBooleanProperty ( "indentOnTab" , indentOnTab . isSelected ( ) ) ; buffer . putBooleanProperty ( "indentOnEnter" , indentOnEnter . isSelected ( ) ) ; buffer . putBooleanProperty ( "noTabs" , noTabs . isSelected ( ) ) ; buffer . propertiesChanged ( ) ; dispose ( ) ; view . getTextArea ( ) . getPainter ( ) . repaint ( ) ; } public void cancel ( ) { dispose ( ) ; } private View view ; private Buffer buffer ; private JComboBox tabSize ; private JComboBox indentSize ; private JComboBox maxLineLen ; private Mode [ ] modes ; private JComboBox mode ; private JComboBox lineSeparator ; private JComboBox encoding ; private JCheckBox indentOnTab ; private JCheckBox indentOnEnter ; private JCheckBox syntax ; private JCheckBox noTabs ; private JTextArea props ; private JButton ok ; private JButton cancel ; private void updatePropsField ( ) { props . setText ( ":mode=" + modes [ mode . getSelectedIndex ( ) ] . getName ( ) + ":tabSize=" + tabSize . getSelectedItem ( ) + ":indentSize=" + indentSize . getSelectedItem ( ) + ":noTabs=" + noTabs . isSelected ( ) + ":indentOnTab=" + indentOnTab . isSelected ( ) + ":indentOnEnter=" + indentOnEnter . isSelected ( ) + ":syntax=" + syntax . isSelected ( ) + ":maxLineLen=" + maxLineLen . getSelectedItem ( ) + ":" ) ; } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == ok ) ok ( ) ; else if ( source == cancel ) cancel ( ) ; else if ( source == mode ) { Mode _mode = jEdit . getMode ( ( String ) mode . getSelectedItem ( ) ) ; tabSize . setSelectedItem ( _mode . getProperty ( "tabSize" ) ) ; indentSize . setSelectedItem ( _mode . getProperty ( "indentSize" ) ) ; maxLineLen . setSelectedItem ( _mode . getProperty ( "maxLineLen" ) ) ; indentOnTab . setSelected ( _mode . getBooleanProperty ( "indentOnTab" ) ) ; indentOnEnter . setSelected ( _mode . getBooleanProperty ( "indentOnEnter" ) ) ; syntax . setSelected ( _mode . getBooleanProperty ( "syntax" ) ) ; noTabs . setSelected ( _mode . getBooleanProperty ( "noTabs" ) ) ; updatePropsField ( ) ; } else updatePropsField ( ) ; } } } 	1	['15', '7', '0', '12', '91', '47', '2', '11', '3', '0.808035714', '1186', '1', '3', '0.979010495', '0.283333333', '1', '1', '77', '7', '1.3333', '6']
package bsh ; class BSHAssignment extends SimpleNode implements ParserConstants { public int operator ; BSHAssignment ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { BSHLHSPrimaryExpression lhsNode = ( BSHLHSPrimaryExpression ) jjtGetChild ( 0 ) ; if ( lhsNode == null ) throw new InterpreterError ( "Error, null LHSnode" ) ; LHS lhs = lhsNode . toLHS ( callstack , interpreter ) ; if ( lhs == null ) throw new InterpreterError ( "Error, null LHS" ) ; Object rhs = ( ( SimpleNode ) jjtGetChild ( 1 ) ) . eval ( callstack , interpreter ) ; if ( rhs == Primitive . VOID ) throw new EvalError ( "Void assignment." , this ) ; switch ( operator ) { case ASSIGN : try { return lhs . assign ( rhs ) ; } catch ( EvalError e ) { e . reThrow ( this ) ; } case PLUSASSIGN : return lhs . assign ( operation ( lhs . getValue ( ) , rhs , PLUS ) ) ; case MINUSASSIGN : return lhs . assign ( operation ( lhs . getValue ( ) , rhs , MINUS ) ) ; case STARASSIGN : return lhs . assign ( operation ( lhs . getValue ( ) , rhs , STAR ) ) ; case SLASHASSIGN : return lhs . assign ( operation ( lhs . getValue ( ) , rhs , SLASH ) ) ; case ANDASSIGN : case ANDASSIGNX : return lhs . assign ( operation ( lhs . getValue ( ) , rhs , BIT_AND ) ) ; case ORASSIGN : case ORASSIGNX : return lhs . assign ( operation ( lhs . getValue ( ) , rhs , BIT_OR ) ) ; case XORASSIGN : return lhs . assign ( operation ( lhs . getValue ( ) , rhs , XOR ) ) ; case MODASSIGN : return lhs . assign ( operation ( lhs . getValue ( ) , rhs , MOD ) ) ; case LSHIFTASSIGN : case LSHIFTASSIGNX : return lhs . assign ( operation ( lhs . getValue ( ) , rhs , LSHIFT ) ) ; case RSIGNEDSHIFTASSIGN : case RSIGNEDSHIFTASSIGNX : return lhs . assign ( operation ( lhs . getValue ( ) , rhs , RSIGNEDSHIFT ) ) ; case RUNSIGNEDSHIFTASSIGN : case RUNSIGNEDSHIFTASSIGNX : return lhs . assign ( operation ( lhs . getValue ( ) , rhs , RUNSIGNEDSHIFT ) ) ; default : throw new InterpreterError ( "unimplemented operator in assignment BSH" ) ; } } private Object operation ( Object lhs , Object rhs , int kind ) throws EvalError { if ( lhs instanceof String && rhs != Primitive . VOID ) { if ( kind != PLUS ) throw new EvalError ( "Use of non + operator with String LHS" , this ) ; return ( String ) lhs + rhs ; } if ( lhs instanceof Primitive || rhs instanceof Primitive ) if ( lhs == Primitive . VOID || rhs == Primitive . VOID ) throw new EvalError ( "Illegal use of undefined object or 'void' literal" , this ) ; else if ( lhs == Primitive . NULL || rhs == Primitive . NULL ) throw new EvalError ( "Illegal use of null object or 'null' literal" , this ) ; if ( ( lhs instanceof Boolean || lhs instanceof Character || lhs instanceof Number || lhs instanceof Primitive ) && ( rhs instanceof Boolean || rhs instanceof Character || rhs instanceof Number || rhs instanceof Primitive ) ) { return Primitive . binaryOperation ( lhs , rhs , kind ) ; } throw new EvalError ( "Non primitive value in operator: " + lhs . getClass ( ) + " " + tokenImage [ kind ] + " " + rhs . getClass ( ) , this ) ; } } 	0	['3', '2', '0', '11', '18', '3', '1', '10', '1', '1', '273', '0', '0', '0.9', '0.533333333', '1', '1', '89.66666667', '1', '0.6667', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import javax . swing . event . * ; import java . awt . * ; import java . awt . event . * ; import java . util . Vector ; import org . gjt . sp . jedit . * ; public class CompleteWord extends JWindow { public CompleteWord ( View view , String word , Vector completions , Point location ) { super ( view ) ; this . view = view ; this . word = word ; words = new JList ( completions ) ; words . setVisibleRowCount ( Math . min ( completions . size ( ) , 8 ) ) ; words . addMouseListener ( new MouseHandler ( ) ) ; words . setSelectedIndex ( 0 ) ; words . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; JScrollPane scroller = new JScrollPane ( words , JScrollPane . VERTICAL_SCROLLBAR_ALWAYS , JScrollPane . HORIZONTAL_SCROLLBAR_NEVER ) ; getContentPane ( ) . add ( scroller , BorderLayout . CENTER ) ; GUIUtilities . requestFocus ( this , words ) ; pack ( ) ; setLocation ( location ) ; show ( ) ; KeyHandler keyHandler = new KeyHandler ( ) ; addKeyListener ( keyHandler ) ; getRootPane ( ) . addKeyListener ( keyHandler ) ; words . addKeyListener ( keyHandler ) ; view . setKeyEventInterceptor ( keyHandler ) ; } public void dispose ( ) { view . setKeyEventInterceptor ( null ) ; super . dispose ( ) ; } private View view ; private String word ; private JList words ; private void insertSelected ( ) { view . getTextArea ( ) . setSelectedText ( ( ( String ) words . getSelectedValue ( ) ) . substring ( word . length ( ) ) ) ; dispose ( ) ; } class KeyHandler extends KeyAdapter { public void keyPressed ( KeyEvent evt ) { switch ( evt . getKeyCode ( ) ) { case KeyEvent . VK_TAB : case KeyEvent . VK_ENTER : insertSelected ( ) ; evt . consume ( ) ; break ; case KeyEvent . VK_ESCAPE : dispose ( ) ; evt . consume ( ) ; break ; case KeyEvent . VK_UP : if ( getFocusOwner ( ) == words ) return ; int selected = words . getSelectedIndex ( ) ; if ( selected == 0 ) return ; selected = selected - 1 ; words . setSelectedIndex ( selected ) ; words . ensureIndexIsVisible ( selected ) ; evt . consume ( ) ; break ; case KeyEvent . VK_DOWN : if ( getFocusOwner ( ) == words ) return ; selected = words . getSelectedIndex ( ) ; if ( selected == words . getModel ( ) . getSize ( ) - 1 ) return ; selected = selected + 1 ; words . setSelectedIndex ( selected ) ; words . ensureIndexIsVisible ( selected ) ; evt . consume ( ) ; break ; default : dispose ( ) ; view . processKeyEvent ( evt ) ; break ; } } public void keyTyped ( KeyEvent evt ) { evt = KeyEventWorkaround . processKeyEvent ( evt ) ; if ( evt == null ) return ; else { dispose ( ) ; view . processKeyEvent ( evt ) ; } } } class MouseHandler extends MouseAdapter { public void mouseClicked ( MouseEvent evt ) { insertSelected ( ) ; } } } 	1	['6', '5', '0', '5', '34', '0', '3', '5', '2', '0.4', '129', '1', '1', '0.991816694', '0.277777778', '0', '0', '20', '1', '0.8333', '1']
package bsh ; class SimpleNode implements Node { protected Node parent ; protected Node [ ] children ; protected int id ; Token firstToken , lastToken ; String sourceFile ; public SimpleNode ( int i ) { id = i ; } public void jjtOpen ( ) { } public void jjtClose ( ) { } public void jjtSetParent ( Node n ) { parent = n ; } public Node jjtGetParent ( ) { return parent ; } public void jjtAddChild ( Node n , int i ) { if ( children == null ) children = new Node [ i + 1 ] ; else if ( i >= children . length ) { Node c [ ] = new Node [ i + 1 ] ; System . arraycopy ( children , 0 , c , 0 , children . length ) ; children = c ; } children [ i ] = n ; } public Node jjtGetChild ( int i ) { return children [ i ] ; } public SimpleNode getChild ( int i ) { return ( SimpleNode ) jjtGetChild ( i ) ; } public int jjtGetNumChildren ( ) { return ( children == null ) ? 0 : children . length ; } public String toString ( ) { return ParserTreeConstants . jjtNodeName [ id ] ; } public String toString ( String prefix ) { return prefix + toString ( ) ; } public void dump ( String prefix ) { System . out . println ( toString ( prefix ) ) ; if ( children != null ) { for ( int i = 0 ; i < children . length ; ++ i ) { SimpleNode n = ( SimpleNode ) children [ i ] ; if ( n != null ) { n . dump ( prefix + " " ) ; } } } } public void prune ( ) { jjtSetParent ( null ) ; } public Object eval ( NameSpace namespace ) throws EvalError { throw new EvalError ( "Unimplemented or inappropriate for " + getClass ( ) . getName ( ) ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { return eval ( callstack . top ( ) ) ; } public void setSourceFile ( String sourceFile ) { this . sourceFile = sourceFile ; } public String getSourceFile ( ) { if ( sourceFile == null ) if ( parent != null ) return ( ( SimpleNode ) parent ) . getSourceFile ( ) ; else return "<unknown file>" ; else return sourceFile ; } public int getLineNumber ( ) { return firstToken . beginLine ; } public String getText ( ) { StringBuffer text = new StringBuffer ( ) ; Token t = firstToken ; while ( t != null ) { text . append ( t . image ) ; if ( ! t . image . equals ( "." ) ) text . append ( " " ) ; if ( t == lastToken || t . image . equals ( "{" ) || t . image . equals ( ";" ) ) break ; t = t . next ; } return text . toString ( ) ; } } 	0	['19', '1', '35', '50', '30', '147', '46', '7', '19', '0.888888889', '240', '0.5', '4', '0', '0.233082707', '0', '0', '11.31578947', '6', '1.6316', '0']
package org . gjt . sp . jedit . options ; import javax . swing . border . * ; import javax . swing . event . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . util . * ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . * ; public class ContextOptionPane extends AbstractOptionPane { public ContextOptionPane ( ) { super ( "context" ) ; } protected void _init ( ) { setLayout ( new BorderLayout ( ) ) ; JLabel caption = new JLabel ( jEdit . getProperty ( "options.context.caption" ) ) ; add ( BorderLayout . NORTH , caption ) ; String contextMenu = jEdit . getProperty ( "view.context" ) ; StringTokenizer st = new StringTokenizer ( contextMenu ) ; listModel = new DefaultListModel ( ) ; while ( st . hasMoreTokens ( ) ) { String actionName = ( String ) st . nextToken ( ) ; String label = getActionLabel ( actionName ) ; if ( label == null ) continue ; listModel . addElement ( new MenuItem ( actionName , label ) ) ; } list = new JList ( listModel ) ; list . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; list . addListSelectionListener ( new ListHandler ( ) ) ; add ( BorderLayout . CENTER , new JScrollPane ( list ) ) ; JPanel buttons = new JPanel ( ) ; buttons . setBorder ( new EmptyBorder ( 3 , 0 , 0 , 0 ) ) ; buttons . setLayout ( new BoxLayout ( buttons , BoxLayout . X_AXIS ) ) ; buttons . add ( Box . createGlue ( ) ) ; ActionHandler actionHandler = new ActionHandler ( ) ; add = new JButton ( jEdit . getProperty ( "options.context.add" ) ) ; add . addActionListener ( actionHandler ) ; buttons . add ( add ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; remove = new JButton ( jEdit . getProperty ( "options.context.remove" ) ) ; remove . addActionListener ( actionHandler ) ; buttons . add ( remove ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; moveUp = new JButton ( jEdit . getProperty ( "options.context.moveUp" ) ) ; moveUp . addActionListener ( actionHandler ) ; buttons . add ( moveUp ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; moveDown = new JButton ( jEdit . getProperty ( "options.context.moveDown" ) ) ; moveDown . addActionListener ( actionHandler ) ; buttons . add ( moveDown ) ; buttons . add ( Box . createGlue ( ) ) ; updateButtons ( ) ; add ( BorderLayout . SOUTH , buttons ) ; EditAction [ ] actions = jEdit . getActions ( ) ; Vector vector = new Vector ( actions . length ) ; for ( int i = 0 ; i < actions . length ; i ++ ) { String actionName = actions [ i ] . getName ( ) ; String label = jEdit . getProperty ( actionName + ".label" ) ; if ( label == null ) continue ; vector . addElement ( new MenuItem ( actionName , label ) ) ; } MiscUtilities . quicksort ( vector , new MenuItemCompare ( ) ) ; actionsList = new DefaultListModel ( ) ; actionsList . ensureCapacity ( vector . size ( ) ) ; for ( int i = 0 ; i < vector . size ( ) ; i ++ ) { actionsList . addElement ( vector . elementAt ( i ) ) ; } } class MenuItemCompare implements MiscUtilities . Compare { public int compare ( Object obj1 , Object obj2 ) { return ( ( MenuItem ) obj1 ) . label . toLowerCase ( ) . compareTo ( ( ( MenuItem ) obj2 ) . label . toLowerCase ( ) ) ; } } protected void _save ( ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < listModel . getSize ( ) ; i ++ ) { if ( i != 0 ) buf . append ( ' ' ) ; buf . append ( ( ( MenuItem ) listModel . elementAt ( i ) ) . actionName ) ; } jEdit . setProperty ( "view.context" , buf . toString ( ) ) ; } static String getActionLabel ( String actionName ) { if ( actionName . equals ( "-" ) ) return "-" ; else { if ( actionName . startsWith ( "play-macro@" ) ) { int index = Math . max ( 11 , actionName . indexOf ( '/' ) + 1 ) ; return actionName . substring ( index ) . replace ( '_' , ' ' ) ; } else return jEdit . getProperty ( actionName + ".label" ) ; } } private DefaultListModel listModel ; private JList list ; private JButton add ; private JButton remove ; private JButton moveUp , moveDown ; private DefaultListModel actionsList ; private void updateButtons ( ) { int index = list . getSelectedIndex ( ) ; remove . setEnabled ( index != - 1 && listModel . getSize ( ) != 0 ) ; moveUp . setEnabled ( index > 0 ) ; moveDown . setEnabled ( index != - 1 && index != listModel . getSize ( ) - 1 ) ; } static class MenuItem { String actionName ; String label ; MenuItem ( String actionName , String label ) { this . actionName = actionName ; if ( label . equals ( "-" ) ) this . label = label ; else this . label = GUIUtilities . prettifyMenuLabel ( label ) ; } public String toString ( ) { return label ; } } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == add ) { ContextAddDialog dialog = new ContextAddDialog ( ContextOptionPane . this , actionsList ) ; MenuItem selection = dialog . getSelection ( ) ; if ( selection == null ) return ; int index = list . getSelectedIndex ( ) ; if ( index == - 1 ) index = listModel . getSize ( ) ; else index ++ ; listModel . insertElementAt ( selection , index ) ; list . setSelectedIndex ( index ) ; } else if ( source == remove ) { int index = list . getSelectedIndex ( ) ; listModel . removeElementAt ( index ) ; updateButtons ( ) ; } else if ( source == moveUp ) { int index = list . getSelectedIndex ( ) ; Object selected = list . getSelectedValue ( ) ; listModel . removeElementAt ( index ) ; listModel . insertElementAt ( selected , index - 1 ) ; list . setSelectedIndex ( index - 1 ) ; } else if ( source == moveDown ) { int index = list . getSelectedIndex ( ) ; Object selected = list . getSelectedValue ( ) ; listModel . removeElementAt ( index ) ; listModel . insertElementAt ( selected , index + 1 ) ; list . setSelectedIndex ( index + 1 ) ; } } } class ListHandler implements ListSelectionListener { public void valueChanged ( ListSelectionEvent evt ) { updateButtons ( ) ; } } } class ContextAddDialog extends EnhancedDialog { public ContextAddDialog ( Component comp , ListModel actionsListModel ) { super ( JOptionPane . getFrameForComponent ( comp ) , jEdit . getProperty ( "options.context.add.title" ) , true ) ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; content . add ( BorderLayout . NORTH , new JLabel ( jEdit . getProperty ( "options.context.add.caption" ) ) ) ; JPanel mainPanel = new JPanel ( new BorderLayout ( 6 , 0 ) ) ; ActionHandler actionHandler = new ActionHandler ( ) ; ButtonGroup grp = new ButtonGroup ( ) ; separator = new JRadioButton ( jEdit . getProperty ( "options.context" + ".add.separator" ) ) ; separator . setSelected ( true ) ; separator . addActionListener ( actionHandler ) ; grp . add ( separator ) ; mainPanel . add ( BorderLayout . NORTH , separator ) ; JPanel actionPanel = new JPanel ( new BorderLayout ( 6 , 0 ) ) ; action = new JRadioButton ( jEdit . getProperty ( "options.context" + ".add.action" ) ) ; action . addActionListener ( actionHandler ) ; grp . add ( action ) ; actionPanel . add ( BorderLayout . NORTH , action ) ; actionsList = new JList ( actionsListModel ) ; actionsList . setVisibleRowCount ( 8 ) ; actionsList . setEnabled ( false ) ; actionPanel . add ( BorderLayout . CENTER , new JScrollPane ( actionsList ) ) ; mainPanel . add ( BorderLayout . CENTER , actionPanel ) ; JPanel macroPanel = new JPanel ( new BorderLayout ( 6 , 0 ) ) ; macro = new JRadioButton ( jEdit . getProperty ( "options.context" + ".add.macro" ) ) ; macro . addActionListener ( actionHandler ) ; grp . add ( macro ) ; macroPanel . add ( BorderLayout . NORTH , macro ) ; macrosList = new JList ( Macros . getMacroList ( ) ) ; macrosList . setVisibleRowCount ( 8 ) ; macrosList . setEnabled ( false ) ; macroPanel . add ( BorderLayout . CENTER , new JScrollPane ( macrosList ) ) ; mainPanel . add ( BorderLayout . SOUTH , macroPanel ) ; content . add ( BorderLayout . CENTER , mainPanel ) ; JPanel southPanel = new JPanel ( ) ; southPanel . setLayout ( new BoxLayout ( southPanel , BoxLayout . X_AXIS ) ) ; southPanel . setBorder ( new EmptyBorder ( 12 , 0 , 0 , 0 ) ) ; southPanel . add ( Box . createGlue ( ) ) ; ok = new JButton ( jEdit . getProperty ( "common.ok" ) ) ; ok . addActionListener ( actionHandler ) ; getRootPane ( ) . setDefaultButton ( ok ) ; southPanel . add ( ok ) ; southPanel . add ( Box . createHorizontalStrut ( 6 ) ) ; cancel = new JButton ( jEdit . getProperty ( "common.cancel" ) ) ; cancel . addActionListener ( actionHandler ) ; southPanel . add ( cancel ) ; southPanel . add ( Box . createGlue ( ) ) ; content . add ( BorderLayout . SOUTH , southPanel ) ; pack ( ) ; setLocationRelativeTo ( JOptionPane . getFrameForComponent ( comp ) ) ; show ( ) ; } public void ok ( ) { isOK = true ; dispose ( ) ; } public void cancel ( ) { dispose ( ) ; } public ContextOptionPane . MenuItem getSelection ( ) { if ( ! isOK ) return null ; if ( separator . isSelected ( ) ) return new ContextOptionPane . MenuItem ( "-" , "-" ) ; else if ( action . isSelected ( ) ) return ( ContextOptionPane . MenuItem ) actionsList . getSelectedValue ( ) ; else if ( macro . isSelected ( ) ) { String selectedMacro = macrosList . getSelectedValue ( ) . toString ( ) ; selectedMacro = "play-macro@" + selectedMacro ; return new ContextOptionPane . MenuItem ( selectedMacro , ContextOptionPane . getActionLabel ( selectedMacro ) ) ; } else throw new InternalError ( ) ; } private boolean isOK ; private JRadioButton separator , action , macro ; private JList actionsList , macrosList ; private JButton ok , cancel ; class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source instanceof JRadioButton ) { actionsList . setEnabled ( action . isSelected ( ) ) ; macrosList . setEnabled ( macro . isSelected ( ) ) ; } if ( source == ok ) ok ( ) ; else if ( source == cancel ) cancel ( ) ; } } } 	1	['13', '6', '0', '13', '65', '46', '7', '9', '1', '0.785714286', '438', '1', '0', '0.982195846', '0.333333333', '2', '4', '32.15384615', '9', '2.2308', '1']
package bsh ; class BSHForStatement extends SimpleNode implements ParserConstants { public boolean hasForInit ; public boolean hasExpression ; public boolean hasForUpdate ; private SimpleNode forInit ; private SimpleNode expression ; private SimpleNode forUpdate ; private SimpleNode statement ; private boolean parsed ; BSHForStatement ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { int i = 0 ; if ( hasForInit ) forInit = ( ( SimpleNode ) jjtGetChild ( i ++ ) ) ; if ( hasExpression ) expression = ( ( SimpleNode ) jjtGetChild ( i ++ ) ) ; if ( hasForUpdate ) forUpdate = ( ( SimpleNode ) jjtGetChild ( i ++ ) ) ; if ( i < jjtGetNumChildren ( ) ) statement = ( ( SimpleNode ) jjtGetChild ( i ) ) ; NameSpace enclosingNameSpace = callstack . top ( ) ; BlockNameSpace forNameSpace = new BlockNameSpace ( enclosingNameSpace ) ; callstack . swap ( forNameSpace ) ; if ( hasForInit ) forInit . eval ( callstack , interpreter ) ; Object returnControl = Primitive . VOID ; while ( true ) { if ( hasExpression ) { boolean cond = BSHIfStatement . evaluateCondition ( expression , callstack , interpreter ) ; if ( ! cond ) break ; } boolean breakout = false ; if ( statement != null ) { Object ret = statement . eval ( callstack , interpreter ) ; if ( ret instanceof ReturnControl ) { switch ( ( ( ReturnControl ) ret ) . kind ) { case RETURN : returnControl = ret ; breakout = true ; break ; case CONTINUE : break ; case BREAK : breakout = true ; break ; } } } if ( breakout ) break ; if ( hasForUpdate ) forUpdate . eval ( callstack , interpreter ) ; } callstack . swap ( enclosingNameSpace ) ; return returnControl ; } } 	0	['2', '2', '0', '12', '10', '1', '1', '11', '1', '1.125', '137', '0.625', '4', '0.947368421', '0.625', '1', '1', '63.5', '1', '0.5', '0']
package org . gjt . sp . jedit . io ; import java . awt . Component ; import java . io . * ; import java . net . * ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class UrlVFS extends VFS { public UrlVFS ( ) { super ( "url" ) ; } public int getCapabilities ( ) { return READ_CAP | WRITE_CAP ; } public String constructPath ( String parent , String path ) { if ( parent . endsWith ( "/" ) ) return parent + path ; else return parent + '/' + path ; } public String getParentOfPath ( String path ) { return MiscUtilities . getParentOfPath ( path ) ; } public InputStream _createInputStream ( Object session , String path , boolean ignoreErrors , Component comp ) throws IOException { try { return new URL ( path ) . openStream ( ) ; } catch ( MalformedURLException mu ) { Log . log ( Log . ERROR , this , mu ) ; String [ ] args = { path , mu . getMessage ( ) } ; VFSManager . error ( comp , "badurl" , args ) ; return null ; } } public OutputStream _createOutputStream ( Object session , String path , Component comp ) throws IOException { try { return new URL ( path ) . openConnection ( ) . getOutputStream ( ) ; } catch ( MalformedURLException mu ) { Log . log ( Log . ERROR , this , mu ) ; String [ ] args = { path } ; VFSManager . error ( comp , "badurl" , args ) ; return null ; } } } 	1	['6', '2', '0', '4', '19', '15', '1', '4', '6', '2', '93', '0', '0', '0.807692308', '0.5', '1', '3', '14.5', '2', '1', '1']
package bsh ; class BSHVariableDeclarator extends SimpleNode { public String name ; BSHVariableDeclarator ( int id ) { super ( id ) ; } public Object eval ( BSHType typeNode , CallStack callstack , Interpreter interpreter ) throws EvalError { Object value = Primitive . VOID ; if ( jjtGetNumChildren ( ) > 0 ) { SimpleNode initializer = ( SimpleNode ) jjtGetChild ( 0 ) ; if ( ( typeNode != null ) && initializer instanceof BSHArrayInitializer ) value = ( ( BSHArrayInitializer ) initializer ) . eval ( typeNode . getBaseType ( ) , typeNode . getArrayDims ( ) , callstack , interpreter ) ; else value = initializer . eval ( callstack , interpreter ) ; } return value ; } } 	0	['2', '2', '0', '10', '9', '1', '2', '8', '1', '2', '40', '0', '0', '0.947368421', '0.6', '1', '2', '18.5', '1', '0.5', '0']
package org . gjt . sp . util ; public class WorkThread extends Thread { public WorkThread ( WorkThreadPool pool , ThreadGroup group , String name ) { super ( group , name ) ; setDaemon ( true ) ; setPriority ( 4 ) ; this . pool = pool ; } public void setAbortable ( boolean abortable ) { synchronized ( abortLock ) { this . abortable = abortable ; if ( aborted ) stop ( new Abort ( ) ) ; } } public boolean isRequestRunning ( ) { return requestRunning ; } public String getStatus ( ) { return status ; } public void setStatus ( String status ) { this . status = status ; pool . fireProgressChanged ( this ) ; } public int getProgressValue ( ) { return progressValue ; } public void setProgressValue ( int progressValue ) { this . progressValue = progressValue ; pool . fireProgressChanged ( this ) ; } public int getProgressMaximum ( ) { return progressMaximum ; } public void setProgressMaximum ( int progressMaximum ) { this . progressMaximum = progressMaximum ; pool . fireProgressChanged ( this ) ; } public void abortCurrentRequest ( ) { synchronized ( abortLock ) { if ( abortable && ! aborted ) stop ( new Abort ( ) ) ; aborted = true ; } } public void run ( ) { Log . log ( Log . DEBUG , this , "Work request thread starting [" + getName ( ) + "]" ) ; for ( ; ; ) { doRequests ( ) ; } } private WorkThreadPool pool ; private Object abortLock = new Object ( ) ; private boolean requestRunning ; private boolean abortable ; private boolean aborted ; private String status ; private int progressValue ; private int progressMaximum ; private void doRequests ( ) { WorkThreadPool . Request request ; for ( ; ; ) { request = pool . getNextRequest ( ) ; if ( request == null ) break ; else { requestRunning = true ; pool . fireProgressChanged ( this ) ; doRequest ( request ) ; requestRunning = false ; pool . fireProgressChanged ( this ) ; } } synchronized ( pool . waitForAllLock ) { pool . waitForAllLock . notifyAll ( ) ; } synchronized ( pool . lock ) { try { pool . lock . wait ( ) ; } catch ( InterruptedException ie ) { Log . log ( Log . ERROR , this , ie ) ; } } } private void doRequest ( WorkThreadPool . Request request ) { try { request . run . run ( ) ; } catch ( Abort a ) { Log . log ( Log . ERROR , WorkThread . class , "Unhandled abort" ) ; } catch ( Throwable t ) { Log . log ( Log . ERROR , WorkThread . class , "Exception " + "in work thread:" ) ; Log . log ( Log . ERROR , WorkThread . class , t ) ; } finally { synchronized ( abortLock ) { aborted = abortable = false ; } status = null ; progressValue = progressMaximum = 0 ; pool . requestDone ( ) ; pool . fireProgressChanged ( this ) ; } } public static class Abort extends Error { public Abort ( ) { super ( "Work request aborted" ) ; } } } 	1	['14', '2', '0', '8', '34', '37', '5', '4', '11', '0.760683761', '324', '1', '1', '0.824324324', '0.224489796', '0', '0', '21.5', '8', '1.7143', '1']
package org . gjt . sp . util ; import java . util . EventListener ; public interface WorkThreadProgressListener extends EventListener { void progressUpdate ( WorkThreadPool threadPool , int threadIndex ) ; } 	0	['1', '1', '0', '5', '1', '0', '5', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . gjt . sp . jedit . io ; import javax . swing . text . BadLocationException ; import javax . swing . text . Element ; import javax . swing . text . Segment ; import java . io . * ; import java . util . zip . * ; import java . util . Vector ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . * ; public class BufferIORequest extends WorkRequest { public static final int IOBUFSIZE = 32768 ; public static final int PROGRESS_INTERVAL = 300 ; public static final String LOAD_DATA = "IORequest__loadData" ; public static final int LOAD = 0 ; public static final int SAVE = 1 ; public static final int AUTOSAVE = 2 ; public static final int INSERT = 3 ; public BufferIORequest ( int type , View view , Buffer buffer , Object session , VFS vfs , String path ) { this . type = type ; this . view = view ; this . buffer = buffer ; this . session = session ; this . vfs = vfs ; this . path = path ; markersPath = vfs . getParentOfPath ( path ) + '.' + vfs . getFileName ( path ) + ".marks" ; } public void run ( ) { switch ( type ) { case LOAD : load ( ) ; break ; case SAVE : save ( ) ; break ; case AUTOSAVE : autosave ( ) ; break ; case INSERT : insert ( ) ; break ; } } public String toString ( ) { String typeString ; switch ( type ) { case LOAD : typeString = "LOAD" ; break ; case SAVE : typeString = "SAVE" ; break ; case AUTOSAVE : typeString = "AUTOSAVE" ; break ; default : typeString = "UNKNOWN!!!" ; } return getClass ( ) . getName ( ) + "[type=" + typeString + ",buffer=" + buffer + "]" ; } private int type ; private View view ; private Buffer buffer ; private Object session ; private VFS vfs ; private String path ; private String markersPath ; private void load ( ) { InputStream in = null ; try { try { String [ ] args = { vfs . getFileName ( path ) } ; setStatus ( jEdit . getProperty ( "vfs.status.load" , args ) ) ; setAbortable ( true ) ; setProgressValue ( 0 ) ; VFS . DirectoryEntry entry = vfs . _getDirectoryEntry ( session , path , view ) ; long length ; if ( entry != null ) length = entry . length ; else length = 0L ; in = vfs . _createInputStream ( session , path , false , view ) ; if ( in == null ) return ; if ( path . endsWith ( ".gz" ) ) in = new GZIPInputStream ( in ) ; String lineSeparator = read ( buffer , in , length ) ; buffer . putProperty ( Buffer . LINESEP , lineSeparator ) ; buffer . setNewFile ( false ) ; } catch ( CharConversionException ch ) { Log . log ( Log . ERROR , this , ch ) ; Object [ ] pp = { path , buffer . getProperty ( Buffer . ENCODING ) , ch . toString ( ) } ; VFSManager . error ( view , "encoding-error" , pp ) ; } catch ( IOException io ) { Log . log ( Log . ERROR , this , io ) ; Object [ ] pp = { path , io . toString ( ) } ; VFSManager . error ( view , "read-error" , pp ) ; } if ( jEdit . getBooleanProperty ( "persistentMarkers" ) ) { try { String [ ] args = { vfs . getFileName ( path ) } ; setStatus ( jEdit . getProperty ( "vfs.status.load-markers" , args ) ) ; setAbortable ( true ) ; in = vfs . _createInputStream ( session , markersPath , true , view ) ; if ( in != null ) readMarkers ( buffer , in ) ; } catch ( IOException io ) { } } } catch ( WorkThread . Abort a ) { if ( in != null ) { try { in . close ( ) ; } catch ( IOException io ) { } } } finally { try { vfs . _endVFSSession ( session , view ) ; } catch ( IOException io ) { Log . log ( Log . ERROR , this , io ) ; String [ ] pp = { path , io . toString ( ) } ; VFSManager . error ( view , "read-error" , pp ) ; } catch ( WorkThread . Abort a ) { } } } private String read ( Buffer buffer , InputStream _in , long length ) throws IOException { boolean trackProgress = ( length != 0 ) ; File file = buffer . getFile ( ) ; setProgressValue ( 0 ) ; setProgressMaximum ( ( int ) length ) ; if ( length == 0 ) length = IOBUFSIZE ; StringBuffer sbuf = new StringBuffer ( ( int ) length ) ; InputStreamReader in = new InputStreamReader ( _in , ( String ) buffer . getProperty ( Buffer . ENCODING ) ) ; char [ ] buf = new char [ IOBUFSIZE ] ; int len ; boolean CRLF = false ; boolean CROnly = false ; boolean lastWasCR = false ; int lineCount = 0 ; while ( ( len = in . read ( buf , 0 , buf . length ) ) != - 1 ) { int lastLine = 0 ; for ( int i = 0 ; i < len ; i ++ ) { switch ( buf [ i ] ) { case '\r' : if ( lastWasCR ) { CROnly = true ; CRLF = false ; } else { lastWasCR = true ; } sbuf . append ( buf , lastLine , i - lastLine ) ; sbuf . append ( '\n' ) ; if ( trackProgress && lineCount ++ % PROGRESS_INTERVAL == 0 ) setProgressValue ( sbuf . length ( ) ) ; lastLine = i + 1 ; break ; case '\n' : if ( lastWasCR ) { CROnly = false ; CRLF = true ; lastWasCR = false ; lastLine = i + 1 ; } else { CROnly = false ; CRLF = false ; sbuf . append ( buf , lastLine , i - lastLine ) ; sbuf . append ( '\n' ) ; if ( trackProgress && lineCount ++ % PROGRESS_INTERVAL == 0 ) setProgressValue ( sbuf . length ( ) ) ; lastLine = i + 1 ; } break ; default : if ( lastWasCR ) { CROnly = true ; CRLF = false ; lastWasCR = false ; } break ; } } if ( trackProgress ) setProgressValue ( sbuf . length ( ) ) ; sbuf . append ( buf , lastLine , len - lastLine ) ; } setAbortable ( false ) ; String returnValue ; if ( CRLF ) returnValue = "\r\n" ; else if ( CROnly ) returnValue = "\r" ; else returnValue = "\n" ; in . close ( ) ; int bufferLength = sbuf . length ( ) ; if ( bufferLength != 0 ) { char ch = sbuf . charAt ( bufferLength - 1 ) ; if ( length >= 2 && ch == 0x1a && sbuf . charAt ( bufferLength - 2 ) == '\n' ) sbuf . setLength ( bufferLength - 2 ) ; else if ( ch == '\n' ) sbuf . setLength ( bufferLength - 1 ) ; } buffer . putProperty ( LOAD_DATA , sbuf ) ; return returnValue ; } private void readMarkers ( Buffer buffer , InputStream _in ) throws IOException { buffer . removeAllMarkers ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( _in ) ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) { if ( ! line . startsWith ( "!" ) ) continue ; char shortcut = line . charAt ( 1 ) ; int start = line . indexOf ( ';' ) ; int end = line . indexOf ( ';' , start + 1 ) ; int position = Integer . parseInt ( line . substring ( start + 1 , end ) ) ; buffer . addMarker ( shortcut , position ) ; } in . close ( ) ; } private void save ( ) { OutputStream out = null ; try { String [ ] args = { vfs . getFileName ( path ) } ; setStatus ( jEdit . getProperty ( "vfs.status.save" , args ) ) ; setAbortable ( true ) ; try { buffer . readLock ( ) ; String savePath ; if ( ( vfs . getCapabilities ( ) & VFS . RENAME_CAP ) != 0 ) { savePath = vfs . getParentOfPath ( path ) + '#' + vfs . getFileName ( path ) + "#save#" ; } else savePath = path ; out = vfs . _createOutputStream ( session , savePath , view ) ; if ( out != null ) { if ( path . endsWith ( ".gz" ) ) out = new GZIPOutputStream ( out ) ; write ( buffer , out ) ; } if ( buffer . getProperty ( Buffer . BACKED_UP ) == null ) { vfs . _backup ( session , path , view ) ; buffer . putProperty ( Buffer . BACKED_UP , Boolean . TRUE ) ; } if ( ( vfs . getCapabilities ( ) & VFS . RENAME_CAP ) != 0 ) vfs . _rename ( session , savePath , path , view ) ; if ( ( vfs . getCapabilities ( ) & VFS . DELETE_CAP ) != 0 ) { if ( jEdit . getBooleanProperty ( "persistentMarkers" ) && buffer . getMarkers ( ) . size ( ) != 0 ) { setStatus ( jEdit . getProperty ( "vfs.status.save-markers" , args ) ) ; setProgressValue ( 0 ) ; out = vfs . _createOutputStream ( session , markersPath , view ) ; if ( out != null ) writeMarkers ( buffer , out ) ; } else vfs . _delete ( session , markersPath , view ) ; } } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } catch ( IOException io ) { Log . log ( Log . ERROR , this , io ) ; String [ ] pp = { path , io . toString ( ) } ; VFSManager . error ( view , "write-error" , pp ) ; } finally { buffer . readUnlock ( ) ; } } catch ( WorkThread . Abort a ) { if ( out != null ) { try { out . close ( ) ; } catch ( IOException io ) { } } } finally { try { vfs . _saveComplete ( session , buffer , view ) ; vfs . _endVFSSession ( session , view ) ; } catch ( IOException io ) { Log . log ( Log . ERROR , this , io ) ; String [ ] pp = { path , io . toString ( ) } ; VFSManager . error ( view , "write-error" , pp ) ; } catch ( WorkThread . Abort a ) { } } } private void autosave ( ) { OutputStream out = null ; try { String [ ] args = { vfs . getFileName ( path ) } ; setStatus ( jEdit . getProperty ( "vfs.status.autosave" , args ) ) ; setAbortable ( true ) ; try { buffer . readLock ( ) ; if ( ! buffer . isDirty ( ) ) { return ; } out = vfs . _createOutputStream ( session , path , view ) ; if ( out == null ) return ; write ( buffer , out ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } catch ( IOException io ) { } finally { buffer . readUnlock ( ) ; } } catch ( WorkThread . Abort a ) { if ( out != null ) { try { out . close ( ) ; } catch ( IOException io ) { } } } } private void write ( Buffer buffer , OutputStream _out ) throws IOException , BadLocationException { BufferedWriter out = new BufferedWriter ( new OutputStreamWriter ( _out , ( String ) buffer . getProperty ( Buffer . ENCODING ) ) , IOBUFSIZE ) ; Segment lineSegment = new Segment ( ) ; String newline = ( String ) buffer . getProperty ( Buffer . LINESEP ) ; if ( newline == null ) newline = System . getProperty ( "line.separator" ) ; Element map = buffer . getDefaultRootElement ( ) ; setProgressMaximum ( map . getElementCount ( ) / PROGRESS_INTERVAL ) ; setProgressValue ( 0 ) ; int i = 0 ; while ( i < map . getElementCount ( ) ) { Element line = map . getElement ( i ) ; int start = line . getStartOffset ( ) ; buffer . getText ( start , line . getEndOffset ( ) - start - 1 , lineSegment ) ; out . write ( lineSegment . array , lineSegment . offset , lineSegment . count ) ; out . write ( newline ) ; if ( ++ i % PROGRESS_INTERVAL == 0 ) setProgressValue ( i / PROGRESS_INTERVAL ) ; } out . close ( ) ; } private void writeMarkers ( Buffer buffer , OutputStream out ) throws IOException { Writer o = new BufferedWriter ( new OutputStreamWriter ( out ) ) ; Vector markers = buffer . getMarkers ( ) ; for ( int i = 0 ; i < markers . size ( ) ; i ++ ) { Marker marker = ( Marker ) markers . elementAt ( i ) ; o . write ( '!' ) ; o . write ( marker . getShortcut ( ) ) ; o . write ( ';' ) ; String pos = String . valueOf ( marker . getPosition ( ) ) ; o . write ( pos ) ; o . write ( ';' ) ; o . write ( pos ) ; o . write ( '\n' ) ; } o . close ( ) ; } private void insert ( ) { InputStream in = null ; try { try { String [ ] args = { vfs . getFileName ( path ) } ; setStatus ( jEdit . getProperty ( "vfs.status.load" , args ) ) ; setAbortable ( true ) ; VFS . DirectoryEntry entry = vfs . _getDirectoryEntry ( session , path , view ) ; long length ; if ( entry != null ) length = entry . length ; else length = 0L ; in = vfs . _createInputStream ( session , path , false , view ) ; if ( in == null ) return ; if ( path . endsWith ( ".gz" ) ) in = new GZIPInputStream ( in ) ; read ( buffer , in , length ) ; } catch ( IOException io ) { Log . log ( Log . ERROR , this , io ) ; String [ ] pp = { path , io . toString ( ) } ; VFSManager . error ( view , "read-error" , pp ) ; } } catch ( WorkThread . Abort a ) { if ( in != null ) { try { in . close ( ) ; } catch ( IOException io ) { } } } finally { try { vfs . _endVFSSession ( session , view ) ; } catch ( IOException io ) { Log . log ( Log . ERROR , this , io ) ; String [ ] pp = { path , io . toString ( ) } ; VFSManager . error ( view , "read-error" , pp ) ; } catch ( WorkThread . Abort a ) { } } } } 	1	['11', '2', '0', '10', '96', '21', '2', '10', '3', '0.828571429', '1272', '0.5', '3', '0.333333333', '0.236363636', '0', '0', '113.3636364', '17', '4.9091', '9']
package org . gjt . sp . jedit . msg ; import org . gjt . sp . jedit . * ; public class BufferUpdate extends EBMessage . NonVetoable { public static final Object CREATED = "CREATED" ; public static final Object LOAD_STARTED = "LOAD_STARTED" ; public static final Object LOADED = "LOADED" ; public static final Object CLOSED = "CLOSED" ; public static final Object DIRTY_CHANGED = "DIRTY_CHANGED" ; public static final Object MARKERS_CHANGED = "MARKERS_CHANGED" ; public static final Object MODE_CHANGED = "MODE_CHANGED" ; public static final Object ENCODING_CHANGED = "ENCODING_CHANGED" ; public static final Object SAVING = "SAVING" ; public BufferUpdate ( Buffer buffer , View view , Object what ) { super ( buffer ) ; this . view = view ; if ( what == null ) throw new NullPointerException ( "What must be non-null" ) ; this . what = what ; } public Object getWhat ( ) { return what ; } public Buffer getBuffer ( ) { return ( Buffer ) getSource ( ) ; } public View getView ( ) { return view ; } public String paramString ( ) { return super . paramString ( ) + ",what=" + what + ",view=" + view ; } private Object what ; private View view ; } 	0	['6', '3', '0', '14', '14', '5', '11', '5', '5', '0.927272727', '81', '0.181818182', '1', '0.6', '0.4', '1', '1', '10.66666667', '1', '0.6667', '0']
package org . gjt . sp . jedit . textarea ; import javax . swing . text . * ; import org . gjt . sp . jedit . Buffer ; public abstract class Selection { public int getStart ( ) { return start ; } public int getEnd ( ) { return end ; } public int getStartLine ( ) { return startLine ; } public int getEndLine ( ) { return endLine ; } public abstract int getStart ( Buffer buffer , int line ) ; public abstract int getEnd ( Buffer buffer , int line ) ; public String toString ( ) { return getClass ( ) . getName ( ) + "[start=" + start + ",end=" + end + ",startLine=" + startLine + ",endLine=" + endLine + "]" ; } int start , end , startLine , endLine ; protected Selection ( ) { } protected Selection ( Selection copy ) { start = copy . start ; end = copy . end ; } protected Selection ( int start , int end ) { this . start = start ; this . end = end ; } public static class Range extends Selection { public Range ( ) { super ( ) ; } public Range ( Selection sel ) { super ( sel ) ; } public Range ( int start , int end ) { super ( start , end ) ; } public int getStart ( Buffer buffer , int line ) { if ( line == startLine ) return start ; else { Element map = buffer . getDefaultRootElement ( ) ; Element lineElement = map . getElement ( line ) ; return lineElement . getStartOffset ( ) ; } } public int getEnd ( Buffer buffer , int line ) { if ( line == endLine ) return end ; else { Element map = buffer . getDefaultRootElement ( ) ; Element lineElement = map . getElement ( line ) ; return lineElement . getEndOffset ( ) - 1 ; } } } public static class Rect extends Selection { public Rect ( ) { super ( ) ; } public Rect ( Selection sel ) { super ( sel ) ; } public Rect ( int start , int end ) { super ( start , end ) ; } public int getStart ( Buffer buffer , int line ) { if ( line == startLine ) return start ; else { Element map = buffer . getDefaultRootElement ( ) ; int _start = start - map . getElement ( startLine ) . getStartOffset ( ) ; int _end = end - map . getElement ( endLine ) . getStartOffset ( ) ; Element lineElement = map . getElement ( line ) ; return Math . min ( lineElement . getEndOffset ( ) - 1 , lineElement . getStartOffset ( ) + Math . min ( _start , _end ) ) ; } } public int getEnd ( Buffer buffer , int line ) { if ( line == endLine ) return end ; else { Element map = buffer . getDefaultRootElement ( ) ; int _start = start - map . getElement ( startLine ) . getStartOffset ( ) ; int _end = end - map . getElement ( endLine ) . getStartOffset ( ) ; Element lineElement = map . getElement ( line ) ; return Math . min ( lineElement . getEndOffset ( ) - 1 , lineElement . getStartOffset ( ) + Math . max ( _start , _end ) ) ; } } } } 	1	['10', '1', '2', '15', '17', '23', '14', '1', '7', '0.777777778', '80', '0', '0', '0', '0.4', '0', '0', '6.6', '1', '0.7', '1']
package org . gjt . sp . jedit . search ; import org . gjt . sp . jedit . * ; public interface SearchFileSet { Buffer getFirstBuffer ( View view ) ; Buffer getNextBuffer ( View view , Buffer buffer ) ; void matchFound ( Buffer buffer ) ; int getBufferCount ( ) ; String getCode ( ) ; } 	0	['5', '1', '0', '9', '5', '10', '7', '2', '5', '2', '5', '0', '0', '0', '0.6', '0', '0', '0', '1', '1', '0']
package org . gjt . sp . jedit . syntax ; public class Token { public static final byte NULL = 0 ; public static final byte COMMENT1 = 1 ; public static final byte COMMENT2 = 2 ; public static final byte LITERAL1 = 3 ; public static final byte LITERAL2 = 4 ; public static final byte LABEL = 5 ; public static final byte KEYWORD1 = 6 ; public static final byte KEYWORD2 = 7 ; public static final byte KEYWORD3 = 8 ; public static final byte FUNCTION = 9 ; public static final byte MARKUP = 10 ; public static final byte OPERATOR = 11 ; public static final byte DIGIT = 12 ; public static final byte INVALID = 13 ; public static final byte ID_COUNT = 14 ; public static final byte END = 127 ; public int length ; public byte id ; public Token prev ; public Token next ; public Token ( int length , byte id ) { this . length = length ; this . id = id ; } public String toString ( ) { return "[id=" + id + ",length=" + length + "]" ; } } 	1	['2', '1', '0', '4', '7', '0', '4', '0', '2', '1.8', '48', '0', '2', '0', '0.666666667', '0', '0', '13', '1', '0.5', '1']
package bsh ; import java . io . Reader ; class Parser implements ParserTreeConstants , ParserConstants { protected JJTParserState jjtree = new JJTParserState ( ) ; void jjtreeOpenNodeScope ( Node n ) { ( ( SimpleNode ) n ) . firstToken = getToken ( 1 ) ; } void jjtreeCloseNodeScope ( Node n ) { ( ( SimpleNode ) n ) . lastToken = getToken ( 0 ) ; } void reInitInput ( Reader in ) { ReInit ( in ) ; } void reInitTokenInput ( Reader in ) { jj_input_stream . ReInit ( in , jj_input_stream . getEndLine ( ) , jj_input_stream . getEndColumn ( ) ) ; } final public boolean Line ( ) throws ParseException { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case 0 : jj_consume_token ( 0 ) ; Interpreter . debug ( "End of File!" ) ; { if ( true ) return true ; } break ; case BOOLEAN : case BREAK : case BYTE : case CHAR : case CONTINUE : case DO : case DOUBLE : case FALSE : case FINAL : case FLOAT : case FOR : case IF : case IMPORT : case INT : case LONG : case NEW : case NULL : case RETURN : case SHORT : case SWITCH : case THROW : case TRUE : case TRY : case VOID : case WHILE : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case LBRACE : case SEMICOLON : case BANG : case TILDE : case INCR : case DECR : case PLUS : case MINUS : if ( jj_2_1 ( 2147483647 ) ) { Expression ( ) ; jj_consume_token ( SEMICOLON ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BREAK : case BYTE : case CHAR : case CONTINUE : case DO : case DOUBLE : case FALSE : case FINAL : case FLOAT : case FOR : case IF : case IMPORT : case INT : case LONG : case NEW : case NULL : case RETURN : case SHORT : case SWITCH : case THROW : case TRUE : case TRY : case VOID : case WHILE : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case LBRACE : case SEMICOLON : case INCR : case DECR : BlockStatement ( ) ; break ; default : jj_la1 [ 0 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } { if ( true ) return false ; } break ; default : jj_la1 [ 1 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } throw new Error ( "Missing return statement in function" ) ; } final public void MethodDeclaration ( ) throws ParseException { BSHMethodDeclaration jjtn000 = new BSHMethodDeclaration ( JJTMETHODDECLARATION ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; Token t = null ; try { if ( jj_2_2 ( 2147483647 ) ) { ReturnType ( ) ; t = jj_consume_token ( IDENTIFIER ) ; jjtn000 . name = t . image ; FormalParameters ( ) ; Block ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : t = jj_consume_token ( IDENTIFIER ) ; jjtn000 . name = t . image ; FormalParameters ( ) ; Block ( ) ; break ; default : jj_la1 [ 2 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void MethodDeclarationLookahead ( ) throws ParseException { if ( jj_2_3 ( 2147483647 ) ) { ReturnType ( ) ; jj_consume_token ( IDENTIFIER ) ; FormalParameters ( ) ; jj_consume_token ( LBRACE ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : jj_consume_token ( IDENTIFIER ) ; FormalParameters ( ) ; jj_consume_token ( LBRACE ) ; break ; default : jj_la1 [ 3 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void MethodDeclarationTypeLookahead ( ) throws ParseException { ReturnType ( ) ; jj_consume_token ( IDENTIFIER ) ; jj_consume_token ( LPAREN ) ; } final public void ImportDeclaration ( ) throws ParseException { BSHImportDeclaration jjtn000 = new BSHImportDeclaration ( JJTIMPORTDECLARATION ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; Token t = null ; try { if ( jj_2_4 ( 2 ) ) { jj_consume_token ( IMPORT ) ; AmbiguousName ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case DOT : t = jj_consume_token ( DOT ) ; jj_consume_token ( STAR ) ; break ; default : jj_la1 [ 4 ] = jj_gen ; ; } jj_consume_token ( SEMICOLON ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; if ( t != null ) jjtn000 . importPackage = true ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IMPORT : jj_consume_token ( IMPORT ) ; jj_consume_token ( STAR ) ; jj_consume_token ( SEMICOLON ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . superImport = true ; break ; default : jj_la1 [ 5 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void VariableDeclarator ( ) throws ParseException { BSHVariableDeclarator jjtn000 = new BSHVariableDeclarator ( JJTVARIABLEDECLARATOR ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; Token t ; try { t = jj_consume_token ( IDENTIFIER ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case ASSIGN : jj_consume_token ( ASSIGN ) ; VariableInitializer ( ) ; break ; default : jj_la1 [ 6 ] = jj_gen ; ; } jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . name = t . image ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void VariableInitializer ( ) throws ParseException { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACE : ArrayInitializer ( ) ; break ; case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case BANG : case TILDE : case INCR : case DECR : case PLUS : case MINUS : Expression ( ) ; break ; default : jj_la1 [ 7 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } final public void ArrayInitializer ( ) throws ParseException { BSHArrayInitializer jjtn000 = new BSHArrayInitializer ( JJTARRAYINITIALIZER ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( LBRACE ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case LBRACE : case BANG : case TILDE : case INCR : case DECR : case PLUS : case MINUS : VariableInitializer ( ) ; label_1 : while ( true ) { if ( jj_2_5 ( 2 ) ) { ; } else { break label_1 ; } jj_consume_token ( COMMA ) ; VariableInitializer ( ) ; } break ; default : jj_la1 [ 8 ] = jj_gen ; ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case COMMA : jj_consume_token ( COMMA ) ; break ; default : jj_la1 [ 9 ] = jj_gen ; ; } jj_consume_token ( RBRACE ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void FormalParameters ( ) throws ParseException { BSHFormalParameters jjtn000 = new BSHFormalParameters ( JJTFORMALPARAMETERS ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( LPAREN ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FLOAT : case INT : case LONG : case SHORT : case IDENTIFIER : FormalParameter ( ) ; label_2 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case COMMA : ; break ; default : jj_la1 [ 10 ] = jj_gen ; break label_2 ; } jj_consume_token ( COMMA ) ; FormalParameter ( ) ; } break ; default : jj_la1 [ 11 ] = jj_gen ; ; } jj_consume_token ( RPAREN ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void FormalParameter ( ) throws ParseException { BSHFormalParameter jjtn000 = new BSHFormalParameter ( JJTFORMALPARAMETER ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; Token t ; try { if ( jj_2_6 ( 2 ) ) { Type ( ) ; t = jj_consume_token ( IDENTIFIER ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . name = t . image ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : t = jj_consume_token ( IDENTIFIER ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . name = t . image ; break ; default : jj_la1 [ 12 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void Type ( ) throws ParseException { BSHType jjtn000 = new BSHType ( JJTTYPE ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FLOAT : case INT : case LONG : case SHORT : PrimitiveType ( ) ; break ; case IDENTIFIER : AmbiguousName ( ) ; break ; default : jj_la1 [ 13 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } label_3 : while ( true ) { if ( jj_2_7 ( 2 ) ) { ; } else { break label_3 ; } jj_consume_token ( LBRACKET ) ; jj_consume_token ( RBRACKET ) ; jjtn000 . addArrayDimension ( ) ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void ReturnType ( ) throws ParseException { BSHReturnType jjtn000 = new BSHReturnType ( JJTRETURNTYPE ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case VOID : jj_consume_token ( VOID ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . isVoid = true ; break ; case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FLOAT : case INT : case LONG : case SHORT : case IDENTIFIER : Type ( ) ; break ; default : jj_la1 [ 14 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void PrimitiveType ( ) throws ParseException { BSHPrimitiveType jjtn000 = new BSHPrimitiveType ( JJTPRIMITIVETYPE ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : jj_consume_token ( BOOLEAN ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . type = Boolean . TYPE ; break ; case CHAR : jj_consume_token ( CHAR ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . type = Character . TYPE ; break ; case BYTE : jj_consume_token ( BYTE ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . type = Byte . TYPE ; break ; case SHORT : jj_consume_token ( SHORT ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . type = Short . TYPE ; break ; case INT : jj_consume_token ( INT ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . type = Integer . TYPE ; break ; case LONG : jj_consume_token ( LONG ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . type = Long . TYPE ; break ; case FLOAT : jj_consume_token ( FLOAT ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . type = Float . TYPE ; break ; case DOUBLE : jj_consume_token ( DOUBLE ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . type = Double . TYPE ; break ; default : jj_la1 [ 15 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void AmbiguousName ( ) throws ParseException { BSHAmbiguousName jjtn000 = new BSHAmbiguousName ( JJTAMBIGUOUSNAME ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; Token t ; StringBuffer s ; try { t = jj_consume_token ( IDENTIFIER ) ; s = new StringBuffer ( t . image ) ; label_4 : while ( true ) { if ( jj_2_8 ( 2 ) ) { ; } else { break label_4 ; } jj_consume_token ( DOT ) ; t = jj_consume_token ( IDENTIFIER ) ; s . append ( "." + t . image ) ; } jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . text = s . toString ( ) ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void Expression ( ) throws ParseException { if ( jj_2_9 ( 2147483647 ) ) { Assignment ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case BANG : case TILDE : case INCR : case DECR : case PLUS : case MINUS : ConditionalExpression ( ) ; break ; default : jj_la1 [ 16 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void Assignment ( ) throws ParseException { BSHAssignment jjtn000 = new BSHAssignment ( JJTASSIGNMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; int op ; try { LHSPrimaryExpression ( ) ; op = AssignmentOperator ( ) ; jjtn000 . operator = op ; Expression ( ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public int AssignmentOperator ( ) throws ParseException { Token t ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case ASSIGN : jj_consume_token ( ASSIGN ) ; break ; case STARASSIGN : jj_consume_token ( STARASSIGN ) ; break ; case SLASHASSIGN : jj_consume_token ( SLASHASSIGN ) ; break ; case MODASSIGN : jj_consume_token ( MODASSIGN ) ; break ; case PLUSASSIGN : jj_consume_token ( PLUSASSIGN ) ; break ; case MINUSASSIGN : jj_consume_token ( MINUSASSIGN ) ; break ; case ANDASSIGN : jj_consume_token ( ANDASSIGN ) ; break ; case XORASSIGN : jj_consume_token ( XORASSIGN ) ; break ; case ORASSIGN : jj_consume_token ( ORASSIGN ) ; break ; case LSHIFTASSIGN : jj_consume_token ( LSHIFTASSIGN ) ; break ; case LSHIFTASSIGNX : jj_consume_token ( LSHIFTASSIGNX ) ; break ; case RSIGNEDSHIFTASSIGN : jj_consume_token ( RSIGNEDSHIFTASSIGN ) ; break ; case RSIGNEDSHIFTASSIGNX : jj_consume_token ( RSIGNEDSHIFTASSIGNX ) ; break ; case RUNSIGNEDSHIFTASSIGN : jj_consume_token ( RUNSIGNEDSHIFTASSIGN ) ; break ; case RUNSIGNEDSHIFTASSIGNX : jj_consume_token ( RUNSIGNEDSHIFTASSIGNX ) ; break ; default : jj_la1 [ 17 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } t = getToken ( 0 ) ; { if ( true ) return t . kind ; } throw new Error ( "Missing return statement in function" ) ; } final public void ConditionalExpression ( ) throws ParseException { ConditionalOrExpression ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case HOOK : jj_consume_token ( HOOK ) ; Expression ( ) ; jj_consume_token ( COLON ) ; BSHTernaryExpression jjtn001 = new BSHTernaryExpression ( JJTTERNARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { ConditionalExpression ( ) ; } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 3 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } break ; default : jj_la1 [ 18 ] = jj_gen ; ; } } final public void ConditionalOrExpression ( ) throws ParseException { Token t = null ; ConditionalAndExpression ( ) ; label_5 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOL_OR : case BOOL_ORX : ; break ; default : jj_la1 [ 19 ] = jj_gen ; break label_5 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOL_OR : t = jj_consume_token ( BOOL_OR ) ; break ; case BOOL_ORX : t = jj_consume_token ( BOOL_ORX ) ; break ; default : jj_la1 [ 20 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } ConditionalAndExpression ( ) ; BSHBinaryExpression jjtn001 = new BSHBinaryExpression ( JJTBINARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } } final public void ConditionalAndExpression ( ) throws ParseException { Token t = null ; InclusiveOrExpression ( ) ; label_6 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOL_AND : case BOOL_ANDX : ; break ; default : jj_la1 [ 21 ] = jj_gen ; break label_6 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOL_AND : t = jj_consume_token ( BOOL_AND ) ; break ; case BOOL_ANDX : t = jj_consume_token ( BOOL_ANDX ) ; break ; default : jj_la1 [ 22 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } InclusiveOrExpression ( ) ; BSHBinaryExpression jjtn001 = new BSHBinaryExpression ( JJTBINARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } } final public void InclusiveOrExpression ( ) throws ParseException { Token t = null ; ExclusiveOrExpression ( ) ; label_7 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BIT_OR : case BIT_ORX : ; break ; default : jj_la1 [ 23 ] = jj_gen ; break label_7 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BIT_OR : t = jj_consume_token ( BIT_OR ) ; break ; case BIT_ORX : t = jj_consume_token ( BIT_ORX ) ; break ; default : jj_la1 [ 24 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } ExclusiveOrExpression ( ) ; BSHBinaryExpression jjtn001 = new BSHBinaryExpression ( JJTBINARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } } final public void ExclusiveOrExpression ( ) throws ParseException { Token t = null ; AndExpression ( ) ; label_8 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case XOR : ; break ; default : jj_la1 [ 25 ] = jj_gen ; break label_8 ; } t = jj_consume_token ( XOR ) ; AndExpression ( ) ; BSHBinaryExpression jjtn001 = new BSHBinaryExpression ( JJTBINARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } } final public void AndExpression ( ) throws ParseException { Token t = null ; EqualityExpression ( ) ; label_9 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BIT_AND : case BIT_ANDX : ; break ; default : jj_la1 [ 26 ] = jj_gen ; break label_9 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BIT_AND : t = jj_consume_token ( BIT_AND ) ; break ; case BIT_ANDX : t = jj_consume_token ( BIT_ANDX ) ; break ; default : jj_la1 [ 27 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } EqualityExpression ( ) ; BSHBinaryExpression jjtn001 = new BSHBinaryExpression ( JJTBINARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } } final public void EqualityExpression ( ) throws ParseException { Token t = null ; InstanceOfExpression ( ) ; label_10 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case EQ : case NE : ; break ; default : jj_la1 [ 28 ] = jj_gen ; break label_10 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case EQ : t = jj_consume_token ( EQ ) ; break ; case NE : t = jj_consume_token ( NE ) ; break ; default : jj_la1 [ 29 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } InstanceOfExpression ( ) ; BSHBinaryExpression jjtn001 = new BSHBinaryExpression ( JJTBINARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } } final public void InstanceOfExpression ( ) throws ParseException { Token t = null ; RelationalExpression ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case INSTANCEOF : t = jj_consume_token ( INSTANCEOF ) ; Type ( ) ; BSHBinaryExpression jjtn001 = new BSHBinaryExpression ( JJTBINARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } break ; default : jj_la1 [ 30 ] = jj_gen ; ; } } final public void RelationalExpression ( ) throws ParseException { Token t = null ; ShiftExpression ( ) ; label_11 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case GT : case GTX : case LT : case LTX : case LE : case LEX : case GE : case GEX : ; break ; default : jj_la1 [ 31 ] = jj_gen ; break label_11 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LT : t = jj_consume_token ( LT ) ; break ; case LTX : t = jj_consume_token ( LTX ) ; break ; case GT : t = jj_consume_token ( GT ) ; break ; case GTX : t = jj_consume_token ( GTX ) ; break ; case LE : t = jj_consume_token ( LE ) ; break ; case LEX : t = jj_consume_token ( LEX ) ; break ; case GE : t = jj_consume_token ( GE ) ; break ; case GEX : t = jj_consume_token ( GEX ) ; break ; default : jj_la1 [ 32 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } ShiftExpression ( ) ; BSHBinaryExpression jjtn001 = new BSHBinaryExpression ( JJTBINARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } } final public void ShiftExpression ( ) throws ParseException { Token t = null ; AdditiveExpression ( ) ; label_12 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LSHIFT : case LSHIFTX : case RSIGNEDSHIFT : case RSIGNEDSHIFTX : case RUNSIGNEDSHIFT : case RUNSIGNEDSHIFTX : ; break ; default : jj_la1 [ 33 ] = jj_gen ; break label_12 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LSHIFT : t = jj_consume_token ( LSHIFT ) ; break ; case LSHIFTX : t = jj_consume_token ( LSHIFTX ) ; break ; case RSIGNEDSHIFT : t = jj_consume_token ( RSIGNEDSHIFT ) ; break ; case RSIGNEDSHIFTX : t = jj_consume_token ( RSIGNEDSHIFTX ) ; break ; case RUNSIGNEDSHIFT : t = jj_consume_token ( RUNSIGNEDSHIFT ) ; break ; case RUNSIGNEDSHIFTX : t = jj_consume_token ( RUNSIGNEDSHIFTX ) ; break ; default : jj_la1 [ 34 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } AdditiveExpression ( ) ; BSHBinaryExpression jjtn001 = new BSHBinaryExpression ( JJTBINARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } } final public void AdditiveExpression ( ) throws ParseException { Token t = null ; MultiplicativeExpression ( ) ; label_13 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case PLUS : case MINUS : ; break ; default : jj_la1 [ 35 ] = jj_gen ; break label_13 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case PLUS : t = jj_consume_token ( PLUS ) ; break ; case MINUS : t = jj_consume_token ( MINUS ) ; break ; default : jj_la1 [ 36 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } MultiplicativeExpression ( ) ; BSHBinaryExpression jjtn001 = new BSHBinaryExpression ( JJTBINARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } } final public void MultiplicativeExpression ( ) throws ParseException { Token t = null ; UnaryExpression ( ) ; label_14 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case STAR : case SLASH : case MOD : ; break ; default : jj_la1 [ 37 ] = jj_gen ; break label_14 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case STAR : t = jj_consume_token ( STAR ) ; break ; case SLASH : t = jj_consume_token ( SLASH ) ; break ; case MOD : t = jj_consume_token ( MOD ) ; break ; default : jj_la1 [ 38 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } UnaryExpression ( ) ; BSHBinaryExpression jjtn001 = new BSHBinaryExpression ( JJTBINARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } } final public void UnaryExpression ( ) throws ParseException { Token t = null ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case PLUS : case MINUS : switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case PLUS : t = jj_consume_token ( PLUS ) ; break ; case MINUS : t = jj_consume_token ( MINUS ) ; break ; default : jj_la1 [ 39 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } UnaryExpression ( ) ; BSHUnaryExpression jjtn001 = new BSHUnaryExpression ( JJTUNARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 1 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 1 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } break ; case INCR : PreIncrementExpression ( ) ; break ; case DECR : PreDecrementExpression ( ) ; break ; case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case BANG : case TILDE : UnaryExpressionNotPlusMinus ( ) ; break ; default : jj_la1 [ 40 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } final public void PreIncrementExpression ( ) throws ParseException { Token t = null ; t = jj_consume_token ( INCR ) ; LHSPrimaryExpression ( ) ; BSHUnaryExpression jjtn001 = new BSHUnaryExpression ( JJTUNARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 1 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 1 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } final public void PreDecrementExpression ( ) throws ParseException { Token t = null ; t = jj_consume_token ( DECR ) ; LHSPrimaryExpression ( ) ; BSHUnaryExpression jjtn001 = new BSHUnaryExpression ( JJTUNARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 1 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 1 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } final public void UnaryExpressionNotPlusMinus ( ) throws ParseException { Token t = null ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BANG : case TILDE : switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case TILDE : t = jj_consume_token ( TILDE ) ; break ; case BANG : t = jj_consume_token ( BANG ) ; break ; default : jj_la1 [ 41 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } UnaryExpression ( ) ; BSHUnaryExpression jjtn001 = new BSHUnaryExpression ( JJTUNARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 1 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 1 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } break ; default : jj_la1 [ 42 ] = jj_gen ; if ( jj_2_10 ( 2147483647 ) ) { CastExpression ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : PostfixExpression ( ) ; break ; default : jj_la1 [ 43 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } } final public void CastLookahead ( ) throws ParseException { if ( jj_2_11 ( 2 ) ) { jj_consume_token ( LPAREN ) ; PrimitiveType ( ) ; } else if ( jj_2_12 ( 2147483647 ) ) { jj_consume_token ( LPAREN ) ; AmbiguousName ( ) ; jj_consume_token ( LBRACKET ) ; jj_consume_token ( RBRACKET ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LPAREN : jj_consume_token ( LPAREN ) ; AmbiguousName ( ) ; jj_consume_token ( RPAREN ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case TILDE : jj_consume_token ( TILDE ) ; break ; case BANG : jj_consume_token ( BANG ) ; break ; case LPAREN : jj_consume_token ( LPAREN ) ; break ; case IDENTIFIER : jj_consume_token ( IDENTIFIER ) ; break ; case NEW : jj_consume_token ( NEW ) ; break ; case FALSE : case NULL : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : Literal ( ) ; break ; default : jj_la1 [ 44 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } break ; default : jj_la1 [ 45 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void PostfixExpression ( ) throws ParseException { Token t = null ; if ( jj_2_13 ( 2147483647 ) ) { LHSPrimaryExpression ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case INCR : case DECR : switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case INCR : t = jj_consume_token ( INCR ) ; break ; case DECR : t = jj_consume_token ( DECR ) ; break ; default : jj_la1 [ 46 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } BSHUnaryExpression jjtn001 = new BSHUnaryExpression ( JJTUNARYEXPRESSION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { jjtree . closeNodeScope ( jjtn001 , 1 ) ; jjtc001 = false ; jjtreeCloseNodeScope ( jjtn001 ) ; jjtn001 . kind = t . kind ; jjtn001 . postfix = true ; } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 1 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } break ; default : jj_la1 [ 47 ] = jj_gen ; ; } } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : PrimaryExpression ( ) ; break ; default : jj_la1 [ 48 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void CastExpression ( ) throws ParseException { BSHCastExpression jjtn000 = new BSHCastExpression ( JJTCASTEXPRESSION ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { if ( jj_2_14 ( 2147483647 ) ) { jj_consume_token ( LPAREN ) ; Type ( ) ; jj_consume_token ( RPAREN ) ; UnaryExpression ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LPAREN : jj_consume_token ( LPAREN ) ; Type ( ) ; jj_consume_token ( RPAREN ) ; UnaryExpressionNotPlusMinus ( ) ; break ; default : jj_la1 [ 49 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void PrimaryExpression ( ) throws ParseException { BSHPrimaryExpression jjtn000 = new BSHPrimaryExpression ( JJTPRIMARYEXPRESSION ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { PrimaryPrefix ( ) ; label_15 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACE : case LBRACKET : case DOT : ; break ; default : jj_la1 [ 50 ] = jj_gen ; break label_15 ; } PrimarySuffix ( ) ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void PrimaryPrefix ( ) throws ParseException { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case FALSE : case NULL : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : Literal ( ) ; break ; case LPAREN : jj_consume_token ( LPAREN ) ; Expression ( ) ; jj_consume_token ( RPAREN ) ; break ; case NEW : AllocationExpression ( ) ; break ; default : jj_la1 [ 52 ] = jj_gen ; if ( jj_2_15 ( 2147483647 ) ) { Type ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : BSHMethodInvocation jjtn001 = new BSHMethodInvocation ( JJTMETHODINVOCATION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { AmbiguousName ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LPAREN : Arguments ( ) ; break ; default : jj_la1 [ 51 ] = jj_gen ; ; } } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , jjtree . nodeArity ( ) > 1 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } break ; default : jj_la1 [ 53 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } } final public void PrimarySuffix ( ) throws ParseException { BSHPrimarySuffix jjtn000 = new BSHPrimarySuffix ( JJTPRIMARYSUFFIX ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; Token t = null ; try { if ( jj_2_16 ( 2 ) ) { jj_consume_token ( DOT ) ; jj_consume_token ( CLASS ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . operation = BSHPrimarySuffix . CLASS ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACKET : jj_consume_token ( LBRACKET ) ; Expression ( ) ; jj_consume_token ( RBRACKET ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . operation = BSHPrimarySuffix . INDEX ; break ; case DOT : jj_consume_token ( DOT ) ; t = jj_consume_token ( IDENTIFIER ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LPAREN : Arguments ( ) ; break ; default : jj_la1 [ 54 ] = jj_gen ; ; } jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . operation = BSHPrimarySuffix . NAME ; jjtn000 . field = t . image ; break ; case LBRACE : jj_consume_token ( LBRACE ) ; Expression ( ) ; jj_consume_token ( RBRACE ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . operation = BSHPrimarySuffix . PROPERTY ; break ; default : jj_la1 [ 55 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void LHSPrimaryPrefix ( ) throws ParseException { BSHMethodInvocation jjtn001 = new BSHMethodInvocation ( JJTMETHODINVOCATION ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; jjtreeOpenNodeScope ( jjtn001 ) ; try { AmbiguousName ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LPAREN : Arguments ( ) ; break ; default : jj_la1 [ 56 ] = jj_gen ; ; } } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , jjtree . nodeArity ( ) > 1 ) ; jjtreeCloseNodeScope ( jjtn001 ) ; } } } final public void LHSPrimaryExpression ( ) throws ParseException { BSHLHSPrimaryExpression jjtn000 = new BSHLHSPrimaryExpression ( JJTLHSPRIMARYEXPRESSION ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { LHSPrimaryPrefix ( ) ; label_16 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACE : case LBRACKET : case DOT : ; break ; default : jj_la1 [ 57 ] = jj_gen ; break label_16 ; } LHSPrimarySuffix ( ) ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void LHSPrimarySuffix ( ) throws ParseException { BSHLHSPrimarySuffix jjtn000 = new BSHLHSPrimarySuffix ( JJTLHSPRIMARYSUFFIX ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; Token t = null , t1 , t2 = null ; try { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACKET : jj_consume_token ( LBRACKET ) ; Expression ( ) ; jj_consume_token ( RBRACKET ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . operation = BSHLHSPrimarySuffix . INDEX ; break ; case DOT : jj_consume_token ( DOT ) ; t1 = jj_consume_token ( IDENTIFIER ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LPAREN : Arguments ( ) ; jj_consume_token ( DOT ) ; t2 = jj_consume_token ( IDENTIFIER ) ; break ; default : jj_la1 [ 58 ] = jj_gen ; ; } jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . operation = BSHLHSPrimarySuffix . NAME ; if ( t2 == null ) jjtn000 . field = t1 . image ; else { jjtn000 . method = t1 . image ; jjtn000 . field = t2 . image ; } break ; case LBRACE : jj_consume_token ( LBRACE ) ; Expression ( ) ; jj_consume_token ( RBRACE ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . operation = BSHLHSPrimarySuffix . PROPERTY ; break ; default : jj_la1 [ 59 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void Literal ( ) throws ParseException { BSHLiteral jjtn000 = new BSHLiteral ( JJTLITERAL ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; Token x ; boolean b ; String literal ; char ch ; try { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case INTEGER_LITERAL : x = jj_consume_token ( INTEGER_LITERAL ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; literal = x . image ; ch = literal . charAt ( literal . length ( ) - 1 ) ; if ( ch == 'l' || ch == 'L' ) { literal = literal . substring ( 0 , literal . length ( ) - 1 ) ; jjtn000 . value = new Primitive ( new Long ( literal ) ) ; } else jjtn000 . value = new Primitive ( Integer . decode ( literal ) ) ; break ; case FLOATING_POINT_LITERAL : x = jj_consume_token ( FLOATING_POINT_LITERAL ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; literal = x . image ; ch = literal . charAt ( literal . length ( ) - 1 ) ; if ( ch == 'f' || ch == 'F' ) { literal = literal . substring ( 0 , literal . length ( ) - 1 ) ; jjtn000 . value = new Primitive ( new Float ( literal ) ) ; } else { if ( ch == 'd' || ch == 'D' ) literal = literal . substring ( 0 , literal . length ( ) - 1 ) ; jjtn000 . value = new Primitive ( new Double ( literal ) ) ; } break ; case CHARACTER_LITERAL : x = jj_consume_token ( CHARACTER_LITERAL ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; try { jjtn000 . charSetup ( x . image . substring ( 1 , x . image . length ( ) - 1 ) ) ; } catch ( Exception e ) { { if ( true ) throw new ParseException ( "Error parsing character: " + x . image ) ; } } break ; case STRING_LITERAL : x = jj_consume_token ( STRING_LITERAL ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; try { jjtn000 . stringSetup ( x . image . substring ( 1 , x . image . length ( ) - 1 ) ) ; } catch ( Exception e ) { { if ( true ) throw new ParseException ( "Error parsing string: " + x . image ) ; } } break ; case FALSE : case TRUE : b = BooleanLiteral ( ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . value = new Primitive ( new Boolean ( b ) ) ; break ; case NULL : NullLiteral ( ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . value = Primitive . NULL ; break ; case VOID : VoidLiteral ( ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . value = Primitive . VOID ; break ; default : jj_la1 [ 60 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public boolean BooleanLiteral ( ) throws ParseException { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case TRUE : jj_consume_token ( TRUE ) ; { if ( true ) return true ; } break ; case FALSE : jj_consume_token ( FALSE ) ; { if ( true ) return false ; } break ; default : jj_la1 [ 61 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } throw new Error ( "Missing return statement in function" ) ; } final public void NullLiteral ( ) throws ParseException { jj_consume_token ( NULL ) ; } final public void VoidLiteral ( ) throws ParseException { jj_consume_token ( VOID ) ; } final public void Arguments ( ) throws ParseException { BSHArguments jjtn000 = new BSHArguments ( JJTARGUMENTS ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( LPAREN ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case BANG : case TILDE : case INCR : case DECR : case PLUS : case MINUS : ArgumentList ( ) ; break ; default : jj_la1 [ 62 ] = jj_gen ; ; } jj_consume_token ( RPAREN ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void ArgumentList ( ) throws ParseException { Expression ( ) ; label_17 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case COMMA : ; break ; default : jj_la1 [ 63 ] = jj_gen ; break label_17 ; } jj_consume_token ( COMMA ) ; Expression ( ) ; } } final public void AllocationExpression ( ) throws ParseException { BSHAllocationExpression jjtn000 = new BSHAllocationExpression ( JJTALLOCATIONEXPRESSION ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { if ( jj_2_18 ( 2 ) ) { jj_consume_token ( NEW ) ; PrimitiveType ( ) ; ArrayDimensions ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case NEW : jj_consume_token ( NEW ) ; AmbiguousName ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACKET : ArrayDimensions ( ) ; break ; case LPAREN : Arguments ( ) ; if ( jj_2_17 ( 2 ) ) { Block ( ) ; } else { ; } break ; default : jj_la1 [ 64 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } break ; default : jj_la1 [ 65 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void ArrayDimensions ( ) throws ParseException { BSHArrayDimensions jjtn000 = new BSHArrayDimensions ( JJTARRAYDIMENSIONS ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { if ( jj_2_20 ( 2 ) ) { label_18 : while ( true ) { jj_consume_token ( LBRACKET ) ; Expression ( ) ; jj_consume_token ( RBRACKET ) ; jjtn000 . addArrayDimension ( ) ; if ( jj_2_19 ( 2 ) ) { ; } else { break label_18 ; } } } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACKET : label_19 : while ( true ) { jj_consume_token ( LBRACKET ) ; jj_consume_token ( RBRACKET ) ; jjtn000 . addArrayDimension ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACKET : ; break ; default : jj_la1 [ 66 ] = jj_gen ; break label_19 ; } } ArrayInitializer ( ) ; break ; default : jj_la1 [ 67 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void Statement ( ) throws ParseException { if ( jj_2_21 ( 2 ) ) { LabeledStatement ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACE : Block ( ) ; break ; case SEMICOLON : EmptyStatement ( ) ; break ; case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case INCR : case DECR : StatementExpression ( ) ; jj_consume_token ( SEMICOLON ) ; break ; case SWITCH : SwitchStatement ( ) ; break ; case IF : IfStatement ( ) ; break ; case WHILE : WhileStatement ( ) ; break ; case DO : DoStatement ( ) ; break ; case FOR : ForStatement ( ) ; break ; case BREAK : BreakStatement ( ) ; break ; case CONTINUE : ContinueStatement ( ) ; break ; case RETURN : ReturnStatement ( ) ; break ; case THROW : ThrowStatement ( ) ; break ; case TRY : TryStatement ( ) ; break ; default : jj_la1 [ 68 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void LabeledStatement ( ) throws ParseException { jj_consume_token ( IDENTIFIER ) ; jj_consume_token ( COLON ) ; Statement ( ) ; } final public void Block ( ) throws ParseException { BSHBlock jjtn000 = new BSHBlock ( JJTBLOCK ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( LBRACE ) ; label_20 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BREAK : case BYTE : case CHAR : case CONTINUE : case DO : case DOUBLE : case FALSE : case FINAL : case FLOAT : case FOR : case IF : case IMPORT : case INT : case LONG : case NEW : case NULL : case RETURN : case SHORT : case SWITCH : case THROW : case TRUE : case TRY : case VOID : case WHILE : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case LBRACE : case SEMICOLON : case INCR : case DECR : ; break ; default : jj_la1 [ 69 ] = jj_gen ; break label_20 ; } BlockStatement ( ) ; } jj_consume_token ( RBRACE ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void BlockStatement ( ) throws ParseException { if ( jj_2_22 ( 2147483647 ) ) { MethodDeclaration ( ) ; } else if ( jj_2_23 ( 2147483647 ) ) { TypedVariableDeclaration ( ) ; jj_consume_token ( SEMICOLON ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BREAK : case BYTE : case CHAR : case CONTINUE : case DO : case DOUBLE : case FALSE : case FLOAT : case FOR : case IF : case INT : case LONG : case NEW : case NULL : case RETURN : case SHORT : case SWITCH : case THROW : case TRUE : case TRY : case VOID : case WHILE : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case LBRACE : case SEMICOLON : case INCR : case DECR : Statement ( ) ; break ; case IMPORT : ImportDeclaration ( ) ; break ; default : jj_la1 [ 70 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void EmptyStatement ( ) throws ParseException { jj_consume_token ( SEMICOLON ) ; } final public void StatementExpression ( ) throws ParseException { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case INCR : PreIncrementExpression ( ) ; break ; case DECR : PreDecrementExpression ( ) ; break ; default : jj_la1 [ 71 ] = jj_gen ; if ( jj_2_24 ( 2147483647 ) ) { Assignment ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : PostfixExpression ( ) ; break ; default : jj_la1 [ 72 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } } final public void SwitchStatement ( ) throws ParseException { BSHSwitchStatement jjtn000 = new BSHSwitchStatement ( JJTSWITCHSTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( SWITCH ) ; jj_consume_token ( LPAREN ) ; Expression ( ) ; jj_consume_token ( RPAREN ) ; jj_consume_token ( LBRACE ) ; label_21 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case CASE : case _DEFAULT : ; break ; default : jj_la1 [ 73 ] = jj_gen ; break label_21 ; } SwitchLabel ( ) ; label_22 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BREAK : case BYTE : case CHAR : case CONTINUE : case DO : case DOUBLE : case FALSE : case FINAL : case FLOAT : case FOR : case IF : case IMPORT : case INT : case LONG : case NEW : case NULL : case RETURN : case SHORT : case SWITCH : case THROW : case TRUE : case TRY : case VOID : case WHILE : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case LBRACE : case SEMICOLON : case INCR : case DECR : ; break ; default : jj_la1 [ 74 ] = jj_gen ; break label_22 ; } BlockStatement ( ) ; } } jj_consume_token ( RBRACE ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void SwitchLabel ( ) throws ParseException { BSHSwitchLabel jjtn000 = new BSHSwitchLabel ( JJTSWITCHLABEL ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case CASE : jj_consume_token ( CASE ) ; Expression ( ) ; jj_consume_token ( COLON ) ; break ; case _DEFAULT : jj_consume_token ( _DEFAULT ) ; jj_consume_token ( COLON ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . isDefault = true ; break ; default : jj_la1 [ 75 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void IfStatement ( ) throws ParseException { BSHIfStatement jjtn000 = new BSHIfStatement ( JJTIFSTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( IF ) ; jj_consume_token ( LPAREN ) ; Expression ( ) ; jj_consume_token ( RPAREN ) ; Statement ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case ELSE : jj_consume_token ( ELSE ) ; Statement ( ) ; break ; default : jj_la1 [ 76 ] = jj_gen ; ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void WhileStatement ( ) throws ParseException { BSHWhileStatement jjtn000 = new BSHWhileStatement ( JJTWHILESTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( WHILE ) ; jj_consume_token ( LPAREN ) ; Expression ( ) ; jj_consume_token ( RPAREN ) ; Statement ( ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void DoStatement ( ) throws ParseException { BSHWhileStatement jjtn000 = new BSHWhileStatement ( JJTWHILESTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( DO ) ; Statement ( ) ; jj_consume_token ( WHILE ) ; jj_consume_token ( LPAREN ) ; Expression ( ) ; jj_consume_token ( RPAREN ) ; jj_consume_token ( SEMICOLON ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . isDoStatement = true ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void ForStatement ( ) throws ParseException { BSHForStatement jjtn000 = new BSHForStatement ( JJTFORSTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( FOR ) ; jj_consume_token ( LPAREN ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FINAL : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case INCR : case DECR : ForInit ( ) ; jjtn000 . hasForInit = true ; break ; default : jj_la1 [ 77 ] = jj_gen ; ; } jj_consume_token ( SEMICOLON ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case BANG : case TILDE : case INCR : case DECR : case PLUS : case MINUS : Expression ( ) ; jjtn000 . hasExpression = true ; break ; default : jj_la1 [ 78 ] = jj_gen ; ; } jj_consume_token ( SEMICOLON ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case INCR : case DECR : ForUpdate ( ) ; jjtn000 . hasForUpdate = true ; break ; default : jj_la1 [ 79 ] = jj_gen ; ; } jj_consume_token ( RPAREN ) ; Statement ( ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void ForInit ( ) throws ParseException { Token t = null ; if ( jj_2_25 ( 2147483647 ) ) { TypedVariableDeclaration ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case INCR : case DECR : StatementExpressionList ( ) ; break ; default : jj_la1 [ 80 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void TypedVariableDeclaration ( ) throws ParseException { BSHTypedVariableDeclaration jjtn000 = new BSHTypedVariableDeclaration ( JJTTYPEDVARIABLEDECLARATION ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; Token t = null ; try { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case FINAL : t = jj_consume_token ( FINAL ) ; break ; default : jj_la1 [ 81 ] = jj_gen ; ; } Type ( ) ; VariableDeclarator ( ) ; label_23 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case COMMA : ; break ; default : jj_la1 [ 82 ] = jj_gen ; break label_23 ; } jj_consume_token ( COMMA ) ; VariableDeclarator ( ) ; } jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . isFinal = ( t != null ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void StatementExpressionList ( ) throws ParseException { BSHStatementExpressionList jjtn000 = new BSHStatementExpressionList ( JJTSTATEMENTEXPRESSIONLIST ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { StatementExpression ( ) ; label_24 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case COMMA : ; break ; default : jj_la1 [ 83 ] = jj_gen ; break label_24 ; } jj_consume_token ( COMMA ) ; StatementExpression ( ) ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void ForUpdate ( ) throws ParseException { StatementExpressionList ( ) ; } final public void BreakStatement ( ) throws ParseException { BSHReturnStatement jjtn000 = new BSHReturnStatement ( JJTRETURNSTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( BREAK ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : jj_consume_token ( IDENTIFIER ) ; break ; default : jj_la1 [ 84 ] = jj_gen ; ; } jj_consume_token ( SEMICOLON ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . kind = BREAK ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void ContinueStatement ( ) throws ParseException { BSHReturnStatement jjtn000 = new BSHReturnStatement ( JJTRETURNSTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( CONTINUE ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : jj_consume_token ( IDENTIFIER ) ; break ; default : jj_la1 [ 85 ] = jj_gen ; ; } jj_consume_token ( SEMICOLON ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . kind = CONTINUE ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void ReturnStatement ( ) throws ParseException { BSHReturnStatement jjtn000 = new BSHReturnStatement ( JJTRETURNSTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( RETURN ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FALSE : case FLOAT : case INT : case LONG : case NEW : case NULL : case SHORT : case TRUE : case VOID : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case CHARACTER_LITERAL : case STRING_LITERAL : case IDENTIFIER : case LPAREN : case BANG : case TILDE : case INCR : case DECR : case PLUS : case MINUS : Expression ( ) ; break ; default : jj_la1 [ 86 ] = jj_gen ; ; } jj_consume_token ( SEMICOLON ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; jjtreeCloseNodeScope ( jjtn000 ) ; jjtn000 . kind = RETURN ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void ThrowStatement ( ) throws ParseException { BSHThrowStatement jjtn000 = new BSHThrowStatement ( JJTTHROWSTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( THROW ) ; Expression ( ) ; jj_consume_token ( SEMICOLON ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final public void TryStatement ( ) throws ParseException { BSHTryStatement jjtn000 = new BSHTryStatement ( JJTTRYSTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; jjtreeOpenNodeScope ( jjtn000 ) ; try { jj_consume_token ( TRY ) ; Block ( ) ; label_25 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case CATCH : ; break ; default : jj_la1 [ 87 ] = jj_gen ; break label_25 ; } jj_consume_token ( CATCH ) ; jj_consume_token ( LPAREN ) ; FormalParameter ( ) ; jj_consume_token ( RPAREN ) ; Block ( ) ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case FINALLY : jj_consume_token ( FINALLY ) ; Block ( ) ; break ; default : jj_la1 [ 88 ] = jj_gen ; ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; jjtreeCloseNodeScope ( jjtn000 ) ; } } } final private boolean jj_2_1 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_1 ( ) ; jj_save ( 0 , xla ) ; return retval ; } final private boolean jj_2_2 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_2 ( ) ; jj_save ( 1 , xla ) ; return retval ; } final private boolean jj_2_3 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_3 ( ) ; jj_save ( 2 , xla ) ; return retval ; } final private boolean jj_2_4 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_4 ( ) ; jj_save ( 3 , xla ) ; return retval ; } final private boolean jj_2_5 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_5 ( ) ; jj_save ( 4 , xla ) ; return retval ; } final private boolean jj_2_6 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_6 ( ) ; jj_save ( 5 , xla ) ; return retval ; } final private boolean jj_2_7 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_7 ( ) ; jj_save ( 6 , xla ) ; return retval ; } final private boolean jj_2_8 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_8 ( ) ; jj_save ( 7 , xla ) ; return retval ; } final private boolean jj_2_9 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_9 ( ) ; jj_save ( 8 , xla ) ; return retval ; } final private boolean jj_2_10 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_10 ( ) ; jj_save ( 9 , xla ) ; return retval ; } final private boolean jj_2_11 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_11 ( ) ; jj_save ( 10 , xla ) ; return retval ; } final private boolean jj_2_12 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_12 ( ) ; jj_save ( 11 , xla ) ; return retval ; } final private boolean jj_2_13 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_13 ( ) ; jj_save ( 12 , xla ) ; return retval ; } final private boolean jj_2_14 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_14 ( ) ; jj_save ( 13 , xla ) ; return retval ; } final private boolean jj_2_15 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_15 ( ) ; jj_save ( 14 , xla ) ; return retval ; } final private boolean jj_2_16 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_16 ( ) ; jj_save ( 15 , xla ) ; return retval ; } final private boolean jj_2_17 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_17 ( ) ; jj_save ( 16 , xla ) ; return retval ; } final private boolean jj_2_18 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_18 ( ) ; jj_save ( 17 , xla ) ; return retval ; } final private boolean jj_2_19 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_19 ( ) ; jj_save ( 18 , xla ) ; return retval ; } final private boolean jj_2_20 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_20 ( ) ; jj_save ( 19 , xla ) ; return retval ; } final private boolean jj_2_21 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_21 ( ) ; jj_save ( 20 , xla ) ; return retval ; } final private boolean jj_2_22 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_22 ( ) ; jj_save ( 21 , xla ) ; return retval ; } final private boolean jj_2_23 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_23 ( ) ; jj_save ( 22 , xla ) ; return retval ; } final private boolean jj_2_24 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_24 ( ) ; jj_save ( 23 , xla ) ; return retval ; } final private boolean jj_2_25 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_25 ( ) ; jj_save ( 24 , xla ) ; return retval ; } final private boolean jj_3R_27 ( ) { if ( jj_3R_45 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_16 ( ) { if ( jj_scan_token ( DOT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( CLASS ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_102 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3_16 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_117 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_118 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_119 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_79 ( ) { if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_96 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_149 ( ) { if ( jj_scan_token ( FINAL ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_39 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_78 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_79 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_78 ( ) { if ( jj_3R_45 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_96 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_2 ( ) { if ( jj_3R_27 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_132 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_149 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_30 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_226 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_227 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3_15 ( ) { if ( jj_3R_30 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( DOT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( CLASS ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_42 ( ) { if ( jj_scan_token ( FINAL ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_25 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_42 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_30 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_148 ( ) { if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_96 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_37 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_36 ( ) { if ( jj_scan_token ( DECR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_243 ( ) { if ( jj_scan_token ( ELSE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_133 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_81 ( ) { if ( jj_3R_102 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_101 ( ) { if ( jj_3R_28 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_116 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_147 ( ) { if ( jj_3R_45 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_96 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_37 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_92 ( ) { if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_35 ( ) { if ( jj_scan_token ( INCR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_269 ( ) { if ( jj_3R_270 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_131 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_147 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_148 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_100 ( ) { if ( jj_3R_30 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_244 ( ) { if ( jj_3R_261 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_268 ( ) { if ( jj_3R_132 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_261 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_268 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_269 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_246 ( ) { if ( jj_3R_262 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_99 ( ) { if ( jj_3R_115 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_245 ( ) { if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_91 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_98 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_1 ( ) { if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_80 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_97 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_98 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_99 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_100 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_101 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_97 ( ) { if ( jj_3R_109 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_14 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_34 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_90 ( ) { if ( jj_scan_token ( BANG ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_280 ( ) { if ( jj_scan_token ( DECR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_181 ( ) { if ( jj_scan_token ( FOR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_244 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; xsp = jj_scanpos ; if ( jj_3R_245 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; xsp = jj_scanpos ; if ( jj_3R_246 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_133 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_41 ( ) { if ( jj_3R_80 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_81 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_89 ( ) { if ( jj_scan_token ( TILDE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_282 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_30 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_265 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_279 ( ) { if ( jj_scan_token ( INCR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_180 ( ) { if ( jj_scan_token ( DO ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_133 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( WHILE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_281 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_30 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_238 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_278 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_281 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_282 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_274 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_279 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_280 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_13 ( ) { if ( jj_3R_31 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_35 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_36 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_209 ( ) { if ( jj_3R_41 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_179 ( ) { if ( jj_scan_token ( WHILE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_133 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_12 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_28 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_208 ( ) { if ( jj_3R_31 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_274 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_260 ( ) { if ( jj_3R_95 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_178 ( ) { if ( jj_scan_token ( IF ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_133 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_243 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_201 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_208 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_209 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_68 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_28 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_89 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_90 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_91 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_92 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_93 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_94 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_67 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_28 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_10 ( ) { if ( jj_3R_33 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_267 ( ) { if ( jj_scan_token ( _DEFAULT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( COLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_11 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_34 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_33 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3_11 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_67 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_68 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_277 ( ) { if ( jj_scan_token ( BANG ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_266 ( ) { if ( jj_scan_token ( CASE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( COLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_259 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_266 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_267 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_242 ( ) { if ( jj_3R_259 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_260 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_273 ( ) { if ( jj_3R_201 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_258 ( ) { if ( jj_scan_token ( MOD ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_272 ( ) { if ( jj_3R_278 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_24 ( ) { if ( jj_3R_41 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_32 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_276 ( ) { if ( jj_scan_token ( TILDE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_177 ( ) { if ( jj_scan_token ( SWITCH ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_242 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } if ( jj_scan_token ( RBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_271 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_276 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_277 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_238 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_265 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_271 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_272 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_273 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_257 ( ) { if ( jj_scan_token ( SLASH ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_195 ( ) { if ( jj_3R_201 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_233 ( ) { if ( jj_scan_token ( RSIGNEDSHIFTX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_200 ( ) { if ( jj_scan_token ( DECR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_31 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_194 ( ) { if ( jj_3R_82 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_193 ( ) { if ( jj_3R_200 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_256 ( ) { if ( jj_scan_token ( STAR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_192 ( ) { if ( jj_3R_199 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_176 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_192 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_193 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_194 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_195 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_239 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_256 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_257 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_258 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_238 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_199 ( ) { if ( jj_scan_token ( INCR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_31 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_232 ( ) { if ( jj_scan_token ( RSIGNEDSHIFT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_264 ( ) { if ( jj_scan_token ( MINUS ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_255 ( ) { if ( jj_3R_265 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_225 ( ) { if ( jj_scan_token ( GEX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_254 ( ) { if ( jj_3R_200 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_175 ( ) { if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_253 ( ) { if ( jj_3R_199 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_263 ( ) { if ( jj_scan_token ( PLUS ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_221 ( ) { if ( jj_scan_token ( GTX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_40 ( ) { if ( jj_scan_token ( FINAL ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_252 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_263 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_264 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_238 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_238 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_252 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_253 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_254 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_255 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_23 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_40 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_30 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_241 ( ) { if ( jj_scan_token ( MINUS ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_113 ( ) { if ( jj_3R_134 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_22 ( ) { if ( jj_3R_39 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_224 ( ) { if ( jj_scan_token ( GE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_235 ( ) { if ( jj_scan_token ( RUNSIGNEDSHIFTX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_228 ( ) { if ( jj_3R_238 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_239 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_112 ( ) { if ( jj_3R_133 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_220 ( ) { if ( jj_scan_token ( GT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_231 ( ) { if ( jj_scan_token ( LSHIFTX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_240 ( ) { if ( jj_scan_token ( PLUS ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_111 ( ) { if ( jj_3R_132 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_229 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_240 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_241 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_228 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_213 ( ) { if ( jj_scan_token ( NE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_95 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_110 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_111 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_112 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_113 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_110 ( ) { if ( jj_3R_131 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_77 ( ) { if ( jj_3R_95 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_216 ( ) { if ( jj_3R_228 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_229 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_223 ( ) { if ( jj_scan_token ( LEX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_234 ( ) { if ( jj_scan_token ( RUNSIGNEDSHIFT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_230 ( ) { if ( jj_scan_token ( LSHIFT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_219 ( ) { if ( jj_scan_token ( LTX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_37 ( ) { if ( jj_scan_token ( LBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_77 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } if ( jj_scan_token ( RBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_217 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_230 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_231 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_232 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_233 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_234 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_235 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_216 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_212 ( ) { if ( jj_scan_token ( EQ ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_214 ( ) { if ( jj_3R_216 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_217 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_205 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_212 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_213 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_204 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_38 ( ) { if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( COLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_133 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_222 ( ) { if ( jj_scan_token ( LE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_218 ( ) { if ( jj_scan_token ( LT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_215 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_218 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_219 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_220 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_221 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_222 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_223 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_224 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_225 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_214 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_162 ( ) { if ( jj_3R_186 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_161 ( ) { if ( jj_3R_185 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_210 ( ) { if ( jj_3R_214 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_215 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_160 ( ) { if ( jj_3R_184 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_159 ( ) { if ( jj_3R_183 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_211 ( ) { if ( jj_scan_token ( INSTANCEOF ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_30 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_158 ( ) { if ( jj_3R_182 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_204 ( ) { if ( jj_3R_210 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_211 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_157 ( ) { if ( jj_3R_181 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_207 ( ) { if ( jj_scan_token ( BIT_ANDX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_156 ( ) { if ( jj_3R_180 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_155 ( ) { if ( jj_3R_179 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_189 ( ) { if ( jj_scan_token ( XOR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_188 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_154 ( ) { if ( jj_3R_178 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_197 ( ) { if ( jj_3R_204 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_205 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_153 ( ) { if ( jj_3R_177 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_152 ( ) { if ( jj_3R_176 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_60 ( ) { if ( jj_scan_token ( ORASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_17 ( ) { if ( jj_3R_37 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_206 ( ) { if ( jj_scan_token ( BIT_AND ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_151 ( ) { if ( jj_3R_175 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_198 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_206 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_207 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_197 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_150 ( ) { if ( jj_3R_37 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_188 ( ) { if ( jj_3R_197 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_198 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_59 ( ) { if ( jj_scan_token ( XORASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_21 ( ) { if ( jj_3R_38 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_133 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3_21 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_150 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_151 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_152 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_153 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_154 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_155 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_156 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_157 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_158 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_159 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_160 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_161 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_162 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_191 ( ) { if ( jj_scan_token ( BIT_ORX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_168 ( ) { if ( jj_3R_188 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_189 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_167 ( ) { if ( jj_3R_105 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3_17 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_58 ( ) { if ( jj_scan_token ( ANDASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_196 ( ) { if ( jj_scan_token ( LBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_64 ( ) { if ( jj_scan_token ( RSIGNEDSHIFTASSIGNX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_171 ( ) { if ( jj_scan_token ( BOOL_ANDX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_187 ( ) { Token xsp ; if ( jj_3R_196 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_196 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } if ( jj_3R_86 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_166 ( ) { if ( jj_3R_165 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_190 ( ) { if ( jj_scan_token ( BIT_OR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_19 ( ) { if ( jj_scan_token ( LBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_104 ( ) { if ( jj_scan_token ( HOOK ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( COLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_83 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_169 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_190 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_191 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_168 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_165 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3_20 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_187 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_57 ( ) { if ( jj_scan_token ( MINUSASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_20 ( ) { Token xsp ; if ( jj_3_19 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; while ( true ) { xsp = jj_scanpos ; if ( jj_3_19 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_63 ( ) { if ( jj_scan_token ( RSIGNEDSHIFTASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_139 ( ) { if ( jj_3R_168 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_169 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_142 ( ) { if ( jj_scan_token ( BOOL_ORX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_170 ( ) { if ( jj_scan_token ( BOOL_AND ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_56 ( ) { if ( jj_scan_token ( PLUSASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_140 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_170 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_171 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_139 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_120 ( ) { if ( jj_3R_139 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_140 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_137 ( ) { if ( jj_scan_token ( NEW ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_28 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_166 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_167 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_55 ( ) { if ( jj_scan_token ( MODASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_141 ( ) { if ( jj_scan_token ( BOOL_OR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_18 ( ) { if ( jj_scan_token ( NEW ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_34 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_165 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_115 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3_18 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_137 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_121 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_141 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_142 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_120 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_172 ( ) { if ( jj_scan_token ( COMMA ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_103 ( ) { if ( jj_3R_120 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_121 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_54 ( ) { if ( jj_scan_token ( SLASHASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_143 ( ) { if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_172 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_66 ( ) { if ( jj_scan_token ( RUNSIGNEDSHIFTASSIGNX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_122 ( ) { if ( jj_3R_143 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_62 ( ) { if ( jj_scan_token ( LSHIFTASSIGNX ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_83 ( ) { if ( jj_3R_103 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_104 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_53 ( ) { if ( jj_scan_token ( STARASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_105 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_122 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_65 ( ) { if ( jj_scan_token ( RUNSIGNEDSHIFTASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_61 ( ) { if ( jj_scan_token ( LSHIFTASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_52 ( ) { if ( jj_scan_token ( ASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_146 ( ) { if ( jj_scan_token ( VOID ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_32 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_52 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_53 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_54 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_55 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_56 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_57 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_58 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_59 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_60 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_61 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_62 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_63 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_64 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_65 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_66 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_145 ( ) { if ( jj_scan_token ( NULL ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_9 ( ) { if ( jj_3R_31 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_32 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_174 ( ) { if ( jj_scan_token ( FALSE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_82 ( ) { if ( jj_3R_31 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_32 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_173 ( ) { if ( jj_scan_token ( TRUE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_144 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_173 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_174 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_44 ( ) { if ( jj_3R_83 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_43 ( ) { if ( jj_3R_82 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_26 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_43 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_44 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_130 ( ) { if ( jj_3R_146 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_129 ( ) { if ( jj_3R_145 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_128 ( ) { if ( jj_3R_144 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_127 ( ) { if ( jj_scan_token ( STRING_LITERAL ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_8 ( ) { if ( jj_scan_token ( DOT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_28 ( ) { if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3_8 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_126 ( ) { if ( jj_scan_token ( CHARACTER_LITERAL ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_203 ( ) { if ( jj_scan_token ( COMMA ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_76 ( ) { if ( jj_scan_token ( DOUBLE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_75 ( ) { if ( jj_scan_token ( FLOAT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_74 ( ) { if ( jj_scan_token ( LONG ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_73 ( ) { if ( jj_scan_token ( INT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_49 ( ) { if ( jj_3R_28 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_72 ( ) { if ( jj_scan_token ( SHORT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_71 ( ) { if ( jj_scan_token ( BYTE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_70 ( ) { if ( jj_scan_token ( CHAR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_125 ( ) { if ( jj_scan_token ( FLOATING_POINT_LITERAL ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_69 ( ) { if ( jj_scan_token ( BOOLEAN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_34 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_69 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_70 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_71 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_72 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_73 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_74 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_75 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_76 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_85 ( ) { if ( jj_3R_30 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_45 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_84 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_85 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_84 ( ) { if ( jj_scan_token ( VOID ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_7 ( ) { if ( jj_scan_token ( LBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_48 ( ) { if ( jj_3R_34 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_109 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_124 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_125 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_126 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_127 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_128 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_129 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_130 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_124 ( ) { if ( jj_scan_token ( INTEGER_LITERAL ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_123 ( ) { if ( jj_3R_105 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( DOT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_30 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_48 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_49 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; while ( true ) { xsp = jj_scanpos ; if ( jj_3_7 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_136 ( ) { if ( jj_scan_token ( COMMA ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_135 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_164 ( ) { if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_108 ( ) { if ( jj_scan_token ( LBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_6 ( ) { if ( jj_3R_30 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_135 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3_6 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_164 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_51 ( ) { if ( jj_3R_88 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_5 ( ) { if ( jj_scan_token ( COMMA ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_29 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_87 ( ) { if ( jj_3R_105 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_107 ( ) { if ( jj_scan_token ( DOT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_123 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_114 ( ) { if ( jj_3R_135 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_136 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_106 ( ) { if ( jj_scan_token ( LBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_88 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_106 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_107 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_108 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_96 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_114 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_202 ( ) { if ( jj_3R_29 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3_5 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_86 ( ) { if ( jj_scan_token ( LBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_202 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; xsp = jj_scanpos ; if ( jj_3R_203 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_31 ( ) { if ( jj_3R_50 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_51 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_251 ( ) { if ( jj_scan_token ( FINALLY ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_37 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_250 ( ) { if ( jj_scan_token ( CATCH ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_135 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_37 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_47 ( ) { if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_186 ( ) { if ( jj_scan_token ( TRY ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_37 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_250 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } xsp = jj_scanpos ; if ( jj_3R_251 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_46 ( ) { if ( jj_3R_86 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_29 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_46 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_47 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_236 ( ) { if ( jj_scan_token ( ASSIGN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_29 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_50 ( ) { if ( jj_3R_28 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_87 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_249 ( ) { if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_237 ( ) { if ( jj_scan_token ( DOT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( STAR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_248 ( ) { if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_185 ( ) { if ( jj_scan_token ( THROW ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_138 ( ) { if ( jj_3R_105 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_227 ( ) { if ( jj_scan_token ( COMMA ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_226 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_94 ( ) { if ( jj_3R_109 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_275 ( ) { if ( jj_scan_token ( COMMA ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_176 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_184 ( ) { if ( jj_scan_token ( RETURN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_249 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_247 ( ) { if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_226 ( ) { if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_236 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_93 ( ) { if ( jj_scan_token ( NEW ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_183 ( ) { if ( jj_scan_token ( CONTINUE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_248 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_163 ( ) { if ( jj_scan_token ( IMPORT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( STAR ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_182 ( ) { if ( jj_scan_token ( BREAK ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_247 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_119 ( ) { if ( jj_scan_token ( LBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RBRACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_118 ( ) { if ( jj_scan_token ( DOT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_138 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_262 ( ) { if ( jj_3R_270 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_4 ( ) { if ( jj_scan_token ( IMPORT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_28 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_237 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( SEMICOLON ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_134 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3_4 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_163 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_116 ( ) { if ( jj_3R_105 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_3 ( ) { if ( jj_3R_27 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_117 ( ) { if ( jj_scan_token ( LBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_26 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_270 ( ) { if ( jj_3R_176 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_275 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } public ParserTokenManager token_source ; ASCII_UCodeESC_CharStream jj_input_stream ; public Token token , jj_nt ; private int jj_ntk ; private Token jj_scanpos , jj_lastpos ; private int jj_la ; public boolean lookingAhead = false ; private boolean jj_semLA ; private int jj_gen ; final private int [ ] jj_la1 = new int [ 89 ] ; final private int [ ] jj_la1_0 = { 0xdb6a5800 , 0xdb6a5801 , 0x0 , 0x0 , 0x0 , 0x80000000 , 0x0 , 0x9424800 , 0x9424800 , 0x0 , 0x0 , 0x8424800 , 0x0 , 0x8424800 , 0x8424800 , 0x8424800 , 0x9424800 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x9424800 , 0x0 , 0x0 , 0x9424800 , 0x1000000 , 0x0 , 0x0 , 0x0 , 0x9424800 , 0x0 , 0x0 , 0x0 , 0x1000000 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x1000000 , 0x1000000 , 0x9424800 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x596a5800 , 0xdb6a5800 , 0xd96a5800 , 0x0 , 0x9424800 , 0x108000 , 0xdb6a5800 , 0x108000 , 0x800000 , 0xb424800 , 0x9424800 , 0x9424800 , 0x9424800 , 0x2000000 , 0x0 , 0x0 , 0x0 , 0x0 , 0x9424800 , 0x10000 , 0x4000000 , } ; final private int [ ] jj_la1_1 = { 0xa747f63a , 0xa747f63a , 0x4000000 , 0x4000000 , 0x0 , 0x0 , 0x0 , 0xa745443a , 0xa745443a , 0x0 , 0x0 , 0x400040a , 0x4000000 , 0x400040a , 0x401040a , 0x40a , 0x2745443a , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x1 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x2745443a , 0x0 , 0x0 , 0x2745443a , 0x27454030 , 0x20000000 , 0x0 , 0x0 , 0x2745443a , 0x20000000 , 0x80000000 , 0x20000000 , 0x23454030 , 0x4000000 , 0x20000000 , 0x80000000 , 0x20000000 , 0x80000000 , 0x20000000 , 0x80000000 , 0x3454020 , 0x4000 , 0x2745443a , 0x0 , 0x20000000 , 0x10 , 0x0 , 0x0 , 0xa747f63a , 0xa747f63a , 0xa747f63a , 0x0 , 0x2745443a , 0x0 , 0xa747f63a , 0x0 , 0x0 , 0x2745443a , 0x2745443a , 0x2745443a , 0x2745443a , 0x0 , 0x0 , 0x0 , 0x4000000 , 0x4000000 , 0x2745443a , 0x0 , 0x0 , } ; final private int [ ] jj_la1_2 = { 0x6000008 , 0x1e001808 , 0x0 , 0x0 , 0x20 , 0x0 , 0x40 , 0x1e001800 , 0x1e001800 , 0x10 , 0x10 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x1e001800 , 0x40 , 0x2000 , 0x600000 , 0x600000 , 0x1800000 , 0x1800000 , 0x0 , 0x0 , 0x0 , 0x80000000 , 0x80000000 , 0x108000 , 0x108000 , 0x0 , 0xf0780 , 0xf0780 , 0x0 , 0x0 , 0x18000000 , 0x18000000 , 0x60000000 , 0x60000000 , 0x18000000 , 0x1e001800 , 0x1800 , 0x1800 , 0x0 , 0x1800 , 0x0 , 0x6000000 , 0x6000000 , 0x0 , 0x0 , 0x22 , 0x0 , 0x0 , 0x0 , 0x0 , 0x22 , 0x0 , 0x22 , 0x0 , 0x22 , 0x0 , 0x0 , 0x1e001800 , 0x10 , 0x2 , 0x0 , 0x2 , 0x2 , 0x6000008 , 0x6000008 , 0x6000008 , 0x6000000 , 0x0 , 0x0 , 0x6000008 , 0x0 , 0x0 , 0x6000000 , 0x1e001800 , 0x6000000 , 0x6000000 , 0x0 , 0x10 , 0x10 , 0x0 , 0x0 , 0x1e001800 , 0x0 , 0x0 , } ; final private int [ ] jj_la1_3 = { 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x7faf800 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x6 , 0x6 , 0x8 , 0x1 , 0x1 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x7e0 , 0x7e0 , 0x0 , 0x0 , 0x10 , 0x10 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , } ; final private JJCalls [ ] jj_2_rtns = new JJCalls [ 25 ] ; private boolean jj_rescan = false ; private int jj_gc = 0 ; public Parser ( java . io . InputStream stream ) { jj_input_stream = new ASCII_UCodeESC_CharStream ( stream , 1 , 1 ) ; token_source = new ParserTokenManager ( jj_input_stream ) ; token = new Token ( ) ; jj_ntk = - 1 ; jj_gen = 0 ; for ( int i = 0 ; i < 89 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; } public void ReInit ( java . io . InputStream stream ) { jj_input_stream . ReInit ( stream , 1 , 1 ) ; token_source . ReInit ( jj_input_stream ) ; token = new Token ( ) ; jj_ntk = - 1 ; jjtree . reset ( ) ; jj_gen = 0 ; for ( int i = 0 ; i < 89 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; } public Parser ( java . io . Reader stream ) { jj_input_stream = new ASCII_UCodeESC_CharStream ( stream , 1 , 1 ) ; token_source = new ParserTokenManager ( jj_input_stream ) ; token = new Token ( ) ; jj_ntk = - 1 ; jj_gen = 0 ; for ( int i = 0 ; i < 89 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; } public void ReInit ( java . io . Reader stream ) { jj_input_stream . ReInit ( stream , 1 , 1 ) ; token_source . ReInit ( jj_input_stream ) ; token = new Token ( ) ; jj_ntk = - 1 ; jjtree . reset ( ) ; jj_gen = 0 ; for ( int i = 0 ; i < 89 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; } public Parser ( ParserTokenManager tm ) { token_source = tm ; token = new Token ( ) ; jj_ntk = - 1 ; jj_gen = 0 ; for ( int i = 0 ; i < 89 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; } public void ReInit ( ParserTokenManager tm ) { token_source = tm ; token = new Token ( ) ; jj_ntk = - 1 ; jjtree . reset ( ) ; jj_gen = 0 ; for ( int i = 0 ; i < 89 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; } final private Token jj_consume_token ( int kind ) throws ParseException { Token oldToken ; if ( ( oldToken = token ) . next != null ) token = token . next ; else token = token . next = token_source . getNextToken ( ) ; jj_ntk = - 1 ; if ( token . kind == kind ) { jj_gen ++ ; if ( ++ jj_gc > 100 ) { jj_gc = 0 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) { JJCalls c = jj_2_rtns [ i ] ; while ( c != null ) { if ( c . gen < jj_gen ) c . first = null ; c = c . next ; } } } return token ; } token = oldToken ; jj_kind = kind ; throw generateParseException ( ) ; } final private boolean jj_scan_token ( int kind ) { if ( jj_scanpos == jj_lastpos ) { jj_la -- ; if ( jj_scanpos . next == null ) { jj_lastpos = jj_scanpos = jj_scanpos . next = token_source . getNextToken ( ) ; } else { jj_lastpos = jj_scanpos = jj_scanpos . next ; } } else { jj_scanpos = jj_scanpos . next ; } if ( jj_rescan ) { int i = 0 ; Token tok = token ; while ( tok != null && tok != jj_scanpos ) { i ++ ; tok = tok . next ; } if ( tok != null ) jj_add_error_token ( kind , i ) ; } return ( jj_scanpos . kind != kind ) ; } final public Token getNextToken ( ) { if ( token . next != null ) token = token . next ; else token = token . next = token_source . getNextToken ( ) ; jj_ntk = - 1 ; jj_gen ++ ; return token ; } final public Token getToken ( int index ) { Token t = lookingAhead ? jj_scanpos : token ; for ( int i = 0 ; i < index ; i ++ ) { if ( t . next != null ) t = t . next ; else t = t . next = token_source . getNextToken ( ) ; } return t ; } final private int jj_ntk ( ) { if ( ( jj_nt = token . next ) == null ) return ( jj_ntk = ( token . next = token_source . getNextToken ( ) ) . kind ) ; else return ( jj_ntk = jj_nt . kind ) ; } private java . util . Vector jj_expentries = new java . util . Vector ( ) ; private int [ ] jj_expentry ; private int jj_kind = - 1 ; private int [ ] jj_lasttokens = new int [ 100 ] ; private int jj_endpos ; private void jj_add_error_token ( int kind , int pos ) { if ( pos >= 100 ) return ; if ( pos == jj_endpos + 1 ) { jj_lasttokens [ jj_endpos ++ ] = kind ; } else if ( jj_endpos != 0 ) { jj_expentry = new int [ jj_endpos ] ; for ( int i = 0 ; i < jj_endpos ; i ++ ) { jj_expentry [ i ] = jj_lasttokens [ i ] ; } boolean exists = false ; for ( java . util . Enumeration enum = jj_expentries . elements ( ) ; enum . hasMoreElements ( ) ; ) { int [ ] oldentry = ( int [ ] ) ( enum . nextElement ( ) ) ; if ( oldentry . length == jj_expentry . length ) { exists = true ; for ( int i = 0 ; i < jj_expentry . length ; i ++ ) { if ( oldentry [ i ] != jj_expentry [ i ] ) { exists = false ; break ; } } if ( exists ) break ; } } if ( ! exists ) jj_expentries . addElement ( jj_expentry ) ; if ( pos != 0 ) jj_lasttokens [ ( jj_endpos = pos ) - 1 ] = kind ; } } final public ParseException generateParseException ( ) { jj_expentries . removeAllElements ( ) ; boolean [ ] la1tokens = new boolean [ 123 ] ; for ( int i = 0 ; i < 123 ; i ++ ) { la1tokens [ i ] = false ; } if ( jj_kind >= 0 ) { la1tokens [ jj_kind ] = true ; jj_kind = - 1 ; } for ( int i = 0 ; i < 89 ; i ++ ) { if ( jj_la1 [ i ] == jj_gen ) { for ( int j = 0 ; j < 32 ; j ++ ) { if ( ( jj_la1_0 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ j ] = true ; } if ( ( jj_la1_1 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ 32 + j ] = true ; } if ( ( jj_la1_2 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ 64 + j ] = true ; } if ( ( jj_la1_3 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ 96 + j ] = true ; } } } } for ( int i = 0 ; i < 123 ; i ++ ) { if ( la1tokens [ i ] ) { jj_expentry = new int [ 1 ] ; jj_expentry [ 0 ] = i ; jj_expentries . addElement ( jj_expentry ) ; } } jj_endpos = 0 ; jj_rescan_token ( ) ; jj_add_error_token ( 0 , 0 ) ; int [ ] [ ] exptokseq = new int [ jj_expentries . size ( ) ] [ ] ; for ( int i = 0 ; i < jj_expentries . size ( ) ; i ++ ) { exptokseq [ i ] = ( int [ ] ) jj_expentries . elementAt ( i ) ; } return new ParseException ( token , exptokseq , tokenImage ) ; } final public void enable_tracing ( ) { } final public void disable_tracing ( ) { } final private void jj_rescan_token ( ) { jj_rescan = true ; for ( int i = 0 ; i < 25 ; i ++ ) { JJCalls p = jj_2_rtns [ i ] ; do { if ( p . gen > jj_gen ) { jj_la = p . arg ; jj_lastpos = jj_scanpos = p . first ; switch ( i ) { case 0 : jj_3_1 ( ) ; break ; case 1 : jj_3_2 ( ) ; break ; case 2 : jj_3_3 ( ) ; break ; case 3 : jj_3_4 ( ) ; break ; case 4 : jj_3_5 ( ) ; break ; case 5 : jj_3_6 ( ) ; break ; case 6 : jj_3_7 ( ) ; break ; case 7 : jj_3_8 ( ) ; break ; case 8 : jj_3_9 ( ) ; break ; case 9 : jj_3_10 ( ) ; break ; case 10 : jj_3_11 ( ) ; break ; case 11 : jj_3_12 ( ) ; break ; case 12 : jj_3_13 ( ) ; break ; case 13 : jj_3_14 ( ) ; break ; case 14 : jj_3_15 ( ) ; break ; case 15 : jj_3_16 ( ) ; break ; case 16 : jj_3_17 ( ) ; break ; case 17 : jj_3_18 ( ) ; break ; case 18 : jj_3_19 ( ) ; break ; case 19 : jj_3_20 ( ) ; break ; case 20 : jj_3_21 ( ) ; break ; case 21 : jj_3_22 ( ) ; break ; case 22 : jj_3_23 ( ) ; break ; case 23 : jj_3_24 ( ) ; break ; case 24 : jj_3_25 ( ) ; break ; } } p = p . next ; } while ( p != null ) ; } jj_rescan = false ; } final private void jj_save ( int index , int xla ) { JJCalls p = jj_2_rtns [ index ] ; while ( p . gen > jj_gen ) { if ( p . next == null ) { p = p . next = new JJCalls ( ) ; break ; } p = p . next ; } p . gen = jj_gen + xla - jj_la ; p . first = token ; p . arg = xla ; } static final class JJCalls { int gen ; Token first ; int arg ; JJCalls next ; } } 	0	['399', '1', '0', '47', '487', '0', '1', '47', '82', '0.71839196', '23350', '0.8', '8', '0', '0.183375104', '0', '0', '57.45864662', '46', '5.5439', '0']
package org . gjt . sp . jedit . textarea ; import javax . swing . text . * ; import javax . swing . JComponent ; import java . awt . event . MouseEvent ; import java . awt . * ; import org . gjt . sp . jedit . syntax . * ; import org . gjt . sp . jedit . Buffer ; import org . gjt . sp . jedit . TextUtilities ; import org . gjt . sp . util . Log ; public class TextAreaPainter extends JComponent implements TabExpander { public TextAreaPainter ( JEditTextArea textArea ) { enableEvents ( AWTEvent . FOCUS_EVENT_MASK | AWTEvent . KEY_EVENT_MASK | AWTEvent . MOUSE_EVENT_MASK ) ; this . textArea = textArea ; setAutoscrolls ( true ) ; setDoubleBuffered ( true ) ; setOpaque ( true ) ; setCursor ( Cursor . getPredefinedCursor ( Cursor . TEXT_CURSOR ) ) ; } public boolean isManagingFocus ( ) { return false ; } public boolean getFocusTraversalKeysEnabled ( ) { return false ; } public final SyntaxStyle [ ] getStyles ( ) { return styles ; } public final void setStyles ( SyntaxStyle [ ] styles ) { this . styles = styles ; repaint ( ) ; } public final Color getCaretColor ( ) { return caretColor ; } public final void setCaretColor ( Color caretColor ) { this . caretColor = caretColor ; if ( textArea . getBuffer ( ) != null ) textArea . invalidateLine ( textArea . getCaretLine ( ) ) ; } public final Color getSelectionColor ( ) { return selectionColor ; } public final void setSelectionColor ( Color selectionColor ) { this . selectionColor = selectionColor ; if ( textArea . getBuffer ( ) != null ) textArea . invalidateSelectedLines ( ) ; } public final Color getLineHighlightColor ( ) { return lineHighlightColor ; } public final void setLineHighlightColor ( Color lineHighlightColor ) { this . lineHighlightColor = lineHighlightColor ; if ( textArea . getBuffer ( ) != null ) textArea . invalidateLine ( textArea . getCaretLine ( ) ) ; } public final boolean isLineHighlightEnabled ( ) { return lineHighlight ; } public final void setLineHighlightEnabled ( boolean lineHighlight ) { this . lineHighlight = lineHighlight ; if ( textArea . getBuffer ( ) != null ) textArea . invalidateSelectedLines ( ) ; } public final Color getBracketHighlightColor ( ) { return bracketHighlightColor ; } public final void setBracketHighlightColor ( Color bracketHighlightColor ) { this . bracketHighlightColor = bracketHighlightColor ; if ( textArea . getBuffer ( ) != null ) textArea . invalidateLine ( textArea . getBracketLine ( ) ) ; } public final boolean isBracketHighlightEnabled ( ) { return bracketHighlight ; } public final void setBracketHighlightEnabled ( boolean bracketHighlight ) { this . bracketHighlight = bracketHighlight ; if ( textArea . getBuffer ( ) != null ) textArea . invalidateLine ( textArea . getBracketLine ( ) ) ; } public final boolean isBlockCaretEnabled ( ) { return blockCaret ; } public final void setBlockCaretEnabled ( boolean blockCaret ) { this . blockCaret = blockCaret ; if ( textArea . getBuffer ( ) != null ) textArea . invalidateLine ( textArea . getCaretLine ( ) ) ; } public final Color getEOLMarkerColor ( ) { return eolMarkerColor ; } public final void setEOLMarkerColor ( Color eolMarkerColor ) { this . eolMarkerColor = eolMarkerColor ; repaint ( ) ; } public final boolean getEOLMarkersPainted ( ) { return eolMarkers ; } public final void setEOLMarkersPainted ( boolean eolMarkers ) { this . eolMarkers = eolMarkers ; repaint ( ) ; } public final Color getWrapGuideColor ( ) { return wrapGuideColor ; } public final void setWrapGuideColor ( Color wrapGuideColor ) { this . wrapGuideColor = wrapGuideColor ; repaint ( ) ; } public final boolean getWrapGuidePainted ( ) { return wrapGuide ; } public final void setWrapGuidePainted ( boolean wrapGuide ) { this . wrapGuide = wrapGuide ; repaint ( ) ; } public void setAntiAliasEnabled ( boolean antiAlias ) { this . antiAlias = antiAlias ; textArea . getTextRenderer ( ) . configure ( antiAlias , fracFontMetrics ) ; } public boolean isAntiAliasEnabled ( ) { return antiAlias ; } public void setFractionalFontMetricsEnabled ( boolean fracFontMetrics ) { this . fracFontMetrics = fracFontMetrics ; textArea . getTextRenderer ( ) . configure ( antiAlias , fracFontMetrics ) ; } public boolean isFractionalFontMetricsEnabled ( ) { return fracFontMetrics ; } public void addCustomHighlight ( TextAreaHighlight highlight ) { highlight . init ( textArea , highlights ) ; highlights = highlight ; } public String getToolTipText ( MouseEvent evt ) { if ( maxLineLen != 0 ) { int wrapGuidePos = maxLineLen + textArea . getHorizontalOffset ( ) ; if ( Math . abs ( evt . getX ( ) - wrapGuidePos ) < 5 ) { return String . valueOf ( textArea . getBuffer ( ) . getProperty ( "maxLineLen" ) ) ; } } if ( highlights != null ) return highlights . getToolTipText ( evt ) ; else return null ; } public FontMetrics getFontMetrics ( ) { return fm ; } public void setFont ( Font font ) { super . setFont ( font ) ; fm = getFontMetrics ( font ) ; textArea . recalculateVisibleLines ( ) ; updateTabSize ( ) ; } public void paintComponent ( Graphics gfx ) { updateTabSize ( ) ; textArea . getTextRenderer ( ) . setupGraphics ( gfx ) ; Buffer buffer = textArea . getBuffer ( ) ; Rectangle clipRect = gfx . getClipBounds ( ) ; gfx . setColor ( getBackground ( ) ) ; gfx . fillRect ( clipRect . x , clipRect . y , clipRect . width , clipRect . height ) ; int x = textArea . getHorizontalOffset ( ) ; int height = fm . getHeight ( ) ; int firstLine = textArea . getFirstLine ( ) ; int firstInvalid = firstLine + clipRect . y / height ; int lastInvalid = firstLine + ( clipRect . y + clipRect . height - 1 ) / height ; int lineCount = textArea . getVirtualLineCount ( ) ; int y = ( clipRect . y - clipRect . y % height ) ; try { int maxWidth = textArea . maxHorizontalScrollWidth ; boolean updateMaxHorizontalScrollWidth = false ; for ( int line = firstInvalid ; line <= lastInvalid ; line ++ ) { boolean valid = buffer . isLoaded ( ) && line >= 0 && line < lineCount ; int physicalLine ; if ( valid ) physicalLine = buffer . virtualToPhysical ( line ) ; else { int virtualLineCount = buffer . getVirtualLineCount ( ) ; physicalLine = buffer . virtualToPhysical ( virtualLineCount - 1 ) + ( line - virtualLineCount ) ; } int width = paintLine ( gfx , buffer , valid , line , physicalLine , x , y ) - x + 5 ; if ( valid ) { buffer . setLineWidth ( physicalLine , width ) ; if ( width > maxWidth ) updateMaxHorizontalScrollWidth = true ; } y += height ; } if ( buffer . isNextLineRequested ( ) ) { int h = clipRect . y + clipRect . height ; repaint ( 0 , h , getWidth ( ) , getHeight ( ) - h ) ; } if ( updateMaxHorizontalScrollWidth ) textArea . updateMaxHorizontalScrollWidth ( ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , this , "Error repainting line" + " range {" + firstInvalid + "," + lastInvalid + "}:" ) ; Log . log ( Log . ERROR , this , e ) ; } } public float nextTabStop ( float x , int tabOffset ) { int offset = textArea . getHorizontalOffset ( ) ; int ntabs = ( ( int ) x - offset ) / tabSize ; return ( ntabs + 1 ) * tabSize + offset ; } public Dimension getPreferredSize ( ) { Dimension dim = new Dimension ( ) ; dim . width = fm . charWidth ( 'w' ) * 80 ; dim . height = fm . getHeight ( ) * 25 ; return dim ; } public Dimension getMinimumSize ( ) { return getPreferredSize ( ) ; } void updateTabSize ( ) { if ( textArea . getBuffer ( ) == null ) return ; tabSize = fm . charWidth ( ' ' ) * ( ( Integer ) textArea . getBuffer ( ) . getProperty ( PlainDocument . tabSizeAttribute ) ) . intValue ( ) ; int _maxLineLen = ( ( Integer ) textArea . getBuffer ( ) . getProperty ( "maxLineLen" ) ) . intValue ( ) ; if ( _maxLineLen <= 0 ) maxLineLen = 0 ; else maxLineLen = fm . charWidth ( ' ' ) * _maxLineLen ; } private JEditTextArea textArea ; private SyntaxStyle [ ] styles ; private Color caretColor ; private Color selectionColor ; private Color lineHighlightColor ; private Color bracketHighlightColor ; private Color eolMarkerColor ; private Color wrapGuideColor ; private boolean blockCaret ; private boolean lineHighlight ; private boolean bracketHighlight ; private boolean eolMarkers ; private boolean wrapGuide ; private boolean antiAlias ; private boolean fracFontMetrics ; private int tabSize ; private int maxLineLen ; private FontMetrics fm ; private TextAreaHighlight highlights ; private int paintLine ( Graphics gfx , Buffer buffer , boolean valid , int virtualLine , int physicalLine , int x , int y ) { paintHighlight ( gfx , virtualLine , physicalLine , y , valid ) ; if ( maxLineLen != 0 && wrapGuide ) { gfx . setColor ( wrapGuideColor ) ; gfx . drawLine ( x + maxLineLen , y , x + maxLineLen , y + fm . getHeight ( ) ) ; } if ( valid ) { Font defaultFont = getFont ( ) ; Color defaultColor = getForeground ( ) ; gfx . setFont ( defaultFont ) ; gfx . setColor ( defaultColor ) ; int baseLine = y + fm . getHeight ( ) - fm . getLeading ( ) - fm . getDescent ( ) ; x = buffer . paintSyntaxLine ( physicalLine , gfx , x , baseLine , this , true , true , defaultFont , defaultColor , ( lineHighlight && textArea . getSelectionCount ( ) == 0 && physicalLine == textArea . getCaretLine ( ) ? lineHighlightColor : getBackground ( ) ) , styles , textArea . getTextRenderer ( ) ) ; if ( eolMarkers ) { gfx . setFont ( defaultFont ) ; gfx . setColor ( eolMarkerColor ) ; gfx . drawString ( "." , x , baseLine ) ; } if ( physicalLine == textArea . getCaretLine ( ) && textArea . isCaretVisible ( ) ) paintCaret ( gfx , physicalLine , y ) ; if ( buffer . isFoldStart ( physicalLine ) && ! buffer . isLineVisible ( physicalLine + 1 ) ) { gfx . setColor ( defaultColor ) ; int start = textArea . getHorizontalOffset ( ) + fm . charWidth ( ' ' ) * buffer . getFoldLevel ( physicalLine ) ; gfx . drawLine ( start , y + fm . getHeight ( ) - 1 , x - 1 , y + fm . getHeight ( ) - 1 ) ; } } return x ; } private void paintHighlight ( Graphics gfx , int virtualLine , int physicalLine , int y , boolean valid ) { if ( valid ) { if ( textArea . selection . size ( ) == 0 ) { if ( lineHighlight && physicalLine == textArea . getCaretLine ( ) ) { gfx . setColor ( lineHighlightColor ) ; gfx . fillRect ( 0 , y , getWidth ( ) , fm . getHeight ( ) ) ; } } else { gfx . setColor ( selectionColor ) ; for ( int i = textArea . selection . size ( ) - 1 ; i >= 0 ; i -- ) { paintSelection ( gfx , physicalLine , y , ( Selection ) textArea . selection . elementAt ( i ) ) ; } } if ( bracketHighlight && physicalLine == textArea . getBracketLine ( ) && textArea . isHighlightVisible ( ) ) paintBracketHighlight ( gfx , physicalLine , y ) ; } if ( highlights != null ) { highlights . paintHighlight ( gfx , virtualLine , y - fm . getLeading ( ) - fm . getDescent ( ) ) ; } } private void paintBracketHighlight ( Graphics gfx , int physicalLine , int y ) { int position = textArea . getBracketPosition ( ) ; if ( position == - 1 ) return ; int x = textArea . offsetToX ( physicalLine , position ) ; gfx . setColor ( bracketHighlightColor ) ; gfx . drawRect ( x , y , fm . charWidth ( '(' ) - 1 , fm . getHeight ( ) - 1 ) ; } private void paintCaret ( Graphics gfx , int physicalLine , int y ) { int offset = textArea . getCaretPosition ( ) - textArea . getLineStartOffset ( physicalLine ) ; int caretX = textArea . offsetToX ( physicalLine , offset ) ; int height = fm . getHeight ( ) ; gfx . setColor ( caretColor ) ; if ( textArea . isOverwriteEnabled ( ) ) { gfx . drawLine ( caretX , y + height - 1 , caretX + fm . charWidth ( 'w' ) , y + height - 1 ) ; } else if ( blockCaret ) { if ( textArea . selection == null && lineHighlight ) gfx . setXORMode ( lineHighlightColor ) ; else gfx . setXORMode ( getBackground ( ) ) ; gfx . fillRect ( caretX , y , fm . charWidth ( 'w' ) , height ) ; gfx . setPaintMode ( ) ; } else { gfx . drawLine ( caretX , y , caretX , y + height - 1 ) ; } } private void paintSelection ( Graphics gfx , int physicalLine , int y , Selection s ) { if ( physicalLine < s . startLine || physicalLine > s . endLine ) return ; int lineStart = textArea . getLineStartOffset ( physicalLine ) ; int x1 , x2 ; if ( s instanceof Selection . Rect ) { int lineLen = textArea . getLineLength ( physicalLine ) ; x1 = textArea . offsetToX ( physicalLine , Math . min ( lineLen , s . start - textArea . getLineStartOffset ( s . startLine ) ) ) ; x2 = textArea . offsetToX ( physicalLine , Math . min ( lineLen , s . end - textArea . getLineStartOffset ( s . endLine ) ) ) ; if ( x1 > x2 ) { int tmp = x2 ; x2 = x1 ; x1 = tmp ; } } else if ( s . startLine == s . endLine ) { x1 = textArea . offsetToX ( physicalLine , s . start - lineStart ) ; x2 = textArea . offsetToX ( physicalLine , s . end - lineStart ) ; } else if ( physicalLine == s . startLine ) { x1 = textArea . offsetToX ( physicalLine , s . start - lineStart ) ; x2 = getWidth ( ) ; } else if ( physicalLine == s . endLine ) { x1 = 0 ; x2 = textArea . offsetToX ( physicalLine , s . end - lineStart ) ; } else { x1 = 0 ; x2 = getWidth ( ) ; } if ( x1 == x2 ) x2 ++ ; gfx . fillRect ( x1 , y , x2 - x1 , fm . getHeight ( ) ) ; } } 	1	['45', '4', '0', '15', '122', '462', '8', '8', '39', '0.899521531', '1143', '1', '3', '0.936231884', '0.136752137', '3', '18', '23.97777778', '12', '2.0889', '16']
package org . gjt . sp . jedit . syntax ; public class ParserRuleFactory { public static final ParserRule createSpanRule ( String begin , String end , byte id , boolean noLineBreak , boolean atLineStart , boolean excludeMatch , boolean noWordBreak ) { int ruleAction = TokenMarker . SPAN | ( ( noLineBreak ) ? TokenMarker . NO_LINE_BREAK : 0 ) | ( ( atLineStart ) ? TokenMarker . AT_LINE_START : 0 ) | ( ( excludeMatch ) ? TokenMarker . EXCLUDE_MATCH : 0 ) | ( ( noWordBreak ) ? TokenMarker . NO_WORD_BREAK : 0 ) ; String [ ] strings = new String [ 2 ] ; strings [ 0 ] = begin ; strings [ 1 ] = end ; int [ ] ruleSeqLengths = getStringLengthArray ( strings ) ; char [ ] ruleChars = getCharArray ( strings , ruleSeqLengths ) ; return new ParserRule ( ruleChars , ruleSeqLengths , ruleAction , id ) ; } public static final ParserRule createDelegateSpanRule ( String begin , String end , String delegateSet , byte id , boolean noLineBreak , boolean atLineStart , boolean excludeMatch , boolean noWordBreak ) { int ruleAction = TokenMarker . SPAN | TokenMarker . DELEGATE | ( ( noLineBreak ) ? TokenMarker . NO_LINE_BREAK : 0 ) | ( ( atLineStart ) ? TokenMarker . AT_LINE_START : 0 ) | ( ( excludeMatch ) ? TokenMarker . EXCLUDE_MATCH : 0 ) | ( ( noWordBreak ) ? TokenMarker . NO_WORD_BREAK : 0 ) ; String [ ] strings = new String [ 3 ] ; strings [ 0 ] = begin ; strings [ 1 ] = end ; strings [ 2 ] = delegateSet ; int [ ] ruleSeqLengths = getStringLengthArray ( strings ) ; char [ ] ruleChars = getCharArray ( strings , ruleSeqLengths ) ; return new ParserRule ( ruleChars , ruleSeqLengths , ruleAction , id ) ; } public static final ParserRule createEOLSpanRule ( String seq , byte id , boolean atLineStart , boolean excludeMatch ) { int ruleAction = TokenMarker . EOL_SPAN | ( ( atLineStart ) ? TokenMarker . AT_LINE_START : 0 ) | ( ( excludeMatch ) ? TokenMarker . EXCLUDE_MATCH : 0 ) ; String [ ] strings = new String [ 1 ] ; strings [ 0 ] = seq ; int [ ] ruleSeqLengths = new int [ 1 ] ; char [ ] ruleChars ; if ( seq != null ) { ruleSeqLengths [ 0 ] = seq . length ( ) ; ruleChars = seq . toCharArray ( ) ; } else { ruleChars = new char [ 0 ] ; } return new ParserRule ( ruleChars , ruleSeqLengths , ruleAction , id ) ; } public static final ParserRule createMarkPreviousRule ( String seq , byte id , boolean atLineStart , boolean excludeMatch ) { int ruleAction = TokenMarker . MARK_PREVIOUS | ( ( atLineStart ) ? TokenMarker . AT_LINE_START : 0 ) | ( ( excludeMatch ) ? TokenMarker . EXCLUDE_MATCH : 0 ) ; String [ ] strings = new String [ 1 ] ; strings [ 0 ] = seq ; int [ ] ruleSeqLengths = new int [ 1 ] ; char [ ] ruleChars ; if ( seq != null ) { ruleSeqLengths [ 0 ] = seq . length ( ) ; ruleChars = seq . toCharArray ( ) ; } else { ruleChars = new char [ 0 ] ; } return new ParserRule ( ruleChars , ruleSeqLengths , ruleAction , id ) ; } public static final ParserRule createMarkFollowingRule ( String seq , byte id , boolean atLineStart , boolean excludeMatch ) { int ruleAction = TokenMarker . MARK_FOLLOWING | ( ( atLineStart ) ? TokenMarker . AT_LINE_START : 0 ) | ( ( excludeMatch ) ? TokenMarker . EXCLUDE_MATCH : 0 ) ; String [ ] strings = new String [ 1 ] ; strings [ 0 ] = seq ; int [ ] ruleSeqLengths = new int [ 1 ] ; char [ ] ruleChars ; if ( seq != null ) { ruleSeqLengths [ 0 ] = seq . length ( ) ; ruleChars = seq . toCharArray ( ) ; } else { ruleChars = new char [ 0 ] ; } return new ParserRule ( ruleChars , ruleSeqLengths , ruleAction , id ) ; } public static final ParserRule createSequenceRule ( String seq , byte id , boolean atLineStart ) { int ruleAction = ( ( atLineStart ) ? TokenMarker . AT_LINE_START : 0 ) ; String [ ] strings = new String [ 1 ] ; strings [ 0 ] = seq ; int [ ] ruleSeqLengths = new int [ 1 ] ; char [ ] ruleChars ; if ( seq != null ) { ruleSeqLengths [ 0 ] = seq . length ( ) ; ruleChars = seq . toCharArray ( ) ; } else { ruleChars = new char [ 0 ] ; } return new ParserRule ( ruleChars , ruleSeqLengths , ruleAction , id ) ; } public static final ParserRule createEscapeRule ( String seq ) { int ruleAction = TokenMarker . IS_ESCAPE ; String [ ] strings = new String [ 1 ] ; strings [ 0 ] = seq ; int [ ] ruleSeqLengths = new int [ 1 ] ; char [ ] ruleChars ; if ( seq != null ) { ruleSeqLengths [ 0 ] = seq . length ( ) ; ruleChars = seq . toCharArray ( ) ; } else { ruleChars = new char [ 0 ] ; } return new ParserRule ( ruleChars , ruleSeqLengths , ruleAction , Token . NULL ) ; } public static final ParserRule createWhitespaceRule ( String seq ) { int ruleAction = TokenMarker . WHITESPACE ; String [ ] strings = new String [ 1 ] ; strings [ 0 ] = seq ; int [ ] ruleSeqLengths = new int [ 1 ] ; char [ ] ruleChars ; if ( seq != null ) { ruleSeqLengths [ 0 ] = seq . length ( ) ; ruleChars = seq . toCharArray ( ) ; } else { ruleChars = new char [ 0 ] ; } return new ParserRule ( ruleChars , ruleSeqLengths , ruleAction , Token . NULL ) ; } private static char [ ] getCharArray ( String [ ] strings , int [ ] lengthArray ) { if ( lengthArray == null || lengthArray . length == 0 ) return new char [ 0 ] ; char [ ] chars ; int charArrayLength = 0 ; for ( int i = 0 ; i < lengthArray . length ; i ++ ) { charArrayLength += lengthArray [ i ] ; } chars = new char [ charArrayLength ] ; int copyOffset = 0 ; for ( int i = 0 ; i < strings . length ; i ++ ) { if ( strings [ i ] != null ) { System . arraycopy ( strings [ i ] . toCharArray ( ) , 0 , chars , copyOffset , lengthArray [ i ] ) ; copyOffset += lengthArray [ i ] ; } } return chars ; } private static int [ ] getStringLengthArray ( String [ ] strings ) { int [ ] stringLengthArray ; if ( strings == null ) return new int [ 0 ] ; stringLengthArray = new int [ strings . length ] ; for ( int i = 0 ; i < strings . length ; i ++ ) { if ( strings [ i ] != null ) { stringLengthArray [ i ] = strings [ i ] . length ( ) ; } } return stringLengthArray ; } } 	0	['11', '1', '0', '3', '16', '55', '2', '1', '9', '2', '456', '0', '0', '0', '0.363636364', '0', '0', '40.45454545', '6', '3.5455', '0']
package org . gjt . sp . jedit ; import javax . swing . text . BadLocationException ; import javax . swing . text . Position ; import org . gjt . sp . util . Log ; public class Marker { public char getShortcut ( ) { return shortcut ; } public void setShortcut ( char shortcut ) { this . shortcut = shortcut ; } public int getPosition ( ) { return ( position == null ? pos : position . getOffset ( ) ) ; } Marker ( Buffer buffer , char shortcut , int position ) { this . buffer = buffer ; this . shortcut = shortcut ; this . pos = position ; } void createPosition ( ) { try { position = buffer . createPosition ( pos ) ; } catch ( BadLocationException bl ) { Log . log ( Log . ERROR , this , bl ) ; } } void removePosition ( ) { position = null ; } private Buffer buffer ; private char shortcut ; private int pos ; private Position position ; } 	1	['6', '1', '0', '8', '10', '0', '7', '2', '3', '0.65', '57', '1', '1', '0', '0.416666667', '0', '0', '7.833333333', '2', '1', '2']
package bsh ; class TokenMgrError extends Error { static final int LEXICAL_ERROR = 0 ; static final int STATIC_LEXER_ERROR = 1 ; static final int INVALID_LEXICAL_STATE = 2 ; static final int LOOP_DETECTED = 3 ; int errorCode ; protected static final String addEscapes ( String str ) { StringBuffer retval = new StringBuffer ( ) ; char ch ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { switch ( str . charAt ( i ) ) { case 0 : continue ; case '\b' : retval . append ( "\\b" ) ; continue ; case '\t' : retval . append ( "\\t" ) ; continue ; case '\n' : retval . append ( "\\n" ) ; continue ; case '\f' : retval . append ( "\\f" ) ; continue ; case '\r' : retval . append ( "\\r" ) ; continue ; case '\"' : retval . append ( "\\\"" ) ; continue ; case '\'' : retval . append ( "\\\'" ) ; continue ; case '\\' : retval . append ( "\\\\" ) ; continue ; default : if ( ( ch = str . charAt ( i ) ) < 0x20 || ch > 0x7e ) { String s = "0000" + Integer . toString ( ch , 16 ) ; retval . append ( "\\u" + s . substring ( s . length ( ) - 4 , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . toString ( ) ; } private static final String LexicalError ( boolean EOFSeen , int lexState , int errorLine , int errorColumn , String errorAfter , char curChar ) { return ( "Lexical error at line " + errorLine + ", column " + errorColumn + ".  Encountered: " + ( EOFSeen ? "<EOF> " : ( "\"" + addEscapes ( String . valueOf ( curChar ) ) + "\"" ) + " (" + ( int ) curChar + "), " ) + "after : \"" + addEscapes ( errorAfter ) + "\"" ) ; } public String getMessage ( ) { return super . getMessage ( ) ; } public TokenMgrError ( ) { } public TokenMgrError ( String message , int reason ) { super ( message ) ; errorCode = reason ; } public TokenMgrError ( boolean EOFSeen , int lexState , int errorLine , int errorColumn , String errorAfter , char curChar , int reason ) { this ( LexicalError ( EOFSeen , lexState , errorLine , errorColumn , errorAfter , curChar ) , reason ) ; } } 	0	['6', '3', '0', '2', '19', '15', '2', '0', '4', '1.12', '184', '0', '0', '0.85', '0.5', '1', '1', '28.83333333', '14', '2.8333', '0']
package org . gjt . sp . jedit . pluginmgr ; import javax . swing . border . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . * ; public class PluginManagerProgress extends JDialog { public PluginManagerProgress ( JDialog dialog , String caption , Roster roster ) { super ( JOptionPane . getFrameForComponent ( dialog ) , caption , true ) ; this . roster = roster ; JPanel content = new JPanel ( new BorderLayout ( 12 , 12 ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; globalProgress = new JProgressBar ( ) ; globalProgress . setStringPainted ( true ) ; globalProgress . setString ( caption ) ; count = roster . getOperationCount ( ) ; globalProgress . setMaximum ( count ) ; content . add ( BorderLayout . NORTH , globalProgress ) ; localProgress = new JProgressBar ( ) ; localProgress . setStringPainted ( true ) ; content . add ( BorderLayout . CENTER , localProgress ) ; stop = new JButton ( jEdit . getProperty ( "plugin-manager.progress.stop" ) ) ; stop . addActionListener ( new ActionHandler ( ) ) ; JPanel panel = new JPanel ( ) ; panel . setLayout ( new BoxLayout ( panel , BoxLayout . X_AXIS ) ) ; panel . add ( Box . createGlue ( ) ) ; panel . add ( stop ) ; panel . add ( Box . createGlue ( ) ) ; content . add ( BorderLayout . SOUTH , panel ) ; addWindowListener ( new WindowHandler ( ) ) ; pack ( ) ; Dimension screen = getToolkit ( ) . getScreenSize ( ) ; Dimension size = getSize ( ) ; size . width = Math . max ( size . width , 500 ) ; setSize ( size ) ; setLocationRelativeTo ( dialog ) ; show ( ) ; } public void removing ( String plugin ) { String [ ] args = { plugin } ; showMessage ( jEdit . getProperty ( "plugin-manager.progress.removing" , args ) ) ; stop . setEnabled ( true ) ; } public void downloading ( String plugin ) { String [ ] args = { plugin } ; showMessage ( jEdit . getProperty ( "plugin-manager.progress.downloading" , args ) ) ; stop . setEnabled ( true ) ; } public void installing ( String plugin ) { String [ ] args = { plugin } ; showMessage ( jEdit . getProperty ( "plugin-manager.progress.installing" , args ) ) ; stop . setEnabled ( false ) ; } public void setMaximum ( final int total ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { localProgress . setMaximum ( total ) ; } } ) ; } public void setValue ( final int value ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { localProgress . setValue ( value ) ; } } ) ; } public void done ( final boolean ok ) { this . ok |= ok ; try { if ( ! ok || done == count ) { SwingUtilities . invokeAndWait ( new Runnable ( ) { public void run ( ) { dispose ( ) ; if ( ok ) { GUIUtilities . message ( PluginManagerProgress . this , "plugin-manager.done" , null ) ; } else { } } } ) ; } else { SwingUtilities . invokeAndWait ( new Runnable ( ) { public void run ( ) { globalProgress . setValue ( done ++ ) ; localProgress . setValue ( 0 ) ; } } ) ; } } catch ( Exception e ) { } } public boolean isOK ( ) { return ok ; } private Thread thread ; private JProgressBar globalProgress , localProgress ; private JButton stop ; private int count ; private int done = 1 ; private boolean ok ; private Roster roster ; private void showMessage ( final String msg ) { try { SwingUtilities . invokeAndWait ( new Runnable ( ) { public void run ( ) { localProgress . setString ( msg ) ; } } ) ; } catch ( Exception e ) { } Thread . yield ( ) ; } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { if ( evt . getSource ( ) == stop ) { thread . interrupt ( ) ; dispose ( ) ; } } } class WindowHandler extends WindowAdapter { boolean done ; public void windowActivated ( WindowEvent evt ) { if ( done ) return ; done = true ; thread = new RosterThread ( ) ; thread . start ( ) ; } public void windowClosing ( WindowEvent evt ) { thread . interrupt ( ) ; dispose ( ) ; } } class RosterThread extends Thread { RosterThread ( ) { super ( "Plugin manager thread" ) ; } public void run ( ) { roster . performOperations ( PluginManagerProgress . this ) ; } } } 	1	['17', '6', '0', '14', '59', '94', '13', '9', '8', '0.8984375', '334', '1', '1', '0.976011994', '0.213235294', '3', '6', '18.17647059', '5', '1.3529', '1']
package bsh ; class BSHThrowStatement extends SimpleNode { BSHThrowStatement ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { Object obj = ( ( SimpleNode ) jjtGetChild ( 0 ) ) . eval ( callstack , interpreter ) ; if ( ! ( obj instanceof Exception ) ) throw new EvalError ( "Expression in 'throw' must be Exception type" , this ) ; throw new TargetError ( ( Exception ) obj , this ) ; } } 	0	['2', '2', '0', '7', '7', '1', '1', '6', '1', '2', '30', '0', '0', '0.947368421', '0.625', '1', '1', '14', '1', '0.5', '0']
package org . gjt . sp . jedit . io ; import java . util . Enumeration ; import java . util . Hashtable ; import javax . swing . SwingUtilities ; import java . awt . Component ; import java . util . Vector ; import org . gjt . sp . jedit . msg . VFSUpdate ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; import org . gjt . sp . util . WorkThreadPool ; public class VFSManager { public static void start ( ) { ioThreadPool . start ( ) ; } public static WorkThreadPool getIOThreadPool ( ) { return ioThreadPool ; } public static VFS getFileVFS ( ) { return fileVFS ; } public static VFS getUrlVFS ( ) { return urlVFS ; } public static VFS getVFSByName ( String name ) { return ( VFS ) vfsHash . get ( name ) ; } public static VFS getVFSForProtocol ( String protocol ) { if ( protocol . equals ( "file" ) ) return fileVFS ; else { VFS vfs = ( VFS ) protocolHash . get ( protocol ) ; if ( vfs != null ) return vfs ; else return urlVFS ; } } public static VFS getVFSForPath ( String path ) { if ( MiscUtilities . isURL ( path ) ) return getVFSForProtocol ( MiscUtilities . getProtocolOfURL ( path ) ) ; else return fileVFS ; } public static void registerVFS ( String protocol , VFS vfs ) { Log . log ( Log . DEBUG , VFSManager . class , "Registered " + vfs . getName ( ) + " filesystem for " + protocol + " protocol" ) ; vfsHash . put ( vfs . getName ( ) , vfs ) ; protocolHash . put ( protocol , vfs ) ; } public static Enumeration getFilesystems ( ) { return vfsHash . elements ( ) ; } public static void waitForRequests ( ) { ioThreadPool . waitForRequests ( ) ; } public static boolean errorOccurred ( ) { return error ; } public static int getRequestCount ( ) { return ioThreadPool . getRequestCount ( ) ; } public static void runInAWTThread ( Runnable run ) { ioThreadPool . addWorkRequest ( run , true ) ; } public static void runInWorkThread ( Runnable run ) { ioThreadPool . addWorkRequest ( run , false ) ; } public static void error ( final Component comp , final String error , final Object [ ] args ) { if ( SwingUtilities . isEventDispatchThread ( ) ) { GUIUtilities . error ( comp , error , args ) ; return ; } VFSManager . error = true ; runInAWTThread ( new Runnable ( ) { public void run ( ) { VFSManager . error = false ; if ( comp == null || ! comp . isShowing ( ) ) GUIUtilities . error ( null , error , args ) ; else GUIUtilities . error ( comp , error , args ) ; } } ) ; } public static void sendVFSUpdate ( VFS vfs , String path , boolean parent ) { if ( parent ) { sendVFSUpdate ( vfs , vfs . getParentOfPath ( path ) , false ) ; sendVFSUpdate ( vfs , path , false ) ; } else { if ( path . length ( ) != 1 && ( path . endsWith ( "/" ) || path . endsWith ( java . io . File . separator ) ) ) path = path . substring ( 0 , path . length ( ) - 1 ) ; synchronized ( vfsUpdateLock ) { for ( int i = 0 ; i < vfsUpdates . size ( ) ; i ++ ) { VFSUpdate msg = ( VFSUpdate ) vfsUpdates . elementAt ( i ) ; if ( msg . getPath ( ) . equals ( path ) ) { return ; } } vfsUpdates . addElement ( new VFSUpdate ( path ) ) ; if ( vfsUpdates . size ( ) == 1 ) { VFSManager . runInAWTThread ( new SendVFSUpdatesSafely ( ) ) ; } } } } static class SendVFSUpdatesSafely implements Runnable { public void run ( ) { synchronized ( vfsUpdateLock ) { for ( int i = 0 ; i < vfsUpdates . size ( ) ; i ++ ) { EditBus . send ( ( VFSUpdate ) vfsUpdates . elementAt ( i ) ) ; } vfsUpdates . removeAllElements ( ) ; } } } private static WorkThreadPool ioThreadPool ; private static VFS fileVFS ; private static VFS urlVFS ; private static Hashtable vfsHash ; private static Hashtable protocolHash ; private static boolean error ; private static Object vfsUpdateLock ; private static Vector vfsUpdates ; static { int count ; try { count = Integer . parseInt ( jEdit . getProperty ( "ioThreadCount" ) ) ; } catch ( NumberFormatException nf ) { count = 4 ; } ioThreadPool = new WorkThreadPool ( "jEdit I/O" , count ) ; fileVFS = new FileVFS ( ) ; urlVFS = new UrlVFS ( ) ; vfsHash = new Hashtable ( ) ; protocolHash = new Hashtable ( ) ; vfsUpdateLock = new Object ( ) ; vfsUpdates = new Vector ( ) ; registerVFS ( FavoritesVFS . PROTOCOL , new FavoritesVFS ( ) ) ; registerVFS ( FileRootsVFS . PROTOCOL , new FileRootsVFS ( ) ) ; } private VFSManager ( ) { } } 	1	['23', '1', '0', '39', '64', '159', '33', '13', '16', '0.858585859', '300', '1', '3', '0', '0.103896104', '0', '0', '11.65217391', '9', '1.4783', '2']
package bsh ; class BSHTernaryExpression extends SimpleNode { BSHTernaryExpression ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { SimpleNode cond = ( SimpleNode ) jjtGetChild ( 0 ) , evalTrue = ( SimpleNode ) jjtGetChild ( 1 ) , evalFalse = ( SimpleNode ) jjtGetChild ( 2 ) ; if ( BSHIfStatement . evaluateCondition ( cond , callstack , interpreter ) ) return evalTrue . eval ( callstack , interpreter ) ; else return evalFalse . eval ( callstack , interpreter ) ; } } 	0	['2', '2', '0', '7', '6', '1', '1', '6', '1', '2', '36', '0', '0', '0.947368421', '0.625', '1', '1', '17', '1', '0.5', '0']
package org . gjt . sp . jedit . pluginmgr ; import javax . swing . border . EmptyBorder ; import javax . swing . event . * ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . util . Vector ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . * ; class InstallPluginsDialog extends EnhancedDialog { static final int INSTALL = 0 ; static final int UPDATE = 1 ; InstallPluginsDialog ( JDialog dialog , Vector model , int mode ) { super ( JOptionPane . getFrameForComponent ( dialog ) , ( mode == INSTALL ? jEdit . getProperty ( "install-plugins.title" ) : jEdit . getProperty ( "update-plugins.title" ) ) , true ) ; JPanel content = new JPanel ( new BorderLayout ( ) ) ; content . setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; setContentPane ( content ) ; JLabel label = new JLabel ( jEdit . getProperty ( "install-plugins.caption" ) ) ; label . setBorder ( new EmptyBorder ( 0 , 0 , 6 , 0 ) ) ; content . add ( BorderLayout . NORTH , label ) ; JPanel panel = new JPanel ( new BorderLayout ( ) ) ; panel . setBorder ( new EmptyBorder ( 0 , 0 , 12 , 0 ) ) ; plugins = new JCheckBoxList ( model ) ; plugins . getSelectionModel ( ) . addListSelectionListener ( new ListHandler ( ) ) ; JScrollPane scroller = new JScrollPane ( plugins ) ; Dimension dim = scroller . getPreferredSize ( ) ; dim . height = 120 ; scroller . setPreferredSize ( dim ) ; panel . add ( BorderLayout . CENTER , scroller ) ; JPanel panel2 = new JPanel ( new BorderLayout ( ) ) ; panel2 . setBorder ( new EmptyBorder ( 6 , 0 , 0 , 0 ) ) ; JPanel labelBox = new JPanel ( new GridLayout ( ( mode == UPDATE ? 6 : 5 ) , 1 , 0 , 3 ) ) ; labelBox . setBorder ( new EmptyBorder ( 0 , 0 , 3 , 12 ) ) ; labelBox . add ( new JLabel ( jEdit . getProperty ( "install-plugins" + ".info.name" ) , SwingConstants . RIGHT ) ) ; labelBox . add ( new JLabel ( jEdit . getProperty ( "install-plugins" + ".info.author" ) , SwingConstants . RIGHT ) ) ; labelBox . add ( new JLabel ( jEdit . getProperty ( "install-plugins" + ".info.latest-version" ) , SwingConstants . RIGHT ) ) ; if ( mode == UPDATE ) { labelBox . add ( new JLabel ( jEdit . getProperty ( "install-plugins" + ".info.installed-version" ) , SwingConstants . RIGHT ) ) ; } labelBox . add ( new JLabel ( jEdit . getProperty ( "install-plugins" + ".info.updated" ) , SwingConstants . RIGHT ) ) ; labelBox . add ( new JLabel ( jEdit . getProperty ( "install-plugins" + ".info.description" ) , SwingConstants . RIGHT ) ) ; panel2 . add ( BorderLayout . WEST , labelBox ) ; JPanel valueBox = new JPanel ( new GridLayout ( ( mode == UPDATE ? 6 : 5 ) , 1 , 0 , 3 ) ) ; valueBox . setBorder ( new EmptyBorder ( 0 , 0 , 3 , 0 ) ) ; valueBox . add ( name = new JLabel ( ) ) ; valueBox . add ( author = new JLabel ( ) ) ; valueBox . add ( latestVersion = new JLabel ( ) ) ; if ( mode == UPDATE ) { valueBox . add ( installedVersion = new JLabel ( ) ) ; } valueBox . add ( updated = new JLabel ( ) ) ; valueBox . add ( Box . createGlue ( ) ) ; panel2 . add ( BorderLayout . CENTER , valueBox ) ; JPanel panel3 = new JPanel ( new BorderLayout ( 0 , 3 ) ) ; description = new JTextArea ( 6 , 30 ) ; description . setEditable ( false ) ; description . setLineWrap ( true ) ; description . setWrapStyleWord ( true ) ; panel3 . add ( BorderLayout . NORTH , new JScrollPane ( description ) ) ; if ( mode == INSTALL ) { JPanel panel4 = new JPanel ( new BorderLayout ( 0 , 3 ) ) ; ButtonGroup grp = new ButtonGroup ( ) ; installUser = new JRadioButton ( ) ; String settings = jEdit . getSettingsDirectory ( ) ; if ( settings == null ) { settings = jEdit . getProperty ( "install-plugins.none" ) ; installUser . setEnabled ( false ) ; } else { settings = MiscUtilities . constructPath ( settings , "jars" ) ; installUser . setEnabled ( true ) ; } String [ ] args = { settings } ; installUser . setText ( jEdit . getProperty ( "install-plugins.user" , args ) ) ; grp . add ( installUser ) ; panel4 . add ( BorderLayout . CENTER , installUser ) ; installSystem = new JRadioButton ( ) ; String jEditHome = jEdit . getJEditHome ( ) ; if ( jEditHome == null ) { jEditHome = jEdit . getProperty ( "install-plugins.none" ) ; installSystem . setEnabled ( false ) ; } else { jEditHome = MiscUtilities . constructPath ( jEditHome , "jars" ) ; installSystem . setEnabled ( true ) ; } args [ 0 ] = jEditHome ; installSystem . setText ( jEdit . getProperty ( "install-plugins.system" , args ) ) ; grp . add ( installSystem ) ; panel4 . add ( BorderLayout . SOUTH , installSystem ) ; if ( installUser . isEnabled ( ) ) installUser . setSelected ( true ) ; else installSystem . setSelected ( true ) ; panel3 . add ( BorderLayout . CENTER , panel4 ) ; } panel3 . add ( BorderLayout . SOUTH , downloadSource = new JCheckBox ( jEdit . getProperty ( "install-plugins.downloadSource" ) ) ) ; downloadSource . setSelected ( jEdit . getBooleanProperty ( "install-plugins" + ".downloadSource.value" ) ) ; panel2 . add ( BorderLayout . SOUTH , panel3 ) ; panel . add ( BorderLayout . SOUTH , panel2 ) ; content . add ( BorderLayout . CENTER , panel ) ; Box box = new Box ( BoxLayout . X_AXIS ) ; box . add ( Box . createGlue ( ) ) ; install = new JButton ( jEdit . getProperty ( "install-plugins.install" ) ) ; install . setEnabled ( false ) ; getRootPane ( ) . setDefaultButton ( install ) ; install . addActionListener ( new ActionHandler ( ) ) ; box . add ( install ) ; box . add ( Box . createHorizontalStrut ( 6 ) ) ; cancel = new JButton ( jEdit . getProperty ( "common.cancel" ) ) ; cancel . addActionListener ( new ActionHandler ( ) ) ; box . add ( cancel ) ; box . add ( Box . createHorizontalStrut ( 6 ) ) ; box . add ( Box . createGlue ( ) ) ; content . add ( BorderLayout . SOUTH , box ) ; pack ( ) ; setLocationRelativeTo ( dialog ) ; show ( ) ; } public void ok ( ) { jEdit . setBooleanProperty ( "install-plugins.downloadSource.value" , downloadSource . isSelected ( ) ) ; dispose ( ) ; } public void cancel ( ) { cancelled = true ; dispose ( ) ; } void installPlugins ( Roster roster ) { if ( cancelled ) return ; String installDirectory ; if ( installUser == null || installUser . isSelected ( ) ) { installDirectory = MiscUtilities . constructPath ( jEdit . getSettingsDirectory ( ) , "jars" ) ; } else { installDirectory = MiscUtilities . constructPath ( jEdit . getJEditHome ( ) , "jars" ) ; } Object [ ] selected = plugins . getCheckedValues ( ) ; for ( int i = 0 ; i < selected . length ; i ++ ) { PluginList . Plugin plugin = ( PluginList . Plugin ) selected [ i ] ; plugin . install ( roster , installDirectory , downloadSource . isSelected ( ) ) ; } } private JCheckBoxList plugins ; private JLabel name ; private JLabel author ; private JLabel latestVersion ; private JLabel installedVersion ; private JLabel updated ; private JTextArea description ; private JRadioButton installUser ; private JRadioButton installSystem ; private JCheckBox downloadSource ; private JButton install ; private JButton cancel ; private boolean cancelled ; private Thread thread ; class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { if ( evt . getSource ( ) == install ) ok ( ) ; else cancel ( ) ; } } class ListHandler implements ListSelectionListener { public void valueChanged ( ListSelectionEvent evt ) { Object selected = plugins . getSelectedValue ( ) ; if ( selected instanceof PluginList . Plugin ) { install . setEnabled ( true ) ; PluginList . Plugin plugin = ( PluginList . Plugin ) selected ; PluginList . Branch branch = plugin . getCompatibleBranch ( ) ; name . setText ( plugin . name ) ; author . setText ( plugin . author ) ; if ( branch . obsolete ) latestVersion . setText ( jEdit . getProperty ( "install-plugins.info.obsolete" ) ) ; else latestVersion . setText ( branch . version ) ; if ( installedVersion != null ) installedVersion . setText ( plugin . installedVersion ) ; updated . setText ( branch . date ) ; StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < branch . deps . size ( ) ; i ++ ) { PluginList . Dependency dep = ( PluginList . Dependency ) branch . deps . elementAt ( i ) ; if ( dep . what . equals ( "plugin" ) && ! dep . isSatisfied ( ) ) { if ( buf . length ( ) != 0 ) buf . append ( ", " ) ; buf . append ( dep . plugin ) ; } } description . setText ( plugin . description + ( buf . length ( ) == 0 ? "" : jEdit . getProperty ( "install-plugins.info" + ".also-install" ) + buf . toString ( ) + ( branch . obsolete ? jEdit . getProperty ( "install-plugins.info.obsolete-text" ) : "" ) ) ) ; } else { install . setEnabled ( false ) ; name . setText ( null ) ; author . setText ( null ) ; latestVersion . setText ( null ) ; if ( installedVersion != null ) installedVersion . setText ( null ) ; updated . setText ( null ) ; description . setText ( null ) ; } } } } 	1	['12', '7', '0', '9', '72', '40', '3', '8', '2', '0.943181818', '687', '0.875', '1', '0.983433735', '0.222222222', '1', '3', '54.91666667', '5', '1.25', '4']
package org . gjt . sp . jedit . search ; import gnu . regexp . RE ; import java . io . * ; import java . util . Vector ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class DirectoryListSet extends BufferListSet { public DirectoryListSet ( String directory , String glob , boolean recurse ) { super ( listFiles ( directory , glob , recurse ) ) ; this . directory = directory ; this . glob = glob ; this . recurse = recurse ; } public String getDirectory ( ) { return directory ; } public String getFileFilter ( ) { return glob ; } public boolean isRecursive ( ) { return recurse ; } public String getCode ( ) { return "new DirectoryListSet(\"" + MiscUtilities . charsToEscapes ( directory ) + "\",\"" + MiscUtilities . charsToEscapes ( glob ) + "\"," + recurse + ")" ; } private String directory ; private String glob ; private boolean recurse ; private static Vector listFiles ( String directory , String glob , boolean recurse ) { Log . log ( Log . DEBUG , DirectoryListSet . class , "Searching in " + directory ) ; Vector files = new Vector ( 50 ) ; RE filter ; try { filter = new RE ( MiscUtilities . globToRE ( glob ) ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , DirectoryListSet . class , e ) ; return files ; } listFiles ( new Vector ( ) , files , new File ( directory ) , filter , recurse ) ; return files ; } private static void listFiles ( Vector stack , Vector files , File directory , RE filter , boolean recurse ) { if ( stack . contains ( directory ) ) { Log . log ( Log . ERROR , DirectoryListSet . class , "Recursion in DirectoryListSet: " + directory . getPath ( ) ) ; return ; } else stack . addElement ( directory ) ; String [ ] _files = directory . list ( ) ; if ( _files == null ) return ; MiscUtilities . quicksort ( _files , new MiscUtilities . StringICaseCompare ( ) ) ; for ( int i = 0 ; i < _files . length ; i ++ ) { String name = _files [ i ] ; File file = new File ( directory , name ) ; if ( file . isDirectory ( ) ) { if ( recurse ) listFiles ( stack , files , file , filter , recurse ) ; } else { if ( ! filter . isMatch ( name ) ) continue ; Log . log ( Log . DEBUG , DirectoryListSet . class , file . getPath ( ) ) ; String canonPath ; try { canonPath = file . getCanonicalPath ( ) ; } catch ( IOException io ) { canonPath = file . getPath ( ) ; } files . addElement ( canonPath ) ; } } } } 	0	['8', '2', '0', '8', '34', '12', '2', '6', '5', '0.714285714', '223', '1', '0', '0.5', '0.291666667', '0', '0', '26.375', '8', '2', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . border . EmptyBorder ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import java . io . IOException ; import java . net . URL ; import java . util . Random ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class TipOfTheDay extends EnhancedDialog { public TipOfTheDay ( View view ) { super ( view , jEdit . getProperty ( "tip.title" ) , false ) ; setContentPane ( new TipPanel ( ) ) ; setDefaultCloseOperation ( DISPOSE_ON_CLOSE ) ; pack ( ) ; setLocationRelativeTo ( view ) ; show ( ) ; } public void ok ( ) { dispose ( ) ; } public void cancel ( ) { dispose ( ) ; } class TipPanel extends JPanel { TipPanel ( ) { super ( new BorderLayout ( 12 , 12 ) ) ; setBorder ( new EmptyBorder ( 12 , 12 , 12 , 12 ) ) ; JLabel label = new JLabel ( jEdit . getProperty ( "tip.caption" ) ) ; label . setFont ( new Font ( "SansSerif" , Font . PLAIN , 24 ) ) ; label . setForeground ( UIManager . getColor ( "Button.foreground" ) ) ; TipPanel . this . add ( BorderLayout . NORTH , label ) ; tipText = new JEditorPane ( ) ; tipText . setEditable ( false ) ; tipText . setContentType ( "text/html" ) ; nextTip ( ) ; JScrollPane scroller = new JScrollPane ( tipText ) ; scroller . setPreferredSize ( new Dimension ( 150 , 150 ) ) ; TipPanel . this . add ( BorderLayout . CENTER , scroller ) ; ActionHandler actionHandler = new ActionHandler ( ) ; Box buttons = new Box ( BoxLayout . X_AXIS ) ; showNextTime = new JCheckBox ( jEdit . getProperty ( "tip.show-next-time" ) , jEdit . getBooleanProperty ( "tip.show" ) ) ; showNextTime . addActionListener ( actionHandler ) ; buttons . add ( showNextTime ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; buttons . add ( Box . createGlue ( ) ) ; nextTip = new JButton ( jEdit . getProperty ( "tip.next-tip" ) ) ; nextTip . addActionListener ( actionHandler ) ; buttons . add ( nextTip ) ; buttons . add ( Box . createHorizontalStrut ( 6 ) ) ; close = new JButton ( jEdit . getProperty ( "common.close" ) ) ; close . addActionListener ( actionHandler ) ; buttons . add ( close ) ; TipOfTheDay . this . getRootPane ( ) . setDefaultButton ( close ) ; Dimension dim = nextTip . getPreferredSize ( ) ; dim . width = Math . max ( dim . width , close . getPreferredSize ( ) . width ) ; nextTip . setPreferredSize ( dim ) ; close . setPreferredSize ( dim ) ; TipPanel . this . add ( BorderLayout . SOUTH , buttons ) ; } private JCheckBox showNextTime ; private JButton nextTip , close ; private JEditorPane tipText ; private int currentTip = - 1 ; private void nextTip ( ) { int count = Integer . parseInt ( jEdit . getProperty ( "tip.count" ) ) ; int tipToShow = currentTip ; while ( tipToShow == currentTip ) tipToShow = Math . abs ( new Random ( ) . nextInt ( ) ) % count ; try { tipText . setPage ( TipOfTheDay . class . getResource ( "/org/gjt/sp/jedit/tips/tip" + tipToShow + ".html" ) ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , this , e ) ; } } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { Object source = evt . getSource ( ) ; if ( source == showNextTime ) { jEdit . setBooleanProperty ( "tip.show" , showNextTime . isSelected ( ) ) ; } else if ( source == nextTip ) nextTip ( ) ; else if ( source == close ) dispose ( ) ; } } } } 	1	['6', '7', '0', '6', '18', '13', '3', '4', '3', '0.8', '55', '1', '0', '0.992401216', '0.25', '0', '0', '8', '1', '0.8333', '2']
package bsh ; import java . lang . reflect . * ; import java . lang . reflect . InvocationHandler ; import java . io . * ; class XThis extends This { InvocationHandler invocationHandler = new Handler ( ) ; XThis ( NameSpace namespace , Interpreter declaringInterp ) { super ( namespace , declaringInterp ) ; } public String toString ( ) { return "'this' reference (XThis) to Bsh object: " + namespace . name ; } String toStringShowInts ( Class [ ] ints ) { StringBuffer sb = new StringBuffer ( toString ( ) + "\nimplements:" ) ; for ( int i = 0 ; i < ints . length ; i ++ ) sb . append ( " " + ints [ i ] . getName ( ) + ( ( ints . length > 1 ) ? "," : "" ) ) ; return sb . toString ( ) ; } public Object getInterface ( Class clas ) { return Proxy . newProxyInstance ( clas . getClassLoader ( ) , new Class [ ] { clas } , invocationHandler ) ; } class Handler implements InvocationHandler , java . io . Serializable { public Object invoke ( Object proxy , Method method , Object [ ] args ) throws EvalError { Class [ ] sig = Reflect . getTypes ( args ) ; BshMethod bmethod = namespace . getMethod ( method . getName ( ) , sig ) ; if ( bmethod != null ) return Primitive . unwrap ( bmethod . invokeDeclaredMethod ( args , declaringInterpreter , callstack , null ) ) ; bmethod = namespace . getMethod ( "invoke" , new Class [ ] { null , null } ) ; if ( bmethod != null ) return Primitive . unwrap ( bmethod . invokeDeclaredMethod ( new Object [ ] { method . getName ( ) , args } , declaringInterpreter , callstack , null ) ) ; if ( method . getName ( ) . equals ( "toString" ) ) return toStringShowInts ( proxy . getClass ( ) . getInterfaces ( ) ) ; if ( method . getName ( ) . equals ( "hashCode" ) ) return new Integer ( this . hashCode ( ) ) ; if ( method . getName ( ) . equals ( "equals" ) ) { Object obj = args [ 0 ] ; return new Boolean ( proxy == obj ) ; } throw new EvalError ( "Bsh script method: " + method . getName ( ) + " not found in namespace: " + namespace . name ) ; } } ; private synchronized void writeObject ( ObjectOutputStream s ) throws IOException { NameSpace parent = namespace . getParent ( ) ; Interpreter interpreter = declaringInterpreter ; namespace . prune ( ) ; s . defaultWriteObject ( ) ; namespace . setParent ( parent ) ; declaringInterpreter = interpreter ; } } 	0	['5', '2', '0', '4', '18', '8', '1', '4', '2', '0.75', '106', '0', '0', '0.714285714', '0.333333333', '1', '2', '20', '3', '1.2', '0']
package org . gjt . sp . jedit . pluginmgr ; import com . microstar . xml . * ; import java . io . * ; import java . net . URL ; import java . util . Hashtable ; import java . util . Vector ; import org . gjt . sp . util . Log ; import org . gjt . sp . jedit . * ; class PluginList { Vector plugins ; Hashtable pluginHash ; Vector pluginSets ; PluginList ( ) throws Exception { plugins = new Vector ( ) ; pluginHash = new Hashtable ( ) ; pluginSets = new Vector ( ) ; String path = jEdit . getProperty ( "plugin-manager.url" ) ; PluginListHandler handler = new PluginListHandler ( this , path ) ; XmlParser parser = new XmlParser ( ) ; parser . setHandler ( handler ) ; parser . parse ( null , null , new BufferedReader ( new InputStreamReader ( new URL ( path ) . openStream ( ) , "UTF8" ) ) ) ; } void addPlugin ( Plugin plugin ) { plugin . checkIfInstalled ( ) ; plugins . addElement ( plugin ) ; pluginHash . put ( plugin . name , plugin ) ; } void addPluginSet ( PluginSet set ) { pluginSets . addElement ( set ) ; } void finished ( ) { for ( int i = 0 ; i < plugins . size ( ) ; i ++ ) { Plugin plugin = ( Plugin ) plugins . elementAt ( i ) ; for ( int j = 0 ; j < plugin . branches . size ( ) ; j ++ ) { Branch branch = ( Branch ) plugin . branches . elementAt ( j ) ; for ( int k = 0 ; k < branch . deps . size ( ) ; k ++ ) { Dependency dep = ( Dependency ) branch . deps . elementAt ( k ) ; if ( dep . what . equals ( "plugin" ) ) dep . plugin = ( Plugin ) pluginHash . get ( dep . pluginName ) ; } } } } void dump ( ) { for ( int i = 0 ; i < plugins . size ( ) ; i ++ ) { System . err . println ( ( Plugin ) plugins . elementAt ( i ) ) ; System . err . println ( ) ; } } static class PluginSet { String name ; String description ; Vector plugins = new Vector ( ) ; void install ( Roster roster , String installDirectory , boolean downloadSource ) { for ( int i = 0 ; i < plugins . size ( ) ; i ++ ) { Plugin plugin = ( Plugin ) plugins . elementAt ( i ) ; if ( plugin . canBeInstalled ( ) ) { plugin . install ( roster , installDirectory , downloadSource ) ; } } } public String toString ( ) { return plugins . toString ( ) ; } } static class Plugin { String jar ; String name ; String description ; String author ; Vector branches = new Vector ( ) ; String installed ; String installedVersion ; void checkIfInstalled ( ) { EditPlugin . JAR [ ] jars = jEdit . getPluginJARs ( ) ; for ( int i = 0 ; i < jars . length ; i ++ ) { String path = jars [ i ] . getPath ( ) ; if ( ! new File ( path ) . exists ( ) ) continue ; if ( MiscUtilities . getFileName ( path ) . equals ( jar ) ) { installed = path ; EditPlugin [ ] plugins = jars [ i ] . getPlugins ( ) ; if ( plugins . length >= 1 ) { installedVersion = jEdit . getProperty ( "plugin." + plugins [ 0 ] . getClassName ( ) + ".version" ) ; } break ; } } String [ ] notLoaded = jEdit . getNotLoadedPluginJARs ( ) ; for ( int i = 0 ; i < notLoaded . length ; i ++ ) { String path = notLoaded [ i ] ; if ( MiscUtilities . getFileName ( path ) . equals ( jar ) ) { installed = path ; break ; } } } Branch getCompatibleBranch ( ) { for ( int i = 0 ; i < branches . size ( ) ; i ++ ) { Branch branch = ( Branch ) branches . elementAt ( i ) ; if ( branch . canSatisfyDependencies ( ) ) return branch ; } return null ; } boolean canBeInstalled ( ) { Branch branch = getCompatibleBranch ( ) ; return branch != null && ! branch . obsolete ; } void install ( Roster roster , String installDirectory , boolean downloadSource ) { if ( installed != null ) roster . addOperation ( new Roster . Remove ( installed ) ) ; Branch branch = getCompatibleBranch ( ) ; if ( branch . obsolete ) return ; branch . satisfyDependencies ( roster , installDirectory , downloadSource ) ; if ( installed != null ) { installDirectory = MiscUtilities . getParentOfPath ( installed ) ; } roster . addOperation ( new Roster . Install ( ( downloadSource ? branch . downloadSource : branch . download ) , installDirectory ) ) ; } public String toString ( ) { return name ; } } static class Branch { String version ; String date ; String download ; String downloadSource ; boolean obsolete ; Vector deps = new Vector ( ) ; boolean canSatisfyDependencies ( ) { for ( int i = 0 ; i < deps . size ( ) ; i ++ ) { Dependency dep = ( Dependency ) deps . elementAt ( i ) ; if ( ! dep . canSatisfy ( ) ) return false ; } return true ; } void satisfyDependencies ( Roster roster , String installDirectory , boolean downloadSource ) { for ( int i = 0 ; i < deps . size ( ) ; i ++ ) { Dependency dep = ( Dependency ) deps . elementAt ( i ) ; dep . satisfy ( roster , installDirectory , downloadSource ) ; } } public String toString ( ) { return "[version=" + version + ",download=" + download + ",obsolete=" + obsolete + ",deps=" + deps + "]" ; } } static class Dependency { String what ; String from ; String to ; String pluginName ; Plugin plugin ; Dependency ( String what , String from , String to , String pluginName ) { this . what = what ; this . from = from ; this . to = to ; this . pluginName = pluginName ; } boolean isSatisfied ( ) { if ( what . equals ( "plugin" ) ) { for ( int i = 0 ; i < plugin . branches . size ( ) ; i ++ ) { Branch branch = ( Branch ) plugin . branches . elementAt ( i ) ; if ( plugin . installedVersion != null && ( from == null || MiscUtilities . compareVersions ( plugin . installedVersion , from ) >= 0 ) && ( to == null || MiscUtilities . compareVersions ( plugin . installedVersion , to ) <= 0 ) ) { return true ; } } return false ; } else if ( what . equals ( "jdk" ) ) { String javaVersion = System . getProperty ( "java.version" ) . substring ( 0 , 3 ) ; if ( ( from == null || MiscUtilities . compareVersions ( javaVersion , from ) >= 0 ) && ( to == null || MiscUtilities . compareVersions ( javaVersion , to ) <= 0 ) ) return true ; else return false ; } else if ( what . equals ( "jedit" ) ) { String build = jEdit . getBuild ( ) ; if ( ( from == null || MiscUtilities . compareVersions ( build , from ) >= 0 ) && ( to == null || MiscUtilities . compareVersions ( build , to ) <= 0 ) ) return true ; else return false ; } else { Log . log ( Log . ERROR , this , "Invalid dependency: " + what ) ; return false ; } } boolean canSatisfy ( ) { return ( what . equals ( "plugin" ) || isSatisfied ( ) ) ; } void satisfy ( Roster roster , String installDirectory , boolean downloadSource ) { if ( what . equals ( "plugin" ) ) { for ( int i = 0 ; i < plugin . branches . size ( ) ; i ++ ) { Branch branch = ( Branch ) plugin . branches . elementAt ( i ) ; if ( ( plugin . installedVersion == null || MiscUtilities . compareVersions ( plugin . installedVersion , branch . version ) < 0 ) && ( from == null || MiscUtilities . compareVersions ( branch . version , from ) >= 0 ) && ( to == null || MiscUtilities . compareVersions ( branch . version , to ) <= 0 ) ) { plugin . install ( roster , installDirectory , downloadSource ) ; return ; } } } } public String toString ( ) { return "[what=" + what + ",from=" + from + ",to=" + to + ",plugin=" + plugin + "]" ; } } } 	1	['5', '1', '0', '11', '26', '0', '4', '8', '0', '0.5', '155', '0', '0', '0', '0.466666667', '0', '0', '29.4', '5', '1.8', '2']
package bsh ; class BSHLiteral extends SimpleNode { public Object value ; BSHLiteral ( int id ) { super ( id ) ; } public Object eval ( CallStack callstack , Interpreter interpreter ) throws EvalError { if ( value == null ) throw new InterpreterError ( "Null in bsh literal: " + value ) ; return value ; } private char getEscapeChar ( char ch ) { switch ( ch ) { case 'b' : ch = '\b' ; break ; case 't' : ch = '\t' ; break ; case 'n' : ch = '\n' ; break ; case 'f' : ch = '\f' ; break ; case 'r' : ch = '\r' ; break ; case '"' : case '\'' : case '\\' : break ; } return ch ; } public void charSetup ( String str ) { char ch = str . charAt ( 0 ) ; if ( ch == '\\' ) { ch = str . charAt ( 1 ) ; if ( Character . isDigit ( ch ) ) ch = ( char ) Integer . parseInt ( str . substring ( 1 ) , 8 ) ; else ch = getEscapeChar ( ch ) ; } value = new Primitive ( new Character ( ch ) ) ; } void stringSetup ( String str ) { StringBuffer buffer = new StringBuffer ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( ch == '\\' ) { ch = str . charAt ( ++ i ) ; if ( Character . isDigit ( ch ) ) { int endPos = i ; while ( endPos < i + 2 ) { if ( Character . isDigit ( str . charAt ( endPos + 1 ) ) ) endPos ++ ; else break ; } ch = ( char ) Integer . parseInt ( str . substring ( i , endPos + 1 ) , 8 ) ; i = endPos ; } else ch = getEscapeChar ( ch ) ; } buffer . append ( ch ) ; } value = buffer . toString ( ) ; } } 	0	['5', '2', '0', '7', '20', '4', '1', '6', '2', '0.5', '153', '0', '0', '0.818181818', '0.366666667', '0', '0', '29.4', '10', '4', '0']
package org . gjt . sp . jedit . io ; import javax . swing . filechooser . FileSystemView ; import java . awt . Component ; import java . io . * ; import java . util . Vector ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class FileVFS extends VFS { public static final String BACKED_UP_PROPERTY = "FileVFS__backedUp" ; public static final String PERMISSIONS_PROPERTY = "FileVFS__perms" ; public FileVFS ( ) { super ( "file" ) ; fsView = FileSystemView . getFileSystemView ( ) ; } public int getCapabilities ( ) { return READ_CAP | WRITE_CAP | BROWSE_CAP | DELETE_CAP | RENAME_CAP | MKDIR_CAP ; } public String getParentOfPath ( String path ) { if ( File . separatorChar == '\\' ) { if ( path . length ( ) == 2 && path . charAt ( 1 ) == ':' ) return FileRootsVFS . PROTOCOL + ":" ; else if ( path . length ( ) == 3 && path . endsWith ( ":\\" ) ) return FileRootsVFS . PROTOCOL + ":" ; } if ( path . equals ( "/" ) ) return FileRootsVFS . PROTOCOL + ":" ; return MiscUtilities . getParentOfPath ( path ) ; } public String constructPath ( String parent , String path ) { return MiscUtilities . constructPath ( parent , path ) ; } public char getFileSeparator ( ) { return File . separatorChar ; } public boolean load ( View view , Buffer buffer , String path ) { File file = buffer . getFile ( ) ; if ( ! file . exists ( ) ) { buffer . setNewFile ( true ) ; return false ; } else buffer . setReadOnly ( ! file . canWrite ( ) ) ; if ( file . isDirectory ( ) ) { String [ ] args = { file . getPath ( ) } ; GUIUtilities . error ( view , "open-directory" , args ) ; buffer . setNewFile ( false ) ; return false ; } if ( ! file . canRead ( ) ) { String [ ] args = { file . getPath ( ) } ; GUIUtilities . error ( view , "no-read" , args ) ; buffer . setNewFile ( false ) ; return false ; } return super . load ( view , buffer , path ) ; } public boolean save ( View view , Buffer buffer , String path ) { File file = new File ( path ) ; if ( file . isDirectory ( ) ) { String [ ] args = { file . getPath ( ) } ; GUIUtilities . error ( view , "save-directory" , args ) ; return false ; } if ( ( file . exists ( ) && ! file . canWrite ( ) ) || ( ! file . exists ( ) && ! new File ( file . getParent ( ) ) . canWrite ( ) ) ) { String [ ] args = { path } ; GUIUtilities . error ( view , "no-write" , args ) ; return false ; } int permissions = getPermissions ( buffer . getPath ( ) ) ; Log . log ( Log . DEBUG , this , buffer . getPath ( ) + " has permissions 0" + Integer . toString ( permissions , 8 ) ) ; buffer . putProperty ( PERMISSIONS_PROPERTY , new Integer ( permissions ) ) ; return super . save ( view , buffer , path ) ; } public boolean insert ( View view , Buffer buffer , String path ) { File file = new File ( path ) ; if ( ! file . exists ( ) ) return false ; if ( file . isDirectory ( ) ) { String [ ] args = { file . getPath ( ) } ; GUIUtilities . error ( view , "open-directory" , args ) ; return false ; } if ( ! file . canRead ( ) ) { String [ ] args = { file . getPath ( ) } ; GUIUtilities . error ( view , "no-read" , args ) ; return false ; } return super . load ( view , buffer , path ) ; } public VFS . DirectoryEntry [ ] _listDirectory ( Object session , String path , Component comp ) { if ( File . separatorChar == '\\' ) { if ( path . length ( ) == 2 && path . charAt ( 1 ) == ':' ) path = path . concat ( File . separator ) ; } File directory = new File ( path ) ; String [ ] list = directory . list ( ) ; if ( list == null ) { String [ ] pp = { path } ; VFSManager . error ( comp , "directory-error-nomsg" , pp ) ; return null ; } Vector list2 = new Vector ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { String name = list [ i ] ; String _path ; if ( path . endsWith ( File . separator ) ) _path = path + name ; else _path = path + File . separatorChar + name ; File file = new File ( _path ) ; int type ; if ( file . isDirectory ( ) ) type = VFS . DirectoryEntry . DIRECTORY ; else type = VFS . DirectoryEntry . FILE ; VFS . DirectoryEntry entry = new VFS . DirectoryEntry ( name , _path , _path , type , file . length ( ) , fsView . isHiddenFile ( file ) ) ; list2 . addElement ( entry ) ; } VFS . DirectoryEntry [ ] retVal = new VFS . DirectoryEntry [ list2 . size ( ) ] ; list2 . copyInto ( retVal ) ; return retVal ; } public DirectoryEntry _getDirectoryEntry ( Object session , String path , Component comp ) { if ( path . endsWith ( "/" ) || path . endsWith ( File . separator ) ) path = path . substring ( 0 , path . length ( ) - 1 ) ; File file = new File ( path ) ; if ( ! file . exists ( ) ) return null ; int type ; if ( file . isDirectory ( ) ) type = VFS . DirectoryEntry . DIRECTORY ; else type = VFS . DirectoryEntry . FILE ; return new VFS . DirectoryEntry ( file . getName ( ) , path , path , type , file . length ( ) , fsView . isHiddenFile ( file ) ) ; } public boolean _delete ( Object session , String path , Component comp ) { boolean retVal = new File ( path ) . delete ( ) ; if ( retVal ) VFSManager . sendVFSUpdate ( this , path , true ) ; return retVal ; } public boolean _rename ( Object session , String from , String to , Component comp ) { File _to = new File ( to ) ; _to . delete ( ) ; boolean retVal = new File ( from ) . renameTo ( _to ) ; VFSManager . sendVFSUpdate ( this , from , true ) ; VFSManager . sendVFSUpdate ( this , to , true ) ; return retVal ; } public boolean _mkdir ( Object session , String directory , Component comp ) { boolean retVal = new File ( directory ) . mkdirs ( ) ; VFSManager . sendVFSUpdate ( this , directory , true ) ; return retVal ; } public void _backup ( Object session , String path , Component comp ) throws IOException { int backups ; try { backups = Integer . parseInt ( jEdit . getProperty ( "backups" ) ) ; } catch ( NumberFormatException nf ) { Log . log ( Log . ERROR , this , nf ) ; backups = 1 ; } if ( backups == 0 ) return ; String backupPrefix = jEdit . getProperty ( "backup.prefix" , "" ) ; String backupSuffix = jEdit . getProperty ( "backup.suffix" , "~" ) ; File file = new File ( path ) ; String backupDirectory = jEdit . getProperty ( "backup.directory" ) ; if ( backupDirectory == null || backupDirectory . length ( ) == 0 ) backupDirectory = file . getParent ( ) ; else { backupDirectory = MiscUtilities . constructPath ( System . getProperty ( "user.home" ) , backupDirectory ) ; backupDirectory = MiscUtilities . concatPath ( backupDirectory , file . getParent ( ) ) ; File dir = new File ( backupDirectory ) ; if ( ! dir . exists ( ) ) dir . mkdirs ( ) ; } String name = file . getName ( ) ; if ( backups == 1 ) { file . renameTo ( new File ( backupDirectory , backupPrefix + name + backupSuffix ) ) ; } else { new File ( backupDirectory , backupPrefix + name + backupSuffix + backups + backupSuffix ) . delete ( ) ; for ( int i = backups - 1 ; i > 0 ; i -- ) { File backup = new File ( backupDirectory , backupPrefix + name + backupSuffix + i + backupSuffix ) ; backup . renameTo ( new File ( backupDirectory , backupPrefix + name + backupSuffix + ( i + 1 ) + backupSuffix ) ) ; } file . renameTo ( new File ( backupDirectory , backupPrefix + name + backupSuffix + "1" + backupSuffix ) ) ; } } public InputStream _createInputStream ( Object session , String path , boolean ignoreErrors , Component comp ) throws IOException { try { return new FileInputStream ( path ) ; } catch ( IOException io ) { if ( ignoreErrors ) return null ; else throw io ; } } public OutputStream _createOutputStream ( Object session , String path , Component comp ) throws IOException { OutputStream retVal = new FileOutputStream ( path ) ; return retVal ; } public void _saveComplete ( Object session , Buffer buffer , Component comp ) { int permissions = ( ( Integer ) buffer . getProperty ( PERMISSIONS_PROPERTY ) ) . intValue ( ) ; setPermissions ( buffer . getPath ( ) , permissions ) ; } public static int getPermissions ( String path ) { int permissions = 0 ; if ( isUnix ) { String [ ] cmdarray = { "ls" , "-ld" , path } ; try { Process process = Runtime . getRuntime ( ) . exec ( cmdarray ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( process . getInputStream ( ) ) ) ; String output = reader . readLine ( ) ; if ( output != null ) { String s = output . substring ( 1 , 10 ) ; if ( s . length ( ) == 9 ) { if ( s . charAt ( 0 ) == 'r' ) permissions += 0400 ; if ( s . charAt ( 1 ) == 'w' ) permissions += 0200 ; if ( s . charAt ( 2 ) == 'x' ) permissions += 0100 ; else if ( s . charAt ( 2 ) == 's' ) permissions += 04100 ; else if ( s . charAt ( 2 ) == 'S' ) permissions += 04000 ; if ( s . charAt ( 3 ) == 'r' ) permissions += 040 ; if ( s . charAt ( 4 ) == 'w' ) permissions += 020 ; if ( s . charAt ( 5 ) == 'x' ) permissions += 010 ; else if ( s . charAt ( 5 ) == 's' ) permissions += 02010 ; else if ( s . charAt ( 5 ) == 'S' ) permissions += 02000 ; if ( s . charAt ( 6 ) == 'r' ) permissions += 04 ; if ( s . charAt ( 7 ) == 'w' ) permissions += 02 ; if ( s . charAt ( 8 ) == 'x' ) permissions += 01 ; else if ( s . charAt ( 8 ) == 't' ) permissions += 01001 ; else if ( s . charAt ( 8 ) == 'T' ) permissions += 01000 ; } } } catch ( Throwable t ) { } } return permissions ; } public static void setPermissions ( String path , int permissions ) { if ( permissions != 0 ) { if ( isUnix ) { String [ ] cmdarray = { "chmod" , Integer . toString ( permissions , 8 ) , path } ; try { Process process = Runtime . getRuntime ( ) . exec ( cmdarray ) ; process . getInputStream ( ) . close ( ) ; process . getOutputStream ( ) . close ( ) ; process . getErrorStream ( ) . close ( ) ; int exitCode = process . waitFor ( ) ; if ( exitCode != 0 ) Log . log ( Log . NOTICE , FileVFS . class , "chmod exited with code " + exitCode ) ; } catch ( Throwable t ) { } } } } private FileSystemView fsView ; private static boolean isUnix ; static { if ( File . separatorChar == '/' ) { String osName = System . getProperty ( "os.name" ) ; if ( osName . indexOf ( "MacOS" ) != - 1 ) { if ( osName . indexOf ( "X" ) != - 1 ) { isUnix = true ; } else { isUnix = false ; } } else { isUnix = true ; } } Log . log ( Log . DEBUG , FileVFS . class , "Unix operating system " + ( isUnix ? "detected; will" : "not detected; will not" ) + " use permission-preserving code" ) ; } } 	1	['21', '2', '0', '12', '94', '198', '5', '9', '19', '0.94', '981', '0.6', '0', '0.525', '0.375', '2', '4', '45.47619048', '16', '3.1905', '6']
package org . gjt . sp . jedit . options ; import javax . swing . * ; import java . awt . * ; import org . gjt . sp . jedit . gui . FontSelector ; import org . gjt . sp . jedit . * ; public class TextAreaOptionPane extends AbstractOptionPane { public TextAreaOptionPane ( ) { super ( "textarea" ) ; } public void _init ( ) { String _fontFamily = jEdit . getProperty ( "view.font" ) ; int _fontStyle ; try { _fontStyle = Integer . parseInt ( jEdit . getProperty ( "view.fontstyle" ) ) ; } catch ( NumberFormatException nf ) { _fontStyle = Font . PLAIN ; } int _fontSize ; try { _fontSize = Integer . parseInt ( jEdit . getProperty ( "view.fontsize" ) ) ; } catch ( NumberFormatException nf ) { _fontSize = 14 ; } font = new FontSelector ( new Font ( _fontFamily , _fontStyle , _fontSize ) ) ; addComponent ( jEdit . getProperty ( "options.textarea.font" ) , font ) ; lineHighlight = new JCheckBox ( jEdit . getProperty ( "options.textarea" + ".lineHighlight" ) ) ; lineHighlight . setSelected ( jEdit . getBooleanProperty ( "view.lineHighlight" ) ) ; addComponent ( lineHighlight ) ; bracketHighlight = new JCheckBox ( jEdit . getProperty ( "options.textarea" + ".bracketHighlight" ) ) ; bracketHighlight . setSelected ( jEdit . getBooleanProperty ( "view.bracketHighlight" ) ) ; addComponent ( bracketHighlight ) ; eolMarkers = new JCheckBox ( jEdit . getProperty ( "options.textarea" + ".eolMarkers" ) ) ; eolMarkers . setSelected ( jEdit . getBooleanProperty ( "view.eolMarkers" ) ) ; addComponent ( eolMarkers ) ; wrapGuide = new JCheckBox ( jEdit . getProperty ( "options.textarea" + ".wrapGuide" ) ) ; wrapGuide . setSelected ( jEdit . getBooleanProperty ( "view.wrapGuide" ) ) ; addComponent ( wrapGuide ) ; blinkCaret = new JCheckBox ( jEdit . getProperty ( "options.textarea" + ".blinkCaret" ) ) ; blinkCaret . setSelected ( jEdit . getBooleanProperty ( "view.caretBlink" ) ) ; addComponent ( blinkCaret ) ; blockCaret = new JCheckBox ( jEdit . getProperty ( "options.textarea" + ".blockCaret" ) ) ; blockCaret . setSelected ( jEdit . getBooleanProperty ( "view.blockCaret" ) ) ; addComponent ( blockCaret ) ; electricBorders = new JCheckBox ( jEdit . getProperty ( "options.textarea" + ".electricBorders" ) ) ; electricBorders . setSelected ( ! "0" . equals ( jEdit . getProperty ( "view.electricBorders" ) ) ) ; addComponent ( electricBorders ) ; homeEnd = new JCheckBox ( jEdit . getProperty ( "options.textarea" + ".homeEnd" ) ) ; homeEnd . setSelected ( jEdit . getBooleanProperty ( "view.homeEnd" ) ) ; addComponent ( homeEnd ) ; middleMousePaste = new JCheckBox ( jEdit . getProperty ( "options.textarea" + ".middleMousePaste" ) ) ; middleMousePaste . setSelected ( jEdit . getBooleanProperty ( "view.middleMousePaste" ) ) ; addComponent ( middleMousePaste ) ; antiAlias = new JCheckBox ( jEdit . getProperty ( "options.textarea" + ".antiAlias" ) ) ; antiAlias . setSelected ( jEdit . getBooleanProperty ( "view.antiAlias" ) ) ; fracFontMetrics = new JCheckBox ( jEdit . getProperty ( "options.textarea" + ".fracFontMetrics" ) ) ; fracFontMetrics . setSelected ( jEdit . getBooleanProperty ( "view.fracFontMetrics" ) ) ; if ( System . getProperty ( "java.version" ) . compareTo ( "1.2" ) >= 0 ) { addComponent ( antiAlias ) ; addComponent ( fracFontMetrics ) ; } } public void _save ( ) { Font _font = font . getFont ( ) ; jEdit . setProperty ( "view.font" , _font . getFamily ( ) ) ; jEdit . setProperty ( "view.fontsize" , String . valueOf ( _font . getSize ( ) ) ) ; jEdit . setProperty ( "view.fontstyle" , String . valueOf ( _font . getStyle ( ) ) ) ; jEdit . setBooleanProperty ( "view.lineHighlight" , lineHighlight . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.bracketHighlight" , bracketHighlight . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.eolMarkers" , eolMarkers . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.wrapGuide" , wrapGuide . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.caretBlink" , blinkCaret . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.blockCaret" , blockCaret . isSelected ( ) ) ; jEdit . setProperty ( "view.electricBorders" , electricBorders . isSelected ( ) ? "3" : "0" ) ; jEdit . setBooleanProperty ( "view.homeEnd" , homeEnd . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.middleMousePaste" , middleMousePaste . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.antiAlias" , antiAlias . isSelected ( ) ) ; jEdit . setBooleanProperty ( "view.fracFontMetrics" , fracFontMetrics . isSelected ( ) ) ; } private FontSelector font ; private JCheckBox lineHighlight ; private JCheckBox bracketHighlight ; private JCheckBox eolMarkers ; private JCheckBox wrapGuide ; private JCheckBox blinkCaret ; private JCheckBox blockCaret ; private JCheckBox electricBorders ; private JCheckBox homeEnd ; private JCheckBox middleMousePaste ; private JCheckBox antiAlias ; private JCheckBox fracFontMetrics ; } 	0	['3', '6', '0', '4', '24', '1', '1', '3', '3', '0.5', '321', '1', '1', '0.996987952', '1', '2', '4', '102', '3', '1.6667', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . * ; import java . awt . event . * ; import java . awt . * ; import org . gjt . sp . jedit . textarea . JEditTextArea ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public class EnhancedCheckBoxMenuItem extends JCheckBoxMenuItem { public EnhancedCheckBoxMenuItem ( String label , EditAction action ) { super ( label ) ; this . action = action ; if ( action != null ) { setEnabled ( true ) ; addActionListener ( new EditAction . Wrapper ( action ) ) ; shortcutProp1 = action . getName ( ) + ".shortcut" ; shortcutProp2 = action . getName ( ) + ".shortcut2" ; } else setEnabled ( false ) ; setModel ( new Model ( ) ) ; } public Dimension getPreferredSize ( ) { Dimension d = super . getPreferredSize ( ) ; String shortcut = getShortcut ( ) ; if ( shortcut != null ) { d . width += ( getFontMetrics ( acceleratorFont ) . stringWidth ( shortcut ) + 10 ) ; } return d ; } public void paint ( Graphics g ) { super . paint ( g ) ; String shortcut = getShortcut ( ) ; if ( shortcut != null ) { g . setFont ( acceleratorFont ) ; g . setColor ( getModel ( ) . isArmed ( ) ? acceleratorSelectionForeground : acceleratorForeground ) ; FontMetrics fm = g . getFontMetrics ( ) ; Insets insets = getInsets ( ) ; g . drawString ( shortcut , getWidth ( ) - ( fm . stringWidth ( shortcut ) + insets . right + insets . left ) , getFont ( ) . getSize ( ) + ( insets . top - 1 ) ) ; } } public String getActionCommand ( ) { return getModel ( ) . getActionCommand ( ) ; } private String shortcutProp1 ; private String shortcutProp2 ; private EditAction action ; private static Font acceleratorFont ; private static Color acceleratorForeground ; private static Color acceleratorSelectionForeground ; private String getShortcut ( ) { if ( action == null ) return null ; else { String shortcut1 = jEdit . getProperty ( shortcutProp1 ) ; String shortcut2 = jEdit . getProperty ( shortcutProp2 ) ; if ( shortcut1 == null || shortcut1 . length ( ) == 0 ) { if ( shortcut2 == null || shortcut2 . length ( ) == 0 ) return null ; else return shortcut2 ; } else { if ( shortcut2 == null || shortcut2 . length ( ) == 0 ) return shortcut1 ; else return shortcut1 + " or " + shortcut2 ; } } } static { acceleratorFont = UIManager . getFont ( "MenuItem.acceleratorFont" ) ; acceleratorFont = new Font ( "Monospaced" , acceleratorFont . getStyle ( ) , acceleratorFont . getSize ( ) ) ; acceleratorForeground = UIManager . getColor ( "MenuItem.acceleratorForeground" ) ; acceleratorSelectionForeground = UIManager . getColor ( "MenuItem.acceleratorSelectionForeground" ) ; } class Model extends DefaultButtonModel { public boolean isSelected ( ) { if ( ! isShowing ( ) ) return false ; try { return action . isSelected ( EditAction . getView ( EnhancedCheckBoxMenuItem . this ) ) ; } catch ( Throwable t ) { Log . log ( Log . ERROR , this , t ) ; return false ; } } public void setSelected ( boolean b ) { } } } 	1	['7', '7', '0', '5', '38', '9', '2', '4', '4', '0.611111111', '210', '1', '1', '0.993811881', '0.3', '3', '13', '28.14285714', '8', '2.1429', '2']
package gnu . regexp ; import java . io . Reader ; import java . io . BufferedReader ; import java . io . IOException ; class CharIndexedReader implements CharIndexed { private static final int BUFFER_INCREMENT = 1024 ; private static final int UNKNOWN = Integer . MAX_VALUE ; private final BufferedReader br ; private int index = - 1 ; private int bufsize = BUFFER_INCREMENT ; private int end = UNKNOWN ; private char cached = OUT_OF_BOUNDS ; private char [ ] lookBehind = new char [ ] { OUT_OF_BOUNDS , OUT_OF_BOUNDS } ; CharIndexedReader ( Reader reader , int index ) { if ( reader instanceof BufferedReader ) { br = ( BufferedReader ) reader ; } else { br = new BufferedReader ( reader , BUFFER_INCREMENT ) ; } next ( ) ; if ( index > 0 ) move ( index ) ; } private boolean next ( ) { lookBehind [ 1 ] = lookBehind [ 0 ] ; lookBehind [ 0 ] = cached ; if ( end == 1 ) { cached = OUT_OF_BOUNDS ; return false ; } end -- ; try { if ( index != - 1 ) { br . reset ( ) ; } int i = br . read ( ) ; br . mark ( bufsize ) ; if ( i == - 1 ) { end = 1 ; cached = OUT_OF_BOUNDS ; return false ; } cached = ( char ) i ; index = 1 ; } catch ( IOException e ) { e . printStackTrace ( ) ; cached = OUT_OF_BOUNDS ; return false ; } return true ; } public char charAt ( int index ) { if ( index == 0 ) { return cached ; } else if ( index >= end ) { return OUT_OF_BOUNDS ; } else if ( index >= bufsize ) { try { while ( bufsize <= index ) bufsize += BUFFER_INCREMENT ; br . reset ( ) ; br . mark ( bufsize ) ; br . skip ( index - 1 ) ; } catch ( IOException e ) { } } else if ( this . index != index ) { try { br . reset ( ) ; br . skip ( index - 1 ) ; } catch ( IOException e ) { } } else if ( index == - 1 ) { return lookBehind [ 0 ] ; } else if ( index == - 2 ) { return lookBehind [ 1 ] ; } else if ( index < - 2 ) { return OUT_OF_BOUNDS ; } char ch = OUT_OF_BOUNDS ; try { int i = br . read ( ) ; this . index = index + 1 ; if ( i == - 1 ) { end = index ; return ch ; } ch = ( char ) i ; } catch ( IOException ie ) { } return ch ; } public boolean move ( int index ) { boolean retval = true ; while ( retval && ( index -- > 0 ) ) retval = next ( ) ; return retval ; } public boolean isValid ( ) { return ( cached != OUT_OF_BOUNDS ) ; } } 	0	['5', '1', '0', '3', '12', '0', '2', '1', '3', '0.46875', '269', '1', '0', '0', '0.6', '0', '0', '51.2', '10', '3.8', '0']
package org . gjt . sp . jedit ; import com . microstar . xml . * ; import javax . swing . plaf . metal . * ; import javax . swing . plaf . FontUIResource ; import javax . swing . text . Element ; import javax . swing . * ; import java . awt . * ; import java . awt . event . * ; import java . io . * ; import java . net . * ; import java . text . MessageFormat ; import java . util . * ; import org . gjt . sp . jedit . browser . VFSBrowser ; import org . gjt . sp . jedit . msg . * ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . io . * ; import org . gjt . sp . jedit . search . SearchAndReplace ; import org . gjt . sp . jedit . syntax . * ; import org . gjt . sp . jedit . textarea . * ; import org . gjt . sp . util . Log ; public class jEdit { public static String getVersion ( ) { return MiscUtilities . buildToVersion ( getBuild ( ) ) ; } public static String getBuild ( ) { return "03.02.99.00" ; } public static void main ( String [ ] args ) { int level = Log . WARNING ; if ( args . length >= 1 ) { String levelStr = args [ 0 ] ; if ( levelStr . length ( ) == 1 && Character . isDigit ( levelStr . charAt ( 0 ) ) ) { level = Integer . parseInt ( levelStr ) ; args [ 0 ] = null ; } } boolean endOpts = false ; settingsDirectory = MiscUtilities . constructPath ( System . getProperty ( "user.home" ) , ".jedit" ) ; String portFile = "server" ; boolean restore = true ; boolean noStartupScripts = false ; String userDir = System . getProperty ( "user.dir" ) ; String scriptFile = null ; for ( int i = 0 ; i < args . length ; i ++ ) { String arg = args [ i ] ; if ( arg == null ) continue ; else if ( arg . length ( ) == 0 ) args [ i ] = null ; else if ( arg . startsWith ( "-" ) && ! endOpts ) { if ( arg . equals ( "--" ) ) endOpts = true ; else if ( arg . equals ( "-usage" ) ) { version ( ) ; System . err . println ( ) ; usage ( ) ; System . exit ( 1 ) ; } else if ( arg . equals ( "-version" ) ) { version ( ) ; System . exit ( 1 ) ; } else if ( arg . equals ( "-nosettings" ) ) settingsDirectory = null ; else if ( arg . startsWith ( "-settings=" ) ) settingsDirectory = arg . substring ( 10 ) ; else if ( arg . startsWith ( "-noserver" ) ) portFile = null ; else if ( arg . equals ( "-server" ) ) portFile = "server" ; else if ( arg . startsWith ( "-server=" ) ) portFile = arg . substring ( 8 ) ; else if ( arg . startsWith ( "-background" ) ) background = true ; else if ( arg . equals ( "-norestore" ) ) restore = false ; else if ( arg . equals ( "-nostartupscripts" ) ) noStartupScripts = true ; else if ( arg . startsWith ( "-run=" ) ) scriptFile = arg . substring ( 5 ) ; else { System . err . println ( "Unknown option: " + arg ) ; usage ( ) ; System . exit ( 1 ) ; } args [ i ] = null ; } } if ( settingsDirectory != null && portFile != null ) portFile = MiscUtilities . constructPath ( settingsDirectory , portFile ) ; else portFile = null ; Log . init ( true , level ) ; if ( portFile != null && new File ( portFile ) . exists ( ) ) { int port , key ; try { BufferedReader in = new BufferedReader ( new FileReader ( portFile ) ) ; port = Integer . parseInt ( in . readLine ( ) ) ; key = Integer . parseInt ( in . readLine ( ) ) ; in . close ( ) ; Socket socket = new Socket ( InetAddress . getByName ( "127.0.0.1" ) , port ) ; Writer out = new OutputStreamWriter ( socket . getOutputStream ( ) , "UTF8" ) ; out . write ( String . valueOf ( key ) ) ; out . write ( '\n' ) ; String script = makeServerScript ( restore , args , scriptFile ) ; out . write ( script ) ; out . close ( ) ; System . exit ( 0 ) ; } catch ( Exception e ) { Log . log ( Log . NOTICE , jEdit . class , "An error occurred" + " while connecting to the jEdit server instance." ) ; Log . log ( Log . NOTICE , jEdit . class , "This probably means that" + " jEdit crashed and/or exited abnormally" ) ; Log . log ( Log . NOTICE , jEdit . class , "the last time it was run." ) ; Log . log ( Log . NOTICE , jEdit . class , "If you don't" + " know what this means, don't worry." ) ; Log . log ( Log . NOTICE , jEdit . class , e ) ; } } if ( System . getProperty ( "os.name" ) . indexOf ( "MacOS X" ) != - 1 ) { System . getProperties ( ) . put ( "com.apple.macos.useScreenMenuBar" , "true" ) ; } boolean showSplash = true ; Writer stream ; if ( settingsDirectory != null ) { File _settingsDirectory = new File ( settingsDirectory ) ; if ( ! _settingsDirectory . exists ( ) ) _settingsDirectory . mkdirs ( ) ; File _macrosDirectory = new File ( settingsDirectory , "macros" ) ; if ( ! _macrosDirectory . exists ( ) ) _macrosDirectory . mkdir ( ) ; String logPath = MiscUtilities . constructPath ( settingsDirectory , "activity.log" ) ; try { stream = new BufferedWriter ( new FileWriter ( logPath ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; stream = null ; } if ( new File ( settingsDirectory , "nosplash" ) . exists ( ) ) showSplash = false ; } else { stream = null ; } if ( showSplash ) GUIUtilities . showSplashScreen ( ) ; Log . setLogWriter ( stream ) ; Log . log ( Log . NOTICE , jEdit . class , "jEdit version " + getVersion ( ) ) ; Log . log ( Log . MESSAGE , jEdit . class , "Settings directory is " + settingsDirectory ) ; if ( portFile != null ) { server = new EditServer ( portFile ) ; if ( ! server . isOK ( ) ) server = null ; } else { if ( background ) { background = false ; System . err . println ( "You cannot specify both the" + " -background and -noserver switches" ) ; } } initMisc ( ) ; initSystemProperties ( ) ; BeanShell . init ( ) ; GUIUtilities . advanceSplashProgress ( ) ; if ( jEditHome != null ) initSiteProperties ( ) ; initUserProperties ( ) ; initActions ( ) ; initPlugins ( ) ; if ( settingsDirectory != null ) { File history = new File ( MiscUtilities . constructPath ( settingsDirectory , "history" ) ) ; if ( history . exists ( ) ) historyModTime = history . lastModified ( ) ; HistoryModel . loadHistory ( history ) ; File recent = new File ( MiscUtilities . constructPath ( settingsDirectory , "recent.xml" ) ) ; if ( recent . exists ( ) ) recentModTime = recent . lastModified ( ) ; BufferHistory . load ( recent ) ; } Abbrevs . load ( ) ; GUIUtilities . advanceSplashProgress ( ) ; sortBuffers = getBooleanProperty ( "sortBuffers" ) ; sortByName = getBooleanProperty ( "sortByName" ) ; initPLAF ( ) ; reloadModes ( ) ; GUIUtilities . advanceSplashProgress ( ) ; SearchAndReplace . load ( ) ; FavoritesVFS . loadFavorites ( ) ; Macros . loadMacros ( ) ; GUIUtilities . advanceSplashProgress ( ) ; for ( int i = 0 ; i < jars . size ( ) ; i ++ ) { ( ( EditPlugin . JAR ) jars . elementAt ( i ) ) . getClassLoader ( ) . startAllPlugins ( ) ; } if ( ! noStartupScripts && jEditHome != null ) { String path = MiscUtilities . constructPath ( jEditHome , "startup" ) ; File file = new File ( path ) ; if ( file . exists ( ) ) runStartupScripts ( file ) ; } if ( ! noStartupScripts && settingsDirectory != null ) { String path = MiscUtilities . constructPath ( settingsDirectory , "startup" ) ; File file = new File ( path ) ; if ( ! file . exists ( ) ) file . mkdirs ( ) ; else runStartupScripts ( file ) ; } if ( scriptFile != null ) { scriptFile = MiscUtilities . constructPath ( userDir , scriptFile ) ; BeanShell . runScript ( null , scriptFile , false , false ) ; } propertiesChanged ( ) ; GUIUtilities . advanceSplashProgress ( ) ; Buffer buffer = openFiles ( null , userDir , args ) ; String splitConfig = null ; if ( restore && settingsDirectory != null && jEdit . getBooleanProperty ( "restore" ) && ( bufferCount == 0 || jEdit . getBooleanProperty ( "restore.cli" ) ) ) { splitConfig = restoreOpenFiles ( ) ; } final Buffer _buffer = buffer ; final String _splitConfig = splitConfig ; GUIUtilities . advanceSplashProgress ( ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { if ( bufferCount == 0 ) newFile ( null ) ; EditBus . send ( new EditorStarted ( null ) ) ; View view ; if ( _buffer != null ) view = newView ( null , _buffer ) ; else view = newView ( null , _splitConfig ) ; if ( jEdit . getBooleanProperty ( "firstTime" ) ) new HelpViewer ( "welcome.html" ) ; else if ( jEdit . getBooleanProperty ( "tip.show" ) ) new TipOfTheDay ( view ) ; setBooleanProperty ( "firstTime" , false ) ; VFSManager . start ( ) ; if ( server != null ) server . start ( ) ; GUIUtilities . hideSplashScreen ( ) ; Log . log ( Log . MESSAGE , jEdit . class , "Startup " + "complete" ) ; } } ) ; } public static final Properties getProperties ( ) { return props ; } public static final String getProperty ( String name ) { return props . getProperty ( name ) ; } public static final String getProperty ( String name , String def ) { return props . getProperty ( name , def ) ; } public static final String getProperty ( String name , Object [ ] args ) { if ( name == null ) return null ; if ( args == null ) return props . getProperty ( name , name ) ; else return MessageFormat . format ( props . getProperty ( name , name ) , args ) ; } public static final boolean getBooleanProperty ( String name ) { return getBooleanProperty ( name , false ) ; } public static final boolean getBooleanProperty ( String name , boolean def ) { String value = getProperty ( name ) ; if ( value == null ) return def ; else if ( value . equals ( "true" ) || value . equals ( "yes" ) || value . equals ( "on" ) ) return true ; else if ( value . equals ( "false" ) || value . equals ( "no" ) || value . equals ( "off" ) ) return false ; else return def ; } public static final void setProperty ( String name , String value ) { if ( value == null || value . length ( ) == 0 ) { String prop = ( String ) defaultProps . get ( name ) ; if ( prop == null || prop . length ( ) == 0 ) props . remove ( name ) ; else props . put ( name , "" ) ; } else { String prop = ( String ) defaultProps . get ( name ) ; if ( value . equals ( prop ) ) props . remove ( name ) ; else props . put ( name , value ) ; } } public static final void setTemporaryProperty ( String name , String value ) { props . remove ( name ) ; defaultProps . put ( name , value ) ; } public static final void setDefaultProperty ( String name , String value ) { setTemporaryProperty ( name , value ) ; } public static final void setBooleanProperty ( String name , boolean value ) { setProperty ( name , value ? "true" : "false" ) ; } public static final void unsetProperty ( String name ) { if ( defaultProps . get ( name ) != null ) props . put ( name , "" ) ; else props . remove ( name ) ; } public static final void resetProperty ( String name ) { props . remove ( name ) ; } public static void propertiesChanged ( ) { initKeyBindings ( ) ; int interval ; try { interval = Integer . parseInt ( getProperty ( "autosave" ) ) ; } catch ( NumberFormatException nf ) { interval = 30 ; } Autosave . setInterval ( interval ) ; saveCaret = getBooleanProperty ( "saveCaret" ) ; UIDefaults defaults = UIManager . getDefaults ( ) ; if ( jEdit . getBooleanProperty ( "globalColors" ) ) { Color background = new javax . swing . plaf . ColorUIResource ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.bgColor" ) ) ) ; Color foreground = new javax . swing . plaf . ColorUIResource ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.fgColor" ) ) ) ; Color caretColor = new javax . swing . plaf . ColorUIResource ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.caretColor" ) ) ) ; Color selectionColor = new javax . swing . plaf . ColorUIResource ( GUIUtilities . parseColor ( jEdit . getProperty ( "view.selectionColor" ) ) ) ; String [ ] prefixes = { "TextField" , "TextArea" , "List" , "Table" } ; for ( int i = 0 ; i < prefixes . length ; i ++ ) { String prefix = prefixes [ i ] ; defaults . put ( prefix + ".disabledBackground" , background ) ; defaults . put ( prefix + ".background" , background ) ; defaults . put ( prefix + ".disabledForeground" , foreground ) ; defaults . put ( prefix + ".foreground" , foreground ) ; defaults . put ( prefix + ".caretForeground" , caretColor ) ; defaults . put ( prefix + ".selectionForeground" , foreground ) ; defaults . put ( prefix + ".selectionBackground" , selectionColor ) ; } defaults . put ( "Tree.background" , background ) ; defaults . put ( "Tree.foreground" , foreground ) ; defaults . put ( "Tree.textBackground" , background ) ; defaults . put ( "Tree.textForeground" , foreground ) ; defaults . put ( "Tree.selectionForeground" , foreground ) ; defaults . put ( "Tree.selectionBackground" , selectionColor ) ; } String family = jEdit . getProperty ( "view.font" ) ; int size ; try { size = Integer . parseInt ( jEdit . getProperty ( "view.fontsize" ) ) ; } catch ( NumberFormatException nf ) { size = 14 ; } int style ; try { style = Integer . parseInt ( jEdit . getProperty ( "view.fontstyle" ) ) ; } catch ( NumberFormatException nf ) { style = Font . PLAIN ; } Font font = new Font ( family , style , size ) ; defaults . put ( "TextArea.font" , font ) ; defaults . put ( "TextPane.font" , font ) ; EditBus . send ( new PropertiesChanged ( null ) ) ; } public static String [ ] getNotLoadedPluginJARs ( ) { Vector returnValue = new Vector ( ) ; if ( jEditHome != null ) { String systemPluginDir = MiscUtilities . constructPath ( jEditHome , "jars" ) ; String [ ] list = new File ( systemPluginDir ) . list ( ) ; if ( list != null ) getNotLoadedPluginJARs ( returnValue , systemPluginDir , list ) ; } if ( settingsDirectory != null ) { String userPluginDir = MiscUtilities . constructPath ( settingsDirectory , "jars" ) ; String [ ] list = new File ( userPluginDir ) . list ( ) ; if ( list != null ) { getNotLoadedPluginJARs ( returnValue , userPluginDir , list ) ; } } String [ ] _returnValue = new String [ returnValue . size ( ) ] ; returnValue . copyInto ( _returnValue ) ; return _returnValue ; } public static EditPlugin getPlugin ( String name ) { EditPlugin [ ] plugins = getPlugins ( ) ; for ( int i = 0 ; i < plugins . length ; i ++ ) { if ( plugins [ i ] . getClassName ( ) . equals ( name ) ) return plugins [ i ] ; } return null ; } public static EditPlugin [ ] getPlugins ( ) { Vector vector = new Vector ( ) ; for ( int i = 0 ; i < jars . size ( ) ; i ++ ) { ( ( EditPlugin . JAR ) jars . elementAt ( i ) ) . getPlugins ( vector ) ; } plugins . getPlugins ( vector ) ; EditPlugin [ ] array = new EditPlugin [ vector . size ( ) ] ; vector . copyInto ( array ) ; return array ; } public static EditPlugin . JAR [ ] getPluginJARs ( ) { EditPlugin . JAR [ ] array = new EditPlugin . JAR [ jars . size ( ) ] ; jars . copyInto ( array ) ; return array ; } public static EditPlugin . JAR getPluginJAR ( String path ) { for ( int i = 0 ; i < jars . size ( ) ; i ++ ) { EditPlugin . JAR jar = ( EditPlugin . JAR ) jars . elementAt ( i ) ; if ( jar . getPath ( ) . equals ( path ) ) return jar ; } return null ; } public static void addPluginJAR ( EditPlugin . JAR plugin ) { jars . addElement ( plugin ) ; } public static void addAction ( EditAction action ) { actionHash . put ( action . getName ( ) , action ) ; } public static EditAction getAction ( String action ) { return ( EditAction ) actionHash . get ( action ) ; } public static EditAction [ ] getActions ( ) { EditAction [ ] actions = new EditAction [ actionHash . size ( ) ] ; Enumeration enum = actionHash . elements ( ) ; int i = 0 ; while ( enum . hasMoreElements ( ) ) { actions [ i ++ ] = ( EditAction ) enum . nextElement ( ) ; } return actions ; } public static void reloadModes ( ) { modes = new Vector ( 50 ) ; if ( jEditHome == null ) loadModeCatalog ( "/modes/catalog" , true ) ; else { loadModeCatalog ( MiscUtilities . constructPath ( jEditHome , "modes" , "catalog" ) , false ) ; } if ( settingsDirectory != null ) { File userModeDir = new File ( MiscUtilities . constructPath ( settingsDirectory , "modes" ) ) ; if ( ! userModeDir . exists ( ) ) userModeDir . mkdirs ( ) ; File userCatalog = new File ( MiscUtilities . constructPath ( settingsDirectory , "modes" , "catalog" ) ) ; if ( ! userCatalog . exists ( ) ) { try { FileWriter out = new FileWriter ( userCatalog ) ; out . write ( jEdit . getProperty ( "defaultCatalog" ) ) ; out . close ( ) ; } catch ( IOException io ) { Log . log ( Log . ERROR , jEdit . class , io ) ; } } loadModeCatalog ( userCatalog . getPath ( ) , false ) ; } Buffer buffer = buffersFirst ; while ( buffer != null ) { buffer . setMode ( ) ; buffer = buffer . next ; } } public static Mode getMode ( String name ) { for ( int i = 0 ; i < modes . size ( ) ; i ++ ) { Mode mode = ( Mode ) modes . elementAt ( i ) ; if ( mode . getName ( ) . equals ( name ) ) return mode ; } return null ; } public static Mode [ ] getModes ( ) { Mode [ ] array = new Mode [ modes . size ( ) ] ; modes . copyInto ( array ) ; return array ; } public static void showOpenFileDialog ( View view ) { showOpenFileDialog ( view , null ) ; } public static void showOpenFileWithOtherEncodingDialog ( View view ) { String encoding = GUIUtilities . input ( view , "encoding-prompt" , null , jEdit . getProperty ( "buffer.encoding" , System . getProperty ( "file.encoding" ) ) ) ; if ( encoding == null ) return ; Macros . Recorder recorder = view . getMacroRecorder ( ) ; if ( recorder != null ) { recorder . record ( "props = new Hashtable();" ) ; recorder . record ( "props.put(\"encoding\",\"" + encoding + "\");" ) ; recorder . record ( "jEdit.showOpenFileDialog(view,props);" ) ; } Hashtable props = new Hashtable ( ) ; props . put ( Buffer . ENCODING , encoding ) ; showOpenFileDialog ( view , props ) ; } public static void showOpenFileDialog ( View view , Hashtable props ) { String [ ] files = GUIUtilities . showVFSFileDialog ( view , null , VFSBrowser . OPEN_DIALOG , true ) ; Buffer buffer = null ; if ( files != null ) { for ( int i = 0 ; i < files . length ; i ++ ) { Buffer newBuffer = openFile ( null , null , files [ i ] , false , props ) ; if ( newBuffer != null ) buffer = newBuffer ; } } if ( buffer != null ) view . setBuffer ( buffer ) ; } public static String restoreOpenFiles ( ) { if ( settingsDirectory == null ) return null ; File session = new File ( MiscUtilities . constructPath ( settingsDirectory , "session" ) ) ; if ( ! session . exists ( ) ) return null ; String splitConfig = null ; try { BufferedReader in = new BufferedReader ( new FileReader ( session ) ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) { if ( line . startsWith ( "splits\t" ) ) splitConfig = line . substring ( 7 ) ; else openFile ( null , line ) ; } in . close ( ) ; } catch ( IOException io ) { Log . log ( Log . ERROR , jEdit . class , "Error while loading " + session ) ; Log . log ( Log . ERROR , jEdit . class , io ) ; } return splitConfig ; } public static void saveOpenFiles ( View view ) { if ( settingsDirectory == null ) return ; view . getEditPane ( ) . saveCaretInfo ( ) ; Buffer current = view . getBuffer ( ) ; File session = new File ( MiscUtilities . constructPath ( settingsDirectory , "session" ) ) ; try { String lineSep = System . getProperty ( "line.separator" ) ; BufferedWriter out = new BufferedWriter ( new FileWriter ( session ) ) ; Buffer buffer = buffersFirst ; while ( buffer != null ) { out . write ( buffer . getPath ( ) ) ; out . write ( lineSep ) ; buffer = buffer . next ; } out . write ( "splits\t" ) ; out . write ( view . getSplitConfig ( ) ) ; out . write ( lineSep ) ; out . close ( ) ; } catch ( IOException io ) { Log . log ( Log . ERROR , jEdit . class , "Error while saving " + session ) ; Log . log ( Log . ERROR , jEdit . class , io ) ; } } public static Buffer openFiles ( View view , String parent , String [ ] args ) { Buffer retVal = null ; Buffer lastBuffer = null ; for ( int i = 0 ; i < args . length ; i ++ ) { String arg = args [ i ] ; if ( arg == null ) continue ; else if ( arg . startsWith ( "+line:" ) || arg . startsWith ( "+marker:" ) ) { if ( lastBuffer != null ) gotoMarker ( view , lastBuffer , arg ) ; continue ; } lastBuffer = openFile ( null , parent , arg , false , null ) ; if ( retVal == null && lastBuffer != null ) retVal = lastBuffer ; } if ( view != null && retVal != null ) view . setBuffer ( retVal ) ; return retVal ; } public static Buffer openFile ( View view , String path ) { return openFile ( view , null , path , false , new Hashtable ( ) ) ; } public static Buffer openFile ( View view , String parent , String path , boolean readOnly , boolean newFile ) { return openFile ( view , parent , path , newFile , new Hashtable ( ) ) ; } public static Buffer openFile ( View view , String parent , String path , boolean readOnly , boolean newFile , Hashtable props ) { return openFile ( view , parent , path , newFile , props ) ; } public static Buffer openFile ( final View view , String parent , String path , boolean newFile , Hashtable props ) { if ( view != null && parent == null ) { File file = view . getBuffer ( ) . getFile ( ) ; if ( file != null ) parent = file . getParent ( ) ; } String protocol ; if ( MiscUtilities . isURL ( path ) ) { protocol = MiscUtilities . getProtocolOfURL ( path ) ; if ( protocol . equals ( "file" ) ) path = path . substring ( 5 ) ; } else protocol = "file" ; if ( protocol . equals ( "file" ) ) path = MiscUtilities . constructPath ( parent , path ) ; Buffer buffer = getBuffer ( path ) ; if ( buffer != null ) { if ( view != null ) view . setBuffer ( buffer ) ; return buffer ; } if ( props == null ) props = new Hashtable ( ) ; BufferHistory . Entry entry = BufferHistory . getEntry ( path ) ; if ( entry != null && saveCaret && props . get ( Buffer . CARET ) == null ) { int caret = entry . caret ; props . put ( Buffer . CARET , new Integer ( entry . caret ) ) ; if ( entry . selection != null ) { props . put ( Buffer . SELECTION , entry . getSelection ( ) ) ; } } if ( entry != null && props . get ( Buffer . ENCODING ) == null ) { if ( entry . encoding != null ) props . put ( Buffer . ENCODING , entry . encoding ) ; } final Buffer newBuffer = new Buffer ( view , path , newFile , false , props ) ; if ( ! newBuffer . load ( view , false ) ) return null ; addBufferToList ( newBuffer ) ; EditBus . send ( new BufferUpdate ( newBuffer , view , BufferUpdate . CREATED ) ) ; if ( view != null ) view . setBuffer ( newBuffer ) ; return newBuffer ; } public static Buffer openTemporary ( View view , String parent , String path , boolean newFile ) { if ( view != null && parent == null ) { File file = view . getBuffer ( ) . getFile ( ) ; if ( file != null ) parent = file . getParent ( ) ; } String protocol ; if ( MiscUtilities . isURL ( path ) ) { protocol = MiscUtilities . getProtocolOfURL ( path ) ; if ( protocol . equals ( "file" ) ) path = path . substring ( 5 ) ; } else protocol = "file" ; if ( protocol . equals ( "file" ) ) path = MiscUtilities . constructPath ( parent , path ) ; Buffer buffer = getBuffer ( path ) ; if ( buffer != null ) return buffer ; buffer = new Buffer ( null , path , newFile , true , new Hashtable ( ) ) ; if ( ! buffer . load ( view , false ) ) return null ; else return buffer ; } public static void commitTemporary ( Buffer buffer ) { if ( ! buffer . isTemporary ( ) ) return ; buffer . setMode ( ) ; buffer . propertiesChanged ( ) ; addBufferToList ( buffer ) ; buffer . commitTemporary ( ) ; EditBus . send ( new BufferUpdate ( buffer , null , BufferUpdate . CREATED ) ) ; } public static Buffer newFile ( View view ) { return newFile ( view , null ) ; } public static Buffer newFile ( View view , String dir ) { if ( dir != null && buffersFirst != null && buffersFirst == buffersLast && buffersFirst . isUntitled ( ) && ! buffersFirst . isDirty ( ) ) { closeBuffer ( view , buffersFirst ) ; return buffersFirst ; } int untitledCount = 0 ; Buffer buffer = buffersFirst ; while ( buffer != null ) { if ( buffer . getName ( ) . startsWith ( "Untitled-" ) ) { try { untitledCount = Math . max ( untitledCount , Integer . parseInt ( buffer . getName ( ) . substring ( 9 ) ) ) ; } catch ( NumberFormatException nf ) { } } buffer = buffer . next ; } return openFile ( view , dir , "Untitled-" + ( untitledCount + 1 ) , true , null ) ; } public static boolean closeBuffer ( View view , Buffer buffer ) { if ( buffer . isPerformingIO ( ) ) { VFSManager . waitForRequests ( ) ; if ( VFSManager . errorOccurred ( ) ) return false ; } if ( buffer . isDirty ( ) ) { Object [ ] args = { buffer . getName ( ) } ; int result = GUIUtilities . confirm ( view , "notsaved" , args , JOptionPane . YES_NO_CANCEL_OPTION , JOptionPane . WARNING_MESSAGE ) ; if ( result == JOptionPane . YES_OPTION ) { if ( ! buffer . save ( view , null , true ) ) return false ; } else if ( result != JOptionPane . NO_OPTION ) return false ; } _closeBuffer ( view , buffer ) ; return true ; } public static void _closeBuffer ( View view , Buffer buffer ) { if ( buffer . isClosed ( ) ) { return ; } if ( ! buffer . isNewFile ( ) ) { view . getEditPane ( ) . saveCaretInfo ( ) ; Integer _caret = ( Integer ) buffer . getProperty ( Buffer . CARET ) ; int caret = ( _caret == null ? 0 : _caret . intValue ( ) ) ; BufferHistory . setEntry ( buffer . getPath ( ) , caret , ( Selection [ ] ) buffer . getProperty ( Buffer . SELECTION ) , ( String ) buffer . getProperty ( Buffer . ENCODING ) ) ; } removeBufferFromList ( buffer ) ; buffer . close ( ) ; EditBus . send ( new BufferUpdate ( buffer , view , BufferUpdate . CLOSED ) ) ; if ( buffersFirst == null && buffersLast == null ) newFile ( view ) ; } public static boolean closeAllBuffers ( View view ) { return closeAllBuffers ( view , false ) ; } public static boolean closeAllBuffers ( View view , boolean isExiting ) { boolean dirty = false ; Buffer buffer = buffersFirst ; while ( buffer != null ) { if ( buffer . isDirty ( ) ) { dirty = true ; break ; } buffer = buffer . next ; } if ( dirty ) { boolean ok = new CloseDialog ( view ) . isOK ( ) ; if ( ! ok ) return false ; } VFSManager . waitForRequests ( ) ; if ( VFSManager . errorOccurred ( ) ) return false ; buffer = buffersFirst ; buffersFirst = buffersLast = null ; bufferCount = 0 ; while ( buffer != null ) { if ( ! buffer . isNewFile ( ) ) { Integer _caret = ( Integer ) buffer . getProperty ( Buffer . CARET ) ; int caret = ( _caret == null ? 0 : _caret . intValue ( ) ) ; BufferHistory . setEntry ( buffer . getPath ( ) , caret , ( Selection [ ] ) buffer . getProperty ( Buffer . SELECTION ) , ( String ) buffer . getProperty ( Buffer . ENCODING ) ) ; } buffer . close ( ) ; if ( ! isExiting ) { EditBus . send ( new BufferUpdate ( buffer , view , BufferUpdate . CLOSED ) ) ; } buffer = buffer . next ; } if ( ! isExiting ) newFile ( view ) ; return true ; } public static void saveAllBuffers ( View view , boolean confirm ) { if ( confirm ) { int result = GUIUtilities . confirm ( view , "saveall" , null , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE ) ; if ( result != JOptionPane . YES_OPTION ) return ; } Buffer buffer = buffersFirst ; while ( buffer != null ) { if ( buffer . isDirty ( ) ) buffer . save ( view , null , true ) ; buffer = buffer . next ; } } public static void reloadAllBuffers ( final View view , boolean confirm ) { if ( confirm ) { int result = GUIUtilities . confirm ( view , "reload-all" , null , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE ) ; if ( result != JOptionPane . YES_OPTION ) return ; } View _view = viewsFirst ; while ( _view != null ) { EditPane [ ] panes = _view . getEditPanes ( ) ; for ( int i = 0 ; i < panes . length ; i ++ ) { panes [ i ] . saveCaretInfo ( ) ; } _view = _view . next ; } Buffer [ ] buffers = jEdit . getBuffers ( ) ; for ( int i = 0 ; i < buffers . length ; i ++ ) { Buffer buffer = buffers [ i ] ; buffer . load ( view , true ) ; } } public static Buffer getBuffer ( String path ) { boolean caseInsensitiveFilesystem = ( File . separatorChar == '\\' || File . separatorChar == ':' ) ; Buffer buffer = buffersFirst ; while ( buffer != null ) { String _path = buffer . getPath ( ) ; if ( caseInsensitiveFilesystem ) { if ( _path . equalsIgnoreCase ( path ) ) return buffer ; } else { if ( _path . equals ( path ) ) return buffer ; } buffer = buffer . next ; } return null ; } public static Buffer [ ] getBuffers ( ) { Buffer [ ] buffers = new Buffer [ bufferCount ] ; Buffer buffer = buffersFirst ; for ( int i = 0 ; i < bufferCount ; i ++ ) { buffers [ i ] = buffer ; buffer = buffer . next ; } return buffers ; } public static int getBufferCount ( ) { return bufferCount ; } public static Buffer getFirstBuffer ( ) { return buffersFirst ; } public static Buffer getLastBuffer ( ) { return buffersLast ; } public static InputHandler getInputHandler ( ) { return inputHandler ; } public static View newView ( View view , Buffer buffer ) { if ( view != null ) { view . showWaitCursor ( ) ; view . getEditPane ( ) . saveCaretInfo ( ) ; } View newView = new View ( buffer , null ) ; newView . pack ( ) ; if ( view != null ) { GUIUtilities . saveGeometry ( view , "view" ) ; view . hideWaitCursor ( ) ; } GUIUtilities . loadGeometry ( newView , "view" ) ; addViewToList ( newView ) ; EditBus . send ( new ViewUpdate ( newView , ViewUpdate . CREATED ) ) ; newView . show ( ) ; return newView ; } public static View newView ( View view ) { return newView ( view , view . getSplitConfig ( ) ) ; } public static View newView ( View view , String splitConfig ) { if ( view != null ) { view . showWaitCursor ( ) ; view . getEditPane ( ) . saveCaretInfo ( ) ; } View newView = new View ( null , splitConfig ) ; newView . pack ( ) ; if ( view != null ) { GUIUtilities . saveGeometry ( view , "view" ) ; view . hideWaitCursor ( ) ; } GUIUtilities . loadGeometry ( newView , "view" ) ; addViewToList ( newView ) ; EditBus . send ( new ViewUpdate ( newView , ViewUpdate . CREATED ) ) ; newView . show ( ) ; return newView ; } public static void closeView ( View view ) { closeView ( view , true ) ; } public static View [ ] getViews ( ) { View [ ] views = new View [ viewCount ] ; View view = viewsFirst ; for ( int i = 0 ; i < viewCount ; i ++ ) { views [ i ] = view ; view = view . next ; } return views ; } public static int getViewCount ( ) { return viewCount ; } public static View getFirstView ( ) { return viewsFirst ; } public static View getLastView ( ) { return viewsLast ; } public static String getJEditHome ( ) { return jEditHome ; } public static String getSettingsDirectory ( ) { return settingsDirectory ; } public static void saveSettings ( ) { if ( settingsDirectory != null ) { File file = new File ( MiscUtilities . constructPath ( settingsDirectory , "recent.xml" ) ) ; if ( file . exists ( ) && file . lastModified ( ) != recentModTime ) { Log . log ( Log . WARNING , jEdit . class , file + " changed" + " on disk; will not save recent files" ) ; } else { BufferHistory . save ( file ) ; } recentModTime = file . lastModified ( ) ; file = new File ( MiscUtilities . constructPath ( settingsDirectory , "history" ) ) ; if ( file . exists ( ) && file . lastModified ( ) != historyModTime ) { Log . log ( Log . WARNING , jEdit . class , file + " changed" + " on disk; will not save history" ) ; } else { HistoryModel . saveHistory ( file ) ; } historyModTime = file . lastModified ( ) ; SearchAndReplace . save ( ) ; Abbrevs . save ( ) ; FavoritesVFS . saveFavorites ( ) ; file = new File ( MiscUtilities . constructPath ( settingsDirectory , "properties" ) ) ; if ( file . exists ( ) && file . lastModified ( ) != propsModTime ) { Log . log ( Log . WARNING , jEdit . class , file + " changed" + " on disk; will not save user properties" ) ; } else { try { OutputStream out = new FileOutputStream ( file ) ; props . save ( out , "jEdit properties" ) ; out . close ( ) ; } catch ( IOException io ) { Log . log ( Log . ERROR , jEdit . class , io ) ; } propsModTime = file . lastModified ( ) ; } } } public static void exit ( View view , boolean reallyExit ) { VFSManager . waitForRequests ( ) ; EditBus . send ( new EditorExitRequested ( view ) ) ; reallyExit |= ! background ; saveOpenFiles ( view ) ; if ( ! closeAllBuffers ( view , reallyExit ) ) return ; if ( ! reallyExit ) { view = viewsFirst ; while ( view != null ) { closeView ( view , false ) ; view = view . next ; } saveSettings ( ) ; return ; } view . close ( ) ; Autosave . stop ( ) ; if ( server != null ) server . stopServer ( ) ; EditPlugin [ ] plugins = getPlugins ( ) ; for ( int i = 0 ; i < plugins . length ; i ++ ) { plugins [ i ] . stop ( ) ; } EditBus . send ( new EditorExiting ( null ) ) ; saveSettings ( ) ; Log . closeStream ( ) ; System . exit ( 0 ) ; } static void updatePosition ( Buffer buffer ) { if ( sortBuffers ) { removeBufferFromList ( buffer ) ; addBufferToList ( buffer ) ; } } public static void addMode ( Mode mode ) { Log . log ( Log . DEBUG , jEdit . class , "Adding edit mode " + mode . getName ( ) ) ; modes . addElement ( mode ) ; } static void loadMode ( Mode mode ) { Object fileName = mode . getProperty ( "file" ) ; Log . log ( Log . NOTICE , jEdit . class , "Loading edit mode " + fileName ) ; XmlParser parser = new XmlParser ( ) ; XModeHandler xmh = new XModeHandler ( parser , mode . getName ( ) , fileName . toString ( ) ) ; parser . setHandler ( xmh ) ; try { Reader grammar ; if ( fileName instanceof URL ) { grammar = new BufferedReader ( new InputStreamReader ( ( ( URL ) fileName ) . openStream ( ) ) ) ; } else { grammar = new BufferedReader ( new FileReader ( ( String ) fileName ) ) ; } parser . parse ( null , null , grammar ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , jEdit . class , e ) ; if ( e instanceof XmlException ) { XmlException xe = ( XmlException ) e ; int line = xe . getLine ( ) ; String message = xe . getMessage ( ) ; Object [ ] args = { fileName , new Integer ( line ) , message } ; GUIUtilities . error ( null , "xmode-parse" , args ) ; } TokenMarker marker = new TokenMarker ( ) ; marker . addRuleSet ( "MAIN" , new ParserRuleSet ( ) ) ; mode . setTokenMarker ( marker ) ; } } static void loadProps ( InputStream in , boolean def ) throws IOException { in = new BufferedInputStream ( in ) ; if ( def ) defaultProps . load ( in ) ; else props . load ( in ) ; in . close ( ) ; } static void addPlugin ( EditPlugin plugin ) { plugins . addPlugin ( plugin ) ; } static boolean loadActions ( String path , Reader in , boolean plugin ) { Log . log ( Log . DEBUG , jEdit . class , "Loading actions from " + path ) ; ActionListHandler ah = new ActionListHandler ( path , plugin ) ; XmlParser parser = new XmlParser ( ) ; parser . setHandler ( ah ) ; try { parser . parse ( null , null , in ) ; return true ; } catch ( XmlException xe ) { int line = xe . getLine ( ) ; String message = xe . getMessage ( ) ; Log . log ( Log . ERROR , jEdit . class , path + ":" + line + ": " + message ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , jEdit . class , e ) ; } return false ; } private static String jEditHome ; private static String settingsDirectory ; private static long propsModTime , historyModTime , recentModTime ; private static Properties defaultProps ; private static Properties props ; private static EditServer server ; private static boolean background ; private static Hashtable actionHash ; private static Vector jars ; private static EditPlugin . JAR plugins ; private static Vector modes ; private static Vector recent ; private static boolean saveCaret ; private static InputHandler inputHandler ; private static boolean sortBuffers ; private static boolean sortByName ; private static int bufferCount ; private static Buffer buffersFirst ; private static Buffer buffersLast ; private static int viewCount ; private static View viewsFirst ; private static View viewsLast ; private jEdit ( ) { } private static void usage ( ) { System . out . println ( "Usage: jedit [<options>] [<files>]" ) ; System . out . println ( "	<file> +marker:<marker>: Positions caret" + " at marker <marker>" ) ; System . out . println ( "	<file> +line:<line>: Positions caret" + " at line number <line>" ) ; System . out . println ( "	--: End of options" ) ; System . out . println ( "	-background: Run in background mode" ) ; System . out . println ( "	-norestore: Don't restore previously open files" ) ; System . out . println ( "	-run=<script>: Run the specified BeanShell script" ) ; System . out . println ( "	-server: Read/write server" + " info from/to $HOME/.jedit/server" ) ; System . out . println ( "	-server=<name>: Read/write server" + " info from/to $HOME/.jedit/<name>" ) ; System . out . println ( "	-noserver: Don't start edit server" ) ; System . out . println ( "	-settings=<path>: Load user-specific" + " settings from <path>" ) ; System . out . println ( "	-nosettings: Don't load user-specific" + " settings" ) ; System . out . println ( "	-nostartupscripts: Don't run startup scripts" ) ; System . out . println ( "	-version: Print jEdit version and exit" ) ; System . out . println ( "	-usage: Print this message and exit" ) ; System . out . println ( ) ; System . out . println ( "To set minimum activity log level," + " specify a number as the first" ) ; System . out . println ( "command line parameter" + " (1-9, 1 = print everything, 9 = fatal errors only)" ) ; System . out . println ( ) ; System . out . println ( "Report bugs to Slava Pestov <slava@jedit.org>." ) ; } private static void version ( ) { System . out . println ( "jEdit " + getVersion ( ) ) ; } private static String makeServerScript ( boolean restore , String [ ] args , String scriptFile ) { StringBuffer script = new StringBuffer ( ) ; String userDir = System . getProperty ( "user.dir" ) ; script . append ( "parent = \"" ) ; script . append ( MiscUtilities . charsToEscapes ( userDir ) ) ; script . append ( "\";\n" ) ; script . append ( "args = new String[" ) ; script . append ( args . length ) ; script . append ( "];\n" ) ; for ( int i = 0 ; i < args . length ; i ++ ) { script . append ( "args[" ) ; script . append ( i ) ; script . append ( "] = " ) ; if ( args [ i ] == null ) script . append ( "null" ) ; else { script . append ( '"' ) ; script . append ( MiscUtilities . charsToEscapes ( args [ i ] ) ) ; script . append ( '"' ) ; } script . append ( ";\n" ) ; } script . append ( "EditServer.handleClient(" + restore + ",parent,args);\n" ) ; if ( scriptFile != null ) { scriptFile = MiscUtilities . constructPath ( userDir , scriptFile ) ; script . append ( "BeanShell.runScript(null,\"" + MiscUtilities . charsToEscapes ( scriptFile ) + "\",false,false);\n" ) ; } return script . toString ( ) ; } private static void initMisc ( ) { System . getProperties ( ) . put ( "java.protocol.handler.pkgs" , "org.gjt.sp.jedit.proto|" + System . getProperty ( "java.protocol.handler.pkgs" , "" ) ) ; inputHandler = new DefaultInputHandler ( null ) ; jEditHome = System . getProperty ( "jedit.home" ) ; if ( jEditHome == null ) { String classpath = System . getProperty ( "java.class.path" ) ; int index = classpath . toLowerCase ( ) . indexOf ( "jedit.jar" ) ; int start = classpath . lastIndexOf ( File . pathSeparator , index ) + 1 ; if ( index > start ) { jEditHome = classpath . substring ( start , index - 1 ) ; } else { { jEditHome = System . getProperty ( "user.dir" ) ; } } } Log . log ( Log . MESSAGE , jEdit . class , "jEdit home directory is " + jEditHome ) ; actionHash = new Hashtable ( ) ; plugins = new EditPlugin . JAR ( null , null ) ; jars = new Vector ( ) ; } private static void initSystemProperties ( ) { defaultProps = props = new Properties ( ) ; try { loadProps ( jEdit . class . getResourceAsStream ( "/org/gjt/sp/jedit/jedit.props" ) , true ) ; loadProps ( jEdit . class . getResourceAsStream ( "/org/gjt/sp/jedit/jedit_gui.props" ) , true ) ; loadProps ( jEdit . class . getResourceAsStream ( "/org/gjt/sp/jedit/jedit_keys.props" ) , true ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , jEdit . class , "Error while loading system properties!" ) ; Log . log ( Log . ERROR , jEdit . class , "One of the following property files could not be loaded:\n" + "- jedit.props\n" + "- jedit_gui.props\n" + "- jedit_keys.props\n" + "jedit.jar is probably corrupt." ) ; Log . log ( Log . ERROR , jEdit . class , e ) ; System . exit ( 1 ) ; } } private static void initSiteProperties ( ) { String siteSettingsDirectory = MiscUtilities . constructPath ( jEditHome , "properties" ) ; File siteSettings = new File ( siteSettingsDirectory ) ; if ( ! ( siteSettings . exists ( ) && siteSettings . isDirectory ( ) ) ) return ; String [ ] snippets = siteSettings . list ( ) ; if ( snippets == null ) return ; MiscUtilities . quicksort ( snippets , new MiscUtilities . StringICaseCompare ( ) ) ; for ( int i = 0 ; i < snippets . length ; ++ i ) { String snippet = snippets [ i ] ; if ( ! snippet . toLowerCase ( ) . endsWith ( ".props" ) ) continue ; try { String path = MiscUtilities . constructPath ( siteSettingsDirectory , snippet ) ; Log . log ( Log . DEBUG , jEdit . class , "Loading site snippet: " + path ) ; loadProps ( new FileInputStream ( new File ( path ) ) , true ) ; } catch ( FileNotFoundException fnf ) { Log . log ( Log . DEBUG , jEdit . class , fnf ) ; } catch ( IOException e ) { Log . log ( Log . ERROR , jEdit . class , "Cannot load site snippet " + snippet ) ; Log . log ( Log . ERROR , jEdit . class , e ) ; } } } private static void initActions ( ) { Reader in = new BufferedReader ( new InputStreamReader ( jEdit . class . getResourceAsStream ( "actions.xml" ) ) ) ; if ( ! loadActions ( "actions.xml" , in , false ) ) System . exit ( 1 ) ; } private static void initPlugins ( ) { if ( jEditHome != null ) loadPlugins ( MiscUtilities . constructPath ( jEditHome , "jars" ) ) ; else { try { InputStream in = jEdit . class . getResourceAsStream ( "Firewall.props" ) ; if ( in != null ) { loadProps ( in , true ) ; Class clazz ; ClassLoader loader = jEdit . class . getClassLoader ( ) ; if ( loader != null ) clazz = loader . loadClass ( "FirewallPlugin" ) ; else clazz = Class . forName ( "FirewallPlugin" ) ; EditPlugin plugin = ( EditPlugin ) clazz . newInstance ( ) ; addPlugin ( plugin ) ; } } catch ( Throwable t ) { Log . log ( Log . ERROR , jEdit . class , "Could not load firewall plugin:" ) ; Log . log ( Log . ERROR , jEdit . class , t ) ; } } if ( settingsDirectory != null ) { File jarsDirectory = new File ( settingsDirectory , "jars" ) ; if ( ! jarsDirectory . exists ( ) ) jarsDirectory . mkdir ( ) ; loadPlugins ( jarsDirectory . getPath ( ) ) ; } } private static void initUserProperties ( ) { props = new Properties ( defaultProps ) ; if ( settingsDirectory != null ) { File file = new File ( MiscUtilities . constructPath ( settingsDirectory , "properties" ) ) ; propsModTime = file . lastModified ( ) ; try { loadProps ( new FileInputStream ( file ) , false ) ; } catch ( FileNotFoundException fnf ) { Log . log ( Log . DEBUG , jEdit . class , fnf ) ; } catch ( IOException e ) { Log . log ( Log . ERROR , jEdit . class , e ) ; } } } private static void initPLAF ( ) { String lf = getProperty ( "lookAndFeel" ) ; try { if ( lf != null && lf . length ( ) != 0 ) UIManager . setLookAndFeel ( lf ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , jEdit . class , e ) ; } } private static void runStartupScripts ( File directory ) { if ( ! directory . isDirectory ( ) ) return ; String [ ] snippets = directory . list ( ) ; if ( snippets == null ) return ; MiscUtilities . quicksort ( snippets , new MiscUtilities . StringICaseCompare ( ) ) ; for ( int i = 0 ; i < snippets . length ; ++ i ) { String snippet = snippets [ i ] ; if ( ! snippet . toLowerCase ( ) . endsWith ( ".bsh" ) ) continue ; String path = new File ( directory , snippet ) . getPath ( ) ; BeanShell . runScript ( null , path , false , false ) ; } } private static void getNotLoadedPluginJARs ( Vector returnValue , String dir , String [ ] list ) { loop : for ( int i = 0 ; i < list . length ; i ++ ) { String name = list [ i ] ; if ( ! name . toLowerCase ( ) . endsWith ( ".jar" ) ) continue loop ; String path = MiscUtilities . constructPath ( dir , name ) ; for ( int j = 0 ; j < jars . size ( ) ; j ++ ) { EditPlugin . JAR jar = ( EditPlugin . JAR ) jars . elementAt ( j ) ; String jarPath = jar . getPath ( ) ; String jarName = MiscUtilities . getFileName ( jarPath ) ; if ( path . equals ( jarPath ) ) continue loop ; else if ( ! new File ( jarPath ) . exists ( ) && name . equals ( jarName ) ) continue loop ; } returnValue . addElement ( path ) ; } } private static void gotoMarker ( final View view , final Buffer buffer , final String marker ) { VFSManager . runInAWTThread ( new Runnable ( ) { public void run ( ) { int pos ; if ( marker . startsWith ( "+line:" ) ) { try { int line = Integer . parseInt ( marker . substring ( 6 ) ) ; Element lineElement = buffer . getDefaultRootElement ( ) . getElement ( line - 1 ) ; pos = lineElement . getStartOffset ( ) ; } catch ( Exception e ) { return ; } } else if ( marker . startsWith ( "+marker:" ) ) { if ( marker . length ( ) != 9 ) return ; Marker m = buffer . getMarker ( marker . charAt ( 8 ) ) ; if ( m == null ) return ; pos = m . getPosition ( ) ; } else throw new InternalError ( ) ; if ( view != null && view . getBuffer ( ) == buffer ) view . getTextArea ( ) . setCaretPosition ( pos ) ; else buffer . putProperty ( Buffer . CARET , new Integer ( pos ) ) ; } } ) ; } private static void addBufferToList ( Buffer buffer ) { if ( viewCount <= 1 && buffersFirst != null && buffersFirst == buffersLast && buffersFirst . isUntitled ( ) && ! buffersFirst . isDirty ( ) ) { Buffer oldBuffersFirst = buffersFirst ; buffersFirst = buffersLast = buffer ; EditBus . send ( new BufferUpdate ( oldBuffersFirst , null , BufferUpdate . CLOSED ) ) ; return ; } bufferCount ++ ; if ( buffersFirst == null ) { buffersFirst = buffersLast = buffer ; return ; } else if ( sortBuffers ) { String name1 = ( sortByName ? buffer . getName ( ) : buffer . getPath ( ) ) . toLowerCase ( ) ; Buffer _buffer = buffersFirst ; while ( _buffer != null ) { String name2 = ( sortByName ? _buffer . getName ( ) : _buffer . getPath ( ) ) . toLowerCase ( ) ; if ( name1 . compareTo ( name2 ) <= 0 ) { buffer . next = _buffer ; buffer . prev = _buffer . prev ; _buffer . prev = buffer ; if ( _buffer != buffersFirst ) buffer . prev . next = buffer ; else buffersFirst = buffer ; return ; } _buffer = _buffer . next ; } } buffer . prev = buffersLast ; buffersLast . next = buffer ; buffersLast = buffer ; } private static void removeBufferFromList ( Buffer buffer ) { bufferCount -- ; if ( buffer == buffersFirst && buffer == buffersLast ) { buffersFirst = buffersLast = null ; return ; } if ( buffer == buffersFirst ) { buffersFirst = buffer . next ; buffer . next . prev = null ; } else { buffer . prev . next = buffer . next ; } if ( buffer == buffersLast ) { buffersLast = buffersLast . prev ; buffer . prev . next = null ; } else { buffer . next . prev = buffer . prev ; } buffer . next = buffer . prev = null ; } private static void addViewToList ( View view ) { viewCount ++ ; if ( viewsFirst == null ) viewsFirst = viewsLast = view ; else { view . prev = viewsLast ; viewsLast . next = view ; viewsLast = view ; } } private static void removeViewFromList ( View view ) { viewCount -- ; if ( viewsFirst == viewsLast ) { viewsFirst = viewsLast = null ; return ; } if ( view == viewsFirst ) { viewsFirst = view . next ; view . next . prev = null ; } else { view . prev . next = view . next ; } if ( view == viewsLast ) { viewsLast = viewsLast . prev ; view . prev . next = null ; } else { view . next . prev = view . prev ; } } private static void closeView ( View view , boolean callExit ) { if ( viewsFirst == viewsLast && callExit ) exit ( view , false ) ; else { EditBus . send ( new ViewUpdate ( view , ViewUpdate . CLOSED ) ) ; view . close ( ) ; removeViewFromList ( view ) ; } } private static void loadModeCatalog ( String path , boolean resource ) { Log . log ( Log . MESSAGE , jEdit . class , "Loading mode catalog file " + path ) ; ModeCatalogHandler handler = new ModeCatalogHandler ( MiscUtilities . getParentOfPath ( path ) , resource ) ; XmlParser parser = new XmlParser ( ) ; parser . setHandler ( handler ) ; try { InputStream _in ; if ( resource ) _in = jEdit . class . getResourceAsStream ( path ) ; else _in = new FileInputStream ( path ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( _in ) ) ; parser . parse ( null , null , in ) ; } catch ( XmlException xe ) { int line = xe . getLine ( ) ; String message = xe . getMessage ( ) ; Log . log ( Log . ERROR , jEdit . class , path + ":" + line + ": " + message ) ; } catch ( Exception e ) { Log . log ( Log . ERROR , jEdit . class , e ) ; } } private static void loadPlugins ( String directory ) { Log . log ( Log . NOTICE , jEdit . class , "Loading plugins from " + directory ) ; File file = new File ( directory ) ; if ( ! ( file . exists ( ) && file . isDirectory ( ) ) ) return ; String [ ] plugins = file . list ( ) ; if ( plugins == null ) return ; MiscUtilities . quicksort ( plugins , new MiscUtilities . StringICaseCompare ( ) ) ; for ( int i = 0 ; i < plugins . length ; i ++ ) { String plugin = plugins [ i ] ; if ( ! plugin . toLowerCase ( ) . endsWith ( ".jar" ) ) continue ; String path = MiscUtilities . constructPath ( directory , plugin ) ; if ( plugin . equals ( "EditBuddy.jar" ) || plugin . equals ( "PluginManager.jar" ) || plugin . equals ( "jaxp.jar" ) || plugin . equals ( "crimson.jar" ) ) { String [ ] args = { plugin } ; GUIUtilities . error ( null , "plugin.obsolete" , args ) ; continue ; } try { Log . log ( Log . DEBUG , jEdit . class , "Scanning JAR file: " + path ) ; new JARClassLoader ( path ) ; } catch ( IOException io ) { Log . log ( Log . ERROR , jEdit . class , "Cannot load" + " plugin " + plugin ) ; Log . log ( Log . ERROR , jEdit . class , io ) ; String [ ] args = { plugin , io . toString ( ) } ; GUIUtilities . error ( null , "plugin.load-error" , args ) ; } } } private static void initKeyBindings ( ) { inputHandler . removeAllKeyBindings ( ) ; EditAction [ ] actions = getActions ( ) ; for ( int i = 0 ; i < actions . length ; i ++ ) { EditAction action = actions [ i ] ; String shortcut1 = jEdit . getProperty ( action . getName ( ) + ".shortcut" ) ; if ( shortcut1 != null ) inputHandler . addKeyBinding ( shortcut1 , action ) ; String shortcut2 = jEdit . getProperty ( action . getName ( ) + ".shortcut2" ) ; if ( shortcut2 != null ) inputHandler . addKeyBinding ( shortcut2 , action ) ; } Vector macros = Macros . getMacroList ( ) ; for ( int i = 0 ; i < macros . size ( ) ; i ++ ) { Macros . Macro macro = ( Macros . Macro ) macros . elementAt ( i ) ; String shortcut1 = jEdit . getProperty ( macro . name + ".shortcut" ) ; if ( shortcut1 != null ) jEdit . getInputHandler ( ) . addKeyBinding ( shortcut1 , macro . action ) ; String shortcut2 = jEdit . getProperty ( macro . name + ".shortcut2" ) ; if ( shortcut2 != null ) jEdit . getInputHandler ( ) . addKeyBinding ( shortcut2 , macro . action ) ; } } } 	1	['99', '1', '0', '162', '325', '4043', '137', '48', '67', '0.915102041', '4367', '1', '7', '0', '0.059417706', '0', '0', '42.85858586', '56', '4.0707', '23']
package org . gjt . sp . util ; import javax . swing . text . * ; import java . io . * ; import java . util . StringTokenizer ; public class Log { public static final int MAXLINES = 500 ; public static final int DEBUG = 1 ; public static final int MESSAGE = 3 ; public static final int NOTICE = 5 ; public static final int WARNING = 7 ; public static final int ERROR = 9 ; public static void init ( boolean stdio , int level ) { if ( stdio ) { if ( System . out == realOut && System . err == realErr ) { System . setOut ( createPrintStream ( NOTICE , null ) ) ; System . setErr ( createPrintStream ( ERROR , null ) ) ; } } Log . level = level ; Log . stream = stream ; log ( MESSAGE , Log . class , "When reporting bugs, please" + " include the following information:" ) ; String [ ] props = { "java.version" , "java.vendor" , "java.compiler" , "os.name" , "os.version" , "os.arch" , "user.home" , "java.class.path" , } ; for ( int i = 0 ; i < props . length ; i ++ ) { log ( MESSAGE , Log . class , props [ i ] + "=" + System . getProperty ( props [ i ] ) ) ; } } public static void setLogWriter ( Writer stream ) { if ( Log . stream == null && stream != null ) { try { stream . write ( logDocument . getText ( 0 , logDocument . getLength ( ) ) ) ; stream . flush ( ) ; } catch ( Exception e ) { } } Log . stream = stream ; } public static Document getLogDocument ( ) { return logDocument ; } public static void flushStream ( ) { if ( stream != null ) { try { stream . flush ( ) ; } catch ( IOException io ) { io . printStackTrace ( realErr ) ; } } } public static void closeStream ( ) { if ( stream != null ) { try { stream . close ( ) ; stream = null ; } catch ( IOException io ) { io . printStackTrace ( realErr ) ; } } } public static void log ( int urgency , Object source , Object message ) { String _source ; if ( source == null ) { _source = Thread . currentThread ( ) . getName ( ) ; if ( _source == null ) { _source = Thread . currentThread ( ) . getClass ( ) . getName ( ) ; } } else if ( source instanceof Class ) _source = ( ( Class ) source ) . getName ( ) ; else _source = source . getClass ( ) . getName ( ) ; int index = _source . lastIndexOf ( '.' ) ; if ( index != - 1 ) _source = _source . substring ( index + 1 ) ; if ( message instanceof Throwable ) { _logException ( urgency , source , ( Throwable ) message ) ; } else { String _message = String . valueOf ( message ) ; synchronized ( LOCK ) { StringTokenizer st = new StringTokenizer ( _message , "\r\n" ) ; while ( st . hasMoreTokens ( ) ) { _log ( urgency , _source , st . nextToken ( ) ) ; } } } } private static Object LOCK = new Object ( ) ; private static Document logDocument ; private static int level ; private static Writer stream ; private static String lineSep ; private static PrintStream realOut ; private static PrintStream realErr ; static { level = WARNING ; realOut = System . out ; realErr = System . err ; logDocument = new PlainDocument ( ) ; lineSep = System . getProperty ( "line.separator" ) ; } private static PrintStream createPrintStream ( final int urgency , final Object source ) { return new PrintStream ( new OutputStream ( ) { public void write ( int b ) { byte [ ] barray = { ( byte ) b } ; write ( barray , 0 , 1 ) ; } public void write ( byte [ ] b , int off , int len ) { String str = new String ( b , off , len ) ; log ( urgency , source , str ) ; } } ) ; } private static void _logException ( final int urgency , final Object source , final Throwable message ) { PrintStream out = createPrintStream ( urgency , source ) ; synchronized ( LOCK ) { message . printStackTrace ( out ) ; } } private static void _log ( int urgency , String source , String message ) { String urgencyString = "[" + urgencyToString ( urgency ) + "] " ; String fullMessage = urgencyString + source + ": " + message ; try { logDocument . insertString ( logDocument . getLength ( ) , fullMessage , null ) ; logDocument . insertString ( logDocument . getLength ( ) , "\n" , null ) ; Element map = logDocument . getDefaultRootElement ( ) ; int lines = map . getElementCount ( ) ; if ( lines > MAXLINES ) { Element first = map . getElement ( 0 ) ; Element last = map . getElement ( lines - MAXLINES ) ; logDocument . remove ( first . getStartOffset ( ) , last . getEndOffset ( ) ) ; } if ( stream != null ) { stream . write ( fullMessage ) ; stream . write ( lineSep ) ; } } catch ( Exception e ) { e . printStackTrace ( realErr ) ; } message = urgencyString + message + '\n' ; if ( urgency >= level ) { if ( urgency == ERROR ) realErr . print ( message ) ; else realOut . print ( message ) ; } } private static String urgencyToString ( int urgency ) { switch ( urgency ) { case DEBUG : return "debug" ; case MESSAGE : return "message" ; case NOTICE : return "notice" ; case WARNING : return "warning" ; case ERROR : return "error" ; } throw new IllegalArgumentException ( "Invalid urgency: " + urgency ) ; } } 	0	['13', '1', '0', '64', '55', '36', '64', '1', '7', '0.886904762', '433', '0.571428571', '0', '0', '0.178571429', '0', '0', '31.23076923', '7', '2.3077', '0']
package org . gjt . sp . jedit . search ; import bsh . NameSpace ; import gnu . regexp . * ; import javax . swing . text . Segment ; import org . gjt . sp . jedit . BeanShell ; import org . gjt . sp . jedit . MiscUtilities ; public class RESearchMatcher implements SearchMatcher { public static final RESyntax RE_SYNTAX_JEDIT = new RESyntax ( RESyntax . RE_SYNTAX_PERL5 ) . set ( RESyntax . RE_CHAR_CLASSES ) . setLineSeparator ( "\n" ) ; public RESearchMatcher ( String search , String replace , boolean ignoreCase , boolean beanshell , String replaceMethod ) throws Exception { this . replace = MiscUtilities . escapesToChars ( replace ) ; this . beanshell = beanshell ; this . replaceMethod = replaceMethod ; replaceNS = new NameSpace ( BeanShell . getNameSpace ( ) , "search and replace" ) ; re = new RE ( search , ( ignoreCase ? RE . REG_ICASE : 0 ) | RE . REG_MULTILINE , RE_SYNTAX_JEDIT ) ; } public int [ ] nextMatch ( Segment text ) { REMatch match = re . getMatch ( new CharIndexedSegment ( text , 0 ) ) ; if ( match == null ) return null ; int start = match . getStartIndex ( ) ; int end = match . getEndIndex ( ) ; if ( start == end ) { return null ; } int [ ] result = { start , end } ; return result ; } public String substitute ( String text ) throws Exception { REMatch match = re . getMatch ( text ) ; if ( match == null ) return null ; if ( beanshell ) { int count = match . getSubCount ( ) ; for ( int i = 0 ; i < count ; i ++ ) replaceNS . setVariable ( "_" + i , match . toString ( i ) ) ; Object obj = BeanShell . runCachedBlock ( replaceMethod , null , replaceNS ) ; if ( obj == null ) return null ; else return obj . toString ( ) ; } else return match . substituteInto ( replace ) ; } private String replace ; private RE re ; private boolean beanshell ; private String replaceMethod ; private NameSpace replaceNS ; } 	1	['4', '1', '0', '11', '25', '0', '2', '9', '3', '0.611111111', '145', '0.833333333', '3', '0', '0.583333333', '0', '0', '33.75', '3', '1', '4']
package bsh ; public class EvalError extends Exception { SimpleNode node ; public EvalError ( String s ) { super ( s ) ; } public EvalError ( String s , SimpleNode node ) { super ( s ) ; this . node = node ; } public String toString ( ) { String trace ; if ( node != null ) trace = " : at Line: " + node . getLineNumber ( ) + " : in file: " + node . getSourceFile ( ) + " : " + node . getText ( ) ; else trace = ": <at unknown location>" ; return getMessage ( ) + trace ; } public void reThrow ( String msg ) throws EvalError { reThrow ( msg , null ) ; } public void reThrow ( SimpleNode node ) throws EvalError { reThrow ( null , node ) ; } public void reThrow ( String addMsg , SimpleNode addNode ) throws EvalError { String msg = getMessage ( ) ; if ( addMsg != null ) msg = addMsg + " : " + msg ; SimpleNode node = this . node ; if ( node == null && addNode != null ) node = addNode ; throw new EvalError ( msg , node ) ; } void setNode ( SimpleNode node ) { this . node = node ; } SimpleNode getNode ( ) { return node ; } public String getErrorText ( ) { if ( node != null ) return node . getText ( ) ; else return "<unknown error>" ; } public int getErrorLineNumber ( ) { if ( node != null ) return node . getLineNumber ( ) ; else return - 1 ; } public String getErrorSourceFile ( ) { if ( node != null ) return node . getSourceFile ( ) ; else return "<unknown file>" ; } } 	0	['11', '3', '2', '51', '20', '0', '51', '1', '9', '0.1', '137', '0', '1', '0.653846154', '0.575757576', '1', '1', '11.36363636', '2', '1.1818', '0']
package org . gjt . sp . jedit . search ; import javax . swing . text . BadLocationException ; import javax . swing . text . Element ; import javax . swing . text . Segment ; import javax . swing . tree . * ; import javax . swing . SwingUtilities ; import org . gjt . sp . jedit . io . VFSManager ; import org . gjt . sp . jedit . Buffer ; import org . gjt . sp . jedit . GUIUtilities ; import org . gjt . sp . jedit . jEdit ; import org . gjt . sp . jedit . View ; import org . gjt . sp . util . * ; public class HyperSearchRequest extends WorkRequest { public HyperSearchRequest ( View view , SearchMatcher matcher , HyperSearchResults results ) { this . view = view ; this . matcher = matcher ; this . results = results ; this . resultTreeModel = results . getTreeModel ( ) ; this . resultTreeRoot = ( DefaultMutableTreeNode ) resultTreeModel . getRoot ( ) ; } public void run ( ) { SearchFileSet fileset = SearchAndReplace . getSearchFileSet ( ) ; setProgressMaximum ( fileset . getBufferCount ( ) ) ; setStatus ( jEdit . getProperty ( "hypersearch.status" ) ) ; int resultCount = 0 ; int bufferCount = 0 ; try { int current = 0 ; Buffer buffer = fileset . getFirstBuffer ( view ) ; if ( buffer != null ) { do { setProgressValue ( ++ current ) ; int thisResultCount = doHyperSearch ( buffer , matcher ) ; if ( thisResultCount != 0 ) { bufferCount ++ ; resultCount += thisResultCount ; } } while ( ( buffer = fileset . getNextBuffer ( view , buffer ) ) != null ) ; } } catch ( Exception e ) { Log . log ( Log . ERROR , this , e ) ; Object [ ] args = { e . getMessage ( ) } ; if ( args [ 0 ] == null ) args [ 0 ] = e . toString ( ) ; VFSManager . error ( view , "searcherror" , args ) ; } catch ( WorkThread . Abort a ) { } finally { final int _resultCount = resultCount ; final int _bufferCount = bufferCount ; VFSManager . runInAWTThread ( new Runnable ( ) { public void run ( ) { results . searchDone ( _resultCount , _bufferCount ) ; } } ) ; } } private View view ; private SearchMatcher matcher ; private HyperSearchResults results ; private DefaultTreeModel resultTreeModel ; private DefaultMutableTreeNode resultTreeRoot ; private int doHyperSearch ( Buffer buffer , SearchMatcher matcher ) throws Exception { setAbortable ( false ) ; int resultCount = 0 ; final DefaultMutableTreeNode bufferNode = new DefaultMutableTreeNode ( buffer . getPath ( ) ) ; try { buffer . readLock ( ) ; Element map = buffer . getDefaultRootElement ( ) ; Segment text = new Segment ( ) ; int offset = 0 ; int length = buffer . getLength ( ) ; int line = - 1 ; loop : for ( ; ; ) { buffer . getText ( offset , length - offset , text ) ; int [ ] match = matcher . nextMatch ( text ) ; if ( match == null ) break loop ; offset += match [ 1 ] ; int newLine = map . getElementIndex ( offset ) ; if ( line == newLine ) { continue loop ; } line = newLine ; resultCount ++ ; bufferNode . insert ( new DefaultMutableTreeNode ( new HyperSearchResult ( buffer , line ) , false ) , bufferNode . getChildCount ( ) ) ; } } finally { buffer . readUnlock ( ) ; } if ( resultCount != 0 ) { resultTreeRoot . insert ( bufferNode , resultTreeRoot . getChildCount ( ) ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { resultTreeModel . reload ( resultTreeRoot ) ; } } ) ; } setAbortable ( true ) ; return resultCount ; } } 	1	['6', '2', '0', '14', '40', '3', '3', '14', '2', '0.72', '252', '1', '3', '0.5', '0.305555556', '1', '1', '40.16666667', '10', '2.3333', '3']
package org . gjt . sp . jedit . syntax ; import javax . swing . text . Segment ; import org . gjt . sp . jedit . TextUtilities ; public class KeywordMap { public KeywordMap ( boolean ignoreCase ) { this ( ignoreCase , 52 ) ; this . ignoreCase = ignoreCase ; } public KeywordMap ( boolean ignoreCase , int mapLength ) { this . mapLength = mapLength ; this . ignoreCase = ignoreCase ; map = new Keyword [ mapLength ] ; } public byte lookup ( Segment text , int offset , int length ) { if ( length == 0 ) return Token . NULL ; Keyword k = map [ getSegmentMapKey ( text , offset , length ) ] ; while ( k != null ) { if ( length != k . keyword . length ) { k = k . next ; continue ; } if ( TextUtilities . regionMatches ( ignoreCase , text , offset , k . keyword ) ) return k . id ; k = k . next ; } return Token . NULL ; } public void add ( String keyword , byte id ) { int key = getStringMapKey ( keyword ) ; map [ key ] = new Keyword ( keyword . toCharArray ( ) , id , map [ key ] ) ; } public boolean getIgnoreCase ( ) { return ignoreCase ; } public void setIgnoreCase ( boolean ignoreCase ) { this . ignoreCase = ignoreCase ; } protected int mapLength ; protected int getStringMapKey ( String s ) { return ( Character . toUpperCase ( s . charAt ( 0 ) ) + Character . toUpperCase ( s . charAt ( s . length ( ) - 1 ) ) ) % mapLength ; } protected int getSegmentMapKey ( Segment s , int off , int len ) { return ( Character . toUpperCase ( s . array [ off ] ) + Character . toUpperCase ( s . array [ off + len - 1 ] ) ) % mapLength ; } class Keyword { public Keyword ( char [ ] keyword , byte id , Keyword next ) { this . keyword = keyword ; this . id = id ; this . next = next ; } public char [ ] keyword ; public byte id ; public Keyword next ; } private Keyword [ ] map ; private boolean ignoreCase ; } 	0	['8', '1', '0', '5', '15', '0', '4', '2', '6', '0.428571429', '139', '1', '1', '0', '0.395833333', '0', '0', '16', '5', '1.375', '0']
package org . gjt . sp . jedit . gui ; import javax . swing . JOptionPane ; import javax . swing . JPopupMenu ; import java . awt . event . * ; import java . awt . Component ; import java . util . * ; import org . gjt . sp . jedit . textarea . JEditTextArea ; import org . gjt . sp . jedit . * ; import org . gjt . sp . util . Log ; public abstract class InputHandler extends KeyAdapter { public InputHandler ( View view ) { this . view = view ; } public abstract void addKeyBinding ( String keyBinding , EditAction action ) ; public abstract void removeKeyBinding ( String keyBinding ) ; public abstract void removeAllKeyBindings ( ) ; public boolean isPrefixActive ( ) { return false ; } public boolean isRepeatEnabled ( ) { return repeat ; } public void setRepeatEnabled ( boolean repeat ) { this . repeat = repeat ; repeatCount = 0 ; view . getStatus ( ) . setMessage ( null ) ; } public int getRepeatCount ( ) { return ( repeat && repeatCount > 0 ? repeatCount : 1 ) ; } public void setRepeatCount ( int repeatCount ) { repeat = true ; this . repeatCount = repeatCount ; view . getStatus ( ) . setMessage ( null ) ; } public EditAction getLastAction ( ) { return lastAction ; } public int getLastActionCount ( ) { return lastActionCount ; } public void readNextChar ( String msg , String code ) { view . getStatus ( ) . setMessage ( msg ) ; readNextChar ( code ) ; } public void readNextChar ( String code ) { readNextChar = code ; } public void invokeAction ( EditAction action ) { Buffer buffer = view . getBuffer ( ) ; buffer . endCompoundEdit ( ) ; if ( lastAction == action ) lastActionCount ++ ; else { lastAction = action ; lastActionCount = 1 ; } boolean _repeat = repeat ; int _repeatCount = getRepeatCount ( ) ; if ( action . noRepeat ( ) || _repeatCount == 1 ) action . invoke ( view ) ; else { if ( _repeatCount > REPEAT_COUNT_THRESHOLD ) { String label = jEdit . getProperty ( action . getName ( ) + ".label" ) ; if ( label == null ) label = action . getName ( ) ; else label = GUIUtilities . prettifyMenuLabel ( label ) ; Object [ ] pp = { label , new Integer ( _repeatCount ) } ; if ( GUIUtilities . confirm ( view , "large-repeat-count" , pp , JOptionPane . WARNING_MESSAGE , JOptionPane . YES_NO_OPTION ) != JOptionPane . YES_OPTION ) { repeat = false ; repeatCount = 0 ; view . getStatus ( ) . setMessage ( null ) ; return ; } } try { buffer . beginCompoundEdit ( ) ; for ( int i = 0 ; i < _repeatCount ; i ++ ) action . invoke ( view ) ; } finally { buffer . endCompoundEdit ( ) ; } } Macros . Recorder recorder = view . getMacroRecorder ( ) ; if ( recorder != null && ! action . noRecord ( ) ) recorder . record ( _repeatCount , action . getCode ( ) ) ; if ( _repeat ) { if ( readNextChar != null ) return ; repeat = false ; repeatCount = 0 ; view . getStatus ( ) . setMessage ( null ) ; } } private static final int REPEAT_COUNT_THRESHOLD = 20 ; protected View view ; protected boolean repeat ; protected int repeatCount ; protected EditAction lastAction ; protected int lastActionCount ; protected String readNextChar ; protected void userInput ( char ch ) { lastAction = null ; if ( readNextChar != null ) invokeReadNextChar ( ch ) ; else { Buffer buffer = view . getBuffer ( ) ; if ( ! buffer . insideCompoundEdit ( ) ) buffer . beginCompoundEdit ( ) ; JEditTextArea textArea = view . getTextArea ( ) ; int _repeatCount = getRepeatCount ( ) ; if ( _repeatCount == 1 ) textArea . userInput ( ch ) ; else { if ( _repeatCount > REPEAT_COUNT_THRESHOLD ) { Object [ ] pp = { String . valueOf ( ch ) , new Integer ( _repeatCount ) } ; if ( GUIUtilities . confirm ( view , "large-repeat-count.user-input" , pp , JOptionPane . WARNING_MESSAGE , JOptionPane . YES_NO_OPTION ) != JOptionPane . YES_OPTION ) { repeat = false ; repeatCount = 0 ; view . getStatus ( ) . setMessage ( null ) ; return ; } } for ( int i = 0 ; i < _repeatCount ; i ++ ) textArea . userInput ( ch ) ; } Macros . Recorder recorder = view . getMacroRecorder ( ) ; if ( recorder != null ) recorder . record ( _repeatCount , ch ) ; } setRepeatEnabled ( false ) ; } protected void invokeReadNextChar ( char ch ) { String charStr = MiscUtilities . charsToEscapes ( String . valueOf ( ch ) ) ; int index ; while ( ( index = readNextChar . indexOf ( "__char__" ) ) != - 1 ) { readNextChar = readNextChar . substring ( 0 , index ) + '\'' + charStr + '\'' + readNextChar . substring ( index + 8 ) ; } Macros . Recorder recorder = view . getMacroRecorder ( ) ; if ( recorder != null ) recorder . record ( getRepeatCount ( ) , readNextChar ) ; if ( getRepeatCount ( ) != 1 ) { Buffer buffer = view . getBuffer ( ) ; try { buffer . beginCompoundEdit ( ) ; BeanShell . eval ( view , "for(int i = 1; i < " + getRepeatCount ( ) + "; i++)\n{\n" + readNextChar + "\n}" , false ) ; } finally { buffer . endCompoundEdit ( ) ; } } else BeanShell . eval ( view , readNextChar , false ) ; readNextChar = null ; view . getStatus ( ) . setMessage ( null ) ; } } 	1	['16', '2', '1', '13', '47', '48', '8', '10', '14', '0.780952381', '443', '1', '2', '0.166666667', '0.241071429', '0', '0', '26.25', '14', '2.625', '6']
package org . gjt . sp . jedit . browser ; import java . awt . * ; import java . awt . event . * ; import java . util . * ; import javax . swing . * ; import javax . swing . event . * ; import org . gjt . sp . jedit . io . * ; import org . gjt . sp . jedit . search . * ; import org . gjt . sp . jedit . * ; public class BrowserPopupMenu extends JPopupMenu { public BrowserPopupMenu ( VFSBrowser browser , VFS . DirectoryEntry file ) { this . browser = browser ; if ( file != null ) { this . file = file ; this . vfs = VFSManager . getVFSForPath ( file . path ) ; boolean delete = ( vfs . getCapabilities ( ) & VFS . DELETE_CAP ) != 0 ; boolean rename = ( vfs . getCapabilities ( ) & VFS . RENAME_CAP ) != 0 ; if ( jEdit . getBuffer ( file . path ) != null ) { if ( browser . getMode ( ) == VFSBrowser . BROWSER ) { add ( createMenuItem ( "open" ) ) ; add ( createMenuItem ( "insert" ) ) ; add ( createMenuItem ( "close" ) ) ; } else add ( createMenuItem ( "choose" ) ) ; } else { if ( file . type == VFS . DirectoryEntry . DIRECTORY || file . type == VFS . DirectoryEntry . FILESYSTEM ) { add ( createMenuItem ( "browse" ) ) ; } else if ( browser . getMode ( ) != VFSBrowser . BROWSER ) { add ( createMenuItem ( "choose" ) ) ; } else { add ( createMenuItem ( "open" ) ) ; add ( createOpenEncodingMenu ( ) ) ; add ( createMenuItem ( "insert" ) ) ; } if ( rename ) add ( createMenuItem ( "rename" ) ) ; if ( delete ) add ( createMenuItem ( "delete" ) ) ; } addSeparator ( ) ; } else vfs = VFSManager . getVFSForPath ( browser . getDirectory ( ) ) ; JCheckBoxMenuItem showHiddenFiles = new JCheckBoxMenuItem ( jEdit . getProperty ( "vfs.browser.menu.show-hidden-files.label" ) ) ; showHiddenFiles . setActionCommand ( "show-hidden-files" ) ; showHiddenFiles . setSelected ( browser . getShowHiddenFiles ( ) ) ; showHiddenFiles . addActionListener ( new ActionHandler ( ) ) ; add ( showHiddenFiles ) ; addSeparator ( ) ; add ( createMenuItem ( "new-file" ) ) ; add ( createMenuItem ( "new-directory" ) ) ; addSeparator ( ) ; if ( browser . getMode ( ) == VFSBrowser . BROWSER && vfs instanceof FileVFS ) { add ( createMenuItem ( "search-in-directory" ) ) ; addSeparator ( ) ; } add ( createMenuItem ( "add-to-favorites" ) ) ; add ( createMenuItem ( "go-to-favorites" ) ) ; Vector vec = new Vector ( ) ; Enumeration enum = VFSManager . getFilesystems ( ) ; while ( enum . hasMoreElements ( ) ) { VFS vfs = ( VFS ) enum . nextElement ( ) ; if ( ( vfs . getCapabilities ( ) & VFS . BROWSE_CAP ) == 0 ) continue ; JMenuItem menuItem = new JMenuItem ( jEdit . getProperty ( "vfs." + vfs . getName ( ) + ".label" ) ) ; menuItem . setActionCommand ( "vfs." + vfs . getName ( ) ) ; menuItem . addActionListener ( new ActionHandler ( ) ) ; vec . addElement ( menuItem ) ; } if ( vec . size ( ) != 0 ) { addSeparator ( ) ; MiscUtilities . quicksort ( vec , new MiscUtilities . MenuItemCompare ( ) ) ; for ( int i = 0 ; i < vec . size ( ) ; i ++ ) add ( ( JMenuItem ) vec . elementAt ( i ) ) ; } } private VFSBrowser browser ; private VFS . DirectoryEntry file ; private VFS vfs ; private JMenuItem createMenuItem ( String name ) { String label = jEdit . getProperty ( "vfs.browser.menu." + name + ".label" ) ; JMenuItem mi = new JMenuItem ( label ) ; mi . setActionCommand ( name ) ; mi . addActionListener ( new ActionHandler ( ) ) ; return mi ; } private JMenu createOpenEncodingMenu ( ) { ActionListener listener = new ActionHandler ( ) ; JMenu openEncoding = new JMenu ( jEdit . getProperty ( "open-encoding.label" ) ) ; String systemEncoding = System . getProperty ( "file.encoding" ) ; JMenuItem mi = new JMenuItem ( jEdit . getProperty ( "os-encoding" ) ) ; mi . setActionCommand ( "open@" + systemEncoding ) ; mi . addActionListener ( listener ) ; openEncoding . add ( mi ) ; mi = new JMenuItem ( jEdit . getProperty ( "jedit-encoding" ) ) ; mi . setActionCommand ( "open@" + jEdit . getProperty ( "buffer.encoding" , systemEncoding ) ) ; mi . addActionListener ( listener ) ; openEncoding . add ( mi ) ; openEncoding . addSeparator ( ) ; StringTokenizer st = new StringTokenizer ( jEdit . getProperty ( "encodings" ) ) ; while ( st . hasMoreTokens ( ) ) { String encoding = st . nextToken ( ) ; mi = new JMenuItem ( encoding ) ; mi . setActionCommand ( "open@" + encoding ) ; mi . addActionListener ( listener ) ; openEncoding . add ( mi ) ; } openEncoding . addSeparator ( ) ; mi = new JMenuItem ( jEdit . getProperty ( "other-encoding.label" ) ) ; mi . setActionCommand ( "other-encoding" ) ; mi . addActionListener ( listener ) ; openEncoding . add ( mi ) ; return openEncoding ; } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { View view = browser . getView ( ) ; String actionCommand = evt . getActionCommand ( ) ; if ( actionCommand . startsWith ( "open@" ) ) { Hashtable props = new Hashtable ( ) ; props . put ( Buffer . ENCODING , actionCommand . substring ( 5 ) ) ; jEdit . openFile ( view , null , file . path , false , props ) ; } else if ( actionCommand . equals ( "other-encoding" ) ) { String encoding = GUIUtilities . input ( browser , "encoding-prompt" , null , jEdit . getProperty ( "buffer.encoding" , System . getProperty ( "file.encoding" ) ) ) ; if ( encoding == null ) return ; Hashtable props = new Hashtable ( ) ; props . put ( Buffer . ENCODING , encoding ) ; jEdit . openFile ( view , null , file . path , false , props ) ; } else if ( actionCommand . equals ( "open" ) ) jEdit . openFile ( view , file . path ) ; else if ( actionCommand . equals ( "insert" ) ) view . getBuffer ( ) . insert ( view , file . path ) ; else if ( actionCommand . equals ( "choose" ) ) browser . filesActivated ( ) ; else if ( actionCommand . equals ( "close" ) ) { Buffer buffer = jEdit . getBuffer ( file . path ) ; if ( buffer != null ) jEdit . closeBuffer ( view , buffer ) ; } else if ( actionCommand . equals ( "browse" ) ) browser . setDirectory ( file . path ) ; else if ( evt . getActionCommand ( ) . equals ( "rename" ) ) browser . rename ( file . path ) ; else if ( evt . getActionCommand ( ) . equals ( "delete" ) ) browser . delete ( file . deletePath ) ; else if ( actionCommand . equals ( "show-hidden-files" ) ) { browser . setShowHiddenFiles ( ! browser . getShowHiddenFiles ( ) ) ; browser . reloadDirectory ( ) ; } else if ( actionCommand . equals ( "new-file" ) ) { VFS . DirectoryEntry [ ] selected = browser . getSelectedFiles ( ) ; if ( selected . length >= 1 ) { VFS . DirectoryEntry file = selected [ 0 ] ; if ( file . type == VFS . DirectoryEntry . DIRECTORY ) jEdit . newFile ( view , file . path ) ; else { VFS vfs = VFSManager . getVFSForPath ( file . path ) ; jEdit . newFile ( view , vfs . getParentOfPath ( file . path ) ) ; } } else jEdit . newFile ( view , browser . getDirectory ( ) ) ; } else if ( actionCommand . equals ( "new-directory" ) ) browser . mkdir ( ) ; else if ( actionCommand . equals ( "search-in-directory" ) ) { String path ; VFS . DirectoryEntry [ ] selected = browser . getSelectedFiles ( ) ; if ( selected . length >= 1 ) { VFS . DirectoryEntry file = selected [ 0 ] ; if ( file . type == VFS . DirectoryEntry . DIRECTORY ) path = file . path ; else { VFS vfs = VFSManager . getVFSForPath ( file . path ) ; path = vfs . getParentOfPath ( file . path ) ; } } else path = browser . getDirectory ( ) ; SearchAndReplace . setSearchFileSet ( new DirectoryListSet ( path , browser . getFilenameFilter ( ) , true ) ) ; new SearchDialog ( browser . getView ( ) , null , SearchDialog . DIRECTORY ) ; } else if ( actionCommand . equals ( "add-to-favorites" ) ) { Vector toAdd = new Vector ( ) ; VFS . DirectoryEntry [ ] selected = browser . getSelectedFiles ( ) ; for ( int i = 0 ; i < selected . length ; i ++ ) { VFS . DirectoryEntry file = selected [ i ] ; if ( file . type == VFS . DirectoryEntry . FILE ) { GUIUtilities . error ( browser , "vfs.browser.files-favorites" , null ) ; return ; } else toAdd . addElement ( file . path ) ; } if ( toAdd . size ( ) != 0 ) { for ( int i = 0 ; i < toAdd . size ( ) ; i ++ ) { FavoritesVFS . addToFavorites ( ( String ) toAdd . elementAt ( i ) ) ; } } else { String directory = browser . getDirectory ( ) ; if ( directory . equals ( FavoritesVFS . PROTOCOL + ":" ) ) { GUIUtilities . error ( browser , "vfs.browser.recurse-favorites" , null ) ; } else { FavoritesVFS . addToFavorites ( directory ) ; } } } else if ( actionCommand . equals ( "go-to-favorites" ) ) browser . setDirectory ( FavoritesVFS . PROTOCOL + ":" ) ; else if ( actionCommand . startsWith ( "vfs." ) ) { String vfsName = actionCommand . substring ( 4 ) ; VFS vfs = VFSManager . getVFSByName ( vfsName ) ; String directory = vfs . showBrowseDialog ( null , browser ) ; if ( directory != null ) browser . setDirectory ( directory ) ; } } } } 	0	['5', '5', '0', '14', '45', '6', '4', '11', '1', '0.833333333', '458', '1', '3', '0.994436718', '0.32', '0', '0', '90', '3', '1.4', '0']
package org . gjt . sp . jedit . search ; import javax . swing . * ; import javax . swing . border . * ; import javax . swing . text . * ; import javax . swing . tree . * ; import java . awt . * ; import java . awt . event . * ; import org . gjt . sp . jedit . gui . * ; import org . gjt . sp . jedit . io . VFSManager ; import org . gjt . sp . jedit . msg . * ; import org . gjt . sp . jedit . jEdit ; import org . gjt . sp . jedit . Buffer ; import org . gjt . sp . jedit . EBComponent ; import org . gjt . sp . jedit . EBMessage ; import org . gjt . sp . jedit . EditBus ; import org . gjt . sp . jedit . View ; import org . gjt . sp . util . Log ; public class HyperSearchResults extends JPanel implements DockableWindow , EBComponent { public static final String NAME = "hypersearch-results" ; public HyperSearchResults ( View view ) { super ( new BorderLayout ( ) ) ; this . view = view ; caption = new JLabel ( ) ; updateCaption ( 0 , 0 ) ; add ( BorderLayout . NORTH , caption ) ; resultTreeRoot = new DefaultMutableTreeNode ( ) ; resultTreeModel = new DefaultTreeModel ( resultTreeRoot ) ; resultTree = new JTree ( resultTreeModel ) ; resultTree . setCellRenderer ( new ResultCellRenderer ( ) ) ; resultTree . setVisibleRowCount ( 16 ) ; resultTree . setRootVisible ( false ) ; resultTree . setShowsRootHandles ( true ) ; resultTree . putClientProperty ( "JTree.lineStyle" , "Angled" ) ; resultTree . setEditable ( false ) ; resultTree . addMouseListener ( new MouseHandler ( ) ) ; JScrollPane scrollPane = new JScrollPane ( resultTree ) ; Dimension dim = scrollPane . getPreferredSize ( ) ; dim . width = 400 ; scrollPane . setPreferredSize ( dim ) ; add ( BorderLayout . CENTER , scrollPane ) ; } public String getName ( ) { return NAME ; } public Component getComponent ( ) { return this ; } public void addNotify ( ) { super . addNotify ( ) ; EditBus . addToBus ( this ) ; } public void removeNotify ( ) { super . removeNotify ( ) ; EditBus . removeFromBus ( this ) ; } public void handleMessage ( EBMessage msg ) { if ( msg instanceof BufferUpdate ) { BufferUpdate bmsg = ( BufferUpdate ) msg ; Buffer buffer = bmsg . getBuffer ( ) ; if ( bmsg . getWhat ( ) == BufferUpdate . LOADED ) { for ( int i = resultTreeRoot . getChildCount ( ) - 1 ; i >= 0 ; i -- ) { DefaultMutableTreeNode bufferNode = ( DefaultMutableTreeNode ) resultTreeRoot . getChildAt ( i ) ; for ( int j = bufferNode . getChildCount ( ) - 1 ; j >= 0 ; j -- ) { HyperSearchResult result = ( HyperSearchResult ) ( ( DefaultMutableTreeNode ) bufferNode . getChildAt ( j ) ) . getUserObject ( ) ; if ( buffer . getPath ( ) . equals ( result . path ) ) result . bufferOpened ( buffer ) ; } } } else if ( bmsg . getWhat ( ) == BufferUpdate . CLOSED ) { for ( int i = resultTreeRoot . getChildCount ( ) - 1 ; i >= 0 ; i -- ) { DefaultMutableTreeNode bufferNode = ( DefaultMutableTreeNode ) resultTreeRoot . getChildAt ( i ) ; for ( int j = bufferNode . getChildCount ( ) - 1 ; j >= 0 ; j -- ) { HyperSearchResult result = ( HyperSearchResult ) ( ( DefaultMutableTreeNode ) bufferNode . getChildAt ( j ) ) . getUserObject ( ) ; if ( buffer . getPath ( ) . equals ( result . path ) ) result . bufferClosed ( ) ; } } } } } public DefaultTreeModel getTreeModel ( ) { return resultTreeModel ; } public void searchStarted ( ) { caption . setText ( jEdit . getProperty ( "hypersearch-results.searching" ) ) ; resultTreeRoot . removeAllChildren ( ) ; resultTreeModel . reload ( resultTreeRoot ) ; } public void searchDone ( int resultCount , int bufferCount ) { updateCaption ( resultCount , bufferCount ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { if ( resultTreeRoot . getChildCount ( ) == 1 ) { resultTree . expandPath ( new TreePath ( ( ( DefaultMutableTreeNode ) resultTreeRoot . getChildAt ( 0 ) ) . getPath ( ) ) ) ; } } } ) ; } private View view ; private JLabel caption ; private JTree resultTree ; private DefaultMutableTreeNode resultTreeRoot ; private DefaultTreeModel resultTreeModel ; private void updateCaption ( int resultCount , int bufferCount ) { Object [ ] pp = { new Integer ( resultCount ) , new Integer ( bufferCount ) } ; caption . setText ( jEdit . getProperty ( "hypersearch-results.caption" , pp ) ) ; } class MouseHandler extends MouseAdapter { public void mouseClicked ( MouseEvent evt ) { TreePath path = resultTree . getPathForLocation ( evt . getX ( ) , evt . getY ( ) ) ; if ( path == null ) return ; Object value = ( ( DefaultMutableTreeNode ) path . getLastPathComponent ( ) ) . getUserObject ( ) ; if ( value instanceof String ) { Buffer buffer = jEdit . openFile ( view , ( String ) value ) ; if ( buffer == null ) return ; view . setBuffer ( buffer ) ; view . toFront ( ) ; view . requestFocus ( ) ; } else { final HyperSearchResult result = ( HyperSearchResult ) value ; final Buffer buffer = result . getBuffer ( ) ; if ( buffer == null ) return ; VFSManager . runInAWTThread ( new Runnable ( ) { public void run ( ) { int pos = result . linePos . getOffset ( ) ; view . setBuffer ( buffer ) ; view . getTextArea ( ) . setCaretPosition ( pos ) ; view . toFront ( ) ; view . requestFocus ( ) ; } } ) ; } } } class ResultCellRenderer extends DefaultTreeCellRenderer { public Component getTreeCellRendererComponent ( JTree tree , Object value , boolean sel , boolean expanded , boolean leaf , int row , boolean hasFocus ) { Component comp = super . getTreeCellRendererComponent ( tree , value , sel , expanded , leaf , row , hasFocus ) ; if ( ! ( comp instanceof JLabel ) ) return comp ; JLabel label = ( JLabel ) comp ; label . setIcon ( null ) ; return label ; } } } 	1	['13', '5', '0', '17', '53', '54', '8', '12', '9', '0.875', '303', '0.833333333', '1', '0.981954887', '0.261538462', '3', '12', '21.84615385', '10', '1.6923', '2']
