package org . apache . xerces . dom ; import org . w3c . dom . range . * ; public class RangeExceptionImpl extends RangeException { public RangeExceptionImpl ( short code , String message ) { super ( code , message ) ; } } 	1	['1', '5', '0', '1', '2', '0', '1', '0', '1', '2', '6', '0', '0', '1', '1', '0', '0', '5', '0', '0', '1']
package org . apache . xerces . dom ; import java . io . * ; import org . w3c . dom . * ; import org . w3c . dom . events . * ; import org . apache . xerces . dom . * ; import org . apache . xerces . dom . events . * ; public abstract class ChildAndParentNode extends ChildNode { static final long serialVersionUID = 0 ; protected DocumentImpl ownerDocument ; protected ChildNode firstChild = null ; protected transient int nodeListLength = - 1 ; protected transient ChildNode nodeListNode ; protected transient int nodeListIndex = - 1 ; protected ChildAndParentNode ( DocumentImpl ownerDocument ) { super ( ownerDocument ) ; this . ownerDocument = ownerDocument ; } public ChildAndParentNode ( ) { } public Node cloneNode ( boolean deep ) { ChildAndParentNode newnode = ( ChildAndParentNode ) super . cloneNode ( deep ) ; newnode . ownerDocument = ownerDocument ; if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } newnode . firstChild = null ; newnode . nodeListIndex = - 1 ; newnode . nodeListLength = - 1 ; if ( deep ) { for ( Node child = firstChild ; child != null ; child = child . getNextSibling ( ) ) { newnode . appendChild ( child . cloneNode ( true ) ) ; } } return newnode ; } public Document getOwnerDocument ( ) { return ownerDocument ; } DocumentImpl ownerDocument ( ) { return ownerDocument ; } void setOwnerDocument ( DocumentImpl doc ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } for ( Node child = firstChild ; child != null ; child = child . getNextSibling ( ) ) { ( ( NodeImpl ) child ) . setOwnerDocument ( doc ) ; } ownerDocument = doc ; } public boolean hasChildNodes ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return firstChild != null ; } public NodeList getChildNodes ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return this ; } public Node getFirstChild ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return firstChild ; } public Node getLastChild ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return lastChild ( ) ; } final ChildNode lastChild ( ) { return firstChild != null ? firstChild . previousSibling : null ; } final void lastChild ( ChildNode node ) { if ( firstChild != null ) { firstChild . previousSibling = node ; } } public Node insertBefore ( Node newChild , Node refChild ) throws DOMException { return internalInsertBefore ( newChild , refChild , MUTATION_ALL ) ; } Node internalInsertBefore ( Node newChild , Node refChild , int mutationMask ) throws DOMException { if ( isReadOnly ( ) ) throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; boolean errorChecking = ownerDocument . errorChecking ; if ( errorChecking && newChild . getOwnerDocument ( ) != ownerDocument ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } if ( errorChecking ) { boolean treeSafe = true ; for ( NodeImpl a = parentNode ( ) ; treeSafe && a != null ; a = a . parentNode ( ) ) { treeSafe = newChild != a ; } if ( ! treeSafe ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } if ( refChild != null && refChild . getParentNode ( ) != this ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } } if ( newChild . getNodeType ( ) == Node . DOCUMENT_FRAGMENT_NODE ) { for ( Node kid = newChild . getFirstChild ( ) ; kid != null ; kid = kid . getNextSibling ( ) ) { if ( errorChecking && ! ownerDocument . isKidOK ( this , kid ) ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } } while ( newChild . hasChildNodes ( ) ) { insertBefore ( newChild . getFirstChild ( ) , refChild ) ; } } else if ( errorChecking && ( ! ( newChild instanceof ChildNode ) || ! ownerDocument . isKidOK ( this , newChild ) ) ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } else { ChildNode newInternal = ( ChildNode ) newChild ; EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents && ( mutationMask & MUTATION_AGGREGATE ) != 0 ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } } Node oldparent = newInternal . parentNode ( ) ; if ( oldparent != null ) { oldparent . removeChild ( newInternal ) ; } ChildNode refInternal = ( ChildNode ) refChild ; newInternal . ownerNode = this ; newInternal . isOwned ( true ) ; if ( firstChild == null ) { firstChild = newInternal ; newInternal . isFirstChild ( true ) ; newInternal . previousSibling = newInternal ; } else { if ( refInternal == null ) { ChildNode lastChild = firstChild . previousSibling ; lastChild . nextSibling = newInternal ; newInternal . previousSibling = lastChild ; firstChild . previousSibling = newInternal ; } else { if ( refChild == firstChild ) { firstChild . isFirstChild ( false ) ; newInternal . nextSibling = firstChild ; newInternal . previousSibling = firstChild . previousSibling ; firstChild . previousSibling = newInternal ; firstChild = newInternal ; newInternal . isFirstChild ( true ) ; } else { ChildNode prev = refInternal . previousSibling ; newInternal . nextSibling = refInternal ; prev . nextSibling = newInternal ; refInternal . previousSibling = newInternal ; newInternal . previousSibling = prev ; } } } changed ( ) ; if ( nodeListLength != - 1 ) { nodeListLength ++ ; } if ( nodeListIndex != - 1 ) { if ( nodeListNode == refInternal ) { nodeListNode = newInternal ; } else { nodeListIndex = - 1 ; } } if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( ( mutationMask & MUTATION_LOCAL ) != 0 ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_NODE_INSERTED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_INSERTED , true , false , this , null , null , null ) ; newInternal . dispatchEvent ( me ) ; } lc = LCount . lookup ( MutationEventImpl . DOM_NODE_INSERTED_INTO_DOCUMENT ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { NodeImpl eventAncestor = this ; if ( enclosingAttr != null ) eventAncestor = ( NodeImpl ) ( enclosingAttr . node . getOwnerElement ( ) ) ; if ( eventAncestor != null ) { NodeImpl p = eventAncestor ; while ( p != null ) { eventAncestor = p ; if ( p . getNodeType ( ) == ATTRIBUTE_NODE ) p = ( ElementImpl ) ( ( AttrImpl ) p ) . getOwnerElement ( ) ; else p = p . parentNode ( ) ; } if ( eventAncestor . getNodeType ( ) == Node . DOCUMENT_NODE ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_INSERTED_INTO_DOCUMENT , false , false , null , null , null , null ) ; dispatchEventToSubtree ( newInternal , me ) ; } } } } if ( ( mutationMask & MUTATION_AGGREGATE ) != 0 ) dispatchAggregateEvents ( enclosingAttr ) ; } } return newChild ; } public Node removeChild ( Node oldChild ) throws DOMException { return internalRemoveChild ( oldChild , MUTATION_ALL ) ; } Node internalRemoveChild ( Node oldChild , int mutationMask ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( ownerDocument . errorChecking && oldChild != null && oldChild . getParentNode ( ) != this ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } ownerDocument . removedChildNode ( oldChild ) ; ChildNode oldInternal = ( ChildNode ) oldChild ; EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } if ( ( mutationMask & MUTATION_LOCAL ) != 0 ) { lc = LCount . lookup ( MutationEventImpl . DOM_NODE_REMOVED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_REMOVED , true , false , this , null , null , null ) ; oldInternal . dispatchEvent ( me ) ; } lc = LCount . lookup ( MutationEventImpl . DOM_NODE_REMOVED_FROM_DOCUMENT ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { NodeImpl eventAncestor = this ; if ( enclosingAttr != null ) eventAncestor = ( NodeImpl ) enclosingAttr . node . getOwnerElement ( ) ; if ( eventAncestor != null ) { for ( NodeImpl p = eventAncestor . parentNode ( ) ; p != null ; p = p . parentNode ( ) ) { eventAncestor = p ; } if ( eventAncestor . getNodeType ( ) == Node . DOCUMENT_NODE ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_REMOVED_FROM_DOCUMENT , false , false , null , null , null , null ) ; dispatchEventToSubtree ( oldInternal , me ) ; } } } } } if ( nodeListLength != - 1 ) { nodeListLength -- ; } if ( nodeListIndex != - 1 ) { if ( nodeListNode == oldInternal ) { nodeListIndex -- ; nodeListNode = oldInternal . previousSibling ( ) ; } else { nodeListIndex = - 1 ; } } if ( oldInternal == firstChild ) { oldInternal . isFirstChild ( false ) ; firstChild = oldInternal . nextSibling ; if ( firstChild != null ) { firstChild . isFirstChild ( true ) ; firstChild . previousSibling = oldInternal . previousSibling ; } } else { ChildNode prev = oldInternal . previousSibling ; ChildNode next = oldInternal . nextSibling ; prev . nextSibling = next ; if ( next == null ) { firstChild . previousSibling = prev ; } else { next . previousSibling = prev ; } } oldInternal . ownerNode = ownerDocument ; oldInternal . isOwned ( false ) ; oldInternal . nextSibling = null ; oldInternal . previousSibling = null ; changed ( ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( ( mutationMask & MUTATION_AGGREGATE ) != 0 ) dispatchAggregateEvents ( enclosingAttr ) ; } return oldInternal ; } public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException { EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } } internalInsertBefore ( newChild , oldChild , MUTATION_LOCAL ) ; internalRemoveChild ( oldChild , MUTATION_LOCAL ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { dispatchAggregateEvents ( enclosingAttr ) ; } return oldChild ; } public int getLength ( ) { if ( nodeListLength == - 1 ) { ChildNode node ; if ( nodeListIndex != - 1 && nodeListNode != null ) { nodeListLength = nodeListIndex ; node = nodeListNode ; } else { node = firstChild ; nodeListLength = 0 ; } for ( ; node != null ; node = node . nextSibling ) { nodeListLength ++ ; } } return nodeListLength ; } public Node item ( int index ) { if ( nodeListIndex != - 1 && nodeListNode != null ) { if ( nodeListIndex < index ) { while ( nodeListIndex < index && nodeListNode != null ) { nodeListIndex ++ ; nodeListNode = nodeListNode . nextSibling ; } } else if ( nodeListIndex > index ) { while ( nodeListIndex > index && nodeListNode != null ) { nodeListIndex -- ; nodeListNode = nodeListNode . previousSibling ( ) ; } } return nodeListNode ; } nodeListNode = firstChild ; for ( nodeListIndex = 0 ; nodeListIndex < index && nodeListNode != null ; nodeListIndex ++ ) { nodeListNode = nodeListNode . nextSibling ; } return nodeListNode ; } public void normalize ( ) { Node kid ; for ( kid = firstChild ; kid != null ; kid = kid . getNextSibling ( ) ) { kid . normalize ( ) ; } } public void setReadOnly ( boolean readOnly , boolean deep ) { super . setReadOnly ( readOnly , deep ) ; if ( deep ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } for ( ChildNode mykid = firstChild ; mykid != null ; mykid = mykid . nextSibling ) { if ( ! ( mykid instanceof EntityReference ) ) { mykid . setReadOnly ( readOnly , true ) ; } } } } protected void synchronizeChildren ( ) { needsSyncChildren ( false ) ; } protected final void synchronizeChildren ( int nodeIndex ) { boolean orig = ownerDocument . mutationEvents ; ownerDocument . mutationEvents = false ; needsSyncChildren ( false ) ; DeferredDocumentImpl ownerDocument = ( DeferredDocumentImpl ) this . ownerDocument ; ChildNode first = null ; ChildNode last = null ; for ( int index = ownerDocument . getLastChild ( nodeIndex ) ; index != - 1 ; index = ownerDocument . getPrevSibling ( index ) ) { ChildNode node = ( ChildNode ) ownerDocument . getNodeObject ( index ) ; if ( last == null ) { last = node ; } else { first . previousSibling = node ; } node . ownerNode = this ; node . isOwned ( true ) ; node . nextSibling = first ; first = node ; } if ( last != null ) { firstChild = first ; first . isFirstChild ( true ) ; lastChild ( last ) ; } ownerDocument . mutationEvents = orig ; } private void writeObject ( ObjectOutputStream out ) throws IOException { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } out . defaultWriteObject ( ) ; } private void readObject ( ObjectInputStream ois ) throws ClassNotFoundException , IOException { ois . defaultReadObject ( ) ; needsSyncChildren ( false ) ; nodeListLength = - 1 ; nodeListIndex = - 1 ; } } 	1	['25', '3', '3', '13', '67', '34', '3', '11', '14', '0.638888889', '1120', '0.833333333', '3', '0.684931507', '0.205', '2', '22', '43.56', '11', '2.28', '2']
package org . w3c . dom . events ; import org . w3c . dom . DOMException ; public interface DocumentEvent { public Event createEvent ( String eventType ) throws DOMException ; } 	1	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '2']
package org . apache . xerces . dom ; import java . io . * ; import org . w3c . dom . * ; import org . w3c . dom . events . * ; import org . apache . xerces . dom . * ; import org . apache . xerces . dom . events . * ; public abstract class ParentNode extends NodeImpl { static final long serialVersionUID = 2815829867152120872L ; protected DocumentImpl ownerDocument ; protected ChildNode firstChild = null ; protected transient int nodeListLength = - 1 ; protected transient ChildNode nodeListNode ; protected transient int nodeListIndex = - 1 ; protected ParentNode ( DocumentImpl ownerDocument ) { super ( ownerDocument ) ; this . ownerDocument = ownerDocument ; } public ParentNode ( ) { } public Node cloneNode ( boolean deep ) { ParentNode newnode = ( ParentNode ) super . cloneNode ( deep ) ; newnode . ownerDocument = ownerDocument ; if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } newnode . firstChild = null ; newnode . nodeListIndex = - 1 ; newnode . nodeListLength = - 1 ; if ( deep ) { for ( Node child = firstChild ; child != null ; child = child . getNextSibling ( ) ) { newnode . appendChild ( child . cloneNode ( true ) ) ; } } return newnode ; } public Document getOwnerDocument ( ) { return ownerDocument ; } DocumentImpl ownerDocument ( ) { return ownerDocument ; } void setOwnerDocument ( DocumentImpl doc ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } for ( Node child = firstChild ; child != null ; child = child . getNextSibling ( ) ) { ( ( NodeImpl ) child ) . setOwnerDocument ( doc ) ; } ownerDocument = doc ; } public boolean hasChildNodes ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return firstChild != null ; } public NodeList getChildNodes ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return this ; } public Node getFirstChild ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return firstChild ; } public Node getLastChild ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return lastChild ( ) ; } final ChildNode lastChild ( ) { return firstChild != null ? firstChild . previousSibling : null ; } final void lastChild ( ChildNode node ) { if ( firstChild != null ) { firstChild . previousSibling = node ; } } public Node insertBefore ( Node newChild , Node refChild ) throws DOMException { return internalInsertBefore ( newChild , refChild , MUTATION_ALL ) ; } Node internalInsertBefore ( Node newChild , Node refChild , int mutationMask ) throws DOMException { if ( isReadOnly ( ) ) throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; boolean errorChecking = ownerDocument . errorChecking ; if ( errorChecking && newChild . getOwnerDocument ( ) != ownerDocument ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } if ( errorChecking ) { boolean treeSafe = true ; for ( NodeImpl a = parentNode ( ) ; treeSafe && a != null ; a = a . parentNode ( ) ) { treeSafe = newChild != a ; } if ( ! treeSafe ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } if ( refChild != null && refChild . getParentNode ( ) != this ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } } if ( newChild . getNodeType ( ) == Node . DOCUMENT_FRAGMENT_NODE ) { for ( Node kid = newChild . getFirstChild ( ) ; kid != null ; kid = kid . getNextSibling ( ) ) { if ( errorChecking && ! ownerDocument . isKidOK ( this , kid ) ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } } while ( newChild . hasChildNodes ( ) ) { insertBefore ( newChild . getFirstChild ( ) , refChild ) ; } } else if ( errorChecking && ( ! ( newChild instanceof ChildNode ) || ! ownerDocument . isKidOK ( this , newChild ) ) ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } else { ChildNode newInternal = ( ChildNode ) newChild ; EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents && ( mutationMask & MUTATION_AGGREGATE ) != 0 ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } } Node oldparent = newInternal . parentNode ( ) ; if ( oldparent != null ) { oldparent . removeChild ( newInternal ) ; } ChildNode refInternal = ( ChildNode ) refChild ; newInternal . ownerNode = this ; newInternal . isOwned ( true ) ; if ( firstChild == null ) { firstChild = newInternal ; newInternal . isFirstChild ( true ) ; newInternal . previousSibling = newInternal ; } else { if ( refInternal == null ) { ChildNode lastChild = firstChild . previousSibling ; lastChild . nextSibling = newInternal ; newInternal . previousSibling = lastChild ; firstChild . previousSibling = newInternal ; } else { if ( refChild == firstChild ) { firstChild . isFirstChild ( false ) ; newInternal . nextSibling = firstChild ; newInternal . previousSibling = firstChild . previousSibling ; firstChild . previousSibling = newInternal ; firstChild = newInternal ; newInternal . isFirstChild ( true ) ; } else { ChildNode prev = refInternal . previousSibling ; newInternal . nextSibling = refInternal ; prev . nextSibling = newInternal ; refInternal . previousSibling = newInternal ; newInternal . previousSibling = prev ; } } } changed ( ) ; if ( nodeListLength != - 1 ) { nodeListLength ++ ; } if ( nodeListIndex != - 1 ) { if ( nodeListNode == refInternal ) { nodeListNode = newInternal ; } else { nodeListIndex = - 1 ; } } if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( ( mutationMask & MUTATION_LOCAL ) != 0 ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_NODE_INSERTED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_INSERTED , true , false , this , null , null , null ) ; newInternal . dispatchEvent ( me ) ; } lc = LCount . lookup ( MutationEventImpl . DOM_NODE_INSERTED_INTO_DOCUMENT ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { NodeImpl eventAncestor = this ; if ( enclosingAttr != null ) eventAncestor = ( NodeImpl ) ( enclosingAttr . node . getOwnerElement ( ) ) ; if ( eventAncestor != null ) { NodeImpl p = eventAncestor ; while ( p != null ) { eventAncestor = p ; if ( p . getNodeType ( ) == ATTRIBUTE_NODE ) p = ( ElementImpl ) ( ( AttrImpl ) p ) . getOwnerElement ( ) ; else p = p . parentNode ( ) ; } if ( eventAncestor . getNodeType ( ) == Node . DOCUMENT_NODE ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_INSERTED_INTO_DOCUMENT , false , false , null , null , null , null ) ; dispatchEventToSubtree ( newInternal , me ) ; } } } } if ( ( mutationMask & MUTATION_AGGREGATE ) != 0 ) dispatchAggregateEvents ( enclosingAttr ) ; } } return newChild ; } public Node removeChild ( Node oldChild ) throws DOMException { return internalRemoveChild ( oldChild , MUTATION_ALL ) ; } Node internalRemoveChild ( Node oldChild , int mutationMask ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( ownerDocument . errorChecking && oldChild != null && oldChild . getParentNode ( ) != this ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } ownerDocument . removedChildNode ( oldChild ) ; ChildNode oldInternal = ( ChildNode ) oldChild ; EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } if ( ( mutationMask & MUTATION_LOCAL ) != 0 ) { lc = LCount . lookup ( MutationEventImpl . DOM_NODE_REMOVED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_REMOVED , true , false , this , null , null , null ) ; oldInternal . dispatchEvent ( me ) ; } lc = LCount . lookup ( MutationEventImpl . DOM_NODE_REMOVED_FROM_DOCUMENT ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { NodeImpl eventAncestor = this ; if ( enclosingAttr != null ) eventAncestor = ( NodeImpl ) enclosingAttr . node . getOwnerElement ( ) ; if ( eventAncestor != null ) { for ( NodeImpl p = eventAncestor . parentNode ( ) ; p != null ; p = p . parentNode ( ) ) { eventAncestor = p ; } if ( eventAncestor . getNodeType ( ) == Node . DOCUMENT_NODE ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_REMOVED_FROM_DOCUMENT , false , false , null , null , null , null ) ; dispatchEventToSubtree ( oldInternal , me ) ; } } } } } if ( nodeListLength != - 1 ) { nodeListLength -- ; } if ( nodeListIndex != - 1 ) { if ( nodeListNode == oldInternal ) { nodeListIndex -- ; nodeListNode = oldInternal . previousSibling ( ) ; } else { nodeListIndex = - 1 ; } } if ( oldInternal == firstChild ) { oldInternal . isFirstChild ( false ) ; firstChild = oldInternal . nextSibling ; if ( firstChild != null ) { firstChild . isFirstChild ( true ) ; firstChild . previousSibling = oldInternal . previousSibling ; } } else { ChildNode prev = oldInternal . previousSibling ; ChildNode next = oldInternal . nextSibling ; prev . nextSibling = next ; if ( next == null ) { firstChild . previousSibling = prev ; } else { next . previousSibling = prev ; } } oldInternal . ownerNode = ownerDocument ; oldInternal . isOwned ( false ) ; oldInternal . nextSibling = null ; oldInternal . previousSibling = null ; changed ( ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( ( mutationMask & MUTATION_AGGREGATE ) != 0 ) dispatchAggregateEvents ( enclosingAttr ) ; } return oldInternal ; } public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException { EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } } internalInsertBefore ( newChild , oldChild , MUTATION_LOCAL ) ; internalRemoveChild ( oldChild , MUTATION_LOCAL ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { dispatchAggregateEvents ( enclosingAttr ) ; } return oldChild ; } public int getLength ( ) { if ( nodeListLength == - 1 ) { ChildNode node ; if ( nodeListIndex != - 1 && nodeListNode != null ) { nodeListLength = nodeListIndex ; node = nodeListNode ; } else { node = firstChild ; nodeListLength = 0 ; } for ( ; node != null ; node = node . nextSibling ) { nodeListLength ++ ; } } return nodeListLength ; } public Node item ( int index ) { if ( nodeListIndex != - 1 && nodeListNode != null ) { if ( nodeListIndex < index ) { while ( nodeListIndex < index && nodeListNode != null ) { nodeListIndex ++ ; nodeListNode = nodeListNode . nextSibling ; } } else if ( nodeListIndex > index ) { while ( nodeListIndex > index && nodeListNode != null ) { nodeListIndex -- ; nodeListNode = nodeListNode . previousSibling ( ) ; } } return nodeListNode ; } nodeListNode = firstChild ; for ( nodeListIndex = 0 ; nodeListIndex < index && nodeListNode != null ; nodeListIndex ++ ) { nodeListNode = nodeListNode . nextSibling ; } return nodeListNode ; } public void normalize ( ) { Node kid ; for ( kid = firstChild ; kid != null ; kid = kid . getNextSibling ( ) ) { kid . normalize ( ) ; } } public void setReadOnly ( boolean readOnly , boolean deep ) { super . setReadOnly ( readOnly , deep ) ; if ( deep ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } for ( ChildNode mykid = firstChild ; mykid != null ; mykid = mykid . nextSibling ) { if ( ! ( mykid instanceof EntityReference ) ) { mykid . setReadOnly ( readOnly , true ) ; } } } } protected void synchronizeChildren ( ) { needsSyncChildren ( false ) ; } protected final void synchronizeChildren ( int nodeIndex ) { boolean orig = ownerDocument . mutationEvents ; ownerDocument . mutationEvents = false ; needsSyncChildren ( false ) ; DeferredDocumentImpl ownerDocument = ( DeferredDocumentImpl ) this . ownerDocument ; ChildNode first = null ; ChildNode last = null ; for ( int index = ownerDocument . getLastChild ( nodeIndex ) ; index != - 1 ; index = ownerDocument . getPrevSibling ( index ) ) { ChildNode node = ( ChildNode ) ownerDocument . getNodeObject ( index ) ; if ( last == null ) { last = node ; } else { first . previousSibling = node ; } node . ownerNode = this ; node . isOwned ( true ) ; node . nextSibling = first ; first = node ; } if ( last != null ) { firstChild = first ; first . isFirstChild ( true ) ; lastChild ( last ) ; } ownerDocument . mutationEvents = orig ; } private void writeObject ( ObjectOutputStream out ) throws IOException { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } out . defaultWriteObject ( ) ; } private void readObject ( ObjectInputStream ois ) throws ClassNotFoundException , IOException { ois . defaultReadObject ( ) ; needsSyncChildren ( false ) ; nodeListLength = - 1 ; nodeListIndex = - 1 ; } } 	1	['25', '2', '5', '14', '68', '34', '5', '11', '14', '0.638888889', '1120', '0.833333333', '3', '0.656716418', '0.205', '1', '17', '43.56', '11', '2.28', '2']
package javax . xml . parsers ; public abstract class DocumentBuilderFactory { private boolean namespaces = false ; private boolean validation = false ; private static String property = "javax.xml.parsers.DocumentBuilderFactory" ; private static String factory = "org.apache.xerces.jaxp.DocumentBuilderFactoryImpl" ; protected DocumentBuilderFactory ( ) { super ( ) ; } public static DocumentBuilderFactory newInstance ( ) { String n = factory ; try { n = System . getProperty ( property , factory ) ; } catch ( SecurityException e ) { n = factory ; } try { return ( DocumentBuilderFactory ) Class . forName ( n ) . newInstance ( ) ; } catch ( ClassNotFoundException e ) { throw new FactoryConfigurationError ( "Cannot load class " + "DocumentBuilderFactory class \"" + n + "\"" ) ; } catch ( InstantiationException e ) { throw new FactoryConfigurationError ( "Cannot instantiate the " + "specified DocumentBuilderFactory class \"" + n + "\"" ) ; } catch ( IllegalAccessException e ) { throw new FactoryConfigurationError ( "Cannot access the specified " + "DocumentBuilderFactory class \"" + n + "\"" ) ; } catch ( ClassCastException e ) { throw new FactoryConfigurationError ( "The specified class \"" + n + "\" is not instance of \"" + "javax.xml.parsers.DocumentBuilderFactory\"" ) ; } } public abstract DocumentBuilder newDocumentBuilder ( ) throws ParserConfigurationException ; public void setNamespaceAware ( boolean aware ) { this . namespaces = aware ; } public void setValidating ( boolean validating ) { this . validation = validating ; } public boolean isNamespaceAware ( ) { return ( this . namespaces ) ; } public boolean isValidating ( ) { return ( this . validation ) ; } } 	1	['8', '1', '1', '0', '16', '14', '0', '0', '6', '0.785714286', '117', '1', '0', '0', '0.571428571', '0', '0', '13.125', '1', '0.75', '1']
package org . apache . xerces . dom ; import java . io . * ; import java . util . Vector ; import java . util . Enumeration ; import org . w3c . dom . * ; public class NamedNodeMapImpl implements NamedNodeMap , Serializable { static final long serialVersionUID = - 7039242451046758020L ; protected short flags ; protected final static short READONLY = 0x1 << 0 ; protected final static short CHANGED = 0x1 << 1 ; protected final static short HASDEFAULTS = 0x1 << 2 ; protected Vector nodes ; protected NodeImpl ownerNode ; protected NamedNodeMapImpl ( NodeImpl ownerNode ) { this . ownerNode = ownerNode ; } public int getLength ( ) { return ( nodes != null ) ? nodes . size ( ) : 0 ; } public Node item ( int index ) { return ( nodes != null && index < nodes . size ( ) ) ? ( Node ) ( nodes . elementAt ( index ) ) : null ; } public Node getNamedItem ( String name ) { int i = findNamePoint ( name , 0 ) ; return ( i < 0 ) ? null : ( Node ) ( nodes . elementAt ( i ) ) ; } public Node getNamedItemNS ( String namespaceURI , String localName ) { int i = findNamePoint ( namespaceURI , localName ) ; return ( i < 0 ) ? null : ( Node ) ( nodes . elementAt ( i ) ) ; } public Node setNamedItem ( Node arg ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( arg . getOwnerDocument ( ) != ownerNode . ownerDocument ( ) ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } int i = findNamePoint ( arg . getNodeName ( ) , 0 ) ; NodeImpl previous = null ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . setElementAt ( arg , i ) ; } else { i = - 1 - i ; if ( null == nodes ) { nodes = new Vector ( 5 , 10 ) ; } nodes . insertElementAt ( arg , i ) ; } return previous ; } public Node setNamedItemNS ( Node arg ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( arg . getOwnerDocument ( ) != ownerNode . ownerDocument ( ) ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } int i = findNamePoint ( arg . getNamespaceURI ( ) , arg . getLocalName ( ) ) ; NodeImpl previous = null ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . setElementAt ( arg , i ) ; } else { i = findNamePoint ( arg . getNodeName ( ) , 0 ) ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . insertElementAt ( arg , i ) ; } else { i = - 1 - i ; if ( null == nodes ) { nodes = new Vector ( 5 , 10 ) ; } nodes . insertElementAt ( arg , i ) ; } } return previous ; } public Node removeNamedItem ( String name ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } int i = findNamePoint ( name , 0 ) ; if ( i < 0 ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } NodeImpl n = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . removeElementAt ( i ) ; return n ; } public Node removeNamedItemNS ( String namespaceURI , String name ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } int i = findNamePoint ( namespaceURI , name ) ; if ( i < 0 ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } NodeImpl n = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . removeElementAt ( i ) ; return n ; } public NamedNodeMapImpl cloneMap ( NodeImpl ownerNode ) { NamedNodeMapImpl newmap = new NamedNodeMapImpl ( ownerNode ) ; newmap . cloneContent ( this ) ; return newmap ; } protected void cloneContent ( NamedNodeMapImpl srcmap ) { if ( srcmap . nodes != null ) { nodes = new Vector ( srcmap . nodes . size ( ) ) ; for ( int i = 0 ; i < srcmap . nodes . size ( ) ; ++ i ) { NodeImpl n = ( NodeImpl ) srcmap . nodes . elementAt ( i ) ; NodeImpl clone = ( NodeImpl ) n . cloneNode ( true ) ; clone . isSpecified ( n . isSpecified ( ) ) ; nodes . insertElementAt ( clone , i ) ; } } } void setReadOnly ( boolean readOnly , boolean deep ) { isReadOnly ( readOnly ) ; if ( deep && nodes != null ) { Enumeration e = nodes . elements ( ) ; while ( e . hasMoreElements ( ) ) { ( ( NodeImpl ) e . nextElement ( ) ) . setReadOnly ( readOnly , deep ) ; } } } boolean getReadOnly ( ) { return isReadOnly ( ) ; } void setOwnerDocument ( DocumentImpl doc ) { if ( nodes != null ) { for ( int i = 0 ; i < nodes . size ( ) ; i ++ ) { ( ( NodeImpl ) item ( i ) ) . setOwnerDocument ( doc ) ; } } } final boolean isReadOnly ( ) { return ( flags & READONLY ) != 0 ; } final void isReadOnly ( boolean value ) { flags = ( short ) ( value ? flags | READONLY : flags & ~ READONLY ) ; } final boolean changed ( ) { return ( flags & CHANGED ) != 0 ; } final void changed ( boolean value ) { flags = ( short ) ( value ? flags | CHANGED : flags & ~ CHANGED ) ; } final boolean hasDefaults ( ) { return ( flags & HASDEFAULTS ) != 0 ; } final void hasDefaults ( boolean value ) { flags = ( short ) ( value ? flags | HASDEFAULTS : flags & ~ HASDEFAULTS ) ; } protected int findNamePoint ( String name , int start ) { int i = 0 ; if ( nodes != null ) { int first = start ; int last = nodes . size ( ) - 1 ; while ( first <= last ) { i = ( first + last ) / 2 ; int test = name . compareTo ( ( ( Node ) ( nodes . elementAt ( i ) ) ) . getNodeName ( ) ) ; if ( test == 0 ) { return i ; } else if ( test < 0 ) { last = i - 1 ; } else { first = i + 1 ; } } if ( first > i ) { i = first ; } } return - 1 - i ; } protected int findNamePoint ( String namespaceURI , String name ) { if ( nodes == null ) return - 1 ; if ( namespaceURI == null ) return - 1 ; if ( name == null ) return - 1 ; for ( int i = 0 ; i < nodes . size ( ) ; i ++ ) { NodeImpl a = ( NodeImpl ) nodes . elementAt ( i ) ; if ( namespaceURI . equals ( a . getNamespaceURI ( ) ) && name . equals ( a . getLocalName ( ) ) ) { return i ; } } return - 1 ; } } 	1	['22', '1', '1', '9', '48', '41', '6', '3', '9', '0.843537415', '579', '0.857142857', '1', '0', '0.227272727', '0', '0', '25', '7', '2.2727', '1']
package org . w3c . dom ; public interface NamedNodeMap { public Node getNamedItem ( String name ) ; public Node setNamedItem ( Node arg ) throws DOMException ; public Node removeNamedItem ( String name ) throws DOMException ; public Node item ( int index ) ; public int getLength ( ) ; public Node getNamedItemNS ( String namespaceURI , String localName ) ; public Node setNamedItemNS ( Node arg ) throws DOMException ; public Node removeNamedItemNS ( String namespaceURI , String localName ) throws DOMException ; } 	1	['8', '1', '0', '0', '8', '28', '0', '0', '8', '2', '8', '0', '0', '0', '0.46875', '0', '0', '0', '1', '1', '2']
package org . apache . xml . serialize ; import java . util . Hashtable ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentType ; import org . w3c . dom . Node ; import org . w3c . dom . html . HTMLDocument ; public class OutputFormat { public static class DTD { public static final String HTMLPublicId = "-//W3C//DTD HTML 4.0//EN" ; public static final String HTMLSystemId = "http://www.w3.org/TR/WD-html-in-xml/DTD/xhtml1-strict.dtd" ; public static final String XHTMLPublicId = "-//W3C//DTD XHTML 1.0 Strict//EN" ; public static final String XHTMLSystemId = "http://www.w3.org/TR/WD-html-in-xml/DTD/xhtml1-strict.dtd" ; } public static class Defaults { public static final int Indent = 4 ; public static final String Encoding = "UTF-8" ; public static final int LineWidth = 72 ; } private String _method ; private String _version ; private int _indent = 0 ; private String _encoding = Defaults . Encoding ; private String _mediaType ; private String _doctypeSystem ; private String _doctypePublic ; private boolean _omitXmlDeclaration = false ; private boolean _omitDoctype = false ; private boolean _omitComments = false ; private boolean _stripComments = false ; private boolean _standalone = false ; private String [ ] _cdataElements ; private String [ ] _nonEscapingElements ; private String _lineSeparator = LineSeparator . Web ; private int _lineWidth = Defaults . LineWidth ; private boolean _preserve = false ; public OutputFormat ( ) { } public OutputFormat ( String method , String encoding , boolean indenting ) { setMethod ( method ) ; setEncoding ( encoding ) ; setIndenting ( indenting ) ; } public OutputFormat ( Document doc ) { setMethod ( whichMethod ( doc ) ) ; setDoctype ( whichDoctypePublic ( doc ) , whichDoctypeSystem ( doc ) ) ; setMediaType ( whichMediaType ( getMethod ( ) ) ) ; } public OutputFormat ( Document doc , String encoding , boolean indenting ) { this ( doc ) ; setEncoding ( encoding ) ; setIndenting ( indenting ) ; } public String getMethod ( ) { return _method ; } public void setMethod ( String method ) { _method = method ; } public String getVersion ( ) { return _version ; } public void setVersion ( String version ) { _version = version ; } public int getIndent ( ) { return _indent ; } public boolean getIndenting ( ) { return ( _indent > 0 ) ; } public void setIndent ( int indent ) { if ( indent < 0 ) _indent = 0 ; else _indent = indent ; } public void setIndenting ( boolean on ) { if ( on ) { _indent = Defaults . Indent ; _lineWidth = Defaults . LineWidth ; } else { _indent = 0 ; _lineWidth = 0 ; } } public String getEncoding ( ) { return _encoding ; } public void setEncoding ( String encoding ) { _encoding = encoding ; } public String getMediaType ( ) { return _mediaType ; } public void setMediaType ( String mediaType ) { _mediaType = mediaType ; } public void setDoctype ( String publicId , String systemId ) { _doctypePublic = publicId ; _doctypeSystem = systemId ; } public String getDoctypePublic ( ) { return _doctypePublic ; } public String getDoctypeSystem ( ) { return _doctypeSystem ; } public boolean getOmitComments ( ) { return _omitComments ; } public void setOmitComments ( boolean omit ) { _omitComments = omit ; } public boolean getOmitDocumentType ( ) { return _omitDoctype ; } public void setOmitDocumentType ( boolean omit ) { _omitDoctype = omit ; } public boolean getOmitXMLDeclaration ( ) { return _omitXmlDeclaration ; } public void setOmitXMLDeclaration ( boolean omit ) { _omitXmlDeclaration = omit ; } public boolean getStandalone ( ) { return _standalone ; } public void setStandalone ( boolean standalone ) { _standalone = standalone ; } public String [ ] getCDataElements ( ) { return _cdataElements ; } public boolean isCDataElement ( String tagName ) { int i ; if ( _cdataElements == null ) return false ; for ( i = 0 ; i < _cdataElements . length ; ++ i ) if ( _cdataElements [ i ] . equals ( tagName ) ) return true ; return false ; } public void setCDataElements ( String [ ] cdataElements ) { _cdataElements = cdataElements ; } public String [ ] getNonEscapingElements ( ) { return _nonEscapingElements ; } public boolean isNonEscapingElement ( String tagName ) { int i ; if ( _nonEscapingElements == null ) return false ; for ( i = 0 ; i < _nonEscapingElements . length ; ++ i ) if ( _nonEscapingElements [ i ] . equals ( tagName ) ) return true ; return false ; } public void setNonEscapingElements ( String [ ] nonEscapingElements ) { _nonEscapingElements = nonEscapingElements ; } public String getLineSeparator ( ) { return _lineSeparator ; } public void setLineSeparator ( String lineSeparator ) { if ( lineSeparator == null ) _lineSeparator = LineSeparator . Web ; else _lineSeparator = lineSeparator ; } public boolean getPreserveSpace ( ) { return _preserve ; } public void setPreserveSpace ( boolean preserve ) { _preserve = preserve ; } public int getLineWidth ( ) { return _lineWidth ; } public void setLineWidth ( int lineWidth ) { if ( lineWidth <= 0 ) _lineWidth = 0 ; else _lineWidth = lineWidth ; } public char getLastPrintable ( ) { if ( getEncoding ( ) != null && ( getEncoding ( ) . equalsIgnoreCase ( "ASCII" ) ) ) return 0xFF ; else return 0xFFFF ; } public static String whichMethod ( Document doc ) { Node node ; String value ; int i ; if ( doc instanceof HTMLDocument ) return Method . HTML ; node = doc . getFirstChild ( ) ; while ( node != null ) { if ( node . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( node . getNodeName ( ) . equalsIgnoreCase ( "html" ) ) { return Method . HTML ; } else if ( node . getNodeName ( ) . equalsIgnoreCase ( "root" ) ) { return Method . FOP ; } else { return Method . XML ; } } else if ( node . getNodeType ( ) == Node . TEXT_NODE ) { value = node . getNodeValue ( ) ; for ( i = 0 ; i < value . length ( ) ; ++ i ) if ( value . charAt ( i ) != 0x20 && value . charAt ( i ) != 0x0A && value . charAt ( i ) != 0x09 && value . charAt ( i ) != 0x0D ) return Method . XML ; } node = node . getNextSibling ( ) ; } return Method . XML ; } public static String whichDoctypePublic ( Document doc ) { DocumentType doctype ; if ( doc instanceof HTMLDocument ) return DTD . XHTMLPublicId ; return null ; } public static String whichDoctypeSystem ( Document doc ) { DocumentType doctype ; if ( doc instanceof HTMLDocument ) return DTD . XHTMLSystemId ; return null ; } public static String whichMediaType ( String method ) { if ( method . equalsIgnoreCase ( Method . XML ) ) return "text/xml" ; if ( method . equalsIgnoreCase ( Method . HTML ) ) return "text/html" ; if ( method . equalsIgnoreCase ( Method . XHTML ) ) return "text/html" ; if ( method . equalsIgnoreCase ( Method . TEXT ) ) return "text/plain" ; if ( method . equalsIgnoreCase ( Method . FOP ) ) return "application/pdf" ; return null ; } } 	1	['42', '1', '0', '11', '52', '695', '11', '0', '42', '0.899186992', '498', '1', '0', '0', '0.257936508', '0', '0', '10.5', '12', '1.6429', '1']
package javax . xml . parsers ; import java . io . File ; import java . io . InputStream ; import java . io . IOException ; import org . xml . sax . HandlerBase ; import org . xml . sax . InputSource ; import org . xml . sax . Parser ; import org . xml . sax . SAXException ; public abstract class SAXParser { protected SAXParser ( ) { super ( ) ; } public void parse ( InputStream stream , HandlerBase base ) throws SAXException , IOException , IllegalArgumentException { if ( stream == null ) throw new IllegalArgumentException ( ) ; this . parse ( new InputSource ( stream ) , base ) ; } public void parse ( String uri , HandlerBase base ) throws SAXException , IOException , IllegalArgumentException { if ( uri == null ) throw new IllegalArgumentException ( ) ; this . parse ( new InputSource ( uri ) , base ) ; } public void parse ( File file , HandlerBase base ) throws SAXException , IOException , IllegalArgumentException { if ( file == null ) throw new IllegalArgumentException ( ) ; String path = file . getAbsolutePath ( ) ; if ( File . separatorChar != '/' ) { path = path . replace ( File . separatorChar , '/' ) ; } if ( ! path . startsWith ( "/" ) ) { path = "/" + path ; } if ( ! path . endsWith ( "/" ) && file . isDirectory ( ) ) { path = path + "/" ; } java . net . URL url = new java . net . URL ( "file" , "" , path ) ; this . parse ( new InputSource ( url . toString ( ) ) , base ) ; } public void parse ( InputSource source , HandlerBase base ) throws SAXException , IOException , IllegalArgumentException { if ( source == null ) throw new IllegalArgumentException ( ) ; Parser p = this . getParser ( ) ; if ( base != null ) { p . setDocumentHandler ( base ) ; p . setDTDHandler ( base ) ; p . setEntityResolver ( base ) ; p . setErrorHandler ( base ) ; } p . parse ( source ) ; } public abstract Parser getParser ( ) throws SAXException ; public abstract boolean isNamespaceAware ( ) ; public abstract boolean isValidating ( ) ; } 	1	['8', '1', '1', '0', '27', '28', '0', '0', '7', '2', '128', '0', '0', '0', '0.333333333', '0', '0', '15', '1', '0.875', '1']
package org . w3c . dom ; public interface Element extends Node { public String getTagName ( ) ; public String getAttribute ( String name ) ; public void setAttribute ( String name , String value ) throws DOMException ; public void removeAttribute ( String name ) throws DOMException ; public Attr getAttributeNode ( String name ) ; public Attr setAttributeNode ( Attr newAttr ) throws DOMException ; public Attr removeAttributeNode ( Attr oldAttr ) throws DOMException ; public NodeList getElementsByTagName ( String name ) ; public String getAttributeNS ( String namespaceURI , String localName ) ; public void setAttributeNS ( String namespaceURI , String qualifiedName , String value ) throws DOMException ; public void removeAttributeNS ( String namespaceURI , String localName ) throws DOMException ; public Attr getAttributeNodeNS ( String namespaceURI , String localName ) ; public Attr setAttributeNodeNS ( Attr newAttr ) throws DOMException ; public NodeList getElementsByTagNameNS ( String namespaceURI , String localName ) ; public boolean hasAttribute ( String name ) ; public boolean hasAttributeNS ( String namespaceURI , String localName ) ; } 	1	['16', '1', '0', '0', '16', '120', '0', '0', '16', '2', '16', '0', '0', '0', '0.645833333', '0', '0', '0', '1', '1', '2']
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class NotationImpl extends NodeImpl implements Notation { static final long serialVersionUID = - 764632195890658402L ; protected String name ; protected String publicId ; protected String systemId ; public NotationImpl ( DocumentImpl ownerDoc , String name ) { super ( ownerDoc ) ; this . name = name ; } public short getNodeType ( ) { return Node . NOTATION_NODE ; } public String getNodeName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public String getPublicId ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return publicId ; } public String getSystemId ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return systemId ; } public void setPublicId ( String id ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } publicId = id ; } public void setSystemId ( String id ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } systemId = id ; } } 	1	['7', '2', '1', '5', '12', '15', '3', '3', '7', '0.916666667', '80', '0.75', '0', '0.88', '0.523809524', '1', '4', '9.857142857', '3', '1.8571', '1']
package org . w3c . dom . events ; public interface EventListener { public void handleEvent ( Event evt ) ; } 	1	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '2']
package org . xml . sax . ext ; import org . xml . sax . SAXException ; public interface LexicalHandler { public abstract void startDTD ( String name , String publicId , String systemId ) throws SAXException ; public abstract void endDTD ( ) throws SAXException ; public abstract void startEntity ( String name ) throws SAXException ; public abstract void endEntity ( String name ) throws SAXException ; public abstract void startCDATA ( ) throws SAXException ; public abstract void endCDATA ( ) throws SAXException ; public abstract void comment ( char ch [ ] , int start , int length ) throws SAXException ; } 	1	['7', '1', '0', '0', '7', '21', '0', '0', '7', '2', '7', '0', '0', '0', '0.428571429', '0', '0', '0', '1', '1', '1']
package org . apache . xerces . dom ; import org . w3c . dom . * ; import org . apache . xerces . dom . events . MutationEventImpl ; public class AttrImpl extends ParentNode implements Attr { static final long serialVersionUID = 7277707688218972102L ; protected String name ; protected AttrImpl ( DocumentImpl ownerDocument , String name ) { super ( ownerDocument ) ; this . name = name ; isSpecified ( true ) ; } protected AttrImpl ( ) { } public Node cloneNode ( boolean deep ) { AttrImpl clone = ( AttrImpl ) super . cloneNode ( deep ) ; clone . isSpecified ( true ) ; return clone ; } public short getNodeType ( ) { return Node . ATTRIBUTE_NODE ; } public String getNodeName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public void setNodeValue ( String value ) throws DOMException { setValue ( value ) ; } public String getNodeValue ( ) { return getValue ( ) ; } public String getName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public void setValue ( String value ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } LCount lc = null ; String oldvalue = "" ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 && ownerNode != null ) { oldvalue = getValue ( ) ; } } if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } while ( firstChild != null ) internalRemoveChild ( firstChild , MUTATION_LOCAL ) ; } else { if ( firstChild != null ) { firstChild . previousSibling = null ; firstChild . isFirstChild ( false ) ; firstChild = null ; } needsSyncChildren ( false ) ; } isSpecified ( true ) ; if ( value != null ) { internalInsertBefore ( ownerDocument . createTextNode ( value ) , null , MUTATION_LOCAL ) ; } changed ( ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { dispatchAggregateEvents ( this , oldvalue ) ; } } public String getValue ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } if ( firstChild == null ) { return "" ; } ChildNode node = firstChild . nextSibling ; if ( node == null ) { return firstChild . getNodeValue ( ) ; } StringBuffer value = new StringBuffer ( firstChild . getNodeValue ( ) ) ; while ( node != null ) { value . append ( node . getNodeValue ( ) ) ; node = node . nextSibling ; } return value . toString ( ) ; } public boolean getSpecified ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return isSpecified ( ) ; } public Element getElement ( ) { return ( Element ) ( isOwned ( ) ? ownerNode : null ) ; } public Element getOwnerElement ( ) { return ( Element ) ( isOwned ( ) ? ownerNode : null ) ; } public void normalize ( ) { Node kid , next ; for ( kid = firstChild ; kid != null ; kid = next ) { next = kid . getNextSibling ( ) ; if ( next != null && kid . getNodeType ( ) == Node . TEXT_NODE && next . getNodeType ( ) == Node . TEXT_NODE ) { ( ( Text ) kid ) . appendData ( next . getNodeValue ( ) ) ; removeChild ( next ) ; next = kid ; } } } public void setSpecified ( boolean arg ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } isSpecified ( arg ) ; } public String toString ( ) { return getName ( ) + "=" + "\"" + getValue ( ) + "\"" ; } } 	1	['16', '4', '2', '13', '46', '102', '10', '6', '14', '0.933333333', '288', '0.5', '0', '0.849462366', '0.34375', '3', '18', '16.875', '11', '2.375', '1']
package org . w3c . dom ; public interface CharacterData extends Node { public String getData ( ) throws DOMException ; public void setData ( String data ) throws DOMException ; public int getLength ( ) ; public String substringData ( int offset , int count ) throws DOMException ; public void appendData ( String arg ) throws DOMException ; public void insertData ( int offset , String arg ) throws DOMException ; public void deleteData ( int offset , int count ) throws DOMException ; public void replaceData ( int offset , int count , String arg ) throws DOMException ; } 	1	['8', '1', '0', '0', '8', '28', '0', '0', '8', '2', '8', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '2']
package org . w3c . dom . events ; import org . w3c . dom . Node ; public interface Event { public static final short CAPTURING_PHASE = 1 ; public static final short AT_TARGET = 2 ; public static final short BUBBLING_PHASE = 3 ; public String getType ( ) ; public EventTarget getTarget ( ) ; public Node getCurrentNode ( ) ; public short getEventPhase ( ) ; public boolean getBubbles ( ) ; public boolean getCancelable ( ) ; public long getTimeStamp ( ) ; public void stopPropagation ( ) ; public void preventDefault ( ) ; public void initEvent ( String eventTypeArg , boolean canBubbleArg , boolean cancelableArg ) ; } 	1	['10', '1', '0', '0', '10', '45', '0', '0', '10', '1.111111111', '13', '0', '0', '0', '0.4', '0', '0', '0', '1', '1', '2']
package org . apache . xerces . dom ; import java . io . * ; import java . util . Enumeration ; import java . util . Vector ; import org . w3c . dom . * ; public class ElementImpl extends ChildAndParentNode implements Element { static final long serialVersionUID = 3717253516652722278L ; protected String name ; protected AttributeMap attributes ; public ElementImpl ( DocumentImpl ownerDoc , String name ) { super ( ownerDoc ) ; this . name = name ; needsSyncData ( true ) ; } protected ElementImpl ( ) { } public short getNodeType ( ) { return Node . ELEMENT_NODE ; } public String getNodeName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public NamedNodeMap getAttributes ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { attributes = new AttributeMap ( this , null ) ; } return attributes ; } public Node cloneNode ( boolean deep ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } ElementImpl newnode = ( ElementImpl ) super . cloneNode ( deep ) ; if ( attributes != null ) { newnode . attributes = ( AttributeMap ) attributes . cloneMap ( newnode ) ; } return newnode ; } void setOwnerDocument ( DocumentImpl doc ) { super . setOwnerDocument ( doc ) ; if ( attributes != null ) { attributes . setOwnerDocument ( doc ) ; } } public String getAttribute ( String name ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return "" ; } Attr attr = ( Attr ) ( attributes . getNamedItem ( name ) ) ; return ( attr == null ) ? "" : attr . getValue ( ) ; } public Attr getAttributeNode ( String name ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return null ; } return ( Attr ) attributes . getNamedItem ( name ) ; } public NodeList getElementsByTagName ( String tagname ) { return new DeepNodeListImpl ( this , tagname ) ; } public String getTagName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public void normalize ( ) { Node kid , next ; for ( kid = getFirstChild ( ) ; kid != null ; kid = next ) { next = kid . getNextSibling ( ) ; if ( next != null && kid . getNodeType ( ) == Node . TEXT_NODE && next . getNodeType ( ) == Node . TEXT_NODE ) { ( ( Text ) kid ) . appendData ( next . getNodeValue ( ) ) ; removeChild ( next ) ; next = kid ; } else if ( kid . getNodeType ( ) == Node . ELEMENT_NODE ) { ( ( Element ) kid ) . normalize ( ) ; } } } public void removeAttribute ( String name ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return ; } attributes . safeRemoveNamedItem ( name ) ; } public Attr removeAttributeNode ( Attr oldAttr ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } return ( Attr ) attributes . removeNamedItem ( oldAttr . getName ( ) ) ; } public void setAttribute ( String name , String value ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } Attr newAttr = getAttributeNode ( name ) ; if ( newAttr == null ) { newAttr = getOwnerDocument ( ) . createAttribute ( name ) ; if ( attributes == null ) { attributes = new AttributeMap ( this , null ) ; } attributes . setNamedItem ( newAttr ) ; } newAttr . setNodeValue ( value ) ; } public Attr setAttributeNode ( Attr newAttr ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( ownerDocument . errorChecking && newAttr . getOwnerDocument ( ) != ownerDocument ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } if ( attributes == null ) { attributes = new AttributeMap ( this , null ) ; } return ( Attr ) attributes . setNamedItem ( newAttr ) ; } public String getAttributeNS ( String namespaceURI , String localName ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return "" ; } Attr attr = ( Attr ) ( attributes . getNamedItemNS ( namespaceURI , localName ) ) ; return ( attr == null ) ? null : attr . getValue ( ) ; } public void setAttributeNS ( String namespaceURI , String localName , String value ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } Attr newAttr = getAttributeNodeNS ( namespaceURI , localName ) ; if ( newAttr == null ) { newAttr = getOwnerDocument ( ) . createAttributeNS ( namespaceURI , localName ) ; if ( attributes == null ) { attributes = new AttributeMap ( this , null ) ; } attributes . setNamedItemNS ( newAttr ) ; } newAttr . setNodeValue ( value ) ; } public void removeAttributeNS ( String namespaceURI , String localName ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return ; } attributes . safeRemoveNamedItemNS ( namespaceURI , localName ) ; } public Attr getAttributeNodeNS ( String namespaceURI , String localName ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return null ; } return ( Attr ) attributes . getNamedItemNS ( namespaceURI , localName ) ; } public Attr setAttributeNodeNS ( Attr newAttr ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( ownerDocument . errorChecking && newAttr . getOwnerDocument ( ) != ownerDocument ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } if ( attributes == null ) { attributes = new AttributeMap ( this , null ) ; } return ( Attr ) attributes . setNamedItemNS ( newAttr ) ; } public boolean hasAttributes ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return ( attributes != null && attributes . getLength ( ) != 0 ) ; } public boolean hasAttribute ( String name ) { return getAttributeNode ( name ) != null ; } public boolean hasAttributeNS ( String namespaceURI , String localName ) { return getAttributeNodeNS ( namespaceURI , localName ) != null ; } public NodeList getElementsByTagNameNS ( String namespaceURI , String localName ) { return new DeepNodeListImpl ( this , namespaceURI , localName ) ; } public void setReadOnly ( boolean readOnly , boolean deep ) { super . setReadOnly ( readOnly , deep ) ; if ( attributes != null ) { attributes . setReadOnly ( readOnly , true ) ; } } protected void synchronizeData ( ) { needsSyncData ( false ) ; setupDefaultAttributes ( ) ; } protected void setupDefaultAttributes ( ) { NamedNodeMapImpl defaults = getDefaultAttributes ( ) ; if ( defaults != null ) { attributes = new AttributeMap ( this , defaults ) ; } } protected NamedNodeMapImpl getDefaultAttributes ( ) { DocumentTypeImpl doctype = ( DocumentTypeImpl ) ownerDocument . getDoctype ( ) ; if ( doctype == null ) { return null ; } ElementDefinitionImpl eldef = ( ElementDefinitionImpl ) doctype . getElements ( ) . getNamedItem ( getNodeName ( ) ) ; if ( eldef == null ) { return null ; } return ( NamedNodeMapImpl ) eldef . getAttributes ( ) ; } } 	1	['29', '4', '4', '17', '70', '124', '12', '9', '24', '0.75', '598', '0.666666667', '1', '0.73', '0.337931034', '2', '11', '19.51724138', '6', '2.4828', '1']
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class TextImpl extends CharacterDataImpl implements CharacterData , Text { static final long serialVersionUID = - 5294980852957403469L ; public TextImpl ( DocumentImpl ownerDoc , String data ) { super ( ownerDoc , data ) ; } public short getNodeType ( ) { return Node . TEXT_NODE ; } public String getNodeName ( ) { return "#text" ; } public void setIgnorableWhitespace ( boolean ignore ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } isIgnorableWhitespace ( ignore ) ; } public boolean isIgnorableWhitespace ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return internalIsIgnorableWhitespace ( ) ; } public Text splitText ( int offset ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( offset < 0 || offset > data . length ( ) - 1 ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } Text newText = getOwnerDocument ( ) . createTextNode ( data . substring ( offset ) ) ; setNodeValue ( data . substring ( 0 , offset ) ) ; Node parentNode = getParentNode ( ) ; if ( parentNode != null ) { parentNode . insertBefore ( newText , nextSibling ) ; } return newText ; } } 	1	['6', '3', '2', '9', '21', '15', '6', '4', '6', '1.2', '90', '0', '0', '0.915254237', '0.333333333', '1', '4', '13.83333333', '2', '1.1667', '1']
package org . w3c . dom ; public class DOMException extends RuntimeException { public DOMException ( short code , String message ) { super ( message ) ; this . code = code ; } public short code ; public static final short INDEX_SIZE_ERR = 1 ; public static final short DOMSTRING_SIZE_ERR = 2 ; public static final short HIERARCHY_REQUEST_ERR = 3 ; public static final short WRONG_DOCUMENT_ERR = 4 ; public static final short INVALID_CHARACTER_ERR = 5 ; public static final short NO_DATA_ALLOWED_ERR = 6 ; public static final short NO_MODIFICATION_ALLOWED_ERR = 7 ; public static final short NOT_FOUND_ERR = 8 ; public static final short NOT_SUPPORTED_ERR = 9 ; public static final short INUSE_ATTRIBUTE_ERR = 10 ; public static final short INVALID_STATE_ERR = 11 ; public static final short SYNTAX_ERR = 12 ; public static final short INVALID_MODIFICATION_ERR = 13 ; public static final short NAMESPACE_ERR = 14 ; public static final short INVALID_ACCESS_ERR = 15 ; } 	1	['1', '4', '1', '0', '2', '0', '0', '0', '1', '2', '24', '0', '0', '1', '1', '0', '0', '7', '0', '0', '2']
package org . w3c . dom . events ; public interface EventTarget { public void addEventListener ( String type , EventListener listener , boolean useCapture ) ; public void removeEventListener ( String type , EventListener listener , boolean useCapture ) ; public boolean dispatchEvent ( Event evt ) throws EventException ; } 	1	['3', '1', '0', '0', '3', '3', '0', '0', '3', '2', '3', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '2']
package org . w3c . dom ; public interface NodeList { public Node item ( int index ) ; public int getLength ( ) ; } 	1	['2', '1', '0', '0', '2', '1', '0', '0', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '2']
package javax . xml . parsers ; public class ParserConfigurationException extends Exception { public ParserConfigurationException ( ) { super ( ) ; } public ParserConfigurationException ( String msg ) { super ( msg ) ; } } 	1	['2', '3', '0', '0', '4', '1', '0', '0', '2', '2', '9', '0', '0', '1', '0.75', '0', '0', '3.5', '0', '0', '1']
package org . apache . xerces . domx ; public abstract class DOMException extends org . w3c . dom . DOMException { public static final short UNSPECIFIED_EVENT_TYPE = 100 ; public static final short UNSUPPORTED_EVENT_TYPE = 101 ; public DOMException ( short code , String message ) { super ( code , message ) ; } } 	1	['1', '5', '1', '1', '2', '0', '1', '0', '1', '2', '8', '0', '0', '1', '1', '0', '0', '5', '0', '0', '1']
package org . apache . xerces . dom ; import org . w3c . dom . * ; import org . apache . xerces . dom . events . MutationEventImpl ; public class AttrNSImpl extends AttrImpl { static final long serialVersionUID = - 781906615369795414L ; protected String namespaceURI ; protected String localName ; protected AttrNSImpl ( DocumentImpl ownerDocument , String namespaceURI , String qualifiedName ) { super ( ownerDocument , qualifiedName ) ; if ( ! DocumentImpl . isXMLName ( qualifiedName ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } int index = qualifiedName . indexOf ( ':' ) ; String prefix ; if ( index < 0 ) { prefix = null ; localName = qualifiedName ; } else { prefix = qualifiedName . substring ( 0 , index ) ; localName = qualifiedName . substring ( index + 1 ) ; } if ( ( prefix != null && ( namespaceURI == null || namespaceURI . equals ( "" ) || ( prefix . equals ( "xml" ) && ! namespaceURI . equals ( "http://www.w3.org/XML/1998/namespace" ) ) || ( prefix . equals ( "xmlns" ) && ! namespaceURI . equals ( "http://www.w3.org/2000/xmlns/" ) ) ) ) || ( qualifiedName . equals ( "xmlns" ) && ( namespaceURI == null || ! namespaceURI . equals ( "http://www.w3.org/2000/xmlns/" ) ) ) ) { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } this . namespaceURI = namespaceURI ; } protected AttrNSImpl ( DocumentImpl ownerDocument , String value ) { super ( ownerDocument , value ) ; } public String getNamespaceURI ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return namespaceURI ; } public String getPrefix ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } int index = name . indexOf ( ':' ) ; return index < 0 ? null : name . substring ( 0 , index ) ; } public void setPrefix ( String prefix ) throws DOMException { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( namespaceURI == null || ( prefix != null && ( ( prefix . equals ( "xmlns" ) && ! namespaceURI . equals ( "http://www.w3.org/2000/xmlns/" ) ) || ( prefix . equals ( "xml" ) && ! namespaceURI . equals ( "http://www.w3.org/XML/1998/namespace" ) ) ) ) ) { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } if ( ownerDocument . errorChecking && ! DocumentImpl . isXMLName ( prefix ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } name = prefix + ":" + localName ; } public String getLocalName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return localName ; } } 	1	['6', '3', '1', '4', '18', '3', '2', '3', '4', '0.8', '192', '0.666666667', '0', '0.9375', '0.611111111', '3', '3', '30.5', '3', '1.3333', '1']
package org . apache . xerces . jaxp ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import org . xml . sax . SAXException ; public class SAXParserFactoryImpl extends SAXParserFactory { public SAXParserFactoryImpl ( ) { super ( ) ; } public SAXParser newSAXParser ( ) throws ParserConfigurationException { return ( new SAXParserImpl ( this . isNamespaceAware ( ) , this . isValidating ( ) ) ) ; } } 	1	['2', '2', '0', '1', '6', '1', '0', '1', '2', '2', '13', '0', '0', '0.928571429', '1', '0', '0', '5.5', '1', '0.5', '1']
package org . apache . xerces . dom ; import java . io . * ; import java . util . Vector ; import java . util . Enumeration ; import org . w3c . dom . * ; import org . apache . xerces . dom . events . MutationEventImpl ; import org . w3c . dom . events . * ; public class AttributeMap extends NamedNodeMapImpl { protected AttributeMap ( ElementImpl ownerNode , NamedNodeMapImpl defaults ) { super ( ownerNode ) ; if ( defaults != null ) { cloneContent ( defaults ) ; if ( nodes != null ) { hasDefaults ( true ) ; } } } public Node setNamedItem ( Node arg ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( arg . getOwnerDocument ( ) != ownerNode . ownerDocument ( ) ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } NodeImpl argn = ( NodeImpl ) arg ; if ( argn . isOwned ( ) ) { throw new DOMExceptionImpl ( DOMException . INUSE_ATTRIBUTE_ERR , "DOM009 Attribute already in use" ) ; } argn . ownerNode = ownerNode ; argn . isOwned ( true ) ; int i = findNamePoint ( arg . getNodeName ( ) , 0 ) ; NodeImpl previous = null ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . setElementAt ( arg , i ) ; previous . ownerNode = ownerNode . ownerDocument ( ) ; previous . isOwned ( false ) ; previous . isSpecified ( true ) ; } else { i = - 1 - i ; if ( null == nodes ) { nodes = new Vector ( 5 , 10 ) ; } nodes . insertElementAt ( arg , i ) ; } if ( NodeImpl . MUTATIONEVENTS && ownerNode . ownerDocument ( ) . mutationEvents ) { ownerNode . dispatchAggregateEvents ( ( AttrImpl ) arg , previous == null ? null : previous . getNodeValue ( ) ) ; } return previous ; } public Node setNamedItemNS ( Node arg ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( arg . getOwnerDocument ( ) != ownerNode . ownerDocument ( ) ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } NodeImpl argn = ( NodeImpl ) arg ; if ( argn . isOwned ( ) ) { throw new DOMExceptionImpl ( DOMException . INUSE_ATTRIBUTE_ERR , "DOM009 Attribute already in use" ) ; } argn . ownerNode = ownerNode ; argn . isOwned ( true ) ; int i = findNamePoint ( argn . getNamespaceURI ( ) , argn . getLocalName ( ) ) ; NodeImpl previous = null ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . setElementAt ( arg , i ) ; previous . ownerNode = ownerNode . ownerDocument ( ) ; previous . isOwned ( false ) ; previous . isSpecified ( true ) ; } else { i = findNamePoint ( arg . getNodeName ( ) , 0 ) ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . insertElementAt ( arg , i ) ; } else { i = - 1 - i ; if ( null == nodes ) { nodes = new Vector ( 5 , 10 ) ; } nodes . insertElementAt ( arg , i ) ; } } if ( NodeImpl . MUTATIONEVENTS && ownerNode . ownerDocument ( ) . mutationEvents ) { ownerNode . dispatchAggregateEvents ( ( AttrImpl ) arg , previous == null ? null : previous . getNodeValue ( ) ) ; } return previous ; } public Node removeNamedItem ( String name ) throws DOMException { return internalRemoveNamedItem ( name , true ) ; } Node safeRemoveNamedItem ( String name ) { return internalRemoveNamedItem ( name , false ) ; } final protected Node internalRemoveNamedItem ( String name , boolean raiseEx ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } int i = findNamePoint ( name , 0 ) ; if ( i < 0 ) { if ( raiseEx ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } else { return null ; } } NodeImpl n = ( NodeImpl ) nodes . elementAt ( i ) ; if ( hasDefaults ( ) ) { NamedNodeMapImpl defaults = ( ( ElementImpl ) ownerNode ) . getDefaultAttributes ( ) ; Node d ; if ( defaults != null && ( d = defaults . getNamedItem ( name ) ) != null && findNamePoint ( name , i + 1 ) < 0 ) { NodeImpl clone = ( NodeImpl ) d . cloneNode ( true ) ; clone . ownerNode = ownerNode ; clone . isOwned ( true ) ; clone . isSpecified ( false ) ; nodes . setElementAt ( clone , i ) ; } else { nodes . removeElementAt ( i ) ; } } else { nodes . removeElementAt ( i ) ; } n . ownerNode = ownerNode . ownerDocument ( ) ; n . isOwned ( false ) ; n . isSpecified ( true ) ; return n ; } public Node removeNamedItemNS ( String namespaceURI , String name ) throws DOMException { return internalRemoveNamedItemNS ( namespaceURI , name , true ) ; } Node safeRemoveNamedItemNS ( String namespaceURI , String name ) { return internalRemoveNamedItemNS ( namespaceURI , name , false ) ; } final protected Node internalRemoveNamedItemNS ( String namespaceURI , String name , boolean raiseEx ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } int i = findNamePoint ( namespaceURI , name ) ; if ( i < 0 ) { if ( raiseEx ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } else { return null ; } } LCount lc = null ; String oldvalue = "" ; AttrImpl enclosingAttribute = null ; if ( NodeImpl . MUTATIONEVENTS && ownerNode . ownerDocument ( ) . mutationEvents ) { lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttribute = ( AttrImpl ) ( nodes . elementAt ( i ) ) ; oldvalue = enclosingAttribute . getNodeValue ( ) ; } } NodeImpl n = ( NodeImpl ) nodes . elementAt ( i ) ; String nodeName = n . getNodeName ( ) ; if ( hasDefaults ( ) ) { NamedNodeMapImpl defaults = ( ( ElementImpl ) ownerNode ) . getDefaultAttributes ( ) ; Node d ; if ( defaults != null && ( d = defaults . getNamedItem ( nodeName ) ) != null ) { int j = findNamePoint ( nodeName , 0 ) ; if ( j >= 0 && findNamePoint ( nodeName , j + 1 ) < 0 ) { NodeImpl clone = ( NodeImpl ) d . cloneNode ( true ) ; clone . ownerNode = ownerNode ; clone . isOwned ( true ) ; clone . isSpecified ( false ) ; nodes . setElementAt ( clone , i ) ; } else { nodes . removeElementAt ( i ) ; } } else { nodes . removeElementAt ( i ) ; } } else { nodes . removeElementAt ( i ) ; } n . ownerNode = ownerNode . ownerDocument ( ) ; n . isOwned ( false ) ; n . isSpecified ( true ) ; if ( NodeImpl . MUTATIONEVENTS && ownerNode . ownerDocument ( ) . mutationEvents ) { if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_ATTR_MODIFIED , true , false , null , n . getNodeValue ( ) , ( ( ElementImpl ) ownerNode ) . getAttribute ( name ) , name ) ; ownerNode . dispatchEvent ( me ) ; } ownerNode . dispatchAggregateEvents ( null , null ) ; } return n ; } public NamedNodeMapImpl cloneMap ( NodeImpl ownerNode ) { AttributeMap newmap = new AttributeMap ( ( ElementImpl ) ownerNode , null ) ; newmap . hasDefaults ( hasDefaults ( ) ) ; newmap . cloneContent ( this ) ; return newmap ; } } 	1	['10', '2', '0', '8', '43', '25', '1', '8', '5', '2', '592', '0', '0', '0.571428571', '0.328571429', '1', '7', '58.2', '13', '2.8', '2']
package javax . xml . parsers ; import java . io . File ; import java . io . InputStream ; import java . io . IOException ; import org . xml . sax . EntityResolver ; import org . xml . sax . ErrorHandler ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . w3c . dom . Document ; public abstract class DocumentBuilder { protected DocumentBuilder ( ) { super ( ) ; } public Document parse ( InputStream stream ) throws SAXException , IOException , IllegalArgumentException { if ( stream == null ) throw new IllegalArgumentException ( ) ; return ( this . parse ( new InputSource ( stream ) ) ) ; } public Document parse ( String uri ) throws SAXException , IOException , IllegalArgumentException { if ( uri == null ) throw new IllegalArgumentException ( ) ; return ( this . parse ( new InputSource ( uri ) ) ) ; } public Document parse ( File file ) throws SAXException , IOException , IllegalArgumentException { if ( file == null ) throw new IllegalArgumentException ( ) ; return ( this . parse ( new InputSource ( file . getName ( ) ) ) ) ; } public abstract Document parse ( InputSource source ) throws SAXException , IOException , IllegalArgumentException ; public abstract Document newDocument ( ) ; public abstract boolean isNamespaceAware ( ) ; public abstract boolean isValidating ( ) ; public abstract void setEntityResolver ( EntityResolver er ) ; public abstract void setErrorHandler ( ErrorHandler eh ) ; } 	1	['10', '1', '1', '0', '15', '45', '0', '0', '9', '2', '53', '0', '0', '0', '0.228571429', '0', '0', '4.3', '1', '0.9', '1']
package org . apache . xerces . dom . events ; import org . apache . xerces . dom . * ; import org . w3c . dom . * ; import org . w3c . dom . events . * ; public class MutationEventImpl extends org . apache . xerces . dom . events . EventImpl implements MutationEvent { Node relatedNode = null ; String prevValue = null , newValue = null , attrName = null ; public static final String DOM_SUBTREE_MODIFIED = "DOMSubtreeModified" ; public static final String DOM_NODE_INSERTED = "DOMNodeInserted" ; public static final String DOM_NODE_REMOVED = "DOMNodeRemoved" ; public static final String DOM_NODE_REMOVED_FROM_DOCUMENT = "DOMNodeRemovedFromDocument" ; public static final String DOM_NODE_INSERTED_INTO_DOCUMENT = "DOMNodeInsertedIntoDocument" ; public static final String DOM_ATTR_MODIFIED = "DOMAttrModified" ; public static final String DOM_CHARACTER_DATA_MODIFIED = "DOMCharacterDataModified" ; public String getAttrName ( ) { return attrName ; } public String getNewValue ( ) { return newValue ; } public String getPrevValue ( ) { return prevValue ; } public Node getRelatedNode ( ) { return relatedNode ; } public void initMutationEvent ( String typeArg , boolean canBubbleArg , boolean cancelableArg , Node relatedNodeArg , String prevValueArg , String newValueArg , String attrNameArg ) { relatedNode = relatedNodeArg ; prevValue = prevValueArg ; newValue = newValueArg ; attrName = attrNameArg ; super . initEvent ( typeArg , canBubbleArg , cancelableArg ) ; } } 	1	['6', '2', '0', '7', '8', '0', '6', '1', '6', '0.981818182', '62', '0', '1', '0.642857143', '0.375', '0', '0', '7.5', '1', '0.8333', '2']
package org . apache . xerces . readers ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . utils . SymbolCache ; import org . apache . xerces . utils . UTF8DataChunk ; import org . apache . xerces . utils . XMLCharacterProperties ; import org . xml . sax . SAXParseException ; import org . xml . sax . helpers . LocatorImpl ; import java . io . InputStream ; import java . util . Vector ; final class UTF8Reader extends XMLEntityReader { private final static boolean USE_OUT_OF_LINE_LOAD_NEXT_BYTE = false ; private final static boolean USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE = true ; public UTF8Reader ( XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , boolean sendCharDataAsCharArray , InputStream dataStream , StringPool stringPool ) throws Exception { super ( entityHandler , errorReporter , sendCharDataAsCharArray ) ; fInputStream = dataStream ; fStringPool = stringPool ; fCharArrayRange = fStringPool . createCharArrayRange ( ) ; fCurrentChunk = UTF8DataChunk . createChunk ( fStringPool , null ) ; fillCurrentChunk ( ) ; } public int addString ( int offset , int length ) { if ( length == 0 ) return 0 ; return fCurrentChunk . addString ( offset , length ) ; } public int addSymbol ( int offset , int length ) { if ( length == 0 ) return 0 ; return fCurrentChunk . addSymbol ( offset , length , 0 ) ; } private int addSymbol ( int offset , int length , int hashcode ) { if ( length == 0 ) return 0 ; return fCurrentChunk . addSymbol ( offset , length , hashcode ) ; } public void append ( XMLEntityHandler . CharBuffer charBuffer , int offset , int length ) { fCurrentChunk . append ( charBuffer , offset , length ) ; } private int slowLoadNextByte ( ) throws Exception { fCallClearPreviousChunk = true ; if ( fCurrentChunk . nextChunk ( ) != null ) { fCurrentChunk = fCurrentChunk . nextChunk ( ) ; fCurrentIndex = 0 ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; return ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } else { fCurrentChunk = UTF8DataChunk . createChunk ( fStringPool , fCurrentChunk ) ; return fillCurrentChunk ( ) ; } } private int loadNextByte ( ) throws Exception { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; return fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { return slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) return slowLoadNextByte ( ) ; else return ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } private boolean atEOF ( int offset ) { return ( offset > fLength ) ; } public XMLEntityHandler . EntityReader changeReaders ( ) throws Exception { XMLEntityHandler . EntityReader nextReader = super . changeReaders ( ) ; fCurrentChunk . releaseChunk ( ) ; fCurrentChunk = null ; fMostRecentData = null ; fMostRecentByte = 0 ; return nextReader ; } public boolean lookingAtChar ( char ch , boolean skipPastChar ) throws Exception { int b0 = fMostRecentByte ; if ( b0 != ch ) { if ( b0 == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtChar ( ch , skipPastChar ) ; } } if ( ch == 0x0A && b0 == 0x0D ) { if ( skipPastChar ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; b0 = fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( b0 == 0x0A ) { fLinefeedCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } } } return true ; } return false ; } if ( ch == 0x0D ) return false ; if ( skipPastChar ) { fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } } return true ; } public boolean lookingAtValidChar ( boolean skipPastChar ) throws Exception { int b0 = fMostRecentByte ; if ( b0 < 0x80 ) { if ( b0 >= 0x20 || b0 == 0x09 ) { if ( skipPastChar ) { fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } } return true ; } if ( b0 == 0x0A ) { if ( skipPastChar ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } } return true ; } if ( b0 == 0x0D ) { if ( skipPastChar ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; b0 = fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( b0 == 0x0A ) { fLinefeedCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } } } return true ; } if ( b0 == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtValidChar ( skipPastChar ) ; } } return false ; } UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; int b1 = loadNextByte ( ) ; if ( ( 0xe0 & b0 ) == 0xc0 ) { if ( skipPastChar ) { fCharacterCounter ++ ; loadNextByte ( ) ; } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; } return true ; } int b2 = loadNextByte ( ) ; if ( ( 0xf0 & b0 ) == 0xe0 ) { boolean result = false ; if ( ! ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) ) { if ( skipPastChar ) { fCharacterCounter ++ ; loadNextByte ( ) ; return true ; } result = true ; } fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return result ; } int b3 = loadNextByte ( ) ; boolean result = false ; if ( ( ( b0 & 0xf8 ) == 0xf0 ) && ( ( b1 & 0xc0 ) == 0x80 ) && ( ( b2 & 0xc0 ) == 0x80 ) && ( ( b3 & 0xc0 ) == 0x80 ) ) { if ( skipPastChar ) { fCharacterCounter ++ ; loadNextByte ( ) ; return true ; } result = true ; fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return result ; } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return result ; } } public boolean lookingAtSpace ( boolean skipPastChar ) throws Exception { int ch = fMostRecentByte ; if ( ch > 0x20 ) return false ; if ( ch == 0x20 || ch == 0x09 ) { if ( ! skipPastChar ) return true ; fCharacterCounter ++ ; } else if ( ch == 0x0A ) { if ( ! skipPastChar ) return true ; fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { if ( ! skipPastChar ) return true ; fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; ch = fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ch != 0x0A ) return true ; fLinefeedCounter ++ ; } else { if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtSpace ( skipPastChar ) ; } } return false ; } if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } return true ; } public void skipToChar ( char ch ) throws Exception { int b0 = fMostRecentByte ; while ( true ) { if ( b0 == ch ) return ; if ( b0 == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) . skipToChar ( ch ) ; return ; } fCharacterCounter ++ ; } else if ( b0 == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( b0 == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; b0 = loadNextByte ( ) ; if ( b0 != 0x0A ) continue ; fLinefeedCounter ++ ; } else if ( b0 < 0x80 ) { fCharacterCounter ++ ; } else { fCharacterCounter ++ ; if ( ( 0xe0 & b0 ) == 0xc0 ) { loadNextByte ( ) ; } else if ( ( 0xf0 & b0 ) == 0xe0 ) { loadNextByte ( ) ; loadNextByte ( ) ; } else { loadNextByte ( ) ; loadNextByte ( ) ; loadNextByte ( ) ; } } b0 = loadNextByte ( ) ; } } public void skipPastSpaces ( ) throws Exception { int ch = fMostRecentByte ; while ( true ) { if ( ch == 0x20 || ch == 0x09 ) { fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; ch = fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ch != 0x0A ) continue ; fLinefeedCounter ++ ; } else { if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) changeReaders ( ) . skipPastSpaces ( ) ; return ; } if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; ch = fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } } } protected boolean skippedMultiByteCharWithFlag ( int b0 , int flag ) throws Exception { UTF8DataChunk saveChunk = fCurrentChunk ; int saveOffset = fCurrentOffset ; int saveIndex = fCurrentIndex ; if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } int b1 = loadNextByte ( ) ; if ( ( 0xe0 & b0 ) == 0xc0 ) { if ( ( XMLCharacterProperties . fgCharFlags [ ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ] & flag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } return true ; } int b2 = loadNextByte ( ) ; if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } if ( ( XMLCharacterProperties . fgCharFlags [ ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ] & flag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } return true ; } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } } public void skipPastName ( char fastcheck ) throws Exception { int b0 = fMostRecentByte ; if ( b0 < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ b0 ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ! skippedMultiByteCharWithFlag ( b0 , XMLCharacterProperties . E_InitialNameCharFlag ) ) return ; } while ( true ) { fCharacterCounter ++ ; b0 = loadNextByte ( ) ; if ( fastcheck == b0 ) return ; if ( b0 < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ b0 ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ! skippedMultiByteCharWithFlag ( b0 , XMLCharacterProperties . E_NameCharFlag ) ) return ; } } } public void skipPastNmtoken ( char fastcheck ) throws Exception { int b0 = fMostRecentByte ; while ( true ) { if ( fastcheck == b0 ) return ; if ( b0 < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ b0 ] == 0 ) return ; } else { if ( ! skippedMultiByteCharWithFlag ( b0 , XMLCharacterProperties . E_NameCharFlag ) ) return ; } fCharacterCounter ++ ; b0 = loadNextByte ( ) ; } } public boolean skippedString ( char [ ] s ) throws Exception { int length = s . length ; byte [ ] data = fMostRecentData ; int index = fCurrentIndex + length ; int sindex = length ; try { while ( sindex -- > 0 ) { if ( data [ -- index ] != s [ sindex ] ) return false ; } fCurrentIndex += length ; } catch ( ArrayIndexOutOfBoundsException ex ) { int i = 0 ; index = fCurrentIndex ; while ( index < UTF8DataChunk . CHUNK_SIZE ) { if ( data [ index ++ ] != s [ i ++ ] ) return false ; } UTF8DataChunk dataChunk = fCurrentChunk ; int savedOffset = fCurrentOffset ; int savedIndex = fCurrentIndex ; slowLoadNextByte ( ) ; data = fMostRecentData ; index = 0 ; while ( i < length ) { if ( data [ index ++ ] != s [ i ++ ] ) { fCurrentChunk = dataChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = savedOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = fMostRecentData [ savedIndex ] & 0xFF ; return false ; } } fCurrentIndex = index ; } fCharacterCounter += length ; fCurrentOffset += length ; try { fMostRecentByte = data [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } return true ; } public int scanInvalidChar ( ) throws Exception { int b0 = fMostRecentByte ; int ch = b0 ; if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; ch = loadNextByte ( ) ; if ( ch != 0x0A ) return 0x0A ; fLinefeedCounter ++ ; } else if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . scanInvalidChar ( ) ; } fCharacterCounter ++ ; } else if ( b0 >= 0x80 ) { fCharacterCounter ++ ; int b1 = loadNextByte ( ) ; int b2 = 0 ; if ( ( 0xe0 & b0 ) == 0xc0 ) { ch = ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ; } else if ( ( 0xf0 & b0 ) == 0xe0 ) { b2 = loadNextByte ( ) ; ch = ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; } else if ( ( 0xf8 & b0 ) == 0xf0 ) { b2 = loadNextByte ( ) ; int b3 = loadNextByte ( ) ; ch = ( ( 0x0f & b0 ) << 18 ) + ( ( 0x3f & b1 ) << 12 ) + ( ( 0x3f & b2 ) << 6 ) + ( 0x3f & b3 ) ; } } loadNextByte ( ) ; return ch ; } public int scanCharRef ( boolean hex ) throws Exception { int ch = fMostRecentByte ; if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . scanCharRef ( hex ) ; } return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; } int num = 0 ; if ( hex ) { if ( ch > 'f' || XMLCharacterProperties . fgAsciiXDigitChar [ ch ] == 0 ) return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; num = ch - ( ch < 'A' ? '0' : ( ch < 'a' ? 'A' : 'a' ) - 10 ) ; } else { if ( ch < '0' || ch > '9' ) return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; num = ch - '0' ; } fCharacterCounter ++ ; loadNextByte ( ) ; boolean toobig = false ; while ( true ) { ch = fMostRecentByte ; if ( ch == 0 ) break ; if ( hex ) { if ( ch > 'f' || XMLCharacterProperties . fgAsciiXDigitChar [ ch ] == 0 ) break ; } else { if ( ch < '0' || ch > '9' ) break ; } fCharacterCounter ++ ; loadNextByte ( ) ; if ( hex ) { int dig = ch - ( ch < 'A' ? '0' : ( ch < 'a' ? 'A' : 'a' ) - 10 ) ; num = ( num << 4 ) + dig ; } else { int dig = ch - '0' ; num = ( num * 10 ) + dig ; } if ( num > 0x10FFFF ) { toobig = true ; num = 0 ; } } if ( ch != ';' ) return XMLEntityHandler . CHARREF_RESULT_SEMICOLON_REQUIRED ; fCharacterCounter ++ ; loadNextByte ( ) ; if ( toobig ) return XMLEntityHandler . CHARREF_RESULT_OUT_OF_RANGE ; return num ; } public int scanStringLiteral ( ) throws Exception { boolean single ; if ( ! ( single = lookingAtChar ( '\'' , true ) ) && ! lookingAtChar ( '\"' , true ) ) { return XMLEntityHandler . STRINGLIT_RESULT_QUOTE_REQUIRED ; } int offset = fCurrentOffset ; char qchar = single ? '\'' : '\"' ; while ( ! lookingAtChar ( qchar , false ) ) { if ( ! lookingAtValidChar ( true ) ) { return XMLEntityHandler . STRINGLIT_RESULT_INVALID_CHAR ; } } int stringIndex = fCurrentChunk . addString ( offset , fCurrentOffset - offset ) ; lookingAtChar ( qchar , true ) ; return stringIndex ; } public static final byte fgAsciiAttValueChar [ ] = { 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 2 , 2 , 4 , 4 , 2 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 0 , 0 , 1 , 0 , 0 , 0 , 2 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; public int scanAttValue ( char qchar , boolean asSymbol ) throws Exception { int offset = fCurrentOffset ; int b0 = fMostRecentByte ; while ( true ) { if ( b0 < 0x80 ) { switch ( fgAsciiAttValueChar [ b0 ] ) { case 1 : if ( b0 == qchar ) { int length = fCurrentOffset - offset ; int result = length == 0 ? StringPool . EMPTY_STRING : ( asSymbol ? fCurrentChunk . addSymbol ( offset , length , 0 ) : fCurrentChunk . addString ( offset , length ) ) ; fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } return result ; } case 0 : fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } continue ; case 2 : return XMLEntityHandler . ATTVALUE_RESULT_COMPLEX ; case 3 : return XMLEntityHandler . ATTVALUE_RESULT_LESSTHAN ; case 4 : return XMLEntityHandler . ATTVALUE_RESULT_INVALID_CHAR ; } } else { if ( ! skipMultiByteCharData ( b0 ) ) return XMLEntityHandler . ATTVALUE_RESULT_INVALID_CHAR ; b0 = fMostRecentByte ; } } } public static final byte fgAsciiEntityValueChar [ ] = { 7 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 0 , 5 , 4 , 4 , 6 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 0 , 0 , 1 , 0 , 0 , 3 , 2 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; public int scanEntityValue ( int qchar , boolean createString ) throws Exception { int offset = fCurrentOffset ; int b0 = fMostRecentByte ; while ( true ) { if ( b0 < 0x80 ) { switch ( fgAsciiEntityValueChar [ b0 ] ) { case 1 : if ( b0 == qchar ) { if ( ! createString ) return XMLEntityHandler . ENTITYVALUE_RESULT_FINISHED ; int length = fCurrentOffset - offset ; int result = length == 0 ? StringPool . EMPTY_STRING : fCurrentChunk . addString ( offset , length ) ; fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } return result ; } case 0 : fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } continue ; case 5 : fLinefeedCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } continue ; case 6 : fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( b0 != 0x0A ) { continue ; } fLinefeedCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } continue ; case 2 : return XMLEntityHandler . ENTITYVALUE_RESULT_REFERENCE ; case 3 : return XMLEntityHandler . ENTITYVALUE_RESULT_PEREF ; case 7 : if ( atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . ENTITYVALUE_RESULT_END_OF_INPUT ; } case 4 : return XMLEntityHandler . ENTITYVALUE_RESULT_INVALID_CHAR ; } } else { if ( ! skipMultiByteCharData ( b0 ) ) return XMLEntityHandler . ENTITYVALUE_RESULT_INVALID_CHAR ; b0 = fMostRecentByte ; } } } public boolean scanExpectedName ( char fastcheck , StringPool . CharArrayRange expectedName ) throws Exception { char [ ] expected = expectedName . chars ; int offset = expectedName . offset ; int len = expectedName . length ; int b0 = fMostRecentByte ; int ch = 0 ; int i = 0 ; while ( true ) { if ( b0 < 0x80 ) { ch = b0 ; if ( i == len ) break ; if ( ch != expected [ offset ] ) { skipPastNmtoken ( fastcheck ) ; return false ; } } else { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; int b1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b1 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b1 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b1 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b1 = slowLoadNextByte ( ) ; else b1 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xe0 & b0 ) == 0xc0 ) { ch = ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ; if ( i == len ) break ; if ( ch != expected [ offset ] ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; skipPastNmtoken ( fastcheck ) ; return false ; } } else { int b2 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b2 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b2 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b2 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b2 = slowLoadNextByte ( ) ; else b2 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } ch = ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; if ( i == len ) break ; if ( ch != expected [ offset ] ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; skipPastNmtoken ( fastcheck ) ; return false ; } } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } } } i ++ ; offset ++ ; fCharacterCounter ++ ; fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ch == fastcheck ) return true ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) return true ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) return true ; } skipPastNmtoken ( fastcheck ) ; return false ; } public void scanQName ( char fastcheck , QName qname ) throws Exception { int ch = fMostRecentByte ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 ) { qname . clear ( ) ; return ; } if ( ch == ':' ) { qname . clear ( ) ; return ; } } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) { qname . clear ( ) ; return ; } } int offset = fCurrentOffset ; int index = fCurrentIndex ; byte [ ] data = fMostRecentData ; int prefixend = - 1 ; while ( true ) { fCharacterCounter ++ ; fCurrentOffset ++ ; index ++ ; try { ch = data [ index ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; index = 0 ; data = fMostRecentData ; } if ( fastcheck == ch ) break ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) break ; if ( ch == ':' ) { if ( prefixend != - 1 ) break ; prefixend = fCurrentOffset ; try { ch = data [ index + 1 ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { UTF8DataChunk savedChunk = fCurrentChunk ; int savedOffset = fCurrentOffset ; ch = slowLoadNextByte ( ) ; fCurrentChunk = savedChunk ; fCurrentOffset = savedOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; } boolean lpok = true ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 || ch == ':' ) lpok = false ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) lpok = false ; } ch = ':' ; if ( ! lpok ) { prefixend = - 1 ; break ; } } } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) break ; } } fCurrentIndex = index ; fMostRecentByte = ch ; int length = fCurrentOffset - offset ; qname . rawname = addSymbol ( offset , length ) ; qname . prefix = prefixend == - 1 ? - 1 : addSymbol ( offset , prefixend - offset ) ; qname . localpart = prefixend == - 1 ? qname . rawname : addSymbol ( prefixend + 1 , fCurrentOffset - ( prefixend + 1 ) ) ; qname . uri = - 1 ; } private int getMultiByteSymbolChar ( int b0 ) throws Exception { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } int b1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b1 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b1 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b1 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b1 = slowLoadNextByte ( ) ; else b1 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xe0 & b0 ) == 0xc0 ) { int ch = ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ; if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } loadNextByte ( ) ; return ch ; } int b2 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b2 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b2 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b2 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b2 = slowLoadNextByte ( ) ; else b2 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } int ch = ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } loadNextByte ( ) ; return ch ; } fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } public int scanName ( char fastcheck ) throws Exception { int b0 = fMostRecentByte ; int ch ; if ( b0 < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ b0 ] == 0 ) { if ( b0 == 0 && atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . scanName ( fastcheck ) ; } return - 1 ; } ch = b0 ; } else { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } int b1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b1 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b1 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b1 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b1 = slowLoadNextByte ( ) ; else b1 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xe0 & b0 ) == 0xc0 ) { ch = ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ; if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } } else { int b2 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b2 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b2 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b2 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b2 = slowLoadNextByte ( ) ; else b2 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } ch = ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } } } fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } return scanMatchingName ( ch , b0 , fastcheck ) ; } private int scanMatchingName ( int ch , int b0 , int fastcheck ) throws Exception { SymbolCache cache = fStringPool . getSymbolCache ( ) ; int [ ] [ ] cacheLines = cache . fCacheLines ; char [ ] symbolChars = cache . fSymbolChars ; boolean lengthOfOne = fastcheck == fMostRecentByte ; int startOffset = cache . fSymbolCharsOffset ; int entry = 0 ; int [ ] entries = cacheLines [ entry ] ; int offset = 1 + ( ( entries [ 0 ] - 1 ) * SymbolCache . CACHE_RECORD_SIZE ) ; int totalMisses = 0 ; if ( lengthOfOne ) { while ( offset > 0 ) { if ( entries [ offset + SymbolCache . CHAR_OFFSET ] == ch ) { if ( entries [ offset + SymbolCache . INDEX_OFFSET ] != - 1 ) { int symbolIndex = entries [ offset + SymbolCache . INDEX_OFFSET ] ; if ( totalMisses > 3 ) fStringPool . updateCacheLine ( symbolIndex , totalMisses , 1 ) ; return symbolIndex ; } break ; } offset -= SymbolCache . CACHE_RECORD_SIZE ; totalMisses ++ ; } try { symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { symbolChars = new char [ cache . fSymbolCharsOffset * 2 ] ; System . arraycopy ( cache . fSymbolChars , 0 , symbolChars , 0 , cache . fSymbolCharsOffset ) ; cache . fSymbolChars = symbolChars ; symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } cache . fSymbolCharsOffset ++ ; if ( offset < 0 ) { offset = 1 + ( entries [ 0 ] * SymbolCache . CACHE_RECORD_SIZE ) ; entries [ 0 ] ++ ; try { entries [ offset + SymbolCache . CHAR_OFFSET ] = ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { int newSize = 1 + ( ( offset - 1 ) * 2 ) ; entries = new int [ newSize ] ; System . arraycopy ( cacheLines [ entry ] , 0 , entries , 0 , offset ) ; cacheLines [ entry ] = entries ; entries [ offset + SymbolCache . CHAR_OFFSET ] = ch ; } entries [ offset + SymbolCache . NEXT_OFFSET ] = - 1 ; } int result = fStringPool . createNonMatchingSymbol ( startOffset , entry , entries , offset ) ; return result ; } try { symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { symbolChars = new char [ cache . fSymbolCharsOffset * 2 ] ; System . arraycopy ( cache . fSymbolChars , 0 , symbolChars , 0 , cache . fSymbolCharsOffset ) ; cache . fSymbolChars = symbolChars ; symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } cache . fSymbolCharsOffset ++ ; int depth = 1 ; while ( true ) { if ( offset < 0 ) break ; if ( entries [ offset + SymbolCache . CHAR_OFFSET ] != ch ) { offset -= SymbolCache . CACHE_RECORD_SIZE ; totalMisses ++ ; continue ; } if ( b0 >= 0x80 ) { ch = getMultiByteSymbolChar ( b0 ) ; b0 = fMostRecentByte ; } else if ( b0 == fastcheck || XMLCharacterProperties . fgAsciiNameChar [ b0 ] == 0 ) { ch = - 1 ; } else { ch = b0 ; fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } } if ( ch == - 1 ) { if ( entries [ offset + SymbolCache . INDEX_OFFSET ] == - 1 ) { return fStringPool . createNonMatchingSymbol ( startOffset , entry , entries , offset ) ; } cache . fSymbolCharsOffset = startOffset ; int symbolIndex = entries [ offset + SymbolCache . INDEX_OFFSET ] ; if ( totalMisses > ( depth * 3 ) ) fStringPool . updateCacheLine ( symbolIndex , totalMisses , depth ) ; return symbolIndex ; } try { symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { symbolChars = new char [ cache . fSymbolCharsOffset * 2 ] ; System . arraycopy ( cache . fSymbolChars , 0 , symbolChars , 0 , cache . fSymbolCharsOffset ) ; cache . fSymbolChars = symbolChars ; symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } cache . fSymbolCharsOffset ++ ; entry = entries [ offset + SymbolCache . NEXT_OFFSET ] ; try { entries = cacheLines [ entry ] ; } catch ( ArrayIndexOutOfBoundsException ex ) { if ( entry == - 1 ) { entry = cache . fCacheLineCount ++ ; entries [ offset + SymbolCache . NEXT_OFFSET ] = entry ; entries = new int [ 1 + ( SymbolCache . INITIAL_CACHE_RECORD_COUNT * SymbolCache . CACHE_RECORD_SIZE ) ] ; try { cacheLines [ entry ] = entries ; } catch ( ArrayIndexOutOfBoundsException ex2 ) { cacheLines = new int [ entry * 2 ] [ ] ; System . arraycopy ( cache . fCacheLines , 0 , cacheLines , 0 , entry ) ; cache . fCacheLines = cacheLines ; cacheLines [ entry ] = entries ; } } else { entries = cacheLines [ entry ] ; throw new RuntimeException ( "RDR001 untested" ) ; } } offset = 1 + ( ( entries [ 0 ] - 1 ) * SymbolCache . CACHE_RECORD_SIZE ) ; depth ++ ; } if ( offset < 0 ) offset = 1 + ( entries [ 0 ] * SymbolCache . CACHE_RECORD_SIZE ) ; while ( true ) { entries [ 0 ] ++ ; try { entries [ offset + SymbolCache . CHAR_OFFSET ] = ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { int newSize = 1 + ( ( offset - 1 ) * 2 ) ; entries = new int [ newSize ] ; System . arraycopy ( cacheLines [ entry ] , 0 , entries , 0 , offset ) ; cacheLines [ entry ] = entries ; entries [ offset + SymbolCache . CHAR_OFFSET ] = ch ; } if ( b0 >= 0x80 ) { ch = getMultiByteSymbolChar ( b0 ) ; b0 = fMostRecentByte ; } else if ( b0 == fastcheck || XMLCharacterProperties . fgAsciiNameChar [ b0 ] == 0 ) { ch = - 1 ; } else { ch = b0 ; fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } } if ( ch == - 1 ) { entries [ offset + SymbolCache . NEXT_OFFSET ] = - 1 ; break ; } entry = cache . fCacheLineCount ++ ; entries [ offset + SymbolCache . INDEX_OFFSET ] = - 1 ; entries [ offset + SymbolCache . NEXT_OFFSET ] = entry ; entries = new int [ 1 + ( SymbolCache . INITIAL_CACHE_RECORD_COUNT * SymbolCache . CACHE_RECORD_SIZE ) ] ; try { cacheLines [ entry ] = entries ; } catch ( ArrayIndexOutOfBoundsException ex ) { cacheLines = new int [ entry * 2 ] [ ] ; System . arraycopy ( cache . fCacheLines , 0 , cacheLines , 0 , entry ) ; cache . fCacheLines = cacheLines ; cacheLines [ entry ] = entries ; } offset = 1 ; try { symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { symbolChars = new char [ cache . fSymbolCharsOffset * 2 ] ; System . arraycopy ( cache . fSymbolChars , 0 , symbolChars , 0 , cache . fSymbolCharsOffset ) ; cache . fSymbolChars = symbolChars ; symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } cache . fSymbolCharsOffset ++ ; } int result = fStringPool . createNonMatchingSymbol ( startOffset , entry , entries , offset ) ; return result ; } private int recognizeMarkup ( int b0 , QName element ) throws Exception { switch ( b0 ) { case 0 : return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; case '?' : fCharacterCounter ++ ; loadNextByte ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_PI ; case '!' : fCharacterCounter ++ ; b0 = loadNextByte ( ) ; if ( b0 == 0 ) { fCharacterCounter -- ; fCurrentOffset -- ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( b0 == '-' ) { fCharacterCounter ++ ; b0 = loadNextByte ( ) ; if ( b0 == 0 ) { fCharacterCounter -= 2 ; fCurrentOffset -= 2 ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( b0 == '-' ) { fCharacterCounter ++ ; b0 = loadNextByte ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_COMMENT ; } break ; } if ( b0 == '[' ) { for ( int i = 0 ; i < 6 ; i ++ ) { fCharacterCounter ++ ; b0 = loadNextByte ( ) ; if ( b0 == 0 ) { fCharacterCounter -= ( 2 + i ) ; fCurrentOffset -= ( 2 + i ) ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( b0 != cdata_string [ i ] ) { return XMLEntityHandler . CONTENT_RESULT_MARKUP_NOT_RECOGNIZED ; } } fCharacterCounter ++ ; loadNextByte ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_CDSECT ; } break ; case '/' : fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } int expectedName = element . rawname ; fStringPool . getCharArrayRange ( expectedName , fCharArrayRange ) ; char [ ] expected = fCharArrayRange . chars ; int offset = fCharArrayRange . offset ; int len = fCharArrayRange . length ; if ( b0 == expected [ offset ++ ] ) { UTF8DataChunk savedChunk = fCurrentChunk ; int savedIndex = fCurrentIndex ; int savedOffset = fCurrentOffset ; for ( int i = 1 ; i < len ; i ++ ) { if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( b0 != expected [ offset ++ ] ) { fCurrentChunk = savedChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = savedOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = fMostRecentData [ savedIndex ] & 0xFF ; return XMLEntityHandler . CONTENT_RESULT_START_OF_ETAG ; } } fCharacterCounter += len ; fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( b0 == '>' ) { fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } return XMLEntityHandler . CONTENT_RESULT_MATCHING_ETAG ; } while ( b0 == 0x20 || b0 == 0x09 || b0 == 0x0A || b0 == 0x0D ) { if ( b0 == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; b0 = loadNextByte ( ) ; } else if ( b0 == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; b0 = loadNextByte ( ) ; if ( b0 == 0x0A ) { fLinefeedCounter ++ ; b0 = loadNextByte ( ) ; } } else { fCharacterCounter ++ ; b0 = loadNextByte ( ) ; } if ( b0 == '>' ) { fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } return XMLEntityHandler . CONTENT_RESULT_MATCHING_ETAG ; } } fCurrentChunk = savedChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = savedOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = fMostRecentData [ savedIndex ] & 0xFF ; } return XMLEntityHandler . CONTENT_RESULT_START_OF_ETAG ; default : return XMLEntityHandler . CONTENT_RESULT_START_OF_ELEMENT ; } return XMLEntityHandler . CONTENT_RESULT_MARKUP_NOT_RECOGNIZED ; } private int recognizeReference ( int ch ) throws Exception { if ( ch == 0 ) { return XMLEntityHandler . CONTENT_RESULT_REFERENCE_END_OF_INPUT ; } if ( ch == '#' ) { fCharacterCounter ++ ; loadNextByte ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_CHARREF ; } else { return XMLEntityHandler . CONTENT_RESULT_START_OF_ENTITYREF ; } } public int scanContent ( QName element ) throws Exception { if ( fCallClearPreviousChunk && fCurrentChunk . clearPreviousChunk ( ) ) fCallClearPreviousChunk = false ; fCharDataLength = 0 ; int charDataOffset = fCurrentOffset ; int ch = fMostRecentByte ; if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiWSCharData [ ch ] ) { case 0 : if ( fSendCharDataAsCharArray ) { try { fCharacters [ fCharDataLength ] = ( char ) ch ; fCharDataLength ++ ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowAppendCharData ( ch ) ; } } fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } break ; case 1 : fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ! fInCDSect ) { return recognizeMarkup ( ch , element ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '<' ) ; break ; case 2 : fCharacterCounter ++ ; ch = loadNextByte ( ) ; if ( ! fInCDSect ) { return recognizeReference ( ch ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '&' ) ; break ; case 3 : fCharacterCounter ++ ; ch = loadNextByte ( ) ; if ( ch != ']' ) { if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } if ( fCurrentIndex + 1 == UTF8DataChunk . CHUNK_SIZE ) { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; if ( loadNextByte ( ) != '>' ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = ']' ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) { if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextByte ( ) ; fCharacterCounter += 2 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; case 5 : do { if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ch != 0x0A ) { if ( fSendCharDataAsCharArray ) appendCharData ( 0x0A ) ; if ( ch == 0x20 || ch == 0x09 || ch == 0x0D ) continue ; break ; } fLinefeedCounter ++ ; } else { fCharacterCounter ++ ; } if ( fSendCharDataAsCharArray ) { try { fCharacters [ fCharDataLength ] = ( char ) ch ; fCharDataLength ++ ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowAppendCharData ( ch ) ; } } if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } } while ( ch == 0x20 || ch == 0x09 || ch == 0x0A || ch == 0x0D ) ; if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiCharData [ ch ] ) { case 0 : if ( fSendCharDataAsCharArray ) appendCharData ( ch ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 1 : if ( ! fInCDSect ) { if ( fSendCharDataAsCharArray ) { fCharDataHandler . processWhitespace ( fCharacters , 0 , fCharDataLength ) ; } else { int stringIndex = addString ( charDataOffset , fCurrentOffset - charDataOffset ) ; fCharDataHandler . processWhitespace ( stringIndex ) ; } fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } return recognizeMarkup ( ch , element ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '<' ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 2 : if ( ! fInCDSect ) { whitespace ( charDataOffset , fCurrentOffset ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; return recognizeReference ( ch ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '&' ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 3 : int endOffset = fCurrentOffset ; ch = loadNextByte ( ) ; if ( ch != ']' ) { fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } if ( fCurrentIndex + 1 == UTF8DataChunk . CHUNK_SIZE ) { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; if ( loadNextByte ( ) != '>' ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = ']' ; fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) { fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextByte ( ) ; whitespace ( charDataOffset , endOffset ) ; fCharacterCounter += 3 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : whitespace ( charDataOffset , fCurrentOffset ) ; if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else { if ( fSendCharDataAsCharArray ) { if ( ! copyMultiByteCharData ( ch ) ) { whitespace ( charDataOffset , fCurrentOffset ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else if ( ! skipMultiByteCharData ( ch ) ) { whitespace ( charDataOffset , fCurrentOffset ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } break ; } } else { if ( fSendCharDataAsCharArray ) { if ( ! copyMultiByteCharData ( ch ) ) { return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else { if ( ! skipMultiByteCharData ( ch ) ) { return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } } if ( fSendCharDataAsCharArray ) ch = copyAsciiCharData ( ) ; else ch = skipAsciiCharData ( ) ; while ( true ) { if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiCharData [ ch ] ) { case 0 : if ( fSendCharDataAsCharArray ) appendCharData ( ch ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 1 : if ( ! fInCDSect ) { if ( fSendCharDataAsCharArray ) { fCharDataHandler . processCharacters ( fCharacters , 0 , fCharDataLength ) ; } else { int stringIndex = addString ( charDataOffset , fCurrentOffset - charDataOffset ) ; fCharDataHandler . processCharacters ( stringIndex ) ; } fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } return recognizeMarkup ( ch , element ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '<' ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 2 : if ( ! fInCDSect ) { characters ( charDataOffset , fCurrentOffset ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; return recognizeReference ( ch ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '&' ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 3 : int endOffset = fCurrentOffset ; ch = loadNextByte ( ) ; if ( ch != ']' ) { fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } if ( fCurrentIndex + 1 == UTF8DataChunk . CHUNK_SIZE ) { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; if ( loadNextByte ( ) != '>' ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = ']' ; fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) { fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextByte ( ) ; characters ( charDataOffset , endOffset ) ; fCharacterCounter += 3 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : if ( ch == 0x0A ) { if ( fSendCharDataAsCharArray ) appendCharData ( ch ) ; fLinefeedCounter ++ ; fCharacterCounter = 1 ; ch = loadNextByte ( ) ; break ; } if ( ch == 0x0D ) { if ( fSendCharDataAsCharArray ) appendCharData ( 0x0A ) ; fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; ch = loadNextByte ( ) ; if ( ch == 0x0A ) { fLinefeedCounter ++ ; ch = loadNextByte ( ) ; } break ; } characters ( charDataOffset , fCurrentOffset ) ; if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else { if ( fSendCharDataAsCharArray ) { if ( ! copyMultiByteCharData ( ch ) ) { characters ( charDataOffset , fCurrentOffset ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else if ( ! skipMultiByteCharData ( ch ) ) { characters ( charDataOffset , fCurrentOffset ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } ch = fMostRecentByte ; } } } private boolean copyMultiByteCharData ( int b0 ) throws Exception { UTF8DataChunk saveChunk = fCurrentChunk ; int saveOffset = fCurrentOffset ; int saveIndex = fCurrentIndex ; int b1 = loadNextByte ( ) ; if ( ( 0xe0 & b0 ) == 0xc0 ) { int ch = ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ; appendCharData ( ch ) ; loadNextByte ( ) ; return true ; } int b2 = loadNextByte ( ) ; if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } int ch = ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; appendCharData ( ch ) ; loadNextByte ( ) ; return true ; } int b3 = loadNextByte ( ) ; if ( ( 0xf8 & b0 ) == 0xf0 ) { if ( b0 > 0xF4 || ( b0 == 0xF4 && b1 >= 0x90 ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } int ch = ( ( 0x0f & b0 ) << 18 ) + ( ( 0x3f & b1 ) << 12 ) + ( ( 0x3f & b2 ) << 6 ) + ( 0x3f & b3 ) ; if ( ch < 0x10000 ) { appendCharData ( ch ) ; } else { appendCharData ( ( ( ch - 0x00010000 ) > > 10 ) + 0xd800 ) ; appendCharData ( ( ( ch - 0x00010000 ) & 0x3ff ) + 0xdc00 ) ; } loadNextByte ( ) ; return true ; } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } } private boolean skipMultiByteCharData ( int b0 ) throws Exception { UTF8DataChunk saveChunk = fCurrentChunk ; int saveOffset = fCurrentOffset ; int saveIndex = fCurrentIndex ; int b1 = loadNextByte ( ) ; if ( ( 0xe0 & b0 ) == 0xc0 ) { loadNextByte ( ) ; return true ; } int b2 = loadNextByte ( ) ; if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } loadNextByte ( ) ; return true ; } int b3 = loadNextByte ( ) ; if ( b0 > 0xF4 || ( b0 == 0xF4 && b1 >= 0x90 ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } loadNextByte ( ) ; return true ; } private int copyAsciiCharData ( ) throws Exception { int srcIndex = fCurrentIndex ; int offset = fCurrentOffset - srcIndex ; byte [ ] data = fMostRecentData ; int dstIndex = fCharDataLength ; boolean skiplf = false ; while ( true ) { int ch ; try { ch = data [ srcIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { offset += srcIndex ; slowLoadNextByte ( ) ; srcIndex = 0 ; data = fMostRecentData ; ch = data [ srcIndex ] & 0xFF ; } if ( ch >= 0x80 ) { fCurrentOffset = offset + srcIndex ; fCurrentIndex = srcIndex ; fMostRecentByte = ch ; return ch ; } if ( XMLCharacterProperties . fgAsciiCharData [ ch ] == 0 ) { fCharacterCounter ++ ; skiplf = false ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; if ( skiplf ) { skiplf = false ; srcIndex ++ ; continue ; } fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; skiplf = true ; ch = 0x0A ; } else { fCurrentOffset = offset + srcIndex ; fCurrentIndex = srcIndex ; fMostRecentByte = ch ; return ch ; } srcIndex ++ ; try { fCharacters [ fCharDataLength ] = ( char ) ch ; fCharDataLength ++ ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowAppendCharData ( ch ) ; } } } private int skipAsciiCharData ( ) throws Exception { int srcIndex = fCurrentIndex ; int offset = fCurrentOffset - srcIndex ; byte [ ] data = fMostRecentData ; while ( true ) { int ch ; try { ch = data [ srcIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { offset += srcIndex ; slowLoadNextByte ( ) ; srcIndex = 0 ; data = fMostRecentData ; ch = data [ srcIndex ] & 0xFF ; } if ( ch >= 0x80 ) { fCurrentOffset = offset + srcIndex ; fCurrentIndex = srcIndex ; fMostRecentByte = ch ; return ch ; } if ( XMLCharacterProperties . fgAsciiCharData [ ch ] == 0 ) { fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; } else { fCurrentOffset = offset + srcIndex ; fCurrentIndex = srcIndex ; fMostRecentByte = ch ; return ch ; } srcIndex ++ ; } } private char [ ] fCharacters = new char [ UTF8DataChunk . CHUNK_SIZE ] ; private int fCharDataLength = 0 ; private void appendCharData ( int ch ) throws Exception { try { fCharacters [ fCharDataLength ] = ( char ) ch ; fCharDataLength ++ ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowAppendCharData ( ch ) ; } } private void slowAppendCharData ( int ch ) throws Exception { characters ( 0 , fCharDataLength ) ; fCharDataLength = 0 ; fCharacters [ fCharDataLength ++ ] = ( char ) ch ; } private void characters ( int offset , int endOffset ) throws Exception { if ( ! fSendCharDataAsCharArray ) { int stringIndex = addString ( offset , endOffset - offset ) ; fCharDataHandler . processCharacters ( stringIndex ) ; return ; } fCharDataHandler . processCharacters ( fCharacters , 0 , fCharDataLength ) ; } private void whitespace ( int offset , int endOffset ) throws Exception { if ( ! fSendCharDataAsCharArray ) { int stringIndex = addString ( offset , endOffset - offset ) ; fCharDataHandler . processWhitespace ( stringIndex ) ; return ; } fCharDataHandler . processWhitespace ( fCharacters , 0 , fCharDataLength ) ; } private static final char [ ] cdata_string = { 'C' , 'D' , 'A' , 'T' , 'A' , '[' } ; private StringPool . CharArrayRange fCharArrayRange = null ; private InputStream fInputStream = null ; private StringPool fStringPool = null ; private UTF8DataChunk fCurrentChunk = null ; private int fCurrentIndex = 0 ; private byte [ ] fMostRecentData = null ; private int fMostRecentByte = 0 ; private int fLength = 0 ; private boolean fCalledCharPropInit = false ; private boolean fCallClearPreviousChunk = true ; private int fillCurrentChunk ( ) throws Exception { byte [ ] buf = fCurrentChunk . toByteArray ( ) ; if ( fInputStream == null ) { if ( buf == null ) buf = new byte [ 1 ] ; buf [ 0 ] = 0 ; fMostRecentData = buf ; fCurrentIndex = 0 ; fCurrentChunk . setByteArray ( fMostRecentData ) ; return ( fMostRecentByte = fMostRecentData [ 0 ] & 0xFF ) ; } if ( buf == null ) buf = new byte [ UTF8DataChunk . CHUNK_SIZE ] ; int offset = 0 ; int capacity = UTF8DataChunk . CHUNK_SIZE ; int result = 0 ; do { try { result = fInputStream . read ( buf , offset , capacity ) ; } catch ( java . io . IOException ex ) { result = - 1 ; } if ( result == - 1 ) { fInputStream . close ( ) ; fInputStream = null ; try { buf [ offset ] = 0 ; } catch ( ArrayIndexOutOfBoundsException ex ) { } break ; } if ( result > 0 ) { offset += result ; capacity -= result ; } } while ( capacity > 0 ) ; fMostRecentData = buf ; fLength += offset ; fCurrentIndex = 0 ; fCurrentChunk . setByteArray ( fMostRecentData ) ; return ( fMostRecentByte = fMostRecentData [ 0 ] & 0xFF ) ; } } 	1	['41', '2', '0', '13', '75', '0', '1', '12', '22', '0.608823529', '7413', '0.882352941', '3', '0.152173913', '0.170833333', '1', '4', '179.3902439', '2', '1.0488', '1']
package org . apache . xerces . dom . events ; import org . w3c . dom . events . * ; import org . w3c . dom . Node ; public class EventImpl implements Event { public String type = null ; public EventTarget target ; public Node currentNode ; public short eventPhase ; public boolean initialized = false , bubbles = true , cancelable = false ; public boolean stopPropagation = false , preventDefault = false ; protected long timeStamp = System . currentTimeMillis ( ) ; public void initEvent ( String eventTypeArg , boolean canBubbleArg , boolean cancelableArg ) { type = eventTypeArg ; bubbles = canBubbleArg ; cancelable = cancelableArg ; initialized = true ; } public boolean getBubbles ( ) { return bubbles ; } public boolean getCancelable ( ) { return cancelable ; } public Node getCurrentNode ( ) { return currentNode ; } public short getEventPhase ( ) { return eventPhase ; } public EventTarget getTarget ( ) { return target ; } public String getType ( ) { return type ; } public long getTimeStamp ( ) { return timeStamp ; } public void stopPropagation ( ) { stopPropagation = true ; } public void preventDefault ( ) { preventDefault = true ; } } 	1	['11', '1', '1', '3', '13', '35', '3', '0', '11', '0.9', '87', '0.1', '2', '0', '0.393939394', '0', '0', '6', '1', '0.9091', '1']
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class DOMImplementationImpl implements DOMImplementation { static DOMImplementationImpl singleton = new DOMImplementationImpl ( ) ; public boolean hasFeature ( String feature , String version ) { return ( feature . equalsIgnoreCase ( "XML" ) && ( version == null || version . equals ( "1.0" ) || version . equals ( "2.0" ) ) ) || ( feature . equalsIgnoreCase ( "Events" ) && ( version == null || version . equals ( "2.0" ) ) ) || ( feature . equalsIgnoreCase ( "MutationEvents" ) && ( version == null || version . equals ( "2.0" ) ) ) || ( feature . equalsIgnoreCase ( "Traversal" ) && ( version == null || version . equals ( "2.0" ) ) ) ; } public static DOMImplementation getDOMImplementation ( ) { return singleton ; } public DocumentType createDocumentType ( String qualifiedName , String publicID , String systemID ) { if ( ! DocumentImpl . isXMLName ( qualifiedName ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } int index = qualifiedName . indexOf ( ':' ) ; if ( index == 0 || index == qualifiedName . length ( ) - 1 ) { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } return new DocumentTypeImpl ( null , qualifiedName , publicID , systemID ) ; } public Document createDocument ( String namespaceURI , String qualifiedName , DocumentType doctype ) throws DOMException { if ( doctype != null && doctype . getOwnerDocument ( ) != null ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } DocumentImpl doc = new DocumentImpl ( doctype ) ; Element e = doc . createElementNS ( namespaceURI , qualifiedName ) ; doc . appendChild ( e ) ; return doc ; } } 	1	['6', '1', '2', '5', '18', '13', '3', '3', '5', '0.8', '127', '0', '1', '0', '0.533333333', '0', '0', '20', '14', '3.3333', '1']
package org . w3c . dom . traversal ; import org . w3c . dom . DOMException ; import org . w3c . dom . Node ; public interface DocumentTraversal { public NodeIterator createNodeIterator ( Node root , int whatToShow , NodeFilter filter , boolean entityReferenceExpansion ) ; public TreeWalker createTreeWalker ( Node root , int whatToShow , NodeFilter filter , boolean entityReferenceExpansion ) throws DOMException ; } 	1	['2', '1', '0', '0', '2', '1', '0', '0', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '2']
package org . apache . xerces . readers ; import java . io . FileNotFoundException ; import java . io . UnsupportedEncodingException ; import java . net . MalformedURLException ; import java . util . Stack ; import java . util . Vector ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . utils . ImplementationMessages ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . utils . URI ; import org . apache . xerces . utils . XMLCharacterProperties ; import org . apache . xerces . utils . XMLMessages ; import org . xml . sax . EntityResolver ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . helpers . LocatorImpl ; public class DefaultEntityHandler implements XMLEntityHandler , XMLEntityHandler . DTDHandler { public interface EventHandler { public void startEntityReference ( int entityName , int entityType , int entityContext ) throws Exception ; public void endEntityReference ( int entityName , int entityType , int entityContext ) throws Exception ; public void sendEndOfInputNotifications ( int entityName , boolean moreToFollow ) throws Exception ; public void sendReaderChangeNotifications ( XMLEntityHandler . EntityReader reader , int readerId ) throws Exception ; public boolean externalEntityStandaloneCheck ( ) ; public boolean getValidating ( ) ; } private class ReaderState { XMLEntityHandler . EntityReader reader ; InputSource source ; int entityName ; int entityType ; int entityContext ; String publicId ; String systemId ; int readerId ; int depth ; ReaderState nextReaderState ; } private ReaderState fReaderStateFreeList = null ; private StringPool fStringPool = null ; private EventHandler fEventHandler = null ; private XMLEntityHandler . CharDataHandler fCharDataHandler = null ; private XMLErrorReporter fErrorReporter = null ; private EntityResolver fResolver = null ; private EntityPool fEntityPool = null ; private EntityPool fParameterEntityPool = null ; private byte [ ] fEntityTypeStack = null ; private int [ ] fEntityNameStack = null ; private int fEntityStackDepth = 0 ; private Stack fReaderStack = new Stack ( ) ; private XMLEntityHandler . EntityReader fReader = null ; private InputSource fSource = null ; private int fEntityName = - 1 ; private int fEntityType = - 1 ; private int fEntityContext = - 1 ; private String fPublicId = null ; private String fSystemId = null ; private int fReaderId = - 1 ; private int fReaderDepth = - 1 ; private int fNextReaderId = 0 ; private NullReader fNullReader = null ; protected XMLEntityReaderFactory fReaderFactory = null ; private boolean fSendCharDataAsCharArray = false ; public DefaultEntityHandler ( StringPool stringPool , XMLErrorReporter errorReporter ) { fStringPool = stringPool ; fErrorReporter = errorReporter ; fReaderFactory = new DefaultReaderFactory ( ) ; fEntityPool = new EntityPool ( fStringPool , fErrorReporter , true ) ; } public void setEventHandler ( EventHandler eventHandler ) { fEventHandler = eventHandler ; } public void setCharDataHandler ( XMLEntityHandler . CharDataHandler charDataHandler ) { fCharDataHandler = charDataHandler ; } public XMLEntityHandler . CharDataHandler getCharDataHandler ( ) { return fCharDataHandler ; } public void setSendCharDataAsCharArray ( boolean flag ) { fSendCharDataAsCharArray = flag ; fReaderFactory . setSendCharDataAsCharArray ( fSendCharDataAsCharArray ) ; } public void setReaderFactory ( XMLEntityReaderFactory readerFactory ) { fReaderFactory = readerFactory ; fReaderFactory . setSendCharDataAsCharArray ( fSendCharDataAsCharArray ) ; } public void reset ( StringPool stringPool ) { fStringPool = stringPool ; fEntityPool . reset ( fStringPool ) ; fParameterEntityPool = null ; fReaderStack . removeAllElements ( ) ; fEntityStackDepth = 0 ; fReader = null ; fSource = null ; fEntityName = - 1 ; fEntityType = - 1 ; fEntityContext = - 1 ; fPublicId = null ; fSystemId = null ; fReaderId = - 1 ; fReaderDepth = - 1 ; fNextReaderId = 0 ; } public void setAllowJavaEncodings ( boolean flag ) { fReaderFactory . setAllowJavaEncodingName ( flag ) ; } public boolean getAllowJavaEncodings ( ) { return fReaderFactory . getAllowJavaEncodingName ( ) ; } public int addInternalPEDecl ( int name , int value , boolean isExternal ) throws Exception { if ( fParameterEntityPool == null ) fParameterEntityPool = new EntityPool ( fStringPool , fErrorReporter , false ) ; int entityHandle = fParameterEntityPool . addEntityDecl ( name , value , - 1 , - 1 , - 1 , - 1 , isExternal ) ; return entityHandle ; } public int addExternalPEDecl ( int name , int publicId , int systemId , boolean isExternal ) throws Exception { if ( fParameterEntityPool == null ) fParameterEntityPool = new EntityPool ( fStringPool , fErrorReporter , false ) ; int entityHandle = fParameterEntityPool . addEntityDecl ( name , - 1 , publicId , systemId , fStringPool . addSymbol ( fSystemId ) , - 1 , isExternal ) ; return entityHandle ; } public int addInternalEntityDecl ( int name , int value , boolean isExternal ) throws Exception { int entityHandle = fEntityPool . addEntityDecl ( name , value , - 1 , - 1 , - 1 , - 1 , isExternal ) ; return entityHandle ; } public int addExternalEntityDecl ( int name , int publicId , int systemId , boolean isExternal ) throws Exception { int entityHandle = fEntityPool . addEntityDecl ( name , - 1 , publicId , systemId , fStringPool . addSymbol ( fSystemId ) , - 1 , isExternal ) ; return entityHandle ; } public int addUnparsedEntityDecl ( int name , int publicId , int systemId , int notationName , boolean isExternal ) throws Exception { int entityHandle = fEntityPool . addEntityDecl ( name , - 1 , publicId , systemId , fStringPool . addSymbol ( fSystemId ) , notationName , isExternal ) ; if ( ! fEntityPool . isNotationDeclared ( notationName ) ) { Object [ ] args = { fStringPool . toString ( name ) , fStringPool . toString ( notationName ) } ; fEntityPool . addRequiredNotation ( notationName , fErrorReporter . getLocator ( ) , XMLMessages . MSG_NOTATION_NOT_DECLARED_FOR_UNPARSED_ENTITYDECL , XMLMessages . VC_NOTATION_DECLARED , args ) ; } return entityHandle ; } public int addNotationDecl ( int notationName , int publicId , int systemId , boolean isExternal ) throws Exception { int notationHandle = fEntityPool . addNotationDecl ( notationName , publicId , systemId , fStringPool . addSymbol ( fSystemId ) , isExternal ) ; return notationHandle ; } public boolean isUnparsedEntity ( int entityName ) { int entityHandle = fEntityPool . lookupEntity ( entityName ) ; return ( entityHandle != - 1 && fEntityPool . isUnparsedEntity ( entityHandle ) ) ; } public boolean isNotationDeclared ( int notationName ) { return fEntityPool . isNotationDeclared ( notationName ) ; } public void addRequiredNotation ( int notationName , Locator locator , int majorCode , int minorCode , Object [ ] args ) { fEntityPool . addRequiredNotation ( notationName , locator , majorCode , minorCode , args ) ; } public void checkRequiredNotations ( ) throws Exception { fEntityPool . checkRequiredNotations ( ) ; } protected int lookupEntity ( int entityNameIndex ) { int entityIndex = fEntityPool . lookupEntity ( entityNameIndex ) ; return entityIndex ; } private void reportRecoverableXMLError ( int majorCode , int minorCode , int stringIndex1 ) throws Exception { Object [ ] args = { fStringPool . toString ( stringIndex1 ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } public boolean externalReferenceInContent ( int entityHandle ) throws Exception { boolean external = fEntityPool . isExternalEntity ( entityHandle ) ; if ( fEventHandler . externalEntityStandaloneCheck ( ) ) { if ( external ) { reportRecoverableXMLError ( XMLMessages . MSG_EXTERNAL_ENTITY_NOT_PERMITTED , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fEntityName ) ; } else if ( fEntityPool . getEntityDeclIsExternal ( entityHandle ) ) { reportRecoverableXMLError ( XMLMessages . MSG_REFERENCE_TO_EXTERNALLY_DECLARED_ENTITY_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fEntityName ) ; } } return external ; } protected int valueOfReferenceInAttValue ( int entityHandle ) throws Exception { if ( fEventHandler . externalEntityStandaloneCheck ( ) && fEntityPool . getEntityDeclIsExternal ( entityHandle ) ) { reportRecoverableXMLError ( XMLMessages . MSG_REFERENCE_TO_EXTERNALLY_DECLARED_ENTITY_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fEntityName ) ; } int entityValue = fEntityPool . getEntityValue ( entityHandle ) ; return entityValue ; } protected boolean isExternalEntity ( int entityHandle ) { boolean external = fEntityPool . isExternalEntity ( entityHandle ) ; return external ; } protected int getEntityValue ( int entityHandle ) { int value = fEntityPool . getEntityValue ( entityHandle ) ; return value ; } protected String getPublicIdOfEntity ( int entityHandle ) { int publicId = fEntityPool . getPublicId ( entityHandle ) ; return fStringPool . toString ( publicId ) ; } protected String getSystemIdOfEntity ( int entityHandle ) { int systemId = fEntityPool . getSystemId ( entityHandle ) ; return fStringPool . toString ( systemId ) ; } protected int lookupParameterEntity ( int peName ) throws Exception { int entityHandle = - 1 ; if ( fParameterEntityPool != null ) entityHandle = fParameterEntityPool . lookupEntity ( peName ) ; return entityHandle ; } protected boolean isExternalParameterEntity ( int peIndex ) { boolean external = fParameterEntityPool . isExternalEntity ( peIndex ) ; return external ; } protected int getParameterEntityValue ( int peIndex ) { int value = fParameterEntityPool . getEntityValue ( peIndex ) ; return value ; } protected String getPublicIdOfParameterEntity ( int peIndex ) { int publicId = fParameterEntityPool . getPublicId ( peIndex ) ; return fStringPool . toString ( publicId ) ; } protected String getSystemIdOfParameterEntity ( int peIndex ) { int systemId = fParameterEntityPool . getSystemId ( peIndex ) ; return fStringPool . toString ( systemId ) ; } public XMLEntityHandler . EntityReader getEntityReader ( ) { return fReader ; } public void addRecognizer ( XMLDeclRecognizer recognizer ) { fReaderFactory . addRecognizer ( recognizer ) ; } public void setEntityResolver ( EntityResolver resolver ) { fResolver = resolver ; } public EntityResolver getEntityResolver ( ) { return fResolver ; } public String expandSystemId ( String systemId ) { return expandSystemId ( systemId , fSystemId ) ; } private String expandSystemId ( String systemId , String currentSystemId ) { String id = systemId ; if ( id == null || id . length ( ) == 0 ) { return systemId ; } try { URI uri = new URI ( id ) ; if ( uri != null ) { return systemId ; } } catch ( URI . MalformedURIException e ) { } id = fixURI ( id ) ; URI base = null ; URI uri = null ; try { if ( currentSystemId == null ) { String dir ; try { dir = fixURI ( System . getProperty ( "user.dir" ) ) ; } catch ( SecurityException se ) { dir = "" ; } if ( ! dir . endsWith ( "/" ) ) { dir = dir + "/" ; } base = new URI ( "file" , "" , dir , null , null ) ; } else { base = new URI ( currentSystemId ) ; } uri = new URI ( base , id ) ; } catch ( Exception e ) { } if ( uri == null ) { return systemId ; } return uri . toString ( ) ; } private static String fixURI ( String str ) { str = str . replace ( java . io . File . separatorChar , '/' ) ; if ( str . length ( ) >= 2 ) { char ch1 = str . charAt ( 1 ) ; if ( ch1 == ':' ) { char ch0 = Character . toUpperCase ( str . charAt ( 0 ) ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { str = "/" + str ; } } } return str ; } public boolean startReadingFromDocument ( InputSource source ) throws Exception { pushEntity ( false , - 2 ) ; fSystemId = null ; pushNullReader ( ) ; fEntityName = - 2 ; fEntityType = ENTITYTYPE_DOCUMENT ; fEntityContext = ENTITYREF_DOCUMENT ; fReaderDepth = 0 ; fReaderId = fNextReaderId ++ ; fPublicId = source . getPublicId ( ) ; fSystemId = source . getSystemId ( ) ; fEventHandler . startEntityReference ( fEntityName , fEntityType , fEntityContext ) ; fSystemId = expandSystemId ( fSystemId , null ) ; fSource = source ; boolean xmlDecl = true ; try { fReader = fReaderFactory . createReader ( this , fErrorReporter , source , fSystemId , xmlDecl , fStringPool ) ; } catch ( MalformedURLException mu ) { String errorSystemId = fSystemId ; fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; Object [ ] args = { errorSystemId } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . IO0 , 0 , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } catch ( FileNotFoundException fnf ) { String errorSystemId = fSystemId ; fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; Object [ ] args = { errorSystemId } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . IO0 , 0 , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } catch ( UnsupportedEncodingException uee ) { fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; String encoding = uee . getMessage ( ) ; if ( encoding == null ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODING_REQUIRED , XMLMessages . P81_REQUIRED , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } else if ( ! XMLCharacterProperties . validEncName ( encoding ) ) { Object [ ] args = { encoding } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODINGDECL_INVALID , XMLMessages . P81_INVALID_VALUE , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } else { Object [ ] args = { encoding } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODING_NOT_SUPPORTED , XMLMessages . P81_NOT_SUPPORTED , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } } fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; return fReader != null ; } public void startReadingFromExternalSubset ( String publicId , String systemId , int readerDepth ) throws Exception { pushEntity ( true , - 1 ) ; pushReader ( ) ; pushNullReader ( ) ; fEntityName = - 1 ; fEntityType = ENTITYTYPE_EXTERNAL_SUBSET ; fEntityContext = ENTITYREF_EXTERNAL_SUBSET ; fReaderDepth = readerDepth ; fReaderId = fNextReaderId ++ ; fPublicId = publicId ; fSystemId = systemId ; startReadingFromExternalEntity ( false , - 1 ) ; } public void stopReadingFromExternalSubset ( ) throws Exception { if ( ! ( fReader instanceof NullReader ) ) throw new RuntimeException ( "FWK004 cannot happen 18" + "\n18" ) ; popReader ( ) ; fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; } public boolean startReadingFromEntity ( int entityName , int readerDepth , int context ) throws Exception { if ( context > XMLEntityHandler . ENTITYREF_IN_CONTENT ) return startReadingFromParameterEntity ( entityName , readerDepth , context ) ; int entityHandle = lookupEntity ( entityName ) ; if ( entityHandle < 0 ) { int minorCode = XMLMessages . VC_ENTITY_DECLARED ; int errorType = XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ; if ( fEntityContext == ENTITYREF_DOCUMENT || fEntityContext == ENTITYREF_IN_ATTVALUE ) { minorCode = XMLMessages . WFC_ENTITY_DECLARED ; errorType = XMLErrorReporter . ERRORTYPE_FATAL_ERROR ; } else if ( ! fEventHandler . getValidating ( ) ) { return false ; } Object [ ] args = { fStringPool . toString ( entityName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENTITY_NOT_DECLARED , minorCode , args , errorType ) ; return false ; } if ( context == ENTITYREF_IN_CONTENT ) { if ( fEntityPool . isUnparsedEntity ( entityHandle ) ) { Object [ ] args = { fStringPool . toString ( entityName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_REFERENCE_TO_UNPARSED_ENTITY , XMLMessages . WFC_PARSED_ENTITY , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; return false ; } } else { if ( isExternalEntity ( entityHandle ) ) { Object [ ] args = { fStringPool . toString ( entityName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_REFERENCE_TO_EXTERNAL_ENTITY , XMLMessages . WFC_NO_EXTERNAL_ENTITY_REFERENCES , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; return false ; } } if ( ! pushEntity ( false , entityName ) ) { Object [ ] args = { fStringPool . toString ( entityName ) , entityReferencePath ( false , entityName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_RECURSIVE_REFERENCE , XMLMessages . WFC_NO_RECURSION , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; return false ; } pushReader ( ) ; fEntityName = entityName ; fEntityContext = context ; fReaderDepth = readerDepth ; fReaderId = fNextReaderId ++ ; if ( context != ENTITYREF_IN_CONTENT || ! externalReferenceInContent ( entityHandle ) ) { fEntityType = ENTITYTYPE_INTERNAL ; fPublicId = null ; fSystemId = fSystemId ; int value = - 1 ; if ( context == ENTITYREF_IN_CONTENT || context == ENTITYREF_IN_DEFAULTATTVALUE ) value = getEntityValue ( entityHandle ) ; else value = valueOfReferenceInAttValue ( entityHandle ) ; startReadingFromInternalEntity ( value , false ) ; return false ; } fEntityType = ENTITYTYPE_EXTERNAL ; fPublicId = getPublicIdOfEntity ( entityHandle ) ; fSystemId = getSystemIdOfEntity ( entityHandle ) ; return startReadingFromExternalEntity ( true , entityHandle ) ; } private boolean startReadingFromParameterEntity ( int peName , int readerDepth , int context ) throws Exception { int entityHandle = lookupParameterEntity ( peName ) ; if ( entityHandle == - 1 ) { if ( fEventHandler . getValidating ( ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ENTITY_NOT_DECLARED , XMLMessages . VC_ENTITY_DECLARED , peName ) ; } return false ; } if ( ! pushEntity ( true , peName ) ) { Object [ ] args = { fStringPool . toString ( peName ) , entityReferencePath ( true , peName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_RECURSIVE_PEREFERENCE , XMLMessages . WFC_NO_RECURSION , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; return false ; } pushReader ( ) ; fEntityName = peName ; fEntityContext = context ; fReaderDepth = readerDepth ; fReaderId = fNextReaderId ++ ; if ( ! isExternalParameterEntity ( entityHandle ) ) { fEntityType = ENTITYTYPE_INTERNAL_PE ; fPublicId = null ; fSystemId = fSystemId ; int value = getParameterEntityValue ( entityHandle ) ; startReadingFromInternalEntity ( value , fEntityContext == ENTITYREF_IN_ENTITYVALUE ? false : true ) ; return false ; } fEntityType = ENTITYTYPE_EXTERNAL_PE ; fPublicId = getPublicIdOfParameterEntity ( entityHandle ) ; fSystemId = getSystemIdOfParameterEntity ( entityHandle ) ; return startReadingFromExternalEntity ( true , entityHandle ) ; } private void startReadingFromInternalEntity ( int value , boolean addSpaces ) throws Exception { if ( fEntityContext == ENTITYREF_IN_ENTITYVALUE ) { } fSource = null ; fEventHandler . startEntityReference ( fEntityName , fEntityType , fEntityContext ) ; fReader = fReaderFactory . createStringReader ( this , fErrorReporter , fSendCharDataAsCharArray , getLineNumber ( ) , getColumnNumber ( ) , value , fStringPool , addSpaces ) ; fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; } private boolean startReadingFromExternalEntity ( boolean checkForTextDecl , int entityHandle ) throws Exception { if ( fEntityContext == ENTITYREF_IN_ENTITYVALUE ) { } if ( fEntityContext == ENTITYREF_IN_DTD_WITHIN_MARKUP ) { } fEventHandler . startEntityReference ( fEntityName , fEntityType , fEntityContext ) ; String baseSystemId = null ; if ( entityHandle != - 1 ) { if ( fEntityType == ENTITYTYPE_EXTERNAL_PE ) baseSystemId = fParameterEntityPool . getBaseSystemId ( entityHandle ) ; else baseSystemId = fEntityPool . getBaseSystemId ( entityHandle ) ; } if ( baseSystemId == null ) { ReaderState rs = ( ReaderState ) fReaderStack . peek ( ) ; baseSystemId = rs . systemId ; } fSystemId = expandSystemId ( fSystemId , baseSystemId ) ; fSource = fResolver == null ? null : fResolver . resolveEntity ( fPublicId , fSystemId ) ; if ( fSource == null ) { fSource = new InputSource ( fSystemId ) ; if ( fPublicId != null ) fSource . setPublicId ( fPublicId ) ; } else { if ( fSource . getSystemId ( ) != null ) { fSystemId = expandSystemId ( fSource . getSystemId ( ) , baseSystemId ) ; } if ( fSource . getPublicId ( ) != null ) { fPublicId = fSource . getPublicId ( ) ; } } boolean textDecl = false ; try { fReader = fReaderFactory . createReader ( this , fErrorReporter , fSource , fSystemId , textDecl , fStringPool ) ; } catch ( MalformedURLException mu ) { String errorSystemId = fSystemId ; fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; Object [ ] args = { errorSystemId } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . IO0 , 0 , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } catch ( FileNotFoundException fnf ) { String errorSystemId = fSystemId ; fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; Object [ ] args = { errorSystemId } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . IO0 , 0 , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } catch ( UnsupportedEncodingException uee ) { fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; String encoding = uee . getMessage ( ) ; if ( encoding == null ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODING_REQUIRED , XMLMessages . P81_REQUIRED , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } else if ( ! XMLCharacterProperties . validEncName ( encoding ) ) { Object [ ] args = { encoding } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODINGDECL_INVALID , XMLMessages . P81_INVALID_VALUE , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } else { Object [ ] args = { encoding } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODING_NOT_SUPPORTED , XMLMessages . P81_NOT_SUPPORTED , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } } if ( fReader == null || ! checkForTextDecl ) { fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; return false ; } int readerId = fReaderId ; fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; boolean parseTextDecl = fReader . lookingAtChar ( '<' , false ) ; if ( readerId != fReaderId ) parseTextDecl = false ; return parseTextDecl ; } private void pushNullReader ( ) { ReaderState rs = fReaderStateFreeList ; if ( rs == null ) rs = new ReaderState ( ) ; else fReaderStateFreeList = rs . nextReaderState ; if ( fNullReader == null ) fNullReader = new NullReader ( ) ; rs . reader = fNullReader ; rs . source = null ; rs . entityName = - 1 ; rs . entityType = - 1 ; rs . entityContext = - 1 ; rs . publicId = "Null Entity" ; rs . systemId = fSystemId ; rs . readerId = fNextReaderId ++ ; rs . depth = - 1 ; rs . nextReaderState = null ; fReaderStack . push ( rs ) ; } private void pushReader ( ) { ReaderState rs = fReaderStateFreeList ; if ( rs == null ) rs = new ReaderState ( ) ; else fReaderStateFreeList = rs . nextReaderState ; rs . reader = fReader ; rs . source = fSource ; rs . entityName = fEntityName ; rs . entityType = fEntityType ; rs . entityContext = fEntityContext ; rs . publicId = fPublicId ; rs . systemId = fSystemId ; rs . readerId = fReaderId ; rs . depth = fReaderDepth ; rs . nextReaderState = null ; fReaderStack . push ( rs ) ; } private void popReader ( ) { if ( fReaderStack . empty ( ) ) throw new RuntimeException ( "FWK004 cannot happen 19" + "\n19" ) ; ReaderState rs = ( ReaderState ) fReaderStack . pop ( ) ; fReader = rs . reader ; fSource = rs . source ; fEntityName = rs . entityName ; fEntityType = rs . entityType ; fEntityContext = rs . entityContext ; fPublicId = rs . publicId ; fSystemId = rs . systemId ; fReaderId = rs . readerId ; fReaderDepth = rs . depth ; rs . nextReaderState = fReaderStateFreeList ; fReaderStateFreeList = rs ; } public boolean startEntityDecl ( boolean isPE , int entityName ) throws Exception { if ( ! pushEntity ( isPE , entityName ) ) { int majorCode = isPE ? XMLMessages . MSG_RECURSIVE_PEREFERENCE : XMLMessages . MSG_RECURSIVE_REFERENCE ; Object [ ] args = { fStringPool . toString ( entityName ) , entityReferencePath ( isPE , entityName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , XMLMessages . WFC_NO_RECURSION , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; return false ; } return true ; } public void endEntityDecl ( ) throws Exception { popEntity ( ) ; } private boolean pushEntity ( boolean isPE , int entityName ) throws Exception { if ( entityName >= 0 ) { for ( int i = 0 ; i < fEntityStackDepth ; i ++ ) { if ( fEntityNameStack [ i ] == entityName && fEntityTypeStack [ i ] == ( isPE ? 1 : 0 ) ) { return false ; } } } if ( fEntityTypeStack == null ) { fEntityTypeStack = new byte [ 8 ] ; fEntityNameStack = new int [ 8 ] ; } else if ( fEntityStackDepth == fEntityTypeStack . length ) { byte [ ] newTypeStack = new byte [ fEntityStackDepth * 2 ] ; System . arraycopy ( fEntityTypeStack , 0 , newTypeStack , 0 , fEntityStackDepth ) ; fEntityTypeStack = newTypeStack ; int [ ] newNameStack = new int [ fEntityStackDepth * 2 ] ; System . arraycopy ( fEntityNameStack , 0 , newNameStack , 0 , fEntityStackDepth ) ; fEntityNameStack = newNameStack ; } fEntityTypeStack [ fEntityStackDepth ] = ( byte ) ( isPE ? 1 : 0 ) ; fEntityNameStack [ fEntityStackDepth ] = entityName ; fEntityStackDepth ++ ; return true ; } private String entityReferencePath ( boolean isPE , int entityName ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( "(top-level)" ) ; for ( int i = 0 ; i < fEntityStackDepth ; i ++ ) { if ( fEntityNameStack [ i ] >= 0 ) { sb . append ( '-' ) ; sb . append ( fEntityTypeStack [ i ] == 1 ? '%' : '&' ) ; sb . append ( fStringPool . toString ( fEntityNameStack [ i ] ) ) ; sb . append ( ';' ) ; } } sb . append ( '-' ) ; sb . append ( isPE ? '%' : '&' ) ; sb . append ( fStringPool . toString ( entityName ) ) ; sb . append ( ';' ) ; return sb . toString ( ) ; } private void popEntity ( ) throws Exception { fEntityStackDepth -- ; } public int getReaderId ( ) { return fReaderId ; } public void setReaderDepth ( int depth ) { fReaderDepth = depth ; } public int getReaderDepth ( ) { return fReaderDepth ; } public String getPublicId ( ) { return fPublicId ; } public String getSystemId ( ) { return fSystemId ; } public int getLineNumber ( ) { return fReader == null ? 0 : fReader . getLineNumber ( ) ; } public int getColumnNumber ( ) { return fReader == null ? 0 : fReader . getColumnNumber ( ) ; } public XMLEntityHandler . EntityReader changeReaders ( ) throws Exception { fEventHandler . sendEndOfInputNotifications ( fEntityName , fReaderStack . size ( ) > 1 ) ; fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; popEntity ( ) ; return fReader ; } private final class NullReader implements XMLEntityHandler . EntityReader { public NullReader ( ) { } public int currentOffset ( ) { return - 1 ; } public int getLineNumber ( ) { return - 1 ; } public int getColumnNumber ( ) { return - 1 ; } public void setInCDSect ( boolean inCDSect ) { } public boolean getInCDSect ( ) { return false ; } public void append ( XMLEntityHandler . CharBuffer charBuffer , int offset , int length ) { } public int addString ( int offset , int length ) { return - 1 ; } public int addSymbol ( int offset , int length ) { return - 1 ; } public boolean lookingAtChar ( char ch , boolean skipPastChar ) { return false ; } public boolean lookingAtValidChar ( boolean skipPastChar ) { return false ; } public boolean lookingAtSpace ( boolean skipPastChar ) { return false ; } public void skipToChar ( char ch ) { } public void skipPastSpaces ( ) { } public void skipPastName ( char fastcheck ) { } public void skipPastNmtoken ( char fastcheck ) { } public boolean skippedString ( char [ ] s ) { return false ; } public int scanInvalidChar ( ) { return - 1 ; } public int scanCharRef ( boolean hex ) { return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; } public int scanStringLiteral ( ) { return XMLEntityHandler . STRINGLIT_RESULT_QUOTE_REQUIRED ; } public int scanAttValue ( char qchar , boolean asSymbol ) { return XMLEntityHandler . ATTVALUE_RESULT_INVALID_CHAR ; } public int scanEntityValue ( int qchar , boolean createString ) { return XMLEntityHandler . ENTITYVALUE_RESULT_INVALID_CHAR ; } public boolean scanExpectedName ( char fastcheck , StringPool . CharArrayRange expectedName ) { return false ; } public void scanQName ( char fastcheck , QName qname ) { qname . clear ( ) ; } public int scanName ( char fastcheck ) { return - 1 ; } public int scanContent ( QName element ) throws Exception { return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } static final int CHUNK_SHIFT = 5 ; static final int CHUNK_SIZE = ( 1 << CHUNK_SHIFT ) ; static final int CHUNK_MASK = CHUNK_SIZE - 1 ; static final int INITIAL_CHUNK_COUNT = ( 1 << ( 10 - CHUNK_SHIFT ) ) ; public final class EntityPool { private StringPool fStringPool = null ; private XMLErrorReporter fErrorReporter = null ; private int fEntityCount = 0 ; private int [ ] [ ] fName = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fValue = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fPublicId = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fSystemId = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fBaseSystemId = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fNotationName = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private byte [ ] [ ] fDeclIsExternal = new byte [ INITIAL_CHUNK_COUNT ] [ ] ; private int fNotationListHead = - 1 ; private boolean fCreateStandardEntities = false ; private Vector fRequiredNotations = null ; public EntityPool ( StringPool stringPool , XMLErrorReporter errorReporter , boolean createStandardEntities ) { fStringPool = stringPool ; fErrorReporter = errorReporter ; fCreateStandardEntities = createStandardEntities ; if ( fCreateStandardEntities ) { createInternalEntity ( "lt" , "&#60;" ) ; createInternalEntity ( "gt" , ">" ) ; createInternalEntity ( "amp" , "&#38;" ) ; createInternalEntity ( "apos" , "\'" ) ; createInternalEntity ( "quot" , "\"" ) ; } } public void reset ( StringPool stringPool ) { fStringPool = stringPool ; fEntityCount = 0 ; fNotationListHead = - 1 ; if ( fRequiredNotations != null ) fRequiredNotations . removeAllElements ( ) ; if ( fCreateStandardEntities ) { createInternalEntity ( "lt" , "&#60;" ) ; createInternalEntity ( "gt" , ">" ) ; createInternalEntity ( "amp" , "&#38;" ) ; createInternalEntity ( "apos" , "\'" ) ; createInternalEntity ( "quot" , "\"" ) ; } } private void createInternalEntity ( String name , String value ) { int chunk = fEntityCount > > CHUNK_SHIFT ; int index = fEntityCount & CHUNK_MASK ; ensureCapacity ( chunk ) ; fName [ chunk ] [ index ] = fStringPool . addSymbol ( name ) ; fValue [ chunk ] [ index ] = fStringPool . addString ( value ) ; fPublicId [ chunk ] [ index ] = - 1 ; fSystemId [ chunk ] [ index ] = - 1 ; fBaseSystemId [ chunk ] [ index ] = - 1 ; fNotationName [ chunk ] [ index ] = - 1 ; fEntityCount ++ ; } private boolean ensureCapacity ( int chunk ) { try { return fName [ chunk ] [ 0 ] == 0 ; } catch ( ArrayIndexOutOfBoundsException ex ) { int [ ] [ ] newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fName , 0 , newIntArray , 0 , chunk ) ; fName = newIntArray ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fValue , 0 , newIntArray , 0 , chunk ) ; fValue = newIntArray ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fPublicId , 0 , newIntArray , 0 , chunk ) ; fPublicId = newIntArray ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fSystemId , 0 , newIntArray , 0 , chunk ) ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fBaseSystemId , 0 , newIntArray , 0 , chunk ) ; fBaseSystemId = newIntArray ; fSystemId = newIntArray ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fNotationName , 0 , newIntArray , 0 , chunk ) ; fNotationName = newIntArray ; byte [ ] [ ] newByteArray = new byte [ chunk * 2 ] [ ] ; System . arraycopy ( fDeclIsExternal , 0 , newByteArray , 0 , chunk ) ; fDeclIsExternal = newByteArray ; } catch ( NullPointerException ex ) { } fName [ chunk ] = new int [ CHUNK_SIZE ] ; fValue [ chunk ] = new int [ CHUNK_SIZE ] ; fPublicId [ chunk ] = new int [ CHUNK_SIZE ] ; fSystemId [ chunk ] = new int [ CHUNK_SIZE ] ; fBaseSystemId [ chunk ] = new int [ CHUNK_SIZE ] ; fNotationName [ chunk ] = new int [ CHUNK_SIZE ] ; fDeclIsExternal [ chunk ] = new byte [ CHUNK_SIZE ] ; return true ; } public int addEntityDecl ( int name , int value , int publicId , int systemId , int baseSystemId , int notationName , boolean isExternal ) { int chunk = fEntityCount > > CHUNK_SHIFT ; int index = fEntityCount & CHUNK_MASK ; ensureCapacity ( chunk ) ; fName [ chunk ] [ index ] = name ; fValue [ chunk ] [ index ] = value ; fPublicId [ chunk ] [ index ] = publicId ; fSystemId [ chunk ] [ index ] = systemId ; fBaseSystemId [ chunk ] [ index ] = baseSystemId ; fNotationName [ chunk ] [ index ] = notationName ; fDeclIsExternal [ chunk ] [ index ] = isExternal ? ( byte ) 0x80 : ( byte ) 0 ; int entityIndex = fEntityCount ++ ; return entityIndex ; } public int addNotationDecl ( int notationName , int publicId , int systemId , int baseSystemId , boolean isExternal ) { int nIndex = fNotationListHead ; while ( nIndex != - 1 ) { int chunk = nIndex > > CHUNK_SHIFT ; int index = nIndex & CHUNK_MASK ; if ( fNotationName [ chunk ] [ index ] == notationName ) return - 1 ; nIndex = fValue [ chunk ] [ index ] ; } int chunk = fEntityCount > > CHUNK_SHIFT ; int index = fEntityCount & CHUNK_MASK ; ensureCapacity ( chunk ) ; fName [ chunk ] [ index ] = - 1 ; fValue [ chunk ] [ index ] = fNotationListHead ; fPublicId [ chunk ] [ index ] = publicId ; fSystemId [ chunk ] [ index ] = systemId ; fBaseSystemId [ chunk ] [ index ] = baseSystemId ; fNotationName [ chunk ] [ index ] = notationName ; fDeclIsExternal [ chunk ] [ index ] = isExternal ? ( byte ) 0x80 : ( byte ) 0 ; fNotationListHead = fEntityCount ++ ; return fNotationListHead ; } public int lookupEntity ( int nameIndex ) { if ( nameIndex == - 1 ) return - 1 ; int chunk = 0 ; int index = 0 ; for ( int entityIndex = 0 ; entityIndex < fEntityCount ; entityIndex ++ ) { if ( fName [ chunk ] [ index ] == nameIndex ) return entityIndex ; if ( ++ index == CHUNK_SIZE ) { chunk ++ ; index = 0 ; } } return - 1 ; } public boolean isExternalEntity ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return ( fValue [ chunk ] [ index ] == - 1 ) ; } public boolean isUnparsedEntity ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return ( fNotationName [ chunk ] [ index ] != - 1 ) ; } public boolean getEntityDeclIsExternal ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return ( fDeclIsExternal [ chunk ] [ index ] < 0 ) ; } public int getEntityName ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return fName [ chunk ] [ index ] ; } public int getEntityValue ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return fValue [ chunk ] [ index ] ; } public int getPublicId ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return fPublicId [ chunk ] [ index ] ; } public int getSystemId ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return fSystemId [ chunk ] [ index ] ; } public String getBaseSystemId ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; int baseIndex = fBaseSystemId [ chunk ] [ index ] ; if ( baseIndex == - 1 ) { return null ; } else { return fStringPool . toString ( baseIndex ) ; } } public boolean isNotationDeclared ( int nameIndex ) { int nIndex = fNotationListHead ; while ( nIndex != - 1 ) { int chunk = nIndex > > CHUNK_SHIFT ; int index = nIndex & CHUNK_MASK ; if ( fNotationName [ chunk ] [ index ] == nameIndex ) return true ; nIndex = fValue [ chunk ] [ index ] ; } return false ; } public boolean getNotationDeclIsExternal ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return ( fDeclIsExternal [ chunk ] [ index ] < 0 ) ; } public int getNotationName ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return fNotationName [ chunk ] [ index ] ; } class RequiredNotation { RequiredNotation ( int notationName , Locator locator , int majorCode , int minorCode , Object [ ] args ) { fNotationName = notationName ; fLocator = new LocatorImpl ( locator ) ; fMajorCode = majorCode ; fMinorCode = minorCode ; fArgs = args ; } int fNotationName ; LocatorImpl fLocator ; int fMajorCode ; int fMinorCode ; Object [ ] fArgs ; } ; public void addRequiredNotation ( int notationName , Locator locator , int majorCode , int minorCode , Object [ ] args ) { if ( fRequiredNotations == null ) fRequiredNotations = new Vector ( ) ; for ( int index = 0 ; index < fRequiredNotations . size ( ) ; index ++ ) { RequiredNotation rn = ( RequiredNotation ) fRequiredNotations . elementAt ( index ) ; if ( rn . fNotationName == notationName ) return ; } fRequiredNotations . addElement ( new RequiredNotation ( notationName , locator , majorCode , minorCode , args ) ) ; } public void checkRequiredNotations ( ) throws Exception { if ( fRequiredNotations == null ) return ; for ( int index = 0 ; index < fRequiredNotations . size ( ) ; index ++ ) { RequiredNotation rn = ( RequiredNotation ) fRequiredNotations . elementAt ( index ) ; if ( ! isNotationDeclared ( rn . fNotationName ) ) { fErrorReporter . reportError ( rn . fLocator , XMLMessages . XML_DOMAIN , rn . fMajorCode , rn . fMinorCode , rn . fArgs , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } } } } 	1	['62', '1', '0', '24', '130', '753', '10', '17', '39', '0.850197852', '2272', '0.862068966', '12', '0', '0.138248848', '0', '0', '35.17741935', '6', '1.3226', '1']
package org . w3c . dom ; public interface DOMImplementation { public boolean hasFeature ( String feature , String version ) ; public DocumentType createDocumentType ( String qualifiedName , String publicId , String systemId ) throws DOMException ; public Document createDocument ( String namespaceURI , String qualifiedName , DocumentType doctype ) throws DOMException ; } 	1	['3', '1', '0', '0', '3', '3', '0', '0', '3', '2', '3', '0', '0', '0', '0.777777778', '0', '0', '0', '1', '1', '2']
package org . apache . xerces . utils ; import java . lang . * ; public final class HexBin { static private final int BASELENGTH = 255 ; static private final int LOOKUPLENGTH = 16 ; static private byte [ ] hexNumberTable = new byte [ BASELENGTH ] ; static private byte [ ] lookUpHexAlphabet = new byte [ LOOKUPLENGTH ] ; static { for ( int i = 0 ; i < BASELENGTH ; i ++ ) { hexNumberTable [ i ] = - 1 ; } for ( int i = '9' ; i >= '0' ; i -- ) { hexNumberTable [ i ] = ( byte ) ( i - '0' ) ; } for ( int i = 'F' ; i >= 'A' ; i -- ) { hexNumberTable [ i ] = ( byte ) ( i - 'A' + 10 ) ; } for ( int i = 'f' ; i >= 'a' ; i -- ) { hexNumberTable [ i ] = ( byte ) ( i - 'a' + 10 ) ; } for ( int i = 0 ; i <= 25 ; i ++ ) lookUpHexAlphabet [ i ] = ( byte ) ( 'A' + i ) ; for ( int i = 0 ; i < 10 ; i ++ ) lookUpHexAlphabet [ i ] = ( byte ) ( '0' + i ) ; for ( int i = 10 ; i <= 15 ; i ++ ) lookUpHexAlphabet [ i ] = ( byte ) ( 'A' + i - 10 ) ; } static boolean isHex ( byte octect ) { return ( hexNumberTable [ octect ] != - 1 ) ; } static boolean isArrayByteHex ( byte [ ] arrayOctect ) { int length = arrayOctect . length ; if ( length == 0 ) return false ; for ( int i = 0 ; i < length ; i ++ ) { if ( HexBin . isHex ( arrayOctect [ i ] ) == false ) return false ; } return true ; } public static boolean isHex ( String isValidString ) { return ( isArrayByteHex ( isValidString . getBytes ( ) ) ) ; } static public byte [ ] encode ( byte [ ] binaryData ) { int lengthData = binaryData . length ; int lengthEncode = lengthData ; byte [ ] encodedData = new byte [ lengthData ] ; for ( int i = 0 ; i < lengthData ; i ++ ) { encodedData [ i ] = lookUpHexAlphabet [ binaryData [ i ] ] ; } return encodedData ; } static public byte [ ] decode ( byte [ ] binaryData ) { int lengthData = binaryData . length ; int lengthEncode = lengthData ; byte [ ] decodedData = new byte [ lengthData ] ; for ( int i = 0 ; i < lengthData ; i ++ ) { decodedData [ i ] = hexNumberTable [ binaryData [ i ] ] ; } return decodedData ; } } 	1	['7', '1', '0', '1', '9', '13', '1', '0', '4', '0.875', '208', '1', '0', '0', '0.25', '0', '0', '28.14285714', '4', '1.5714', '1']
package org . w3c . dom ; public interface EntityReference extends Node { } 	1	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '2']
package org . w3c . dom ; public interface Attr extends Node { public String getName ( ) ; public boolean getSpecified ( ) ; public String getValue ( ) ; public void setValue ( String value ) throws DOMException ; public Element getOwnerElement ( ) ; } 	1	['5', '1', '0', '0', '5', '10', '0', '0', '5', '2', '5', '0', '0', '0', '0.6', '0', '0', '0', '1', '1', '2']
package org . apache . xerces . dom ; import org . w3c . dom . DOMException ; import org . w3c . dom . DocumentFragment ; import org . w3c . dom . Document ; import org . w3c . dom . Node ; import org . w3c . dom . CharacterData ; import org . apache . xerces . dom . DOMExceptionImpl ; import org . apache . xerces . dom . DocumentImpl ; import org . w3c . dom . range . * ; import java . util . Vector ; public class RangeImpl implements Range { static final int START = 0 ; static final int AFTER = 1 ; static final int BEFORE = - 1 ; DocumentImpl fDocument ; Node fStartContainer ; Node fEndContainer ; int fStartOffset ; int fEndOffset ; boolean fIsCollapsed ; boolean fDetach = false ; Node fInsertNode = null ; Node fDeleteNode = null ; Node fSplitNode = null ; public RangeImpl ( DocumentImpl document ) { fDocument = document ; fStartContainer = document ; fEndContainer = document ; fStartOffset = 0 ; fEndOffset = 0 ; fDetach = false ; } public Node getStartContainer ( ) { return fStartContainer ; } public int getStartOffset ( ) { return fStartOffset ; } public Node getEndContainer ( ) { return fEndContainer ; } public int getEndOffset ( ) { return fEndOffset ; } public boolean getCollapsed ( ) { return ( fStartContainer == fEndContainer && fStartOffset == fEndOffset ) ; } public Node getCommonAncestorContainer ( ) { Vector startV = new Vector ( ) ; Node node ; for ( node = fStartContainer ; node != null ; node = node . getParentNode ( ) ) { startV . addElement ( node ) ; } Vector endV = new Vector ( ) ; for ( node = fEndContainer ; node != null ; node = node . getParentNode ( ) ) { endV . addElement ( node ) ; } int s = startV . size ( ) - 1 ; int e = endV . size ( ) - 1 ; Object result = null ; while ( s >= 0 && e >= 0 ) { if ( startV . elementAt ( s ) == endV . elementAt ( e ) ) { result = startV . elementAt ( s ) ; } else { break ; } -- s ; -- e ; } return ( Node ) result ; } public void setStart ( Node refNode , int offset ) throws RangeException , DOMException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } checkIndex ( refNode , offset ) ; fStartContainer = refNode ; fStartOffset = offset ; } public void setEnd ( Node refNode , int offset ) throws RangeException , DOMException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } checkIndex ( refNode , offset ) ; fEndContainer = refNode ; fEndOffset = offset ; } public void setStartBefore ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } fStartContainer = refNode . getParentNode ( ) ; int i = 0 ; for ( Node n = refNode ; n != null ; n = n . getPreviousSibling ( ) ) { i ++ ; } fStartOffset = i - 1 ; } public void setStartAfter ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } fStartContainer = refNode . getParentNode ( ) ; int i = 0 ; for ( Node n = refNode ; n != null ; n = n . getPreviousSibling ( ) ) { i ++ ; } fStartOffset = i ; } public void setEndBefore ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } fEndContainer = refNode . getParentNode ( ) ; int i = 0 ; for ( Node n = refNode ; n != null ; n = n . getPreviousSibling ( ) ) { i ++ ; } fEndOffset = i - 1 ; } public void setEndAfter ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } fEndContainer = refNode . getParentNode ( ) ; int i = 0 ; for ( Node n = refNode ; n != null ; n = n . getPreviousSibling ( ) ) { i ++ ; } fEndOffset = i ; } public void collapse ( boolean toStart ) { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( toStart ) { fEndContainer = fStartContainer ; fEndOffset = fStartOffset ; } else { fStartContainer = fEndContainer ; fStartOffset = fEndOffset ; } } public void selectNode ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } Node parent = refNode . getParentNode ( ) ; if ( parent != null ) { fStartContainer = parent ; fEndContainer = parent ; int i = 0 ; for ( Node n = refNode ; n != null ; n = n . getPreviousSibling ( ) ) { i ++ ; } fStartOffset = i - 1 ; fEndOffset = fStartOffset + 1 ; } } public void selectNodeContents ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } fStartContainer = refNode ; fEndContainer = refNode ; Node first = refNode . getFirstChild ( ) ; fStartOffset = 0 ; if ( first == null ) { fEndOffset = 0 ; } else { int i = 0 ; for ( Node n = first ; n != null ; n = n . getNextSibling ( ) ) { i ++ ; } fEndOffset = i ; } } public short compareBoundaryPoints ( short how , Range sourceRange ) throws DOMException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } Node endPointA ; Node endPointB ; int offsetA ; int offsetB ; if ( how == START_TO_START ) { endPointA = sourceRange . getStartContainer ( ) ; endPointB = fStartContainer ; offsetA = sourceRange . getStartOffset ( ) ; offsetB = fStartOffset ; } else if ( how == START_TO_END ) { endPointA = sourceRange . getStartContainer ( ) ; endPointB = fEndContainer ; offsetA = sourceRange . getStartOffset ( ) ; offsetB = fEndOffset ; } else if ( how == END_TO_START ) { endPointA = sourceRange . getEndContainer ( ) ; endPointB = fStartContainer ; offsetA = sourceRange . getEndOffset ( ) ; offsetB = fStartOffset ; } else { endPointA = sourceRange . getEndContainer ( ) ; endPointB = fEndContainer ; offsetA = sourceRange . getEndOffset ( ) ; offsetB = fEndOffset ; } if ( endPointA == endPointB ) { if ( offsetA < offsetB ) return - 1 ; if ( offsetA == offsetB ) return 0 ; return 1 ; } for ( Node node = endPointA . getFirstChild ( ) ; node != null ; node = node . getNextSibling ( ) ) { if ( isAncestorOf ( node , endPointB ) ) { int index = indexOf ( node , endPointA ) ; if ( offsetA < index ) return - 1 ; if ( offsetA == index ) return 0 ; return 1 ; } } for ( Node node = endPointB . getFirstChild ( ) ; node != null ; node = node . getNextSibling ( ) ) { if ( isAncestorOf ( node , endPointA ) ) { int index = indexOf ( node , endPointB ) ; if ( offsetB < index ) return - 1 ; if ( offsetB == index ) return 0 ; return 1 ; } } Node ancestor = getCommonAncestorContainer ( ) ; Node current = ancestor ; do { if ( current == endPointA ) return - 1 ; if ( current == endPointB ) return 1 ; current = nextNode ( current , true ) ; } while ( current != null && current != ancestor ) ; return - 2 ; } public void deleteContents ( ) throws DOMException { Node current = fStartContainer ; Node parent = null ; Node next ; boolean deleteCurrent = false ; Node root = getCommonAncestorContainer ( ) ; if ( fStartContainer == fEndContainer ) { if ( fStartOffset == fEndOffset ) { return ; } if ( fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { String value = fStartContainer . getNodeValue ( ) ; int realStart = fStartOffset ; int realEnd = fEndOffset ; if ( fStartOffset > value . length ( ) ) realStart = value . length ( ) - 1 ; if ( fEndOffset > value . length ( ) ) realEnd = value . length ( ) - 1 ; deleteData ( ( CharacterData ) fStartContainer , realStart , realEnd - realStart ) ; } else { current = fStartContainer . getFirstChild ( ) ; int i = 0 ; for ( i = 0 ; i < fStartOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } for ( i = 0 ; i < fEndOffset - fStartOffset && current != null ; i ++ ) { Node newCurrent = current . getNextSibling ( ) ; removeChild ( fStartContainer , current ) ; current = newCurrent ; } } collapse ( true ) ; return ; } Node partialNode = null ; int partialInt = START ; Node startRoot = null ; if ( current . getNodeType ( ) == Node . TEXT_NODE ) { deleteData ( ( CharacterData ) current , fStartOffset , current . getNodeValue ( ) . length ( ) - fStartOffset ) ; } else { current = current . getFirstChild ( ) ; for ( int i = 0 ; i < fStartOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } if ( current == null ) { current = fStartContainer ; } else if ( current != fStartContainer ) { deleteCurrent = true ; } } while ( current != root && current != null ) { parent = current . getParentNode ( ) ; if ( parent == root ) { if ( startRoot == null ) startRoot = current ; } else { if ( partialNode == null ) { partialNode = parent ; partialInt = AFTER ; } } if ( parent != root ) { next = current . getNextSibling ( ) ; Node nextnext ; while ( next != null ) { nextnext = next . getNextSibling ( ) ; removeChild ( parent , next ) ; next = nextnext ; } } if ( deleteCurrent ) { removeChild ( parent , current ) ; deleteCurrent = false ; } current = parent ; } Node endRoot = null ; current = fEndContainer ; if ( current . getNodeType ( ) == Node . TEXT_NODE ) { deleteData ( ( CharacterData ) current , 0 , fEndOffset ) ; } else { if ( fEndOffset == 0 ) { current = fEndContainer ; } else { current = current . getFirstChild ( ) ; for ( int i = 1 ; i < fEndOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } if ( current == null ) { current = fEndContainer . getLastChild ( ) ; } else if ( current != fStartContainer ) { deleteCurrent = true ; } } } while ( current != root && current != null ) { parent = current . getParentNode ( ) ; if ( parent == root ) { if ( endRoot == null ) endRoot = current ; } else { if ( partialNode == null ) { partialNode = parent ; partialInt = BEFORE ; } } if ( parent != root && parent != null ) { next = current . getPreviousSibling ( ) ; Node nextnext ; while ( next != null ) { nextnext = next . getPreviousSibling ( ) ; removeChild ( parent , next ) ; next = nextnext ; } } if ( deleteCurrent ) { removeChild ( parent , current ) ; deleteCurrent = false ; } current = parent ; } current = endRoot . getPreviousSibling ( ) ; Node prev = null ; while ( current != null && current != startRoot ) { prev = current . getPreviousSibling ( ) ; parent = current . getParentNode ( ) ; if ( parent != null ) { removeChild ( parent , current ) ; } current = prev ; } if ( partialNode == null ) { collapse ( true ) ; } else if ( partialInt == AFTER ) { setStartAfter ( partialNode ) ; setEndAfter ( partialNode ) ; } else if ( partialInt == BEFORE ) { setStartBefore ( partialNode ) ; setEndBefore ( partialNode ) ; } } public DocumentFragment extractContents ( ) throws DOMException { return traverseContents ( EXTRACT_CONTENTS ) ; } public DocumentFragment cloneContents ( ) throws DOMException { return traverseContents ( CLONE_CONTENTS ) ; } public void insertNode ( Node newNode ) throws DOMException , RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } int type = newNode . getNodeType ( ) ; if ( type == Node . ATTRIBUTE_NODE || type == Node . ENTITY_NODE || type == Node . NOTATION_NODE || type == Node . DOCUMENT_NODE || type == Node . DOCUMENT_FRAGMENT_NODE ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } if ( newNode == null ) return ; Node cloneCurrent ; Node current ; boolean MULTIPLE_MODE = false ; if ( fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( newNode . getNodeType ( ) != Node . TEXT_NODE ) { cloneCurrent = fStartContainer . cloneNode ( false ) ; ( ( TextImpl ) cloneCurrent ) . setNodeValueInternal ( ( cloneCurrent . getNodeValue ( ) ) . substring ( fStartOffset ) ) ; ( ( TextImpl ) fStartContainer ) . setNodeValueInternal ( ( fStartContainer . getNodeValue ( ) ) . substring ( 0 , fStartOffset ) ) ; Node next = fStartContainer . getNextSibling ( ) ; if ( next != null ) { Node parent = fStartContainer . getParentNode ( ) ; if ( parent != null ) { parent . insertBefore ( newNode , next ) ; parent . insertBefore ( cloneCurrent , next ) ; } } else { Node parent = fStartContainer . getParentNode ( ) ; if ( parent != null ) { parent . appendChild ( newNode ) ; parent . appendChild ( cloneCurrent ) ; } } signalSplitData ( fStartContainer , cloneCurrent , fStartOffset ) ; } else { String value = fStartContainer . getNodeValue ( ) ; String newValue = newNode . getNodeValue ( ) ; insertData ( ( CharacterData ) fStartContainer , fStartOffset , newValue ) ; } } else { current = fStartContainer . getFirstChild ( ) ; int i = 0 ; for ( i = 0 ; i < fStartOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } if ( current != null ) { fStartContainer . insertBefore ( newNode , current ) ; } else { fStartContainer . appendChild ( newNode ) ; } } } public void surroundContents ( Node newParent ) throws DOMException , RangeException { if ( newParent == null ) return ; if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } int type = newParent . getNodeType ( ) ; if ( type == Node . ATTRIBUTE_NODE || type == Node . ENTITY_NODE || type == Node . NOTATION_NODE || type == Node . DOCUMENT_TYPE_NODE || type == Node . DOCUMENT_NODE || type == Node . DOCUMENT_FRAGMENT_NODE ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } Node root = getCommonAncestorContainer ( ) ; Node realStart = fStartContainer ; Node realEnd = fEndContainer ; if ( fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { realStart = fStartContainer . getParentNode ( ) ; } if ( fEndContainer . getNodeType ( ) == Node . TEXT_NODE ) { realEnd = fEndContainer . getParentNode ( ) ; } if ( realStart != realEnd ) { throw new RangeExceptionImpl ( RangeException . BAD_BOUNDARYPOINTS_ERR , "DOM013 Bad boundary points" ) ; } DocumentFragment frag = extractContents ( ) ; insertNode ( newParent ) ; newParent . appendChild ( frag ) ; selectNode ( newParent ) ; } public Range cloneRange ( ) { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } Range range = fDocument . createRange ( ) ; range . setStart ( fStartContainer , fStartOffset ) ; range . setEnd ( fEndContainer , fEndOffset ) ; return range ; } public String toString ( ) { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } Node node = fStartContainer ; StringBuffer sb = new StringBuffer ( ) ; if ( fStartContainer . getNodeType ( ) == Node . TEXT_NODE || fStartContainer . getNodeType ( ) == Node . CDATA_SECTION_NODE ) { if ( fStartContainer == fEndContainer ) { sb . append ( fStartContainer . getNodeValue ( ) . substring ( fStartOffset , fEndOffset ) ) ; return sb . toString ( ) ; } else { sb . append ( fStartContainer . getNodeValue ( ) . substring ( fStartOffset ) ) ; } } while ( node != fEndContainer ) { node = nextNode ( node , true ) ; if ( node == null ) break ; if ( node . getNodeType ( ) == Node . TEXT_NODE || node . getNodeType ( ) == Node . CDATA_SECTION_NODE ) { sb . append ( node . getNodeValue ( ) ) ; } } if ( fEndContainer . getNodeType ( ) == Node . TEXT_NODE || fEndContainer . getNodeType ( ) == Node . CDATA_SECTION_NODE ) { sb . append ( fEndContainer . getNodeValue ( ) . substring ( 0 , fEndOffset ) ) ; } return sb . toString ( ) ; } public void detach ( ) { fDetach = true ; fDocument . removeRange ( this ) ; } void signalSplitData ( Node node , Node newNode , int offset ) { fSplitNode = node ; fDocument . splitData ( node , newNode , offset ) ; fSplitNode = null ; } void receiveSplitData ( Node node , Node newNode , int offset ) { if ( node == null || newNode == null ) return ; if ( fSplitNode == node ) return ; if ( node == fStartContainer && fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( fStartOffset > offset ) { fStartOffset = fStartOffset - offset ; fStartContainer = newNode ; } } if ( node == fEndContainer && fEndContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( fEndOffset > offset ) { fEndOffset = fEndOffset - offset ; fEndContainer = newNode ; } } } void deleteData ( CharacterData node , int offset , int count ) { fDeleteNode = node ; node . deleteData ( offset , count ) ; fDeleteNode = null ; } void receiveDeletedText ( Node node , int offset , int count ) { if ( node == null ) return ; if ( fDeleteNode == node ) return ; if ( node == fStartContainer && fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( fStartOffset > offset + count ) { fStartOffset = offset + ( fStartOffset - ( offset + count ) ) ; } else if ( fStartOffset > offset ) { fStartOffset = offset ; } } if ( node == fEndContainer && fEndContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( fEndOffset > offset + count ) { fEndOffset = offset + ( fEndOffset - ( offset + count ) ) ; } else if ( fEndOffset > offset ) { fEndOffset = offset ; } } } void insertData ( CharacterData node , int index , String insert ) { fInsertNode = node ; node . insertData ( index , insert ) ; fInsertNode = null ; } void receiveInsertedText ( Node node , int index , int len ) { if ( node == null ) return ; if ( fInsertNode == node ) return ; if ( node == fStartContainer && fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( index < fStartOffset ) { fStartOffset = fStartOffset + len ; } } if ( node == fEndContainer && fEndContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( index < fEndOffset ) { fEndOffset = fEndOffset + len ; } } } void receiveReplacedText ( Node node ) { if ( node == null ) return ; if ( node == fStartContainer && fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { fStartOffset = 0 ; } if ( node == fEndContainer && fEndContainer . getNodeType ( ) == Node . TEXT_NODE ) { fEndOffset = 0 ; } } public void insertedNodeFromDOM ( Node node ) { if ( node == null ) return ; if ( fInsertNode == node ) return ; Node parent = node . getParentNode ( ) ; if ( parent == fStartContainer ) { int index = indexOf ( node , fStartContainer ) ; if ( index < fStartOffset ) { fStartOffset ++ ; } } if ( parent == fEndContainer ) { int index = indexOf ( node , fEndContainer ) ; if ( index < fEndOffset ) { fEndOffset ++ ; } } } Node fRemoveChild = null ; Node removeChild ( Node parent , Node child ) { fRemoveChild = child ; Node n = parent . removeChild ( child ) ; fRemoveChild = null ; return n ; } void removeNode ( Node node ) { if ( node == null ) return ; if ( fRemoveChild == node ) return ; Node parent = node . getParentNode ( ) ; if ( parent == fStartContainer ) { int index = indexOf ( node , fStartContainer ) ; if ( index <= fStartOffset ) { fStartOffset -- ; } } if ( parent == fEndContainer ) { int index = indexOf ( node , fEndContainer ) ; if ( index < fEndOffset ) { fEndOffset -- ; } } if ( parent != fStartContainer && parent != fEndContainer ) { if ( isAncestorOf ( node , fStartContainer ) ) { fStartContainer = parent ; fStartOffset = indexOf ( node , parent ) - 1 ; } if ( isAncestorOf ( node , fEndContainer ) ) { fEndContainer = parent ; fEndOffset = indexOf ( node , parent ) - 1 ; } } } static final int EXTRACT_CONTENTS = 1 ; static final int CLONE_CONTENTS = 2 ; DocumentFragment traverseContents ( int traversalType ) throws DOMException { if ( fStartContainer == null || fEndContainer == null ) { return null ; } DocumentFragment frag = fDocument . createDocumentFragment ( ) ; Node current = fStartContainer ; Node cloneCurrent = null ; Node cloneParent = null ; Node partialNode = null ; int partialInt = START ; Vector d = new Vector ( ) ; if ( fStartContainer == fEndContainer ) { if ( fStartOffset == fEndOffset ) { return frag ; } if ( fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { cloneCurrent = fStartContainer . cloneNode ( false ) ; cloneCurrent . setNodeValue ( ( cloneCurrent . getNodeValue ( ) ) . substring ( fStartOffset , fEndOffset ) ) ; if ( traversalType == EXTRACT_CONTENTS ) { deleteData ( ( CharacterData ) current , fStartOffset , fEndOffset - fStartOffset ) ; } frag . appendChild ( cloneCurrent ) ; } else { current = current . getFirstChild ( ) ; int i = 0 ; for ( i = 0 ; i < fStartOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } int n = fEndOffset - fStartOffset ; for ( i = 0 ; i < n && current != null ; i ++ ) { Node newCurrent = current . getNextSibling ( ) ; if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; frag . appendChild ( cloneCurrent ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { frag . appendChild ( current ) ; } current = newCurrent ; } } return frag ; } Node root = getCommonAncestorContainer ( ) ; Node parent = null ; current = fStartContainer ; if ( current . getNodeType ( ) == Node . TEXT_NODE ) { cloneCurrent = current . cloneNode ( false ) ; cloneCurrent . setNodeValue ( ( cloneCurrent . getNodeValue ( ) ) . substring ( fStartOffset ) ) ; if ( traversalType == EXTRACT_CONTENTS ) { deleteData ( ( CharacterData ) current , fStartOffset , current . getNodeValue ( ) . length ( ) - fStartOffset ) ; } } else { current = current . getFirstChild ( ) ; for ( int i = 0 ; i < fStartOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } if ( current == null ) { current = fStartContainer ; } if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { cloneCurrent = current ; } } Node startRoot = null ; parent = null ; while ( current != root ) { parent = current . getParentNode ( ) ; if ( parent == root ) { cloneParent = frag ; startRoot = current ; } else { if ( parent == null ) System . out . println ( "parent==null: current=" + current ) ; cloneParent = parent . cloneNode ( false ) ; if ( partialNode == null && parent != root ) { partialNode = parent ; partialInt = AFTER ; } } Node next = null ; current = current . getNextSibling ( ) ; cloneParent . appendChild ( cloneCurrent ) ; while ( current != null ) { next = current . getNextSibling ( ) ; if ( current != null && parent != root ) { if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; cloneParent . appendChild ( cloneCurrent ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { cloneParent . appendChild ( current ) ; } } current = next ; } current = parent ; cloneCurrent = cloneParent ; } Node endRoot = null ; current = fEndContainer ; if ( current . getNodeType ( ) == Node . TEXT_NODE ) { cloneCurrent = current . cloneNode ( false ) ; cloneCurrent . setNodeValue ( ( cloneCurrent . getNodeValue ( ) ) . substring ( 0 , fEndOffset ) ) ; if ( traversalType == EXTRACT_CONTENTS ) { deleteData ( ( CharacterData ) current , 0 , fEndOffset ) ; } } else { if ( fEndOffset == 0 ) { current = fEndContainer ; } else { current = current . getFirstChild ( ) ; for ( int i = 1 ; i < fEndOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } if ( current == null ) { current = fEndContainer . getLastChild ( ) ; } } if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { cloneCurrent = current ; } } while ( current != root && current != null ) { parent = current . getParentNode ( ) ; if ( parent == root ) { cloneParent = frag ; endRoot = current ; } else { cloneParent = parent . cloneNode ( false ) ; if ( partialNode == null && parent != root ) { partialNode = parent ; partialInt = BEFORE ; } } Node holdCurrent = current ; current = parent . getFirstChild ( ) ; cloneParent . appendChild ( cloneCurrent ) ; Node next = null ; while ( current != holdCurrent && current != null ) { next = current . getNextSibling ( ) ; if ( current != null && parent != root ) { if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; cloneParent . appendChild ( cloneCurrent ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { cloneParent . appendChild ( current ) ; } } current = next ; } current = parent ; cloneCurrent = cloneParent ; } d . removeAllElements ( ) ; Node clonedPrevious = frag . getLastChild ( ) ; current = endRoot . getPreviousSibling ( ) ; Node prev = null ; while ( current != startRoot && current != null ) { prev = current . getPreviousSibling ( ) ; if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { cloneCurrent = current ; } frag . insertBefore ( cloneCurrent , clonedPrevious ) ; current = prev ; clonedPrevious = cloneCurrent ; } if ( traversalType == EXTRACT_CONTENTS ) { if ( partialNode == null ) { collapse ( true ) ; } else if ( partialInt == AFTER ) { setStartAfter ( partialNode ) ; setEndAfter ( partialNode ) ; } else if ( partialInt == BEFORE ) { setStartBefore ( partialNode ) ; setEndBefore ( partialNode ) ; } } return frag ; } void checkIndex ( Node refNode , int offset ) throws DOMException { if ( offset < 0 ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } int type = refNode . getNodeType ( ) ; if ( ( type == Node . TEXT_NODE || type == Node . CDATA_SECTION_NODE || type == Node . COMMENT_NODE || type == Node . PROCESSING_INSTRUCTION_NODE ) && offset > refNode . getNodeValue ( ) . length ( ) ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } Node child = refNode . getFirstChild ( ) ; int i = 1 ; for ( ; child != null ; i ++ ) { child = child . getNextSibling ( ) ; } if ( i > offset ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } } boolean isAncestorTypeValid ( Node node ) { for ( Node n = node ; n != null ; n = n . getParentNode ( ) ) { int type = n . getNodeType ( ) ; if ( type == Node . ATTRIBUTE_NODE || type == Node . ENTITY_NODE || type == Node . NOTATION_NODE || type == Node . DOCUMENT_TYPE_NODE ) return false ; } return true ; } Node nextNode ( Node node , boolean visitChildren ) { if ( node == null ) return null ; Node result ; if ( visitChildren ) { result = node . getFirstChild ( ) ; if ( result != null ) { return result ; } } result = node . getNextSibling ( ) ; if ( result != null ) { return result ; } Node parent = node . getParentNode ( ) ; while ( parent != null && parent != fDocument ) { result = parent . getNextSibling ( ) ; if ( result != null ) { return result ; } else { parent = parent . getParentNode ( ) ; } } return null ; } boolean isAncestorOf ( Node a , Node b ) { for ( Node node = b ; node != null ; node = node . getParentNode ( ) ) { if ( node == a ) return true ; } return false ; } int indexOf ( Node child , Node parent ) { Node node ; int i = 0 ; if ( child . getParentNode ( ) != parent ) return - 1 ; for ( node = child ; node != null ; node = node . getPreviousSibling ( ) ) { i ++ ; } return i ; } } 	1	['41', '1', '0', '4', '85', '0', '1', '4', '26', '0.796875', '2564', '0', '7', '0', '0.222222222', '0', '0', '61.14634146', '11', '3.0244', '2']
package org . apache . xerces . jaxp ; import java . io . File ; import java . io . InputStream ; import java . io . IOException ; import javax . xml . parsers . ParserConfigurationException ; import org . apache . xerces . parsers . SAXParser ; import org . xml . sax . HandlerBase ; import org . xml . sax . InputSource ; import org . xml . sax . Parser ; import org . xml . sax . SAXException ; public class SAXParserImpl extends javax . xml . parsers . SAXParser { private boolean namespaces = false ; private boolean validation = false ; private Parser parser = null ; private SAXParserImpl ( ) { super ( ) ; } protected SAXParserImpl ( boolean namespaces , boolean validation ) throws ParserConfigurationException { this ( ) ; SAXParser p = new SAXParser ( ) ; try { p . setFeature ( "http://xml.org/sax/features/namespaces" , namespaces ) ; } catch ( SAXException e ) { throw new ParserConfigurationException ( "Cannot set namespace " + "awareness to " + namespaces ) ; } try { p . setFeature ( "http://xml.org/sax/features/validation" , validation ) ; } catch ( SAXException e ) { throw new ParserConfigurationException ( "Cannot set validation to " + validation ) ; } this . namespaces = namespaces ; this . validation = validation ; this . parser = p ; } public Parser getParser ( ) { return ( this . parser ) ; } public boolean isNamespaceAware ( ) { return ( this . namespaces ) ; } public boolean isValidating ( ) { return ( this . validation ) ; } } 	1	['5', '2', '0', '2', '13', '0', '1', '1', '3', '0.5', '81', '1', '1', '0.863636364', '0.6', '1', '1', '14.6', '1', '0.6', '1']
package javax . xml . parsers ; import org . xml . sax . SAXException ; public abstract class SAXParserFactory { private boolean namespaces = false ; private boolean validation = false ; private static String property = "javax.xml.parsers.SAXParserFactory" ; private static String factory = "org.apache.xerces.jaxp.SAXParserFactoryImpl" ; protected SAXParserFactory ( ) { super ( ) ; } public static SAXParserFactory newInstance ( ) { String n = factory ; try { n = System . getProperty ( property , factory ) ; } catch ( SecurityException e ) { n = factory ; } try { return ( SAXParserFactory ) Class . forName ( n ) . newInstance ( ) ; } catch ( ClassNotFoundException e ) { throw new FactoryConfigurationError ( "Cannot load class " + "SAXParserFactory class \"" + n + "\"" ) ; } catch ( InstantiationException e ) { throw new FactoryConfigurationError ( "Cannot instantiate the " + "specified SAXParserFactory class \"" + n + "\"" ) ; } catch ( IllegalAccessException e ) { throw new FactoryConfigurationError ( "Cannot access the specified " + "SAXParserFactory class \"" + n + "\"" ) ; } catch ( ClassCastException e ) { throw new FactoryConfigurationError ( "The specified class \"" + n + "\" is not instance of \"javax.xml.parsers.SAXParserFactory\"" ) ; } } public abstract SAXParser newSAXParser ( ) throws ParserConfigurationException , SAXException ; public void setNamespaceAware ( boolean aware ) { this . namespaces = aware ; } public void setValidating ( boolean validating ) { this . validation = validating ; } public boolean isNamespaceAware ( ) { return ( this . namespaces ) ; } public boolean isValidating ( ) { return ( this . validation ) ; } } 	1	['8', '1', '1', '0', '16', '14', '0', '0', '6', '0.785714286', '115', '1', '0', '0', '0.571428571', '0', '0', '12.875', '1', '0.75', '1']
package org . apache . xerces . framework ; public class Version { public static String fVersion = "Xerces 1.2.0" ; public static void main ( String argv [ ] ) { System . out . println ( fVersion ) ; } } 	1	['3', '1', '0', '0', '5', '1', '0', '0', '2', '0.5', '14', '0', '0', '0', '0.5', '0', '0', '3.333333333', '1', '0.3333', '4']
package org . w3c . dom ; public interface CDATASection extends Text { } 	1	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '2']
package org . apache . xerces . validators . common ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . utils . ImplementationMessages ; import org . apache . xerces . utils . QName ; import org . apache . xerces . validators . schema . EquivClassComparator ; public class DFAContentModel implements XMLContentModel { private static final int EPSILON = - 2 ; private static final int EOC = - 3 ; private static final boolean DEBUG_VALIDATE_CONTENT = false ; private EquivClassComparator comparator = null ; private QName fElemMap [ ] = null ; private int fElemMapType [ ] = null ; private int fElemMapSize = 0 ; private boolean fDTD ; private int fEOCIndex = 0 ; private int fEOCPos = 0 ; private int fEpsilonIndex = 0 ; private boolean fFinalStateFlags [ ] = null ; private CMStateSet fFollowList [ ] = null ; private CMNode fHeadNode = null ; private int fLeafCount = 0 ; private CMLeaf fLeafList [ ] = null ; private int fLeafListType [ ] = null ; private ContentLeafNameTypeVector fLeafNameTypeVector = null ; private int fTransTable [ ] [ ] = null ; private int fTransTableSize = 0 ; private boolean fEmptyContentIsValid = false ; private QName fQName = new QName ( ) ; public DFAContentModel ( CMNode syntaxTree , int leafCount ) throws CMException { this ( syntaxTree , leafCount , false ) ; } public DFAContentModel ( CMNode syntaxTree , int leafCount , boolean dtd ) throws CMException { fLeafCount = leafCount ; fEpsilonIndex = EPSILON ; fEOCIndex = EOC ; fDTD = dtd ; buildDFA ( syntaxTree ) ; } public int validateContent ( QName children [ ] , int offset , int length ) throws CMException { if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "DFAContentModel#validateContent" ) ; if ( length == 0 ) { if ( DEBUG_VALIDATE_CONTENT ) { System . out . println ( "!!! no children" ) ; System . out . println ( "elemMap=" + fElemMap ) ; for ( int i = 0 ; i < fElemMap . length ; i ++ ) { int uriIndex = fElemMap [ i ] . uri ; int localpartIndex = fElemMap [ i ] . localpart ; } System . out . println ( "EOCIndex=" + fEOCIndex ) ; } return fEmptyContentIsValid ? - 1 : 0 ; } int curState = 0 ; for ( int childIndex = 0 ; childIndex < length ; childIndex ++ ) { final QName curElem = children [ offset + childIndex ] ; int elemIndex = 0 ; for ( ; elemIndex < fElemMapSize ; elemIndex ++ ) { int type = fElemMapType [ elemIndex ] & 0x0f ; if ( type == XMLContentSpec . CONTENTSPECNODE_LEAF ) { if ( fDTD ) { if ( fElemMap [ elemIndex ] . rawname == curElem . rawname ) { break ; } } else { if ( fElemMap [ elemIndex ] . uri == curElem . uri && fElemMap [ elemIndex ] . localpart == curElem . localpart ) break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY ) { int uri = fElemMap [ elemIndex ] . uri ; if ( uri == - 1 || uri == curElem . uri ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL ) { if ( curElem . uri == - 1 ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ) { if ( fElemMap [ elemIndex ] . uri != curElem . uri ) { break ; } } } if ( elemIndex == fElemMapSize ) { if ( DEBUG_VALIDATE_CONTENT ) { System . out . println ( "!!! didn't find it" ) ; System . out . println ( "curElem : " + curElem ) ; for ( int i = 0 ; i < fElemMapSize ; i ++ ) { System . out . println ( "fElemMap[" + i + "] = " + fElemMap [ i ] ) ; System . out . println ( "fElemMapType[" + i + "] = " + fElemMapType [ i ] ) ; } } return childIndex ; } curState = fTransTable [ curState ] [ elemIndex ] ; if ( curState == - 1 ) { if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "!!! not a legal transition" ) ; return childIndex ; } } if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "curState=" + curState + ", childCount=" + length ) ; if ( ! fFinalStateFlags [ curState ] ) return length ; return - 1 ; } private boolean isEqual ( QName name1 , QName name2 ) { return name1 . localpart == name2 . localpart && name1 . uri == name2 . uri ; } public int validateContentSpecial ( QName children [ ] , int offset , int length ) throws Exception { if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "DFAContentModel#validateContentSpecial" ) ; if ( comparator == null ) { return validateContent ( children , offset , length ) ; } if ( length == 0 ) { if ( DEBUG_VALIDATE_CONTENT ) { System . out . println ( "!!! no children" ) ; System . out . println ( "elemMap=" + fElemMap ) ; for ( int i = 0 ; i < fElemMap . length ; i ++ ) { int uriIndex = fElemMap [ i ] . uri ; int localpartIndex = fElemMap [ i ] . localpart ; } System . out . println ( "EOCIndex=" + fEOCIndex ) ; } return fEmptyContentIsValid ? - 1 : 0 ; } int curState = 0 ; for ( int childIndex = 0 ; childIndex < length ; childIndex ++ ) { final QName curElem = children [ offset + childIndex ] ; int elemIndex = 0 ; for ( ; elemIndex < fElemMapSize ; elemIndex ++ ) { int type = fElemMapType [ elemIndex ] & 0x0f ; if ( type == XMLContentSpec . CONTENTSPECNODE_LEAF ) { if ( comparator . isEquivalentTo ( curElem , fElemMap [ elemIndex ] ) ) break ; } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY ) { int uri = fElemMap [ elemIndex ] . uri ; if ( uri == - 1 || uri == curElem . uri ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL ) { if ( curElem . uri == - 1 ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ) { if ( fElemMap [ elemIndex ] . uri != curElem . uri ) { break ; } } } if ( elemIndex == fElemMapSize ) { if ( DEBUG_VALIDATE_CONTENT ) { System . out . println ( "!!! didn't find it" ) ; System . out . println ( "curElem : " + curElem ) ; for ( int i = 0 ; i < fElemMapSize ; i ++ ) { System . out . println ( "fElemMap[" + i + "] = " + fElemMap [ i ] ) ; System . out . println ( "fElemMapType[" + i + "] = " + fElemMapType [ i ] ) ; } } return childIndex ; } curState = fTransTable [ curState ] [ elemIndex ] ; if ( curState == - 1 ) { if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "!!! not a legal transition" ) ; return childIndex ; } } if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "curState=" + curState + ", childCount=" + length ) ; if ( ! fFinalStateFlags [ curState ] ) return length ; return - 1 ; } public void setEquivClassComparator ( EquivClassComparator comparator ) { this . comparator = comparator ; } public int whatCanGoHere ( boolean fullyValid , InsertableElementsInfo info ) throws CMException { int curState = 0 ; for ( int childIndex = 0 ; childIndex < info . insertAt ; childIndex ++ ) { final QName curElem = info . curChildren [ childIndex ] ; int elemIndex = 0 ; for ( ; elemIndex < fElemMapSize ; elemIndex ++ ) { if ( fElemMap [ elemIndex ] . uri == curElem . uri && fElemMap [ elemIndex ] . localpart == curElem . localpart ) break ; } if ( elemIndex == fElemMapSize ) return childIndex ; curState = fTransTable [ curState ] [ elemIndex ] ; if ( curState == - 1 ) return childIndex ; } final int insertState = curState ; info . canHoldPCData = false ; info . isValidEOC = fFinalStateFlags [ insertState ] ; info . resultsCount = fElemMapSize ; if ( ( info . results == null ) || ( info . results . length < info . resultsCount ) ) info . results = new boolean [ info . resultsCount ] ; if ( ( info . possibleChildren == null ) || ( info . possibleChildren . length < info . resultsCount ) ) { info . possibleChildren = new QName [ info . resultsCount ] ; for ( int i = 0 ; i < info . possibleChildren . length ; i ++ ) { info . possibleChildren [ i ] = new QName ( ) ; } } for ( int index = 0 ; index < fElemMapSize ; index ++ ) { info . possibleChildren [ index ] . setValues ( fElemMap [ index ] ) ; info . results [ index ] = ( fTransTable [ insertState ] [ index ] != - 1 ) ; } if ( fullyValid ) { for ( int index = 0 ; index < info . resultsCount ; index ++ ) { if ( ! info . results [ index ] ) continue ; info . curChildren [ info . insertAt ] = info . possibleChildren [ index ] ; if ( validateContent ( info . curChildren , 0 , info . childCount ) != - 1 ) info . results [ index ] = false ; } } return - 1 ; } public ContentLeafNameTypeVector getContentLeafNameTypeVector ( ) { return fLeafNameTypeVector ; } private void buildDFA ( CMNode syntaxTree ) throws CMException { fQName . setValues ( - 1 , fEOCIndex , fEOCIndex ) ; CMLeaf nodeEOC = new CMLeaf ( fQName ) ; fHeadNode = new CMBinOp ( XMLContentSpec . CONTENTSPECNODE_SEQ , syntaxTree , nodeEOC ) ; fEOCPos = fLeafCount ; nodeEOC . setPosition ( fLeafCount ++ ) ; fLeafList = new CMLeaf [ fLeafCount ] ; fLeafListType = new int [ fLeafCount ] ; postTreeBuildInit ( fHeadNode , 0 ) ; fFollowList = new CMStateSet [ fLeafCount ] ; for ( int index = 0 ; index < fLeafCount ; index ++ ) fFollowList [ index ] = new CMStateSet ( fLeafCount ) ; calcFollowList ( fHeadNode ) ; fElemMap = new QName [ fLeafCount ] ; fElemMapType = new int [ fLeafCount ] ; fElemMapSize = 0 ; for ( int outIndex = 0 ; outIndex < fLeafCount ; outIndex ++ ) { fElemMap [ outIndex ] = new QName ( ) ; if ( ( fLeafListType [ outIndex ] & 0x0f ) != 0 ) { if ( fLeafNameTypeVector == null ) { fLeafNameTypeVector = new ContentLeafNameTypeVector ( ) ; } } final QName element = fLeafList [ outIndex ] . getElement ( ) ; int inIndex = 0 ; for ( ; inIndex < fElemMapSize ; inIndex ++ ) { if ( fDTD ) { if ( fElemMap [ inIndex ] . rawname == element . rawname ) { break ; } } else { if ( fElemMap [ inIndex ] . uri == element . uri && fElemMap [ inIndex ] . localpart == element . localpart && fElemMapType [ inIndex ] == fLeafListType [ outIndex ] ) break ; } } if ( inIndex == fElemMapSize ) { fElemMap [ fElemMapSize ] . setValues ( element ) ; fElemMapType [ fElemMapSize ] = fLeafListType [ outIndex ] ; fElemMapSize ++ ; } } if ( fLeafNameTypeVector != null ) { fLeafNameTypeVector . setValues ( fElemMap , fElemMapType , fElemMapSize ) ; } int curArraySize = fLeafCount * 4 ; CMStateSet [ ] statesToDo = new CMStateSet [ curArraySize ] ; fFinalStateFlags = new boolean [ curArraySize ] ; fTransTable = new int [ curArraySize ] [ ] ; CMStateSet setT = fHeadNode . firstPos ( ) ; int unmarkedState = 0 ; int curState = 0 ; fTransTable [ curState ] = makeDefStateList ( ) ; statesToDo [ curState ] = setT ; curState ++ ; while ( unmarkedState < curState ) { setT = statesToDo [ unmarkedState ] ; int [ ] transEntry = fTransTable [ unmarkedState ] ; fFinalStateFlags [ unmarkedState ] = setT . getBit ( fEOCPos ) ; unmarkedState ++ ; CMStateSet newSet = null ; for ( int elemIndex = 0 ; elemIndex < fElemMapSize ; elemIndex ++ ) { if ( newSet == null ) newSet = new CMStateSet ( fLeafCount ) ; else newSet . zeroBits ( ) ; for ( int leafIndex = 0 ; leafIndex < fLeafCount ; leafIndex ++ ) { if ( setT . getBit ( leafIndex ) ) { final QName leaf = fLeafList [ leafIndex ] . getElement ( ) ; final QName element = fElemMap [ elemIndex ] ; if ( fDTD ) { if ( leaf . rawname == element . rawname ) { newSet . union ( fFollowList [ leafIndex ] ) ; } } else { if ( leaf . uri == element . uri && leaf . localpart == element . localpart ) newSet . union ( fFollowList [ leafIndex ] ) ; } } } if ( ! newSet . isEmpty ( ) ) { int stateIndex = 0 ; for ( ; stateIndex < curState ; stateIndex ++ ) { if ( statesToDo [ stateIndex ] . isSameSet ( newSet ) ) break ; } if ( stateIndex == curState ) { statesToDo [ curState ] = newSet ; fTransTable [ curState ] = makeDefStateList ( ) ; curState ++ ; newSet = null ; } transEntry [ elemIndex ] = stateIndex ; if ( curState == curArraySize ) { final int newSize = ( int ) ( curArraySize * 1.5 ) ; CMStateSet [ ] newToDo = new CMStateSet [ newSize ] ; boolean [ ] newFinalFlags = new boolean [ newSize ] ; int [ ] [ ] newTransTable = new int [ newSize ] [ ] ; for ( int expIndex = 0 ; expIndex < curArraySize ; expIndex ++ ) { newToDo [ expIndex ] = statesToDo [ expIndex ] ; newFinalFlags [ expIndex ] = fFinalStateFlags [ expIndex ] ; newTransTable [ expIndex ] = fTransTable [ expIndex ] ; } curArraySize = newSize ; statesToDo = newToDo ; fFinalStateFlags = newFinalFlags ; fTransTable = newTransTable ; } } } } fEmptyContentIsValid = ( ( CMBinOp ) fHeadNode ) . getLeft ( ) . isNullable ( ) ; if ( DEBUG_VALIDATE_CONTENT ) dumpTree ( fHeadNode , 0 ) ; fHeadNode = null ; fLeafList = null ; fFollowList = null ; } private void calcFollowList ( CMNode nodeCur ) throws CMException { if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_CHOICE ) { calcFollowList ( ( ( CMBinOp ) nodeCur ) . getLeft ( ) ) ; calcFollowList ( ( ( CMBinOp ) nodeCur ) . getRight ( ) ) ; } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_SEQ ) { calcFollowList ( ( ( CMBinOp ) nodeCur ) . getLeft ( ) ) ; calcFollowList ( ( ( CMBinOp ) nodeCur ) . getRight ( ) ) ; final CMStateSet last = ( ( CMBinOp ) nodeCur ) . getLeft ( ) . lastPos ( ) ; final CMStateSet first = ( ( CMBinOp ) nodeCur ) . getRight ( ) . firstPos ( ) ; for ( int index = 0 ; index < fLeafCount ; index ++ ) { if ( last . getBit ( index ) ) fFollowList [ index ] . union ( first ) ; } } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE ) { calcFollowList ( ( ( CMUniOp ) nodeCur ) . getChild ( ) ) ; final CMStateSet first = nodeCur . firstPos ( ) ; final CMStateSet last = nodeCur . lastPos ( ) ; for ( int index = 0 ; index < fLeafCount ; index ++ ) { if ( last . getBit ( index ) ) fFollowList [ index ] . union ( first ) ; } } else if ( ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE ) || ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE ) ) { throw new CMException ( ImplementationMessages . VAL_NIICM ) ; } } private void dumpTree ( CMNode nodeCur , int level ) throws CMException { for ( int index = 0 ; index < level ; index ++ ) System . out . print ( "   " ) ; int type = nodeCur . type ( ) ; if ( ( type == XMLContentSpec . CONTENTSPECNODE_CHOICE ) || ( type == XMLContentSpec . CONTENTSPECNODE_SEQ ) ) { if ( type == XMLContentSpec . CONTENTSPECNODE_CHOICE ) System . out . print ( "Choice Node " ) ; else System . out . print ( "Seq Node " ) ; if ( nodeCur . isNullable ( ) ) System . out . print ( "Nullable " ) ; System . out . print ( "firstPos=" ) ; System . out . print ( nodeCur . firstPos ( ) . toString ( ) ) ; System . out . print ( " lastPos=" ) ; System . out . println ( nodeCur . lastPos ( ) . toString ( ) ) ; dumpTree ( ( ( CMBinOp ) nodeCur ) . getLeft ( ) , level + 1 ) ; dumpTree ( ( ( CMBinOp ) nodeCur ) . getRight ( ) , level + 1 ) ; } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE ) { System . out . print ( "Rep Node " ) ; if ( nodeCur . isNullable ( ) ) System . out . print ( "Nullable " ) ; System . out . print ( "firstPos=" ) ; System . out . print ( nodeCur . firstPos ( ) . toString ( ) ) ; System . out . print ( " lastPos=" ) ; System . out . println ( nodeCur . lastPos ( ) . toString ( ) ) ; dumpTree ( ( ( CMUniOp ) nodeCur ) . getChild ( ) , level + 1 ) ; } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_LEAF ) { System . out . print ( "Leaf: (pos=" + ( ( CMLeaf ) nodeCur ) . getPosition ( ) + "), " + ( ( CMLeaf ) nodeCur ) . getElement ( ) + "(elemIndex=" + ( ( CMLeaf ) nodeCur ) . getElement ( ) + ") " ) ; if ( nodeCur . isNullable ( ) ) System . out . print ( " Nullable " ) ; System . out . print ( "firstPos=" ) ; System . out . print ( nodeCur . firstPos ( ) . toString ( ) ) ; System . out . print ( " lastPos=" ) ; System . out . println ( nodeCur . lastPos ( ) . toString ( ) ) ; } else { throw new CMException ( ImplementationMessages . VAL_NIICM ) ; } } private int [ ] makeDefStateList ( ) { int [ ] retArray = new int [ fElemMapSize ] ; for ( int index = 0 ; index < fElemMapSize ; index ++ ) retArray [ index ] = - 1 ; return retArray ; } private int postTreeBuildInit ( CMNode nodeCur , int curIndex ) throws CMException { nodeCur . setMaxStates ( fLeafCount ) ; if ( ( nodeCur . type ( ) & 0x0f ) == XMLContentSpec . CONTENTSPECNODE_ANY || ( nodeCur . type ( ) & 0x0f ) == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL || ( nodeCur . type ( ) & 0x0f ) == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ) { QName qname = new QName ( - 1 , - 1 , - 1 , ( ( CMAny ) nodeCur ) . getURI ( ) ) ; fLeafList [ curIndex ] = new CMLeaf ( qname , ( ( CMAny ) nodeCur ) . getPosition ( ) ) ; fLeafListType [ curIndex ] = nodeCur . type ( ) ; curIndex ++ ; } else if ( ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_CHOICE ) || ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_SEQ ) ) { curIndex = postTreeBuildInit ( ( ( CMBinOp ) nodeCur ) . getLeft ( ) , curIndex ) ; curIndex = postTreeBuildInit ( ( ( CMBinOp ) nodeCur ) . getRight ( ) , curIndex ) ; } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE ) { curIndex = postTreeBuildInit ( ( ( CMUniOp ) nodeCur ) . getChild ( ) , curIndex ) ; } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_LEAF ) { final QName node = ( ( CMLeaf ) nodeCur ) . getElement ( ) ; if ( node . localpart != fEpsilonIndex ) { fLeafList [ curIndex ] = ( CMLeaf ) nodeCur ; fLeafListType [ curIndex ] = XMLContentSpec . CONTENTSPECNODE_LEAF ; curIndex ++ ; } } else { throw new CMException ( ImplementationMessages . VAL_NIICM ) ; } return curIndex ; } } 	1	['13', '1', '0', '13', '52', '30', '1', '12', '7', '0.757575758', '1444', '1', '7', '0', '0.307692308', '0', '0', '108.3846154', '3', '1.0769', '2']
package org . apache . xerces . validators . common ; import org . apache . xerces . framework . XMLAttrList ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . framework . XMLDocumentHandler ; import org . apache . xerces . framework . XMLDocumentScanner ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . readers . DefaultEntityHandler ; import org . apache . xerces . readers . XMLEntityHandler ; import org . apache . xerces . utils . ChunkyCharArray ; import org . apache . xerces . utils . Hash2intTable ; import org . apache . xerces . utils . NamespacesScope ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . utils . XMLCharacterProperties ; import org . apache . xerces . utils . XMLMessages ; import org . apache . xerces . utils . ImplementationMessages ; import org . apache . xerces . parsers . DOMParser ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . xml . sax . InputSource ; import org . xml . sax . EntityResolver ; import org . xml . sax . Locator ; import org . xml . sax . helpers . LocatorImpl ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . xerces . validators . dtd . DTDGrammar ; import org . apache . xerces . validators . schema . EquivClassComparator ; import org . apache . xerces . validators . schema . SchemaGrammar ; import org . apache . xerces . validators . schema . SchemaMessageProvider ; import org . apache . xerces . validators . schema . SchemaSymbols ; import org . apache . xerces . validators . schema . TraverseSchema ; import org . apache . xerces . validators . datatype . DatatypeValidatorFactoryImpl ; import org . apache . xerces . validators . datatype . DatatypeValidator ; import org . apache . xerces . validators . datatype . InvalidDatatypeValueException ; import org . apache . xerces . validators . datatype . StateMessageDatatype ; import org . apache . xerces . validators . datatype . IDREFDatatypeValidator ; import org . apache . xerces . validators . datatype . IDDatatypeValidator ; import org . apache . xerces . validators . datatype . ENTITYDatatypeValidator ; public final class XMLValidator implements DefaultEntityHandler . EventHandler , XMLEntityHandler . CharDataHandler , XMLDocumentScanner . EventHandler , NamespacesScope . NamespacesHandler { private static final boolean PRINT_EXCEPTION_STACK_TRACE = false ; private static final boolean DEBUG_PRINT_ATTRIBUTES = false ; private static final boolean DEBUG_PRINT_CONTENT = false ; private static final boolean DEBUG_SCHEMA_VALIDATION = false ; private static final boolean DEBUG_ELEMENT_CHILDREN = false ; private static final int CHUNK_SHIFT = 8 ; private static final int CHUNK_SIZE = ( 1 << CHUNK_SHIFT ) ; private static final int CHUNK_MASK = CHUNK_SIZE - 1 ; private static final int INITIAL_CHUNK_COUNT = ( 1 << ( 10 - CHUNK_SHIFT ) ) ; private Hashtable fIdDefs = null ; private StateMessageDatatype fStoreIDRef = new StateMessageDatatype ( ) { private Hashtable fIdDefs ; public Object getDatatypeObject ( ) { return ( Object ) fIdDefs ; } public int getDatatypeState ( ) { return IDREFDatatypeValidator . IDREF_STORE ; } public void setDatatypeObject ( Object data ) { fIdDefs = ( Hashtable ) data ; } } ; private StateMessageDatatype fResetID = new StateMessageDatatype ( ) { public Object getDatatypeObject ( ) { return ( Object ) null ; } public int getDatatypeState ( ) { return IDDatatypeValidator . ID_CLEAR ; } public void setDatatypeObject ( Object data ) { } } ; private StateMessageDatatype fResetIDRef = new StateMessageDatatype ( ) { public Object getDatatypeObject ( ) { return ( Object ) null ; } public int getDatatypeState ( ) { return IDREFDatatypeValidator . IDREF_CLEAR ; } public void setDatatypeObject ( Object data ) { } } ; private StateMessageDatatype fValidateIDRef = new StateMessageDatatype ( ) { public Object getDatatypeObject ( ) { return ( Object ) null ; } public int getDatatypeState ( ) { return IDREFDatatypeValidator . IDREF_VALIDATE ; } public void setDatatypeObject ( Object data ) { } } ; private StateMessageDatatype fValidateENTITYMsg = new StateMessageDatatype ( ) { private Object packagedMessage = null ; public Object getDatatypeObject ( ) { return packagedMessage ; } public int getDatatypeState ( ) { return ENTITYDatatypeValidator . ENTITY_INITIALIZE ; } public void setDatatypeObject ( Object data ) { packagedMessage = data ; } } ; private AttributeValidator fAttValidatorNOTATION = new AttValidatorNOTATION ( ) ; private AttributeValidator fAttValidatorENUMERATION = new AttValidatorENUMERATION ( ) ; private AttributeValidator fAttValidatorDATATYPE = null ; StringPool fStringPool = null ; boolean fValidating = false ; boolean fInElementContent = false ; int fStandaloneReader = - 1 ; private boolean fValidationEnabled = false ; private boolean fDynamicValidation = false ; private boolean fSchemaValidation = true ; private boolean fValidationEnabledByDynamic = false ; private boolean fDynamicDisabledByValidation = false ; private boolean fWarningOnDuplicateAttDef = false ; private boolean fWarningOnUndeclaredElements = false ; private boolean fLoadDTDGrammar = true ; private int fDeclaration [ ] ; private XMLErrorReporter fErrorReporter = null ; private DefaultEntityHandler fEntityHandler = null ; private QName fCurrentElement = new QName ( ) ; private ContentLeafNameTypeVector [ ] fContentLeafStack = new ContentLeafNameTypeVector [ 8 ] ; private int [ ] fValidationFlagStack = new int [ 8 ] ; private int [ ] fScopeStack = new int [ 8 ] ; private int [ ] fGrammarNameSpaceIndexStack = new int [ 8 ] ; private int [ ] fElementEntityStack = new int [ 8 ] ; private int [ ] fElementIndexStack = new int [ 8 ] ; private int [ ] fContentSpecTypeStack = new int [ 8 ] ; private static final int sizeQNameParts = 8 ; private QName [ ] fElementQNamePartsStack = new QName [ sizeQNameParts ] ; private QName [ ] fElementChildren = new QName [ 32 ] ; private int fElementChildrenLength = 0 ; private int [ ] fElementChildrenOffsetStack = new int [ 32 ] ; private int fElementDepth = - 1 ; private boolean fNamespacesEnabled = false ; private NamespacesScope fNamespacesScope = null ; private int fNamespacesPrefix = - 1 ; private QName fRootElement = new QName ( ) ; private int fAttrListHandle = - 1 ; private int fCurrentElementEntity = - 1 ; private int fCurrentElementIndex = - 1 ; private int fCurrentContentSpecType = - 1 ; private boolean fSeenDoctypeDecl = false ; private final int TOP_LEVEL_SCOPE = - 1 ; private int fCurrentScope = TOP_LEVEL_SCOPE ; private int fCurrentSchemaURI = - 1 ; private int fEmptyURI = - 1 ; private int fXsiPrefix = - 1 ; private int fXsiURI = - 2 ; private int fXsiTypeAttValue = - 1 ; private DatatypeValidator fXsiTypeValidator = null ; private Grammar fGrammar = null ; private int fGrammarNameSpaceIndex = - 1 ; private GrammarResolver fGrammarResolver = null ; private boolean fScanningDTD = false ; private XMLDocumentScanner fDocumentScanner = null ; private boolean fCalledStartDocument = false ; private XMLDocumentHandler fDocumentHandler = null ; private XMLDocumentHandler . DTDHandler fDTDHandler = null ; private boolean fSeenRootElement = false ; private XMLAttrList fAttrList = null ; private int fXMLLang = - 1 ; private LocatorImpl fAttrNameLocator = null ; private boolean fCheckedForSchema = false ; private boolean fDeclsAreExternal = false ; private StringPool . CharArrayRange fCurrentElementCharArrayRange = null ; private char [ ] fCharRefData = null ; private boolean fSendCharDataAsCharArray = false ; private boolean fBufferDatatype = false ; private StringBuffer fDatatypeBuffer = new StringBuffer ( ) ; private QName fTempQName = new QName ( ) ; private XMLAttributeDecl fTempAttDecl = new XMLAttributeDecl ( ) ; private XMLAttributeDecl fTempAttributeDecl = new XMLAttributeDecl ( ) ; private XMLElementDecl fTempElementDecl = new XMLElementDecl ( ) ; private boolean fGrammarIsDTDGrammar = false ; private boolean fGrammarIsSchemaGrammar = false ; private boolean fNeedValidationOff = false ; private int fEMPTYSymbol = - 1 ; private int fANYSymbol = - 1 ; private int fMIXEDSymbol = - 1 ; private int fCHILDRENSymbol = - 1 ; private int fCDATASymbol = - 1 ; private int fIDSymbol = - 1 ; private int fIDREFSymbol = - 1 ; private int fIDREFSSymbol = - 1 ; private int fENTITYSymbol = - 1 ; private int fENTITIESSymbol = - 1 ; private int fNMTOKENSymbol = - 1 ; private int fNMTOKENSSymbol = - 1 ; private int fNOTATIONSymbol = - 1 ; private int fENUMERATIONSymbol = - 1 ; private int fREQUIREDSymbol = - 1 ; private int fFIXEDSymbol = - 1 ; private int fDATATYPESymbol = - 1 ; private int fEpsilonIndex = - 1 ; private DatatypeValidatorFactoryImpl fDataTypeReg = DatatypeValidatorFactoryImpl . getDatatypeRegistry ( ) ; private DatatypeValidator fValID = this . fDataTypeReg . getDatatypeValidator ( "ID" ) ; private DatatypeValidator fValIDRef = this . fDataTypeReg . getDatatypeValidator ( "IDREF" ) ; private DatatypeValidator fValIDRefs = this . fDataTypeReg . getDatatypeValidator ( "IDREFS" ) ; private DatatypeValidator fValENTITY = this . fDataTypeReg . getDatatypeValidator ( "ENTITY" ) ; private DatatypeValidator fValENTITIES = this . fDataTypeReg . getDatatypeValidator ( "ENTITIES" ) ; private DatatypeValidator fValNMTOKEN = this . fDataTypeReg . getDatatypeValidator ( "NMTOKEN" ) ; private DatatypeValidator fValNMTOKENS = this . fDataTypeReg . getDatatypeValidator ( "NMTOKENS" ) ; private DatatypeValidator fValNOTATION = this . fDataTypeReg . getDatatypeValidator ( "NOTATION" ) ; public XMLValidator ( StringPool stringPool , XMLErrorReporter errorReporter , DefaultEntityHandler entityHandler , XMLDocumentScanner documentScanner ) { fStringPool = stringPool ; fErrorReporter = errorReporter ; fEntityHandler = entityHandler ; fDocumentScanner = documentScanner ; fEmptyURI = fStringPool . addSymbol ( "" ) ; fXsiURI = fStringPool . addSymbol ( SchemaSymbols . URI_XSI ) ; fAttrList = new XMLAttrList ( fStringPool ) ; entityHandler . setEventHandler ( this ) ; entityHandler . setCharDataHandler ( this ) ; fDocumentScanner . setEventHandler ( this ) ; for ( int i = 0 ; i < sizeQNameParts ; i ++ ) { fElementQNamePartsStack [ i ] = new QName ( ) ; } init ( ) ; } public void setGrammarResolver ( GrammarResolver grammarResolver ) { fGrammarResolver = grammarResolver ; } public void initHandlers ( boolean sendCharDataAsCharArray , XMLDocumentHandler docHandler , XMLDocumentHandler . DTDHandler dtdHandler ) { fSendCharDataAsCharArray = sendCharDataAsCharArray ; fEntityHandler . setSendCharDataAsCharArray ( fSendCharDataAsCharArray ) ; fDocumentHandler = docHandler ; fDTDHandler = dtdHandler ; } public void resetOrCopy ( StringPool stringPool ) throws Exception { fAttrList = new XMLAttrList ( stringPool ) ; resetCommon ( stringPool ) ; } public void reset ( StringPool stringPool ) throws Exception { fAttrList . reset ( stringPool ) ; resetCommon ( stringPool ) ; } public void setValidationEnabled ( boolean flag ) throws Exception { fValidationEnabled = flag ; fValidationEnabledByDynamic = false ; if ( fValidationEnabled ) { if ( fDynamicDisabledByValidation ) { fDynamicValidation = true ; fDynamicDisabledByValidation = false ; } } else if ( fDynamicValidation ) { fDynamicValidation = false ; fDynamicDisabledByValidation = true ; } fValidating = fValidationEnabled ; } public boolean getValidationEnabled ( ) { return fValidationEnabled ; } public void setSchemaValidationEnabled ( boolean flag ) { fSchemaValidation = flag ; } public boolean getSchemaValidationEnabled ( ) { return fSchemaValidation ; } public void setDynamicValidationEnabled ( boolean flag ) throws Exception { fDynamicValidation = flag ; fDynamicDisabledByValidation = false ; if ( ! fDynamicValidation ) { if ( fValidationEnabledByDynamic ) { fValidationEnabled = false ; fValidationEnabledByDynamic = false ; } } else if ( ! fValidationEnabled ) { fValidationEnabled = true ; fValidationEnabledByDynamic = true ; } fValidating = fValidationEnabled ; } public boolean getDynamicValidationEnabled ( ) { return fDynamicValidation ; } public void setLoadDTDGrammar ( boolean loadDG ) { if ( fValidating ) { fLoadDTDGrammar = true ; } else { fLoadDTDGrammar = loadDG ; } } public boolean getLoadDTDGrammar ( ) { return fLoadDTDGrammar ; } public void setNamespacesEnabled ( boolean flag ) { fNamespacesEnabled = flag ; } public boolean getNamespacesEnabled ( ) { return fNamespacesEnabled ; } public void setWarningOnDuplicateAttDef ( boolean flag ) { fWarningOnDuplicateAttDef = flag ; } public boolean getWarningOnDuplicateAttDef ( ) { return fWarningOnDuplicateAttDef ; } public void setWarningOnUndeclaredElements ( boolean flag ) { fWarningOnUndeclaredElements = flag ; } public boolean getWarningOnUndeclaredElements ( ) { return fWarningOnUndeclaredElements ; } public void startEntityReference ( int entityName , int entityType , int entityContext ) throws Exception { fDocumentHandler . startEntityReference ( entityName , entityType , entityContext ) ; } public void endEntityReference ( int entityName , int entityType , int entityContext ) throws Exception { fDocumentHandler . endEntityReference ( entityName , entityType , entityContext ) ; } public void sendEndOfInputNotifications ( int entityName , boolean moreToFollow ) throws Exception { fDocumentScanner . endOfInput ( entityName , moreToFollow ) ; } public void sendReaderChangeNotifications ( XMLEntityHandler . EntityReader reader , int readerId ) throws Exception { fDocumentScanner . readerChange ( reader , readerId ) ; } public boolean externalEntityStandaloneCheck ( ) { return ( fStandaloneReader != - 1 && fValidating ) ; } public boolean getValidating ( ) { return fValidating ; } public void processCharacters ( char [ ] chars , int offset , int length ) throws Exception { if ( fValidating ) { if ( fInElementContent || fCurrentContentSpecType == XMLElementDecl . TYPE_EMPTY ) { charDataInContent ( ) ; } if ( fBufferDatatype ) { fDatatypeBuffer . append ( chars , offset , length ) ; } } fDocumentHandler . characters ( chars , offset , length ) ; } public void processCharacters ( int data ) throws Exception { if ( fValidating ) { if ( fInElementContent || fCurrentContentSpecType == XMLElementDecl . TYPE_EMPTY ) { charDataInContent ( ) ; } if ( fBufferDatatype ) { fDatatypeBuffer . append ( fStringPool . toString ( data ) ) ; } } fDocumentHandler . characters ( data ) ; } public void processWhitespace ( char [ ] chars , int offset , int length ) throws Exception { if ( fInElementContent ) { if ( fStandaloneReader != - 1 && fValidating && getElementDeclIsExternal ( fCurrentElementIndex ) ) { reportRecoverableXMLError ( XMLMessages . MSG_WHITE_SPACE_IN_ELEMENT_CONTENT_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION ) ; } fDocumentHandler . ignorableWhitespace ( chars , offset , length ) ; } else { if ( fCurrentContentSpecType == XMLElementDecl . TYPE_EMPTY ) { charDataInContent ( ) ; } fDocumentHandler . characters ( chars , offset , length ) ; } } public void processWhitespace ( int data ) throws Exception { if ( fInElementContent ) { if ( fStandaloneReader != - 1 && fValidating && getElementDeclIsExternal ( fCurrentElementIndex ) ) { reportRecoverableXMLError ( XMLMessages . MSG_WHITE_SPACE_IN_ELEMENT_CONTENT_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION ) ; } fDocumentHandler . ignorableWhitespace ( data ) ; } else { if ( fCurrentContentSpecType == XMLElementDecl . TYPE_EMPTY ) { charDataInContent ( ) ; } fDocumentHandler . characters ( data ) ; } } public void scanElementType ( XMLEntityHandler . EntityReader entityReader , char fastchar , QName element ) throws Exception { if ( ! fNamespacesEnabled ) { element . clear ( ) ; element . localpart = entityReader . scanName ( fastchar ) ; element . rawname = element . localpart ; } else { entityReader . scanQName ( fastchar , element ) ; if ( entityReader . lookingAtChar ( ':' , false ) ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_TWO_COLONS_IN_QNAME , XMLMessages . P5_INVALID_CHARACTER , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; entityReader . skipPastNmtoken ( ' ' ) ; } } } public boolean scanExpectedElementType ( XMLEntityHandler . EntityReader entityReader , char fastchar , QName element ) throws Exception { if ( fCurrentElementCharArrayRange == null ) { fCurrentElementCharArrayRange = fStringPool . createCharArrayRange ( ) ; } fStringPool . getCharArrayRange ( fCurrentElement . rawname , fCurrentElementCharArrayRange ) ; return entityReader . scanExpectedName ( fastchar , fCurrentElementCharArrayRange ) ; } public void scanAttributeName ( XMLEntityHandler . EntityReader entityReader , QName element , QName attribute ) throws Exception { if ( ! fSeenRootElement ) { fSeenRootElement = true ; rootElementSpecified ( element ) ; fStringPool . resetShuffleCount ( ) ; } if ( ! fNamespacesEnabled ) { attribute . clear ( ) ; attribute . localpart = entityReader . scanName ( '=' ) ; attribute . rawname = attribute . localpart ; } else { entityReader . scanQName ( '=' , attribute ) ; if ( entityReader . lookingAtChar ( ':' , false ) ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_TWO_COLONS_IN_QNAME , XMLMessages . P5_INVALID_CHARACTER , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; entityReader . skipPastNmtoken ( ' ' ) ; } } } public void callStartDocument ( ) throws Exception { if ( ! fCalledStartDocument ) { fDocumentHandler . startDocument ( ) ; fCalledStartDocument = true ; } } public void callEndDocument ( ) throws Exception { if ( fCalledStartDocument ) { fDocumentHandler . endDocument ( ) ; } } public void callXMLDecl ( int version , int encoding , int standalone ) throws Exception { fDocumentHandler . xmlDecl ( version , encoding , standalone ) ; } public void callStandaloneIsYes ( ) throws Exception { fStandaloneReader = fEntityHandler . getReaderId ( ) ; } public void callTextDecl ( int version , int encoding ) throws Exception { fDocumentHandler . textDecl ( version , encoding ) ; } public void element ( QName element ) throws Exception { fAttrListHandle = - 1 ; } public boolean attribute ( QName element , QName attrName , int attrValue ) throws Exception { if ( fAttrListHandle == - 1 ) { fAttrListHandle = fAttrList . startAttrList ( ) ; } return fAttrList . addAttr ( attrName , attrValue , fCDATASymbol , true , true ) == - 1 ; } public void callStartElement ( QName element ) throws Exception { if ( DEBUG_SCHEMA_VALIDATION ) System . out . println ( "\n=======StartElement : " + fStringPool . toString ( element . localpart ) ) ; if ( ! fSeenRootElement ) { fSeenRootElement = true ; rootElementSpecified ( element ) ; fStringPool . resetShuffleCount ( ) ; } if ( fGrammar != null && fGrammarIsDTDGrammar ) { fAttrListHandle = addDTDDefaultAttributes ( element , fAttrList , fAttrListHandle , fValidating , fStandaloneReader != - 1 ) ; } fCheckedForSchema = true ; if ( fNamespacesEnabled ) { bindNamespacesToElementAndAttributes ( element , fAttrList ) ; } validateElementAndAttributes ( element , fAttrList ) ; if ( fAttrListHandle != - 1 ) { fAttrList . endAttrList ( ) ; } fDocumentHandler . startElement ( element , fAttrList , fAttrListHandle ) ; fAttrListHandle = - 1 ; fElementDepth ++ ; if ( fValidating ) { if ( fElementChildrenOffsetStack . length < fElementDepth ) { int newarray [ ] = new int [ fElementChildrenOffsetStack . length * 2 ] ; System . arraycopy ( fElementChildrenOffsetStack , 0 , newarray , 0 , fElementChildrenOffsetStack . length ) ; fElementChildrenOffsetStack = newarray ; } fElementChildrenOffsetStack [ fElementDepth ] = fElementChildrenLength ; if ( fElementChildren . length <= fElementChildrenLength ) { QName [ ] newarray = new QName [ fElementChildrenLength * 2 ] ; System . arraycopy ( fElementChildren , 0 , newarray , 0 , fElementChildren . length ) ; fElementChildren = newarray ; } QName qname = fElementChildren [ fElementChildrenLength ] ; if ( qname == null ) { for ( int i = fElementChildrenLength ; i < fElementChildren . length ; i ++ ) { fElementChildren [ i ] = new QName ( ) ; } qname = fElementChildren [ fElementChildrenLength ] ; } qname . setValues ( element ) ; fElementChildrenLength ++ ; if ( DEBUG_ELEMENT_CHILDREN ) { printChildren ( ) ; printStack ( ) ; } } ensureStackCapacity ( fElementDepth ) ; fCurrentElement . setValues ( element ) ; fCurrentElementEntity = fEntityHandler . getReaderId ( ) ; fElementQNamePartsStack [ fElementDepth ] . setValues ( fCurrentElement ) ; fElementEntityStack [ fElementDepth ] = fCurrentElementEntity ; fElementIndexStack [ fElementDepth ] = fCurrentElementIndex ; fContentSpecTypeStack [ fElementDepth ] = fCurrentContentSpecType ; if ( fNeedValidationOff ) { fValidating = false ; fNeedValidationOff = false ; } if ( fValidating && fGrammarIsSchemaGrammar ) { pushContentLeafStack ( ) ; } fValidationFlagStack [ fElementDepth ] = fValidating ? 0 : - 1 ; fScopeStack [ fElementDepth ] = fCurrentScope ; fGrammarNameSpaceIndexStack [ fElementDepth ] = fGrammarNameSpaceIndex ; } private void pushContentLeafStack ( ) throws Exception { int contentType = getContentSpecType ( fCurrentElementIndex ) ; if ( contentType == XMLElementDecl . TYPE_CHILDREN ) { XMLContentModel cm = getElementContentModel ( fCurrentElementIndex ) ; ContentLeafNameTypeVector cv = cm . getContentLeafNameTypeVector ( ) ; if ( cm != null ) { fContentLeafStack [ fElementDepth ] = cv ; } } } private void ensureStackCapacity ( int newElementDepth ) { if ( newElementDepth == fElementQNamePartsStack . length ) { int [ ] newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fScopeStack , 0 , newStack , 0 , newElementDepth ) ; fScopeStack = newStack ; newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fGrammarNameSpaceIndexStack , 0 , newStack , 0 , newElementDepth ) ; fGrammarNameSpaceIndexStack = newStack ; QName [ ] newStackOfQueue = new QName [ newElementDepth * 2 ] ; System . arraycopy ( this . fElementQNamePartsStack , 0 , newStackOfQueue , 0 , newElementDepth ) ; fElementQNamePartsStack = newStackOfQueue ; QName qname = fElementQNamePartsStack [ newElementDepth ] ; if ( qname == null ) { for ( int i = newElementDepth ; i < fElementQNamePartsStack . length ; i ++ ) { fElementQNamePartsStack [ i ] = new QName ( ) ; } } newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fElementEntityStack , 0 , newStack , 0 , newElementDepth ) ; fElementEntityStack = newStack ; newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fElementIndexStack , 0 , newStack , 0 , newElementDepth ) ; fElementIndexStack = newStack ; newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fContentSpecTypeStack , 0 , newStack , 0 , newElementDepth ) ; fContentSpecTypeStack = newStack ; newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fValidationFlagStack , 0 , newStack , 0 , newElementDepth ) ; fValidationFlagStack = newStack ; ContentLeafNameTypeVector [ ] newStackV = new ContentLeafNameTypeVector [ newElementDepth * 2 ] ; System . arraycopy ( fContentLeafStack , 0 , newStackV , 0 , newElementDepth ) ; fContentLeafStack = newStackV ; } } public void callEndElement ( int readerId ) throws Exception { if ( DEBUG_SCHEMA_VALIDATION ) System . out . println ( "=======EndElement : " + fStringPool . toString ( fCurrentElement . localpart ) + "\n" ) ; int prefixIndex = fCurrentElement . prefix ; int elementType = fCurrentElement . rawname ; if ( fCurrentElementEntity != readerId ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ELEMENT_ENTITY_MISMATCH , XMLMessages . P78_NOT_WELLFORMED , new Object [ ] { fStringPool . toString ( elementType ) } , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } fElementDepth -- ; if ( fValidating ) { int elementIndex = fCurrentElementIndex ; if ( elementIndex != - 1 && fCurrentContentSpecType != - 1 ) { QName children [ ] = fElementChildren ; int childrenOffset = fElementChildrenOffsetStack [ fElementDepth + 1 ] + 1 ; int childrenLength = fElementChildrenLength - childrenOffset ; if ( DEBUG_ELEMENT_CHILDREN ) { System . out . println ( "endElement(" + fStringPool . toString ( fCurrentElement . rawname ) + ')' ) ; System . out . println ( "fCurrentContentSpecType : " + fCurrentContentSpecType ) ; System . out . print ( "offset: " ) ; System . out . print ( childrenOffset ) ; System . out . print ( ", length: " ) ; System . out . print ( childrenLength ) ; System . out . println ( ) ; printChildren ( ) ; printStack ( ) ; } int result = checkContent ( elementIndex , children , childrenOffset , childrenLength ) ; if ( DEBUG_SCHEMA_VALIDATION ) System . out . println ( "!!!!!!!!In XMLValidator, the return value from checkContent : " + result ) ; if ( result != - 1 ) { int majorCode = result != childrenLength ? XMLMessages . MSG_CONTENT_INVALID : XMLMessages . MSG_CONTENT_INCOMPLETE ; fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ; if ( fTempElementDecl . type == XMLElementDecl . TYPE_EMPTY ) { reportRecoverableXMLError ( majorCode , 0 , fStringPool . toString ( elementType ) , "EMPTY" ) ; } else reportRecoverableXMLError ( majorCode , 0 , fStringPool . toString ( elementType ) , XMLContentSpec . toString ( fGrammar , fStringPool , fTempElementDecl . contentSpecIndex ) ) ; } } fElementChildrenLength = fElementChildrenOffsetStack [ fElementDepth + 1 ] + 1 ; } fDocumentHandler . endElement ( fCurrentElement ) ; if ( fNamespacesEnabled ) { fNamespacesScope . decreaseDepth ( ) ; } if ( fElementDepth < - 1 ) { throw new RuntimeException ( "FWK008 Element stack underflow" ) ; } if ( fElementDepth < 0 ) { fCurrentElement . clear ( ) ; fCurrentElementEntity = - 1 ; fCurrentElementIndex = - 1 ; fCurrentContentSpecType = - 1 ; fInElementContent = false ; if ( fValidating ) { try { this . fValIDRef . validate ( null , this . fValidateIDRef ) ; this . fValIDRefs . validate ( null , this . fValidateIDRef ) ; } catch ( InvalidDatatypeValueException ex ) { reportRecoverableXMLError ( ex . getMajorCode ( ) , ex . getMinorCode ( ) , ex . getMessage ( ) ) ; } } try { this . fValID . validate ( null , this . fResetID ) ; this . fValIDRef . validate ( null , this . fResetIDRef ) ; this . fValIDRefs . validate ( null , this . fResetIDRef ) ; } catch ( InvalidDatatypeValueException ex ) { System . err . println ( "Error re-Initializing: ID,IDRef,IDRefs pools" ) ; } return ; } fCurrentElement . prefix = - 1 ; if ( fNamespacesEnabled ) { fCurrentElement . localpart = fElementQNamePartsStack [ fElementDepth ] . localpart ; } else { fCurrentElement . localpart = fElementQNamePartsStack [ fElementDepth ] . rawname ; } fCurrentElement . rawname = fElementQNamePartsStack [ fElementDepth ] . rawname ; fCurrentElement . uri = fElementQNamePartsStack [ fElementDepth ] . uri ; fCurrentElement . prefix = fElementQNamePartsStack [ fElementDepth ] . prefix ; fCurrentElementEntity = fElementEntityStack [ fElementDepth ] ; fCurrentElementIndex = fElementIndexStack [ fElementDepth ] ; fCurrentContentSpecType = fContentSpecTypeStack [ fElementDepth ] ; fValidating = fValidationFlagStack [ fElementDepth ] == 0 ? true : false ; fCurrentScope = fScopeStack [ fElementDepth ] ; if ( fGrammarNameSpaceIndex != fGrammarNameSpaceIndexStack [ fElementDepth ] ) { fGrammarNameSpaceIndex = fGrammarNameSpaceIndexStack [ fElementDepth ] ; if ( fValidating && fGrammarIsSchemaGrammar ) if ( ! switchGrammar ( fGrammarNameSpaceIndex ) ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Grammar with uri : " + fStringPool . toString ( fGrammarNameSpaceIndex ) + " , can not found" ) ; } } if ( fValidating ) { fBufferDatatype = false ; } fInElementContent = ( fCurrentContentSpecType == XMLElementDecl . TYPE_CHILDREN ) ; } public void callStartCDATA ( ) throws Exception { fDocumentHandler . startCDATA ( ) ; } public void callEndCDATA ( ) throws Exception { fDocumentHandler . endCDATA ( ) ; } public void callCharacters ( int ch ) throws Exception { if ( fCharRefData == null ) { fCharRefData = new char [ 2 ] ; } int count = ( ch < 0x10000 ) ? 1 : 2 ; if ( count == 1 ) { fCharRefData [ 0 ] = ( char ) ch ; } else { fCharRefData [ 0 ] = ( char ) ( ( ( ch - 0x00010000 ) > > 10 ) + 0xd800 ) ; fCharRefData [ 1 ] = ( char ) ( ( ( ch - 0x00010000 ) & 0x3ff ) + 0xdc00 ) ; } if ( fValidating && ( fInElementContent || fCurrentContentSpecType == XMLElementDecl . TYPE_EMPTY ) ) { charDataInContent ( ) ; } if ( fSendCharDataAsCharArray ) { fDocumentHandler . characters ( fCharRefData , 0 , count ) ; } else { int index = fStringPool . addString ( new String ( fCharRefData , 0 , count ) ) ; fDocumentHandler . characters ( index ) ; } } public void callProcessingInstruction ( int target , int data ) throws Exception { fDocumentHandler . processingInstruction ( target , data ) ; } public void callComment ( int comment ) throws Exception { fDocumentHandler . comment ( comment ) ; } public void startNamespaceDeclScope ( int prefix , int uri ) throws Exception { fDocumentHandler . startNamespaceDeclScope ( prefix , uri ) ; } public void endNamespaceDeclScope ( int prefix ) throws Exception { fDocumentHandler . endNamespaceDeclScope ( prefix ) ; } public void setRootElementType ( QName rootElement ) { fRootElement . setValues ( rootElement ) ; } private boolean getElementDeclIsExternal ( int elementIndex ) { if ( fGrammarIsDTDGrammar ) { return ( ( DTDGrammar ) fGrammar ) . getElementDeclIsExternal ( elementIndex ) ; } return false ; } public int getContentSpecType ( int elementIndex ) { int contentSpecType = - 1 ; if ( elementIndex > - 1 ) { if ( fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ) { contentSpecType = fTempElementDecl . type ; } } return contentSpecType ; } public int getContentSpecHandle ( int elementIndex ) { int contentSpecHandle = - 1 ; if ( elementIndex > - 1 ) { if ( fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ) { contentSpecHandle = fTempElementDecl . contentSpecIndex ; } } return contentSpecHandle ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode ) throws Exception { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , null , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode , int stringIndex1 ) throws Exception { Object [ ] args = { fStringPool . toString ( stringIndex1 ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode , String string1 ) throws Exception { Object [ ] args = { string1 } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode , int stringIndex1 , int stringIndex2 ) throws Exception { Object [ ] args = { fStringPool . toString ( stringIndex1 ) , fStringPool . toString ( stringIndex2 ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode , String string1 , String string2 ) throws Exception { Object [ ] args = { string1 , string2 } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode , String string1 , String string2 , String string3 ) throws Exception { Object [ ] args = { string1 , string2 , string3 } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected int whatCanGoHere ( int elementIndex , boolean fullyValid , InsertableElementsInfo info ) throws Exception { if ( info . insertAt > info . childCount || info . curChildren == null || info . childCount < 1 || info . childCount > info . curChildren . length ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . VAL_WCGHI , 0 , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } int retVal = 0 ; try { final XMLContentModel cmElem = getElementContentModel ( elementIndex ) ; retVal = cmElem . whatCanGoHere ( fullyValid , info ) ; } catch ( CMException excToCatch ) { int majorCode = excToCatch . getErrorCode ( ) ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , majorCode , 0 , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; throw excToCatch ; } return retVal ; } protected boolean getAttDefIsExternal ( QName element , QName attribute ) { int attDefIndex = getAttDef ( element , attribute ) ; if ( fGrammarIsDTDGrammar ) { return ( ( DTDGrammar ) fGrammar ) . getAttributeDeclIsExternal ( attDefIndex ) ; } return false ; } private boolean usingStandaloneReader ( ) { return fStandaloneReader == - 1 || fEntityHandler . getReaderId ( ) == fStandaloneReader ; } private LocatorImpl getLocatorImpl ( LocatorImpl fillin ) { Locator here = fErrorReporter . getLocator ( ) ; if ( fillin == null ) return new LocatorImpl ( here ) ; fillin . setPublicId ( here . getPublicId ( ) ) ; fillin . setSystemId ( here . getSystemId ( ) ) ; fillin . setLineNumber ( here . getLineNumber ( ) ) ; fillin . setColumnNumber ( here . getColumnNumber ( ) ) ; return fillin ; } private void poolReset ( ) { try { this . fValID . validate ( null , this . fResetID ) ; this . fValIDRef . validate ( null , this . fResetIDRef ) ; this . fValIDRefs . validate ( null , this . fResetIDRef ) ; } catch ( InvalidDatatypeValueException ex ) { System . err . println ( "Error re-Initializing: ID,IDRef,IDRefs pools" ) ; } } private void resetCommon ( StringPool stringPool ) throws Exception { fStringPool = stringPool ; fValidating = fValidationEnabled ; fValidationEnabledByDynamic = false ; fDynamicDisabledByValidation = false ; poolReset ( ) ; fCalledStartDocument = false ; fStandaloneReader = - 1 ; fElementChildrenLength = 0 ; fElementDepth = - 1 ; fSeenRootElement = false ; fSeenDoctypeDecl = false ; fNamespacesScope = null ; fNamespacesPrefix = - 1 ; fRootElement . clear ( ) ; fAttrListHandle = - 1 ; fCheckedForSchema = false ; fCurrentScope = TOP_LEVEL_SCOPE ; fCurrentSchemaURI = - 1 ; fEmptyURI = - 1 ; fXsiPrefix = - 1 ; fXsiTypeValidator = null ; fGrammar = null ; fGrammarNameSpaceIndex = - 1 ; if ( fGrammarResolver != null ) { fGrammarResolver . clearGrammarResolver ( ) ; } fGrammarIsDTDGrammar = false ; fGrammarIsSchemaGrammar = false ; init ( ) ; } private void init ( ) { fEmptyURI = fStringPool . addSymbol ( "" ) ; fXsiURI = fStringPool . addSymbol ( SchemaSymbols . URI_XSI ) ; fEMPTYSymbol = fStringPool . addSymbol ( "EMPTY" ) ; fANYSymbol = fStringPool . addSymbol ( "ANY" ) ; fMIXEDSymbol = fStringPool . addSymbol ( "MIXED" ) ; fCHILDRENSymbol = fStringPool . addSymbol ( "CHILDREN" ) ; fCDATASymbol = fStringPool . addSymbol ( "CDATA" ) ; fIDSymbol = fStringPool . addSymbol ( "ID" ) ; fIDREFSymbol = fStringPool . addSymbol ( "IDREF" ) ; fIDREFSSymbol = fStringPool . addSymbol ( "IDREFS" ) ; fENTITYSymbol = fStringPool . addSymbol ( "ENTITY" ) ; fENTITIESSymbol = fStringPool . addSymbol ( "ENTITIES" ) ; fNMTOKENSymbol = fStringPool . addSymbol ( "NMTOKEN" ) ; fNMTOKENSSymbol = fStringPool . addSymbol ( "NMTOKENS" ) ; fNOTATIONSymbol = fStringPool . addSymbol ( "NOTATION" ) ; fENUMERATIONSymbol = fStringPool . addSymbol ( "ENUMERATION" ) ; fREQUIREDSymbol = fStringPool . addSymbol ( "#REQUIRED" ) ; fFIXEDSymbol = fStringPool . addSymbol ( "#FIXED" ) ; fDATATYPESymbol = fStringPool . addSymbol ( "<<datatype>>" ) ; fEpsilonIndex = fStringPool . addSymbol ( "<<CMNODE_EPSILON>>" ) ; fXMLLang = fStringPool . addSymbol ( "xml:lang" ) ; try { Object [ ] packageArgsEntityVal = { ( Object ) this . fEntityHandler , ( Object ) this . fStringPool } ; fValidateENTITYMsg . setDatatypeObject ( ( Object ) packageArgsEntityVal ) ; fValENTITIES . validate ( null , fValidateENTITYMsg ) ; fValENTITY . validate ( null , fValidateENTITYMsg ) ; } catch ( InvalidDatatypeValueException ex ) { System . err . println ( "Error: " + ex . getLocalizedMessage ( ) ) ; } } private int addDefaultAttributes ( int elementIndex , XMLAttrList attrList , int attrIndex , boolean validationEnabled , boolean standalone ) throws Exception { fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ; int elementNameIndex = fTempElementDecl . name . localpart ; int attlistIndex = fGrammar . getFirstAttributeDeclIndex ( elementIndex ) ; int firstCheck = attrIndex ; int lastCheck = - 1 ; while ( attlistIndex != - 1 ) { fGrammar . getAttributeDecl ( attlistIndex , fTempAttDecl ) ; int attPrefix = fTempAttDecl . name . prefix ; int attName = fTempAttDecl . name . localpart ; int attType = attributeTypeName ( fTempAttDecl ) ; int attDefType = fTempAttDecl . defaultType ; int attValue = - 1 ; if ( fTempAttDecl . defaultValue != null ) { attValue = fStringPool . addSymbol ( fTempAttDecl . defaultValue ) ; } boolean specified = false ; boolean required = attDefType == XMLAttributeDecl . DEFAULT_TYPE_REQUIRED ; if ( firstCheck != - 1 ) { boolean cdata = attType == fCDATASymbol ; if ( ! cdata || required || attValue != - 1 ) { int i = attrList . getFirstAttr ( firstCheck ) ; while ( i != - 1 && ( lastCheck == - 1 || i <= lastCheck ) ) { if ( ( fGrammarIsDTDGrammar && ( attrList . getAttrName ( i ) == fTempAttDecl . name . rawname ) ) || ( fStringPool . equalNames ( attrList . getAttrLocalpart ( i ) , attName ) && fStringPool . equalNames ( attrList . getAttrURI ( i ) , fTempAttDecl . name . uri ) ) ) { if ( validationEnabled && attDefType == XMLAttributeDecl . DEFAULT_TYPE_FIXED ) { int alistValue = attrList . getAttValue ( i ) ; if ( alistValue != attValue && ! fStringPool . toString ( alistValue ) . equals ( fStringPool . toString ( attValue ) ) ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) , fStringPool . toString ( alistValue ) , fStringPool . toString ( attValue ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_FIXED_ATTVALUE_INVALID , XMLMessages . VC_FIXED_ATTRIBUTE_DEFAULT , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } specified = true ; break ; } i = attrList . getNextAttr ( i ) ; } } } if ( ! specified ) { if ( required ) { if ( validationEnabled ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_REQUIRED_ATTRIBUTE_NOT_SPECIFIED , XMLMessages . VC_REQUIRED_ATTRIBUTE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } else if ( attValue != - 1 ) { if ( validationEnabled && standalone ) if ( fGrammarIsDTDGrammar && ( ( DTDGrammar ) fGrammar ) . getAttributeDeclIsExternal ( attlistIndex ) ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_DEFAULTED_ATTRIBUTE_NOT_SPECIFIED , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } if ( attType == fIDREFSymbol ) { this . fValIDRef . validate ( fStringPool . toString ( attValue ) , this . fStoreIDRef ) ; } else if ( attType == fIDREFSSymbol ) { this . fValIDRefs . validate ( fStringPool . toString ( attValue ) , this . fStoreIDRef ) ; } if ( attrIndex == - 1 ) { attrIndex = attrList . startAttrList ( ) ; } fTempQName . setValues ( attPrefix , attName , attName , fTempAttDecl . name . uri ) ; int newAttr = attrList . addAttr ( fTempQName , attValue , attType , false , false ) ; if ( lastCheck == - 1 ) { lastCheck = newAttr ; } } } attlistIndex = fGrammar . getNextAttributeDeclIndex ( attlistIndex ) ; } return attrIndex ; } private int addDTDDefaultAttributes ( QName element , XMLAttrList attrList , int attrIndex , boolean validationEnabled , boolean standalone ) throws Exception { int elementIndex = fGrammar . getElementDeclIndex ( element , - 1 ) ; if ( elementIndex == - 1 ) { return attrIndex ; } fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ; int elementNameIndex = fTempElementDecl . name . rawname ; int attlistIndex = fGrammar . getFirstAttributeDeclIndex ( elementIndex ) ; int firstCheck = attrIndex ; int lastCheck = - 1 ; while ( attlistIndex != - 1 ) { fGrammar . getAttributeDecl ( attlistIndex , fTempAttDecl ) ; int attPrefix = fTempAttDecl . name . prefix ; int attName = fTempAttDecl . name . rawname ; int attLocalpart = fTempAttDecl . name . localpart ; int attType = attributeTypeName ( fTempAttDecl ) ; int attDefType = fTempAttDecl . defaultType ; int attValue = - 1 ; if ( fTempAttDecl . defaultValue != null ) { attValue = fStringPool . addSymbol ( fTempAttDecl . defaultValue ) ; } boolean specified = false ; boolean required = attDefType == XMLAttributeDecl . DEFAULT_TYPE_REQUIRED ; if ( firstCheck != - 1 ) { boolean cdata = attType == fCDATASymbol ; if ( ! cdata || required || attValue != - 1 ) { int i = attrList . getFirstAttr ( firstCheck ) ; while ( i != - 1 && ( lastCheck == - 1 || i <= lastCheck ) ) { if ( attrList . getAttrName ( i ) == fTempAttDecl . name . rawname ) { if ( validationEnabled && attDefType == XMLAttributeDecl . DEFAULT_TYPE_FIXED ) { int alistValue = attrList . getAttValue ( i ) ; if ( alistValue != attValue && ! fStringPool . toString ( alistValue ) . equals ( fStringPool . toString ( attValue ) ) ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) , fStringPool . toString ( alistValue ) , fStringPool . toString ( attValue ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_FIXED_ATTVALUE_INVALID , XMLMessages . VC_FIXED_ATTRIBUTE_DEFAULT , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } specified = true ; break ; } i = attrList . getNextAttr ( i ) ; } } } if ( ! specified ) { if ( required ) { if ( validationEnabled ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_REQUIRED_ATTRIBUTE_NOT_SPECIFIED , XMLMessages . VC_REQUIRED_ATTRIBUTE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } else if ( attValue != - 1 ) { if ( validationEnabled && standalone ) if ( fGrammarIsDTDGrammar && ( ( DTDGrammar ) fGrammar ) . getAttributeDeclIsExternal ( attlistIndex ) ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_DEFAULTED_ATTRIBUTE_NOT_SPECIFIED , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } if ( attType == fIDREFSymbol ) { this . fValIDRef . validate ( fStringPool . toString ( attValue ) , this . fStoreIDRef ) ; } else if ( attType == fIDREFSSymbol ) { this . fValIDRefs . validate ( fStringPool . toString ( attValue ) , this . fStoreIDRef ) ; } if ( attrIndex == - 1 ) { attrIndex = attrList . startAttrList ( ) ; } fTempQName . setValues ( attPrefix , attLocalpart , attName , fTempAttDecl . name . uri ) ; int newAttr = attrList . addAttr ( fTempQName , attValue , attType , false , false ) ; if ( lastCheck == - 1 ) { lastCheck = newAttr ; } } } attlistIndex = fGrammar . getNextAttributeDeclIndex ( attlistIndex ) ; } return attrIndex ; } private XMLContentModel getElementContentModel ( int elementIndex ) throws CMException { XMLContentModel contentModel = null ; if ( elementIndex > - 1 ) { if ( fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ) { contentModel = fGrammar . getElementContentModel ( elementIndex ) ; } } return contentModel ; } private int getAttDef ( QName element , QName attribute ) { if ( fGrammar != null ) { int scope = fCurrentScope ; if ( element . uri > - 1 ) { scope = TOP_LEVEL_SCOPE ; } int elementIndex = fGrammar . getElementDeclIndex ( element , scope ) ; if ( elementIndex == - 1 ) { return - 1 ; } int attDefIndex = fGrammar . getFirstAttributeDeclIndex ( elementIndex ) ; while ( attDefIndex != - 1 ) { fGrammar . getAttributeDecl ( attDefIndex , fTempAttributeDecl ) ; if ( fTempAttributeDecl . name . localpart == attribute . localpart && fTempAttributeDecl . name . uri == attribute . uri ) { return attDefIndex ; } attDefIndex = fGrammar . getNextAttributeDeclIndex ( attDefIndex ) ; } } return - 1 ; } private int getAttDefByElementIndex ( int elementIndex , QName attribute ) { if ( fGrammar != null && elementIndex > - 1 ) { if ( elementIndex == - 1 ) { return - 1 ; } int attDefIndex = fGrammar . getFirstAttributeDeclIndex ( elementIndex ) ; while ( attDefIndex != - 1 ) { fGrammar . getAttributeDecl ( attDefIndex , fTempAttDecl ) ; if ( fGrammarIsDTDGrammar ) { if ( fTempAttDecl . name . rawname == attribute . rawname ) return attDefIndex ; } else if ( fTempAttDecl . name . localpart == attribute . localpart && fTempAttDecl . name . uri == attribute . uri ) { return attDefIndex ; } if ( fGrammarIsSchemaGrammar ) { if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_ANY ) { return attDefIndex ; } else if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_LOCAL ) { if ( attribute . uri == - 1 ) { return attDefIndex ; } } else if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_OTHER ) { if ( attribute . uri != fTempAttDecl . name . uri ) { return attDefIndex ; } } else if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_LIST ) { if ( fStringPool . stringInList ( fTempAttDecl . enumeration , attribute . uri ) ) { return attDefIndex ; } } } attDefIndex = fGrammar . getNextAttributeDeclIndex ( attDefIndex ) ; } } return - 1 ; } private void rootElementSpecified ( QName rootElement ) throws Exception { if ( fLoadDTDGrammar ) if ( fGrammar == null ) { fGrammar = fGrammarResolver . getGrammar ( "" ) ; if ( fGrammar == null && DEBUG_SCHEMA_VALIDATION ) { System . out . println ( "Oops! no grammar is found for validation" ) ; } if ( fDynamicValidation && fGrammar == null ) { fValidating = false ; } if ( fGrammar != null ) { if ( fGrammar instanceof DTDGrammar ) { fGrammarIsDTDGrammar = true ; fGrammarIsSchemaGrammar = false ; } else if ( fGrammar instanceof SchemaGrammar ) { fGrammarIsSchemaGrammar = true ; fGrammarIsDTDGrammar = false ; } fGrammarNameSpaceIndex = fEmptyURI ; } } if ( fValidating ) { if ( fGrammarIsDTDGrammar && ( ( DTDGrammar ) fGrammar ) . getRootElementQName ( fRootElement ) ) { String root1 = fStringPool . toString ( fRootElement . rawname ) ; String root2 = fStringPool . toString ( rootElement . rawname ) ; if ( ! root1 . equals ( root2 ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ROOT_ELEMENT_TYPE , XMLMessages . VC_ROOT_ELEMENT_TYPE , fRootElement . rawname , rootElement . rawname ) ; } } } if ( fNamespacesEnabled ) { if ( fNamespacesScope == null ) { fNamespacesScope = new NamespacesScope ( this ) ; fNamespacesPrefix = fStringPool . addSymbol ( "xmlns" ) ; fNamespacesScope . setNamespaceForPrefix ( fNamespacesPrefix , - 1 ) ; int xmlSymbol = fStringPool . addSymbol ( "xml" ) ; int xmlNamespace = fStringPool . addSymbol ( "http://www.w3.org/XML/1998/namespace" ) ; fNamespacesScope . setNamespaceForPrefix ( xmlSymbol , xmlNamespace ) ; } } } private boolean switchGrammar ( int newGrammarNameSpaceIndex ) throws Exception { Grammar tempGrammar = fGrammarResolver . getGrammar ( fStringPool . toString ( newGrammarNameSpaceIndex ) ) ; if ( tempGrammar == null ) { tempGrammar = fGrammarResolver . getGrammar ( "" ) ; } if ( tempGrammar == null ) { return false ; } else { fGrammar = tempGrammar ; if ( fGrammar instanceof DTDGrammar ) { fGrammarIsDTDGrammar = true ; fGrammarIsSchemaGrammar = false ; } else if ( fGrammar instanceof SchemaGrammar ) { fGrammarIsSchemaGrammar = true ; fGrammarIsDTDGrammar = false ; } return true ; } } private void bindNamespacesToElementAndAttributes ( QName element , XMLAttrList attrList ) throws Exception { fNamespacesScope . increaseDepth ( ) ; Hashtable locationUriPairs = null ; if ( fAttrListHandle != - 1 ) { int index = attrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { int attName = attrList . getAttrName ( index ) ; int attPrefix = attrList . getAttrPrefix ( index ) ; if ( fStringPool . equalNames ( attName , fXMLLang ) ) { } else if ( fStringPool . equalNames ( attName , fNamespacesPrefix ) ) { int uri = fStringPool . addSymbol ( attrList . getAttValue ( index ) ) ; fNamespacesScope . setNamespaceForPrefix ( StringPool . EMPTY_STRING , uri ) ; } else { if ( attPrefix == fNamespacesPrefix ) { int nsPrefix = attrList . getAttrLocalpart ( index ) ; int uri = fStringPool . addSymbol ( attrList . getAttValue ( index ) ) ; fNamespacesScope . setNamespaceForPrefix ( nsPrefix , uri ) ; if ( fValidating && fSchemaValidation ) { boolean seeXsi = false ; String attrValue = fStringPool . toString ( attrList . getAttValue ( index ) ) ; if ( attrValue . equals ( SchemaSymbols . URI_XSI ) ) { fXsiPrefix = nsPrefix ; seeXsi = true ; } if ( ! seeXsi ) { } } } } index = attrList . getNextAttr ( index ) ; } if ( fValidating && fSchemaValidation ) { fXsiTypeAttValue = - 1 ; index = attrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { int attName = attrList . getAttrName ( index ) ; int attPrefix = attrList . getAttrPrefix ( index ) ; if ( fStringPool . equalNames ( attName , fNamespacesPrefix ) ) { } else { if ( DEBUG_SCHEMA_VALIDATION ) { System . out . println ( "deal with XSI" ) ; System . out . println ( "before find XSI: " + fStringPool . toString ( attPrefix ) + "," + fStringPool . toString ( fXsiPrefix ) ) ; } if ( fXsiPrefix != - 1 && attPrefix == fXsiPrefix ) { if ( DEBUG_SCHEMA_VALIDATION ) { System . out . println ( "find XSI: " + fStringPool . toString ( attPrefix ) + "," + fStringPool . toString ( attName ) ) ; } int localpart = attrList . getAttrLocalpart ( index ) ; if ( localpart == fStringPool . addSymbol ( SchemaSymbols . XSI_SCHEMALOCACTION ) ) { if ( locationUriPairs == null ) { locationUriPairs = new Hashtable ( ) ; } parseSchemaLocation ( fStringPool . toString ( attrList . getAttValue ( index ) ) , locationUriPairs ) ; } else if ( localpart == fStringPool . addSymbol ( SchemaSymbols . XSI_NONAMESPACESCHEMALOCACTION ) ) { if ( locationUriPairs == null ) { locationUriPairs = new Hashtable ( ) ; } locationUriPairs . put ( fStringPool . toString ( attrList . getAttValue ( index ) ) , "" ) ; if ( fNamespacesScope != null ) { fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( "" ) , fStringPool . addSymbol ( "" ) ) ; } } else if ( localpart == fStringPool . addSymbol ( SchemaSymbols . XSI_TYPE ) ) { fXsiTypeAttValue = attrList . getAttValue ( index ) ; } } } index = attrList . getNextAttr ( index ) ; } if ( locationUriPairs != null ) { Enumeration locations = locationUriPairs . keys ( ) ; while ( locations . hasMoreElements ( ) ) { String loc = ( String ) locations . nextElement ( ) ; String uri = ( String ) locationUriPairs . get ( loc ) ; resolveSchemaGrammar ( loc , uri ) ; } } } } int prefix = element . prefix != - 1 ? element . prefix : 0 ; int uri = fNamespacesScope . getNamespaceForPrefix ( prefix ) ; if ( element . prefix != - 1 || uri != - 1 ) { element . uri = uri ; if ( element . uri == - 1 ) { Object [ ] args = { fStringPool . toString ( element . prefix ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XMLNS_DOMAIN , XMLMessages . MSG_PREFIX_DECLARED , XMLMessages . NC_PREFIX_DECLARED , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } if ( fAttrListHandle != - 1 ) { int index = attrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { int attName = attrList . getAttrName ( index ) ; if ( ! fStringPool . equalNames ( attName , fNamespacesPrefix ) ) { int attPrefix = attrList . getAttrPrefix ( index ) ; if ( attPrefix != fNamespacesPrefix ) { if ( attPrefix != - 1 ) { int attrUri = fNamespacesScope . getNamespaceForPrefix ( attPrefix ) ; if ( attrUri == - 1 ) { Object [ ] args = { fStringPool . toString ( attPrefix ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XMLNS_DOMAIN , XMLMessages . MSG_PREFIX_DECLARED , XMLMessages . NC_PREFIX_DECLARED , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } attrList . setAttrURI ( index , attrUri ) ; } } } index = attrList . getNextAttr ( index ) ; } } } void parseSchemaLocation ( String schemaLocationStr , Hashtable locationUriPairs ) { if ( locationUriPairs != null ) { StringTokenizer tokenizer = new StringTokenizer ( schemaLocationStr , " \n\t\r" , false ) ; int tokenTotal = tokenizer . countTokens ( ) ; if ( tokenTotal % 2 != 0 ) { } else { while ( tokenizer . hasMoreTokens ( ) ) { String uri = tokenizer . nextToken ( ) ; String location = tokenizer . nextToken ( ) ; locationUriPairs . put ( location , uri ) ; } } } else { } } private void resolveSchemaGrammar ( String loc , String uri ) throws Exception { SchemaGrammar grammar = ( SchemaGrammar ) fGrammarResolver . getGrammar ( uri ) ; if ( grammar == null ) { DOMParser parser = new DOMParser ( ) ; parser . setEntityResolver ( new Resolver ( fEntityHandler ) ) ; parser . setErrorHandler ( new ErrorHandler ( ) ) ; try { parser . setFeature ( "http://xml.org/sax/features/validation" , false ) ; parser . setFeature ( "http://xml.org/sax/features/namespaces" , true ) ; parser . setFeature ( "http://apache.org/xml/features/dom/defer-node-expansion" , false ) ; } catch ( org . xml . sax . SAXNotRecognizedException e ) { e . printStackTrace ( ) ; } catch ( org . xml . sax . SAXNotSupportedException e ) { e . printStackTrace ( ) ; } InputSource source = null ; EntityResolver currentER = parser . getEntityResolver ( ) ; if ( currentER != null ) { source = currentER . resolveEntity ( "" , loc ) ; } if ( source == null ) { loc = fEntityHandler . expandSystemId ( loc ) ; source = new InputSource ( loc ) ; } try { parser . parse ( source ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( SAXException e ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , e . getMessage ( ) ) ; } Document document = parser . getDocument ( ) ; TraverseSchema tst = null ; try { if ( DEBUG_SCHEMA_VALIDATION ) { System . out . println ( "I am geting the Schema Document" ) ; } Element root = document . getDocumentElement ( ) ; if ( root == null ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Can't get back Schema document's root element :" + loc ) ; } else { if ( uri == null || ! uri . equals ( root . getAttribute ( SchemaSymbols . ATT_TARGETNAMESPACE ) ) ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Schema in " + loc + " has a different target namespace " + "from the one specified in the instance document :" + uri ) ; } grammar = new SchemaGrammar ( ) ; grammar . setGrammarDocument ( document ) ; tst = new TraverseSchema ( root , fStringPool , ( SchemaGrammar ) grammar , fGrammarResolver , fErrorReporter , source . getSystemId ( ) ) ; fGrammarResolver . putGrammar ( document . getDocumentElement ( ) . getAttribute ( "targetNamespace" ) , grammar ) ; } } catch ( Exception e ) { e . printStackTrace ( System . err ) ; } } } private void resolveSchemaGrammar ( String uri ) throws Exception { resolveSchemaGrammar ( uri , uri ) ; } static class Resolver implements EntityResolver { private static final String SYSTEM [ ] = { "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/structures.dtd" , "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/datatypes.dtd" , "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/versionInfo.ent" , } ; private static final String PATH [ ] = { "structures.dtd" , "datatypes.dtd" , "versionInfo.ent" , } ; private DefaultEntityHandler fEntityHandler ; public Resolver ( DefaultEntityHandler handler ) { fEntityHandler = handler ; } public InputSource resolveEntity ( String publicId , String systemId ) throws IOException , SAXException { for ( int i = 0 ; i < SYSTEM . length ; i ++ ) { if ( systemId . equals ( SYSTEM [ i ] ) ) { InputSource source = new InputSource ( getClass ( ) . getResourceAsStream ( PATH [ i ] ) ) ; source . setPublicId ( publicId ) ; source . setSystemId ( systemId ) ; return source ; } } EntityResolver resolver = fEntityHandler . getEntityResolver ( ) ; if ( resolver != null ) { InputSource source = resolver . resolveEntity ( publicId , systemId ) ; if ( source != null ) { return source ; } } return new InputSource ( fEntityHandler . expandSystemId ( systemId ) ) ; } } static class ErrorHandler implements org . xml . sax . ErrorHandler { public void warning ( SAXParseException ex ) { System . err . println ( "[Warning] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; } public void error ( SAXParseException ex ) { System . err . println ( "[Error] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; } public void fatalError ( SAXParseException ex ) { System . err . println ( "[Fatal Error] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; } private String getLocationString ( SAXParseException ex ) { StringBuffer str = new StringBuffer ( ) ; String systemId_ = ex . getSystemId ( ) ; if ( systemId_ != null ) { int index = systemId_ . lastIndexOf ( '/' ) ; if ( index != - 1 ) systemId_ = systemId_ . substring ( index + 1 ) ; str . append ( systemId_ ) ; } str . append ( ':' ) ; str . append ( ex . getLineNumber ( ) ) ; str . append ( ':' ) ; str . append ( ex . getColumnNumber ( ) ) ; return str . toString ( ) ; } } private int attributeTypeName ( XMLAttributeDecl attrDecl ) { switch ( attrDecl . type ) { case XMLAttributeDecl . TYPE_ENTITY : { return attrDecl . list ? fENTITIESSymbol : fENTITYSymbol ; } case XMLAttributeDecl . TYPE_ENUMERATION : { String enumeration = fStringPool . stringListAsString ( attrDecl . enumeration ) ; return fStringPool . addString ( enumeration ) ; } case XMLAttributeDecl . TYPE_ID : { return fIDSymbol ; } case XMLAttributeDecl . TYPE_IDREF : { return attrDecl . list ? fIDREFSSymbol : fIDREFSymbol ; } case XMLAttributeDecl . TYPE_NMTOKEN : { return attrDecl . list ? fNMTOKENSSymbol : fNMTOKENSSymbol ; } case XMLAttributeDecl . TYPE_NOTATION : { return fNOTATIONSymbol ; } } return fCDATASymbol ; } private void validateElementAndAttributes ( QName element , XMLAttrList attrList ) throws Exception { if ( ( fElementDepth >= 0 && fValidationFlagStack [ fElementDepth ] != 0 ) || ( fGrammar == null && ! fValidating && ! fNamespacesEnabled ) ) { fCurrentElementIndex = - 1 ; fCurrentContentSpecType = - 1 ; fInElementContent = false ; if ( fAttrListHandle != - 1 ) { fAttrList . endAttrList ( ) ; int index = fAttrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { if ( fStringPool . equalNames ( fAttrList . getAttrName ( index ) , fXMLLang ) ) { fDocumentScanner . checkXMLLangAttributeValue ( fAttrList . getAttValue ( index ) ) ; break ; } index = fAttrList . getNextAttr ( index ) ; } } return ; } int elementIndex = - 1 ; int contentSpecType = - 1 ; boolean skipThisOne = false ; boolean laxThisOne = false ; if ( fGrammarIsSchemaGrammar && fContentLeafStack [ fElementDepth ] != null ) { ContentLeafNameTypeVector cv = fContentLeafStack [ fElementDepth ] ; QName [ ] fElemMap = cv . leafNames ; for ( int i = 0 ; i < cv . leafCount ; i ++ ) { int type = cv . leafTypes [ i ] ; if ( type == XMLContentSpec . CONTENTSPECNODE_LEAF ) { if ( fElemMap [ i ] . uri == element . uri && fElemMap [ i ] . localpart == element . localpart ) break ; } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY ) { int uri = fElemMap [ i ] . uri ; if ( uri == - 1 || uri == element . uri ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL ) { if ( element . uri == - 1 ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ) { if ( fElemMap [ i ] . uri != element . uri ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_SKIP ) { int uri = fElemMap [ i ] . uri ; if ( uri == - 1 || uri == element . uri ) { skipThisOne = true ; break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL_SKIP ) { if ( element . uri == - 1 ) { skipThisOne = true ; break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER_SKIP ) { if ( fElemMap [ i ] . uri != element . uri ) { skipThisOne = true ; break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LAX ) { int uri = fElemMap [ i ] . uri ; if ( uri == - 1 || uri == element . uri ) { laxThisOne = true ; break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL_LAX ) { if ( element . uri == - 1 ) { laxThisOne = true ; break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER_LAX ) { if ( fElemMap [ i ] . uri != element . uri ) { laxThisOne = true ; break ; } } } } if ( skipThisOne ) { fNeedValidationOff = true ; } else { if ( fNamespacesEnabled && fValidating && element . uri != fGrammarNameSpaceIndex && element . uri != - 1 ) { fGrammarNameSpaceIndex = element . uri ; boolean success = switchGrammar ( fGrammarNameSpaceIndex ) ; if ( ! success && ! laxThisOne ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Grammar with uri : " + fStringPool . toString ( fGrammarNameSpaceIndex ) + " , can not found" ) ; } } if ( fGrammar != null ) { if ( DEBUG_SCHEMA_VALIDATION ) { System . out . println ( "*******Lookup element: uri: " + fStringPool . toString ( element . uri ) + "localpart: '" + fStringPool . toString ( element . localpart ) + "' and scope : " + fCurrentScope + "\n" ) ; } elementIndex = fGrammar . getElementDeclIndex ( element , fCurrentScope ) ; if ( elementIndex == - 1 ) { elementIndex = fGrammar . getElementDeclIndex ( element , TOP_LEVEL_SCOPE ) ; } if ( elementIndex == - 1 ) { if ( fGrammarIsSchemaGrammar && fCurrentElementIndex != - 1 ) { TraverseSchema . ComplexTypeInfo baseTypeInfo = null ; baseTypeInfo = ( ( SchemaGrammar ) fGrammar ) . getElementComplexTypeInfo ( fCurrentElementIndex ) ; while ( baseTypeInfo != null ) { elementIndex = fGrammar . getElementDeclIndex ( element , baseTypeInfo . scopeDefined ) ; if ( elementIndex > - 1 ) { break ; } baseTypeInfo = baseTypeInfo . baseComplexTypeInfo ; } } if ( elementIndex == - 1 ) { if ( laxThisOne ) { fNeedValidationOff = true ; } else if ( DEBUG_SCHEMA_VALIDATION ) System . out . println ( "!!! can not find elementDecl in the grammar, " + " the element localpart: " + element . localpart + "[" + fStringPool . toString ( element . localpart ) + "]" + " the element uri: " + element . uri + "[" + fStringPool . toString ( element . uri ) + "]" + " and the current enclosing scope: " + fCurrentScope ) ; } } if ( DEBUG_SCHEMA_VALIDATION ) { fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ; System . out . println ( "elementIndex: " + elementIndex + " \n and itsName : '" + fStringPool . toString ( fTempElementDecl . name . localpart ) + "' \n its ContentType:" + fTempElementDecl . type + "\n its ContentSpecIndex : " + fTempElementDecl . contentSpecIndex + "\n" + " and the current enclosing scope: " + fCurrentScope ) ; } } contentSpecType = getContentSpecType ( elementIndex ) ; if ( fGrammarIsSchemaGrammar && elementIndex != - 1 ) { if ( fXsiTypeAttValue > - 1 ) { String xsiType = fStringPool . toString ( fXsiTypeAttValue ) ; int colonP = xsiType . indexOf ( ":" ) ; String prefix = "" ; String localpart = xsiType ; if ( colonP > - 1 ) { prefix = xsiType . substring ( 0 , colonP ) ; localpart = xsiType . substring ( colonP + 1 ) ; } String uri = "" ; int uriIndex = - 1 ; if ( fNamespacesScope != null ) { uriIndex = fNamespacesScope . getNamespaceForPrefix ( fStringPool . addSymbol ( prefix ) ) ; if ( uriIndex > - 1 ) { uri = fStringPool . toString ( uriIndex ) ; if ( uriIndex != fGrammarNameSpaceIndex ) { fGrammarNameSpaceIndex = fCurrentSchemaURI = uriIndex ; boolean success = switchGrammar ( fCurrentSchemaURI ) ; if ( ! success && ! fNeedValidationOff ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Grammar with uri : " + fStringPool . toString ( fCurrentSchemaURI ) + " , can not found" ) ; } } } } Hashtable complexRegistry = ( ( SchemaGrammar ) fGrammar ) . getComplexTypeRegistry ( ) ; DatatypeValidatorFactoryImpl dataTypeReg = ( ( SchemaGrammar ) fGrammar ) . getDatatypeRegistry ( ) ; if ( complexRegistry == null || dataTypeReg == null ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , fErrorReporter . getLocator ( ) . getSystemId ( ) + " line" + fErrorReporter . getLocator ( ) . getLineNumber ( ) + ", canot resolve xsi:type = " + xsiType + "  ---2" ) ; } else { TraverseSchema . ComplexTypeInfo typeInfo = ( TraverseSchema . ComplexTypeInfo ) complexRegistry . get ( uri + "," + localpart ) ; if ( typeInfo == null ) { if ( uri . length ( ) == 0 || uri . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) ) { fXsiTypeValidator = dataTypeReg . getDatatypeValidator ( localpart ) ; } else fXsiTypeValidator = dataTypeReg . getDatatypeValidator ( uri + "," + localpart ) ; if ( fXsiTypeValidator == null ) reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "unresolved type : " + uri + "," + localpart + " found  in xsi:type handling" ) ; } else elementIndex = typeInfo . templateElementIndex ; } fXsiTypeAttValue = - 1 ; } fCurrentScope = ( ( SchemaGrammar ) fGrammar ) . getElementDefinedScope ( elementIndex ) ; String anotherSchemaURI = ( ( SchemaGrammar ) fGrammar ) . getElementFromAnotherSchemaURI ( elementIndex ) ; if ( anotherSchemaURI != null ) { if ( contentSpecType != - 1 && contentSpecType != XMLElementDecl . TYPE_SIMPLE && contentSpecType != XMLElementDecl . TYPE_EMPTY ) { TraverseSchema . ComplexTypeInfo typeInfo = ( ( SchemaGrammar ) fGrammar ) . getElementComplexTypeInfo ( elementIndex ) ; if ( typeInfo != null ) { elementIndex = typeInfo . templateElementIndex ; } } fGrammarNameSpaceIndex = fCurrentSchemaURI = fStringPool . addSymbol ( anotherSchemaURI ) ; boolean success = switchGrammar ( fCurrentSchemaURI ) ; if ( ! success && ! fNeedValidationOff ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Grammar with uri : " + fStringPool . toString ( fCurrentSchemaURI ) + " , can not found" ) ; } } } if ( contentSpecType == - 1 && fValidating && ! fNeedValidationOff ) { reportRecoverableXMLError ( XMLMessages . MSG_ELEMENT_NOT_DECLARED , XMLMessages . VC_ELEMENT_VALID , element . rawname ) ; } if ( fGrammar != null && fGrammarIsSchemaGrammar && elementIndex != - 1 ) { fAttrListHandle = addDefaultAttributes ( elementIndex , attrList , fAttrListHandle , fValidating , fStandaloneReader != - 1 ) ; } if ( fAttrListHandle != - 1 ) { fAttrList . endAttrList ( ) ; } if ( DEBUG_PRINT_ATTRIBUTES ) { String elementStr = fStringPool . toString ( element . rawname ) ; System . out . print ( "startElement: <" + elementStr ) ; if ( fAttrListHandle != - 1 ) { int index = attrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { System . out . print ( " " + fStringPool . toString ( attrList . getAttrName ( index ) ) + "=\"" + fStringPool . toString ( attrList . getAttValue ( index ) ) + "\"" ) ; index = attrList . getNextAttr ( index ) ; } } System . out . println ( ">" ) ; } if ( fAttrListHandle != - 1 && ! fNeedValidationOff ) { int index = fAttrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { int attrNameIndex = attrList . getAttrName ( index ) ; if ( fStringPool . equalNames ( attrNameIndex , fXMLLang ) ) { fDocumentScanner . checkXMLLangAttributeValue ( attrList . getAttValue ( index ) ) ; } int _xmlns = fStringPool . addSymbol ( "xmlns" ) ; if ( attrNameIndex != _xmlns && attrList . getAttrPrefix ( index ) != _xmlns ) if ( fGrammar != null ) { fAttrNameLocator = getLocatorImpl ( fAttrNameLocator ) ; fTempQName . setValues ( attrList . getAttrPrefix ( index ) , attrList . getAttrLocalpart ( index ) , attrList . getAttrName ( index ) , attrList . getAttrURI ( index ) ) ; int attDefIndex = getAttDefByElementIndex ( elementIndex , fTempQName ) ; if ( fTempQName . uri != fXsiURI ) if ( attDefIndex == - 1 ) { if ( fValidating ) { Object [ ] args = { fStringPool . toString ( element . rawname ) , fStringPool . toString ( attrList . getAttrName ( index ) ) } ; fErrorReporter . reportError ( fAttrNameLocator , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ATTRIBUTE_NOT_DECLARED , XMLMessages . VC_ATTRIBUTE_VALUE_TYPE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } else { fGrammar . getAttributeDecl ( attDefIndex , fTempAttDecl ) ; int attributeType = attributeTypeName ( fTempAttDecl ) ; attrList . setAttType ( index , attributeType ) ; if ( fValidating ) { if ( fGrammarIsDTDGrammar && ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ENTITY || fTempAttDecl . type == XMLAttributeDecl . TYPE_ENUMERATION || fTempAttDecl . type == XMLAttributeDecl . TYPE_ID || fTempAttDecl . type == XMLAttributeDecl . TYPE_IDREF || fTempAttDecl . type == XMLAttributeDecl . TYPE_NMTOKEN || fTempAttDecl . type == XMLAttributeDecl . TYPE_NOTATION ) ) { validateDTDattribute ( element , attrList . getAttValue ( index ) , fTempAttDecl ) ; } else if ( fGrammarIsSchemaGrammar && ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_ANY || fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_LIST || fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_LOCAL || fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_OTHER ) ) { if ( fTempAttDecl . defaultType == XMLAttributeDecl . PROCESSCONTENTS_SKIP ) { } else if ( fTempAttDecl . defaultType == XMLAttributeDecl . PROCESSCONTENTS_STRICT || fTempAttDecl . defaultType == XMLAttributeDecl . PROCESSCONTENTS_LAX ) { boolean reportError = false ; boolean processContentStrict = fTempAttDecl . defaultType == XMLAttributeDecl . PROCESSCONTENTS_STRICT ; if ( fTempQName . uri == - 1 ) { if ( processContentStrict ) { reportError = true ; } } else { Grammar aGrammar = fGrammarResolver . getGrammar ( fStringPool . toString ( fTempQName . uri ) ) ; if ( aGrammar == null || ! ( aGrammar instanceof SchemaGrammar ) ) { if ( processContentStrict ) { reportError = true ; } } else { SchemaGrammar sGrammar = ( SchemaGrammar ) aGrammar ; Hashtable attRegistry = sGrammar . getAttirubteDeclRegistry ( ) ; if ( attRegistry == null ) { if ( processContentStrict ) { reportError = true ; } } else { XMLAttributeDecl attDecl = ( XMLAttributeDecl ) attRegistry . get ( fStringPool . toString ( fTempQName . localpart ) ) ; if ( attDecl == null ) { if ( processContentStrict ) { reportError = true ; } } else { DatatypeValidator attDV = attDecl . datatypeValidator ; if ( attDV == null ) { if ( processContentStrict ) { reportError = true ; } } else { try { String unTrimValue = fStringPool . toString ( attrList . getAttValue ( index ) ) ; String value = unTrimValue . trim ( ) ; if ( attDecl . type == XMLAttributeDecl . TYPE_ID ) { this . fStoreIDRef . setDatatypeObject ( fValID . validate ( value , null ) ) ; } if ( attDecl . type == XMLAttributeDecl . TYPE_IDREF ) { attDV . validate ( value , this . fStoreIDRef ) ; } else attDV . validate ( unTrimValue , null ) ; } catch ( InvalidDatatypeValueException idve ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , SchemaMessageProvider . SCHEMA_DOMAIN , SchemaMessageProvider . DatatypeError , SchemaMessageProvider . MSG_NONE , new Object [ ] { idve . getMessage ( ) } , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } } } } } if ( reportError ) { Object [ ] args = { fStringPool . toString ( element . rawname ) , "ANY---" + fStringPool . toString ( attrList . getAttrName ( index ) ) } ; fErrorReporter . reportError ( fAttrNameLocator , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ATTRIBUTE_NOT_DECLARED , XMLMessages . VC_ATTRIBUTE_VALUE_TYPE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } } else if ( fTempAttDecl . datatypeValidator == null ) { Object [ ] args = { fStringPool . toString ( element . rawname ) , fStringPool . toString ( attrList . getAttrName ( index ) ) } ; System . out . println ( "[Error] Datatypevalidator for attribute " + fStringPool . toString ( attrList . getAttrName ( index ) ) + " not found in element type " + fStringPool . toString ( element . rawname ) ) ; fErrorReporter . reportError ( fAttrNameLocator , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ATTRIBUTE_NOT_DECLARED , XMLMessages . VC_ATTRIBUTE_VALUE_TYPE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } else { try { String unTrimValue = fStringPool . toString ( attrList . getAttValue ( index ) ) ; String value = unTrimValue . trim ( ) ; if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ID ) { this . fStoreIDRef . setDatatypeObject ( fValID . validate ( value , null ) ) ; } else if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_IDREF ) { fTempAttDecl . datatypeValidator . validate ( value , this . fStoreIDRef ) ; } else { fTempAttDecl . datatypeValidator . validate ( unTrimValue , null ) ; } } catch ( InvalidDatatypeValueException idve ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , SchemaMessageProvider . SCHEMA_DOMAIN , SchemaMessageProvider . DatatypeError , SchemaMessageProvider . MSG_NONE , new Object [ ] { idve . getMessage ( ) } , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } } } } index = fAttrList . getNextAttr ( index ) ; } } } if ( fAttrListHandle != - 1 ) { int index = attrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { int attName = attrList . getAttrName ( index ) ; if ( ! fStringPool . equalNames ( attName , fNamespacesPrefix ) ) { int attPrefix = attrList . getAttrPrefix ( index ) ; if ( attPrefix != fNamespacesPrefix ) { if ( attPrefix != - 1 ) { int uri = fNamespacesScope . getNamespaceForPrefix ( attPrefix ) ; if ( uri == - 1 ) { Object [ ] args = { fStringPool . toString ( attPrefix ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XMLNS_DOMAIN , XMLMessages . MSG_PREFIX_DECLARED , XMLMessages . NC_PREFIX_DECLARED , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } attrList . setAttrURI ( index , uri ) ; } } } index = attrList . getNextAttr ( index ) ; } } fCurrentElementIndex = elementIndex ; fCurrentContentSpecType = contentSpecType ; if ( fValidating && contentSpecType == XMLElementDecl . TYPE_SIMPLE ) { fBufferDatatype = true ; fDatatypeBuffer . setLength ( 0 ) ; } fInElementContent = ( contentSpecType == XMLElementDecl . TYPE_CHILDREN ) ; } private void validateDTDattribute ( QName element , int attValue , XMLAttributeDecl attributeDecl ) throws Exception { AttributeValidator av = null ; switch ( attributeDecl . type ) { case XMLAttributeDecl . TYPE_ENTITY : { boolean isAlistAttribute = attributeDecl . list ; String unTrimValue = fStringPool . toString ( attValue ) ; String value = unTrimValue . trim ( ) ; if ( fValidationEnabled ) { if ( value != unTrimValue ) { if ( invalidStandaloneAttDef ( element , attributeDecl . name ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attributeDecl . name . rawname ) , unTrimValue , value ) ; } } } try { if ( isAlistAttribute ) { fValENTITIES . validate ( value , null ) ; } else { fValENTITY . validate ( value , null ) ; } } catch ( InvalidDatatypeValueException ex ) { if ( ex . getMajorCode ( ) != 1 && ex . getMinorCode ( ) != - 1 ) { reportRecoverableXMLError ( ex . getMajorCode ( ) , ex . getMinorCode ( ) , fStringPool . toString ( attributeDecl . name . rawname ) , value ) ; } else { System . err . println ( "Error: " + ex . getLocalizedMessage ( ) ) ; } } } break ; case XMLAttributeDecl . TYPE_ENUMERATION : av = fAttValidatorENUMERATION ; break ; case XMLAttributeDecl . TYPE_ID : { String unTrimValue = fStringPool . toString ( attValue ) ; String value = unTrimValue . trim ( ) ; if ( fValidationEnabled ) { if ( value != unTrimValue ) { if ( invalidStandaloneAttDef ( element , attributeDecl . name ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attributeDecl . name . rawname ) , unTrimValue , value ) ; } } } try { this . fStoreIDRef . setDatatypeObject ( fValID . validate ( value , null ) ) ; } catch ( InvalidDatatypeValueException ex ) { reportRecoverableXMLError ( ex . getMajorCode ( ) , ex . getMinorCode ( ) , fStringPool . toString ( attributeDecl . name . rawname ) , value ) ; } } break ; case XMLAttributeDecl . TYPE_IDREF : { String unTrimValue = fStringPool . toString ( attValue ) ; String value = unTrimValue . trim ( ) ; boolean isAlistAttribute = attributeDecl . list ; if ( fValidationEnabled ) { if ( value != unTrimValue ) { if ( invalidStandaloneAttDef ( element , attributeDecl . name ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attributeDecl . name . rawname ) , unTrimValue , value ) ; } } } try { if ( isAlistAttribute ) { fValIDRefs . validate ( value , this . fStoreIDRef ) ; } else { fValIDRef . validate ( value , this . fStoreIDRef ) ; } } catch ( InvalidDatatypeValueException ex ) { if ( ex . getMajorCode ( ) != 1 && ex . getMinorCode ( ) != - 1 ) { reportRecoverableXMLError ( ex . getMajorCode ( ) , ex . getMinorCode ( ) , fStringPool . toString ( attributeDecl . name . rawname ) , value ) ; } else { System . err . println ( "Error: " + ex . getLocalizedMessage ( ) ) ; } } } break ; case XMLAttributeDecl . TYPE_NOTATION : { av = fAttValidatorNOTATION ; } break ; case XMLAttributeDecl . TYPE_NMTOKEN : { String unTrimValue = fStringPool . toString ( attValue ) ; String value = unTrimValue . trim ( ) ; boolean isAlistAttribute = attributeDecl . list ; if ( fValidationEnabled ) { if ( value != unTrimValue ) { if ( invalidStandaloneAttDef ( element , attributeDecl . name ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attributeDecl . name . rawname ) , unTrimValue , value ) ; } } } try { if ( isAlistAttribute ) { fValNMTOKENS . validate ( value , null ) ; } else { fValNMTOKEN . validate ( value , null ) ; } } catch ( InvalidDatatypeValueException ex ) { reportRecoverableXMLError ( XMLMessages . MSG_NMTOKEN_INVALID , XMLMessages . VC_NAME_TOKEN , fStringPool . toString ( attributeDecl . name . rawname ) , value ) ; } } break ; } if ( av != null ) av . normalize ( element , attributeDecl . name , attValue , attributeDecl . type , attributeDecl . enumeration ) ; } private void charDataInContent ( ) { if ( DEBUG_ELEMENT_CHILDREN ) { System . out . println ( "charDataInContent()" ) ; } if ( fElementChildren . length <= fElementChildrenLength ) { QName [ ] newarray = new QName [ fElementChildren . length * 2 ] ; System . arraycopy ( fElementChildren , 0 , newarray , 0 , fElementChildren . length ) ; fElementChildren = newarray ; } QName qname = fElementChildren [ fElementChildrenLength ] ; if ( qname == null ) { for ( int i = fElementChildrenLength ; i < fElementChildren . length ; i ++ ) { fElementChildren [ i ] = new QName ( ) ; } qname = fElementChildren [ fElementChildrenLength ] ; } qname . clear ( ) ; fElementChildrenLength ++ ; } private int checkContent ( int elementIndex , QName [ ] children , int childOffset , int childCount ) throws Exception { final int elementType = fCurrentElement . rawname ; if ( DEBUG_PRINT_CONTENT ) { String strTmp = fStringPool . toString ( elementType ) ; System . out . println ( "Name: " + strTmp + ", " + "Count: " + childCount + ", " + "ContentSpecType: " + fCurrentContentSpecType ) ; for ( int index = childOffset ; index < ( childOffset + childCount ) && index < 10 ; index ++ ) { if ( index == 0 ) { System . out . print ( "  (" ) ; } String childName = ( children [ index ] . localpart == - 1 ) ? "#PCDATA" : fStringPool . toString ( children [ index ] . localpart ) ; if ( index + 1 == childCount ) { System . out . println ( childName + ")" ) ; } else if ( index + 1 == 10 ) { System . out . println ( childName + ",...)" ) ; } else { System . out . print ( childName + "," ) ; } } } final int contentType = fCurrentContentSpecType ; if ( contentType == XMLElementDecl . TYPE_EMPTY ) { if ( childCount != 0 ) { return 0 ; } } else if ( contentType == XMLElementDecl . TYPE_ANY ) { } else if ( contentType == XMLElementDecl . TYPE_MIXED || contentType == XMLElementDecl . TYPE_CHILDREN ) { XMLContentModel cmElem = null ; try { cmElem = getElementContentModel ( elementIndex ) ; int result = cmElem . validateContent ( children , childOffset , childCount ) ; if ( result != - 1 && fGrammarIsSchemaGrammar ) { EquivClassComparator comparator = new EquivClassComparator ( fGrammarResolver , fStringPool ) ; cmElem . setEquivClassComparator ( comparator ) ; result = cmElem . validateContentSpecial ( children , childOffset , childCount ) ; } return result ; } catch ( CMException excToCatch ) { int majorCode = excToCatch . getErrorCode ( ) ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , majorCode , 0 , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } } else if ( contentType == - 1 ) { reportRecoverableXMLError ( XMLMessages . MSG_ELEMENT_NOT_DECLARED , XMLMessages . VC_ELEMENT_VALID , elementType ) ; } else if ( contentType == XMLElementDecl . TYPE_SIMPLE ) { XMLContentModel cmElem = null ; if ( childCount > 0 ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , SchemaMessageProvider . SCHEMA_DOMAIN , SchemaMessageProvider . DatatypeError , SchemaMessageProvider . MSG_NONE , new Object [ ] { "In element '" + fStringPool . toString ( elementType ) + "' : " + "Can not have element children within a simple type content" } , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } else { try { fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ; DatatypeValidator dv = fTempElementDecl . datatypeValidator ; if ( fXsiTypeValidator != null ) { dv = fXsiTypeValidator ; fXsiTypeValidator = null ; } if ( dv == null ) { System . out . println ( "Internal Error: this element have a simpletype " + "but no datatypevalidator was found, element " + fTempElementDecl . name + ",locapart: " + fStringPool . toString ( fTempElementDecl . name . localpart ) ) ; } else { dv . validate ( fDatatypeBuffer . toString ( ) , null ) ; } } catch ( InvalidDatatypeValueException idve ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , SchemaMessageProvider . SCHEMA_DOMAIN , SchemaMessageProvider . DatatypeError , SchemaMessageProvider . MSG_NONE , new Object [ ] { idve . getMessage ( ) } , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } } else { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . VAL_CST , 0 , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } return - 1 ; } private void printChildren ( ) { if ( DEBUG_ELEMENT_CHILDREN ) { System . out . print ( '[' ) ; for ( int i = 0 ; i < fElementChildrenLength ; i ++ ) { System . out . print ( ' ' ) ; QName qname = fElementChildren [ i ] ; if ( qname != null ) { System . out . print ( fStringPool . toString ( qname . rawname ) ) ; } else { System . out . print ( "null" ) ; } if ( i < fElementChildrenLength - 1 ) { System . out . print ( ", " ) ; } System . out . flush ( ) ; } System . out . print ( " ]" ) ; System . out . println ( ) ; } } private void printStack ( ) { if ( DEBUG_ELEMENT_CHILDREN ) { System . out . print ( '{' ) ; for ( int i = 0 ; i <= fElementDepth ; i ++ ) { System . out . print ( ' ' ) ; System . out . print ( fElementChildrenOffsetStack [ i ] ) ; if ( i < fElementDepth ) { System . out . print ( ", " ) ; } System . out . flush ( ) ; } System . out . print ( " }" ) ; System . out . println ( ) ; } } public interface AttributeValidator { public int normalize ( QName element , QName attribute , int attValue , int attType , int enumHandle ) throws Exception ; } boolean invalidStandaloneAttDef ( QName element , QName attribute ) { if ( fStandaloneReader == - 1 ) { return false ; } if ( element . rawname == - 1 ) { return false ; } return getAttDefIsExternal ( element , attribute ) ; } final class AttValidatorNOTATION implements AttributeValidator { public int normalize ( QName element , QName attribute , int attValueHandle , int attType , int enumHandle ) throws Exception { String attValue = fStringPool . toString ( attValueHandle ) ; String newAttValue = attValue . trim ( ) ; if ( fValidating ) { if ( newAttValue != attValue ) { if ( invalidStandaloneAttDef ( element , attribute ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attribute . rawname ) , attValue , newAttValue ) ; } attValueHandle = fStringPool . addSymbol ( newAttValue ) ; } else { attValueHandle = fStringPool . addSymbol ( attValueHandle ) ; } if ( ! fStringPool . stringInList ( enumHandle , attValueHandle ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTRIBUTE_VALUE_NOT_IN_LIST , XMLMessages . VC_NOTATION_ATTRIBUTES , fStringPool . toString ( attribute . rawname ) , newAttValue , fStringPool . stringListAsString ( enumHandle ) ) ; } } else if ( newAttValue != attValue ) { attValueHandle = fStringPool . addSymbol ( newAttValue ) ; } return attValueHandle ; } boolean invalidStandaloneAttDef ( QName element , QName attribute ) { if ( fStandaloneReader == - 1 ) { return false ; } if ( element . rawname == - 1 ) { return false ; } return getAttDefIsExternal ( element , attribute ) ; } } final class AttValidatorENUMERATION implements AttributeValidator { public int normalize ( QName element , QName attribute , int attValueHandle , int attType , int enumHandle ) throws Exception { String attValue = fStringPool . toString ( attValueHandle ) ; String newAttValue = attValue . trim ( ) ; if ( fValidating ) { if ( newAttValue != attValue ) { if ( invalidStandaloneAttDef ( element , attribute ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attribute . rawname ) , attValue , newAttValue ) ; } attValueHandle = fStringPool . addSymbol ( newAttValue ) ; } else { attValueHandle = fStringPool . addSymbol ( attValueHandle ) ; } if ( ! fStringPool . stringInList ( enumHandle , attValueHandle ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTRIBUTE_VALUE_NOT_IN_LIST , XMLMessages . VC_ENUMERATION , fStringPool . toString ( attribute . rawname ) , newAttValue , fStringPool . stringListAsString ( enumHandle ) ) ; } } else if ( newAttValue != attValue ) { attValueHandle = fStringPool . addSymbol ( newAttValue ) ; } return attValueHandle ; } boolean invalidStandaloneAttDef ( QName element , QName attribute ) { if ( fStandaloneReader == - 1 ) { return false ; } if ( element . rawname == - 1 ) { return false ; } return getAttDefIsExternal ( element , attribute ) ; } } } 	1	['86', '1', '0', '46', '255', '1993', '8', '44', '51', '0.943103448', '6176', '0.965517241', '38', '0', '0.101328904', '0', '0', '69.46511628', '17', '1.5581', '2']
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class ElementNSImpl extends ElementImpl { static final long serialVersionUID = - 9142310625494392642L ; protected String namespaceURI ; protected String localName ; protected ElementNSImpl ( DocumentImpl ownerDocument , String namespaceURI , String qualifiedName ) throws DOMException { super ( ownerDocument , qualifiedName ) ; if ( ! DocumentImpl . isXMLName ( qualifiedName ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } int index = qualifiedName . indexOf ( ':' ) ; String prefix ; if ( index < 0 ) { prefix = null ; localName = qualifiedName ; } else { prefix = qualifiedName . substring ( 0 , index ) ; localName = qualifiedName . substring ( index + 1 ) ; } if ( prefix != null && ( namespaceURI == null || namespaceURI . equals ( "" ) || ( prefix . equals ( "xml" ) && ! namespaceURI . equals ( "http://www.w3.org/XML/1998/namespace" ) ) ) ) { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } this . namespaceURI = namespaceURI ; } protected ElementNSImpl ( DocumentImpl ownerDocument , String value ) { super ( ownerDocument , value ) ; } public String getNamespaceURI ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return namespaceURI ; } public String getPrefix ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } int index = name . indexOf ( ':' ) ; return index < 0 ? null : name . substring ( 0 , index ) ; } public void setPrefix ( String prefix ) throws DOMException { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( namespaceURI == null || ( prefix != null && prefix . equals ( "xml" ) && ! namespaceURI . equals ( "http://www.w3.org/XML/1998/namespace" ) ) ) { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } if ( ownerDocument . errorChecking && ! DocumentImpl . isXMLName ( prefix ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } name = prefix + ":" + localName ; } public String getLocalName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return localName ; } } 	1	['6', '3', '1', '4', '18', '3', '2', '3', '4', '0.8', '165', '0.666666667', '0', '0.947368421', '0.611111111', '3', '3', '26', '3', '1.3333', '1']
package org . w3c . dom ; public interface Document extends Node { public DocumentType getDoctype ( ) ; public DOMImplementation getImplementation ( ) ; public Element getDocumentElement ( ) ; public Element createElement ( String tagName ) throws DOMException ; public DocumentFragment createDocumentFragment ( ) ; public Text createTextNode ( String data ) ; public Comment createComment ( String data ) ; public CDATASection createCDATASection ( String data ) throws DOMException ; public ProcessingInstruction createProcessingInstruction ( String target , String data ) throws DOMException ; public Attr createAttribute ( String name ) throws DOMException ; public EntityReference createEntityReference ( String name ) throws DOMException ; public NodeList getElementsByTagName ( String tagname ) ; public Node importNode ( Node importedNode , boolean deep ) throws DOMException ; public Element createElementNS ( String namespaceURI , String qualifiedName ) throws DOMException ; public Attr createAttributeNS ( String namespaceURI , String qualifiedName ) throws DOMException ; public NodeList getElementsByTagNameNS ( String namespaceURI , String localName ) ; public Element getElementById ( String elementId ) ; } 	1	['17', '1', '0', '0', '17', '136', '0', '0', '17', '2', '17', '0', '0', '0', '0.455882353', '0', '0', '0', '1', '1', '2']
package org . w3c . dom . traversal ; import org . w3c . dom . DOMException ; import org . w3c . dom . Node ; public interface NodeIterator { public Node getRoot ( ) ; public int getWhatToShow ( ) ; public NodeFilter getFilter ( ) ; public boolean getExpandEntityReferences ( ) ; public Node nextNode ( ) throws DOMException ; public Node previousNode ( ) throws DOMException ; public void detach ( ) ; } 	1	['7', '1', '0', '0', '7', '21', '0', '0', '7', '2', '7', '0', '0', '0', '1', '0', '0', '0', '1', '1', '2']
package org . w3c . dom . events ; public class EventException extends RuntimeException { public EventException ( short code , String message ) { super ( message ) ; this . code = code ; } public short code ; public static final short UNSPECIFIED_EVENT_TYPE_ERR = 0 ; } 	1	['1', '4', '0', '0', '2', '0', '0', '0', '1', '2', '10', '0', '0', '1', '1', '0', '0', '7', '0', '0', '2']
package org . xml . sax . ext ; import org . xml . sax . SAXException ; public interface DeclHandler { public abstract void elementDecl ( String name , String model ) throws SAXException ; public abstract void attributeDecl ( String eName , String aName , String type , String valueDefault , String value ) throws SAXException ; public abstract void internalEntityDecl ( String name , String value ) throws SAXException ; public abstract void externalEntityDecl ( String name , String publicId , String systemId ) throws SAXException ; } 	1	['4', '1', '0', '0', '4', '6', '0', '0', '4', '2', '4', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . xerces . validators . schema ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . validators . common . Grammar ; import org . apache . xerces . validators . common . GrammarResolver ; import org . apache . xerces . validators . common . GrammarResolverImpl ; import org . apache . xerces . validators . common . XMLElementDecl ; import org . apache . xerces . validators . common . XMLAttributeDecl ; import org . apache . xerces . validators . schema . SchemaSymbols ; import org . apache . xerces . validators . schema . XUtil ; import org . apache . xerces . validators . datatype . DatatypeValidator ; import org . apache . xerces . validators . datatype . DatatypeValidatorFactoryImpl ; import org . apache . xerces . validators . datatype . InvalidDatatypeValueException ; import org . apache . xerces . utils . StringPool ; import org . w3c . dom . Element ; import org . w3c . dom . * ; import java . util . * ; import java . net . URL ; import java . net . MalformedURLException ; import org . apache . xerces . parsers . DOMParser ; import org . apache . xerces . validators . common . XMLValidator ; import org . apache . xerces . validators . datatype . DatatypeValidator . * ; import org . apache . xerces . validators . datatype . InvalidDatatypeValueException ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . NamespacesScope ; import org . apache . xerces . parsers . SAXParser ; import org . apache . xerces . framework . XMLParser ; import org . apache . xerces . framework . XMLDocumentScanner ; import org . xml . sax . InputSource ; import org . xml . sax . SAXParseException ; import org . xml . sax . EntityResolver ; import org . xml . sax . ErrorHandler ; import org . xml . sax . SAXException ; import java . io . IOException ; import org . w3c . dom . Document ; import org . apache . xml . serialize . OutputFormat ; import org . apache . xml . serialize . XMLSerializer ; import org . apache . xerces . validators . schema . SchemaSymbols ; public class TraverseSchema implements NamespacesScope . NamespacesHandler { private static final int TOP_LEVEL_SCOPE = - 1 ; private static boolean DEBUGGING = false ; private XMLErrorReporter fErrorReporter = null ; private StringPool fStringPool = null ; private GrammarResolver fGrammarResolver = null ; private SchemaGrammar fSchemaGrammar = null ; private Element fSchemaRootElement ; private DatatypeValidatorFactoryImpl fDatatypeRegistry = DatatypeValidatorFactoryImpl . getDatatypeRegistry ( ) ; private Hashtable fComplexTypeRegistry = new Hashtable ( ) ; private Hashtable fAttributeDeclRegistry = new Hashtable ( ) ; private Vector fIncludeLocations = new Vector ( ) ; private Vector fImportLocations = new Vector ( ) ; private int fAnonTypeCount = 0 ; private int fScopeCount = 0 ; private int fCurrentScope = TOP_LEVEL_SCOPE ; private int fSimpleTypeAnonCount = 0 ; private Stack fCurrentTypeNameStack = new Stack ( ) ; private Hashtable fElementRecurseComplex = new Hashtable ( ) ; private boolean fElementDefaultQualified = false ; private boolean fAttributeDefaultQualified = false ; private int fTargetNSURI ; private String fTargetNSURIString = "" ; private NamespacesScope fNamespacesScope = null ; private String fCurrentSchemaURL = "" ; private XMLAttributeDecl fTempAttributeDecl = new XMLAttributeDecl ( ) ; private XMLElementDecl fTempElementDecl = new XMLElementDecl ( ) ; public class ComplexTypeInfo { public String typeName ; public DatatypeValidator baseDataTypeValidator ; public ComplexTypeInfo baseComplexTypeInfo ; public int derivedBy = 0 ; public int blockSet = 0 ; public int finalSet = 0 ; public boolean isAbstract = false ; public int scopeDefined = - 1 ; public int contentType ; public int contentSpecHandle = - 1 ; public int templateElementIndex = - 1 ; public int attlistHead = - 1 ; public DatatypeValidator datatypeValidator ; } public final static String SchemaForSchemaURI = "http://www.w3.org/TR-1/Schema" ; private TraverseSchema ( ) { } public void setGrammarResolver ( GrammarResolver grammarResolver ) { fGrammarResolver = grammarResolver ; } public void startNamespaceDeclScope ( int prefix , int uri ) { } public void endNamespaceDeclScope ( int prefix ) { } private String resolvePrefixToURI ( String prefix ) throws Exception { String uriStr = fStringPool . toString ( fNamespacesScope . getNamespaceForPrefix ( fStringPool . addSymbol ( prefix ) ) ) ; if ( uriStr == null ) { reportGenericSchemaError ( "prefix : [" + prefix + "] can not be resolved to a URI" ) ; return "" ; } if ( prefix . length ( ) == 0 && uriStr . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) && fTargetNSURIString . length ( ) == 0 ) { uriStr = "" ; } return uriStr ; } public TraverseSchema ( Element root , StringPool stringPool , SchemaGrammar schemaGrammar , GrammarResolver grammarResolver , XMLErrorReporter errorReporter , String schemaURL ) throws Exception { fErrorReporter = errorReporter ; fCurrentSchemaURL = schemaURL ; doTraverseSchema ( root , stringPool , schemaGrammar , grammarResolver ) ; } public TraverseSchema ( Element root , StringPool stringPool , SchemaGrammar schemaGrammar , GrammarResolver grammarResolver ) throws Exception { doTraverseSchema ( root , stringPool , schemaGrammar , grammarResolver ) ; } public void doTraverseSchema ( Element root , StringPool stringPool , SchemaGrammar schemaGrammar , GrammarResolver grammarResolver ) throws Exception { fNamespacesScope = new NamespacesScope ( this ) ; fSchemaRootElement = root ; fStringPool = stringPool ; fSchemaGrammar = schemaGrammar ; fGrammarResolver = grammarResolver ; if ( root == null ) { return ; } String rootPrefix = root . getPrefix ( ) ; if ( rootPrefix == null || rootPrefix . length ( ) == 0 ) { String xmlns = root . getAttribute ( "xmlns" ) ; if ( xmlns . length ( ) == 0 ) root . setAttribute ( "xmlns" , SchemaSymbols . URI_SCHEMAFORSCHEMA ) ; } fTargetNSURIString = root . getAttribute ( SchemaSymbols . ATT_TARGETNAMESPACE ) ; if ( fTargetNSURIString == null ) { fTargetNSURIString = "" ; } fTargetNSURI = fStringPool . addSymbol ( fTargetNSURIString ) ; if ( fGrammarResolver == null ) { reportGenericSchemaError ( "Internal error: don't have a GrammarResolver for TraverseSchema" ) ; } else { fSchemaGrammar . setComplexTypeRegistry ( fComplexTypeRegistry ) ; fSchemaGrammar . setDatatypeRegistry ( fDatatypeRegistry ) ; fSchemaGrammar . setAttributeDeclRegistry ( fAttributeDeclRegistry ) ; fSchemaGrammar . setNamespacesScope ( fNamespacesScope ) ; fSchemaGrammar . setTargetNamespaceURI ( fTargetNSURIString ) ; fGrammarResolver . putGrammar ( fTargetNSURIString , fSchemaGrammar ) ; } NamedNodeMap schemaEltAttrs = root . getAttributes ( ) ; int i = 0 ; Attr sattr = null ; boolean seenXMLNS = false ; while ( ( sattr = ( Attr ) schemaEltAttrs . item ( i ++ ) ) != null ) { String attName = sattr . getName ( ) ; if ( attName . startsWith ( "xmlns:" ) ) { String attValue = sattr . getValue ( ) ; String prefix = attName . substring ( attName . indexOf ( ":" ) + 1 ) ; fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( prefix ) , fStringPool . addSymbol ( attValue ) ) ; } if ( attName . equals ( "xmlns" ) ) { String attValue = sattr . getValue ( ) ; fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( "" ) , fStringPool . addSymbol ( attValue ) ) ; seenXMLNS = true ; } } if ( ! seenXMLNS && fTargetNSURIString . length ( ) == 0 ) { fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( "" ) , fStringPool . addSymbol ( "" ) ) ; } fElementDefaultQualified = root . getAttribute ( SchemaSymbols . ATT_ELEMENTFORMDEFAULT ) . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) ; fAttributeDefaultQualified = root . getAttribute ( SchemaSymbols . ATT_ATTRIBUTEFORMDEFAULT ) . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) ; if ( fTargetNSURI == StringPool . EMPTY_STRING ) { fElementDefaultQualified = true ; } fCurrentScope = - 1 ; checkTopLevelDuplicateNames ( root ) ; extractTopLevel3Components ( root ) ; for ( Element child = XUtil . getFirstChildElement ( root ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { String name = child . getNodeName ( ) ; if ( name . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { traverseAnnotationDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_SIMPLETYPE ) ) { traverseSimpleTypeDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_COMPLEXTYPE ) ) { traverseComplexTypeDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_ELEMENT ) ) { traverseElementDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { } else if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { traverseAttributeDecl ( child , null ) ; } else if ( name . equals ( SchemaSymbols . ELT_WILDCARD ) ) { traverseWildcardDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_GROUP ) && child . getAttribute ( SchemaSymbols . ATT_REF ) . equals ( "" ) ) { } else if ( name . equals ( SchemaSymbols . ELT_NOTATION ) ) { ; } else if ( name . equals ( SchemaSymbols . ELT_INCLUDE ) ) { traverseInclude ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_IMPORT ) ) { traverseImport ( child ) ; } } } private void checkTopLevelDuplicateNames ( Element root ) { } private void extractTopLevel3Components ( Element root ) { for ( Element child = XUtil . getFirstChildElement ( root ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { String name = child . getNodeName ( ) ; if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { fSchemaGrammar . topLevelAttrGrpDecls . put ( name , child ) ; } else if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { fSchemaGrammar . topLevelAttrDecls . put ( name , child ) ; } else if ( name . equals ( SchemaSymbols . ELT_GROUP ) && child . getAttribute ( SchemaSymbols . ATT_REF ) . equals ( "" ) ) { fSchemaGrammar . topLevelGroupDecls . put ( name , child ) ; } } } private String expandSystemId ( String systemId , String currentSystemId ) throws Exception { String id = systemId ; if ( id == null || id . length ( ) == 0 ) { return systemId ; } try { URL url = new URL ( id ) ; if ( url != null ) { return systemId ; } } catch ( MalformedURLException e ) { } id = fixURI ( id ) ; URL base = null ; URL url = null ; try { if ( currentSystemId == null ) { String dir ; try { dir = fixURI ( System . getProperty ( "user.dir" ) ) ; } catch ( SecurityException se ) { dir = "" ; } if ( ! dir . endsWith ( "/" ) ) { dir = dir + "/" ; } base = new URL ( "file" , "" , dir ) ; } else { base = new URL ( currentSystemId ) ; } url = new URL ( base , id ) ; } catch ( Exception e ) { } if ( url == null ) { return systemId ; } return url . toString ( ) ; } private static String fixURI ( String str ) { str = str . replace ( java . io . File . separatorChar , '/' ) ; if ( str . length ( ) >= 2 ) { char ch1 = str . charAt ( 1 ) ; if ( ch1 == ':' ) { char ch0 = Character . toUpperCase ( str . charAt ( 0 ) ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { str = "/" + str ; } } } return str ; } private void traverseInclude ( Element includeDecl ) throws Exception { String location = includeDecl . getAttribute ( SchemaSymbols . ATT_SCHEMALOCATION ) ; location = expandSystemId ( location , fCurrentSchemaURL ) ; if ( fIncludeLocations . contains ( ( Object ) location ) ) { return ; } fIncludeLocations . addElement ( ( Object ) location ) ; DOMParser parser = new DOMParser ( ) { public void ignorableWhitespace ( char ch [ ] , int start , int length ) { } public void ignorableWhitespace ( int dataIdx ) { } } ; parser . setEntityResolver ( new Resolver ( ) ) ; parser . setErrorHandler ( new ErrorHandler ( ) ) ; try { parser . setFeature ( "http://xml.org/sax/features/validation" , false ) ; parser . setFeature ( "http://xml.org/sax/features/namespaces" , true ) ; parser . setFeature ( "http://apache.org/xml/features/dom/defer-node-expansion" , false ) ; } catch ( org . xml . sax . SAXNotRecognizedException e ) { e . printStackTrace ( ) ; } catch ( org . xml . sax . SAXNotSupportedException e ) { e . printStackTrace ( ) ; } try { parser . parse ( location ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( SAXException e ) { } Document document = parser . getDocument ( ) ; Element root = null ; if ( document != null ) { root = document . getDocumentElement ( ) ; } if ( root != null ) { String targetNSURI = root . getAttribute ( SchemaSymbols . ATT_TARGETNAMESPACE ) ; if ( targetNSURI . length ( ) > 0 && ! targetNSURI . equals ( fTargetNSURIString ) ) { reportGenericSchemaError ( "included schema '" + location + "' has a different targetNameSpace '" + targetNSURI + "'" ) ; } else { boolean saveElementDefaultQualified = fElementDefaultQualified ; boolean saveAttributeDefaultQualified = fAttributeDefaultQualified ; int saveScope = fCurrentScope ; String savedSchemaURL = fCurrentSchemaURL ; Element saveRoot = fSchemaRootElement ; fSchemaRootElement = root ; fCurrentSchemaURL = location ; traverseIncludedSchema ( root ) ; fCurrentSchemaURL = savedSchemaURL ; fCurrentScope = saveScope ; fElementDefaultQualified = saveElementDefaultQualified ; fAttributeDefaultQualified = saveAttributeDefaultQualified ; fSchemaRootElement = saveRoot ; } } } private void traverseIncludedSchema ( Element root ) throws Exception { NamedNodeMap schemaEltAttrs = root . getAttributes ( ) ; int i = 0 ; Attr sattr = null ; boolean seenXMLNS = false ; while ( ( sattr = ( Attr ) schemaEltAttrs . item ( i ++ ) ) != null ) { String attName = sattr . getName ( ) ; if ( attName . startsWith ( "xmlns:" ) ) { String attValue = sattr . getValue ( ) ; String prefix = attName . substring ( attName . indexOf ( ":" ) + 1 ) ; fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( prefix ) , fStringPool . addSymbol ( attValue ) ) ; } if ( attName . equals ( "xmlns" ) ) { String attValue = sattr . getValue ( ) ; fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( "" ) , fStringPool . addSymbol ( attValue ) ) ; seenXMLNS = true ; } } if ( ! seenXMLNS && fTargetNSURIString . length ( ) == 0 ) { fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( "" ) , fStringPool . addSymbol ( "" ) ) ; } fElementDefaultQualified = root . getAttribute ( SchemaSymbols . ATT_ELEMENTFORMDEFAULT ) . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) ; fAttributeDefaultQualified = root . getAttribute ( SchemaSymbols . ATT_ATTRIBUTEFORMDEFAULT ) . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) ; if ( fTargetNSURI == StringPool . EMPTY_STRING ) { fElementDefaultQualified = true ; } fCurrentScope = - 1 ; checkTopLevelDuplicateNames ( root ) ; extractTopLevel3Components ( root ) ; for ( Element child = XUtil . getFirstChildElement ( root ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { String name = child . getNodeName ( ) ; if ( name . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { traverseAnnotationDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_SIMPLETYPE ) ) { traverseSimpleTypeDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_COMPLEXTYPE ) ) { traverseComplexTypeDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_ELEMENT ) ) { traverseElementDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { } else if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { traverseAttributeDecl ( child , null ) ; } else if ( name . equals ( SchemaSymbols . ELT_WILDCARD ) ) { traverseWildcardDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_GROUP ) && child . getAttribute ( SchemaSymbols . ATT_REF ) . equals ( "" ) ) { } else if ( name . equals ( SchemaSymbols . ELT_NOTATION ) ) { ; } else if ( name . equals ( SchemaSymbols . ELT_INCLUDE ) ) { traverseInclude ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_IMPORT ) ) { traverseImport ( child ) ; } } } private void traverseImport ( Element importDecl ) throws Exception { String location = importDecl . getAttribute ( SchemaSymbols . ATT_SCHEMALOCATION ) ; location = expandSystemId ( location , fCurrentSchemaURL ) ; String namespaceString = importDecl . getAttribute ( SchemaSymbols . ATT_NAMESPACE ) ; SchemaGrammar importedGrammar = new SchemaGrammar ( ) ; if ( fGrammarResolver . getGrammar ( namespaceString ) != null ) { importedGrammar = ( SchemaGrammar ) fGrammarResolver . getGrammar ( namespaceString ) ; } if ( fImportLocations . contains ( ( Object ) location ) ) { return ; } fImportLocations . addElement ( ( Object ) location ) ; DOMParser parser = new DOMParser ( ) { public void ignorableWhitespace ( char ch [ ] , int start , int length ) { } public void ignorableWhitespace ( int dataIdx ) { } } ; parser . setEntityResolver ( new Resolver ( ) ) ; parser . setErrorHandler ( new ErrorHandler ( ) ) ; try { parser . setFeature ( "http://xml.org/sax/features/validation" , false ) ; parser . setFeature ( "http://xml.org/sax/features/namespaces" , true ) ; parser . setFeature ( "http://apache.org/xml/features/dom/defer-node-expansion" , false ) ; } catch ( org . xml . sax . SAXNotRecognizedException e ) { e . printStackTrace ( ) ; } catch ( org . xml . sax . SAXNotSupportedException e ) { e . printStackTrace ( ) ; } try { parser . parse ( location ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( SAXException e ) { e . printStackTrace ( ) ; } Document document = parser . getDocument ( ) ; Element root = null ; if ( document != null ) { root = document . getDocumentElement ( ) ; } if ( root != null ) { String targetNSURI = root . getAttribute ( SchemaSymbols . ATT_TARGETNAMESPACE ) ; if ( ! targetNSURI . equals ( namespaceString ) ) { reportGenericSchemaError ( "imported schema '" + location + "' has a different targetNameSpace '" + targetNSURI + "' from what is declared '" + namespaceString + "'." ) ; } else new TraverseSchema ( root , fStringPool , importedGrammar , fGrammarResolver , fErrorReporter , location ) ; } else { reportGenericSchemaError ( "Could not get the doc root for imported Schema file: " + location ) ; } } private void traverseAnnotationDecl ( Element comment ) { return ; } private int traverseSimpleTypeDecl ( Element simpleTypeDecl ) throws Exception { String varietyProperty = simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_DERIVEDBY ) ; if ( varietyProperty . length ( ) == 0 ) { varietyProperty = SchemaSymbols . ATTVAL_RESTRICTION ; } String nameProperty = simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ; String baseTypeQNameProperty = simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_BASE ) ; String abstractProperty = simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_ABSTRACT ) ; int newSimpleTypeName = - 1 ; if ( nameProperty . equals ( "" ) ) { newSimpleTypeName = fStringPool . addSymbol ( "#S#" + fSimpleTypeAnonCount ++ ) ; } else newSimpleTypeName = fStringPool . addSymbol ( nameProperty ) ; int basetype ; DatatypeValidator baseValidator = null ; if ( baseTypeQNameProperty != null ) { basetype = fStringPool . addSymbol ( baseTypeQNameProperty ) ; String prefix = "" ; String localpart = baseTypeQNameProperty ; int colonptr = baseTypeQNameProperty . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = baseTypeQNameProperty . substring ( 0 , colonptr ) ; localpart = baseTypeQNameProperty . substring ( colonptr + 1 ) ; } String uri = resolvePrefixToURI ( prefix ) ; baseValidator = getDatatypeValidator ( uri , localpart ) ; if ( baseValidator == null ) { Element baseTypeNode = getTopLevelComponentByName ( SchemaSymbols . ELT_SIMPLETYPE , localpart ) ; if ( baseTypeNode != null ) { traverseSimpleTypeDecl ( baseTypeNode ) ; baseValidator = getDatatypeValidator ( uri , localpart ) ; if ( baseValidator == null ) { reportSchemaError ( SchemaMessageProvider . UnknownBaseDatatype , new Object [ ] { simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_BASE ) , simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_NAME ) } ) ; return - 1 ; } } else { reportSchemaError ( SchemaMessageProvider . UnknownBaseDatatype , new Object [ ] { simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_BASE ) , simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_NAME ) } ) ; return - 1 ; } } } Element content = XUtil . getFirstChildElement ( simpleTypeDecl ) ; int numFacets = 0 ; Hashtable facetData = null ; if ( content != null ) { if ( content . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { traverseAnnotationDecl ( content ) ; content = XUtil . getNextSiblingElement ( content ) ; } int numEnumerationLiterals = 0 ; facetData = new Hashtable ( ) ; Vector enumData = new Vector ( ) ; while ( content != null ) { if ( content . getNodeType ( ) == Node . ELEMENT_NODE ) { Element facetElt = ( Element ) content ; numFacets ++ ; if ( facetElt . getNodeName ( ) . equals ( SchemaSymbols . ELT_ENUMERATION ) ) { numEnumerationLiterals ++ ; String enumVal = facetElt . getAttribute ( SchemaSymbols . ATT_VALUE ) ; enumData . addElement ( enumVal ) ; Element enumContent = XUtil . getFirstChildElement ( facetElt ) ; if ( enumContent != null && enumContent != null && enumContent . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { traverseAnnotationDecl ( content ) ; } } else { facetData . put ( facetElt . getNodeName ( ) , facetElt . getAttribute ( SchemaSymbols . ATT_VALUE ) ) ; } } content = XUtil . getNextSiblingElement ( content ) ; } if ( numEnumerationLiterals > 0 ) { facetData . put ( SchemaSymbols . ELT_ENUMERATION , enumData ) ; } } String nameOfType = fStringPool . toString ( newSimpleTypeName ) ; if ( fTargetNSURIString . length ( ) != 0 ) { nameOfType = fTargetNSURIString + "," + nameOfType ; } try { DatatypeValidator newValidator = fDatatypeRegistry . getDatatypeValidator ( nameOfType ) ; if ( newValidator == null ) { boolean derivedByList = varietyProperty . equals ( SchemaSymbols . ATTVAL_LIST ) ? true : false ; fDatatypeRegistry . createDatatypeValidator ( nameOfType , baseValidator , facetData , derivedByList ) ; } } catch ( Exception e ) { reportSchemaError ( SchemaMessageProvider . DatatypeError , new Object [ ] { e . getMessage ( ) } ) ; } return fStringPool . addSymbol ( nameOfType ) ; } private int traverseAny ( Element child ) throws Exception { int anyIndex = - 1 ; String namespace = child . getAttribute ( SchemaSymbols . ATT_NAMESPACE ) . trim ( ) ; String processContents = child . getAttribute ( "processContents" ) . trim ( ) ; int processContentsAny = XMLContentSpec . CONTENTSPECNODE_ANY ; int processContentsAnyOther = XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ; int processContentsAnyLocal = XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL ; if ( processContents . length ( ) > 0 && ! processContents . equals ( "strict" ) ) { if ( processContents . equals ( "lax" ) ) { processContentsAny = XMLContentSpec . CONTENTSPECNODE_ANY_LAX ; processContentsAnyOther = XMLContentSpec . CONTENTSPECNODE_ANY_OTHER_LAX ; processContentsAnyLocal = XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL_LAX ; } else if ( processContents . equals ( "skip" ) ) { processContentsAny = XMLContentSpec . CONTENTSPECNODE_ANY_SKIP ; processContentsAnyOther = XMLContentSpec . CONTENTSPECNODE_ANY_OTHER_SKIP ; processContentsAnyLocal = XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL_SKIP ; } } if ( namespace . length ( ) == 0 || namespace . equals ( "##any" ) ) { anyIndex = fSchemaGrammar . addContentSpecNode ( processContentsAny , - 1 , - 1 , false ) ; } else if ( namespace . equals ( "##other" ) ) { String uri = child . getOwnerDocument ( ) . getDocumentElement ( ) . getAttribute ( "targetNamespace" ) ; int uriIndex = fStringPool . addSymbol ( uri ) ; anyIndex = fSchemaGrammar . addContentSpecNode ( processContentsAnyOther , - 1 , uriIndex , false ) ; } else if ( namespace . equals ( "##local" ) ) { anyIndex = fSchemaGrammar . addContentSpecNode ( processContentsAnyLocal , - 1 , - 1 , false ) ; } else if ( namespace . length ( ) > 0 ) { StringTokenizer tokenizer = new StringTokenizer ( namespace ) ; Vector tokens = new Vector ( ) ; while ( tokenizer . hasMoreElements ( ) ) { String token = tokenizer . nextToken ( ) ; if ( token . equals ( "##targetNamespace" ) ) { token = child . getOwnerDocument ( ) . getDocumentElement ( ) . getAttribute ( "targetNamespace" ) ; } tokens . addElement ( token ) ; } String uri = ( String ) tokens . elementAt ( 0 ) ; int uriIndex = fStringPool . addSymbol ( uri ) ; int leafIndex = fSchemaGrammar . addContentSpecNode ( processContentsAny , - 1 , uriIndex , false ) ; int valueIndex = leafIndex ; int count = tokens . size ( ) ; if ( count > 1 ) { uri = ( String ) tokens . elementAt ( 1 ) ; uriIndex = fStringPool . addSymbol ( uri ) ; leafIndex = fSchemaGrammar . addContentSpecNode ( processContentsAny , - 1 , uriIndex , false ) ; int otherValueIndex = leafIndex ; int choiceIndex = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_CHOICE , valueIndex , otherValueIndex , false ) ; for ( int i = 2 ; i < count ; i ++ ) { uri = ( String ) tokens . elementAt ( i ) ; uriIndex = fStringPool . addSymbol ( uri ) ; leafIndex = fSchemaGrammar . addContentSpecNode ( processContentsAny , - 1 , uriIndex , false ) ; otherValueIndex = leafIndex ; choiceIndex = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_CHOICE , choiceIndex , otherValueIndex , false ) ; } anyIndex = choiceIndex ; } else { anyIndex = leafIndex ; } } else { reportGenericSchemaError ( "Empty namespace attribute for any element" ) ; } return anyIndex ; } public DatatypeValidator getDatatypeValidator ( String uri , String localpart ) { DatatypeValidator dv = null ; if ( uri . length ( ) == 0 || uri . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) ) { dv = fDatatypeRegistry . getDatatypeValidator ( localpart ) ; } else { dv = fDatatypeRegistry . getDatatypeValidator ( uri + "," + localpart ) ; } return dv ; } private XMLAttributeDecl traverseAnyAttribute ( Element anyAttributeDecl ) throws Exception { XMLAttributeDecl anyAttDecl = new XMLAttributeDecl ( ) ; String processContents = anyAttributeDecl . getAttribute ( SchemaSymbols . ATT_PROCESSCONTENTS ) . trim ( ) ; String namespace = anyAttributeDecl . getAttribute ( SchemaSymbols . ATT_NAMESPACE ) . trim ( ) ; String curTargetUri = anyAttributeDecl . getOwnerDocument ( ) . getDocumentElement ( ) . getAttribute ( "targetNamespace" ) ; if ( namespace . length ( ) == 0 || namespace . equals ( SchemaSymbols . ATTVAL_TWOPOUNDANY ) ) { anyAttDecl . type = XMLAttributeDecl . TYPE_ANY_ANY ; } else if ( namespace . equals ( SchemaSymbols . ATTVAL_TWOPOUNDOTHER ) ) { anyAttDecl . type = XMLAttributeDecl . TYPE_ANY_OTHER ; anyAttDecl . name . uri = fStringPool . addSymbol ( curTargetUri ) ; } else if ( namespace . equals ( SchemaSymbols . ATTVAL_TWOPOUNDLOCAL ) ) { anyAttDecl . type = XMLAttributeDecl . TYPE_ANY_LOCAL ; } else if ( namespace . length ( ) > 0 ) { anyAttDecl . type = XMLAttributeDecl . TYPE_ANY_LIST ; StringTokenizer tokenizer = new StringTokenizer ( namespace ) ; int aStringList = fStringPool . startStringList ( ) ; Vector tokens = new Vector ( ) ; while ( tokenizer . hasMoreElements ( ) ) { String token = tokenizer . nextToken ( ) ; if ( token . equals ( "##targetNamespace" ) ) { token = curTargetUri ; } if ( ! fStringPool . addStringToList ( aStringList , fStringPool . addSymbol ( token ) ) ) { reportGenericSchemaError ( "Internal StringPool error when reading the " + "namespace attribute for anyattribute declaration" ) ; } } fStringPool . finishStringList ( aStringList ) ; anyAttDecl . enumeration = aStringList ; } else { reportGenericSchemaError ( "Empty namespace attribute for anyattribute declaration" ) ; } anyAttDecl . defaultType = XMLAttributeDecl . PROCESSCONTENTS_STRICT ; if ( processContents . equals ( SchemaSymbols . ATTVAL_SKIP ) ) { anyAttDecl . defaultType = XMLAttributeDecl . PROCESSCONTENTS_SKIP ; } else if ( processContents . equals ( SchemaSymbols . ATTVAL_LAX ) ) { anyAttDecl . defaultType = XMLAttributeDecl . PROCESSCONTENTS_LAX ; } return anyAttDecl ; } private XMLAttributeDecl mergeTwoAnyAttribute ( XMLAttributeDecl oneAny , XMLAttributeDecl anotherAny ) { if ( oneAny . type == - 1 ) { return oneAny ; } if ( anotherAny . type == - 1 ) { return anotherAny ; } if ( oneAny . type == XMLAttributeDecl . TYPE_ANY_ANY ) { return anotherAny ; } if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_ANY ) { return oneAny ; } if ( oneAny . type == XMLAttributeDecl . TYPE_ANY_OTHER ) { if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_OTHER ) { if ( anotherAny . name . uri == oneAny . name . uri ) { return oneAny ; } else { oneAny . type = - 1 ; return oneAny ; } } else if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_LOCAL ) { return anotherAny ; } else if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_LIST ) { if ( ! fStringPool . stringInList ( anotherAny . enumeration , oneAny . name . uri ) ) { return anotherAny ; } else { int [ ] anotherAnyURIs = fStringPool . stringListAsIntArray ( anotherAny . enumeration ) ; int newList = fStringPool . startStringList ( ) ; for ( int i = 0 ; i < anotherAnyURIs . length ; i ++ ) { if ( anotherAnyURIs [ i ] != oneAny . name . uri ) { fStringPool . addStringToList ( newList , anotherAnyURIs [ i ] ) ; } } fStringPool . finishStringList ( newList ) ; anotherAny . enumeration = newList ; return anotherAny ; } } } if ( oneAny . type == XMLAttributeDecl . TYPE_ANY_LOCAL ) { if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_OTHER || anotherAny . type == XMLAttributeDecl . TYPE_ANY_LOCAL ) { return oneAny ; } else if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_LIST ) { oneAny . type = - 1 ; return oneAny ; } } if ( oneAny . type == XMLAttributeDecl . TYPE_ANY_LIST ) { if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_OTHER ) { if ( ! fStringPool . stringInList ( oneAny . enumeration , anotherAny . name . uri ) ) { return oneAny ; } else { int [ ] oneAnyURIs = fStringPool . stringListAsIntArray ( oneAny . enumeration ) ; int newList = fStringPool . startStringList ( ) ; for ( int i = 0 ; i < oneAnyURIs . length ; i ++ ) { if ( oneAnyURIs [ i ] != anotherAny . name . uri ) { fStringPool . addStringToList ( newList , oneAnyURIs [ i ] ) ; } } fStringPool . finishStringList ( newList ) ; oneAny . enumeration = newList ; return oneAny ; } } else if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_LOCAL ) { oneAny . type = - 1 ; return oneAny ; } else if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_LIST ) { int [ ] result = intersect2sets ( fStringPool . stringListAsIntArray ( oneAny . enumeration ) , fStringPool . stringListAsIntArray ( anotherAny . enumeration ) ) ; int newList = fStringPool . startStringList ( ) ; for ( int i = 0 ; i < result . length ; i ++ ) { fStringPool . addStringToList ( newList , result [ i ] ) ; } fStringPool . finishStringList ( newList ) ; oneAny . enumeration = newList ; return oneAny ; } } return oneAny ; } int [ ] intersect2sets ( int [ ] one , int [ ] theOther ) { int [ ] result = new int [ ( one . length > theOther . length ? one . length : theOther . length ) ] ; int count = 0 ; for ( int i = 0 ; i < one . length ; i ++ ) { for ( int j = 0 ; j < theOther . length ; j ++ ) { if ( one [ i ] == theOther [ j ] ) { result [ count ++ ] = one [ i ] ; } } } int [ ] result2 = new int [ count ] ; System . arraycopy ( result , 0 , result2 , 0 , count ) ; return result2 ; } private int traverseComplexTypeDecl ( Element complexTypeDecl ) throws Exception { String isAbstract = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_ABSTRACT ) ; String base = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_BASE ) ; String blockSet = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_BLOCK ) ; String content = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_CONTENT ) ; String derivedBy = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_DERIVEDBY ) ; String finalSet = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_FINAL ) ; String typeId = complexTypeDecl . getAttribute ( SchemaSymbols . ATTVAL_ID ) ; String typeName = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ; boolean isNamedType = false ; if ( DEBUGGING ) System . out . println ( "traversing complex Type : " + typeName + "," + base + "," + content + "." ) ; if ( typeName . equals ( "" ) ) { typeName = "#" + fAnonTypeCount ++ ; } else { fCurrentTypeNameStack . push ( typeName ) ; isNamedType = true ; } if ( isTopLevel ( complexTypeDecl ) ) { String fullName = fTargetNSURIString + "," + typeName ; ComplexTypeInfo temp = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fullName ) ; if ( temp != null ) { return fStringPool . addSymbol ( fullName ) ; } } int scopeDefined = fScopeCount ++ ; int previousScope = fCurrentScope ; fCurrentScope = scopeDefined ; Element child = null ; int contentSpecType = - 1 ; int csnType = 0 ; int left = - 2 ; int right = - 2 ; ComplexTypeInfo baseTypeInfo = null ; DatatypeValidator baseTypeValidator = null ; DatatypeValidator simpleTypeValidator = null ; int baseTypeSymbol = - 1 ; String fullBaseName = "" ; boolean baseIsSimpleSimple = false ; boolean baseIsComplexSimple = false ; boolean derivedByRestriction = true ; boolean derivedByExtension = false ; int baseContentSpecHandle = - 1 ; Element baseTypeNode = null ; if ( base . length ( ) > 0 ) { if ( derivedBy . length ( ) == 0 ) { reportGenericSchemaError ( "derivedBy must be present when base is present in " + SchemaSymbols . ELT_COMPLEXTYPE + " " + typeName ) ; } else { if ( derivedBy . equals ( SchemaSymbols . ATTVAL_EXTENSION ) ) { derivedByRestriction = false ; } String prefix = "" ; String localpart = base ; int colonptr = base . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = base . substring ( 0 , colonptr ) ; localpart = base . substring ( colonptr + 1 ) ; } int localpartIndex = fStringPool . addSymbol ( localpart ) ; String typeURI = resolvePrefixToURI ( prefix ) ; if ( ! typeURI . equals ( fTargetNSURIString ) && ! typeURI . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) && typeURI . length ( ) != 0 ) { baseTypeInfo = getTypeInfoFromNS ( typeURI , localpart ) ; if ( baseTypeInfo == null ) { baseTypeValidator = getTypeValidatorFromNS ( typeURI , localpart ) ; if ( baseTypeValidator == null ) { System . out . println ( "Could not find base type " + localpart + " in schema " + typeURI ) ; } else { baseIsSimpleSimple = true ; } } } else { fullBaseName = typeURI + "," + localpart ; baseTypeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fullBaseName ) ; if ( baseTypeInfo == null ) { baseTypeValidator = getDatatypeValidator ( typeURI , localpart ) ; if ( baseTypeValidator == null ) { baseTypeNode = getTopLevelComponentByName ( SchemaSymbols . ELT_COMPLEXTYPE , localpart ) ; if ( baseTypeNode != null ) { baseTypeSymbol = traverseComplexTypeDecl ( baseTypeNode ) ; baseTypeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fStringPool . toString ( baseTypeSymbol ) ) ; } else { baseTypeNode = getTopLevelComponentByName ( SchemaSymbols . ELT_SIMPLETYPE , localpart ) ; if ( baseTypeNode != null ) { baseTypeSymbol = traverseSimpleTypeDecl ( baseTypeNode ) ; simpleTypeValidator = baseTypeValidator = getDatatypeValidator ( typeURI , localpart ) ; if ( simpleTypeValidator == null ) { } baseIsSimpleSimple = true ; } else { reportGenericSchemaError ( "Base type could not be found : " + base ) ; } } } else { simpleTypeValidator = baseTypeValidator ; baseIsSimpleSimple = true ; } } } if ( baseIsSimpleSimple && derivedByRestriction ) { reportGenericSchemaError ( "base is a simpledType, can't derive by restriction in " + typeName ) ; } if ( baseTypeInfo != null ) { if ( derivedByRestriction ) { } else { } if ( baseTypeInfo . contentSpecHandle > - 1 ) { if ( derivedByRestriction ) { checkParticleDerivationOK ( complexTypeDecl , baseTypeNode ) ; } baseContentSpecHandle = baseTypeInfo . contentSpecHandle ; } else if ( baseTypeInfo . datatypeValidator != null ) { baseTypeValidator = baseTypeInfo . datatypeValidator ; baseIsComplexSimple = true ; } } if ( baseIsComplexSimple && ! derivedByRestriction ) { reportGenericSchemaError ( "base is ComplexSimple, can't derive by extension in " + typeName ) ; } } } child = null ; if ( baseIsComplexSimple ) { contentSpecType = XMLElementDecl . TYPE_SIMPLE ; int numEnumerationLiterals = 0 ; int numFacets = 0 ; Hashtable facetData = new Hashtable ( ) ; Vector enumData = new Vector ( ) ; for ( child = XUtil . getFirstChildElement ( complexTypeDecl ) ; child != null && ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MINEXCLUSIVE ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MININCLUSIVE ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MAXEXCLUSIVE ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MAXINCLUSIVE ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_PRECISION ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_SCALE ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_LENGTH ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MINLENGTH ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MAXLENGTH ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ENCODING ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_PERIOD ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_DURATION ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ENUMERATION ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_PATTERN ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) ; child = XUtil . getNextSiblingElement ( child ) ) { if ( child . getNodeType ( ) == Node . ELEMENT_NODE ) { Element facetElt = ( Element ) child ; numFacets ++ ; if ( facetElt . getNodeName ( ) . equals ( SchemaSymbols . ELT_ENUMERATION ) ) { numEnumerationLiterals ++ ; enumData . addElement ( facetElt . getAttribute ( SchemaSymbols . ATT_VALUE ) ) ; Element enumContent = XUtil . getFirstChildElement ( facetElt ) ; if ( enumContent != null && enumContent . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { traverseAnnotationDecl ( child ) ; } } else { facetData . put ( facetElt . getNodeName ( ) , facetElt . getAttribute ( SchemaSymbols . ATT_VALUE ) ) ; } } } if ( numEnumerationLiterals > 0 ) { facetData . put ( SchemaSymbols . ELT_ENUMERATION , enumData ) ; } if ( numFacets > 0 ) { simpleTypeValidator = fDatatypeRegistry . createDatatypeValidator ( typeName , baseTypeValidator , facetData , false ) ; } else simpleTypeValidator = baseTypeValidator ; if ( child != null ) { reportGenericSchemaError ( "Invalid child '" + child . getNodeName ( ) + "' in complexType : '" + typeName + "', because it restricts another complexSimpleType" ) ; } } if ( content . equals ( SchemaSymbols . ATTVAL_TEXTONLY ) ) { if ( base . length ( ) == 0 ) { simpleTypeValidator = baseTypeValidator = getDatatypeValidator ( "" , SchemaSymbols . ATTVAL_STRING ) ; } else if ( baseTypeValidator == null && baseTypeInfo != null && baseTypeInfo . datatypeValidator == null ) reportSchemaError ( SchemaMessageProvider . NotADatatype , new Object [ ] { base } ) ; contentSpecType = XMLElementDecl . TYPE_SIMPLE ; } else { if ( ! baseIsComplexSimple ) { contentSpecType = XMLElementDecl . TYPE_CHILDREN ; } csnType = XMLContentSpec . CONTENTSPECNODE_SEQ ; boolean mixedContent = false ; boolean elementContent = true ; boolean textContent = false ; boolean emptyContent = false ; left = - 2 ; right = - 2 ; boolean hadContent = false ; if ( content . equals ( SchemaSymbols . ATTVAL_EMPTY ) ) { contentSpecType = XMLElementDecl . TYPE_EMPTY ; emptyContent = true ; elementContent = false ; left = - 1 ; } else if ( content . equals ( SchemaSymbols . ATTVAL_MIXED ) ) { contentSpecType = XMLElementDecl . TYPE_MIXED ; mixedContent = true ; elementContent = false ; csnType = XMLContentSpec . CONTENTSPECNODE_CHOICE ; } else if ( content . equals ( SchemaSymbols . ATTVAL_ELEMENTONLY ) || content . equals ( "" ) ) { elementContent = true ; } else if ( content . equals ( SchemaSymbols . ATTVAL_TEXTONLY ) ) { textContent = true ; elementContent = false ; } if ( mixedContent ) { left = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , - 1 , - 1 , false ) ; csnType = XMLContentSpec . CONTENTSPECNODE_CHOICE ; } boolean seeParticle = false ; boolean seeOtherParticle = false ; boolean seeAll = false ; for ( child = XUtil . getFirstChildElement ( complexTypeDecl ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; hadContent = true ; seeParticle = false ; String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { if ( mixedContent || elementContent ) { if ( DEBUGGING ) System . out . println ( " child element name " + child . getAttribute ( SchemaSymbols . ATT_NAME ) ) ; QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; seeOtherParticle = true ; } else { reportSchemaError ( SchemaMessageProvider . EltRefOnlyInMixedElemOnly , null ) ; } } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; seeOtherParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ALL ) ) { index = traverseAll ( child ) ; seeParticle = true ; seeAll = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; seeOtherParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; seeOtherParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ATTRIBUTE ) || childName . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { break ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; seeOtherParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { } else if ( childName . equals ( SchemaSymbols . ELT_ANYATTRIBUTE ) ) { break ; } else { if ( ! baseIsComplexSimple ) if ( base . equals ( "" ) ) reportSchemaError ( SchemaMessageProvider . GenericError , new Object [ ] { "unrecogized child '" + childName + "' in compelx type " + typeName } ) ; else reportSchemaError ( SchemaMessageProvider . GenericError , new Object [ ] { "unrecogized child '" + childName + "' in compelx type '" + typeName + "' with base " + base } ) ; } if ( baseIsComplexSimple && seeParticle ) { reportGenericSchemaError ( "In complexType " + typeName + ", base type is complextype with simpleType content, can't have any particle children at all" ) ; hadContent = false ; left = index = - 2 ; contentSpecType = XMLElementDecl . TYPE_SIMPLE ; break ; } if ( seeParticle ) { index = expandContentModel ( index , child ) ; } if ( seeAll && seeOtherParticle ) { reportGenericSchemaError ( " 'All' group needs to be the only child in Complextype : " + typeName ) ; } if ( seeAll ) { } if ( left == - 2 ) { left = index ; } else if ( right == - 2 ) { right = index ; } else { left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; right = index ; } } if ( ! ( seeOtherParticle || seeAll ) && ( elementContent || mixedContent ) && ( base . length ( ) == 0 || ( base . length ( ) > 0 && derivedByRestriction && ! baseIsComplexSimple ) ) ) { contentSpecType = XMLElementDecl . TYPE_SIMPLE ; simpleTypeValidator = getDatatypeValidator ( "" , SchemaSymbols . ATTVAL_STRING ) ; reportGenericSchemaError ( " complexType '" + typeName + "' with a elementOnly or mixed content " + "need to have at least one particle child" ) ; } if ( hadContent && right != - 2 ) left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; if ( mixedContent && hadContent ) { left = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE , left , - 1 , false ) ; } } if ( ! derivedByRestriction && baseContentSpecHandle > - 1 ) { if ( left == - 2 ) { left = baseContentSpecHandle ; } else left = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , baseContentSpecHandle , left , false ) ; } if ( content . length ( ) == 0 && base . length ( ) == 0 && left == - 2 ) { contentSpecType = XMLElementDecl . TYPE_ANY ; } if ( content . length ( ) == 0 && simpleTypeValidator == null && left == - 2 ) { if ( base . length ( ) > 0 && baseTypeInfo != null && baseTypeInfo . contentType == XMLElementDecl . TYPE_EMPTY ) { contentSpecType = XMLElementDecl . TYPE_EMPTY ; } } if ( DEBUGGING ) System . out . println ( "!!!!!>>>>>" + typeName + ", " + baseTypeInfo + ", " + baseContentSpecHandle + ", " + left + ", " + scopeDefined ) ; ComplexTypeInfo typeInfo = new ComplexTypeInfo ( ) ; typeInfo . baseComplexTypeInfo = baseTypeInfo ; typeInfo . baseDataTypeValidator = baseTypeValidator ; int derivedByInt = - 1 ; if ( derivedBy . length ( ) > 0 ) { derivedByInt = parseComplexDerivedBy ( derivedBy ) ; } typeInfo . derivedBy = derivedByInt ; typeInfo . scopeDefined = scopeDefined ; typeInfo . contentSpecHandle = left ; typeInfo . contentType = contentSpecType ; typeInfo . datatypeValidator = simpleTypeValidator ; typeInfo . blockSet = parseBlockSet ( complexTypeDecl . getAttribute ( SchemaSymbols . ATT_BLOCK ) ) ; typeInfo . finalSet = parseFinalSet ( complexTypeDecl . getAttribute ( SchemaSymbols . ATT_FINAL ) ) ; typeInfo . isAbstract = isAbstract . equals ( SchemaSymbols . ATTVAL_TRUE ) ? true : false ; int typeNameIndex = fStringPool . addSymbol ( typeName ) ; int templateElementNameIndex = fStringPool . addSymbol ( "$" + typeName ) ; typeInfo . templateElementIndex = fSchemaGrammar . addElementDecl ( new QName ( - 1 , templateElementNameIndex , typeNameIndex , fTargetNSURI ) , ( fTargetNSURI == - 1 ) ? - 1 : fCurrentScope , scopeDefined , contentSpecType , left , - 1 , simpleTypeValidator ) ; typeInfo . attlistHead = fSchemaGrammar . getFirstAttributeDeclIndex ( typeInfo . templateElementIndex ) ; XMLAttributeDecl attWildcard = null ; Vector anyAttDecls = new Vector ( ) ; for ( child = XUtil . getFirstChildElement ( complexTypeDecl ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { if ( ( baseIsComplexSimple || baseIsSimpleSimple ) && derivedByRestriction ) { reportGenericSchemaError ( "In complexType " + typeName + ", base type has simpleType " + "content and derivation method is" + " 'restriction', can't have any " + "attribute children at all" ) ; break ; } traverseAttributeDecl ( child , typeInfo ) ; } else if ( childName . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { if ( ( baseIsComplexSimple || baseIsSimpleSimple ) && derivedByRestriction ) { reportGenericSchemaError ( "In complexType " + typeName + ", base " + "type has simpleType content and " + "derivation method is 'restriction'," + " can't have any attribute children at all" ) ; break ; } traverseAttributeGroupDecl ( child , typeInfo , anyAttDecls ) ; } else if ( childName . equals ( SchemaSymbols . ELT_ANYATTRIBUTE ) ) { attWildcard = traverseAnyAttribute ( child ) ; } } if ( attWildcard != null ) { XMLAttributeDecl fromGroup = null ; final int count = anyAttDecls . size ( ) ; if ( count > 0 ) { fromGroup = ( XMLAttributeDecl ) anyAttDecls . elementAt ( 0 ) ; for ( int i = 1 ; i < count ; i ++ ) { fromGroup = mergeTwoAnyAttribute ( fromGroup , ( XMLAttributeDecl ) anyAttDecls . elementAt ( i ) ) ; } } if ( fromGroup != null ) { int saveProcessContents = attWildcard . defaultType ; attWildcard = mergeTwoAnyAttribute ( attWildcard , fromGroup ) ; attWildcard . defaultType = saveProcessContents ; } } else { } XMLAttributeDecl baseAttWildcard = null ; if ( baseTypeInfo != null && baseTypeInfo . attlistHead > - 1 ) { int attDefIndex = baseTypeInfo . attlistHead ; while ( attDefIndex > - 1 ) { fTempAttributeDecl . clear ( ) ; fSchemaGrammar . getAttributeDecl ( attDefIndex , fTempAttributeDecl ) ; if ( fTempAttributeDecl . type == XMLAttributeDecl . TYPE_ANY_ANY || fTempAttributeDecl . type == XMLAttributeDecl . TYPE_ANY_LIST || fTempAttributeDecl . type == XMLAttributeDecl . TYPE_ANY_LOCAL || fTempAttributeDecl . type == XMLAttributeDecl . TYPE_ANY_OTHER ) { if ( attWildcard == null ) { baseAttWildcard = fTempAttributeDecl ; } attDefIndex = fSchemaGrammar . getNextAttributeDeclIndex ( attDefIndex ) ; continue ; } int temp = fSchemaGrammar . getAttributeDeclIndex ( typeInfo . templateElementIndex , fTempAttributeDecl . name ) ; if ( temp > - 1 ) { if ( derivedByRestriction ) { attDefIndex = fSchemaGrammar . getNextAttributeDeclIndex ( attDefIndex ) ; continue ; } } fSchemaGrammar . addAttDef ( typeInfo . templateElementIndex , fTempAttributeDecl . name , fTempAttributeDecl . type , fTempAttributeDecl . enumeration , fTempAttributeDecl . defaultType , fTempAttributeDecl . defaultValue , fTempAttributeDecl . datatypeValidator , fTempAttributeDecl . list ) ; attDefIndex = fSchemaGrammar . getNextAttributeDeclIndex ( attDefIndex ) ; } } if ( attWildcard != null ) { if ( attWildcard . type != - 1 ) { fSchemaGrammar . addAttDef ( typeInfo . templateElementIndex , attWildcard . name , attWildcard . type , attWildcard . enumeration , attWildcard . defaultType , attWildcard . defaultValue , attWildcard . datatypeValidator , attWildcard . list ) ; } else { } } else if ( baseAttWildcard != null ) { fSchemaGrammar . addAttDef ( typeInfo . templateElementIndex , baseAttWildcard . name , baseAttWildcard . type , baseAttWildcard . enumeration , baseAttWildcard . defaultType , baseAttWildcard . defaultValue , baseAttWildcard . datatypeValidator , baseAttWildcard . list ) ; } typeInfo . attlistHead = fSchemaGrammar . getFirstAttributeDeclIndex ( typeInfo . templateElementIndex ) ; if ( ! typeName . startsWith ( "#" ) ) { typeName = fTargetNSURIString + "," + typeName ; } typeInfo . typeName = new String ( typeName ) ; if ( DEBUGGING ) System . out . println ( "add complex Type to Registry: " + typeName + "," + content + "." ) ; fComplexTypeRegistry . put ( typeName , typeInfo ) ; fCurrentScope = previousScope ; if ( isNamedType ) { fCurrentTypeNameStack . pop ( ) ; checkRecursingComplexType ( ) ; } fSchemaGrammar . setElementComplexTypeInfo ( typeInfo . templateElementIndex , typeInfo ) ; typeNameIndex = fStringPool . addSymbol ( typeName ) ; return typeNameIndex ; } private void checkRecursingComplexType ( ) throws Exception { if ( fCurrentTypeNameStack . empty ( ) ) { if ( ! fElementRecurseComplex . isEmpty ( ) ) { Enumeration e = fElementRecurseComplex . keys ( ) ; while ( e . hasMoreElements ( ) ) { QName nameThenScope = ( QName ) e . nextElement ( ) ; String typeName = ( String ) fElementRecurseComplex . get ( nameThenScope ) ; int eltUriIndex = nameThenScope . uri ; int eltNameIndex = nameThenScope . localpart ; int enclosingScope = nameThenScope . prefix ; ComplexTypeInfo typeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fTargetNSURIString + "," + typeName ) ; if ( typeInfo == null ) { throw new Exception ( "Internal Error in void checkRecursingComplexType(). " ) ; } else { int elementIndex = fSchemaGrammar . addElementDecl ( new QName ( - 1 , eltNameIndex , eltNameIndex , eltUriIndex ) , enclosingScope , typeInfo . scopeDefined , typeInfo . contentType , typeInfo . contentSpecHandle , typeInfo . attlistHead , typeInfo . datatypeValidator ) ; fSchemaGrammar . setElementComplexTypeInfo ( elementIndex , typeInfo ) ; } } fElementRecurseComplex . clear ( ) ; } } } private void checkParticleDerivationOK ( Element derivedTypeNode , Element baseTypeNode ) { } private int expandContentModel ( int index , Element particle ) throws Exception { String minOccurs = particle . getAttribute ( SchemaSymbols . ATT_MINOCCURS ) ; String maxOccurs = particle . getAttribute ( SchemaSymbols . ATT_MAXOCCURS ) ; int min = 1 , max = 1 ; if ( minOccurs . equals ( "" ) ) { minOccurs = "1" ; } if ( maxOccurs . equals ( "" ) ) { if ( minOccurs . equals ( "0" ) ) { maxOccurs = "1" ; } else { maxOccurs = minOccurs ; } } int leafIndex = index ; if ( minOccurs . equals ( "1" ) && maxOccurs . equals ( "1" ) ) { } else if ( minOccurs . equals ( "0" ) && maxOccurs . equals ( "1" ) ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE , index , - 1 , false ) ; } else if ( minOccurs . equals ( "0" ) && maxOccurs . equals ( "unbounded" ) ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE , index , - 1 , false ) ; } else if ( minOccurs . equals ( "1" ) && maxOccurs . equals ( "unbounded" ) ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE , index , - 1 , false ) ; } else if ( maxOccurs . equals ( "unbounded" ) ) { try { min = Integer . parseInt ( minOccurs ) ; } catch ( Exception e ) { reportSchemaError ( SchemaMessageProvider . GenericError , new Object [ ] { "illegal value for minOccurs : '" + e . getMessage ( ) + "' " } ) ; } if ( min < 2 ) { } index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE , index , - 1 , false ) ; for ( int i = 0 ; i < ( min - 1 ) ; i ++ ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , leafIndex , index , false ) ; } } else { try { min = Integer . parseInt ( minOccurs ) ; max = Integer . parseInt ( maxOccurs ) ; } catch ( Exception e ) { reportSchemaError ( SchemaMessageProvider . GenericError , new Object [ ] { "illegal value for minOccurs or maxOccurs : '" + e . getMessage ( ) + "' " } ) ; } if ( min == 0 ) { int optional = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE , leafIndex , - 1 , false ) ; index = optional ; for ( int i = 0 ; i < ( max - min - 1 ) ; i ++ ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , index , optional , false ) ; } } else { for ( int i = 0 ; i < ( min - 1 ) ; i ++ ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , index , leafIndex , false ) ; } int optional = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE , leafIndex , - 1 , false ) ; for ( int i = 0 ; i < ( max - min ) ; i ++ ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , index , optional , false ) ; } } } return index ; } private int traverseAttributeDecl ( Element attrDecl , ComplexTypeInfo typeInfo ) throws Exception { String attNameStr = attrDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ; int attName = fStringPool . addSymbol ( attNameStr ) ; String isQName = attrDecl . getAttribute ( SchemaSymbols . ATT_FORM ) ; DatatypeValidator dv = null ; int attType = - 1 ; boolean attIsList = false ; int dataTypeSymbol = - 1 ; String ref = attrDecl . getAttribute ( SchemaSymbols . ATT_REF ) ; String datatype = attrDecl . getAttribute ( SchemaSymbols . ATT_TYPE ) ; String localpart = null ; if ( ! ref . equals ( "" ) ) { if ( XUtil . getFirstChildElement ( attrDecl ) != null ) reportSchemaError ( SchemaMessageProvider . NoContentForRef , null ) ; String prefix = "" ; localpart = ref ; int colonptr = ref . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = ref . substring ( 0 , colonptr ) ; localpart = ref . substring ( colonptr + 1 ) ; } String uriStr = resolvePrefixToURI ( prefix ) ; if ( ! uriStr . equals ( fTargetNSURIString ) ) { addAttributeDeclFromAnotherSchema ( localpart , uriStr , typeInfo ) ; return - 1 ; } Element referredAttribute = getTopLevelComponentByName ( SchemaSymbols . ELT_ATTRIBUTE , localpart ) ; if ( referredAttribute != null ) { traverseAttributeDecl ( referredAttribute , typeInfo ) ; } else { reportGenericSchemaError ( "Couldn't find top level attribute " + ref ) ; } return - 1 ; } if ( datatype . equals ( "" ) ) { Element child = XUtil . getFirstChildElement ( attrDecl ) ; while ( child != null && ! child . getNodeName ( ) . equals ( SchemaSymbols . ELT_SIMPLETYPE ) ) child = XUtil . getNextSiblingElement ( child ) ; if ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_SIMPLETYPE ) ) { attType = XMLAttributeDecl . TYPE_SIMPLE ; dataTypeSymbol = traverseSimpleTypeDecl ( child ) ; localpart = fStringPool . toString ( dataTypeSymbol ) ; } else { attType = XMLAttributeDecl . TYPE_SIMPLE ; localpart = "string" ; dataTypeSymbol = fStringPool . addSymbol ( localpart ) ; } localpart = fStringPool . toString ( dataTypeSymbol ) ; dv = fDatatypeRegistry . getDatatypeValidator ( localpart ) ; } else { String prefix = "" ; localpart = datatype ; dataTypeSymbol = fStringPool . addSymbol ( localpart ) ; int colonptr = datatype . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = datatype . substring ( 0 , colonptr ) ; localpart = datatype . substring ( colonptr + 1 ) ; } String typeURI = resolvePrefixToURI ( prefix ) ; if ( typeURI . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) || typeURI . length ( ) == 0 ) { dv = getDatatypeValidator ( "" , localpart ) ; if ( localpart . equals ( "ID" ) ) { attType = XMLAttributeDecl . TYPE_ID ; } else if ( localpart . equals ( "IDREF" ) ) { attType = XMLAttributeDecl . TYPE_IDREF ; } else if ( localpart . equals ( "IDREFS" ) ) { attType = XMLAttributeDecl . TYPE_IDREF ; attIsList = true ; } else if ( localpart . equals ( "ENTITY" ) ) { attType = XMLAttributeDecl . TYPE_ENTITY ; } else if ( localpart . equals ( "ENTITIES" ) ) { attType = XMLAttributeDecl . TYPE_ENTITY ; attIsList = true ; } else if ( localpart . equals ( "NMTOKEN" ) ) { attType = XMLAttributeDecl . TYPE_NMTOKEN ; } else if ( localpart . equals ( "NMTOKENS" ) ) { attType = XMLAttributeDecl . TYPE_NMTOKEN ; attIsList = true ; } else if ( localpart . equals ( SchemaSymbols . ELT_NOTATION ) ) { attType = XMLAttributeDecl . TYPE_NOTATION ; } else { attType = XMLAttributeDecl . TYPE_SIMPLE ; if ( dv == null && typeURI . length ( ) == 0 ) { Element topleveltype = getTopLevelComponentByName ( SchemaSymbols . ELT_SIMPLETYPE , localpart ) ; if ( topleveltype != null ) { traverseSimpleTypeDecl ( topleveltype ) ; dv = getDatatypeValidator ( typeURI , localpart ) ; } else { reportGenericSchemaError ( "simpleType not found : " + localpart ) ; } } } } else { dv = getDatatypeValidator ( typeURI , localpart ) ; if ( dv == null && typeURI . equals ( fTargetNSURIString ) ) { Element topleveltype = getTopLevelComponentByName ( SchemaSymbols . ELT_SIMPLETYPE , localpart ) ; if ( topleveltype != null ) { traverseSimpleTypeDecl ( topleveltype ) ; dv = getDatatypeValidator ( typeURI , localpart ) ; } else { reportGenericSchemaError ( "simpleType not found : " + localpart ) ; } } attType = XMLAttributeDecl . TYPE_SIMPLE ; } } int attDefaultType = - 1 ; int attDefaultValue = - 1 ; String use = attrDecl . getAttribute ( SchemaSymbols . ATT_USE ) ; boolean required = use . equals ( SchemaSymbols . ATTVAL_REQUIRED ) ; if ( dv == null ) { reportGenericSchemaError ( "could not resolve the type or get a null validator for datatype : " + fStringPool . toString ( dataTypeSymbol ) ) ; } if ( required ) { attDefaultType = XMLAttributeDecl . DEFAULT_TYPE_REQUIRED ; } else { if ( use . equals ( SchemaSymbols . ATTVAL_FIXED ) ) { String fixed = attrDecl . getAttribute ( SchemaSymbols . ATT_VALUE ) ; if ( ! fixed . equals ( "" ) ) { attDefaultType = XMLAttributeDecl . DEFAULT_TYPE_FIXED ; attDefaultValue = fStringPool . addString ( fixed ) ; } } else if ( use . equals ( SchemaSymbols . ATTVAL_DEFAULT ) ) { String defaultValue = attrDecl . getAttribute ( SchemaSymbols . ATT_VALUE ) ; if ( ! defaultValue . equals ( "" ) ) { attDefaultType = XMLAttributeDecl . DEFAULT_TYPE_DEFAULT ; attDefaultValue = fStringPool . addString ( defaultValue ) ; } } else if ( use . equals ( SchemaSymbols . ATTVAL_PROHIBITED ) ) { attDefaultType = XMLAttributeDecl . DEFAULT_TYPE_IMPLIED ; } else { attDefaultType = XMLAttributeDecl . DEFAULT_TYPE_IMPLIED ; } if ( attType == XMLAttributeDecl . TYPE_SIMPLE && attDefaultValue != - 1 ) { try { if ( dv != null ) dv . validate ( fStringPool . toString ( attDefaultValue ) , null ) ; else reportSchemaError ( SchemaMessageProvider . NoValidatorFor , new Object [ ] { datatype } ) ; } catch ( InvalidDatatypeValueException idve ) { reportSchemaError ( SchemaMessageProvider . IncorrectDefaultType , new Object [ ] { attrDecl . getAttribute ( SchemaSymbols . ATT_NAME ) , idve . getMessage ( ) } ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . out . println ( "Internal error in attribute datatype validation" ) ; } } } int uriIndex = - 1 ; if ( isQName . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) || fAttributeDefaultQualified || isTopLevel ( attrDecl ) ) { uriIndex = fTargetNSURI ; } QName attQName = new QName ( - 1 , attName , attName , uriIndex ) ; if ( DEBUGGING ) System . out . println ( " the dataType Validator for " + fStringPool . toString ( attName ) + " is " + dv ) ; if ( isTopLevel ( attrDecl ) ) { fTempAttributeDecl . datatypeValidator = dv ; fTempAttributeDecl . name . setValues ( attQName ) ; fTempAttributeDecl . type = attType ; fTempAttributeDecl . defaultType = attDefaultType ; fTempAttributeDecl . list = attIsList ; if ( attDefaultValue != - 1 ) { fTempAttributeDecl . defaultValue = new String ( fStringPool . toString ( attDefaultValue ) ) ; } fAttributeDeclRegistry . put ( attNameStr , new XMLAttributeDecl ( fTempAttributeDecl ) ) ; } if ( typeInfo != null ) { fSchemaGrammar . addAttDef ( typeInfo . templateElementIndex , attQName , attType , dataTypeSymbol , attDefaultType , fStringPool . toString ( attDefaultValue ) , dv , attIsList ) ; } return - 1 ; } private int addAttributeDeclFromAnotherSchema ( String name , String uriStr , ComplexTypeInfo typeInfo ) throws Exception { SchemaGrammar aGrammar = ( SchemaGrammar ) fGrammarResolver . getGrammar ( uriStr ) ; if ( uriStr == null || ! ( aGrammar instanceof SchemaGrammar ) ) { reportGenericSchemaError ( "!!Schema not found in #addAttributeDeclFromAnotherSchema, schema uri : " + uriStr ) ; return - 1 ; } Hashtable attrRegistry = aGrammar . getAttirubteDeclRegistry ( ) ; if ( attrRegistry == null ) { reportGenericSchemaError ( "no attribute was defined in schema : " + uriStr ) ; return - 1 ; } XMLAttributeDecl tempAttrDecl = ( XMLAttributeDecl ) attrRegistry . get ( name ) ; if ( tempAttrDecl == null ) { reportGenericSchemaError ( "no attribute named \"" + name + "\" was defined in schema : " + uriStr ) ; return - 1 ; } if ( typeInfo != null ) { fSchemaGrammar . addAttDef ( typeInfo . templateElementIndex , tempAttrDecl . name , tempAttrDecl . type , - 1 , tempAttrDecl . defaultType , tempAttrDecl . defaultValue , tempAttrDecl . datatypeValidator , tempAttrDecl . list ) ; } return 0 ; } private int traverseAttributeGroupDecl ( Element attrGrpDecl , ComplexTypeInfo typeInfo , Vector anyAttDecls ) throws Exception { int attGrpName = fStringPool . addSymbol ( attrGrpDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ) ; String ref = attrGrpDecl . getAttribute ( SchemaSymbols . ATT_REF ) ; int attType = - 1 ; int enumeration = - 1 ; if ( ! ref . equals ( "" ) ) { if ( XUtil . getFirstChildElement ( attrGrpDecl ) != null ) reportSchemaError ( SchemaMessageProvider . NoContentForRef , null ) ; String prefix = "" ; String localpart = ref ; int colonptr = ref . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = ref . substring ( 0 , colonptr ) ; localpart = ref . substring ( colonptr + 1 ) ; } String uriStr = resolvePrefixToURI ( prefix ) ; if ( ! uriStr . equals ( fTargetNSURIString ) ) { traverseAttributeGroupDeclFromAnotherSchema ( localpart , uriStr , typeInfo , anyAttDecls ) ; return - 1 ; } Element referredAttrGrp = getTopLevelComponentByName ( SchemaSymbols . ELT_ATTRIBUTEGROUP , localpart ) ; if ( referredAttrGrp != null ) { traverseAttributeGroupDecl ( referredAttrGrp , typeInfo , anyAttDecls ) ; } else { reportGenericSchemaError ( "Couldn't find top level attributegroup " + ref ) ; } return - 1 ; } for ( Element child = XUtil . getFirstChildElement ( attrGrpDecl ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { traverseAttributeDecl ( child , typeInfo ) ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { traverseAttributeGroupDecl ( child , typeInfo , anyAttDecls ) ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANYATTRIBUTE ) ) { anyAttDecls . addElement ( traverseAnyAttribute ( child ) ) ; break ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { } } return - 1 ; } private int traverseAttributeGroupDeclFromAnotherSchema ( String attGrpName , String uriStr , ComplexTypeInfo typeInfo , Vector anyAttDecls ) throws Exception { SchemaGrammar aGrammar = ( SchemaGrammar ) fGrammarResolver . getGrammar ( uriStr ) ; if ( uriStr == null || aGrammar == null || ! ( aGrammar instanceof SchemaGrammar ) ) { reportGenericSchemaError ( "!!Schema not found in #traverseAttributeGroupDeclFromAnotherSchema, schema uri : " + uriStr ) ; return - 1 ; } Element attGrpDecl = ( Element ) aGrammar . topLevelAttrGrpDecls . get ( ( Object ) attGrpName ) ; if ( attGrpDecl == null ) { reportGenericSchemaError ( "no attribute group named \"" + attGrpName + "\" was defined in schema : " + uriStr ) ; return - 1 ; } NamespacesScope saveNSMapping = fNamespacesScope ; int saveTargetNSUri = fTargetNSURI ; fTargetNSURI = fStringPool . addSymbol ( aGrammar . getTargetNamespaceURI ( ) ) ; fNamespacesScope = aGrammar . getNamespacesScope ( ) ; int attType = - 1 ; int enumeration = - 1 ; for ( Element child = XUtil . getFirstChildElement ( attGrpDecl ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { String childAttName = child . getAttribute ( SchemaSymbols . ATT_NAME ) ; if ( childAttName . length ( ) > 0 ) { Hashtable attDeclRegistry = aGrammar . getAttirubteDeclRegistry ( ) ; if ( attDeclRegistry != null ) { if ( attDeclRegistry . get ( ( Object ) childAttName ) != null ) { addAttributeDeclFromAnotherSchema ( childAttName , uriStr , typeInfo ) ; return - 1 ; } } } else traverseAttributeDecl ( child , typeInfo ) ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { traverseAttributeGroupDecl ( child , typeInfo , anyAttDecls ) ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANYATTRIBUTE ) ) { anyAttDecls . addElement ( traverseAnyAttribute ( child ) ) ; break ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { } } fNamespacesScope = saveNSMapping ; fTargetNSURI = saveTargetNSUri ; return - 1 ; } private QName traverseElementDecl ( Element elementDecl ) throws Exception { int contentSpecType = - 1 ; int contentSpecNodeIndex = - 1 ; int typeNameIndex = - 1 ; int scopeDefined = - 2 ; DatatypeValidator dv = null ; String name = elementDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ; if ( DEBUGGING ) System . out . println ( "traversing element decl : " + name ) ; String ref = elementDecl . getAttribute ( SchemaSymbols . ATT_REF ) ; String type = elementDecl . getAttribute ( SchemaSymbols . ATT_TYPE ) ; String minOccurs = elementDecl . getAttribute ( SchemaSymbols . ATT_MINOCCURS ) ; String maxOccurs = elementDecl . getAttribute ( SchemaSymbols . ATT_MAXOCCURS ) ; String dflt = elementDecl . getAttribute ( SchemaSymbols . ATT_DEFAULT ) ; String fixed = elementDecl . getAttribute ( SchemaSymbols . ATT_FIXED ) ; String equivClass = elementDecl . getAttribute ( SchemaSymbols . ATT_EQUIVCLASS ) ; String isQName = elementDecl . getAttribute ( SchemaSymbols . ATT_FORM ) ; String fromAnotherSchema = null ; if ( isTopLevel ( elementDecl ) ) { int nameIndex = fStringPool . addSymbol ( name ) ; int eltKey = fSchemaGrammar . getElementDeclIndex ( fTargetNSURI , nameIndex , TOP_LEVEL_SCOPE ) ; if ( eltKey > - 1 ) { return new QName ( - 1 , nameIndex , nameIndex , fTargetNSURI ) ; } } int blockSet = parseBlockSet ( elementDecl . getAttribute ( SchemaSymbols . ATT_BLOCK ) ) ; int finalSet = parseFinalSet ( elementDecl . getAttribute ( SchemaSymbols . ATT_FINAL ) ) ; boolean isNullable = elementDecl . getAttribute ( SchemaSymbols . ATT_NULLABLE ) . equals ( SchemaSymbols . ATTVAL_TRUE ) ? true : false ; boolean isAbstract = elementDecl . getAttribute ( SchemaSymbols . ATT_ABSTRACT ) . equals ( SchemaSymbols . ATTVAL_TRUE ) ? true : false ; int elementMiscFlags = 0 ; if ( isNullable ) { elementMiscFlags += SchemaSymbols . NULLABLE ; } if ( isAbstract ) { elementMiscFlags += SchemaSymbols . ABSTRACT ; } int attrCount = 0 ; if ( ! ref . equals ( "" ) ) attrCount ++ ; if ( ! type . equals ( "" ) ) attrCount ++ ; if ( attrCount > 1 ) reportSchemaError ( SchemaMessageProvider . OneOfTypeRefArchRef , null ) ; if ( ! ref . equals ( "" ) ) { if ( XUtil . getFirstChildElement ( elementDecl ) != null ) reportSchemaError ( SchemaMessageProvider . NoContentForRef , null ) ; String prefix = "" ; String localpart = ref ; int colonptr = ref . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = ref . substring ( 0 , colonptr ) ; localpart = ref . substring ( colonptr + 1 ) ; } int localpartIndex = fStringPool . addSymbol ( localpart ) ; String uriString = resolvePrefixToURI ( prefix ) ; QName eltName = new QName ( prefix != null ? fStringPool . addSymbol ( prefix ) : - 1 , localpartIndex , fStringPool . addSymbol ( ref ) , uriString != null ? fStringPool . addSymbol ( uriString ) : - 1 ) ; if ( ! uriString . equals ( fTargetNSURIString ) ) { return eltName ; } int elementIndex = fSchemaGrammar . getElementDeclIndex ( eltName , TOP_LEVEL_SCOPE ) ; if ( elementIndex == - 1 ) { Element targetElement = getTopLevelComponentByName ( SchemaSymbols . ELT_ELEMENT , localpart ) ; if ( targetElement == null ) { reportGenericSchemaError ( "Element " + localpart + " not found in the Schema" ) ; return eltName ; } else { } } return eltName ; } Element equivClassElementDecl = null ; int equivClassElementDeclIndex = - 1 ; boolean noErrorSoFar = true ; String equivClassUri = null ; String equivClassLocalpart = null ; String equivClassFullName = null ; ComplexTypeInfo equivClassEltTypeInfo = null ; DatatypeValidator equivClassEltDV = null ; if ( equivClass . length ( ) > 0 ) { equivClassUri = resolvePrefixToURI ( getPrefix ( equivClass ) ) ; equivClassLocalpart = getLocalPart ( equivClass ) ; equivClassFullName = equivClassUri + "," + equivClassLocalpart ; if ( ! equivClassUri . equals ( fTargetNSURIString ) ) { equivClassEltTypeInfo = getElementDeclTypeInfoFromNS ( equivClassUri , equivClassLocalpart ) ; if ( equivClassEltTypeInfo == null ) { equivClassEltDV = getElementDeclTypeValidatorFromNS ( equivClassUri , equivClassLocalpart ) ; if ( equivClassEltDV == null ) { noErrorSoFar = false ; reportGenericSchemaError ( "Could not find type for element '" + equivClassLocalpart + "' in schema '" + equivClassUri + "'" ) ; } } } else { equivClassElementDecl = getTopLevelComponentByName ( SchemaSymbols . ELT_ELEMENT , equivClassLocalpart ) ; if ( equivClassElementDecl == null ) { equivClassElementDeclIndex = fSchemaGrammar . getElementDeclIndex ( fTargetNSURI , getLocalPartIndex ( equivClass ) , TOP_LEVEL_SCOPE ) ; if ( equivClassElementDeclIndex == - 1 ) { noErrorSoFar = false ; reportGenericSchemaError ( "Equivclass affiliation element " + equivClass + " in element declaration " + name ) ; } } else { equivClassElementDeclIndex = fSchemaGrammar . getElementDeclIndex ( fTargetNSURI , getLocalPartIndex ( equivClass ) , TOP_LEVEL_SCOPE ) ; if ( equivClassElementDeclIndex == - 1 ) { traverseElementDecl ( equivClassElementDecl ) ; equivClassElementDeclIndex = fSchemaGrammar . getElementDeclIndex ( fTargetNSURI , getLocalPartIndex ( equivClass ) , TOP_LEVEL_SCOPE ) ; } } if ( equivClassElementDeclIndex != - 1 ) { equivClassEltTypeInfo = fSchemaGrammar . getElementComplexTypeInfo ( equivClassElementDeclIndex ) ; if ( equivClassEltTypeInfo == null ) { fSchemaGrammar . getElementDecl ( equivClassElementDeclIndex , fTempElementDecl ) ; equivClassEltDV = fTempElementDecl . datatypeValidator ; if ( equivClassEltDV == null ) { noErrorSoFar = false ; reportGenericSchemaError ( "Could not find type for element '" + equivClassLocalpart + "' in schema '" + equivClassUri + "'" ) ; } } } } } ComplexTypeInfo typeInfo = null ; Element child = XUtil . getFirstChildElement ( elementDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; boolean haveAnonType = false ; if ( child != null ) { String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_COMPLEXTYPE ) ) { if ( child . getAttribute ( SchemaSymbols . ATT_NAME ) . length ( ) > 0 ) { noErrorSoFar = false ; reportGenericSchemaError ( "anonymous complexType in element '" + name + "' has a name attribute" ) ; } else typeNameIndex = traverseComplexTypeDecl ( child ) ; if ( typeNameIndex != - 1 ) { typeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fStringPool . toString ( typeNameIndex ) ) ; } else { noErrorSoFar = false ; reportGenericSchemaError ( "traverse complexType error in element '" + name + "'" ) ; } haveAnonType = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SIMPLETYPE ) ) { if ( child . getAttribute ( SchemaSymbols . ATT_NAME ) . length ( ) > 0 ) { noErrorSoFar = false ; reportGenericSchemaError ( "anonymous simpleType in element '" + name + "' has a name attribute" ) ; } else typeNameIndex = traverseSimpleTypeDecl ( child ) ; if ( typeNameIndex != - 1 ) { dv = fDatatypeRegistry . getDatatypeValidator ( fStringPool . toString ( typeNameIndex ) ) ; } else { noErrorSoFar = false ; reportGenericSchemaError ( "traverse simpleType error in element '" + name + "'" ) ; } contentSpecType = XMLElementDecl . TYPE_SIMPLE ; haveAnonType = true ; } else if ( type . equals ( "" ) ) { contentSpecType = XMLElementDecl . TYPE_ANY ; contentSpecNodeIndex = - 1 ; } else { System . out . println ( "unhandled case in TraverseElementDecl" ) ; } } if ( haveAnonType && ( type . length ( ) > 0 ) ) { noErrorSoFar = false ; reportGenericSchemaError ( "Element '" + name + "' have both a type attribute and a annoymous type child" ) ; } else if ( ! type . equals ( "" ) ) { if ( equivClassElementDecl != null ) { checkEquivClassOK ( elementDecl , equivClassElementDecl ) ; } String prefix = "" ; String localpart = type ; int colonptr = type . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = type . substring ( 0 , colonptr ) ; localpart = type . substring ( colonptr + 1 ) ; } String typeURI = resolvePrefixToURI ( prefix ) ; if ( ! typeURI . equals ( fTargetNSURIString ) && ! typeURI . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) && typeURI . length ( ) != 0 ) { fromAnotherSchema = typeURI ; typeInfo = getTypeInfoFromNS ( typeURI , localpart ) ; if ( typeInfo == null ) { dv = getTypeValidatorFromNS ( typeURI , localpart ) ; if ( dv == null ) { noErrorSoFar = false ; reportGenericSchemaError ( "Could not find type " + localpart + " in schema " + typeURI ) ; } } } else { typeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( typeURI + "," + localpart ) ; if ( typeInfo == null ) { dv = getDatatypeValidator ( typeURI , localpart ) ; if ( dv == null ) if ( typeURI . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) && ! fTargetNSURIString . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) ) { noErrorSoFar = false ; reportGenericSchemaError ( "type not found : " + typeURI + ":" + localpart ) ; } else { Element topleveltype = getTopLevelComponentByName ( SchemaSymbols . ELT_COMPLEXTYPE , localpart ) ; if ( topleveltype != null ) { if ( fCurrentTypeNameStack . search ( ( Object ) localpart ) > - 1 ) { int uriInd = - 1 ; if ( isQName . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) || fElementDefaultQualified ) { uriInd = fTargetNSURI ; } int nameIndex = fStringPool . addSymbol ( name ) ; QName tempQName = new QName ( fCurrentScope , nameIndex , nameIndex , uriInd ) ; fElementRecurseComplex . put ( tempQName , localpart ) ; return new QName ( - 1 , nameIndex , nameIndex , uriInd ) ; } else { typeNameIndex = traverseComplexTypeDecl ( topleveltype ) ; typeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fStringPool . toString ( typeNameIndex ) ) ; } } else { topleveltype = getTopLevelComponentByName ( SchemaSymbols . ELT_SIMPLETYPE , localpart ) ; if ( topleveltype != null ) { typeNameIndex = traverseSimpleTypeDecl ( topleveltype ) ; dv = getDatatypeValidator ( typeURI , localpart ) ; } else { noErrorSoFar = false ; reportGenericSchemaError ( "type not found : " + typeURI + ":" + localpart ) ; } } } } } } else if ( haveAnonType ) { if ( equivClassElementDecl != null ) { checkEquivClassOK ( elementDecl , equivClassElementDecl ) ; } } else { if ( typeInfo == null && dv == null ) typeInfo = equivClassEltTypeInfo ; if ( typeInfo == null && dv == null ) dv = equivClassEltDV ; } if ( typeInfo == null && dv == null ) { if ( noErrorSoFar ) { contentSpecType = XMLElementDecl . TYPE_ANY ; } else { noErrorSoFar = false ; reportGenericSchemaError ( "untyped element : " + name ) ; } } if ( typeInfo != null ) { contentSpecNodeIndex = typeInfo . contentSpecHandle ; contentSpecType = typeInfo . contentType ; scopeDefined = typeInfo . scopeDefined ; dv = typeInfo . datatypeValidator ; } if ( dv != null ) { contentSpecType = XMLElementDecl . TYPE_SIMPLE ; } child = XUtil . getFirstChildElement ( elementDecl ) ; Vector idConstraints = null ; while ( child != null ) { String childName = child . getNodeName ( ) ; child = XUtil . getNextSiblingElement ( child ) ; } int elementNameIndex = fStringPool . addSymbol ( name ) ; int localpartIndex = elementNameIndex ; int uriIndex = - 1 ; int enclosingScope = fCurrentScope ; if ( isQName . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) || fElementDefaultQualified ) { uriIndex = fTargetNSURI ; } if ( isTopLevel ( elementDecl ) ) { uriIndex = fTargetNSURI ; enclosingScope = TOP_LEVEL_SCOPE ; } int existSuchElementIndex = fSchemaGrammar . getElementDeclIndex ( uriIndex , localpartIndex , enclosingScope ) ; if ( existSuchElementIndex > - 1 ) { fSchemaGrammar . getElementDecl ( existSuchElementIndex , fTempElementDecl ) ; DatatypeValidator edv = fTempElementDecl . datatypeValidator ; ComplexTypeInfo eTypeInfo = fSchemaGrammar . getElementComplexTypeInfo ( existSuchElementIndex ) ; if ( ( ( eTypeInfo != null ) && ( eTypeInfo != typeInfo ) ) || ( ( edv != null ) && ( edv != dv ) ) ) { noErrorSoFar = false ; reportGenericSchemaError ( "duplicate element decl in the same scope : " + fStringPool . toString ( localpartIndex ) ) ; } } QName eltQName = new QName ( - 1 , localpartIndex , elementNameIndex , uriIndex ) ; int attrListHead = - 1 ; if ( typeInfo != null ) { attrListHead = typeInfo . attlistHead ; } int elementIndex = fSchemaGrammar . addElementDecl ( eltQName , enclosingScope , scopeDefined , contentSpecType , contentSpecNodeIndex , attrListHead , dv ) ; if ( DEBUGGING ) { System . out . println ( "########elementIndex:" + elementIndex + " (" + fStringPool . toString ( eltQName . uri ) + "," + fStringPool . toString ( eltQName . localpart ) + ")" + " eltType:" + type + " contentSpecType:" + contentSpecType + " SpecNodeIndex:" + contentSpecNodeIndex + " enclosingScope: " + enclosingScope + " scopeDefined: " + scopeDefined + "\n" ) ; } if ( typeInfo != null ) { fSchemaGrammar . setElementComplexTypeInfo ( elementIndex , typeInfo ) ; } else { fSchemaGrammar . setElementComplexTypeInfo ( elementIndex , typeInfo ) ; } fSchemaGrammar . setElementFromAnotherSchemaURI ( elementIndex , fromAnotherSchema ) ; fSchemaGrammar . setElementDeclBlockSet ( elementIndex , blockSet ) ; fSchemaGrammar . setElementDeclFinalSet ( elementIndex , finalSet ) ; fSchemaGrammar . setElementDeclMiscFlags ( elementIndex , elementMiscFlags ) ; fSchemaGrammar . setElementDeclEquivClassElementFullName ( elementIndex , equivClassFullName ) ; return eltQName ; } int getLocalPartIndex ( String fullName ) { int colonAt = fullName . indexOf ( ":" ) ; String localpart = fullName ; if ( colonAt > - 1 ) { localpart = fullName . substring ( colonAt + 1 ) ; } return fStringPool . addSymbol ( localpart ) ; } String getLocalPart ( String fullName ) { int colonAt = fullName . indexOf ( ":" ) ; String localpart = fullName ; if ( colonAt > - 1 ) { localpart = fullName . substring ( colonAt + 1 ) ; } return localpart ; } int getPrefixIndex ( String fullName ) { int colonAt = fullName . indexOf ( ":" ) ; String prefix = "" ; if ( colonAt > - 1 ) { prefix = fullName . substring ( 0 , colonAt ) ; } return fStringPool . addSymbol ( prefix ) ; } String getPrefix ( String fullName ) { int colonAt = fullName . indexOf ( ":" ) ; String prefix = "" ; if ( colonAt > - 1 ) { prefix = fullName . substring ( 0 , colonAt ) ; } return prefix ; } private void checkEquivClassOK ( Element elementDecl , Element equivClassElementDecl ) { } private Element getTopLevelComponentByName ( String componentCategory , String name ) throws Exception { Element child = XUtil . getFirstChildElement ( fSchemaRootElement ) ; if ( child == null ) { return null ; } while ( child != null ) { if ( child . getNodeName ( ) . equals ( componentCategory ) ) { if ( child . getAttribute ( SchemaSymbols . ATT_NAME ) . equals ( name ) ) { return child ; } } child = XUtil . getNextSiblingElement ( child ) ; } return null ; } private boolean isTopLevel ( Element component ) { if ( component . getParentNode ( ) . getNodeName ( ) . endsWith ( SchemaSymbols . ELT_SCHEMA ) ) { return true ; } return false ; } DatatypeValidator getTypeValidatorFromNS ( String newSchemaURI , String localpart ) throws Exception { return getDatatypeValidator ( newSchemaURI , localpart ) ; } ComplexTypeInfo getTypeInfoFromNS ( String newSchemaURI , String localpart ) throws Exception { Grammar grammar = fGrammarResolver . getGrammar ( newSchemaURI ) ; if ( grammar != null && grammar instanceof SchemaGrammar ) { SchemaGrammar sGrammar = ( SchemaGrammar ) grammar ; ComplexTypeInfo typeInfo = ( ComplexTypeInfo ) sGrammar . getComplexTypeRegistry ( ) . get ( newSchemaURI + "," + localpart ) ; return typeInfo ; } else { reportGenericSchemaError ( "could not resolve URI : " + newSchemaURI + " to a SchemaGrammar in getTypeInfoFromNS" ) ; } return null ; } DatatypeValidator getElementDeclTypeValidatorFromNS ( String newSchemaURI , String localpart ) throws Exception { Grammar grammar = fGrammarResolver . getGrammar ( newSchemaURI ) ; if ( grammar != null && grammar instanceof SchemaGrammar ) { SchemaGrammar sGrammar = ( SchemaGrammar ) grammar ; int eltIndex = sGrammar . getElementDeclIndex ( fStringPool . addSymbol ( newSchemaURI ) , fStringPool . addSymbol ( localpart ) , TOP_LEVEL_SCOPE ) ; DatatypeValidator dv = null ; if ( eltIndex > - 1 ) { sGrammar . getElementDecl ( eltIndex , fTempElementDecl ) ; dv = fTempElementDecl . datatypeValidator ; } else { reportGenericSchemaError ( "could not find global element : '" + localpart + " in the SchemaGrammar " + newSchemaURI ) ; } return dv ; } else { reportGenericSchemaError ( "could not resolve URI : " + newSchemaURI + " to a SchemaGrammar in getELementDeclTypeValidatorFromNS" ) ; } return null ; } ComplexTypeInfo getElementDeclTypeInfoFromNS ( String newSchemaURI , String localpart ) throws Exception { Grammar grammar = fGrammarResolver . getGrammar ( newSchemaURI ) ; if ( grammar != null && grammar instanceof SchemaGrammar ) { SchemaGrammar sGrammar = ( SchemaGrammar ) grammar ; int eltIndex = sGrammar . getElementDeclIndex ( fStringPool . addSymbol ( newSchemaURI ) , fStringPool . addSymbol ( localpart ) , TOP_LEVEL_SCOPE ) ; ComplexTypeInfo typeInfo = null ; if ( eltIndex > - 1 ) { typeInfo = sGrammar . getElementComplexTypeInfo ( eltIndex ) ; } else { reportGenericSchemaError ( "could not find global element : '" + localpart + " in the SchemaGrammar " + newSchemaURI ) ; } return typeInfo ; } else { reportGenericSchemaError ( "could not resolve URI : " + newSchemaURI + " to a SchemaGrammar in getElementDeclTypeInfoFromNS" ) ; } return null ; } private int traverseGroupDecl ( Element groupDecl ) throws Exception { String groupName = groupDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ; String ref = groupDecl . getAttribute ( SchemaSymbols . ATT_REF ) ; if ( ! ref . equals ( "" ) ) { if ( XUtil . getFirstChildElement ( groupDecl ) != null ) reportSchemaError ( SchemaMessageProvider . NoContentForRef , null ) ; String prefix = "" ; String localpart = ref ; int colonptr = ref . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = ref . substring ( 0 , colonptr ) ; localpart = ref . substring ( colonptr + 1 ) ; } int localpartIndex = fStringPool . addSymbol ( localpart ) ; String uriStr = resolvePrefixToURI ( prefix ) ; if ( ! uriStr . equals ( fTargetNSURIString ) ) { return traverseGroupDeclFromAnotherSchema ( localpart , uriStr ) ; } int contentSpecIndex = - 1 ; Element referredGroup = getTopLevelComponentByName ( SchemaSymbols . ELT_GROUP , localpart ) ; if ( referredGroup == null ) { reportGenericSchemaError ( "Group " + localpart + " not found in the Schema" ) ; throw new Exception ( "Group " + localpart + " not found in the Schema" ) ; } else { contentSpecIndex = traverseGroupDecl ( referredGroup ) ; } return contentSpecIndex ; } boolean traverseElt = true ; if ( fCurrentScope == TOP_LEVEL_SCOPE ) { traverseElt = false ; } Element child = XUtil . getFirstChildElement ( groupDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; int contentSpecType = 0 ; int csnType = 0 ; int allChildren [ ] = null ; int allChildCount = 0 ; csnType = XMLContentSpec . CONTENTSPECNODE_SEQ ; contentSpecType = XMLElementDecl . TYPE_CHILDREN ; int left = - 2 ; int right = - 2 ; boolean hadContent = false ; boolean seeAll = false ; boolean seeParticle = false ; for ( ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; hadContent = true ; boolean illegalChild = false ; String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ALL ) ) { index = traverseAll ( child ) ; seeAll = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; } else { illegalChild = true ; reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "group" , childName } ) ; } if ( ! illegalChild ) { index = expandContentModel ( index , child ) ; } if ( seeParticle && seeAll ) { reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "'all' needs to be 'the' only Child" , childName } ) ; } if ( left == - 2 ) { left = index ; } else if ( right == - 2 ) { right = index ; } else { left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; right = index ; } } if ( hadContent && right != - 2 ) left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; return left ; } private int traverseGroupDeclFromAnotherSchema ( String groupName , String uriStr ) throws Exception { SchemaGrammar aGrammar = ( SchemaGrammar ) fGrammarResolver . getGrammar ( uriStr ) ; if ( uriStr == null || aGrammar == null || ! ( aGrammar instanceof SchemaGrammar ) ) { reportGenericSchemaError ( "!!Schema not found in #traverseGroupDeclFromAnotherSchema, " + "schema uri: " + uriStr + ", groupName: " + groupName ) ; return - 1 ; } Element groupDecl = ( Element ) aGrammar . topLevelGroupDecls . get ( ( Object ) groupName ) ; if ( groupDecl == null ) { reportGenericSchemaError ( "no group named \"" + groupName + "\" was defined in schema : " + uriStr ) ; return - 1 ; } NamespacesScope saveNSMapping = fNamespacesScope ; int saveTargetNSUri = fTargetNSURI ; fTargetNSURI = fStringPool . addSymbol ( aGrammar . getTargetNamespaceURI ( ) ) ; fNamespacesScope = aGrammar . getNamespacesScope ( ) ; boolean traverseElt = true ; if ( fCurrentScope == TOP_LEVEL_SCOPE ) { traverseElt = false ; } Element child = XUtil . getFirstChildElement ( groupDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; int contentSpecType = 0 ; int csnType = 0 ; int allChildren [ ] = null ; int allChildCount = 0 ; csnType = XMLContentSpec . CONTENTSPECNODE_SEQ ; contentSpecType = XMLElementDecl . TYPE_CHILDREN ; int left = - 2 ; int right = - 2 ; boolean hadContent = false ; for ( ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; hadContent = true ; boolean seeParticle = false ; String childName = child . getNodeName ( ) ; int childNameIndex = fStringPool . addSymbol ( childName ) ; String formAttrVal = child . getAttribute ( SchemaSymbols . ATT_FORM ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ALL ) ) { index = traverseAll ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; } else { reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "group" , childName } ) ; } if ( seeParticle ) { index = expandContentModel ( index , child ) ; } if ( left == - 2 ) { left = index ; } else if ( right == - 2 ) { right = index ; } else { left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; right = index ; } } if ( hadContent && right != - 2 ) left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; fNamespacesScope = saveNSMapping ; fTargetNSURI = saveTargetNSUri ; return left ; } int traverseSequence ( Element sequenceDecl ) throws Exception { Element child = XUtil . getFirstChildElement ( sequenceDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; int contentSpecType = 0 ; int csnType = 0 ; csnType = XMLContentSpec . CONTENTSPECNODE_SEQ ; contentSpecType = XMLElementDecl . TYPE_CHILDREN ; int left = - 2 ; int right = - 2 ; boolean hadContent = false ; for ( ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; hadContent = true ; boolean seeParticle = false ; String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; } else { reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "group" , childName } ) ; } if ( seeParticle ) { index = expandContentModel ( index , child ) ; } if ( left == - 2 ) { left = index ; } else if ( right == - 2 ) { right = index ; } else { left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; right = index ; } } if ( hadContent && right != - 2 ) left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; return left ; } int traverseChoice ( Element choiceDecl ) throws Exception { Element child = XUtil . getFirstChildElement ( choiceDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; int contentSpecType = 0 ; int csnType = 0 ; csnType = XMLContentSpec . CONTENTSPECNODE_CHOICE ; contentSpecType = XMLElementDecl . TYPE_CHILDREN ; int left = - 2 ; int right = - 2 ; boolean hadContent = false ; for ( ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; hadContent = true ; boolean seeParticle = false ; String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; } else { reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "group" , childName } ) ; } if ( seeParticle ) { index = expandContentModel ( index , child ) ; } if ( left == - 2 ) { left = index ; } else if ( right == - 2 ) { right = index ; } else { left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; right = index ; } } if ( hadContent && right != - 2 ) left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; return left ; } int traverseAll ( Element allDecl ) throws Exception { Element child = XUtil . getFirstChildElement ( allDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; int allChildren [ ] = null ; int allChildCount = 0 ; int left = - 2 ; for ( ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; boolean seeParticle = false ; String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; } else { reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "group" , childName } ) ; } if ( seeParticle ) { index = expandContentModel ( index , child ) ; } try { allChildren [ allChildCount ] = index ; } catch ( NullPointerException ne ) { allChildren = new int [ 32 ] ; allChildren [ allChildCount ] = index ; } catch ( ArrayIndexOutOfBoundsException ae ) { int [ ] newArray = new int [ allChildren . length * 2 ] ; System . arraycopy ( allChildren , 0 , newArray , 0 , allChildren . length ) ; allChildren [ allChildCount ] = index ; } allChildCount ++ ; } left = buildAllModel ( allChildren , allChildCount ) ; return left ; } private int buildAllModel ( int children [ ] , int count ) throws Exception { if ( count > 1 ) { XMLContentSpec choice = new XMLContentSpec ( ) ; choice . type = XMLContentSpec . CONTENTSPECNODE_CHOICE ; choice . value = - 1 ; choice . otherValue = - 1 ; int [ ] exactChildren = new int [ count ] ; System . arraycopy ( children , 0 , exactChildren , 0 , count ) ; sort ( exactChildren , 0 , count ) ; int index = buildAllModel ( exactChildren , 0 , choice ) ; return index ; } if ( count > 0 ) { return children [ 0 ] ; } return - 1 ; } private int buildAllModel ( int src [ ] , int offset , XMLContentSpec choice ) throws Exception { if ( src . length - offset == 2 ) { int seqIndex = createSeq ( src ) ; if ( choice . value == - 1 ) { choice . value = seqIndex ; } else { if ( choice . otherValue != - 1 ) { choice . value = fSchemaGrammar . addContentSpecNode ( choice . type , choice . value , choice . otherValue , false ) ; } choice . otherValue = seqIndex ; } swap ( src , offset , offset + 1 ) ; seqIndex = createSeq ( src ) ; if ( choice . value == - 1 ) { choice . value = seqIndex ; } else { if ( choice . otherValue != - 1 ) { choice . value = fSchemaGrammar . addContentSpecNode ( choice . type , choice . value , choice . otherValue , false ) ; } choice . otherValue = seqIndex ; } return fSchemaGrammar . addContentSpecNode ( choice . type , choice . value , choice . otherValue , false ) ; } for ( int i = offset ; i < src . length - 1 ; i ++ ) { choice . value = buildAllModel ( src , offset + 1 , choice ) ; choice . otherValue = - 1 ; sort ( src , offset , src . length - offset ) ; shift ( src , offset , i + 1 ) ; } int choiceIndex = buildAllModel ( src , offset + 1 , choice ) ; sort ( src , offset , src . length - offset ) ; return choiceIndex ; } private int createSeq ( int src [ ] ) throws Exception { int left = src [ 0 ] ; int right = src [ 1 ] ; for ( int i = 2 ; i < src . length ; i ++ ) { left = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , left , right , false ) ; right = src [ i ] ; } return fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , left , right , false ) ; } private void shift ( int src [ ] , int pos , int offset ) { int temp = src [ offset ] ; for ( int i = offset ; i > pos ; i -- ) { src [ i ] = src [ i - 1 ] ; } src [ pos ] = temp ; } private void sort ( int src [ ] , final int offset , final int length ) { for ( int i = offset ; i < offset + length - 1 ; i ++ ) { int lowest = i ; for ( int j = i + 1 ; j < offset + length ; j ++ ) { if ( src [ j ] < src [ lowest ] ) { lowest = j ; } } if ( lowest != i ) { int temp = src [ i ] ; src [ i ] = src [ lowest ] ; src [ lowest ] = temp ; } } } private void swap ( int src [ ] , int i , int j ) { int temp = src [ i ] ; src [ i ] = src [ j ] ; src [ j ] = temp ; } private int traverseWildcardDecl ( Element wildcardDecl ) throws Exception { int wildcardID = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATTVAL_ID ) ) ; int wildcardMaxOccurs = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATT_MAXOCCURS ) ) ; int wildcardMinOccurs = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATT_MINOCCURS ) ) ; int wildcardNamespace = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATT_NAMESPACE ) ) ; int wildcardProcessContents = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATT_PROCESSCONTENTS ) ) ; int wildcardContent = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATT_CONTENT ) ) ; return - 1 ; } private int parseInt ( String intString ) throws Exception { if ( intString . equals ( "*" ) ) { return SchemaSymbols . INFINITY ; } else { return Integer . parseInt ( intString ) ; } } private int parseSimpleDerivedBy ( String derivedByString ) throws Exception { if ( derivedByString . equals ( SchemaSymbols . ATTVAL_LIST ) ) { return SchemaSymbols . LIST ; } else if ( derivedByString . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { return SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "SimpleType: Invalid value for 'derivedBy'" ) ; return - 1 ; } } private int parseComplexDerivedBy ( String derivedByString ) throws Exception { if ( derivedByString . equals ( SchemaSymbols . ATTVAL_EXTENSION ) ) { return SchemaSymbols . EXTENSION ; } else if ( derivedByString . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { return SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "ComplexType: Invalid value for 'derivedBy'" ) ; return - 1 ; } } private int parseSimpleFinal ( String finalString ) throws Exception { if ( finalString . equals ( SchemaSymbols . ATTVAL_POUNDALL ) ) { return SchemaSymbols . ENUMERATION + SchemaSymbols . RESTRICTION + SchemaSymbols . LIST + SchemaSymbols . REPRODUCTION ; } else { int enumerate = 0 ; int restrict = 0 ; int list = 0 ; int reproduce = 0 ; StringTokenizer t = new StringTokenizer ( finalString , " " ) ; while ( t . hasMoreTokens ( ) ) { String token = t . nextToken ( ) ; if ( token . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { if ( restrict == 0 ) { restrict = SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "restriction in set twice" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_LIST ) ) { if ( list == 0 ) { list = SchemaSymbols . LIST ; } else { reportGenericSchemaError ( "list in set twice" ) ; } } else { reportGenericSchemaError ( "Invalid value (" + finalString + ")" ) ; } } return enumerate + restrict + list + reproduce ; } } private int parseComplexContent ( String contentString ) throws Exception { if ( contentString . equals ( SchemaSymbols . ATTVAL_EMPTY ) ) { return XMLElementDecl . TYPE_EMPTY ; } else if ( contentString . equals ( SchemaSymbols . ATTVAL_ELEMENTONLY ) ) { return XMLElementDecl . TYPE_CHILDREN ; } else if ( contentString . equals ( SchemaSymbols . ATTVAL_TEXTONLY ) ) { return XMLElementDecl . TYPE_SIMPLE ; } else if ( contentString . equals ( SchemaSymbols . ATTVAL_MIXED ) ) { return XMLElementDecl . TYPE_MIXED ; } else { reportGenericSchemaError ( "Invalid value for content" ) ; return - 1 ; } } private int parseDerivationSet ( String finalString ) throws Exception { if ( finalString . equals ( "#all" ) ) { return SchemaSymbols . EXTENSION + SchemaSymbols . RESTRICTION + SchemaSymbols . REPRODUCTION ; } else { int extend = 0 ; int restrict = 0 ; int reproduce = 0 ; StringTokenizer t = new StringTokenizer ( finalString , " " ) ; while ( t . hasMoreTokens ( ) ) { String token = t . nextToken ( ) ; if ( token . equals ( SchemaSymbols . ATTVAL_EXTENSION ) ) { if ( extend == 0 ) { extend = SchemaSymbols . EXTENSION ; } else { reportGenericSchemaError ( "extension already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { if ( restrict == 0 ) { restrict = SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "restriction already in set" ) ; } } else { reportGenericSchemaError ( "Invalid final value (" + finalString + ")" ) ; } } return extend + restrict + reproduce ; } } private int parseBlockSet ( String finalString ) throws Exception { if ( finalString . equals ( "#all" ) ) { return SchemaSymbols . EQUIVCLASS + SchemaSymbols . EXTENSION + SchemaSymbols . LIST + SchemaSymbols . RESTRICTION + SchemaSymbols . REPRODUCTION ; } else { int extend = 0 ; int restrict = 0 ; int reproduce = 0 ; StringTokenizer t = new StringTokenizer ( finalString , " " ) ; while ( t . hasMoreTokens ( ) ) { String token = t . nextToken ( ) ; if ( token . equals ( SchemaSymbols . ATTVAL_EQUIVCLASS ) ) { if ( extend == 0 ) { extend = SchemaSymbols . EQUIVCLASS ; } else { reportGenericSchemaError ( "'equivClass' already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_EXTENSION ) ) { if ( extend == 0 ) { extend = SchemaSymbols . EXTENSION ; } else { reportGenericSchemaError ( "extension already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_LIST ) ) { if ( extend == 0 ) { extend = SchemaSymbols . LIST ; } else { reportGenericSchemaError ( "'list' already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { if ( restrict == 0 ) { restrict = SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "restriction already in set" ) ; } } else { reportGenericSchemaError ( "Invalid final value (" + finalString + ")" ) ; } } return extend + restrict + reproduce ; } } private int parseFinalSet ( String finalString ) throws Exception { if ( finalString . equals ( "#all" ) ) { return SchemaSymbols . EQUIVCLASS + SchemaSymbols . EXTENSION + SchemaSymbols . LIST + SchemaSymbols . RESTRICTION + SchemaSymbols . REPRODUCTION ; } else { int extend = 0 ; int restrict = 0 ; int reproduce = 0 ; StringTokenizer t = new StringTokenizer ( finalString , " " ) ; while ( t . hasMoreTokens ( ) ) { String token = t . nextToken ( ) ; if ( token . equals ( SchemaSymbols . ATTVAL_EQUIVCLASS ) ) { if ( extend == 0 ) { extend = SchemaSymbols . EQUIVCLASS ; } else { reportGenericSchemaError ( "'equivClass' already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_EXTENSION ) ) { if ( extend == 0 ) { extend = SchemaSymbols . EXTENSION ; } else { reportGenericSchemaError ( "extension already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_LIST ) ) { if ( extend == 0 ) { extend = SchemaSymbols . LIST ; } else { reportGenericSchemaError ( "'list' already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { if ( restrict == 0 ) { restrict = SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "restriction already in set" ) ; } } else { reportGenericSchemaError ( "Invalid final value (" + finalString + ")" ) ; } } return extend + restrict + reproduce ; } } private void reportGenericSchemaError ( String error ) throws Exception { if ( fErrorReporter == null ) { System . err . println ( "__TraverseSchemaError__ : " + error ) ; } else { reportSchemaError ( SchemaMessageProvider . GenericError , new Object [ ] { error } ) ; } } private void reportSchemaError ( int major , Object args [ ] ) throws Exception { if ( fErrorReporter == null ) { System . out . println ( "__TraverseSchemaError__ : " + SchemaMessageProvider . fgMessageKeys [ major ] ) ; for ( int i = 0 ; i < args . length ; i ++ ) { System . out . println ( ( String ) args [ i ] ) ; } } else { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , SchemaMessageProvider . SCHEMA_DOMAIN , major , SchemaMessageProvider . MSG_NONE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } public static void main ( String args [ ] ) { if ( args . length != 1 ) { System . out . println ( "Error: Usage java TraverseSchema yourFile.xsd" ) ; System . exit ( 0 ) ; } DOMParser parser = new DOMParser ( ) { public void ignorableWhitespace ( char ch [ ] , int start , int length ) { } public void ignorableWhitespace ( int dataIdx ) { } } ; parser . setEntityResolver ( new Resolver ( ) ) ; parser . setErrorHandler ( new ErrorHandler ( ) ) ; try { parser . setFeature ( "http://xml.org/sax/features/validation" , false ) ; parser . setFeature ( "http://apache.org/xml/features/dom/defer-node-expansion" , false ) ; } catch ( org . xml . sax . SAXNotRecognizedException e ) { e . printStackTrace ( ) ; } catch ( org . xml . sax . SAXNotSupportedException e ) { e . printStackTrace ( ) ; } try { parser . parse ( args [ 0 ] ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( SAXException e ) { e . printStackTrace ( ) ; } Document document = parser . getDocument ( ) ; OutputFormat format = new OutputFormat ( document ) ; java . io . StringWriter outWriter = new java . io . StringWriter ( ) ; XMLSerializer serial = new XMLSerializer ( outWriter , format ) ; TraverseSchema tst = null ; try { Element root = document . getDocumentElement ( ) ; tst = new TraverseSchema ( root , new StringPool ( ) , new SchemaGrammar ( ) , ( GrammarResolver ) new GrammarResolverImpl ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( System . err ) ; } parser . getDocument ( ) ; } static class Resolver implements EntityResolver { private static final String SYSTEM [ ] = { "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/structures.dtd" , "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/datatypes.dtd" , "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/versionInfo.ent" , } ; private static final String PATH [ ] = { "structures.dtd" , "datatypes.dtd" , "versionInfo.ent" , } ; public InputSource resolveEntity ( String publicId , String systemId ) throws IOException { for ( int i = 0 ; i < SYSTEM . length ; i ++ ) { if ( systemId . equals ( SYSTEM [ i ] ) ) { InputSource source = new InputSource ( getClass ( ) . getResourceAsStream ( PATH [ i ] ) ) ; source . setPublicId ( publicId ) ; source . setSystemId ( systemId ) ; return source ; } } return null ; } } static class ErrorHandler implements org . xml . sax . ErrorHandler { public void warning ( SAXParseException ex ) { System . err . println ( "[Warning] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; } public void error ( SAXParseException ex ) { System . err . println ( "[Error] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; } public void fatalError ( SAXParseException ex ) throws SAXException { System . err . println ( "[Fatal Error] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; throw ex ; } private String getLocationString ( SAXParseException ex ) { StringBuffer str = new StringBuffer ( ) ; String systemId_ = ex . getSystemId ( ) ; if ( systemId_ != null ) { int index = systemId_ . lastIndexOf ( '/' ) ; if ( index != - 1 ) systemId_ = systemId_ . substring ( index + 1 ) ; str . append ( systemId_ ) ; } str . append ( ':' ) ; str . append ( ex . getLineNumber ( ) ) ; str . append ( ':' ) ; str . append ( ex . getColumnNumber ( ) ) ; return str . toString ( ) ; } } } 	1	['66', '1', '0', '27', '209', '1255', '4', '26', '8', '0.769230769', '8696', '0.962962963', '9', '0', '0.154871795', '0', '0', '130.3484848', '25', '1.697', '4']
package org . w3c . dom ; public interface Node { public static final short ELEMENT_NODE = 1 ; public static final short ATTRIBUTE_NODE = 2 ; public static final short TEXT_NODE = 3 ; public static final short CDATA_SECTION_NODE = 4 ; public static final short ENTITY_REFERENCE_NODE = 5 ; public static final short ENTITY_NODE = 6 ; public static final short PROCESSING_INSTRUCTION_NODE = 7 ; public static final short COMMENT_NODE = 8 ; public static final short DOCUMENT_NODE = 9 ; public static final short DOCUMENT_TYPE_NODE = 10 ; public static final short DOCUMENT_FRAGMENT_NODE = 11 ; public static final short NOTATION_NODE = 12 ; public String getNodeName ( ) ; public String getNodeValue ( ) throws DOMException ; public void setNodeValue ( String nodeValue ) throws DOMException ; public short getNodeType ( ) ; public Node getParentNode ( ) ; public NodeList getChildNodes ( ) ; public Node getFirstChild ( ) ; public Node getLastChild ( ) ; public Node getPreviousSibling ( ) ; public Node getNextSibling ( ) ; public NamedNodeMap getAttributes ( ) ; public Document getOwnerDocument ( ) ; public Node insertBefore ( Node newChild , Node refChild ) throws DOMException ; public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException ; public Node removeChild ( Node oldChild ) throws DOMException ; public Node appendChild ( Node newChild ) throws DOMException ; public boolean hasChildNodes ( ) ; public Node cloneNode ( boolean deep ) ; public void normalize ( ) ; public boolean supports ( String feature , String version ) ; public String getNamespaceURI ( ) ; public String getPrefix ( ) ; public void setPrefix ( String prefix ) throws DOMException ; public String getLocalName ( ) ; public boolean hasAttributes ( ) ; } 	1	['25', '1', '0', '0', '25', '300', '0', '0', '25', '1.041666667', '37', '0', '0', '0', '0.33', '0', '0', '0', '1', '1', '2']
package org . w3c . dom ; public interface Entity extends Node { public String getPublicId ( ) ; public String getSystemId ( ) ; public String getNotationName ( ) ; } 	1	['3', '1', '0', '0', '3', '3', '0', '0', '3', '2', '3', '0', '0', '0', '1', '0', '0', '0', '1', '1', '2']
package org . w3c . dom ; public interface Text extends CharacterData { public Text splitText ( int offset ) throws DOMException ; } 	1	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '2']
package org . w3c . dom . traversal ; import org . w3c . dom . Node ; public interface NodeFilter { public static final short FILTER_ACCEPT = 1 ; public static final short FILTER_REJECT = 2 ; public static final short FILTER_SKIP = 3 ; public static final int SHOW_ALL = 0xFFFFFFFF ; public static final int SHOW_ELEMENT = 0x00000001 ; public static final int SHOW_ATTRIBUTE = 0x00000002 ; public static final int SHOW_TEXT = 0x00000004 ; public static final int SHOW_CDATA_SECTION = 0x00000008 ; public static final int SHOW_ENTITY_REFERENCE = 0x00000010 ; public static final int SHOW_ENTITY = 0x00000020 ; public static final int SHOW_PROCESSING_INSTRUCTION = 0x00000040 ; public static final int SHOW_COMMENT = 0x00000080 ; public static final int SHOW_DOCUMENT = 0x00000100 ; public static final int SHOW_DOCUMENT_TYPE = 0x00000200 ; public static final int SHOW_DOCUMENT_FRAGMENT = 0x00000400 ; public static final int SHOW_NOTATION = 0x00000800 ; public short acceptNode ( Node n ) ; } 	1	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '17', '0', '0', '0', '1', '0', '0', '0', '1', '1', '2']
package org . w3c . dom ; public interface Notation extends Node { public String getPublicId ( ) ; public String getSystemId ( ) ; } 	1	['2', '1', '0', '0', '2', '1', '0', '0', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '2']
package org . apache . xerces . dom ; import org . w3c . dom . * ; import org . apache . xerces . dom . events . MutationEventImpl ; import org . w3c . dom . events . * ; public abstract class CharacterDataImpl extends ChildNode { static final long serialVersionUID = 7931170150428474230L ; protected String data ; private static transient NodeList singletonNodeList = new NodeList ( ) { public Node item ( int index ) { return null ; } public int getLength ( ) { return 0 ; } } ; protected CharacterDataImpl ( DocumentImpl ownerDocument , String data ) { super ( ownerDocument ) ; this . data = data ; } public NodeList getChildNodes ( ) { return singletonNodeList ; } public String getNodeValue ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return data ; } void setNodeValueInternal ( String value ) { setValueCalled ( true ) ; setNodeValue ( value ) ; setValueCalled ( false ) ; } public void setNodeValue ( String value ) { if ( isReadOnly ( ) ) throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; if ( needsSyncData ( ) ) { synchronizeData ( ) ; } String oldvalue = value ; EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } } this . data = value ; if ( ! setValueCalled ( ) ) { ownerDocument ( ) . replacedText ( this ) ; } if ( MUTATIONEVENTS ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_CHARACTER_DATA_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_CHARACTER_DATA_MODIFIED , true , false , null , oldvalue , value , null ) ; dispatchEvent ( me ) ; } dispatchAggregateEvents ( enclosingAttr ) ; } } public String getData ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return data ; } public int getLength ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return data . length ( ) ; } public void appendData ( String data ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } setNodeValue ( this . data + data ) ; } public void deleteData ( int offset , int count ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( count < 0 ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } int tailLength = Math . max ( data . length ( ) - count - offset , 0 ) ; try { setNodeValueInternal ( data . substring ( 0 , offset ) + ( tailLength > 0 ? data . substring ( offset + count , offset + count + tailLength ) : "" ) ) ; ownerDocument ( ) . deletedText ( this , offset , count ) ; } catch ( StringIndexOutOfBoundsException e ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } } public void insertData ( int offset , String data ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } try { setNodeValueInternal ( new StringBuffer ( this . data ) . insert ( offset , data ) . toString ( ) ) ; ownerDocument ( ) . insertedText ( this , offset , data . length ( ) ) ; } catch ( StringIndexOutOfBoundsException e ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } } public void replaceData ( int offset , int count , String data ) throws DOMException { deleteData ( offset , count ) ; insertData ( offset , data ) ; } public void setData ( String value ) throws DOMException { setNodeValue ( value ) ; } public String substringData ( int offset , int count ) throws DOMException { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } int length = data . length ( ) ; if ( count < 0 || offset < 0 || offset > length - 1 ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } int tailIndex = Math . min ( offset + count , length ) ; return data . substring ( offset , tailIndex ) ; } } 	1	['14', '3', '3', '10', '41', '17', '3', '7', '11', '0.717948718', '333', '0.666666667', '1', '0.806451613', '0.480769231', '1', '2', '22.57142857', '6', '1.5714', '2']
package org . apache . xerces . jaxp ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import org . xml . sax . SAXException ; public class DocumentBuilderFactoryImpl extends DocumentBuilderFactory { public DocumentBuilderFactoryImpl ( ) { super ( ) ; } public DocumentBuilder newDocumentBuilder ( ) throws ParserConfigurationException { return ( new DocumentBuilderImpl ( this . isNamespaceAware ( ) , this . isValidating ( ) ) ) ; } } 	1	['2', '2', '0', '1', '6', '1', '0', '1', '2', '2', '13', '0', '0', '0.958333333', '1', '0', '0', '5.5', '1', '0.5', '1']
package org . apache . xerces . parsers ; import org . apache . xerces . framework . XMLAttrList ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . framework . XMLDocumentHandler ; import org . apache . xerces . framework . XMLParser ; import org . apache . xerces . readers . XMLEntityHandler ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . validators . common . XMLAttributeDecl ; import org . apache . xerces . validators . common . XMLElementDecl ; import org . xml . sax . Attributes ; import org . xml . sax . AttributeList ; import org . xml . sax . ContentHandler ; import org . xml . sax . DocumentHandler ; import org . xml . sax . DTDHandler ; import org . xml . sax . EntityResolver ; import org . xml . sax . Parser ; import org . xml . sax . XMLReader ; import org . xml . sax . SAXException ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; import org . xml . sax . ext . DeclHandler ; import org . xml . sax . ext . LexicalHandler ; import org . xml . sax . helpers . AttributesImpl ; public class SAXParser extends XMLParser implements XMLDocumentHandler , XMLDocumentHandler . DTDHandler , Parser , XMLReader { private static final String RECOGNIZED_FEATURES [ ] = { "http://xml.org/sax/features/namespace-prefixes" , "http://xml.org/sax/features/string-interning" , } ; private static final String RECOGNIZED_PROPERTIES [ ] = { "http://xml.org/sax/properties/lexical-handler" , "http://xml.org/sax/properties/declaration-handler" , "http://xml.org/sax/properties/dom-node" , } ; private static final boolean DEBUG_CALLBACKS = false ; private DocumentHandler fDocumentHandler ; private org . xml . sax . DTDHandler fDTDHandler ; private ContentHandler fContentHandler ; private DeclHandler fDeclHandler ; private LexicalHandler fLexicalHandler ; private boolean fNamespacePrefixes = false ; private transient AttributesImpl fAttributes = new AttributesImpl ( ) ; public SAXParser ( ) { initHandlers ( true , this , this ) ; } public String [ ] getFeaturesRecognized ( ) { String superRecognized [ ] = super . getFeaturesRecognized ( ) ; String thisRecognized [ ] = RECOGNIZED_FEATURES ; int thisLength = thisRecognized . length ; if ( thisLength == 0 ) { return superRecognized ; } int superLength = superRecognized . length ; if ( superLength == 0 ) { return thisRecognized ; } String recognized [ ] = new String [ superLength + thisLength ] ; System . arraycopy ( superRecognized , 0 , recognized , 0 , superLength ) ; System . arraycopy ( thisRecognized , 0 , recognized , superLength , thisLength ) ; return recognized ; } public String [ ] getPropertiesRecognized ( ) { String superRecognized [ ] = super . getPropertiesRecognized ( ) ; String thisRecognized [ ] = RECOGNIZED_PROPERTIES ; int thisLength = thisRecognized . length ; if ( thisLength == 0 ) { return superRecognized ; } int superLength = superRecognized . length ; if ( superLength == 0 ) { return thisRecognized ; } String recognized [ ] = new String [ superLength + thisLength ] ; System . arraycopy ( superRecognized , 0 , recognized , 0 , superLength ) ; System . arraycopy ( thisRecognized , 0 , recognized , superLength , thisLength ) ; return recognized ; } protected void setDeclHandler ( DeclHandler handler ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( fParseInProgress ) { throw new SAXNotSupportedException ( "PAR011 Feature: http://xml.org/sax/properties/declaration-handler" + " is not supported during parse." + "\nhttp://xml.org/sax/properties/declaration-handler" ) ; } fDeclHandler = handler ; } protected DeclHandler getDeclHandler ( ) throws SAXNotRecognizedException , SAXNotSupportedException { return fDeclHandler ; } protected void setLexicalHandler ( LexicalHandler handler ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( fParseInProgress ) { throw new SAXNotSupportedException ( "PAR011 Feature: http://xml.org/sax/properties/lexical-handler" + " is not supported during parse." + "\nhttp://xml.org/sax/properties/lexical-handler" ) ; } fLexicalHandler = handler ; } protected LexicalHandler getLexicalHandler ( ) throws SAXNotRecognizedException , SAXNotSupportedException { return fLexicalHandler ; } public void setDocumentHandler ( DocumentHandler handler ) { fDocumentHandler = handler ; } public void setDTDHandler ( org . xml . sax . DTDHandler handler ) { fDTDHandler = handler ; } public org . xml . sax . DTDHandler getDTDHandler ( ) { return fDTDHandler ; } protected void setNamespacePrefixes ( boolean process ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( fParseInProgress ) { throw new SAXNotSupportedException ( "PAR004 Cannot setFeature(http://xml.org/sax/features/namespace-prefixes): parse is in progress.\n" + "http://xml.org/sax/features/namespace-prefixes" ) ; } fNamespacePrefixes = process ; } protected boolean getNamespacePrefixes ( ) throws SAXNotRecognizedException , SAXNotSupportedException { return fNamespacePrefixes ; } public void setFeature ( String featureId , boolean state ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( featureId . startsWith ( SAX2_FEATURES_PREFIX ) ) { String feature = featureId . substring ( SAX2_FEATURES_PREFIX . length ( ) ) ; if ( feature . equals ( "namespace-prefixes" ) ) { setNamespacePrefixes ( state ) ; return ; } if ( feature . equals ( "string-interning" ) ) { if ( state ) { throw new SAXNotSupportedException ( "PAR018 " + state + " state for feature \"" + featureId + "\" is not supported.\n" + state + '\t' + featureId ) ; } return ; } } super . setFeature ( featureId , state ) ; } public boolean getFeature ( String featureId ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( featureId . startsWith ( SAX2_FEATURES_PREFIX ) ) { String feature = featureId . substring ( SAX2_FEATURES_PREFIX . length ( ) ) ; if ( feature . equals ( "namespace-prefixes" ) ) { return getNamespacePrefixes ( ) ; } if ( feature . equals ( "string-interning" ) ) { return false ; } } return super . getFeature ( featureId ) ; } public void setProperty ( String propertyId , Object value ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( propertyId . startsWith ( SAX2_PROPERTIES_PREFIX ) ) { String property = propertyId . substring ( SAX2_PROPERTIES_PREFIX . length ( ) ) ; if ( property . equals ( "lexical-handler" ) ) { try { setLexicalHandler ( ( LexicalHandler ) value ) ; } catch ( ClassCastException e ) { throw new SAXNotSupportedException ( "PAR012 For propertyID \"" + propertyId + "\", the value \"" + value + "\" cannot be cast to LexicalHandler." + '\n' + propertyId + '\t' + value + "\tLexicalHandler" ) ; } return ; } if ( property . equals ( "declaration-handler" ) ) { try { setDeclHandler ( ( DeclHandler ) value ) ; } catch ( ClassCastException e ) { throw new SAXNotSupportedException ( "PAR012 For propertyID \"" + propertyId + "\", the value \"" + value + "\" cannot be cast to DeclHandler." + '\n' + propertyId + '\t' + value + "\tDeclHandler" ) ; } return ; } if ( property . equals ( "dom-node" ) ) { throw new SAXNotSupportedException ( "PAR013 Property \"" + propertyId + "\" is read only." + '\n' + propertyId ) ; } } super . setProperty ( propertyId , value ) ; } public Object getProperty ( String propertyId ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( propertyId . startsWith ( SAX2_PROPERTIES_PREFIX ) ) { String property = propertyId . substring ( SAX2_PROPERTIES_PREFIX . length ( ) ) ; if ( property . equals ( "lexical-handler" ) ) { return getLexicalHandler ( ) ; } if ( property . equals ( "declaration-handler" ) ) { return getDeclHandler ( ) ; } if ( property . equals ( "dom-node" ) ) { throw new SAXNotSupportedException ( "PAR014 Cannot getProperty(\"" + propertyId + "\". No DOM Tree exists.\n" + propertyId ) ; } } return super . getProperty ( propertyId ) ; } public void setContentHandler ( ContentHandler handler ) { if ( handler == null ) { throw new NullPointerException ( ) ; } fContentHandler = handler ; } public ContentHandler getContentHandler ( ) { return fContentHandler ; } public void startDTD ( QName rootElement , int publicId , int systemId ) throws Exception { if ( fLexicalHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( rootElement . rawname ) ; String pubid = fStringPool . toString ( publicId ) ; String sysid = fStringPool . toString ( systemId ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "startDTD(" + name + ", " + pubid + ", " + sysid + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . startDTD ( name , pubid , sysid ) ; } } } public void endDTD ( ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "endDTD()" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . endDTD ( ) ; } } public void elementDecl ( QName elementDecl , int contentSpecType , int contentSpecIndex , XMLContentSpec . Provider contentSpecProvider ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( elementDecl . rawname ) ; String contentModel ; if ( contentSpecType == XMLElementDecl . TYPE_ANY ) { contentModel = "ANY" ; } else if ( contentSpecType == XMLElementDecl . TYPE_EMPTY ) { contentModel = "EMPTY" ; } else { contentModel = XMLContentSpec . toString ( contentSpecProvider , fStringPool , contentSpecIndex ) ; } if ( DEBUG_CALLBACKS ) { System . err . println ( "elementDecl(" + name + ", " + contentModel + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . elementDecl ( name , contentModel ) ; } } } public void attlistDecl ( QName elementDecl , QName attributeDecl , int attType , boolean attList , String enumString , int attDefaultType , int attDefaultValue ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String eName = fStringPool . toString ( elementDecl . rawname ) ; String aName = fStringPool . toString ( attributeDecl . rawname ) ; String aType = enumString ; if ( attType != XMLAttributeDecl . TYPE_ENUMERATION ) { switch ( attType ) { case XMLAttributeDecl . TYPE_CDATA : { aType = "CDATA" ; break ; } case XMLAttributeDecl . TYPE_ENTITY : { aType = attList ? "ENTITIES" : "ENTITY" ; break ; } case XMLAttributeDecl . TYPE_ID : { aType = "ID" ; break ; } case XMLAttributeDecl . TYPE_IDREF : { aType = attList ? "IDREFS" : "IDREF" ; break ; } case XMLAttributeDecl . TYPE_NMTOKEN : { aType = attList ? "NMTOKENS" : "NMTOKEN" ; break ; } case XMLAttributeDecl . TYPE_NOTATION : { aType = "NOTATION" ; break ; } } } String aDefaultType = "" ; switch ( attDefaultType ) { case XMLAttributeDecl . DEFAULT_TYPE_FIXED : { aDefaultType = "#FIXED" ; break ; } case XMLAttributeDecl . DEFAULT_TYPE_IMPLIED : { aDefaultType = "#IMPLIED" ; break ; } case XMLAttributeDecl . DEFAULT_TYPE_REQUIRED : { aDefaultType = "#REQUIRED" ; break ; } } String aDefaultValue = fStringPool . toString ( attDefaultValue ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "attributeDecl(" + eName + ", " + aName + ", " + aType + ", " + aDefaultType + ", " + aDefaultValue + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . attributeDecl ( eName , aName , aType , aDefaultType , aDefaultValue ) ; } } } public void internalPEDecl ( int entityName , int entityValue ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String name = "%" + fStringPool . toString ( entityName ) ; String value = fStringPool . toString ( entityValue ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "internalEntityDecl(" + name + ", " + value + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . internalEntityDecl ( name , value ) ; } } } public void externalPEDecl ( int entityName , int publicId , int systemId ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String name = "%" + fStringPool . toString ( entityName ) ; String pubid = fStringPool . toString ( publicId ) ; String sysid = fStringPool . toString ( systemId ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "externalEntityDecl(" + name + ", " + pubid + ", " + sysid + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . externalEntityDecl ( name , pubid , sysid ) ; } } } public void internalEntityDecl ( int entityName , int entityValue ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( entityName ) ; String value = fStringPool . toString ( entityValue ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "internalEntityDecl(" + name + ", " + value + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . internalEntityDecl ( name , value ) ; } } } public void externalEntityDecl ( int entityName , int publicId , int systemId ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( entityName ) ; String pubid = fStringPool . toString ( publicId ) ; String sysid = fStringPool . toString ( systemId ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "externalEntityDecl(" + name + ", " + pubid + ", " + sysid + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . externalEntityDecl ( name , pubid , sysid ) ; } } } public void unparsedEntityDecl ( int entityName , int publicId , int systemId , int notationName ) throws Exception { if ( fDTDHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( entityName ) ; String pubid = fStringPool . toString ( publicId ) ; String sysid = fStringPool . toString ( systemId ) ; String notation = fStringPool . toString ( notationName ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "unparsedEntityDecl(" + name + ", " + pubid + ", " + sysid + ", " + notation + ")" ) ; } if ( fDTDHandler != null ) { fDTDHandler . unparsedEntityDecl ( name , pubid , sysid , notation ) ; } } } public void notationDecl ( int notationName , int publicId , int systemId ) throws Exception { if ( fDTDHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( notationName ) ; String pubid = fStringPool . toString ( publicId ) ; String sysid = fStringPool . toString ( systemId ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "notationDecl(" + name + ", " + pubid + ", " + sysid + ")" ) ; } if ( fDTDHandler != null ) { fDTDHandler . notationDecl ( name , pubid , sysid ) ; } } } public void startDocument ( ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "setDocumentLocator(<locator>)" ) ; System . err . println ( "startDocument()" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . setDocumentLocator ( getLocator ( ) ) ; fDocumentHandler . startDocument ( ) ; } if ( fContentHandler != null ) { fContentHandler . setDocumentLocator ( getLocator ( ) ) ; fContentHandler . startDocument ( ) ; } } public void endDocument ( ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "endDocument()" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . endDocument ( ) ; } if ( fContentHandler != null ) { fContentHandler . endDocument ( ) ; } } public void xmlDecl ( int versionIndex , int encodingIndex , int standaloneIndex ) throws Exception { if ( DEBUG_CALLBACKS ) { String notes = "" ; if ( versionIndex != - 1 ) notes += " version='" + fStringPool . toString ( versionIndex ) + "'" ; if ( encodingIndex != - 1 ) notes += " encoding='" + fStringPool . toString ( encodingIndex ) + "'" ; if ( standaloneIndex != - 1 ) notes += " standalone='" + fStringPool . toString ( standaloneIndex ) + "'" ; System . err . println ( "xmlDecl(<?xml" + notes + "?>)" ) ; } fStringPool . releaseString ( versionIndex ) ; fStringPool . releaseString ( encodingIndex ) ; fStringPool . releaseString ( standaloneIndex ) ; } public void textDecl ( int versionIndex , int encodingIndex ) throws Exception { if ( DEBUG_CALLBACKS ) { String notes = "" ; if ( versionIndex != - 1 ) notes += " version='" + fStringPool . toString ( versionIndex ) + "'" ; if ( encodingIndex != - 1 ) notes += " encoding='" + fStringPool . toString ( encodingIndex ) + "'" ; System . err . println ( "textDecl(<?xml" + notes + "?>)" ) ; } fStringPool . releaseString ( versionIndex ) ; fStringPool . releaseString ( encodingIndex ) ; } public void startNamespaceDeclScope ( int prefix , int uri ) throws Exception { if ( fContentHandler != null || DEBUG_CALLBACKS ) { String p = fStringPool . toString ( prefix ) ; String ns = fStringPool . toString ( uri ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "startNamespaceDeclScope(" + p + ", " + ns + ")" ) ; } if ( fContentHandler != null ) { fContentHandler . startPrefixMapping ( p , ns ) ; } } } public void endNamespaceDeclScope ( int prefix ) throws Exception { if ( fContentHandler != null || DEBUG_CALLBACKS ) { String p = fStringPool . toString ( prefix ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "endNamespaceDeclScope(" + p + ")" ) ; } if ( fContentHandler != null ) { fContentHandler . endPrefixMapping ( p ) ; } } } public void internalSubset ( int internalSubset ) { } public void startElement ( QName element , XMLAttrList attrList , int attrListIndex ) throws Exception { String name = fStringPool . toString ( element . rawname ) ; AttributeList attrs = attrList . getAttributeList ( attrListIndex ) ; if ( DEBUG_CALLBACKS ) { String atts = attrs . getLength ( ) > 0 ? "" : " " ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { atts += " " + attrs . getName ( i ) + "='" + attrs . getValue ( i ) + "'" ; } System . err . println ( "startElement(" + name + "," + atts + ")" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . startElement ( name , attrs ) ; } if ( fContentHandler != null ) { boolean namespaces = getNamespaces ( ) ; int uriIndex = element . uri ; String uri = uriIndex != - 1 && namespaces ? fStringPool . toString ( uriIndex ) : "" ; int localIndex = element . localpart ; String local = localIndex != - 1 && namespaces ? fStringPool . toString ( localIndex ) : "" ; String raw = name ; fAttributes . clear ( ) ; for ( int attrIndex = attrList . getFirstAttr ( attrListIndex ) ; attrIndex != - 1 ; attrIndex = attrList . getNextAttr ( attrIndex ) ) { int attrNameIndex = attrList . getAttrName ( attrIndex ) ; int attrUriIndex = attrList . getAttrURI ( attrIndex ) ; String attrUri = attrUriIndex != - 1 && namespaces ? fStringPool . toString ( attrUriIndex ) : "" ; int attrLocalIndex = attrList . getAttrLocalpart ( attrIndex ) ; String attrLocal = attrLocalIndex != - 1 && namespaces ? fStringPool . toString ( attrLocalIndex ) : "" ; String attrRaw = fStringPool . toString ( attrNameIndex ) ; String attrType = fStringPool . toString ( attrList . getAttType ( attrIndex ) ) ; String attrValue = fStringPool . toString ( attrList . getAttValue ( attrIndex ) ) ; int attrPrefix = attrList . getAttrPrefix ( attrIndex ) ; boolean namespacePrefixes = getNamespacePrefixes ( ) ; if ( ! namespaces || namespacePrefixes || ( attrPrefix != fStringPool . addSymbol ( "xmlns" ) && attrLocalIndex != fStringPool . addSymbol ( "xmlns" ) ) ) fAttributes . addAttribute ( attrUri , attrLocal , attrRaw , attrType , attrValue ) ; } fContentHandler . startElement ( uri , local , raw , fAttributes ) ; } attrList . releaseAttrList ( attrListIndex ) ; } public void endElement ( QName element ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "endElement(" + fStringPool . toString ( element . rawname ) + ")" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . endElement ( fStringPool . toString ( element . rawname ) ) ; } if ( fContentHandler != null ) { boolean namespaces = getNamespaces ( ) ; int uriIndex = element . uri ; String uri = uriIndex != - 1 && namespaces ? fStringPool . toString ( uriIndex ) : "" ; int localIndex = element . localpart ; String local = localIndex != - 1 && namespaces ? fStringPool . toString ( localIndex ) : "" ; String raw = fStringPool . toString ( element . rawname ) ; fContentHandler . endElement ( uri , local , raw ) ; } } public void startEntityReference ( int entityName , int entityType , int entityContext ) throws Exception { if ( fLexicalHandler != null || DEBUG_CALLBACKS ) { switch ( entityType ) { case XMLEntityHandler . ENTITYTYPE_INTERNAL_PE : case XMLEntityHandler . ENTITYTYPE_EXTERNAL_PE : if ( DEBUG_CALLBACKS ) { System . err . println ( "startEntity(%" + fStringPool . toString ( entityName ) + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . startEntity ( "%" + fStringPool . toString ( entityName ) ) ; } break ; case XMLEntityHandler . ENTITYTYPE_INTERNAL : case XMLEntityHandler . ENTITYTYPE_EXTERNAL : if ( DEBUG_CALLBACKS ) { System . err . println ( "startEntity(" + fStringPool . toString ( entityName ) + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . startEntity ( fStringPool . toString ( entityName ) ) ; } break ; case XMLEntityHandler . ENTITYTYPE_UNPARSED : throw new RuntimeException ( "PAR015 startEntityReference(): ENTITYTYPE_UNPARSED" ) ; case XMLEntityHandler . ENTITYTYPE_DOCUMENT : break ; case XMLEntityHandler . ENTITYTYPE_EXTERNAL_SUBSET : if ( DEBUG_CALLBACKS ) { System . err . println ( "startEntity(\"[dtd]\")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . startEntity ( "[dtd]" ) ; } break ; } } } public void endEntityReference ( int entityName , int entityType , int entityContext ) throws Exception { if ( fLexicalHandler != null || DEBUG_CALLBACKS ) { switch ( entityType ) { case XMLEntityHandler . ENTITYTYPE_INTERNAL_PE : case XMLEntityHandler . ENTITYTYPE_EXTERNAL_PE : if ( DEBUG_CALLBACKS ) { System . err . println ( "endEntity(%" + fStringPool . toString ( entityName ) + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . endEntity ( "%" + fStringPool . toString ( entityName ) ) ; } break ; case XMLEntityHandler . ENTITYTYPE_INTERNAL : case XMLEntityHandler . ENTITYTYPE_EXTERNAL : if ( DEBUG_CALLBACKS ) { System . err . println ( "endEntity(" + fStringPool . toString ( entityName ) + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . endEntity ( fStringPool . toString ( entityName ) ) ; } break ; case XMLEntityHandler . ENTITYTYPE_UNPARSED : throw new RuntimeException ( "PAR016 endEntityReference(): ENTITYTYPE_UNPARSED" ) ; case XMLEntityHandler . ENTITYTYPE_DOCUMENT : break ; case XMLEntityHandler . ENTITYTYPE_EXTERNAL_SUBSET : if ( DEBUG_CALLBACKS ) { System . err . println ( "endEntity(\"[dtd]\")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . endEntity ( "[dtd]" ) ; } break ; } } } public void startCDATA ( ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "startCDATA()" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . startCDATA ( ) ; } } public void endCDATA ( ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "endCDATA()" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . endCDATA ( ) ; } } public void characters ( int dataIndex ) throws Exception { throw new RuntimeException ( "PAR017 cannot happen 5\n5" ) ; } public void ignorableWhitespace ( int dataIndex ) throws Exception { throw new RuntimeException ( "PAR017 cannot happen 6\n6" ) ; } public void processingInstruction ( int piTarget , int piData ) throws Exception { if ( fDocumentHandler != null || fContentHandler != null || DEBUG_CALLBACKS ) { String target = fStringPool . orphanString ( piTarget ) ; String data = piData == - 1 ? "" : fStringPool . orphanString ( piData ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "processingInstruction(" + target + ", " + data + ")" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . processingInstruction ( target , data ) ; } if ( fContentHandler != null ) { fContentHandler . processingInstruction ( target , data ) ; } } else { fStringPool . releaseString ( piTarget ) ; fStringPool . releaseString ( piData ) ; } } public void comment ( int dataIndex ) throws Exception { if ( fLexicalHandler != null || DEBUG_CALLBACKS ) { String data = fStringPool . orphanString ( dataIndex ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "comment(" + data + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . comment ( data . toCharArray ( ) , 0 , data . length ( ) ) ; } } else { fStringPool . releaseString ( dataIndex ) ; } } public void characters ( char ch [ ] , int start , int length ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "characters(<char-data>) length " + length ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . characters ( ch , start , length ) ; } if ( fContentHandler != null ) { fContentHandler . characters ( ch , start , length ) ; } } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "ignorableWhitespace(<white-space>)" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . ignorableWhitespace ( ch , start , length ) ; } if ( fContentHandler != null ) { fContentHandler . ignorableWhitespace ( ch , start , length ) ; } } } 	1	['48', '2', '1', '10', '122', '568', '2', '8', '41', '0.90212766', '1384', '1', '6', '0.737142857', '0.141337386', '2', '9', '27.625', '3', '1.0625', '1']
package org . w3c . dom ; public interface DocumentType extends Node { public String getName ( ) ; public NamedNodeMap getEntities ( ) ; public NamedNodeMap getNotations ( ) ; public String getPublicId ( ) ; public String getSystemId ( ) ; public String getInternalSubset ( ) ; } 	1	['6', '1', '0', '0', '6', '15', '0', '0', '6', '2', '6', '0', '0', '0', '1', '0', '0', '0', '1', '1', '2']
package org . apache . xerces . dom ; import org . apache . xerces . domx . DOMException ; public class DOMExceptionImpl extends DOMException { public DOMExceptionImpl ( short code , String message ) { super ( code , message ) ; } } 	1	['1', '6', '0', '17', '2', '0', '16', '1', '1', '2', '6', '0', '0', '1', '1', '0', '0', '5', '0', '0', '1']
package org . w3c . dom ; public interface Comment extends CharacterData { } 	1	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '2']
package org . w3c . dom . traversal ; import org . w3c . dom . DOMException ; import org . w3c . dom . Node ; public interface TreeWalker { public Node getRoot ( ) ; public int getWhatToShow ( ) ; public NodeFilter getFilter ( ) ; public boolean getExpandEntityReferences ( ) ; public Node getCurrentNode ( ) ; public void setCurrentNode ( Node currentNode ) throws DOMException ; public Node parentNode ( ) ; public Node firstChild ( ) ; public Node lastChild ( ) ; public Node previousSibling ( ) ; public Node nextSibling ( ) ; public Node previousNode ( ) ; public Node nextNode ( ) ; } 	1	['13', '1', '0', '0', '13', '78', '0', '0', '13', '2', '13', '0', '0', '0', '0.538461538', '0', '0', '0', '1', '1', '2']
package org . apache . xerces . dom ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . w3c . dom . * ; import org . w3c . dom . traversal . * ; import org . w3c . dom . range . * ; import org . w3c . dom . events . * ; import org . apache . xerces . dom . events . * ; public class DocumentImpl extends ParentNode implements Document , DocumentTraversal , DocumentEvent , DocumentRange { static final long serialVersionUID = 515687835542616694L ; protected DocumentTypeImpl docType ; protected ElementImpl docElement ; protected Hashtable identifiers ; protected Vector iterators ; protected Vector ranges ; protected static int [ ] kidOK ; protected Hashtable userData ; protected Hashtable eventListeners ; protected int changes = 0 ; protected boolean allowGrammarAccess ; protected boolean errorChecking = true ; protected boolean mutationEvents = false ; static { kidOK = new int [ 13 ] ; kidOK [ DOCUMENT_NODE ] = 1 << ELEMENT_NODE | 1 << PROCESSING_INSTRUCTION_NODE | 1 << COMMENT_NODE | 1 << DOCUMENT_TYPE_NODE ; kidOK [ DOCUMENT_FRAGMENT_NODE ] = kidOK [ ENTITY_NODE ] = kidOK [ ENTITY_REFERENCE_NODE ] = kidOK [ ELEMENT_NODE ] = 1 << ELEMENT_NODE | 1 << PROCESSING_INSTRUCTION_NODE | 1 << COMMENT_NODE | 1 << TEXT_NODE | 1 << CDATA_SECTION_NODE | 1 << ENTITY_REFERENCE_NODE ; kidOK [ ATTRIBUTE_NODE ] = 1 << TEXT_NODE | 1 << ENTITY_REFERENCE_NODE ; kidOK [ DOCUMENT_TYPE_NODE ] = kidOK [ PROCESSING_INSTRUCTION_NODE ] = kidOK [ COMMENT_NODE ] = kidOK [ TEXT_NODE ] = kidOK [ CDATA_SECTION_NODE ] = kidOK [ NOTATION_NODE ] = 0 ; } public DocumentImpl ( ) { this ( false ) ; } public DocumentImpl ( boolean grammarAccess ) { super ( null ) ; ownerDocument = this ; allowGrammarAccess = grammarAccess ; } public DocumentImpl ( DocumentType doctype ) { this ( doctype , false ) ; } public DocumentImpl ( DocumentType doctype , boolean grammarAccess ) { this ( grammarAccess ) ; this . docType = ( DocumentTypeImpl ) doctype ; if ( this . docType != null ) { docType . ownerDocument = this ; } } final public Document getOwnerDocument ( ) { return null ; } public short getNodeType ( ) { return Node . DOCUMENT_NODE ; } public String getNodeName ( ) { return "#document" ; } public Node cloneNode ( boolean deep ) { DocumentImpl newdoc = new DocumentImpl ( ) ; if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } if ( deep ) { for ( ChildNode n = firstChild ; n != null ; n = n . nextSibling ) { newdoc . appendChild ( newdoc . importNode ( n , true ) ) ; } } newdoc . identifiers = null ; newdoc . iterators = null ; newdoc . ranges = null ; newdoc . userData = null ; newdoc . eventListeners = null ; newdoc . allowGrammarAccess = allowGrammarAccess ; newdoc . errorChecking = errorChecking ; newdoc . mutationEvents = mutationEvents ; return newdoc ; } public Node insertBefore ( Node newChild , Node refChild ) throws DOMException { int type = newChild . getNodeType ( ) ; if ( errorChecking ) { if ( ( type == Node . ELEMENT_NODE && docElement != null ) || ( type == Node . DOCUMENT_TYPE_NODE && docType != null ) ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } } super . insertBefore ( newChild , refChild ) ; if ( type == Node . ELEMENT_NODE ) { docElement = ( ElementImpl ) newChild ; } else if ( type == Node . DOCUMENT_TYPE_NODE ) { docType = ( DocumentTypeImpl ) newChild ; } return newChild ; } public Node removeChild ( Node oldChild ) throws DOMException { super . removeChild ( oldChild ) ; int type = oldChild . getNodeType ( ) ; if ( type == Node . ELEMENT_NODE ) { docElement = null ; } else if ( type == Node . DOCUMENT_TYPE_NODE ) { docType = null ; } return oldChild ; } public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException { super . replaceChild ( newChild , oldChild ) ; int type = oldChild . getNodeType ( ) ; if ( type == Node . ELEMENT_NODE ) { docElement = ( ElementImpl ) newChild ; } else if ( type == Node . DOCUMENT_TYPE_NODE ) { docType = ( DocumentTypeImpl ) newChild ; } return oldChild ; } public Attr createAttribute ( String name ) throws DOMException { if ( errorChecking && ! isXMLName ( name ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } return new AttrImpl ( this , name ) ; } public CDATASection createCDATASection ( String data ) throws DOMException { return new CDATASectionImpl ( this , data ) ; } public Comment createComment ( String data ) { return new CommentImpl ( this , data ) ; } public DocumentFragment createDocumentFragment ( ) { return new DocumentFragmentImpl ( this ) ; } public Element createElement ( String tagName ) throws DOMException { if ( errorChecking && ! isXMLName ( tagName ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } return new ElementImpl ( this , tagName ) ; } public EntityReference createEntityReference ( String name ) throws DOMException { if ( errorChecking && ! isXMLName ( name ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } return new EntityReferenceImpl ( this , name ) ; } public ProcessingInstruction createProcessingInstruction ( String target , String data ) throws DOMException { if ( errorChecking && ! isXMLName ( target ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } return new ProcessingInstructionImpl ( this , target , data ) ; } public Text createTextNode ( String data ) { return new TextImpl ( this , data ) ; } public DocumentType getDoctype ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return docType ; } public Element getDocumentElement ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return docElement ; } public NodeList getElementsByTagName ( String tagname ) { return new DeepNodeListImpl ( this , tagname ) ; } public DOMImplementation getImplementation ( ) { return DOMImplementationImpl . getDOMImplementation ( ) ; } public void setErrorChecking ( boolean check ) { errorChecking = check ; } public boolean getErrorChecking ( ) { return errorChecking ; } public void setMutationEvents ( boolean set ) { mutationEvents = set ; } public boolean getMutationEvents ( ) { return mutationEvents ; } public DocumentType createDocumentType ( String qualifiedName , String publicID , String systemID ) throws DOMException { if ( errorChecking && ! isXMLName ( qualifiedName ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } return new DocumentTypeImpl ( this , qualifiedName , publicID , systemID ) ; } public Entity createEntity ( String name ) throws DOMException { return new EntityImpl ( this , name ) ; } public Notation createNotation ( String name ) throws DOMException { return new NotationImpl ( this , name ) ; } public ElementDefinitionImpl createElementDefinition ( String name ) throws DOMException { return new ElementDefinitionImpl ( this , name ) ; } public Node importNode ( Node source , boolean deep ) throws DOMException { Node newnode = null ; DOMImplementation domImplementation = source . getOwnerDocument ( ) . getImplementation ( ) ; boolean domLevel20 = domImplementation . hasFeature ( "XML" , "2.0" ) ; int type = source . getNodeType ( ) ; switch ( type ) { case ELEMENT_NODE : { Element newelement ; if ( domLevel20 == true ) { if ( source . getLocalName ( ) == null ) { newelement = createElement ( source . getNodeName ( ) ) ; } else { newelement = createElementNS ( source . getNamespaceURI ( ) , source . getNodeName ( ) ) ; } } else { newelement = createElement ( source . getNodeName ( ) ) ; } NamedNodeMap srcattr = source . getAttributes ( ) ; if ( srcattr != null ) { for ( int i = 0 ; i < srcattr . getLength ( ) ; i ++ ) { Attr attr = ( Attr ) srcattr . item ( i ) ; if ( attr . getSpecified ( ) ) { Attr nattr = ( Attr ) importNode ( attr , true ) ; if ( domLevel20 == true ) { if ( attr . getLocalName ( ) == null ) newelement . setAttributeNode ( nattr ) ; else newelement . setAttributeNodeNS ( nattr ) ; } else { newelement . setAttributeNode ( nattr ) ; } } } } newnode = newelement ; break ; } case ATTRIBUTE_NODE : { if ( domLevel20 == true ) { if ( source . getLocalName ( ) == null ) { newnode = createAttribute ( source . getNodeName ( ) ) ; } else { newnode = createAttributeNS ( source . getNamespaceURI ( ) , source . getNodeName ( ) ) ; } } else { newnode = createAttribute ( source . getNodeName ( ) ) ; } deep = true ; break ; } case TEXT_NODE : { newnode = createTextNode ( source . getNodeValue ( ) ) ; break ; } case CDATA_SECTION_NODE : { newnode = createCDATASection ( source . getNodeValue ( ) ) ; break ; } case ENTITY_REFERENCE_NODE : { newnode = createEntityReference ( source . getNodeName ( ) ) ; ( ( EntityReferenceImpl ) newnode ) . isReadOnly ( false ) ; break ; } case ENTITY_NODE : { Entity srcentity = ( Entity ) source ; EntityImpl newentity = ( EntityImpl ) createEntity ( source . getNodeName ( ) ) ; newentity . setPublicId ( srcentity . getPublicId ( ) ) ; newentity . setSystemId ( srcentity . getSystemId ( ) ) ; newentity . setNotationName ( srcentity . getNotationName ( ) ) ; newentity . isReadOnly ( false ) ; newnode = newentity ; break ; } case PROCESSING_INSTRUCTION_NODE : { newnode = createProcessingInstruction ( source . getNodeName ( ) , source . getNodeValue ( ) ) ; break ; } case COMMENT_NODE : { newnode = createComment ( source . getNodeValue ( ) ) ; break ; } case DOCUMENT_TYPE_NODE : { DocumentType srcdoctype = ( DocumentType ) source ; DocumentTypeImpl newdoctype = ( DocumentTypeImpl ) createDocumentType ( srcdoctype . getNodeName ( ) , srcdoctype . getPublicId ( ) , srcdoctype . getSystemId ( ) ) ; NamedNodeMap smap = srcdoctype . getEntities ( ) ; NamedNodeMap tmap = newdoctype . getEntities ( ) ; if ( smap != null ) { for ( int i = 0 ; i < smap . getLength ( ) ; i ++ ) { tmap . setNamedItem ( importNode ( smap . item ( i ) , true ) ) ; } } smap = srcdoctype . getNotations ( ) ; tmap = newdoctype . getNotations ( ) ; if ( smap != null ) { for ( int i = 0 ; i < smap . getLength ( ) ; i ++ ) { tmap . setNamedItem ( importNode ( smap . item ( i ) , true ) ) ; } } newnode = newdoctype ; break ; } case DOCUMENT_FRAGMENT_NODE : { newnode = createDocumentFragment ( ) ; break ; } case NOTATION_NODE : { Notation srcnotation = ( Notation ) source ; NotationImpl newnotation = ( NotationImpl ) createNotation ( source . getNodeName ( ) ) ; newnotation . setPublicId ( srcnotation . getPublicId ( ) ) ; newnotation . setSystemId ( srcnotation . getSystemId ( ) ) ; newnode = newnotation ; break ; } case DOCUMENT_NODE : default : { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } } if ( deep ) { for ( Node srckid = source . getFirstChild ( ) ; srckid != null ; srckid = srckid . getNextSibling ( ) ) { newnode . appendChild ( importNode ( srckid , true ) ) ; } } if ( newnode . getNodeType ( ) == Node . ENTITY_REFERENCE_NODE || newnode . getNodeType ( ) == Node . ENTITY_NODE ) { ( ( NodeImpl ) newnode ) . setReadOnly ( true , true ) ; } return newnode ; } public void adoptNode ( Node source ) { if ( ! ( source instanceof NodeImpl ) ) { throw new DOMExceptionImpl ( DOMException . NOT_SUPPORTED_ERR , "cannot move a node in from another DOM implementation" ) ; } Node parent = source . getParentNode ( ) ; if ( parent != null ) { parent . removeChild ( source ) ; } ( ( NodeImpl ) source ) . setOwnerDocument ( this ) ; } public Element getElementById ( String elementId ) { return getIdentifier ( elementId ) ; } public void putIdentifier ( String idName , Element element ) { if ( element == null ) { removeIdentifier ( idName ) ; return ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( identifiers == null ) { identifiers = new Hashtable ( ) ; } identifiers . put ( idName , element ) ; } public Element getIdentifier ( String idName ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( identifiers == null ) { return null ; } return ( Element ) identifiers . get ( idName ) ; } public void removeIdentifier ( String idName ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( identifiers == null ) { return ; } identifiers . remove ( idName ) ; } public Enumeration getIdentifiers ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( identifiers == null ) { identifiers = new Hashtable ( ) ; } return identifiers . keys ( ) ; } public Element createElementNS ( String namespaceURI , String qualifiedName ) throws DOMException { return new ElementNSImpl ( this , namespaceURI , qualifiedName ) ; } public Attr createAttributeNS ( String namespaceURI , String qualifiedName ) throws DOMException { return new AttrNSImpl ( this , namespaceURI , qualifiedName ) ; } public NodeList getElementsByTagNameNS ( String namespaceURI , String localName ) { return new DeepNodeListImpl ( this , namespaceURI , localName ) ; } public NodeIterator createNodeIterator ( Node root , short whatToShow , NodeFilter filter ) { return createNodeIterator ( root , whatToShow , filter , true ) ; } public NodeIterator createNodeIterator ( Node root , int whatToShow , NodeFilter filter , boolean entityReferenceExpansion ) { NodeIterator iterator = new NodeIteratorImpl ( this , root , whatToShow , filter , entityReferenceExpansion ) ; if ( iterators == null ) { iterators = new Vector ( ) ; } iterators . addElement ( iterator ) ; return iterator ; } public TreeWalker createTreeWalker ( Node root , short whatToShow , NodeFilter filter ) { return createTreeWalker ( root , whatToShow , filter , true ) ; } public TreeWalker createTreeWalker ( Node root , int whatToShow , NodeFilter filter , boolean entityReferenceExpansion ) { if ( root == null ) { throw new DOMExceptionImpl ( DOMException . NOT_SUPPORTED_ERR , "DOM007 Not supported" ) ; } TreeWalker treeWalker = new TreeWalkerImpl ( root , whatToShow , filter , entityReferenceExpansion ) ; return treeWalker ; } void removeNodeIterator ( NodeIterator nodeIterator ) { if ( nodeIterator == null ) return ; if ( iterators == null ) return ; iterators . removeElement ( nodeIterator ) ; } public Range createRange ( ) { if ( ranges == null ) { ranges = new Vector ( ) ; } Range range = new RangeImpl ( this ) ; ranges . addElement ( range ) ; return range ; } void removeRange ( Range range ) { if ( range == null ) return ; if ( ranges == null ) return ; ranges . removeElement ( range ) ; } void replacedText ( Node node ) { if ( ranges != null ) { Enumeration enum = ranges . elements ( ) ; while ( enum . hasMoreElements ( ) ) { ( ( RangeImpl ) enum . nextElement ( ) ) . receiveReplacedText ( node ) ; } } } void deletedText ( Node node , int offset , int count ) { if ( ranges != null ) { Enumeration enum = ranges . elements ( ) ; while ( enum . hasMoreElements ( ) ) { ( ( RangeImpl ) enum . nextElement ( ) ) . receiveDeletedText ( node , offset , count ) ; } } } void insertedText ( Node node , int offset , int count ) { if ( ranges != null ) { Enumeration enum = ranges . elements ( ) ; while ( enum . hasMoreElements ( ) ) { ( ( RangeImpl ) enum . nextElement ( ) ) . receiveInsertedText ( node , offset , count ) ; } } } void splitData ( Node node , Node newNode , int offset ) { if ( ranges != null ) { Enumeration enum = ranges . elements ( ) ; while ( enum . hasMoreElements ( ) ) { ( ( RangeImpl ) enum . nextElement ( ) ) . receiveSplitData ( node , newNode , offset ) ; } } } void removedChildNode ( Node oldChild ) { if ( iterators != null ) { Enumeration enum = iterators . elements ( ) ; while ( enum . hasMoreElements ( ) ) { ( ( NodeIteratorImpl ) enum . nextElement ( ) ) . removeNode ( oldChild ) ; } } if ( ranges != null ) { Enumeration enum = ranges . elements ( ) ; while ( enum . hasMoreElements ( ) ) { ( ( RangeImpl ) enum . nextElement ( ) ) . removeNode ( oldChild ) ; } } } public Event createEvent ( String type ) throws DOMException { if ( "Event" . equals ( type ) ) return new EventImpl ( ) ; if ( "MutationEvent" . equals ( type ) ) return new MutationEventImpl ( ) ; else throw new DOMExceptionImpl ( DOMExceptionImpl . UNSUPPORTED_EVENT_TYPE , "DOM007 Not supported" ) ; } public Object clone ( ) throws CloneNotSupportedException { DocumentImpl newdoc = ( DocumentImpl ) super . clone ( ) ; newdoc . docType = null ; newdoc . docElement = null ; return newdoc ; } public static boolean isXMLName ( String s ) { if ( s == null ) { return false ; } char [ ] ca = new char [ s . length ( ) ] ; s . getChars ( 0 , s . length ( ) , ca , 0 ) ; if ( ! Character . isLetter ( ca [ 0 ] ) && "_:" . indexOf ( ( int ) ca [ 0 ] ) == - 1 ) { return false ; } for ( int i = 1 ; i < s . length ( ) ; ++ i ) { char c = ca [ i ] ; int ctype = Character . getType ( c ) ; if ( ! Character . isLetterOrDigit ( c ) && ( ".-_:" . indexOf ( c ) == - 1 ) && ( ! ( ctype >= 6 && ctype <= 8 && ! ( ( c >= 0x06dd && c <= 0x06de ) || ( c >= 0x20dd && c <= 0x20e0 ) || c >= 0x309b ) ) ) && ( ! ( ctype == 4 && ! ( ( c >= 0x02d0 && c <= 0x0559 ) || ( c >= 0x06e5 && c <= 0x06e6 ) || ( c >= 0x309b && c <= 0x309c ) ) || c == 0x00b7 || c == 0x0387 ) ) ) { return false ; } } return true ; } protected void setUserData ( NodeImpl n , Object data ) { if ( userData == null ) { userData = new Hashtable ( ) ; } if ( data == null ) { userData . remove ( n ) ; } else { userData . put ( n , data ) ; } } protected Object getUserData ( NodeImpl n ) { if ( userData == null ) { return null ; } return userData . get ( n ) ; } protected void setEventListeners ( NodeImpl n , Vector listeners ) { if ( eventListeners == null ) { eventListeners = new Hashtable ( ) ; } if ( listeners == null ) { eventListeners . remove ( n ) ; if ( eventListeners . isEmpty ( ) ) { mutationEvents = false ; } } else { eventListeners . put ( n , listeners ) ; mutationEvents = true ; } } protected Vector getEventListeners ( NodeImpl n ) { if ( eventListeners == null ) { return null ; } return ( Vector ) eventListeners . get ( n ) ; } protected boolean isKidOK ( Node parent , Node child ) { if ( allowGrammarAccess && parent . getNodeType ( ) == Node . DOCUMENT_TYPE_NODE ) { return child . getNodeType ( ) == Node . ELEMENT_NODE ; } return 0 != ( kidOK [ parent . getNodeType ( ) ] & 1 << child . getNodeType ( ) ) ; } protected void changed ( ) { changes ++ ; } protected int changes ( ) { return changes ; } } 	1	['62', '4', '3', '53', '161', '1649', '48', '25', '49', '0.926229508', '1344', '0.916666667', '2', '0.580882353', '0.155107188', '2', '19', '20.48387097', '23', '1.9516', '2']
package org . w3c . dom ; public interface ProcessingInstruction extends Node { public String getTarget ( ) ; public String getData ( ) ; public void setData ( String data ) throws DOMException ; } 	1	['3', '1', '0', '0', '3', '3', '0', '0', '3', '2', '3', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '2']
package org . apache . xerces . dom ; import java . io . * ; import java . util . Vector ; import org . w3c . dom . * ; import org . apache . xerces . dom . events . EventImpl ; import org . apache . xerces . dom . events . MutationEventImpl ; import org . w3c . dom . events . * ; public abstract class NodeImpl implements Node , NodeList , EventTarget , Cloneable , Serializable { static final long serialVersionUID = - 6316591992167219696L ; public static final short ELEMENT_DEFINITION_NODE = - 1 ; protected NodeImpl ownerNode ; protected short flags ; protected final static short READONLY = 0x1 << 0 ; protected final static short SYNCDATA = 0x1 << 1 ; protected final static short SYNCCHILDREN = 0x1 << 2 ; protected final static short OWNED = 0x1 << 3 ; protected final static short FIRSTCHILD = 0x1 << 4 ; protected final static short SPECIFIED = 0x1 << 5 ; protected final static short IGNORABLEWS = 0x1 << 6 ; protected final static short SETVALUE = 0x1 << 7 ; protected NodeImpl ( DocumentImpl ownerDocument ) { ownerNode = ownerDocument ; } public NodeImpl ( ) { } public abstract short getNodeType ( ) ; public abstract String getNodeName ( ) ; public String getNodeValue ( ) { return null ; } public void setNodeValue ( String x ) throws DOMException { } public Node appendChild ( Node newChild ) throws DOMException { return insertBefore ( newChild , null ) ; } public Node cloneNode ( boolean deep ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } NodeImpl newnode ; try { newnode = ( NodeImpl ) clone ( ) ; } catch ( CloneNotSupportedException e ) { return null ; } newnode . ownerNode = ownerDocument ( ) ; newnode . isOwned ( false ) ; newnode . isReadOnly ( false ) ; return newnode ; } public Document getOwnerDocument ( ) { if ( isOwned ( ) ) { return ownerNode . ownerDocument ( ) ; } else { return ( Document ) ownerNode ; } } DocumentImpl ownerDocument ( ) { if ( isOwned ( ) ) { return ownerNode . ownerDocument ( ) ; } else { return ( DocumentImpl ) ownerNode ; } } void setOwnerDocument ( DocumentImpl doc ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( ! isOwned ( ) ) { ownerNode = doc ; } } public Node getParentNode ( ) { return null ; } NodeImpl parentNode ( ) { return null ; } public Node getNextSibling ( ) { return null ; } public Node getPreviousSibling ( ) { return null ; } ChildNode previousSibling ( ) { return null ; } public NamedNodeMap getAttributes ( ) { return null ; } public boolean hasAttributes ( ) { return false ; } public boolean hasChildNodes ( ) { return false ; } public NodeList getChildNodes ( ) { return this ; } public Node getFirstChild ( ) { return null ; } public Node getLastChild ( ) { return null ; } public Node insertBefore ( Node newChild , Node refChild ) throws DOMException { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } public Node removeChild ( Node oldChild ) throws DOMException { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } public int getLength ( ) { return 0 ; } public Node item ( int index ) { return null ; } public void normalize ( ) { } public boolean supports ( String feature , String version ) { return ownerDocument ( ) . getImplementation ( ) . hasFeature ( feature , version ) ; } public String getNamespaceURI ( ) { return null ; } public String getPrefix ( ) { return null ; } public void setPrefix ( String prefix ) throws DOMException { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } public String getLocalName ( ) { return null ; } protected final static boolean MUTATIONEVENTS = true ; protected final static int MUTATION_NONE = 0x00 ; protected final static int MUTATION_LOCAL = 0x01 ; protected final static int MUTATION_AGGREGATE = 0x02 ; protected final static int MUTATION_ALL = 0xffff ; class LEntry { String type ; EventListener listener ; boolean useCapture ; LEntry ( String type , EventListener listener , boolean useCapture ) { this . type = type ; this . listener = listener ; this . useCapture = useCapture ; } } ; public void addEventListener ( String type , EventListener listener , boolean useCapture ) { if ( type == null || type . equals ( "" ) || listener == null ) return ; removeEventListener ( type , listener , useCapture ) ; Vector nodeListeners = ownerDocument ( ) . getEventListeners ( this ) ; if ( nodeListeners == null ) { nodeListeners = new Vector ( ) ; ownerDocument ( ) . setEventListeners ( this , nodeListeners ) ; } nodeListeners . addElement ( new LEntry ( type , listener , useCapture ) ) ; LCount lc = LCount . lookup ( type ) ; if ( useCapture ) ++ lc . captures ; else ++ lc . bubbles ; } public void removeEventListener ( String type , EventListener listener , boolean useCapture ) { Vector nodeListeners = ownerDocument ( ) . getEventListeners ( this ) ; if ( nodeListeners == null || type == null || type . equals ( "" ) || listener == null ) return ; for ( int i = nodeListeners . size ( ) - 1 ; i >= 0 ; -- i ) { LEntry le = ( LEntry ) ( nodeListeners . elementAt ( i ) ) ; if ( le . useCapture == useCapture && le . listener == listener && le . type . equals ( type ) ) { nodeListeners . removeElementAt ( i ) ; if ( nodeListeners . size ( ) == 0 ) ownerDocument ( ) . setEventListeners ( this , null ) ; LCount lc = LCount . lookup ( type ) ; if ( useCapture ) -- lc . captures ; else -- lc . bubbles ; break ; } } } public boolean dispatchEvent ( Event event ) { if ( event == null ) return false ; EventImpl evt = ( EventImpl ) event ; if ( ! evt . initialized || evt . type == null || evt . type . equals ( "" ) ) throw new DOMExceptionImpl ( DOMExceptionImpl . UNSPECIFIED_EVENT_TYPE , "DOM010 Unspecified event type" ) ; LCount lc = LCount . lookup ( evt . getType ( ) ) ; if ( lc . captures + lc . bubbles + lc . defaults == 0 ) return evt . preventDefault ; evt . target = this ; evt . stopPropagation = false ; evt . preventDefault = false ; Vector pv = new Vector ( 10 , 10 ) ; Node p = this , n = p . getParentNode ( ) ; while ( n != null ) { pv . addElement ( n ) ; p = n ; n = n . getParentNode ( ) ; } if ( lc . captures > 0 ) { evt . eventPhase = Event . CAPTURING_PHASE ; for ( int j = pv . size ( ) - 1 ; j >= 0 ; -- j ) { if ( evt . stopPropagation ) break ; NodeImpl nn = ( NodeImpl ) pv . elementAt ( j ) ; evt . currentNode = nn ; Vector nodeListeners = ownerDocument ( ) . getEventListeners ( nn ) ; if ( nodeListeners != null ) { Vector nl = ( Vector ) ( nodeListeners . clone ( ) ) ; for ( int i = nl . size ( ) - 1 ; i >= 0 ; -- i ) { LEntry le = ( LEntry ) ( nl . elementAt ( i ) ) ; if ( le . useCapture && le . type . equals ( evt . type ) ) try { le . listener . handleEvent ( evt ) ; } catch ( Exception e ) { } } } } } if ( lc . bubbles > 0 ) { evt . eventPhase = Event . AT_TARGET ; evt . currentNode = this ; Vector nodeListeners = ownerDocument ( ) . getEventListeners ( this ) ; if ( ! evt . stopPropagation && nodeListeners != null ) { Vector nl = ( Vector ) nodeListeners . clone ( ) ; for ( int i = nl . size ( ) - 1 ; i >= 0 ; -- i ) { LEntry le = ( LEntry ) nl . elementAt ( i ) ; if ( le != null && ! le . useCapture && le . type . equals ( evt . type ) ) try { le . listener . handleEvent ( evt ) ; } catch ( Exception e ) { } } } if ( evt . bubbles ) { evt . eventPhase = Event . BUBBLING_PHASE ; for ( int j = 0 ; j < pv . size ( ) ; ++ j ) { if ( evt . stopPropagation ) break ; NodeImpl nn = ( NodeImpl ) pv . elementAt ( j ) ; evt . currentNode = nn ; nodeListeners = ownerDocument ( ) . getEventListeners ( nn ) ; if ( nodeListeners != null ) { Vector nl = ( Vector ) ( nodeListeners . clone ( ) ) ; for ( int i = nl . size ( ) - 1 ; i >= 0 ; -- i ) { LEntry le = ( LEntry ) ( nl . elementAt ( i ) ) ; if ( ! le . useCapture && le . type . equals ( evt . type ) ) try { le . listener . handleEvent ( evt ) ; } catch ( Exception e ) { } } } } } } if ( lc . defaults > 0 && ( ! evt . cancelable || ! evt . preventDefault ) ) { } return evt . preventDefault ; } void dispatchEventToSubtree ( Node n , Event e ) { if ( MUTATIONEVENTS && ownerDocument ( ) . mutationEvents ) { Vector nodeListeners = ownerDocument ( ) . getEventListeners ( this ) ; if ( nodeListeners == null || n == null ) return ; ( ( NodeImpl ) n ) . dispatchEvent ( e ) ; if ( n . getNodeType ( ) == Node . ELEMENT_NODE ) { NamedNodeMap a = n . getAttributes ( ) ; for ( int i = a . getLength ( ) - 1 ; i >= 0 ; -- i ) dispatchEventToSubtree ( a . item ( i ) , e ) ; } dispatchEventToSubtree ( n . getFirstChild ( ) , e ) ; dispatchEventToSubtree ( n . getNextSibling ( ) , e ) ; } } class EnclosingAttr { AttrImpl node ; String oldvalue ; } EnclosingAttr getEnclosingAttr ( ) { if ( MUTATIONEVENTS && ownerDocument ( ) . mutationEvents ) { NodeImpl eventAncestor = this ; while ( true ) { if ( eventAncestor == null ) return null ; int type = eventAncestor . getNodeType ( ) ; if ( type == Node . ATTRIBUTE_NODE ) { EnclosingAttr retval = new EnclosingAttr ( ) ; retval . node = ( AttrImpl ) eventAncestor ; retval . oldvalue = retval . node . getNodeValue ( ) ; return retval ; } else if ( type == Node . ENTITY_REFERENCE_NODE ) eventAncestor = eventAncestor . parentNode ( ) ; else return null ; } } return null ; } void dispatchAggregateEvents ( EnclosingAttr ea ) { if ( ea != null ) dispatchAggregateEvents ( ea . node , ea . oldvalue ) ; else dispatchAggregateEvents ( null , null ) ; } void dispatchAggregateEvents ( AttrImpl enclosingAttr , String oldvalue ) { if ( MUTATIONEVENTS && ownerDocument ( ) . mutationEvents ) { Vector nodeListeners = ownerDocument ( ) . getEventListeners ( this ) ; if ( nodeListeners == null ) return ; NodeImpl owner = null ; if ( enclosingAttr != null ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { owner = ( ( NodeImpl ) ( enclosingAttr . getOwnerElement ( ) ) ) ; if ( owner != null ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_ATTR_MODIFIED , true , false , null , oldvalue , enclosingAttr . getNodeValue ( ) , enclosingAttr . getNodeName ( ) ) ; owner . dispatchEvent ( me ) ; } } } LCount lc = LCount . lookup ( MutationEventImpl . DOM_SUBTREE_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_SUBTREE_MODIFIED , true , false , null , null , null , null ) ; if ( enclosingAttr != null ) { enclosingAttr . dispatchEvent ( me ) ; if ( owner != null ) owner . dispatchEvent ( me ) ; } else dispatchEvent ( me ) ; } } } public void setReadOnly ( boolean readOnly , boolean deep ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } isReadOnly ( readOnly ) ; } public boolean getReadOnly ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return isReadOnly ( ) ; } public void setUserData ( Object data ) { ownerDocument ( ) . setUserData ( this , data ) ; } public Object getUserData ( ) { return ownerDocument ( ) . getUserData ( this ) ; } protected void changed ( ) { ownerDocument ( ) . changed ( ) ; } protected int changes ( ) { return ownerDocument ( ) . changes ( ) ; } protected void synchronizeData ( ) { needsSyncData ( false ) ; } final boolean isReadOnly ( ) { return ( flags & READONLY ) != 0 ; } final void isReadOnly ( boolean value ) { flags = ( short ) ( value ? flags | READONLY : flags & ~ READONLY ) ; } final boolean needsSyncData ( ) { return ( flags & SYNCDATA ) != 0 ; } final void needsSyncData ( boolean value ) { flags = ( short ) ( value ? flags | SYNCDATA : flags & ~ SYNCDATA ) ; } final boolean needsSyncChildren ( ) { return ( flags & SYNCCHILDREN ) != 0 ; } final void needsSyncChildren ( boolean value ) { flags = ( short ) ( value ? flags | SYNCCHILDREN : flags & ~ SYNCCHILDREN ) ; } final boolean isOwned ( ) { return ( flags & OWNED ) != 0 ; } final void isOwned ( boolean value ) { flags = ( short ) ( value ? flags | OWNED : flags & ~ OWNED ) ; } final boolean isFirstChild ( ) { return ( flags & FIRSTCHILD ) != 0 ; } final void isFirstChild ( boolean value ) { flags = ( short ) ( value ? flags | FIRSTCHILD : flags & ~ FIRSTCHILD ) ; } final boolean isSpecified ( ) { return ( flags & SPECIFIED ) != 0 ; } final void isSpecified ( boolean value ) { flags = ( short ) ( value ? flags | SPECIFIED : flags & ~ SPECIFIED ) ; } final boolean internalIsIgnorableWhitespace ( ) { return ( flags & IGNORABLEWS ) != 0 ; } final void isIgnorableWhitespace ( boolean value ) { flags = ( short ) ( value ? flags | IGNORABLEWS : flags & ~ IGNORABLEWS ) ; } final boolean setValueCalled ( ) { return ( flags & SETVALUE ) != 0 ; } final void setValueCalled ( boolean value ) { flags = ( short ) ( value ? flags | SETVALUE : flags & ~ SETVALUE ) ; } public String toString ( ) { return "[" + getNodeName ( ) + ": " + getNodeValue ( ) + "]" ; } private void writeObject ( ObjectOutputStream out ) throws IOException { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } out . defaultWriteObject ( ) ; } } 	1	['66', '1', '3', '25', '106', '1829', '21', '9', '36', '0.967521368', '1123', '0.833333333', '1', '0', '0.116550117', '0', '0', '15.74242424', '31', '2.2727', '2']
package org . apache . xerces . validators . datatype ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Locale ; import java . util . Vector ; import java . io . IOException ; import org . apache . xerces . validators . schema . SchemaSymbols ; import org . apache . xerces . utils . regex . RegularExpression ; public class DecimalDatatypeValidator extends AbstractDatatypeValidator { private Locale fLocale = null ; private DatatypeValidator fBaseValidator = null ; private boolean fDerivedByList = false ; private BigDecimal [ ] fEnumDecimal = null ; private String fPattern = null ; private BigDecimal fMaxInclusive = null ; private BigDecimal fMaxExclusive = null ; private BigDecimal fMinInclusive = null ; private BigDecimal fMinExclusive = null ; private int fFacetsDefined = 0 ; private int fScale = 0 ; private int fPrecision = 0 ; private boolean isMaxExclusiveDefined = false ; private boolean isMaxInclusiveDefined = false ; private boolean isMinExclusiveDefined = false ; private boolean isMinInclusiveDefined = false ; private boolean isScaleDefined = false ; private boolean isPrecisionDefined = false ; private DatatypeMessageProvider fMessageProvider = new DatatypeMessageProvider ( ) ; private RegularExpression fRegex = null ; private Hashtable fFacets = null ; public DecimalDatatypeValidator ( ) throws InvalidDatatypeFacetException { this ( null , null , false ) ; } public DecimalDatatypeValidator ( DatatypeValidator base , Hashtable facets , boolean derivedByList ) throws InvalidDatatypeFacetException { setBasetype ( base ) ; fDerivedByList = derivedByList ; if ( facets != null ) { fFacets = checkForFacetConsistency ( facets , base . getFacets ( ) ) ; fFacets = facets ; if ( fDerivedByList == false ) { Vector enumeration = null ; String value = null ; for ( Enumeration e = facets . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; try { if ( key . equals ( SchemaSymbols . ELT_PATTERN ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_PATTERN ; fPattern = value ; if ( fPattern != null ) fRegex = new RegularExpression ( fPattern , "X" ) ; } else if ( key . equals ( SchemaSymbols . ELT_ENUMERATION ) ) { fFacetsDefined += DatatypeValidator . FACET_ENUMERATION ; enumeration = ( Vector ) facets . get ( key ) ; } else if ( key . equals ( SchemaSymbols . ELT_MAXINCLUSIVE ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_MAXINCLUSIVE ; fMaxInclusive = new BigDecimal ( stripPlusIfPresent ( value ) ) ; } else if ( key . equals ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_MAXEXCLUSIVE ; fMaxExclusive = new BigDecimal ( stripPlusIfPresent ( value ) ) ; } else if ( key . equals ( SchemaSymbols . ELT_MININCLUSIVE ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_MININCLUSIVE ; fMinInclusive = new BigDecimal ( stripPlusIfPresent ( value ) ) ; } else if ( key . equals ( SchemaSymbols . ELT_MINEXCLUSIVE ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_MINEXCLUSIVE ; fMinExclusive = new BigDecimal ( stripPlusIfPresent ( value ) ) ; } else if ( key . equals ( SchemaSymbols . ELT_PRECISION ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_PRECISSION ; isPrecisionDefined = true ; fPrecision = Integer . parseInt ( value ) ; } else if ( key . equals ( SchemaSymbols . ELT_SCALE ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_SCALE ; isScaleDefined = true ; fScale = Integer . parseInt ( value ) ; } else { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . MSG_FORMAT_FAILURE , DatatypeMessageProvider . MSG_NONE , null ) ) ; } } catch ( Exception ex ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . IllegalFacetValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { value , key } ) ) ; } } isMaxExclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MAXEXCLUSIVE ) != 0 ) ? true : false ; isMaxInclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MAXINCLUSIVE ) != 0 ) ? true : false ; isMinExclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MINEXCLUSIVE ) != 0 ) ? true : false ; isMinInclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MININCLUSIVE ) != 0 ) ? true : false ; if ( isMaxExclusiveDefined && isMaxInclusiveDefined ) { throw new InvalidDatatypeFacetException ( "It is an error for both maxInclusive and maxExclusive to be specified for the same datatype." ) ; } if ( isMinExclusiveDefined && isMinInclusiveDefined ) { throw new InvalidDatatypeFacetException ( "It is an error for both minInclusive and minExclusive to be specified for the same datatype." ) ; } if ( isMaxExclusiveDefined && isMinExclusiveDefined ) { int compareTo = this . fMaxExclusive . compareTo ( this . fMinExclusive ) ; if ( compareTo != 1 ) throw new InvalidDatatypeFacetException ( "maxExclusive value ='" + this . fMaxExclusive + "'must be > than minExclusive value ='" + this . fMinExclusive + "'. " ) ; } if ( isMaxInclusiveDefined && isMinInclusiveDefined ) { int compareTo = this . fMaxInclusive . compareTo ( this . fMinInclusive ) ; if ( compareTo == - 1 ) throw new InvalidDatatypeFacetException ( "maxInclusive value ='" + this . fMaxInclusive + "'must be >= than minInclusive value ='" + this . fMinInclusive + "'. " ) ; } if ( isMaxExclusiveDefined && isMinInclusiveDefined ) { int compareTo = this . fMaxExclusive . compareTo ( this . fMinInclusive ) ; if ( compareTo != 1 ) throw new InvalidDatatypeFacetException ( "maxExclusive value ='" + this . fMaxExclusive + "'must be > than minInclusive value ='" + this . fMinInclusive + "'. " ) ; } if ( isMaxInclusiveDefined && isMinExclusiveDefined ) { int compareTo = this . fMaxInclusive . compareTo ( this . fMinExclusive ) ; if ( compareTo != 1 ) throw new InvalidDatatypeFacetException ( "maxInclusive value ='" + this . fMaxInclusive + "'must be > than minExclusive value ='" + this . fMinExclusive + "'. " ) ; } if ( ( fFacetsDefined & DatatypeValidator . FACET_ENUMERATION ) != 0 ) { if ( enumeration != null ) { fEnumDecimal = new BigDecimal [ enumeration . size ( ) ] ; int i = 0 ; try { for ( ; i < enumeration . size ( ) ; i ++ ) { fEnumDecimal [ i ] = new BigDecimal ( stripPlusIfPresent ( ( ( String ) enumeration . elementAt ( i ) ) ) ) ; boundsCheck ( fEnumDecimal [ i ] ) ; } } catch ( Exception idve ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . InvalidEnumValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { enumeration . elementAt ( i ) } ) ) ; } } } } else { } } } public Object validate ( String content , Object state ) throws InvalidDatatypeValueException { if ( fDerivedByList == false ) { if ( this . fBaseValidator != null ) { this . fBaseValidator . validate ( content , state ) ; } if ( ( fFacetsDefined & DatatypeValidator . FACET_PATTERN ) != 0 ) { if ( fRegex == null || fRegex . matches ( content ) == false ) throw new InvalidDatatypeValueException ( "Value'" + content + "' does not match regular expression facet " + fRegex . getPattern ( ) ) ; } BigDecimal d = null ; try { d = new BigDecimal ( stripPlusIfPresent ( content ) ) ; } catch ( Exception nfe ) { throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . NotDecimal , DatatypeMessageProvider . MSG_NONE , new Object [ ] { "'" + content + "'" } ) ) ; } if ( isScaleDefined == true ) { if ( d . scale ( ) > fScale ) throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . ScaleExceeded , DatatypeMessageProvider . MSG_NONE , new Object [ ] { content } ) ) ; } if ( isPrecisionDefined == true ) { int precision = d . movePointRight ( d . scale ( ) ) . toString ( ) . length ( ) - ( ( d . signum ( ) < 0 ) ? 1 : 0 ) ; if ( precision > fPrecision ) throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . PrecisionExceeded , DatatypeMessageProvider . MSG_NONE , new Object [ ] { content } ) ) ; } boundsCheck ( d ) ; if ( fEnumDecimal != null ) enumCheck ( d ) ; } else { } return null ; } public void boundsCheck ( BigDecimal d ) throws InvalidDatatypeValueException { boolean minOk = false ; boolean maxOk = false ; String upperBound = ( fMaxExclusive != null ) ? ( fMaxExclusive . toString ( ) ) : ( ( fMaxInclusive != null ) ? fMaxInclusive . toString ( ) : "" ) ; String lowerBound = ( fMinExclusive != null ) ? ( fMinExclusive . toString ( ) ) : ( ( fMinInclusive != null ) ? fMinInclusive . toString ( ) : "" ) ; String lowerBoundIndicator = "" ; String upperBoundIndicator = "" ; if ( isMaxInclusiveDefined ) { maxOk = ( d . compareTo ( fMaxInclusive ) <= 0 ) ; upperBound = fMaxInclusive . toString ( ) ; if ( upperBound != null ) { upperBoundIndicator = "<=" ; } else { upperBound = "" ; } } else if ( isMaxExclusiveDefined ) { maxOk = ( d . compareTo ( fMaxExclusive ) < 0 ) ; upperBound = fMaxExclusive . toString ( ) ; if ( upperBound != null ) { upperBoundIndicator = "<" ; } else { upperBound = "" ; } } else { maxOk = ( ! isMaxInclusiveDefined && ! isMaxExclusiveDefined ) ; } if ( isMinInclusiveDefined ) { minOk = ( d . compareTo ( fMinInclusive ) >= 0 ) ; lowerBound = fMinInclusive . toString ( ) ; if ( lowerBound != null ) { lowerBoundIndicator = "<=" ; } else { lowerBound = "" ; } } else if ( isMinExclusiveDefined ) { minOk = ( d . compareTo ( fMinExclusive ) > 0 ) ; lowerBound = fMinExclusive . toString ( ) ; if ( lowerBound != null ) { lowerBoundIndicator = "<" ; } else { lowerBound = "" ; } } else { minOk = ( ! isMinInclusiveDefined && ! isMinExclusiveDefined ) ; } if ( ! ( minOk && maxOk ) ) throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . OutOfBounds , DatatypeMessageProvider . MSG_NONE , new Object [ ] { d . toString ( ) , lowerBound , upperBound , lowerBoundIndicator , upperBoundIndicator } ) ) ; } private void enumCheck ( BigDecimal v ) throws InvalidDatatypeValueException { for ( int i = 0 ; i < fEnumDecimal . length ; i ++ ) { if ( v . equals ( fEnumDecimal [ i ] ) ) { return ; } } throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . NotAnEnumValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { v } ) ) ; } public void setLocale ( Locale locale ) { fLocale = locale ; } public Hashtable getFacets ( ) { return fFacets ; } private String getErrorString ( int major , int minor , Object args [ ] ) { try { return fMessageProvider . createMessage ( fLocale , major , minor , args ) ; } catch ( Exception e ) { return "Illegal Errorcode " + minor ; } } public Object clone ( ) throws CloneNotSupportedException { throw new CloneNotSupportedException ( "clone() is not supported in " + this . getClass ( ) . getName ( ) ) ; } public int compare ( String content1 , String content2 ) { return 0 ; } private void setBasetype ( DatatypeValidator base ) { fBaseValidator = base ; } static private String stripPlusIfPresent ( String value ) { String strippedPlus = value ; if ( value . length ( ) >= 2 && value . charAt ( 0 ) == '+' && value . charAt ( 1 ) != '-' ) { strippedPlus = value . substring ( 1 ) ; } return strippedPlus ; } private Hashtable checkForFacetConsistency ( Hashtable thisTypeFacets , Hashtable baseTypeFacets ) throws InvalidDatatypeFacetException { String thisTypeFacetValue ; String baseValue ; if ( baseTypeFacets != null ) { Enumeration setOfBaseKeys = baseTypeFacets . keys ( ) ; String keyInBase ; BigDecimal valueOfThisType = null ; BigDecimal valueOfBase = null ; while ( setOfBaseKeys . hasMoreElements ( ) ) { keyInBase = ( String ) setOfBaseKeys . nextElement ( ) ; baseValue = ( String ) baseTypeFacets . get ( keyInBase ) ; thisTypeFacetValue = ( String ) thisTypeFacets . get ( keyInBase ) ; if ( thisTypeFacetValue == null ) { String strThisType = null ; thisTypeFacets . put ( keyInBase , baseValue ) ; if ( keyInBase . equals ( SchemaSymbols . ELT_MAXEXCLUSIVE ) && thisTypeFacets . containsKey ( SchemaSymbols . ELT_MAXINCLUSIVE ) ) { strThisType = ( String ) thisTypeFacets . get ( SchemaSymbols . ELT_MAXINCLUSIVE ) ; valueOfThisType = new BigDecimal ( stripPlusIfPresent ( strThisType ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( valueOfThisType . compareTo ( valueOfBase ) == - 1 ) { thisTypeFacets . remove ( keyInBase ) ; } else { thisTypeFacets . remove ( SchemaSymbols . ELT_MAXINCLUSIVE ) ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MAXINCLUSIVE ) && thisTypeFacets . containsKey ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ) { strThisType = ( String ) thisTypeFacets . get ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ; valueOfThisType = new BigDecimal ( stripPlusIfPresent ( strThisType ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( valueOfThisType . compareTo ( valueOfBase ) == - 1 ) { thisTypeFacets . remove ( keyInBase ) ; } else { thisTypeFacets . remove ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MINEXCLUSIVE ) && thisTypeFacets . containsKey ( SchemaSymbols . ELT_MININCLUSIVE ) ) { strThisType = ( String ) thisTypeFacets . get ( SchemaSymbols . ELT_MININCLUSIVE ) ; valueOfThisType = new BigDecimal ( stripPlusIfPresent ( strThisType ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( valueOfThisType . compareTo ( valueOfBase ) == 1 ) { thisTypeFacets . remove ( keyInBase ) ; } else { thisTypeFacets . remove ( SchemaSymbols . ELT_MININCLUSIVE ) ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MININCLUSIVE ) && thisTypeFacets . containsKey ( SchemaSymbols . ELT_MINEXCLUSIVE ) ) { strThisType = ( String ) thisTypeFacets . get ( SchemaSymbols . ELT_MINEXCLUSIVE ) ; valueOfThisType = new BigDecimal ( stripPlusIfPresent ( strThisType ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( valueOfThisType . compareTo ( valueOfBase ) == 1 ) { thisTypeFacets . remove ( keyInBase ) ; } else { thisTypeFacets . remove ( SchemaSymbols . ELT_MINEXCLUSIVE ) ; } } } else { if ( keyInBase . equals ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ) { valueOfThisType = new BigDecimal ( stripPlusIfPresent ( thisTypeFacetValue ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( ( valueOfThisType . compareTo ( valueOfBase ) ) == - 1 ) { ; } else { ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MAXINCLUSIVE ) ) { valueOfThisType = new BigDecimal ( stripPlusIfPresent ( thisTypeFacetValue ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( ( valueOfThisType . compareTo ( valueOfBase ) ) == - 1 ) { ; } else { ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MINEXCLUSIVE ) ) { valueOfThisType = new BigDecimal ( stripPlusIfPresent ( thisTypeFacetValue ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( ( valueOfThisType . compareTo ( valueOfBase ) ) == - 1 ) { ; } else { ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MININCLUSIVE ) ) { valueOfThisType = new BigDecimal ( stripPlusIfPresent ( thisTypeFacetValue ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( ( valueOfThisType . compareTo ( valueOfBase ) ) == - 1 ) { ; } else { ; } } } } } return thisTypeFacets ; } } 	1	['13', '2', '0', '7', '52', '58', '1', '6', '8', '0.76984127', '1337', '1', '3', '0.266666667', '0.2', '0', '0', '100.2307692', '4', '1.0769', '1']
package javax . xml . parsers ; public class FactoryConfigurationError extends Error { private Exception exception = null ; public FactoryConfigurationError ( ) { this ( null , null ) ; } public FactoryConfigurationError ( String msg ) { this ( null , msg ) ; } public FactoryConfigurationError ( Exception e ) { this ( e , null ) ; } public FactoryConfigurationError ( Exception e , String msg ) { super ( msg ) ; this . exception = e ; } public Exception getException ( ) { return ( this . exception ) ; } } 	1	['5', '3', '0', '0', '6', '8', '0', '0', '5', '0', '34', '1', '0', '0.944444444', '0.6', '0', '0', '5.6', '1', '0.2', '1']
package org . w3c . dom ; public interface DocumentFragment extends Node { } 	1	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '2']
package org . w3c . dom . events ; import org . w3c . dom . Node ; public interface MutationEvent extends Event { public Node getRelatedNode ( ) ; public String getPrevValue ( ) ; public String getNewValue ( ) ; public String getAttrName ( ) ; public void initMutationEvent ( String typeArg , boolean canBubbleArg , boolean cancelableArg , Node relatedNodeArg , String prevValueArg , String newValueArg , String attrNameArg ) ; } 	1	['5', '1', '0', '0', '5', '10', '0', '0', '5', '2', '5', '0', '0', '0', '0.4', '0', '0', '0', '1', '1', '2']
package org . apache . xerces . dom ; import org . w3c . dom . * ; import org . w3c . dom . traversal . * ; import org . apache . xerces . dom . DocumentImpl ; import org . apache . xerces . dom . DOMExceptionImpl ; public class NodeIteratorImpl implements NodeIterator { private DocumentImpl fDocument ; private Node fRoot ; private int fWhatToShow = NodeFilter . SHOW_ALL ; private NodeFilter fNodeFilter ; private boolean fDetach = false ; private Node fCurrentNode ; private boolean fForward = true ; private boolean fEntityReferenceExpansion ; public NodeIteratorImpl ( DocumentImpl document , Node root , int whatToShow , NodeFilter nodeFilter , boolean entityReferenceExpansion ) { fDocument = document ; fRoot = root ; fCurrentNode = null ; fWhatToShow = whatToShow ; fNodeFilter = nodeFilter ; fEntityReferenceExpansion = entityReferenceExpansion ; } public Node getRoot ( ) { return fRoot ; } public int getWhatToShow ( ) { return fWhatToShow ; } public NodeFilter getFilter ( ) { return fNodeFilter ; } public boolean getExpandEntityReferences ( ) { return fEntityReferenceExpansion ; } public Node nextNode ( ) { if ( fDetach ) { throw new DOMExceptionImpl ( DOMExceptionImpl . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( fRoot == null ) return null ; Node nextNode = fCurrentNode ; boolean accepted = false ; accepted_loop : while ( ! accepted ) { if ( ! fForward && nextNode != null ) { nextNode = fCurrentNode ; } else { if ( ! fEntityReferenceExpansion && nextNode != null && nextNode . getNodeType ( ) == Node . ENTITY_REFERENCE_NODE ) { nextNode = nextNode ( nextNode , false ) ; } else { nextNode = nextNode ( nextNode , true ) ; } } fForward = true ; if ( nextNode == null ) return null ; accepted = acceptNode ( nextNode ) ; if ( accepted ) { fCurrentNode = nextNode ; return fCurrentNode ; } else continue accepted_loop ; } return null ; } public Node previousNode ( ) { if ( fDetach ) { throw new DOMExceptionImpl ( DOMExceptionImpl . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( fRoot == null || fCurrentNode == null ) return null ; Node previousNode = fCurrentNode ; boolean accepted = false ; accepted_loop : while ( ! accepted ) { if ( fForward && previousNode != null ) { previousNode = fCurrentNode ; } else { previousNode = previousNode ( previousNode ) ; } fForward = false ; if ( previousNode == null ) return null ; accepted = acceptNode ( previousNode ) ; if ( accepted ) { fCurrentNode = previousNode ; return fCurrentNode ; } else continue accepted_loop ; } return null ; } boolean acceptNode ( Node node ) { if ( fNodeFilter == null ) { return ( fWhatToShow & ( 1 << node . getNodeType ( ) - 1 ) ) != 0 ; } else { return ( ( fWhatToShow & ( 1 << node . getNodeType ( ) - 1 ) ) != 0 ) && fNodeFilter . acceptNode ( node ) == NodeFilter . FILTER_ACCEPT ; } } Node matchNodeOrParent ( Node node ) { for ( Node n = node ; n != fRoot ; n = n . getParentNode ( ) ) { if ( node == n ) return n ; } return null ; } Node nextNode ( Node node , boolean visitChildren ) { if ( node == null ) return fRoot ; Node result ; if ( visitChildren ) { if ( node . hasChildNodes ( ) ) { result = node . getFirstChild ( ) ; return result ; } } result = node . getNextSibling ( ) ; if ( result != null ) return result ; Node parent = node . getParentNode ( ) ; while ( parent != null && parent != fRoot ) { result = parent . getNextSibling ( ) ; if ( result != null ) { return result ; } else { parent = parent . getParentNode ( ) ; } } return null ; } Node previousNode ( Node node ) { Node result ; if ( node == fRoot ) return null ; result = node . getPreviousSibling ( ) ; if ( result == null ) { result = node . getParentNode ( ) ; return result ; } if ( result . hasChildNodes ( ) && ! ( ! fEntityReferenceExpansion && result != null && result . getNodeType ( ) == Node . ENTITY_REFERENCE_NODE ) ) { while ( result . hasChildNodes ( ) ) { result = result . getLastChild ( ) ; } } return result ; } public void removeNode ( Node node ) { if ( node == null ) return ; Node deleted = matchNodeOrParent ( node ) ; if ( deleted == null ) return ; if ( fForward ) { fCurrentNode = previousNode ( deleted ) ; } else { Node next = nextNode ( deleted , false ) ; if ( next != null ) { fCurrentNode = next ; } else { fCurrentNode = previousNode ( deleted ) ; fForward = true ; } } } public void detach ( ) { fDetach = true ; fDocument . removeNodeIterator ( this ) ; } } 	1	['13', '1', '0', '2', '24', '8', '1', '2', '9', '0.6875', '374', '1', '4', '0', '0.307692308', '0', '0', '27.15384615', '11', '4.1538', '1']
package org . apache . xerces . readers ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . utils . CharDataChunk ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringHasher ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . utils . XMLCharacterProperties ; import org . apache . xerces . utils . ImplementationMessages ; import org . xml . sax . SAXParseException ; import java . util . Vector ; abstract class AbstractCharReader extends XMLEntityReader { protected AbstractCharReader ( XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , boolean sendCharDataAsCharArray , StringPool stringPool ) { super ( entityHandler , errorReporter , sendCharDataAsCharArray ) ; fStringPool = stringPool ; fCurrentChunk = CharDataChunk . createChunk ( fStringPool , null ) ; } protected CharDataChunk fCurrentChunk = null ; protected int fCurrentIndex = 0 ; protected char [ ] fMostRecentData = null ; protected int fMostRecentChar = 0 ; protected int fLength = 0 ; protected abstract int fillCurrentChunk ( ) throws Exception ; protected void deferException ( int errorCode , Object [ ] args , int offset ) { if ( fDeferredErrors == null ) fDeferredErrors = new Vector ( ) ; DeferredError de = new DeferredError ( errorCode , args , offset ) ; fDeferredErrors . addElement ( de ) ; } protected XMLEntityHandler . EntityReader changeReaders ( ) throws Exception { XMLEntityHandler . EntityReader nextReader = super . changeReaders ( ) ; fCurrentChunk . releaseChunk ( ) ; fCurrentChunk = null ; return nextReader ; } public void append ( XMLEntityHandler . CharBuffer charBuffer , int offset , int length ) { fCurrentChunk . append ( charBuffer , offset , length ) ; } public int addString ( int offset , int length ) { if ( length == 0 ) return 0 ; return fCurrentChunk . addString ( offset , length ) ; } public int addSymbol ( int offset , int length ) { if ( length == 0 ) return 0 ; return fCurrentChunk . addSymbol ( offset , length , 0 ) ; } public boolean lookingAtChar ( char chr , boolean skipPastChar ) throws Exception { int ch = fMostRecentChar ; if ( ch != chr ) { if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtChar ( chr , skipPastChar ) ; } } return false ; } if ( skipPastChar ) { fCharacterCounter ++ ; fCurrentOffset ++ ; if ( ++ fCurrentIndex == CharDataChunk . CHUNK_SIZE ) slowLoadNextChar ( ) ; else fMostRecentChar = fMostRecentData [ fCurrentIndex ] & 0xFFFF ; } return true ; } public boolean lookingAtValidChar ( boolean skipPastChar ) throws Exception { int ch = fMostRecentChar ; if ( ch < 0xD800 ) { if ( ch >= 0x20 || ch == 0x09 ) { if ( skipPastChar ) { fCharacterCounter ++ ; loadNextChar ( ) ; } return true ; } if ( ch == 0x0A ) { if ( skipPastChar ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; loadNextChar ( ) ; } return true ; } if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtValidChar ( skipPastChar ) ; } } return false ; } if ( ch > 0xFFFD ) { return false ; } if ( ch < 0xDC00 ) { CharDataChunk savedChunk = fCurrentChunk ; int savedIndex = fCurrentIndex ; int savedOffset = fCurrentOffset ; ch = loadNextChar ( ) ; boolean valid = ( ch >= 0xDC00 && ch < 0xE000 ) ; if ( ! valid || ! skipPastChar ) { fCurrentChunk = savedChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = savedOffset ; fMostRecentData = savedChunk . toCharArray ( ) ; fMostRecentChar = fMostRecentData [ savedIndex ] & 0xFFFF ; return valid ; } } else if ( ch < 0xE000 ) { return false ; } if ( skipPastChar ) { fCharacterCounter ++ ; loadNextChar ( ) ; } return true ; } public boolean lookingAtSpace ( boolean skipPastChar ) throws Exception { int ch = fMostRecentChar ; if ( ch > 0x20 ) return false ; if ( ch == 0x20 || ch == 0x09 ) { if ( ! skipPastChar ) return true ; fCharacterCounter ++ ; } else if ( ch == 0x0A ) { if ( ! skipPastChar ) return true ; fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else { if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtSpace ( skipPastChar ) ; } } return false ; } fCurrentOffset ++ ; if ( ++ fCurrentIndex == CharDataChunk . CHUNK_SIZE ) slowLoadNextChar ( ) ; else fMostRecentChar = fMostRecentData [ fCurrentIndex ] & 0xFFFF ; return true ; } public void skipToChar ( char chr ) throws Exception { int ch = fMostRecentChar ; while ( true ) { if ( ch == chr ) return ; if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) . skipToChar ( chr ) ; return ; } fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch >= 0xD800 && ch < 0xDC00 ) { fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch < 0xDC00 || ch >= 0xE000 ) continue ; } else fCharacterCounter ++ ; ch = loadNextChar ( ) ; } } public void skipPastSpaces ( ) throws Exception { int ch = fMostRecentChar ; while ( true ) { if ( ch == 0x20 || ch == 0x09 ) { fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else { if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) changeReaders ( ) . skipPastSpaces ( ) ; return ; } ch = loadNextChar ( ) ; } } public void skipPastName ( char fastcheck ) throws Exception { int ch = fMostRecentChar ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) return ; } while ( true ) { fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( fastcheck == ch ) return ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) return ; } } } public void skipPastNmtoken ( char fastcheck ) throws Exception { int ch = fMostRecentChar ; while ( true ) { if ( fastcheck == ch ) return ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) return ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; } } public boolean skippedString ( char [ ] s ) throws Exception { int length = s . length ; char [ ] data = fMostRecentData ; int index = fCurrentIndex ; if ( index + length <= CharDataChunk . CHUNK_SIZE ) { for ( int i = 0 ; i < length ; i ++ ) { if ( data [ index ++ ] != s [ i ] ) return false ; } fCharacterCounter += length ; fCurrentOffset += length ; fCurrentIndex = index ; if ( index == CharDataChunk . CHUNK_SIZE ) slowLoadNextChar ( ) ; else fMostRecentChar = data [ index ] & 0xFFFF ; return true ; } CharDataChunk dataChunk = fCurrentChunk ; int offset = fCurrentOffset ; int savedIndex = index ; int i = 0 ; while ( index < CharDataChunk . CHUNK_SIZE ) { if ( data [ index ++ ] != s [ i ++ ] ) return false ; } slowLoadNextChar ( ) ; data = fMostRecentData ; index = 0 ; while ( i < length ) { if ( data [ index ++ ] != s [ i ++ ] ) { fCurrentChunk = dataChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = offset ; fMostRecentData = dataChunk . toCharArray ( ) ; fMostRecentChar = fMostRecentData [ savedIndex ] & 0xFFFF ; return false ; } } fCharacterCounter += length ; fCurrentOffset += length ; fCurrentIndex = index ; if ( index == CharDataChunk . CHUNK_SIZE ) slowLoadNextChar ( ) ; else fMostRecentChar = data [ index ] & 0xFFFF ; return true ; } public int scanInvalidChar ( ) throws Exception { int ch = fMostRecentChar ; if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; loadNextChar ( ) ; } else if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . scanInvalidChar ( ) ; } if ( fDeferredErrors != null ) { for ( int i = 0 ; i < fDeferredErrors . size ( ) ; i ++ ) { DeferredError de = ( DeferredError ) fDeferredErrors . elementAt ( i ) ; if ( de . offset == fCurrentIndex ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , de . errorCode , 0 , de . args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; fDeferredErrors . removeElementAt ( i ) ; fCharacterCounter ++ ; loadNextChar ( ) ; return - 1 ; } } } fCharacterCounter ++ ; loadNextChar ( ) ; } else { fCharacterCounter ++ ; if ( ch >= 0xD800 && ch < 0xDC00 ) { int ch2 = loadNextChar ( ) ; if ( ch2 >= 0xDC00 && ch2 < 0xE000 ) { ch = ( ( ch - 0xD800 ) << 10 ) + ( ch2 - 0xDC00 ) + 0x10000 ; loadNextChar ( ) ; } } else loadNextChar ( ) ; } return ch ; } public int scanCharRef ( boolean hex ) throws Exception { int ch = fMostRecentChar ; if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . scanCharRef ( hex ) ; } return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; } int num = 0 ; if ( hex ) { if ( ch > 'f' || XMLCharacterProperties . fgAsciiXDigitChar [ ch ] == 0 ) return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; num = ch - ( ch < 'A' ? '0' : ( ch < 'a' ? 'A' : 'a' ) - 10 ) ; } else { if ( ch < '0' || ch > '9' ) return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; num = ch - '0' ; } fCharacterCounter ++ ; loadNextChar ( ) ; boolean toobig = false ; while ( true ) { ch = fMostRecentChar ; if ( ch == 0 ) break ; if ( hex ) { if ( ch > 'f' || XMLCharacterProperties . fgAsciiXDigitChar [ ch ] == 0 ) break ; } else { if ( ch < '0' || ch > '9' ) break ; } fCharacterCounter ++ ; loadNextChar ( ) ; if ( hex ) { int dig = ch - ( ch < 'A' ? '0' : ( ch < 'a' ? 'A' : 'a' ) - 10 ) ; num = ( num << 4 ) + dig ; } else { int dig = ch - '0' ; num = ( num * 10 ) + dig ; } if ( num > 0x10FFFF ) { toobig = true ; num = 0 ; } } if ( ch != ';' ) return XMLEntityHandler . CHARREF_RESULT_SEMICOLON_REQUIRED ; fCharacterCounter ++ ; loadNextChar ( ) ; if ( toobig ) return XMLEntityHandler . CHARREF_RESULT_OUT_OF_RANGE ; return num ; } public int scanStringLiteral ( ) throws Exception { boolean single ; if ( ! ( single = lookingAtChar ( '\'' , true ) ) && ! lookingAtChar ( '\"' , true ) ) { return XMLEntityHandler . STRINGLIT_RESULT_QUOTE_REQUIRED ; } int offset = fCurrentOffset ; char qchar = single ? '\'' : '\"' ; while ( ! lookingAtChar ( qchar , false ) ) { if ( ! lookingAtValidChar ( true ) ) { return XMLEntityHandler . STRINGLIT_RESULT_INVALID_CHAR ; } } int stringIndex = addString ( offset , fCurrentOffset - offset ) ; lookingAtChar ( qchar , true ) ; return stringIndex ; } public int scanAttValue ( char qchar , boolean asSymbol ) throws Exception { int offset = fCurrentOffset ; while ( true ) { if ( lookingAtChar ( qchar , false ) ) { break ; } if ( lookingAtChar ( ' ' , true ) ) { continue ; } if ( lookingAtSpace ( false ) ) { return XMLEntityHandler . ATTVALUE_RESULT_COMPLEX ; } if ( lookingAtChar ( '&' , false ) ) { return XMLEntityHandler . ATTVALUE_RESULT_COMPLEX ; } if ( lookingAtChar ( '<' , false ) ) { return XMLEntityHandler . ATTVALUE_RESULT_LESSTHAN ; } if ( ! lookingAtValidChar ( true ) ) { return XMLEntityHandler . ATTVALUE_RESULT_INVALID_CHAR ; } } int result = asSymbol ? addSymbol ( offset , fCurrentOffset - offset ) : addString ( offset , fCurrentOffset - offset ) ; lookingAtChar ( qchar , true ) ; return result ; } public int scanEntityValue ( int qchar , boolean createString ) throws Exception { int offset = fCurrentOffset ; while ( true ) { if ( atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . ENTITYVALUE_RESULT_END_OF_INPUT ; } if ( qchar != - 1 && lookingAtChar ( ( char ) qchar , false ) ) { if ( ! createString ) return XMLEntityHandler . ENTITYVALUE_RESULT_FINISHED ; break ; } if ( lookingAtChar ( '&' , false ) ) { return XMLEntityHandler . ENTITYVALUE_RESULT_REFERENCE ; } if ( lookingAtChar ( '%' , false ) ) { return XMLEntityHandler . ENTITYVALUE_RESULT_PEREF ; } if ( ! lookingAtValidChar ( true ) ) { return XMLEntityHandler . ENTITYVALUE_RESULT_INVALID_CHAR ; } } int result = addString ( offset , fCurrentOffset - offset ) ; lookingAtChar ( ( char ) qchar , true ) ; return result ; } public int scanName ( char fastcheck ) throws Exception { int ch = fMostRecentChar ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 ) return - 1 ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) return - 1 ; } int offset = fCurrentOffset ; int index = fCurrentIndex ; char [ ] data = fMostRecentData ; if ( ++ index == CharDataChunk . CHUNK_SIZE ) { slowLoadNextChar ( ) ; index = 0 ; data = fMostRecentData ; } fCharacterCounter ++ ; fCurrentOffset ++ ; int hashcode = 0 ; while ( true ) { hashcode = StringHasher . hashChar ( hashcode , ch ) ; ch = data [ index ] & 0xFFFF ; if ( fastcheck == ch ) break ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) break ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) break ; } if ( ++ index == CharDataChunk . CHUNK_SIZE ) { slowLoadNextChar ( ) ; index = 0 ; data = fMostRecentData ; } fCharacterCounter ++ ; fCurrentOffset ++ ; } fCurrentIndex = index ; fMostRecentChar = ch ; hashcode = StringHasher . finishHash ( hashcode ) ; int length = fCurrentOffset - offset ; int nameIndex = fCurrentChunk . addSymbol ( offset , length , hashcode ) ; return nameIndex ; } public boolean scanExpectedName ( char fastcheck , StringPool . CharArrayRange expectedName ) throws Exception { char [ ] expected = expectedName . chars ; int offset = expectedName . offset ; int len = expectedName . length ; int ch = fMostRecentChar ; for ( int i = 0 ; i < len ; i ++ ) { if ( ch != expected [ offset ++ ] ) { skipPastNmtoken ( fastcheck ) ; return false ; } fCharacterCounter ++ ; fCurrentOffset ++ ; if ( ++ fCurrentIndex == CharDataChunk . CHUNK_SIZE ) ch = slowLoadNextChar ( ) ; else ch = ( fMostRecentChar = fMostRecentData [ fCurrentIndex ] & 0xFFFF ) ; } if ( ch == fastcheck ) return true ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) return true ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) return true ; } skipPastNmtoken ( fastcheck ) ; return false ; } public void scanQName ( char fastcheck , QName qname ) throws Exception { int ch = fMostRecentChar ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 ) { qname . clear ( ) ; return ; } if ( ch == ':' ) { qname . clear ( ) ; return ; } } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) { qname . clear ( ) ; return ; } } int offset = fCurrentOffset ; int index = fCurrentIndex ; char [ ] data = fMostRecentData ; if ( ++ index == CharDataChunk . CHUNK_SIZE ) { slowLoadNextChar ( ) ; index = 0 ; data = fMostRecentData ; } fCharacterCounter ++ ; fCurrentOffset ++ ; int hashcode = 0 ; int prefixend = - 1 ; while ( true ) { hashcode = StringHasher . hashChar ( hashcode , ch ) ; ch = data [ index ] & 0xFFFF ; if ( fastcheck == ch ) break ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) break ; if ( ch == ':' ) { if ( prefixend != - 1 ) break ; prefixend = fCurrentOffset ; if ( index + 1 == CharDataChunk . CHUNK_SIZE ) { CharDataChunk savedChunk = fCurrentChunk ; int savedOffset = fCurrentOffset ; ch = slowLoadNextChar ( ) ; fCurrentChunk = savedChunk ; fCurrentOffset = savedOffset ; fMostRecentData = savedChunk . toCharArray ( ) ; } else ch = data [ index + 1 ] & 0xFFFF ; boolean lpok = true ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 || ch == ':' ) lpok = false ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) lpok = false ; } ch = ':' ; if ( ! lpok ) { prefixend = - 1 ; break ; } } } else { if ( fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) break ; } if ( ++ index == CharDataChunk . CHUNK_SIZE ) { slowLoadNextChar ( ) ; index = 0 ; data = fMostRecentData ; } fCharacterCounter ++ ; fCurrentOffset ++ ; } fCurrentIndex = index ; fMostRecentChar = ch ; hashcode = StringHasher . finishHash ( hashcode ) ; int length = fCurrentOffset - offset ; qname . rawname = fCurrentChunk . addSymbol ( offset , length , hashcode ) ; qname . prefix = prefixend == - 1 ? - 1 : addSymbol ( offset , prefixend - offset ) ; qname . localpart = prefixend == - 1 ? qname . rawname : addSymbol ( prefixend + 1 , fCurrentOffset - ( prefixend + 1 ) ) ; qname . uri = - 1 ; } public int scanContent ( QName element ) throws Exception { if ( fCallClearPreviousChunk && fCurrentChunk . clearPreviousChunk ( ) ) fCallClearPreviousChunk = false ; int charDataOffset = fCurrentOffset ; int ch = fMostRecentChar ; if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiWSCharData [ ch ] ) { case 0 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 1 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ! fInCDSect ) { return recognizeMarkup ( ch ) ; } break ; case 2 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ! fInCDSect ) { return recognizeReference ( ch ) ; } break ; case 3 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch != ']' ) break ; if ( fCurrentIndex + 1 == CharDataChunk . CHUNK_SIZE ) { CharDataChunk dataChunk = fCurrentChunk ; int index = fCurrentIndex ; int offset = fCurrentOffset ; if ( loadNextChar ( ) != '>' ) { fCurrentChunk = dataChunk ; fCurrentIndex = index ; fCurrentOffset = offset ; fMostRecentData = dataChunk . toCharArray ( ) ; fMostRecentChar = ']' ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) break ; fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextChar ( ) ; fCharacterCounter += 2 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; case 5 : do { if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else fCharacterCounter ++ ; ch = loadNextChar ( ) ; } while ( ch == 0x20 || ch == 0x09 || ch == 0x0A ) ; if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiCharData [ ch ] ) { case 0 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 1 : if ( ! fInCDSect ) { callCharDataHandler ( charDataOffset , fCurrentOffset , true ) ; fCharacterCounter ++ ; ch = loadNextChar ( ) ; return recognizeMarkup ( ch ) ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 2 : if ( ! fInCDSect ) { callCharDataHandler ( charDataOffset , fCurrentOffset , true ) ; fCharacterCounter ++ ; ch = loadNextChar ( ) ; return recognizeReference ( ch ) ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 3 : int endOffset = fCurrentOffset ; ch = loadNextChar ( ) ; if ( ch != ']' ) { fCharacterCounter ++ ; break ; } if ( fCurrentIndex + 1 == CharDataChunk . CHUNK_SIZE ) { CharDataChunk dataChunk = fCurrentChunk ; int index = fCurrentIndex ; int offset = fCurrentOffset ; if ( loadNextChar ( ) != '>' ) { fCurrentChunk = dataChunk ; fCurrentIndex = index ; fCurrentOffset = offset ; fMostRecentData = dataChunk . toCharArray ( ) ; fMostRecentChar = ']' ; fCharacterCounter ++ ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) { fCharacterCounter ++ ; break ; } fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextChar ( ) ; callCharDataHandler ( charDataOffset , endOffset , true ) ; fCharacterCounter += 3 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : callCharDataHandler ( charDataOffset , fCurrentOffset , true ) ; if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else if ( ! skipMultiByteCharData ( ch ) ) { callCharDataHandler ( charDataOffset , fCurrentOffset , true ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } break ; } } else if ( ! skipMultiByteCharData ( ch ) ) { return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } ch = skipAsciiCharData ( ) ; while ( true ) { if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiCharData [ ch ] ) { case 0 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 1 : if ( ! fInCDSect ) { callCharDataHandler ( charDataOffset , fCurrentOffset , false ) ; fCharacterCounter ++ ; ch = loadNextChar ( ) ; return recognizeMarkup ( ch ) ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 2 : if ( ! fInCDSect ) { callCharDataHandler ( charDataOffset , fCurrentOffset , false ) ; fCharacterCounter ++ ; ch = loadNextChar ( ) ; return recognizeReference ( ch ) ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 3 : int endOffset = fCurrentOffset ; ch = loadNextChar ( ) ; if ( ch != ']' ) { fCharacterCounter ++ ; break ; } if ( fCurrentIndex + 1 == CharDataChunk . CHUNK_SIZE ) { CharDataChunk dataChunk = fCurrentChunk ; int index = fCurrentIndex ; int offset = fCurrentOffset ; if ( loadNextChar ( ) != '>' ) { fCurrentChunk = dataChunk ; fCurrentIndex = index ; fCurrentOffset = offset ; fMostRecentData = dataChunk . toCharArray ( ) ; fMostRecentChar = ']' ; fCharacterCounter ++ ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) { fCharacterCounter ++ ; break ; } fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextChar ( ) ; callCharDataHandler ( charDataOffset , endOffset , false ) ; fCharacterCounter += 3 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; ch = loadNextChar ( ) ; break ; } callCharDataHandler ( charDataOffset , fCurrentOffset , false ) ; if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else { if ( ! skipMultiByteCharData ( ch ) ) { callCharDataHandler ( charDataOffset , fCurrentOffset , false ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } ch = fMostRecentChar ; } } } private static final char [ ] cdata_string = { 'C' , 'D' , 'A' , 'T' , 'A' , '[' } ; private StringPool fStringPool = null ; private boolean fCalledCharPropInit = false ; private boolean fCallClearPreviousChunk = true ; private Vector fDeferredErrors = null ; private class DeferredError { int errorCode ; Object [ ] args ; int offset ; DeferredError ( int ec , Object [ ] a , int o ) { errorCode = ec ; args = a ; offset = o ; } } private int recognizeMarkup ( int ch ) throws Exception { switch ( ch ) { case 0 : return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; case '?' : fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_PI ; case '!' : fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch == 0 ) { fCharacterCounter -- ; fCurrentOffset -- ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( ch == '-' ) { fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch == 0 ) { fCharacterCounter -= 2 ; fCurrentOffset -= 2 ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( ch == '-' ) { fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_COMMENT ; } break ; } if ( ch == '[' ) { for ( int i = 0 ; i < 6 ; i ++ ) { fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch == 0 ) { fCharacterCounter -= ( 2 + i ) ; fCurrentOffset -= ( 2 + i ) ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( ch != cdata_string [ i ] ) { return XMLEntityHandler . CONTENT_RESULT_MARKUP_NOT_RECOGNIZED ; } } fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_CDSECT ; } break ; case '/' : fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_ETAG ; default : return XMLEntityHandler . CONTENT_RESULT_START_OF_ELEMENT ; } return XMLEntityHandler . CONTENT_RESULT_MARKUP_NOT_RECOGNIZED ; } private int recognizeReference ( int ch ) throws Exception { if ( ch == 0 ) { return XMLEntityHandler . CONTENT_RESULT_REFERENCE_END_OF_INPUT ; } if ( ch == '#' ) { fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_CHARREF ; } else { return XMLEntityHandler . CONTENT_RESULT_START_OF_ENTITYREF ; } } private boolean skipMultiByteCharData ( int ch ) throws Exception { if ( ch < 0xD800 ) { loadNextChar ( ) ; return true ; } if ( ch > 0xFFFD ) return false ; if ( ch >= 0xDC00 && ch < 0xE000 ) return false ; if ( ch >= 0xD800 && ch < 0xDC00 ) { CharDataChunk savedChunk = fCurrentChunk ; int savedIndex = fCurrentIndex ; int savedOffset = fCurrentOffset ; ch = loadNextChar ( ) ; if ( ch < 0xDC00 || ch >= 0xE000 ) { fCurrentChunk = savedChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = savedOffset ; fMostRecentData = savedChunk . toCharArray ( ) ; fMostRecentChar = fMostRecentData [ savedIndex ] & 0xFFFF ; return false ; } } loadNextChar ( ) ; return true ; } private int skipAsciiCharData ( ) throws Exception { int index = fCurrentIndex ; int offset = fCurrentOffset - index ; while ( true ) { char [ ] data = fMostRecentData ; while ( index < CharDataChunk . CHUNK_SIZE ) { int ch = data [ index ] & 0xFFFF ; if ( ch >= 0x80 ) { fCurrentOffset = offset + index ; fCurrentIndex = index ; fMostRecentChar = ch ; return ch ; } if ( XMLCharacterProperties . fgAsciiCharData [ ch ] == 0 ) { fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else { fCurrentOffset = offset + index ; fCurrentIndex = index ; fMostRecentChar = ch ; return ch ; } index ++ ; } offset += index ; slowLoadNextChar ( ) ; index = 0 ; } } private void callCharDataHandler ( int offset , int endOffset , boolean isWhitespace ) throws Exception { int length = endOffset - offset ; if ( ! fSendCharDataAsCharArray ) { int stringIndex = addString ( offset , length ) ; if ( isWhitespace ) fCharDataHandler . processWhitespace ( stringIndex ) ; else fCharDataHandler . processCharacters ( stringIndex ) ; return ; } CharDataChunk dataChunk = fCurrentChunk . chunkFor ( offset ) ; int index = offset & CharDataChunk . CHUNK_MASK ; if ( index + length <= CharDataChunk . CHUNK_SIZE ) { if ( length != 0 ) { if ( isWhitespace ) fCharDataHandler . processWhitespace ( dataChunk . toCharArray ( ) , index , length ) ; else fCharDataHandler . processCharacters ( dataChunk . toCharArray ( ) , index , length ) ; } return ; } int count = length ; int nbytes = CharDataChunk . CHUNK_SIZE - index ; if ( isWhitespace ) fCharDataHandler . processWhitespace ( dataChunk . toCharArray ( ) , index , nbytes ) ; else fCharDataHandler . processCharacters ( dataChunk . toCharArray ( ) , index , nbytes ) ; count -= nbytes ; do { dataChunk = dataChunk . nextChunk ( ) ; if ( dataChunk == null ) { throw new RuntimeException ( new ImplementationMessages ( ) . createMessage ( null , ImplementationMessages . INT_DCN , 0 , null ) ) ; } nbytes = count <= CharDataChunk . CHUNK_SIZE ? count : CharDataChunk . CHUNK_SIZE ; if ( isWhitespace ) fCharDataHandler . processWhitespace ( dataChunk . toCharArray ( ) , 0 , nbytes ) ; else fCharDataHandler . processCharacters ( dataChunk . toCharArray ( ) , 0 , nbytes ) ; count -= nbytes ; } while ( count > 0 ) ; } private int slowLoadNextChar ( ) throws Exception { fCallClearPreviousChunk = true ; if ( fCurrentChunk . nextChunk ( ) != null ) { fCurrentChunk = fCurrentChunk . nextChunk ( ) ; fCurrentIndex = 0 ; fMostRecentData = fCurrentChunk . toCharArray ( ) ; return ( fMostRecentChar = fMostRecentData [ fCurrentIndex ] & 0xFFFF ) ; } else { fCurrentChunk = CharDataChunk . createChunk ( fStringPool , fCurrentChunk ) ; return fillCurrentChunk ( ) ; } } private int loadNextChar ( ) throws Exception { fCurrentOffset ++ ; if ( ++ fCurrentIndex == CharDataChunk . CHUNK_SIZE ) return slowLoadNextChar ( ) ; return ( fMostRecentChar = fMostRecentData [ fCurrentIndex ] & 0xFFFF ) ; } private boolean atEOF ( int offset ) { return ( offset > fLength ) ; } } 	1	['33', '2', '2', '16', '70', '0', '3', '14', '20', '0.565625', '3041', '1', '2', '0.184210526', '0.174479167', '1', '3', '90.84848485', '2', '1.0606', '1']
